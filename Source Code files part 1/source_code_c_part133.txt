eOffset.QuadPart + outArb[OUT_ARB_COUNT-1].Length.QuadPart;
				inArb->Length.QuadPart = MAXLONGLONG - inArb->FileOffset.QuadPart;
				
			} else {
				break;
			}
#undef	OUT_ARB_COUNT
		}

		//
		// Check the file length.  If it is less than the size of the common store file, then
		// reduce sizeBackedByUnderlyingFile.
		//

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		status = SipQueryInformationFile(
					irpSp->FileObject,
					DeviceObject,
					FileStandardInformation,
					sizeof(FILE_STANDARD_INFORMATION),
					standardInfo,
					NULL);

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		if (!NT_SUCCESS(status)) {
			SipReleaseScb(scb);
			SipReleaseBackpointerResource(CSFile);
			SIS_MARK_POINT_ULONG(status);

			goto fail;
		}

		if (standardInfo->EndOfFile.QuadPart < scb->PerLink->CsFile->FileSize.QuadPart) {
			scb->SizeBackedByUnderlyingFile = standardInfo->EndOfFile.QuadPart;
			scb->Flags |= SIS_SCB_ANYTHING_IN_COPIED_FILE|SIS_SCB_BACKING_FILE_OPENED_DIRTY;
		} else if (standardInfo->EndOfFile.QuadPart != scb->PerLink->CsFile->FileSize.QuadPart) {
			scb->Flags |= SIS_SCB_ANYTHING_IN_COPIED_FILE|SIS_SCB_BACKING_FILE_OPENED_DIRTY;
		}

		scb->Flags |= SIS_SCB_RANGES_INITIALIZED;
	}


	//
	// Allocate a perFO for this file object.  We couldn't do this in
	// stage 1 because FsRtl insists that file objects that we claim
	// have FsContext filled in, which isn't the case until we get
	// here.
	//
	perFO = SipCreatePerFO(irpSp->FileObject,scb,DeviceObject);

	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	if (perFO == NULL) {
#if		DBG
		DbgPrint("SIS: SiCreate: unable to allocate per-FO\n");
#endif	// DBG

		SIS_MARK_POINT_ULONG(scb);

		SipReleaseScb(scb);
		SipReleaseBackpointerResource(CSFile);

		status = STATUS_INSUFFICIENT_RESOURCES;
		goto fail;
	}

	//
	// If this was a FILE_OPEN_REPARSE_POINT create, indicate that in the perFO.
	//
	if (context->openReparsePoint) {
		perFO->Flags |= SIS_PER_FO_OPEN_REPARSE;
	}

	//
	// If this is a delete-on-close create, set the appropriate flag in the
	// perFO.
	//
	if (irpSp->Parameters.Create.Options & FILE_DELETE_ON_CLOSE) {
		perFO->Flags |= SIS_PER_FO_DELETE_ON_CLOSE;
	}

	//
	// Indicate that we expect to see a cleanup for this file object.
	// The UnClose count is incremented in the per-FO allocator, because
	// we will see closes (but not cleanups) for stream file objects.
	//
	InterlockedIncrement(&perFO->fc->UncleanCount);
	perFO->Flags |= SIS_PER_FO_UNCLEANUP;

	SipReleaseScb(scb);
	SipReleaseBackpointerResource(CSFile);

	//
	// If this is a COMPLETE_ON_OPLOCKED create and it returned 
	// STATUS_OPLOCK_BREAK_IN_PROGRESS, launch an irp with a
	// FSCTL_OPLOCK_BREAK_NOTIFY on this file so that we can tell
	// when we can allow reads to go to the common store file through
	// this file object.
	//
	if (STATUS_OPLOCK_BREAK_IN_PROGRESS == context->Iosb->Status) {
		PIRP					fsctlIrp;
		PIO_STACK_LOCATION		fsctlIrpSp;

		SIS_MARK_POINT_ULONG(scb);

		//
		// Take a reference to the file object so that it won't go away until the irp
		// completes.
		//
		status = ObReferenceObjectByPointer(
					irpSp->FileObject,
					FILE_READ_DATA,
					*IoFileObjectType,
					KernelMode);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto fail;
		}

		//
		// Allocate and set  up an irp for an FSCTL_OPLOCK_BREAK_NOTIFY.
		//

		fsctlIrp = IoAllocateIrp( deviceExtension->AttachedToDeviceObject->StackSize, FALSE);
		if (NULL == fsctlIrp) {
			SIS_MARK_POINT_ULONG(scb);

			ObDereferenceObject(irpSp->FileObject);

			status = STATUS_INSUFFICIENT_RESOURCES;
			goto fail;
		}

	    fsctlIrp->Tail.Overlay.OriginalFileObject = irpSp->FileObject;
	    fsctlIrp->Tail.Overlay.Thread = PsGetCurrentThread();
	    fsctlIrp->RequestorMode = KernelMode;

	    //
	    // Fill in the service independent parameters in the IRP.
	    //

	    fsctlIrp->UserEvent = (PKEVENT) NULL;
    	fsctlIrp->UserIosb = NULL;
	    fsctlIrp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
    	fsctlIrp->Overlay.AsynchronousParameters.UserApcContext = NULL;

	    //
    	// Get a pointer to the stack location for the first driver.  This will be
	    // used to pass the original function codes and parameters.
    	//

	    fsctlIrpSp = IoGetNextIrpStackLocation( fsctlIrp );
    	fsctlIrpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
		fsctlIrpSp->MinorFunction = IRP_MN_USER_FS_REQUEST;
	    fsctlIrpSp->FileObject = irpSp->FileObject;

		fsctlIrpSp->Parameters.FileSystemControl.OutputBufferLength = 0;
		fsctlIrpSp->Parameters.FileSystemControl.InputBufferLength = 0;
		fsctlIrpSp->Parameters.FileSystemControl.FsControlCode = FSCTL_OPLOCK_BREAK_NOTIFY;
		fsctlIrpSp->Parameters.FileSystemControl.Type3InputBuffer = NULL;

		fsctlIrp->AssociatedIrp.SystemBuffer = NULL;
		fsctlIrp->Flags = 0;

		IoSetCompletionRoutine(
			fsctlIrp,
			SiOplockBreakNotifyCompletion,
			perFO,
			TRUE,
			TRUE,
			TRUE);

		//
		// Mark the perFO as waiting for an opbreak.
		//

		perFO->Flags |= SIS_PER_FO_OPBREAK;

		//
		// Launch the irp.  It's asynchronous and the completion routine will clean it up.
		//
		status = IoCallDriver(deviceExtension->AttachedToDeviceObject, fsctlIrp);

		SIS_MARK_POINT_ULONG(status);

#if		DBG
		if (BJBDebug & 0x2000) {
			DbgPrint("SIS: SiCreate: launched FSCTL_OPLOCK_BREAK_NOTIFY on irp %p, perFO %p, fo %p, status %x\n",
						fsctlIrp, perFO, perFO->fileObject, status);
		}
#endif	// DBG

	}

	//
	// Drop the reference to the SCB that was created by the lookup,
	// since it is now referenced by the perFO that we just allocated.
	//
	SipDereferenceScb(scb, RefsLookedUp);

	//
	// Make sure that we've looked up the fileId for this perLink.
	//
	ASSERT( SipAssureNtfsIdValid(perFO, perLink) );

	//
	// Now complete the original irp with the completion status that came back from the
	// actual open of the file (unless we have an oplock break in progress, in which
	// case we return that).
	//
	ASSERT(NT_SUCCESS(context->Iosb->Status));	// we peeled off the failure case a while back

	Irp->IoStatus = *context->Iosb;
	status = Irp->IoStatus.Status;

#if		DBG
	if (BJBDebug & 0x2) {
		PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

		DbgPrint("SIS: SiCreate %d: completing with status %x, scb %p, fileObject %p, %0.*ws\n",
                    __LINE__,
					Irp->IoStatus.Status,
					scb,
					irpSp->FileObject,
					irpSp->FileObject->FileName.Length / sizeof(WCHAR),irpSp->FileObject->FileName.Buffer);
	}
#endif	// DBG

	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	if (NULL != fileName->Buffer) {
		ExFreePool(fileName->Buffer);
		fileName->Buffer = NULL;
	}
	if (NULL != relatedFileObject) {
		ObDereferenceObject(relatedFileObject);
		relatedFileObject = NULL;
	}

	return status;

fail:

	SIS_MARK_POINT_ULONG(status);

	if (NULL != perFO) {
		SipDeallocatePerFO(perFO, DeviceObject);
	}

	if (NULL != scb) {
		SipDereferenceScb(scb, RefsLookedUp);
	}

	if (completedStage2) {
		SipUnopenFileObject(DeviceObject, Irp);
	}

	if (NULL != fileName->Buffer) {
		ExFreePool(fileName->Buffer);
		fileName->Buffer = NULL;
	}

	if (NULL != relatedFileObject) {
		ObDereferenceObject(relatedFileObject);
		relatedFileObject = NULL;
	}
	
	Irp->IoStatus.Status = status;
	Irp->IoStatus.Information = 0;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return status;

deleteReparsePoint:

	ASSERT(NT_SUCCESS(context->Iosb->Status));

	//
	// If this wasn't a FILE_OPEN_REPARSE_POINT create, then delete the bogus reparse point.
	// If it was, then we leave the reparse point but don't attach to the file or do anything else
	// with it.
	//

	if (!context->openReparsePoint) {

		//
		// For whatever reason, we've decided that this is a bogus SIS reparse point and
		// that it should be deleted.  Do so and then let the open complete successfully
		// for the file that used to be under the reparse point.
		//

#if		DBG
		if (STATUS_OBJECT_NAME_NOT_FOUND != status) {
			DbgPrint("SIS: SiCreate: deleting reparse point for f.o. 0x%x\n", irpSp->FileObject);
		}
#endif	// DBG

		ASSERT(NULL == perFO);

		if (NULL != scb) {
			SipDereferenceScb(scb, RefsLookedUp);
		}

		reparseBuffer->ReparseTag = IO_REPARSE_TAG_SIS;
		reparseBuffer->ReparseDataLength = 0;
		reparseBuffer->Reserved = 0xcabd;	// ???

		status = SipFsControlFile(
					irpSp->FileObject,
					DeviceObject,
					FSCTL_DELETE_REPARSE_POINT,
					reparseBuffer,
					FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer),
					NULL,										// output buffer
					0,											// output buffer length
					NULL);										// returned output buffer length

		SIS_MARK_POINT_ULONG(status);

#if		DBG
		if (!NT_SUCCESS(status)) {
			DbgPrint("SIS: SiCreate: unable to delete bogus reparse point for f.o. 0x%x, 0x%x\n",irpSp->FileObject,status);
		}
#endif	// DBG
	}

openUnderlyingFile:

	//
	// Regardless of whether we deleted the reparse point,
	// complete the create with whatever status came back when we opened
	// the reparse point.
	//

	ASSERT(completedStage2);

	Irp->IoStatus = *context->Iosb;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	if (NULL != fileName->Buffer) {
		ExFreePool(fileName->Buffer);
		fileName->Buffer = NULL;
	}
	if (NULL != relatedFileObject) {
		ObDereferenceObject(relatedFileObject);
		relatedFileObject = NULL;
	}

	return context->Iosb->Status;
	
}
#undef	reparseBuffer


NTSTATUS
SiCreateCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++
Routine Description:

    This function is the create/open completion routine for this filter
    file system driver.  If a file is a SIS link, it will stop the
	IRP completion and allow SiCreate to deal with the SIS
	link.  Otherwise, it will allow the irp to complete normally.

Arguments:

    DeviceObject - Pointer to the device on which the file was created.

    Irp - Pointer to the I/O Request Packet the represents the operation.

    Context - a PSIS_CREATE_COMPLETION_CONTEXT

Return Value:

    The function value is STATUS_SUCCESS or STATUS_MORE_PROCESSING_REQUIRED
	depending on whether the file was a SIS reparse point.

--*/

{
	PSIS_CREATE_COMPLETION_CONTEXT 	context = (PSIS_CREATE_COMPLETION_CONTEXT)Contxt;
	BOOLEAN 						completeFinished;
	BOOLEAN							validReparseStructure;
	PREPARSE_DATA_BUFFER 			reparseBuffer;

    UNREFERENCED_PARAMETER( DeviceObject );

	//
	// Clear the pending returned bit in the irp.  This is necessary because SiCreate
	// waits for us even if the lower level returned pending.
	//
	Irp->PendingReturned = FALSE;

	SIS_MARK_POINT_ULONG(Irp);

#if		DBG
	if (BJBDebug & 0x2) {
		PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

		DbgPrint("SIS: SiCreateCompletion %d: status: %x, fo %p, %0.*ws\n",
                    __LINE__,
					Irp->IoStatus.Status,
					irpSp->FileObject,
					irpSp->FileObject->FileName.Length / sizeof(WCHAR),irpSp->FileObject->FileName.Buffer);
	}
#endif	// DBG

	context->alternateStream = FALSE;

    if ((Irp->IoStatus.Status == STATUS_REPARSE )  &&
        (Irp->IoStatus.Information == IO_REPARSE_TAG_SIS)) {

		SIS_MARK_POINT_ULONG(context);

		//
		// It's a SIS reparse point.  Check to make sure that it's
		// a sensible request and a sensible reparse point.
		//

		reparseBuffer = (PREPARSE_DATA_BUFFER)Irp->Tail.Overlay.AuxiliaryBuffer;

		//
		// Verify that this is the terminal part of the pathname; ie., that someone
		// isn't trying to use a SIS reparse point as a directory name.  For reasons
		// that aren't entirely clear, NTFS returns the length of the remaining
		// pathname component in the Reserved field in the reparse buffer.  Check that
		// it's zero here, and fail if it's not.
		//
		if (reparseBuffer->Reserved != 0) {
			// 
			// This is a SIS link being used as the non-final portion of a pathname.
			// See if it is for a directory or for a named stream.  If it's a directory,
			// then someone has used a SIS link as a directory in an open request, which
			// is invalid and should be failed.  If it's a named stream, then we allow the
			// open to proceed to the underlying stream.
			//
			PIO_STACK_LOCATION	irpSp = IoGetCurrentIrpStackLocation(Irp);
			PUNICODE_STRING		fileName = &irpSp->FileObject->FileName;
			WCHAR				delimiter;

			SIS_MARK_POINT_ULONG(reparseBuffer->Reserved);

			//
			// The Reserved field in the reparse buffer is the length of the *unprocessed*
			// portion of the name.  Make sure that it's meaningful, and that it points at
			// either a colon or backslash.
			//
			ASSERT(reparseBuffer->Reserved <= fileName->Length);

			delimiter = fileName->Buffer[(fileName->Length - reparseBuffer->Reserved)/sizeof(WCHAR)];

#if		0
			//
			// There's a bug in NTFS where it fills in the reserved field with a number that's one
			// character too big (unless the file name started with a ':', in which case it gets
			// it right).  Compensate for that.
			//
			if (
#if		DBG
				(!(BJBDebug & 0x04000000)) && 
#endif	// DBG
				(delimiter != '\\' && (fileName->Length > reparseBuffer->Reserved))) {
				ASSERT(reparseBuffer->Reserved >= 4);
				reparseBuffer->Reserved -= sizeof(WCHAR);
				delimiter = fileName->Buffer[(fileName->Length - reparseBuffer->Reserved)/sizeof(WCHAR)];
			}
#endif	// 0

			ASSERT((':' == delimiter) || ('\\' == delimiter));

			if (':' == delimiter) {
				//
				// It's a stream name delimiter.  If it's the last character of the file name or it's followed
				// immediately by another ':', then it's the unnamed stream and we let it be.  Otherwise, we open
				// the alternate stream.
				//
				SIS_MARK_POINT();
				if ((reparseBuffer->Reserved == fileName->Length) ||
					(':' != fileName->Buffer[(fileName->Length - (reparseBuffer->Reserved - sizeof(WCHAR))) / sizeof(WCHAR)])) {

					context->alternateStream = TRUE;
					completeFinished = FALSE;

					goto finish;
				} else {
					//
					// It's the ::$DATA stream.  Fall through.
					//
					SIS_MARK_POINT();
				}
			} else {
				//
				// It's a directory.  Fail the request.
				//
				SIS_MARK_POINT();

				Irp->IoStatus.Status = STATUS_OBJECT_PATH_NOT_FOUND;
				Irp->IoStatus.Information = 0;

				completeFinished = TRUE;

				goto finish;
			}
		}

		validReparseStructure = SipIndicesFromReparseBuffer(
									reparseBuffer,
									&context->CSid,
									&context->LinkIndex,
                                    &context->CSFileNtfsId,
                                    &context->LinkFileNtfsId,
									NULL,						// CS file checksum, handled in stage 2
									NULL,
									NULL);

		ExFreePool(Irp->Tail.Overlay.AuxiliaryBuffer);
		Irp->Tail.Overlay.AuxiliaryBuffer = NULL;
#if	DBG
		reparseBuffer = NULL;	// Just for safety
#endif	// DBG

		if (!validReparseStructure) {
			SIS_MARK_POINT();

			//
			// It's a corrupt reparse buffer.  We'll set FILE_CORRUPT_ERROR here, and SiCreate will pick it up
			// and let the user open the underlying file without SIS.
			//
			Irp->IoStatus.Status = STATUS_FILE_CORRUPT_ERROR;
			
			completeFinished = FALSE;

			goto finish;
		}

		SIS_MARK_POINT_ULONG(context->LinkIndex.LowPart);

		completeFinished = FALSE;
	} else if ((Irp->IoStatus.Status == STATUS_REPARSE) && context->openReparsePoint && context->overwriteOrSupersede) {
		//
		// The user wanted to open the reparse point overwrise or supersede, and it's a non-SIS
		// reparse point.  We need to send the request back to SiCreate
		// and let it resubmit it with the open reparse flag reset.  First,
		// blow away the reparse buffer.
		//

		ASSERT(NULL != Irp->Tail.Overlay.AuxiliaryBuffer);

		ExFreePool(Irp->Tail.Overlay.AuxiliaryBuffer);
		Irp->Tail.Overlay.AuxiliaryBuffer = NULL;

		completeFinished = FALSE;
	} else if (NT_SUCCESS(Irp->IoStatus.Status) && 
				context->openReparsePoint && 
				(!context->overwriteOrSupersede) &&
				(STATUS_REPARSE != Irp->IoStatus.Status)) {
		//
		// It was an open reparse point request without supersede/overwrite specified.
		// We need to send the request back to SiCreate to see if the file is a SIS reparse
		// point.  We don't need to blow away the reparse buffer, because there isn't
		// one.
		//

		//
		// We allow STATUS_REPARSE returns when openReparsePoint and !overwriteOrSupersede
		// to fall through and complete.  These typically come because of mount points that
		// are used as an internal pathname component (OPEN_REPARSE only applies to the
		// final component).  If we eventually wind up at a SIS reparse point, we'll make another
		// trip through SiCreate and catch it then.
		//

		completeFinished = FALSE;
	} else {
		//
		// It's not a SIS reparse point, and so not our problem.  Allow the normal
		// completion to happen.
		//
		completeFinished = TRUE;
	}

finish:

	*context->Iosb = Irp->IoStatus;
	context->completeFinished = completeFinished;

	KeSetEvent(context->event, IO_NO_INCREMENT, FALSE);

	if (completeFinished) {
		SIS_MARK_POINT();
		return STATUS_SUCCESS;
	} else {
		SIS_MARK_POINT();
		return STATUS_MORE_PROCESSING_REQUIRED;
	}
}


NTSTATUS
SiCreateCompletionStage2(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

	A user did a create, which completed with a SIS reparse tag.  We caught
	it, added FILE_OPEN_REPARSE_POINT and sent it back down.  It's now 
	completed.  Bounce control back to SiCreate, cutting off the
	Irp completion processing here.

Arguments:

    DeviceObject - Pointer to the device on which the file was created.

    Irp - Pointer to the I/O Request Packet the represents the operation.

    Context - Points at a SIS_CREATE_COMPLETION_CONTEXT

Return Value:

    The function value is STATUS_MORE_PROCESSING_REQUIRED.

--*/

{
	PSIS_CREATE_COMPLETION_CONTEXT 	context = (PSIS_CREATE_COMPLETION_CONTEXT)Contxt;

    UNREFERENCED_PARAMETER( DeviceObject );
	SIS_MARK_POINT();

	//
	// Clear the pending returned bit in the irp.  This is necessary because SiCreate
	// waits for us even if the lower level returned pending.
	//
	Irp->PendingReturned = FALSE;

	*context->Iosb = Irp->IoStatus;
	KeSetEvent(context->event, IO_NO_INCREMENT, FALSE);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

BOOLEAN
SipWaitForFinalCopy(
	IN PSIS_PER_LINK	perLink,
	IN BOOLEAN			FinalCopyInProgress)
/*++

Routine Description:

	Wait for a file to be out of final copy processing.  If the file is being
	deleted, then we just pretend that final copy isn't requested, and return
	FALSE.
	

Arguments:

	perLink	-	The per-link for the file for which we want to wait

	FinalCopyInProgress - The value returned when we looked up the SCB.

Return Value:

	TRUE if the file has changed and needs to be reevaluated, FALSE if it's OK
	to use this per link.

--*/
{
	NTSTATUS 			status;
	KIRQL 				OldIrql;
	BOOLEAN 			finalCopyDone;
	BOOLEAN				fileDeleted;

	if (FinalCopyInProgress) {

		SIS_MARK_POINT_ULONG(perLink);
	
		status = KeWaitForSingleObject(perLink->Event, Executive, KernelMode, FALSE, NULL);
		ASSERT(status == STATUS_SUCCESS);
	
		KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
		if (perLink->Flags & SIS_PER_LINK_FINAL_COPY_DONE) {
			finalCopyDone = TRUE;
		} else {
			finalCopyDone = FALSE;
		}
		KeReleaseSpinLock(perLink->SpinLock, OldIrql);
	
		return finalCopyDone;
	} else {
		//
		// Handle the case where we got in between when the final copy done
		// bit was set and the last reference to the file dropped by cow.c.
		// If this happens, we'll see the final copy done bit set, but won't have
		// final copy in progress set and won't get a wakeup.  
		// In this case, just drop our reference and retry.  This shouldn't 
		// produce a livelock because the reparse point should be gone and the 
		// next trip through create should follow the standard, non-SIS path.
		//
	
		KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
		finalCopyDone = (perLink->Flags & SIS_PER_LINK_FINAL_COPY_DONE) ? TRUE : FALSE;
		fileDeleted = (perLink->Flags & (SIS_PER_LINK_FILE_DELETED|SIS_PER_LINK_FINAL_DELETE_IN_PROGRESS)) ? TRUE : FALSE;
		KeReleaseSpinLock(perLink->SpinLock, OldIrql);

		//
		// The file is going or gone, so there's no need to wait for any final copy processing.
		//
		if (fileDeleted) {
			SIS_MARK_POINT_ULONG(perLink);

			return FALSE;
		}
	
		if (finalCopyDone) {
			SIS_MARK_POINT_ULONG(perLink);
	
			return TRUE;
		}
	}

	return FALSE;
}

NTSTATUS
SipAssureCSFileOpen(
	IN PSIS_CS_FILE		CSFile)
/*++

Routine Description:

	Make sure that the actual file corresponding to the given CSFile
	object (along with its backpointer stream) is actually open.  If it
	isn't, post a worker thread request to do it, and wait for it to
	complete.

Arguments:

	CSFile - the common store file object

Return Value:

	status of the open; STATUS_SUCCESS if it was already open.

--*/
{
	NTSTATUS			status;

	KeEnterCriticalRegion();		// We must disable APCs while holding a mutant in a user thread
	status = SipAcquireUFO(CSFile/*,TRUE*/);

//	SIS_MARK_POINT_ULONG(CSFile);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		KeLeaveCriticalRegion();
		return status;
	}

    if (CSFile->Flags & CSFILE_FLAG_CORRUPT) {

		//
		// The CS file backpointer stream is corrupt, which means that we're
		// doing a volume check, and this file is unavailable until the volume
		// check completes.  Indicate a retry.
		//

        status = STATUS_RETRY;

    } else if ((NULL == CSFile->UnderlyingFileObject) || 
			   (NULL == CSFile->UnderlyingFileHandle) ||
			   (NULL == CSFile->BackpointerStreamFileObject) ||
			   (NULL == CSFile->BackpointerStreamHandle)) {

		SI_OPEN_CS_FILE openRequest[1];
		//
		// No one has opened this CS file yet, so we need
		// to do it.  Queue up a work item to do it on
		// a worker thread.
		//

		SIS_MARK_POINT_ULONG(CSFile);

		openRequest->CSFile = CSFile;
        openRequest->openByName = FALSE;

		KeInitializeEvent(
			openRequest->event,
			NotificationEvent,
			FALSE);

		ExInitializeWorkItem(
			openRequest->workQueueItem,
			SipOpenCSFile,
			openRequest);

		ExQueueWorkItem(
			openRequest->workQueueItem,
			CriticalWorkQueue);

		status = KeWaitForSingleObject(
					openRequest->event,
					Executive,
					KernelMode,
					FALSE,
					NULL);

		//
		// If this fails, we're hosed because the worker thread might touch the openRequest,
		// which is on our stack.
		//
		ASSERT(status == STATUS_SUCCESS);

		status = openRequest->openStatus;

		if ((STATUS_FILE_INVALID == status) || (CSFile->Flags & CSFILE_FLAG_CORRUPT)) {
			//
			// We're doing a volume check, so tell the user to retry later when the check
			// has gotten far enough.
			//
			status = STATUS_RETRY;
		}

	} else {
		//
		// The underlying file was already open, so we just succeed.
		//
		status = STATUS_SUCCESS;
	}
	SipReleaseUFO(CSFile);
	KeLeaveCriticalRegion();

	return status;
}


NTSTATUS
SiOtherCreates (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles "other" create operations.  It simply passes the
    operation on to the base file system.  These operations to the control
    device object are failed.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the status of the call to the file system's entry
    point.

--*/

{
    PAGED_CODE();

    //
    //  If this is for our control device object, don't allow it to be opened.
    //

    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) {

        //
        //  Sfilter doesn't allow for any communication through its control
        //  device object, therefore it fails all requests to open a handle
        //  to its control device object.
        //
        //  See the FileSpy sample for an example of how to allow creates to 
        //  the filter's control device object and manage communication via
        //  that handle.
        //

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Just pass the operation on, we don't want to see the completion
    //

    IoSkipCurrentIrpStackLocation( Irp );

    return IoCallDriver( ((PDEVICE_EXTENSION)DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\sisuprt.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    sisuprt.c

Abstract:

    General support routines for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

#if     DBG
//
// Counts of how many of these things are active in the system.
//
ULONG           outstandingCSFiles = 0;
ULONG           outstandingPerLinks = 0;
ULONG           outstandingSCBs = 0;
ULONG           outstandingPerFOs = 0;
ULONG           totalScbReferences = 0;
ULONG           totalScbReferencesByType[NumScbReferenceTypes];

//
// Setting this forces an assert the next time we go through SipIsFileObjectSIS.
//
ULONG BJBAssertNow = 0;
#endif  // DBG

#if     TIMING
ULONG   BJBDumpTimingNow = 0;
ULONG   BJBClearTimingNow = 0;
#endif  // TIMING

#if     COUNTING_MALLOC
ULONG   BJBDumpCountingMallocNow = 0;
#endif  // COUNTING_MALLOC

#if     DBG
VOID
SipVerifyTypedScbRefcounts(
    IN PSIS_SCB                 scb)
/*++

Routine Description:

    Check to see that the total of all of the different typed refcounts
    in the scb is the same as the scb's overall reference count.

    The caller must hold the ScbSpinLock for the volume.

Arguments:

    scb - the scb to check

Return Value:

    VOID

--*/
{
    ULONG               totalReferencesByType = 0;
    SCB_REFERENCE_TYPE  referenceTypeIndex;

    //
    // Verify that the typed ref counts match the total ref count.
    //
    for (   referenceTypeIndex = RefsLookedUp;
            referenceTypeIndex < NumScbReferenceTypes;
            referenceTypeIndex++) {

            ASSERT(scb->referencesByType[referenceTypeIndex] <= scb->RefCount); // essentially checking for negative indices

            totalReferencesByType += scb->referencesByType[referenceTypeIndex];
    }

    ASSERT(totalReferencesByType == scb->RefCount);
}
#endif  // DBG

PSIS_SCB
SipLookupScb(
    IN PLINK_INDEX                      PerLinkIndex,
    IN PCSID                            CSid,
    IN PLARGE_INTEGER                   LinkFileNtfsId,
    IN PLARGE_INTEGER                   CSFileNtfsId,
    IN PUNICODE_STRING                  StreamName,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PETHREAD                         RequestingThread,
    OUT PBOOLEAN                        FinalCopyInProgress,
    OUT PBOOLEAN                        LinkIndexCollision)
/*++

Routine Description:

    Find an SCB based on the per link index, cs index, stream name
    and volume (represented by the device object).  If an SCB already
    exists for the desired stream then we return it, otherwise we create
    and initialize it.  In any case, the caller gets a reference to it
    which must eventually be destroyed by calling SipDereferenceScb.

    We set the "final copy" boolean according as the file is in a final
    copy state at the time that the lookup is performed.

    This routine must be called at PASSIVE_LEVEL (ie., APCs can't be
    masked).

Arguments:

    PerLinkIndex        - The index of the link for this scb

    CSid                - The id of the common store file for this scb

    LinkFileNtfsId      - The link file's id

    CSFileNtfsId        - The common store file's id

    StreamName          - The name of the particular stream we're using

    DeviceObject        - The D.O. for the volume on which this stream lives

    RequestingThread    - The thread that launched the irp that's causing us to
                            do this lookup.  If this is the COWing thread,
                            we won't set FinalCopyInProgress

    FinalCopyInProgress - Returns TRUE iff there is a final copy in progress
                            on this file.

Return Value:

    A pointer to the SCB, or NULL if one couldn't be found or allocated
    (most likely because of out of memory).

--*/
{
    PSIS_SCB                scb;
    KIRQL                   OldIrql;
    PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;
    PSIS_TREE               scbTree = deviceExtension->ScbTree;
    SCB_KEY                 scbKey[1];

    UNREFERENCED_PARAMETER( StreamName );
    UNREFERENCED_PARAMETER( LinkIndexCollision );
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Initialize the search key with the link index.
    //
    scbKey->Index = *PerLinkIndex;

    //
    // Lock out other table modifications/queries.
    //
    KeAcquireSpinLock(deviceExtension->ScbSpinLock, &OldIrql);

    //
    // Search for an existing scb.
    //
    scb = SipLookupElementTree(scbTree, scbKey);

    if (!scb) {
        //
        // There is no scb matching this index & name.  Make one.
        //

        scb = ExAllocatePoolWithTag( NonPagedPool, sizeof (SIS_SCB), 'SsiS');
        if (!scb) {
            SIS_MARK_POINT();
            KeReleaseSpinLock(deviceExtension->ScbSpinLock, OldIrql);
            return NULL;
        }

#if     DBG
        InterlockedIncrement(&outstandingSCBs);
#endif  // DBG

        RtlZeroMemory(scb,sizeof(SIS_SCB));

        SIS_MARK_POINT_ULONG(scb);

        scb->PerLink = SipLookupPerLink(
                           PerLinkIndex,
                           CSid,
                           LinkFileNtfsId,
                           CSFileNtfsId,
                           DeviceObject,
                           RequestingThread,
                           FinalCopyInProgress);

        if (!scb->PerLink) {
            goto releaseAndPunt;
        }

        ASSERT(scb->PerLink->Index.QuadPart == PerLinkIndex->QuadPart);

        scb->RefCount = 1;

#if     DBG
        scb->referencesByType[RefsLookedUp] = 1;
        SipVerifyTypedScbRefcounts(scb);

        InterlockedIncrement(&totalScbReferences);
        InterlockedIncrement(&totalScbReferencesByType[RefsLookedUp]);
#endif  // DBG

        ExInitializeFastMutex(scb->FastMutex);

        //
        // Add it to the tail of the scb list.
        //
        InsertTailList(&deviceExtension->ScbList, &scb->ScbList);

#if DBG
        {
        PSIS_SCB scbNew =
#endif

        SipInsertElementTree(scbTree, scb, scbKey);

#if DBG
        ASSERT(scbNew == scb);
        }
#endif

    } else {
        //
        // An scb matching this index & name was found.
        //

        scb->RefCount++;

        SIS_MARK_POINT_ULONG(scb);

#if     DBG
        //
        // Increment the appropriate refs-by-type count, and then assert that the total
        // refs-by-type is the same as the overall reference count.
        //
        scb->referencesByType[RefsLookedUp]++;
        SipVerifyTypedScbRefcounts(scb);

        InterlockedIncrement(&totalScbReferences);
        InterlockedIncrement(&totalScbReferencesByType[RefsLookedUp]);
#endif  // DBG


        //
        // Handle final-copy-in-progress processing.
        //

        SIS_MARK_POINT_ULONG(scb->PerLink->COWingThread);
        SIS_MARK_POINT_ULONG(RequestingThread);

        if (RequestingThread != scb->PerLink->COWingThread || NULL == RequestingThread) {
            KeAcquireSpinLockAtDpcLevel(scb->PerLink->SpinLock);
            if (scb->PerLink->Flags & SIS_PER_LINK_FINAL_COPY) {

                *FinalCopyInProgress = TRUE;
                if (!(scb->PerLink->Flags & SIS_PER_LINK_FINAL_COPY_WAITERS)) {
                    //
                    // We're the first waiter.  Set the bit and clear the event.
                    //
                    SIS_MARK_POINT_ULONG(scb);

                    scb->PerLink->Flags |= SIS_PER_LINK_FINAL_COPY_WAITERS;
                    KeClearEvent(scb->PerLink->Event);
                } else {
                    SIS_MARK_POINT_ULONG(scb);
                }
            } else {
                *FinalCopyInProgress = FALSE;
            }
            KeReleaseSpinLockFromDpcLevel(scb->PerLink->SpinLock);
        }
    }

    KeReleaseSpinLock(deviceExtension->ScbSpinLock, OldIrql);

    //
    // We need to assure that the SCB is properly initialized.  Acquire the SCB
    // and check the initialized bit.
    //
    SipAcquireScb(scb);

    if (scb->Flags & SIS_SCB_INITIALIZED) {
        SIS_MARK_POINT();
        SipReleaseScb(scb);
        return scb;
    }

    //
    // Now handle the part of the initialization that can't happen at
    // DISPATCH_LEVEL.
    //

    //  Initialize the scb's file lock record
    FsRtlInitializeFileLock( &scb->FileLock, SiCompleteLockIrpRoutine, NULL );

    //
    // Initialize the Ranges large mcb.  We probably should postpone
    // doing this until we do copy-on-write or take a fault on
    // the file, but for now we'll just do it off the bat.
    //
    FsRtlInitializeLargeMcb(scb->Ranges,NonPagedPool);
    scb->Flags |= SIS_SCB_MCB_INITIALIZED|SIS_SCB_INITIALIZED;

    //
    // Don't bother to initialize the FileId field
    // until copy-on-write time.
    //

    SipReleaseScb(scb);

//  SIS_MARK_POINT_ULONG(scb);

    return scb;

releaseAndPunt:

    // We can only come here before the scb has been inserted into the tree.

    KeReleaseSpinLock(deviceExtension->ScbSpinLock, OldIrql);

    if (scb->PerLink) {
        SipDereferencePerLink(scb->PerLink);
    }

#if     DBG
    InterlockedDecrement(&outstandingSCBs);
#endif  // DBG

    ExFreePool(scb);

    return NULL;
}

VOID
SipReferenceScb(
    IN PSIS_SCB                         scb,
    IN SCB_REFERENCE_TYPE               referenceType)
{
    PDEVICE_EXTENSION       deviceExtension = (PDEVICE_EXTENSION)scb->PerLink->CsFile->DeviceObject->DeviceExtension;
    KIRQL                   OldIrql;
#if DBG
    ULONG               totalReferencesByType = 0;
#endif  // DBG

    UNREFERENCED_PARAMETER( referenceType );

    KeAcquireSpinLock(deviceExtension->ScbSpinLock, &OldIrql);

    ASSERT(scb->RefCount > 0);

    scb->RefCount++;

#if     DBG
    //
    // Update the typed ref counts
    //
    scb->referencesByType[referenceType]++;

    SipVerifyTypedScbRefcounts(scb);

    InterlockedIncrement(&totalScbReferencesByType[referenceType]);
    InterlockedIncrement(&totalScbReferences);
#endif  // DBG

    KeReleaseSpinLock(deviceExtension->ScbSpinLock, OldIrql);
}

typedef struct _SI_DEREFERENCE_SCB_REQUEST {
    WORK_QUEUE_ITEM         workItem[1];
    PSIS_SCB                scb;
    SCB_REFERENCE_TYPE      referenceType;
} SI_DEREFERENCE_SCB_REQUEST, *PSI_DEREFERENCE_SCB_REQUEST;

VOID
SiPostedDereferenceScb(
    IN PVOID                            parameter)
/*++

Routine Description:

    Someone tried to remove the final reference from an SCB at elevated IRQL.  Since
    that's not directly possible, the request has been posted.  We're on a worker thread
    at PASSIVE_LEVEL now, so we can drop the reference.

Arguments:

    parameter - a PVOID PSI_DEREFERENCE_SCB_REQUEST.


Return Value:

    void

--*/
{
    PSI_DEREFERENCE_SCB_REQUEST request = parameter;

    ASSERT(PASSIVE_LEVEL == KeGetCurrentIrql());

    SipDereferenceScb(request->scb,request->referenceType);

    ExFreePool(request);
}

VOID
SipDereferenceScb(
    IN PSIS_SCB                         scb,
    IN SCB_REFERENCE_TYPE               referenceType)
/*++

Routine Description:

    Drop a reference to an SCB.  If appropriate, clean up the SCB, etc.

    This function must be called at IRQL <= DISPATCH_LEVEL.

Arguments:

    scb - the scb to which we want to drop our reference

    referenceType   - the type of the reference we're dropping; only used in DBG code.

Return Value:

    void

--*/
{

    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION)scb->PerLink->CsFile->DeviceObject->DeviceExtension;
    KIRQL               InitialIrql;
#if DBG
    ULONG               totalReferencesByType = 0;
#endif  // DBG

    KeAcquireSpinLock(deviceExtension->ScbSpinLock, &InitialIrql);

    ASSERT(InitialIrql <= DISPATCH_LEVEL);

    ASSERT(scb->RefCount != 0);

	if ((1 == scb->RefCount) && ((DISPATCH_LEVEL == InitialIrql) || (IoGetRemainingStackSize() < 4096))) {
		PSI_DEREFERENCE_SCB_REQUEST	request;

        KeReleaseSpinLock(deviceExtension->ScbSpinLock, InitialIrql);

        SIS_MARK_POINT_ULONG(scb);

        //
        // We're at elevated IRQL and this is the last reference.  Post the dereference of the scb.
        //
        request = ExAllocatePoolWithTag(NonPagedPool, sizeof(SI_DEREFERENCE_SCB_REQUEST), ' siS');
        if (NULL == request) {

            //
            // We're basically hosed here.  Just dribble the scb reference.
            // This is way bad, partly because we're leaking nonpaged memory
            // while we're out of memory, and partly because we'll never remove
            // the last scb reference and so possibly never do final copy.
            // BUGBUGBUG : This must be fixed.
            //
            SIS_MARK_POINT();
#if     DBG
            DbgPrint("SIS: SipDereferenceScb: couldn't allocate an SI_DEREFERENCE_SCB_REQUEST.  Dribbling SCB 0x%x\n",scb);
#endif  // DBG
            return;
        }

        request->scb = scb;
        request->referenceType = referenceType;

        ExInitializeWorkItem(request->workItem, SiPostedDereferenceScb, request);
        ExQueueWorkItem(request->workItem, CriticalWorkQueue);

        return;
    }

    scb->RefCount--;

#if     DBG
    //
    // Update the typed ref counts
    //
    ASSERT(scb->referencesByType[referenceType] != 0);
    scb->referencesByType[referenceType]--;
    SipVerifyTypedScbRefcounts(scb);

    InterlockedDecrement(&totalScbReferencesByType[referenceType]);
    InterlockedDecrement(&totalScbReferences);
#endif  // DBG

    if (scb->RefCount == 0) {
        //PDEVICE_EXTENSION   deviceExtension = scb->PerLink->CsFile->DeviceObject->DeviceExtension;
        KIRQL               NewIrql;
        PSIS_TREE           scbTree = deviceExtension->ScbTree;

        SIS_MARK_POINT_ULONG(scb);

        //
        // Before freeing this SCB, we need to see if we have to do a final copy on it.
        // Really, this should happen based on the perLink not the SCB, but for now...
        //
        KeAcquireSpinLock(scb->PerLink->SpinLock, &NewIrql);

        ASSERT((scb->PerLink->Flags & SIS_PER_LINK_FINAL_COPY) == 0);

        if ((scb->PerLink->Flags & (SIS_PER_LINK_DIRTY|SIS_PER_LINK_FINAL_COPY_DONE)) == SIS_PER_LINK_DIRTY) {

            scb->PerLink->Flags |= SIS_PER_LINK_FINAL_COPY;

            KeReleaseSpinLock(scb->PerLink->SpinLock, NewIrql);

            //
            // Restore a reference, which we're handing to SipCompleteCopy
            //
            scb->RefCount = 1;

#if     DBG
            scb->referencesByType[RefsFinalCopy] = 1;

            InterlockedIncrement(&totalScbReferences);
            InterlockedIncrement(&totalScbReferencesByType[RefsFinalCopy]);
#endif  // DBG

            KeReleaseSpinLock(deviceExtension->ScbSpinLock, InitialIrql);

            //
            // Now send the SCB off to complete copy.  Because of the flag we
            // just set in the per link, no one will be able to open this file
            // until the copy completes.
            //

            SIS_MARK_POINT_ULONG(scb);

            SipCompleteCopy(scb,FALSE);

            return;
        }

        //
        // The final copy is finished or isn't needed.  Either way, we can
        // proceed with releasing the scb.
        //
        KeReleaseSpinLock(scb->PerLink->SpinLock, NewIrql);

        //
        // Pull the SCB out of the tree.
        //
#if DBG // Make sure it's in the tree before we remove it.
        {
        SCB_KEY scbKey[1];
        scbKey->Index = scb->PerLink->Index;

        ASSERT(scb == SipLookupElementTree(scbTree, scbKey));
        }
#endif
        SipDeleteElementTree(scbTree, scb);

        //
        // Remove the scb from the scb list.
        //
        RemoveEntryList(&scb->ScbList);

        // Now no one can reference the structure but us, so we can drop the lock

        KeReleaseSpinLock(deviceExtension->ScbSpinLock, InitialIrql);

        //
        //  Uninitialize the byte range file locks and opportunistic locks
        //
        FsRtlUninitializeFileLock(&scb->FileLock);

        if (scb->Flags & SIS_SCB_MCB_INITIALIZED) {
            FsRtlUninitializeLargeMcb(scb->Ranges);
            scb->Flags &= ~SIS_SCB_MCB_INITIALIZED;
        }

        SipDereferencePerLink(scb->PerLink);

        //
        // If there is a predecessor scb, we need to drop our reference to it.
        //
        if (scb->PredecessorScb) {
            SipDereferenceScb(scb->PredecessorScb, RefsPredecessorScb);
        }

        SIS_MARK_POINT_ULONG(scb);

#if     DBG
        InterlockedDecrement(&outstandingSCBs);
#endif  // DBG

        ExFreePool(scb);
    } else {
        KeReleaseSpinLock(deviceExtension->ScbSpinLock, InitialIrql);
    }
//  SIS_MARK_POINT_ULONG(scb);
}

#if		DBG
VOID
SipTransferScbReferenceType(
	IN PSIS_SCB							scb,
	IN SCB_REFERENCE_TYPE				oldReferenceType,
	IN SCB_REFERENCE_TYPE				newReferenceType)
/*++

Routine Description:

	Transfer a reference to a scb from one type to another.
	This is only defined in the checked build, because we don't
	track reference types in free builds (they're only for debugging,
	all we need for proper execution is the reference count, which
	isn't changed by this call).  In the free build this is a macro
	that expands to nothing.

Arguments:

	scb - the scb for which we want to transfer our reference

	oldReferenceType	- the type of the reference we're dropping
	newReferenceType	- the type of the reference we're adding

Return Value:

	void

--*/
{
	PDEVICE_EXTENSION		deviceExtension = (PDEVICE_EXTENSION)scb->PerLink->CsFile->DeviceObject->DeviceExtension;
	KIRQL					OldIrql;

	KeAcquireSpinLock(deviceExtension->ScbSpinLock, &OldIrql);

	ASSERT(scb->RefCount > 0);
	ASSERT(0 < scb->referencesByType[oldReferenceType]);
	scb->referencesByType[oldReferenceType]--;
	scb->referencesByType[newReferenceType]++;

	SipVerifyTypedScbRefcounts(scb);

	InterlockedDecrement(&totalScbReferencesByType[oldReferenceType]);
	InterlockedIncrement(&totalScbReferencesByType[newReferenceType]);

	KeReleaseSpinLock(deviceExtension->ScbSpinLock, OldIrql);
}
#endif	// DBG

LONG
SipScbTreeCompare (
    IN PVOID                            Key,
    IN PVOID                            Node)
{
    PSCB_KEY scbKey = (PSCB_KEY) Key;
    PSIS_SCB scb = (PSIS_SCB) Node;
    LONGLONG r;

    r = scbKey->Index.QuadPart - scb->PerLink->Index.QuadPart;

    if (r > 0)
        return 1;
    else if (r < 0)
        return -1;
    else
        return 0;
}

PSIS_PER_LINK
SipLookupPerLink(
    IN PLINK_INDEX                  PerLinkIndex,
    IN PCSID                        CSid,
    IN PLARGE_INTEGER               LinkFileNtfsId,
    IN PLARGE_INTEGER               CSFileNtfsId,
    IN PDEVICE_OBJECT               DeviceObject,
    IN PETHREAD                     RequestingThread OPTIONAL,
    OUT PBOOLEAN                    FinalCopyInProgress)
{
    PSIS_PER_LINK       perLink;
    KIRQL               OldIrql;
    PDEVICE_EXTENSION   DeviceExtension = DeviceObject->DeviceExtension;
    PSIS_TREE           perLinkTree = DeviceExtension->PerLinkTree;
    PER_LINK_KEY        perLinkKey[1];

    perLinkKey->Index = *PerLinkIndex;

    KeAcquireSpinLock(DeviceExtension->PerLinkSpinLock, &OldIrql);

    SIS_MARK_POINT_ULONG(PerLinkIndex->HighPart);
    SIS_MARK_POINT_ULONG(PerLinkIndex->LowPart);

    perLink = SipLookupElementTree(perLinkTree, perLinkKey);

    if (perLink) {
        SIS_MARK_POINT_ULONG(perLink);
        SIS_MARK_POINT_ULONG(perLink->CsFile);

        perLink->RefCount++;

        if (perLink->COWingThread != RequestingThread || NULL == RequestingThread) {
            //
            // Handle setting "FinalCopyInProgress."  If there's a final copy outstanding
            // now, clear the final copy wakeup event, and if necessary set the bit
            // requesting a final copy wakeup, and set the boolean.
            // Otherwise, clear the boolean.
            //

            KeAcquireSpinLockAtDpcLevel(perLink->SpinLock);

            if (perLink->Flags & SIS_PER_LINK_FINAL_COPY) {

                *FinalCopyInProgress = TRUE;
                if (!(perLink->Flags & SIS_PER_LINK_FINAL_COPY_WAITERS)) {
                    perLink->Flags |= SIS_PER_LINK_FINAL_COPY_WAITERS;
                    KeClearEvent(perLink->Event);
                }
            } else {
                *FinalCopyInProgress = FALSE;
            }

            KeReleaseSpinLockFromDpcLevel(perLink->SpinLock);
        }

        KeReleaseSpinLock(DeviceExtension->PerLinkSpinLock, OldIrql);
        return(perLink);
    }

    perLink = ExAllocatePoolWithTag( NonPagedPool, sizeof(SIS_PER_LINK), 'LsiS');

    if (!perLink) {
        goto insufficient;
    }

#if     DBG
    InterlockedIncrement(&outstandingPerLinks);
#endif  // DBG

    RtlZeroMemory(perLink,sizeof(SIS_PER_LINK));
    KeInitializeSpinLock(perLink->SpinLock);

    perLink->CsFile = SipLookupCSFile(
                        CSid,
                        CSFileNtfsId,
                        DeviceObject);
    if (!perLink->CsFile) {
        KeReleaseSpinLock(DeviceExtension->PerLinkSpinLock, OldIrql);

#if     DBG
        InterlockedDecrement(&outstandingPerLinks);
#endif  // DBG

        ExFreePool(perLink);
        return NULL;
    }

    SIS_MARK_POINT_ULONG(perLink);
    SIS_MARK_POINT_ULONG(perLink->CsFile);

    perLink->RefCount = 1;
    perLink->Index = *PerLinkIndex;
    perLink->LinkFileNtfsId = *LinkFileNtfsId;

    //
    // Now add it to the tree.
    //

#if DBG
    {
    PSIS_PER_LINK perLinkNew =
#endif

    SipInsertElementTree(perLinkTree, perLink, perLinkKey);

#if DBG
    ASSERT(perLinkNew == perLink);
    }
#endif

    KeInitializeEvent(perLink->Event,NotificationEvent,FALSE);
    KeInitializeEvent(perLink->DeleteEvent,NotificationEvent,FALSE);

    KeReleaseSpinLock(DeviceExtension->PerLinkSpinLock, OldIrql);

    //
    // Since we're the first reference to this per link, there can't
    // be a final copy in progress.  Indicate so.
    //
    *FinalCopyInProgress = FALSE;

    return perLink;

insufficient:
    KeReleaseSpinLock(DeviceExtension->PerLinkSpinLock, OldIrql);

    if (!perLink) return NULL;

#if     DBG
    InterlockedDecrement(&outstandingPerLinks);
#endif  // DBG

    ExFreePool(perLink);

    return NULL;
}

VOID
SipReferencePerLink(
    IN PSIS_PER_LINK                    perLink)
{
    PDEVICE_EXTENSION           deviceExtension = perLink->CsFile->DeviceObject->DeviceExtension;
    KIRQL                       OldIrql;

    KeAcquireSpinLock(deviceExtension->PerLinkSpinLock, &OldIrql);

    //
    // The caller must already have a reference.  Assert that.
    //
    ASSERT(perLink->RefCount > 0);

    perLink->RefCount++;
    KeReleaseSpinLock(deviceExtension->PerLinkSpinLock, OldIrql);
}

VOID
SipDereferencePerLink(
    IN PSIS_PER_LINK                    PerLink)
{
    PDEVICE_EXTENSION           deviceExtension = PerLink->CsFile->DeviceObject->DeviceExtension;
    KIRQL                       OldIrql;

    KeAcquireSpinLock(deviceExtension->PerLinkSpinLock, &OldIrql);
    ASSERT(OldIrql < DISPATCH_LEVEL);

    ASSERT(PerLink->RefCount != 0);

    PerLink->RefCount--;

    if (PerLink->RefCount == 0) {
        PSIS_TREE perLinkTree = deviceExtension->PerLinkTree;

        //
        // Pull the perlink out of the tree.
        //

#if DBG     // Make sure it's in the tree before we remove it.
        {
        PER_LINK_KEY perLinkKey[1];
        perLinkKey->Index = PerLink->Index;

        ASSERT(PerLink == SipLookupElementTree(perLinkTree, perLinkKey));
        }
#endif
        SipDeleteElementTree(perLinkTree, PerLink);

        KeReleaseSpinLock(deviceExtension->PerLinkSpinLock, OldIrql);

        //
        // Release the reference that this link held to the CsFile.
        //

        SipDereferenceCSFile(PerLink->CsFile);

        //
        // And return the memory for the per link.
        //

#if     DBG
        InterlockedDecrement(&outstandingPerLinks);
#endif  // DBG

        SIS_MARK_POINT_ULONG(PerLink);

        ExFreePool(PerLink);    // Probably should cache a few of these
    } else {
        KeReleaseSpinLock(deviceExtension->PerLinkSpinLock, OldIrql);
    }
}

PSIS_SCB
SipEnumerateScbList(
    PDEVICE_EXTENSION deviceExtension,
    PSIS_SCB curScb)
{
    KIRQL           OldIrql;
    BOOLEAN         deref;
    PLIST_ENTRY     nextListEntry, listHead;
    PSIS_SCB        scb;

    listHead = &deviceExtension->ScbList;

    KeAcquireSpinLock(deviceExtension->ScbSpinLock, &OldIrql);

    if (NULL == curScb) {               // start at the head
        nextListEntry = listHead->Flink;
    } else {
        nextListEntry = curScb->ScbList.Flink;
    }

    if (nextListEntry == listHead) {    // stop at the tail
        scb = NULL;
    } else {
        scb = CONTAINING_RECORD(nextListEntry, SIS_SCB, ScbList);
    }

    //
    // We've got the next scb on the list, now we need to add a reference
    // to scb, and remove a reference from curScb.
    //
    if (scb) {
        ASSERT(scb->RefCount > 0);

        scb->RefCount++;

#if     DBG
        ++scb->referencesByType[RefsEnumeration];
        SipVerifyTypedScbRefcounts(scb);

        InterlockedIncrement(&totalScbReferences);
        InterlockedIncrement(&totalScbReferencesByType[RefsEnumeration]);
#endif
    }

    deref = FALSE;

    if (curScb) {
        ASSERT(curScb->RefCount > 0);

        if (curScb->RefCount > 1) {
            curScb->RefCount--;

#if     DBG
            --curScb->referencesByType[RefsEnumeration];
            SipVerifyTypedScbRefcounts(curScb);

            InterlockedDecrement(&totalScbReferences);
            InterlockedDecrement(&totalScbReferencesByType[RefsEnumeration]);
#endif

        } else {
            deref = TRUE;
        }
    }

    KeReleaseSpinLock(deviceExtension->ScbSpinLock, OldIrql);

    if (deref) {

        //
        // Take the long path.
        //
        SipDereferenceScb(curScb, RefsEnumeration);
    }

    return scb;
}

VOID
SipUpdateLinkIndex(
    PSIS_SCB scb,
    PLINK_INDEX LinkIndex)
{
    PDEVICE_EXTENSION           deviceExtension = scb->PerLink->CsFile->DeviceObject->DeviceExtension;
    PSIS_PER_LINK               perLink = scb->PerLink;
    PSIS_TREE                   perLinkTree = deviceExtension->PerLinkTree;
    PSIS_TREE                   scbTree = deviceExtension->ScbTree;
    KIRQL                       OldIrql1;
    PER_LINK_KEY                perLinkKey[1];
    SCB_KEY                     scbKey[1];

    SIS_MARK_POINT_ULONG(scb);

    KeAcquireSpinLock(deviceExtension->ScbSpinLock, &OldIrql1);
    KeAcquireSpinLockAtDpcLevel(deviceExtension->PerLinkSpinLock);

    //
    // Pull the SCB out of the tree.
    //
#if DBG     // Make sure it's in the tree before we remove it.
    {
    SCB_KEY scbKey[1];
    scbKey->Index = perLink->Index;

    ASSERT(scb == SipLookupElementTree(scbTree, scbKey));
    }
#endif
    SipDeleteElementTree(scbTree, scb);

    //
    // Pull the perlink out of the tree.
    //
#if DBG     // Make sure it's in the tree before we remove it.
    {
    perLinkKey->Index = perLink->Index;

    ASSERT(perLink == SipLookupElementTree(perLinkTree, perLinkKey));
    }
#endif

    SipDeleteElementTree(perLinkTree, perLink);

    //
    // Set the new index.
    //
    perLink->Index = *LinkIndex;

    //
    // Now add the perLink back into the tree.
    //
    perLinkKey->Index = *LinkIndex;

#if DBG
    {
    PSIS_PER_LINK perLinkNew =
#endif

    SipInsertElementTree(perLinkTree, perLink, perLinkKey);

#if DBG
    ASSERT(perLinkNew == perLink);
    }
#endif

    //
    // And add the scb back into its tree.
    //
    scbKey->Index = perLink->Index;

#if DBG
    {
    PSIS_SCB scbNew =
#endif

    SipInsertElementTree(scbTree, scb, scbKey);

#if DBG
    ASSERT(scbNew == scb);
    }
#endif

    KeReleaseSpinLockFromDpcLevel(deviceExtension->PerLinkSpinLock);
    KeReleaseSpinLock(deviceExtension->ScbSpinLock, OldIrql1);

    return;
}

LONG
SipPerLinkTreeCompare (
    IN PVOID                            Key,
    IN PVOID                            Node)
{
    PPER_LINK_KEY perLinkKey = (PPER_LINK_KEY) Key;
    PSIS_PER_LINK perLink = Node;
    LONGLONG r;

    r = perLinkKey->Index.QuadPart - perLink->Index.QuadPart;

    if (r > 0)
        return 1;
    else if (r < 0)
        return -1;
    else
        return 0;
}


PSIS_CS_FILE
SipLookupCSFile(
    IN PCSID                            CSid,
    IN PLARGE_INTEGER                   CSFileNtfsId        OPTIONAL,
    IN PDEVICE_OBJECT                   DeviceObject)
{
    PSIS_CS_FILE        csFile;
    KIRQL               OldIrql;
    PDEVICE_EXTENSION   DeviceExtension = DeviceObject->DeviceExtension;
    PSIS_TREE           csFileTree = DeviceExtension->CSFileTree;
    CS_FILE_KEY         csFileKey[1];
    ULONG               i;

    csFileKey->CSid = *CSid;

    KeAcquireSpinLock(DeviceExtension->CSFileSpinLock, &OldIrql);

    csFile = SipLookupElementTree(csFileTree, csFileKey);

    if (csFile) {
        csFile->RefCount++;
        KeReleaseSpinLock(DeviceExtension->CSFileSpinLock, OldIrql);

        if (NULL != CSFileNtfsId) {
            KeAcquireSpinLock(csFile->SpinLock, &OldIrql);
            if (csFile->Flags & CSFILE_NTFSID_SET) {
                if (csFile->CSFileNtfsId.QuadPart != CSFileNtfsId->QuadPart) {
                    //
                    // It's only a hint, so it's OK if it's wrong.  If one of them
                    // is zero, take the other one.  Otherwise, just keep the older one
                    // because it's more likely to have come from the real file.
                    //
#if     DBG
                    if (0 != CSFileNtfsId->QuadPart) {
                        DbgPrint("SIS: SipLookupCSFile: non matching CSFileNtfsId 0x%x.0x%x != 0x%x.0x%x\n",
                            csFile->CSFileNtfsId.HighPart,csFile->CSFileNtfsId.LowPart,
                            CSFileNtfsId->HighPart,CSFileNtfsId->LowPart);
                    }
#endif  // DBG
                    if (0 == csFile->CSFileNtfsId.QuadPart) {
                        csFile->CSFileNtfsId = *CSFileNtfsId;
                    }
                }
            } else {
                csFile->CSFileNtfsId = *CSFileNtfsId;
            }
            KeReleaseSpinLock(csFile->SpinLock, OldIrql);
        }

        return(csFile);
    }

    csFile = ExAllocatePoolWithTag( NonPagedPool, sizeof(SIS_CS_FILE), 'CsiS');

    if (!csFile) {
        KeReleaseSpinLock(DeviceExtension->CSFileSpinLock, OldIrql);
        return NULL;
    }

#if     DBG
    InterlockedIncrement(&outstandingCSFiles);
#endif  // DBG

    RtlZeroMemory(csFile,sizeof(SIS_CS_FILE));
    csFile->RefCount = 1;
    csFile->UnderlyingFileObject = NULL;
    csFile->CSid = *CSid;
    csFile->DeviceObject = DeviceObject;
    for (i = 0; i < SIS_CS_BACKPOINTER_CACHE_SIZE; i++) {
        csFile->BackpointerCache[i].LinkFileIndex.QuadPart = -1;
    }
    KeInitializeMutant(csFile->UFOMutant,FALSE);
    ExInitializeResourceLite(csFile->BackpointerResource);

    if (NULL != CSFileNtfsId) {
        csFile->CSFileNtfsId = *CSFileNtfsId;
        csFile->Flags |= CSFILE_NTFSID_SET;
    }

    // Now add it to the tree.

#if DBG
    {
    PSIS_CS_FILE csFileNew =
#endif

    SipInsertElementTree(csFileTree, csFile, csFileKey);

#if DBG
    ASSERT(csFileNew == csFile);
    }
#endif

    KeReleaseSpinLock(DeviceExtension->CSFileSpinLock, OldIrql);
    return csFile;
}

VOID
SipReferenceCSFile(
    IN PSIS_CS_FILE                     CSFile)
{
    PDEVICE_EXTENSION               deviceExtension = CSFile->DeviceObject->DeviceExtension;
    KIRQL                           OldIrql;

    KeAcquireSpinLock(deviceExtension->CSFileSpinLock, &OldIrql);

    //
    // The caller must already have a reference in order to add one.  Assert so.
    //
    ASSERT(CSFile->RefCount > 0);
    CSFile->RefCount++;

    KeReleaseSpinLock(deviceExtension->CSFileSpinLock, OldIrql);
}

VOID
SipDereferenceCSFile(
    IN PSIS_CS_FILE                     CSFile)
{
    PDEVICE_EXTENSION   DeviceExtension = CSFile->DeviceObject->DeviceExtension;
    KIRQL               OldIrql;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Grab the CSFileHandleResource shared.  We need to do this to prevent a race between when
    // the backpointer stream handle gets closed and someone else opening the file (and hence
    // the backpointer stream).  That race results in a sharing violation for the opener.
    // Because we're acquiring a resource in a user thread, we must block APCs.
    //

    //
    //  After acquiring this resource this routine may call SipCloseHandles.
    //  If it does, that routine creates a worker thread which releases the
    //  resource.  There was a bug in that code because we were not changing
    //  the owner.  I fixed the code to change the owner but then there was
    //  another problem because SiFilterContextFreedCallback can eventually
    //  call this routine (via SipDereferenceScb).  We were crashing there
    //  because the owner ship on the CSFileHandleResource had changed.  To
    //  work around that I was change the ownership before calling
    //  SipDereferenceScb.  We now have a potential deadlock because the system
    //  no longer recognizes a recursive acquire.  If someone had acquired it
    //  exclusive between the acquire in SiFilterContextFreedCallback and this
    //  one we would hang, thus deadlocking.  To get around this I am now
    //  acquiring this with starve exclusive.
    //

    KeEnterCriticalRegion();
    ExAcquireSharedStarveExclusive(DeviceExtension->CSFileHandleResource,TRUE);

    KeAcquireSpinLock(DeviceExtension->CSFileSpinLock, &OldIrql);

    ASSERT(CSFile->RefCount > 0);
    CSFile->RefCount--;

    if (CSFile->RefCount == 0) {
        PSIS_TREE csFileTree = DeviceExtension->CSFileTree;
        //
        // Pull the CSFile out of the tree.
        //
#if DBG     // Make sure it's in the tree before we remove it.
        {
        CS_FILE_KEY csFileKey[1];
        csFileKey->CSid = CSFile->CSid;

        ASSERT(CSFile == SipLookupElementTree(csFileTree, csFileKey));
       }
#endif
        SipDeleteElementTree(csFileTree, CSFile);

        KeReleaseSpinLock(DeviceExtension->CSFileSpinLock, OldIrql);

        // Close the underlying file object.
        if (CSFile->UnderlyingFileObject != NULL) {
            ObDereferenceObject(CSFile->UnderlyingFileObject);
#if     DBG
            CSFile->UnderlyingFileObject = NULL;
#endif  // DBG
        }

        if (NULL != CSFile->BackpointerStreamFileObject) {
            ObDereferenceObject(CSFile->BackpointerStreamFileObject);
#if     DBG
            CSFile->BackpointerStreamFileObject = NULL;
#endif  // DBG
        }

        //
        // Now close the underlying file and backpointer stream handles.
        //
        if (NULL != CSFile->UnderlyingFileHandle) {

            SipCloseHandles(
                    CSFile->UnderlyingFileHandle,
                    CSFile->BackpointerStreamHandle,
                    DeviceExtension->CSFileHandleResource);

        } else {
            ASSERT(NULL == CSFile->BackpointerStreamHandle);

            ExReleaseResourceLite(DeviceExtension->CSFileHandleResource);
        }
        //
        // We've either handed off responsibility for the CSFileHandleResource to a system thread,
        // or we have released it, so we can drop our disabling of APCs.
        //
        KeLeaveCriticalRegion();

        ExDeleteResourceLite(CSFile->BackpointerResource);

#if     DBG
        InterlockedDecrement(&outstandingCSFiles);
#endif  // DBG

        SIS_MARK_POINT_ULONG(CSFile);

        ExFreePool(CSFile); // Probably should cache a few of these
    } else {
        KeReleaseSpinLock(DeviceExtension->CSFileSpinLock, OldIrql);
        ExReleaseResourceLite(DeviceExtension->CSFileHandleResource);
        KeLeaveCriticalRegion();
    }
}

//
// This function relies on the fact that a GUID is the same size as two longlongs.  There
// is an assert to that effect in DriverEntry.
//
LONG
SipCSFileTreeCompare (
    IN PVOID                            Key,
    IN PVOID                            Node)
{
    PCS_FILE_KEY csFileKey = (PCS_FILE_KEY) Key;
    PSIS_CS_FILE csFile = (PSIS_CS_FILE)Node;

    PLONGLONG keyValue1 = (PLONGLONG)&csFileKey->CSid;
    PLONGLONG keyValue2 = keyValue1 + 1;
    PLONGLONG nodeValue1 = (PLONGLONG)&csFile->CSid;
    PLONGLONG nodeValue2 = nodeValue1 + 1;

    if (*keyValue1 < *nodeValue1) {
        return -1;
    } else if (*keyValue1 > *nodeValue1) {
        return 1;
    } else {
        if (*keyValue2 < *nodeValue2) {
            return -1;
        } else if (*keyValue2 > *nodeValue2) {
            return 1;
        } else {
            ASSERT(IsEqualGUID(&csFileKey->CSid, &csFile->CSid));
            return 0;
        }
    }
}

NTSTATUS
SipCreateEvent(
    IN EVENT_TYPE                       eventType,
    OUT PHANDLE                         eventHandle,
    OUT PKEVENT                         *event)
{

    NTSTATUS        status;

    status = ZwCreateEvent(
                eventHandle,
                EVENT_ALL_ACCESS,
                NULL,
                eventType,
                FALSE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("SipCreateEvent: Unable to allocate event, 0x%x\n",status);
        *eventHandle = NULL;
        *event = NULL;
        return status;
    }

    status = ObReferenceObjectByHandle(
                *eventHandle,
                EVENT_ALL_ACCESS,
                NULL,
                KernelMode,
                event,
                NULL);

    if (!NT_SUCCESS(status)) {
        DbgPrint("SipCreateEvent: Unable to reference event, 0x%x\n",status);
        ZwClose(*eventHandle);

        *eventHandle = NULL;
        *event = NULL;
    }

    return status;
}

VOID
SipAddRangeToFaultedList(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PSIS_SCB                         scb,
    IN PLARGE_INTEGER                   offset,
    IN LONGLONG                         length
    )
/*++

Routine Description:

    Adds a range to the faulted list for a given stream.  If the range
    (or part of it) is already written, we leave it that way.  It's also
    OK for some or all of the range to already be faulted.

    The caller must hold the scb, and we'll return without
    dropping it.

Arguments:
    deviceExtension - the D.E. for the volume on which this file lives

    scb - Pointer to the scb for the file

    offset - pointer to the offset of the beginning of the read range

    Length - Length of the read range

Return Value:

    VOID
--*/
{
    BOOLEAN         inMappedRange;
    LONGLONG        mappedTo;
    LONGLONG        mappedSectorCount;
    LONGLONG        currentOffset = offset->QuadPart / deviceExtension->FilesystemVolumeSectorSize;
    LONGLONG        lengthInSectors;

    SipAssertScbHeld(scb);

    lengthInSectors = (length + deviceExtension->FilesystemVolumeSectorSize - 1) /
                        deviceExtension->FilesystemVolumeSectorSize;

    //
    // Loop looking up filled in ranges and setting them appropriately.
    //

    while (lengthInSectors != 0) {
        inMappedRange = FsRtlLookupLargeMcbEntry(
                            scb->Ranges,
                            currentOffset,
                            &mappedTo,
                            &mappedSectorCount,
                            NULL,               // LargeStartingLbn
                            NULL,               // LargeCountFromStartingLbn
                            NULL);              // Index

        if (!inMappedRange) {
            //
            // Not only isn't there a mapping for this range, but it's beyond
            // the largest thing mapped in the MCB, so we can just do the whole
            // mapping at once.  Set the variables appropriately and fall
            // through.
            mappedTo = 0;
            mappedSectorCount = lengthInSectors;
        } else {

            ASSERT(mappedSectorCount > 0);

            //
            // If the mapped (or unmapped, as the case may be) range extends beyond
            // the just faulted region, reduce our idea of its size.
            //
            if (mappedSectorCount > lengthInSectors) {
                mappedSectorCount = lengthInSectors;
            }
        }

        //
        // Check to see whether this is mapped to x + FAULTED_OFFSET (in which case it's
        // already faulted) or mapped to x + WRITTEN_OFFSET (in which case it's written and
        // should be left alone).  Otherwise, fill it in as faulted.
        //

        if ((mappedTo != currentOffset + FAULTED_OFFSET)
            && (mappedTo != currentOffset + WRITTEN_OFFSET)) {
            BOOLEAN worked =
                    FsRtlAddLargeMcbEntry(
                        scb->Ranges,
                        currentOffset,
                        currentOffset + FAULTED_OFFSET,
                        mappedSectorCount);

            //
            // FsRtlAddLargeMcbEntry is only supposed to fail if you're adding to a range
            // that's already in the MCB, which we should never be doing.  Assert that.
            //
            ASSERT(worked);
        }

        ASSERT(mappedSectorCount <= lengthInSectors);
        lengthInSectors -= mappedSectorCount;
        currentOffset += mappedSectorCount;
    }
}

NTSTATUS
SipAddRangeToWrittenList(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PSIS_SCB                         scb,
    IN PLARGE_INTEGER                   offset,
    IN LONGLONG                         length
    )
/*++

Routine Description:

    Adds a range to the written list for a given stream.  If the range
    (or part of it) is already faulted, we change it to written.  It's also
    OK for some or all of the range to already be written.

    The caller must hold the scb, and we'll return without
    dropping it.

Arguments:

    scb - Pointer to the scb for the file

    offset - pointer to the offset of the beginning of the write range

    Length - Length of the write range

Return Value:

    status of the operation
--*/
{
    BOOLEAN         worked;
    LONGLONG        offsetInSectors = offset->QuadPart / deviceExtension->FilesystemVolumeSectorSize;
    LONGLONG        lengthInSectors;

    SipAssertScbHeld(scb);

    lengthInSectors = (length + deviceExtension->FilesystemVolumeSectorSize - 1) /
                        deviceExtension->FilesystemVolumeSectorSize;

    if (0 == lengthInSectors) {
        //
        // Sometimes FsRtl doesn't like being called with a zero length.  We know it's
        // a no-op, so just immediately return success.
        //

        SIS_MARK_POINT();

        return STATUS_SUCCESS;
    }

    //
    // First, blow away any mappings that might already exist for the
    // range we're marking as written.  We need to use a try-except
    // because FsRtlRemoveLargeMcbEntry can raise.
    //

    try {
        FsRtlRemoveLargeMcbEntry(
                scb->Ranges,
                offsetInSectors,
                lengthInSectors);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Now, add the region as written.
    //
    worked = FsRtlAddLargeMcbEntry(
                scb->Ranges,
                offsetInSectors,
                offsetInSectors + WRITTEN_OFFSET,
                lengthInSectors);
    //
    // This is only supposed to fail if you're adding to a range that's
    // already mapped, which we shouldn't be doing because we just
    // unmapped it.  Assert so.
    //
    ASSERT(worked);

    return STATUS_SUCCESS;
}

SIS_RANGE_DIRTY_STATE
SipGetRangeDirty(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PSIS_SCB                         scb,
    IN PLARGE_INTEGER                   offset,
    IN LONGLONG                         length,
    IN BOOLEAN                          faultedIsDirty
    )
/*++

Routine Description:

    This routine may be called while synchronized for cached write, to
    test for a possible Eof update, and return with a status if Eof is
    being updated and with the previous FileSize to restore on error.
    All updates to Eof are serialized by waiting in this routine.  If
    this routine returns TRUE, then NtfsFinishIoAtEof must be called.

    This routine must be called while synchronized with the FsRtl header.

    This code is stolen from NTFS, and modified to deal only with FileSize
    rather than  ValidDataLength.

Arguments:

    deviceExtension - the D.E. for the volume this file lives on

    scb - Pointer to the scb for the file

    offset - A pointer to the offset within the file of the beginning of the range

    length - the length of the range

    faultedIsDirty - Should faulted (as opposed to written) regions be
        treated as dirty or clean

Return Value:

    Clean, Dirty or Mixed.
--*/
{
    BOOLEAN         inMappedRange;
    LONGLONG        currentOffsetInSectors = offset->QuadPart / deviceExtension->FilesystemVolumeSectorSize;
    BOOLEAN         seenDirty = FALSE;
    BOOLEAN         seenClean = FALSE;
    LONGLONG        lengthInSectors;

    SipAssertScbHeld(scb);

    //
    // Handle the case where we're being asked about parts beyond the backed region.
    // Bytes from the end of the mapped range to the end of the backed region
    // are untouched.  Bytes beyond the end of the backed region are dirty.
    //
    if (offset->QuadPart >= scb->SizeBackedByUnderlyingFile) {
        //
        // The whole region's beyond the backed section. It's all dirty.
        //
        return Dirty;
    } else if (offset->QuadPart + length > scb->SizeBackedByUnderlyingFile) {
        //
        // Some of the region's betond the backed section.  We've seen dirty,
        // plus we need to truncate the length.
        //
        seenDirty = TRUE;
        length = scb->SizeBackedByUnderlyingFile - offset->QuadPart;
    }

    lengthInSectors = (length + deviceExtension->FilesystemVolumeSectorSize - 1) /
                        deviceExtension->FilesystemVolumeSectorSize;

    //
    // Loop though the range specified getting the mappings from the MCB.
    //
    while (lengthInSectors > 0) {
        LONGLONG        mappedTo;
        LONGLONG        sectorCount;

        inMappedRange = FsRtlLookupLargeMcbEntry(
                            scb->Ranges,
                            currentOffsetInSectors,
                            &mappedTo,
                            &sectorCount,
                            NULL,           // starting LBN
                            NULL,           // count from starting LBN
                            NULL);          // index

        if (!inMappedRange) {
            //
            // We're beyond the end of the range.  Fix stuff up so it looks normal.
            //
            sectorCount = lengthInSectors;
            mappedTo = 0;

        } else {
            ASSERT(sectorCount > 0);
            //
            // If the mapped (or unmapped, as the case may be) range extends beyond
            // the just faulted region, reduce our idea of its size.
            //
            if (sectorCount > lengthInSectors) {
                sectorCount = lengthInSectors;
            }
        }

        //
        // Decide whether this range is clean or dirty.  Written is always dirty,
        // not mapped is always clean, and faulted is dirty iff faultedIsDirty.
        if ((mappedTo == currentOffsetInSectors + WRITTEN_OFFSET)
            || (faultedIsDirty && mappedTo == (currentOffsetInSectors + FAULTED_OFFSET))) {
            //
            // It's dirty.
            //
            if (seenClean) {
                //
                // We've seen clean, and now we've seen dirty, so it's mixed and we can
                // quit looking.
                //
                return Mixed;
            }
            seenDirty = TRUE;
        } else {
            //
            // It's clean.
            //
            if (seenDirty) {
                //
                // We've seen dirty, and now we've seen clean, so it's mixed and we can
                // quit looking.
                //
                return Mixed;
            }
            seenClean = TRUE;
        }

        currentOffsetInSectors += sectorCount;
        lengthInSectors -= sectorCount;
    }

    //
    // Assert that we haven't seen both clean and dirty regions.  If we had,
    // then we should have already returned.
    //
    ASSERT(!seenClean || !seenDirty);

    return seenDirty ? Dirty : Clean;
}

BOOLEAN
SipGetRangeEntry(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PSIS_SCB                         scb,
    IN LONGLONG                         startingOffset,
    OUT PLONGLONG                       length,
    OUT PSIS_RANGE_STATE                state)
{
    BOOLEAN         inRange;
    LONGLONG        mappedTo;
    LONGLONG        sectorCount;
    LONGLONG        startingSectorOffset = startingOffset / deviceExtension->FilesystemVolumeSectorSize;

    SipAssertScbHeld(scb);

    if (!(scb->Flags & SIS_SCB_MCB_INITIALIZED)) {
        return FALSE;
    }

    ASSERT(startingOffset < scb->SizeBackedByUnderlyingFile);

    inRange = FsRtlLookupLargeMcbEntry(
                    scb->Ranges,
                    startingSectorOffset,
                    &mappedTo,
                    &sectorCount,
                    NULL,                       // LargeStartingLbn
                    NULL,                       // LargeCountFromStartingLbn
                    NULL);                      // index

    if (!inRange) {
        return FALSE;
    }

    *length = sectorCount * deviceExtension->FilesystemVolumeSectorSize;

    if (mappedTo == -1) {
        *state = Untouched;
    } else if (mappedTo == startingSectorOffset + FAULTED_OFFSET) {
        *state = Faulted;
    } else {
        ASSERT(mappedTo == startingSectorOffset + WRITTEN_OFFSET);
        *state = Written;
    }

    return TRUE;
}

#if     DBG

BOOLEAN
SipIsFileObjectSISInternal(
    IN PFILE_OBJECT                     fileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN SIS_FIND_TYPE                    findType,
    OUT PSIS_PER_FILE_OBJECT            *perFO OPTIONAL,
    OUT PSIS_SCB                        *scbReturn OPTIONAL,
    IN PCHAR                            fileName,
    IN ULONG                            fileLine
    )

#else   // DBG

BOOLEAN
SipIsFileObjectSIS(
    IN PFILE_OBJECT                     fileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN SIS_FIND_TYPE                    findType,
    OUT PSIS_PER_FILE_OBJECT            *perFO OPTIONAL,
    OUT PSIS_SCB                        *scbReturn OPTIONAL
    )

#endif  // DBG
/*++

Routine Description:

    Given a file object, find out if it is an SIS file object.
    If it is, then return the PER_FO pointer for the object.

    We use the FsRtl FilterContext support for this operation.

Arguments:

    fileObject - The file object that we're considering.

    DeviceObject - the SIS DeviceObject for this volume.

    findType - look for active only, or active & defunct scb.

    perFO - returns a pointer to the perFO for this file object
            if it is a SIS file object.

Return Value:

    FALSE - This is not an SIS file object.
    TRUE - This is an SIS file object, and perFO
            has been set accordingly.

--*/
{
    PSIS_FILTER_CONTEXT     fc;
    PSIS_SCB                scb;
    PSIS_PER_FILE_OBJECT    localPerFO;
    PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;
    //PSIS_PER_LINK           perLink;
    BOOLEAN                 rc;
    BOOLEAN                 newPerFO;

	//
	// It's possible to get some calls with a NULL file object.  Clearly, no file object
	// at all isn't a SIS file object, so say so before we dereference the file object pointer.
	//
	if (NULL == fileObject) {
		SIS_MARK_POINT();
		rc = FALSE;
		goto Done2;
	}

#if     DBG
    if (BJBAssertNow != 0) {
        BJBAssertNow = 0;
        ASSERT(!"You asked for this");
    }

	if ((NULL != BJBMagicFsContext) && (fileObject->FsContext == BJBMagicFsContext)) {
		ASSERT(!"Hit on BJBMagicFsContext");
	}
#endif	// DBG

#if     TIMING
    if (BJBDumpTimingNow) {
        SipDumpTimingInfo();
        BJBDumpTimingNow = 0;
    }
    if (BJBClearTimingNow) {
        SipClearTimingInfo();
        BJBClearTimingNow = 0;
    }
#endif  // TIMING

#if     COUNTING_MALLOC
    if (BJBDumpCountingMallocNow) {
        SipDumpCountingMallocStats();
        //      BJBDumpCountingMallocNow  is cleared in SipDumpCountingMallocStats
    }
#endif  // COUNTING_MALLOC

    //
    // We should have already verified that this isn't our primary device object.
    //
    ASSERT(!IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject));

    ASSERT(fileObject->Type == IO_TYPE_FILE);
    ASSERT(fileObject->Size == sizeof(FILE_OBJECT));

    //
    // The filter context won't go away while we hold the resource, because as long
    // as the file exists the NTFS SCB will exists, and NTFS won't call the
    // "remove filter context" callback.
    //

    //
    // Call FsRtl to see if this file object has a context registered for it.
    // We always use our DeviceObject as the OwnerId.
    //
    fc = (PSIS_FILTER_CONTEXT) FsRtlLookupPerStreamContext(
                                    FsRtlGetPerStreamContextPointer(fileObject),
                                    DeviceObject,
                                    NULL);

    //
    // If FsRtl didn't find what we want, then this isn't one of our file objects.
    //
    if (NULL == fc) {
        rc = FALSE;
        goto Done2;
    }

    SIS_MARK_POINT_ULONG(fc);
    SIS_MARK_POINT_ULONG(fileObject);
//  SIS_MARK_POINT_ULONG(scb);

    //
    // Assert that what we got back is the right kind of thing.
    //
    ASSERT(fc->ContextCtrl.OwnerId == DeviceObject && fc->ContextCtrl.InstanceId == NULL);

	SipAcquireFc(fc);
    scb = fc->primaryScb;

    //
    // If we're looking for an active scb only and the primary scb is defunct,
    // we're done.
    //
    if ((FindActive == findType) && (scb->PerLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE)) {

#if     DBG
        {
            //
            // Keep track of the last scb that got marked coming through here, and only
            // do a mark point if this one is different.  This keeps the log polution to
            // a minimum when the stress test beats on a file that's got a defunct scb.
            // We don't bother with proper synchronization around this variable, because
            // we don't really care all that much if this works perfectly.
            //
            static PSIS_SCB lastMarkedScb = NULL;

            if (scb != lastMarkedScb) {
                SIS_MARK_POINT_ULONG(scb);
                lastMarkedScb = scb;
            }
        }
#endif  // DBG

        rc = FALSE;
        goto Done;

    }

    //
    //  Locate the existing PerFO (if we have one) or allocate a new one
    //

    localPerFO = SipAllocatePerFO(fc, fileObject, scb, DeviceObject, &newPerFO);

    if (!localPerFO) {
        ASSERT("SIS: SipIsFileObjectSIS: unable to allocate new perFO.\n");

        SIS_MARK_POINT();
        rc = FALSE;
        goto Done;
    }

#if DBG
    //
    //  If this was newly allocated, handle it
    //

    if (newPerFO) {

        if (BJBDebug & 0x4) {
            DbgPrint("SIS: SipIsFileObjectSIS: Allocating new perFO for fileObject %p, scb %p\n",fileObject,scb);
            if (!(fileObject->Flags & FO_STREAM_FILE)) {
                DbgPrint("SIS: SipIsFileObjectSIS: the allocated file object wasn't a stream file (%s %u)\n",fileName,fileLine);
            }
        }

        localPerFO->Flags |= SIS_PER_FO_NO_CREATE;
        localPerFO->AllocatingFilename = fileName;
        localPerFO->AllocatingLineNumber = fileLine;
    }
#endif  // DBG


//	//
//	// Cruise down the perFO list and see if there is a perFO that
//	// corresponds to this file object.
//	//
//
//    if (NULL != fc->perFOs) {
//
//        for (   localPerFO = fc->perFOs;
//                localPerFO->fileObject != fileObject && localPerFO->Next != fc->perFOs;
//                localPerFO = localPerFO->Next) {
//
//            // Intentionally empty loop body.
//        }
//    }
//
//    if ((NULL == fc->perFOs) || (localPerFO->fileObject != fileObject)) {
//        //
//        // We don't have a perFO for this file object associated with this
//        // SCB.  We're most likely dealing with a stream file object that
//        // got created underneath us.  Allocate one and add it into the list.
//        //
////        perLink = scb->PerLink;
//
//#if     DBG
//        if (BJBDebug & 0x4) {
//            DbgPrint("SIS: SipIsFileObjectSIS: Allocating new perFO for fileObject %p, scb %p\n",fileObject,scb);
//            if (!(fileObject->Flags & FO_STREAM_FILE)) {
//                DbgPrint("SIS: SipIsFileObjectSIS: the allocated file object wasn't a stream file (%s %u)\n",fileName,fileLine);
//            }
//        }
//
//        SIS_MARK_POINT_ULONG(fileName);
//        SIS_MARK_POINT_ULONG(fileLine);
//#endif  // DBG
//
//        localPerFO = SipAllocatePerFO(fc, fileObject, scb, DeviceObject);
//
//        SIS_MARK_POINT_ULONG(scb);
//        SIS_MARK_POINT_ULONG(fileObject);
//
//        if (!localPerFO) {
//            ASSERT("SIS: SipIsFileObjectSIS: unable to allocate new perFO.\n");
//
//            SIS_MARK_POINT();
//            rc = FALSE;
//            goto Done;
//        }
//
//#if     DBG
//        localPerFO->Flags |= SIS_PER_FO_NO_CREATE;
//        localPerFO->AllocatingFilename = fileName;
//        localPerFO->AllocatingLineNumber = fileLine;
//#endif  // DBG
//    }

    rc = TRUE;

Done:
    SipReleaseFc(fc);
Done2:

    //
    // Return the PerFO if the user wanted it.
    //
    if (ARGUMENT_PRESENT(perFO)) {
        *perFO = rc ? localPerFO : NULL;
    }
    if (ARGUMENT_PRESENT(scbReturn)) {
        *scbReturn = rc ? scb : NULL;
    }
//  SIS_MARK_POINT_ULONG(localPerFO);

    return rc;
}

typedef struct _SI_POSTED_FILTER_CONTEXT_FREED_CALLBACK {
    WORK_QUEUE_ITEM         workItem[1];
    PSIS_FILTER_CONTEXT     fc;
} SI_POSTED_FILTER_CONTEXT_FREED_CALLBACK, *PSI_POSTED_FILTER_CONTEXT_FREED_CALLBACK;

VOID
SiPostedFilterContextFreed(
    IN PVOID                            context)
/*++

Routine Description:

    NTFS informed us that a filter context was freed, and we had to post
    processing the request in order to avoid a deadlock.  Drop the
    reference to the SCB held by the filter context, and then free the
    filter context and the posted request itself.

Arguments:

    context - the posted request to dereference the filter context.

Return Value:

    void

--*/
{
    PSI_POSTED_FILTER_CONTEXT_FREED_CALLBACK    request = context;

    SIS_MARK_POINT_ULONG(request->fc);

    SipDereferenceScb(request->fc->primaryScb, RefsFc);

    ExFreePool(request->fc);
    ExFreePool(request);

    return;
}

VOID
SiFilterContextFreedCallback (
    IN PVOID context
    )
/*++

Routine Description:

    This function is called when a file with a SIS filter context
    attached is about to be destroyed.

    For now, we don't do anything, but once this functionality is really
    enabled, we'll detach from the file here and only here.

Arguments:

    context - the filter context to be detached.

Return Value:

    void

--*/
{
    PSIS_FILTER_CONTEXT fc = context;
    PDEVICE_EXTENSION   deviceExtension;

    SIS_MARK_POINT_ULONG(fc);
    SIS_MARK_POINT_ULONG(fc->primaryScb);

    //
    // This can't be freed if there's still a file object referring to it.
    //

    ASSERT(NULL != fc);
    ASSERT(0 == fc->perFOCount);
    ASSERT(NULL != fc->primaryScb);

    deviceExtension = fc->primaryScb->PerLink->CsFile->DeviceObject->DeviceExtension;

    ASSERT(fc->ContextCtrl.OwnerId == deviceExtension->DeviceObject);
    ASSERT(NULL == fc->ContextCtrl.InstanceId);

    //
    // We're in a callback from NTFS.  The rules of this callback are that we
    // can't block acquiring resources.  If this happens to be the last access
    // to the given CS file, we'll try to acquire the volume-wide CSFileHandleResource
    // shared inside SipDereferenceScb.  This could potentially block, which can lead
    // to a deadlock if NTFS is doing a volume-wide checkpoint.  To avoid this,
    // take the resource here, and take it Wait == FALSE.  If we can't get it,
    // then post this request.
    //

    //
    // Enter a critical region before (possibly) taking a resource in what might be a user thread.
    //
    KeEnterCriticalRegion();
    if (
#if DBG
        (BJBDebug & 0x04000000) ||
#endif  // DBG
        !ExAcquireResourceSharedLite(deviceExtension->CSFileHandleResource, FALSE)
       ) {

        PSI_POSTED_FILTER_CONTEXT_FREED_CALLBACK    request;

        SIS_MARK_POINT_ULONG(fc);

        request = ExAllocatePoolWithTag(
                    NonPagedPool,
                    sizeof(SI_POSTED_FILTER_CONTEXT_FREED_CALLBACK),
                    ' siS');

        if (NULL == request) {
            SIS_MARK_POINT_ULONG(fc);
            //
            // This is pretty bad.  Dribble the request.
            // BUGBUGBUG : This must be fixed.
            //
        }
        else {
            request->fc = fc;
            ExInitializeWorkItem(request->workItem, SiPostedFilterContextFreed, request);
            ExQueueWorkItem(request->workItem, CriticalWorkQueue);
        }
    } else {

        //
        //  I am changing the owner at this point because of an interesting
        //  bug check that I was getting.  The routine SipDereferenceScb can
        //  eventually call SipCloseHandles.  This routine acquire this same
        //  resource recursivly, and then releases it in a worker thread.  To
        //  do this it changes the owner of this resource.  Because it was a
        //  nested acquire, changing the owner changed our ownership as well.
        //  When we returned we received a E3 bug check (resource not owned)
        //  because our thread no longer owned the resource.  To fix this
        //  I am going to change the owner to our device extension.  Then the
        //  recursive call 
        //

        ExSetResourceOwnerPointer(deviceExtension->CSFileHandleResource, 
                                  (PVOID)MAKE_RESOURCE_OWNER(&deviceExtension));

        SipDereferenceScb(fc->primaryScb, RefsFc);

        ExReleaseResourceForThreadLite(deviceExtension->CSFileHandleResource,
                                       MAKE_RESOURCE_OWNER(&deviceExtension));

        ExFreePool(fc);
    }

    //
    // We're done with the resource, release our APC block.
    //

    KeLeaveCriticalRegion();
}


PSIS_PER_FILE_OBJECT
SipAllocatePerFO(
    IN PSIS_FILTER_CONTEXT      fc,
    IN PFILE_OBJECT             fileObject,
    IN PSIS_SCB                 scb,
    IN PDEVICE_OBJECT           DeviceObject,
    OUT PBOOLEAN                newPerFO OPTIONAL
    )
/*++

Routine Description:

    Allocate a per file-object structure, initialize it and associate
    it with a filter context and scb.  A filter context must already exist.

Arguments:

    fc - a pointer to the filter context associated with this file.

    fileObject - The file object that we're claiming.

    scb - a pointer to the SIS scb for this file.

    DeviceObject - the SIS DeviceObject for this volume

    newPerFO - boolean to say if this was a newly allocated structure (only
                set in DEBUG version)

Return Value:


    A pointer to the perFO for this file object if successful, else NULL.

--*/
{
    PSIS_PER_FILE_OBJECT perFO;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( newPerFO );

    SIS_MARK_POINT_ULONG(fc);
    SIS_MARK_POINT_ULONG(fileObject);

#if DBG
    if (ARGUMENT_PRESENT(newPerFO)) {

        *newPerFO = FALSE;
    }
#endif
                
	//
	//  See if we already have a perFO structure for this fileObject.  If so
    //  return it instead of allocating a new one.
	//

    if (NULL != fc->perFOs) {

        perFO = fc->perFOs;
        do {

            ASSERT(perFO->fc == fc);
            ASSERT(perFO->FsContext == fileObject->FsContext);

            if (perFO->fileObject == fileObject) {

                //
                //  We found one, return it
                //

#if DBG
                if (BJBDebug & 0x4) {
                    DbgPrint("SIS: SipAllocatePerFO: Found existing perFO\n");
                }
#endif
                SIS_MARK_POINT_ULONG(perFO);
                return perFO;
            }

            //
            //  Advance to the next link
            //

            perFO = perFO->Next;

        } while (perFO != fc->perFOs);
    }

//#if DBG
//
//    ASSERT(scb == fc->primaryScb);
//
//    //
//    // Cruise the list of perFOs for this filter context and assert that
//    // there's not already one there for this file object.  Furthermore,
//    // assert that all of the perFOs on the list point at the same FsContext.
//    //
//
//    if (fc->perFOs) {
//
//        PSIS_PER_FILE_OBJECT    otherPerFO;
//        PVOID                   FsContext = fileObject->FsContext;
//
//        otherPerFO = fc->perFOs;
//
//        do {
//
//            ASSERT(otherPerFO->fc == fc);
//            ASSERT(otherPerFO->fileObject != fileObject);
//            ASSERT(otherPerFO->FsContext == FsContext);
//
//            otherPerFO = otherPerFO->Next;
//
//        } while (otherPerFO != fc->perFOs);
//    }
//
//#endif  // DBG

    perFO = ExAllocatePoolWithTag(NonPagedPool, sizeof(SIS_PER_FILE_OBJECT), 'FsiS');

    if (!perFO) {
#if     DBG
        DbgPrint("SIS: SipAllocatePerFO: unable to allocate perFO\n");
#endif  // DBG
        goto Error;
    }

#if DBG
    if (ARGUMENT_PRESENT(newPerFO)) {

        *newPerFO = TRUE;
    }
#endif

    SIS_MARK_POINT_ULONG(perFO);

    RtlZeroMemory(perFO, sizeof(SIS_PER_FILE_OBJECT));

    perFO->fc = fc;
    perFO->referenceScb = scb;
    perFO->fileObject = fileObject;
#if DBG
    perFO->FsContext = fileObject->FsContext;   // Just keep track of this for consistency checking
#endif  // DBG
    KeInitializeSpinLock(perFO->SpinLock);

    //
    // Insert this per-FO on the linked list in the filter context.
    //

    if (!fc->perFOs) {

        ASSERT(0 == fc->perFOCount);

        fc->perFOs = perFO;

        perFO->Prev = perFO;
        perFO->Next = perFO;

    } else {

        perFO->Prev = fc->perFOs->Prev;
        perFO->Next = fc->perFOs;

        perFO->Next->Prev = perFO;
        perFO->Prev->Next = perFO;

    }

#if DBG
    InterlockedIncrement(&outstandingPerFOs);
#endif  // DBG

    fc->perFOCount++;

    //
    // Grab a reference for this file object to this scb.
    //
    SipReferenceScb(scb, RefsPerFO);

//  SIS_MARK_POINT_ULONG(perFO);

Error:

    return perFO;
}


PSIS_PER_FILE_OBJECT
SipCreatePerFO(
    IN PFILE_OBJECT             fileObject,
    IN PSIS_SCB                 scb,
    IN PDEVICE_OBJECT           DeviceObject)
/*++

Routine Description:

    Create a per file-object structure, initialize it and associate
    it with an scb.  A filter context will also be created and
    registered if one does not already exist.  The caller must hold the
    scb, and it will still be held on return.

Arguments:

    fileObject - The file object that we're claiming.

    scb - a pointer to the SIS scb for this file.

    DeviceObject - the SIS DeviceObject for this volume

Return Value:


    A pointer to the perFO for this file object if successful, else NULL.

--*/
{
    PDEVICE_EXTENSION           deviceExtension = DeviceObject->DeviceExtension;
    PSIS_FILTER_CONTEXT         fc;
    PSIS_PER_FILE_OBJECT        perFO;
    NTSTATUS                    status;

    //
    // This scb must be the primary scb.  If a filter context already exists,
    // either this scb is already attached to it as the primary scb, or else
    // it will become the new primary scb.
    //

    SipAssertScbHeld(scb);

    //
    // Lookup the filter context.
    //

    fc = (PSIS_FILTER_CONTEXT) FsRtlLookupPerStreamContext(
                                            FsRtlGetPerStreamContextPointer(fileObject), 
                                            DeviceObject, 
                                            NULL);

    if (!fc) {

        //
        // A filter context doesn't already exist.  Create one.
        //

        fc = ExAllocatePoolWithTag(NonPagedPool, sizeof(SIS_FILTER_CONTEXT), 'FsiS');

        if (!fc) {
#if     DBG
            DbgPrint("SIS: SipCreatePerFO: unable to allocate filter context\n");
#endif  // DBG

            perFO = NULL;
            goto Error;

        }

        SIS_MARK_POINT_ULONG(fc);

        RtlZeroMemory(fc, sizeof(SIS_FILTER_CONTEXT));

        //
        // Fill in the fields in the FSRTL_FILTER_CONTEXT within the fc.
        //

        FsRtlInitPerStreamContext( &fc->ContextCtrl,
                                   DeviceObject,
                                   NULL,
                                   SiFilterContextFreedCallback );
        fc->primaryScb = scb;

        SipReferenceScb(scb, RefsFc);

        ExInitializeFastMutex(fc->FastMutex);

        //
        // And insert it as a filter context.
        //
        status = FsRtlInsertPerStreamContext(
                            FsRtlGetPerStreamContextPointer(fileObject), 
                            &fc->ContextCtrl);

        ASSERT(STATUS_SUCCESS == status);

        SipAcquireFc(fc);

    } else {
        SipAcquireFc(fc);

        SIS_MARK_POINT_ULONG(fc);

        if (fc->primaryScb != scb) {

            PSIS_SCB    defunctScb = fc->primaryScb;

            //
            // A filter context exists along with another scb.  It must be a
            // defunct scb.
            //

            ASSERT(defunctScb->PerLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE);

            //
            // Switch the reference for the defunct scb from RefsFc to
            // RefsDefunct.  Add a reference from the fc to the new scb, and
            // from the new scb to the defunct one.
            //

            SipReferenceScb(defunctScb, RefsPredecessorScb);
            SipDereferenceScb(defunctScb, RefsFc);

            SipReferenceScb(scb, RefsFc);
            scb->PredecessorScb = defunctScb;

            fc->primaryScb = scb;
        }
    }

    //
    // Now add a perFO to the filter context.
    //

    perFO = SipAllocatePerFO(fc, fileObject, scb, DeviceObject, NULL);
    SipReleaseFc(fc);

Error:

    return perFO;
}

VOID
SipDeallocatePerFO(
    IN OUT PSIS_PER_FILE_OBJECT         perFO,
    IN PDEVICE_OBJECT                   DeviceObject)
{
    PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;
    PSIS_FILTER_CONTEXT     fc;
    PFILE_OBJECT            fileObject = perFO->fileObject;

    SIS_MARK_POINT_ULONG(perFO);

    //
    // This perFO holds a reference to its scb, therefore we know its scb
    // pointer is valid.
    //
    ASSERT(perFO->referenceScb);

    //
    // The perFO also holds a reference to the filter context, and therefore
    // we know the filter context pointer is valid.
    //
    fc = perFO->fc;
    ASSERT(fc && fc->perFOCount > 0);

    SipAcquireFc(fc);
    ASSERT(*(ULONG volatile *)&fc->perFOCount > 0);

    //
    // Remove the perFO from the filter context's linked list.  If this is the last
    // perFO, then we just zero the fc's perFO pointer.
    //

    if (1 == fc->perFOCount) {
        ASSERT(fc->perFOs == perFO);
        fc->perFOs = NULL;
    } else {

        perFO->Prev->Next = perFO->Next;
        perFO->Next->Prev = perFO->Prev;

        if (perFO == fc->perFOs) {
            fc->perFOs = perFO->Next;
        }
    }

    ASSERT(perFO != fc->perFOs);

    //
    // Decrement the count of per-FOs for this filter context.
    //
    fc->perFOCount--;

    SipReleaseFc(fc);

    //
    // Assert that we don't have an outstanding opbreak for this file object.  (We guarantee
    // that this can't happen by taking a reference to the file object when we launch the
    // FSCTL_OPLOCK_BREAK_NOTIFY.)  Free the break event if one has been allocated.
    //

    ASSERT(!(perFO->Flags & (SIS_PER_FO_OPBREAK|SIS_PER_FO_OPBREAK_WAITERS)));

    if (NULL != perFO->BreakEvent) {

        ExFreePool(perFO->BreakEvent);
#if     DBG
        perFO->BreakEvent = NULL;
#endif  // DBG

    }

    //
    // Now we're safe to drop our reference to the SCB (and possibly have it be
    // deallocated, which in turn may cause other scb's that were previously part
    // of this filter context to be deallocated).
    //

    SipDereferenceScb(perFO->referenceScb, RefsPerFO);

    //
    // Free the memory for the perFO that we just deleted.
    //
    ExFreePool(perFO);

#if     DBG
    InterlockedDecrement(&outstandingPerFOs);
#endif  // DBG
}

NTSTATUS
SipInitializePrimaryScb(
    IN PSIS_SCB                         primaryScb,
    IN PSIS_SCB                         defunctScb,
    IN PFILE_OBJECT                     fileObject,
    IN PDEVICE_OBJECT                   DeviceObject)
/*++

Routine Description:

    Installs the primaryScb on the filter context scb chain identified via
    fileObject and adjusts reference counts appropriately.  This requires
	a RefsLookedUp reference type to the primary Scb, and consumes it (the
	primary scb is then referred to by the filter context for the fileObject,
	so the caller can rely on its still existing iff the fileObject continues
	to exist).

Arguments:

    primaryScb - pointer to the scb to become the primary scb.

    defunctScb - pointer to the current primary scb that will become defunct.

    fileObject - pointer to the file object that references defunctScb.

    DeviceObject - the device object holding the specified file object.

Return Value:

    The status of the request

--*/
{
    PSIS_FILTER_CONTEXT fc;
    NTSTATUS            status;

    //
    // We need to acquire only the primaryScb lock.  The only thing we will do
    // to defunctScb is adjust its reference count, and we know that the
    // filter context already holds a reference to it (unless a thread race
    // has already done this work--which we check below).
    //

    SipAcquireScb(primaryScb);

    //
    // Lookup the filter context.
    //

    fc = (PSIS_FILTER_CONTEXT) FsRtlLookupPerStreamContext(
                                        FsRtlGetPerStreamContextPointer(fileObject), 
                                        DeviceObject, 
                                        NULL);

    ASSERT(fc);

    if (!fc) {
        status = STATUS_INTERNAL_ERROR;
        goto Error;
    }

    SipAcquireFc(fc);

    if (NULL == primaryScb->PredecessorScb) {

        //
        // No other threads have beaten us to this.  Do the initialization.
        //

        ASSERT(defunctScb == fc->primaryScb);

        //
        // Switch the reference for the defunct scb from RefsFc to RefsDefunct.  Add a reference
        // from the fc to the new scb, and from the new scb to the defunct one.
        //

        SipReferenceScb(defunctScb, RefsPredecessorScb);
        SipDereferenceScb(defunctScb, RefsFc);

        SipTransferScbReferenceType(primaryScb, RefsLookedUp, RefsFc);
        primaryScb->PredecessorScb = defunctScb;

        fc->primaryScb = primaryScb;

    } else {
		SipDereferenceScb(primaryScb, RefsLookedUp);
	}

    ASSERT(defunctScb == primaryScb->PredecessorScb);

    SipReleaseFc(fc);

    status = STATUS_SUCCESS;

Error:
    SipReleaseScb(primaryScb);

    return status;
}

NTSTATUS
SipAcquireUFO(
    IN PSIS_CS_FILE                     CSFile
    )
{
    NTSTATUS status;

    //
    // Caller better be at APC_LEVEL or have APCs blocked or be in a system thread.
    //

    ASSERT((KeGetCurrentIrql() == APC_LEVEL) ||
        (PsIsSystemThread(PsGetCurrentThread())) ||
        KeAreApcsDisabled());

    status = KeWaitForSingleObject(
                    CSFile->UFOMutant,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL);

    ASSERT((status == STATUS_SUCCESS) || (status == STATUS_ABANDONED));
    if ((status != STATUS_SUCCESS) && (status != STATUS_ABANDONED)) {

        return status;
    }

    return STATUS_SUCCESS;
}

VOID
SipReleaseUFO(
    IN PSIS_CS_FILE                 CSFile)
{
    //
    // We use abandon rather than just plain wait, because we're not guaranteed to be
    // in the thread that acquired the mutant.
    //
    KeReleaseMutant(CSFile->UFOMutant, IO_NO_INCREMENT, TRUE, FALSE);
}

NTSTATUS
SipAcquireCollisionLock(
    PDEVICE_EXTENSION DeviceExtension)
{
    NTSTATUS status;

    status = KeWaitForSingleObject(
                    DeviceExtension->CollisionMutex,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL);

    ASSERT((status == STATUS_SUCCESS) || (status == STATUS_ABANDONED));
    if ((status != STATUS_SUCCESS) && (status != STATUS_ABANDONED)) {

        return status;
    }

    return STATUS_SUCCESS;
}

VOID
SipReleaseCollisionLock(
    PDEVICE_EXTENSION DeviceExtension)
{
    KeReleaseMutex(DeviceExtension->CollisionMutex, FALSE);
}

typedef struct _SI_DEREFERENCE_OBJECT_REQUEST {
    WORK_QUEUE_ITEM         workItem[1];
    PVOID                   object;
} SI_DEREFERENCE_OBJECT_REQUEST, *PSI_DEREFERENCE_OBJECT_REQUEST;

VOID
SiPostedDereferenceObject(
    IN PVOID                parameter)
{
    PSI_DEREFERENCE_OBJECT_REQUEST request = parameter;

    ASSERT(PASSIVE_LEVEL == KeGetCurrentIrql());

    ObDereferenceObject(request->object);

    ExFreePool(request);
}

VOID
SipDereferenceObject(
    IN PVOID                object)
/*++

Routine Description:

    This is just like ObDereferenceObject except that it can be called at
    Irql <= DISPATCH_LEVEL.

Arguments:

    object - the object to dereference

Return Value:

    void

--*/
{
    KIRQL       Irql;

    Irql = KeGetCurrentIrql();
    ASSERT(Irql <= DISPATCH_LEVEL);

    if (Irql == PASSIVE_LEVEL) {
        //
        // We're already on passive level, just do it inline.
        //
        ObDereferenceObject(object);
    } else {
        //
        // The DDK doc says that you can't call ObDereferenceObject at APC_LEVEL, so we'll
        // be safe and post those along with the DISPATCH_LEVEL calls.
        //
        PSI_DEREFERENCE_OBJECT_REQUEST  request;

        SIS_MARK_POINT_ULONG(object);

        request = ExAllocatePoolWithTag(NonPagedPool, sizeof(SI_DEREFERENCE_OBJECT_REQUEST), ' siS');
        if (NULL == request) {
            SIS_MARK_POINT();

#if     DBG
            DbgPrint("SIS: SipDereferenceObject: unable to allocate an SI_DEREFERENCE_OBJECT_REQUEST.  Dribbling object 0x0%x\n",object);
#endif  // DBG

            //
            // This is pretty bad.  Dribble the request.
            // BUGBUGBUG : This must be fixed.
            //
            return;
        }

        request->object = object;
        ExInitializeWorkItem(request->workItem, SiPostedDereferenceObject, request);
        ExQueueWorkItem(request->workItem, CriticalWorkQueue);
    }
}

BOOLEAN
SipAcquireBackpointerResource(
    IN PSIS_CS_FILE                     CSFile,
    IN BOOLEAN                          Exclusive,
    IN BOOLEAN                          Wait)
/*++

Routine Description:

    Acquire the backpointer resource for a common store file.  If not in a system thread,
    enters a critical region in order to block APCs that might suspend the thread while it's
    holding the resource.  In order to hand off the resource to a system thread, the user must
    call SipHandoffBackpointerResource.  In order to release it, call
    SipReleaseBackpointerResource.

Arguments:

    CSFile      - The common store file who's backpointer resource we wish to acquire
    Exclusive   - Do we want to acquire it exclusively or shared
    Wait        - Block or fail on a contested acquire

Return Value:

    TRUE iff the resource was acquired.

--*/
{
    BOOLEAN     result;

    if (!PsIsSystemThread(PsGetCurrentThread())) {
        KeEnterCriticalRegion();
    }

    if (Exclusive) {
        result = ExAcquireResourceExclusiveLite(CSFile->BackpointerResource,Wait);
    } else {
        result = ExAcquireResourceSharedLite(CSFile->BackpointerResource, Wait);
    }

    if (result) {

        //
        //  Since we may release this resource in another thread, change
        //  the ownership know from the current thread to the CSFile structure
        //

        ExSetResourceOwnerPointer(CSFile->BackpointerResource,
                                  (PVOID)MAKE_RESOURCE_OWNER(CSFile));
    }


    return result;
}

VOID
SipReleaseBackpointerResource(
    IN PSIS_CS_FILE                     CSFile)
{
    ExReleaseResourceForThreadLite(CSFile->BackpointerResource,
                                   MAKE_RESOURCE_OWNER(CSFile));

    if (!PsIsSystemThread(PsGetCurrentThread())) {
        KeLeaveCriticalRegion();
    }
}

VOID
SipHandoffBackpointerResource(
    IN PSIS_CS_FILE                     CSFile)
{
    UNREFERENCED_PARAMETER( CSFile );

    if (!PsIsSystemThread(PsGetCurrentThread())) {
        KeLeaveCriticalRegion();
    }
}

NTSTATUS
SipPrepareRefcountChangeAndAllocateNewPerLink(
    IN PSIS_CS_FILE             CSFile,
    IN PLARGE_INTEGER           LinkFileFileId,
    IN PDEVICE_OBJECT           DeviceObject,
    OUT PLINK_INDEX             newLinkIndex,
    OUT PSIS_PER_LINK           *perLink,
    OUT PBOOLEAN                prepared)
/*++

Routine Description:

    We want to make a new link to a common store file.  Prepare a refcount change
    on the common store file, and allocate a new link index and per link for
    the file.  Handles the bizarre error case where a "newly allocated" link index
    already has a perLink existing for it by retrying with a new link index.

Arguments:

    CSFile          - The common store file to which the new link will point

    LinkFileFileId  - The file ID for the link that's being created

    DeviceObject    - The SIS device object for this volume

    newLinkIndex    - Returns the newly allocated link index

    perLink         - Returns the newly allocated per link

    prepared        - Set iff we've prepared a refcount change when we return.
                      Always set on success, may or may not be set on failure.
                      If this is set, it is the caller's responsibility to
                      complete the refcount change.


Return Value:

    status of the request

--*/
{
    NTSTATUS        status;
    ULONG           retryCount;
    BOOLEAN         finalCopyInProgress;

    //
    // We need to do this in a retry loop in order to handle the case where
    // the "newly allocated" link index already exists in the system.  This
    // can happen when bogus reparse points get written on the volume with the
    // SIS filter disabled.  It could also happen if someone munges the MaxIndex
    // file, or because of bugs in the SIS filter.
    //
    for (retryCount = 0; retryCount < 500; retryCount++) {  //This retry count was made up
        //
        // Now, prepare a refcount change, which will allocate a link index.
        //
        status = SipPrepareCSRefcountChange(
                    CSFile,
                    newLinkIndex,
                    LinkFileFileId,
                    SIS_REFCOUNT_UPDATE_LINK_CREATED);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);

            *prepared = FALSE;
            return status;
        }

        *prepared = TRUE;

        *perLink = SipLookupPerLink(
                        newLinkIndex,
                        &CSFile->CSid,
                        LinkFileFileId,
                        &CSFile->CSFileNtfsId,
                        DeviceObject,
                        NULL,
                        &finalCopyInProgress);

        if (NULL == *perLink) {
            SIS_MARK_POINT();

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        if (CSFile == (*perLink)->CsFile) {
            //
            // This is the normal case.
            //
            break;
        }

#if     DBG
        DbgPrint("SIS: SipPrepareRefcountChangeAndAllocateNewPerLink: retrying 0x%x due to collision, %d\n",CSFile,retryCount);
#endif  // DBG

        //
        // Somehow, we got a conflict on a perLink that should have been newly allocated.
        // Back out the prepare and try again.
        //
        SipCompleteCSRefcountChange(
            NULL,
            NULL,
            CSFile,
            FALSE,
            TRUE);

        *prepared = FALSE;

        SipDereferencePerLink(*perLink);
    }

    if (NULL == *perLink) {
        //
        // This is the failure-after-retry case.  Give up.
        //
        SIS_MARK_POINT_ULONG(CSFile);

        return STATUS_DRIVER_INTERNAL_ERROR;
    }

    ASSERT(IsEqualGUID(&(*perLink)->CsFile->CSid, &CSFile->CSid));

    //
    // Since this link file doesn't even exist until now, we can't have final copy in
    // progress.
    //
    ASSERT(!finalCopyInProgress);

    return STATUS_SUCCESS;
}


#if     DBG
BOOLEAN
SipAssureNtfsIdValid(
    IN PSIS_PER_FILE_OBJECT     PerFO,
    IN OUT PSIS_PER_LINK        PerLink)
{
    NTSTATUS                    status;
    FILE_INTERNAL_INFORMATION   internalInfo[1];
    ULONG                       returnedLength;

    ASSERT(PerFO->fc->primaryScb->PerLink == PerLink);

    status = SipQueryInformationFile(
                PerFO->fileObject,
                PerLink->CsFile->DeviceObject,
                FileInternalInformation,
                sizeof(FILE_INTERNAL_INFORMATION),
                internalInfo,
                &returnedLength);

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        return FALSE;
    }

    ASSERT(status != STATUS_PENDING);
    ASSERT(returnedLength == sizeof(FILE_INTERNAL_INFORMATION));

    return internalInfo->IndexNumber.QuadPart == PerLink->LinkFileNtfsId.QuadPart;
}
#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\sis.h ===
/*++

Copyright (c) 1997, 1998	Microsoft Corporation

Module Name:

	sis.h

Abstract:

	Exported data structure definitions for the Single Instance Store.  Note: these definitions
	are only exported to other NT components (in particular sisbackup), not to external users.

Author:

	Bill Bolosky		[bolosky]		March 1998

Revision History:

--*/

typedef	GUID CSID, *PCSID;

typedef union _LINK_INDEX {
    struct {
        ULONG       LowPart;
        ULONG       HighPart : 31;
    };
    struct {
        ULONGLONG   QuadPart : 63,
                    Check    : 1;
    };
} LINK_INDEX, *PLINK_INDEX;

//
// The maximum length of the filename part of a file with an index name.  The
// filename format is <guid>.sis where ".sis" is a literal and <guid>
// is the standard striung representation of the GUID that is the common store
// id for the file with the curly braces stripped off.
//
#define	INDEX_MAX_NUMERIC_STRING_LENGTH (40 * sizeof(WCHAR)) // 36 for the guid (without "{}" and 4 for ".sis"

//
// Definitions for the checksum stream on a SIS file.
//
#define	BACKPOINTER_STREAM_NAME			L":sisBackpointers$"
#define	BACKPOINTER_STREAM_NAME_SIZE	(17 * sizeof(WCHAR))

//
// A backpointer entry, mapping LinkFileIndex -> LinkFileNtfsId.
//
typedef struct _SIS_BACKPOINTER {
	LINK_INDEX							LinkFileIndex;

	LARGE_INTEGER						LinkFileNtfsId;
} SIS_BACKPOINTER, *PSIS_BACKPOINTER;

#define	SIS_BACKPOINTER_RESERVED_ENTRIES	1		// # entries in the first sector reserved for other junk

//
// The header that fits in the space saved by "SIS_BACKPOINTER_RESERVED_ENTRIES" at the
// beginning of each backpointer stream.
//
typedef struct _SIS_BACKPOINTER_STREAM_HEADER {
	//
	// The format of the backpointer stream.  Incremented when we change this or
	// SIS_BACKPOINTER.
	//
	ULONG								FormatVersion;

	//
	// A magic number to identify that this is really what we think it is.
	//
	ULONG								Magic;

	//
	// A checksum of the contents of the file; used to verify that reparse
	// points are valid.
	//
	LONGLONG							FileContentChecksum;
} SIS_BACKPOINTER_STREAM_HEADER, *PSIS_BACKPOINTER_STREAM_HEADER;

#define	BACKPOINTER_STREAM_FORMAT_VERSION	1
#define	BACKPOINTER_MAGIC					0xf1ebf00d

#if 0
//
// Version 1 of the SIS reparse point buffer.
//
typedef struct _SI_REPARSE_BUFFER_V1 {
	//
	// A version number so that we can change the reparse point format
	// and still properly handle old ones.  This structure describes
	// version 1.
	//
	ULONG							ReparsePointFormatVersion;

	//
	// The index of the common store file.
	//
	CSINDEX							CSIndex;

	//
	// The index of this link file.
	//
	CSINDEX							LinkIndex;
} SI_REPARSE_BUFFER_V1, *PSI_REPARSE_BUFFER_V1;

//
// Version 2 of the SIS reparse point buffer.
//
typedef struct _SI_REPARSE_BUFFER_V2 {

	//
	// A version number so that we can change the reparse point format
	// and still properly handle old ones.  This structure describes
	// version 2.
	//
	ULONG							ReparsePointFormatVersion;

	//
	// The index of the common store file.
	//
	CSINDEX							CSIndex;

	//
	// The index of this link file.
	//
	CSINDEX							LinkIndex;

    //
    // The file ID of the link file.
    //
    LARGE_INTEGER                   LinkFileNtfsId;

    //
    // A "131 hash" checksum of this structure.
    // N.B.  Must be last.
    //
    LARGE_INTEGER                   Checksum;

} SI_REPARSE_BUFFER_V2, *PSI_REPARSE_BUFFER_V2;

//
// Version 3 of the SIS reparse point buffer.
//
typedef struct _SI_REPARSE_BUFFER_V3 {

	//
	// A version number so that we can change the reparse point format
	// and still properly handle old ones.  This structure describes
	// version 3.
	//
	ULONG							ReparsePointFormatVersion;

	//
	// The index of the common store file.
	//
	CSINDEX							CSIndex;

	//
	// The index of this link file.
	//
	CSINDEX							LinkIndex;

    //
    // The file ID of the link file.
    //
    LARGE_INTEGER                   LinkFileNtfsId;

    //
    // The file ID of the common store file.
    //
    LARGE_INTEGER                   CSFileNtfsId;

    //
    // A "131 hash" checksum of this structure.
    // N.B.  Must be last.
    //
    LARGE_INTEGER                   Checksum;

} SI_REPARSE_BUFFER_V3, *PSI_REPARSE_BUFFER_V3;
#endif

//
// Version 4 and version 5 of the reparse point buffer are
// identical in structure.  The only difference is that version
// 5 reparse points were created after the problems with
// allocated ranges in the source files of small copies was fixed,
// and so are eligible for partial final copy.  Version 4 files
// are not.
//

//
// The bits that are actually in a SIS reparse point.  Version 5.
//
typedef struct _SI_REPARSE_BUFFER {

	//
	// A version number so that we can change the reparse point format
	// and still properly handle old ones.  This structure describes
	// version 4.
	//
	ULONG							ReparsePointFormatVersion;

	ULONG							Reserved;

	//
	// The id of the common store file.
	//
	CSID							CSid;

	//
	// The index of this link file.
	//
	LINK_INDEX						LinkIndex;

    //
    // The file ID of the link file.
    //
    LARGE_INTEGER                   LinkFileNtfsId;

    //
    // The file ID of the common store file.
    //
    LARGE_INTEGER                   CSFileNtfsId;

	//
	// A "131 hash" checksum of the contents of the
	// common store file.
	//
	LONGLONG						CSChecksum;

    //
    // A "131 hash" checksum of this structure.
    // N.B.  Must be last.
    //
    LARGE_INTEGER                   Checksum;

} SI_REPARSE_BUFFER, *PSI_REPARSE_BUFFER;

#define	SIS_REPARSE_BUFFER_FORMAT_VERSION			5
#define	SIS_MAX_REPARSE_DATA_VALUE_LENGTH (sizeof(SI_REPARSE_BUFFER))
#define SIS_REPARSE_DATA_SIZE (FIELD_OFFSET(REPARSE_DATA_BUFFER,GenericReparseBuffer)+SIS_MAX_REPARSE_DATA_VALUE_LENGTH)

#define SIS_CSDIR_STRING            		L"\\SIS Common Store\\"
#define SIS_CSDIR_STRING_NCHARS     		18
#define SIS_CSDIR_STRING_SIZE       		(SIS_CSDIR_STRING_NCHARS * sizeof(WCHAR))

#define	SIS_GROVELER_FILE_STRING			L"GrovelerFile"
#define	SIS_GROVELER_FILE_STRING_NCHARS		12
#define	SIS_GROVELER_FILE_STRING_SIZE		(SIS_GROVELER_FILE_STRING_NCHARS * sizeof(WCHAR))

#define	SIS_VOLCHECK_FILE_STRING			L"VolumeCheck"
#define	SIS_VOLCHECK_FILE_STRING_NCHARS		11
#define	SIS_VOLCHECK_FILE_STRING_SIZE		(SIS_VOLCHECK_FILE_STRING_NCHARS * sizeof(WCHAR))

typedef struct _SIS_LINK_FILES {
	ULONG					operation;
	union {
			struct {
				HANDLE			file1;
				HANDLE			file2;
				HANDLE			abortEvent;
			} Merge;

			struct {
				HANDLE			file1;
				HANDLE			abortEvent;
				CSID			CSid;
			} MergeWithCS;

			struct {
				CSID			CSid;
			} HintNoRefs;

			struct {
				HANDLE			file;
			} VerifyNoMap;
	} u;
} SIS_LINK_FILES, *PSIS_LINK_FILES;


#define	SIS_LINK_FILES_OP_MERGE				0xb0000001
#define	SIS_LINK_FILES_OP_MERGE_CS			0xb0000002
#define	SIS_LINK_FILES_OP_HINT_NO_REFS		0xb0000003
#define	SIS_LINK_FILES_OP_VERIFY_NO_MAP		0xb0000004
#define	SIS_LINK_FILES_CHECK_VOLUME			0xb0000005

#define	LOG_FILE_NAME		L"LogFile"
#define	LOG_FILE_NAME_LEN	(7 * sizeof(WCHAR))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\silock.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    silock.c

Abstract:

	File locking routines for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SiLockControl)
#endif

NTSTATUS
SiCompleteLockIrpRoutine(
	IN PVOID				Context,
	IN PIRP					Irp)
/*++

Routine Description:

	FsRtl has decided to complete a lock request irp.  We don't want to really
	complete the irp because we're going to send it to NTFS to set up the parallel
	lock structure.  So, we use this routine as the "CompleteLockIrp" routine for
	fsrtl, and then we don't really complete the irp.

Arguments:
	Context			- our context parameter (unused)

	irp				- the create irp, which contains the create request in the
					  current stack location.

Return Value:

	the status from the irp

--*/
{
	UNREFERENCED_PARAMETER(Context);

	return Irp->IoStatus.Status;
}

NTSTATUS
SiLockControl(
    IN PDEVICE_OBJECT 		DeviceObject,
    IN PIRP 				Irp)
{
	NTSTATUS				status;
	PSIS_SCB				scb;
	PIO_STACK_LOCATION		irpSp = IoGetCurrentIrpStackLocation(Irp);
	PFILE_OBJECT			fileObject = irpSp->FileObject;
	PSIS_PER_FILE_OBJECT	perFO;
	PDEVICE_EXTENSION		deviceExtension = DeviceObject->DeviceExtension;

	PAGED_CODE();

	SipHandleControlDeviceObject(DeviceObject, Irp);

	if (!SipIsFileObjectSIS(fileObject,DeviceObject,FindActive,&perFO,&scb)) {
		SipDirectPassThroughAndReturn(DeviceObject, Irp);
	}

	SIS_MARK_POINT();

	//  Now call the FsRtl routine to do the actual processing of the
	//  Lock request
	status = FsRtlProcessFileLock( &scb->FileLock, Irp, NULL );

	//
	// Now, pass the request down on the link/copied file so that NTFS will also
	// maintain the file lock.
	//

    Irp->CurrentLocation++;
    Irp->Tail.Overlay.CurrentStackLocation++;
	
    return IoCallDriver( deviceExtension->AttachedToDeviceObject, Irp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\silog.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    silog.c

Abstract:

	Logging support for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

#ifdef	ALLOC_PRAGMA
#pragma alloc_text(PAGE, SipComputeChecksum)
#pragma alloc_text(PAGE, SipDrainLogFile)
#endif	// ALLOC_PRAGMA



#if	DBG
VOID
SipDBGDumpLogRecord(
	PSIS_LOG_HEADER			header)
{
    DbgPrint("log record: type %d, size %d, index 0x%x.0x%x\n",
				header->Type,
				header->Size,
				header->Index.HighPart,
				header->Index.LowPart);

	switch (header->Type) {
	}
}
#endif	// DBG

NTSTATUS
SipMakeLogEntry(
	IN OUT PDEVICE_EXTENSION			deviceExtension,
	IN USHORT							type,
	IN USHORT							size,
	IN PVOID							record)
/*++

Routine Description:

	Make an entry in the SIS log.  Creates the header, computes the
	checksum and then writes the log entry to the log file for this
	volume.  A successful return guarantees that the log record is
	flushed to disk.  This routine blocks.

Arguments:

	deviceExtension - the device extension for the volume onto which we're
		logging.

	type - the type of the record we're writing.

	size - the size of the record we're writing (not counting the header)

	record - the log record data to write to the file.

Return Value:

	Returns STATUS_SUCCESS or an error returned from the actual disk write.
--*/
{
#if		ENABLE_LOGGING
    PSIS_LOG_HEADER						header = NULL;
	NTSTATUS							status;
	PIRP								irp;
	KEVENT								event[1];
	PIO_STACK_LOCATION					irpSp;
	BOOLEAN								mutantAcquired = FALSE;
	IO_STATUS_BLOCK						Iosb[1];


	if (deviceExtension->LogFileHandle == NULL) {
		SIS_MARK_POINT();
		return STATUS_DRIVER_INTERNAL_ERROR;
	}

	header = ExAllocatePoolWithTag(PagedPool, size + sizeof(SIS_LOG_HEADER), ' siS');

	if (!header) {
		SIS_MARK_POINT();
		status =  STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}

	ASSERT(size % 4 == 0);	// The log drain code relies on this

	header->Magic = SIS_LOG_HEADER_MAGIC;
	header->Type = type;
	header->Size = size + sizeof(SIS_LOG_HEADER);

	status = SipAllocateIndex(deviceExtension, &header->Index);
	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		return status;
	}

	//
	// Copy the log record into the newly alloated header+record area.
	//
	RtlMoveMemory(header + 1, record, size);

	//
	// Compute the checksum.  We need to set the checksum field in the header
	// to 0 before we do the computation so that whatever's there isn't
	// part of the checksum (and then overwritten with the real checksum).
	//
	header->Checksum.QuadPart = 0;
	SipComputeChecksum(header, header->Size, &header->Checksum.QuadPart);

	//
	// Acquire the log mutant to serialize writing to the log file.
	//

	status = KeWaitForSingleObject(deviceExtension->LogFileMutant, Executive, KernelMode, FALSE, NULL);
	ASSERT(status == STATUS_SUCCESS);
	mutantAcquired = TRUE;

	ASSERT(deviceExtension->LogFileHandle != NULL && deviceExtension->LogFileObject != NULL);	// Should have happened in phase 2 initialization

	//
	// Create an irp to do the write.  We don't want to just use ZwWriteFile because we want to
	// avoid the context switch to the process where we hold the log handle.
	//

	irp = IoBuildAsynchronousFsdRequest(
				IRP_MJ_WRITE,
				deviceExtension->FileSystemDeviceObject,
				header,
				header->Size,
				&deviceExtension->LogWriteOffset,
				Iosb);

	if (!irp) {
		SIS_MARK_POINT();
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}

	irpSp = IoGetNextIrpStackLocation(irp);
	irpSp->FileObject = deviceExtension->LogFileObject;

	//
	// Initialize the event on which we'll wait for the write to complete.
	//
	KeInitializeEvent(event,NotificationEvent,FALSE);

	IoSetCompletionRoutine(
			irp, 
			SiDeleteAndSetCompletion,
			event,
			TRUE, 
			TRUE, 
			TRUE);

	//
	// Make sure that this request is really write through all the way to the disk
	// medium.
	//
	irpSp->Flags |= SL_WRITE_THROUGH;


	status = IoCallDriver(deviceExtension->FileSystemDeviceObject, irp);

	// At this point, we have released the mutant in the complete
	// routine.

#if		DBG
	irp = NULL; irpSp = NULL;  // The completion routine may have already deallocated the irp.
#endif	// DBG

	if (STATUS_PENDING == status) {
		status = KeWaitForSingleObject(event,Executive,KernelMode,FALSE,NULL);
		ASSERT(status == STATUS_SUCCESS);
		status = Iosb->Status;
	}

	if (!NT_SUCCESS(status)) {
#if		DBG
		DbgPrint("SiMakeLogEntry: Log entry failed after write wait, 0x%x\n",status);
#endif	// DBG
		SIS_MARK_POINT_ULONG(status);
		goto done;
	} else {
		ASSERT(Iosb->Information == header->Size);
		deviceExtension->LogWriteOffset.QuadPart += header->Size;
	}

done:
	if (header != NULL) {
		ExFreePool(header);
	}

	if (mutantAcquired) {
		KeReleaseMutant(
				deviceExtension->LogFileMutant,
				IO_NO_INCREMENT,
				FALSE,
				FALSE);
	}

	return status;
#else	// ENABLE_LOGGING
    UNREFERENCED_PARAMETER( deviceExtension );
    UNREFERENCED_PARAMETER( type );
    UNREFERENCED_PARAMETER( size );
    UNREFERENCED_PARAMETER( record );

	return STATUS_SUCCESS;
#endif	// ENABLE_LOGGING
}
	
VOID
SipComputeChecksum(
	IN PVOID							buffer,
	IN ULONG							size,
	IN OUT PLONGLONG					checksum)
/*++

Routine Description:

	Compute a checksum for a buffer.  We use the "131 hash," which
	work by keeping a 64 bit running total, and for each 32 bits of
	data multiplying the 64 bits by 131 and adding in the next 32
	bits.  Must be called at PASSIVE_LEVEL, and all aruments
	may be pagable.

Arguments:

	buffer - pointer to the data to be checksummed

	size - size of the data to be checksummed

	checksum - pointer to large integer to receive the checksum.  This
		may be within the buffer, and SipComputeChecksum guarantees that
		the initial value will be used in computing the checksum.

Return Value:

	void
--*/
{
	LONGLONG runningTotal;
	ULONG *ptr = (unsigned *)buffer;
	ULONG bytesRemaining = size;

	PAGED_CODE();

	//
	// NB: code in volume check assumes that the checksum of the empty bit string is
	// 0.  If this is ceases to be true, be sure to fix the code there.
	//

	runningTotal = *checksum;

	while (bytesRemaining >= sizeof(*ptr)) {
		runningTotal = runningTotal * 131 + *ptr;
		bytesRemaining -= sizeof(*ptr);
		ptr++;
	}

	if (bytesRemaining > 0) {
		ULONG extra;

		ASSERT(bytesRemaining < sizeof (ULONG));
		extra = 0;
		RtlMoveMemory(&extra, ptr, bytesRemaining);
		
		runningTotal = runningTotal * 131 + extra;
	}

	*checksum = runningTotal;
}

NTSTATUS
SipOpenLogFile(
	IN OUT PDEVICE_EXTENSION			deviceExtension)
/*++

Routine Description:

	Open the log file for this volume.  Must not already be opened.  Must be called
	exactly once per volume, and must be called on a worker thread.

Arguments:

	deviceExtension - the device extension for the volume for which we're
		to open the log file.

Return Value:

	Returns status of the open.
--*/
{
#if		ENABLE_LOGGING
	NTSTATUS 					status;
	OBJECT_ATTRIBUTES			Obja[1];
	UNICODE_STRING				fileName;
	IO_STATUS_BLOCK				Iosb[1];

	SIS_MARK_POINT();

	ASSERT(deviceExtension->LogFileHandle == NULL);
	ASSERT(deviceExtension->LogFileObject == NULL);

	fileName.Length = 0;
	fileName.MaximumLength = deviceExtension->CommonStorePathname.Length + LOG_FILE_NAME_LEN;
	fileName.Buffer = ExAllocatePoolWithTag(PagedPool, fileName.MaximumLength, ' siS');

	if (!fileName.Buffer) {
#if		DBG
		DbgPrint("SIS: SipOpenLogFile: unable to allocate filename buffer.  We're toast.\n");
#endif	// DBG

		SIS_MARK_POINT();

		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}

	RtlCopyUnicodeString(
		&fileName,
		&deviceExtension->CommonStorePathname);

	ASSERT(fileName.Length == deviceExtension->CommonStorePathname.Length);

	status = RtlAppendUnicodeToString(
					&fileName,
					LOG_FILE_NAME);

	ASSERT(status == STATUS_SUCCESS);
	ASSERT(fileName.Length == deviceExtension->CommonStorePathname.Length + LOG_FILE_NAME_LEN);	// or else you changed LOG_FILE_NAME without changing LOG_FILE_NAME_LEN

	InitializeObjectAttributes(
		Obja,
		&fileName,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL);

	status = NtCreateFile(
				&deviceExtension->LogFileHandle,
				GENERIC_READ | GENERIC_WRITE,
				Obja,
				Iosb,
				NULL,								// allocation size
				FILE_ATTRIBUTE_NORMAL,
				FILE_SHARE_READ,					// share access
				FILE_OPEN_IF,
				FILE_WRITE_THROUGH,
				NULL,								// EA buffer
				0);									// EA length

	if (!NT_SUCCESS(status)) {
#if	DBG
		DbgPrint("SipOpenLogFile: ZwCreate failed, 0x%x\n",status);
#endif	// DBG
		SIS_MARK_POINT_ULONG(status);
		goto done;
	} else {
		status = ObReferenceObjectByHandle(
					deviceExtension->LogFileHandle,
					FILE_READ_DATA | FILE_WRITE_DATA,
					*IoFileObjectType,
					KernelMode,
					&deviceExtension->LogFileObject,
					NULL);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
#if		DBG
			DbgPrint("SipOpenLogFile: ObReferenceObjectByHandle failed, 0x%x\n",status);
#endif	// DBG

			NtClose(deviceExtension->LogFileHandle);
			deviceExtension->LogFileHandle = NULL;
			goto done;
		}
	}


	SipDrainLogFile(deviceExtension);

	SIS_MARK_POINT();

done:

	if (fileName.Buffer) {
		ExFreePool(fileName.Buffer);
#if		DBG
		fileName.Buffer = NULL;
#endif	// DBG
	}
	
	return status;

#undef	LOG_FILE_NAME
#undef	LOG_FILE_NAME_LEN
#else	// ENABLE_LOGGING

    UNREFERENCED_PARAMETER( deviceExtension );
	return STATUS_SUCCESS;
#endif	// ENABLE_LOGGING
}

VOID
SipDrainLogFile(
	PDEVICE_EXTENSION					deviceExtension)
/*++

Routine Description:

	Drain the log file for this volume and assure that all of the operations in it
	have happened or not happened atomically.

Arguments:

	deviceExtension - the device extension for the volume for which we're
		to drain the log file.

Return Value:

	VOID
--*/
{
#if		ENABLE_LOGGING
	FILE_ALLOCATED_RANGE_BUFFER		inArb[1];
	FILE_ALLOCATED_RANGE_BUFFER		outArb[1];
	NTSTATUS						status;
	HANDLE							eventHandle = NULL;
	PKEVENT							event = NULL;
	IO_STATUS_BLOCK					Iosb[1];
	LARGE_INTEGER					fileOffset;
	PCHAR							buffer = NULL;
#define	BUFFER_SIZE	16384
	PULONG							bufferPointer;
	PSIS_LOG_HEADER					logHeader;
	LARGE_INTEGER					stashedChecksum, computedChecksum;
	BOOLEAN							clearLog = FALSE;

	PAGED_CODE();

	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	buffer = ExAllocatePoolWithTag(PagedPool, BUFFER_SIZE, ' siS');

	if (NULL == buffer) {
		SIS_MARK_POINT();
		goto done;
	}

	status = SipCreateEvent(
				NotificationEvent,
				&eventHandle,
				&event);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto done;
	}

#if		DBG
	deviceExtension->LogWriteOffset.QuadPart = -1;
#endif	// DBG

	//
	// Figure out where the log file starts.
	//
	inArb->FileOffset.QuadPart = 0;
	inArb->Length.QuadPart = MAXLONGLONG;

	status = NtFsControlFile(
				deviceExtension->LogFileHandle,
				eventHandle,
				NULL,							// APC routine
				NULL,							// ApcContext
				Iosb,
				FSCTL_QUERY_ALLOCATED_RANGES,
				inArb,
				sizeof(FILE_ALLOCATED_RANGE_BUFFER),
				outArb,
				sizeof(FILE_ALLOCATED_RANGE_BUFFER));

	if (STATUS_PENDING == status) {
		status = KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);
		ASSERT(STATUS_SUCCESS == status);	// must succeed because Iosb is on the stack
		status = Iosb->Status;
	}

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		clearLog = TRUE;
		goto done;
	}

	if (0 == Iosb->Information) {
		//
		// The file is empty.  We're done.
		//
		SIS_MARK_POINT_ULONG(deviceExtension);
		clearLog = TRUE;
		goto done;
	}

	//
	// Skip over any leading unallocated range, starting at the beginning of the first allocated range.
	//
	fileOffset = outArb->FileOffset;

	//
	// Find the first log entry by searching for the first occurance of the magic number.
	//

	for (;;) {

		KeClearEvent(event);
	
		status = ZwReadFile(
					deviceExtension->LogFileHandle,
					eventHandle,
					NULL,							// APC routine
					NULL,							// APC context
					Iosb,
					buffer,
					BUFFER_SIZE,
					&fileOffset,
					NULL);							// key

		if (STATUS_PENDING == status) {
			status = KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);
			ASSERT(STATUS_SUCCESS == status);	// must succeed because Iosb is on the stack
			status = Iosb->Status;
		}

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			clearLog = TRUE;
			goto done;
		}

		if (0 == Iosb->Information) {
			SIS_MARK_POINT();
			clearLog = TRUE;
			goto done;
		}

		//
		// Cruise through the buffer looking for the magic number
		//
		for (bufferPointer = (PULONG)buffer; bufferPointer < ((PULONG)buffer) + BUFFER_SIZE/sizeof(ULONG); bufferPointer++) {
			if (SIS_LOG_HEADER_MAGIC == *bufferPointer) {
				fileOffset.QuadPart += (bufferPointer - ((PULONG)buffer)) * sizeof(ULONG);
				goto startLogReading;
			}
		}

		//
		// We didn't find it, read in the next chunk.
		//

		fileOffset.QuadPart += BUFFER_SIZE;
	}

startLogReading:

	for (;;) {
		KeClearEvent(event);

		status = ZwReadFile(
					deviceExtension->LogFileHandle,
					eventHandle,
					NULL,							// APC routine
					NULL,							// APC context
					Iosb,
					buffer,
					BUFFER_SIZE,
					&fileOffset,
					NULL);							// key

		if (STATUS_PENDING == status) {
			status = KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);
			ASSERT(STATUS_SUCCESS == status);	// must succeed because Iosb is on the stack
			status = Iosb->Status;
		}

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			deviceExtension->LogWriteOffset = fileOffset;
			goto done;
		}

		if (0 == Iosb->Information) {
			SIS_MARK_POINT();
			deviceExtension->LogWriteOffset = fileOffset;
			goto done;
		}

		ASSERT(Iosb->Information <= BUFFER_SIZE);

		logHeader = (PSIS_LOG_HEADER)buffer;

		while ((((PCHAR)logHeader) - buffer) + sizeof(SIS_LOG_HEADER) <= Iosb->Information) {
			//
			// We know that we've got enough space for the log header.  
			//

			//
			// Check the header to see if it looks valid (ie., if it's got a good magic
			// number).  
			//
			if (SIS_LOG_HEADER_MAGIC != logHeader->Magic) {
				//
				// This log record is corrupt.  Start writing the new log records here, and 
				// punt the readback.
				//
				SIS_MARK_POINT();
				deviceExtension->LogWriteOffset.QuadPart = fileOffset.QuadPart + (((PCHAR)logHeader) - buffer);
				goto done;
			}

			//
			// See if we have enough space for the whole record.
			//
			if (((ULONG)(((PCHAR)logHeader - buffer) + logHeader->Size)) > Iosb->Information) {
				if (logHeader->Size > BUFFER_SIZE) {
					//
					// The log is corrupt.  Punt reading it.
					//
					SIS_MARK_POINT();
					deviceExtension->LogWriteOffset.QuadPart = fileOffset.QuadPart + (((PCHAR)logHeader) - buffer);
					goto done;
				}

				//
				// The log record isn't contained entirely within the buffer we've read.  Advance the buffer.
				//
				break;
			}

			//
			// We've got a whole log record.  Process it.
			//

			//
			// Make sure that the log record checkum matches.  First, we have to stash the checksum out of
			// the header and then set the header space to 0, because that's what it was when the checksum
			// was computed in the first place.
			//
			stashedChecksum = logHeader->Checksum;
			logHeader->Checksum.QuadPart = 0;
			computedChecksum.QuadPart = 0;

			SipComputeChecksum(logHeader, logHeader->Size, &computedChecksum.QuadPart);

			if (computedChecksum.QuadPart != stashedChecksum.QuadPart) {
				//
				// eventlog an error.
				//
#if		DBG
				DbgPrint("SIS: SipDrainLogFile: log record checksum doesn't match, 0x%x.0x%x != 0x%x.0x%x\n",
							computedChecksum.HighPart,computedChecksum.LowPart,
							stashedChecksum.HighPart,stashedChecksum.LowPart);
#endif	// DBG
				deviceExtension->LogWriteOffset.QuadPart = fileOffset.QuadPart + (((PCHAR)logHeader) - buffer);
				goto done;
			}

			//
			// The log record looks good.  Process it.
			//
			switch (logHeader->Type) {
				case SIS_LOG_TYPE_REFCOUNT_UPDATE: {
					PSIS_LOG_REFCOUNT_UPDATE refcountLogRecord = (PSIS_LOG_REFCOUNT_UPDATE)(logHeader + 1);

					SipProcessRefcountUpdateLogRecord(deviceExtension,refcountLogRecord);

/*BJB*/				DbgPrint("SIS: SipDrainLog: RC update UT %d, LF NTFS id 0x%x.0x%x, LI 0x%x.0x%x, CSid <whatever>\n",
								refcountLogRecord->UpdateType,refcountLogRecord->LinkFileNtfsId.HighPart,
								refcountLogRecord->LinkFileNtfsId.LowPart,refcountLogRecord->LinkIndex.HighPart,
								refcountLogRecord->LinkIndex.LowPart);

					break;
				}

				default: {
#if		DBG
					DbgPrint("SIS: SipDrainLog: Unknown log record type %d, ignoring.\n",logHeader->Type);
#endif	// DBG
					break;
				}
			}

			logHeader = (PSIS_LOG_HEADER)(((PCHAR)logHeader) + logHeader->Size);
		}

		//
		// Advance within the file to the beginning of the next record, loop around and reread the buffer.
		//
		fileOffset.QuadPart += ((PCHAR)logHeader) - buffer;
	}

done:

	if (clearLog) {
		SipClearLogFile(deviceExtension);
	}

	if (NULL != event) {
		ObDereferenceObject(event);
		event = NULL;
	}

	if (NULL != eventHandle) {
		NtClose(eventHandle);
		eventHandle = NULL;
	}

	if (NULL != buffer) {
		ExFreePool(buffer);
	}

	ASSERT(-1 != deviceExtension->LogWriteOffset.QuadPart);	// This should have been reset somewhere here.

#undef	BUFFER_SIZE	
#else
    UNREFERENCED_PARAMETER( deviceExtension );
#endif	// ENABLE_LOGGING
}

VOID
SipClearLogFile(
	PDEVICE_EXTENSION				deviceExtension)
/*++

Routine Description:

	Clear out the contents of the log file.  Must be called during initialization 
	when we're guaranteed to be serialized.  Also sets the log file sparse.

Arguments:

	deviceExtension - the device extension for the volume for which we're
		to clear the log file.

Return Value:

	VOID
--*/
{
#if		ENABLE_LOGGING
	FILE_END_OF_FILE_INFORMATION 		eofInfo[1];
	LARGE_INTEGER						byteOffset;
	NTSTATUS							status;
	IO_STATUS_BLOCK						Iosb[1];

	ASSERT(NULL != deviceExtension->LogFileObject);

	eofInfo->EndOfFile.QuadPart = 0;

	status = SipSetInformationFile(
				deviceExtension->LogFileObject,
				deviceExtension->DeviceObject,
				FileEndOfFileInformation,
				sizeof(FILE_END_OF_FILE_INFORMATION),
				eofInfo);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
#if		DBG
		DbgPrint("SipClearLogFile: unable to set EOF to 0, status 0x%x\n",status);
#endif	// DBG
		return;
	}

	deviceExtension->LogWriteOffset.QuadPart = 0;

	status = SipFsControlFile(
				deviceExtension->LogFileObject,
				deviceExtension->DeviceObject,
				FSCTL_SET_SPARSE,
				NULL,							// input buffer
				0,								// input buffer length
				NULL,							// output buffer
				0,								// output buffer length
				NULL);							// returned output buffer length

#if		DBG
	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		DbgPrint("SIS: SipClearLogFile: set sparse failed 0x%x\n",status);
	}
#endif	// DBG

#else
    UNREFERENCED_PARAMETER( deviceExtension );
#endif	// ENABLE_LOGGING
}

#if		ENABLE_LOGGING
VOID
SipAcquireLog(
	IN OUT PDEVICE_EXTENSION			deviceExtension)
{
	NTSTATUS status;
	status = KeWaitForSingleObject(deviceExtension->LogFileMutant, Executive, KernelMode, FALSE, NULL);
	ASSERT(status == STATUS_SUCCESS || status == STATUS_ABANDONED);
}

VOID
SipReleaseLog(
	IN OUT PDEVICE_EXTENSION			deviceExtension)
{
	KeReleaseMutant(deviceExtension->LogFileMutant, IO_NO_INCREMENT, TRUE, FALSE);
}

typedef	struct _TRIM_ENTRY {
	HANDLE				logHandle;
	LARGE_INTEGER		firstValidAddress;

	struct _TRIM_ENTRY	*next;
} TRIM_ENTRY, *PTRIM_ENTRY;

HANDLE		trimEventHandle = NULL;
PKEVENT		trimEvent = NULL;
#endif	// ENABLE_LOGGING

VOID
SiTrimLogs(
	IN PVOID			parameter)
/*++

Routine Description:

	Run through the list of SIS volumes on this system, and trim the log files
	for each of them.  This function should be called with a period greater than
	the longest time we expect log entries to be meaningful.

	Note: this routine is NOT thread safe; it can only be called once at a time.
	Since it reschedules itself, this should not be an issue.

Arguments:

	the parameter is ignored

Return Value:

	none
--*/
{
#if		ENABLE_LOGGING
	KIRQL							OldIrql;
	PTRIM_ENTRY						trimEntries = NULL;
	PDEVICE_EXTENSION				deviceExtension;
	NTSTATUS						status;
	FILE_ZERO_DATA_INFORMATION		zeroDataInfo[1];
	IO_STATUS_BLOCK					Iosb[1];
	LARGE_INTEGER					dueTime;

	UNREFERENCED_PARAMETER(parameter);

	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	SIS_MARK_POINT();

	if (NULL == trimEventHandle) {
		status = SipCreateEvent(
					SynchronizationEvent,
					&trimEventHandle,
					&trimEvent);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
#if		DBG
			DbgPrint("SIS: SipTrimLogs: can't allocate event, 0x%x\n",status);
#endif	// DBG
			goto done;
		}
	}

	//
	// First cruise the device extensions and build up a list of trim entries for them.
	// We need to do it this way (rather than running the list of device extensions directly)
	// because we need to handle the case where a volume is dismounted while we're in progress.
	// If it happens, then we'll have an invalid LogFileHandle, which will cause an error return
	// from the fsctl, which we'll ignore.
	//

	KeAcquireSpinLock(deviceExtensionListLock, &OldIrql);

	for (deviceExtension = deviceExtensionListHead->Next;
		 deviceExtension != deviceExtensionListHead;
		 deviceExtension = deviceExtension->Next) {

		if (deviceExtension->Phase2InitializationComplete && (NULL != deviceExtension->LogFileHandle)) {
			//
			// This is a device with a log file.  Make a new trim entry for it.
			//
			PTRIM_ENTRY	newEntry = ExAllocatePoolWithTag(NonPagedPool, sizeof(TRIM_ENTRY), ' siS');
			if (NULL == newEntry) {
				//
				// Just punt the rest of the volumes.
				//
				break;
			}

			newEntry->next = trimEntries;
			trimEntries = newEntry;

			newEntry->firstValidAddress = deviceExtension->PreviousLogWriteOffset;
			newEntry->logHandle = deviceExtension->LogFileHandle;

			//
			// Now update the device extension so that we'll trim to the current pointer on the
			// next pass.
			//
			deviceExtension->PreviousLogWriteOffset = deviceExtension->LogWriteOffset;
		}
	}

	KeReleaseSpinLock(deviceExtensionListLock, OldIrql);

	//
	// Now we're back at PASSIVE_LEVEL.  Cruise the trim entries and truncate each log file as appropriate.
	//
	zeroDataInfo->FileOffset.QuadPart = 0;

	while (NULL != trimEntries) {
		PTRIM_ENTRY	thisEntry;

#if		DBG
	if (BJBDebug & 0x20000) {
		DbgPrint("SIS: SipTrimLogs: trimming log with LFH 0x%x.\n",trimEntries->logHandle);
	}
#endif	// DBG

		zeroDataInfo->BeyondFinalZero = trimEntries->firstValidAddress;

		status = ZwFsControlFile(
					trimEntries->logHandle,
					trimEventHandle,
					NULL,							// APC routine
					NULL,							// APC context
					Iosb,
					FSCTL_SET_ZERO_DATA,
					zeroDataInfo,
					sizeof(FILE_ZERO_DATA_INFORMATION),
					NULL,
					0);

		if (STATUS_PENDING == status) {
			status = KeWaitForSingleObject(trimEvent, Executive, KernelMode, FALSE, NULL);
			ASSERT(STATUS_SUCCESS == status);		// Iosb is on the stack, so we can't let this fail
			status = Iosb->Status;
		}

#if		DBG
		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			DbgPrint("SIS: SipTrimLogs: FSCTL_ZERO_DATA failed, 0x%x\n",status);
		}
#endif	// DBG

		thisEntry = trimEntries;
		trimEntries = thisEntry->next;

		ExFreePool(thisEntry);
	}

	//
	// We've trimmed every log file in the system.  Rechedule ourselves.
	//

done:

	dueTime.QuadPart = LOG_TRIM_TIMER_INTERVAL;

	KeSetTimerEx(
		LogTrimTimer,
		dueTime,
		0,
		LogTrimDpc);

	return;

#else	// ENABLE_LOGGING

    UNREFERENCED_PARAMETER( parameter );
#endif	// ENABLE_LOGGING
}

VOID
SiLogTrimDpcRoutine(
	IN PKDPC		dpc,
	IN PVOID		context,
	IN PVOID		systemArg1,
	IN PVOID		systemArg2)
{
#if		ENABLE_LOGGING
	ExQueueWorkItem(LogTrimWorkItem,DelayedWorkQueue);

#if		DBG
	if (BJBDebug & 0x20000) {
		DbgPrint("SIS: LogTrimDpcRoutine: queued up log trim.\n");
	}
#endif	// DBG

#else	// ENABLE_LOGGING
    UNREFERENCED_PARAMETER( dpc );
    UNREFERENCED_PARAMETER( context );
    UNREFERENCED_PARAMETER( systemArg1 );
    UNREFERENCED_PARAMETER( systemArg2 );
#endif	// ENABLE_LOGGING
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\sip.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    sip.h

Abstract:

    Private data structure definitions for the Single Instance Store.

Author:

    Bill Bolosky        [bolosky]       July 1997

Revision History:

--*/

#ifndef     _SIp_
#define     _SIp_


#include "ntifs.h"
#include "ntdddisk.h"
#include "ntddscsi.h"
#include "ntiologc.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#include "sis.h"

//
//  Enable these warnings in the code.
//

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4101)   // Unreferenced local variable

//
//  Debug definitions
//

#define ENABLE_LOGGING                  0   // enable support for transaction logging and failure recovery
#define ENABLE_PARTIAL_FINAL_COPY       0   // enable copying out only into allocated ranges
#define INTERRUPTABLE_FINAL_COPY        1   // allow final copies (in cow.c) to stop in progress
#define TIMING                          0   // timing instrumentation (should be off in most builds)
#define RANDOMLY_FAILING_MALLOC         0   // debugging code to test what happens when ExAllocatePool fails randomly (off in most builds)
#define COUNTING_MALLOC                 0   // debugging code to track dynamic memory usage (off in most builds)


#ifndef INLINE
#define INLINE __inline
#endif


//
// this is a COPY of ntfs\nodetype.h data. this MUST be cleaned up
// NTRAID#65193-2000/03/10-nealch  Remove NTFS_NTC_SCB_DATA definition
//
#define NTFS_NTC_SCB_DATA   ((CSHORT)0x0705)

//
// Memory Pool tags used by SIS.
//

// BsiS -   BreakEvent in a perFO
// CsiS -   CSFile objects
// FsiS -   per file object
// LsiS -   per link objects
// SsiS -   SCB

#define SIS_POOL_TAG    ' siS'          // anything else


//
//  Local name buffer size (in WCHAR's)
//

#define MAX_DEVNAME_LENGTH  256


//
//  Our local DbgPrintEx() filter flag values
//

#define DPFLTR_VOLNAME_TRACE_LEVEL      31  //  trace volume name
#define DPFLTR_FSCONTROL_TRACE_LEVEL    30  //  trace FSCONTROL's   (0x00000400)
#define DPFLTR_DISMOUNT_TRACE_LEVEL     29  //  trace DISMOUNTS     (0x08000000)

//
//  Internal debug information
//

#if     DBG
extern PVOID    BJBMagicFsContext;
extern unsigned BJBDebug;
// BJB Debug Bits       0x00000001  Print all SiClose calls
//                      0x00000002  Print all create completions
//                      0x00000004  Print when SipIsFileObjectSIS allocates a new perFO
//                      0x00000008  Intentionally fail copies of alternate streams
//                      0x00000010  Prints in siinfo
//                      0x00000020  Prints all scbs going through cleanup
//                      0x00000040  Prints all filenames coming into create
//                      0x00000080  Always fail opens as if DELETE_IN_PROGRESS
//                      0x00000100  Allow opens with bogus checksum
//                      0x00000200  Print out CS file checksum info
//                      0x00000400  Breakpoint when SiFsControl is called with an unknown control code
//                      0x00000800  Prints in copyfile
//                      0x00001000  Print all fscontrol calls
//                      0x00002000  Print stuff related to complete-if-oplocked
//                      0x00004000  Print all reads
//                      0x00008000  Print all writes
//                      0x00010000  Print setEof calls
//                      0x00020000  Print stuff in TrimLog code
//                      0x00040000  Print out unexpected cleanups
//                      0x00080000  Assert on volume check initiation
//                      0x00100000  Print newly opened dirty files
//                      0x00200000  Disable final copy (for testing purposes)
//                      0x00400000  Don't check security in LINK_FILES fsctl.
//                      0x00800000  Intentionally fail SET_REPARSE_POINT calls
//                      0x01000000  Intentionally fail final copy
//                      0x02000000  Don't Print out all intentionally failed mallocs
//                      0x04000000  Always post filter context freed callbacks
//                      0x08000000  Print on dismount actions
//                      0x10000000  Open with FILE_SHARE_WRITE attribute

//                      0x0817fa77  Value to set if you want all debug prints
#endif  // DBG


// IoFileObjectType is a data import, and hence is a pointer in this module's
// import address table referring to the actual variable in ntoskrnl.exe.
//

extern POBJECT_TYPE *IoFileObjectType;          // shouldn't this come from somewhere else??

#define GCH_MARK_POINT_STRLEN       80
#define GCH_MARK_POINT_ROLLOVER     512
extern LONG GCHEnableFastIo;
extern LONG GCHEnableMarkPoint;
extern LONG GCHMarkPointNext;
extern CHAR GCHMarkPointStrings[GCH_MARK_POINT_ROLLOVER][GCH_MARK_POINT_STRLEN];
extern KSPIN_LOCK MarkPointSpinLock[1];

#if     DBG
#define SIS_MARK_POINT()        SipMarkPoint(__FILE__, __LINE__)
#define SIS_MARK_POINT_ULONG(value) SipMarkPointUlong(__FILE__, __LINE__, (ULONG_PTR)(value));
#else
#define SIS_MARK_POINT()
#define SIS_MARK_POINT_ULONG(value)
#endif

#if     TIMING
#define SIS_TIMING_POINT_SET(n) SipTimingPoint(__FILE__, __LINE__, n)
#define SIS_TIMING_POINT()  SipTimingPoint(__FILE__, __LINE__, 0)

//
// Timimg classes.  These can be enabled and disabled dynamically.
// They must be limited to 0-31.  Class 0 is resrved for the
// "unnamed" class, and is accessed by using SIS_TIMING_POINT()
// (ie., by not specifying a class in the timing point).
//
#define SIS_TIMING_CLASS_CREATE     1
#define SIS_TIMING_CLASS_COPYFILE   2

#else   // TIMING
#define SIS_TIMING_POINT_SET(n)
#define SIS_TIMING_POINT()
#endif  // TIMING

#if     RANDOMLY_FAILING_MALLOC
#define ExAllocatePoolWithTag(poolType, size, tag)  SipRandomlyFailingExAllocatePoolWithTag((poolType),(size),(tag),__FILE__,__LINE__)

VOID *
SipRandomlyFailingExAllocatePoolWithTag(
    IN POOL_TYPE        PoolType,
    IN ULONG            NumberOfBytes,
    IN ULONG            Tag,
    IN PCHAR            File,
    IN ULONG            Line);

VOID
SipInitFailingMalloc(void);

#elif   COUNTING_MALLOC
//
// This is the definition of ExAllocatePoolWithTag for COUNTING_MALLOC and not RANDOMLY_FAILING_MALLOC.
// If both are on, the user calls RANDOMLY_FAILING_MALLOC, which in turn calls the counting malloc
// directly.
//
#define ExAllocatePoolWithTag(poolType, size, tag)  SipCountingExAllocatePoolWithTag((poolType),(size),(tag), __FILE__, __LINE__)
#endif  // RANDOMLY_FAILING_MALLOC / COUNTING_MALLOC

#if     COUNTING_MALLOC
#define ExFreePool(p) SipCountingExFreePool((p))

VOID *
SipCountingExAllocatePoolWithTag(
    IN POOL_TYPE        PoolType,
    IN ULONG            NumberOfBytes,
    IN ULONG            Tag,
    IN PCHAR            File,
    IN ULONG            Line);

VOID
SipCountingExFreePool(
    PVOID               p);

VOID
SipInitCountingMalloc(void);

VOID
SipDumpCountingMallocStats(void);
#endif  // COUNTING_MALLOC

#if DBG

#undef ASSERT
#undef ASSERTMSG

VOID
SipAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define ASSERT( exp ) \
    ((!(exp)) ? SipAssert( #exp, __FILE__, __LINE__, NULL ) : ((void)0))

#define ASSERTMSG( msg, exp ) \
    ((!(exp)) ? SipAssert( #exp, __FILE__, __LINE__, msg ) : ((void)0))

#endif // DBG

#ifndef IsEqualGUID
#define IsEqualGUID(guid1, guid2) (!memcmp((guid1),(guid2), sizeof(GUID)))
#endif  // IsEqualGUID


//
//  Used to change ownership of a resource
//

#define MAKE_RESOURCE_OWNER(X) (((ERESOURCE_THREAD)(X)) | 0x3)


extern PDRIVER_OBJECT FsDriverObject;
extern PDEVICE_OBJECT FsNtfsDeviceObject;
extern PDEVICE_OBJECT SisControlDeviceObject;

//
// Splay tree support.
//

//
//  The comparison function takes as input a pointer to a user defined
//  key structure, and a pointer to a tree node.  It returns the results
//  of comparing the key and the node.
//

typedef
LONG
(NTAPI *PSIS_TREE_COMPARE_ROUTINE) (
    PVOID Key,
    PVOID Node
    );

typedef struct _SIS_TREE {

    PRTL_SPLAY_LINKS            TreeRoot;
    PSIS_TREE_COMPARE_ROUTINE   CompareRoutine;

} SIS_TREE, *PSIS_TREE;

//
// Define the device extension structure for this driver's extensions.
//

typedef struct _DEVICE_EXTENSION *PDEVICE_EXTENSION;

//
// SIS structure for a common store file opened by SIS.
//
typedef struct _SIS_CS_FILE {
    //
    // This structure is stored in a splay tree.  The splay links must be first.
    //
    RTL_SPLAY_LINKS                     Links;

    //
    // Count of the number of SIS_PER_LINKs that reference this common store file.  Protected by
    // the CSFileSpinLock in the device extension.
    //
    unsigned                            RefCount;

    //
    // A spin lock to protect some of the fields here.
    //
    KSPIN_LOCK                          SpinLock[1];

    //
    // The file object for the actual NTFS common store file.
    //
    PFILE_OBJECT                        UnderlyingFileObject;
    HANDLE                              UnderlyingFileHandle;

    //
    // A handle and file object for the backpointer stream.  This also contains the contents
    // checksum.
    //
    HANDLE                              BackpointerStreamHandle;
    PFILE_OBJECT                        BackpointerStreamFileObject;

    //
    // Various one-bit flags.  Protected by SpinLock.
    //
    ULONG                               Flags;

#define CSFILE_NTFSID_SET                       0x00000001  // Is CSFileNtfsId set in the structure?
#define CSFILE_FLAG_DELETED                     0x00000002  // The common store contents have been deleted
#define CSFILE_NEVER_HAD_A_REFERENCE            0x00000004  // Is this a newly created CS file that has never had a reference to it?
#define CSFILE_FLAG_CORRUPT                     0x00000008  // The backpointer stream is corrupt

    //
    // The size of the file.
    //
    LARGE_INTEGER                       FileSize;

    //
    // The SIS common store file id (which is also the name of the file within the
    // common store directory).
    //
    CSID                                CSid;

    //
    // The NTFS file index for the common store file.
    //
    LARGE_INTEGER                       CSFileNtfsId;

    //
    // The checksum for the contents of the common store file.
    //
    LONGLONG                            Checksum;

    //
    // A cache of recently validated backpointers for this file and an index that
    // represents the next entry to overwrite.
    //
#define SIS_CS_BACKPOINTER_CACHE_SIZE   5
    SIS_BACKPOINTER                     BackpointerCache[SIS_CS_BACKPOINTER_CACHE_SIZE];
    ULONG                               BPCacheNextSlot;

    PDEVICE_OBJECT                      DeviceObject;

    //
    // The number of entries allocated to the backpointer stream.  Note that this
    // is NOT the same as the file reference count, as some of these entries may
    // be deallocated.  Note also that this count is not necessarily 100% accurate,
    // but rather may refer to anywhere in the last sector of the file.
    //
    ULONG                               BPStreamEntries;

    //
    // A resource for controlling access to the backpoionter stream.
    //
    ERESOURCE                           BackpointerResource[1];

    KMUTANT                             UFOMutant[1];
} SIS_CS_FILE, *PSIS_CS_FILE;

//
// The per-link-file object.  There is one of these for each open SIS link file
// in the system, regardless of the number of times that link file is opened.
// This is roughly analogous to an FCB in NTFS.
//
typedef struct _SIS_PER_LINK {
    //
    // This structure is stored in a splay tree.  The splay links must be first.
    //
    RTL_SPLAY_LINKS                     Links;

    //
    // Pointer to the SIS_CS_FILE object for this link file.
    //
    PSIS_CS_FILE                        CsFile;

    //
    // The index of this link file.
    //
    LINK_INDEX                          Index;

    //
    // The NTFS file index for the link file object.
    //
    LARGE_INTEGER                       LinkFileNtfsId;

    //
    // Reference count (number of SCB objects that point at this link object).
    //
    ULONG                               RefCount;

    //
    // Various 1-bit long things
    //
    ULONG                               Flags;

    //
    // The thread that's doing the copy-on-write operation on this file.
    //
    PETHREAD                            COWingThread;


    KSPIN_LOCK                          SpinLock[1];

    //
    // We keep track of the count of threads executing delete or undelete requests in order to
    // make sure that we only have one kind of request in the system at a time.  We need to
    // serialize them so that we're sure what NTFS thinks the delete disposition is when it
    // comes time to delete a file.  If we need to block, we set the SIS_PER_LINK_DELETE_WAITERS
    // flag and wait on perLink->Event.  If the count is non-zero, it represents undeletes if
    // and only if the SIS_PER_LINK_UNDELETE_IN_PROGRESS flag is set.
    //
    ULONG                               PendingDeleteCount;

    //
    // An event that's set when the final copy is completed if there
    // are any final copy waiters.
    //
    KEVENT                              Event[1];

    //
    // An event used to serialize delete operations.
    //
    KEVENT                              DeleteEvent[1];

} SIS_PER_LINK, *PSIS_PER_LINK;

//
// Values for the SIS_PER_LINK Flags field.
//
#define SIS_PER_LINK_BACKPOINTER_GONE           0x00000001      // Have we removed the backpointer for this file
#define SIS_PER_LINK_FINAL_COPY                 0x00000002      // A final copy is in progress (or finished)
#define SIS_PER_LINK_FINAL_COPY_DONE            0x00000004      // A final copy is finished
#define SIS_PER_LINK_DIRTY                      0x00000008      // Has a write ever been done to any stream of this link?
#define SIS_PER_LINK_FINAL_COPY_WAITERS         0x00000010      // Are any threads blocked waiting final copy to be cleared
#define SIS_PER_LINK_OVERWRITTEN                0x00000020      // File's entire contents have been modified
#define SIS_PER_LINK_FILE_DELETED               0x00000040      // Has the file been deleted by SetInformationFile, delete-on-close or rename over?
#define SIS_PER_LINK_DELETE_DISPOSITION_SET     0x00000080      // Does NTFS think that the delete disposition is set on this file?
#define SIS_PER_LINK_DELETE_WAITERS             0x00000100      // Is anyone waiting for PendingDeleteCount to get to zero?
#define SIS_PER_LINK_UNDELETE_IN_PROGRESS       0x00000200      // Set iff PendingDeleteCount represents undelete operations
#define SIS_PER_LINK_FINAL_DELETE_IN_PROGRESS   0x00000400      // We've sent what we think is the final delete to NTFS; don't allow creates
#define SIS_PER_LINK_BACKPOINTER_VERIFIED       0x00000800      // Have we assured that this per link has a CSFile backpointer

typedef struct _SIS_FILTER_CONTEXT {
    //
    // This structure must start off with an FSRTL_FILTER_CONTEXT in order to be able
    // to use the FsRtlFilterContext routines.
    //
    FSRTL_PER_STREAM_CONTEXT ContextCtrl;

    //
    // The primary scb.  There may be other scb's associated with this filter
    // context (identified via the perFO's), but they must all be defunct,
    // i.e. marked SIS_PER_LINK_CAN_IGNORE.  New file objects always attach
    // to the primary scb.
    //
    struct _SIS_SCB                 *primaryScb;

    //
    // Linked list of all the perFO's associated with this file.
    //
    struct _SIS_PER_FILE_OBJECT     *perFOs;

    //
    // Number of perFO's attached to this filter context.
    //
    ULONG                           perFOCount;

    // Counting for OpLocks.
    ULONG                           UncleanCount;

    //
    // A fast mutex to protect the filter context.
    //
    FAST_MUTEX                      FastMutex[1];

#if     DBG
    //
    // The owner of the fast mutex.
    //
    ERESOURCE_THREAD                MutexHolder;
#endif

} SIS_FILTER_CONTEXT, *PSIS_FILTER_CONTEXT;

typedef struct _SIS_PER_FILE_OBJECT {
    //
    // A pointer to the filter context for this file.
    //
    struct _SIS_FILTER_CONTEXT      *fc;

    //
    // A pointer to the SCB holding the reference for this file.
    //
    struct _SIS_SCB                 *referenceScb;

    //
    // A pointer back to the file object that refers to this perFO.
    //
    PFILE_OBJECT                    fileObject;

    //
    // 1-bit stuff
    //
    ULONG                           Flags;
#define SIS_PER_FO_UNCLEANUP        0x00000001  // do we expect to see a cleanup on this perFO?
#define SIS_PER_FO_DELETE_ON_CLOSE  0x00000002  // The file was opened delete-on-close
#define SIS_PER_FO_OPBREAK          0x00000004  // This file was opened COMPLETE_IF_OPLOCKED,
                                                // it returned STATUS_OPLOCK_BREAK_IN_PROGRESS,
                                                // and the oplock break hasn't yet been acked.
#define SIS_PER_FO_OPBREAK_WAITERS  0x00000008  // Is anyone wating for the opbreak to complete?
#define SIS_PER_FO_OPEN_REPARSE     0x00000010  // Was this per-FO opened FILE_OPEN_REPARSE_POINT

#if DBG
#define SIS_PER_FO_NO_CREATE        0x80000000  // Was this perFO allocated by SipIsFileObjectSIS
#define SIS_PER_FO_CLEANED_UP       0x40000000  // Has this perFO already come through cleanup?
#endif  // DBG

    //
    // A spin lock to protect the flags
    //
    KSPIN_LOCK                      SpinLock[1];

    //
    // Linked list pointers for the perFOs associated
    // with a particular filter context.
    //
    struct _SIS_PER_FILE_OBJECT     *Next, *Prev;

    //
    // An event that's used for opbreak waiters.  Only alloated when SIS_PER_FO_OPBREAK
    // is set.
    //
    PKEVENT                         BreakEvent;

#if     DBG
    //
    // The FsContext (NTFS scb) for the file object pointed to by
    // this perFO.
    //
    PVOID                           FsContext;

    //
    // If this was allocated by SipIsFileObjectSIS, then the file and line number
    // of the call that allocated it.
    //
    PCHAR                           AllocatingFilename;
    ULONG                           AllocatingLineNumber;
#endif  // DBG


} SIS_PER_FILE_OBJECT, *PSIS_PER_FILE_OBJECT;

//
// Reference types for references held to SCBs.
//

typedef enum _SCB_REFERENCE_TYPE {
        RefsLookedUp            = 0,        // NB: the code assumes this is the first  reference type
        RefsPerFO,
        RefsPredecessorScb,
        RefsFinalCopy,
        RefsCOWRequest,
        RefsRead,
        RefsWrite,
        RefsWriteCompletion,
        RefsReadCompletion,
        RefsEnumeration,
        RefsFinalCopyRetry,
        RefsFc,
        NumScbReferenceTypes
} SCB_REFERENCE_TYPE, *PSCB_REFERENCE_TYPE;

#if     DBG
extern ULONG            totalScbReferences;
extern ULONG            totalScbReferencesByType[];
#endif  // DBG

//
// The SCB for a SIS-owned file.  These are one per stream for a particular link file.
// They are pointed to by FileObject->FsContext.
//
typedef struct _SIS_SCB {
    RTL_SPLAY_LINKS                     Links;

    // Need something to contain the stream name.

    PSIS_PER_LINK                       PerLink;

    //
    // List of predecessor scb's.  Any SCB's that are predecessors must be
    // defunct (ie., have CAN_IGNORE set).
    //
    struct _SIS_SCB                     *PredecessorScb;

    //
    // Reference count (number of file objects that point to this SCB structure)
    //
    ULONG                               RefCount;

    //
    // All scb's are on a volume global list for enumeration during volume check.
    //
    LIST_ENTRY                          ScbList;

    //
    // The first byte that must be from the copied file rather than from the
    // underlying file.  scb->Ranges is only maintained up to this address.
    // This starts out at the size of the underlying file at copy-on-write time,
    // and gets reduced if the file is truncated, but not increased if its
    // extended.
    //
    LONGLONG                            SizeBackedByUnderlyingFile;

    //
    // The count of failed final copy retries.
    //
    ULONG                               ConsecutiveFailedFinalCopies;

    //
    // Various 1-bit things
    //
    ULONG                               Flags;
#define SIS_SCB_MCB_INITIALIZED             0x00000001
#define SIS_SCB_INITIALIZED                 0x00000004      // is the SCB itself initialized
#define SIS_SCB_ANYTHING_IN_COPIED_FILE     0x00000008      // Is there possibly something in the copied file or its data section?
#define SIS_SCB_RANGES_INITIALIZED          0x00000010      // Have we checked allocated ranges for this file?
#define SIS_SCB_BACKING_FILE_OPENED_DIRTY   0x00000020      // did the backing file stream have anything in it when it was opened?

    //
    // A fast mutex to protect the SCB.
    //
    FAST_MUTEX                          FastMutex[1];

    // File locking structures
    FILE_LOCK                           FileLock;

    //
    // A large MCB to use for the written/faulted ranges.
    //
    LARGE_MCB                           Ranges[1];

#if     DBG
    //
    // The owner of the fast mutex.
    //
    ERESOURCE_THREAD                    MutexHolder;

    //
    // A count of references by type.
    //

    ULONG                               referencesByType[NumScbReferenceTypes];
#endif  // DBG

} SIS_SCB, *PSIS_SCB;

//
// A request to open a common store file. The caller must hold
// the UFOMutant for this file.  Status is returned in openStatus
// and then event is set.  It's the caller's responsibility to
// initialize the event and then deallocate the SI_OPEN_CS_FILE
// after it's completed.
//
typedef struct _SI_OPEN_CS_FILE {
    WORK_QUEUE_ITEM         workQueueItem[1];
    PSIS_CS_FILE            CSFile;
    NTSTATUS                openStatus;
    BOOLEAN                 openByName;
    KEVENT                  event[1];
} SI_OPEN_CS_FILE, *PSI_OPEN_CS_FILE;

//
// A request to close a handle(s) in the PsInitialProcess context. (sent to a worker thread)
//
typedef struct _SI_CLOSE_HANDLES {
    WORK_QUEUE_ITEM         workQueueItem[1];
    HANDLE                  handle1;
    HANDLE                  handle2;                OPTIONAL
    NTSTATUS                status;
    PERESOURCE              resourceToRelease;      OPTIONAL
    ERESOURCE_THREAD        resourceThreadId;       OPTIONAL
} SI_CLOSE_HANDLES, *PSI_CLOSE_HANDLES;

//
// A request to allocate more index space for a particular device.
//
typedef struct _SI_ALLOCATE_INDICES {
    WORK_QUEUE_ITEM         workQueueItem[1];
    PDEVICE_EXTENSION       deviceExtension;
} SI_ALLOCATE_INDICES, *PSI_ALLOCATE_INDICES;

typedef struct _SI_COPY_THREAD_REQUEST {
    LIST_ENTRY              listEntry[1];
    PSIS_SCB                scb;
    BOOLEAN                 fromCleanup;
} SI_COPY_THREAD_REQUEST, *PSI_COPY_THREAD_REQUEST;

typedef struct _SI_FSP_REQUEST {
    WORK_QUEUE_ITEM         workQueueItem[1];
    PIRP                    Irp;
    PDEVICE_OBJECT          DeviceObject;
    ULONG                   Flags;
} SI_FSP_REQUEST, *PSI_FSP_REQUEST;

#define FSP_REQUEST_FLAG_NONE               0x00000000  // Just a define so that we don't have to use "0" in calls
#define FSP_REQUEST_FLAG_WRITE_RETRY        0x00000001

typedef struct _RW_COMPLETION_UPDATE_RANGES_CONTEXT {
        WORK_QUEUE_ITEM         workQueueItem[1];
        PSIS_SCB                scb;
        LARGE_INTEGER           offset;
        ULONG                   length;
        PDEVICE_EXTENSION       deviceExtension;
        BOOLEAN                 NonCached;
} RW_COMPLETION_UPDATE_RANGES_CONTEXT, *PRW_COMPLETION_UPDATE_RANGES_CONTEXT;

typedef struct _SIS_CREATE_CS_FILE_REQUEST {
        WORK_QUEUE_ITEM             workQueueItem[1];
        PDEVICE_EXTENSION           deviceExtension;
        PCSID                       CSid;
        PFILE_OBJECT                srcFileObject;
        PLARGE_INTEGER              NtfsId;
        PKEVENT                     abortEvent;
        PLONGLONG                   CSFileChecksum;
        KEVENT                      doneEvent[1];
        NTSTATUS                    status;
} SIS_CREATE_CS_FILE_REQUEST, *PSIS_CREATE_CS_FILE_REQUEST;


#ifndef COPYFILE_SIS_LINK       // This is in ntioapi.h; leaving this here conditionally allows for compiling with both old and new ntioapi.h
//
// FSCTL_SIS_COPYFILE support
// Source and destination file names are passed in the FileNameBuffer.
// Both strings are null terminated, with the source name starting at
// the beginning of FileNameBuffer, and the destination name immediately
// following.  Length fields include terminating nulls.
//

typedef struct _SI_COPYFILE {
    ULONG SourceFileNameLength;
    ULONG DestinationFileNameLength;
    ULONG Flags;
    WCHAR FileNameBuffer[1];    // NB: Code in the filter requires that this is the final field
} SI_COPYFILE, *PSI_COPYFILE;
#endif  // COPYFILE_SIS_LINK

#define COPYFILE_SIS_LINK       0x0001              // Copy only if source is SIS
#define COPYFILE_SIS_REPLACE    0x0002              // Replace destination if it exists, otherwise don't.
#define COPYFILE_SIS_FLAGS      0x0003
// NB: in DBG systems, the high bit is reserved for "checkpoint log"

//
//  Macro to test if this is my device object
//

#define IS_MY_DEVICE_OBJECT(_devObj) \
    (((_devObj)->DriverObject == FsDriverObject) && \
      ((_devObj)->DeviceExtension != NULL))

//
//  Macro to test if this is my control device object
//

#define IS_MY_CONTROL_DEVICE_OBJECT(_devObj) \
    (((_devObj) == SisControlDeviceObject) ? \
            (ASSERT(((_devObj)->DriverObject == FsDriverObject) && \
                    ((_devObj)->DeviceExtension == NULL)), TRUE) : \
            FALSE)

//
//  Macro to test for device types we want to attach to
//

#define IS_DESIRED_DEVICE_TYPE(_type) \
    ((_type) == FILE_DEVICE_DISK_FILE_SYSTEM)


//#define SIS_DEVICE_TYPE /*(CSHORT)*/0xbb00

typedef struct _DEVICE_EXTENSION {
    PDEVICE_OBJECT                  AttachedToDeviceObject/*FileSystemDeviceObject*/;
    PDEVICE_OBJECT                  RealDeviceObject;

    //
    //  A pointer to the device object associated with this extension
    //

    PDEVICE_OBJECT                  DeviceObject;

    //
    // A list of all of the SIS device extensions in the system.
    //

    LIST_ENTRY                      DevExtLink;

    //
    // The absolute pathname of the common store directory.  This includes
    // the trailing "\"
    //

    UNICODE_STRING                  CommonStorePathname;

    //
    // The absolute pathname of the filesystem root.  This does include
    // a trailing "\"
    //

    UNICODE_STRING                  FilesystemRootPathname;

#if DBG
    //
    //  A cached copy of the name of the device we are attached to.
    //  - If it is a file system device object it will be the name of that
    //    device object.
    //  - If it is a mounted volume device object it will be the name of the
    //    real device object (since mounted volume device objects don't have
    //    names).
    //

    UNICODE_STRING Name;
#endif

    //
    // A count of outstanding final copy retries for this volume.  When this
    // count starts getting too large, we reduce the number of times
    // that we retry final copies in order to preserve memory.
    //
    ULONG                           OutstandingFinalCopyRetries;

    //
    // The volume sector size and the "bytes per file record."  Bytes per file
    // record is a number that's big enough that any file with
    // this allocation size is guaranteed to not be a resident attribute.
    // We store BytesPerFileRecordSegment in a large integer for convenience,
    // because we need to pass it into a call that takes a large integer
    // argument.
    //
    ULONG                           FilesystemVolumeSectorSize;
    LARGE_INTEGER                   FilesystemBytesPerFileRecordSegment;

    //
    // A handle to \SIS Common Store\GrovelerFile.  This is used
    // for two purposes.  First, it is used when we need a handle
    // to do open-by-id; for that purpose any handle on the
    // volume will do.  Second, it is used to check for security
    // on the FSCTL_LINK_FILES fsctl.  Any calls on any file
    // other than the one opened by GrovelerFileHandle will
    // fail; in this way, we can prevent non-privileged users
    // from making this call.
    //

    HANDLE                          GrovelerFileHandle;
    PFILE_OBJECT                    GrovelerFileObject;

    //
    // Various 1 bit flags related to this volume, and a spin lock to protect them.
    //
    KSPIN_LOCK                      FlagsLock[1];
    ULONG                           Flags;
#define SIP_EXTENSION_FLAG_PHASE_2_STARTED  0x00000001          // Phase 2 initialization is started
#define SIP_EXTENSION_FLAG_VCHECK_EXCLUSIVE 0x00000002          // In volume check backpointer resource exclusive phase
#define SIP_EXTENSION_FLAG_VCHECK_PENDING   0x00000004          // A volume check is pending
#define SIP_EXTENSION_FLAG_VCHECK_NODELETE  0x00000008          // In volume check no-delete phase
#define SIP_EXTENSION_FLAG_CORRUPT_MAXINDEX 0x00000010          // invalid maxindex--volume check is fixing it

#define SIP_EXTENSION_FLAG_INITED_CDO       0x40000000          // inited as control device object
#define SIP_EXTENSION_FLAG_INITED_VDO       0x80000000          // inited as volume device object

    //
    // The splay tree for per-link structures for this volume.
    //
    SIS_TREE                        PerLinkTree[1];

    //
    // Spin lock for accessing the per-link list.  Ordered before the CSFileSpinLock.
    //
    KSPIN_LOCK                      PerLinkSpinLock[1];

    //
    // A splay tree and spin lock for the common store file stuructures, just like the per-link ones above.
    // The spin lock is ordered after the PerLinkSpinLock, meaning that once we have the
    // CSFileSpinLock, we cannot try to acquire the PerLinkSpinLock (but do not necessarily need
    // to hold it in the first place).
    //
    SIS_TREE                        CSFileTree[1];
    KSPIN_LOCK                      CSFileSpinLock[1];

    //
    // A resource that protects against a race between the handles being closed on a CS file after
    // the last reference goes away, and someone re-opening a reference to that CS file.  Everyone
    // closing a CS file takes this resource shared.  When an opener gets a sharing violation on the
    // backpointer stream, it takes the resource exclusively and retries.
    //
    ERESOURCE                       CSFileHandleResource[1];

    //
    // The splay tree for SCBs
    //
    SIS_TREE                        ScbTree[1];
    KSPIN_LOCK                      ScbSpinLock[1];

    //
    // Doubly linked list of all scb structures for this volume.
    //
    LIST_ENTRY                      ScbList;

    //
    // State for the LINK_INDEX value generator for this volume.  Keep track of how many are allocated (ie., we've
    // recorded on the disk that they can't be used) and how many are actually used now.  Must hold the
    // IndexSpinLock to access these variables.
    //
    LINK_INDEX                      MaxAllocatedIndex;
    LINK_INDEX                      MaxUsedIndex;
    KSPIN_LOCK                      IndexSpinLock[1];

    //
    // Control for the index allocator.  If there are no unused, allocated indices, a thread sets the
    // IndexAllocationInProgress flag, clears the event, queues up the allocator and blocks
    // on the IndexEvent (a Notification event).  Any subequent threads just block on the event.
    // The allocator gets new indices, updates the variable and sets the event.  When the
    // waiting threads wake up, they just retry the allocation.
    //
    BOOLEAN                         IndexAllocationInProgress;
    KEVENT                          IndexEvent[1];

    //
    // A handle (in the PsInitialSystemProcess context) to the index file.  Only accessed by the index allocator.
    //
    HANDLE                          IndexHandle;
    HANDLE                          IndexFileEventHandle;
    PKEVENT                         IndexFileEvent;

    //
    // The status that came back from the attempt to allocate new indices.
    //
    NTSTATUS                        IndexStatus;

#if     ENABLE_LOGGING
    //
    // Stuff for the SIS log file.  A handle in the PsInitialSystemProcessContext as well as an object
    // that we reference to the file for use in other contexts.
    //
    HANDLE                          LogFileHandle;
    PFILE_OBJECT                    LogFileObject;
    KMUTANT                         LogFileMutant[1];
    LARGE_INTEGER                   LogWriteOffset;
    LARGE_INTEGER                   PreviousLogWriteOffset; // The logwriteoffset from when the trimmer last ran.
#endif  // ENABLE_LOGGING

    //
    // Phase 2 initialization takes place after the mount has completed when we can do full-fledged
    // ZwCreateFile calls and whatnot.  This flag indicates whether it's happened.  Once it's set,
    // it can never be cleared.
    //
    BOOLEAN                         Phase2InitializationComplete;
    KEVENT                          Phase2DoneEvent[1];

    //
    // The thread that's handing phase2 initialization.
    //
    HANDLE                          Phase2ThreadId;

    //
    // The number of backpointer entries per sector (sectorSize / sizeof(SIS_BACKPOINTER).
    //
    ULONG                           BackpointerEntriesPerSector;

    //
    // Taken when a link index collision is being repaired.
    //
    KMUTEX                          CollisionMutex[1];

    //
    // A resource that's used to mediate access to the GrovelerFileObject.  This needs to
    // be taken shared to assure that the GrovelerFileObject isn't messed with.  When the volume
    // is dismounted, the dismount code takes it exclusively in order to blow away the GrovelerFileObject.
    //
    ERESOURCE                       GrovelerFileObjectResource[1];

} DEVICE_EXTENSION;

//
// The spin lock used to maintain the list of device extensions.
//

extern KSPIN_LOCK DeviceExtensionListLock;
extern LIST_ENTRY DeviceExtensionListHead;

//
// Global stuff for the log trimmer.  This uses a timer to fire a DPC, which in turn queues up the real
// log trimmer on a worker thread.  The trimmer then reschedules the DPC when it's done.
//
extern KTIMER              LogTrimTimer[1];
extern KDPC                LogTrimDpc[1];
extern WORK_QUEUE_ITEM     LogTrimWorkItem[1];
#define LOG_TRIM_TIMER_INTERVAL  -10 * 1000 * 1000 * 60     // 1 minute trim interval

//
//  Mutex for interlocking device attachments
//

extern FAST_MUTEX SisDeviceAttachLock;

//
// Offsets used for the SCB ranges
//
#define FAULTED_OFFSET          1000
#define WRITTEN_OFFSET          2000

//
// A macro to get SIS out of the driver stack.  This should be called from
// a dispatch routine when we don't want to hear about this particular Irp
// again.  It is morally equivalent to calling SiPassThrough, only without
// the procedure call overhead.  Note that the return in this macro returns
// from the caller's function, not just from the "macro function."
//
#define SipDirectPassThroughAndReturn(DeviceObject,Irp)                                         \
{                                                                                               \
    (Irp)->CurrentLocation++;                                                                   \
    (Irp)->Tail.Overlay.CurrentStackLocation++;                                                 \
                                                                                                \
    return IoCallDriver(                                                                        \
        ((PDEVICE_EXTENSION)((DeviceObject)->DeviceExtension))->AttachedToDeviceObject,         \
        (Irp));                                                                                 \
}

//
// This function assures that phase 2 initialization is complete for a volume.  It might
// block, but only during initialization.
//
#define SipCheckPhase2(deviceExtension)                                                         \
        ((deviceExtension)->Phase2InitializationComplete ?                                      \
                TRUE : SipHandlePhase2((deviceExtension)))

//
// Test to see if this file object is our primary device object rather than
// an actual filesystem device.  If so, then complete the irp and return from the
// calling function.
//

#define SipHandleControlDeviceObject(DeviceObject,Irp)                                          \
{                                                                                               \
    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) {                                            \
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;                                   \
        Irp->IoStatus.Information = 0;                                                          \
                                                                                                \
        IoCompleteRequest(Irp, IO_NO_INCREMENT);                                                \
                                                                                                \
        return STATUS_INVALID_DEVICE_REQUEST;                                                   \
    }                                                                                           \
}

//
// A debugging routine to determine if a SCB is held exclusively.  Does NOT assert
// that it's held by the current thread, just that it's held by someone
//
#if     DBG && defined (_X86_)
#define SipAssertScbHeld(scb)                                                                   \
{                                                                                               \
    ASSERT((scb)->MutexHolder != 0);                                                            \
}
#else   // DBG
#define SipAssertScbHeld(scb)
#endif  // DBG

//
// A debugging routine to determine if a SCB is held exclusively by a particular thread.
//
#if     DBG && defined (_X86_)
#define SipAssertScbHeldByThread(scb,thread)                                                    \
{                                                                                               \
    ASSERT((scb)->MutexHolder == (thread));                                                     \
}
#else   // DBG
#define SipAssertScbHeldByThread(scb,thread)
#endif  // DBG

//
// Acquire a filter context exclusively
//
#if     DBG
#define SipAcquireFc(fc)                                                                        \
{                                                                                               \
    ExAcquireFastMutex((fc)->FastMutex);                                                        \
    (fc)->MutexHolder = ExGetCurrentResourceThread();                                           \
}
#else   DBG
#define SipAcquireFc(fc)                                                                        \
{                                                                                               \
    ExAcquireFastMutex((fc)->FastMutex);                                                        \
}
#endif  // DBG

//
// Release a filter context
//
#if     DBG
#define SipReleaseFc(fc)                                                                        \
{                                                                                               \
    (fc)->MutexHolder = 0;                                                                      \
    ExReleaseFastMutex((fc)->FastMutex);                                                        \
}
#else   // DBG
#define SipReleaseFc(fc)                                                                        \
{                                                                                               \
    ExReleaseFastMutex((fc)->FastMutex);                                                        \
}
#endif  // DBG

//
// Acquire an SCB exclusively
//
#if     DBG
#define SipAcquireScb(scb)                                                                      \
{                                                                                               \
    ExAcquireFastMutex((scb)->FastMutex);                                                       \
    (scb)->MutexHolder = ExGetCurrentResourceThread();                                          \
}
#else   DBG
#define SipAcquireScb(scb)                                                                      \
{                                                                                               \
    ExAcquireFastMutex((scb)->FastMutex);                                                       \
}
#endif  // DBG

//
// Release a SCB
//
#if     DBG
#define SipReleaseScb(scb)                                                                      \
{                                                                                               \
    (scb)->MutexHolder = 0;                                                                     \
    ExReleaseFastMutex((scb)->FastMutex);                                                       \
}
#else   // DBG
#define SipReleaseScb(scb)                                                                      \
{                                                                                               \
    ExReleaseFastMutex((scb)->FastMutex);                                                       \
}
#endif  // DBG

//
// A header for any log entry in the SIS log file.
//
typedef struct _SIS_LOG_HEADER {
    //
    // A magic number.  This needs to be first for the log reading code.
    //
    ULONG                       Magic;

    //
    // The type of the log record (ie., copy-on-write, COW completed, etc.)
    //
    USHORT                      Type;

    //
    // The size of the log record, including the size of the header record itself.
    //
    USHORT                      Size;

    //
    // An SIS index unique to this log record.  This is here to help insure log
    // consistency.  First, all log records must be in ascending index order.
    // Second, all log records will look slightly different because they
    // will have different indices, and so will have different checksums, making
    // stale log records more likely to be detected.
    //
    LINK_INDEX                  Index;

    //
    // A checksum of the log record, including the header.  When the checksum is
    // computed, the checksum field is set to zero.
    //
    LARGE_INTEGER               Checksum;

} SIS_LOG_HEADER, *PSIS_LOG_HEADER;

#define SIS_LOG_HEADER_MAGIC    0xfeedf1eb

//
// The various types of log records
//
#define SIS_LOG_TYPE_TEST                   1
#define SIS_LOG_TYPE_REFCOUNT_UPDATE        2

//
// Possible values for UpdateType in SipPrepareRefcountChange and in the
// SIS_LOG_REFCOUNT_UPDATE log record.
//
#define SIS_REFCOUNT_UPDATE_LINK_DELETED        2
#define SIS_REFCOUNT_UPDATE_LINK_CREATED        3
#define SIS_REFCOUNT_UPDATE_LINK_OVERWRITTEN    4

//
// A common store file reference count update, either because of a new copy or
// a deletion.  copies-on-write are handled with different log records.
//
typedef struct _SIS_LOG_REFCOUNT_UPDATE {
    //
    // What type of update is this (create, delete or overwrite?)
    //
    ULONG                       UpdateType;

    //
    // If this is a delete, is the link file going away, or has it been
    // overwritten/final copied?
    //
    BOOLEAN                     LinkFileBeingDeleted;

    //
    // The NTFS file Id of the link file.
    //
    LARGE_INTEGER               LinkFileNtfsId;

    //
    // The link and common store indices for this link
    //
    LINK_INDEX                  LinkIndex;
    CSID                        CSid;
} SIS_LOG_REFCOUNT_UPDATE, *PSIS_LOG_REFCOUNT_UPDATE;

//
// Enums for the code that keeps track of whether ranges of a file
// are written, faulted or untouched.
//
typedef enum _SIS_RANGE_DIRTY_STATE {
                    Clean,
                    Mixed,
                    Dirty}
        SIS_RANGE_DIRTY_STATE, *PSIS_RANGE_DIRTY_STATE;

typedef enum _SIS_RANGE_STATE {
                    Untouched,
                    Faulted,
                    Written}
        SIS_RANGE_STATE, *PSIS_RANGE_STATE;


extern LIST_ENTRY CopyList[];
extern KSPIN_LOCK CopyListLock[];
extern KSEMAPHORE CopySemaphore[];

typedef struct _SCB_KEY {
    LINK_INDEX      Index;
} SCB_KEY, *PSCB_KEY;

typedef struct _PER_LINK_KEY {
    LINK_INDEX      Index;
} PER_LINK_KEY, *PPER_LINK_KEY;

typedef struct _CS_FILE_KEY {
    CSID            CSid;
} CS_FILE_KEY, *PCS_FILE_KEY;

//
//  Following macro is used to initialize UNICODE strings, stolen from ntfsstru.h
//

#ifndef CONSTANT_UNICODE_STRING
#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof( s ), s }
#endif

extern const UNICODE_STRING NtfsDataString;

//
//  Miscellaneous support macros (stolen from private\ntos\cntfs\ntfsproc.h).
//
//      ULONG_PTR
//      WordAlign (
//          IN ULONG_PTR Pointer
//          );
//
//      ULONG_PTR
//      LongAlign (
//          IN ULONG_PTR Pointer
//          );
//
//      ULONG_PTR
//      QuadAlign (
//          IN ULONG_PTR Pointer
//          );
//
//      UCHAR
//      CopyUchar1 (
//          IN PUCHAR Destination,
//          IN PUCHAR Source
//          );
//
//      UCHAR
//      CopyUchar2 (
//          IN PUSHORT Destination,
//          IN PUCHAR Source
//          );
//
//      UCHAR
//      CopyUchar4 (
//          IN PULONG Destination,
//          IN PUCHAR Source
//          );
//
//      PVOID
//      Add2Ptr (
//          IN PVOID Pointer,
//          IN ULONG Increment
//          );
//
//      ULONG
//      PtrOffset (
//          IN PVOID BasePtr,
//          IN PVOID OffsetPtr
//          );
//

#define WordAlign(P) (             \
    ((((ULONG_PTR)(P)) + 1) & (-2)) \
)

#define LongAlign(P) (             \
    ((((ULONG_PTR)(P)) + 3) & (-4)) \
)

#define QuadAlign(P) (             \
    ((((ULONG_PTR)(P)) + 7) & (-8)) \
)

#define IsWordAligned(P)    ((ULONG_PTR)(P) == WordAlign( (P) ))

#define IsLongAligned(P)    ((ULONG_PTR)(P) == LongAlign( (P) ))

#define IsQuadAligned(P)    ((ULONG_PTR)(P) == QuadAlign( (P) ))


/////////////////////////////////////////////////////////////////////////////
//
//                      Functions Prototypes
//
/////////////////////////////////////////////////////////////////////////////

//
//  Routines in SIINIT.C
//

VOID
SipCleanupDeviceExtension(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SipMountCompletion(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp,
    IN PVOID                            Context
    );

NTSTATUS
SipLoadFsCompletion(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp,
    IN PVOID                            Context
    );

VOID
SipFsNotification(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN BOOLEAN                          FsActive
    );

NTSTATUS
SipInitializeDeviceExtension(
    IN PDEVICE_OBJECT                   deviceObject
    );

VOID
SipUninitializeDeviceExtension(
    IN PDEVICE_OBJECT                   deviceObject
    );

VOID
SipGetBaseDeviceObjectName(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    );

VOID
SipGetObjectName(
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
    );

#if DBG
VOID
SipCacheDeviceName (
    IN PDEVICE_OBJECT OurDeviceObject
    );
#endif
//
//  ROutines in SIFASTIO.C
//

BOOLEAN
SiFastIoCheckIfPossible(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN ULONG                            Length,
    IN BOOLEAN                          Wait,
    IN ULONG                            LockKey,
    IN BOOLEAN                          CheckForReadOperation,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoRead(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN ULONG                            Length,
    IN BOOLEAN                          Wait,
    IN ULONG                            LockKey,
    OUT PVOID                           Buffer,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoWrite(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN ULONG                            Length,
    IN BOOLEAN                          Wait,
    IN ULONG                            LockKey,
    IN PVOID                            Buffer,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoQueryBasicInfo(
    IN PFILE_OBJECT                     FileObject,
    IN BOOLEAN                          Wait,
    OUT PFILE_BASIC_INFORMATION         Buffer,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoQueryStandardInfo(
    IN PFILE_OBJECT                     FileObject,
    IN BOOLEAN                          Wait,
    OUT PFILE_STANDARD_INFORMATION      Buffer,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoLock(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN PLARGE_INTEGER                   Length,
    PEPROCESS                           ProcessId,
    ULONG                               Key,
    BOOLEAN                             FailImmediately,
    BOOLEAN                             ExclusiveLock,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoUnlockSingle(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN PLARGE_INTEGER                   Length,
    PEPROCESS                           ProcessId,
    ULONG                               Key,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoUnlockAll(
    IN PFILE_OBJECT                     FileObject,
    PEPROCESS                           ProcessId,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoUnlockAllByKey(
    IN PFILE_OBJECT                     FileObject,
    PVOID                               ProcessId,
    ULONG                               Key,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoDeviceControl(
    IN PFILE_OBJECT                     FileObject,
    IN BOOLEAN                          Wait,
    IN PVOID                            InputBuffer OPTIONAL,
    IN ULONG                            InputBufferLength,
    OUT PVOID                           OutputBuffer OPTIONAL,
    IN ULONG                            OutputBufferLength,
    IN ULONG                            IoControlCode,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

VOID
SiFastIoDetachDevice(
    IN PDEVICE_OBJECT                   SourceDevice,
    IN PDEVICE_OBJECT                   TargetDevice
    );

BOOLEAN
SiFastIoQueryNetworkOpenInfo(
    IN PFILE_OBJECT                     FileObject,
    IN BOOLEAN                          Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION  Buffer,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoMdlRead(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN ULONG                            Length,
    IN ULONG                            LockKey,
    OUT PMDL                            *MdlChain,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoMdlReadComplete(
    IN PFILE_OBJECT                     FileObject,
    IN PMDL                             MdlChain,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoPrepareMdlWrite(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN ULONG                            Length,
    IN ULONG                            LockKey,
    OUT PMDL                            *MdlChain,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoMdlWriteComplete(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN PMDL                             MdlChain,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoReadCompressed(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN ULONG                            Length,
    IN ULONG                            LockKey,
    OUT PVOID                           Buffer,
    OUT PMDL                            *MdlChain,
    OUT PIO_STATUS_BLOCK                IoStatus,
    OUT PCOMPRESSED_DATA_INFO           CompressedDataInfo,
    IN ULONG                            CompressedDataInfoLength,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoWriteCompressed(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN ULONG                            Length,
    IN ULONG                            LockKey,
    IN PVOID                            Buffer,
    OUT PMDL                            *MdlChain,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PCOMPRESSED_DATA_INFO            CompressedDataInfo,
    IN ULONG                            CompressedDataInfoLength,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoMdlReadCompleteCompressed(
    IN PFILE_OBJECT                     FileObject,
    IN PMDL                             MdlChain,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoMdlWriteCompleteCompressed(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN PMDL                             MdlChain,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoQueryOpen(
    IN PIRP                             Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION  NetworkInformation,
    IN PDEVICE_OBJECT                   DeviceObject
    );



//
// Declarations for various SIS internal/external functions.
//


BOOLEAN
SipAttachedToDevice (
    IN PDEVICE_OBJECT DeviceObject);

NTSTATUS
SipAttachToMountedDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT NewDeviceObject,
    IN PDEVICE_OBJECT RealDeviceObject);



VOID
SipInitializeTree (
    IN PSIS_TREE                        Tree,
    IN PSIS_TREE_COMPARE_ROUTINE        CompareRoutine);


PVOID
SipInsertElementTree (
    IN PSIS_TREE                        Tree,
    IN PVOID                            Node,
    IN PVOID                            Key);


VOID
SipDeleteElementTree (
    IN PSIS_TREE                        Tree,
    IN PVOID                            Node);

PVOID
SipLookupElementTree (
    IN PSIS_TREE                        Tree,
    IN PVOID                            Key);

LONG
SipScbTreeCompare (
    IN PVOID                            Key,
    IN PVOID                            Node);

LONG
SipPerLinkTreeCompare (
    IN PVOID                            Key,
    IN PVOID                            Node);

LONG
SipCSFileTreeCompare (
    IN PVOID                            Key,
    IN PVOID                            Node);

VOID
SipReferenceScb(
    IN PSIS_SCB                         scb,
    IN SCB_REFERENCE_TYPE               referenceType);

VOID
SipDereferenceScb(
    IN PSIS_SCB                         scb,
    IN SCB_REFERENCE_TYPE               referenceType);

#if		DBG
VOID
SipTransferScbReferenceType(
	IN PSIS_SCB							scb,
	IN SCB_REFERENCE_TYPE				oldReferenceType,
	IN SCB_REFERENCE_TYPE				newReferenceType);
#else	// DBG
#define	SipTransferScbReferenceType(scb,oldReferenceType,newReferenceType)	// We don't track reference types in free builds
#endif	// DBG

PSIS_SCB
SipLookupScb(
    IN PLINK_INDEX                      PerLinkIndex,
    IN PCSID                            CSid,
    IN PLARGE_INTEGER                   LinkFileNtfsId,
    IN PLARGE_INTEGER                   CSFileNtfsId            OPTIONAL,
    IN PUNICODE_STRING                  StreamName,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PETHREAD                         RequestingThread        OPTIONAL,
    OUT PBOOLEAN                        FinalCopyInProgress,
    OUT PBOOLEAN                        LinkIndexCollision);

PSIS_PER_LINK
SipLookupPerLink(
    IN PLINK_INDEX                      PerLinkIndex,
    IN PCSID                            CSid,
    IN PLARGE_INTEGER                   LinkFileNtfsId,
    IN PLARGE_INTEGER                   CSFileNtfsId            OPTIONAL,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PETHREAD                         RequestingThread        OPTIONAL,
    OUT PBOOLEAN                        FinalCopyInProgress);

VOID
SipReferencePerLink(
    IN PSIS_PER_LINK                    PerLink);

VOID
SipDereferencePerLink(
    IN PSIS_PER_LINK                    PerLink);

PSIS_SCB
SipEnumerateScbList(
    PDEVICE_EXTENSION                   deviceExtension,
    PSIS_SCB                            prevScb);

VOID
SipUpdateLinkIndex(
    PSIS_SCB                            Scb,
    PLINK_INDEX                         LinkIndex);

PSIS_CS_FILE
SipLookupCSFile(
    IN PCSID                            CSid,
    IN PLARGE_INTEGER                   CSFileNtfsId            OPTIONAL,
    IN PDEVICE_OBJECT                   DeviceObject);

VOID
SipReferenceCSFile(
    IN PSIS_CS_FILE                     CSFile);

VOID
SipDereferenceCSFile(
    IN PSIS_CS_FILE                     CsFile);

NTSTATUS
SiPrePostIrp(
    IN OUT PIRP                         Irp);

NTSTATUS
SipLockUserBuffer(
    IN OUT PIRP                         Irp,
    IN LOCK_OPERATION                   Operation,
    IN ULONG                            BufferLength);

NTSTATUS
SipPostRequest(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN OUT PIRP                         Irp,
    IN ULONG                            Flags);

VOID
SiCopyThreadStart(
    IN PVOID                            parameter);

NTSTATUS
SipPrepareCSRefcountChange(
    IN PSIS_CS_FILE                     CSFile,
    IN OUT PLINK_INDEX                  LinkIndex,
    IN PLARGE_INTEGER                   LinkFileNtfsId,
    IN ULONG                            UpdateType);

NTSTATUS
SipCompleteCSRefcountChangeForThread(
    IN OUT PSIS_PER_LINK                PerLink,
    IN PLINK_INDEX                      LinkIndex,
    IN PSIS_CS_FILE                     CSFile,
    IN BOOLEAN                          Success,
    IN BOOLEAN                          Increment,
    IN ERESOURCE_THREAD                 thread);

NTSTATUS
SipCompleteCSRefcountChange(
    IN OUT PSIS_PER_LINK                PerLink,
    IN PLINK_INDEX                      LinkIndex,
    IN PSIS_CS_FILE                     CSFile,
    IN BOOLEAN                          Success,
    IN BOOLEAN                          Increment);

NTSTATUS
SipDeleteCSFile(
    PSIS_CS_FILE                        CSFile);

NTSTATUS
SipAllocateIndex(
    IN PDEVICE_EXTENSION                DeviceExtension,
    OUT PLINK_INDEX                     Index);

NTSTATUS
SipGetMaxUsedIndex(
    IN PDEVICE_EXTENSION                DeviceExtension,
    OUT PLINK_INDEX                     Index);

NTSTATUS
SipIndexToFileName(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PCSID                            CSid,
    IN ULONG                            appendBytes,
    IN BOOLEAN                          mayAllocate,
    OUT PUNICODE_STRING                 fileName);

BOOLEAN
SipFileNameToIndex(
    IN PUNICODE_STRING                  fileName,
    OUT PCSID                           CSid);

BOOLEAN
SipIndicesFromReparseBuffer(
    IN PREPARSE_DATA_BUFFER             reparseBuffer,
    OUT PCSID                           CSid,
    OUT PLINK_INDEX                     LinkIndex,
    OUT PLARGE_INTEGER                  CSFileNtfsId,
    OUT PLARGE_INTEGER                  LinkFileNtfsId,
    OUT PLONGLONG                       CSFileChecksum OPTIONAL,
    OUT PBOOLEAN                        EligibleForPartialFinalCopy OPTIONAL,
    OUT PBOOLEAN                        ReparseBufferCorrupt OPTIONAL);

BOOLEAN
SipIndicesIntoReparseBuffer(
    OUT PREPARSE_DATA_BUFFER            reparseBuffer,
    IN PCSID                            CSid,
    IN PLINK_INDEX                      LinkIndex,
    IN PLARGE_INTEGER                   CSFileNtfsId,
    IN PLARGE_INTEGER                   LinkFileNtfsId,
    IN PLONGLONG                        CSFileChecksum,
    IN BOOLEAN                          EligibleForPartialFinalCopy);

NTSTATUS
SipCompleteCopy(
    IN PSIS_SCB                         scb,
    IN BOOLEAN                          fromCleanup);

NTSTATUS
SipCloseHandles(
    IN HANDLE                           handle1,
    IN HANDLE                           handle2                 OPTIONAL,
    IN OUT PERESOURCE                   resourceToRelease       OPTIONAL
    );

NTSTATUS
SiPassThrough(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiCreate(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiOtherCreates (
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiClose(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiCleanup(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiRead(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiWrite(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiSetInfo(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiQueryInfo(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiFsControl(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiLockControl(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );


NTSTATUS
SiOplockCompletion(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp,
    IN PVOID                            Context
    );

VOID
SipOpenLinkFile(
    IN PVOID                            Parameter
    );

VOID
SipChangeCSRefcountWork(
    IN PVOID                            Parameter
    );

BOOLEAN
SiAcquireForLazyWrite(
    IN PVOID                            Context,
    IN BOOLEAN                          Wait
    );

VOID
SiReleaseFromLazyWrite(
    IN PVOID                            Context
    );

BOOLEAN
SiAcquireForReadAhead(
    IN PVOID                            Context,
    IN BOOLEAN                          Wait
    );

VOID
SiReleaseFromReadAhead(
    IN PVOID                            Context
    );

NTSTATUS
SipOpenBackpointerStream(
    IN PSIS_CS_FILE                     csFile,
    IN ULONG                            CreateDisposition
    );

NTSTATUS
SipOpenCSFileWork(
    IN PSIS_CS_FILE                     CSFile,
    IN BOOLEAN                          openByName,
    IN BOOLEAN                          volCheck,
    IN BOOLEAN                          openForDelete,
    OUT PHANDLE                         openedFileHandle OPTIONAL
    );

VOID
SipOpenCSFile(
    IN OUT PSI_OPEN_CS_FILE             openRequest
    );

VOID
SiThreadCreateNotifyRoutine(
    IN HANDLE                           ProcessId,
    IN HANDLE                           ThreadId,
    IN BOOLEAN                          Create
    );

VOID
SipCloseHandlesWork(
    IN PVOID                            parameter
    );

NTSTATUS
SipQueryInformationFile(
    IN PFILE_OBJECT                     FileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN ULONG                            InformationClass,
    IN ULONG                            Length,
    OUT PVOID                           Information,
    OUT PULONG                          ReturnedLength      OPTIONAL
    );

NTSTATUS
SipQueryInformationFileUsingGenericDevice(
    IN PFILE_OBJECT                     FileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN ULONG                            InformationClass,
    IN ULONG                            Length,
    OUT PVOID                           Information,
    OUT PULONG                          ReturnedLength      OPTIONAL
    );

NTSTATUS
SipSetInformationFile(
    IN PFILE_OBJECT                     FileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN FILE_INFORMATION_CLASS           FileInformationClass,
    IN ULONG                            Length,
    IN PVOID                            FileInformation
    );

NTSTATUS
SipSetInformationFileUsingGenericDevice(
    IN PFILE_OBJECT                     FileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN FILE_INFORMATION_CLASS           FileInformationClass,
    IN ULONG                            Length,
    IN PVOID                            FileInformation
    );

NTSTATUS
SipCommonCreate(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp,
    IN BOOLEAN                          Wait
    );

NTSTATUS
SipCommonRead(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp,
    IN BOOLEAN                          Wait
    );

NTSTATUS
SipCommonSetInfo(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp,
    IN BOOLEAN                          Wait
    );

NTSTATUS
SipCommonQueryInfo(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp,
    IN BOOLEAN                          Wait
    );

NTSTATUS
SipCommonLockControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN BOOLEAN Wait
    );

NTSTATUS
SipCommonCleanup(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp,
    IN BOOLEAN                          Wait
    );

NTSTATUS
SipFsCopyFile(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp);

NTSTATUS
SipInitialCopy(
    PSIS_PER_FILE_OBJECT                perFO);

NTSTATUS
SipBltRange(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN HANDLE                           sourceHandle,
    IN OUT HANDLE                       dstHandle,
    IN LONGLONG                         startingOffset,
    IN LONGLONG                         length,
    IN HANDLE                           copyEventHandle,
    IN PKEVENT                          copyEvent,
    IN PKEVENT                          oplockEvent,
    OUT PLONGLONG                       checksum);

NTSTATUS
SipBltRange(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN HANDLE                           sourceHandle,
    IN OUT HANDLE                       dstHandle,
    IN LONGLONG                         startingOffset,
    IN LONGLONG                         length,
    IN HANDLE                           copyEventHandle,
    IN PKEVENT                          copyEvent,
    IN PKEVENT                          oplockEvent,
    OUT PLONGLONG                       checksum);

NTSTATUS
SipBltRangeByObject(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PFILE_OBJECT                     srcFileObject,
    IN OUT HANDLE                       dstHandle,
    IN LONGLONG                         startingOffset,
    IN LONGLONG                         length,
    IN HANDLE                           copyEventHandle,
    IN PKEVENT                          copyEvent,
    IN PKEVENT                          oplockEvent,
    OUT PLONGLONG                       checksum);

NTSTATUS
SipComputeCSChecksum(
    IN PSIS_CS_FILE                     csFile,
    IN OUT PLONGLONG                    csFileChecksum,
    HANDLE                              eventHandle,
    PKEVENT                             event);

NTSTATUS
SipCompleteCopyWork(
    IN PSIS_SCB                         scb,
    IN HANDLE                           eventHandle,
    IN PKEVENT                          event,
    IN BOOLEAN                          fromCleanup);

NTSTATUS
SipMakeLogEntry(
    IN OUT PDEVICE_EXTENSION            deviceExtension,
    IN USHORT                           type,
    IN USHORT                           size,
    IN PVOID                            record);

#if     ENABLE_LOGGING
VOID
SipAcquireLog(
    IN OUT PDEVICE_EXTENSION            deviceExtension);

VOID
SipReleaseLog(
    IN OUT PDEVICE_EXTENSION            deviceExtension);
#endif  // ENABLE_LOGGING

VOID
SipComputeChecksum(
    IN PVOID                            buffer,
    IN ULONG                            size,
    IN OUT PLONGLONG                    checksum);

NTSTATUS
SipOpenLogFile(
    IN OUT PDEVICE_EXTENSION            deviceExtension);

VOID
SipDrainLogFile(
    PDEVICE_EXTENSION                   deviceExtension);

BOOLEAN
SipHandlePhase2(
    PDEVICE_EXTENSION                   deviceExtension);

VOID
SipClearLogFile(
    PDEVICE_EXTENSION                   deviceExtension);

NTSTATUS
SiCheckOplock (
    IN POPLOCK                          Oplock,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp);

NTSTATUS
SiCheckOplockWithWait (
    IN POPLOCK                          Oplock,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp);

VOID
SipProcessCowLogRecord(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PVOID                            logRecord,
    IN OUT PVOID                        *cowReplayPointer);

VOID
SipProcessCowDoneLogRecord(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PVOID                            logRecord,
    IN OUT PVOID                        *cowReplayPointer);

NTSTATUS
SipFinalCopy(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PLARGE_INTEGER                   linkFileNtfsId,
    IN OUT PSIS_SCB                     scb,
    IN HANDLE                           copyEventHandle,
    IN PKEVENT                          event);

VOID
SipCowAllLogRecordsSent(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN OUT PVOID                        *cowReplayPointer);

NTSTATUS
SipCreateEvent(
    IN EVENT_TYPE                       eventType,
    OUT PHANDLE                         eventHandle,
    OUT PKEVENT                         *event);

VOID
SipMarkPoint(
    IN PCHAR                            pszFile,
    IN ULONG                            nLine
    );

VOID
SipMarkPointUlong(
    IN PCHAR                            pszFile,
    IN ULONG                            nLine,
    IN ULONG_PTR                        value
    );

NTSTATUS
SipLinkFiles(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SipCreateCSFile(
    IN PDEVICE_EXTENSION                deviceExtension,
    OUT PCSID                           CSid,
    IN HANDLE                           SrcHandle,
    OUT PLARGE_INTEGER                  NtfsId,
    IN PKEVENT                          oplockEvent OPTIONAL,
    OUT PLONGLONG                       CSFileChecksum
    );

VOID
SipCreateCSFileWork(
    PVOID                               parameter
    );

VOID
SipAddRangeToFaultedList(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PSIS_SCB                         scb,
    IN PLARGE_INTEGER                   offset,
    IN LONGLONG                         length
    );

NTSTATUS
SipAddRangeToWrittenList(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PSIS_SCB                         scb,
    IN PLARGE_INTEGER                   offset,
    IN LONGLONG                         length
    );

SIS_RANGE_DIRTY_STATE
SipGetRangeDirty(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PSIS_SCB                         scb,
    IN PLARGE_INTEGER                   offset,
    IN LONGLONG                         length,
    IN BOOLEAN                          faultedIsDirty
    );

BOOLEAN
SipGetRangeEntry(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PSIS_SCB                         scb,
    IN LONGLONG                         startingOffset,
    OUT PLONGLONG                       length,
    OUT PSIS_RANGE_STATE                state);

typedef enum {
    FindAny,                            // find active or defunct scb
    FindActive                          // find only active scb
} SIS_FIND_TYPE;

#if     DBG

#define SipIsFileObjectSIS(fileObject, DeviceObject, findType, perFO, scb) \
        SipIsFileObjectSISInternal(fileObject, DeviceObject, findType, perFO, scb, __FILE__, __LINE__)

BOOLEAN
SipIsFileObjectSISInternal(
    IN PFILE_OBJECT                     fileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN SIS_FIND_TYPE                    findType,
    OUT PSIS_PER_FILE_OBJECT            *perFO OPTIONAL,
    OUT PSIS_SCB                        *scbReturn OPTIONAL,
    IN PCHAR                            fileName,
    IN ULONG                            fileLine
    );

#else   // DBG

BOOLEAN
SipIsFileObjectSIS(
    IN PFILE_OBJECT                     fileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN SIS_FIND_TYPE                    findType,
    OUT PSIS_PER_FILE_OBJECT            *perFO OPTIONAL,
    OUT PSIS_SCB                        *scbReturn OPTIONAL
    );

#endif  // DBG

NTSTATUS
SipClaimFileObject(
    IN OUT PFILE_OBJECT                 fileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PSIS_SCB                         scb
    );

VOID
SipUnclaimFileObject(
    IN OUT PFILE_OBJECT                 fileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN OUT PSIS_SCB                     scb
    );

PSIS_PER_FILE_OBJECT
SipAllocatePerFO(
    IN PSIS_FILTER_CONTEXT              fc,
    IN PFILE_OBJECT                     fileObject,
    IN PSIS_SCB                         scb,
    IN PDEVICE_OBJECT                   DeviceObject,
    OUT PBOOLEAN                        newPerFO OPTIONAL
    );

PSIS_PER_FILE_OBJECT
SipCreatePerFO(
    IN PFILE_OBJECT                     fileObject,
    IN PSIS_SCB                         scb,
    IN PDEVICE_OBJECT                   DeviceObject
    );

VOID
SipDeallocatePerFO(
    IN OUT PSIS_PER_FILE_OBJECT         perFO,
    IN PDEVICE_OBJECT                   DeviceObject
    );

NTSTATUS
SipInitializePrimaryScb(
    IN PSIS_SCB                         primaryScb,
    IN PSIS_SCB                         defunctScb,
    IN PFILE_OBJECT                     fileObject,
    IN PDEVICE_OBJECT                   DeviceObject
    );

NTSTATUS
SipFsControlFile(
    IN PFILE_OBJECT                     fileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN ULONG                            ioControlCode,
    IN PVOID                            inputBuffer,
    IN ULONG                            inputBufferLength,
    OUT PVOID                           outputBuffer,
    IN ULONG                            outputBufferLength,
    OUT PULONG                          returnedOutputBufferLength  OPTIONAL
    );

NTSTATUS
SipFsControlFileUsingGenericDevice(
    IN PFILE_OBJECT                     fileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN ULONG                            ioControlCode,
    IN PVOID                            inputBuffer,
    IN ULONG                            inputBufferLength,
    OUT PVOID                           outputBuffer,
    IN ULONG                            outputBufferLength,
    OUT PULONG                          returnedOutputBufferLength  OPTIONAL
    );

NTSTATUS
SipFlushBuffersFile(
    IN PFILE_OBJECT                     fileObject,
    IN PDEVICE_OBJECT                   DeviceObject
    );

NTSTATUS
SipAcquireUFO(
    IN PSIS_CS_FILE                     CSFile/*,
    IN BOOLEAN                          Wait*/);

VOID
SipReleaseUFO(
    IN PSIS_CS_FILE                     CSFile);

NTSTATUS
SipAcquireCollisionLock(
    IN PDEVICE_EXTENSION                DeviceExtension);

VOID
SipReleaseCollisionLock(
    IN PDEVICE_EXTENSION                DeviceExtension);

VOID
SipTruncateScb(
    IN OUT PSIS_SCB                     scb,
    IN LONGLONG                         newLength);

NTSTATUS
SipOpenFileById(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PLARGE_INTEGER                   linkFileNtfsId,
    IN ACCESS_MASK                      desiredAccess,
    IN ULONG                            shareAccess,
    IN ULONG                            createOptions,
    OUT PHANDLE                         openedFileHandle);

NTSTATUS
SipWriteFile(
    IN PFILE_OBJECT                     FileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    OUT PIO_STATUS_BLOCK                Iosb,
    IN PVOID                            Buffer,
    IN ULONG                            Length,
    IN PLARGE_INTEGER                   ByteOffset);

BOOLEAN
SipAssureNtfsIdValid(
    IN  PSIS_PER_FILE_OBJECT            PerFO,
    IN OUT PSIS_PER_LINK                PerLink);

BOOLEAN
SipAbort(
    IN PKEVENT event
    );

VOID
SipBeginDeleteModificationOperation(
    IN OUT PSIS_PER_LINK                perLink,
    IN BOOLEAN                          delete);

VOID
SipEndDeleteModificationOperation(
    IN OUT PSIS_PER_LINK                perLink,
    IN BOOLEAN                          delete);

NTSTATUS
SiCompleteLockIrpRoutine(
    IN PVOID                            Context,
    IN PIRP                             Irp);

PVOID
SipMapUserBuffer(
    IN OUT PIRP                         Irp);


NTSTATUS
SipAssureCSFileOpen(
    IN PSIS_CS_FILE                     CSFile);

NTSTATUS
SipCheckVolume(
    IN OUT PDEVICE_EXTENSION            deviceExtension);

NTSTATUS
SipCheckBackpointer(
    IN PSIS_PER_LINK                    PerLink,
    IN BOOLEAN                          Exclusive,
    OUT PBOOLEAN                        foundMatch      OPTIONAL);

NTSTATUS
SipAddBackpointer(
    IN PSIS_CS_FILE                     CSFile,
    IN PLINK_INDEX                      LinkFileIndex,
    IN PLARGE_INTEGER                   LinkFileNtfsId);

NTSTATUS
SipRemoveBackpointer(
    IN PSIS_CS_FILE                     CSFile,
    IN PLINK_INDEX                      LinkIndex,
    IN PLARGE_INTEGER                   LinkFileNtfsId,
    OUT PBOOLEAN                        ReferencesRemain);

NTSTATUS
SiDeleteAndSetCompletion(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp,
    IN PVOID                            Context);

VOID
SiTrimLogs(
    IN PVOID                            parameter);

VOID
SiLogTrimDpcRoutine(
    IN PKDPC                            dpc,
    IN PVOID                            context,
    IN PVOID                            systemArg1,
    IN PVOID                            systemArg2);

VOID
SipProcessRefcountUpdateLogRecord(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PSIS_LOG_REFCOUNT_UPDATE         logRecord);

NTSTATUS
SipAssureMaxIndexFileOpen(
    IN PDEVICE_EXTENSION                deviceExtension);

VOID
SipDereferenceObject(
    IN PVOID                            object);

BOOLEAN
SipAcquireBackpointerResource(
    IN PSIS_CS_FILE                     CSFile,
    IN BOOLEAN                          Exclusive,
    IN BOOLEAN                          Wait);

VOID
SipHandoffBackpointerResource(
    IN PSIS_CS_FILE                     CSFile);

VOID
SipReleaseBackpointerResource(
    IN PSIS_CS_FILE                     CSFile);

NTSTATUS
SipPrepareRefcountChangeAndAllocateNewPerLink(
    IN PSIS_CS_FILE                     CSFile,
    IN PLARGE_INTEGER                   LinkFileFileId,
    IN PDEVICE_OBJECT                   DeviceObject,
    OUT PLINK_INDEX                     newLinkIndex,
    OUT PSIS_PER_LINK                   *perLink,
    OUT PBOOLEAN                        prepared);

#if TIMING
VOID
SipTimingPoint(
    IN PCHAR                            file,
    IN ULONG                            line,
    IN ULONG                            n);

VOID
SipDumpTimingInfo();

VOID
SipClearTimingInfo();

VOID
SipInitializeTiming();
#endif  // TIMING

#if DBG
VOID
SipCheckpointLog();
#endif  // DBG
#endif      _SIp_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\sis.c ===
/*++

Copyright (c) 1989-1993, 1997-1999  Microsoft Corporation

Module Name:

    sis.c

Abstract:

    Code for the single instance store (SIS) filter driver.  Initially based on Darryl
    Havens' sfilter module.

Authors:

    Bill Bolosky & Scott Cutshall, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

LONG GCHEnableFastIo = 0;

#if     DBG
LONG        GCHEnableMarkPoint = 0;
LONG        GCHMarkPointNext = 0;
KSPIN_LOCK  MarkPointSpinLock[1];
CHAR        GCHMarkPointStrings[GCH_MARK_POINT_ROLLOVER][GCH_MARK_POINT_STRLEN];
PVOID       BJBMagicFsContext;
unsigned    BJBDebug = 0;
#endif  // DBG


//
// Global storage for this file system filter driver.
//

PDEVICE_OBJECT FsNtfsDeviceObject = NULL;

PDRIVER_OBJECT FsDriverObject;

LIST_ENTRY FsDeviceQueue;

ERESOURCE FsLock;

//
// Assign text sections for each routine.
//

#ifdef ALLOC_PRAGMA
#endif


NTSTATUS
SiPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the general purpose file
    system driver.  It simply passes requests onto the next driver in the
    stack, which is presumably a disk file system.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

    A note to filter file system implementers:  This routine actually "passes"
    through the request by taking this driver out of the loop.  If the driver
    would like to pass the I/O request through, but then also see the result,
    then rather than essentially taking itself out of the loop it could keep
    itself in by copying the caller's parameters to the next stack location
    and then set its own completion routine.  Note that it's important to not
    copy the caller's I/O completion routine into the next stack location, or
    the caller's routine will get invoked twice.

    Hence, this code could do the following:

        deviceExtension = DeviceObject->DeviceExtension;

        IoCopyCurrentIrpStackLocationToNext( Irp );
        IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE );

        return IoCallDriver( deviceExtension->AttachedToDeviceObject, Irp );

    This example actually NULLs out the caller's I/O completion routine, but
    this driver could set its own completion routine so that it could be
    notified when the request was completed.

    Note also that the following code to get the current driver out of the loop
    is not really kosher, but it does work and is much more efficient than the
    above.

--*/

{
    //
    //  The control device object can't be opened
    //

    ASSERT(!IS_MY_CONTROL_DEVICE_OBJECT( DeviceObject ));
    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Get this driver out of the driver stack and get to the next driver as
    //  quickly as possible.
    //

    IoSkipCurrentIrpStackLocation( Irp );
    
    //
    //  Call the appropriate file system driver with the request.
    //

    return IoCallDriver( ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );
}



NTSTATUS
SipCloseHandles(
    IN HANDLE           handle1,
    IN HANDLE           handle2             OPTIONAL,
    IN OUT PERESOURCE   resourceToRelease   OPTIONAL)
/*++

Routine Description:

    Close one or two handles in the PsInitialSystemProcess context.  Optionally takes
    a resource to be released when the close finishes.  Does not wait for the close
    to complete.

    Even if the call fails, the resource is still released.

Arguments:

    The handle(s) to be closed and the resource to be released.

Return Value:

    a failure or status pending.  There is no way provided to synchronize with the
    completion.

--*/

{
    PSI_CLOSE_HANDLES closeRequest;

    closeRequest = ExAllocatePoolWithTag(NonPagedPool, sizeof(SI_CLOSE_HANDLES), ' siS');

    if (NULL == closeRequest) {
        if (NULL != resourceToRelease) {
            ExReleaseResourceLite(resourceToRelease);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    closeRequest->handle1 = handle1;
    closeRequest->handle2 = handle2;
    closeRequest->resourceToRelease = resourceToRelease;
    closeRequest->resourceThreadId = ExGetCurrentResourceThread();

    //
    //  If we have a resource, change the owner from the thread to our worker
    //  thread structure address
    //

    if (resourceToRelease != NULL) {

        ExSetResourceOwnerPointer( resourceToRelease, 
                                   (PVOID)MAKE_RESOURCE_OWNER( closeRequest ));
    }

    ExInitializeWorkItem(closeRequest->workQueueItem, SipCloseHandlesWork, closeRequest);

    ExQueueWorkItem(closeRequest->workQueueItem, CriticalWorkQueue);

    return STATUS_PENDING;
}

VOID
SipCloseHandlesWork(
    IN PVOID        parameter)
/*++

Routine Description:

    ExWorkerThread routine to close a handle or two in the PsInitialProcess context.

Arguments:

    parameter - pointer to a SI_CLOSE_HANDLES structure

Return Value:

    None.

--*/

{
    PSI_CLOSE_HANDLES closeRequest = (PSI_CLOSE_HANDLES)parameter;

    SIS_MARK_POINT_ULONG(closeRequest);

    closeRequest->status = NtClose(closeRequest->handle1);

    if (NT_SUCCESS(closeRequest->status) && (NULL != closeRequest->handle2)) {
        closeRequest->status = NtClose(closeRequest->handle2);
    }

    if (NULL != closeRequest->resourceToRelease) {
        ExReleaseResourceForThreadLite(closeRequest->resourceToRelease, 
                                       MAKE_RESOURCE_OWNER(closeRequest));
    }

    ExFreePool(closeRequest);

    return;
}

NTSTATUS
SipOpenBackpointerStream(
    IN PSIS_CS_FILE csFile,
    IN ULONG CreateDisposition
    )
/*++

Routine Description:

    Open a the backpointer stream of a common store file.  We must hold the
    UFOMutant to call this routine.

    Open the backpointer stream as a relative open to the main data stream.
    We open it write-through because we rely on backpointer writes really
    happening when we're told they are.

    Must be called in the PsInitialSystemProcess context.

Arguments:

    CSFile - The CSFile structure describing the underlying file to open

Return Value:

    The function value is the status of the operation.

--*/
{
    OBJECT_ATTRIBUTES               Obja;
    NTSTATUS                        status;
    IO_STATUS_BLOCK                 Iosb;
    UNICODE_STRING                  streamName;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    ASSERT(NULL == csFile->BackpointerStreamHandle);
    ASSERT(NULL == csFile->BackpointerStreamFileObject);
    ASSERT(NULL != csFile->UnderlyingFileHandle);
//    ASSERT(IS_SYSTEM_THREAD(PsGetCurrentThread()));

    streamName.Buffer = BACKPOINTER_STREAM_NAME;
    streamName.MaximumLength = BACKPOINTER_STREAM_NAME_SIZE;
    streamName.Length = BACKPOINTER_STREAM_NAME_SIZE;

    InitializeObjectAttributes(
        &Obja,
        &streamName,
        OBJ_CASE_INSENSITIVE,
        csFile->UnderlyingFileHandle,
        NULL);

    status = NtCreateFile(
                &csFile->BackpointerStreamHandle,
                GENERIC_READ | GENERIC_WRITE,
                &Obja,
                &Iosb,
                NULL,                   // Allocation Size
                0,                      // File Attributes
#if DBG
                (BJBDebug & 0x10000000) ?
                    FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE :
                                       FILE_SHARE_READ | FILE_SHARE_DELETE,
#else
                FILE_SHARE_READ | FILE_SHARE_DELETE,
#endif
                CreateDisposition,
    /*BJB*/ FILE_SYNCHRONOUS_IO_NONALERT |
                FILE_NON_DIRECTORY_FILE,
                NULL,                   // EA Buffer
                0);                     // EA Length

    if (STATUS_SHARING_VIOLATION == status) {
        PDEVICE_EXTENSION   deviceExtension = csFile->DeviceObject->DeviceExtension;

        //
        // We may be getting a sharing violation with ourselves as we try to close
        // the handles on this file.  Take the device-wide CSFileHandleResource
        // exclusively and retry the create.
        //

        SIS_MARK_POINT_ULONG(csFile);

        ExAcquireResourceExclusiveLite(deviceExtension->CSFileHandleResource, TRUE);

        status = NtCreateFile(
                    &csFile->BackpointerStreamHandle,
                    GENERIC_READ | GENERIC_WRITE,
                    &Obja,
                    &Iosb,
                    NULL,                   // Allocation Size
                    0,                      // File Attributes
#if DBG
                    (BJBDebug & 0x10000000) ?
                        FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE :
                                           FILE_SHARE_READ | FILE_SHARE_DELETE,
#else
                    FILE_SHARE_READ | FILE_SHARE_DELETE,
#endif
                    CreateDisposition,
    /*BJB*/ FILE_SYNCHRONOUS_IO_NONALERT |
                    FILE_NON_DIRECTORY_FILE,
                    NULL,                   // EA Buffer
                    0);                     // EA Length

        //
        // If it failed this time, it's something else and we can let the whole thing fail.
        //

        ExReleaseResourceLite(deviceExtension->CSFileHandleResource);
    }

    return status;
}


NTSTATUS
SipOpenCSFileWork(
    IN PSIS_CS_FILE     CSFile,
    IN BOOLEAN          openByName,
    IN BOOLEAN          volCheck,
    IN BOOLEAN          openForDelete,
    OUT PHANDLE         openedFileHandle OPTIONAL
    )
/*++

Routine Description:

    Open a file in the common store.  We must hold the UFOMutant to call this routine,
    and must be in the PsInitialSystemProcess context.

Arguments:

    CSFile     - The CSFile structure describing the underlying file to open

    openByName - If TRUE, then the file will be opened by name, otherwise it will
                 be opened by ID.

    volCheck   - If TRUE, then a backpointer stream open failure will not
                 cause entire open to abort.

    openForDelete -
                Should we open the file with DELETE permission?

    openedFileHandle - pointer to a variable to receive the opened handle.  If this is
                 specified, the UFOHandle and UnderlyingFileObject in the CSFile will
                 NOT be affected, and we will not take a reference to the file object
                 or fill in the file size info in the CSFile structure or open the
                 backpointer stream and read in the CS file checksum.

Return Value:

    The function value is the status of the operation.

--*/
{
    OBJECT_ATTRIBUTES               Obja;
    PDEVICE_EXTENSION               deviceExtension;
    NTSTATUS                        status;
    IO_STATUS_BLOCK                 Iosb;
    FILE_STANDARD_INFORMATION       standardFileInfo[1];
    HANDLE                          localHandle = NULL;
    HANDLE                          ioEventHandle = NULL;
    PKEVENT                         ioEvent = NULL;
    LARGE_INTEGER                   zero;
    SIS_BACKPOINTER_STREAM_HEADER   backpointerStreamHeader[1];
    FILE_INTERNAL_INFORMATION       internalInfo[1];
    KIRQL                           OldIrql;
    BOOLEAN                         retry = FALSE;
    ULONG                           sectorFill;
    LONGLONG                        csFileChecksum;
    BOOLEAN                         grovelerFileHeld = FALSE;

    //
    // Note that we're overloading nameBuffer as both the fileName buffer
    // and the FILE_NAME_INFORMATION buffer.
    //

#define FN_STACK_BUFFER_LENGTH 240

    UNICODE_STRING              fileName;
    union {
        FILE_NAME_INFORMATION   nameFileInfo[1];
        WCHAR                   nameBuffer[FN_STACK_BUFFER_LENGTH];
    } nameFile;


    UNREFERENCED_PARAMETER( volCheck );

    //
    // Restart here after repairing the backpointer stream.
    //
Restart:

    ASSERT(openByName || !openForDelete);   // can't delete files opened by ID, so we shouldn't be asking for that

/*BJB*/ openByName = TRUE;  // just ignore the NTFS id for the CS file for now.

    if (NULL == openedFileHandle) {
        //
        // If we've already got the file partially open (which can happen primarily in
        // backup/restore situations), then close what we've got and retry.
        //
        if (NULL != CSFile->UnderlyingFileHandle) {
            NtClose(CSFile->UnderlyingFileHandle);
            CSFile->UnderlyingFileHandle = NULL;
        }

        if (NULL != CSFile->UnderlyingFileObject) {
            ObDereferenceObject(CSFile->UnderlyingFileObject);
            CSFile->UnderlyingFileObject = NULL;
        }

        if (NULL != CSFile->BackpointerStreamFileObject) {
            ObDereferenceObject(CSFile->BackpointerStreamFileObject);
            CSFile->BackpointerStreamFileObject = NULL;
        }

        if (NULL != CSFile->BackpointerStreamHandle) {
            NtClose(CSFile->BackpointerStreamHandle);
            CSFile->BackpointerStreamHandle = NULL;
        }
    }


    if (!(CSFile->Flags & CSFILE_NTFSID_SET)) {
        //
        // We don't know the file id, so we have to open by name.
        //
        openByName = TRUE;
    }

    SIS_MARK_POINT_ULONG(((ULONG_PTR)CSFile)|(ULONG)openByName);

    deviceExtension = CSFile->DeviceObject->DeviceExtension;

    fileName.Buffer = nameFile.nameBuffer;
    fileName.MaximumLength = FN_STACK_BUFFER_LENGTH * sizeof(WCHAR);

    // NB: we can't goto Cleanup until here, because it assumes that
    // fileName.Buffer is initialized.

    //
    // We're going to eventually need to verify that the opened common store file
    // is on the right volume.  We do this by checking to see if it matches
    // with the groveler file object.  If, for some reason, we don't have a groveler
    // file object, then just punt now.  We don't need to disable APCs, because
    // we're in a system thread.
    //

//    ASSERT(IS_SYSTEM_THREAD(PsGetCurrentThread()));
    ExAcquireResourceSharedLite(deviceExtension->GrovelerFileObjectResource, TRUE);
    grovelerFileHeld = TRUE;

    if (NULL == deviceExtension->GrovelerFileObject) {
        SIS_MARK_POINT();

        status = STATUS_DRIVER_INTERNAL_ERROR;
        goto Cleanup;
    }

    if (!openByName) {
        //
        // Try to open the file by ID first.
        //

        status = SipOpenFileById(
                    deviceExtension,
                    &CSFile->CSFileNtfsId,
                    GENERIC_READ,                       // can't have !openByName && openForDelete
#if DBG
                    (BJBDebug & 0x10000000) ?
                        FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE :
                                           FILE_SHARE_READ | FILE_SHARE_DELETE,
#else
                    FILE_SHARE_READ | FILE_SHARE_DELETE,
#endif
                    FILE_NON_DIRECTORY_FILE,
                    &localHandle);

        if (!NT_SUCCESS(status)) {
            //
            // Open by id didn't work, so we'll just try opening by name instead.
            //
            openByName = TRUE;
        } else {

            //
            // Verify that the file we opened is what we think it is.  Do that
            // by verifing its name.
            //
            // OPTIMIZATION: is this faster than just opening-by-name?
            //

            status = NtQueryInformationFile(
                        localHandle,
                        &Iosb,
                        nameFile.nameFileInfo,
                        sizeof(nameFile),
                        FileNameInformation);

            if (NT_SUCCESS(status)) {
                SIZE_T  rc;

                //
                // Compare the directory component first.
                //

                rc = RtlCompareMemory(
                        nameFile.nameFileInfo->FileName,
                        SIS_CSDIR_STRING,
                        min(SIS_CSDIR_STRING_SIZE, nameFile.nameFileInfo->FileNameLength));

                if (rc == SIS_CSDIR_STRING_SIZE) {
                    CSID CSid;

                    //
                    // That matched, now compare the file name component.
                    //

                    fileName.Buffer = nameFile.nameFileInfo->FileName + SIS_CSDIR_STRING_NCHARS;
                    fileName.Length = (USHORT) nameFile.nameFileInfo->FileNameLength - SIS_CSDIR_STRING_SIZE;

                    if (SipFileNameToIndex(&fileName, &CSid) &&
                        IsEqualGUID(&CSid,&CSFile->CSid)) {

                        //
                        // They match.
                        //
                        openByName = FALSE;
                    } else {
                        //
                        // This is some other file, just open by name.
                        //
                        openByName = TRUE;
                    }

                    fileName.Buffer = nameFile.nameBuffer;
                }

            } else {

#if     DBG
                DbgPrint("SIS: SipOpenCSFile: NtQueryInformationFile(1) failed, 0x%x\n",status);
#endif  // DBG

                //
                // Re-try using the name.  Also, reset the CSID valid bit, since it obviously ain't.
                //
                openByName = TRUE;

                KeAcquireSpinLock(CSFile->SpinLock, &OldIrql);
                CSFile->Flags &= ~CSFILE_NTFSID_SET;
                KeReleaseSpinLock(CSFile->SpinLock, OldIrql);
            }

            //
            // Close the file if we got a failure above.
            //
            if (openByName) {
                NtClose(localHandle);
#if DBG
                DbgPrint("SIS: SipOpenCSFile: Open by ID failed.\n");
#endif
            }
        }
    }

    if (openByName) {

        //
        // We were unable to open the file by id.  Try opening it by name.
        //
        //  NTRAID#65196-2000/03/10-nealch  If the open-by-ID failed and open-by-name succeeds, 
        //  we should update the ID in the link file reparse info.
        //

        status = SipIndexToFileName(
                    deviceExtension,
                    &CSFile->CSid,
                    0,                      // append bytes
                    TRUE,                   // may allocate
                    &fileName);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Cleanup;
        }

        InitializeObjectAttributes(
            &Obja,
            &fileName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

        status = NtCreateFile(
                    &localHandle,
                    GENERIC_READ | (openForDelete ? DELETE : 0),
                    &Obja,
                    &Iosb,
                    NULL,                               // Allocation Size
                    0,                                  // File Attributes (ignored since we're not creating)
#if DBG
                    (BJBDebug & 0x10000000) ?
                        FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE :
                                           FILE_SHARE_READ | FILE_SHARE_DELETE,
#else
                    FILE_SHARE_READ | FILE_SHARE_DELETE,
#endif
                    FILE_OPEN,                          // Don't create if it doesn't already exist
                    FILE_NON_DIRECTORY_FILE,            // Asynchornous (ie., doesn't specify synchronous)
                    NULL,                               // EA buffer
                    0);                                 // EA length

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            localHandle = NULL;
#if     DBG
            if (STATUS_OBJECT_NAME_NOT_FOUND != status) {
                DbgPrint("SIS: SipOpenCSFile: NtCreateFile failed, 0x%x\n",status);
            }
#endif  // DBG
            goto Cleanup;
        }
    }

    if (NULL != openedFileHandle) {
        *openedFileHandle = localHandle;
    } else {
        //
        // See if we need to read in the file id.
        //
        if (!(CSFile->Flags & CSFILE_NTFSID_SET)) {
            status = NtQueryInformationFile(
                        localHandle,
                        &Iosb,
                        internalInfo,
                        sizeof(*internalInfo),
                        FileInternalInformation);

            if (NT_SUCCESS(status)) {

                KeAcquireSpinLock(CSFile->SpinLock, &OldIrql);
                CSFile->Flags |= CSFILE_NTFSID_SET;
                CSFile->CSFileNtfsId = internalInfo->IndexNumber;
                KeReleaseSpinLock(CSFile->SpinLock, OldIrql);

            } else {
                //
                // Just ignore the error and leave the NTFS id invalid.
                //
                SIS_MARK_POINT_ULONG(status);
            }
        }

        CSFile->UnderlyingFileHandle = localHandle;
        CSFile->UnderlyingFileObject = NULL;        // Filled in later

        status = NtQueryInformationFile(
                    localHandle,
                    &Iosb,
                    standardFileInfo,
                    sizeof(*standardFileInfo),
                    FileStandardInformation);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
#if     DBG
            DbgPrint("SIS: SipOpenCSFile: NtQueryInformationFile(2) failed, 0x%x\n",status);
#endif  // DBG
            goto Cleanup;
        }

        CSFile->FileSize = standardFileInfo->EndOfFile;

        // Now we've got a handle, and we really need a pointer to the file object.  Get it.
        status = ObReferenceObjectByHandle(
                    CSFile->UnderlyingFileHandle,
                    0,                                  // Desired access
                    *IoFileObjectType,
                    KernelMode,
                    &CSFile->UnderlyingFileObject,
                    NULL);                              // Handle information

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
#if     DBG
            DbgPrint("SIS: SipOpenCSFile: ObReferenceObjectByHandle failed, 0x%x\n",status);
#endif  // DBG
            goto Cleanup;
        }

        //
        // Veriy that the common store file object is on the right volume.
        //
        if (IoGetRelatedDeviceObject(CSFile->UnderlyingFileObject) !=
            IoGetRelatedDeviceObject(deviceExtension->GrovelerFileObject)) {

            SIS_MARK_POINT();
            status = STATUS_NOT_SAME_DEVICE;

            goto Cleanup;
        }

        ExReleaseResourceLite(deviceExtension->GrovelerFileObjectResource);
        grovelerFileHeld = FALSE;

        status = SipCreateEvent(
                    SynchronizationEvent,
                    &ioEventHandle,
                    &ioEvent);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Cleanup;
        }

        //
        // We need to get the checksum from the file.  First, open the
        // backpointer stream.
        //
        status = SipOpenBackpointerStream(CSFile, FILE_OPEN);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);

            ASSERT(NULL == CSFile->BackpointerStreamHandle);

            if ((STATUS_OBJECT_NAME_NOT_FOUND == status) ||
                (STATUS_OBJECT_PATH_INVALID == status)) {
                    //
                    // The backpointer stream is just gone.
                    //
                    goto InvalidBPStream;
            }

            goto Cleanup;
        }

        status = ObReferenceObjectByHandle(
                    CSFile->BackpointerStreamHandle,
                    0,                                      // Desired access
                    *IoFileObjectType,
                    KernelMode,
                    &CSFile->BackpointerStreamFileObject,
                    NULL);                                  // Handle Information

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);

            goto Cleanup;
        }

        zero.QuadPart = 0;

        status = NtReadFile(
                    CSFile->BackpointerStreamHandle,
                    ioEventHandle,
                    NULL,                   // APC routine
                    NULL,                   // APC context
                    &Iosb,
                    backpointerStreamHeader,
                    sizeof(*backpointerStreamHeader),
                    &zero,
                    NULL);                  // key

        if (STATUS_PENDING == status) {
            status = KeWaitForSingleObject(ioEvent, Executive, KernelMode, FALSE, NULL);
            ASSERT(STATUS_SUCCESS == status);

            status = Iosb.Status;
        }

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);

            if (STATUS_END_OF_FILE == status) {
                //
                // There's nothing in the backpointer stream.
                //
                goto InvalidBPStream;
            }

            goto Cleanup;
        }

        //
        // Check that we got what we thought we should get.
        //
        if (Iosb.Information < sizeof(*backpointerStreamHeader)) {
            //
            // The backpointer stream is gone.  Volume check.  In the interim we can't allow
            // this file open to proceed because we can't verify the checksum, so fail this
            // create.
            //

            status = STATUS_FILE_INVALID;
            goto InvalidBPStream;

        } else if (BACKPOINTER_MAGIC != backpointerStreamHeader->Magic) {
            SIS_MARK_POINT();

            status = STATUS_FILE_INVALID;
            goto InvalidBPStream;

        } else if (BACKPOINTER_STREAM_FORMAT_VERSION != backpointerStreamHeader->FormatVersion) {
            SIS_MARK_POINT();

            status = STATUS_UNKNOWN_REVISION;
            goto Cleanup;
        }

        CSFile->Checksum = backpointerStreamHeader->FileContentChecksum;

        //
        // Guesstimate the BPStreamEntries value by looking at the length of the BP stream.
        //

        status = NtQueryInformationFile(
                    CSFile->BackpointerStreamHandle,
                    &Iosb,
                    standardFileInfo,
                    sizeof(*standardFileInfo),
                    FileStandardInformation);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Cleanup;
        }

        CSFile->BPStreamEntries = (ULONG)(standardFileInfo->EndOfFile.QuadPart / sizeof(SIS_BACKPOINTER) - SIS_BACKPOINTER_RESERVED_ENTRIES);

        if (CSFile->BPStreamEntries < 1) {
            SIS_MARK_POINT_ULONG(CSFile->BPStreamEntries);
            SipCheckVolume(deviceExtension);
        }

        //
        // If the backpointer stream is not a multiple of sector size, make it so.
        // Fill the end of the last sector with MAXLONGLONG fields.
        //
        sectorFill = (ULONG) (standardFileInfo->EndOfFile.QuadPart % deviceExtension->FilesystemVolumeSectorSize);

        if (sectorFill != 0) {
            SIS_BACKPOINTER fillBP[1];
            LARGE_INTEGER ef = {FILE_WRITE_TO_END_OF_FILE, -1};
            PCHAR sectorFillBuffer;
            PCHAR s, d;
            int i, c;

            SIS_MARK_POINT_ULONG(standardFileInfo->EndOfFile.LowPart);

            fillBP->LinkFileIndex.QuadPart = MAXLONGLONG;
            fillBP->LinkFileNtfsId.QuadPart = MAXLONGLONG;

            //
            // Convert from # bytes used to # bytes free.
            //
            sectorFill = deviceExtension->FilesystemVolumeSectorSize - sectorFill;

            sectorFillBuffer = ExAllocatePoolWithTag(PagedPool, sectorFill, ' siS');
            if (NULL == sectorFillBuffer) {
                SIS_MARK_POINT();
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            //
            // Fill the buffer from back to front, since we know the
            // back end is aligned and the front may not be.
            //
            c = min(sectorFill, sizeof(SIS_BACKPOINTER));

            d = sectorFillBuffer + sectorFill - c;
            s = (PCHAR) (fillBP + 1) - c;
            memcpy(d, s, c);

            s = sectorFillBuffer + sectorFill;
            s--; d--;

            for (i = sectorFill - c; i > 0; --i) {
                *d-- = *s--;
            }

            ASSERT(d+1 == sectorFillBuffer);

            status = NtWriteFile(
                        CSFile->BackpointerStreamHandle,
                        ioEventHandle,
                        NULL,                   // APC routine
                        NULL,                   // APC context
                        &Iosb,
                        sectorFillBuffer,
                        sectorFill,
                        &ef,
                        NULL);                  // key

            if (STATUS_PENDING == status) {
                status = KeWaitForSingleObject(ioEvent, Executive, KernelMode, FALSE, NULL);
                ASSERT(STATUS_SUCCESS == status);

                status = Iosb.Status;
            }

            ExFreePool(sectorFillBuffer);

            if (!NT_SUCCESS(status)) {
                SIS_MARK_POINT_ULONG(status);
                goto Cleanup;
            }

            CSFile->BPStreamEntries = (ULONG)
                ((standardFileInfo->EndOfFile.QuadPart + deviceExtension->FilesystemVolumeSectorSize - 1) /
                    deviceExtension->FilesystemVolumeSectorSize) * deviceExtension->BackpointerEntriesPerSector -
                    SIS_BACKPOINTER_RESERVED_ENTRIES;
        }

#if DBG
        if (BJBDebug & 0x200) {
            DbgPrint("SIS: SipOpenCSFileWork: CS file has checksum 0x%x.%x\n",
                        (ULONG)(CSFile->Checksum >> 32),(ULONG)CSFile->Checksum);
        }
#endif  // DBG

        ASSERT((CSFile->BPStreamEntries + SIS_BACKPOINTER_RESERVED_ENTRIES) % deviceExtension->BackpointerEntriesPerSector == 0);
    }

    status = STATUS_SUCCESS;

Cleanup:

    if (grovelerFileHeld) {
        ExReleaseResourceLite(deviceExtension->GrovelerFileObjectResource);
        grovelerFileHeld = FALSE;
    }

    if (!NT_SUCCESS(status)) {
        if (NULL != localHandle) {
            NtClose(localHandle);
            localHandle = NULL;

            if (NULL != openedFileHandle) {
                *openedFileHandle = NULL;
            } else {
                CSFile->UnderlyingFileHandle = NULL;
                if (NULL != CSFile->UnderlyingFileObject) {
                    ObDereferenceObject(CSFile->UnderlyingFileObject);
                    CSFile->UnderlyingFileObject = NULL;
                }
            }
        }

        if ((NULL != CSFile->BackpointerStreamHandle) && (NULL == openedFileHandle)) {
            NtClose(CSFile->BackpointerStreamHandle);

            if (NULL != CSFile->BackpointerStreamFileObject) {
                ObDereferenceObject(CSFile->BackpointerStreamFileObject);
            }

            CSFile->BackpointerStreamHandle = NULL;
            CSFile->BackpointerStreamFileObject = NULL;
        }
    }

    if (fileName.Buffer != nameFile.nameBuffer) {
        ExFreePool(fileName.Buffer);
    }

    if (NULL != ioEvent) {
        ObDereferenceObject(ioEvent);
        ioEvent = NULL;
    }

    if (NULL != ioEventHandle) {
        NtClose(ioEventHandle);
        ioEventHandle = NULL;
    }

    if (retry) {
        retry = FALSE;
        goto Restart;
    }

    ASSERT((CSFile->BPStreamEntries + SIS_BACKPOINTER_RESERVED_ENTRIES) % deviceExtension->BackpointerEntriesPerSector == 0 ||
            ((CSFile->Flags & (CSFILE_FLAG_DELETED|CSFILE_FLAG_CORRUPT)) && 0 == CSFile->BPStreamEntries) ||
            !NT_SUCCESS(status));

    return status;


InvalidBPStream:

    //
    // The backpointer stream is corrupt, attempt to fix it.
    //
    ASSERT(NULL != CSFile->UnderlyingFileHandle);
    ASSERT(NULL != ioEventHandle && NULL != ioEvent);

    switch (status) {
    case STATUS_OBJECT_PATH_NOT_FOUND:
    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_OBJECT_PATH_INVALID:
        //
        // The backpointer stream is missing.  Create it.
        //
        ASSERT(NULL == CSFile->BackpointerStreamHandle);

        status = SipOpenBackpointerStream(CSFile, FILE_CREATE);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            break;
        }

    case STATUS_FILE_INVALID:
    case STATUS_END_OF_FILE:
        //
        // The backpointer stream header is corrupt, ie. the stream is
        // smaller than the header, or the magic number is invalid.
        // Rebuild it.
        //
        ASSERT(NULL != CSFile->BackpointerStreamHandle);

        status = SipComputeCSChecksum(
                    CSFile,
                    &csFileChecksum,
                    ioEventHandle,
                    ioEvent);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            break;
        }

        //
        // Initialize the backpointer sector.  First write the header,
        // then fill in the remainder of the backpointer entries.
        //

        backpointerStreamHeader->FormatVersion = BACKPOINTER_STREAM_FORMAT_VERSION;
        backpointerStreamHeader->Magic = BACKPOINTER_MAGIC;
        backpointerStreamHeader->FileContentChecksum = csFileChecksum;

        //
        // Write the stream header to disk.
        //

        zero.QuadPart = 0;

        status = ZwWriteFile(
                        CSFile->BackpointerStreamHandle,
                        ioEventHandle,
                        NULL,                   // APC Routine
                        NULL,                   // APC Context
                        &Iosb,
                        backpointerStreamHeader,
                        sizeof *backpointerStreamHeader,
                        &zero,
                        NULL);                  // key

        if (STATUS_PENDING == status) {
            status = KeWaitForSingleObject(ioEvent, Executive, KernelMode, FALSE, NULL);
            ASSERT(status == STATUS_SUCCESS); // Since we've got this pointed at our stack, it must succeed.

            status = Iosb.Status;
        }

        //
        // If all repairs have succeeded, retry from the top.
        //
        if (NT_SUCCESS(status))
            retry = TRUE;

        break;

    default:
        ASSERT(!"SipOpenCSFileWork: Internal Error");
    }

    goto Cleanup;
#undef  FN_STACK_BUFFER_LENGTH
}

VOID
SipOpenCSFile(
    IN OUT PSI_OPEN_CS_FILE     openRequest
    )
/*++

Routine Description:

    Open a file in the common store.  We must hold the UFOMutant to call this routine.

Arguments:

    openRequest - Argument packet.

Return Value:

    None

--*/
{
    openRequest->openStatus = SipOpenCSFileWork(
                                    openRequest->CSFile,
                                    openRequest->openByName,
                                    FALSE,                      // volcheck
                                    FALSE,                      // openForDelete
                                    NULL);

    KeSetEvent(openRequest->event,IO_NO_INCREMENT,FALSE);
}

PVOID
SipMapUserBuffer(
    IN OUT PIRP                         Irp)
{
    PVOID SystemBuffer;
    PAGED_CODE();

    //
    // If there is no Mdl, then we must be in the Fsd, and we can simply
    // return the UserBuffer field from the Irp.
    //

    if (Irp->MdlAddress == NULL) {

        return Irp->UserBuffer;

    } else {

        //
        //  MM can return NULL if there are no system ptes.  We just pass it through, and let the
        //  caller deal with it.
        //

        SystemBuffer = MmGetSystemAddressForMdl( Irp->MdlAddress );

        return SystemBuffer;
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
//                              Debug Support
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#if     DBG
LONG
SipAllocateMarkPoint(void)
{
    LONG    MarkPointThis;
    KIRQL   OldIrql;

    KeAcquireSpinLock(MarkPointSpinLock, &OldIrql);
    MarkPointThis = GCHMarkPointNext;
    GCHMarkPointNext = (GCHMarkPointNext + 1)%GCH_MARK_POINT_ROLLOVER;
    KeReleaseSpinLock(MarkPointSpinLock, OldIrql);

    RtlZeroMemory(GCHMarkPointStrings[MarkPointThis],GCH_MARK_POINT_STRLEN);

    return MarkPointThis;
}

VOID
SipMarkPointUlong(
    IN PCHAR pszFile,
    IN ULONG nLine,
    IN ULONG_PTR value
    )
{
    LONG MarkPointThis = SipAllocateMarkPoint();
    PCHAR sp = strrchr(pszFile, '\\');
    LARGE_INTEGER tickCount;
    PCHAR buffer = GCHMarkPointStrings[MarkPointThis];
    int ccnt;

    ASSERT((buffer - GCHMarkPointStrings[0]) % GCH_MARK_POINT_STRLEN == 0);

    if (sp)
        pszFile = sp + 1;

    KeQueryTickCount(&tickCount);

    ccnt = sprintf(buffer, "%-12s\t%4d\tT: %p\tTC:%d\t%p",
                    pszFile,
                    nLine,
                    PsGetCurrentThread(),
                    tickCount.LowPart,
                    value);

    ASSERT(ccnt < GCH_MARK_POINT_STRLEN);

    if (GCHEnableMarkPoint > 0)
        DbgPrint("SIS:  %s\n", GCHMarkPointStrings[MarkPointThis]);

}
#endif  // DBG

#if     DBG
VOID SipMarkPoint(
    IN PCHAR pszFile,
    IN ULONG nLine
    )
{
    LONG MarkPointThis = SipAllocateMarkPoint();
    PCHAR sp = strrchr(pszFile, '\\');
    LARGE_INTEGER tickCount;
    PCHAR buffer = GCHMarkPointStrings[MarkPointThis];
    int ccnt;

    ASSERT((buffer - GCHMarkPointStrings[0]) % GCH_MARK_POINT_STRLEN == 0);

    if (sp)
        pszFile = sp + 1;

    KeQueryTickCount(&tickCount);

    ccnt = sprintf(buffer, "%-12s\t%4d\tT: %p\tTC:%d",
                    pszFile,
                    nLine,
                    PsGetCurrentThread(),
                    tickCount.LowPart);

    ASSERT(ccnt < GCH_MARK_POINT_STRLEN);

    if (GCHEnableMarkPoint > 0)
        DbgPrint("SIS:  %s\n", buffer);
}



ULONG DisplayIndexMin = 0;
ULONG DisplayIndexMax = 0;

BOOLEAN DumpCheckpointLog = FALSE;

ULONG CheckpointMarkPointNext = 0;
CHAR  CheckpointMarkPointStrings[GCH_MARK_POINT_ROLLOVER][GCH_MARK_POINT_STRLEN];


VOID
SipCheckpointLog()
{
    KIRQL       OldIrql;

    KeAcquireSpinLock(MarkPointSpinLock, &OldIrql);

    RtlCopyMemory(CheckpointMarkPointStrings, GCHMarkPointStrings, sizeof(CHAR) * GCH_MARK_POINT_ROLLOVER * GCH_MARK_POINT_STRLEN);

    CheckpointMarkPointNext = GCHMarkPointNext;
    KeReleaseSpinLock(MarkPointSpinLock, OldIrql);
}

VOID
SipAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    )
{
    KIRQL   OldIrql;
    ULONG   i;

    //
    // Take the MarkPointSpinLock.  This will stop other processors from
    // messing with the debug log, and will also effectively stop all of
    // the other processors pretty quickly as they try to make debug log
    // entries.
    //

    KeAcquireSpinLock(MarkPointSpinLock, &OldIrql);

    DisplayIndexMin = DisplayIndexMax = GCHMarkPointNext;

    DbgPrint("***  SIS assertion failed: %s\n",FailedAssertion);
    DbgPrint("***    Source File: %s, line %d\n",FileName,LineNumber);
    if (NULL != Message) {
        DbgPrint("%s\n",Message);
    }
    DbgBreakPoint();

    if (DumpCheckpointLog) {
        DisplayIndexMin = (CheckpointMarkPointNext + 1) % GCH_MARK_POINT_ROLLOVER;
        DisplayIndexMax = CheckpointMarkPointNext;
    }

    while (DisplayIndexMin != DisplayIndexMax) {
        for (   i = DisplayIndexMin;
                i != DisplayIndexMax % GCH_MARK_POINT_ROLLOVER;
                i = (i+1)%GCH_MARK_POINT_ROLLOVER
            ) {
                if (DumpCheckpointLog) {
                    DbgPrint(   "%d\t%s\n",
                            (i + GCH_MARK_POINT_ROLLOVER - CheckpointMarkPointNext) % GCH_MARK_POINT_ROLLOVER,
                            CheckpointMarkPointStrings[i]);
                } else {
                    DbgPrint(   "%d\t%s\n",
                            (i + GCH_MARK_POINT_ROLLOVER - GCHMarkPointNext) % GCH_MARK_POINT_ROLLOVER,
                            GCHMarkPointStrings[i]);
                }
        }

        DisplayIndexMin = DisplayIndexMax = GCHMarkPointNext;
        DumpCheckpointLog = FALSE;

        DbgBreakPoint();
    }

    KeReleaseSpinLock(MarkPointSpinLock, OldIrql);
}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\siread.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    siread.c

Abstract:

	Read routines for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

VOID
SiReadUpdateRanges(
	PVOID					Parameter)
{
	PRW_COMPLETION_UPDATE_RANGES_CONTEXT	updateContext = Parameter;
	PSIS_SCB								scb = updateContext->scb;

	SIS_MARK_POINT_ULONG(updateContext);
	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	SipAcquireScb(scb);
	
	SipAddRangeToFaultedList(
		updateContext->deviceExtension,
		scb,
		&updateContext->offset,
		updateContext->length);

	scb->Flags |= SIS_SCB_ANYTHING_IN_COPIED_FILE;

	SipReleaseScb(scb);

	SipDereferenceScb(scb,RefsReadCompletion);

	ExFreePool(updateContext);

	return;
}

typedef struct _SI_MULTI_COMPLETE_CONTEXT {
	KEVENT					event[1];
	ULONG					associatedIrpCount;
	KSPIN_LOCK				SpinLock[1];
	IO_STATUS_BLOCK			Iosb[1];
	PIRP					finalAssociatedIrp;
	PDEVICE_EXTENSION		deviceExtension;
	PSIS_SCB				scb;
} SI_MULTI_COMPLETE_CONTEXT, *PSI_MULTI_COMPLETE_CONTEXT;

NTSTATUS
SiMultiReadCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
	)
{
	PSI_MULTI_COMPLETE_CONTEXT 	Context = (PSI_MULTI_COMPLETE_CONTEXT)Contxt;
	PIO_STACK_LOCATION			irpSp = IoGetCurrentIrpStackLocation(Irp);
	BOOLEAN						truncated;
	KIRQL						OldIrql;

	SIS_MARK_POINT_ULONG(irpSp->Parameters.Read.ByteOffset.LowPart);
	SIS_MARK_POINT_ULONG(Irp->IoStatus.Information);

	//
	// We don't necessarily have a valid DeviceObject parameter, so just fill it in
	// from our internal data structures.
	//
	DeviceObject = Context->scb->PerLink->CsFile->DeviceObject;

	truncated = (irpSp->Parameters.Read.Length != Irp->IoStatus.Information);

	if (!NT_SUCCESS(Irp->IoStatus.Status)) {
		SIS_MARK_POINT_ULONG(Irp->IoStatus.Status);

#if		DBG
//		DbgPrint("SIS: SiMultiReadCompletion: failed status 0x%x\n",Irp->IoStatus.Status);
#endif	// DBG

		KeAcquireSpinLock(Context->SpinLock, &OldIrql);
		*Context->Iosb = Irp->IoStatus;
		KeReleaseSpinLock(Context->SpinLock, OldIrql);
	} else if (Irp->Flags & IRP_PAGING_IO) {
		//
		// We need to update the faulted range for the file.  If we're at
		// dispatch level, we can't acquire the SCB in order to do it, so
		// we'll "post" the work.
		//
		if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
			PRW_COMPLETION_UPDATE_RANGES_CONTEXT	updateContext;
		
			SIS_MARK_POINT();

			updateContext = ExAllocatePoolWithTag(NonPagedPool,sizeof(*updateContext),' siS');
			if (NULL == updateContext) {
				//
				// Just fail the whole thing.
				//
				SIS_MARK_POINT();
				KeAcquireSpinLock(Context->SpinLock, &OldIrql);
				Context->Iosb->Status = STATUS_INSUFFICIENT_RESOURCES;
				KeReleaseSpinLock(Context->SpinLock, OldIrql);

				goto done;
			}

			SIS_MARK_POINT_ULONG(updateContext);
			ASSERT(DeviceObject);

			SipReferenceScb(Context->scb,RefsReadCompletion);

			updateContext->scb = Context->scb;
			updateContext->offset = irpSp->Parameters.Write.ByteOffset;
			updateContext->length = (ULONG)Irp->IoStatus.Information;
			updateContext->deviceExtension = DeviceObject->DeviceExtension;

			ExInitializeWorkItem(
				updateContext->workQueueItem,
				SiReadUpdateRanges,
				(PVOID)updateContext);

			ExQueueWorkItem(updateContext->workQueueItem,CriticalWorkQueue);
				
		} else {
			SipAcquireScb(Context->scb);

			SipAddRangeToFaultedList(
				Context->deviceExtension,
				Context->scb,
				&irpSp->Parameters.Read.ByteOffset,
				Irp->IoStatus.Information);

			Context->scb->Flags |= SIS_SCB_ANYTHING_IN_COPIED_FILE;

			SipReleaseScb(Context->scb);
		}

		if (truncated) {
			SIS_MARK_POINT_ULONG(Context->scb);

#if		DBG
			DbgPrint("SIS: SiMultiReadCompletion: truncated scb 0x%x\n",Context->scb);
#endif	// DBG

			KeAcquireSpinLock(Context->SpinLock, &OldIrql);
			if (Irp != Context->finalAssociatedIrp) {
				Context->Iosb->Status = STATUS_END_OF_FILE;	// What's the right status for this?
			}
			Context->Iosb->Information -= (irpSp->Parameters.Read.Length - Irp->IoStatus.Information);
			KeReleaseSpinLock(Context->SpinLock, OldIrql);
		}
	}

done:

	if (InterlockedDecrement(&Context->associatedIrpCount) == 0) {
		KeSetEvent(Context->event, IO_NO_INCREMENT, FALSE);
	}

	IoFreeMdl(Irp->MdlAddress);
	IoFreeIrp(Irp);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SiReadCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

	A read has completed.  This completion routine is only used when we may need to
	add a range into the faulted list for a file (we may not because there may have
	been an overlapping read or write that already added it to the list).  We're
	passed an SCB (and a reference to the SCB) as our context pointer.

Arguments:

    DeviceObject - Pointer to the device on which the file was read

    Irp - Pointer to the I/O Request Packet the represents the operation.

    Context - The scb for the file stream that's being read.

Return Value:

	STATUS_SUCCESS

--*/
{
	PIO_STACK_LOCATION		irpSp = IoGetCurrentIrpStackLocation(Irp);
	PSIS_SCB				scb = (PSIS_SCB)Context;

	//
	// We don't necessarily have a valid DeviceObject parameter, so just fill it in
	// from our internal data structures.
	//
	DeviceObject = scb->PerLink->CsFile->DeviceObject;

	SIS_MARK_POINT_ULONG(scb);

	//
	// If the read failed, it can't have faulted in anything, so we can
	// ignore it.  Otherwise, add the read region into the faulted list.
	//
	if (NT_SUCCESS(Irp->IoStatus.Status)) {
		if (Irp->Flags & IRP_PAGING_IO) {
			//
			// We need to update the faulted range for the file.  If we're at
			// dispatch level, we can't acquire the SCB in order to do it, so
			// we'll "post" the work.
			//
			if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
				PRW_COMPLETION_UPDATE_RANGES_CONTEXT	updateContext;

				updateContext = ExAllocatePoolWithTag(NonPagedPool,sizeof(*updateContext),' siS');
				if (NULL == updateContext) {
					//
					// Just fail the irp.
					//
					SIS_MARK_POINT();
					Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
					Irp->IoStatus.Information = 0;

					goto done;
				}

				SipReferenceScb(scb,RefsReadCompletion);

				SIS_MARK_POINT_ULONG(updateContext);
				ASSERT(DeviceObject);

				updateContext->scb = scb;
				updateContext->offset = irpSp->Parameters.Write.ByteOffset;
				updateContext->length = (ULONG)Irp->IoStatus.Information;
				updateContext->deviceExtension = DeviceObject->DeviceExtension;

				ExInitializeWorkItem(
					updateContext->workQueueItem,
					SiReadUpdateRanges,
					(PVOID)updateContext);

				ExQueueWorkItem(updateContext->workQueueItem,CriticalWorkQueue);
				
			} else {

				//
				// Now add the newly read range to the "faulted" area for this stream.
				// This call won't do any harm if some of the read is already faulted
				// or written.  
				//

				SipAcquireScb(scb);
	
				SipAddRangeToFaultedList(
					(PDEVICE_EXTENSION)DeviceObject->DeviceExtension,
					scb,
					&irpSp->Parameters.Read.ByteOffset,
					Irp->IoStatus.Information);

				scb->Flags |= SIS_SCB_ANYTHING_IN_COPIED_FILE;

				SipReleaseScb(scb);
			}
		} else {
			//
			// If the file object is synchronous, we need to update
			// the CurrentByteOffset.
			//
			PFILE_OBJECT fileObject = irpSp->FileObject;

			if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
				fileObject->CurrentByteOffset.QuadPart =
					irpSp->Parameters.Read.ByteOffset.QuadPart +
					Irp->IoStatus.Information;
			}
		}
	} else {
		SIS_MARK_POINT_ULONG(Irp->IoStatus.Status);

#if		DBG
//		DbgPrint("SIS: SiReadCompletion failed with status 0x%x\n",Irp->IoStatus.Status);
#endif	// DBG
	}

done:

	//
	// Drop the reference to the scb that SiRead acquired for us.
	//
	SipDereferenceScb(scb, RefsRead);

    //
    // Propogate the IRP pending flag.
    //

    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

	return STATUS_SUCCESS;
	
}

NTSTATUS
SipWaitForOpbreak(
	IN PSIS_PER_FILE_OBJECT			perFO,
	IN BOOLEAN						Wait)
/*++

Routine Description:

	We need to wait for an oplock break to happen on this per-FO.  If necessary,
	allocate an event, and then wait for the break to happen.

	Must be called with IRQL < DISPATCH_LEVEL

Arguments:

	perFO - the perFO for the file object on which we're to wait.

Return Value:

	status of the wait
--*/
{
	KIRQL					OldIrql;
	NTSTATUS				status;

	KeAcquireSpinLock(perFO->SpinLock, &OldIrql);

	ASSERT(OldIrql < DISPATCH_LEVEL);

	if (!(perFO->Flags & SIS_PER_FO_OPBREAK)) {
		//
		// If we ever see this clear, we'll never see it set again, because it
		// can only get set when the perFO is created.
		//

//		SIS_MARK_POINT_ULONG(perFO);
		KeReleaseSpinLock(perFO->SpinLock, OldIrql);

		return STATUS_SUCCESS;
	}

	SIS_MARK_POINT_ULONG(perFO);

	if (!Wait) {
#if		DBG
		if (BJBDebug & 0x2000) {
			DbgPrint("SIS: SipWaitForOpbreak: can't wait for perFO %p, FO %p\n",perFO,perFO->fileObject);
		}
#endif	// DBG

		KeReleaseSpinLock(perFO->SpinLock, OldIrql);

		return STATUS_CANT_WAIT;
	}

#if		DBG
	if (BJBDebug & 0x2000) {
		DbgPrint("SIS: SipWaitForOpbreak: waiting for perFO %p, FO %p\n",perFO,perFO->fileObject);
	}
#endif	// DBG

	if (NULL == perFO->BreakEvent) {

		ASSERT(!(perFO->Flags & SIS_PER_FO_OPBREAK_WAITERS));

		perFO->BreakEvent = ExAllocatePoolWithTag(NonPagedPool, sizeof(KEVENT), 'BsiS');

		if (NULL == perFO->BreakEvent) {
			KeReleaseSpinLock(perFO->SpinLock, OldIrql);
			SIS_MARK_POINT_ULONG(perFO);
			return STATUS_INSUFFICIENT_RESOURCES;
		}

#if		DBG
		if (BJBDebug & 0x2000) {
			DbgPrint("SIS: SipWaitForOpbreak: allocated event for perFO %p at %p\n",perFO,perFO->BreakEvent);
		}
#endif	// DBG

		KeInitializeEvent(perFO->BreakEvent, NotificationEvent, FALSE);
	}
	perFO->Flags |= SIS_PER_FO_OPBREAK_WAITERS;
	ASSERT(NULL != perFO->BreakEvent);

	//
	// Drop the lock on the perFO and wait for the oplock break to complete.
	//
	KeReleaseSpinLock(perFO->SpinLock, OldIrql);

	status = KeWaitForSingleObject(perFO->BreakEvent, Executive, KernelMode, FALSE, NULL);

#if		DBG
	if (BJBDebug & 0x2000) {
		DbgPrint("SIS: SipWaitForOpbreak: break completed, status %x, perFO %p\n",status,
					perFO);
	}
#endif	// DBG


	if (status != STATUS_SUCCESS) {
		SIS_MARK_POINT_ULONG(status);
		return status;
	}

	SIS_MARK_POINT_ULONG(perFO);

	return STATUS_SUCCESS;
}

#define	ASSOCIATED_IRPS_PER_BLOCK		5
typedef struct _ASSOCIATED_IRP_BLOCK {
	PIRP							irps[ASSOCIATED_IRPS_PER_BLOCK];
	struct _ASSOCIATED_IRP_BLOCK	*Next;
} ASSOCIATED_IRP_BLOCK, *PASSOCIATED_IRP_BLOCK;

NTSTATUS
SipCommonRead(
    IN PDEVICE_OBJECT 		DeviceObject,
    IN PIRP 				Irp,
	IN BOOLEAN				Wait)

/*++

Routine Description:

	This function handles read operations.  Check to see if the file object is a
	SIS file.  If so, handle the read, otherwise pass it through.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the result of the read, or the
	status of the call to the file system's entry point in the case of a
	pass-through call.

--*/

{
    PIO_STACK_LOCATION 		irpSp = IoGetCurrentIrpStackLocation(Irp);
	PIO_STACK_LOCATION		nextIrpSp;
	PFILE_OBJECT 			fileObject = irpSp->FileObject;
	PDEVICE_EXTENSION		deviceExtension;
	LARGE_INTEGER 			byteOffset;
	ULONG 					readLength;
	PSIS_SCB 				scb;
	NTSTATUS 				status;
	PSIS_CS_FILE			CSFile;
	PSIS_PER_LINK			perLink;
	PSIS_PER_FILE_OBJECT	perFO;
    BOOLEAN 				PagingIo;
    BOOLEAN 				NonCachedIo;
	BOOLEAN					ToCSFile;
	SIS_RANGE_DIRTY_STATE 	rangeDirty;
	KIRQL					OldIrql;
	ASSOCIATED_IRP_BLOCK	HeaderBlock[1];

	if (!SipIsFileObjectSIS(fileObject,DeviceObject,FindActive,&perFO,&scb)) {
		SipDirectPassThroughAndReturn(DeviceObject, Irp);
	}

	deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    PagingIo = (Irp->Flags & IRP_PAGING_IO) ? TRUE : FALSE;
    NonCachedIo = (Irp->Flags & IRP_NOCACHE) ? TRUE : FALSE;

	if (!PagingIo) {	
		//
		// Check to be sure that this file object isn't a complete-if-oplocked
		// create that hasn't yet had the oplock break ack'ed.  We need to do this
		// here because we might want to redirect the call to the common store
		// file, which doesn't have an oplock on it.
		//

		status = SipWaitForOpbreak(perFO, Wait);

		if (STATUS_CANT_WAIT == status) {
			//
			// Post the request.
			//
			SIS_MARK_POINT_ULONG(scb);

			ASSERT(!Wait);

			goto Post;
		}

		if (!NT_SUCCESS(status)) {
			//
			// The check for opbreak failed, probably because of a memory allocation failure.
			// Fail the entire read with the same status.
			//
			SIS_MARK_POINT_ULONG(status);

			goto fail;
		}
	}

	perLink = scb->PerLink;
	CSFile = perLink->CsFile;

	byteOffset = irpSp->Parameters.Read.ByteOffset;
	readLength = irpSp->Parameters.Read.Length;

	SIS_MARK_POINT_ULONG(scb);
	SIS_MARK_POINT_ULONG(byteOffset.LowPart);
	SIS_MARK_POINT_ULONG(readLength);
	SIS_MARK_POINT_ULONG(PagingIo << 1 | NonCachedIo);

#if		DBG
	if (BJBDebug & 0x4000) {
		DbgPrint("SIS: SiRead: perFO %p, scb %p, bo.Low 0x%x, rel 0x%x, PIO %d, NC %d\n",
				perFO,scb,byteOffset.LowPart,readLength,PagingIo, NonCachedIo);
	}
#endif	// DBG

	//
	// Figure out if there's anything in the copied file.  If not, then redirect the read to
	// the CS file.  If there is, then cached reads go to the copied file and noncached reads
	// depend on whether the range is dirty.
	//
	SipAcquireScb(scb);

	if (!(scb->Flags & SIS_SCB_ANYTHING_IN_COPIED_FILE)) {
		//
		// There's nothing in the copied file, 
		// so we just go to the CS file.
		//

		//
		// Since we're redirecting to the common store file, we need to check for file locks
		// ourself, since NTFS's version of the locks are only on the link/copied file.
		//

		// We have to check for read access according to the current
		// state of the file locks.
		
		if (!PagingIo && !FsRtlCheckLockForReadAccess(&scb->FileLock, Irp)) {
			SipReleaseScb(scb);

			status = STATUS_FILE_LOCK_CONFLICT;
			Irp->IoStatus.Information = 0;
			
			SIS_MARK_POINT_ULONG(scb);
			goto fail;
		}

		SipReleaseScb(scb);

		SIS_MARK_POINT_ULONG(scb);

		ToCSFile = TRUE;
	} else if (!NonCachedIo) {
		//
		// This is a cached read into a file that's got something in the copied file.
		// Send the read to the copied file.
		//
		SipReleaseScb(scb);

		SIS_MARK_POINT_ULONG(scb);

		ASSERT(!PagingIo);
		ToCSFile = FALSE;
	} else {
		//
		// The file's dirty and we're doing noncached IO to it.  Decide which way to send
		// the request depending on where there have been writes.
		//

		rangeDirty = SipGetRangeDirty(
						deviceExtension,
						scb,
						&byteOffset,
						(LONGLONG)readLength,
						FALSE);					// faultedIsDirty

		if ((Mixed == rangeDirty)
			&& (byteOffset.QuadPart < scb->SizeBackedByUnderlyingFile) 
			&& (byteOffset.QuadPart + readLength > scb->SizeBackedByUnderlyingFile)) {

			//
			// This is a noncached read that crosses SizeBacked, and that reports Mixed.  For paging IO, we know
			// that we can just send this to the CS file.  For user noncached reads we need to assure that
			// the file is clean (because otherwise we could lose coherence between cached writes and noncached
			// reads).
			//
			if (PagingIo) {
				SIS_MARK_POINT_ULONG(scb);
				rangeDirty = Clean;
			} else {
				//
				// Check to see if the file is dirty.  
				// NTRAID#65194-2000/03/10-nealch  The DIRTY flag should be in the scb, not the per link
				//
				KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
				if (!(perLink->Flags & SIS_PER_LINK_DIRTY)) {
					SIS_MARK_POINT_ULONG(scb);
					rangeDirty = Clean;
				}
				KeReleaseSpinLock(perLink->SpinLock, OldIrql);
			}
		}

		if (rangeDirty == Dirty) {
			SIS_MARK_POINT_ULONG(scb);

			SipReleaseScb(scb);

			ToCSFile = FALSE;
		} else if (rangeDirty == Clean) {
			//
			// The entire range is clean, so we can read it in just one run from the CS file.
			//
			SIS_MARK_POINT_ULONG(scb);

			//
			// Since we're redirecting to the common store file, we need to check for file locks
			// ourself, since NTFS's version of the locks are only on the link/copied file.
			//

			// We have to check for read access according to the current
			// state of the file locks.
		
			if (!PagingIo && !FsRtlCheckLockForReadAccess(&scb->FileLock, Irp)) {
				SipReleaseScb(scb);

				status = STATUS_FILE_LOCK_CONFLICT;
				Irp->IoStatus.Information = 0;
			
				SIS_MARK_POINT_ULONG(scb);
				goto fail;
			}

			SipReleaseScb(scb);

			ToCSFile = TRUE;
		} else {
			//
			// Some of the range is in the copied file and some is in the CS file.  Break the
			// request into pieces and send it down appropriately.
			//

			LONGLONG					currentOffset;
			PASSOCIATED_IRP_BLOCK		currentBlock = HeaderBlock;
			ULONG						blockIndex = 0;
			ULONG						associatedIrpCount = 0;
			SI_MULTI_COMPLETE_CONTEXT	Context[1];
			PIO_STACK_LOCATION			ourIrpSp;

			SIS_MARK_POINT_ULONG(scb);

			// We have to check for read access according to the current
			// state of the file locks.
		
			if (!PagingIo && !FsRtlCheckLockForReadAccess(&scb->FileLock, Irp)) {
				SipReleaseScb(scb);

				status = STATUS_FILE_LOCK_CONFLICT;
				Irp->IoStatus.Information = 0;
			
				SIS_MARK_POINT_ULONG(scb);
				goto fail;
			}

			ASSERT(rangeDirty == Mixed);

			status = SipLockUserBuffer(Irp,IoWriteAccess,readLength);
			if (!NT_SUCCESS(status)) {
				SipReleaseScb(scb);
				SIS_MARK_POINT_ULONG(status);
				goto fail;
			}

			RtlZeroMemory(HeaderBlock, sizeof(ASSOCIATED_IRP_BLOCK));

			//
			// Loop over all  of the ranges in the request, building up an associated Irp
			// for each of them.
			//
			currentOffset = byteOffset.QuadPart;
			while (currentOffset < byteOffset.QuadPart + readLength) {
				LONGLONG			rangeLength;
				SIS_RANGE_STATE		rangeState;
				PMDL				Mdl;
				PIRP				localIrp;

				associatedIrpCount++;

				if (blockIndex == ASSOCIATED_IRPS_PER_BLOCK) {
                    currentBlock->Next = ExAllocatePoolWithTag(NonPagedPool,
                                                               sizeof(ASSOCIATED_IRP_BLOCK),
                                                               ' siS');

					if (currentBlock->Next == NULL) {
						status = STATUS_INSUFFICIENT_RESOURCES;
						SIS_MARK_POINT();
						break;
					}
					currentBlock = currentBlock->Next;
					blockIndex = 0;
					RtlZeroMemory(currentBlock, sizeof(ASSOCIATED_IRP_BLOCK));
				}

				if (currentOffset >= scb->SizeBackedByUnderlyingFile) {
					//
					// We're looking at data that's exclusively beyond the portion of the
					// file that's not backed by the underlying file.  It's "Written" and extends
					// all the way to the end of the read.
					//

					SIS_MARK_POINT_ULONG(currentOffset);

					rangeState = Written;
					rangeLength = byteOffset.QuadPart + readLength - currentOffset;
				} else {
					BOOLEAN 			foundRange;

					foundRange = SipGetRangeEntry(
									deviceExtension,
									scb,
									currentOffset,
									&rangeLength,
									&rangeState);

					if (!foundRange) {
						SIS_MARK_POINT_ULONG(currentOffset);

						rangeState = Untouched;
						rangeLength = byteOffset.QuadPart + readLength - currentOffset;
					} else if (currentOffset + rangeLength > byteOffset.QuadPart + readLength) {
						//
						// The range extends beyond the end of the read.  Truncate it.
						//
						rangeLength = byteOffset.QuadPart + readLength - currentOffset;
					}
				}
				ASSERT(rangeLength > 0 && rangeLength <= byteOffset.QuadPart + readLength - currentOffset);
				ASSERT(rangeLength < MAXULONG);

				localIrp = currentBlock->irps[blockIndex] = 
							IoMakeAssociatedIrp(
									Irp, 
									(CCHAR)(DeviceObject->StackSize + 1));

				if (NULL == localIrp) {
					status = STATUS_INSUFFICIENT_RESOURCES;
					break;
				}

				//
				// Set the paging, noncached and synchronous paging flags in the associated irp, if appropriate.
				//
				if (PagingIo) {
					localIrp->Flags |= IRP_PAGING_IO;
				}
				if (NonCachedIo) {
					localIrp->Flags |= IRP_NOCACHE;
				}
				if (Irp->Flags & IRP_SYNCHRONOUS_PAGING_IO) {
					localIrp->Flags |= IRP_SYNCHRONOUS_PAGING_IO;
				}

				//
				// Setup the UserBuffer address in the associated irp.
				//
				localIrp->UserBuffer = (PCHAR)Irp->UserBuffer + (ULONG)(currentOffset - byteOffset.QuadPart);


				Mdl = IoAllocateMdl(
						(PCHAR)Irp->UserBuffer +
							(ULONG)(currentOffset - byteOffset.QuadPart),
						(ULONG)rangeLength,
						FALSE,
						FALSE,
						localIrp);
							

				if (Mdl == NULL) {
					status = STATUS_INSUFFICIENT_RESOURCES;
					break;
				}

				ASSERT(Mdl == localIrp->MdlAddress);

				IoBuildPartialMdl(
					Irp->MdlAddress,
					Mdl,
					(PCHAR)Irp->UserBuffer +
						(ULONG)(currentOffset - byteOffset.QuadPart),
					(ULONG)rangeLength);


				IoSetNextIrpStackLocation(localIrp);
				ourIrpSp = IoGetCurrentIrpStackLocation(localIrp);
				ourIrpSp->Parameters.Read.Length = (ULONG)rangeLength;
				ourIrpSp->Parameters.Read.ByteOffset.QuadPart = currentOffset;

				nextIrpSp = IoGetNextIrpStackLocation(localIrp);

				RtlCopyMemory(nextIrpSp,irpSp,sizeof(IO_STACK_LOCATION));

				nextIrpSp->Parameters.Read.Length = (ULONG)rangeLength;
				nextIrpSp->Parameters.Read.ByteOffset.QuadPart = currentOffset;

				if ((rangeState == Untouched) || (rangeState == Faulted)) {
					//
					// This range needs to go down to the CS file.
					//
					SIS_MARK_POINT_ULONG(currentOffset);

					nextIrpSp->FileObject = CSFile->UnderlyingFileObject;
				} else {
					SIS_MARK_POINT_ULONG(currentOffset);
				}

				IoSetCompletionRoutine(
					localIrp,
					SiMultiReadCompletion,
					Context,
					TRUE,
					TRUE,
					TRUE);
		
				Context->finalAssociatedIrp = localIrp;

				blockIndex++;
				currentOffset += rangeLength;
			}

			SipReleaseScb(scb);

			if (NT_SUCCESS(status)) {
				//
				// Everything that could have failed has been tried, and didn't
				// fail.  Send the irps down.
				//
				Irp->AssociatedIrp.IrpCount = associatedIrpCount;

				KeInitializeEvent(Context->event, NotificationEvent, FALSE);
				Context->associatedIrpCount = associatedIrpCount;
				KeInitializeSpinLock(Context->SpinLock);
				Context->Iosb->Status = STATUS_SUCCESS;
				Context->Iosb->Information = readLength;
				Context->deviceExtension = deviceExtension;
				Context->scb = scb;

				if (Wait || 1 /*BJB - fixme*/) {
					//
					// If we're waiting, then we're going to complete the
					// master Irp, and so we want to prevent the IO system
					// from doing it for us.
					//
					Irp->AssociatedIrp.IrpCount++;
				}

				currentBlock = HeaderBlock;
				while (currentBlock) {
					for (blockIndex = 0; blockIndex < ASSOCIATED_IRPS_PER_BLOCK; blockIndex++) {
						if (currentBlock->irps[blockIndex]) {
							IoCallDriver(
								deviceExtension->AttachedToDeviceObject,
								currentBlock->irps[blockIndex]);
						} else {
							ASSERT(NULL == currentBlock->Next);
							break;
						}
					}
					currentBlock = currentBlock->Next;
				}
			}

			//
			// Free any extra associated irp blocks we may have allocated.
			//
			while (NULL != HeaderBlock->Next) {
				PASSOCIATED_IRP_BLOCK next = HeaderBlock->Next;

				//
				// If the allocation failed, free any Irps and MDLs as well as the
				// blocks.
				//
				if (!NT_SUCCESS(status)) {
					ULONG i;
					for (i = 0; i < ASSOCIATED_IRPS_PER_BLOCK; i++) {
						if (next->irps[i]) {
							if (next->irps[i]->MdlAddress) {
								IoFreeMdl(next->irps[i]->MdlAddress);
							}
							IoFreeIrp(next->irps[i]);
						}
					}
				}

				HeaderBlock->Next = next->Next;
				ExFreePool(next);
			}

			if (!NT_SUCCESS(status)) {
				goto fail;
			}

			if (Wait || 1 /*BJB - fixme*/) {
				KeWaitForSingleObject(Context->event, Executive, KernelMode, FALSE, NULL);

				Irp->IoStatus = *Context->Iosb;
				IoCompleteRequest(Irp, IO_NO_INCREMENT);
				return Context->Iosb->Status;
			} else {
				return STATUS_PENDING;
			}
		}
	}


	//
	// Now forward the read down to NTFS on the file object that we decided
	// above.  Note that we're intentionally not truncating the read size,
	// even if we did so above, because NTFS will do its own truncation
	// and its own synchronization on the file object.
	//

	nextIrpSp = IoGetNextIrpStackLocation(Irp);
	RtlCopyMemory(nextIrpSp, irpSp, sizeof(IO_STACK_LOCATION));

	if (ToCSFile) {
		nextIrpSp->FileObject = CSFile->UnderlyingFileObject;
		ASSERT(NULL != nextIrpSp->FileObject);
	} else if (NonCachedIo) {
		SIS_MARK_POINT_ULONG(scb);
	}

	//
	// Tell the IO system that we need to see completions on this irp.
	// Grab a reference to the scb for the completion routine.
	//

	SipReferenceScb(scb, RefsRead);

	IoSetCompletionRoutine(
		Irp, 
		SiReadCompletion, 
		scb,
		TRUE, 
		TRUE, 
		TRUE);

	//
	// And send it to NTFS.
	//
	return IoCallDriver(
				deviceExtension->AttachedToDeviceObject, 
				Irp);

fail:

	SIS_MARK_POINT_ULONG(scb);

	Irp->IoStatus.Status = status;
	Irp->IoStatus.Information = 0;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return status;

Post:

	SIS_MARK_POINT_ULONG(scb);

	status = SipPostRequest(
				DeviceObject,
				Irp,
				FSP_REQUEST_FLAG_NONE);

	if (!NT_SUCCESS(status)) {
		//
		// We couldn't post the irp.  Fail the read.
		//
		SIS_MARK_POINT_ULONG(status);

		Irp->IoStatus.Status = status;
		Irp->IoStatus.Information = 0;

		IoCompleteRequest(Irp, IO_NO_INCREMENT);

		return status;
	}

	return STATUS_PENDING;
}

NTSTATUS
SiRead(
    IN PDEVICE_OBJECT 		DeviceObject,
    IN PIRP 				Irp)
{
	SipHandleControlDeviceObject(DeviceObject, Irp);

	return SipCommonRead(DeviceObject,Irp,IoIsOperationSynchronous(Irp));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\siinst.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    siinst.c

Abstract:

        Routines to convert two separate identical files into one.  Used only by the groveler.

Authors:

    Scott Cutshall, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

#ifdef          ALLOC_PRAGMA
#pragma alloc_text(PAGE, SipCreateCSFile)
#pragma alloc_text(PAGE, SipCreateCSFileWork)
#endif          // ALLOC_PRAGMA


BOOLEAN
SipAbort(
    IN PKEVENT event)

/*++

Routine Description:

    This function checks for an abort signaled via an event.

Arguments:

    event - pointer to an event that signals an abort.

Return Value:

    TRUE if an abort request has been signaled, otherwise FALSE.

--*/

{
	if (event) {
		return KeReadStateEvent(event) != 0;
	} else {
		return FALSE;
	}
}

VOID
SipCreateCSFileWork(
	PVOID				parameter)

/*++

Routine Description:

    This function creates a file in the common store directory and copies
    its contents from the specified source file.

Arguments:

        parameter - a pointer to a SIS_CREATE_CS_FILE_REQUEST.  Its fields
        are described below:

    deviceExtension - Pointer to the device extension for this driver.

    CSid - the id assigned to the common store file.  This is allocated here
                        and returned.

    SrcFileObject - the file containing the contents to copy into
        the common store file.

        NtfsId - returns the NTFS file ID for the newly created common store file.

    AbortEvent - pointer to an event that signals an abort request.  If NULL,
                not abortable.

        CSFileChecksum - Receives the checksum for the new common store file.

        doneEvent - an event to signal on completion

        status - a place for us to return our status

Return Value:

        void

--*/

{
	PSIS_CREATE_CS_FILE_REQUEST		createRequest = (PSIS_CREATE_CS_FILE_REQUEST)parameter;
	PDEVICE_EXTENSION				deviceExtension = createRequest->deviceExtension;
	PCSID							CSid = createRequest->CSid;
	PFILE_OBJECT					SrcFileObject = createRequest->srcFileObject;
	PLARGE_INTEGER					NtfsId = createRequest->NtfsId;
	PKEVENT							AbortEvent = createRequest->abortEvent;
	PLONGLONG						CSFileChecksum = createRequest->CSFileChecksum;
	HANDLE							CSHandle = NULL;
	UNICODE_STRING					CSFileName;
	FILE_STANDARD_INFORMATION		standardFileInfo[1];
	FILE_INTERNAL_INFORMATION		internalInformation[1];
	NTSTATUS						status;
	IO_STATUS_BLOCK					Iosb[1];
	OBJECT_ATTRIBUTES				Obja[1];
	HANDLE							copyEventHandle = NULL;
	PKEVENT							copyEvent = NULL;
	HANDLE							backpointerStreamHandle = NULL;
	LARGE_INTEGER					zero;
	PSIS_BACKPOINTER				sector = NULL;
	PSIS_BACKPOINTER_STREAM_HEADER	backpointerStreamHeader;
	ULONG							index;
	ULONG							retryCount;

	PAGED_CODE();

	CSFileName.Buffer = NULL;

	//
	// Allocate a new common store id.
	//
	retryCount = 0;

	for (;;) {
		status = ExUuidCreate(CSid);

		if (STATUS_RETRY == status) {
			KEVENT			neverSetEvent[1];
			LARGE_INTEGER	timeout[1];

			//
			// We got a retry, which means that the Uuid allocator needs to wait for
			// the timer to tick before it can allocate a new uuid.  Go to sleep for
			// a little while.
			//

			if (++retryCount == 10) {
				// 
				// We've retried too much.  Punt.
				//
				SIS_MARK_POINT();
				goto Error;
			}

			KeInitializeEvent(neverSetEvent, SynchronizationEvent, FALSE);
			timeout->QuadPart = -10 * 1000 * 100;   // 100 ms wait

			status = KeWaitForSingleObject(neverSetEvent,Executive, KernelMode, FALSE, timeout);
			ASSERT(STATUS_TIMEOUT == status);
                                
		} else if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		} else {
			break;
		}
	}

	*CSFileChecksum = 0;

	sector = ExAllocatePoolWithTag(PagedPool, deviceExtension->FilesystemVolumeSectorSize, ' siS');

	if (NULL == sector) {
		SIS_MARK_POINT();
		status = STATUS_INSUFFICIENT_RESOURCES;

		goto Error;
	}

	backpointerStreamHeader = (PSIS_BACKPOINTER_STREAM_HEADER)sector;

    //
    // Get the source file size.
    //

	status = SipQueryInformationFile(
				SrcFileObject,
				deviceExtension->DeviceObject,
				FileStandardInformation,
				sizeof(*standardFileInfo),
				standardFileInfo,
				NULL);                           // returned length

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto Error;
	}

	//
	// Create the common store file.
	// First, create the file name from the index.
	//

	CSFileName.MaximumLength = deviceExtension->CommonStorePathname.MaximumLength + 
	                                INDEX_MAX_NUMERIC_STRING_LENGTH + 
	                                BACKPOINTER_STREAM_NAME_SIZE + 
	                                sizeof(WCHAR);
	CSFileName.Buffer = ExAllocatePoolWithTag(PagedPool, CSFileName.MaximumLength, SIS_POOL_TAG);
    CSFileName.Length = 0;

	if (!CSFileName.Buffer) {
		SIS_MARK_POINT();
		status = STATUS_NO_MEMORY;
		goto Error;
	}

	status = SipIndexToFileName(
				deviceExtension, 
				CSid,
				BACKPOINTER_STREAM_NAME_SIZE,
				FALSE,							// may allocate
				&CSFileName);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto Error;
	}

	//
	// Abort if an oplock break has been received.
	//

	if (SipAbort(AbortEvent)) {
		status = STATUS_OPLOCK_BREAK_IN_PROGRESS;
		SIS_MARK_POINT();
		goto Error;
	}

	InitializeObjectAttributes(
		Obja,
		&CSFileName,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL);

	status = ZwCreateFile(
				&CSHandle,
				GENERIC_READ | GENERIC_WRITE | DELETE,
				Obja,
				Iosb,
				&standardFileInfo->EndOfFile,
				FILE_ATTRIBUTE_NOT_CONTENT_INDEXED,
				0,
				FILE_CREATE,
				FILE_NON_DIRECTORY_FILE,
				NULL,                                   // EA buffer
				0);                                             // EA length

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto Error;
	}

	//
	// Create the backpointer stream for the file.
	//
	status = RtlAppendUnicodeToString(&CSFileName,BACKPOINTER_STREAM_NAME);
	ASSERT(STATUS_SUCCESS == status);       // because we allocated the buffer to be big enough

	InitializeObjectAttributes(
		Obja,
		&CSFileName,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL);

	status = ZwCreateFile(
				&backpointerStreamHandle,
				GENERIC_READ | GENERIC_WRITE | DELETE,
				Obja,
				Iosb,
				NULL,                                                   // allocation size
				FILE_ATTRIBUTE_NOT_CONTENT_INDEXED,
				FILE_SHARE_READ | FILE_SHARE_DELETE,
				FILE_CREATE,
				FILE_NON_DIRECTORY_FILE,
				NULL,                                                   // EA Buffer
				0);                                                             // EA Length

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
#if		DBG
		DbgPrint("SIS: SipCreateCSFile: unable to open checksum stream, 0x%x\n",status);
#endif  // DBG
		goto Error;
	}

	//
	// Get the NTFS file id.  This is passed back to the caller so
	// that the common store file can be opened efficiently in the
	// future.
	//
	status = ZwQueryInformationFile(
				CSHandle,
				Iosb,
				internalInformation,
				sizeof(*internalInformation),
				FileInternalInformation);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto Error;
	}

	//
	// Create an event for the copy operation.
	//

	status = SipCreateEvent(
				SynchronizationEvent,
				&copyEventHandle,
				&copyEvent);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto Error;
	}

	//
	// Copy the file's contents into the common store.
	//

	if (0 != standardFileInfo->EndOfFile.QuadPart) {

		status = SipBltRangeByObject(
					deviceExtension,
					SrcFileObject,
					CSHandle,
					0,
					standardFileInfo->EndOfFile.QuadPart,
					copyEventHandle,
					copyEvent,
					AbortEvent,
					CSFileChecksum);

		if ((!NT_SUCCESS(status)) || (STATUS_OPLOCK_BREAK_IN_PROGRESS == status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}
	}

	//
	// Initialize the backpointer sector.  First write the header,
	// then fill in the remainder of the backpointer entries.
	//

	backpointerStreamHeader->FormatVersion = BACKPOINTER_STREAM_FORMAT_VERSION;
	backpointerStreamHeader->Magic = BACKPOINTER_MAGIC;
	backpointerStreamHeader->FileContentChecksum = *CSFileChecksum;

	for (index = SIS_BACKPOINTER_RESERVED_ENTRIES; 
		 index < deviceExtension->BackpointerEntriesPerSector;
		 index++) {

		sector[index].LinkFileIndex.QuadPart = MAXLONGLONG;
		sector[index].LinkFileNtfsId.QuadPart = MAXLONGLONG;
	}

	zero.QuadPart = 0;

	status = ZwWriteFile(
				backpointerStreamHandle,
				copyEventHandle,
				NULL,                                   // APC Routine
				NULL,                                   // APC Context
				Iosb,
				sector,
				deviceExtension->FilesystemVolumeSectorSize,
				&zero,
				NULL);                                  // key

	if (STATUS_PENDING == status) {
		status = KeWaitForSingleObject(copyEvent, Executive, KernelMode, FALSE, NULL);
		ASSERT(status == STATUS_SUCCESS);     // Since we've got this pointed at our stack, it must succeed.

		status = Iosb->Status;
	}

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto Error;
		}

#if     DBG
	if (BJBDebug & 0x200) {
		DbgPrint("SIS: SipCreateCSFile: common store file has checksum 0x%x.%x\n",
				 (ULONG)(*CSFileChecksum >> 32), (ULONG)(*CSFileChecksum));
	}
#endif  // DBG

	//
	// Return the file id.
	//

	*NtfsId = internalInformation->IndexNumber;

Exit:
	if (CSFileName.Buffer) {
	ExFreePool(CSFileName.Buffer);
	}

	if (CSHandle) {
		ZwClose(CSHandle);
	}
	if (backpointerStreamHandle) {
		ZwClose(backpointerStreamHandle);
	}
	if (NULL != copyEvent) {
		ObDereferenceObject(copyEvent);
	}
	if (NULL != copyEventHandle) {
		ZwClose(copyEventHandle);
	}
	if (NULL != sector) {
		ExFreePool(sector);
	}

	createRequest->status = status;
	KeSetEvent(createRequest->doneEvent,IO_DISK_INCREMENT,FALSE);

	return;

Error:
	SIS_MARK_POINT_ULONG(status);

	if (CSHandle) {
		FILE_DISPOSITION_INFORMATION disposition[1];
		NTSTATUS deleteStatus;

		disposition->DeleteFile = TRUE;

		deleteStatus = ZwSetInformationFile(
						CSHandle,
						Iosb,
						disposition,
						sizeof(FILE_DISPOSITION_INFORMATION),
						FileDispositionInformation);

#if     DBG
		if (deleteStatus != STATUS_SUCCESS) {

			//
			// Not much we can do about this.  Just leak the file.
			//

			SIS_MARK_POINT_ULONG(status);

			DbgPrint("SipCreateCSFile: unable to delete CS file, err 0x%x, initial error 0x%x\n", deleteStatus, status);
		}
#endif
	}

	goto Exit;
}


NTSTATUS
SipCreateCSFile(
	IN PDEVICE_EXTENSION		deviceExtension,
	OUT PCSID					CSid,
	IN HANDLE					SrcHandle,
	OUT PLARGE_INTEGER			NtfsId,
	IN PKEVENT					AbortEvent OPTIONAL,
	OUT PLONGLONG				CSFileChecksum)
/*++

Routine Description:

        Create a common store file.  This function just rolls up a create request,
        posts it to a worker thread and waits for it to complete.

Arguments:

	deviceExtension - Pointer to the device extension for this driver.

	CSid - the id assigned to the common store file.  This is allocated in the
                        worker routine and returned to the caller

	SrcHandle - the file containing the contents to copy into
        the common store file.

	NtfsId - returns the NTFS file ID for the newly created common store file.

	AbortEvent - pointer to an event that signals an abort request.  If NULL,
                not abortable.

	CSFileChecksum - Receives the checksum for the new common store file.

Return Value:

        The status of the request

--*/
{
	SIS_CREATE_CS_FILE_REQUEST	createRequest[1];
	NTSTATUS					status;
	OBJECT_HANDLE_INFORMATION	handleInformation[1];

	createRequest->srcFileObject = NULL;
        
	status = ObReferenceObjectByHandle(
				SrcHandle,
				FILE_READ_DATA,
				*IoFileObjectType,
				UserMode,
				(PVOID *) &createRequest->srcFileObject,
				handleInformation);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	createRequest->deviceExtension = deviceExtension;
	createRequest->CSid = CSid;
	createRequest->NtfsId = NtfsId;
	createRequest->abortEvent = AbortEvent;
	createRequest->CSFileChecksum = CSFileChecksum;

	KeInitializeEvent(createRequest->doneEvent,NotificationEvent,FALSE);

	ExInitializeWorkItem(
		createRequest->workQueueItem,
		SipCreateCSFileWork,
		createRequest);

	ExQueueWorkItem(
		createRequest->workQueueItem,
		DelayedWorkQueue);

	status = KeWaitForSingleObject(
				createRequest->doneEvent,
				Executive,
				KernelMode,
				FALSE,
				NULL);

	ASSERT(STATUS_SUCCESS == status);               // createRequest is on our stack, so we really need to wait

	//
	// Return the status of the actual create request.
	//

	status = createRequest->status;

done:

	if (NULL != createRequest->srcFileObject) {
		ObDereferenceObject(createRequest->srcFileObject);
	}

	return status;
}


NTSTATUS
SipRelinkFile(
	PSIS_SCB 		scbSrc,
	PFILE_OBJECT	fileObjectSrc,
	PSIS_CS_FILE	csFileDst)
/*++

Routine Description:

    Unlink the specified link file from it's common store file and relink it to
    the specified different common store file.

Arguments:

    scbSrc - pointer to the scb of the link file.

    fileObjectSrc - pointer to a file object using scbSrc.

    csFileDst - pointer to the common store file that is the target of the
                relink operation.

Return Value:

	The status of the request

--*/
{
	PSIS_SCB		primaryScb;
	PSIS_CS_FILE	csFileSrc;
	LINK_INDEX		NewLinkIndex;
	LINK_INDEX		OldLinkIndex;
	BOOLEAN			FinalCopyInProgress;
	NTSTATUS		status;
	CHAR			reparseBufferBuffer[SIS_REPARSE_DATA_SIZE];
#define reparseBuffer ((PREPARSE_DATA_BUFFER)reparseBufferBuffer)

	csFileSrc = scbSrc->PerLink->CsFile;

	SIS_MARK_POINT_ULONG(csFileDst);

	//
	// If they are already linked to the same common store file then
	// there's nothing to do.
	//

	if (csFileSrc == csFileDst) {
		status = STATUS_SUCCESS;
		goto Exit;
	}

	// NTRAID#65191-2000/05/23-nealch  When a partial SIS file is detected, convert it to a non-sis file.
	//
	// If the CS files have different checksums, then they're not the same file and shouldn't
	// be linked together.  Fail.
	//
	if (csFileSrc->Checksum != csFileDst->Checksum) {
		SIS_MARK_POINT();
		status = STATUS_INVALID_PARAMETER;
		goto Exit;
	}

	//
	// Unlink scbSrc and relink it to csFileDst.  We need to prepare both CS files.
	// CSsrc will be decremented; CSdst will be incremented. In order to avoid
	// deadlocks, we always prepare the CS file with the lower address first.
	//

	OldLinkIndex = scbSrc->PerLink->Index;

	if (csFileSrc < csFileDst) {

		status = SipPrepareCSRefcountChange(
					csFileSrc,
					&OldLinkIndex,
					&scbSrc->PerLink->LinkFileNtfsId,
					SIS_REFCOUNT_UPDATE_LINK_OVERWRITTEN);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}

		status = SipPrepareCSRefcountChange(
					csFileDst,
					&NewLinkIndex,
					&scbSrc->PerLink->LinkFileNtfsId,
					SIS_REFCOUNT_UPDATE_LINK_CREATED);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			//
			// Abort the first refcount change (the one who's prepare worked).
			//
			SipCompleteCSRefcountChange(
				scbSrc->PerLink,
				&OldLinkIndex,
				csFileSrc,
				FALSE,
				FALSE);

			goto Error;
		}

	} else {

		status = SipPrepareCSRefcountChange(
					csFileDst,
					&NewLinkIndex,
					&scbSrc->PerLink->LinkFileNtfsId,
					SIS_REFCOUNT_UPDATE_LINK_CREATED);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}

		status = SipPrepareCSRefcountChange(
					csFileSrc,
					&OldLinkIndex,
					&scbSrc->PerLink->LinkFileNtfsId,
					SIS_REFCOUNT_UPDATE_LINK_OVERWRITTEN);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			//
			// Abort the first refcount change (the one who's prepare worked).
			//
			SipCompleteCSRefcountChange(
				scbSrc->PerLink,
				&NewLinkIndex,
				csFileDst,
				FALSE,
				TRUE);

			goto Error;
		}
	}

	//
	// Fill in the reparse point data.
	//

	reparseBuffer->ReparseDataLength = SIS_MAX_REPARSE_DATA_VALUE_LENGTH;

	if (!SipIndicesIntoReparseBuffer(
			reparseBuffer,
			&csFileDst->CSid,
			&NewLinkIndex,
			&csFileDst->CSFileNtfsId,
			&scbSrc->PerLink->LinkFileNtfsId,
			&csFileDst->Checksum,
			TRUE)) {

		ASSERT(FALSE);
	}

	//
	// Add the new backpointer.  Note that the link file is still properly linked
	// to the source cs file.
	//

	status = SipCompleteCSRefcountChange(
				scbSrc->PerLink,
				&NewLinkIndex,
				csFileDst,
				TRUE,
				TRUE);

	if (!NT_SUCCESS(status)) {
		//
		// Abort the refcount changes.
		//
		SIS_MARK_POINT_ULONG(status);

		SipCompleteCSRefcountChange(
			scbSrc->PerLink,
			&OldLinkIndex,
			csFileSrc,
			FALSE,
			FALSE);
        
		goto Error;

	}

	//
	// Set the reparse point information.  If successful, the link file
	// will correctly point to the new cs file, and the cs file will already
	// have the reference and backpointer set.
	//

	status = SipFsControlFile(
				fileObjectSrc,
				csFileDst->DeviceObject,
				FSCTL_SET_REPARSE_POINT,
				reparseBuffer,
				FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + reparseBuffer->ReparseDataLength,
				NULL,                   // output buffer
				0,                      // output buffer length
				NULL);                  // returned output buffer length

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		//
		// Abort the refcount updates.
		//
		SipCompleteCSRefcountChange(
			scbSrc->PerLink,
			&OldLinkIndex,
			csFileSrc,
			FALSE,
			FALSE);

		//
		// Remove the reference we successfully added to the destination cs file.
		//
		status = SipPrepareCSRefcountChange(
					csFileDst,
					&NewLinkIndex,
					&scbSrc->PerLink->LinkFileNtfsId,
					SIS_REFCOUNT_UPDATE_LINK_OVERWRITTEN);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}

		status = SipCompleteCSRefcountChange(
					scbSrc->PerLink,
					&NewLinkIndex,
					csFileDst,
					TRUE,
					FALSE);

#if		DBG
		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
		}
#endif	//  DBG

		goto Error;
	}

    //
    // When we remove the backpointer from the source CS file the scb will
    // become "defunct", and I/O requests through it via any existing file
    // objects will be sent to the filesystem w/o intervention from SIS.
    // To prevent that, we need to create a new scb that will become the
    // primary, active scb.
    //

    primaryScb = SipLookupScb(
                    &NewLinkIndex,
                    &csFileDst->CSid,
                    &scbSrc->PerLink->LinkFileNtfsId,
                    &csFileDst->CSFileNtfsId,
                    NULL,
                    csFileDst->DeviceObject,
                    NULL,
                    &FinalCopyInProgress,
                    NULL);

    if (primaryScb) {
        ASSERT(IsEqualGUID(&primaryScb->PerLink->CsFile->CSid, &csFileDst->CSid));

        //
        // Install the new scb into the chain of scb's hanging off the filter
        // context and update all appropriate reference counts.
        //

        status = SipInitializePrimaryScb(
                    primaryScb,
                    scbSrc,
                    fileObjectSrc,
                    csFileSrc->DeviceObject);

        ASSERT(STATUS_SUCCESS == status);

		//
		// We've passed off our reference to the primaryScb, so destroy our pointer to it.
		//
		primaryScb = NULL;

    } else {
#if DBG
        SIS_MARK_POINT();
        DbgPrint("SIS: SipRelinkFile: SipLookupScb failed\n");
#endif
    }

    //
    // Finish the refcount updates.
    //

    status = SipCompleteCSRefcountChange(
                scbSrc->PerLink,
                &OldLinkIndex,
                csFileSrc,
                TRUE,
                FALSE);

#if		DBG
    if (!NT_SUCCESS(status)) {
        //
        // Now what?
        //
        SIS_MARK_POINT_ULONG(status);

        goto Error;
    }
#endif	// DBG

    ASSERT(scbSrc->PerLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE);

Error:
Exit:
    return status;
}


typedef struct _SIS_MERGE_NORMAL_FILES_REQUEST {
        WORK_QUEUE_ITEM                 workQueueItem[1];
        PDEVICE_EXTENSION               deviceExtension;
        PFILE_OBJECT                    fileObject[2];
        HANDLE                                  fileHandle[2];
        FILE_BASIC_INFORMATION  basicInfo[2];
        PKEVENT                                 abortEvent;
        NTSTATUS                                status;
        PIRP                                    Irp;
        BOOLEAN                                 posted;
} SIS_MERGE_NORMAL_FILES_REQUEST, *PSIS_MERGE_NORMAL_FILES_REQUEST;


VOID
SipMergeNormalFilesWork(
	PVOID							Parameter)
{
	PSIS_MERGE_NORMAL_FILES_REQUEST	mergeRequest = (PSIS_MERGE_NORMAL_FILES_REQUEST)Parameter;
	NTSTATUS						status;
	CSID							CSid;
	LARGE_INTEGER					CSFileNtfsId;
	LONGLONG						CSFileChecksum;
	PSIS_CS_FILE					CSFile = NULL;
	ULONG							i;
	FILE_STANDARD_INFORMATION		standardInfo[1];
	FILE_INTERNAL_INFORMATION		internalInfo[1];
	LINK_INDEX						linkIndex[2];
	PDEVICE_EXTENSION				deviceExtension = mergeRequest->deviceExtension;
	PDEVICE_OBJECT					DeviceObject = deviceExtension->DeviceObject;
	FILE_ZERO_DATA_INFORMATION		zeroDataInformation[1];
	CHAR							reparseBufferBuffer[SIS_REPARSE_DATA_SIZE];
#define reparseBuffer ((PREPARSE_DATA_BUFFER)reparseBufferBuffer)

    //
    // Copy one of the files into the common store.  This will create
    // the file in the common store and copy the contents.
    //

	if (!mergeRequest->posted) {

		ASSERT(NULL != mergeRequest->fileHandle[0] && NULL != mergeRequest->fileHandle[1]);

		status = SipCreateCSFile(
					deviceExtension,
					&CSid,
					mergeRequest->fileHandle[0],
					&CSFileNtfsId,
					mergeRequest->abortEvent,
					&CSFileChecksum);
	} else {
		SIS_CREATE_CS_FILE_REQUEST              createRequest[1];

		ASSERT(NULL == mergeRequest->fileHandle[0] && NULL == mergeRequest->fileHandle[1]);

		createRequest->deviceExtension = deviceExtension;
		createRequest->CSid = &CSid;
		createRequest->NtfsId = &CSFileNtfsId;
		createRequest->abortEvent = mergeRequest->abortEvent;
		createRequest->CSFileChecksum = &CSFileChecksum;
		createRequest->srcFileObject = mergeRequest->fileObject[0];

		KeInitializeEvent(createRequest->doneEvent, NotificationEvent, FALSE);

		SipCreateCSFileWork(createRequest);

		status = createRequest->status;
	}

	//
	// Check to see if we got an oplock break.  This happens if the abort event is set
	// for whatever reason.  If we did, then we change the status to STATUS_REQUEST_ABORTED.
	// We need to do this because STATUS_OPLOCK_BREAK_IN_PROGRESS is a success code.
	//
	if (STATUS_OPLOCK_BREAK_IN_PROGRESS == status) {
		SIS_MARK_POINT();
		status = STATUS_REQUEST_ABORTED;
		//
		// Fall through and let the upcoming error check take care of it.
		//
	}

    if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
        goto Error;
	}

	CSFile = SipLookupCSFile(
				&CSid,
				&CSFileNtfsId,
				DeviceObject);

	if (NULL == CSFile) {
		SIS_MARK_POINT();
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto Error;
	}

	//
	// Indicate that this is a new CS file that's never had a reference
	// to it.  We don't need to take the spin lock because before we write
	// the reparse point no one can know the GUID to get to this CS file, so
	// we're sure we have it exclusively.
	//
	CSFile->Flags |= CSFILE_NEVER_HAD_A_REFERENCE;

    //
    // Make the link files reparse points.
    //

	for (i = 0; i < 2; ++i) {
		PSIS_PER_LINK           perLink;
		BOOLEAN					prepared = FALSE;

		status = SipQueryInformationFile(
					mergeRequest->fileObject[i],
					DeviceObject,
					FileStandardInformation,
					sizeof(*standardInfo),
					standardInfo,
					NULL);                                          // returned length

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}

		status = SipQueryInformationFile(
					mergeRequest->fileObject[i],
					DeviceObject,
					FileInternalInformation,
					sizeof(*internalInfo),
					internalInfo,
					NULL);                                          // returned length

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}

		//
		// Set the file sparse
		//
		status = SipFsControlFile(
					mergeRequest->fileObject[i],
					DeviceObject,
					FSCTL_SET_SPARSE,
					NULL,                           // input buffer
					0,                                      // i.b. length
					NULL,                           // output buffer
					0,                                      // o.b. length
					NULL);                          // returned length

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}

		//
		// Prepare the refcount change, allocate a new link index and lookup a new perLink.
		//
		status = SipPrepareRefcountChangeAndAllocateNewPerLink(
					CSFile,
					&internalInfo->IndexNumber,
					DeviceObject,
					&linkIndex[i],
					&perLink,
					&prepared);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			
			if (prepared) {
				SipCompleteCSRefcountChange(
						NULL,
						NULL,
						CSFile,
						FALSE,
						TRUE);
			}

			if (NULL != perLink) {
				SipDereferencePerLink(perLink);
				perLink = NULL;
			}

			goto Error;
		}
        //
        // Fill in the reparse point data.
        //
    
        reparseBuffer->ReparseDataLength = SIS_MAX_REPARSE_DATA_VALUE_LENGTH;

        if (!SipIndicesIntoReparseBuffer(
				reparseBuffer,
				&CSid,
				&linkIndex[i],
				&CSFileNtfsId,
				&internalInfo->IndexNumber,
				&CSFileChecksum,
				TRUE)) {

			SIS_MARK_POINT();
            status = STATUS_DRIVER_INTERNAL_ERROR;

			SipCompleteCSRefcountChange(
				perLink,
				&perLink->Index,
				perLink->CsFile,
				FALSE,
				TRUE);

			SipDereferencePerLink(perLink);
			goto Error;
		}

        //
        // Set the reparse point information.
        //

        status = SipFsControlFile(
					mergeRequest->fileObject[i],
					DeviceObject,
					FSCTL_SET_REPARSE_POINT,
					reparseBuffer,
					FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + reparseBuffer->ReparseDataLength,
					NULL,				//  Output buffer
					0,					//  Output buffer length
					NULL);				//  returned output buffer length

        if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			//
			// Abort the CS file reference count update.
			//
			SipCompleteCSRefcountChange(
				perLink,
				&perLink->Index,
				CSFile,
				FALSE,
				TRUE);

			SipDereferencePerLink(perLink);
			perLink = NULL;

			goto Error;
		}

		//
		// Finish the CS file reference count update.
		//
		status = SipCompleteCSRefcountChange(
					perLink,
					&perLink->Index,
					CSFile,
					TRUE,
					TRUE);

		SipDereferencePerLink(perLink);

		if (!NT_SUCCESS(status)) {
			//
			// Now what?  We'll probably wind up doing a volume check because of this.
			//
			SIS_MARK_POINT_ULONG(status);
		}

		if (standardInfo->EndOfFile.QuadPart >= deviceExtension->FilesystemBytesPerFileRecordSegment.QuadPart) {
			//
			// Only zero the file if we're sure that it's $DATA attribute is non-resident.
			// If it's resident, then either we'll convert it to non-resident below, which will
			// generate a paging IO write that will confuse us, or else it will stay resident
			// in which case it will appear to be allocated when we open the file.  If that happens,
			// we want to have the correct data in the file, hence we avoid zeroing it here.
			//

			zeroDataInformation->FileOffset.QuadPart = 0;
			zeroDataInformation->BeyondFinalZero.QuadPart = MAXLONGLONG;

			status = SipFsControlFile(
						mergeRequest->fileObject[i],
						DeviceObject,
						FSCTL_SET_ZERO_DATA,
						zeroDataInformation,
						sizeof(FILE_ZERO_DATA_INFORMATION),
						NULL,                           // output buffer
						0,                                      // o.b. length
						NULL);                          // returned length

			if (!NT_SUCCESS(status)) {
				SIS_MARK_POINT_ULONG(status);
				goto Error;
			}
		}

		//
		// Reset the times
		//
                        
		status = SipSetInformationFile( 
					mergeRequest->fileObject[i],
					DeviceObject,
					FileBasicInformation,
					sizeof(FILE_BASIC_INFORMATION),
					mergeRequest->basicInfo + i);

		//
		// Just ignore an error on this.
		//
#if             DBG
		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			DbgPrint("SIS: SipLinkFiles: set basic info failed\n");
		}
#endif  // DBG

	}	// for each link
#undef  reparseBuffer

Error:

	mergeRequest->status = status;

	if (mergeRequest->posted) {
		//
		// Complete the irp
		//

		mergeRequest->Irp->IoStatus.Status = status;
		mergeRequest->Irp->IoStatus.Information = 0;

		IoCompleteRequest(mergeRequest->Irp, IO_NO_INCREMENT);

		if (NULL != mergeRequest->abortEvent) {
			ObDereferenceObject(mergeRequest->abortEvent);
		}

		for (i = 0; i < 2; ++i) {
			ASSERT(mergeRequest->fileObject[i]);
			ObDereferenceObject(mergeRequest->fileObject[i]);
		}

		ExFreePool(mergeRequest);
	}

	if (NULL != CSFile) {
		SipDereferenceCSFile(CSFile);
	}

	return;
}


NTSTATUS
SipMergeFiles(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp,
	IN PSIS_LINK_FILES	linkFiles)

/*++

Routine Description:

	Merge two files together.  One of the calls from the FSCTL_LINK_FILES
	fsctl.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

	linkFiles - the merge files request

Return Value:

    The function value is the status of the operation.  It does not
        complete the irp (unless it returns STATUS_PENDING, in which
		case the irp will be completed asynchronously).

--*/

{
	HANDLE								fileHandle[2];
	PFILE_OBJECT						fileObject[2] = {NULL, NULL};
	HANDLE								abortEventHandle;
	PKEVENT								abortEvent = NULL;
	PIO_STACK_LOCATION					irpSp = IoGetCurrentIrpStackLocation( Irp );
	NTSTATUS							status;
	OBJECT_HANDLE_INFORMATION			handleInformation;
	PDEVICE_EXTENSION					deviceExtension = DeviceObject->DeviceExtension;
	int									i;
	PSIS_PER_FILE_OBJECT				perFO[2];
	PSIS_SCB							scb[2];
	BOOLEAN								fileIsSIS[2];
	LARGE_INTEGER						zero;
	FILE_BASIC_INFORMATION				basicInfo[2];
	FILE_STANDARD_INFORMATION			standardInfo[1];
	FILE_INTERNAL_INFORMATION			internalInfo[1];
	LONGLONG							CSFileChecksum;
	CHAR								reparseBufferBuffer[SIS_REPARSE_DATA_SIZE];
#define reparseBuffer ((PREPARSE_DATA_BUFFER)reparseBufferBuffer)
	PSIS_CS_FILE						CSFile = NULL;
	FILE_ZERO_DATA_INFORMATION			zeroDataInformation[1];
	PSIS_MERGE_NORMAL_FILES_REQUEST		mergeRequest = NULL;
	BOOLEAN								prepared = FALSE;

	ASSERT(SIS_LINK_FILES_OP_MERGE == linkFiles->operation);

	fileHandle[0] = linkFiles->u.Merge.file1;
	fileHandle[1] = linkFiles->u.Merge.file2;
	abortEventHandle = linkFiles->u.Merge.abortEvent;

	zero.QuadPart = 0;

	//
	// The abort event handle is optional.  It is the responsibility of the
	// caller to signal the event if it wants this service to abort before it
	// completes.
	//

	if (abortEventHandle) {
		status = ObReferenceObjectByHandle( 
					abortEventHandle,
					EVENT_QUERY_STATE | SYNCHRONIZE,
					NULL,
					UserMode,
					&abortEvent,
					NULL);

		if (!NT_SUCCESS( status )) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}
	}

	//
	// Dereference the file handles to pointers to their
	// file objects and see if the two file specifications
	// refer to the same device.
	//

	for (i = 0; i < 2; ++i) {
		status = ObReferenceObjectByHandle( 
					fileHandle[i],
					FILE_READ_DATA,
					*IoFileObjectType,
					UserMode,
					(PVOID *) &fileObject[i],
					&handleInformation );

		if (!NT_SUCCESS( status )) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}
	}

	//
	// Verify that there are no rogue user mapped sections open to the files.
	//
	for (i = 0; i < 2; i++) {
		if ((NULL != fileObject[i]->SectionObjectPointer)
			&& !MmCanFileBeTruncated(fileObject[i]->SectionObjectPointer,&zero)) {

			SIS_MARK_POINT();
			status = STATUS_SHARING_VIOLATION;
			goto Error;
		}
	}

    //
    // Verify that both files are on the same volume.
    //

    if ((IoGetRelatedDeviceObject( fileObject[0] ) !=
         IoGetRelatedDeviceObject( fileObject[1] )) ||
           (IoGetRelatedDeviceObject(fileObject[0]) != 
                IoGetRelatedDeviceObject(irpSp->FileObject))) {

		//
		// The two files refer to different devices, or a different device
		// from the file object on which we were called. Return an appropriate
		// error.
		//

		SIS_MARK_POINT();
		status = STATUS_NOT_SAME_DEVICE;
		goto Error;

	}

	for (i = 0; i < 2; ++i) {
		perFO[i] = NULL;
		fileIsSIS[i] = SipIsFileObjectSIS(fileObject[i],DeviceObject,FindActive,&perFO[i],&scb[i]);

		//
		// Get the file times and sizes so we can reset them after we munge the file,
		// and check the file attributes now.
		//
		status = SipQueryInformationFile(
					fileObject[i],
					DeviceObject,
					FileBasicInformation,
					sizeof(*basicInfo),
					&basicInfo[i],
					NULL);                                  // returned length

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}


		if (basicInfo[i].FileAttributes & (FILE_ATTRIBUTE_ENCRYPTED |
                                           FILE_ATTRIBUTE_DIRECTORY)) {
            //
            // We don't touch encrypted files. Reject the call.
            //
            SIS_MARK_POINT();
            status = STATUS_INVALID_PARAMETER_3;
            goto Error;
        }

		if (fileIsSIS[i]) {
			//
			// If it's a SIS file, we don't need to check the stream info because we
			// know it's alright.  However, we do need to verify that it's not dirty.
			//
			if ((scb[i]->PerLink->Flags & SIS_PER_LINK_DIRTY) || (scb[i]->Flags & SIS_SCB_BACKING_FILE_OPENED_DIRTY)) {
				SIS_MARK_POINT_ULONG(scb[i]);
				status = STATUS_SHARING_VIOLATION;
				goto Error;
			}
		} else {

			if (basicInfo[i].FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
				//
				// We can't SISify other reparse points. Reject the call.
				//
				SIS_MARK_POINT();
				status = STATUS_INVALID_PARAMETER;
				goto Error;
			}

			//
			// Query the file to find its link count, and reject the call if it's bigger than
			// one; we can't have hard links to SIS links.
			//
			status = SipQueryInformationFile(
						fileObject[i],
						DeviceObject,
						FileStandardInformation,
						sizeof(*standardInfo),
						standardInfo,
						NULL);                  // returned length

			if (!NT_SUCCESS(status)) {
				SIS_MARK_POINT_ULONG(status);
				goto Error;
			}

			if (1 != standardInfo->NumberOfLinks) {
				SIS_MARK_POINT_ULONG(standardInfo->NumberOfLinks);
				status = STATUS_INVALID_PARAMETER;
				goto Error;
			}

			//
			// If the file is sparse and has unallocated regions, reject it.
			//
			if (basicInfo[i].FileAttributes & FILE_ATTRIBUTE_SPARSE_FILE) {
				FILE_ALLOCATED_RANGE_BUFFER		inArb[1];
				FILE_ALLOCATED_RANGE_BUFFER		outArb[1];
				ULONG							returnedLength;

				inArb->FileOffset.QuadPart = 0;
				inArb->Length.QuadPart = MAXLONGLONG;

				status = SipFsControlFile(
							fileObject[i],
							DeviceObject,
							FSCTL_QUERY_ALLOCATED_RANGES,
							inArb,
							sizeof(FILE_ALLOCATED_RANGE_BUFFER),
							outArb,
							sizeof(FILE_ALLOCATED_RANGE_BUFFER),
							&returnedLength);

				if ((returnedLength == 0) 
					|| (outArb->FileOffset.QuadPart != 0) 
					|| (outArb->Length.QuadPart < standardInfo->EndOfFile.QuadPart)) {

					//
					// It's not fully allocated.  Disallow the copy.
					//
					status = STATUS_OBJECT_TYPE_MISMATCH;
					SIS_MARK_POINT();
					goto Error;
				}
			}
		}	// else the file isn't a SIS link
	}	// for each file

    //
    // If neither file is a SIS link, then copy file1
    // into the common store and create links to it.
    //

    if (!fileIsSIS[0] && !fileIsSIS[1]) {
		mergeRequest = ExAllocatePoolWithTag(PagedPool, sizeof(SIS_MERGE_NORMAL_FILES_REQUEST), ' siS');

		if (NULL == mergeRequest) {
			SIS_MARK_POINT();
			status = STATUS_INSUFFICIENT_RESOURCES;

			goto Error;
		}

		mergeRequest->posted = !IoIsOperationSynchronous(Irp);

		RtlCopyMemory(mergeRequest->basicInfo,basicInfo,sizeof(FILE_BASIC_INFORMATION) * 2);

		for (i = 0; i < 2; i++) {
			mergeRequest->fileObject[i] = fileObject[i];
			if (mergeRequest->posted) {
				mergeRequest->fileHandle[i] = NULL;
			} else {
				mergeRequest->fileHandle[i] = fileHandle[i];
			}
		}
		mergeRequest->Irp = Irp;
		mergeRequest->deviceExtension = deviceExtension;
		mergeRequest->abortEvent = abortEvent;

		if (mergeRequest->posted) {
			//
			// Post the request to a worker thread and return STATUS_PENDING.
			//

			SIS_MARK_POINT_ULONG(mergeRequest);

			IoMarkIrpPending(Irp);

			ExInitializeWorkItem(
				mergeRequest->workQueueItem,
				SipMergeNormalFilesWork,
				mergeRequest);

			ExQueueWorkItem(
				mergeRequest->workQueueItem,
				DelayedWorkQueue);

			//
			// NULL out our local copies of things whose references we have handed off
			// to the fsp.  This is just to make sure that we don't touch them again,
			// because they can go away at any time, whenever the thread gets around to
			// it.
			//
			Irp = NULL;
			abortEvent = NULL;
			for (i = 0; i < 2; i++) {
				fileObject[i] = NULL;
			}
			mergeRequest = NULL;

			status = STATUS_PENDING;
                        
		} else {
			//
			// We can block, so do the work locally.
			//

			SipMergeNormalFilesWork(mergeRequest);

			status = mergeRequest->status;
		}

	} else if (fileIsSIS[0] && fileIsSIS[1]) {

        //
        // This is relinking from one CS file to another. Unlink it from CsFile1
        // and link it to CsFile0.
        //
        SIS_MARK_POINT_ULONG(scb[1]);

        status = SipRelinkFile(scb[1], fileObject[1], scb[0]->PerLink->CsFile);

        ASSERT(STATUS_PENDING != status);       // this would mess up the Exit code below

    } else {

    	// NTRAID#65191-2000/05/23-nealch  When a partial SIS file is detected, convert it to a non-sis file.
		//
		// One file is a SIS file and the other is not.
		//

        PSIS_CS_FILE            csFile;
        LINK_INDEX              linkIndex;
        HANDLE                  linkHandle;
        PFILE_OBJECT            linkFileObject;
        PSIS_PER_LINK           perLink;        // for the non-link file
        PFILE_BASIC_INFORMATION linkBasicInfo;

        if (fileIsSIS[0]) {

            //
            // File0 is a SIS link, file1 is not.
            //

            csFile = scb[0]->PerLink->CsFile;
            linkHandle = fileHandle[1];
                        linkFileObject = fileObject[1];
            linkBasicInfo = &basicInfo[1];

        } else {

            ASSERT(fileIsSIS[1]);

            //
            // File1 is a SIS link, file0 is not.
            //

            csFile = scb[1]->PerLink->CsFile;
            linkHandle = fileHandle[0];
                        linkFileObject = fileObject[0];
            linkBasicInfo = &basicInfo[0];

        }

		//
		// Make sure the CS file is open so that we know its index and checksum.
		//
		status = SipAssureCSFileOpen(csFile);
		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}

		CSFileChecksum = csFile->Checksum;

		status = SipQueryInformationFile(
					linkFileObject,
					DeviceObject,
					FileInternalInformation,
					sizeof(*internalInfo),
					internalInfo,
					NULL);                                          // returned length

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}

		//
		// Set the file sparse
		//
		status = SipFsControlFile(
					linkFileObject,
					DeviceObject,
					FSCTL_SET_SPARSE,
					NULL,				// input buffer
					0,					// i.b. length
					NULL,				// output buffer
					0,					// o.b. length
					NULL);				// returned length

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT();
			goto Error;
		}

        //
        // Make the non-link file a reparse point.
        //

		//
		// Prepare a refcount change, allocate a new link index and look up a new perLink.
		//
		status = SipPrepareRefcountChangeAndAllocateNewPerLink(
					csFile,
					&internalInfo->IndexNumber,
					DeviceObject,
					&linkIndex,
					&perLink,
					&prepared);

		if (!NT_SUCCESS(status)) {
			if (prepared) {
				SipCompleteCSRefcountChange(
					NULL,
					NULL,
					csFile,
					FALSE,
					TRUE);

				prepared = FALSE;
			}

			if (NULL != perLink) {
				SipDereferencePerLink(perLink);
				perLink = NULL;
			}

			goto Error;
		}

        reparseBuffer->ReparseDataLength = SIS_MAX_REPARSE_DATA_VALUE_LENGTH;

        if (!SipIndicesIntoReparseBuffer(
				reparseBuffer,
				&csFile->CSid,
				&linkIndex,
				&csFile->CSFileNtfsId,
				&internalInfo->IndexNumber,
				&CSFileChecksum,
				TRUE)) {

			SIS_MARK_POINT();
			status = STATUS_DRIVER_INTERNAL_ERROR;
			goto Error;
        }

        //
        // Set the reparse point information.
        //

		status = SipFsControlFile(
					linkFileObject,
					DeviceObject,
					FSCTL_SET_REPARSE_POINT,
					reparseBuffer,
					FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + reparseBuffer->ReparseDataLength,
					NULL,				//  Output buffer
					0,					//  Output buffer length
					NULL);				//  returned output buffer length

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);

			//
			// Abort the refcount update.
			//
			SipCompleteCSRefcountChange(
				perLink,
				&perLink->Index,
				csFile,
				FALSE,
				TRUE);

			SipDereferencePerLink(perLink);
			perLink = NULL;

			goto Error;
		}

		//
		// Complete the refcount update.
		//
		status = SipCompleteCSRefcountChange(
					perLink,
					&perLink->Index,
					perLink->CsFile,
					TRUE,
					TRUE);

		SipDereferencePerLink(perLink);
		perLink = NULL;

		if (!NT_SUCCESS(status)) {
			//
			// Now what?
			//
			SIS_MARK_POINT_ULONG(status);
		}

		if (csFile->FileSize.QuadPart >= deviceExtension->FilesystemBytesPerFileRecordSegment.QuadPart) {

			//
			// Zero the file, which will both deallocate its space, and also force its ValidDataLength to
			// end of file.
			//
			zeroDataInformation->FileOffset.QuadPart = 0;
			zeroDataInformation->BeyondFinalZero.QuadPart = MAXLONGLONG;

			status = SipFsControlFile(
						linkFileObject,
						DeviceObject,
						FSCTL_SET_ZERO_DATA,
						zeroDataInformation,
						sizeof(FILE_ZERO_DATA_INFORMATION),
						NULL,					// output buffer
						0,						// o.b. length
						NULL);					// returned length

			if (!NT_SUCCESS(status)) {
				SIS_MARK_POINT_ULONG(status);
				goto Error;
			}
		}

		//
		// Reset the times
		//
                        
		status = SipSetInformationFile( 
					linkFileObject,
					DeviceObject,
					FileBasicInformation,
					sizeof(FILE_BASIC_INFORMATION),
					linkBasicInfo);

		//
		// Just ignore an error on this.
		//
#if             DBG
		if (!NT_SUCCESS(status)) {
			DbgPrint("SIS: SipLinkFiles: set basic info failed\n");
		}
#endif  // DBG
	}	// else one is SIS and one isn't

//Exit:
Error:

	if (NULL != CSFile) {
		SipDereferenceCSFile(CSFile);
	}

	if (STATUS_PENDING != status) {

		if (abortEvent) {
			ObDereferenceObject(abortEvent);
		}

		for (i = 0; i < 2; ++i) {
			if (fileObject[i]) {
				ObDereferenceObject(fileObject[i]);
			}
		}

		if (NULL != mergeRequest) {
			ExFreePool(mergeRequest);
		}
	}

	return status;
#undef  reparseBuffer
}

NTSTATUS
SipVerifyNoMap(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp,
	IN PSIS_LINK_FILES	linkFiles)
/*++

Routine Description:

	Check out a file to see if there is a mapped section to it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

	linkFiles - the verify_no_map request

Return Value:

	STATUS_SUCCESS if the file has no mapped section.

	STATUS_SHARING_VIOLATION if it has one.

	Another error status if the handle is bogus, etc.

--*/

{
	PFILE_OBJECT	fileObject = NULL;
	NTSTATUS		status;
	LARGE_INTEGER	zero;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

	ASSERT(SIS_LINK_FILES_OP_VERIFY_NO_MAP == linkFiles->operation);

	status = ObReferenceObjectByHandle(
				linkFiles->u.VerifyNoMap.file,
				FILE_READ_DATA,
				*IoFileObjectType,
				UserMode,
				&fileObject,
				NULL);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	zero.QuadPart = 0;

	if ((NULL != fileObject->SectionObjectPointer) 
		&& MmCanFileBeTruncated(fileObject->SectionObjectPointer, &zero)) {

		status = STATUS_SUCCESS;
	} else {
		status = STATUS_SHARING_VIOLATION;
	}

done:
        
	if (NULL != fileObject) {
		ObDereferenceObject(fileObject);
	}

	return status;
}


NTSTATUS
SipMergeFileWithCSFile(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp,
	IN PSIS_LINK_FILES		linkFiles)
/*++

Routine Description:

	Merge a file into a common store file given the CSID of the common store file.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

	linkFiles - the merge_with_cs request

Return Value:

	status of the operation.

--*/
{
	PFILE_OBJECT				fileObject = NULL;
	NTSTATUS					status;
	PSIS_CS_FILE				CSFile = NULL;
	PSIS_PER_FILE_OBJECT		perFO;
	PSIS_SCB					scb;
	PSIS_PER_LINK				perLink = NULL;
	LINK_INDEX					linkIndex;
	FILE_BASIC_INFORMATION		basicInfo[1];
	FILE_INTERNAL_INFORMATION	internalInfo[1];
	FILE_STANDARD_INFORMATION	standardInfo[1];
	PIO_STACK_LOCATION			irpSp = IoGetCurrentIrpStackLocation(Irp);
	BOOLEAN						prepared = FALSE;
	BOOLEAN						isSis;
	FILE_ZERO_DATA_INFORMATION	zeroDataInformation[1];
	CHAR						reparseBufferBuffer[SIS_REPARSE_DATA_SIZE];
#define reparseBuffer ((PREPARSE_DATA_BUFFER)reparseBufferBuffer)

	ASSERT(SIS_LINK_FILES_OP_MERGE_CS == linkFiles->operation);

	status = ObReferenceObjectByHandle(
				linkFiles->u.MergeWithCS.file1,
				FILE_READ_DATA,
				*IoFileObjectType,
				UserMode,
				&fileObject,
				NULL);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	if (IoGetRelatedDeviceObject(fileObject) != 
		IoGetRelatedDeviceObject(irpSp->FileObject)) {

		SIS_MARK_POINT();
		status = STATUS_NOT_SAME_DEVICE;

		goto done;
	}

	isSis = SipIsFileObjectSIS(fileObject,DeviceObject,FindActive,&perFO,&scb);

	if (isSis && (IsEqualGUID(&scb->PerLink->CsFile->CSid, &linkFiles->u.MergeWithCS.CSid))) {
		//
		// We're linking to the CS file that already backs this link file.
		// Declare victory.
		//
		SIS_MARK_POINT_ULONG(CSFile);

		status = STATUS_SUCCESS;
		goto done;
	}

	//
	// Get at the CS file.
	//
	CSFile = SipLookupCSFile(
				&linkFiles->u.MergeWithCS.CSid,
				NULL,
				DeviceObject);

	if (NULL == CSFile) {
		SIS_MARK_POINT();
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}

	status = SipAssureCSFileOpen(CSFile);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	if (isSis) {
		//
		// This is relinking from one CS file to another.
		//
		SIS_MARK_POINT_ULONG(scb);

		status = SipRelinkFile(scb, fileObject, CSFile);

        goto done;
    }

	//
	// It's a normal file.  Relink it.  First query its info.
	//
	status = SipQueryInformationFile(
				fileObject,
				DeviceObject,
				FileBasicInformation,
				sizeof(FILE_BASIC_INFORMATION),
				basicInfo,
				NULL);							// returned length

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto done;
	}

	status = SipQueryInformationFile(
				fileObject,
				DeviceObject,
				FileInternalInformation,
				sizeof(FILE_INTERNAL_INFORMATION),
				internalInfo,
				NULL);							// returned length

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto done;
	}

	status = SipQueryInformationFile(
				fileObject,
				DeviceObject,
				FileStandardInformation,
				sizeof(FILE_STANDARD_INFORMATION),
				standardInfo,
				NULL);							// returned length

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto done;
	}

	//
	// Don't merge files with hard links.
	//
	if (1 != standardInfo->NumberOfLinks) {
		SIS_MARK_POINT_ULONG(standardInfo->NumberOfLinks);

		status = STATUS_INVALID_PARAMETER;
		goto done;
	}

	//
	// Don't merge non-SIS link files with unallocated sparse regions.
	//
	if (basicInfo->FileAttributes & FILE_ATTRIBUTE_SPARSE_FILE) {
		FILE_ALLOCATED_RANGE_BUFFER		inArb[1];
		FILE_ALLOCATED_RANGE_BUFFER		outArb[1];
		ULONG							returnedLength;

		inArb->FileOffset.QuadPart = 0;
		inArb->Length.QuadPart = MAXLONGLONG;

		status = SipFsControlFile(
					fileObject,
					DeviceObject,
					FSCTL_QUERY_ALLOCATED_RANGES,
					inArb,
					sizeof(FILE_ALLOCATED_RANGE_BUFFER),
					outArb,
					sizeof(FILE_ALLOCATED_RANGE_BUFFER),
					&returnedLength);

		if ((returnedLength == 0) 
			|| (outArb->FileOffset.QuadPart != 0) 
			|| (outArb->Length.QuadPart < standardInfo->EndOfFile.QuadPart)) {

			//
			// It's not fully allocated.  Disallow the copy.
			//
			status = STATUS_OBJECT_TYPE_MISMATCH;
			SIS_MARK_POINT();
			goto done;
		}
	}
	

	status = SipPrepareRefcountChangeAndAllocateNewPerLink(
				CSFile,
				&internalInfo->IndexNumber,
				DeviceObject,
				&linkIndex,
				&perLink,
				&prepared);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto done;
	}

    //
    // Fill in the reparse point data.
    //

    reparseBuffer->ReparseDataLength = SIS_MAX_REPARSE_DATA_VALUE_LENGTH;

    if (!SipIndicesIntoReparseBuffer(
			reparseBuffer,
			&CSFile->CSid,
			&linkIndex,
			&CSFile->CSFileNtfsId,
			&internalInfo->IndexNumber,
			&CSFile->Checksum,
			TRUE)) {

		SIS_MARK_POINT();
                        
        status = STATUS_DRIVER_INTERNAL_ERROR;
        goto done;

    }

	//
	// Set the reparse point information and increment the CS file refcount.
	// This needs to proceed using the prepare/act/finish protocol for updating
	// the reference count.  Note that we do this before zeroing the file
	// so as not to lose the contents in the event of a failure later on.
	//

    status = SipFsControlFile(
				fileObject,
				DeviceObject,
				FSCTL_SET_REPARSE_POINT,
				reparseBuffer,
				FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + reparseBuffer->ReparseDataLength,
				NULL,				//  Output buffer
				0,					//  Output buffer length
				NULL);				//  returned output buffer length

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto done;
	}

	status = SipCompleteCSRefcountChange(
				perLink,
				&perLink->Index,
				CSFile,
				TRUE,
				TRUE);

	if (!NT_SUCCESS(status)) {
		//
		// We're probably headed for a volume check here.  Ignore it for now.
		//
		SIS_MARK_POINT_ULONG(status);

#if             DBG
		DbgPrint("SIS: SipMergeFileWithCSFile: complete refcount change failed 0x%x\n",status);
#endif  // DBG
	}

	prepared = FALSE;

	//
	// Set the file sparse, and zero it.
	//

	status = SipFsControlFile(
				fileObject,
				DeviceObject,
				FSCTL_SET_SPARSE,
				NULL,				// input buffer
				0,					// i.b. length
				NULL,				// output buffer
				0,					// o.b. length
				NULL);				// returned o.b. length

	if (!NT_SUCCESS(status)) {
		//
		// If we can't set the file sparse, we'll leave it as a totally dirty
		// SIS file.
		//
		SIS_MARK_POINT_ULONG(status);

#if             DBG
		DbgPrint("SIS: SipMergeFileWithCSFile: unable to set sparse, 0x%x\n",status);
#endif  // DBG

		status = STATUS_SUCCESS;
		goto done;
	}

	zeroDataInformation->FileOffset.QuadPart = 0;
	zeroDataInformation->BeyondFinalZero.QuadPart = MAXLONGLONG;

	status = SipFsControlFile(
				fileObject,
				DeviceObject,
				FSCTL_SET_ZERO_DATA,
				zeroDataInformation,
				sizeof(*zeroDataInformation),
				NULL,							// output buffer
				0,								// o.b. length
				NULL);							// returned o.b. length

    if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		//
		// Just ignore this error and reset the times anyway.
		//
		SIS_MARK_POINT_ULONG(status);

#if             DBG
		DbgPrint("SIS: SipMergeFileWithCSFile: zero data failed, 0x%x\n",status);
#endif  // DBG
	}

	//
	// Reset the file times that are contained in the basic information.
	//

	status = SipSetInformationFile(
				fileObject,
				DeviceObject,
				FileBasicInformation,
				sizeof(FILE_BASIC_INFORMATION),
				basicInfo);

	if (!NT_SUCCESS(status)) {
		//
		// Just ignore this one, too.
		//

		SIS_MARK_POINT_ULONG(status);

#if             DBG
		DbgPrint("SIS: SipMergeFileWithCSFile: unable to reset basic info, 0x%x\n",status);
#endif  // DBG
	}

	status = STATUS_SUCCESS;

done:

	if (NULL != fileObject) {
		ObDereferenceObject(fileObject);
	}

	if (NULL != CSFile) {
		SipDereferenceCSFile(CSFile);
	}

	if (prepared) {
		ASSERT(!NT_SUCCESS(status));

		SipCompleteCSRefcountChange(NULL,NULL,CSFile,FALSE,TRUE);
	}

	if (NULL != perLink) {
		SipDereferencePerLink(perLink);
	}

	return status;

#undef  reparseBuffer
}

NTSTATUS
SipLinkFiles(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp)
/*++

Routine Description:

	This fsctrl function is the generic groveler interface to the filter
	driver.  It currently provides four functions: merge two files together,
	merge a file into a common store file, a hint from the groveler that
	all references to a given common store file are gone, and a request
	to verify that there are no mapped segments to a file.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/
{
	PDEVICE_EXTENSION		deviceExtension = DeviceObject->DeviceExtension;
	PSIS_LINK_FILES			linkFiles;
	NTSTATUS				status;
	PIO_STACK_LOCATION		irpSp = IoGetCurrentIrpStackLocation(Irp);
	BOOLEAN					grovelerFileHeld = FALSE;

	if (!SipCheckPhase2(deviceExtension)) {
		//
		// SIS couldn't initialize.  This probably isn't a SIS-enabled volume, so punt
		// the request.
		//

		SIS_MARK_POINT();

		status = STATUS_INVALID_DEVICE_REQUEST;
		goto done;

	}

	//
	// Make sure the MaxIndex file is already open.  We need to do this
	// to prevent a deadlock if someone perversely wants to do a link
	// with the MaxIndex file itself as the source.  We could probably
	// trust the groveler not to do this, but better safe than sorry.
	//
	status = SipAssureMaxIndexFileOpen(deviceExtension);

	if (!NT_SUCCESS(status)) {

		SIS_MARK_POINT_ULONG(status);

		goto done;

	}

	linkFiles = (PSIS_LINK_FILES)Irp->AssociatedIrp.SystemBuffer;

	if ((NULL == linkFiles)
		|| (irpSp->Parameters.FileSystemControl.InputBufferLength != sizeof(SIS_LINK_FILES))
		|| (irpSp->Parameters.FileSystemControl.OutputBufferLength  != 0)) {

		SIS_MARK_POINT();

		status = STATUS_INVALID_PARAMETER_1;
		goto done;
	}

	//
	// Check to be sure that this file is the GrovelerFile.
	//
	KeEnterCriticalRegion();
	ExAcquireResourceSharedLite(deviceExtension->GrovelerFileObjectResource, TRUE);
	grovelerFileHeld = TRUE;

	if (NULL == deviceExtension->GrovelerFileObject) {
		//
		// If we don't have a GrovelerFileObject, we were unable to
		// open or reference the GrovelerFile when Stage2 ran.  In this
		// case, link files is unavailable until reboot.
		//

		SIS_MARK_POINT();
		status = STATUS_DRIVER_INTERNAL_ERROR;
		goto done;
	}

	if (((NULL == irpSp->FileObject) 
		|| (irpSp->FileObject->FsContext != deviceExtension->GrovelerFileObject->FsContext))
#if             DBG
		&& !(BJBDebug & 0x00400000)
#endif  // DBG
		) {

		//
		// The user didn't use a handle to the right file for this.  Fail the call.
		//
		status = STATUS_ACCESS_DENIED;
		goto done;
	}

	ExReleaseResourceLite(deviceExtension->GrovelerFileObjectResource);
	KeLeaveCriticalRegion();
	grovelerFileHeld = FALSE;

	switch (linkFiles->operation) {

		case SIS_LINK_FILES_OP_MERGE:
			status = SipMergeFiles(DeviceObject, Irp, linkFiles);
			break;

		case SIS_LINK_FILES_OP_MERGE_CS:
			status = SipMergeFileWithCSFile(DeviceObject, Irp, linkFiles);
			break;

#if             0       // Not yet implemented
		case SIS_LINK_FILES_OP_HINT_NO_REFS:
			status = SipHintNoRefs(DeviceObject, Irp, linkFiles);
			status = STATUS_NOT_IMPLEMENTED;
			break;
#endif  // 0

		case SIS_LINK_FILES_OP_VERIFY_NO_MAP:
			status = SipVerifyNoMap(DeviceObject, Irp, linkFiles);
			break;

		case SIS_LINK_FILES_CHECK_VOLUME:
			status = SipCheckVolume(deviceExtension);
			break;

		default: 
			SIS_MARK_POINT();
			status = STATUS_INVALID_PARAMETER_2;
			break;
	}

done:
	if (grovelerFileHeld) {
		ExReleaseResourceLite(deviceExtension->GrovelerFileObjectResource);
		grovelerFileHeld = FALSE;
		KeLeaveCriticalRegion();
	}

	if (STATUS_PENDING != status) {
		Irp->IoStatus.Status = status;
		Irp->IoStatus.Information = 0;

		IoCompleteRequest(Irp, IO_NO_INCREMENT);
	}

	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\confest.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    confest.cpp

Abstract:

    SIS Groveler confidence estimator

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/


#include "all.hxx"

ConfidenceEstimator::ConfidenceEstimator(
    int num_groups,
    double initial_value)
{
    ASSERT(this != 0);
    ASSERT(num_groups > 0);
    ASSERT(initial_value >= 0.0);
    ASSERT(initial_value <= 1.0);
    this->num_groups = num_groups;
    group_values = new double[num_groups];
    confidence_value = initial_value;
    reset(initial_value);
}

ConfidenceEstimator::~ConfidenceEstimator()
{
    ASSERT(this != 0);
    ASSERT(num_groups > 0);
    ASSERT(confidence_value >= 0.0);
    ASSERT(confidence_value <= 1.0);
    ASSERT(group_values != 0);
    delete[] group_values;
    group_values = 0;
}

void
ConfidenceEstimator::reset(
    double reset_value)
{
    ASSERT(this != 0);
    ASSERT(num_groups > 0);
    ASSERT(confidence_value >= 0.0);
    ASSERT(confidence_value <= 1.0);
    ASSERT(group_values != 0);
    ASSERT(reset_value >= 0.0);
    ASSERT(reset_value <= 1.0);
    for (int index = 0; index < num_groups; index++)
    {
        group_values[index] = reset_value;
    }
    confidence_value = reset_value;
}

void
ConfidenceEstimator::update(
    int group_index,
    double value)
{
    ASSERT(this != 0);
    ASSERT(num_groups > 0);
    ASSERT(confidence_value >= 0.0);
    ASSERT(confidence_value <= 1.0);
    ASSERT(group_values != 0);
    ASSERT(group_index >= 0);
    ASSERT(group_index < num_groups);
    if (value > group_values[group_index])
    {
        group_values[group_index] = value;
        confidence_value = 1.0;
        for (int index = 0; index < num_groups; index++)
        {
            if (group_values[index] < confidence_value)
            {
                confidence_value = group_values[index];
            }
        }
    }
    ASSERT(confidence_value >= 0.0);
    ASSERT(confidence_value <= 1.0);
}

double
ConfidenceEstimator::confidence() const
{
    ASSERT(this != 0);
    ASSERT(num_groups > 0);
    ASSERT(confidence_value >= 0.0);
    ASSERT(confidence_value <= 1.0);
    ASSERT(group_values != 0);
    return confidence_value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\confest.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    confest.h

Abstract:

	SIS Groveler confidence estimator include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_CONFEST

#define _INC_CONFEST

class ConfidenceEstimator
{
public:

	ConfidenceEstimator(
		int num_groups,
		double initial_value = 0.0);

	~ConfidenceEstimator();

	void reset(
		double reset_value = 0.0);

	void update(
		int group_index,
		double value);

	double confidence() const;

private:

	int num_groups;
	double confidence_value;
	double *group_values;
};

#endif	/* _INC_CONFEST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\centctrl.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    centctrl.h

Abstract:

	SIS Groveler central controller include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_CENTCTRL

#define _INC_CENTCTRL

class CentralController
{
public:

	CentralController(
		int num_partitions,
		Groveler *grovelers,
		GrovelStatus *groveler_statuses,
		ReadParameters *read_parameters,
		WriteParameters *write_parameters,
		ReadDiskInformation **read_disk_info,
		WriteDiskInformation **write_disk_info,
		int *num_excluded_paths,
		const _TCHAR ***excluded_paths);

	~CentralController();

	bool any_grovelers_alive();

	void demarcate_foreground_batch(
		int partition_index);

	void command_full_volume_scan(
		int partition_index);

	static void control_groveling(
		void *context);

	static void exhort_groveling(
		void *context);

private:

	double get_cpu_load();

	void grovel_partition(
		int partition_index);

	int num_partitions;
	int num_alive_partitions;
	Groveler *grovelers;
	PartitionController **part_controllers;

	IncidentFilter hash_match_ratio_filter;
	IncidentFilter compare_match_ratio_filter;
	IncidentFilter dequeue_hash_ratio_filter;

	double *hash_match_ratio;
	double *compare_match_ratio;
	double *dequeue_hash_ratio;

	bool cpu_load_determinable;
	HQUERY qhandle;
	HCOUNTER ctr_handle;

	int base_grovel_interval;
	int max_grovel_interval;
	int max_response_lag;
	int working_grovel_interval;
	int grovel_duration;
	unsigned int last_invokation_time;

	int foreground_partition_index;
};

#endif	/* _INC_CENTCTRL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\siwrite.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    siwrite.c

Abstract:

	Write routines for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

VOID
SiWriteUpdateRanges(
	PVOID					Parameter)
{
	PRW_COMPLETION_UPDATE_RANGES_CONTEXT	updateContext = Parameter;
	KIRQL									OldIrql;
	PSIS_SCB								scb = updateContext->scb;

	SIS_MARK_POINT_ULONG(updateContext);
	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	SipAcquireScb(scb);

	//
	// Mark the range as written.
	//
	SipAddRangeToWrittenList(
			updateContext->deviceExtension,
			scb,
			&updateContext->offset,
			updateContext->length);

	scb->Flags |= SIS_SCB_ANYTHING_IN_COPIED_FILE;

	SipReleaseScb(scb);

	KeAcquireSpinLock(scb->PerLink->SpinLock, &OldIrql);
	scb->PerLink->Flags |= SIS_PER_LINK_DIRTY;
	KeReleaseSpinLock(scb->PerLink->SpinLock, OldIrql);

	SipDereferenceScb(scb,RefsWriteCompletion);

	ExFreePool(updateContext);

	return;
}

NTSTATUS
SipWriteCommonCompletion(
    IN PDEVICE_OBJECT 		DeviceObject,
    IN PIRP 				Irp,
    IN PSIS_SCB				scb,
	IN ULONG				length)
/*++

Routine Description:

	A write has completed to an SIS file.  Update the written ranges,
	posting if necessary to do this.  This function is called both from the
	normal and Mdl completion routines after they've figured out the appropriate
	write length to use.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

	scb - the scb for this operation

	length - the length of the write that completed.

Return Value:

	Returns STATUS_SUCCESS.
--*/
{
	PIO_STACK_LOCATION		irpSp = IoGetCurrentIrpStackLocation(Irp);
	BOOLEAN					PagingIo;
	KIRQL					OldIrql;
	LARGE_INTEGER			byteOffset;
	
	//
	// We don't necessarily have a valid DeviceObject parameter, so just fill it in
	// from our internal data structures.
	//
	DeviceObject = scb->PerLink->CsFile->DeviceObject;

    PagingIo = (Irp->Flags & IRP_PAGING_IO) ? TRUE : FALSE;

	byteOffset = irpSp->Parameters.Write.ByteOffset;

	if (NT_SUCCESS(Irp->IoStatus.Status)) {

//		SIS_MARK_POINT_ULONG(length);

		//
		// We need to update the written range.  To do that, we need to
		// acquire the scb, which we can only do if we're at less than
		// dispatch level.  If we are at dispatch level or greater, then
		// we'll just post off the work to do the range update.
		// NB: This can possibly cause slightly strange semantics for
		// users, because they could see a write completion, send down
		// a read for the same range, and have it redirected to the
		// common store file because the posted work hasn't happened yet...
		//

		if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
			PRW_COMPLETION_UPDATE_RANGES_CONTEXT	updateContext;

			SIS_MARK_POINT_ULONG(scb);

			updateContext = ExAllocatePoolWithTag(NonPagedPool,sizeof(*updateContext),' siS');
			if (NULL == updateContext) {
				//
				// Just fail the irp.
				//
				Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
				Irp->IoStatus.Information = 0;

				goto done;
			}

			SipReferenceScb(scb,RefsWriteCompletion);

			updateContext->scb = scb;
			updateContext->offset = byteOffset;
			updateContext->length = length;
			updateContext->deviceExtension = DeviceObject->DeviceExtension;

			ExInitializeWorkItem(
				updateContext->workQueueItem,
				SiWriteUpdateRanges,
				(PVOID)updateContext);

			ExQueueWorkItem(updateContext->workQueueItem,CriticalWorkQueue);
			
		} else {

			SipAcquireScb(scb);

			//
			// Mark the range as written.
			//
			SipAddRangeToWrittenList(
					(PDEVICE_EXTENSION)DeviceObject->DeviceExtension,
					scb,
					&byteOffset,
					length);

			scb->Flags |= SIS_SCB_ANYTHING_IN_COPIED_FILE;

			SipReleaseScb(scb);

			KeAcquireSpinLock(scb->PerLink->SpinLock, &OldIrql);
			scb->PerLink->Flags |= SIS_PER_LINK_DIRTY;
			KeReleaseSpinLock(scb->PerLink->SpinLock, OldIrql);
		}

		//
		// If appropriate, update the file pointer.
		//
		if (!PagingIo && (irpSp->FileObject->Flags & FO_SYNCHRONOUS_IO)) {

			irpSp->FileObject->CurrentByteOffset.QuadPart =
				irpSp->Parameters.Write.ByteOffset.QuadPart +
				length;
		}
	} else {
		//
		// The write failed, don't mark anything dirty.
		//
		SIS_MARK_POINT_ULONG(Irp->IoStatus.Status);
	}

done:

	SipDereferenceScb(scb, RefsWrite);

    //
    // Propogate the IRP pending flag.
    //
    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

	return STATUS_SUCCESS;

}

typedef struct _SI_MDL_WRITE_COMPLETION_CONTEXT {
	PSIS_SCB			scb;
	ULONG				length;
} SI_MDL_WRITE_COMPLETION_CONTEXT, *PSI_MDL_WRITE_COMPLETION_CONTEXT;

NTSTATUS
SiWriteMdlCompletion(
    IN PDEVICE_OBJECT 		DeviceObject,
    IN PIRP 				Irp,
    IN PVOID 				Context)
/*++

Routine Description:

	An MDL write complete has completed on an SIS file.  Grab the write length
	from the context and pass it off to the common completion routine.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

	Context - a pointer to the SI_MDL_WRITE_COMPLETION_CONTEXT for this write.

Return Value:

	Returns STATUS_SUCCESS.
--*/
{
	PSI_MDL_WRITE_COMPLETION_CONTEXT completionContext = Context;
	ULONG							 length	= completionContext->length;
	PSIS_SCB						 scb = completionContext->scb;
#if		DBG
	PIO_STACK_LOCATION				 irpSp = IoGetCurrentIrpStackLocation(Irp);

	ASSERT(irpSp->MinorFunction == IRP_MN_COMPLETE_MDL);
#endif	// DBG

	if (!NT_SUCCESS(Irp->IoStatus.Status)) {
		SIS_MARK_POINT_ULONG(Irp->IoStatus.Status);
		length = 0;
	}

	ExFreePool(completionContext);

	return SipWriteCommonCompletion(DeviceObject,Irp,scb,length);
}


NTSTATUS
SiWriteCompletion(
    IN PDEVICE_OBJECT 		DeviceObject,
    IN PIRP 				Irp,
    IN PVOID 				Context)
/*++

Routine Description:

	A non-MDL write has completed.  Extract the length and scb from the irp
	and context pointers, and call the common completion routine.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

	Context - a pointer to the scb

Return Value:

	Returns STATUS_SUCCESS.
--*/
{
	PIO_STACK_LOCATION		irpSp = IoGetCurrentIrpStackLocation(Irp);
	ULONG					length;

	ASSERT(Irp->IoStatus.Status != STATUS_PENDING);

	if (NT_SUCCESS(Irp->IoStatus.Status)) {
		//
		// Figure out how much data was written.  For normal writes, this
		// is just the Information field of the Irp.  For MDL writes, its
		// the length of the region mapped by the MDL.
		//
		ASSERT(irpSp->MinorFunction != IRP_MN_COMPLETE_MDL);
		if (irpSp->MinorFunction == IRP_MN_MDL) {
			//
			// This was a write prepare.  Ignore it.
			//
			SipDereferenceScb((PSIS_SCB)Context, RefsWrite);
			return STATUS_SUCCESS;
		} else if (irpSp->MinorFunction == IRP_MN_NORMAL) {
			length = (ULONG)Irp->IoStatus.Information;
		} else {
			SIS_MARK_POINT_ULONG(Irp);
			SIS_MARK_POINT_ULONG(irpSp);

			DbgPrint("SIS: SiWriteCompletion: unknown minor function code 0x%x, irp 0x%x, irpSp 0x%x\n",
						irpSp->MinorFunction,Irp,irpSp);

			ASSERT(FALSE && "SiWriteComplete: unknown irp minor function");

			SipDereferenceScb((PSIS_SCB)Context, RefsWrite);

			return STATUS_SUCCESS;
		}
	} else {
		length = 0;
	}

	return SipWriteCommonCompletion(DeviceObject,Irp,Context,length);

}


NTSTATUS
SiWrite(
    IN PDEVICE_OBJECT 	DeviceObject,
    IN PIRP 			Irp)
/*++

Routine Description:

	This function handles write operations.  Check to see if the file object is a
	SIS file.  If so, handle the write (possibly forcing a copy-on-write), otherwise
	pass it through to NTFS.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the result of the read, or the
	status of the call to the file system's entry point in the case of a
	pass-through call.

--*/
{
    PIO_STACK_LOCATION 			irpSp = IoGetCurrentIrpStackLocation(Irp);
	PIO_STACK_LOCATION			nextIrpSp;
	PFILE_OBJECT 				fileObject = irpSp->FileObject;
	PSIS_SCB 					scb;
	ULONG						writeLength;
	LONGLONG					byteOffset;
    BOOLEAN 					PagingIo;
	PDEVICE_EXTENSION			deviceExtension;
	PSIS_PER_FILE_OBJECT		perFO;
	PSIS_PER_LINK				perLink;
	PSIS_CS_FILE				csFile;

	SipHandleControlDeviceObject(DeviceObject, Irp);

	if (!SipIsFileObjectSIS(fileObject,DeviceObject,FindActive,&perFO,&scb)) {
		SipDirectPassThroughAndReturn(DeviceObject, Irp);
	}

	ASSERT(perFO->fileObject == fileObject);

	perLink = scb->PerLink;
	csFile = perLink->CsFile;

	deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    PagingIo = (Irp->Flags & IRP_PAGING_IO) ? TRUE : FALSE;
	
	byteOffset = irpSp->Parameters.Write.ByteOffset.QuadPart;
	writeLength = irpSp->Parameters.Write.Length;

	SIS_MARK_POINT_ULONG(perFO);
	SIS_MARK_POINT_ULONG(scb);

#if		DBG
	if (0 != byteOffset) {
		SIS_MARK_POINT_ULONG(byteOffset);
	}

	if (0x200 != writeLength) {
		SIS_MARK_POINT_ULONG(writeLength);
	}

	if (PagingIo || (Irp->Flags & IRP_NOCACHE)) {
		SIS_MARK_POINT_ULONG((PagingIo << 1) | ((Irp->Flags & IRP_NOCACHE) != 0));
	}

	if (BJBDebug & 0x00008000) {
		DbgPrint("SIS: SiWrite: perFO %p, scb %p, bo.Low 0x%x, rel 0x%x, PIO %d, NC %d MF 0x%x\n",
				perFO,scb,(ULONG)byteOffset,writeLength,PagingIo, (Irp->Flags & IRP_NOCACHE) != 0, irpSp->MinorFunction);
	}
#endif	// DBG

	//
	// Setup the next irp stack location for the underlying filesystem on the
	// copied file (which is the same file object with which we were called)
	//
	nextIrpSp = IoGetNextIrpStackLocation(Irp);
	RtlMoveMemory(nextIrpSp,irpSp,sizeof(IO_STACK_LOCATION));

	//
	// Grab a reference to the SCB for the write completion routine.
	//
	SipReferenceScb(scb, RefsWrite);

	if (irpSp->MinorFunction == IRP_MN_COMPLETE_MDL) {
		//
		// This is an MDL completion, grab the length from the MDL here, because it
		// will be gone on the way back up.
		//
		PSI_MDL_WRITE_COMPLETION_CONTEXT completionContext = 
				ExAllocatePoolWithTag(NonPagedPool, sizeof(SI_MDL_WRITE_COMPLETION_CONTEXT),' siS');

		if (NULL == completionContext) {
			SIS_MARK_POINT();
			Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
			Irp->IoStatus.Information = 0;

			SipDereferenceScb(scb, RefsWrite);

			IoCompleteRequest(Irp, IO_NO_INCREMENT);
	
			return STATUS_INSUFFICIENT_RESOURCES;
		}

		ASSERT(NULL != Irp->MdlAddress);
		completionContext->scb = scb;
		completionContext->length = MmGetMdlByteCount(Irp->MdlAddress);

		IoSetCompletionRoutine(
				Irp,
				SiWriteMdlCompletion,
				completionContext,
				TRUE,
				TRUE,
				TRUE);
	} else {

		IoSetCompletionRoutine(
				Irp,
				SiWriteCompletion,
				scb,
				TRUE,
				TRUE,
				TRUE);
	}

	//
	// Hand the request down to the underlying filesystem.
	//
	
	return IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\sitree.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sitree.c

Abstract:

    This module implements a splay tree package based on the Rtl
    splay routines.  Adapted from the Rtl generic table package.

--*/

#include "sip.h"


//
// This enumerated type is used as the function return
// value of the function that is used to search the tree
// for a key.  SisFoundNode indicates that the function found
// the key.  SisInsertAsLeft indicates that the key was not found
// and the node should be inserted as the left child of the
// parent.  SisInsertAsRight indicates that the key was not found
// and the node should be inserted as the right child of the
// parent.
//

typedef enum _SIS_SEARCH_RESULT{
    SisEmptyTree,
    SisFoundNode,
    SisInsertAsLeft,
    SisInsertAsRight
} SIS_SEARCH_RESULT;


static
SIS_SEARCH_RESULT
FindNodeOrParent(
    IN PSIS_TREE Tree,
    IN PVOID Key,
    OUT PRTL_SPLAY_LINKS *NodeOrParent
    )

/*++

Routine Description:

    This routine is private to the tree package and will
    find and return (via the NodeOrParent parameter) the node
    with the given key, or if that node is not in the tree it
    will return (via the NodeOrParent parameter) a pointer to
    the parent.

Arguments:

    Tree        - The  tree to search for the key.

    Key          - Pointer to a buffer holding the key.  The tree
                   package doesn't examine the key itself.  It leaves
                   this up to the user supplied compare routine.

    NodeOrParent - Will be set to point to the node containing the
                   the key or what should be the parent of the node
                   if it were in the tree.  Note that this will *NOT*
                   be set if the search result is SisEmptyTree.

Return Value:

    SIS_SEARCH_RESULT - SisEmptyTree: The tree was empty.  NodeOrParent
                                      is *not* altered.

                    SisFoundNode: A node with the key is in the tree.
                                  NodeOrParent points to that node.

                    SisInsertAsLeft: Node with key was not found.
                                     NodeOrParent points to what would be
                                     parent.  The node would be the left
                                     child.

                    SisInsertAsRight: Node with key was not found.
                                      NodeOrParent points to what would be
                                      parent.  The node would be the right
                                      child.

--*/

{

    if (Tree->TreeRoot == NULL) {

        return SisEmptyTree;

    } else {

        //
        // Used as the iteration variable while stepping through
        // the  tree.
        //
        PRTL_SPLAY_LINKS NodeToExamine = Tree->TreeRoot;

        //
        // Just a temporary.  Hopefully a good compiler will get
        // rid of it.
        //
        PRTL_SPLAY_LINKS Child;

        //
        // Holds the value of the comparasion.
        //
        int Result;

        while (TRUE) {

            //
            // Compare the buffer with the key in the tree element.
            //

            Result = Tree->CompareRoutine(
                         Key,
                         NodeToExamine
                         );

            if (Result < 0) {

                if (Child = RtlLeftChild(NodeToExamine)) {

                    NodeToExamine = Child;

                } else {

                    //
                    // Node is not in the tree.  Set the output
                    // parameter to point to what would be its
                    // parent and return which child it would be.
                    //

                    *NodeOrParent = NodeToExamine;
                    return SisInsertAsLeft;

                }

            } else if (Result > 0) {

                if (Child = RtlRightChild(NodeToExamine)) {

                    NodeToExamine = Child;

                } else {

                    //
                    // Node is not in the tree.  Set the output
                    // parameter to point to what would be its
                    // parent and return which child it would be.
                    //

                    *NodeOrParent = NodeToExamine;
                    return SisInsertAsRight;

                }


            } else {

                //
                // Node is in the tree (or it better be because of the
                // assert).  Set the output parameter to point to
                // the node and tell the caller that we found the node.
                //

                ASSERT(Result == 0);
                *NodeOrParent = NodeToExamine;
                return SisFoundNode;

            }

        }

    }

}


VOID
SipInitializeTree (
    IN PSIS_TREE Tree,
    IN PSIS_TREE_COMPARE_ROUTINE CompareRoutine
    )

/*++

Routine Description:

    The procedure InitializeTree prepares a tree for use.
    This must be called for every individual tree variable before
    it can be used.

Arguments:

    Tree - Pointer to the  tree to be initialized.

    CompareRoutine - User routine to be used to compare to keys in the
                     tree.

Return Value:

    None.

--*/

{

    Tree->TreeRoot = NULL;
    Tree->CompareRoutine = CompareRoutine;

}


PVOID
SipInsertElementTree (
    IN PSIS_TREE Tree,
    IN PVOID Node,
    IN PVOID Key
    )

/*++

Routine Description:

    The function SipInsertElementTree will insert a new element in a tree.
    If an element with the same key already exists in the tree the return
    value is a pointer to the old element.  Otherwise, the return value is
    a pointer to the new element.  Note that this differs from the Rtl
    generic table package in that the actual node passed in is inserted in
    the tree, whereas the table package inserts a copy of the node.

Arguments:

    Tree - Pointer to the tree in which to (possibly) insert the
           node.

    Node - Pointer to the node to insert in the tree.  Will not be inserted
           if a node with a matching key is found.

    Key - Passed to the user comparasion routine.

Return Value:

    PVOID - Pointer to the new node or the existing node if one exists.

--*/

{

    //
    // Holds a pointer to the node in the tree or what would be the
    // parent of the node.
    //
    PRTL_SPLAY_LINKS NodeOrParent;

    //
    // Holds the result of the tree lookup.
    //
    SIS_SEARCH_RESULT Lookup;

    //
    // Node will point to the splay links of what
    // will be returned to the user.
    //
    PRTL_SPLAY_LINKS NodeToReturn = (PRTL_SPLAY_LINKS) Node;

    Lookup = FindNodeOrParent(
                 Tree,
                 Key,
                 &NodeOrParent
                 );

    if (Lookup != SisFoundNode) {

        RtlInitializeSplayLinks(NodeToReturn);

        //
        // Insert the new node in the tree.
        //

        if (Lookup == SisEmptyTree) {

            Tree->TreeRoot = NodeToReturn;

        } else {

            if (Lookup == SisInsertAsLeft) {

                RtlInsertAsLeftChild(
                    NodeOrParent,
                    NodeToReturn
                    );

            } else {

                RtlInsertAsRightChild(
                    NodeOrParent,
                    NodeToReturn
                    );

            }

        }

    } else {

        NodeToReturn = NodeOrParent;

    }

    //
    // Always splay the (possibly) new node.
    //

    Tree->TreeRoot = RtlSplay(NodeToReturn);

    return NodeToReturn;
}


VOID
SipDeleteElementTree (
    IN PSIS_TREE Tree,
    IN PVOID Node
    )

/*++

Routine Description:

    The function SipDeleteElementTree will remove an element
    from a tree.  Note that the memory associated with the node
    is not actually freed.

Arguments:

    Tree - Pointer to the tree in which to remove the specified node.

    Node - Node of tree to remove.

Return Value:

    None.

--*/

{

    PRTL_SPLAY_LINKS NodeToDelete = (PRTL_SPLAY_LINKS) Node;

    //
    // Delete the node from the tree.  Note that RtlDelete
    // will splay the tree.
    //

    Tree->TreeRoot = RtlDelete(NodeToDelete);

}


PVOID
SipLookupElementTree (
    IN PSIS_TREE Tree,
    IN PVOID Key
    )

/*++

Routine Description:

    The function SipLookupElementTree will find an element in a
    tree.  If the element is located the return value is a pointer to
    the element, otherwise if the element is not located the return
    value is NULL.

Arguments:

    Tree - Pointer to the users tree to search for the key.

    Key - Used for the comparasion.

Return Value:

    PVOID - returns a pointer to the user data.

--*/

{

    //
    // Holds a pointer to the node in the tree or what would be the
    // parent of the node.
    //
    PRTL_SPLAY_LINKS NodeOrParent;

    //
    // Holds the result of the tree lookup.
    //
    SIS_SEARCH_RESULT Lookup;

    Lookup = FindNodeOrParent(
                 Tree,
                 Key,
                 &NodeOrParent
                 );

    if (Lookup == SisEmptyTree) {

        return NULL;

    } else {

        //
        // Splay the tree with this node.  Note that we do this irregardless
        // of whether the node was found.
        //

        Tree->TreeRoot = RtlSplay(NodeOrParent);

        //
        // Return a pointer to the user data.
        //

        if (Lookup == SisFoundNode) {

            return NodeOrParent;

        } else {

            return NULL;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\centctrl.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    centctrl.cpp

Abstract:

    SIS Groveler central controller

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

const _TCHAR total_processor_time_path[] = _T("\\Processor(_Total#0)\\% Processor Time");

CentralController::CentralController(
    int num_partitions,
    Groveler *grovelers,
    GrovelStatus *groveler_statuses,
    ReadParameters *read_parameters,
    WriteParameters *write_parameters,
    ReadDiskInformation **read_disk_info,
    WriteDiskInformation **write_disk_info,
    int *num_excluded_paths,
    const _TCHAR ***excluded_paths)
:   hash_match_ratio_filter(read_parameters->sis_efficacy_history_size,
        write_parameters->hash_match_ratio),
    compare_match_ratio_filter(read_parameters->sis_efficacy_history_size,
        write_parameters->compare_match_ratio),
    dequeue_hash_ratio_filter(read_parameters->log_winnow_history_size,
        write_parameters->dequeue_hash_ratio)
{
    ASSERT(this != 0);
    unsigned int current_time = GET_TICK_COUNT();
    this->num_partitions = num_partitions;
    ASSERT(num_partitions > 0);
    this->grovelers = grovelers;
    ASSERT(grovelers != 0);
    base_grovel_interval = read_parameters->base_grovel_interval;
    ASSERT(base_grovel_interval > 0);
    max_grovel_interval = read_parameters->max_grovel_interval;
    ASSERT(max_grovel_interval > 0);
    ASSERT(max_grovel_interval >= base_grovel_interval);
    max_response_lag = read_parameters->max_response_lag;
    ASSERT(max_response_lag > 0);
    working_grovel_interval = read_parameters->working_grovel_interval;
    ASSERT(working_grovel_interval > 0);
    ASSERT(base_grovel_interval >= working_grovel_interval);
    grovel_duration = read_parameters->grovel_duration;
    ASSERT(grovel_duration > 0);
    ASSERT(grovel_duration <= base_grovel_interval);
    ASSERT(grovel_duration <= max_grovel_interval);
    ASSERT(grovel_duration <= working_grovel_interval);
    hash_match_ratio = &write_parameters->hash_match_ratio;
    ASSERT(hash_match_ratio != 0);
    ASSERT(*hash_match_ratio >= 0.0);
    ASSERT(*hash_match_ratio <= 1.0);
    compare_match_ratio = &write_parameters->compare_match_ratio;
    ASSERT(compare_match_ratio != 0);
    ASSERT(*compare_match_ratio >= 0.0);
    ASSERT(*compare_match_ratio <= 1.0);
    dequeue_hash_ratio = &write_parameters->dequeue_hash_ratio;
    ASSERT(dequeue_hash_ratio != 0);
    ASSERT(*dequeue_hash_ratio >= 0.0);
    ASSERT(*dequeue_hash_ratio <= 1.0);
    foreground_partition_index = 0;
    num_alive_partitions = 0;
    bool some_groveler_dead = false;

    //
    //  Create the control structure for each partion
    //

    part_controllers = new PartitionController*[num_partitions];
    for (int index = 0; index < num_partitions; index++)
    {
        part_controllers[index] = new PartitionController(
            &grovelers[index],
            groveler_statuses[index],
            read_parameters->target_entries_per_extraction,
            read_parameters->max_extraction_interval,
            base_grovel_interval,
            max_grovel_interval,
            read_parameters->low_confidence_grovel_interval,
            read_parameters->low_disk_space_grovel_interval,
            read_parameters->partition_info_update_interval,
            read_parameters->base_restart_extraction_interval,
            read_parameters->max_restart_extraction_interval,
            read_parameters->base_restart_groveling_interval,
            read_parameters->max_restart_groveling_interval,
            read_parameters->base_regrovel_interval,
            read_parameters->max_regrovel_interval,
            read_parameters->volscan_regrovel_threshold,
            read_parameters->partition_balance_time_constant,
            read_parameters->read_time_increase_history_size,
            read_parameters->read_time_decrease_history_size,
            read_parameters->file_size_history_size,
            read_disk_info[index]->error_retry_log_extraction,
            read_disk_info[index]->error_retry_groveling,
            read_disk_info[index]->base_usn_log_size,
            read_disk_info[index]->max_usn_log_size,
            read_parameters->sample_group_size,
            read_parameters->acceptance_p_value,
            read_parameters->rejection_p_value,
            read_parameters->base_use_multiplier,
            read_parameters->max_use_multiplier,
            read_parameters->peak_finder_accuracy,
            read_parameters->peak_finder_range,
            read_parameters->base_cpu_load_threshold,
            read_parameters->max_cpu_load_threshold,
            hash_match_ratio,
            compare_match_ratio,
            dequeue_hash_ratio,
            &write_disk_info[index]->partition_hash_read_time_estimate,
            &write_disk_info[index]->partition_compare_read_time_estimate,
            &write_disk_info[index]->mean_file_size,
            &write_disk_info[index]->read_time_confidence,
            &write_disk_info[index]->volume_serial_number,
            index,
            read_parameters->read_report_discard_threshold,
            read_disk_info[index]->min_file_size,
            read_disk_info[index]->min_file_age,
            read_disk_info[index]->allow_compressed_files,
            read_disk_info[index]->allow_encrypted_files,
            read_disk_info[index]->allow_hidden_files,
            read_disk_info[index]->allow_offline_files,
            read_disk_info[index]->allow_temporary_files,
            num_excluded_paths[index],
            excluded_paths[index]);
        if (groveler_statuses[index] != Grovel_disable)
        {
            if (groveler_statuses[index] == Grovel_ok ||
                groveler_statuses[index] == Grovel_new ||
                read_disk_info[index]->error_retry_groveling)
            {
                num_alive_partitions++;
            }
            else
            {
                ASSERT(groveler_statuses[index] == Grovel_error);
                some_groveler_dead = true;
            }
        }
    }
    if (num_alive_partitions == 0)
    {
        if (some_groveler_dead)
        {
            eventlog.report_event(GROVMSG_ALL_GROVELERS_DEAD, ERROR_SUCCESS, 0);
        }
        else
        {
            eventlog.report_event(GROVMSG_ALL_GROVELERS_DISABLED, ERROR_SUCCESS, 0);
        }
        return;
    }

    cpu_load_determinable = false;
    PDH_STATUS status = PdhOpenQuery(0, 0, &qhandle);
    if (status == ERROR_SUCCESS)
    {
        ASSERT(qhandle != 0);
        status = PdhAddCounter(qhandle, total_processor_time_path, 0, &ctr_handle);
        if (status == ERROR_SUCCESS)
        {
            ASSERT(ctr_handle != 0);
            cpu_load_determinable = true;
            get_cpu_load();
        }
        else
        {
            PRINT_DEBUG_MSG(
                (_T("GROVELER: PdhAddCounter returned error.  PDH_STATUS = %lx\n"),
                status));
        }
    }
    else
    {
        PRINT_DEBUG_MSG((_T("GROVELER: PdhOpenQuery returned error.  PDH_STATUS = %lx\n"),
            status));
    }
    last_invokation_time = current_time;
    event_timer.schedule(current_time + base_grovel_interval,
        (void *)this, control_groveling);
}

CentralController::~CentralController()
{
    ASSERT(this != 0);
    ASSERT(num_partitions > 0);
    if (cpu_load_determinable)
    {
        ASSERT(qhandle != 0);
        PDH_STATUS status = PdhCloseQuery(qhandle);
        if (status != ERROR_SUCCESS)
        {
            PRINT_DEBUG_MSG(
                (_T("GROVELER: PdhCloseQuery returned error.  PDH_STATUS = %lx\n"),
                status));
        }
        qhandle = 0;
    }
    for (int index = 0; index < num_partitions; index++)
    {
        ASSERT(part_controllers[index] != 0);
        delete part_controllers[index];
        part_controllers[index] = 0;
    }
    ASSERT(part_controllers != 0);
    delete[] part_controllers;
    part_controllers = 0;
}

bool
CentralController::any_grovelers_alive()
{
    ASSERT(this != 0);
    return num_alive_partitions > 0;
}

void
CentralController::demarcate_foreground_batch(
    int partition_index)
{
    ASSERT(this != 0);
    ASSERT(partition_index >= 0);
    ASSERT(partition_index < num_partitions);
    part_controllers[partition_index]->demarcate_foreground_batch();
}

void
CentralController::command_full_volume_scan(
    int partition_index)
{
    ASSERT(this != 0);
    ASSERT(partition_index >= 0);
    ASSERT(partition_index < num_partitions);
    part_controllers[partition_index]->command_full_volume_scan();
}

void
CentralController::control_groveling(
    void *context)
{
    ASSERT(context != 0);
    unsigned int invokation_time = GET_TICK_COUNT();
    TRACE_PRINTF(TC_centctrl, 3, (_T("time: %d\n"), invokation_time));
    TRACE_PRINTF(TC_centctrl, 3, (_T("\tCCcg -\tcontrolling groveling\n")));
    CentralController *me = (CentralController *)context;
    ASSERT(me->num_partitions > 0);
    ASSERT(me->num_alive_partitions > 0);
    if (SERVICE_GROVELING_PAUSED() || SERVICE_FOREGROUND_GROVELING())
    {
        TRACE_PRINTF(TC_centctrl, 1, (_T("\tCCcg -\tsuspending controller\n")));
        SERVICE_SUSPENDING_CONTROLLER();
        return;  // return without scheduling another control_groveling()
    }
    int partition_index = -1;
    double top_priority = DBL_MAX;
    unsigned int time_delta = invokation_time - me->last_invokation_time;
    ASSERT(signed(time_delta) >= 0);
    for (int index = 0; index < me->num_partitions; index++)
    {
        me->part_controllers[index]->advance(time_delta);
        if (me->part_controllers[index]->wait() == 0)
        {
            double partition_priority = me->part_controllers[index]->priority();
            if (partition_priority < top_priority)
            {
                partition_index = index;
                top_priority = partition_priority;
            }
        }
    }
    if (partition_index >= 0)
    {
        ASSERT(partition_index < me->num_partitions);
        TRACE_PRINTF(TC_centctrl, 5,
            (_T("\tCCcg -\tgroveling partition %d\n"), partition_index));
        me->grovel_partition(partition_index);
    }
    else
    {
        TRACE_PRINTF(TC_centctrl, 4,
            (_T("\tCCcg -\tno partition controllers ready to grovel.\n")));
    }
    int grovel_interval = me->max_response_lag;
    ASSERT(grovel_interval > 0);
    for (index = 0; index < me->num_partitions; index++)
    {
        int wait = me->part_controllers[index]->wait();
        if (wait < grovel_interval)
        {
            grovel_interval = wait;
        }
    }
    if (grovel_interval < me->working_grovel_interval)
    {
        grovel_interval = me->working_grovel_interval;
    }
    TRACE_PRINTF(TC_centctrl, 5,
        (_T("\tCCcg -\tgrovel interval = %d\n"), grovel_interval));
    me->last_invokation_time = invokation_time;
    ASSERT(grovel_interval > 0);
    event_timer.schedule(invokation_time + grovel_interval,
        context, control_groveling);
}

void
CentralController::exhort_groveling(
    void *context)
{
    ASSERT(context != 0);
    unsigned int invokation_time = GET_TICK_COUNT();
    TRACE_PRINTF(TC_centctrl, 3, (_T("time: %d\n"), invokation_time));
    TRACE_PRINTF(TC_centctrl, 3, (_T("\tCCcg -\texhorting groveling\n")));
    CentralController *me = (CentralController *)context;
    ASSERT(me->num_partitions > 0);
    ASSERT(me->num_alive_partitions > 0);
    if (SERVICE_GROVELING_PAUSED() || !SERVICE_FOREGROUND_GROVELING())
    {
        TRACE_PRINTF(TC_centctrl, 1, (_T("\tCCcg -\tsuspending exhorter\n")));
        SERVICE_SUSPENDING_EXHORTER();
        return;  // return without scheduling another exhort_groveling()
    }
    for (int index = 0; index < me->num_partitions; index++)
    {
        me->foreground_partition_index =
            (me->foreground_partition_index + 1) % me->num_partitions;
        if (SERVICE_PARTITION_IN_FOREGROUND(me->foreground_partition_index))
        {
            break;
        }
    }
    ASSERT(me->foreground_partition_index >= 0);
    ASSERT(me->foreground_partition_index < me->num_partitions);
    ASSERT(SERVICE_PARTITION_IN_FOREGROUND(me->foreground_partition_index));
    TRACE_PRINTF(TC_centctrl, 5, (_T("\tCCcg -\tgroveling partition %d\n"),
        me->foreground_partition_index));
    me->grovel_partition(me->foreground_partition_index);
    event_timer.schedule(invokation_time + me->working_grovel_interval,
        context, exhort_groveling);
}

double
CentralController::get_cpu_load()
{
    ASSERT(this != 0);
    if (!cpu_load_determinable)
    {
        return 0.0;
    }
    ASSERT(qhandle != 0);
    ASSERT(ctr_handle != 0);
    PDH_STATUS status = PdhCollectQueryData(qhandle);
    if (status != ERROR_SUCCESS)
    {
        PRINT_DEBUG_MSG(
            (_T("GROVELER: PdhCollectQueryData returned error.  PDH_STATUS = %lx\n"),
            status));
        return 0.0;
    }
    PDH_FMT_COUNTERVALUE pdh_value;
    status =
        PdhGetFormattedCounterValue(ctr_handle, PDH_FMT_LONG, 0, &pdh_value);
    if (status != ERROR_SUCCESS)
    {
        PRINT_DEBUG_MSG(
            (_T("GROVELER: PdhGetFormattedCounterValue returned error.  PDH_STATUS = %lx\n"),
            status));
        return 0.0;
    }
    if (pdh_value.CStatus != ERROR_SUCCESS)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: PDH_FMT_COUNTERVALUE::CStatus = %lx\n"), status));
        return 0.0;
    }
    double cpu_load = double(pdh_value.longValue) / 100.0;
    if (cpu_load < 0.0)
    {
        cpu_load = 0.0;
    }
    if (cpu_load > 1.0)
    {
        cpu_load = 1.0;
    }
    return cpu_load;
}

void
CentralController::grovel_partition(
    int partition_index)
{
    ASSERT(this != 0);
    DWORD count_of_files_hashed;
    DWORDLONG bytes_of_files_hashed;
    DWORD count_of_files_matching;
    DWORDLONG bytes_of_files_matching;
    DWORD count_of_files_compared;
    DWORDLONG bytes_of_files_compared;
    DWORD count_of_files_merged;
    DWORDLONG bytes_of_files_merged;
    DWORD count_of_files_enqueued;
    DWORD count_of_files_dequeued;
    double cpu_load = get_cpu_load();
    TRACE_PRINTF(TC_centctrl, 4, (_T("\tCCgp -\tcpu load = %f\n"), cpu_load));
    ASSERT(cpu_load >= 0.0);
    ASSERT(cpu_load <= 1.0);
    bool ok = part_controllers[partition_index]->
        control_operation(grovel_duration,
        &count_of_files_hashed, &bytes_of_files_hashed,
        &count_of_files_matching, &bytes_of_files_matching,
        &count_of_files_compared, &bytes_of_files_compared,
        &count_of_files_merged, &bytes_of_files_merged,
        &count_of_files_enqueued, &count_of_files_dequeued,
        cpu_load);
    if (ok)
    {
        ASSERT(bytes_of_files_hashed >= count_of_files_hashed);
        ASSERT(bytes_of_files_matching >= count_of_files_matching);
        ASSERT(bytes_of_files_compared >= count_of_files_compared);
        ASSERT(bytes_of_files_merged >= count_of_files_merged);
        ASSERT(count_of_files_hashed >= count_of_files_matching);
        ASSERT(bytes_of_files_hashed >= bytes_of_files_matching);
        ASSERT(count_of_files_compared >= count_of_files_merged);
        ASSERT(bytes_of_files_compared >= bytes_of_files_merged);
        ASSERT(count_of_files_dequeued >= count_of_files_hashed);
        TRACE_PRINTF(TC_centctrl, 3, 
            (_T("\tCCgp -\tpartition %d groveled.\n"), partition_index));
        TRACE_PRINTF(TC_centctrl, 4,
            (_T("\tCCgp -\tfiles hashed = %d\n"), count_of_files_hashed));
        TRACE_PRINTF(TC_centctrl, 4,
            (_T("\tCCgp -\tbytes hashed = %I64d\n"), bytes_of_files_hashed));
        TRACE_PRINTF(TC_centctrl, 4,
            (_T("\tCCgp -\tfiles matching = %d\n"), count_of_files_matching));
        TRACE_PRINTF(TC_centctrl, 4,
            (_T("\tCCgp -\tbytes matching = %I64d\n"),
            bytes_of_files_matching));
        TRACE_PRINTF(TC_centctrl, 4,
            (_T("\tCCgp -\tfiles compared = %d\n"), count_of_files_matching));
        TRACE_PRINTF(TC_centctrl, 4,
            (_T("\tCCgp -\tbytes compared = %I64d\n"),
            bytes_of_files_matching));
        TRACE_PRINTF(TC_centctrl, 4,
            (_T("\tCCgp -\tfiles merged = %d\n"), count_of_files_merged));
        TRACE_PRINTF(TC_centctrl, 4,
            (_T("\tCCgp -\tbytes merged = %I64d\n"), bytes_of_files_merged));
        TRACE_PRINTF(TC_centctrl, 4,
            (_T("\tCCgp -\tfiles enqueued = %d\n"), count_of_files_enqueued));
        TRACE_PRINTF(TC_centctrl, 4,
            (_T("\tCCgp -\tfiles dequeued = %d\n"), count_of_files_dequeued));
        if (bytes_of_files_hashed > 0)
        {
            double sample_hash_match_ratio =
                double(__int64(bytes_of_files_matching))
                / double(__int64(bytes_of_files_hashed));
            ASSERT(sample_hash_match_ratio >= 0.0);
            ASSERT(sample_hash_match_ratio <= 1.0);
            TRACE_PRINTF(TC_centctrl, 4,
                (_T("\tCCgp -\tsample hash match ratio = %f\n"),
                sample_hash_match_ratio));
            hash_match_ratio_filter.update_value(
                sample_hash_match_ratio, count_of_files_hashed);
            *hash_match_ratio = hash_match_ratio_filter.retrieve_value();
            ASSERT(*hash_match_ratio >= 0.0);
            ASSERT(*hash_match_ratio <= 1.0);
            TRACE_PRINTF(TC_centctrl, 3,
                (_T("\tCCgp -\tfiltered hash match ratio = %f\n"),
                *hash_match_ratio));
        }
        if (bytes_of_files_compared > 0)
        {
            double sample_compare_match_ratio =
                double(__int64(bytes_of_files_merged))
                / double(__int64(bytes_of_files_compared));
            ASSERT(sample_compare_match_ratio >= 0.0);
            ASSERT(sample_compare_match_ratio <= 1.0);
            TRACE_PRINTF(TC_centctrl, 4,
                (_T("\tCCgp -\tsample compare match ratio = %f\n"),
                sample_compare_match_ratio));
            compare_match_ratio_filter.update_value(
                sample_compare_match_ratio, count_of_files_compared);
            *compare_match_ratio = compare_match_ratio_filter.retrieve_value();
            ASSERT(*compare_match_ratio >= 0.0);
            ASSERT(*compare_match_ratio <= 1.0);
            TRACE_PRINTF(TC_centctrl, 3,
                (_T("\tCCgp -\tfiltered compare match ratio = %f\n"),
                *compare_match_ratio));
        }
        if (count_of_files_dequeued > 0)
        {
            double sample_dequeue_hash_ratio =
                double(__int64(count_of_files_hashed))
                / double(__int64(count_of_files_dequeued));
            ASSERT(sample_dequeue_hash_ratio >= 0.0);
            ASSERT(sample_dequeue_hash_ratio <= 1.0);
            TRACE_PRINTF(TC_centctrl, 4,
                (_T("\tCCgp -\tsample dequeue hash ratio = %f\n"),
                sample_dequeue_hash_ratio));
            dequeue_hash_ratio_filter.update_value(
                sample_dequeue_hash_ratio, count_of_files_dequeued);
            *dequeue_hash_ratio = dequeue_hash_ratio_filter.retrieve_value();
            ASSERT(*dequeue_hash_ratio >= 0.0);
            ASSERT(*dequeue_hash_ratio <= 1.0);
            TRACE_PRINTF(TC_centctrl, 3,
                (_T("\tCCgp -\tfiltered dequeue hash ratio = %f\n"),
                *dequeue_hash_ratio));
        }
    }
    else
    {
        TRACE_PRINTF(TC_centctrl, 1,
            (_T("\tCCgp -\tpartition %d groveler dead.\n"), partition_index));
        num_alive_partitions--;
        if (num_alive_partitions <= 0)
        {
            ASSERT(num_alive_partitions == 0);
            eventlog.report_event(GROVMSG_ALL_GROVELERS_DEAD, ERROR_SUCCESS, 0);
            event_timer.halt();
            return;
        }
    }
//  get_cpu_load();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\database.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    database.cpp

Abstract:

    SIS Groveler Jet-Blue database front-end

Authors:

    Cedric Krumbein, 1998

Environment:

    User Mode


Revision History:

--*/

#include "all.hxx"

/*****************************************************************************/
/*************** SGDatabase class static value initializations ***************/
/*****************************************************************************/

DWORD SGDatabase::numInstances = 0;

JET_INSTANCE SGDatabase::instance = 0;

BOOL SGDatabase::jetInitialized = FALSE;

TCHAR * SGDatabase::logDir = NULL;

/*****************************************************************************/
/****************** SGDatabase class private static methods ******************/
/*****************************************************************************/

BOOL SGDatabase::set_log_drive(const _TCHAR *drive_name)
{
    int drive_name_len = wcslen(drive_name);
    int logDirLen = drive_name_len + wcslen(CS_DIR_PATH) + 1;
    HRESULT r;

    //
    //  Allocate a buffer
    //

    ASSERT(drive_name_len > 0);
    ASSERT(NULL == logDir);
    logDir = new TCHAR[logDirLen];
    ASSERT(NULL != logDir);

    //
    //  copy the log drive name, remove trailing slash if there is one
    //

    r = StringCchCopy(logDir,
                      logDirLen,
                      drive_name);

    ASSERT(r == S_OK);

    //
    //  Insert common store directory path
    //

    TrimTrailingChar(logDir,L'\\');

    r = StringCchCat(logDir,
                     logDirLen,
                     CS_DIR_PATH);

    ASSERT(r == S_OK);

    return TRUE;
}

BOOL SGDatabase::InitializeEngine()
{
    DWORD_PTR maxVerPages;
    DWORD_PTR minCacheSize;
    DWORD_PTR newCacheSize;
    DWORDLONG cacheSize;
    DWORD circularLog;
    MEMORYSTATUSEX memStatus;
    SYSTEM_INFO sysInfo;

    JET_ERR jetErr;

    ASSERT(!jetInitialized);
    ASSERT(logDir);

    if (!SetCurrentDirectory(logDir)) {
        DPRINTF((_T("SGDatabase::InitializeEngine: can't cd to \"%s\", %ld\n"), logDir, GetLastError()));
        return FALSE;
    }

    circularLog = 1;
    jetErr = JetSetSystemParameter(&instance, 0,
        JET_paramCircularLog, circularLog, NULL);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("(2) JetSetSystemParameter: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    //
    // Set the maximum cache size used by the database engine to min(4% phys mem, 6M).
    //

    jetErr = JetGetSystemParameter(instance, 0,
        JET_paramCacheSizeMin, &minCacheSize, NULL, 0);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetGetSystemParameter: jetErr=%ld\n"), jetErr));
        TerminateEngine();
        return FALSE;
    }

    memStatus.dwLength = sizeof memStatus;
    GlobalMemoryStatusEx(&memStatus);   // get total physical memory
    GetSystemInfo(&sysInfo);            // get page size

    cacheSize = memStatus.ullTotalPhys / 25;    // 4%
    newCacheSize = (DWORD) min(cacheSize, MAX_DATABASE_CACHE_SIZE);
    newCacheSize = newCacheSize / sysInfo.dwPageSize;

    if (newCacheSize < minCacheSize)
        newCacheSize = minCacheSize;

    jetErr = JetSetSystemParameter(&instance, 0,
        JET_paramCacheSizeMax, newCacheSize, NULL);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("(3) JetSetSystemParameter: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    //
    //  Set Version Cache size
    //

    jetErr = JetGetSystemParameter(instance, 0,
        JET_paramMaxVerPages, &maxVerPages, NULL, 0);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("(2) JetGetSystemParameter: jetErr=%ld\n"), jetErr));
        TerminateEngine();
        return FALSE;
    }

    if (maxVerPages >= MIN_VER_PAGES) {
        DPRINTF((_T("JetGetSystemParameter(instance=%lu): MaxVerPages=%lu\n"),
            instance, maxVerPages));
    } else {
        maxVerPages = MIN_VER_PAGES;
        jetErr = JetSetSystemParameter(&instance, 0,
            JET_paramMaxVerPages, maxVerPages, NULL);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("(4) JetSetSystemParameter: jetErr=%ld\n"), jetErr));
            TerminateEngine();
            return FALSE;
        }
        DPRINTF((_T("JetSetSystemParameter(instance=%lu, MaxVerPages)=%lu\n"),
            instance, maxVerPages));
    }

    //
    //  Initialize Jet
    //

    jetErr = JetInit(&instance);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetInit: jetErr=%ld\n"), jetErr));

        //
        //  If we have a log mismatch, delete the log files
        //

        if (jetErr == JET_errDatabaseLogSetMismatch) {

            DeleteAllDatabaseFiles();
        }

        return FALSE;
    }

    jetInitialized = TRUE;
    DPRINTF((_T("JetInit: instance=%lu\n"), instance));

    return TRUE;
}

/*****************************************************************************/

BOOL SGDatabase::TerminateEngine()
{
    JET_ERR jetErr;
    BOOL  rc;

    ASSERT(jetInitialized);

    jetErr = JetTerm(instance);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetTerm: jetErr=%ld\n"), jetErr));
        rc = FALSE;
    } else {
        rc = TRUE;
        CleanupEngineFiles();
    }

    jetInitialized = FALSE;
    DPRINTF((_T("JetTerm\n")));
    return rc;
}

/*****************************************************************************/

void
SGDatabase::CleanupEngineFiles()
// Delete no longer needed jet files.
{
    WIN32_FIND_DATA findData;
    HANDLE fHandle;
    BOOL success;
    TFileName fName,
              delName;

    if (logDir) {

        delName.assign(logDir);
        delName.append(_T("\\"));
        delName.append(DATABASE_DELETE_RES_FILE_NAME);

        fHandle = FindFirstFile(delName.name, &findData);

        if (fHandle != INVALID_HANDLE_VALUE) {
            do {
                if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
                    success = GetParentName(delName.name, &fName);
                    ASSERT(success);      // internal error if failed

                    fName.append(_T("\\"));
                    fName.append(findData.cFileName);

                    if (!DeleteFile(fName.name)) {
                        DPRINTF((_T("SGDatabase: can't delete \"%s\", %d\n"), delName.name, GetLastError()));
                    } else {
                        DPRINTF((_T("Deleted \"%s\"\n"), fName.name));
                    }
                }
            } while (FindNextFile(fHandle, &findData));

            success = FindClose(fHandle);
            ASSERT(success);
        }
    }
}

void
SGDatabase::DeleteAllDatabaseFiles()
// Delete all jet database files
{
    WIN32_FIND_DATA findData;
    HANDLE fHandle;
    BOOL success;
    TFileName fName,
              delName;

    if (logDir) {

        delName.assign(logDir);
        delName.append(_T("\\"));
        delName.append(DATABASE_DELETE_LOG_FILE_NAME);

        fHandle = FindFirstFile(delName.name, &findData);

        if (fHandle != INVALID_HANDLE_VALUE) {
            do {
                if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
                    success = GetParentName(delName.name, &fName);
                    ASSERT(success);      // internal error if failed

                    fName.append(_T("\\"));
                    fName.append(findData.cFileName);

                    if (!DeleteFile(fName.name)) {
                        DPRINTF((_T("SGDatabase: can't delete \"%s\", %d\n"), delName.name, GetLastError()));
                    } else {
                        DPRINTF((_T("Deleted \"%s\"\n"), fName.name));
                    }
                }
            } while (FindNextFile(fHandle, &findData));

            success = FindClose(fHandle);
            ASSERT(success);
        }
    }
}




/*****************************************************************************/
/********************** SGDatabase class private methods *********************/
/*****************************************************************************/

BOOL SGDatabase::CreateTable(
    const CHAR   *tblName,
    DWORD         numColumns,
    ColumnSpec  **columnSpecs,
    JET_COLUMNID *columnIDs,
    JET_TABLEID  *tblID)
{
    JET_COLUMNDEF columnDef;

    JET_COLUMNID colIDcount;

    JET_ERR jetErr;

    ColumnSpec *columnSpec;

    DWORD i, j;

    ASSERT(sesID != ~0);
    ASSERT(dbID  != ~0);

    ASSERT(numColumns <= MAX_COLUMNS);

    jetErr = JetCreateTable(sesID, dbID, tblName,
        TABLE_PAGES, TABLE_DENSITY, tblID);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetCreateTable: jetErr=%ld\n"), jetErr));
        return FALSE;
    }
    DPRINTF((_T("JetCreateTable: tblID=%lu colIDs={"), *tblID));

    columnDef.cbStruct = sizeof(JET_COLUMNDEF);
    columnDef.wCountry = COUNTRY_CODE;
    columnDef.langid   = LANG_ID;
    columnDef.cp       = CODE_PAGE;
    columnDef.wCollate = COLLATE;
    colIDcount         = 1;

    for (i = 0; i < numColumns; i++) {
        columnSpec = columnSpecs[i];
        columnDef.columnid = colIDcount;
        columnDef.coltyp   = columnSpec->coltyp;
        columnDef.cbMax    = columnSpec->size;
        columnDef.grbit    = columnSpec->grbit;

        jetErr = JetAddColumn(sesID, *tblID, columnSpec->name,
            &columnDef, NULL, 0, &columnIDs[i]);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("\nJetAddColumn: jetErr=%ld\n"), jetErr));
            return FALSE;
        }

        DPRINTF((_T(" %lu"), columnIDs[i]));

        if (i+1 < numColumns && colIDcount == columnIDs[i]) {
            ColIDCollision:
            colIDcount++;
            for (j = 0; j < i; j++)
                if (colIDcount == columnIDs[j])
                    goto ColIDCollision;
        }
    }

    DPRINTF((_T(" }\n")));
    return TRUE;
}

/*****************************************************************************/

BOOL SGDatabase::CreateIndex(
    JET_TABLEID  tblID,
    const CHAR  *keyName,
    DWORD        numKeys,
    ColumnSpec **keyColumnSpecs)
{
    JET_ERR jetErr;
    HRESULT r;

    CHAR indexStr[MAX_PATH];

    ColumnSpec *keyColumnSpec;

    DWORD indexStrLen,
          i;

    ASSERT(sesID   != ~0);
    ASSERT(numKeys <= MAX_KEYS);

    indexStrLen = 0;

    for (i = 0; i < numKeys; i++) {
        keyColumnSpec = keyColumnSpecs[i];
        indexStr[indexStrLen++] = '+';

        r = StringCbCopyA( indexStr + indexStrLen, 
                           sizeof(indexStr),
                           keyColumnSpec->name);

        ASSERT(r == S_OK);

        indexStrLen += strlen(keyColumnSpec->name) + 1;
    }

    indexStr[indexStrLen++] = '\0';

    jetErr = JetCreateIndex(sesID, tblID, keyName, 0,
        indexStr, indexStrLen, TABLE_DENSITY);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetCreateIndex: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************/

BOOL SGDatabase::OpenTable(
    const CHAR   *tblName,
    DWORD         numColumns,
    ColumnSpec  **columnSpecs,
    JET_COLUMNID *columnIDs,
    JET_TABLEID  *tblID)
{
    JET_COLUMNDEF columnDef;

    JET_ERR jetErr;

    ColumnSpec *columnSpec;

    DWORD i;

    ASSERT(sesID != ~0);
    ASSERT(dbID  != ~0);

    ASSERT(numColumns <= MAX_COLUMNS);

    jetErr = JetOpenTable(sesID, dbID, tblName, NULL, 0, 0, tblID);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetOpenTable: jetErr=%ld\n"), jetErr));
        return FALSE;
    }
    DPRINTF((_T("JetOpenTable: tblID=%lu colIDs={"), *tblID));

    for (i = 0; i < numColumns; i++) {
        columnSpec = columnSpecs[i];
        jetErr = JetGetTableColumnInfo(sesID, *tblID, columnSpec->name,
            &columnDef, sizeof(JET_COLUMNDEF), JET_ColInfo);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("\nJetGetTableColumnInfo: jetErr=%ld\n"), jetErr));
            return FALSE;
        }
        columnIDs[i] = columnDef.columnid;
        DPRINTF((_T(" %lu"), columnIDs[i]));
    }

    DPRINTF((_T(" }\n")));
    return TRUE;
}

/*****************************************************************************/

BOOL SGDatabase::CloseTable(JET_TABLEID tblID)
{
    JET_ERR jetErr;

    ASSERT(sesID != ~0);
    ASSERT(tblID != ~0);

    jetErr = JetCloseTable(sesID, tblID);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetCloseTable: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************/

LONG SGDatabase::PositionCursor(
    JET_TABLEID  tblID,
    const CHAR  *keyName,
    const VOID  *entry,
    DWORD        numKeys,
    ColumnSpec **keyColumnSpecs) const
{
    JET_COLTYP coltyp;

    JET_ERR jetErr;

    ColumnSpec *keyColumnSpec;

    const BYTE *dataPtr[MAX_KEYS];

    DWORD cbData[MAX_KEYS],
          i;

    ASSERT(sesID   != ~0);
    ASSERT(numKeys <= MAX_KEYS);

    jetErr = JetSetCurrentIndex(sesID, tblID, keyName);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetSetCurrentIndex: jetErr=%ld\n"), jetErr));
        return -1;
    }

    for (i = 0; i < numKeys; i++) {
        keyColumnSpec = keyColumnSpecs[i];
        coltyp = keyColumnSpec->coltyp;
        dataPtr[i] = (const BYTE *)entry + keyColumnSpec->offset;

        if (coltyp == JET_coltypBinary) {
            dataPtr[i] = *(BYTE **)dataPtr[i];
            ASSERT(dataPtr[i] != NULL);
            cbData[i] = (_tcslen((const TCHAR *)dataPtr[i]) + 1) * sizeof(TCHAR);
        } else
            cbData[i] = keyColumnSpec->size;

        jetErr = JetMakeKey(sesID, tblID, dataPtr[i], cbData[i],
            i == 0 ? JET_bitNewKey : 0);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("JetMakeKey: jetErr=%ld\n"), jetErr));
            return -1;
        }
    }

    jetErr = JetSeek(sesID, tblID, JET_bitSeekEQ);
    if (jetErr != JET_errSuccess) {
        if (jetErr == JET_errRecordNotFound)
            return 0;
        DPRINTF((_T("JetSeek: jetErr=%ld\n"), jetErr));
        return -1;
    }

    for (i = 0; i < numKeys; i++) {
        jetErr = JetMakeKey(sesID, tblID, dataPtr[i], cbData[i],
            i == 0 ? JET_bitNewKey : 0);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("JetMakeKey: jetErr=%ld\n"), jetErr));
            return -1;
        }
    }

    jetErr = JetSetIndexRange(sesID, tblID,
        JET_bitRangeUpperLimit | JET_bitRangeInclusive);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetSetIndexRange: jetErr=%ld\n"), jetErr));
        return -1;
    }

    return 1;
}

/*****************************************************************************/

LONG SGDatabase::PositionCursorFirst(
    JET_TABLEID tblID,
    const CHAR *keyName) const
{
    JET_ERR jetErr;

    ASSERT(sesID != ~0);

    jetErr = JetSetCurrentIndex(sesID, tblID, keyName);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetSetCurrentIndex: jetErr=%ld\n"), jetErr));
        return -1;
    }

    jetErr = JetMove(sesID, tblID, JET_MoveFirst, 0);
    if (jetErr != JET_errSuccess) {
        if (jetErr == JET_errNoCurrentRecord)
            return 0;
        DPRINTF((_T("JetMove: jetErr=%ld\n"), jetErr));
        return -1;
    }

    return 1;
}

/*****************************************************************************/

LONG SGDatabase::PositionCursorNext(JET_TABLEID tblID) const
{
    JET_ERR jetErr;

    ASSERT(sesID != ~0);

    jetErr = JetMove(sesID, tblID, JET_MoveNext, 0);
    if (jetErr != JET_errSuccess) {
        if (jetErr == JET_errNoCurrentRecord)
            return 0;
        DPRINTF((_T("JetMove: jetErr=%ld\n"), jetErr));
        return -1;
    }

    return 1;
}

/*****************************************************************************/

LONG SGDatabase::PositionCursorLast(
    JET_TABLEID tblID,
    const CHAR *keyName) const
{
    JET_ERR jetErr;

    ASSERT(sesID != ~0);

    jetErr = JetSetCurrentIndex(sesID, tblID, keyName);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetSetCurrentIndex: jetErr=%ld\n"), jetErr));
        return -1;
    }

    jetErr = JetMove(sesID, tblID, JET_MoveLast, 0);
    if (jetErr != JET_errSuccess) {
        if (jetErr == JET_errNoCurrentRecord)
            return 0;
        DPRINTF((_T("JetMove: jetErr=%ld\n"), jetErr));
        return -1;
    }

    return 1;
}

/*****************************************************************************/

BOOL SGDatabase::PutData(
    JET_TABLEID         tblID,
    const VOID         *entry,
    DWORD               numColumns,
    ColumnSpec        **columnSpecs,
    const JET_COLUMNID *columnIDs)
{
    JET_COLTYP coltyp;

    JET_ERR jetErr;

    ColumnSpec *columnSpec;

    const BYTE *dataPtr;

    DWORD cbData,
          i;

    ASSERT(sesID != ~0);

    ASSERT(numColumns <= MAX_COLUMNS);

    jetErr = JetPrepareUpdate(sesID, tblID, JET_prepInsert);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetPrepareUpdate: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    for (i = 0; i < numColumns; i++) {
        columnSpec = columnSpecs[i];
        coltyp     = columnSpec->coltyp;

        if (columnSpec->grbit != JET_bitColumnAutoincrement) {
            dataPtr = (const BYTE *)entry + columnSpec->offset;
            if (coltyp == JET_coltypBinary
             || coltyp == JET_coltypLongBinary) {
                dataPtr = *(BYTE **)dataPtr;
                cbData  = dataPtr != NULL
                        ? (_tcslen((const TCHAR *)dataPtr) + 1) * sizeof(TCHAR)
                        : 0;
            } else
                cbData  = columnSpec->size;

// May want to convert to JetSetColumns

            jetErr = JetSetColumn(sesID, tblID, columnIDs[i],
                dataPtr, cbData, 0, NULL);
            if (jetErr != JET_errSuccess) {
                DPRINTF((_T("JetSetColumn: jetErr=%ld\n"), jetErr));
                return FALSE;
            }
        }
    }

    jetErr = JetUpdate(sesID, tblID, NULL, 0, NULL);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetUpdate: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************/

BOOL SGDatabase::RetrieveData(
    JET_TABLEID         tblID,
    VOID               *entry,
    DWORD               numColumns,
    ColumnSpec        **columnSpecs,
    const JET_COLUMNID *columnIDs,
    DWORD               includeMask) const
{
    JET_COLTYP coltyp;

    JET_ERR jetErr;

    ColumnSpec *columnSpec;

    BYTE *dataPtr;

    DWORD cbData,
          cbActual,
          i;

    BOOL varCol;

    ASSERT(sesID != ~0);

    ASSERT(numColumns <= MAX_COLUMNS);

// May want to convert to JetRetrieveColumns

    for (i = 0; i < numColumns; i++)
        if ((includeMask & (1U << i)) != 0) {
            columnSpec = columnSpecs[i];
            coltyp = columnSpec->coltyp;
            varCol = coltyp == JET_coltypBinary
                  || coltyp == JET_coltypLongBinary;

            dataPtr = (BYTE *)entry + columnSpec->offset;
            if (varCol)
                dataPtr = *(BYTE **)dataPtr;

            if (dataPtr != NULL) {
                jetErr = JetRetrieveColumn(sesID, tblID, columnIDs[i],
                    dataPtr, columnSpec->size, &cbActual, 0, NULL);

                if (jetErr == JET_errSuccess)
                    cbData = varCol
                           ? (_tcslen((TCHAR *)dataPtr) + 1) * sizeof(TCHAR)
                           : columnSpec->size;
                else if (varCol && jetErr == JET_wrnColumnNull) {
                    *(TCHAR *)dataPtr = _T('\0');
                    cbData = 0;
                } else {
                    DPRINTF((_T("JetRetrieveColumn: jetErr=%ld\n"), jetErr));
                    return FALSE;
                }

                if (cbActual != cbData) {
                    DPRINTF((_T("JetRetrieveColumn: cbActual=%lu!=%lu\n"),
                        cbActual, cbData));
                    return FALSE;
                }
            }
        }

    return TRUE;
}

/*****************************************************************************/

LONG SGDatabase::Delete(JET_TABLEID tblID)
{
    JET_ERR jetErr;

    LONG count,
         status;

    count = 0;

    ASSERT(sesID != ~0);

    while (TRUE) {
        jetErr = JetDelete(sesID, tblID);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("JetDelete: jetErr=%ld\n"), jetErr));
            return -1;
        }

        count++;

        status = PositionCursorNext(tblID);
        if (status <  0)
            return status;
        if (status == 0)
            return count;
    }
}

/*****************************************************************************/

LONG SGDatabase::Count(
    JET_TABLEID tblID,
    const CHAR *keyName) const
{
    JET_ERR jetErr;
    LONG    count,
            status;

    count = 0;

    status = PositionCursorFirst(tblID, keyName);

    if (status <  0)
        return status;
    if (status == 0)
        return 0;

    ASSERT(sesID != ~0);

    jetErr = JetIndexRecordCount(sesID, tblID, (ULONG *) &count, MAXLONG);

    if (jetErr != JET_errSuccess) {
        if (jetErr == JET_errNoCurrentRecord)
            return 0;
        DPRINTF((_T("JetIndexRecordCount: jetErr=%ld\n"), jetErr));
        return -1;
    }

    return count;
}

/*****************************************************************************/
/********************** SGDatabase class public methods **********************/
/*****************************************************************************/

SGDatabase::SGDatabase()
{
    fileName = NULL;

    sesID   =
    tableID =
    queueID =
    stackID =
    listID  = ~0U;
    dbID    = ~0U;

    numTableEntries =
    numQueueEntries =
    numStackEntries =
    numListEntries  = 0;

    numUncommittedTableEntries =
    numUncommittedQueueEntries =
    numUncommittedStackEntries =
    numUncommittedListEntries  = 0;

    inTransaction = FALSE;

    if (!jetInitialized)
        InitializeEngine();

    numInstances++;
}

/*****************************************************************************/

SGDatabase::~SGDatabase()
{
    Close();

    ASSERT(fileName == NULL);

    ASSERT(sesID   == ~0U);
    ASSERT(dbID    == ~0U);
    ASSERT(tableID == ~0U);
    ASSERT(queueID == ~0U);
    ASSERT(stackID == ~0U);
    ASSERT(listID  == ~0U);

    ASSERT(numTableEntries == 0);
    ASSERT(numQueueEntries == 0);
    ASSERT(numStackEntries == 0);
    ASSERT(numListEntries  == 0);

    ASSERT(numUncommittedTableEntries == 0);
    ASSERT(numUncommittedQueueEntries == 0);
    ASSERT(numUncommittedStackEntries == 0);
    ASSERT(numUncommittedListEntries  == 0);

    ASSERT(!inTransaction);

    if (--numInstances == 0 && jetInitialized) {
        TerminateEngine();
    }
}

/*****************************************************************************/

BOOL SGDatabase::Create(
    const TCHAR *dbName)
{
    CHAR szConnect[MAX_PATH];

    DWORD strSize1;

    JET_ERR jetErr;

    ASSERT(fileName == NULL);

    ASSERT(sesID   == ~0U);
    ASSERT(dbID    == ~0U);
    ASSERT(tableID == ~0U);
    ASSERT(queueID == ~0U);
    ASSERT(stackID == ~0U);
    ASSERT(listID  == ~0U);

    ASSERT(numTableEntries == 0);
    ASSERT(numQueueEntries == 0);
    ASSERT(numStackEntries == 0);
    ASSERT(numListEntries  == 0);

    ASSERT(numUncommittedTableEntries == 0);
    ASSERT(numUncommittedQueueEntries == 0);
    ASSERT(numUncommittedStackEntries == 0);
    ASSERT(numUncommittedListEntries  == 0);

    ASSERT(!inTransaction);

    if (!jetInitialized && !InitializeEngine())
        return FALSE;
    ASSERT(jetInitialized);

    jetErr = JetBeginSession(instance, &sesID, USERNAME, PASSWORD);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetBeginSession: jetErr=%ld\n"), jetErr));
        Close();
        return FALSE;
    }
    DPRINTF((_T("JetBeginSession: sesID=%lu\n"), sesID));

    ASSERT(fileName == NULL);
    strSize1 = _tcslen(dbName) + 1;
    fileName = new CHAR[strSize1];
    ASSERT(fileName != NULL);

    (void)StringCchPrintfA(fileName, strSize1, "%S", dbName);

    (void)StringCbPrintfA(szConnect, sizeof(szConnect),
        ";COUNTRY=%u;LANGID=0x%04x;CP=%u",
        COUNTRY_CODE, LANG_ID, CODE_PAGE);

    //
    //  Create the database
    //

    jetErr = JetCreateDatabase(sesID, fileName, szConnect, &dbID, 0);
    if (jetErr == JET_errSuccess) {
        DPRINTF((_T("JetCreateDatabase(\"%s\"): dbID=%lu\n"),dbName, dbID));
    } else {
        if (jetErr != JET_errDatabaseDuplicate) {
            DPRINTF((_T("JetCreateDatabase(\"%s\"): jetErr=%ld\n"),
                dbName, jetErr));
            Close();
            return FALSE;
        }

        if (!DeleteFile(dbName)) {
            DPRINTF((_T("JetCreateDatabase: \"%s\" already exists and can't be deleted: %lu\n"),
                dbName, GetLastError()));
            Close();
            return FALSE;
        }

        jetErr = JetCreateDatabase(sesID, fileName, szConnect, &dbID, 0);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("JetCreateDatabase: deleted old \"%s\"; jetErr=%ld\n"),
                dbName, jetErr));
            Close();
            return FALSE;
        }

        DPRINTF((_T("JetCreateDatabase: deleted old \"%s\"; new dbID=%lu\n"),
            dbName, dbID));
    }

    if (!CreateTable(TABLE_NAME, TABLE_NCOLS,
        tableColumnSpecs, tableColumnIDs, &tableID)) {
        Close();
        return FALSE;
    }

    if (!CreateIndex(tableID, TABLE_KEY_NAME_FILE_ID,
        TABLE_KEY_NCOLS_FILE_ID, tableKeyFileID)
     || !CreateIndex(tableID, TABLE_KEY_NAME_ATTR,
        TABLE_KEY_NCOLS_ATTR, tableKeyAttr)
     || !CreateIndex(tableID, TABLE_KEY_NAME_CSID,
        TABLE_KEY_NCOLS_CSID, tableKeyCSID)) {
        Close();
        return FALSE;
    }

    if (!CreateTable(QUEUE_NAME, QUEUE_NCOLS,
        queueColumnSpecs, queueColumnIDs, &queueID)) {
        Close();
        return FALSE;
    }

    if (!CreateIndex(queueID, QUEUE_KEY_NAME_READY_TIME,
        QUEUE_KEY_NCOLS_READY_TIME, queueKeyReadyTime)
     || !CreateIndex(queueID, QUEUE_KEY_NAME_FILE_ID,
        QUEUE_KEY_NCOLS_FILE_ID, queueKeyFileID)
     || !CreateIndex(queueID, QUEUE_KEY_NAME_ORDER,
        QUEUE_KEY_NCOLS_ORDER, queueKeyOrder)) {
        Close();
        return FALSE;
    }

    if (!CreateTable(STACK_NAME, STACK_NCOLS,
        stackColumnSpecs, stackColumnIDs, &stackID)) {
        Close();
        return FALSE;
    }

    if (!CreateIndex(stackID, STACK_KEY_NAME_FILE_ID,
        STACK_KEY_NCOLS_FILE_ID, stackKeyFileID)
     || !CreateIndex(stackID, STACK_KEY_NAME_ORDER,
        STACK_KEY_NCOLS_ORDER, stackKeyOrder)) {
        Close();
        return FALSE;
    }

    if (!CreateTable(LIST_NAME, LIST_NCOLS,
        listColumnSpecs, listColumnIDs, &listID)) {
        Close();
        return FALSE;
    }

    if (!CreateIndex(listID, LIST_KEY_NAME_NAME,
        LIST_KEY_NCOLS_NAME, listKeyName)) {
        Close();
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************/

BOOL SGDatabase::Open(
    const TCHAR *driveLetterName,
    const TCHAR *dbName, 
    BOOL is_log_drive)
{
    SGNativeStackEntry stackEntry;

    JET_ERR jetErr;

    DWORD strSize1;

    LONG status;

    ASSERT(sesID   == ~0U);
    ASSERT(dbID    == ~0U);
    ASSERT(tableID == ~0U);
    ASSERT(queueID == ~0U);
    ASSERT(stackID == ~0U);
    ASSERT(listID  == ~0U);

    ASSERT(numTableEntries == 0);
    ASSERT(numQueueEntries == 0);
    ASSERT(numStackEntries == 0);
    ASSERT(numListEntries  == 0);

    ASSERT(numUncommittedTableEntries == 0);
    ASSERT(numUncommittedQueueEntries == 0);
    ASSERT(numUncommittedStackEntries == 0);
    ASSERT(numUncommittedListEntries  == 0);

    ASSERT(!inTransaction);

    // If this isn't the log drive, delete any log files that may exist
    // from a previous run.  This is an abnormal condition that can arise
    // when the log drive is changing because of problems detected during
    // a previous startup.

    if (!is_log_drive) {
        WIN32_FIND_DATA findData;
        HANDLE fHandle;
        BOOL success;
        TFileName fName,
                  delName;

        delName.assign(logDir);
        delName.append(_T("\\"));
        delName.append(DATABASE_DELETE_LOG_FILE_NAME);

        fHandle = FindFirstFile(delName.name, &findData);

        if (fHandle != INVALID_HANDLE_VALUE) {
            do {
                if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
                    success = GetParentName(delName.name, &fName);
                    ASSERT(success);      // internal error if failed

                    fName.append(_T("\\"));
                    fName.append(findData.cFileName);

                    if (!DeleteFile(fName.name)) {
                        DPRINTF((_T("SGDatabase::Open: can't delete \"%s\", %d\n"), delName.name, GetLastError()));
                    }
                }
            } while (FindNextFile(fHandle, &findData));

            success = FindClose(fHandle);
            ASSERT(success);
            fHandle = NULL;
        }
    }

    if (!jetInitialized && !InitializeEngine()) {
        Close();
        return FALSE;
    }
    ASSERT(jetInitialized);

    jetErr = JetBeginSession(instance, &sesID, USERNAME, PASSWORD);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetBeginSession: jetErr=%ld\n"), jetErr));
        Close();
        return FALSE;
    }
    DPRINTF((_T("%s: JetBeginSession: sesID=%lu\n"), driveLetterName, sesID));

    ASSERT(fileName == NULL);
    strSize1 = _tcslen(dbName) + 1;
    fileName = new CHAR[strSize1];
    ASSERT(fileName != NULL);

    (void)StringCchPrintfA(fileName, strSize1, "%S", dbName);

    //
    //  Open the database
    //

    jetErr = JetAttachDatabase(sesID, fileName, 0);
    if (jetErr != JET_errSuccess && jetErr != JET_wrnDatabaseAttached) {
        if (jetErr == JET_errFileNotFound) {
            DPRINTF((_T("JetAttachDatabase: \"%s\" not found\n"), dbName));
        } else {
            DPRINTF((_T("JetAttachDatabase(\"%s\"): jetErr=%ld\n"),
                dbName, jetErr));
        }
        Close();
        return FALSE;
    }

    jetErr = JetOpenDatabase(sesID, fileName, NULL, &dbID, 0);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetOpenDatabase(\"%s\"): jetErr=%ld\n"), dbName, jetErr));
        Close();
        return FALSE;
    }
    DPRINTF((_T("%s: JetOpenDatabase(\"%s\"): dbID=%lu\n"), driveLetterName, dbName, dbID));

    if (!OpenTable(TABLE_NAME, TABLE_NCOLS, tableColumnSpecs,
        tableColumnIDs, &tableID)) {
        Close();
        return FALSE;
    }

    if (!OpenTable(QUEUE_NAME, QUEUE_NCOLS, queueColumnSpecs,
        queueColumnIDs, &queueID)) {
        Close();
        return FALSE;
    }

    if (!OpenTable(STACK_NAME, STACK_NCOLS, stackColumnSpecs,
        stackColumnIDs, &stackID)) {
        Close();
        return FALSE;
    }

    if (!OpenTable(LIST_NAME, LIST_NCOLS, listColumnSpecs,
        listColumnIDs, &listID)) {
        Close();
        return FALSE;
    }

    if ((numTableEntries = Count(tableID, TABLE_KEY_NAME_FILE_ID))    < 0
     || (numQueueEntries = Count(queueID, QUEUE_KEY_NAME_READY_TIME)) < 0
     || (numStackEntries = Count(stackID, STACK_KEY_NAME_FILE_ID))    < 0
     || (numListEntries  = Count(listID,  LIST_KEY_NAME_NAME))        < 0) {
        Close();
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************/

BOOL SGDatabase::Close()
{
    JET_ERR jetErr;
    int strLen;
    BOOL success = TRUE;

    if (inTransaction) {
        success = CommitTransaction();
        inTransaction = FALSE;
    }

    ASSERT(numUncommittedTableEntries == 0);
    ASSERT(numUncommittedQueueEntries == 0);
    ASSERT(numUncommittedStackEntries == 0);
    ASSERT(numUncommittedListEntries  == 0);

    if (tableID != ~0U) {
        if (!CloseTable(tableID))
            success = FALSE;
        tableID = ~0U;
    }

    if (queueID != ~0U) {
        if (!CloseTable(queueID))
            success = FALSE;
        queueID = ~0U;
    }

    if (stackID != ~0U) {
        if (!CloseTable(stackID))
            success = FALSE;
        stackID = ~0U;
    }

    if (listID != ~0U) {
        if (!CloseTable(listID))
            success = FALSE;
        listID = ~0U;
    }

    if (dbID != ~0U) {
        ASSERT(fileName != NULL);
        ASSERT(sesID    != ~0U);

        jetErr = JetCloseDatabase(sesID, dbID, 0);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("JetCloseDatabase: jetErr=%ld\n"), jetErr));
            success = FALSE;
        }

        jetErr = JetDetachDatabase(sesID, fileName);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("JetDetachDatabase: jetErr=%ld\n"), jetErr));
            success = FALSE;
        }

        dbID = ~0U;
    }

    if (sesID != ~0U) {
        jetErr = JetEndSession(sesID, 0);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("JetEndSession: jetErr=%ld\n"), jetErr));
            success = FALSE;
        }
        sesID = ~0U;
    }

    if (fileName != NULL) {
        delete[] fileName;
        fileName = NULL;
    }

    numTableEntries =
    numQueueEntries =
    numStackEntries =
    numListEntries  = 0;

    return success;
}

/*****************************************************************************/

BOOL SGDatabase::BeginTransaction()
{
    JET_ERR jetErr;

    ASSERT(!inTransaction);
    ASSERT(numUncommittedTableEntries == 0);
    ASSERT(numUncommittedQueueEntries == 0);
    ASSERT(numUncommittedStackEntries == 0);
    ASSERT(numUncommittedListEntries  == 0);

    if (sesID == ~0U)
        return -1;

    jetErr = JetBeginTransaction(sesID);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetBeginTransaction: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    inTransaction = TRUE;
    return TRUE;
}

/*****************************************************************************/

BOOL SGDatabase::CommitTransaction()
{
    JET_ERR jetErr;

    ASSERT(inTransaction);

    if (sesID == ~0U)
        return -1;

    jetErr = JetCommitTransaction(sesID, 0);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetCommitTransaction: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    numTableEntries += numUncommittedTableEntries;
    numQueueEntries += numUncommittedQueueEntries;
    numStackEntries += numUncommittedStackEntries;
    numListEntries  += numUncommittedListEntries;

    numUncommittedTableEntries = 0;
    numUncommittedQueueEntries = 0;
    numUncommittedStackEntries = 0;
    numUncommittedListEntries  = 0;

    inTransaction = FALSE;
    return TRUE;
}

/*****************************************************************************/

BOOL SGDatabase::AbortTransaction()
{
    JET_ERR jetErr;

    ASSERT(inTransaction);
    inTransaction = FALSE;

    if (sesID == ~0U)
        return -1;

    jetErr = JetRollback(sesID, 0);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetRollback: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    numUncommittedTableEntries = 0;
    numUncommittedQueueEntries = 0;
    numUncommittedStackEntries = 0;
    numUncommittedListEntries  = 0;

    return TRUE;
}

/******************************* Table methods *******************************/

LONG SGDatabase::TablePut(const SGNativeTableEntry *entry)
{
    BOOL alreadyInTransaction = inTransaction;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || tableID == ~0U)
        return -1;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    if (!PutData(tableID, entry, TABLE_NCOLS,
        tableColumnSpecs, tableColumnIDs)) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    numUncommittedTableEntries++;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return 1;
}

/*****************************************************************************/

LONG SGDatabase::TableGetFirstByFileID(SGNativeTableEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || tableID == ~0U)
        return -1;

    status = PositionCursor(tableID, TABLE_KEY_NAME_FILE_ID,
        entry, TABLE_KEY_NCOLS_FILE_ID, tableKeyFileID);
    if (status <= 0)
        return status;

    return RetrieveData(tableID, entry, TABLE_NCOLS, tableColumnSpecs,
        tableColumnIDs, TABLE_EXCLUDE_FILE_ID_MASK ) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::TableGetFirstByAttr(SGNativeTableEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || tableID == ~0U)
        return -1;

    status = PositionCursor(tableID, TABLE_KEY_NAME_ATTR,
        entry, TABLE_KEY_NCOLS_ATTR, tableKeyAttr);
    if (status <= 0)
        return status;

    return RetrieveData(tableID, entry, TABLE_NCOLS, tableColumnSpecs,
        tableColumnIDs, TABLE_EXCLUDE_ATTR_MASK) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::TableGetFirstByCSIndex(SGNativeTableEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || tableID == ~0U)
        return -1;

    status = PositionCursor(tableID, TABLE_KEY_NAME_CSID,
        entry, TABLE_KEY_NCOLS_CSID, tableKeyCSID);
    if (status <= 0)
        return status;

    return RetrieveData(tableID, entry, TABLE_NCOLS, tableColumnSpecs,
        tableColumnIDs, TABLE_EXCLUDE_CS_INDEX_MASK) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::TableGetNext(SGNativeTableEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || tableID == ~0U)
        return -1;

    status = PositionCursorNext(tableID);
    if (status <= 0)
        return status;

    return RetrieveData(tableID, entry, TABLE_NCOLS,
        tableColumnSpecs, tableColumnIDs, GET_ALL_MASK) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::TableDeleteByFileID(DWORDLONG fileID)
{
    SGNativeTableEntry entry;

    LONG status;

    BOOL alreadyInTransaction = inTransaction;

    if (sesID   == ~0U
     || dbID    == ~0U
     || tableID == ~0U)
        return -1;

    entry.fileID = fileID;
    status = PositionCursor(tableID, TABLE_KEY_NAME_FILE_ID,
        &entry, TABLE_KEY_NCOLS_FILE_ID, tableKeyFileID);
    if (status <= 0)
        return status;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    status = Delete(tableID);
    if (status < 0) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    numUncommittedTableEntries -= status;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return status;
}

/*****************************************************************************/

LONG SGDatabase::TableDeleteByCSIndex(const CSID *csIndex)
{
    SGNativeTableEntry entry;

    LONG status;

    BOOL alreadyInTransaction = inTransaction;

    ASSERT(csIndex != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || tableID == ~0U)
        return -1;

    entry.csIndex = *csIndex;
    status = PositionCursor(tableID, TABLE_KEY_NAME_CSID,
        &entry, TABLE_KEY_NCOLS_CSID, tableKeyCSID);
    if (status <= 0)
        return status;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    status = Delete(tableID);
    if (status < 0) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    numUncommittedTableEntries -= status;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return status;
}

/*****************************************************************************/

LONG SGDatabase::TableCount() const
{
    LONG numEntries;

    if (sesID   == ~0U
     || dbID    == ~0U
     || tableID == ~0U)
        return -1;

    numEntries = numTableEntries + numUncommittedTableEntries;

    ASSERT(numEntries >= 0);
    ASSERT(Count(tableID, TABLE_KEY_NAME_FILE_ID) == numEntries);

    return numEntries;
}

/******************************* Queue methods *******************************/

LONG SGDatabase::QueuePut(SGNativeQueueEntry *entry)
{
    BOOL alreadyInTransaction = inTransaction;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || queueID == ~0U)
        return -1;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    if (!PutData(queueID, entry, QUEUE_NCOLS,
        queueColumnSpecs, queueColumnIDs)) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    numUncommittedQueueEntries++;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return 1;
}

/*****************************************************************************/

LONG SGDatabase::QueueGetFirst(SGNativeQueueEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || queueID == ~0U)
        return -1;

    status = PositionCursorFirst(queueID, QUEUE_KEY_NAME_READY_TIME);
    if (status <= 0)
        return status;

    return RetrieveData(queueID, entry, QUEUE_NCOLS,
        queueColumnSpecs, queueColumnIDs, GET_ALL_MASK) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::QueueGetFirstByFileID(SGNativeQueueEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || queueID == ~0U)
        return -1;

    status = PositionCursor(queueID, QUEUE_KEY_NAME_FILE_ID,
        entry, QUEUE_KEY_NCOLS_FILE_ID, queueKeyFileID);
    if (status <= 0)
        return status;

    return RetrieveData(queueID, entry, QUEUE_NCOLS, queueColumnSpecs,
        queueColumnIDs, QUEUE_EXCLUDE_FILE_ID_MASK) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::QueueGetNext(SGNativeQueueEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || queueID == ~0U)
        return -1;

    status = PositionCursorNext(queueID);
    if (status <= 0)
        return status;

    return RetrieveData(queueID, entry, QUEUE_NCOLS,
        queueColumnSpecs, queueColumnIDs, GET_ALL_MASK) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::QueueDelete(DWORD order)
{
    SGNativeQueueEntry entry;

    LONG status;

    BOOL alreadyInTransaction = inTransaction;

    ASSERT(sesID   != ~0U);
    ASSERT(dbID    != ~0U);
    ASSERT(queueID != ~0U);

    entry.order = order;
    status = PositionCursor(queueID, QUEUE_KEY_NAME_ORDER,
        &entry, QUEUE_KEY_NCOLS_ORDER, queueKeyOrder);
    if (status <= 0)
        return status;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    status = Delete(queueID);
    ASSERT(status <= 1);
    if (status < 0) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    numUncommittedQueueEntries -= status;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return status;
}

/*****************************************************************************/

LONG SGDatabase::QueueDeleteByFileID(DWORDLONG fileID)
{
    SGNativeQueueEntry entry;

    LONG status;

    BOOL alreadyInTransaction = inTransaction;

    if (sesID   == ~0U
     || dbID    == ~0U
     || queueID == ~0U)
        return -1;

    entry.fileID = fileID;
    status = PositionCursor(queueID, QUEUE_KEY_NAME_FILE_ID,
        &entry, QUEUE_KEY_NCOLS_FILE_ID, queueKeyFileID);
    if (status <= 0)
        return status;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    status = Delete(queueID);
    if (status < 0) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    numUncommittedQueueEntries -= status;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return status;
}

/*****************************************************************************/

LONG SGDatabase::QueueCount() const
{
    LONG numEntries;

    if (sesID   == ~0U
     || dbID    == ~0U
     || queueID == ~0U)
        return -1;

    numEntries = numQueueEntries + numUncommittedQueueEntries;

    ASSERT(numEntries >= 0);

    //
    //  This appears to be a bogus assert.  I don't believe there is proper
    //  syncronziation on this test because if I do a GO the system resyncs
    //  the count properly and continues on.
    //  Nealch (4/9/02)
    //

    //ASSERT(Count(queueID, QUEUE_KEY_NAME_READY_TIME) == numEntries);

    return numEntries;
}

/******************************* Stack methods *******************************/

LONG SGDatabase::StackPut(DWORDLONG fileID, BOOL done)
{
    SGNativeStackEntry entry;

    LONG status;

    BOOL alreadyInTransaction = inTransaction;

    if (sesID   == ~0U
     || dbID    == ~0U
     || stackID == ~0U)
        return -1;

    if (done)
        entry.order = 0;
    else {
        status = PositionCursorLast(stackID, STACK_KEY_NAME_ORDER);
        if (status < 0)
            return -1;
        if (status == 0)
            entry.order = 1;
        else {
            if (!RetrieveData(stackID, &entry, STACK_NCOLS,
                stackColumnSpecs, stackColumnIDs, STACK_GET_ORDER_ONLY_MASK))
                return -1;
            entry.order++;
        }
    }

    entry.fileID = fileID;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    if (!PutData(stackID, &entry, STACK_NCOLS,
        stackColumnSpecs, stackColumnIDs)) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    numUncommittedStackEntries++;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return 1;
}

/*****************************************************************************/

LONG SGDatabase::StackGetTop(SGNativeStackEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || stackID == ~0U)
        return -1;

    status = PositionCursorLast(stackID, STACK_KEY_NAME_ORDER);
    if (status <= 0)
        return status;

    status = RetrieveData(stackID, entry, STACK_NCOLS,
        stackColumnSpecs, stackColumnIDs, GET_ALL_MASK);
    if (status < 0)
        return status;
    ASSERT(status == 1);

    return entry->order == 0 ? 0 : 1;
}

/*****************************************************************************/

LONG SGDatabase::StackGetFirstByFileID(SGNativeStackEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || stackID == ~0U)
        return -1;

    status = PositionCursor(stackID, STACK_KEY_NAME_FILE_ID,
        entry, STACK_KEY_NCOLS_FILE_ID, stackKeyFileID);
    if (status <= 0)
        return status;

    return RetrieveData(stackID, entry, STACK_NCOLS, stackColumnSpecs,
        stackColumnIDs, STACK_EXCLUDE_FILE_ID_MASK) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::StackGetNext(SGNativeStackEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || stackID == ~0U)
        return -1;

    status = PositionCursorNext(stackID);
    if (status <= 0)
        return status;

    return RetrieveData(stackID, entry, STACK_NCOLS,
        stackColumnSpecs, stackColumnIDs, GET_ALL_MASK) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::StackDelete(DWORD order)
{
    SGNativeStackEntry entry;

    LONG status;

    BOOL alreadyInTransaction = inTransaction;

    if (sesID   == ~0U
     || dbID    == ~0U
     || stackID == ~0U)
        return -1;

    entry.order = order;
    status = PositionCursor(stackID, STACK_KEY_NAME_ORDER,
        &entry, STACK_KEY_NCOLS_ORDER, stackKeyOrder);
    if (status <= 0)
        return status;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    status = Delete(stackID);
    ASSERT(order == 0 || status <= 1);
    if (status < 0) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    numUncommittedStackEntries -= status;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return status;
}

/*****************************************************************************/

LONG SGDatabase::StackDeleteByFileID(DWORDLONG fileID)
{
    SGNativeStackEntry entry;

    LONG status;

    BOOL alreadyInTransaction = inTransaction;

    if (sesID   == ~0U
     || dbID    == ~0U
     || stackID == ~0U)
        return -1;

    entry.fileID = fileID;
    status = PositionCursor(stackID, STACK_KEY_NAME_FILE_ID,
        &entry, STACK_KEY_NCOLS_FILE_ID, stackKeyFileID);
    if (status <= 0)
        return status;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    status = Delete(stackID);
    if (status < 0) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    numUncommittedStackEntries -= status;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return status;
}

/*****************************************************************************/

LONG SGDatabase::StackCount() const
{
    LONG numEntries;

    if (sesID   == ~0U
     || dbID    == ~0U
     || stackID == ~0U)
        return -1;

    numEntries = numStackEntries + numUncommittedStackEntries;

    ASSERT(numEntries >= 0);
    ASSERT(Count(stackID, STACK_KEY_NAME_ORDER) == numEntries);

    return numEntries;
}

/******************************* List methods ********************************/

LONG SGDatabase::ListWrite(const SGNativeListEntry *entry)
{
    LONG status;

    BOOL alreadyInTransaction = inTransaction;

    ASSERT(entry       != NULL);
    ASSERT(entry->name != NULL);

    if (sesID  == ~0U
     || dbID   == ~0U
     || listID == ~0U)
        return -1;

// May want to overwrite the entry directly instead of deleting and inserting

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    status = ListDelete(entry->name);
    ASSERT(status <= 1);
    if (status < 0
     || !PutData(listID, entry, LIST_NCOLS,
            listColumnSpecs, listColumnIDs)) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    if (status == 0)
        numUncommittedListEntries++;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return 1;
}

/*****************************************************************************/

LONG SGDatabase::ListRead(SGNativeListEntry *entry) const
{
    LONG status;

    ASSERT(entry       != NULL);
    ASSERT(entry->name != NULL);

    if (sesID  == ~0U
     || dbID   == ~0U
     || listID == ~0U)
        return -1;

    status = PositionCursor(listID, LIST_KEY_NAME_NAME,
        entry, LIST_KEY_NCOLS_NAME, listKeyName);
    if (status <= 0)
        return status;

    return RetrieveData(listID, entry, LIST_NCOLS, listColumnSpecs,
        listColumnIDs, LIST_EXCLUDE_NAME_MASK) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::ListDelete(const TCHAR *name)
{
    SGNativeListEntry entry;

    LONG status;

    BOOL alreadyInTransaction = inTransaction;

    ASSERT(name != NULL);

    if (sesID  == ~0U
     || dbID   == ~0U
     || listID == ~0U)
        return -1;

    entry.name  = name;
    entry.value = NULL;

    status = PositionCursor(listID, LIST_KEY_NAME_NAME,
        &entry, LIST_KEY_NCOLS_NAME, listKeyName);
    if (status <= 0)
        return status;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    status = Delete(listID);
    if (status < 0) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    return status;
}

/*****************************************************************************/

LONG SGDatabase::ListCount() const
{
    LONG numEntries;

    if (sesID  == ~0U
     || dbID   == ~0U
     || listID == ~0U)
        return -1;

    numEntries = numListEntries + numUncommittedListEntries;

    ASSERT(numEntries >= 0);
    ASSERT(Count(listID, LIST_KEY_NAME_NAME) == numEntries);

    return numEntries;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\debug.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    debug.cpp

Abstract:

    SIS Groveler debug print file

Authors:

    John Douceur,    1998
    Cedric Krumbein, 1998

Environment:

    User Mode

Revision History:

--*/

#include "all.hxx"

#if DBG

VOID __cdecl PrintDebugMsg(
    TCHAR *format,
    ...)
{
    TCHAR debugStr[1024];
    va_list ap;
    HRESULT r;

    va_start(ap, format);

    r = StringCbVPrintf(debugStr, sizeof(debugStr), format, ap);
    ASSERT(r == S_OK);

    OutputDebugString(debugStr);
    va_end(ap);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\database.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	database.h

Abstract:

	SIS Groveler Jet-Blue database include file

Authors:

	Cedric Krumbein, 1998

Environment:

	User Mode


Revision History:

--*/

#define USERNAME ""
#define PASSWORD ""

#define TABLE_PAGES    50
#define TABLE_DENSITY  50
#define MIN_VER_PAGES 128
#define	MAX_DATABASE_CACHE_SIZE (6*1024*1024)

#define COUNTRY_CODE      1
#define LANG_ID      0x0409
#define CODE_PAGE      1252
#define COLLATE           0

#define MAX_KEYS            3
#define MAX_COLUMNS         8
#define MAX_LIST_NAME_LEN 255

#define GET_ALL_MASK (~0U)

typedef struct {
	CHAR      *name;
	DWORD      size;
	DWORD      offset;
	JET_COLTYP coltyp;
	JET_GRBIT  grbit;
} ColumnSpec;

/***************************** Table parameters ******************************/

#define TABLE_NAME "SGTable"

typedef DWORDLONG Signature;
typedef GUID      CSID;

typedef struct _SGNativeTableEntry {
	DWORDLONG fileID;
	DWORDLONG fileSize;
	Signature signature;
	DWORD     attributes;
	CSID      csIndex;
	DWORDLONG createTime;
	DWORDLONG writeTime;
} SGNativeTableEntry;

#define TABLE_COL_NUM_FILE_ID 0
#define TABLE_COL_NUM_SIZE    1
#define TABLE_COL_NUM_SIG     2
#define TABLE_COL_NUM_ATTR    3
#define TABLE_COL_NUM_CSIDLO  4
#define TABLE_COL_NUM_CSIDHI  5
#define TABLE_COL_NUM_CR_TIME 6
#define TABLE_COL_NUM_WR_TIME 7
#define TABLE_NCOLS           8

#define TABLE_COL_NAME_FILE_ID "FileID"
#define TABLE_COL_NAME_SIZE    "FileSize"
#define TABLE_COL_NAME_SIG     "Signature"
#define TABLE_COL_NAME_ATTR    "Attributes"
#define TABLE_COL_NAME_CSIDLO  "CSIndexLo"
#define TABLE_COL_NAME_CSIDHI  "CSIndexHi"
#define TABLE_COL_NAME_CR_TIME "CreateTime"
#define TABLE_COL_NAME_WR_TIME "WriteTime"

#define TABLE_KEY_NAME_FILE_ID "FileIDKey"
#define TABLE_KEY_NAME_ATTR    "AttributeKey"
#define TABLE_KEY_NAME_CSID    "CSIndexKey"

#define TABLE_KEY_NCOLS_FILE_ID 1
#define TABLE_KEY_NCOLS_ATTR    3
#define TABLE_KEY_NCOLS_CSID    2

#define TABLE_EXCLUDE_FILE_ID_MASK \
	(~(1U << TABLE_COL_NUM_FILE_ID))

#define TABLE_EXCLUDE_ATTR_MASK \
	(~(1U << TABLE_COL_NUM_SIZE \
	 | 1U << TABLE_COL_NUM_SIG  \
	 | 1U << TABLE_COL_NUM_ATTR))

#define TABLE_EXCLUDE_CS_INDEX_MASK \
	(~(1U << TABLE_COL_NUM_CSIDLO  \
	 | 1U << TABLE_COL_NUM_CSIDHI))

static ColumnSpec
	tableColDefFileID = {
		TABLE_COL_NAME_FILE_ID,
		sizeof(DWORDLONG),
		offsetof(SGNativeTableEntry, fileID),
		JET_coltypCurrency,
		0
	},
	tableColDefSize = {
		TABLE_COL_NAME_SIZE,
		sizeof(DWORDLONG),
		offsetof(SGNativeTableEntry, fileSize),
		JET_coltypCurrency,
		0
	},
	tableColDefSig = {
		TABLE_COL_NAME_SIG,
		sizeof(Signature),
		offsetof(SGNativeTableEntry, signature),
		JET_coltypCurrency,
		0
	},
	tableColDefAttr = {
		TABLE_COL_NAME_ATTR,
		sizeof(DWORD),
		offsetof(SGNativeTableEntry, attributes),
		JET_coltypLong,
		0
	},
	tableColDefCSIDlo = {
		TABLE_COL_NAME_CSIDLO,
		sizeof(DWORDLONG),
		offsetof(SGNativeTableEntry, csIndex),
		JET_coltypCurrency,
		0
	},
	tableColDefCSIDhi = {
		TABLE_COL_NAME_CSIDHI,
		sizeof(DWORDLONG),
		offsetof(SGNativeTableEntry, csIndex) + sizeof(DWORDLONG),
		JET_coltypCurrency,
		0
	},
	tableColDefCrTime = {
		TABLE_COL_NAME_CR_TIME,
		sizeof(DWORDLONG),
		offsetof(SGNativeTableEntry, createTime),
		JET_coltypCurrency,
		0
	},
	tableColDefWrTime = {
		TABLE_COL_NAME_WR_TIME,
		sizeof(DWORDLONG),
		offsetof(SGNativeTableEntry, writeTime),
		JET_coltypCurrency,
		0
	},
	*tableColumnSpecs[TABLE_NCOLS] = {
		&tableColDefFileID,
		&tableColDefSize,
		&tableColDefSig,
		&tableColDefAttr,
		&tableColDefCSIDlo,
		&tableColDefCSIDhi,
		&tableColDefCrTime,
		&tableColDefWrTime
	},
	*tableKeyFileID[TABLE_KEY_NCOLS_FILE_ID] = {
		&tableColDefFileID
	},
	*tableKeyAttr[TABLE_KEY_NCOLS_ATTR] = {
		&tableColDefSize,
		&tableColDefSig,
		&tableColDefAttr,
	},
	*tableKeyCSID[TABLE_KEY_NCOLS_CSID] = {
		&tableColDefCSIDlo,
		&tableColDefCSIDhi,
	};

/***************************** Queue parameters ******************************/

#define QUEUE_NAME "SGQueue"

typedef struct _SGNativeQueueEntry {
	DWORDLONG fileID;
	DWORDLONG parentID;
	DWORD     reason;
	DWORD     order;
	DWORDLONG readyTime;
	DWORDLONG retryTime;
	TCHAR    *fileName;
} SGNativeQueueEntry;

#define QUEUE_COL_NUM_FILE_ID    0
#define QUEUE_COL_NUM_PARENT_ID  1
#define QUEUE_COL_NUM_REASON     2
#define QUEUE_COL_NUM_ORDER      3
#define QUEUE_COL_NUM_READY_TIME 4
#define QUEUE_COL_NUM_RETRY_TIME 5
#define QUEUE_COL_NUM_NAME       6
#define QUEUE_NCOLS              7

#define QUEUE_COL_NAME_FILE_ID    "FileID"
#define QUEUE_COL_NAME_PARENT_ID  "ParentID"
#define QUEUE_COL_NAME_REASON     "Reason"
#define QUEUE_COL_NAME_ORDER      "Order"
#define QUEUE_COL_NAME_READY_TIME "ReadyTime"
#define QUEUE_COL_NAME_RETRY_TIME "RetryTime"
#define QUEUE_COL_NAME_NAME       "FileName"

#define QUEUE_KEY_NAME_READY_TIME "ReadyTimeKey"
#define QUEUE_KEY_NAME_FILE_ID    "FileIDKey"
#define QUEUE_KEY_NAME_ORDER      "Order"

#define QUEUE_KEY_NCOLS_READY_TIME 1
#define QUEUE_KEY_NCOLS_FILE_ID    1
#define QUEUE_KEY_NCOLS_ORDER      1

#define QUEUE_EXCLUDE_FILE_ID_MASK \
	(~(1U << QUEUE_COL_NUM_FILE_ID))

static ColumnSpec
	queueColDefFileID = {
		QUEUE_COL_NAME_FILE_ID,
		sizeof(DWORDLONG),
		offsetof(SGNativeQueueEntry, fileID),
		JET_coltypCurrency,
		0
	},
	queueColDefParentID = {
		QUEUE_COL_NAME_PARENT_ID,
		sizeof(DWORDLONG),
		offsetof(SGNativeQueueEntry, parentID),
		JET_coltypCurrency,
		0
	},
	queueColDefReason = {
		QUEUE_COL_NAME_REASON,
		sizeof(DWORD),
		offsetof(SGNativeQueueEntry, reason),
		JET_coltypLong,
		0
	},
	queueColDefOrder = {
		QUEUE_COL_NAME_ORDER,
		sizeof(DWORD),
		offsetof(SGNativeQueueEntry, order),
		JET_coltypLong,
		JET_bitColumnAutoincrement
	},
	queueColDefReadyTime = {
		QUEUE_COL_NAME_READY_TIME,
		sizeof(DWORDLONG),
		offsetof(SGNativeQueueEntry, readyTime),
		JET_coltypCurrency,
		0
	},
	queueColDefRetryTime = {
		QUEUE_COL_NAME_RETRY_TIME,
		sizeof(DWORDLONG),
		offsetof(SGNativeQueueEntry, retryTime),
		JET_coltypCurrency,
		0
	},
	queueColDefName = {
		QUEUE_COL_NAME_NAME,
		MAX_PATH * sizeof(TCHAR),
		offsetof(SGNativeQueueEntry, fileName),
		JET_coltypLongBinary,
		0
	},
	*queueColumnSpecs[QUEUE_NCOLS] = {
		&queueColDefFileID,
		&queueColDefParentID,
		&queueColDefReason,
		&queueColDefOrder,
		&queueColDefReadyTime,
		&queueColDefRetryTime,
		&queueColDefName
	},
	*queueKeyReadyTime[QUEUE_KEY_NCOLS_READY_TIME] = {
		&queueColDefReadyTime
	},
	*queueKeyFileID[QUEUE_KEY_NCOLS_FILE_ID] = {
		&queueColDefFileID
	},
	*queueKeyOrder[QUEUE_KEY_NCOLS_ORDER] = {
		&queueColDefOrder
	};

/***************************** Stack parameters ******************************/

#define STACK_NAME "SGStack"

typedef struct _SGNativeStackEntry {
	DWORDLONG fileID;
	DWORD     order;
} SGNativeStackEntry;

#define STACK_COL_NUM_FILE_ID 0
#define STACK_COL_NUM_ORDER   1
#define STACK_NCOLS           2

#define STACK_COL_NAME_FILE_ID "FileID"
#define STACK_COL_NAME_ORDER   "Order"

#define STACK_KEY_NAME_FILE_ID "FileIDKey"
#define STACK_KEY_NAME_ORDER   "Order"

#define STACK_KEY_NCOLS_FILE_ID 1
#define STACK_KEY_NCOLS_ORDER   1

#define STACK_EXCLUDE_FILE_ID_MASK \
	(~(1U << STACK_COL_NUM_FILE_ID))

#define STACK_GET_ORDER_ONLY_MASK \
	  (1U << STACK_COL_NUM_ORDER)

static ColumnSpec
	stackColDefFileID = {
		STACK_COL_NAME_FILE_ID,
		sizeof(DWORDLONG),
		offsetof(SGNativeStackEntry, fileID),
		JET_coltypCurrency,
		0
	},
	stackColDefOrder = {
		STACK_COL_NAME_ORDER,
		sizeof(DWORD),
		offsetof(SGNativeStackEntry, order),
		JET_coltypLong,
		0
	},
	*stackColumnSpecs[STACK_NCOLS] = {
		&stackColDefFileID,
		&stackColDefOrder
	},
	*stackKeyFileID[STACK_KEY_NCOLS_FILE_ID] = {
		&stackColDefFileID
	},
	*stackKeyOrder[STACK_KEY_NCOLS_ORDER] = {
		&stackColDefOrder
	};

/****************************** List parameters ******************************/

#define LIST_NAME "SGList"

typedef struct _SGNativeListEntry {
	const TCHAR *name;
	TCHAR       *value;
} SGNativeListEntry;

#define LIST_COL_NUM_NAME  0
#define LIST_COL_NUM_VALUE 1
#define LIST_NCOLS         2

#define LIST_COL_NAME_NAME  "Name"
#define LIST_COL_NAME_VALUE "Value"

#define LIST_KEY_NAME_NAME "NameKey"

#define LIST_KEY_NCOLS_NAME 1

#define LIST_EXCLUDE_NAME_MASK \
	(~(1U << LIST_COL_NUM_NAME))

static ColumnSpec
	listColDefName = {
		LIST_COL_NAME_NAME,
		MAX_LIST_NAME_LEN,
		offsetof(SGNativeListEntry, name),
		JET_coltypBinary,
		0
	},
	listColDefValue = {
		LIST_COL_NAME_VALUE,
		MAX_PATH * sizeof(TCHAR),
		offsetof(SGNativeListEntry, value),
		JET_coltypLongBinary,
		0
	},
	*listColumnSpecs[LIST_NCOLS] = {
		&listColDefName,
		&listColDefValue,
	},
	*listKeyName[LIST_KEY_NCOLS_NAME] = {
		&listColDefName
	};

/************************ SGDatabase class declaration ***********************/

class SGDatabase {

private:

	static DWORD numInstances;

	static JET_INSTANCE instance;

	static BOOL jetInitialized;

    static TCHAR *logDir;

	CHAR *fileName;         // fully qualified database file name

	JET_SESID sesID;

	JET_DBID dbID;

	JET_TABLEID tableID,
	            queueID,
	            stackID,
	             listID;

	JET_COLUMNID tableColumnIDs[TABLE_NCOLS],
	             queueColumnIDs[QUEUE_NCOLS],
	             stackColumnIDs[STACK_NCOLS],
	              listColumnIDs[ LIST_NCOLS];

	LONG numTableEntries,
	     numQueueEntries,
	     numStackEntries,
	     numListEntries,
	     numUncommittedTableEntries,
	     numUncommittedQueueEntries,
	     numUncommittedStackEntries,
	     numUncommittedListEntries;

	BOOL inTransaction;

// Static methods

	static BOOL InitializeEngine();

	static BOOL TerminateEngine();

    static void CleanupEngineFiles();
    static void DeleteAllDatabaseFiles();

// Table / queue / stack / list methods

	BOOL CreateTable(
		const CHAR   *tblName,
		DWORD         numColumns,
		ColumnSpec  **columnSpecs,
		JET_COLUMNID *columnIDs,
		JET_TABLEID  *tblID);

	BOOL CreateIndex(
		JET_TABLEID  tblID,
		const CHAR  *keyName,
		DWORD        numKeys,
		ColumnSpec **keyColumnSpecs);

	BOOL OpenTable(
		const CHAR   *tblName,
		DWORD         numColumns,
		ColumnSpec  **columnSpecs,
		JET_COLUMNID *columnIDs,
		JET_TABLEID  *tblID);

	BOOL CloseTable(JET_TABLEID tblID);

	LONG PositionCursor(
		JET_TABLEID  tblID,
		const CHAR  *keyName,
		const VOID  *entry,
		DWORD        numKeys,
		ColumnSpec **keyColumnSpecs) const;

	LONG PositionCursorFirst(
		JET_TABLEID tblID,
		const CHAR *keyName) const;

	LONG PositionCursorNext(JET_TABLEID tblID) const;

	LONG PositionCursorLast(
		JET_TABLEID tblID,
		const CHAR *keyName) const;

	BOOL PutData(
		JET_TABLEID         tblID,
		const VOID         *entry,
		DWORD               numColumns,
		ColumnSpec        **columnSpecs,
		const JET_COLUMNID *columnIDs);

	BOOL SGDatabase::RetrieveData(
		JET_TABLEID         tblID,
		VOID               *entry,
		DWORD               numColumns,
		ColumnSpec        **columnSpecs,
		const JET_COLUMNID *columnIDs,
		DWORD               includeMask) const;

	LONG Delete(JET_TABLEID tblID);

	LONG Count(
		JET_TABLEID tblID,
		const CHAR *keyName) const;

public:

// General methods

	SGDatabase();

	~SGDatabase();

	BOOL Create(const TCHAR *dbName);

	BOOL Open(
            const TCHAR *drive_LetterName,
	        const TCHAR *dbName, 
	        BOOL is_log_drive);

	BOOL Close();

	BOOL BeginTransaction();

	BOOL CommitTransaction();

	BOOL AbortTransaction();

    static BOOL set_log_drive(const _TCHAR *drive_name);

// Table methods

	LONG TablePut(const SGNativeTableEntry *entry);

	LONG TableGetFirstByFileID(SGNativeTableEntry *entry) const;

	LONG TableGetFirstByAttr(SGNativeTableEntry *entry) const;

	LONG TableGetFirstByCSIndex(SGNativeTableEntry *entry) const;

	LONG TableGetNext(SGNativeTableEntry *entry) const;

	LONG TableDeleteByFileID(DWORDLONG fileID);

	LONG TableDeleteByCSIndex(const CSID *csIndex);

	LONG TableCount() const;

// Queue methods

	LONG QueuePut(SGNativeQueueEntry *entry);

	LONG QueueGetFirst(SGNativeQueueEntry *entry) const;

	LONG QueueGetFirstByFileID(SGNativeQueueEntry *entry) const;

	LONG QueueGetNext(SGNativeQueueEntry *entry) const;

	LONG QueueDelete(DWORD order);

	LONG QueueDeleteByFileID(DWORDLONG fileID);

	LONG QueueCount() const;

// Stack methods

	LONG StackPut(DWORDLONG fileID, BOOL done);

	LONG StackGetTop(SGNativeStackEntry *entry) const;

	LONG StackGetFirstByFileID(SGNativeStackEntry *entry) const;

	LONG StackGetNext(SGNativeStackEntry *entry) const;

	LONG StackDelete(DWORD order);

	LONG StackDeleteByFileID(DWORDLONG fileID);

	LONG StackCount() const;

// List methods

	LONG ListWrite(const SGNativeListEntry *entry);

	LONG ListRead(SGNativeListEntry *entry) const;

	LONG ListDelete(const TCHAR *name);

	LONG ListCount() const;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\diskinfo.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    diskinfo.h

Abstract:

	SIS Groveler disk information include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_DISKINFO

#define _INC_DISKINFO

struct ReadDiskInformation
{
	ReadDiskInformation(
		const _TCHAR *drive_name);

	int min_file_size;
	int min_file_age;
	bool enable_groveling;
	bool error_retry_log_extraction;
	bool error_retry_groveling;
	bool allow_compressed_files;
	bool allow_encrypted_files;
	bool allow_hidden_files;
	bool allow_offline_files;
	bool allow_temporary_files;
	__int64 base_usn_log_size;
	__int64 max_usn_log_size;

private:

	enum {registry_entry_count = 12};
};

struct WriteDiskInformation
{
	WriteDiskInformation(
		const _TCHAR *drive_name,
		int backup_interval);

	~WriteDiskInformation();
    void flush();

	double partition_hash_read_time_estimate;
	double partition_compare_read_time_estimate;
	double mean_file_size;
	double read_time_confidence;
	int volume_serial_number;
    int grovelAllPathsState;

private:

	enum {registry_entry_count = 6};

	static void backup(
		void *context);

	int backup_interval;
	EntrySpec registry_entries[registry_entry_count];
	_TCHAR *ini_file_partition_path;
};

#endif	/* _INC_DISKINFO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\decayacc.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    decayacc.h

Abstract:

	SIS Groveler decaying accumulator include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_DECAYACC

#define _INC_DECAYACC

class DecayingAccumulator
{
public:

	DecayingAccumulator(
		unsigned int time_constant);

	void increment(
		int increase = 1);

	double retrieve_value() const;

private:

	double time_constant;
	double decaying_accumulation;
	unsigned int update_time;
};

#endif	/* _INC_DECAYACC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\etimer.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    etimer.cpp

Abstract:

    SIS Groveler event timer

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

#define NEW_HeapSegment(segment_size) \
    ((HeapSegment *)(new BYTE[sizeof(HeapSegment) + \
    ((segment_size) - 1) * sizeof(Event)]))

#define DELETE_HeapSegment(heap_segment) delete[] ((BYTE *)(heap_segment))

EventTimer::EventTimer()
{
    ASSERT(this != 0);
    first_segment = NEW_HeapSegment(1);
    first_segment->previous = 0;
    first_segment->next = 0;
    last_segment = first_segment;
    population = 0;
    segment_size = 1;
    heap_ok = false;
}

EventTimer::~EventTimer()
{
    ASSERT(this != 0);
    ASSERT(first_segment != 0);
    ASSERT(last_segment != 0);
    ASSERT(population >= 0);
    ASSERT(segment_size > 0);
    ASSERT((segment_size & (segment_size - 1)) == 0);  // power of 2
    ASSERT(population >= segment_size - 1);
    ASSERT(!heap_ok || population >= segment_size);
    ASSERT(population < 2 * segment_size);
    ASSERT(first_segment != last_segment || segment_size == 1);
    ASSERT(first_segment == last_segment || segment_size > 1);
    while (first_segment != 0)
    {
        HeapSegment *next_segment = first_segment->next;
        ASSERT(first_segment != 0);
        DELETE_HeapSegment(first_segment);
        first_segment = next_segment;
    }
}

void
EventTimer::run()
{
    ASSERT(this != 0);
    running = true;
    while (running && population > 0)
    {
        ASSERT(first_segment != 0);
        ASSERT(last_segment != 0);
        ASSERT(population >= 0);
        ASSERT(segment_size > 0);
        ASSERT((segment_size & (segment_size - 1)) == 0);  // power of 2
        ASSERT(population >= segment_size - 1);
        ASSERT(!heap_ok || population >= segment_size);
        ASSERT(population < 2 * segment_size);
        ASSERT(first_segment != last_segment || segment_size == 1);
        ASSERT(first_segment == last_segment || segment_size > 1);
        if (!heap_ok)
        {
            int final_position = (population + 1) % segment_size;
            unsigned int final_time =
                last_segment->events[final_position].event_time;
            HeapSegment *segment = first_segment;
            HeapSegment *next_segment = segment->next;
            int position = 0;
            int next_position = 0;
            while (segment != last_segment
                && (next_segment != last_segment
                || next_position < final_position))
            {
                if ((next_segment != last_segment ||
                    next_position + 1 < final_position) &&
                    signed(next_segment->events[next_position].event_time -
                    next_segment->events[next_position + 1].event_time) > 0)
                {
                    next_position++;
                }
                if (signed(final_time -
                    next_segment->events[next_position].event_time) <= 0)
                {
                    break;
                }
                segment->events[position] = next_segment->events[next_position];
                segment = next_segment;
                next_segment = segment->next;
                position = next_position;
                next_position = 2 * position;
            }
            segment->events[position] = last_segment->events[final_position];
            if (population < segment_size)
            {
                segment_size /= 2;
                last_segment = last_segment->previous;
            }
            heap_ok = true;
        }
        ASSERT(first_segment != 0);
        ASSERT(last_segment != 0);
        ASSERT(population >= 0);
        ASSERT(segment_size > 0);
        ASSERT((segment_size & (segment_size - 1)) == 0);  // power of 2
        ASSERT(population >= segment_size - 1);
        ASSERT(!heap_ok || population >= segment_size);
        ASSERT(population < 2 * segment_size);
        ASSERT(first_segment != last_segment || segment_size == 1);
        ASSERT(first_segment == last_segment || segment_size > 1);
        unsigned int current_time = GET_TICK_COUNT();
        int sleep_time = __max(
            signed(first_segment->events[0].event_time - current_time), 0);
        do
        {
            bool event_triggered = sync_event.wait(sleep_time);
            if (event_triggered)
            {
                SERVICE_FOLLOW_COMMAND();
                if (!running)
                {
                    return;
                }
            }
            current_time = GET_TICK_COUNT();
            sleep_time = __max(
                signed(first_segment->events[0].event_time - current_time), 0);
        } while (sleep_time > 0);
        heap_ok = false;
        population--;
        (*first_segment->events[0].callback)(first_segment->events[0].context);
        bool ok = shared_data->send_values();
        if (!ok)
        {
            PRINT_DEBUG_MSG((_T("GROVELER: SharedData::send_values() failed\n")));
        }
    }
}

void
EventTimer::halt()
{
    ASSERT(this != 0);
    ASSERT(first_segment != 0);
    ASSERT(last_segment != 0);
    ASSERT(population >= 0);
    ASSERT(segment_size > 0);
    ASSERT((segment_size & (segment_size - 1)) == 0);  // power of 2
    ASSERT(population >= segment_size - 1);
    ASSERT(!heap_ok || population >= segment_size);
    ASSERT(population < 2 * segment_size);
    ASSERT(first_segment != last_segment || segment_size == 1);
    ASSERT(first_segment == last_segment || segment_size > 1);
    running = false;
}

void
EventTimer::schedule(
    unsigned int event_time,
    void *context,
    EventCallback callback)
{
    ASSERT(this != 0);
    ASSERT(first_segment != 0);
    ASSERT(last_segment != 0);
    ASSERT(population >= 0);
    ASSERT(segment_size > 0);
    ASSERT((segment_size & (segment_size - 1)) == 0);  // power of 2
    ASSERT(population >= segment_size - 1);
    ASSERT(!heap_ok || population >= segment_size);
    ASSERT(population < 2 * segment_size);
    ASSERT(first_segment != last_segment || segment_size == 1);
    ASSERT(first_segment == last_segment || segment_size > 1);
    population++;
    HeapSegment *segment;
    int position;
    if (heap_ok)
    {
        if (population >= 2 * segment_size)
        {
            segment_size *= 2;
            if (last_segment->next == 0)
            {
                last_segment->next = NEW_HeapSegment(segment_size);
                last_segment->next->previous = last_segment;
                last_segment->next->next = 0;
            }
            last_segment = last_segment->next;
        }
        segment = last_segment;
        HeapSegment *previous_segment = segment->previous;
        position = population % segment_size;
        int next_position = position >> 1;
        while (previous_segment != 0 && signed(event_time
            - previous_segment->events[next_position].event_time) < 0)
        {
            segment->events[position] = previous_segment->events[next_position];
            segment = previous_segment;
            previous_segment = segment->previous;
            position = next_position;
            next_position >>= 1;
        }
    }
    else
    {
        int final_position = population % segment_size + 1;
        segment = first_segment;
        HeapSegment *next_segment = segment->next;
        position = 0;
        int next_position = 0;
        while (segment != last_segment
            && (next_segment != last_segment
            || next_position < final_position))
        {
            if ((next_segment != last_segment ||
                next_position + 1 < final_position) &&
                signed(next_segment->events[next_position].event_time -
                next_segment->events[next_position + 1].event_time) > 0)
            {
                next_position++;
            }
            if (signed(event_time -
                next_segment->events[next_position].event_time) <= 0)
            {
                break;
            }
            segment->events[position] = next_segment->events[next_position];
            segment = next_segment;
            next_segment = segment->next;
            position = next_position;
            next_position = 2 * position;
        }
    }
    segment->events[position].event_time = event_time;
    segment->events[position].context = context;
    segment->events[position].callback = callback;
    heap_ok = true;
    ASSERT(first_segment != 0);
    ASSERT(last_segment != 0);
    ASSERT(population >= 0);
    ASSERT(segment_size > 0);
    ASSERT((segment_size & (segment_size - 1)) == 0);  // power of 2
    ASSERT(population >= segment_size);
    ASSERT(population < 2 * segment_size);
    ASSERT(first_segment != last_segment || segment_size == 1);
    ASSERT(first_segment == last_segment || segment_size > 1);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\debug.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    SIS Groveler debug print include file

Authors:

    John Douceur,    1998
    Cedric Krumbein, 1998

Environment:

    User Mode

Revision History:

--*/

#ifndef _INC_DEBUG

#define _INC_DEBUG

#undef ASSERT

#if DBG

VOID __cdecl PrintDebugMsg(
    TCHAR *format,
    ...);

#define PRINT_DEBUG_MSG(args) PrintDebugMsg ## args

#define ASSERT(cond) \
    ((!(cond)) ? \
        (PrintDebugMsg(_T("ASSERT FAILED (%s:%d) %s\n"), \
            _T(__FILE__), __LINE__, _T(#cond)), \
         DbgBreakPoint()) : \
        ((void)0))

#define ASSERT_ERROR(cond) \
    ((!(cond)) ? \
        (PrintDebugMsg(_T("ASSERT FAILED (%s:%d) %s: %lu\n"), \
            _T(__FILE__), __LINE__, _T(#cond), GetLastError()), \
         DbgBreakPoint()) : \
        ((void)0))

#define ASSERT_PRINTF(cond, args) \
    ((!(cond)) ? \
        (PrintDebugMsg(_T("ASSERT FAILED (%s:%d) %s "), \
            _T(__FILE__), __LINE__, _T(#cond)), \
         PrintDebugMsg ## args , \
         DbgBreakPoint()) : \
        ((void)0))

#else // DBG

#define PRINT_DEBUG_MSG(args)

#define ASSERT(cond) ((void)0)

#define ASSERT_ERROR(cond) ((void)0)

#define ASSERT_PRINTF(cond, args) ((void)0)

#endif

#endif  /* _INC_DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\diskinfo.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    diskinfo.cpp

Abstract:

    SIS Groveler disk information class

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

static const _TCHAR disks_ini_filename[] = L"grovel.ini";
static const _TCHAR disks_ini_section[] = L"Disk Info";

ReadDiskInformation::ReadDiskInformation(
    const _TCHAR *drive_name)
{
    ASSERT(this != 0);
    EntrySpec registry_entries[registry_entry_count] =
    {
        {_T("minimum merge file size"),     entry_int,      _T("32768"),    &min_file_size},
        {_T("minimum merge file age"),      entry_int,      _T("0"),        &min_file_age},
        {_T("enable groveling"),            entry_bool,     _T("1"),        &enable_groveling},
        {_T("error retry log extraction"),  entry_bool,     _T("1"),        &error_retry_log_extraction},
        {_T("error retry groveling"),       entry_bool,     _T("1"),        &error_retry_groveling},
        {_T("merge compressed files"),      entry_bool,     _T("1"),        &allow_compressed_files},
        {_T("merge encrypted files"),       entry_bool,     _T("0"),        &allow_encrypted_files},
        {_T("merge hidden files"),          entry_bool,     _T("1"),        &allow_hidden_files},
        {_T("merge offline files"),         entry_bool,     _T("0"),        &allow_offline_files},
        {_T("merge temporary files"),       entry_bool,     _T("0"),        &allow_temporary_files},
        {_T("base USN log size"),           entry_int64,    _T("1048576"),  &base_usn_log_size},
        {_T("max USN log size"),            entry_int64,    _T("16777216"), &max_usn_log_size}
    };

    int bLen = _tcslen(disks_ini_filename) + _tcslen(drive_name) + SIS_CSDIR_STRING_NCHARS + (sizeof(_TCHAR)*2);
    _TCHAR *ini_file_partition_path = new _TCHAR[bLen];

    (void)StringCchCopy(ini_file_partition_path, bLen, drive_name);
    TrimTrailingChar(ini_file_partition_path,L'\\');
    (void)StringCchCat(ini_file_partition_path, bLen, SIS_CSDIR_STRING);
    (void)StringCchCat(ini_file_partition_path, bLen, disks_ini_filename);

    IniFile::read(ini_file_partition_path, disks_ini_section,
        registry_entry_count, registry_entries);

#if WRITE_ALL_PARAMETERS

    bool ini_file_overwrite_ok =
        IniFile::overwrite(ini_file_partition_path, disks_ini_section,
        registry_entry_count, registry_entries);
    if (!ini_file_overwrite_ok)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: IniFile::overwrite() failed\n")));
    }

#endif // WRITE_ALL_PARAMETERS

    ASSERT(ini_file_partition_path != 0);
    delete[] ini_file_partition_path;
    ini_file_partition_path = 0;
}

WriteDiskInformation::WriteDiskInformation(
    const _TCHAR *drive_name,
    int backup_interval)
{
    ASSERT(this != 0);
    ASSERT(backup_interval >= 0);
    this->backup_interval = backup_interval;

    EntrySpec registry_entries[registry_entry_count] =
    {
        {_T("hash read time estimate"),     entry_double,   _T("0.0"),      &partition_hash_read_time_estimate},
        {_T("compare read time estimate"),  entry_double,   _T("0.0"),      &partition_compare_read_time_estimate},
        {_T("mean file size"),              entry_double,   _T("65536.0"),  &mean_file_size},
        {_T("read time confidence"),        entry_double,   _T("0.0"),      &read_time_confidence},
        {_T("volume serial number"),        entry_int,      _T("0"),        &volume_serial_number},
        {_T("GrovelAllPaths State"),        entry_int,      _T("1"),        &grovelAllPathsState}
    };

    for (int index = 0; index < registry_entry_count; index++)
    {
        this->registry_entries[index] = registry_entries[index];
    }

    int bLen = _tcslen(disks_ini_filename) + _tcslen(drive_name) + SIS_CSDIR_STRING_NCHARS + (sizeof(_TCHAR)*2);
    ini_file_partition_path = new _TCHAR[bLen];

    (void)StringCchCopy(ini_file_partition_path, bLen, drive_name);
    TrimTrailingChar(ini_file_partition_path,L'\\');
    (void)StringCchCat(ini_file_partition_path, bLen, SIS_CSDIR_STRING);
    (void)StringCchCat(ini_file_partition_path, bLen, disks_ini_filename);

    IniFile::read(ini_file_partition_path, disks_ini_section,
        registry_entry_count, registry_entries);

    if (backup_interval > 0)
    {
        backup((void *)this);
    }
}

WriteDiskInformation::~WriteDiskInformation()
{
    ASSERT(this != 0);
    ASSERT(backup_interval >= 0);
    ASSERT(ini_file_partition_path != 0);
    backup((void *)this);
    delete[] ini_file_partition_path;
    ini_file_partition_path = 0;
}

void
WriteDiskInformation::flush()
{
    bool ini_file_overwrite_ok =
        IniFile::overwrite(ini_file_partition_path, disks_ini_section,
        registry_entry_count, registry_entries);
    if (!ini_file_overwrite_ok)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: IniFile::overwrite() failed\n")));
    }
}


void
WriteDiskInformation::backup(
    void *context)
{
    ASSERT(context != 0);
    unsigned int invokation_time = GET_TICK_COUNT();
    WriteDiskInformation *me = (WriteDiskInformation *)context;
    ASSERT(me->backup_interval >= 0);
    ASSERT(me->ini_file_partition_path != 0);
    bool ini_file_overwrite_ok =
        IniFile::overwrite(me->ini_file_partition_path, disks_ini_section,
        registry_entry_count, me->registry_entries);
    if (!ini_file_overwrite_ok)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: IniFile::overwrite() failed\n")));
    }
    event_timer.schedule(invokation_time + me->backup_interval,
        context, backup);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\decayacc.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    decayacc.cpp

Abstract:

    SIS Groveler decaying accumulator

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/
#include "all.hxx"

DecayingAccumulator::DecayingAccumulator(
    unsigned int time_constant)
{
    ASSERT(this != 0);
    this->time_constant = double(time_constant);
    ASSERT(this->time_constant >= 0.0);
    decaying_accumulation = 0.0;
    update_time = GET_TICK_COUNT();
}

void
DecayingAccumulator::increment(
    int increase)
{
    ASSERT(this != 0);
    ASSERT(time_constant >= 0.0);
    ASSERT(decaying_accumulation >= 0.0);
    ASSERT(increase >= 0);
    unsigned int current_time = GET_TICK_COUNT();
    unsigned int elapsed_time = current_time - update_time;
    ASSERT(signed(elapsed_time) >= 0);
    double coefficient = 0.0;
    if (time_constant > 0.0)
    {
        coefficient = exp(-double(elapsed_time)/time_constant);
    }
    ASSERT(coefficient >= 0.0);
    ASSERT(coefficient <= 1.0);
    decaying_accumulation =
        coefficient * decaying_accumulation + double(increase);
    ASSERT(decaying_accumulation >= 0.0);
    update_time = current_time;
}

double
DecayingAccumulator::retrieve_value() const
{
    ASSERT(this != 0);
    ASSERT(time_constant >= 0.0);
    ASSERT(decaying_accumulation >= 0.0);
    unsigned int current_time = GET_TICK_COUNT();
    unsigned int elapsed_time = current_time - update_time;
    ASSERT(signed(elapsed_time) >= 0);
    double coefficient = 0.0;
    if (time_constant > 0.0)
    {
        coefficient = exp(-double(elapsed_time)/time_constant);
    }
    ASSERT(coefficient >= 0.0);
    ASSERT(coefficient <= 1.0);
    return coefficient * decaying_accumulation;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\etimer.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    etimer.h

Abstract:

	SIS Groveler event timer include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_ETIMER

#define _INC_ETIMER

typedef void (*EventCallback)(void *);

class EventTimer
{
public:

	EventTimer();

	~EventTimer();

	void run();

	void halt();

	void schedule(
		unsigned int event_time,
		void *context,
		EventCallback callback);

private:

	struct Event
	{
		unsigned int event_time;
		void *context;
		EventCallback callback;
	};

	struct HeapSegment
	{
		HeapSegment *previous;
		HeapSegment *next;
		Event events[1];
	};

	HeapSegment *first_segment, *last_segment;
	int population;
	int segment_size;
	bool heap_ok;
	bool running;
};

#endif	/* _INC_ETIMER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\event.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    event.cpp

Abstract:

    SIS Groveler sync event class

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

SyncEvent::SyncEvent(
    bool initial_state,
    bool manual_reset)
{
    ASSERT(this != 0);
    event_handle = CreateEvent(0, manual_reset, initial_state, 0);
    if (event_handle == 0)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: CreateEvent() failed with error %d\n"), err));
        throw exception_create_event;
    }
}

SyncEvent::~SyncEvent()
{
    ASSERT(this != 0);
    ASSERT(event_handle != 0);
    int ok = CloseHandle(event_handle);
    if (!ok)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: CloseHandle() failed with error %d\n"), err));
    }
    event_handle = 0;
}

bool
SyncEvent::set()
{
    ASSERT(this != 0);
    ASSERT(event_handle != 0);
    BOOL ok = SetEvent(event_handle);
    if (!ok)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: SetEvent() failed with error %d\n"), err));
    }
    return (ok != 0);
}

bool
SyncEvent::reset()
{
    ASSERT(this != 0);
    ASSERT(event_handle != 0);
    BOOL ok = ResetEvent(event_handle);
    if (!ok)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: ResetEvent() failed with error %d\n"), err));
    }
    return (ok != 0);
}

bool
SyncEvent::wait(
    unsigned int timeout)
{
    ASSERT(this != 0);
    ASSERT(event_handle != 0);
    ASSERT(signed(timeout) >= 0);
    DWORD result = WAIT_FOR_SINGLE_OBJECT(event_handle, timeout);
    if (result != WAIT_TIMEOUT && result != WAIT_OBJECT_0)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: WaitForSingleObject() returned error %d\n"),
            result));
    }
    return (result == WAIT_OBJECT_0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\event.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    event.h

Abstract:

	SIS Groveler sync event class header

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_EVENT

#define _INC_EVENT

class SyncEvent
{
public:

	SyncEvent(
		bool initial_state,
		bool manual_reset);

	~SyncEvent();

	bool set();

	bool reset();

	bool wait(
		unsigned int timeout);

private:

	HANDLE event_handle;
};

#endif	/* _INC_EVENT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\eventlog.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    eventlog.cpp

Abstract:

    SIS Groveler eventlog interface

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

#ifndef MIN_MESSAGE_SEVERITY
#define MIN_MESSAGE_SEVERITY 0
#endif

const _TCHAR *
EventLog::service_name = _T("Groveler");

const _TCHAR *
EventLog::message_filename = _T("%SystemRoot%\\System32\\grovmsg.dll");

static const _TCHAR *
registry_log_path = 
    _T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\");

const DWORD
EventLog::types_supported =
    EVENTLOG_INFORMATION_TYPE |
    EVENTLOG_WARNING_TYPE |
    EVENTLOG_ERROR_TYPE;

EventLog::EventLog()
{
    ASSERT(this != 0);
    setup_registry();
    event_source_handle = RegisterEventSource(0, service_name);
    if (event_source_handle == 0)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: RegisterEventSource() failed with error %d\n"),
            err));
    }
}

EventLog::~EventLog()
{
    ASSERT(this != 0);
    if (event_source_handle != 0)
    {
        int ok = DeregisterEventSource(event_source_handle);
        if (!ok)
        {
            DWORD err = GetLastError();
            PRINT_DEBUG_MSG((_T("GROVELER: DeregisterEventSource() failed with error %d\n"),
                err));
        }
    }
}

bool
EventLog::report_event(
    DWORD event_id,
    DWORD status,
    int string_count,
//  _TCHAR *string
    ...)
{
    WCHAR *strings[8];
    WCHAR statusStr[32];

    ASSERT(this != 0);
    ASSERT(event_source_handle != 0);
    ASSERT(string_count >= 0);
    if (event_source_handle == 0)
    {
        return false;
    }
    DWORD message_severity = MESSAGE_SEVERITY(event_id);

#if (MIN_MESSAGE_SEVERITY > 0)
    if (message_severity < MIN_MESSAGE_SEVERITY)
    {
        return false;
    }
#endif

    //
    //  Generate the list of strings buffer
    //

    ASSERT((string_count+1) < (sizeof(strings)/sizeof(WCHAR *)));

    va_list ap;
    va_start(ap, string_count);
    for (int index = 0; index < string_count; index++)
    {
        strings[index] = va_arg(ap, _TCHAR *);
        ASSERT(strings[index] != 0);
    }
    va_end(ap);

    //
    //  We are going to always insert the status string at the end of the
    //  list.

    (void)StringCbPrintf(statusStr,sizeof(statusStr),L"%d",status);
    strings[index] = statusStr;

    WORD event_type = 0;
    switch (message_severity)
    {
    case MESSAGE_SEVERITY_SUCCESS:
        event_type = EVENTLOG_AUDIT_SUCCESS;
        break;
    case MESSAGE_SEVERITY_INFORMATIONAL:
        event_type = EVENTLOG_INFORMATION_TYPE;
        break;
    case MESSAGE_SEVERITY_WARNING:
        event_type = EVENTLOG_WARNING_TYPE;
        break;
    case MESSAGE_SEVERITY_ERROR:
        event_type = EVENTLOG_ERROR_TYPE;
        break;
    default:
        ASSERT(false);
    }

    //
    //  Report the events.  We always add one to the string count because
    //  we always put the status string at the end of the buffer.
    //

    BOOL ok = ReportEvent(event_source_handle, event_type, 0, event_id,
        0, (WORD)(string_count+1), 0, (LPCWSTR *)strings, 0);

    if (!ok)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: ReportEvent() failed with error %d\n"), err));
    }

    return (ok != 0);
}

bool
EventLog::setup_registry()
{
    _TCHAR *log_path = 0;
    try
    {
        HKEY path_key = 0;
        DWORD disp;
        int bufSize = _tcslen(registry_log_path) + _tcslen(service_name) + 1;
        log_path = new _TCHAR[bufSize];
        (void)StringCchPrintf(log_path, bufSize, _T("%s%s"), registry_log_path, service_name);

        Registry::create_key_ex(HKEY_LOCAL_MACHINE, log_path, 0, 0,
            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, 0, &path_key, &disp);
        ASSERT(log_path != 0);
        delete[] log_path;
        log_path = 0;
        try
        {
            Registry::set_value_ex(path_key, _T("EventMessageFile"), 0,
                REG_EXPAND_SZ, (BYTE *)message_filename,
                (_tcslen(message_filename) + 1) * sizeof(_TCHAR));
            Registry::set_value_ex(path_key, _T("TypesSupported"), 0,
                REG_DWORD, (BYTE *)&types_supported, sizeof(DWORD));
        }
        catch (DWORD result)
        {
            ASSERT(result != ERROR_SUCCESS);
            PRINT_DEBUG_MSG((_T("GROVELER: Registry::set_value_ex() failed with error %d\n"),
                result));
            ASSERT(path_key != 0);
            Registry::close_key(path_key);
            path_key = 0;
            return false;
        }
        ASSERT(path_key != 0);
        Registry::close_key(path_key);
        path_key = 0;
    }
    catch (DWORD result)
    {
        if (log_path != 0)
        {
            delete[] log_path;
            log_path = 0;
        }
        ASSERT(result != ERROR_SUCCESS);
        PRINT_DEBUG_MSG((_T("GROVELER: Registry::create_key_ex() or Registry::close_key() ")
            _T("failed with error %d\n"), result));
        return false;
    }
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\eventlog.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    eventlog.h

Abstract:

	SIS Groveler event log interface include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_EVENTLOG

#define _INC_EVENTLOG

class EventLog
{
public:

	EventLog();

	~EventLog();

	static bool setup_registry();

	bool report_event(
		DWORD event_id,
        DWORD status,
		int string_count,
	//	_TCHAR *string
		...);

private:

	static const _TCHAR *service_name;
	static const _TCHAR *message_filename;
	static const DWORD types_supported;

	HANDLE event_source_handle;
};

#endif	/* _INC_EVENTLOG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\extract.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    extract.cpp

Abstract:

    SIS Groveler USN journal reading functions

Authors:

    Cedric Krumbein, 1998

Environment:

    User Mode

Revision History:

--*/

#include "all.hxx"

// NT Update Sequence Number (USN) journal definitions

#define USN_ADD_REASONS ( 0U              \
    | USN_REASON_DATA_OVERWRITE           \
    | USN_REASON_DATA_EXTEND              \
    | USN_REASON_DATA_TRUNCATION          \
    | USN_REASON_NAMED_DATA_OVERWRITE     \
    | USN_REASON_NAMED_DATA_EXTEND        \
    | USN_REASON_NAMED_DATA_TRUNCATION    \
    | USN_REASON_FILE_CREATE              \
    | USN_REASON_FILE_DELETE              \
/*  | USN_REASON_PROPERTY_CHANGE       */ \
/*  | USN_REASON_SECURITY_CHANGE       */ \
/*  | USN_REASON_RENAME_OLD_NAME       */ \
/*  | USN_REASON_RENAME_NEW_NAME       */ \
    | USN_REASON_INDEXABLE_CHANGE         \
    | USN_REASON_BASIC_INFO_CHANGE        \
/*  | USN_REASON_HARD_LINK_CHANGE      */ \
    | USN_REASON_COMPRESSION_CHANGE       \
    | USN_REASON_ENCRYPTION_CHANGE        \
    | USN_REASON_OBJECT_ID_CHANGE         \
/*  | USN_REASON_REPARSE_POINT_CHANGE  */ \
    | USN_REASON_CLOSE                    \
)

/*****************************************************************************/

// set_usn_log_size() sets the maximum size of this volume's USN journal.

DWORD Groveler::set_usn_log_size(
    IN DWORDLONG usn_log_size)
{
    CREATE_USN_JOURNAL_DATA createUSN;
    DWORD transferCount;
    DWORD lstatus;

    ASSERT(volumeHandle != NULL);

    createUSN.MaximumSize     = usn_log_size;
    createUSN.AllocationDelta = USN_PAGE_SIZE;

// Set the maximum size of the USN journal.

    if (!DeviceIoControl(
        volumeHandle,
        FSCTL_CREATE_USN_JOURNAL,
        &createUSN,
        sizeof(CREATE_USN_JOURNAL_DATA),
        NULL,
        0,
        &transferCount,
        NULL)) {

        lstatus = GetLastError();

        DPRINTF((_T("%s: error setting USN journal size: %lu\n"),
            driveName, lstatus));
        return lstatus;
    }

    TPRINTF((_T("%s: set USN journal size to %I64u\n"),
        driveName, usn_log_size));

    return ERROR_SUCCESS;
}

/*****************************************************************************/

// get_usn_log_size() returns the current size of this volume's USN journal.

DWORD Groveler::get_usn_log_info(
    OUT USN_JOURNAL_DATA *usnJournalData)
{
    DWORD transferCount,
          lastError;

    BOOL success;

    ASSERT(volumeHandle != NULL);

// Query the USN journal settings.

    success = DeviceIoControl(
        volumeHandle,
        FSCTL_QUERY_USN_JOURNAL,
        NULL,
        0,
        usnJournalData,
        sizeof(USN_JOURNAL_DATA),
        &transferCount,
        NULL);

    if (!success)
        lastError = GetLastError();
    else if (transferCount != sizeof(USN_JOURNAL_DATA)) {
        lastError = ERROR_INVALID_DATA;
        success   = FALSE;
    }

    if (!success) {
        DPRINTF((_T("%s: error querying USN journal settings: %lu\n"),
            driveName, lastError));
        return lastError;
    }

    TPRINTF((_T("%s: USN journal: ID=0x%I64x size=0x%I64x\n"),
        driveName, usnJournalData->UsnJournalID,
        usnJournalData->MaximumSize));

    return ERROR_SUCCESS;
}

/*****************************************************************************/

// extract_log() reads this volume's USN journal.

// If the lastUSN parameter equals zero or doesn't exist, the USN journal
// is read from the beginning. Otherwise, the lastUSN paramerer indicates
// the most recent USN entry read during the last call of extract_log().
// If the lastUSN entry is still available in the USN journal, read the
// journal beginning at the entry following the lastUSN entry. If the
// lastUSN entry is no longer available, it indicates that the USN
// journal has wrapped: read all entries from the journal.

enum USNException {
    USN_ERROR
};

enum DatabaseException {
    DATABASE_ERROR
};

GrovelStatus Groveler::extract_log2(
    OUT DWORD     *num_entries_extracted,
    OUT DWORDLONG *num_bytes_extracted,
    OUT DWORDLONG *num_bytes_skipped,
    OUT DWORD     *num_files_enqueued,
    OUT DWORD     *num_files_dequeued)
{
    struct FileEntry {
        DWORDLONG fileID,
                  parentID,
                  timeStamp;
        DWORD     attributes,
                  reason;
    } *fileEntry = NULL;

    struct DirEntry {
        DWORDLONG dirID;
    } *dirEntry = NULL;

    Table *fileTable = NULL,
          *dirTable  = NULL;

    BYTE usnBuffer[USN_PAGE_SIZE + sizeof(DWORDLONG)];

    READ_USN_JOURNAL_DATA readUSN;

    USN_RECORD *usnRecord;

    SGNativeTableEntry tableEntry;

    SGNativeQueueEntry queueEntry;

    SGNativeStackEntry stackEntry;

    SGNativeListEntry listEntry;

    TCHAR listValue[17];

    DWORDLONG usn_log_size,
              numBytesExtracted = 0,
              numBytesSkipped   = 0,
              startUSN,
              firstUSN,
              nextUSN,
              thisUSN;

    DWORD numEntriesExtracted = 0,
          numTableDeletions   = 0,
          numQueueDeletions   = 0 ,
          numQueueAdditions   = 0,
          numActions          = 0,
          offset,
          bytesRead,
          lastError;

    LONG num;

    BOOL firstEntry = TRUE,
         deleteEntry,
         addEntry,
         success;

    GrovelStatus    status;

    ASSERT(volumeHandle != NULL);
    ASSERT(sgDatabase != NULL);

// If we don't know the previous USN, we can't extract.

    if (lastUSN == UNINITIALIZED_USN) {
        status = Grovel_overrun;
        goto Abort;
    }
    ASSERT(usnID != UNINITIALIZED_USN);

    fileTable = new Table;
    ASSERT(fileTable != NULL);

    if (inScan) {
        dirTable = new Table;
        ASSERT(dirTable != NULL);
    }

// Set up to read the volume's USN journal.

    startUSN = lastUSN == UNINITIALIZED_USN ? 0 : lastUSN;

    readUSN.ReturnOnlyOnClose =  1;
    readUSN.Timeout           =  0;
    readUSN.BytesToWaitFor    =  0;
    readUSN.ReasonMask        = ~0U;
    readUSN.UsnJournalID      =  usnID;

// Read the USN journal one page at a time.

    try {
        while (TRUE) {
            readUSN.StartUsn = startUSN;

            if (!DeviceIoControl(
                volumeHandle,
                FSCTL_READ_USN_JOURNAL,
                &readUSN,
                sizeof(READ_USN_JOURNAL_DATA),
                usnBuffer,
                USN_PAGE_SIZE + sizeof(DWORDLONG),
                &bytesRead,
                NULL)) {

                lastError = GetLastError();


// NTRAID#65198-2000/03/10-nealch  Handle USN id change (treat as overwrite w/ unknown no. of bytes skipped)

// If the journal overflowed, report by how much.

                if (lastError == ERROR_KEY_DELETED || lastError == ERROR_JOURNAL_ENTRY_DELETED) {
                    USN_JOURNAL_DATA usnJournalData;

                    if (get_usn_log_info(&usnJournalData) != ERROR_SUCCESS)
                        return Grovel_error;

                    // The USN journal will not wrap in our lifetimes so we don't really need
                    // to handle USN Journal wrapping.
                    ASSERT((DWORDLONG) usnJournalData.FirstUsn > lastUSN);

                    numBytesSkipped = (DWORDLONG) usnJournalData.FirstUsn - lastUSN;
                    goto Overrun;
                }

                throw USN_ERROR;
            }

            lastError = 0;

            if (bytesRead < sizeof(DWORDLONG))
                throw USN_ERROR;

            nextUSN = *(DWORDLONG *)usnBuffer;
            if (nextUSN < startUSN)
                throw USN_ERROR;

            if (nextUSN == startUSN) {
                if (bytesRead != sizeof(DWORDLONG))
                    throw USN_ERROR;
                break;
            }

            bytesRead         -= sizeof(DWORDLONG);
            offset             = 0;
            numBytesExtracted += bytesRead;

// Process each USN journal entry.

            while (bytesRead > 0) {
                if (bytesRead < sizeof(USN_RECORD))
                    throw USN_ERROR;

                usnRecord = (USN_RECORD *)&usnBuffer[offset + sizeof(DWORDLONG)];

                if (usnRecord->RecordLength <
                        offsetof(USN_RECORD, FileName) + usnRecord->FileNameLength
                 || usnRecord->RecordLength > bytesRead)
                    throw USN_ERROR;

                thisUSN = (DWORDLONG)usnRecord->Usn;
                if (thisUSN < startUSN + offset)
                    throw USN_ERROR;

// If this is the first entry, check if it is the expected
// USN. If it isn't, the USN journal has wrapped.

                if (firstEntry)
                    if (startUSN == 0)
                        numBytesSkipped = thisUSN;
                    else if (thisUSN <= startUSN + usnRecord->RecordLength)
                        numBytesSkipped = 0;
                    else
                        numBytesSkipped = thisUSN - startUSN - usnRecord->RecordLength;

// Skip the first entry if the starting address is greater than zero.
// After skipping the first entry, examine each USN entry as follows:
//
// - If the entry is a directory, and a volume scan is underway,
//   add the directory's ID to the directory table.
//
// - If the entry is a file, add it to the file table. Include
//   its ID and its parent directory's ID, its most recent time
//   stamp and attributes, and its accumulated reason bits.

                if (firstEntry && startUSN > 0)
                    numBytesExtracted -= usnRecord->RecordLength;

                else {
                    if (usnRecord->      FileReferenceNumber == 0
                     || usnRecord->ParentFileReferenceNumber == 0)
                        throw USN_ERROR;

// The entry is a directory.

                    if ((usnRecord->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) {

                        if (dirTable != NULL) {
                            dirEntry = (DirEntry *)dirTable->Get(
                                (const VOID *)&usnRecord->FileReferenceNumber,
                                sizeof(DWORDLONG));

                            if (dirEntry != NULL) {
                                ASSERT(dirEntry->dirID == usnRecord->FileReferenceNumber);
                            } else {
                                dirEntry = new DirEntry;
                                ASSERT(dirEntry != NULL);
                                dirEntry->dirID = usnRecord->FileReferenceNumber;
                                success = dirTable->Put((VOID *)dirEntry, sizeof(DWORDLONG));
                                ASSERT(success);
                            }
                        }
                    }

// The entry is a file.  If USN_SOURCE_DATA_MANAGEMENT is set, assume this entry was created by
// the groveler during a merge operation.

                    else if ((usnRecord->SourceInfo & USN_SOURCE_DATA_MANAGEMENT) == 0) {

                        fileEntry = (FileEntry *)fileTable->Get(
                            (const VOID *)&usnRecord->FileReferenceNumber,
                            sizeof(DWORDLONG));

                        if (fileEntry != NULL) {
                            ASSERT(fileEntry->fileID == usnRecord->FileReferenceNumber);
                        } else {
                            fileEntry = new FileEntry;
                            ASSERT(fileEntry != NULL);
                            fileEntry->fileID   = usnRecord->FileReferenceNumber;
                            fileEntry->reason   = 0;
                            success = fileTable->Put((VOID *)fileEntry, sizeof(DWORDLONG));
                            ASSERT(success);
                        }

                        fileEntry->parentID   = usnRecord->ParentFileReferenceNumber;
                        fileEntry->timeStamp  = (DWORDLONG)usnRecord->TimeStamp.QuadPart;
                        fileEntry->attributes =            usnRecord->FileAttributes;

                        if ((usnRecord->Reason & USN_REASON_FILE_DELETE) != 0)
                            fileEntry->reason  = USN_REASON_FILE_DELETE;
                        else
                            fileEntry->reason |= usnRecord->Reason;
                    } else {
                        TPRINTF((_T("%s: USN_SOURCE_DATA_MANAGEMENT set on file 0x%016I64x\n"),
                            driveName, usnRecord->FileReferenceNumber));
                    }

                    if (numEntriesExtracted++ == 0)
                        firstUSN = thisUSN;
                }

                lastUSN    = thisUSN;
                offset    += usnRecord->RecordLength;
                bytesRead -= usnRecord->RecordLength;
                firstEntry = FALSE;
            }

            startUSN = nextUSN;
        }
    }

// If an error occured while reading the USN journal, return an error status.

    catch (USNException usnException) {
        ASSERT(usnException == USN_ERROR);

        if (fileTable != NULL) {
            delete fileTable;
            fileTable = NULL;
        }

        if (dirTable != NULL) {
            delete dirTable;
            dirTable = NULL;
        }

        lastUSN = UNINITIALIZED_USN;

        DPRINTF((_T("%s: error reading USN journal: %lu\n"),
            driveName, lastError));

        return Grovel_error;
    }

// We've finished reading the USN journal, so update the database. Process
// each entry in the file table, and group the updates into transactions.

    try {
        while ((fileEntry = (FileEntry *)fileTable->GetFirst()) != NULL) {
            ASSERT(fileEntry->fileID != 0);

// If the file is currently open in the grovel process, skip this entry.

            if (inUseFileID1 != NULL && fileEntry->fileID == *inUseFileID1
             || inUseFileID2 != NULL && fileEntry->fileID == *inUseFileID2) {

                DPRINTF((_T("%s: extract_log/grovel collision on file 0x%016I64x\n"),
                    driveName, fileEntry->fileID));

            } else {

// Delete the file from the queue and the table...
//
// - if the file's most recent reason bits in the USN journal
//   indicate it was deleted,
//
// - if the file or the file's most recent parent directory is disallowed,
//
// - or if the file has disallowed attributes.
//
// Otherwise, update or add the file to the queue...
//
// - if the file's reason bits indicate it was changed,
//
// - or if the file isn't present in the table.

                if (fileEntry->reason == USN_REASON_FILE_DELETE
                 || !IsAllowedID(fileEntry->fileID)
                 || !IsAllowedID(fileEntry->parentID)
                 || (fileEntry->attributes & disallowedAttributes) != 0) {
                    deleteEntry = TRUE;
                    addEntry    = FALSE;
                } else {
                    deleteEntry = FALSE;
                    if ((fileEntry->reason & USN_ADD_REASONS) != 0)
                        addEntry = TRUE;
                    else {
                        tableEntry.fileID = fileEntry->fileID;
                        num = sgDatabase->TableGetFirstByFileID(&tableEntry);
                        if (num < 0)
                            throw DATABASE_ERROR;
                        ASSERT(num == 0 || num == 1);
                        addEntry = num == 0;
                    }
                }

                if (deleteEntry || addEntry) {
                    if (numActions == 0) {
                        if (sgDatabase->BeginTransaction() < 0)
                            throw DATABASE_ERROR;
                        numActions = 1;
                    }

                    queueEntry.reason = 0;

                    num = sgDatabase->TableDeleteByFileID(fileEntry->fileID);
                    if (num < 0)
                        throw DATABASE_ERROR;
                    if (num > 0) {
                        ASSERT(num == 1);
                        numTableDeletions++;
                        numActions++;
                    }

                    queueEntry.fileID   = fileEntry->fileID;
                    queueEntry.fileName = NULL;
                    num = sgDatabase->QueueGetFirstByFileID(&queueEntry);
                    if (num < 0)
                        throw DATABASE_ERROR;

                    if (num > 0) {
                        ASSERT(num == 1);
                        num = sgDatabase->QueueDeleteByFileID(fileEntry->fileID);
                        if (num < 0)
                            throw DATABASE_ERROR;
                        ASSERT(num == 1);
                        numQueueDeletions++;
                        numActions++;
                    }

                    if (addEntry) {
                        queueEntry.fileID    = fileEntry->fileID;
                        queueEntry.parentID  = 0;
                        queueEntry.reason   |= fileEntry->reason;
                        queueEntry.readyTime = fileEntry->timeStamp + minFileAge;
                        queueEntry.retryTime = 0;
                        queueEntry.fileName  = NULL;

                        num = sgDatabase->QueuePut(&queueEntry);
                        if (num < 0)
                            throw DATABASE_ERROR;
                        ASSERT(num == 1);

#ifdef DEBUG_USN_REASON
                        if (numQueueAdditions == 0) {
                            DPRINTF((_T("--> __REASON__ _____FILE_ID______\n")));
                        }
                        DPRINTF((_T("    0x%08lx 0x%016I64x\n"),
                            fileEntry->reason, fileEntry->fileID));
#endif

                        numQueueAdditions++;
                        numActions++;
                    }

                    if (numActions >= MAX_ACTIONS_PER_TRANSACTION) {
                        if (!sgDatabase->CommitTransaction())
                            throw DATABASE_ERROR;
                        TPRINTF((_T("%s: committing %lu actions to \"%s\"\n"),
                            driveName, numActions, databaseName));
                        numActions = 0;
                    }
                }
            }

            delete fileEntry;
            fileEntry = NULL;
        }

        delete fileTable;
        fileTable = NULL;

// Process each entry in the directory table. If the directory hasn't already
// been scanned or isn't on the list to be scanned, add it to the list.

        if (dirTable != NULL) {
            ASSERT(inScan);

            while ((dirEntry = (DirEntry *)dirTable->GetFirst()) != NULL) {
                ASSERT(dirEntry->dirID != 0);

                stackEntry.fileID = dirEntry->dirID;
                num = sgDatabase->StackGetFirstByFileID(&stackEntry);
                if (num < 0)
                    throw DATABASE_ERROR;

                if (num == 0) {
                    if (numActions == 0) {
                        if (sgDatabase->BeginTransaction() < 0)
                            throw DATABASE_ERROR;
                        numActions = 1;
                    }

                    num = sgDatabase->StackPut(dirEntry->dirID, FALSE);
                    if (num < 0)
                        throw DATABASE_ERROR;
                    ASSERT(num == 1);
                    numActions++;

                    if (numActions >= MAX_ACTIONS_PER_TRANSACTION) {
                        if (!sgDatabase->CommitTransaction())
                            throw DATABASE_ERROR;
                        TPRINTF((_T("%s: committing %lu actions to \"%s\"\n"),
                            driveName, numActions, databaseName));
                        numActions = 0;
                    }
                }

                delete dirEntry;
                dirEntry = NULL;
            }

            delete dirTable;
            dirTable = NULL;
        }

// Update the last USN number in the database, then commit the changes.  If we're
// doing a volume scan, don't update the lastUSN until the scan is complete.

        if (!inScan) {
            (void)StringCbPrintf(listValue, sizeof(listValue), _T("%016I64x"), lastUSN);
            listEntry.name  = LAST_USN_NAME;
            listEntry.value = listValue;
            num = sgDatabase->ListWrite(&listEntry);
            if (num <= 0)
                throw DATABASE_ERROR;
        }

        if (numActions > 0) {
            if (!sgDatabase->CommitTransaction())
                throw DATABASE_ERROR;
            TPRINTF((_T("%s: committing %lu actions to \"%s\"\n"),
                driveName, numActions, databaseName));
            numActions = 0;
        }
    }

// If a database error occured, return an error status.

    catch (DatabaseException databaseException) {

        ASSERT(databaseException == DATABASE_ERROR);

        if (numActions > 0) {
            sgDatabase->AbortTransaction();
            numActions = 0;
        }

        if (fileTable != NULL) {
            delete fileTable;
            fileTable = NULL;
        }

        if (dirTable != NULL) {
            delete dirTable;
            dirTable = NULL;
        }

        return Grovel_error;
    }

    Overrun:

    status = numBytesSkipped == 0 ? Grovel_ok : Grovel_overrun;

    Abort:

// Return the performance statistics.

    if (num_entries_extracted != NULL)
        *num_entries_extracted = numEntriesExtracted;
    if (num_bytes_extracted   != NULL)
        *num_bytes_extracted   = numBytesExtracted;
    if (num_bytes_skipped     != NULL)
        *num_bytes_skipped     = numBytesSkipped;
    if (num_files_enqueued    != NULL)
        *num_files_enqueued    = numQueueAdditions;
    if (num_files_dequeued    != NULL)
        *num_files_dequeued    = numQueueDeletions;

#if DBG
    if (numEntriesExtracted > 0 && firstUSN < lastUSN) {
        TRACE_PRINTF(TC_extract, 2,
            (_T("%s: USN 0x%I64x-%I64x\n"), driveName, firstUSN, lastUSN));
    } else {
        TRACE_PRINTF(TC_extract, 2,
            (_T("%s: USN 0x%I64x\n"),       driveName, lastUSN));
    }
    TRACE_PRINTF(TC_extract, 2,
        (_T("   NumEntriesExtracted=%lu NumBytesExtracted=%I64u NumBytesSkipped=%I64u\n"),
        numEntriesExtracted, numBytesExtracted, numBytesSkipped));
    TRACE_PRINTF(TC_extract, 2,
        (_T("   NumTableDeletions=%lu NumQueueDeletions=%lu NumQueueAdditions=%lu\n"),
        numTableDeletions, numQueueDeletions, numQueueAdditions));
#endif

    return status;

}

GrovelStatus Groveler::extract_log(
    OUT DWORD     *num_entries_extracted,
    OUT DWORDLONG *num_bytes_extracted,
    OUT DWORDLONG *num_bytes_skipped,
    OUT DWORD     *num_files_enqueued,
    OUT DWORD     *num_files_dequeued)
{
    GrovelStatus status;

#ifdef _CRTDBG
_CrtMemState s1, s2, sdiff;

_CrtMemCheckpoint(&s1);
#endif

    status = extract_log2(
                num_entries_extracted,
                num_bytes_extracted,
                num_bytes_skipped,
                num_files_enqueued,
                num_files_dequeued);

#ifdef _CRTDBG
_CrtMemCheckpoint(&s2);
if (_CrtMemDifference(&sdiff, &s1, &s2))
    _CrtMemDumpStatistics(&sdiff);
#endif

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\filter.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    filter.h

Abstract:

	SIS Groveler temporal filter include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_FILTER

#define _INC_FILTER

class TemporalFilter
{
public:

	TemporalFilter(
		unsigned int time_constant,
		double initial_value = 0.0);

	void reset(
		double reset_value = 0.0);

	void update_value(
		double value);

	double retrieve_value() const;

private:

	double time_constant;
	double filtered_value;
	unsigned int update_time;
};

class DirectedTemporalFilter
{
public:

	DirectedTemporalFilter(
		unsigned int increase_time_constant,
		unsigned int decrease_time_constant,
		double initial_value = 0.0);

	void reset(
		double reset_value = 0.0);

	void update_value(
		double value);

	double retrieve_value() const;

private:

	double increase_time_constant;
	double decrease_time_constant;
	double filtered_value;
	unsigned int update_time;
};

class IncidentFilter
{
public:

	IncidentFilter(
		int mean_history_length,
		double initial_value = 0.0);

	void reset(
		double reset_value = 0.0);

	void update_value(
		double value);

	void update_value(
		double value,
		int weight);

	double retrieve_value() const;

private:

	double coefficient;
	double filtered_value;
};

class DirectedIncidentFilter
{
public:

	DirectedIncidentFilter(
		int increase_mean_history_length,
		int decrease_mean_history_length,
		double initial_value = 0.0);

	void reset(
		double reset_value = 0.0);

	void update_value(
		double value);

	void update_value(
		double value,
		int weight);

	double retrieve_value() const;

private:

	double increase_coefficient;
	double decrease_coefficient;
	double filtered_value;
};

#endif	/* _INC_FILTER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\grovctrl.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    grovctrl.h

Abstract:

	SIS Groveler controller primary include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_GROVCTRL

#define _INC_GROVCTRL

typedef int (* Function)(int, int, _TCHAR **);

struct Action
{
	_TCHAR *arg;
	int min_character_count;
	Function function;
	int flag;
	_TCHAR *help;
};

enum {CTRL_stop, CTRL_pause, CTRL_continue};
enum {CMD_foreground, CMD_background, CMD_volscan};

int install_service(
	int dummy,
	int argc,
	_TCHAR **argv);
int remove_service(
	int dummy,
	int argc,
	_TCHAR **argv);
int set_service_interaction(
	int interactive,
	int argc,
	_TCHAR **argv);
int start_service(
	int dummy,
	int argc,
	_TCHAR **argv);
int control_service(
	int control,
	int argc,
	_TCHAR **argv);
int command_service(
	int command,
	int argc,
	_TCHAR **argv);
int load_counters();
int unload_counters();

#endif	/* _INC_GROVCTRL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\filter.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    filter.cpp

Abstract:

    SIS Groveler temporal filter classes

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

TemporalFilter::TemporalFilter(
    unsigned int time_constant,
    double initial_value)
{
    ASSERT(this != 0);
    this->time_constant = double(time_constant);
    ASSERT(this->time_constant > 0.0);
    filtered_value = initial_value;
    update_time = GET_TICK_COUNT();
}

void
TemporalFilter::reset(
    double reset_value)
{
    ASSERT(this != 0);
    filtered_value = reset_value;
    update_time = GET_TICK_COUNT();
}

void
TemporalFilter::update_value(
    double value)
{
    ASSERT(this != 0);
    ASSERT(time_constant > 0.0);
    unsigned int current_time = GET_TICK_COUNT();
    unsigned int elapsed_time = current_time - update_time;
    ASSERT(signed(elapsed_time) >= 0);
    double coefficient = 1.0 - exp(-double(elapsed_time)/time_constant);
    ASSERT(coefficient >= 0.0);
    ASSERT(coefficient <= 1.0);
    filtered_value += coefficient * (value - filtered_value);
    update_time = current_time;
}

double
TemporalFilter::retrieve_value() const
{
    ASSERT(this != 0);
    return filtered_value;
}

DirectedTemporalFilter::DirectedTemporalFilter(
    unsigned int increase_time_constant,
    unsigned int decrease_time_constant,
    double initial_value)
{
    ASSERT(this != 0);
    this->increase_time_constant = double(increase_time_constant);
    this->decrease_time_constant = double(decrease_time_constant);
    ASSERT(this->increase_time_constant > 0.0);
    ASSERT(this->decrease_time_constant > 0.0);
    filtered_value = initial_value;
    update_time = GET_TICK_COUNT();
}

void
DirectedTemporalFilter::reset(
    double reset_value)
{
    ASSERT(this != 0);
    filtered_value = reset_value;
    update_time = GET_TICK_COUNT();
}

void
DirectedTemporalFilter::update_value(
    double value)
{
    ASSERT(this != 0);
    ASSERT(increase_time_constant > 0.0);
    ASSERT(decrease_time_constant > 0.0);
    unsigned int current_time = GET_TICK_COUNT();
    unsigned int elapsed_time = current_time - update_time;
    ASSERT(signed(elapsed_time) >= 0);
    double coefficient;
    if(value > filtered_value)
    {
        coefficient = 1.0 - exp(-double(elapsed_time)/increase_time_constant);
    }
    else
    {
        coefficient = 1.0 - exp(-double(elapsed_time)/decrease_time_constant);
    }
    ASSERT(coefficient >= 0.0);
    ASSERT(coefficient <= 1.0);
    filtered_value += coefficient * (value - filtered_value);
    update_time = current_time;
}

double
DirectedTemporalFilter::retrieve_value() const
{
    ASSERT(this != 0);
    return filtered_value;
}

IncidentFilter::IncidentFilter(
    int mean_history_length,
    double initial_value)
{
    ASSERT(this != 0);
    ASSERT(mean_history_length > 0);
    coefficient = 1.0 - exp(-1.0 / double(mean_history_length));
    ASSERT(coefficient >= 0.0);
    ASSERT(coefficient < 1.0);
    filtered_value = initial_value;
}

void
IncidentFilter::reset(
    double reset_value)
{
    ASSERT(this != 0);
    filtered_value = reset_value;
}

void
IncidentFilter::update_value(
    double value)
{
    ASSERT(this != 0);
    ASSERT(coefficient >= 0.0);
    ASSERT(coefficient < 1.0);
    filtered_value += coefficient * (value - filtered_value);
}

void
IncidentFilter::update_value(
    double value,
    int weight)
{
    ASSERT(this != 0);
    ASSERT(coefficient >= 0.0);
    ASSERT(coefficient < 1.0);
    ASSERT(weight >= 0);
    double weighted_coefficient = 1.0 - pow(1.0 - coefficient, double(weight));
    ASSERT(weighted_coefficient >= 0.0);
    ASSERT(weighted_coefficient <= 1.0);
    filtered_value += weighted_coefficient * (value - filtered_value);
}

double
IncidentFilter::retrieve_value() const
{
    ASSERT(this != 0);
    return filtered_value;
}

DirectedIncidentFilter::DirectedIncidentFilter(
    int increase_mean_history_length,
    int decrease_mean_history_length,
    double initial_value)
{
    ASSERT(this != 0);
    ASSERT(increase_mean_history_length > 0);
    ASSERT(decrease_mean_history_length > 0);
    increase_coefficient =
        1.0 - exp(-1.0 / double(increase_mean_history_length));
    ASSERT(increase_coefficient >= 0.0);
    ASSERT(increase_coefficient < 1.0);
    decrease_coefficient =
        1.0 - exp(-1.0 / double(decrease_mean_history_length));
    ASSERT(decrease_coefficient >= 0.0);
    ASSERT(decrease_coefficient < 1.0);
    filtered_value = initial_value;
}

void
DirectedIncidentFilter::reset(
    double reset_value)
{
    ASSERT(this != 0);
    filtered_value = reset_value;
}

void
DirectedIncidentFilter::update_value(
    double value)
{
    ASSERT(this != 0);
    if(value > filtered_value)
    {
        ASSERT(increase_coefficient >= 0.0);
        ASSERT(increase_coefficient < 1.0);
        filtered_value += increase_coefficient * (value - filtered_value);
    }
    else
    {
        ASSERT(decrease_coefficient >= 0.0);
        ASSERT(decrease_coefficient < 1.0);
        filtered_value += decrease_coefficient * (value - filtered_value);
    }
}

void
DirectedIncidentFilter::update_value(
    double value,
    int weight)
{
    ASSERT(this != 0);
    ASSERT(weight >= 0);
    double weighted_coefficient;
    if(value > filtered_value)
    {
        ASSERT(increase_coefficient >= 0.0);
        ASSERT(increase_coefficient < 1.0);
        weighted_coefficient =
            1.0 - pow(1.0 - increase_coefficient, double(weight));
    }
    else
    {
        ASSERT(decrease_coefficient >= 0.0);
        ASSERT(decrease_coefficient < 1.0);
        weighted_coefficient =
            1.0 - pow(1.0 - decrease_coefficient, double(weight));
    }
    ASSERT(weighted_coefficient >= 0.0);
    ASSERT(weighted_coefficient <= 1.0);
    filtered_value += weighted_coefficient * (value - filtered_value);
}

double
DirectedIncidentFilter::retrieve_value() const
{
    ASSERT(this != 0);
    return filtered_value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\grovel.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    grovel.cpp

Abstract:

    SIS Groveler main function

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

/*
 *  The core of the groveler executable is an object of the EventTimer class.
 *  All periodic operations are registered with the global event_timer object,
 *  and they are called at appropriate times during the execution of the
 *  event_timer.run() function.
 *
 *  Errors are written to the system event log, which is accessed through
 *  member functions of the EventLog class.  The eventlog object is a global
 *  so that any function or member function of any class can log an event if
 *  necessary.
 *
 *  The service control thread synchronizes with the main groveler thread via
 *  a Windows event.  This event is encapsulated in an object of the SyncEvent
 *  class.
 *
 *  The SISDrives class determines which drives have SIS installed.
 *
 *  The SharedData class is used to write values that are read by the groveler
 *  performance DLL, so that the groveler's operation can be monitored by
 *  PerfMon.  This object needs to be global so that any function or member
 *  function of any class can record performance information.
 *
 *  The CentralController class is instantiated into a global object, rather
 *  than an object local to the main() function, so that the service controller
 *  can invoke CentralController member functions in order to affect its
 *  operation.
 *
 *  Initially, the shared_data and controller pointers are set to null, so that
 *  if an exception occurs, the code that deletes allocated objects can check
 *  for a null to determine whether or not the object has been instantiated.
 *
 */

EventTimer event_timer;
EventLog eventlog;
SyncEvent sync_event(false, false);
SISDrives sis_drives;
LogDrive *log_drive = 0;
SharedData *shared_data = 0;
CentralController *controller = 0;

//
//  It was determined that the groveler needed to be modified to by default
//  only grovel the files in the RIS tree.  Since presently this can only
//  exist on one volume, these are globals used to define if SIS can do
//  all files on a volume or only the RIS tree.
//

int GrovelAllPaths = FALSE;
PWCHAR RISVolumeName = NULL;
PWCHAR RISVolumeGuidName = NULL;
PWCHAR RISPath = NULL;

void ConfigureRISOnlyState();
                      
/*
 *  Ordinarily, the groveler does not stop operation until it is told to by
 *  a command from the service control manager.  However, for testing, it can
 *  sometimes be useful to specify a time limit for running.  The groveler thus
 *  accepts a first argument that indicates such a time limit.  If an argument
 *  is supplied, an invokation of the halt() function is scheduled in the
 *  event_timer object for the specified time.
 *
 */

void halt(
    void *context)
{
    event_timer.halt();
};

/*
 *  The function groveler_new_handler() is installed as a new handler by the
 *  _set_new_handler() function.  Whenever a memory allocation failure occurs,
 *  it throws an exception_memory_allocation, which is caught by the catch
 *  clause in the main() function.
 *
 */

int __cdecl groveler_new_handler(
    size_t bytes)
{
    throw exception_memory_allocation;
    return 0;
}

/*
 *  This file contains the main() function and declarations for global objects
 *  for the groveler.exe program, as well as a couple of simple ancillary
 *  functions, halt() and groveler_new_handler().
 *
 *  The main() function reads configuration information, instantiates a set of
 *  primary objects -- the most significant of which are instances of the
 *  classes Groveler and CentralController -- and enters the run() member
 *  function of the event_timer object, which periodically invokes member
 *  functions of other objects, most notably those of the clasess
 *  CentralController and PartitionController.
 *
 *  Configuration information comes from objects of three classes:
 *  ReadParameters, ReadDiskInformation, and PathList.  The ReadParameters
 *  and PathList classes provide configuration information that applies to
 *  grovelers on all partitions.  The ReadDiskInformation class provides
 *  configuration information that applies to a single disk partition.  One
 *  object of the ReadDiskInformation class is instantiated for each drive
 *  that has SIS installed, as explained above.
 *
 *  For each SIS drive, the main() function instantiates an object of the
 *  ReadDiskInformation class to determine the configuration options (which
 *  ReadDiskInformation obtains from the registry) for the given disk
 *  partition.  If the drive is configured to enable groveling, then an object
 *  of the Groveler class is instantiated for that drive.
 *
 *  The main() function then instantiates an object of class CentralController,
 *  which in turn instantiates an object of class PartitionController for each
 *  SIS-enabled disk partition.  Each partition controller is assigned to one
 *  object of the Groveler class, and it controls the groveler by calling its
 *  member functions at appropriate times.
 *
 *  Nearly all of of the processing done by the groveler executable is
 *  performed within a try clause, the purpose of which is to catch errors of
 *  terminal severity.  There are two such errors (defined in all.hxx) that are
 *  expected to throw such exceptions: a memory allocation failure and a
 *  failure to create an Windows event.  If either of these conditions occurs,
 *  the program terminates.
 *
 */

_main(int argc, _TCHAR **argv)
{
    _set_new_handler(groveler_new_handler);
    SetErrorMode(SEM_FAILCRITICALERRORS);
    int exit_code = NO_ERROR;
    int num_partitions = 0;
    int index;

    //
    // Initially, these pointers are set to null, so that if an exception
    // occurs, the code that deletes allocated objects can check for a null
    // to determine whether or not the object has been instantiated.
    //

    Groveler *grovelers = 0;
    GrovelStatus *groveler_statuses = 0;
    ReadDiskInformation **read_disk_info = 0;
    WriteDiskInformation **write_disk_info = 0;

    //
    // If program tracing is being performed, and if the traces are being sent
    // to a file, the file is opened.  This call is made through a macro
    // so that no code will be generated for released builds.  Since this call
    // is made before the try clause, it is important that the function not
    // perform any operation that could throw an exception, such as a memory
    // allocation.
    //

    OPEN_TRACE_FILE();

    try
    {
        //
        // If a first argument is provided, it is the run period.
        //

        if (argc > 1)
        {
            int run_period = _ttoi(argv[1]);
            if (run_period <= 0)
            {
                PRINT_DEBUG_MSG((_T("GROVELER: run period must be greater than zero\n")));
                return ERROR_BAD_ARGUMENTS;
            }
            unsigned int start_time = GET_TICK_COUNT();
            event_timer.schedule(start_time + run_period, 0, halt);
        }

#if DEBUG_WAIT

        // When debugging the groveler as a service, if the process is attached
        // to a debugger after it has started, then the initialization code
        // will usually be executed before the debugger has a chance to break.
        // However, by defining DEBUG_WAIT to a non-zero value, the code will
        // get stuck in the following infinite loop before doing the bulk of
        // its initialization.  (The event_timer, eventlog, and sync_event
        // objects will have been constructed, because they are declared as
        // globals.)  The debugger can then be used to set debug_wait to false,
        // and debugging can commence with the subsequent code.
        bool debug_wait = true;
        while (debug_wait)
        {
            SLEEP(100);
        };

#endif // DEBUG_WAIT

        //
        //  Report the service has started
        //

        eventlog.report_event(GROVMSG_SERVICE_STARTED, ERROR_SUCCESS, 0);

        //
        //  Get READ parameters
        //

        ReadParameters read_parameters;
        ASSERT(read_parameters.parameter_backup_interval >= 0);

        //
        //  If we are not Groveling all paths, setup RISonly state
        //

        if (!GrovelAllPaths) {

            ConfigureRISOnlyState();

        } else {

            DPRINTF((L"Groveling ALL paths\n"));
        }

        //
        //  Open the drives
        //
                
        sis_drives.open();

        //
        //  See if there were any partions to scan.  If not, quit
        //

        num_partitions = sis_drives.partition_count();
        if (num_partitions == 0)
        {
            PRINT_DEBUG_MSG((_T("GROVELER: No local partitions have SIS installed.\n")));
            eventlog.report_event(GROVMSG_NO_PARTITIONS, ERROR_SUCCESS, 0);
            eventlog.report_event(GROVMSG_SERVICE_STOPPED, ERROR_SUCCESS, 0);
            return ERROR_SERVICE_NOT_ACTIVE;
        }

        //
        //  Report the service is running
        //

        SERVICE_REPORT_START();

        //
        //  Setup shared data are between all the worker threads
        //

        num_partitions = sis_drives.partition_count();

        _TCHAR **drive_names = new _TCHAR *[num_partitions];
        for (index = 0; index < num_partitions; index++)
        {
            drive_names[index] = sis_drives.partition_mount_name(index);
        }

        shared_data = new SharedData(num_partitions, drive_names);

        delete [] drive_names;

        //
        //  Get WRITE parameters
        //

        WriteParameters write_parameters(read_parameters.parameter_backup_interval);

        //
        //  Get excluded path list
        //

        PathList excluded_paths;

        //
        //  Setup LogDrive
        //

        log_drive = new LogDrive;

        Groveler::set_log_drive(sis_drives.partition_mount_name(log_drive->drive_index()));

        //
        //  Setup Groveler objects
        //

        grovelers = new Groveler[num_partitions];
        groveler_statuses = new GrovelStatus[num_partitions];

        //
        // Initially, the status of each partition is set to Grovel_disable so
        // that the close() member function of each Groveler object will not
        // be called unless the open() function is called first.
        //

        for (index = 0; index < num_partitions; index++)
        {
            groveler_statuses[index] = Grovel_disable;
        }

        //
        // Initially, the read_disk_info[] and write_disk_info[] arrays are set
        // to null, so that if an exception occurs, the code that deletes
        // allocated objects can check for a null to determine whether or not
        // the object has been instantiated.
        //

        read_disk_info = new ReadDiskInformation *[num_partitions];
        ZeroMemory(read_disk_info, sizeof(ReadDiskInformation *) * num_partitions);

        write_disk_info = new WriteDiskInformation *[num_partitions];
        ZeroMemory(write_disk_info, sizeof(WriteDiskInformation *) * num_partitions);

        //
        //  Now initilaize each partition
        //

        for (index = 0; index < num_partitions; index++)
        {
            read_disk_info[index] = new ReadDiskInformation(sis_drives.partition_guid_name(index));

            write_disk_info[index] = new WriteDiskInformation(sis_drives.partition_guid_name(index),read_parameters.parameter_backup_interval);

            if (read_disk_info[index]->enable_groveling)
            {
                groveler_statuses[index] = grovelers[index].open(
                            sis_drives.partition_guid_name(index),
                            sis_drives.partition_mount_name(index),
                            (index == log_drive->drive_index()),
                            read_parameters.read_report_discard_threshold,
                            read_disk_info[index]->min_file_size,
                            read_disk_info[index]->min_file_age,
                            read_disk_info[index]->allow_compressed_files,
                            read_disk_info[index]->allow_encrypted_files,
                            read_disk_info[index]->allow_hidden_files,
                            read_disk_info[index]->allow_offline_files,
                            read_disk_info[index]->allow_temporary_files,
                            write_disk_info[index]->grovelAllPathsState,
                            excluded_paths.num_paths[index],
                            excluded_paths.paths[index],
                            read_parameters.base_regrovel_interval,
                            read_parameters.max_regrovel_interval);

                ASSERT(groveler_statuses[index] != Grovel_disable);
            }

            //
            //  Set the new updated RSSonly state which will be saved on
            //  the next interval.
            //

            write_disk_info[index]->grovelAllPathsState = GrovelAllPaths;
            write_disk_info[index]->flush();

            if (groveler_statuses[index] == Grovel_ok)
            {
                log_drive->partition_initialized(index);
                eventlog.report_event(GROVMSG_GROVELER_STARTED, ERROR_SUCCESS,
                    1, sis_drives.partition_mount_name(index));
            }
            else if (groveler_statuses[index] == Grovel_disable)
            {
                eventlog.report_event(GROVMSG_GROVELER_DISABLED, ERROR_SUCCESS,
                    1, sis_drives.partition_mount_name(index));
            }
            else if (groveler_statuses[index] != Grovel_new)
            {
                ASSERT(groveler_statuses[index] == Grovel_error);
                eventlog.report_event(GROVMSG_GROVELER_NOSTART, ERROR_SUCCESS,
                    1, sis_drives.partition_mount_name(index));
            }
        }

        //
        // We have to pass a lot of information to the central controller that
        // it shouldn't really need.  However, if a groveler fails, this
        // information is needed to restart it.  It would be better if the
        // Groveler open() member function had a form that did not require
        // arguments, but rather re-used the arguments that had been passed in
        // previously.  But this is not how it currently works.
        //

        controller = new CentralController(
            num_partitions,
            grovelers,
            groveler_statuses,
            &read_parameters,
            &write_parameters,
            read_disk_info,
            write_disk_info,
            excluded_paths.num_paths,
            excluded_paths.paths);

        SERVICE_RECORD_PARTITION_INDICES();


        ASSERT(read_parameters.grovel_duration > 0);

        SERVICE_SET_MAX_RESPONSE_TIME(read_parameters.grovel_duration);

        //
        // If any grovelers are alive, tell the service control manager that
        // we have concluded the initialization, then commence running.
        //

        if (controller->any_grovelers_alive())
        {
            event_timer.run();
        }

        //
        // If tracing is being performed in delayed mode, print the trace log
        // now that the run has completed.
        //

        PRINT_TRACE_LOG();
    } catch (Exception exception) {
        switch (exception)
        {
            case exception_memory_allocation:
                eventlog.report_event(GROVMSG_MEMALLOC_FAILURE, ERROR_SUCCESS, 0);
                break;

            case exception_create_event:
                eventlog.report_event(GROVMSG_CREATE_EVENT_FAILURE, GetLastError(), 0);
                break;

            default:
                eventlog.report_event(GROVMSG_UNKNOWN_EXCEPTION, exception, 0);
                break;
        }
        exit_code = ERROR_EXCEPTION_IN_SERVICE;
    }

    //
    // If program tracing is being performed, and if the traces are being sent
    // to a file, the file is closed.  This call is made through a macro
    // so that no code will be generated for released builds.  Since the trace
    // file is being closed before the objects are deleted, it is important
    // not to write trace information in the destructor of an object.
    //

    CLOSE_TRACE_FILE();

    //
    // Close each groveler object that was opened.
    //

    if (groveler_statuses != 0 && grovelers != 0)
    {
        for (int i = 0; i < num_partitions; i++)
        {
            if (groveler_statuses[i] != Grovel_disable)
            {
                grovelers[i].close();
            }
        }
    }

    //
    // Delete all objects that were allocated.
    //

    if (groveler_statuses != 0)
    {
        delete[] groveler_statuses;
        groveler_statuses = 0;
    }

    if (grovelers != 0)
    {
        delete[] grovelers;
        grovelers = 0;
    }

    if (read_disk_info != 0)
    {
        for (int i = 0; i < num_partitions; i++)
        {
            if (read_disk_info[i] != 0)
            {
                delete read_disk_info[i];
                read_disk_info[i] = 0;
            }
        }
        delete[] read_disk_info;
        read_disk_info = 0;
    }

    if (write_disk_info != 0)
    {
        for (int i = 0; i < num_partitions; i++)
        {
            if (write_disk_info[i] != 0)
            {
                delete write_disk_info[i];
                write_disk_info[i] = 0;
            }
        }
        delete[] write_disk_info;
        write_disk_info = 0;
    }

    if (controller != 0)
    {
        delete controller;
        controller = 0;
    }

    if (shared_data != 0)
    {
        delete shared_data;
        shared_data = 0;
    }

    if (log_drive != 0)
    {
        delete log_drive;
        log_drive = 0;
    }

    eventlog.report_event(GROVMSG_SERVICE_STOPPED, ERROR_SUCCESS, 0);
    return exit_code;
}


//
//  This routine determines if we can grovel any volumes/files or only
//  RIS files
//

WCHAR RISPathNameKey[] = L"system\\CurrentControlSet\\Services\\tftpd\\parameters";
WCHAR RISPathNameValue[] = L"Directory";


VOID
ConfigureRISOnlyState()
{
    LONG status;
    HKEY keyHandle;
    DWORD valueType;
    DWORD nameSize;
    PWCHAR risName;
    DWORD bufsz;
    BOOL result;
    WCHAR volName[128];
    WCHAR volGuidName[128];

    __try {
        //
        //  Open the TFTPD registry key and see if it exists.  If not then RIS is
        //  not installed.  We will not grovel anything.
        //

        keyHandle = NULL;

        status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                               RISPathNameKey,
                               0,
                               KEY_ALL_ACCESS,
                               &keyHandle );

        if (status != ERROR_SUCCESS) {

            DPRINTF((L"ConfigureRISOnlyState: Error opening registry key \"%s\", status=%d\n",RISPathNameKey,status));
            __leave;
        }


        //
        //  Query the data of the given value entry.  Note that we are just
        //  getting the size of the string to allocate.
        //

        nameSize = 0;

        status = RegQueryValueEx( keyHandle,
                                  RISPathNameValue,
                                  NULL,
                                  &valueType,
                                  NULL,
                                  &nameSize );

        if (status != ERROR_SUCCESS) {

            DPRINTF((L"ConfigureRISOnlyState: Error querying the size of \"%s\" value, status=%d\n",RISPathNameValue,status));
            __leave;
        }

        if (valueType != REG_SZ) {

            DPRINTF((L"ConfigureRISOnlyState: Invalud value type of %d for \'%s\" value\n",valueType,RISPathNameValue));
            __leave;
        }

        //
        //  Allocate name buffer
        //

        risName = new WCHAR[(nameSize/sizeof(WCHAR))];

        //
        //  Now get the string value
        //

        status = RegQueryValueEx( keyHandle,
                                  RISPathNameValue,
                                  NULL,
                                  &valueType,
                                  (LPBYTE)risName,
                                  &nameSize );

        if (status != ERROR_SUCCESS) {

            DPRINTF((L"ConfigureRISOnlyState: Error querying the value of \"%s\", status=%d\n",RISPathNameValue,status));
            __leave;
        }

        //
        //  This will get the volume portion of the name.
        //

        result = GetVolumePathName( risName,
                                    volName,
                                    (sizeof(volName) / sizeof(WCHAR)));
                    
        if (!result) {

            DPRINTF((L"ConfigureRISOnlyState: Error querying the volume name of \"%s\", status=%d\n",risName,status));
            __leave;
        }

        if (_wcsnicmp(risName,volName,wcslen(volName)) != 0) {

            DPRINTF((L"ConfigureRISOnlyState: The queried volume name \"%s\" does not match the volume name portion of the original name \"%s\"\n",volName,risName));
            __leave;
        }

        //
        //  Get the volume GUID name
        //

        result = GetVolumeNameForVolumeMountPoint( volName,
                                                   volGuidName,
                                                   (sizeof(volGuidName) / sizeof(WCHAR)));
                                                   
        if (!result) {

            DPRINTF((L"ConfigureRISOnlyState: Error querying the volume GUID name of \"%s\", status=%d\n",volName,status));
            __leave;
        }

        //
        //  Now allocate buffers for everything and setup the globals
        //

        bufsz = wcslen(volGuidName)+1;
        RISVolumeGuidName = new WCHAR[bufsz];
        (void)StringCchCopy(RISVolumeGuidName, bufsz, volGuidName);

        bufsz = wcslen(volName)+1;
        RISVolumeName = new WCHAR[bufsz];
        (void)StringCchCopy(RISVolumeName, bufsz, volName);

        //
        //  Skip over the volume name at the front and point at the path
        //

        RISPath = risName + (wcslen(volName) - 1);  //we want to keep the beginning slash

    } __finally {

        if (keyHandle) {

            RegCloseKey( keyHandle );
        }
    }

    DPRINTF((L"GrovelAllPaths=%d\n"
             L"RisVolumeName=\"%s\"\n"
             L"RISVolumeGuidName=\"%s\"\n"
             L"RISPath=\"%s\"\n",
             GrovelAllPaths,
             RISVolumeName,
             RISVolumeGuidName,
             RISPath));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\grovctrl.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    grovctrl.cpp

Abstract:

    SIS Groveler controller main function

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

static _TCHAR *service_name = _T("Groveler");
static _TCHAR *service_path = _T("%SystemRoot%\\System32\\grovel.exe");

static const int num_actions = 3;

static Action actions[num_actions] =
{
    {_T("background"),  1,  command_service,            CMD_background, _T(" [drive_letter ...]")},
/*  {_T("continue"),    1,  control_service,            CTRL_continue,  _T("")},*/
    {_T("foreground"),  1,  command_service,            CMD_foreground, _T(" [drive_letter ...]")},
/*  {_T("install"),     3,  install_service,            0,              _T("")},*/
/*  {_T("interact"),    3,  set_service_interaction,    TRUE,           _T("")},*/
/*  {_T("nointeract"),  1,  set_service_interaction,    FALSE,          _T("")},*/
/*  {_T("pause"),       1,  control_service,            CTRL_pause,     _T("")},*/
/*  {_T("remove"),      1,  remove_service,             0,              _T("")},*/
/*  {_T("start"),       3,  start_service,              0,              _T("")},*/
/*  {_T("stop"),        3,  control_service,            CTRL_stop,      _T("")},*/
    {_T("volscan"),     1,  command_service,            CMD_volscan,    _T(" [drive_letter ...]")}
};

static const int perf_value_count = 4;

static _TCHAR *perf_tags[perf_value_count] =
{
    _T("Library"),
    _T("Open"),
    _T("Collect"),
    _T("Close")
};

static _TCHAR *perf_values[perf_value_count] =
{
    _T("grovperf.dll"),
    _T("OpenGrovelerPerformanceData"),
    _T("CollectGrovelerPerformanceData"),
    _T("CloseGrovelerPerformanceData")
};

void
usage(
    _TCHAR *progname,
    _TCHAR *prefix = NULL)
{
    if (prefix != NULL)
    {
        _ftprintf(stderr, _T("unrecognized or ambiguous command: %s\n\n"),
            prefix);
    }

    _ftprintf(stderr, _T("usage:\n"));
    for (int index = 0; index < num_actions; index++)
    {
        _TCHAR *arg = actions[index].arg;
        int min_chars = actions[index].min_character_count;
        _ftprintf(stderr, _T("\t%s %.*s[%s]%s\n"), progname, min_chars,
                arg, &arg[min_chars], actions[index].help);
    }
}

void
display_error(
    DWORD err = 0)
{
    void *buffer = 0;
    if (err == 0)
    {
        err = GetLastError();
    }
    DWORD lang = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);
    DWORD result = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM
        | FORMAT_MESSAGE_IGNORE_INSERTS, 0, err, lang, (LPTSTR) &buffer, 0, 0);
    if (result != 0)
    {
        ASSERT(buffer != 0);
        _ftprintf(stderr, (_TCHAR *)buffer);
    }
    else
    {
        _ftprintf(stderr, _T("error number = %d\n"), err);
    }
    if (buffer != 0)
    {
        LocalFree(buffer);
    }
}

extern "C" __cdecl _tmain(int argc, _TCHAR **argv)
{
    if (argc < 2)
    {
        usage(argv[0]);
        return 1;
    }
    int arglen = _tcslen(argv[1]);
    for (int index = 0; index < num_actions; index++)
    {
        if (arglen >= actions[index].min_character_count &&
            _tcsncicmp(argv[1], actions[index].arg, arglen) == 0)
        {
            break;
        }
    }
    if (index < num_actions)
    {
        Function function = actions[index].function;
        int flag = actions[index].flag;
        ASSERT(function != 0);
        int exit_code = (*function)(flag, argc - 2, &argv[2]);
        return exit_code;
    }
    else
    {
        usage(argv[0], argv[1]);
        return 1;
    }
}

//int
//install_service(
//  int dummy,
//  int argc,
//  _TCHAR **argv)
//{
//  SC_HANDLE sc_manager = OpenSCManager(0, 0, SC_MANAGER_ALL_ACCESS);
//  if (sc_manager == 0)
//  {
//      display_error();
//      return 1;
//  }
//  SC_HANDLE service = CreateService(sc_manager, service_name,
//      service_name, SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
//      SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL, service_path,
//      0, 0, 0, 0, 0);
//  if (service == 0)
//  {
//      display_error();
//      CloseServiceHandle(sc_manager);
//      return 1;
//  }
//  _ftprintf(stderr, _T("Service installed\n"));
//  CloseServiceHandle(service);
//  CloseServiceHandle(sc_manager);
//#if DBG
//  load_counters();
//#endif // DBG
//  return 0;
//}
//
//int remove_service(
//  int dummy,
//  int argc,
//  _TCHAR **argv)
//{
//#if DBG
//  unload_counters();
//#endif // DBG
//  SC_HANDLE sc_manager = OpenSCManager(0, 0, SC_MANAGER_ALL_ACCESS);
//  if (sc_manager == 0)
//  {
//      display_error();
//      return 1;
//  }
//  SC_HANDLE service =
//      OpenService(sc_manager, service_name, SERVICE_ALL_ACCESS);
//  if (service == 0)
//  {
//      display_error();
//      CloseServiceHandle(sc_manager);
//      return 1;
//  }
//  SERVICE_STATUS status;
//  int ok = QueryServiceStatus(service, &status);
//  if (ok && status.dwCurrentState != SERVICE_STOPPED)
//  {
//      ok = ControlService(service, SERVICE_CONTROL_STOP, &status);
//      while (ok && status.dwCurrentState == SERVICE_STOP_PENDING)
//      {
//          Sleep(100);
//          ok = QueryServiceStatus(service, &status);
//      }
//      if (!ok)
//      {
//          display_error();
//          CloseServiceHandle(service);
//          CloseServiceHandle(sc_manager);
//          return 1;
//      }
//      else if (status.dwCurrentState != SERVICE_STOPPED)
//      {
//          _ftprintf(stderr,
//              _T("Unable to stop service\nService not removed\n"));
//          CloseServiceHandle(service);
//          CloseServiceHandle(sc_manager);
//          return 1;
//      }
//  }
//  ok = DeleteService(service);
//  if (!ok)
//  {
//      display_error();
//      CloseServiceHandle(service);
//      CloseServiceHandle(sc_manager);
//      return 1;
//  }
//  _ftprintf(stderr, _T("Service removed\n"));
//  CloseServiceHandle(service);
//  CloseServiceHandle(sc_manager);
//  return 0;
//}

//int
//set_service_interaction(
//  int interactive,
//  int argc,
//  _TCHAR **argv)
//{
//  SC_HANDLE sc_manager = OpenSCManager(0, 0, SC_MANAGER_ALL_ACCESS);
//  if (sc_manager == 0)
//  {
//      display_error();
//      return 1;
//  }
//  SC_LOCK sc_lock = LockServiceDatabase(sc_manager);
//  if (sc_lock == 0)
//  {
//      display_error();
//      CloseServiceHandle(sc_manager);
//      return 1;
//  }
//  SC_HANDLE service =
//      OpenService(sc_manager, service_name, SERVICE_ALL_ACCESS);
//  if (service == 0)
//  {
//      display_error();
//      UnlockServiceDatabase(sc_lock);
//      CloseServiceHandle(sc_manager);
//      return 1;
//  }
//  DWORD service_type = SERVICE_WIN32_OWN_PROCESS;
//  if (interactive)
//  {
//      service_type |= SERVICE_INTERACTIVE_PROCESS;
//  }
//  int ok = ChangeServiceConfig(service, service_type,
//      SERVICE_NO_CHANGE, SERVICE_NO_CHANGE, 0, 0, 0, 0, 0, 0, 0);
//  if (!ok)
//  {
//      display_error();
//      CloseServiceHandle(service);
//      CloseServiceHandle(sc_manager);
//      return 1;
//  }
//  if (interactive)
//  {
//      _ftprintf(stderr, _T("Service configured for interaction\n"));
//  }
//  else
//  {
//      _ftprintf(stderr, _T("Service configured for no interaction\n"));
//  }
//  CloseServiceHandle(service);
//  UnlockServiceDatabase(sc_lock);
//  CloseServiceHandle(sc_manager);
//  return 0;
//}

//int start_service(
//  int dummy,
//  int argc,
//  _TCHAR **argv)
//{
//  SC_HANDLE sc_manager = OpenSCManager(0, 0, SC_MANAGER_ALL_ACCESS);
//  if (sc_manager == 0)
//  {
//      display_error();
//      return 1;
//  }
//  SC_HANDLE service =
//      OpenService(sc_manager, service_name, SERVICE_ALL_ACCESS);
//  if (service == 0)
//  {
//      display_error();
//      CloseServiceHandle(sc_manager);
//      return 1;
//  }
//  SERVICE_STATUS status;
//  int ok = StartService(service, 0, 0);
//  if (!ok)
//  {
//      display_error();
//      CloseServiceHandle(service);
//      CloseServiceHandle(sc_manager);
//      return 1;
//  }
//  ok = QueryServiceStatus(service, &status);
//  while (ok && status.dwCurrentState == SERVICE_START_PENDING)
//  {
//      Sleep(100);
//      ok = QueryServiceStatus(service, &status);
//  }
//  if (!ok)
//  {
//      display_error();
//      CloseServiceHandle(service);
//      CloseServiceHandle(sc_manager);
//      return 1;
//  }
//  else if (status.dwCurrentState != SERVICE_RUNNING)
//  {
//      _ftprintf(stderr, _T("Service not started"));
//      CloseServiceHandle(service);
//      CloseServiceHandle(sc_manager);
//      return 1;
//  }
//  _ftprintf(stderr, _T("Service started\n"));
//  CloseServiceHandle(service);
//  CloseServiceHandle(sc_manager);
//  return 0;
//}

//int control_service(
//  int control,
//  int argc,
//  _TCHAR **argv)
//{
//  DWORD control_code;
//  DWORD pending_state;
//  DWORD target_state;
//  _TCHAR *good_message;
//  _TCHAR *bad_message;
//  switch (control)
//  {
//  case CTRL_stop:
//      control_code = SERVICE_CONTROL_STOP;
//      pending_state = SERVICE_STOP_PENDING;
//      target_state = SERVICE_STOPPED;
//      good_message = _T("Service stopped\n");
//      bad_message = _T("Service not stopped\n");
//      break;
//  case CTRL_pause:
//      control_code = SERVICE_CONTROL_PAUSE;
//      pending_state = SERVICE_PAUSE_PENDING;
//      target_state = SERVICE_PAUSED;
//      good_message = _T("Service paused\n");
//      bad_message = _T("Service not paused\n");
//      break;
//  case CTRL_continue:
//      control_code = SERVICE_CONTROL_CONTINUE;
//      pending_state = SERVICE_CONTINUE_PENDING;
//      target_state = SERVICE_RUNNING;
//      good_message = _T("Service continued\n");
//      bad_message = _T("Service not continued\n");
//      break;
//  default:
//      return 1;
//  }
//  SC_HANDLE sc_manager = OpenSCManager(0, 0, SC_MANAGER_ALL_ACCESS);
//  if (sc_manager == 0)
//  {
//      display_error();
//      return 1;
//  }
//  SC_HANDLE service =
//      OpenService(sc_manager, service_name, SERVICE_ALL_ACCESS);
//  if (service == 0)
//  {
//      display_error();
//      CloseServiceHandle(sc_manager);
//      return 1;
//  }
//  SERVICE_STATUS status;
//  int ok = ControlService(service, control_code, &status);
//  while (ok && status.dwCurrentState == pending_state)
//  {
//      Sleep(100);
//      ok = QueryServiceStatus(service, &status);
//  }
//  if (!ok)
//  {
//      display_error();
//      CloseServiceHandle(service);
//      CloseServiceHandle(sc_manager);
//      return 1;
//  }
//  else if (status.dwCurrentState != target_state)
//  {
//      _ftprintf(stderr, bad_message);
//      CloseServiceHandle(service);
//      CloseServiceHandle(sc_manager);
//      return 1;
//  }
//  _ftprintf(stderr, good_message);
//  CloseServiceHandle(service);
//  CloseServiceHandle(sc_manager);
//  return 0;
//}

int command_service(
    int command,
    int argc,
    _TCHAR **argv)
{
    DWORD control_code;
    _TCHAR *message;
    switch (command)
    {
    case CMD_foreground:
        control_code = SERVICE_CONTROL_FOREGROUND;
        message = _T("Service mode set to foreground");
        break;
    case CMD_background:
        control_code = SERVICE_CONTROL_BACKGROUND;
        message = _T("Service mode set to background");
        break;
    case CMD_volscan:
        control_code = SERVICE_CONTROL_VOLSCAN;
        message = _T("Volume scan initiated");
        break;
    default:
        return 1;
    }
    SC_HANDLE sc_manager = OpenSCManager(0, 0, SC_MANAGER_ALL_ACCESS);
    if (sc_manager == 0)
    {
        display_error();
        return 1;
    }
    SC_HANDLE service =
        OpenService(sc_manager, service_name, SERVICE_ALL_ACCESS);
    if (service == 0)
    {
        display_error();
        CloseServiceHandle(sc_manager);
        return 1;
    }
    int exit_code = 0;
    SERVICE_STATUS status;
    if (argc > 0)
    {
        for (int index = 0; index < argc; index++)
        {
            _TCHAR drive_letter = argv[index][0];
            ASSERT(drive_letter != 0);
            if (drive_letter >= _T('a') && drive_letter <= _T('z')
                || drive_letter >= _T('A') && drive_letter <= _T('Z'))
            {
                DWORD drive_spec = SERVICE_CONTROL_PARTITION_MASK &
                    (DWORD)(_totlower(drive_letter) - _T('a'));
                int ok = ControlService(service,
                    control_code | drive_spec, &status);
                if (ok)
                {
                    _ftprintf(stderr, _T("%s on drive %c\n"),
                        message, drive_letter);
                }
                else
                {
                    display_error();
                    exit_code++;
                }
            }
            else
            {
                _ftprintf(stderr, _T("Invalid drive letter: %c\n"),
                    drive_letter);
                exit_code++;
            }
        }
    }
    else
    {
        int ok = ControlService(service,
            control_code | SERVICE_CONTROL_ALL_PARTITIONS, &status);
        if (ok)
        {
            _ftprintf(stderr, _T("%s on all drives\n"), message);
        }
        else
        {
            display_error();
            exit_code++;
        }
    }
    CloseServiceHandle(service);
    CloseServiceHandle(sc_manager);
    return 0;
}

//int load_counters()
//{
//  HKEY grovperf_key = 0;
//  HKEY perflib_key = 0;
//  _TCHAR grovperf_path[1024];
//  _stprintf(grovperf_path,
//      _T("SYSTEM\\CurrentControlSet\\Services\\%s\\Performance"),
//      service_name);
//  bool ok = Registry::write_string_set(HKEY_LOCAL_MACHINE, grovperf_path,
//      perf_value_count, perf_values, perf_tags);
//  if (!ok)
//  {
//      display_error();
//      _ftprintf(stderr, _T("Unable to configure performance counters\n"));
//      return 1;
//  }
//  _ftprintf(stderr, _T("Adding counter names and explain text for %s\n"),
//      service_name);
//  try
//  {
//      Registry::open_key_ex(HKEY_LOCAL_MACHINE, grovperf_path, 0,
//          KEY_ALL_ACCESS, &grovperf_key);
//      Registry::open_key_ex(HKEY_LOCAL_MACHINE,
//          _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib"),
//          0, KEY_ALL_ACCESS, &perflib_key);
//      DWORD last_counter = 0;
//      DWORD ctr_size = sizeof(DWORD);
//      Registry::query_value_ex(perflib_key, _T("Last Counter"), 0, 0,
//          (BYTE *)&last_counter, &ctr_size);
//      DWORD last_help = 0;
//      ctr_size = sizeof(DWORD);
//      Registry::query_value_ex(perflib_key, _T("Last Help"), 0, 0,
//          (BYTE *)&last_help, &ctr_size);
//      DWORD current_counter;
//      DWORD current_help;
//      for (int language = 0; language < num_languages; language++)
//      {
//          HKEY lang_key = 0;
//          BYTE *counter_text = 0;
//          BYTE *help_text = 0;
//          try
//          {
//              Registry::open_key_ex(perflib_key, language_codes[language], 0,
//                  KEY_ALL_ACCESS, &lang_key);
//              Registry::query_value_ex(lang_key, _T("Counter"), 0, 0, 0,
//                  &ctr_size);
//              counter_text =
//                  new BYTE[ctr_size + num_perf_counters * 64];
//              Registry::query_value_ex(lang_key, _T("Counter"), 0, 0,
//                  counter_text, &ctr_size);
//              DWORD help_size;
//              Registry::query_value_ex(lang_key, _T("Help"), 0, 0, 0,
//                  &help_size);
//              help_text = new BYTE[help_size + num_perf_counters * 256];
//              Registry::query_value_ex(lang_key, _T("Help"), 0, 0,
//                  help_text, &help_size);
//              current_counter = last_counter;
//              current_help = last_help;
//              _TCHAR *counter_point =
//                  (_TCHAR *)(counter_text + ctr_size - sizeof(_TCHAR));
//              _TCHAR *help_point =
//                  (_TCHAR *)(help_text + help_size - sizeof(_TCHAR));
//              current_counter += 2;
//              int chars_written =
//                  _stprintf(counter_point, _T("%d%c%s%c"), current_counter,
//                  0, object_info.text[language].counter_name, 0);
//              counter_point += chars_written;
//              ctr_size += chars_written * sizeof(_TCHAR);
//              current_help += 2;
//              chars_written =
//                  _stprintf(help_point, _T("%d%c%s%c"), current_help, 0,
//                  object_info.text[language].counter_help, 0);
//              help_point += chars_written;
//              help_size += chars_written * sizeof(_TCHAR);
//              for (int index = 0; index < num_perf_counters; index++)
//              {
//                  current_counter += 2;
//                  chars_written = _stprintf(counter_point, _T("%d%c%s%c"),
//                      current_counter, 0,
//                      counter_info[index].text[language].counter_name, 0);
//                  counter_point += chars_written;
//                  ctr_size += chars_written * sizeof(_TCHAR);
//                  current_help += 2;
//                  chars_written = _stprintf(help_point, _T("%d%c%s%c"),
//                      current_help, 0,
//                      counter_info[index].text[language].counter_help, 0);
//                  help_point += chars_written;
//                  help_size += chars_written * sizeof(_TCHAR);
//              }
//              Registry::set_value_ex(lang_key, _T("Counter"), 0,
//                  REG_MULTI_SZ, counter_text, ctr_size);
//              Registry::set_value_ex(lang_key, _T("Help"), 0,
//                  REG_MULTI_SZ, help_text, help_size);
//              delete[] counter_text;
//              delete[] help_text;
//              RegCloseKey(lang_key);
//              lang_key = 0;
//              _ftprintf(stderr, _T("Updating text for language %s\n"),
//                  language_codes[language]);
//          }
//          catch (DWORD)
//          {
//              if (counter_text != 0)
//              {
//                  delete[] counter_text;
//                  counter_text = 0;
//              }
//              if (help_text != 0)
//              {
//                  delete[] help_text;
//                  help_text = 0;
//              }
//              if (lang_key != 0)
//              {
//                  RegCloseKey(lang_key);
//                  lang_key = 0;
//              }
//          }
//      }
//      Registry::set_value_ex(perflib_key, _T("Last Counter"), 0, REG_DWORD,
//          (BYTE *)&current_counter, sizeof(DWORD));
//      Registry::set_value_ex(perflib_key, _T("Last Help"), 0, REG_DWORD,
//          (BYTE *)&current_help, sizeof(DWORD));
//      DWORD first_counter = last_counter + 2;
//      DWORD first_help = last_help + 2;
//      Registry::set_value_ex(grovperf_key, _T("First Counter"), 0, REG_DWORD,
//          (BYTE *)&first_counter, sizeof(DWORD));
//      Registry::set_value_ex(grovperf_key, _T("First Help"), 0, REG_DWORD,
//          (BYTE *)&first_help, sizeof(DWORD));
//      Registry::set_value_ex(grovperf_key, _T("Last Counter"), 0, REG_DWORD,
//          (BYTE *)&current_counter, sizeof(DWORD));
//      Registry::set_value_ex(grovperf_key, _T("Last Help"), 0, REG_DWORD,
//          (BYTE *)&current_help, sizeof(DWORD));
//      Registry::close_key(grovperf_key);
//      grovperf_key = 0;
//      Registry::close_key(perflib_key);
//      perflib_key = 0;
//  }
//  catch (DWORD)
//  {
//      if (grovperf_key != 0)
//      {
//          RegCloseKey(grovperf_key);
//          grovperf_key = 0;
//      }
//      if (perflib_key != 0)
//      {
//          RegCloseKey(perflib_key);
//          perflib_key = 0;
//      }
//      _ftprintf(stderr, _T("Unable to configure performance counters\n"));
//      return 1;
//  }
//  return 0;
//}

//int unload_counters()
//{
//  STARTUPINFO startupinfo;
//  PROCESS_INFORMATION process_information;
//  startupinfo.cb = sizeof(STARTUPINFO);
//  startupinfo.lpReserved = 0;
//  startupinfo.lpDesktop = 0;
//  startupinfo.lpTitle = 0;
//  startupinfo.dwFlags = 0;
//  startupinfo.cbReserved2 = 0;
//  startupinfo.lpReserved2 = 0;
//  int pathlen = GetSystemDirectory(0, 0);
//  if (pathlen == 0)
//  {
//      display_error();
//      return 1;
//  }
//  _TCHAR *command_line = new _TCHAR[pathlen + 64];
//  pathlen = GetSystemDirectory(command_line, pathlen);
//  if (pathlen == 0)
//  {
//      delete[] command_line;
//      display_error();
//      return 1;
//  }
//  _stprintf(&command_line[pathlen], _T("\\unlodctr.exe \"%s\""),
//      service_name);
//  BOOL ok = CreateProcess(0, command_line,
//      0, 0, FALSE, 0, 0, 0, &startupinfo, &process_information);
//  if (!ok)
//  {
//      delete[] command_line;
//      display_error();
//      return 1;
//  }
//  delete[] command_line;
//  DWORD result = WaitForSingleObject(process_information.hProcess, 5000);
//  _tprintf(_T("\n"));
//  if (result != WAIT_OBJECT_0)
//  {
//      return 1;
//  }
//  return 0;
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\groveler.cpp ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    groveler.cpp

Abstract:

    SIS Groveler file groveling functions

Authors:

    Cedric Krumbein, 1998

Environment:

    User Mode

Revision History:

--*/

#include "all.hxx"

#define CLEAR_FILE(FILE) ( \
    (FILE).entry.fileID           = 0, \
    (FILE).entry.fileSize         = 0, \
    (FILE).entry.signature        = 0, \
    (FILE).entry.attributes       = 0, \
    (FILE).entry.csIndex          = nullCSIndex, \
    (FILE).entry.createTime       = 0, \
    (FILE).entry.writeTime        = 0, \
    (FILE).parentID               = 0, \
    (FILE).retryTime              = 0, \
    (FILE).startTime              = 0, \
    (FILE).stopTime               = 0, \
    (FILE).readSynch.Internal     = 0, \
    (FILE).readSynch.InternalHigh = 0, \
    (FILE).readSynch.Offset       = 0, \
    (FILE).readSynch.OffsetHigh   = 0, \
    (FILE).fileName[0]            = _T('\0') )

#define CLEAR_OVERLAPPED(OVERLAPPED) ( \
    (OVERLAPPED).Internal     = 0, \
    (OVERLAPPED).InternalHigh = 0, \
    (OVERLAPPED).Offset       = 0, \
    (OVERLAPPED).OffsetHigh   = 0 )

// Is CS index set?

static const CSID nullCSIndex = {
    0, 0, 0,
    _T('\0'), _T('\0'), _T('\0'), _T('\0'),
    _T('\0'), _T('\0'), _T('\0'), _T('\0')
};

#define HasCSIndex(CSID) \
    (memcmp(&(CSID), &nullCSIndex, sizeof(CSID)) != 0)

#define SameCSIndex(CSID1, CSID2) \
    (memcmp(&(CSID1), &(CSID2), sizeof(CSID)) == 0)

// Exceptions

enum TerminalException {
    INITIALIZE_ERROR,
    DATABASE_ERROR,
    MEMORY_ERROR,
    TERMINATE
};

enum TargetException {
    TARGET_INVALID,
    TARGET_ERROR
};

enum MatchException {
    MATCH_INVALID,
    MATCH_ERROR,
    MATCH_STALE
};

/*****************************************************************************/
/************************** Miscellaneous functions **************************/
/*****************************************************************************/

// NewHandler() is installed by _set_new_handler() to throw an
// exception when the system can't allocate any more memory.

static INT __cdecl NewHandler(size_t size)
{
    throw MEMORY_ERROR;
    return 0; // Dummy return
}

/*****************************************************************************/

// FileIDCompare() is used by qsort() and bsearch()
// to sort or look up a matching file ID.

static INT __cdecl FileIDCompare(
    const VOID *id1,
    const VOID *id2)
{
    DWORDLONG fileID1 = *(DWORDLONG *)id1,
              fileID2 = *(DWORDLONG *)id2;

    return fileID1 < fileID2 ? -1
         : fileID1 > fileID2 ? +1
         :                      0;
}

/*****************************************************************************/

// qsStringCompare() is used by qsort() to sort an array of character strings.

static INT __cdecl qsStringCompare(
    const VOID *str1,
    const VOID *str2)
{
    return _tcsicmp(*(TCHAR **)str1, *(TCHAR **)str2);
}

/*****************************************************************************/

// bsStringCompare() is used by bsearch() look up a matching character string.
// It is assumed that str1 is the path name string we are searching for and
// str2 is the excluded path name string in the excluded paths list.  Note
// that if the excluded path is \a\b, then we return a match on anything that
// is in this directory or subdirectory, as well as an exact match.
// E.g.:  \a\b\c\d.foo & \a\b\foo will match, but \a\b.foo will not.

static INT __cdecl bsStringCompare(
    const VOID *str1,
    const VOID *str2)
{
    TCHAR *s1 = *(TCHAR **) str1;
    TCHAR *s2 = *(TCHAR **) str2;

// str2 is the excluded name.  Make sure we catch subdirectories under it,
// but make sure we don't confuse \a\bx with \a\b

    size_t l = _tcslen(s2);
    INT r = _tcsnicmp(s1, s2, l);

    if (0 == r)
        if (_tcslen(s1) > l && _T('\\') != s1[l])
            r = 1;

    return r;
}

/*****************************************************************************/
/********************** Groveler class private methods ***********************/
/*****************************************************************************/

// IsAllowedID() returns FALSE if the directory or file ID
// is on the list of disallowed IDs, and TRUE otherwise.

BOOL Groveler::IsAllowedID(DWORDLONG fileID) const
{
    BOOL result;
    ASSERT(fileID != 0);

    if (numDisallowedIDs == 0) {

        ASSERT(disallowedIDs == NULL);
        result = TRUE;

    } else {

        ASSERT(disallowedIDs != NULL);
        result = bsearch( &fileID,
                          disallowedIDs,
                          numDisallowedIDs,
                          sizeof(DWORDLONG),
                          FileIDCompare) == NULL;
    }

    DPRINTF((L"IsAllowedID: %04I64x.%012I64x, (%s)\n", 
             ((fileID >> 48) & 0xffff), 
             (fileID & 0xffffffffffff),
             result ? L"yes" : L"no"));

    return result;
}

/*****************************************************************************/

// IsAllowedName() returns FALSE if the directory or file name
// is on the list of disallowed names, and TRUE otherwise.

BOOL Groveler::IsAllowedName(TCHAR *fileName) const
{
    BOOL result;
    ASSERT(fileName != NULL);

    if (numDisallowedNames == 0) {

        ASSERT(disallowedNames == NULL);
        result = TRUE;

    } else {

        ASSERT(disallowedNames != NULL);

        result = (bsearch( &fileName,
                           disallowedNames,
                           numDisallowedNames,
                           sizeof(TCHAR *),
                           bsStringCompare) == NULL);
    }

    //
    //  The name wasn't on the disallowed list, see if the GrovelAllPaths option
    //  is set.  If not then it must be in the RIS valid path, check for it.
    //

    if (result && !GrovelAllPaths && (RISPath != NULL)) {

        //
        //  Do not do this cheeck if this is the root directory of the volume
        //

        if (wcscmp(fileName,L"\\") != 0) {

            result = (bsStringCompare(&fileName,&RISPath) == 0);
        }
    }

    DPRINTF((L"IsAllowedName: \"%s\", (%s)\n", fileName, result ? L"yes" : L"no"));

    return result;
}

/*****************************************************************************/

// WaitForEvent suspends the thread until the specified event is set.

VOID Groveler::WaitForEvent(HANDLE event)
{
    DWORD eventNum;

    BOOL success;

    ASSERT(event != NULL);

    eventNum = WaitForSingleObject(event, INFINITE);
    ASSERT_ERROR(eventNum == WAIT_OBJECT_0);

    success = ResetEvent(event);
    ASSERT_ERROR(success);
}

/*****************************************************************************/

// OpenFileByID() opens the file with the given volumeHandle and fileID.

BOOL Groveler::OpenFileByID(
    FileData *file,
    BOOL      writeEnable)
{
    UNICODE_STRING fileIDString;

    OBJECT_ATTRIBUTES objectAttributes;

    IO_STATUS_BLOCK ioStatusBlock;

    NTSTATUS ntStatus;

    ASSERT(volumeHandle       != NULL);
    ASSERT(file               != NULL);
    ASSERT(file->entry.fileID != 0);
    ASSERT(file->handle       == NULL);

    fileIDString.Length        = sizeof(DWORDLONG);
    fileIDString.MaximumLength = sizeof(DWORDLONG);
    fileIDString.Buffer        = (WCHAR *)&file->entry.fileID;

    objectAttributes.Length                   = sizeof(OBJECT_ATTRIBUTES);
    objectAttributes.RootDirectory            = volumeHandle;
    objectAttributes.ObjectName               = &fileIDString;
    objectAttributes.Attributes               = OBJ_CASE_INSENSITIVE;
    objectAttributes.SecurityDescriptor       = NULL;
    objectAttributes.SecurityQualityOfService = NULL;

    ntStatus = NtCreateFile(
        &file->handle,
        GENERIC_READ |
        (writeEnable ? GENERIC_WRITE : 0),
        &objectAttributes,
        &ioStatusBlock,
        NULL,
        0,
        FILE_SHARE_READ   |
        FILE_SHARE_DELETE |
        (writeEnable ? FILE_SHARE_WRITE : 0),
        FILE_OPEN,
        FILE_OPEN_BY_FILE_ID    |
        FILE_OPEN_REPARSE_POINT |
        FILE_NO_INTERMEDIATE_BUFFERING,
        NULL,
        0);

    if (ntStatus == STATUS_SUCCESS) {
        DWORD bytesReturned;
        MARK_HANDLE_INFO markHandleInfo =
            {USN_SOURCE_DATA_MANAGEMENT, volumeHandle, 0};

// Mark the handle so the usn entry for the merge operation (if completed)
// can be detected and skipped.

        BOOL rc = DeviceIoControl(
                    file->handle,
                    FSCTL_MARK_HANDLE,
                    &markHandleInfo,
                    sizeof markHandleInfo,
                    NULL,
                    0,
                    &bytesReturned,
                    NULL);

        if (!rc) {
            DPRINTF((_T("%s: FSCTL_MARK_HANDLE failed, %lu\n"),
                driveLetterName, GetLastError()));
        }

#if DBG

// Get the file name
        {
            HRESULT r;


            ASSERT(file->fileName[0] == _T('\0'));

            struct TFileName2 {
                ULONG nameLen;
                TCHAR name[MAX_PATH+1];
            } tFileName[1];

            ntStatus = NtQueryInformationFile(
                file->handle,
                &ioStatusBlock,
                tFileName,
                sizeof tFileName,
                FileNameInformation);

            if (ntStatus == STATUS_SUCCESS) {
                
                r = StringCbCopyN(file->fileName,
                                   sizeof(file->fileName),
                                   tFileName->name,
                                   tFileName->nameLen);

                ASSERT(r == S_OK);

            } else {

                r = StringCbCopy(file->fileName,
                                 sizeof(file->fileName),
                                 L"<unresolved name>");

                ASSERT(r == S_OK);
            }
        }
#endif

        return TRUE;
    }

    ASSERT(file->handle == NULL);
    SetLastError(RtlNtStatusToDosError(ntStatus));
    return FALSE;
}

/*****************************************************************************/

// OpenFileByName() opens the file with the given fileName.

BOOL Groveler::OpenFileByName(
    FileData *file,
    BOOL      writeEnable,
    TCHAR    *fileName)
{
    UNICODE_STRING dosPathName,
                   ntPathName;

    OBJECT_ATTRIBUTES objectAttributes;

    IO_STATUS_BLOCK ioStatusBlock;

    NTSTATUS ntStatus;

    ASSERT(file         != NULL);
    ASSERT(file->handle == NULL);

    if (fileName == NULL)
        fileName = file->fileName;
    ASSERT(fileName[0] != _T('\0'));

#ifdef _UNICODE
    dosPathName.Buffer = fileName;
#else
    if (!RtlCreateUnicodeStringFromAsciiz(&dosPathName, fileName)) {
        ntStatus = STATUS_NO_MEMORY;
        goto Error;
    }
#endif

    if (RtlDosPathNameToNtPathName_U(dosPathName.Buffer, &ntPathName, NULL, NULL)) {

        objectAttributes.Length                   = sizeof(OBJECT_ATTRIBUTES);
        objectAttributes.RootDirectory            = NULL;
        objectAttributes.ObjectName               = &ntPathName;
        objectAttributes.Attributes               = OBJ_CASE_INSENSITIVE;
        objectAttributes.SecurityDescriptor       = NULL;
        objectAttributes.SecurityQualityOfService = NULL;

        ntStatus = NtCreateFile(
            &file->handle,
            GENERIC_READ |
            (writeEnable ? GENERIC_WRITE : 0),
            &objectAttributes,
            &ioStatusBlock,
            NULL,
            0,
            FILE_SHARE_READ   |
            FILE_SHARE_DELETE |
            (writeEnable ? FILE_SHARE_WRITE : 0),
            FILE_OPEN,
            FILE_OPEN_REPARSE_POINT |
            FILE_NO_INTERMEDIATE_BUFFERING,
            NULL,
            0);

        RtlFreeUnicodeString(&ntPathName);

    } else {
        ntStatus = STATUS_NO_MEMORY;
    }

#ifndef _UNICODE
    RtlFreeUnicodeString(&dosPathName);
#endif

    if (ntStatus == STATUS_SUCCESS) {
        DWORD bytesReturned;
        MARK_HANDLE_INFO markHandleInfo =
            {USN_SOURCE_DATA_MANAGEMENT, volumeHandle, 0};

// Mark the handle so the usn entry for the merge operation (if completed)
// can be detected and skipped.

        BOOL rc = DeviceIoControl(
                    file->handle,
                    FSCTL_MARK_HANDLE,
                    &markHandleInfo,
                    sizeof markHandleInfo,
                    NULL,
                    0,
                    &bytesReturned,
                    NULL);

        if (!rc) {
            DPRINTF((_T("%s: FSCTL_MARK_HANDLE failed, %lu\n"),
                driveLetterName, GetLastError()));
        }
        return TRUE;
    }

    ASSERT(file->handle == NULL);
    SetLastError(RtlNtStatusToDosError(ntStatus));
    return FALSE;
}

/*****************************************************************************/

// IsFileMapped() checks if the file is mapped by another user.

BOOL Groveler::IsFileMapped(FileData *file)
{
    _SIS_LINK_FILES sisLinkFiles;

    DWORD transferCount;

    BOOL success;

    ASSERT(grovHandle != NULL);
    ASSERT(file->handle != NULL);

    sisLinkFiles.operation          = SIS_LINK_FILES_OP_VERIFY_NO_MAP;
    sisLinkFiles.u.VerifyNoMap.file = file->handle;

    success = DeviceIoControl(
        grovHandle,
        FSCTL_SIS_LINK_FILES,
        (VOID *)&sisLinkFiles,
        sizeof(_SIS_LINK_FILES),
        NULL,
        0,
        &transferCount,
        NULL);

    if (success)
        return FALSE;

    ASSERT(GetLastError() == ERROR_SHARING_VIOLATION);
    return TRUE;
}

/*****************************************************************************/

// SetOplock() sets an oplock on the open file.

BOOL Groveler::SetOplock(FileData *file)
{
    BOOL success;

    ASSERT(file                      != NULL);
    ASSERT(file->handle              != NULL);
    ASSERT(file->oplock.Internal     == 0);
    ASSERT(file->oplock.InternalHigh == 0);
    ASSERT(file->oplock.Offset       == 0);
    ASSERT(file->oplock.OffsetHigh   == 0);
    ASSERT(file->oplock.hEvent       != NULL);
    ASSERT(IsReset(file->oplock.hEvent));

    success = DeviceIoControl(
        file->handle,
        FSCTL_REQUEST_BATCH_OPLOCK,
        NULL,
        0,
        NULL,
        0,
        NULL,
        &file->oplock);

    if (success) {
        ASSERT(IsSet(file->oplock.hEvent));
        success = ResetEvent(file->oplock.hEvent);
        ASSERT_ERROR(success);
        CLEAR_OVERLAPPED(file->oplock);
        SetLastError(0);
        return FALSE;
    }

    if (GetLastError() != ERROR_IO_PENDING) {
        ASSERT(IsReset(file->oplock.hEvent));
        CLEAR_OVERLAPPED(file->oplock);
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************/

// CloseFile() closes the file if it is still open. If an oplock was
// set on the file, it then waits for and resets the oplock break
// event triggered by the closing of the file or by an outside access.

VOID Groveler::CloseFile(FileData *file)
{
    BOOL success;

    ASSERT(file                != NULL);
    ASSERT(file->oplock.hEvent != NULL);

    if (file->handle == NULL) {
        ASSERT(file->oplock.Internal     == 0);
        ASSERT(file->oplock.InternalHigh == 0);
        ASSERT(file->oplock.Offset       == 0);
        ASSERT(file->oplock.OffsetHigh   == 0);
        ASSERT(IsReset(file->oplock.hEvent));
    } else {
        success = CloseHandle(file->handle);
        ASSERT_ERROR(success);
        file->handle = NULL;

        if (file->oplock.Internal     != 0
         || file->oplock.InternalHigh != 0
         || file->oplock.Offset       != 0
         || file->oplock.OffsetHigh   != 0) {
            WaitForEvent(file->oplock.hEvent);
            CLEAR_OVERLAPPED(file->oplock);
        }
    }
}

/*****************************************************************************/

//  CreateDatabase() creates the database.  Initialize it such that if
//  extract_log is called before scan_volume, it will return Grovel_overrun
//  without attempting any USN extraction.  Also, the first time scan_volume
//  is called (with or without start_over), it will know to initialize
//  lastUSN and do a full volume scan.

BOOL Groveler::CreateDatabase(void)
{
    USN_JOURNAL_DATA usnJournalData;

    TFileName tempName;
    TCHAR listValue[17];

    DWORDLONG rootID;

    SGNativeListEntry listEntry;

    LONG num;

    tempName.assign(driveName);
    tempName.append(_T("\\"));

    rootID = GetFileID(NULL,tempName.name);
    if (rootID == 0) {
        DPRINTF((_T("%s: CreateDatabase: can't get root directory ID\n"),
            driveLetterName));
        goto Error;
    }

    if (get_usn_log_info(&usnJournalData) != Grovel_ok) {
        DWORD lastError = GetLastError();

        if (lastError == ERROR_JOURNAL_NOT_ACTIVE) {
            DPRINTF((_T("%s: CreateDatabase: journal not active\n"), driveLetterName));
            if ((set_usn_log_size(65536) != ERROR_SUCCESS) ||
                get_usn_log_info(&usnJournalData) != ERROR_SUCCESS) {

                DPRINTF((_T("%s: CreateDatabase: can't initialize USN journal\n"),
                    driveLetterName));
                goto Error;
            }
        } else {
            DPRINTF((_T("%s: CreateDatabase: can't initialize last USN\n"),
                driveLetterName));
            goto Error;
        }
    }
    lastUSN = usnJournalData.NextUsn;
    usnID   = usnJournalData.UsnJournalID;

    sgDatabase->Close();
    if (!sgDatabase->Create(databaseName)) {
        DPRINTF((_T("%s: CreateDatabase: can't create database \"%s\"\n"),
            driveLetterName, databaseName));
        goto Error;
    }

    num = sgDatabase->StackPut(rootID, FALSE);
    if (num < 0)
        goto Error;
    ASSERT(num == 1);

// Write UNINITIALIZED_USN into the database now, to be replaced when scan_volume
// is complete.  This will be a flag to indicate if the database contents are valid.

    (void)StringCbPrintf(listValue, sizeof(listValue), _T("%016I64x"), UNINITIALIZED_USN);
    listEntry.name  = LAST_USN_NAME;
    listEntry.value = listValue;
    num = sgDatabase->ListWrite(&listEntry);
    if (num < 0)
        goto Error;
    ASSERT(num == 1);

    (void)StringCbPrintf(listValue, sizeof(listValue), _T("%016I64x"), usnID);
    listEntry.name  = USN_ID_NAME;
    listEntry.value = listValue;
    num = sgDatabase->ListWrite(&listEntry);
    if (num < 0)
        goto Error;
    ASSERT(num == 1);

    return TRUE;

    Error:

    lastUSN = usnID = UNINITIALIZED_USN;
    return FALSE;
}

/*****************************************************************************/

#define MAX_ACTIONS 5

// DoTransaction() performs the specified operations
// on the database within a single transaction.

VOID Groveler::DoTransaction(
    DWORD               numActions,
    DatabaseActionList *actionList)
{
    DatabaseActionList *action;

    DWORD i;

    LONG num;

    ASSERT(sgDatabase != NULL);
    ASSERT(actionList != NULL);

    if (sgDatabase->BeginTransaction() < 0)
        throw DATABASE_ERROR;

    for (i = 0; i < numActions; i++) {
        action = &actionList[i];
        switch(action->type) {

            case TABLE_PUT:

                ASSERT(action->u.tableEntry != NULL);
                num = sgDatabase->TablePut(action->u.tableEntry);
                ASSERT(num < 0 || num == 1);
                break;

            case TABLE_DELETE_BY_FILE_ID:

                ASSERT(action->u.fileID != 0);
                num = sgDatabase->TableDeleteByFileID(action->u.fileID);
                break;

            case QUEUE_PUT:

                ASSERT(action->u.queueEntry != NULL);
                num = sgDatabase->QueuePut(action->u.queueEntry);
                ASSERT(num < 0 || num == 1);
                if (num == 1)
                    numFilesEnqueued++;
                break;

            case QUEUE_DELETE:

                ASSERT(action->u.queueIndex != 0);
                num = sgDatabase->QueueDelete(action->u.queueIndex);
                ASSERT(num <= 1);
                if (num == 1)
                    numFilesDequeued++;
#if DBG
                else
                    DPRINTF((_T("DoTransaction: QUEUE_DELETE unsuccessful (%d)"), num));
#endif
                break;

            default:

                ASSERT_PRINTF(FALSE, (_T("type=%lu\n"), action->type));
        }

        if (num < 0) {
            sgDatabase->AbortTransaction();
            throw DATABASE_ERROR;
        }
    }

    if (!sgDatabase->CommitTransaction()) {
        sgDatabase->AbortTransaction();
        throw DATABASE_ERROR;
    }
}

/*****************************************************************************/

// EnqueueCSIndex() deletes all entries with the specified CS index from the
// table and enqueues them to be re-groveled, all within a single transaction.

VOID Groveler::EnqueueCSIndex(CSID *csIndex)
{
    SGNativeTableEntry tableEntry;

    SGNativeQueueEntry oldQueueEntry,
                       newQueueEntry;

    DWORD count;

    LONG num;

    ASSERT(csIndex != NULL);
    ASSERT(HasCSIndex(*csIndex));

    newQueueEntry.parentID  = 0;
    newQueueEntry.reason    = 0;
    newQueueEntry.readyTime = GetTime() + grovelInterval;
    newQueueEntry.retryTime = 0;
    newQueueEntry.fileName  = NULL;

    oldQueueEntry.fileName  = NULL;

    count = 0;

    if (sgDatabase->BeginTransaction() < 0)
        throw DATABASE_ERROR;

    tableEntry.csIndex = *csIndex;
    num = sgDatabase->TableGetFirstByCSIndex(&tableEntry);

    while (num > 0) {
        ASSERT(num == 1);
        count++;

        oldQueueEntry.fileID = tableEntry.fileID;
        num = sgDatabase->QueueGetFirstByFileID(&oldQueueEntry);
        if (num < 0)
            break;
        ASSERT(num == 1);

        if (num == 0) {
            newQueueEntry.fileID = tableEntry.fileID;
            num = sgDatabase->QueuePut(&newQueueEntry);
            if (num < 0)
                break;
            ASSERT(num == 1);
            numFilesEnqueued++;
        }

        num = sgDatabase->TableGetNext(&tableEntry);
    }

    if (num < 0) {
        sgDatabase->AbortTransaction();
        throw DATABASE_ERROR;
    }

    num = sgDatabase->TableDeleteByCSIndex(csIndex);
    if (num < 0) {
        sgDatabase->AbortTransaction();
        throw DATABASE_ERROR;
    }

    ASSERT(count == (DWORD)num);

    if (!sgDatabase->CommitTransaction()) {
        sgDatabase->AbortTransaction();
        throw DATABASE_ERROR;
    }
}

/*****************************************************************************/

#define TARGET_OPLOCK_BREAK 0
#define TARGET_READ_DONE    1
#define GROVEL_START        2
#define NUM_EVENTS          3

// SigCheckPoint suspends the thread until the target file completes its read
// operation. If the time allotment expires before the operation completes,
// the grovelStart event is set to signal grovel() to awaken, and this method
// won't return until grovel() sets the grovelStart event. If the file's
// oplock breaks before this method returns, the file will be closed.

VOID Groveler::SigCheckPoint(
    FileData *target,
    BOOL      targetRead)
{
    HANDLE events[NUM_EVENTS];

    DWORD elapsedTime,
          timeOut,
          eventNum,
          eventTime;

    BOOL targetOplockBroke     = FALSE,
         waitingForGrovelStart = FALSE,
         success;

    ASSERT(target                   != NULL);
    ASSERT(target->handle           != NULL);
    ASSERT(target->oplock   .hEvent != NULL);
    ASSERT(target->readSynch.hEvent != NULL);
    ASSERT(grovelStartEvent         != NULL);
    ASSERT(grovelStopEvent          != NULL);

    events[TARGET_OPLOCK_BREAK] = target->oplock   .hEvent;
    events[TARGET_READ_DONE]    = target->readSynch.hEvent;
    events[GROVEL_START]        = grovelStartEvent;

    while (TRUE) {
        if (waitingForGrovelStart)
            timeOut = INFINITE;
        else if (timeAllotted == INFINITE)
            timeOut = targetRead ? INFINITE : 0;
        else {
            elapsedTime = GetTickCount() - startAllottedTime;
            if (timeAllotted > elapsedTime)
                timeOut = targetRead ? timeAllotted - elapsedTime : 0;
            else {
                waitingForGrovelStart = TRUE;
                timeOut = INFINITE;
                grovelStatus = Grovel_pending;
                ASSERT(IsReset(grovelStopEvent));
                success = SetEvent(grovelStopEvent);
                ASSERT_ERROR(success);
            }
        }

        eventNum  = WaitForMultipleObjects(NUM_EVENTS, events, FALSE, timeOut);
        eventTime = GetTickCount();

        switch (eventNum) {

            case WAIT_OBJECT_0 + TARGET_OPLOCK_BREAK:

                ASSERT(!targetOplockBroke);
                targetOplockBroke = TRUE;
                success = ResetEvent(target->oplock.hEvent);
                ASSERT_ERROR(success);
                if (!targetRead) {
                    CLEAR_OVERLAPPED(target->oplock);
                    CloseFile(target);
                }
                DPRINTF((_T("%s: target file %s oplock broke during hash\n"),
                    driveLetterName, target->fileName));
                break;

            case WAIT_OBJECT_0 + TARGET_READ_DONE:

                ASSERT(targetRead);
                targetRead = FALSE;
                success = ResetEvent(target->readSynch.hEvent);
                ASSERT_ERROR(success);
                target->stopTime = eventTime;
                if (targetOplockBroke) {
                    CLEAR_OVERLAPPED(target->oplock);
                    CloseFile(target);
                }
                break;

            case WAIT_OBJECT_0 + GROVEL_START:

                ASSERT(waitingForGrovelStart);
                waitingForGrovelStart = FALSE;
                success = ResetEvent(grovelStartEvent);
                ASSERT_ERROR(success);
                break;

            case WAIT_TIMEOUT:

                ASSERT(!waitingForGrovelStart);
                if (!targetRead) {
                    if (terminate)
                        throw TERMINATE;
                    if (targetOplockBroke)
                        throw TARGET_ERROR;
                    return;
                }
                waitingForGrovelStart = TRUE;
                grovelStatus = Grovel_pending;
                ASSERT(IsReset(grovelStopEvent));
                success = SetEvent(grovelStopEvent);
                ASSERT_ERROR(success);
                break;

            default:

                ASSERT_PRINTF(FALSE, (_T("eventNum=%lu\n"), eventNum));
        }
    }
}

#undef TARGET_OPLOCK_BREAK
#undef TARGET_READ_DONE
#undef GROVEL_START
#undef NUM_EVENTS

/*****************************************************************************/

#define TARGET_OPLOCK_BREAK 0
#define MATCH_OPLOCK_BREAK  1
#define TARGET_READ_DONE    2
#define MATCH_READ_DONE     3
#define GROVEL_START        4
#define NUM_EVENTS          5

// CmpCheckPoint suspends the thread until the target file, the
// match file, or both complete their read operations. If the time
// allotment expires before the operations complete, the grovelStart
// event is set to signal grovel() to awaken, and this method won't
// return until grovel() sets the grovelStart event. If either file's
// oplock breaks before this method returns, the file will be closed.

VOID Groveler::CmpCheckPoint(
    FileData *target,
    FileData *match,
    BOOL      targetRead,
    BOOL      matchRead)
{
    HANDLE events[NUM_EVENTS];

    DWORD elapsedTime,
          timeOut,
          eventNum,
          eventTime;

    BOOL targetOplockBroke     = FALSE,
         matchOplockBroke      = FALSE,
         waitingForGrovelStart = FALSE,
         success;

    ASSERT(target                   != NULL);
    ASSERT(match                    != NULL);
    ASSERT(target->handle           != NULL);
    ASSERT(match ->handle           != NULL);
    ASSERT(target->oplock   .hEvent != NULL);
    ASSERT(match ->oplock   .hEvent != NULL);
    ASSERT(target->readSynch.hEvent != NULL);
    ASSERT(match ->readSynch.hEvent != NULL);
    ASSERT(grovelStartEvent         != NULL);
    ASSERT(grovelStopEvent          != NULL);

    events[TARGET_OPLOCK_BREAK] = target->oplock   .hEvent;
    events[MATCH_OPLOCK_BREAK]  = match ->oplock   .hEvent;
    events[TARGET_READ_DONE]    = target->readSynch.hEvent;
    events[MATCH_READ_DONE]     = match ->readSynch.hEvent;
    events[GROVEL_START]        = grovelStartEvent;

    while (TRUE) {
        if (waitingForGrovelStart)
            timeOut = INFINITE;
        else if (timeAllotted == INFINITE)
            timeOut = targetRead || matchRead ? INFINITE : 0;
        else {
            elapsedTime = GetTickCount() - startAllottedTime;
            if (timeAllotted > elapsedTime)
                timeOut = targetRead || matchRead
                        ? timeAllotted - elapsedTime : 0;
            else {
                waitingForGrovelStart = TRUE;
                timeOut = INFINITE;
                grovelStatus = Grovel_pending;
                ASSERT(IsReset(grovelStopEvent));
                success = SetEvent(grovelStopEvent);
                ASSERT_ERROR(success);
            }
        }

        eventNum  = WaitForMultipleObjects(NUM_EVENTS, events, FALSE, timeOut);
        eventTime = GetTickCount();

        switch (eventNum) {

            case WAIT_OBJECT_0 + TARGET_OPLOCK_BREAK:

                ASSERT(!targetOplockBroke);
                targetOplockBroke = TRUE;
                success = ResetEvent(target->oplock.hEvent);
                ASSERT_ERROR(success);
                if (!targetRead) {
                    CLEAR_OVERLAPPED(target->oplock);
                    CloseFile(target);
                }
                DPRINTF((_T("%s: target file %s oplock broke during compare\n"),
                    driveLetterName, target->fileName));
                break;

            case WAIT_OBJECT_0 + MATCH_OPLOCK_BREAK:

                ASSERT(!matchOplockBroke);
                matchOplockBroke = TRUE;
                success = ResetEvent(match->oplock.hEvent);
                ASSERT_ERROR(success);
                if (!matchRead) {
                    CLEAR_OVERLAPPED(match->oplock);
                    CloseFile(match);
                }
                DPRINTF((_T("%s: match file %s oplock broke during compare\n"),
                    driveLetterName, match->fileName));
                break;

            case WAIT_OBJECT_0 + TARGET_READ_DONE:

                ASSERT(targetRead);
                targetRead = FALSE;
                success = ResetEvent(target->readSynch.hEvent);
                ASSERT_ERROR(success);
                target->stopTime = eventTime;
                if (targetOplockBroke) {
                    CLEAR_OVERLAPPED(target->oplock);
                    CloseFile(target);
                }
                break;

            case WAIT_OBJECT_0 + MATCH_READ_DONE:

                ASSERT(matchRead);
                matchRead = FALSE;
                success = ResetEvent(match->readSynch.hEvent);
                ASSERT_ERROR(success);
                match->stopTime = eventTime;
                if (matchOplockBroke) {
                    CLEAR_OVERLAPPED(match->oplock);
                    CloseFile(match);
                }
                break;

            case WAIT_OBJECT_0 + GROVEL_START:

                ASSERT(waitingForGrovelStart);
                waitingForGrovelStart = FALSE;
                success = ResetEvent(grovelStartEvent);
                ASSERT_ERROR(success);
                break;

            case WAIT_TIMEOUT:

                ASSERT(!waitingForGrovelStart);
                if (!targetRead && !matchRead) {
                    if (terminate)
                        throw TERMINATE;
                    if (targetOplockBroke)
                        throw TARGET_ERROR;
                    if (matchOplockBroke)
                        throw MATCH_ERROR;
                    return;
                }
                waitingForGrovelStart = TRUE;
                grovelStatus = Grovel_pending;
                ASSERT(IsReset(grovelStopEvent));
                success = SetEvent(grovelStopEvent);
                ASSERT_ERROR(success);
                break;

            default:

                ASSERT_PRINTF(FALSE, (_T("eventNum=%lu\n"), eventNum));
        }
    }
}

#undef TARGET_OPLOCK_BREAK
#undef MATCH_OPLOCK_BREAK
#undef TARGET_READ_DONE
#undef MATCH_READ_DONE
#undef GROVEL_START
#undef NUM_EVENTS

/*****************************************************************************/

#define TARGET_OPLOCK_BREAK 0
#define MATCH_OPLOCK_BREAK  1
#define MERGE_DONE          2
#define GROVEL_START        3
#define NUM_EVENTS          4

// MergeCheckPoint suspends the thread until the merge operation is completed.
// If the time allotment expires before the merge is completed, the
// grovelStart event is set to signal grovel() to awaken, and this method
// won't return until grovel() sets the grovelStart event. If either file's
// oplock breaks before the merge is completed, the abortMerge event is set.

BOOL Groveler::MergeCheckPoint(
    FileData   *target,
    FileData   *match,
    OVERLAPPED *mergeSynch,
    HANDLE      abortMergeEvent,
    BOOL        merge)
{
    HANDLE events[NUM_EVENTS];

    DWORD elapsedTime,
          timeOut,
          eventNum,
          eventTime,
          lastError = STATUS_TIMEOUT;

    BOOL targetOplockBroke     = FALSE,
         matchOplockBroke      = FALSE,
         waitingForGrovelStart = FALSE,
         mergeSuccess          = FALSE,
         success;

    ASSERT(target                != NULL);
    ASSERT(target->handle        != NULL);
    ASSERT(target->oplock.hEvent != NULL);

    ASSERT(match                != NULL);
    ASSERT(match->handle        != NULL);
    ASSERT(match->oplock.hEvent != NULL);

    ASSERT(mergeSynch         != NULL);
    ASSERT(mergeSynch->hEvent != NULL);

    ASSERT(abortMergeEvent  != NULL);
    ASSERT(grovelStartEvent != NULL);
    ASSERT(grovelStopEvent  != NULL);

    ASSERT(grovHandle != NULL);

    events[TARGET_OPLOCK_BREAK] = target->oplock.hEvent;
    events[MATCH_OPLOCK_BREAK]  = match ->oplock.hEvent;
    events[MERGE_DONE]          = mergeSynch->   hEvent;
    events[GROVEL_START]        = grovelStartEvent;

    while (TRUE) {
        if (waitingForGrovelStart)
            timeOut = INFINITE;
        else if (timeAllotted == INFINITE)
            timeOut = merge ? INFINITE : 0;
        else {
            elapsedTime = GetTickCount() - startAllottedTime;
            if (timeAllotted > elapsedTime)
                timeOut = merge ? timeAllotted - elapsedTime : 0;
            else {
                waitingForGrovelStart = TRUE;
                timeOut = INFINITE;
                grovelStatus = Grovel_pending;
                ASSERT(IsReset(grovelStopEvent));
                success = SetEvent(grovelStopEvent);
                ASSERT_ERROR(success);
            }
        }

        eventNum  = WaitForMultipleObjects(NUM_EVENTS, events, FALSE, timeOut);
        eventTime = GetTickCount();

        switch (eventNum) {

            case WAIT_OBJECT_0 + TARGET_OPLOCK_BREAK:

                ASSERT(!targetOplockBroke);
                targetOplockBroke = TRUE;
                success = ResetEvent(target->oplock.hEvent);
                ASSERT_ERROR(success);
                CLEAR_OVERLAPPED(target->oplock);
                if (merge) {
                    success = SetEvent(abortMergeEvent);
                    ASSERT_ERROR(success);
                }
                DPRINTF((_T("%s: target file %s oplock broke during merge\n"),
                    driveLetterName, target->fileName));
                break;

            case WAIT_OBJECT_0 + MATCH_OPLOCK_BREAK:

                ASSERT(!matchOplockBroke);
                matchOplockBroke = TRUE;
                success = ResetEvent(match->oplock.hEvent);
                ASSERT_ERROR(success);
                CLEAR_OVERLAPPED(match->oplock);
                if (merge) {
                    success = SetEvent(abortMergeEvent);
                    ASSERT_ERROR(success);
                }
                DPRINTF((_T("%s: match file %s oplock broke during merge\n"),
                    driveLetterName, match->fileName));
                break;

            case WAIT_OBJECT_0 + MERGE_DONE:

                ASSERT(merge);
                merge = FALSE;
                success = ResetEvent(mergeSynch->hEvent);
                ASSERT_ERROR(success);
                target->stopTime = eventTime;
                mergeSuccess = GetOverlappedResult(
                    grovHandle,
                    mergeSynch,
                    &lastError,
                    FALSE);
                if (!mergeSuccess)
                    lastError = GetLastError();
                else if (lastError != ERROR_SUCCESS)
                    mergeSuccess = FALSE;
                else {
                    GetCSIndex(target->handle, &target->entry.csIndex);
                    if (!HasCSIndex(match->entry.csIndex))
                        GetCSIndex(match->handle, &match->entry.csIndex);
                }
                CloseFile(target);
                CloseFile(match);
                break;

            case WAIT_OBJECT_0 + GROVEL_START:

                ASSERT(waitingForGrovelStart);
                waitingForGrovelStart = FALSE;
                success = ResetEvent(grovelStartEvent);
                ASSERT_ERROR(success);
                break;

            case WAIT_TIMEOUT:

                ASSERT(!waitingForGrovelStart);
                if (!merge) {
                    success = ResetEvent(abortMergeEvent);
                    ASSERT_ERROR(success);
                    if (terminate)
                        throw TERMINATE;
                    if (!mergeSuccess)
                        SetLastError(lastError);
                    return mergeSuccess;
                }
                waitingForGrovelStart = TRUE;
                grovelStatus = Grovel_pending;
                ASSERT(IsReset(grovelStopEvent));
                success = SetEvent(grovelStopEvent);
                ASSERT_ERROR(success);
                break;

            default:

                ASSERT_PRINTF(FALSE, (_T("eventNum=%lu\n"), eventNum));
        }
    }
}

#undef TARGET_OPLOCK_BREAK
#undef MATCH_OPLOCK_BREAK
#undef GROVEL_START
#undef MERGE_DONE
#undef NUM_EVENTS

/*****************************************************************************/

// The following seven methods (GetTarget(), CalculateSignature(),
// GetMatchList(), GetCSFile(), GetMatch(), Compare(), and Merge())
// implement the phases of the groveling process.

// Structures used by the methods.

struct MatchListEntry {
    DWORDLONG fileID,
              createTime,
              writeTime;
};

struct CSIndexEntry {
    CSID  csIndex;
    TCHAR name[1];
};

/*****************************************************************************/

// GetTarget() is the first phase of groveling a file. It dequeues
// a file to be groveled (the "target" file), opens it, checks that
// it meets all criteria, then passes it on to the next phases.

BOOL Groveler::GetTarget(
    FileData *target,
    DWORD    *queueIndex)
{
    SGNativeTableEntry tableEntry;

    SGNativeQueueEntry queueEntry,
                       otherQueueEntry;

    TFileName targetName,
              parentName;

    BY_HANDLE_FILE_INFORMATION fileInfo;

    DWORD lastError;

    DWORDLONG currentTime,
              readyTime;

#if DBG
    DWORD earliestTime;
#endif

    ULARGE_INTEGER word;

    LONG num;

    BOOL byName,
         success;

    TPRINTF((_T("GETTarget: entered\n")));

    ASSERT(target               != NULL);
    ASSERT(target->handle       == NULL);
    ASSERT(target->entry.fileID == 0);
    ASSERT(target->fileName[0]  == _T('\0'));
    ASSERT(!HasCSIndex(target->entry.csIndex));

    ASSERT(queueIndex != NULL);
    ASSERT(sgDatabase != NULL);

// Dequeue a file to be groveled. If the queue is empty or if no
// entry's ready time has been reached, return Grovel_ok to grovel().

    queueEntry.fileName = target->fileName;
    num = sgDatabase->QueueGetFirst(&queueEntry);
    if (num < 0)
        throw DATABASE_ERROR;
    if (num == 0) {
        DPRINTF((_T("%s: queue is empty\n"), driveLetterName));
        return FALSE;
    }
    ASSERT(num == 1);

    currentTime = GetTime();
    if (queueEntry.readyTime > currentTime) {
#if DBG
        earliestTime = (DWORD)((queueEntry.readyTime - currentTime) / 10000);
        DPRINTF((_T("%s: earliest queue entry ready to be groveled in %lu.%03lu sec\n"),
            driveLetterName, earliestTime / 1000, earliestTime % 1000));
#endif
        return FALSE;
    }

    *queueIndex          = queueEntry.order;
    target->entry.fileID = queueEntry.fileID;
    target->parentID     = queueEntry.parentID;
    target->retryTime    = queueEntry.retryTime;

// Open the file by ID or name, and check by name
// that the file and its parent directory are allowed.

    byName = target->entry.fileID == 0;
    if (byName) {

        ASSERT(target->parentID    != 0);
        ASSERT(target->fileName[0] != _T('\0'));

#ifdef DEBUG_USN_REASON
        DPRINTF((_T("--> 0x%08lx 0x%016I64x:\"%s\"\n"),
            queueEntry.reason, target->parentID, target->fileName));
#endif

        if (!GetFileName(volumeHandle, target->parentID, &parentName)) {
            DPRINTF((_T("%s: can't get name for directory 0x%016I64x\n"),
                driveLetterName, target->parentID));
            throw TARGET_INVALID;
        }

        targetName.assign(parentName.name);
        targetName.append(_T("\\"));
        targetName.append(target->fileName);

        if (!IsAllowedName(targetName.name)) {
            DPRINTF((_T("%s: target file \"%s\" is disallowed\n"),
                driveLetterName, targetName.name));
            throw TARGET_INVALID;
        }

        targetName.assign(driveName);
        targetName.append(parentName.name);
        targetName.append(_T("\\"));
        targetName.append(target->fileName);

        if (!OpenFileByName(target, FALSE, targetName.name)) {
            lastError = GetLastError();
            if (lastError == ERROR_FILE_NOT_FOUND
             || lastError == ERROR_PATH_NOT_FOUND) {
                DPRINTF((_T("%s: target file \"%s\" doesn\'t exist\n"),
                    driveLetterName, targetName.name));
                throw TARGET_INVALID;
            }
            DPRINTF((_T("%s: can't open target file \"%s\": %lu\n"),
                driveLetterName, targetName.name, lastError));
            throw TARGET_ERROR;
        }

// Set an oplock on the target file.

        if (!SetOplock(target)) {
            DPRINTF((_T("%s: can't set oplock on target file \"%s\": %lu\n"),
                driveLetterName, targetName.name, GetLastError()));
            throw TARGET_ERROR;
        }

    } else {

        ASSERT(target->parentID    == 0);
        ASSERT(target->fileName[0] == _T('\0'));

        target->parentID = 0;

#ifdef DEBUG_USN_REASON
        DPRINTF((_T("--> 0x%08lx 0x%016I64x 0x%016I64x\n"),
            queueEntry.reason, target->entry.fileID, target->parentID));
#endif

        TPRINTF((_T("GETTarget: Opening %s:0x%016I64x by ID\n"),
                driveName,target->entry.fileID));

        if (!OpenFileByID(target, FALSE)) {
            lastError = GetLastError();
            if (lastError == ERROR_FILE_NOT_FOUND
             || lastError == ERROR_PATH_NOT_FOUND
             || lastError == ERROR_INVALID_PARAMETER) {

                DPRINTF((_T("%s: target file 0x%016I64x doesn\'t exist: %lu\n"),
                    driveLetterName, target->entry.fileID, lastError));

                throw TARGET_INVALID;
            }

            DPRINTF((_T("%s: can't open target file 0x%016I64x: %lu\n"),
                driveLetterName, target->entry.fileID, lastError));

            throw TARGET_ERROR;
        }

// Set an oplock on the target file.
        TPRINTF((_T("GETTarget: Successfully opened %s:0x%016I64x by ID\n"),
                driveName,target->entry.fileID));

        if (!SetOplock(target)) {
            DPRINTF((_T("%s: can't set oplock on target file %s: %lu\n"),
                driveLetterName, target->fileName, GetLastError()));
            throw TARGET_ERROR;
        }

        if (!GetFileName(target->handle, &targetName)) {
            DPRINTF((_T("%s: can't get name for target file %s\n"),
                driveLetterName, target->fileName));
            throw TARGET_ERROR;
        }

        if (!IsAllowedName(targetName.name)) {
            DPRINTF((_T("%s: target file \"%s\" is disallowed\n"),
                driveLetterName, targetName.name));
            throw TARGET_INVALID;
        }
    }

// Get the information on the target file.

    if (!GetFileInformationByHandle(target->handle, &fileInfo)) {
#if DBG
        if (byName) {
            DPRINTF((_T("%s: can't get information on target file \"%s\": %lu\n"),
                driveLetterName, targetName.name, GetLastError()));
        } else {
            DPRINTF((_T("%s: can't get information on target file %s: %lu\n"),
                driveLetterName, target->fileName, GetLastError()));
        }
#endif
        throw TARGET_ERROR;
    }

    word.HighPart = fileInfo.nFileIndexHigh;
    word.LowPart  = fileInfo.nFileIndexLow;
    if (byName)
        target->entry.fileID = word.QuadPart;
    else {
        ASSERT(target->entry.fileID == word.QuadPart);
    }

    target->parentID = 0; // We don't need the parent ID any more.

// If the target file was opened by name, check
// if it currently has an entry in the queue by ID.

    if (byName) {
        otherQueueEntry.fileID   = target->entry.fileID;
        otherQueueEntry.fileName = NULL;
        num = sgDatabase->QueueGetFirstByFileID(&otherQueueEntry);
        if (num < 0)
            throw DATABASE_ERROR;

        if (num > 0) {
            ASSERT(num == 1);
            DPRINTF((_T("%s: target file \"%s\" is already in queue as 0x%016I64x\n"),
                driveLetterName, targetName.name, target->entry.fileID));
            target->entry.fileID = 0; // Prevent the table entry from being deleted.
            throw TARGET_INVALID;
        }
    }

// Fill in the target file's remaining information values.

    word.HighPart = fileInfo.nFileSizeHigh;
    word.LowPart  = fileInfo.nFileSizeLow;
    target->entry.fileSize = word.QuadPart;

    target->entry.attributes = fileInfo.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED;

    word.HighPart = fileInfo.ftCreationTime.dwHighDateTime;
    word.LowPart  = fileInfo.ftCreationTime.dwLowDateTime;
    target->entry.createTime = word.QuadPart;

    word.HighPart = fileInfo.ftLastWriteTime.dwHighDateTime;
    word.LowPart  = fileInfo.ftLastWriteTime.dwLowDateTime;
    target->entry.writeTime = word.QuadPart;

// If the target file is a reparse point, check if it
// is a SIS reparse point. If it is, get the CS index.

    if ((fileInfo.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == 0)
        target->entry.csIndex = nullCSIndex;
    else if (!GetCSIndex(target->handle, &target->entry.csIndex)) {
        DPRINTF((_T("%s: target file %s is a non-SIS reparse point\n"),
            driveLetterName, target->fileName));
        throw TARGET_INVALID;
    }

// Check if the target file is too small or has any disallowed attributes.

    if ((fileInfo.dwFileAttributes & disallowedAttributes) != 0
     ||  fileInfo.nNumberOfLinks != 1
     ||  target->entry.fileSize  <  minFileSize) {
        DPRINTF((_T("%s: target file \"%s\" is disallowed\n"),
            driveLetterName, target->fileName));
        throw TARGET_INVALID;
    }

// If a table entry exists for the target file, check if it is
// consistent with the information we have on the file. If it is, and
// the file was opened by name, or if the queue entry was the result
// of a SIS merge, close the file and go on to grovel the next target.

    tableEntry.fileID = target->entry.fileID;
    num = sgDatabase->TableGetFirstByFileID(&tableEntry);
    if (num < 0)
        throw DATABASE_ERROR;

    if (num > 0) {
        ASSERT(num == 1);
        ASSERT(tableEntry.fileID == target->entry.fileID);

        if             (target->entry.fileSize   == tableEntry.fileSize
         &&             target->entry.attributes == tableEntry.attributes
         && SameCSIndex(target->entry.csIndex,      tableEntry.csIndex)
         &&             target->entry.createTime == tableEntry.createTime
         &&             target->entry.writeTime  == tableEntry.writeTime) {

            if (byName) {
                DPRINTF((_T("%s: target file \"%s\" has already been groveled\n"),
                    driveLetterName, targetName.name));
                target->entry.fileID = 0; // Prevent the table entry from being deleted.
                throw TARGET_INVALID;
            }

            if (queueEntry.reason == USN_REASON_BASIC_INFO_CHANGE) {
                DPRINTF((_T("%s: queue entry for file %s is the result of a SIS merge\n"),
                    driveLetterName, target->fileName));
                target->entry.fileID = 0; // Prevent the table entry from being deleted.
                throw TARGET_INVALID;
            }
        }
    }

// Check if the time since the target file was last modified is too short.
// If it is, close the file and go on to grovel the next target file.

    readyTime = (target->entry.createTime > target->entry.writeTime
               ? target->entry.createTime : target->entry.writeTime) + minFileAge;
    currentTime = GetTime();
    if (currentTime < readyTime)
        throw TARGET_ERROR;

// Check if the target file is mapped by another user.

    if (IsFileMapped(target)) {
        DPRINTF((_T("%s: target file %s is already mapped\n"),
            driveLetterName, target->fileName));
        throw TARGET_ERROR;
    }

    TPRINTF((_T("GETTarget: returning\n")));

    return TRUE;
}

/*****************************************************************************/

// CalculateSignature() calculates the target file's signature. It reads two
// pages, 1/3 and 2/3 through the file, and calculates the signature on each
// page.

VOID Groveler::CalculateSignature(FileData *target)
{
    DWORD lastPageSize,
          bytesToRead,
          prevBytesToRead,
          bytesToRequest,
          prevBytesToRequest = 0,
          bytesRead,
          toggle,
          lastError;

    DWORDLONG numPages,
              pageNum,
              prevPageNum,
              lastPageNum,
              firstPageToRead,
              lastPageToRead;

    ULARGE_INTEGER offset;

    BOOL targetReadDone = FALSE,
         success;

    INT i,
        nPagesToRead;

    ASSERT(target                 != NULL);
    ASSERT(target->entry.fileID   != 0);
    ASSERT(target->handle         != NULL);

    target->entry.signature = 0;

    if (0 == target->entry.fileSize)
        return;

    numPages     =         (target->entry.fileSize - 1) / SIG_PAGE_SIZE  + 1;
    lastPageSize = (DWORD)((target->entry.fileSize - 1) % SIG_PAGE_SIZE) + 1;
    lastPageNum  = numPages - 1;

    ASSERT(numPages > 0);

    firstPageToRead = (numPages + 2) / 3 - 1;
    lastPageToRead = lastPageNum - firstPageToRead;

    if (lastPageToRead > firstPageToRead)
        nPagesToRead = 2;
    else
        nPagesToRead = 1;

    toggle = 0;
    pageNum = firstPageToRead;

// We'll read at most two pages, but make at most three passes through the loop
// since we're doing asynchronous reads.

    for (i = 0; i <= nPagesToRead; ++i) {

// Unless this is the first pass through the loop,
// wait for the previous read of the target file to complete.

        if (i > 0) {
            SigCheckPoint(target, !targetReadDone);

            success = GetOverlappedResult(
                target->handle,
                &target->readSynch,
                &bytesRead,
                FALSE);
            if (!success) {
                DPRINTF((_T("%s: error getting target file %s read results: %lu\n"),
                    driveLetterName, target->fileName, GetLastError()));
                throw TARGET_ERROR;
            }

            if (bytesRead != prevBytesToRequest &&
                bytesRead != prevBytesToRead) {
                DPRINTF((_T("%s: sig read only %lu of %lu bytes from target file %s\n"),
                    driveLetterName, bytesRead, prevBytesToRequest, target->fileName));
                throw TARGET_ERROR;
            }

            if (bytesRead >= sigReportThreshold) {
                hashReadCount++;
                hashReadTime += target->stopTime - target->startTime;
            }
        }

// Unless we've read all of the pages, begin reading the next page.

        if (i < nPagesToRead) {
            offset.QuadPart              = pageNum * SIG_PAGE_SIZE;
            target->readSynch.Offset     = offset.LowPart;
            target->readSynch.OffsetHigh = offset.HighPart;

            bytesToRead     = pageNum == lastPageNum ? lastPageSize : SIG_PAGE_SIZE;
            bytesToRequest  = bytesToRead    + sectorSize - 1;
            bytesToRequest -= bytesToRequest % sectorSize;

            target->startTime = GetTickCount();
            targetReadDone    = ReadFile(target->handle, target->buffer[toggle],
                bytesToRequest, NULL, &target->readSynch);
            target->stopTime  = GetTickCount();
            lastError         = GetLastError();

            if (targetReadDone) {
                success = ResetEvent(target->readSynch.hEvent);
                ASSERT_ERROR(success);
            } else if (lastError != ERROR_IO_PENDING) {
                DPRINTF((_T("%s: error reading target file %s: %lu\n"),
                    driveLetterName, target->fileName, lastError));
                throw TARGET_ERROR;
            }
        }

// Unless this is the first pass through the loop,
// calculate the signature of the target file page just read.

        if (i > 0)
            target->entry.signature = Checksum((VOID *)target->buffer[1-toggle],
                prevBytesToRead, prevPageNum * SIG_PAGE_SIZE, target->entry.signature);

        prevPageNum         = pageNum;
        prevBytesToRead     = bytesToRead;
        prevBytesToRequest  = bytesToRequest;
        toggle              = 1-toggle;
        pageNum             = lastPageToRead;

    }
}

/*****************************************************************************/

// GetMatchList() looks for file entries in the database ("match" files)
// with the same size, signature, and attributes as the target file.

VOID Groveler::GetMatchList(
    FileData *target,
    FIFO     *matchList,
    Table    *csIndexTable)
{
    SGNativeTableEntry tableEntry;

    MatchListEntry *matchListEntry;

    CSIndexEntry *csIndexEntry;

    LONG num;

    BOOL success;

    ASSERT(target                 != NULL);
    ASSERT(target->entry.fileID   != 0);
    ASSERT(target->entry.fileSize >  0);
    ASSERT(target->handle         != NULL);

    ASSERT(matchList           != NULL);
    ASSERT(matchList->Number() == 0);

    ASSERT(csIndexTable           != NULL);
    ASSERT(csIndexTable->Number() == 0);

    ASSERT(sgDatabase != NULL);

    tableEntry.fileSize   = target->entry.fileSize;
    tableEntry.signature  = target->entry.signature;
    tableEntry.attributes = target->entry.attributes;

#ifdef DEBUG_GET_BY_ATTR
    DPRINTF((_T("--> {%I64u, 0x%016I64x, 0x%lx}\n"),
        tableEntry.fileSize, tableEntry.signature, tableEntry.attributes));
#endif

    num = sgDatabase->TableGetFirstByAttr(&tableEntry);

    while (num > 0) {

        ASSERT(num == 1);
        ASSERT(tableEntry.fileID     != 0);
        ASSERT(tableEntry.fileSize   == target->entry.fileSize);
        ASSERT(tableEntry.signature  == target->entry.signature);
        ASSERT(tableEntry.attributes == target->entry.attributes);

        if (!HasCSIndex(tableEntry.csIndex)) {

            matchListEntry = new MatchListEntry;
            ASSERT(matchListEntry != NULL);

            matchListEntry->fileID     = tableEntry.fileID;
            matchListEntry->createTime = tableEntry.createTime;
            matchListEntry->writeTime  = tableEntry.writeTime;
            matchList->Put((VOID *)matchListEntry);

#ifdef DEBUG_GET_BY_ATTR
            DPRINTF((_T("    0x%016I64x\n"), tableEntry.fileID));
#endif

        } else {

            csIndexEntry = (CSIndexEntry *)csIndexTable->Get
                ((const VOID *)&tableEntry.csIndex, sizeof(CSID));

            if (csIndexEntry == NULL) {

                TCHAR *csName = GetCSName(&tableEntry.csIndex);
                if (csName != NULL) {

                    //
                    //  Calculate how big the name buffer is and how big the
                    //  overall structure is.  Note that the CSIndexEntry has
                    //  space in it for one character, which we account for.
                    //

                    int nameBufLen = ((wcslen(csName) + 1) * sizeof(TCHAR));    //account for NULL
                    int bufLen = ((sizeof(CSIndexEntry)-sizeof(TCHAR)) + nameBufLen);
                
                    csIndexEntry = (CSIndexEntry *)(new BYTE[bufLen]);
                    ASSERT(csIndexEntry != NULL);

                    csIndexEntry->csIndex = tableEntry.csIndex;

                    (void)StringCbCopy( csIndexEntry->name,
                                  nameBufLen,
                                  csName);

                    FreeCSName(csName);
                    csName = NULL;
                }

                success = csIndexTable->Put((VOID *)csIndexEntry, sizeof(CSID));
                ASSERT_ERROR(success);
            }

#ifdef DEBUG_GET_BY_ATTR
            DPRINTF((_T("    0x%016I64x %s\n"),
                match->entry.fileID, csIndexEntry->name));
#endif
        }

        num = sgDatabase->TableGetNext(&tableEntry);
    }

    if (num < 0)
        throw DATABASE_ERROR;
}

/*****************************************************************************/

// GetCSFile() pops the first entry from the CS index table and opens it.

BOOL Groveler::GetCSFile(
    FileData *target,
    FileData *match,
    Table    *csIndexTable)
{
    CSIndexEntry *csIndexEntry;

    TFileName csFileName;

    DWORD lastError;

    BY_HANDLE_FILE_INFORMATION fileInfo;

    ULARGE_INTEGER fileSize;

    LONG num;

    ASSERT(target                 != NULL);
    ASSERT(target->entry.fileID   != 0);
    ASSERT(target->entry.fileSize >  0);
    ASSERT(target->handle         != NULL);

    ASSERT(match                   != NULL);
    ASSERT(match->entry.fileID     == 0);
    ASSERT(match->entry.fileSize   == 0);
    ASSERT(match->entry.signature  == 0);
    ASSERT(match->entry.attributes == 0);
    ASSERT(!HasCSIndex(match->entry.csIndex));
    ASSERT(match->entry.createTime == 0);
    ASSERT(match->entry.writeTime  == 0);
    ASSERT(match->handle           == NULL);
    ASSERT(match->parentID         == 0);
    ASSERT(match->retryTime        == 0);
    ASSERT(match->fileName[0]      == _T('\0'));

    ASSERT(csIndexTable != NULL);
    ASSERT(sgDatabase   != NULL);

// Pop the first entry from the CS index table. If the entry's CS
// index is the same as the target file's, skip to the next entry.

    do {
        csIndexEntry = (CSIndexEntry *)csIndexTable->GetFirst();
        if (csIndexEntry == NULL) {
            match->entry.csIndex = nullCSIndex;
            match->fileName[0]   = _T('\0');
            return FALSE;
        }

        ASSERT(HasCSIndex(csIndexEntry->csIndex));

        match->entry.csIndex = csIndexEntry->csIndex;
        _tcscpy(match->fileName, csIndexEntry->name);

        delete csIndexEntry;
        csIndexEntry = NULL;
    } while (SameCSIndex(target->entry.csIndex, match->entry.csIndex));

    match->entry.fileSize   = target->entry.fileSize;
    match->entry.signature  = target->entry.signature;
    match->entry.attributes = target->entry.attributes;

    csFileName.assign(driveName);
    csFileName.append(CS_DIR_PATH);
    csFileName.append(_T("\\"));
    csFileName.append(match->fileName);
    csFileName.append(_T(".sis"));

// Open the CS file. If the file doesn't exist, remove all entries
// from the table that point to this file. If the file can't be
// opened for any other reason, mark that the target file may
// need to be groveled again, then go on to the next match file.

#ifdef DEBUG_GET_BY_ATTR
    DPRINTF((_T("--> %s\n"), match->fileName));
#endif

    if (!OpenFileByName(match, FALSE, csFileName.name)) {
        lastError = GetLastError();
        if (lastError == ERROR_FILE_NOT_FOUND
         || lastError == ERROR_PATH_NOT_FOUND) {
            DPRINTF((_T("%s: CS file %s doesn't exist\n"),
                driveLetterName, match->fileName));
            throw MATCH_INVALID;
        }
        DPRINTF((_T("%s: can't open CS file %s: %lu\n"),
            driveLetterName, match->fileName, lastError));
        throw MATCH_ERROR;
    }

// Get the information on the CS file. If this fails,
// close the file, mark that the target file may need to
// be groveled again, then go on to the next match file.

    if (!GetFileInformationByHandle(match->handle, &fileInfo)) {
        DPRINTF((_T("%s: can't get information on CS file %s: %lu\n"),
            driveLetterName, match->fileName, GetLastError()));
        throw MATCH_ERROR;
    }

// If the CS file's information doesn't match its expected values, close the
// CS file, delete the match file entry from the table, and go on to the
// next match file. Otherwise, go on to compare the target and CS files.

    fileSize.HighPart = fileInfo.nFileSizeHigh;
    fileSize.LowPart  = fileInfo.nFileSizeLow;

    if (match->entry.fileSize != fileSize.QuadPart) {
        DPRINTF((_T("%s: CS file %s doesn't have expected information\n"),
            driveLetterName, match->fileName));
        throw MATCH_STALE;
    }

    return TRUE;
}

/*****************************************************************************/

// GetMatch() pops the first entry from the match list and opens it.

BOOL Groveler::GetMatch(
    FileData *target,
    FileData *match,
    FIFO     *matchList)
{
    SGNativeQueueEntry queueEntry;

    MatchListEntry *matchListEntry;

    DWORD attributes,
          lastError;

    BY_HANDLE_FILE_INFORMATION fileInfo;

    ULARGE_INTEGER fileID,
                   fileSize,
                   createTime,
                   writeTime;

    LONG num;

    ASSERT(target                 != NULL);
    ASSERT(target->entry.fileID   != 0);
    ASSERT(target->entry.fileSize >  0);
    ASSERT(target->handle         != NULL);

    ASSERT(match                   != NULL);
    ASSERT(match->entry.fileID     == 0);
    ASSERT(match->entry.fileSize   == 0);
    ASSERT(match->entry.signature  == 0);
    ASSERT(match->entry.attributes == 0);
    ASSERT(!HasCSIndex(match->entry.csIndex));
    ASSERT(match->entry.createTime == 0);
    ASSERT(match->entry.writeTime  == 0);
    ASSERT(match->handle           == NULL);
    ASSERT(match->parentID         == 0);
    ASSERT(match->retryTime        == 0);
    ASSERT(match->fileName[0]      == _T('\0'));

    ASSERT(matchList  != NULL);
    ASSERT(sgDatabase != NULL);

// Pop the first entry from the match list. If the entry's file ID is
// the same as the target file's, or if the entry is on the queue after
// having been enqueued by extract_log(), skip to the next entry.

    while (TRUE) {
        matchListEntry = (MatchListEntry *)matchList->Get();
        if (matchListEntry == NULL) {
            match->entry.fileID     = 0;
            match->entry.createTime = 0;
            match->entry.writeTime  = 0;
            return FALSE;
        }

        match->entry.fileID     = matchListEntry->fileID;
        match->entry.createTime = matchListEntry->createTime;
        match->entry.writeTime  = matchListEntry->writeTime;

        delete matchListEntry;
        matchListEntry = NULL;

        ASSERT(match->entry.fileID != 0);

        if (target->entry.fileID == match->entry.fileID)
            continue;

        queueEntry.fileID   = match->entry.fileID;
        queueEntry.fileName = NULL;
        num = sgDatabase->QueueGetFirstByFileID(&queueEntry);
        if (num < 0)
            throw DATABASE_ERROR;
        if (num > 0) {
            ASSERT(num == 1);
            if (queueEntry.reason != 0) {
                DPRINTF((_T("%s: match file 0x%016I64x is in the queue from USN\n"),
                    driveLetterName, match->entry.fileID));
                continue;
            }
        }

        break;
    }

    match->entry.fileSize   = target->entry.fileSize;
    match->entry.signature  = target->entry.signature;
    match->entry.attributes = target->entry.attributes;

// Open the match file. If it doesn't exist, remove its entry from the table.
// If the file can't be opened for any other reason, mark that the target
// file may need to be groveled again, then go on to the next match file.

#ifdef DEBUG_GET_BY_ATTR
    DPRINTF((_T("--> 0x%016I64x\n"), match->entry.fileID));
#endif

    if (!OpenFileByID(match, FALSE)) {
        lastError = GetLastError();
        if (lastError == ERROR_FILE_NOT_FOUND
         || lastError == ERROR_PATH_NOT_FOUND
         || lastError == ERROR_INVALID_PARAMETER) {
            DPRINTF((_T("%s: match file 0x%016I64x doesn\'t exist: %lu\n"),
                driveLetterName, match->entry.fileID, lastError));
            throw MATCH_INVALID;
        }

        DPRINTF((_T("%s: can't open match file 0x%016I64x: %lu\n"),
            driveLetterName, match->entry.fileID, lastError));
        throw MATCH_ERROR;
    }

// Set an oplock on the match file.

    if (!SetOplock(match)) {
        DPRINTF((_T("%s: can't set oplock on match file %s: %lu\n"),
            driveLetterName, match->fileName, GetLastError()));
        throw MATCH_ERROR;
    }

// Get the information on the match file. If this fails,
// close the file, mark that the target file may need to
// be groveled again, then go on to the next match file.

    if (!GetFileInformationByHandle(match->handle, &fileInfo)) {
        DPRINTF((_T("%s: can't get information on match file %s: %lu\n"),
            driveLetterName, match->fileName, GetLastError()));
        throw MATCH_ERROR;
    }

    fileID.HighPart = fileInfo.nFileIndexHigh;
    fileID.LowPart  = fileInfo.nFileIndexLow;
    ASSERT(match->entry.fileID == fileID.QuadPart);

    fileSize.HighPart = fileInfo.nFileSizeHigh;
    fileSize.LowPart  = fileInfo.nFileSizeLow;

    attributes = fileInfo.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED;

    createTime.HighPart = fileInfo.ftCreationTime.dwHighDateTime;
    createTime.LowPart  = fileInfo.ftCreationTime.dwLowDateTime;

    writeTime.HighPart = fileInfo.ftLastWriteTime.dwHighDateTime;
    writeTime.LowPart  = fileInfo.ftLastWriteTime.dwLowDateTime;

// If the match file's information isn't consistent with its table entry, close
// the file, enqueue it to be re-groveled, and go on to the next match file.

    if (match->entry.fileSize   != fileSize  .QuadPart
     || match->entry.attributes != attributes
     || match->entry.createTime != createTime.QuadPart
     || match->entry.writeTime  != writeTime .QuadPart) {
        DPRINTF((_T("%s: match file %s doesn't match its information\n"),
            driveLetterName, match->fileName));
        throw MATCH_STALE;
    }

    if ((fileInfo.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) != 0) {
        if (GetCSIndex(match->handle, &match->entry.csIndex)) {
            DPRINTF((_T("%s: match file %s is a SIS reparse point\n"),
                driveLetterName, match->fileName));
            throw MATCH_STALE;
        }

        DPRINTF((_T("%s: match file %s is a non-SIS reparse point\n"),
            driveLetterName, match->fileName));
        throw MATCH_INVALID;
    }

// Check if the match file is mapped by another user.

    if (IsFileMapped(match)) {
        DPRINTF((_T("%s: match file %s is already mapped\n"),
            driveLetterName, match->fileName));
        throw MATCH_ERROR;
    }

    return TRUE;
}

/*****************************************************************************/

// Compare() compares the target and match files. It reads each file
// one page (64 kB) at a time and compares each pair of pages.

BOOL Groveler::Compare(
    FileData *target,
    FileData *match)
{
    DWORD lastPageSize,
          bytesToRead = 0,
          prevBytesToRead,
          bytesToRequest = 0,
          prevBytesToRequest = 0,
          bytesRead,
          toggle,
          targetTime,
          matchTime,
          lastError;

    DWORDLONG numPages,
              pageNum,
              prevPageNum;

    ULARGE_INTEGER offset;

    BOOL targetReadDone = FALSE,
         matchReadDone = FALSE,
         filesMatch,
         success;

    ASSERT(target               != NULL);
    ASSERT(target->handle       != NULL);
    ASSERT(target->entry.fileID != 0);

    ASSERT(match         != NULL);
    ASSERT(match->handle != NULL);
    ASSERT(    match->entry.fileID != 0
           && !HasCSIndex(match->entry.csIndex)
        ||     match->entry.fileID == 0
           &&  match->fileName[0]  != _T('\0')
           &&  HasCSIndex(match->entry.csIndex));

    ASSERT(target->entry.fileSize   == match->entry.fileSize);
    ASSERT(target->entry.signature  == match->entry.signature);
    ASSERT(target->entry.attributes == match->entry.attributes);

    numPages     =         (target->entry.fileSize - 1) / CMP_PAGE_SIZE  + 1;
    lastPageSize = (DWORD)((target->entry.fileSize - 1) % CMP_PAGE_SIZE) + 1;

    toggle     = 0;
    filesMatch = TRUE;

    for (pageNum = 0; pageNum <= numPages; pageNum++) {

// Unless this is the first pass through the loop,
// wait for the previous read of both files to complete.

        if (pageNum > 0) {
            CmpCheckPoint(target, match, !targetReadDone, !matchReadDone);

            success = GetOverlappedResult(
                target->handle,
                &target->readSynch,
                &bytesRead,
                FALSE);
            if (!success) {
                DPRINTF((_T("%s: error getting target file %s read results: %lu\n"),
                    driveLetterName, target->fileName, GetLastError()));
                throw TARGET_ERROR;
            }

            if (bytesRead != prevBytesToRequest &&
                bytesRead != prevBytesToRead) {
                DPRINTF((_T("%s: cmp read only %lu of %lu bytes from target file %s\n"),
                    driveLetterName, bytesRead, prevBytesToRequest, target->fileName));
                throw TARGET_ERROR;
            }

            success = GetOverlappedResult(
                match->handle,
                &match->readSynch,
                &bytesRead,
                FALSE);
            if (!success) {
#if DBG
                if (match->entry.fileID != 0) {
                    DPRINTF((_T("%s: error getting match file %s read results: %lu\n"),
                        driveLetterName, match->fileName, GetLastError()));
                } else {
                    DPRINTF((_T("%s: error getting CS file %s read results: %lu\n"),
                        driveLetterName, match->fileName, GetLastError()));
                }
#endif
                throw MATCH_ERROR;
            }

            if (bytesRead != prevBytesToRequest &&
                bytesRead != prevBytesToRead) {
#if DBG
                if (match->entry.fileID != 0) {
                    DPRINTF((_T("%s: read only %lu of %lu bytes from match file %s\n"),
                        driveLetterName, bytesRead, prevBytesToRequest, match->fileName));
                } else {
                    DPRINTF((_T("%s: read only %lu of %lu bytes from CS file %s\n"),
                        driveLetterName, bytesRead, prevBytesToRequest, match->fileName));
                }
#endif
                throw MATCH_ERROR;
            }

            if (bytesRead >= cmpReportThreshold) {
                compareReadCount += 2;
                if (targetReadDone) { // Non-overlapped
                    targetTime = target->stopTime - target->startTime;
                    matchTime  = match ->stopTime - match ->startTime;
                    compareReadTime += targetTime + matchTime;
                } else {              // Overlapped
                    targetTime = target->stopTime - target->startTime;
                    matchTime  = match ->stopTime - target->startTime;
                    compareReadTime += targetTime > matchTime ? targetTime : matchTime;
                }
            }

            if (!filesMatch)
                break;
        }

// Unless all pages of the target file have already been read,
// begin reading the next page of the file.

        if (pageNum < numPages) {
            offset.QuadPart             = pageNum * CMP_PAGE_SIZE;
            target->readSynch.Offset     =
            match ->readSynch.Offset     = offset.LowPart;
            target->readSynch.OffsetHigh =
            match ->readSynch.OffsetHigh = offset.HighPart;

            bytesToRead     = pageNum < numPages-1 ? CMP_PAGE_SIZE : lastPageSize;
            bytesToRequest  = bytesToRead    + sectorSize - 1;
            bytesToRequest -= bytesToRequest % sectorSize;

            target->startTime = GetTickCount();
            targetReadDone    = ReadFile(target->handle, target->buffer[toggle],
                bytesToRequest, NULL, &target->readSynch);
            target->stopTime  = GetTickCount();
            lastError         = GetLastError();

            if (targetReadDone) {
                success = ResetEvent(target->readSynch.hEvent);
                ASSERT_ERROR(success);
            } else if (lastError != ERROR_IO_PENDING) {
                DPRINTF((_T("%s: error reading target file %s: %lu\n"),
                    driveLetterName, target->fileName, lastError));
                throw TARGET_ERROR;
            }

            match->startTime = GetTickCount();
            matchReadDone    = ReadFile(match->handle, match->buffer[toggle],
                bytesToRequest, NULL, &match->readSynch);
            match->stopTime  = GetTickCount();
            lastError        = GetLastError();

            if (matchReadDone) {
                success = ResetEvent(match->readSynch.hEvent);
                ASSERT_ERROR(success);
            } else if (lastError != ERROR_IO_PENDING) {
#if DBG
                if (match->entry.fileID != 0) {
                    DPRINTF((_T("%s: error reading match file %s: %lu\n"),
                        driveLetterName, match->fileName, lastError));
                } else {
                    DPRINTF((_T("%s: error reading CS file %s: %lu\n"),
                        driveLetterName, match->fileName, lastError));
                }
#endif
                throw MATCH_ERROR;
            }
        }

// Unless this is the first pass through the loop,
// compare the target and match file pages just read.

        if (pageNum > 0)
            filesMatch = memcmp(target->buffer[1-toggle],
                                match ->buffer[1-toggle], prevBytesToRead) == 0;

        prevPageNum         = pageNum;
        prevBytesToRead     = bytesToRead;
        prevBytesToRequest  = bytesToRequest;
        toggle              = 1-toggle;
    }

    if (!filesMatch) {
#if DBG
        if (match->entry.fileID != 0) {
            DPRINTF((_T("%s:1 files %s and %s failed compare (sz: 0x%x)\n"),
                driveLetterName, target->fileName, match->fileName, target->entry.fileSize));
        } else {
            DPRINTF((_T("%s:2 files %s and %s failed compare (sz: 0x%x)\n"),
                driveLetterName, target->fileName, match->fileName, target->entry.fileSize));
        }
#endif
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************/

// Merge() calls the SIS filter to merge the target and match files.

BOOL Groveler::Merge(
    FileData   *target,
    FileData   *match,
    OVERLAPPED *mergeSynch,
    HANDLE      abortMergeEvent)
{
    _SIS_LINK_FILES sisLinkFiles;

#if DBG
    TCHAR *csName;
#endif

    DWORD transferCount,
          lastError;

    BOOL mergeDone,
         merged,
         success;

    ASSERT(target               != NULL);
    ASSERT(target->handle       != NULL);
    ASSERT(target->entry.fileID != 0);

    ASSERT(match         != NULL);
    ASSERT(match->handle != NULL);
    ASSERT(    match->entry.fileID != 0
           && !HasCSIndex(match->entry.csIndex)
        ||     match->entry.fileID == 0
           &&  match->fileName[0]  != _T('\0')
           &&  HasCSIndex(match->entry.csIndex));

    ASSERT(mergeSynch               != NULL);
    ASSERT(mergeSynch->Internal     == 0);
    ASSERT(mergeSynch->InternalHigh == 0);
    ASSERT(mergeSynch->Offset       == 0);
    ASSERT(mergeSynch->OffsetHigh   == 0);
    ASSERT(mergeSynch->hEvent       != NULL);
    ASSERT(IsReset(mergeSynch->hEvent));

    ASSERT(abortMergeEvent != NULL);
    ASSERT(IsReset(abortMergeEvent));

    ASSERT(target->entry.fileSize   == match->entry.fileSize);
    ASSERT(target->entry.signature  == match->entry.signature);
    ASSERT(target->entry.attributes == match->entry.attributes);

    ASSERT(grovHandle != NULL);

// Set up to merge the files.

    if (match->entry.fileID != 0) {
        sisLinkFiles.operation          = SIS_LINK_FILES_OP_MERGE;
        sisLinkFiles.u.Merge.file1      = target->handle;
        sisLinkFiles.u.Merge.file2      = match ->handle;
        sisLinkFiles.u.Merge.abortEvent = NULL; // Should be abortMergeEvent
    } else {
        sisLinkFiles.operation                = SIS_LINK_FILES_OP_MERGE_CS;
        sisLinkFiles.u.MergeWithCS.file1      = target->handle;
        sisLinkFiles.u.MergeWithCS.abortEvent = NULL; // Should be abortMergeEvent
        sisLinkFiles.u.MergeWithCS.CSid       = match->entry.csIndex;
    }

// Call the SIS filter to merge the files.

    target->startTime = GetTickCount();
    mergeDone = DeviceIoControl(
        grovHandle,
        FSCTL_SIS_LINK_FILES,
        (VOID *)&sisLinkFiles,
        sizeof(_SIS_LINK_FILES),
        NULL,
        0,
        NULL,
        mergeSynch);
    target->stopTime = GetTickCount();

// If the merge completed successfully before the call returned, reset
// the merge done event, get the new CS indices, and close the files.

    if (mergeDone) {
        success = ResetEvent(mergeSynch->hEvent);
        ASSERT_ERROR(success);
        mergeTime += target->stopTime - target->startTime;
        GetCSIndex(target->handle, &target->entry.csIndex);
        if (!HasCSIndex(match->entry.csIndex))
            GetCSIndex(match->handle, &match->entry.csIndex);
        CloseFile(target);
        CloseFile(match);
    }

// If the merge failed, close the files and return an error status.

    else {
        lastError = GetLastError();
        if (lastError != ERROR_IO_PENDING) {
            CloseFile(target);
            CloseFile(match);

#if DBG
            if (match->entry.fileID != 0) {
                DPRINTF((_T("%s:3 files %s and %s failed merge: %lu\n"),
                    driveLetterName, target->fileName, match->fileName, lastError));
            } else {
                DPRINTF((_T("%s:4 files %s and %s failed merge: %lu\n"),
                    driveLetterName, target->fileName, match->fileName, lastError));
            }
#endif

            return FALSE;
        }

// If the merge is in progress, wait for it to complete.
// (MergeCheckPoint() will get the new CS indices and close the files.

        else {
            merged = MergeCheckPoint(target, match, mergeSynch,
                abortMergeEvent, !mergeDone);

            if (!merged) {
#if DBG
                lastError = GetLastError();
                if (match->entry.fileID != 0) {
                    DPRINTF((_T("%s: error getting merge results of files %s and %s: %lu\n"),
                        driveLetterName, target->fileName, match->fileName, lastError));
                } else {
                    DPRINTF((_T("%s: error getting merge results of files %s and %s: %lu\n"),
                        driveLetterName, target->fileName, match->fileName, lastError));
                }
#endif

                return FALSE;
            }
        }
    }

// If the merge succeeded, analyze and report the results.

    mergeTime += target->stopTime - target->startTime;
    merged = HasCSIndex (target->entry.csIndex)
          && SameCSIndex(target->entry.csIndex, match->entry.csIndex);

#if DBG

    csName = GetCSName(&target->entry.csIndex);

    if (merged) {
        if (match->entry.fileID != 0) {
            DPRINTF((_T("%s: files %s and %s merged: CS index is %s\n"),
                driveLetterName, target->fileName, match->fileName,
                csName != NULL ? csName : _T("...")));
        } else {
            DPRINTF((_T("%s: files %s and %s merged\n"),
                driveLetterName, target->fileName, match->fileName));
        }
    } else {
        if (match->entry.fileID != 0) {
            DPRINTF((_T("%s:5 files %s and %s merged, but CS indices don't match\n"),
                driveLetterName, target->fileName, match->fileName));
        } else {
            DPRINTF((_T("%s:6 files %s and %s merged, but CS indices don't match\n"),
                driveLetterName, target->fileName, match->fileName));
        }
    }

    if (csName != NULL) {
        FreeCSName(csName);
        csName = NULL;
    }

#endif

    return merged;
}

/*****************************************************************************/

// Worker() performs the groveling processing.

VOID Groveler::Worker()
{
    FileData target,
             match;

    SGNativeQueueEntry queueEntry;

    FIFO *matchList = NULL;

    Table *csIndexTable = NULL;

    OVERLAPPED mergeSynch = { 0, 0, 0, 0, NULL };

    HANDLE abortMergeEvent = NULL;

    TCHAR *csName;

    DatabaseActionList actionList[MAX_ACTIONS];

    BYTE *buffer1 = NULL,
         *buffer2 = NULL,
         *buffer3 = NULL,
         *buffer4 = NULL;

    DWORD queueIndex,
          bufferSize,
          numCompares,
          numMatches,
          numActions;

#if DBG
    DWORD enqueueTime;
#endif

    LONG num;

    BOOL needToRetry,
         hashed,
         gotMatch,
         filesMatch,
         merged,
         success;

    CLEAR_FILE(target);
    CLEAR_OVERLAPPED(target.oplock);
    target.handle = NULL;

    CLEAR_FILE(match);
    CLEAR_OVERLAPPED(match.oplock);
    match.handle = NULL;

    _set_new_handler(NewHandler);

// Create the events.

    try {

        if ((target.oplock   .hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL
         || (match .oplock   .hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL
         || (target.readSynch.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL
         || (match .readSynch.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL
         || (mergeSynch      .hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL
         || (abortMergeEvent         = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL) {
            DPRINTF((_T("%s: unable to create events: %lu\n"),
                driveLetterName, GetLastError()));
            throw INITIALIZE_ERROR;
        }

// Allocate and align the file buffers.

        bufferSize = SIG_PAGE_SIZE > CMP_PAGE_SIZE ? SIG_PAGE_SIZE : CMP_PAGE_SIZE
                   + sectorSize;
        buffer1 = new BYTE[bufferSize];
        ASSERT(buffer1 != NULL);
        buffer2 = new BYTE[bufferSize];
        ASSERT(buffer2 != NULL);
        buffer3 = new BYTE[bufferSize];
        ASSERT(buffer3 != NULL);
        buffer4 = new BYTE[bufferSize];
        ASSERT(buffer4 != NULL);

        ASSERT(inUseFileID1 == NULL);
        ASSERT(inUseFileID2 == NULL);

        inUseFileID1 = &target.entry.fileID;
        inUseFileID2 = &match .entry.fileID;

        target.buffer[0] = buffer1 + sectorSize - (PtrToUlong(buffer1) % sectorSize);
        target.buffer[1] = buffer2 + sectorSize - (PtrToUlong(buffer2) % sectorSize);
        match .buffer[0] = buffer3 + sectorSize - (PtrToUlong(buffer3) % sectorSize);
        match .buffer[1] = buffer4 + sectorSize - (PtrToUlong(buffer4) % sectorSize);

// Signal to grovel() that this thread is alive,
// then wait for it to signal to start.

        grovelStatus = Grovel_ok;
        ASSERT(IsReset(grovelStopEvent));
        success = SetEvent(grovelStopEvent);
        ASSERT_ERROR(success);

        WaitForEvent(grovelStartEvent);
        if (terminate)
            throw TERMINATE;

#ifdef _CRTDBG
_CrtMemState s[2], sdiff;
int stateIndex = 0;

_CrtMemCheckpoint(&s[stateIndex]);
stateIndex = 1;
#endif

// The main loop.

        while (TRUE) {
            try {

#ifdef _CRTDBG
_CrtMemCheckpoint(&s[stateIndex]);

if (_CrtMemDifference(&sdiff, &s[stateIndex^1], &s[stateIndex]))
    _CrtMemDumpStatistics(&sdiff);
stateIndex ^= 1;
#endif

                hashed      = FALSE;
                numCompares = 0;
                numMatches  = 0;
                merged      = FALSE;
                needToRetry = FALSE;

// Get a target file.  abortGroveling is set when scan_volume is attempting to
// sync up with this thread.  We stop here, a safe place to let scan_volume
// replace the database.

                if (abortGroveling || !GetTarget(&target, &queueIndex)) {
                    CLEAR_FILE(target);

                    grovelStatus = Grovel_ok;
                    ASSERT(IsReset(grovelStopEvent));
                    success = SetEvent(grovelStopEvent);
                    ASSERT_ERROR(success);

                    WaitForEvent(grovelStartEvent);
                    if (terminate)
                        throw TERMINATE;

                    continue;
                }

// Calculate the target file's signature.

                hashed = TRUE;

                CalculateSignature(&target);

// Get a list of match files.

                ASSERT(matchList    == NULL);
                ASSERT(csIndexTable == NULL);

                matchList = new FIFO();
                ASSERT(matchList != NULL);

                csIndexTable = new Table();
                ASSERT(csIndexTable != NULL);

                GetMatchList(&target, matchList, csIndexTable);

// Compare the target file to each match file until a matching file is found
// or all comparisons fail. Try the SIS files first, then the regular files.

                while (TRUE) {
                    try {

                        gotMatch = FALSE;

                        if (!gotMatch && csIndexTable != NULL) {
                            gotMatch = GetCSFile(&target, &match, csIndexTable);
                            if (!gotMatch) {
                                delete csIndexTable;
                                csIndexTable = NULL;
                            }
                        }

                        if (!gotMatch && matchList != NULL) {
                            gotMatch = GetMatch(&target, &match, matchList);
                            if (!gotMatch) {
                                delete matchList;
                                matchList = NULL;
                            }
                        }

// After comparing the target file to every file on both
// lists, close the target file and update the database,
// then go on to process the next target file.

                        if (!gotMatch) {
                            CloseFile(&target);

                            numActions                 =  3;
                            actionList[0].type         =  TABLE_DELETE_BY_FILE_ID;
                            actionList[0].u.fileID     =  target.entry.fileID;
                            actionList[1].type         =  TABLE_PUT;
                            actionList[1].u.tableEntry = &target.entry;
                            actionList[2].type         =  QUEUE_DELETE;
                            actionList[2].u.queueIndex =  queueIndex;

                            if (needToRetry) {
                                queueEntry.fileID    = target.entry.fileID;
                                queueEntry.parentID  = target.parentID;
                                queueEntry.reason    = 0;
                                queueEntry.fileName  = NULL;

                                queueEntry.retryTime = target.retryTime * 2; // Exponential back-off
                                if (queueEntry.retryTime < grovelInterval)
                                    queueEntry.retryTime = grovelInterval;
                                queueEntry.readyTime = GetTime() + queueEntry.retryTime;

                                numActions                 =  4;
                                actionList[3].type         =  QUEUE_PUT;
                                actionList[3].u.queueEntry = &queueEntry;
                            }

#if DBG

                            if (!HasCSIndex(target.entry.csIndex)) {
                                TRACE_PRINTF(TC_groveler, 4,
                                    (_T("%s: adding file {%s, %I64u, 0x%016I64x} to table\n"),
                                    driveLetterName, target.fileName, target.entry.fileSize,
                                    target.entry.signature));
                            } else {
                                csName = GetCSName(&target.entry.csIndex);
                                TRACE_PRINTF(TC_groveler, 4,
                                    (_T("%s: adding file {%s, %I64u, 0x%016I64x, %s} to table\n"),
                                    driveLetterName, target.fileName, target.entry.fileSize,
                                    target.entry.signature, csName != NULL ? csName : _T("...")));
                                if (csName != NULL) {
                                    FreeCSName(csName);
                                    csName = NULL;
                                }
                            }

                            if (needToRetry) {
                                enqueueTime = (DWORD)(queueEntry.retryTime / 10000);
                                DPRINTF((_T("   Re-enqueuing target file %s to be groveled in %lu.%03lu sec\n"),
                                    target.fileName, enqueueTime / 1000, enqueueTime % 1000));
                            }

#endif

                            DoTransaction(numActions, actionList);
                            break;
                        }

// Compare the target file with this match file.

                        numCompares++;

                        ASSERT(!inCompare);
                        inCompare  = TRUE;
                        filesMatch = Compare(&target, &match);
                        inCompare  = FALSE;

                        if (!filesMatch) {
                            CloseFile(&match);
                            CLEAR_FILE(match);
                            continue;
                        }

// If the target and match files are identical, go on to merge them.

                        numMatches++;

                        merged = Merge(&target, &match, &mergeSynch, abortMergeEvent);

// Update the database as follows:
//
// - Update the target file's table entry.
//
// - If the merge succeeded and the match file was a regular file,
//   update the match file's table entry.
//
// - If the merge failed, re-enqueue the target file to be groveled again.

                        numActions                 =  3;
                        actionList[0].type         =  TABLE_DELETE_BY_FILE_ID;
                        actionList[0].u.fileID     =  target.entry.fileID;
                        actionList[1].type         =  TABLE_PUT;
                        actionList[1].u.tableEntry = &target.entry;
                        actionList[2].type         =  QUEUE_DELETE;
                        actionList[2].u.queueIndex =  queueIndex;

                        if (merged) {
                            if (match.entry.fileID != 0) {
                                actionList[numActions  ].type         =  TABLE_DELETE_BY_FILE_ID;
                                actionList[numActions++].u.fileID     =  match.entry.fileID;
                                actionList[numActions  ].type         =  TABLE_PUT;
                                actionList[numActions++].u.tableEntry = &match.entry;
                            }
                        } else {
                            queueEntry.fileID    = target.entry.fileID;
                            queueEntry.parentID  = target.parentID;
                            queueEntry.reason    = 0;
                            queueEntry.fileName  = NULL;

                            queueEntry.retryTime = target.retryTime * 2; // Exponential back-off
                            if (queueEntry.retryTime < grovelInterval)
                                queueEntry.retryTime = grovelInterval;
                            queueEntry.readyTime = GetTime() + queueEntry.retryTime;

                            actionList[numActions  ].type         =  QUEUE_PUT;
                            actionList[numActions++].u.queueEntry = &queueEntry;
                        }

#if DBG

                        if (!HasCSIndex(target.entry.csIndex)) {
                            TPRINTF((_T("%s: adding file {%s, %I64u, 0x%016I64x} to table\n"),
                                driveLetterName, target.fileName, target.entry.fileSize,
                                target.entry.signature));
                        } else {
                            csName = GetCSName(&target.entry.csIndex);
                            TPRINTF((_T("%s: adding file {%s, %I64u, 0x%016I64x, %s} to table\n"),
                                driveLetterName, target.fileName, target.entry.fileSize,
                                target.entry.signature, csName != NULL ? csName : _T("...")));
                            if (csName != NULL) {
                                FreeCSName(csName);
                                csName = NULL;
                            }
                        }

                        if (!merged) {
                            enqueueTime = (DWORD)(queueEntry.retryTime / 10000);
                            DPRINTF((_T("   Re-enqueuing target file %s to be groveled in %lu.%03lu sec\n"),
                                target.fileName, enqueueTime / 1000, enqueueTime % 1000));
                        }

#endif

                        DoTransaction(numActions, actionList);
                        break;
                    }

// Match exceptions

                    catch (MatchException matchException) {

                        inCompare = FALSE;

                        switch (matchException) {

// MATCH_INVALID: the match file doesn't exist or is disallowed. Close the file
// and remove its entry from the table, then go on to try the next match file.

                            case MATCH_INVALID:

                                CloseFile(&match);

                                if (match.entry.fileID != 0) {
                                    ASSERT(!HasCSIndex(match.entry.csIndex));
                                    num = sgDatabase->TableDeleteByFileID(match.entry.fileID);
                                    if (num < 0)
                                        throw DATABASE_ERROR;
                                    ASSERT(num == 1);
                                } else {
                                    ASSERT(HasCSIndex(match.entry.csIndex));
                                    num = sgDatabase->TableDeleteByCSIndex(&match.entry.csIndex);
                                    if (num < 0)
                                        throw DATABASE_ERROR;
                                    ASSERT(num > 0);
                                }

                                CLEAR_FILE(match);
                                break;

// MATCH_ERROR: an error occured while opening or reading the match
// file. Close the file and mark that the target file may need to be
// groveled again, then go on to try the next match file.

                            case MATCH_ERROR:

                                CloseFile(&match);
                                CLEAR_FILE(match);
                                needToRetry = TRUE;
                                break;

// MATCH_STALE: the match file table entry is invalid for some reason.
// Close the file, remove its entry from the table, enqueue
// it to be re-groveled, then go on to the next match file.

                            case MATCH_STALE:

                                CloseFile(&match);

                                if (match.entry.fileID != 0) {

                                    queueEntry.fileID    = match.entry.fileID;
                                    queueEntry.parentID  = match.parentID;
                                    queueEntry.reason    = 0;
                                    queueEntry.readyTime = GetTime() + grovelInterval;
                                    queueEntry.retryTime = 0;
                                    queueEntry.fileName  = NULL;

                                    numActions                 =  2;
                                    actionList[0].type         =  TABLE_DELETE_BY_FILE_ID;
                                    actionList[0].u.fileID     =  match.entry.fileID;
                                    actionList[1].type         =  QUEUE_PUT;
                                    actionList[1].u.queueEntry = &queueEntry;
#if DBG
                                    enqueueTime = (DWORD)(grovelInterval / 10000);
                                    DPRINTF((_T("   Enqueuing match file %s to be groveled in %lu.%03lu sec\n"),
                                        match.fileName, enqueueTime / 1000, enqueueTime % 1000));
#endif

                                    DoTransaction(numActions, actionList);

                                } else {

                                    ASSERT(HasCSIndex(match.entry.csIndex));
                                    EnqueueCSIndex(&match.entry.csIndex);

                                }

                                CLEAR_FILE(match);
                                break;

                            default:

                                ASSERT_PRINTF(FALSE, (_T("matchException=%lu\n"),
                                    matchException));
                        }
                    }
                }
            }

// Target exceptions

            catch (TargetException targetException) {

                inCompare = FALSE;

                DPRINTF((_T("WORKER: Handling TargetException %d, status=%d\n"),
                    targetException,GetLastError()));

                switch (targetException) {

// TARGET_INVALID: the target file is invalid for some reason: it doesn't
// exist, it is disallowed properties, it is in the queue by both file
// name and file ID, or it was in the queue by file name and has already
// been groveled. Close the files, remove the target file's entry from
// the table, then go on to grovel the next target file.

                    case TARGET_INVALID:

                        CloseFile(&target);
                        CloseFile(&match);

                        if (matchList != NULL) {
                            delete matchList;
                            matchList = NULL;
                        }

                        if (csIndexTable != NULL) {
                            delete csIndexTable;
                            csIndexTable = NULL;
                        }

                        numActions                 = 1;
                        actionList[0].type         = QUEUE_DELETE;
                        actionList[0].u.queueIndex = queueIndex;

                        if (target.entry.fileID != 0) {
                            numActions             = 2;
                            actionList[1].type     = TABLE_DELETE_BY_FILE_ID;
                            actionList[1].u.fileID = target.entry.fileID;
                        }

                        DoTransaction(numActions, actionList);
                        break;

// An error occured while opening or reading the target file. Close
// the files and re-enqueue the target file to be groveled again.

                    case TARGET_ERROR:

                        ASSERT(target.entry.fileID != 0
                            || target.fileName[0]  != _T('\0'));

                        CloseFile(&target);
                        CloseFile(&match);

                        queueEntry.fileID    = target.entry.fileID;
                        queueEntry.parentID  = target.parentID;
                        queueEntry.reason    = 0;
                        queueEntry.fileName  = target.entry.fileID == 0
                                             ? target.fileName : NULL;

                        queueEntry.retryTime = target.retryTime * 2; // Exponential back-off
                        if (queueEntry.retryTime < grovelInterval)
                            queueEntry.retryTime = grovelInterval;
                        queueEntry.readyTime = GetTime() + queueEntry.retryTime;

                        actionList[0].type         =  QUEUE_DELETE;
                        actionList[0].u.queueIndex =  queueIndex;
                        actionList[1].type         =  QUEUE_PUT;
                        actionList[1].u.queueEntry = &queueEntry;

#if DBG
                        enqueueTime = (DWORD)(queueEntry.retryTime / 10000);
                        if (target.entry.fileID != 0) {
                            DPRINTF((_T("   Re-enqueuing target file %s to be groveled in %lu.%03lu sec\n"),
                                target.fileName, enqueueTime / 1000, enqueueTime % 1000));
                        } else {
                            DPRINTF((_T("   Re-enqueuing target file %s to be groveled in %lu.%03lu sec\n"),
                                target.fileName, enqueueTime / 1000, enqueueTime % 1000));
                        }
#endif

                        DoTransaction(2, actionList);
                        break;

                    default:

                        ASSERT_PRINTF(FALSE, (_T("targetException=%lu\n"),
                            targetException));
                }
            }

// Do some clean-up.

            ASSERT(target.handle == NULL);
            ASSERT(match .handle == NULL);

            if (matchList != NULL) {
                delete matchList;
                matchList = NULL;
            }

            if (csIndexTable != NULL) {
                delete csIndexTable;
                csIndexTable = NULL;
            }

// Update the activity counters for this target file,
// then go on to process the next file.

            if (hashed) {
                hashCount++;
                hashBytes += target.entry.fileSize;
            }

            compareCount += numCompares;
            compareBytes += numCompares * target.entry.fileSize;

            matchCount += numMatches;
            matchBytes += numMatches * target.entry.fileSize;

            if (merged) {
                mergeCount++;
                mergeBytes += target.entry.fileSize;
            }

            CLEAR_FILE(target);
            CLEAR_FILE(match);

            CLEAR_OVERLAPPED(mergeSynch);
        }
    }

// Terminal exceptions

    catch (TerminalException terminalException) {
        switch (terminalException) {

            case INITIALIZE_ERROR:
                break;

// DATABASE_ERROR: an error occured in the database. Return an error status.

            case DATABASE_ERROR:
                break;

// MEMORY_ERROR: unable to allocate memory. Return an error status.

            case MEMORY_ERROR:
                DPRINTF((_T("%s: Unable to allocate memory\n"),
                    driveLetterName));
                break;

// TERMINATE: grovel() signaled for this thread to terminate.

            case TERMINATE:
                break;

            default:
                ASSERT_PRINTF(FALSE, (_T("terminalException=%lu\n"),
                    terminalException));
        }
    }

// Close the files and clean up.

    CloseFile(&target);
    CloseFile(&target);

    CLEAR_FILE(target);
    CLEAR_FILE(match);

    if (matchList != NULL) {
        delete matchList;
        matchList = NULL;
    }

    if (csIndexTable != NULL) {
        delete csIndexTable;
        csIndexTable = NULL;
    }

    if (target.oplock.hEvent != NULL) {
        success = CloseHandle(target.oplock.hEvent);
        ASSERT_ERROR(success);
        target.oplock.hEvent = NULL;
    }
    if (match.oplock.hEvent != NULL) {
        success = CloseHandle(match.oplock.hEvent);
        ASSERT_ERROR(success);
        match.oplock.hEvent = NULL;
    }
    if (target.readSynch.hEvent != NULL) {
        success = CloseHandle(target.readSynch.hEvent);
        ASSERT_ERROR(success);
        target.readSynch.hEvent = NULL;
    }
    if (match.readSynch.hEvent != NULL) {
        success = CloseHandle(match.readSynch.hEvent);
        ASSERT_ERROR(success);
        match.readSynch.hEvent = NULL;
    }
    if (mergeSynch.hEvent != NULL) {
        success = CloseHandle(mergeSynch.hEvent);
        ASSERT_ERROR(success);
        mergeSynch.hEvent = NULL;
    }
    if (abortMergeEvent != NULL) {
        success = CloseHandle(abortMergeEvent);
        ASSERT_ERROR(success);
        abortMergeEvent = NULL;
    }

    if (buffer1 != NULL) {
        delete [] buffer1;
        buffer1 = NULL;
    }
    if (buffer2 != NULL) {
        delete [] buffer2;
        buffer2 = NULL;
    }
    if (buffer3 != NULL) {
        delete [] buffer3;
        buffer3 = NULL;
    }
    if (buffer4 != NULL) {
        delete [] buffer4;
        buffer4 = NULL;
    }

    inUseFileID1 = NULL;
    inUseFileID2 = NULL;

// Signal grovel() that this thread is terminating by
// setting the grovelStop event with an error status.

    grovelThread = NULL;

    grovelStatus = Grovel_error;
    ASSERT(IsReset(grovelStopEvent));
    success = SetEvent(grovelStopEvent);
    ASSERT_ERROR(success);
}

/*****************************************************************************/
/******************* Groveler class static private methods *******************/
/*****************************************************************************/

// WorkerThread() runs in its own thread.
// It calls Worker() to perform the groveling processing.

DWORD Groveler::WorkerThread(VOID *groveler)
{
    ((Groveler *)groveler)->Worker();
    return 0; // Dummy return value
}

/*****************************************************************************/
/*********************** Groveler class public methods ***********************/
/*****************************************************************************/

BOOL Groveler::set_log_drive(const _TCHAR *drive_name)
{
    return SGDatabase::set_log_drive(drive_name);
}

// is_sis_installed tests whether the SIS filter is
// installed on a volume by calling SIS copyfile.

BOOL Groveler::is_sis_installed(const _TCHAR *drive_name)
{
    HANDLE volHandle;

    SI_COPYFILE copyFile;

    DWORD transferCount,
          lastError;

    BOOL success;

    volHandle = CreateFile(
        drive_name,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_BACKUP_SEMANTICS,
        NULL);

    if (volHandle == INVALID_HANDLE_VALUE)
        return FALSE;

    copyFile.SourceFileNameLength      = 0;
    copyFile.DestinationFileNameLength = 0;
    copyFile.Flags                     = COPYFILE_SIS_REPLACE;

    success = DeviceIoControl(
        volHandle,
        FSCTL_SIS_COPYFILE,
        (VOID *)&copyFile,
        sizeof(SI_COPYFILE),
        NULL,
        0,
        &transferCount,
        NULL);

    lastError = GetLastError();
    ASSERT(!success);

    success = CloseHandle(volHandle);
    ASSERT_ERROR(success);

    switch (lastError) {

        case ERROR_INVALID_FUNCTION:
            return FALSE;

        case ERROR_INVALID_PARAMETER:
            return TRUE;                    //sis is installed on this volume

        default:

            ASSERT_PRINTF(FALSE, (_T("lastError=%lu\n"), lastError));
    }

    return FALSE; // Dummy return value
}

/*****************************************************************************/

// The groveler constructor creates and initializes all class variables.

Groveler::Groveler()
{
    volumeHandle        = NULL;
    grovHandle          = NULL;

    sgDatabase          = NULL;
    driveName           = NULL;
    driveLetterName     = NULL;
    databaseName        = NULL;

    numDisallowedIDs    = 0;
    numDisallowedNames  = 0;
    disallowedIDs       = NULL;
    disallowedNames     = NULL;

    grovelStartEvent    = NULL;
    grovelStopEvent     = NULL;
    grovelThread        = NULL;

    inUseFileID1        = NULL;
    inUseFileID2        = NULL;

    abortGroveling      = FALSE;
    inCompare           = FALSE;
    inScan              = FALSE;
    terminate           = TRUE;

    usnID               = lastUSN = UNINITIALIZED_USN;
}

/*****************************************************************************/

// The groveler destructor destroys all class variables.

Groveler::~Groveler()
{
// If the volume is open, call close() to close it.

    close();

    ASSERT(volumeHandle == NULL);
    ASSERT(grovHandle   == NULL);

    ASSERT(sgDatabase   == NULL);
    ASSERT(driveName    == NULL);
    ASSERT(driveLetterName == NULL);
    ASSERT(databaseName == NULL);

    ASSERT(numDisallowedIDs   == 0);
    ASSERT(numDisallowedNames == 0);
    ASSERT(disallowedIDs      == NULL);
    ASSERT(disallowedNames    == NULL);

    ASSERT(grovelStartEvent   == NULL);
    ASSERT(grovelStopEvent    == NULL);
    ASSERT(grovelThread       == NULL);

    ASSERT(inUseFileID1 == NULL);
    ASSERT(inUseFileID2 == NULL);

    ASSERT(terminate);
    ASSERT(!inCompare);
    ASSERT(!inScan);

    ASSERT(usnID == UNINITIALIZED_USN);
}

/*****************************************************************************/

// Open() opens the specified volume.

GrovelStatus Groveler::open(
    IN const TCHAR  *drive_name,
    IN const TCHAR  *drive_letterName,
    IN BOOL          is_log_drive,
    IN DOUBLE        read_report_discard_threshold,
    IN DWORD         min_file_size,
    IN DWORD         min_file_age,
    IN BOOL          allow_compressed_files,
    IN BOOL          allow_encrypted_files,
    IN BOOL          allow_hidden_files,
    IN BOOL          allow_offline_files,
    IN BOOL          allow_temporary_files,
    IN int           previousGrovelAllPathsState,
    IN DWORD         num_excluded_paths,
    IN const TCHAR **excluded_paths,
    IN DWORD         base_regrovel_interval,
    IN DWORD         max_regrovel_interval)
{
    DWORD threadID;

    TCHAR fileStr[MAX_PATH+1];

    TCHAR listValue[MAX_PATH+1],
         *strPtr;

    USN_JOURNAL_DATA usnJournalData;

    SGNativeListEntry listEntry;

    DWORDLONG fileID;

    DWORD sectorsPerCluster,
          numberOfFreeClusters,
          totalNumberOfClusters,
          bufferSize,
          strLen,
          i;

    GrovelStatus openStatus;

    LONG num;

    BOOL success;

    ASSERT(volumeHandle == NULL);
    ASSERT(grovHandle   == NULL);

    ASSERT(sgDatabase   == NULL);
    ASSERT(databaseName == NULL);

    ASSERT(numDisallowedIDs   == 0);
    ASSERT(numDisallowedNames == 0);
    ASSERT(disallowedIDs      == NULL);
    ASSERT(disallowedNames    == NULL);

    ASSERT(grovelStartEvent   == NULL);
    ASSERT(grovelStopEvent    == NULL);
    ASSERT(grovelThread       == NULL);

    ASSERT(inUseFileID1 == NULL);
    ASSERT(inUseFileID2 == NULL);

    ASSERT(terminate);
    ASSERT(!inCompare);
    ASSERT(!inScan);

    ASSERT(usnID == UNINITIALIZED_USN);

#if 0
while (!IsDebuggerPresent())
    Sleep(2000);

DebugBreak();
#endif

    //
    // Make sure that the filter has run phase 2 initialization if this is
    // a SIS enabled volume.
    //
    is_sis_installed(drive_name);

    //
    //  Get drive name without trailing slash
    //

    int nBufSize = wcslen(drive_name) + 1;      //in chars

    driveName = new TCHAR[nBufSize];

    (void)StringCchCopy(driveName, nBufSize, drive_name);
    TrimTrailingChar(driveName,L'\\');

    //
    //  Get drive Letter name without trailing "\" or ":"
    //

    nBufSize = wcslen(drive_letterName) + 1;    //in chars

    driveLetterName = new TCHAR[nBufSize];

    (void)StringCchCopy(driveLetterName, nBufSize, drive_letterName);

    TrimTrailingChar(driveLetterName,L'\\');
    TrimTrailingChar(driveLetterName,L':');

#ifdef _CRTDBG
    // Send all reports to STDOUT
    _CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_FILE );
    _CrtSetReportFile( _CRT_WARN, _CRTDBG_FILE_STDERR );
    _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_FILE );
    _CrtSetReportFile( _CRT_ERROR, _CRTDBG_FILE_STDERR );
    _CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_FILE );
    _CrtSetReportFile( _CRT_ASSERT, _CRTDBG_FILE_STDERR );
#endif

// Open the volume and the GrovelerFile.  The SIS fsctl
// functions require that we pass in a handle to GrovelerFile as a means
// of proving our "privilege".  An access violation is returned if we don't.

    volumeHandle = CreateFile(
        driveName,
        GENERIC_READ    | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED|FILE_FLAG_BACKUP_SEMANTICS,
        NULL);

    if (volumeHandle == INVALID_HANDLE_VALUE) {
        volumeHandle = NULL;
        DPRINTF((_T("%s: Can't open volume \"%s\" %lu\n"),
                driveLetterName, driveName, GetLastError()));
        close();
        return Grovel_error;
    }

    (void)StringCbCopy(fileStr,sizeof(fileStr),driveName);
    (void)StringCbCat(fileStr,sizeof(fileStr),CS_DIR_PATH);
    (void)StringCbCat(fileStr,sizeof(fileStr),_T("\\"));
    (void)StringCbCat(fileStr,sizeof(fileStr),GROVELER_FILE_NAME);

    grovHandle = CreateFile(
        fileStr,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED,
        NULL);
    if (grovHandle == INVALID_HANDLE_VALUE) {
        grovHandle = NULL;
        DPRINTF((_T("%s: can't open groveler file \"%s\": %lu\n"),
            driveLetterName, fileStr, GetLastError()));
        close();
        return Grovel_error;
    }

    (void)StringCbCopy(fileStr,sizeof(fileStr),driveName);
    (void)StringCbCat(fileStr,sizeof(fileStr),_T("\\"));

    success = GetDiskFreeSpace(fileStr, &sectorsPerCluster, &sectorSize,
        &numberOfFreeClusters, &totalNumberOfClusters);
    ASSERT(success);

    ASSERT(SIG_PAGE_SIZE % sectorSize == 0);
    ASSERT(CMP_PAGE_SIZE % sectorSize == 0);

    sigReportThreshold =
        (DWORD)((DOUBLE)SIG_PAGE_SIZE * read_report_discard_threshold);
    cmpReportThreshold =
        (DWORD)((DOUBLE)CMP_PAGE_SIZE * read_report_discard_threshold);

//
// Open this volume's database. If this fails, create a
// new database. If that fails, return an error status.
//

    ASSERT(databaseName == NULL);
    strLen = _tcslen(driveName) + _tcslen(CS_DIR_PATH) + _tcslen(DATABASE_FILE_NAME) + 1;     // +1 for '\'
    databaseName = new TCHAR[strLen+1];
    ASSERT(databaseName != NULL);

    (void)StringCchPrintf(databaseName, (strLen+1), _T("%s%s\\%s"), driveName, CS_DIR_PATH, DATABASE_FILE_NAME);

    sgDatabase = new SGDatabase();
    if (sgDatabase == NULL) {
        DPRINTF((_T("%s: can't create database object\n"),
            driveLetterName));
        close();
        return Grovel_error;
    }

    openStatus = Grovel_ok;

    if (get_usn_log_info(&usnJournalData) != Grovel_ok) {
        DPRINTF((_T("%s: can't initialize usnID\n"),
            driveLetterName));
    } else {
        usnID = usnJournalData.UsnJournalID;

        if (!sgDatabase->Open(driveLetterName,databaseName, is_log_drive)) {
            DPRINTF((_T("%s: can't open database \"%s\"\n"),
                driveLetterName, databaseName));
        } else {
            listValue[0]    = _T('\0');
            listEntry.name  = LAST_USN_NAME;
            listEntry.value = listValue;
            if (sgDatabase->ListRead(&listEntry) <= 0
             || _stscanf(listValue, _T("%I64x"), &lastUSN) != 1
             || lastUSN == UNINITIALIZED_USN) {
                DPRINTF((_T("%s: can't get last USN value\n"), driveLetterName));
            } else {
                DWORDLONG storedUsnID;

                listValue[0]    = _T('\0');
                listEntry.name  = USN_ID_NAME;
                listEntry.value = listValue;
                if (sgDatabase->ListRead(&listEntry) <= 0
                 || _stscanf(listValue, _T("%I64x"), &storedUsnID) != 1
                 || storedUsnID != usnID) {
                    DPRINTF((_T("%s: can't get USN ID value from database\n"), driveLetterName));
                } else {
                    //
                    //  See if any uncommited operations
                    //

                    num = sgDatabase->StackCount();
                    if (0 == num) {

                        //
                        //  See if the RIS state changed.  If not, we can
                        //  continue.  If so, reset grovel state so we will
                        //  rescan the volume.
                        //
                            
                        if (GrovelAllPaths == previousGrovelAllPathsState) {

                            goto OpenedDatabase;

                        } else {

                            DPRINTF((L"GrovelAllPaths state changed, rescanning the volume\n"));
                        }
                    }
                }
            }
        }
    }

// Set abortGroveling to block the worker thread, and set lastUSN to block extract_log
// until scan_volume starts.

    abortGroveling = TRUE;
    lastUSN = usnID = UNINITIALIZED_USN;
    openStatus = Grovel_new;

OpenedDatabase:

// Create the disallowed directories list.

    if (num_excluded_paths == 0) {
        disallowedIDs   = NULL;
        disallowedNames = NULL;
    } else {
        disallowedIDs   = new DWORDLONG[num_excluded_paths];
        disallowedNames = new TCHAR *  [num_excluded_paths];
        ASSERT(disallowedIDs   != NULL);
        ASSERT(disallowedNames != NULL);

        for (i = 0; i < num_excluded_paths; i++) {
            ASSERT(excluded_paths[i] != NULL);

            if (excluded_paths[i][0] == _T('\\')) {
                strLen = _tcslen(excluded_paths[i]);
                while (strLen > 1 && excluded_paths[i][strLen-1] == _T('\\'))
                    strLen--;

                strPtr = new TCHAR[strLen+1];
                ASSERT(strPtr != NULL);
                disallowedNames[numDisallowedNames++] = strPtr;

                _tcsncpy(strPtr, excluded_paths[i], strLen);
                strPtr[strLen] = _T('\0');

                fileID = GetFileID(drive_name,strPtr);
                if (fileID != 0) {
                    disallowedIDs[numDisallowedIDs++] = fileID;
                }
                TPRINTF((L"%s: Exclude path=\"%s\", ID=%04I64x.%012I64x\n",
                         driveLetterName,
                         strPtr, 
                         ((fileID >> 48) & 0xffff),
                         (fileID & 0xffffffffffff)));
            }
        }

        if (numDisallowedNames == 0) {
            delete disallowedNames;
            disallowedNames = NULL;
        } else if (numDisallowedNames > 1)
            qsort(
                disallowedNames,
                numDisallowedNames,
                sizeof(TCHAR *),
                qsStringCompare);

        if (numDisallowedIDs == 0) {
            delete disallowedIDs;
            disallowedIDs = NULL;
        } else if (numDisallowedIDs > 1)
            qsort(
                disallowedIDs,
                numDisallowedIDs,
                sizeof(DWORDLONG),
                FileIDCompare);
    }

//
// Set the remaining class values.
//
// minFileAge is expressed in 10^-7 seconds, min_file_age in milliseconds.
//

    minFileSize    = min_file_size > MIN_FILE_SIZE ? min_file_size : MIN_FILE_SIZE;
    minFileAge     = min_file_age  * 10000;
    grovelInterval = minFileAge > MIN_GROVEL_INTERVAL ? minFileAge : MIN_GROVEL_INTERVAL;

    disallowedAttributes =           FILE_ATTRIBUTE_DIRECTORY
     | (allow_compressed_files ? 0 : FILE_ATTRIBUTE_COMPRESSED)
     | (allow_encrypted_files  ? 0 : FILE_ATTRIBUTE_ENCRYPTED)
     | (allow_hidden_files     ? 0 : FILE_ATTRIBUTE_HIDDEN)
     | (allow_offline_files    ? 0 : FILE_ATTRIBUTE_OFFLINE)
     | (allow_temporary_files  ? 0 : FILE_ATTRIBUTE_TEMPORARY);

//
// Create the events used to handshake with the worker thread.
//

    if ((grovelStartEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL
     || (grovelStopEvent  = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL) {
        DPRINTF((_T("%s: unable to create events: %lu\n"),
            driveLetterName, GetLastError()));
        close();
        return Grovel_error;
    }

//
// Create the worker thread, then wait for it to set
// the grovelStop event to announce its existence.
//

    terminate = FALSE;

    grovelThread = CreateThread(
        NULL,
        0,
        WorkerThread,
        (VOID *)this,
        0,
        &threadID);
    if (grovelThread == NULL) {
        DPRINTF((_T("%s: can't create the worker thread: %lu\n"),
            driveLetterName, GetLastError()));
        close();
        return Grovel_error;
    }

    WaitForEvent(grovelStopEvent);

    if (grovelStatus == Grovel_error) {
        grovelThread = NULL;
        close();
        return Grovel_error;
    }
    ASSERT(grovelStatus == Grovel_ok);

    return openStatus;
}

/*****************************************************************************/

GrovelStatus Groveler::close()
{
    DWORD i;

    LONG num;

    BOOL success;

// If active, signal the worker thread to stop,
// then wait for it to acknowledge.

    terminate = TRUE;

    if (grovelThread != NULL) {
        ASSERT(grovelStartEvent != NULL);
        ASSERT(grovelStopEvent  != NULL);

        timeAllotted = INFINITE;
        do {
            ASSERT(IsReset(grovelStartEvent));
            success = SetEvent(grovelStartEvent);
            ASSERT_ERROR(success);
            WaitForEvent(grovelStopEvent);
        } while (grovelStatus != Grovel_error);

        grovelThread = NULL;
    }

    inCompare = FALSE;
    inScan    = FALSE;
    usnID     = UNINITIALIZED_USN;

    ASSERT(inUseFileID1 == NULL);
    ASSERT(inUseFileID2 == NULL);

// Close the events.

    if (grovelStartEvent != NULL) {
        success = CloseHandle(grovelStartEvent);
        ASSERT_ERROR(success);
        grovelStartEvent = NULL;
    }

    if (grovelStopEvent != NULL) {
        success = CloseHandle(grovelStopEvent);
        ASSERT_ERROR(success);
        grovelStopEvent = NULL;
    }

// If the volume or GrovelerFile are open, close them.

    if (volumeHandle != NULL) {
        success = CloseHandle(volumeHandle);
        ASSERT_ERROR(success);
        volumeHandle = NULL;
    }

    if (grovHandle != NULL) {
        success = CloseHandle(grovHandle);
        ASSERT_ERROR(success);
        grovHandle = NULL;
    }

// Close this volume's database.

    if (sgDatabase != NULL) {
        delete sgDatabase;
        sgDatabase = NULL;
    }

    if (databaseName != NULL) {
        delete[] databaseName;
        databaseName = NULL;
    }

// Deallocate the disallowed directory lists.

    if (numDisallowedNames == 0) {
        ASSERT(disallowedNames == NULL);
    } else {
        for (i = 0; i < numDisallowedNames; i++)
            delete (disallowedNames[i]);
        delete disallowedNames;
        disallowedNames    = NULL;
        numDisallowedNames = 0;
    }

    if (numDisallowedIDs == 0) {
        ASSERT(disallowedIDs == NULL);
    } else {
        delete disallowedIDs;
        disallowedIDs    = NULL;
        numDisallowedIDs = 0;
    }

    if (driveName != NULL) {
        delete[] driveName;
        driveName = NULL;
    }

    if (driveLetterName != NULL) {
        delete[] driveLetterName;
        driveLetterName = NULL;
    }

    return Grovel_ok;
}

/*****************************************************************************/

// grovel() is the front-end method for controlling the groveling
// process on each NTFS volume. The groveling process itself is
// implemented in the Worker() method. grovel() starts the groveling
// process by setting the grovelStart event. Worker() signals back to
// grovel() that it is finished or has used up its time allocation by
// setting the grovelStop event, which causes grovel() to return.

GrovelStatus Groveler::grovel(
    IN  DWORD      time_allotted,

    OUT DWORD     *hash_read_ops,
    OUT DWORD     *hash_read_time,
    OUT DWORD     *count_of_files_hashed,
    OUT DWORDLONG *bytes_of_files_hashed,

    OUT DWORD     *compare_read_ops,
    OUT DWORD     *compare_read_time,
    OUT DWORD     *count_of_files_compared,
    OUT DWORDLONG *bytes_of_files_compared,

    OUT DWORD     *count_of_files_matching,
    OUT DWORDLONG *bytes_of_files_matching,

    OUT DWORD     *merge_time,
    OUT DWORD     *count_of_files_merged,
    OUT DWORDLONG *bytes_of_files_merged,

    OUT DWORD     *count_of_files_enqueued,
    OUT DWORD     *count_of_files_dequeued)
{
    DWORD timeConsumed;

    BOOL success;

    ASSERT(volumeHandle != NULL);

    hashCount     = 0;
    hashReadCount = 0;
    hashReadTime  = 0;
    hashBytes     = 0;

    compareCount     = 0;
    compareReadCount = 0;
    compareReadTime  = 0;
    compareBytes     = 0;

    matchCount = 0;
    matchBytes = 0;

    mergeCount = 0;
    mergeTime  = 0;
    mergeBytes = 0;

    numFilesEnqueued = 0;
    numFilesDequeued = 0;

#ifdef DEBUG_UNTHROTTLED
    timeAllotted = INFINITE;
#else
    timeAllotted = time_allotted;
#endif

    startAllottedTime = GetTickCount();

    ASSERT(IsReset(grovelStartEvent));
    success = SetEvent(grovelStartEvent);
    ASSERT_ERROR(success);
    WaitForEvent(grovelStopEvent);
    timeConsumed = GetTickCount() - startAllottedTime;

// Return the performance statistics.

    if (count_of_files_hashed   != NULL)
        *count_of_files_hashed   = hashCount;
    if (hash_read_ops           != NULL)
        *hash_read_ops           = hashReadCount;
    if (hash_read_time          != NULL)
        *hash_read_time          = hashReadTime;
    if (bytes_of_files_hashed   != NULL)
        *bytes_of_files_hashed   = hashBytes;

    if (count_of_files_compared != NULL)
        *count_of_files_compared = compareCount;
    if (compare_read_ops        != NULL)
        *compare_read_ops        = compareReadCount;
    if (compare_read_time       != NULL)
        *compare_read_time       = compareReadTime;
    if (bytes_of_files_compared != NULL)
        *bytes_of_files_compared = compareBytes;

    if (count_of_files_matching != NULL)
        *count_of_files_matching = matchCount;
    if (bytes_of_files_matching != NULL)
        *bytes_of_files_matching = matchBytes;

    if (count_of_files_merged   != NULL)
        *count_of_files_merged   = mergeCount;
    if (merge_time              != NULL)
        *merge_time              = mergeTime;
    if (bytes_of_files_merged   != NULL)
        *bytes_of_files_merged   = mergeBytes;

    if (count_of_files_enqueued != NULL)
        *count_of_files_enqueued = numFilesEnqueued;
    if (count_of_files_dequeued != NULL)
        *count_of_files_dequeued = numFilesDequeued;

    TRACE_PRINTF(TC_groveler, 2,
        (_T("%s            Count   Reads   Bytes Time (sec)\n"),
        driveLetterName));
    TRACE_PRINTF(TC_groveler, 2,
        (_T("  Hashings: %7lu %7lu %7I64u %4lu.%03lu    Time: %5lu.%03lu sec\n"),
        hashCount, hashReadCount, hashBytes,
        hashReadTime / 1000, hashReadTime % 1000,
        timeConsumed / 1000, timeConsumed % 1000));
    TRACE_PRINTF(TC_groveler, 2,
        (_T("  Compares: %7lu %7lu %7I64u %4lu.%03lu    Enqueues: %lu\n"),
        compareCount, compareReadCount, compareBytes,
        compareReadTime / 1000, compareReadTime % 1000, numFilesEnqueued));
    TRACE_PRINTF(TC_groveler, 2,
        (_T("  Matches:  %7lu         %7I64u             Dequeues: %lu\n"),
        matchCount, matchBytes, numFilesDequeued));
    TRACE_PRINTF(TC_groveler, 2,
        (_T("  Merges:   %7lu         %7I64u %4lu.%03lu\n"),
        mergeCount, mergeBytes, mergeTime / 1000, mergeTime % 1000));

    return grovelStatus;
}

/*****************************************************************************/

// count_of_files_in_queue() returns a count of the number
// of files in this volume's queue waiting to be groveled.

DWORD Groveler::count_of_files_in_queue() const
{
    LONG numEntries;

    ASSERT(volumeHandle != NULL);
    ASSERT(sgDatabase   != NULL);

    numEntries = sgDatabase->QueueCount();
    if (numEntries < 0)
        return 0;

    TPRINTF((_T("%s: count_of_files_in_queue=%ld\n"),
        driveLetterName, numEntries));

    return (DWORD)numEntries;
}

/*****************************************************************************/

// count_of_files_to_compare() returns 1 if two files are ready to be
// compared or are in the process of being compared, and 0 otherwise.

DWORD Groveler::count_of_files_to_compare() const
{
    DWORD numCompareFiles;

    ASSERT(volumeHandle != NULL);
    ASSERT(sgDatabase   != NULL);

    numCompareFiles = inCompare ? 1 : 0;

    TPRINTF((_T("%s: count_of_files_to_compare=%lu\n"),
        driveLetterName, numCompareFiles));

    return numCompareFiles;
}

/*****************************************************************************/

// time_to_first_file_ready() returns the time in milliseconds until
// the first entry in the queue is ready to be groveled. If the queue
// is empty, it returns INFINITE. If an error occurs, it returns 0.

DWORD Groveler::time_to_first_file_ready() const
{
    SGNativeQueueEntry queueEntry;

    DWORDLONG currentTime;

    DWORD earliestTime;

    LONG num;

    ASSERT(volumeHandle != NULL);
    ASSERT(sgDatabase   != NULL);

    queueEntry.fileName = NULL;
    num = sgDatabase->QueueGetFirst(&queueEntry);
    if (num < 0)
        return 0;

    if (num == 0)
        earliestTime = INFINITE;
    else {
        ASSERT(num == 1);
        currentTime  = GetTime();
        earliestTime = queueEntry.readyTime > currentTime
                     ? (DWORD)((queueEntry.readyTime - currentTime) / 10000)
                     : 0;
    }

    TPRINTF((_T("%s: time_to_first_file_ready=%lu.%03lu\n"),
        driveLetterName, earliestTime / 1000, earliestTime % 1000));

    return earliestTime;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\inifile.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    inifile.h

Abstract:

	SIS Groveler initialization file interface headers

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_INIFILE

#define _INC_INIFILE

#ifndef _DEF_ENTRY_INFO
#define _DEF_ENTRY_INFO

enum EntryType
{
	entry_bool,
	entry_char,
	entry_int,
	entry_int64,
	entry_double
};

struct EntrySpec
{
	const _TCHAR *identifier;
	EntryType type;
	const _TCHAR *default_value;
	void *pointer;
};

#endif	/* _DEF_ENTRY_INFO */

class IniFile
{
public:

	static bool read(
		const _TCHAR *filename,
		const _TCHAR *section,
		int num_entries,
		EntrySpec *entries);

	static bool overwrite(
		const _TCHAR *filename,
		const _TCHAR *section,
		int num_entries,
		EntrySpec *entries);

	static bool	read_string_set(
		const _TCHAR *filename,
		const _TCHAR *section,
		int *num_strings,
		_TCHAR ***strings,
		_TCHAR **buffer);

private:

	enum {id_buffer_length = 256};

	static void load_string_into_value(
		EntryType type,
		const _TCHAR *string,
		void *value);

	static void store_value_in_string(
		EntryType type,
		void *value,
		_TCHAR *string,
		int stringLen);  //in bytes

	IniFile() {}
	~IniFile() {}
};

#endif	/* _INC_INIFILE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\groveler.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	groveler.h

Abstract:

	SIS Groveler file groveling headers

Authors:

	Cedric Krumbein, 1998

Environment:

	User Mode

Revision History:

--*/

#define CS_DIR_PATH                     _T("\\SIS Common Store")
#define GROVELER_FILE_NAME              _T("GrovelerFile")
#define DATABASE_FILE_NAME              _T("database.mdb")
#define DATABASE_DELETE_RES_FILE_NAME   _T("res*.log")
#define DATABASE_DELETE_LOG_FILE_NAME   _T("*.log")
#define LAST_USN_NAME                   _T("LastUSN")
#define USN_ID_NAME                     _T("UsnID")

#define MIN_FILE_SIZE                1
#define MIN_GROVEL_INTERVAL  600000000 // One minute
#define SIG_PAGE_SIZE             4096
#define CMP_PAGE_SIZE            65536
#define MAX_ACTIONS_PER_TRANSACTION 64

#define UNINITIALIZED_USN MAXLONGLONG


// Groveler class definitions

enum GrovelStatus {
	Grovel_ok,
	Grovel_pending,
	Grovel_error,
	Grovel_overrun,
	Grovel_new,
	Grovel_disable
};


struct FileData {
	SGNativeTableEntry entry;
	DWORDLONG          parentID,
	                   retryTime;
	HANDLE             handle;
	DWORD              startTime,
	                   stopTime;
	OVERLAPPED         readSynch,
	                   oplock;
	TCHAR              fileName[MAX_PATH+1];
	BYTE              *buffer  [2];
};

enum DatabaseActionType {
	TABLE_PUT,
	TABLE_DELETE_BY_FILE_ID,
	QUEUE_PUT,
	QUEUE_DELETE
};

struct DatabaseActionList {
	DatabaseActionType type;
	union {
		SGNativeTableEntry *tableEntry;
		DWORDLONG           fileID;
		SGNativeQueueEntry *queueEntry;
		DWORD               queueIndex;
	} u;
};


class Groveler {
private:

	TCHAR *driveName,
	      *driveLetterName,
          *databaseName,
	     **disallowedNames;

	DWORD sectorSize,
	      sigReportThreshold,
	      cmpReportThreshold,
	      numDisallowedNames,
	      numDisallowedIDs,
	      disallowedAttributes,
	      startAllottedTime,
	      timeAllotted,
	      hashCount,
	      hashReadCount,
	      hashReadTime,
	      compareCount,
	      compareReadCount,
	      compareReadTime,
	      matchCount,
	      mergeCount,
	      mergeTime,
	      numFilesEnqueued,
	      numFilesDequeued;

	DWORDLONG *disallowedIDs,
	          *inUseFileID1,
	          *inUseFileID2,
	           usnID,
	           minFileSize,
	           minFileAge,
	           grovelInterval,
	           lastUSN,
	           hashBytes,
	           compareBytes,
	           matchBytes,
	           mergeBytes;

	HANDLE volumeHandle,
           grovHandle,
	       grovelStartEvent,
	       grovelStopEvent,
	       grovelThread;

	SGDatabase *sgDatabase;

	GrovelStatus grovelStatus;

	BOOL abortGroveling,
         inScan,
	     inCompare,
	     terminate;

	BOOL IsAllowedID(DWORDLONG fileID) const;

	BOOL IsAllowedName(TCHAR *fileName) const;

	VOID WaitForEvent(HANDLE event);

	BOOL OpenFileByID(
		FileData *file,
		BOOL      writeEnable);

	BOOL OpenFileByName(
		FileData *file,
		BOOL      writeEnable,
		TCHAR    *fileName = NULL);

	BOOL IsFileMapped(FileData *file);

	BOOL SetOplock(FileData *file);

	VOID CloseFile(FileData *file);

    BOOL CreateDatabase(void);

	VOID DoTransaction(
		DWORD               numActions,
		DatabaseActionList *actionList);

	VOID EnqueueCSIndex(CSID *csIndex);

	VOID SigCheckPoint(
		FileData *target,
		BOOL      targetRead);

	VOID CmpCheckPoint(
		FileData *target,
		FileData *match,
		BOOL      targetRead,
		BOOL      matchRead);

	BOOL MergeCheckPoint(
		FileData   *target,
		FileData   *match,
		OVERLAPPED *mergeSynch,
		HANDLE      abortMergeEvent,
		BOOL        merge);

	BOOL GetTarget(
		FileData *target,
		DWORD    *queueIndex);

	VOID CalculateSignature(FileData *target);

	VOID GetMatchList(
		FileData *target,
		FIFO     *matchList,
		Table    *csIndexTable);

	BOOL GetCSFile(
		FileData *target,
		FileData *match,
		Table    *csIndexTable);

	BOOL GetMatch(
		FileData *target,
		FileData *match,
		FIFO     *matchList);

	BOOL Compare(
		FileData *target,
		FileData *match);

	BOOL Merge(
		FileData   *target,
		FileData   *match,
		OVERLAPPED *mergeSynch,
		HANDLE      abortMergeEvent);

	VOID Worker();

	GrovelStatus extract_log2(
		OUT DWORD     *num_entries_extracted,
		OUT DWORDLONG *num_bytes_extracted,
		OUT DWORDLONG *num_bytes_skipped,
		OUT DWORD     *num_files_enqueued,
		OUT DWORD     *num_files_dequeued);

	static DWORD WorkerThread(VOID *groveler);

public:

	static BOOL is_sis_installed(const _TCHAR *drive_name);

    static BOOL set_log_drive(const _TCHAR *drive_name);

	Groveler();

	~Groveler();

	GrovelStatus open(
		IN const TCHAR  *drive_name,
		IN const TCHAR  *drive_letterName,
        IN BOOL          is_log_drive,
		IN DOUBLE        read_report_discard_threshold,
		IN DWORD         min_file_size,
		IN DWORD         min_file_age,
		IN BOOL          allow_compressed_files,
		IN BOOL          allow_encrypted_files,
		IN BOOL          allow_hidden_files,
		IN BOOL          allow_offline_files,
		IN BOOL          allow_temporary_files,
        IN int           previousGrovelAllPathsState,
		IN DWORD         num_excluded_paths,
		IN const TCHAR **excluded_paths,
		IN DWORD         base_regrovel_interval,
		IN DWORD         max_regrovel_interval);

	GrovelStatus close();

	GrovelStatus scan_volume(
		IN  DWORD  time_allotted,
		IN  BOOL   start_over,
		OUT DWORD *time_consumed,
		OUT DWORD *findfirst_count,
		OUT DWORD *findnext_count,
		OUT DWORD *count_of_files_enqueued);

	DWORD set_usn_log_size(
		IN DWORDLONG usn_log_size);

    DWORD get_usn_log_info(
	    OUT USN_JOURNAL_DATA *usnJournalData);

	GrovelStatus extract_log(
		OUT DWORD     *num_entries_extracted,
		OUT DWORDLONG *num_bytes_extracted,
		OUT DWORDLONG *num_bytes_skipped,
		OUT DWORD     *num_files_enqueued,
		OUT DWORD     *num_files_dequeued);

	GrovelStatus grovel(
		IN  DWORD      time_allotted,

		OUT DWORD     *hash_read_ops,
		OUT DWORD     *hash_read_time,
		OUT DWORD     *count_of_files_hashed,
		OUT DWORDLONG *bytes_of_files_hashed,

		OUT DWORD     *compare_read_ops,
		OUT DWORD     *compare_read_time,
		OUT DWORD     *count_of_files_compared,
		OUT DWORDLONG *bytes_of_files_compared,

		OUT DWORD     *count_of_files_matching,
		OUT DWORDLONG *bytes_of_files_matching,

		OUT DWORD     *merge_time,
		OUT DWORD     *count_of_files_merged,
		OUT DWORDLONG *bytes_of_files_merged,

		OUT DWORD     *count_of_files_enqueued,
		OUT DWORD     *count_of_files_dequeued);

	DWORD count_of_files_in_queue() const;

	DWORD count_of_files_to_compare() const;

	DWORD time_to_first_file_ready() const;
};

// Special debugging flags

// #define DEBUG_USN_REASON
// #define DEBUG_GET_BY_ATTR
// #define DEBUG_UNTHROTTLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\grovperf.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    grovperf.cpp

Abstract:

    SIS Groveler performance DLL main file

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

static _TCHAR service_name[] = L"Groveler";

static DWORD first_counter;
static DWORD first_help;
static int open_count = 0;

static SharedData *shared_data = NULL;

static const int ms_per_100ns_inv = 10000;

static __int64 total_counter[num_perf_counters];

extern "C" DWORD CALLBACK OpenGrovelerPerformanceData(LPWSTR lpDeviceNames)
{
    if (open_count == 0)
    {
        shared_data = new SharedData;
        ASSERT(shared_data != NULL);
        HKEY path_key;
        _TCHAR perf_path[1024];

        (void)StringCbPrintf(perf_path,
                       sizeof(perf_path),
                      _T("SYSTEM\\CurrentControlSet\\Services\\%s\\Performance"),
                      service_name);

        long result =
            RegOpenKeyEx(HKEY_LOCAL_MACHINE, perf_path, 0, KEY_READ, &path_key);
        ASSERT_PRINTF(result == ERROR_SUCCESS, (_T("error = %d\n"), result));
        if (result != ERROR_SUCCESS)
        {
            return result;
        }

        ASSERT(path_key != 0);
        first_counter = 0;
        DWORD ctr_size = sizeof(DWORD);
        result = RegQueryValueEx(path_key, _T("First Counter"), 0, 0,
            (BYTE *)&first_counter, &ctr_size);
        ASSERT_PRINTF(result == ERROR_SUCCESS, (_T("error = %d\n"), result));
        if (result != ERROR_SUCCESS)
        {
            RegCloseKey(path_key);
            return result;
        }

        first_help = 0;
        ctr_size = sizeof(DWORD);
        result = RegQueryValueEx(path_key, _T("First Help"), 0, 0,
            (BYTE *)&first_help, &ctr_size);
        ASSERT_PRINTF(result == ERROR_SUCCESS, (_T("error = %d\n"), result));
        if (result != ERROR_SUCCESS)
        {
            RegCloseKey(path_key);
            return result;
        }
        ASSERT(path_key != 0);
        RegCloseKey(path_key);
        path_key = 0;
    }
    open_count++;
    return ERROR_SUCCESS;
}

extern "C" DWORD WINAPI CloseGrovelerPerformanceData()
{
    ASSERT(open_count > 0);
    open_count--;
    if (open_count == 0)
    {
        ASSERT(shared_data != NULL);
        delete shared_data;
        shared_data = NULL;
    }
    return ERROR_SUCCESS;
}

extern "C" DWORD WINAPI CollectGrovelerPerformanceData(
    LPWSTR lpwszValue,
    LPVOID *lppData,
    LPDWORD lpcbBytes,
    LPDWORD lpcObjectTypes)
{
    if (open_count == 0)
    {
        *lpcbBytes = 0;
        *lpcObjectTypes = 0;
        return ERROR_SUCCESS;
    }
    int num_partitions;
    SharedDataRecord records[max_shared_data_records];
    bool ok = shared_data->extract_values(&num_partitions, records);
    if (!ok)
    {
        *lpcbBytes = 0;
        *lpcObjectTypes = 0;
        return ERROR_SUCCESS;
    }
    int data_size = space_needed_for_data(num_partitions);
    if (data_size > int(*lpcbBytes))
    {
        *lpcbBytes = 0;
        *lpcObjectTypes = 0;
        return ERROR_MORE_DATA;
    }
    build_part_object_info_block(lppData, num_partitions, data_size);
    for (int index = 0; index < num_partitions; index++)
    {
        build_part_instance_info_block(lppData, index, records);
    }
    if (num_partitions > 0)
    {
        build_total_instance_info_block(lppData, num_partitions, records);
    }
    *lpcbBytes = data_size;
    *lpcObjectTypes = 1;
    return ERROR_SUCCESS;
}

int space_needed_for_data(
    int num_partitions)
{
    if (num_partitions > 0)
    {
        return sizeof(PartitionObjectInformationBlock) +
            num_partitions * sizeof(PartitionInstanceInformationBlock) +
            sizeof(TotalInstanceInformationBlock);
    }
    else
    {
        return sizeof(PartitionObjectInformationBlock);
    }
}

void build_part_object_info_block(
    LPVOID *lppData,
    int num_partitions,
    int data_size)
{
    int num_instances = 0;
    if (num_partitions > 0)
    {
        num_instances = num_partitions + 1;
    }
    PartitionObjectInformationBlock *block =
        (PartitionObjectInformationBlock *)*lppData;
    block->object_type.TotalByteLength = data_size;
    block->object_type.DefinitionLength =
        sizeof(PartitionObjectInformationBlock);
    block->object_type.HeaderLength = sizeof(PERF_OBJECT_TYPE);
    block->object_type.ObjectNameTitleIndex = first_counter;
    block->object_type.ObjectNameTitle = 0;
    block->object_type.ObjectHelpTitleIndex = first_help;
    block->object_type.ObjectHelpTitle = 0;
    block->object_type.DetailLevel = object_info.detail_level;
    block->object_type.NumCounters = num_perf_counters;
    block->object_type.DefaultCounter = 0;
    block->object_type.NumInstances = num_instances;
    block->object_type.CodePage = 0;
    for (int index = 0; index < num_perf_counters; index++)
    {
        block->definition[index].ByteLength = sizeof(PERF_COUNTER_DEFINITION);
        block->definition[index].CounterNameTitleIndex =
            first_counter + 2 * (index + 1);
        block->definition[index].CounterNameTitle = 0;
        block->definition[index].CounterHelpTitleIndex =
            first_help + 2 * (index + 1);
        block->definition[index].CounterHelpTitle = 0;
        block->definition[index].DefaultScale = 0;
        block->definition[index].DetailLevel = counter_info[index].detail_level;
        block->definition[index].CounterType = counter_info[index].counter_type;
        block->definition[index].CounterSize = sizeof(LARGE_INTEGER);
        block->definition[index].CounterOffset =
            FIELD_OFFSET( PartitionData, counter[index] );
    }
    *lppData = (void *)(block + 1);
}

void build_part_instance_info_block(
    LPVOID *lppData,
    int partition_index,
    SharedDataRecord *records)
{
    PartitionInstanceInformationBlock *block =
        (PartitionInstanceInformationBlock *)*lppData;
    block->instance_def.ByteLength =
        FIELD_OFFSET(PartitionInstanceInformationBlock, partition_data);
    block->instance_def.ParentObjectTitleIndex = 0;
    block->instance_def.ParentObjectInstance = 0;
    block->instance_def.UniqueID = PERF_NO_UNIQUE_ID;
    block->instance_def.NameOffset =
        FIELD_OFFSET(PartitionInstanceInformationBlock, instance_name);
    block->instance_def.NameLength =
        sizeof(_TCHAR) * (partition_name_length);

    (void)StringCbPrintf(block->instance_name, sizeof(block->instance_name), _T("%-.*s"),
                partition_name_length,
                records[partition_index].driveName);

    block->partition_data.counter_block.ByteLength = sizeof(PartitionData);
    for (int index = 0; index < num_perf_counters; index++)
    {
        switch (counter_info[index].counter_type)
        {
        case PERF_100NSEC_TIMER:
            block->partition_data.counter[index].QuadPart = ms_per_100ns_inv *
                records[partition_index].fields[counter_info[index].source];
            break;
        default:
            block->partition_data.counter[index].QuadPart =
                records[partition_index].fields[counter_info[index].source];
            break;
        }
    }
    *lppData = (void *)(block + 1);
}

void build_total_instance_info_block(
    LPVOID *lppData,
    int num_partitions,
    SharedDataRecord *records)
{
    TotalInstanceInformationBlock *block =
        (TotalInstanceInformationBlock *)*lppData;
    block->instance_def.ByteLength =
        FIELD_OFFSET(TotalInstanceInformationBlock, partition_data);
    block->instance_def.ParentObjectTitleIndex = 0;
    block->instance_def.ParentObjectInstance = 0;
    block->instance_def.UniqueID = PERF_NO_UNIQUE_ID;
    block->instance_def.NameOffset =
        FIELD_OFFSET(TotalInstanceInformationBlock, instance_name);
    block->instance_def.NameLength =
        sizeof(_TCHAR) * (total_name_length);
    _tcscpy(block->instance_name, _T("_Total"));
    block->partition_data.counter_block.ByteLength = sizeof(PartitionData);
    for (int index = 0; index < num_perf_counters; index++)
    {
        total_counter[index] = 0;
    }
    for (int part = 0; part < num_partitions; part++)
    {
        for (index = 0; index < num_perf_counters; index++)
        {
            total_counter[index] +=
                records[part].fields[counter_info[index].source];
        }
    }
    for (index = 0; index < num_perf_counters; index++)
    {
        switch (counter_info[index].counter_type)
        {
        case PERF_100NSEC_TIMER:
            block->partition_data.counter[index].QuadPart =
                ms_per_100ns_inv * total_counter[index];
            break;
        default:
            block->partition_data.counter[index].QuadPart =
                total_counter[index];
            break;
        }
    }
    *lppData = (void *)(block + 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\grovperf.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    grovperf.h

Abstract:

	SIS Groveler performance DLL primary include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_GROVPERF

#define _INC_GROVPERF

#define WIN32_LEAN_AND_MEAN 1

extern "C" DWORD CALLBACK OpenGrovelerPerformanceData(LPWSTR lpDeviceNames);

extern "C" DWORD WINAPI CloseGrovelerPerformanceData();

extern "C" DWORD WINAPI CollectGrovelerPerformanceData(
	LPWSTR lpwszValue,
	LPVOID *lppData,
    LPDWORD lpcbBytes,
	LPDWORD lpcObjectTypes);

int space_needed_for_data(
	int num_partitions);

void build_part_object_info_block(
	LPVOID *lppData,
	int num_partitions,
	int data_size);

void build_part_instance_info_block(
	LPVOID *lppData,
	int partition_index,
	SharedDataRecord *records);

void build_total_instance_info_block(
	LPVOID *lppData,
	int num_partitions,
	SharedDataRecord *records);

#pragma pack (8)

const int partition_name_length = 32;
const int total_name_length = 7;

struct PartitionData
{
	PERF_COUNTER_BLOCK counter_block;
	LARGE_INTEGER counter[num_perf_counters];
};

struct PartitionObjectInformationBlock
{
	PERF_OBJECT_TYPE object_type;
	PERF_COUNTER_DEFINITION definition[num_perf_counters];
};

struct PartitionInstanceInformationBlock
{
	PERF_INSTANCE_DEFINITION instance_def;
	_TCHAR instance_name[partition_name_length];
	PartitionData partition_data;
};

struct TotalInstanceInformationBlock
{
	PERF_INSTANCE_DEFINITION instance_def;
	_TCHAR instance_name[total_name_length];
	PartitionData partition_data;
};

#pragma pack ()

#endif	/* _INC_GROVPERF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\inifile.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    inifile.cpp

Abstract:

    SIS Groveler initialization file interface

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

bool
IniFile::read(
    const _TCHAR *filename,
    const _TCHAR *section,
    int num_entries,
    EntrySpec *entries)
{
    WCHAR id_buffer[id_buffer_length];

    ASSERT(filename != 0);
    ASSERT(section != 0);
    ASSERT(num_entries > 0);
    ASSERT(entries != 0);
    for (int index = 0; index < num_entries; index++)
    {
        ASSERT(entries[index].identifier != 0);
        ASSERT(entries[index].default_value != 0);
        ASSERT(entries[index].pointer != 0);
        DWORD num_chars = GetPrivateProfileString(
            section,
            entries[index].identifier,
            entries[index].default_value,
            id_buffer,
            id_buffer_length,
            filename);
        load_string_into_value(entries[index].type, id_buffer,
            entries[index].pointer);
    }
    return true;
}

bool
IniFile::overwrite(
    const _TCHAR *filename,
    const _TCHAR *section,
    int num_entries,
    EntrySpec *entries)
{
    WCHAR id_buffer[id_buffer_length];

    ASSERT(filename != 0);
    ASSERT(section != 0);
    ASSERT(num_entries > 0);
    ASSERT(entries != 0);
    for (int index = 0; index < num_entries; index++)
    {
        ASSERT(entries[index].identifier != 0);
        ASSERT(entries[index].pointer != 0);
        store_value_in_string(entries[index].type, entries[index].pointer,
                              id_buffer, sizeof(id_buffer));
        BOOL success = WritePrivateProfileString(
            section,
            entries[index].identifier,
            id_buffer,
            filename);
        if (!success)
        {
            DWORD err = GetLastError();
            PRINT_DEBUG_MSG((
                _T("GROVELER: WritePrivateProvileString() failed with error %d\n"), err));
        }
    }
    return true;
}

bool
IniFile::read_string_set(
    const _TCHAR *filename,
    const _TCHAR *section,
    int *num_strings,
    _TCHAR ***strings,
    _TCHAR **buffer)
{
    ASSERT(filename != 0);
    ASSERT(section != 0);
    ASSERT(num_strings != 0);
    ASSERT(strings != 0);
    ASSERT(buffer != 0);
    *num_strings = 0;
    *strings = 0;
    *buffer = 0;
    DWORD copied_chars;
    DWORD buffer_size = 128;
    _TCHAR *string_buffer = 0;

    do
    {
        if (string_buffer != 0)
        {
            delete[] string_buffer;
        }
        buffer_size *= 2;

        if (buffer_size >= (32*1024))
            return false;

        string_buffer = new _TCHAR[buffer_size];
        copied_chars = GetPrivateProfileSection(
            section,
            string_buffer,
            buffer_size,
            filename);
    } while (copied_chars >= buffer_size - 2);

    int num_values = 0;
    _TCHAR **string_set = 0;
    if (string_buffer[0] != 0)
    {
        num_values = 1;
        for (int index = 0;
            string_buffer[index] != 0 || string_buffer[index + 1] != 0;
            index++)
        {
            if (string_buffer[index] == 0)
            {
                num_values++;
            }
        }
        string_set = new _TCHAR *[num_values];
        int buffer_offset = 0;
        for (index = 0; index < num_values; index++)
        {
            while (string_buffer[buffer_offset] != _T('='))
            {
                if (string_buffer[buffer_offset] == 0) {
                    delete[] string_set;
                    delete[] string_buffer;
                    return false;
                }
                buffer_offset++;
            }
            string_set[index] = &string_buffer[buffer_offset + 1];
            buffer_offset += _tcslen(string_set[index]) + 2;
        }
    }
    *num_strings = num_values;
    *strings = string_set;
    *buffer = string_buffer;
    return true;
}

void
IniFile::load_string_into_value(
    EntryType type,
    const _TCHAR *string,
    void *value)
{
    ASSERT(string != 0);
    ASSERT(value != 0);
    switch (type)
    {
    case entry_bool:
        *((bool *)value) = _ttoi(string) != 0;
        break;
    case entry_char:
        *((_TCHAR *)value) = string[0];
        break;
    case entry_int:
        (VOID)_stscanf(string, _T("%d"), (int *)value);
        break;
    case entry_int64:
        (VOID)_stscanf(string, _T("%I64d"), (__int64 *)value);
        break;
    case entry_double:
        (VOID)_stscanf(string, _T("%lf"), (double *)value);
        break;
    default:
        ASSERT(false);
    }
}

void
IniFile::store_value_in_string(
    EntryType type,
    void *value,
    _TCHAR *string,
    int stringLen)  //in bytes
{
    ASSERT(string != 0);
    ASSERT(value != 0);
    switch (type)
    {
    case entry_bool:
        (void)StringCbPrintf(string, stringLen, *((bool *)value) ? _T("1") : _T("0"));
        break;
    case entry_char:
        (void)StringCbPrintf(string, stringLen, _T("%c"), *((_TCHAR *)value));
        break;
    case entry_int:
        (void)StringCbPrintf(string, stringLen, _T("%d"), *((int *)value));
        break;
    case entry_int64:
        (void)StringCbPrintf(string, stringLen, _T("%I64d"), *((__int64 *)value));
        break;
    case entry_double:
        (void)StringCbPrintf(string, stringLen, _T("%g"), *((double *)value));
        break;
    default:
        ASSERT(false);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\logdrive.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    logdrive.h

Abstract:

	SIS Groveler logging drive header

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_LOGDRIVE

#define _INC_LOGDRIVE

class LogDrive
{
public:

	LogDrive();

	~LogDrive();

	int drive_index() const
		{return log_drive_index;}

	void partition_initialized(
		int partition_index);

private:

	static bool read_registry(
		_TCHAR *name,
		DWORD size);

	static bool write_registry(
		_TCHAR *name);

	int log_drive_index;

	bool *part_initted;
	bool registry_written;
};

#endif	/* _INC_LOGDRIVE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\logdrive.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    logdrive.cpp

Abstract:

    SIS Groveler logging drive class

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

static const _TCHAR registry_parameter_path[] = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Groveler\\Parameters");
static const _TCHAR *log_drive_key_name = _T("log drive");

LogDrive::LogDrive()
{
    _TCHAR *guid_name;

    part_initted = 0;
    registry_written = false;
    log_drive_index = 0;
    _TCHAR reg_name[MAX_PATH + 1];
    read_registry(reg_name,sizeof(reg_name));

    int partition_count = sis_drives.partition_count();
    ASSERT(partition_count > 0);

    part_initted = new bool[partition_count];
    for (int index = 0; index < partition_count; index++)
    {
        part_initted[index] = false;
    }

    for (index = 0; index < partition_count; index++)
    {
        guid_name = sis_drives.partition_guid_name(index);
        if (_tcsicmp(reg_name, guid_name) == 0)
        {
            log_drive_index = index;
            write_registry(_T(""));
            return;
        }
    }

    __int64 log_drive_space = 0;
    for (index = 0; index < partition_count; index++)
    {
        guid_name = sis_drives.partition_guid_name(index);
        ULARGE_INTEGER my_free_bytes;
        ULARGE_INTEGER total_bytes;
        ULARGE_INTEGER free_bytes;
        int ok = GetDiskFreeSpaceEx(
            guid_name, &my_free_bytes, &total_bytes, &free_bytes);
        if (ok)
        {
            __int64 space = free_bytes.QuadPart;
            if (space > log_drive_space)
            {
                log_drive_space = space;
                log_drive_index = index;
            }
        }
        else
        {
            DWORD err = GetLastError();
            PRINT_DEBUG_MSG((_T("GROVELER: GetDiskFreeSpaceEx() failed with error %d\n"),
                err));
        }
    }
    write_registry(_T(""));
}

LogDrive::~LogDrive()
{
    if (part_initted != 0)
    {
        delete[] part_initted;
        part_initted = 0;
    }
}

void
LogDrive::partition_initialized(
    int partition_index)
{
    if (!registry_written)
    {
        int partition_count = sis_drives.partition_count();
        ASSERT(partition_index >= 0);
        ASSERT(partition_index < partition_count);
        part_initted[partition_index] = true;
        for (int index = 0; index < partition_count; index++)
        {
            if (!part_initted[index])
            {
                return;
            }
        }
        write_registry(sis_drives.partition_guid_name(log_drive_index));
        registry_written = true;
    }
}

bool
LogDrive::read_registry(
    _TCHAR *name,
    DWORD size)
{
    DWORD type;
    try
    {
        HKEY path_key = 0;
        Registry::open_key_ex(HKEY_LOCAL_MACHINE,
            registry_parameter_path, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, &path_key);
        try
        {
            Registry::query_value_ex(path_key, log_drive_key_name, 0,
                &type, (BYTE *)name, &size);
        }
        catch (DWORD result)
        {
            ASSERT(result != ERROR_SUCCESS);
            PRINT_DEBUG_MSG((
                _T("GROVELER: Registry::query_value_ex() failed with error %d\n"),
                result));
            ASSERT(path_key != 0);
            Registry::close_key(path_key);
            path_key = 0;
            *name = 0;
            return false;
        }
        ASSERT(path_key != 0);
        Registry::close_key(path_key);
        path_key = 0;
    }
    catch (DWORD result)
    {
        ASSERT(result != ERROR_SUCCESS);
        PRINT_DEBUG_MSG((_T("GROVELER: Registry::open_key_ex() or Registry::close_key() ")
            _T("failed with error %d\n"), result));
        *name = 0;
        return false;
    }
    if (type != REG_EXPAND_SZ)
    {
        *name = 0;
        return false;
    }
    return true;
}

bool
LogDrive::write_registry(
    _TCHAR *name)
{
    try
    {
        HKEY path_key = 0;
        DWORD disp;
        Registry::create_key_ex(HKEY_LOCAL_MACHINE,
            registry_parameter_path, 0, 0, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 0, &path_key, &disp);
        try
        {
            Registry::set_value_ex(path_key, log_drive_key_name, 0,
                REG_EXPAND_SZ, (BYTE *)name,
                (_tcslen(name) + 1) * sizeof(_TCHAR));
        }
        catch (DWORD result)
        {
            ASSERT(result != ERROR_SUCCESS);
            PRINT_DEBUG_MSG((
                _T("GROVELER: Registry::set_value_ex() failed with error %d\n"),
                result));
            ASSERT(path_key != 0);
            Registry::close_key(path_key);
            path_key = 0;
            return false;
        }
        ASSERT(path_key != 0);
        Registry::close_key(path_key);
        path_key = 0;
    }
    catch (DWORD result)
    {
        ASSERT(result != ERROR_SUCCESS);
        PRINT_DEBUG_MSG((_T("GROVELER: Registry::create_key_ex() or Registry::close_key() ")
            _T("failed with error %d\n"), result));
        return false;
    }
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\meancomp.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    meancomp.cpp

Abstract:

    SIS Groveler mean comparitor

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

const int MeanComparator::max_sample_table_size = 20;

MeanComparator::PTableDescriptor
    MeanComparator::p_list = {-1.0, 0, 0, &p_list, &p_list, 0};

MeanComparator::MeanComparator(
    int num_clans,
    int sample_group_size,
    double acceptance_p_value,
    double rejection_p_value,
    double tolerance)
{
    ASSERT(this != 0);
    ASSERT(num_clans > 0);
    ASSERT(sample_group_size > 0);
    ASSERT(acceptance_p_value >= 0.0);
    ASSERT(acceptance_p_value <= 1.0);
    ASSERT(rejection_p_value >= 0.0);
    ASSERT(rejection_p_value <= 1.0);
    ASSERT(tolerance >= 0.0);
    ASSERT(tolerance <= 1.0);
    this->num_clans = num_clans;
    this->sample_group_size = sample_group_size;
    this->tolerance = tolerance;
    sample_table_size = __min(sample_group_size, max_sample_table_size);
    acceptance_table = add_p_value(acceptance_p_value, sample_table_size);
    ASSERT(acceptance_table != 0);
    rejection_table = add_p_value(rejection_p_value, sample_table_size);
    ASSERT(rejection_table != 0);
    samples = new Sample[sample_group_size];
    compare_values = new double[num_clans];
    current_offset = 0;
    current_group_size = 0;
}

MeanComparator::~MeanComparator()
{
    ASSERT(this != 0);
    ASSERT(acceptance_table != 0);
    remove_p_value(acceptance_table);
    acceptance_table = 0;
    ASSERT(rejection_table != 0);
    remove_p_value(rejection_table);
    rejection_table = 0;
    ASSERT(samples != 0);
    delete[] samples;
    samples = 0;
    ASSERT(compare_values != 0);
    delete[] compare_values;
    compare_values = 0;
}

void
MeanComparator::reset()
{
    ASSERT(this != 0);
    ASSERT(current_group_size >= 0);
    ASSERT(current_group_size <= sample_group_size);
    current_group_size = 0;
}

void
MeanComparator::sample(
    int clan,
    double value)
{
    ASSERT(this != 0);
    ASSERT(current_group_size >= 0);
    ASSERT(current_group_size <= sample_group_size);
    ASSERT(current_offset >= 0);
    ASSERT(current_offset < sample_group_size);
    current_offset--;
    if (current_offset < 0)
    {
        current_offset += sample_group_size;
    }
    current_group_size = __min(current_group_size + 1, sample_group_size);
    ASSERT(current_offset >= 0);
    ASSERT(current_offset < sample_group_size);
    samples[current_offset].clan = clan;
    samples[current_offset].value = value;
}

bool
MeanComparator::within(
    double compare_value,
    ...)
{
    ASSERT(this != 0);
    ASSERT(num_clans > 0);
    ASSERT(current_group_size >= 0);
    ASSERT(current_group_size <= sample_group_size);
    ASSERT(current_offset >= 0);
    ASSERT(current_offset < sample_group_size);
    va_list ap;
    va_start(ap, compare_value);
    compare_values[0] = compare_value;
    for (int index = 1; index < num_clans; index++)
    {
        compare_values[index] = va_arg(ap, double);
    }
    va_end(ap);
    int sample_count = 0;
    int below_count = 0;
    int *p_table = acceptance_table->p_table;
    ASSERT(p_table != 0);
    for (index = 0;
        index < current_group_size && sample_count < sample_table_size;
        index++)
    {
        int loc = (index + current_offset) % sample_group_size;
        int clan = samples[loc].clan;
        double value = samples[loc].value;
        double cv = compare_values[clan];
        if (fabs(value - cv) > tolerance * cv)
        {
            sample_count++;
            if (value < cv)
            {
                below_count++;
                if (below_count > p_table[sample_count-1])
                {
                    return true;
                }
            }
        }
    }
    return false;
}

bool
MeanComparator::exceeds(
    double compare_value,
    ...)
{
    ASSERT(this != 0);
    ASSERT(num_clans > 0);
    ASSERT(current_group_size >= 0);
    ASSERT(current_group_size <= sample_group_size);
    ASSERT(current_offset >= 0);
    ASSERT(current_offset < sample_group_size);
    va_list ap;
    va_start(ap, compare_value);
    compare_values[0] = compare_value;
    for (int index = 1; index < num_clans; index++)
    {
        compare_values[index] = va_arg(ap, double);
    }
    va_end(ap);
    int sample_count = 0;
    int above_count = 0;
    int *p_table = rejection_table->p_table;
    ASSERT(p_table != 0);
    for (index = 0;
        index < current_group_size && sample_count < sample_table_size;
        index++)
    {
        int loc = (index + current_offset) % sample_group_size;
        int clan = samples[loc].clan;
        double value = samples[loc].value;
        double cv = compare_values[clan];
        if (fabs(value - cv) > tolerance * cv)
        {
            sample_count++;
            if (value > cv)
            {
                above_count++;
                if (above_count > p_table[sample_count-1])
                {
                    return true;
                }
            }
        }
    }
    return false;
}

MeanComparator::PTableDescriptor *
MeanComparator::add_p_value(
    double p_value,
    int sample_table_size)
{
    ASSERT(p_list.next != 0);
    ASSERT(p_list.prev != 0);
    PTableDescriptor *ptd = p_list.next;
    while (ptd != &p_list && ptd->p_value < p_value)
    {
        ASSERT(ptd->next == &p_list || ptd->next->p_value > ptd->p_value);
        ptd = ptd->next;
    }
    ASSERT(ptd != 0);
    if (ptd->p_value == p_value)
    {
        ASSERT(ptd != &p_list);
        ASSERT(ptd->table_size > 0);
        ASSERT(ptd->table_size <= max_sample_table_size);
        if (ptd->table_size >= sample_table_size)
        {
            ptd->ref_count++;
            return ptd;
        }
        ASSERT(ptd->p_table != 0);
        delete[] ptd->p_table;
        ptd->p_table = 0;
    }
    else
    {
        PTableDescriptor *new_ptd = new PTableDescriptor;
        new_ptd->p_value = p_value;
        new_ptd->p_table = 0;
        new_ptd->next = ptd;
        new_ptd->prev = ptd->prev;
        ptd->prev->next = new_ptd;
        ptd->prev = new_ptd;
        new_ptd->ref_count = 0;
        ptd = new_ptd;
    }
    ASSERT(ptd->prev == &p_list || ptd->prev->p_value < p_value);
    ASSERT(ptd->next == &p_list || ptd->next->p_value > p_value);
    int *p_table = new int[sample_table_size];
    ptd->table_size = sample_table_size;
    double threshold = p_value;
    for (int n = 1; n <= sample_table_size; n++)
    {
        threshold *= 2.0;
        if (1.0 > threshold)
        {
            p_table[n - 1] = n;
            continue;
        }
        __int64 numerator = 1;
        __int64 denominator = 1;
        __int64 sum = 1;
        for (int r = 1; r <= n; r++)
        {
            numerator *= n - r + 1;
            ASSERT(numerator > 0);
            denominator *= r;
            ASSERT(denominator > 0);
            sum += numerator / denominator;
            ASSERT(sum > 0);
            if (double(sum) > threshold)
            {
                break;
            }
        }
        p_table[n - 1] = n - r;
    }
    ptd->p_table = p_table;
    ptd->ref_count++;
    return ptd;
}

bool
MeanComparator::remove_p_value(
    PTableDescriptor *ptd)
{
    ASSERT(ptd != 0);
    ptd->ref_count--;
    ASSERT(ptd->ref_count >= 0);
    if (ptd->ref_count == 0)
    {
        ASSERT(ptd->p_table != 0);
        delete[] ptd->p_table;
        ptd->p_table = 0;
        ptd->prev->next = ptd->next;
        ptd->next->prev = ptd->prev;
        delete ptd;
        ptd = 0;
    }
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\meancomp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    meancomp.h

Abstract:

	SIS Groveler mean comparitor headers

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_MEANCOMP

#define _INC_MEANCOMP

class MeanComparator
{
public:

	MeanComparator(
		int num_clans,
		int sample_group_size,
		double acceptance_p_value,
		double rejection_p_value,
		double tolerance);

	~MeanComparator();

	void reset();

	void sample(
		int clan,
		double value);

	bool within(
		double compare_value,
		...);

	bool exceeds(
		double compare_value,
		...);

private:

	struct PTableDescriptor
	{
		double p_value;
		int table_size;
		int *p_table;
		PTableDescriptor *next;
		PTableDescriptor *prev;
		int ref_count;
	};

	struct Sample
	{
		int clan;
		double value;
	};

	static PTableDescriptor *add_p_value(
		double p_value,
		int sample_table_size);

	static bool remove_p_value(
		PTableDescriptor *ptd);

	static const int max_sample_table_size;

	static PTableDescriptor p_list;

	int num_clans;
	int sample_group_size;
	int sample_table_size;
	PTableDescriptor *acceptance_table;
	PTableDescriptor *rejection_table;

	double tolerance;
	Sample *samples;
	double *compare_values;
	int current_offset;
	int current_group_size;
};

#endif	/* _INC_MEANCOMP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\params.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    params.cpp

Abstract:

    SIS Groveler parameter support & defaults

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

static const _TCHAR registry_parameter_path[] =
    _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Groveler\\Parameters");

ReadParameters::ReadParameters()
{
    ASSERT(this != 0);
    static EntrySpec registry_entries[registry_entry_count] =
    {
        {_T("parameter backup interval"),           entry_int,      _T("600000"),   &parameter_backup_interval},
        {_T("target entries per log extraction"),   entry_int,      _T("100"),      &target_entries_per_extraction},
        {_T("max extraction interval"),             entry_int,      _T("10000"),    &max_extraction_interval},
        {_T("base grovel interval"),                entry_int,      _T("5000"),     &base_grovel_interval},
        {_T("max grovel interval"),                 entry_int,      _T("600000"),   &max_grovel_interval},
        {_T("max response lag"),                    entry_int,      _T("10000"),    &max_response_lag},
        {_T("low-confidence grovel interval"),      entry_int,      _T("15000"),    &low_confidence_grovel_interval},
        {_T("low-disk-space grovel interval"),      entry_int,      _T("500"),      &low_disk_space_grovel_interval},
        {_T("working grovel interval"),             entry_int,      _T("500"),      &working_grovel_interval},
        {_T("grovel duration"),                     entry_int,      _T("400"),      &grovel_duration},
        {_T("partition info update interval"),      entry_int,      _T("60000"),    &partition_info_update_interval},
        {_T("base restart extraction interval"),    entry_int,      _T("10000"),    &base_restart_extraction_interval},
        {_T("max restart extraction interval"),     entry_int,      _T("3600000"),  &max_restart_extraction_interval},
        {_T("base restart groveling interval"),     entry_int,      _T("30000"),    &base_restart_groveling_interval},
        {_T("max restart groveling interval"),      entry_int,      _T("86400000"), &max_restart_groveling_interval},
        {_T("base regrovel interval"),              entry_int,      _T("60000"),    &base_regrovel_interval},
        {_T("max regrovel interval"),               entry_int,      _T("86400000"), &max_regrovel_interval},
        {_T("volscan regrovel threshold"),          entry_int,      _T("120000"),   &volscan_regrovel_threshold},
        {_T("partition balance time constant"),     entry_int,      _T("1800000"),  &partition_balance_time_constant},
        {_T("read time increase history size"),     entry_int,      _T("5"),        &read_time_increase_history_size},
        {_T("read time decrease history size"),     entry_int,      _T("2"),        &read_time_decrease_history_size},
        {_T("SIS efficacy history size"),           entry_int,      _T("1000"),     &sis_efficacy_history_size},
        {_T("log winnow history size"),             entry_int,      _T("1000"),     &log_winnow_history_size},
        {_T("file size history size"),              entry_int,      _T("1000"),     &file_size_history_size},
        {_T("sample group size"),                   entry_int,      _T("10"),       &sample_group_size},
        {_T("acceptance P-value"),                  entry_double,   _T("0.2"),      &acceptance_p_value},
        {_T("rejection P-value"),                   entry_double,   _T("0.05"),     &rejection_p_value},
        {_T("base use multiplier"),                 entry_double,   _T("1.0"),      &base_use_multiplier},
        {_T("max use multiplier"),                  entry_double,   _T("2.0"),      &max_use_multiplier},
        {_T("peak finder accuracy"),                entry_double,   _T("0.05"),     &peak_finder_accuracy},
        {_T("peak finder range"),                   entry_double,   _T("20.0"),     &peak_finder_range},
        {_T("base CPU load threshold"),             entry_double,   _T("0.50"),     &base_cpu_load_threshold},
        {_T("max CPU load threshold"),              entry_double,   _T("1.0"),      &max_cpu_load_threshold},
        {_T("read report discard threshold"),       entry_double,   _T("0.75"),     &read_report_discard_threshold},
        {_T("GrovelAllPaths"),                      entry_int,      _T("0"),        &GrovelAllPaths}
    };

    Registry::read(HKEY_LOCAL_MACHINE, registry_parameter_path,
        registry_entry_count, registry_entries);

#if WRITE_ALL_PARAMETERS

    bool registry_write_ok =
        Registry::write(HKEY_LOCAL_MACHINE, registry_parameter_path,
        registry_entry_count, registry_entries);
    if (!registry_write_ok)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: Registry::write() to %s failed\n"),
            registry_parameter_path));
    }

#endif // WRITE_ALL_PARAMETERS
}

WriteParameters::WriteParameters(
    int backup_interval)
{
    ASSERT(this != 0);
    ASSERT(backup_interval >= 0);
    this->backup_interval = backup_interval;

    static EntrySpec registry_entries[registry_entry_count] =
    {
        {_T("hash match ratio"),                    entry_double,   _T("0.01"),     &hash_match_ratio},
        {_T("compare match ratio"),                 entry_double,   _T("1.0"),      &compare_match_ratio},
        {_T("dequeue hash ratio"),                  entry_double,   _T("1.0"),      &dequeue_hash_ratio}
    };

    for (int index = 0; index < registry_entry_count; index++)
    {
        this->registry_entries[index] = registry_entries[index];
    }

    Registry::read(HKEY_LOCAL_MACHINE, registry_parameter_path,
        registry_entry_count, registry_entries);

    if (backup_interval > 0)
    {
        backup((void *)this);
    }
}

WriteParameters::~WriteParameters()
{
    ASSERT(this != 0);
    ASSERT(backup_interval >= 0);
    backup((void *)this);
}

void
WriteParameters::backup(
    void *context)
{
    ASSERT(context != 0);
    unsigned int invokation_time = GET_TICK_COUNT();
    WriteParameters *me = (WriteParameters *)context;
    ASSERT(me->backup_interval >= 0);

    bool registry_overwrite_ok =
        Registry::overwrite(HKEY_LOCAL_MACHINE, registry_parameter_path,
        registry_entry_count, me->registry_entries);
    if (!registry_overwrite_ok)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: Registry::overwrite() to %s failed\n"),
            registry_parameter_path));
    }

    event_timer.schedule(invokation_time + me->backup_interval,
        context, backup);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\mutex.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mutex.h

Abstract:

	SIS Groveler named mutex class header

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_MUTEX

#define _INC_MUTEX

class NamedMutex
{
public:

	NamedMutex(
		const _TCHAR *name,
		SECURITY_ATTRIBUTES *security_attributes = 0);

	~NamedMutex();

	bool release();

	bool acquire(
		unsigned int timeout);

private:

	HANDLE mutex_handle;
};

#endif	/* _INC_MUTEX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\params.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    params.h

Abstract:

	SIS Groveler registry parameters headers

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_PARAMS

#define _INC_PARAMS

struct ReadParameters
{
	ReadParameters();

	int parameter_backup_interval;
	int target_entries_per_extraction;
	int max_extraction_interval;
	int base_grovel_interval;
	int max_grovel_interval;
	int max_response_lag;
	int low_confidence_grovel_interval;
	int low_disk_space_grovel_interval;
	int working_grovel_interval;
	int grovel_duration;
	int partition_info_update_interval;
	int base_restart_extraction_interval;
	int max_restart_extraction_interval;
	int base_restart_groveling_interval;
	int max_restart_groveling_interval;
	int base_regrovel_interval;
	int max_regrovel_interval;
	int volscan_regrovel_threshold;
	int partition_balance_time_constant;
	int read_time_increase_history_size;
	int read_time_decrease_history_size;
	int sis_efficacy_history_size;
	int log_winnow_history_size;
	int file_size_history_size;
	int sample_group_size;
	double acceptance_p_value;
	double rejection_p_value;
	double base_use_multiplier;
	double max_use_multiplier;
	double peak_finder_accuracy;
	double peak_finder_range;
	double base_cpu_load_threshold;
	double max_cpu_load_threshold;
	double read_report_discard_threshold;

private:

	enum {registry_entry_count = 35};
};

struct WriteParameters
{
	WriteParameters(
		int backup_interval);

	~WriteParameters();

	double hash_match_ratio;
	double compare_match_ratio;
	double dequeue_hash_ratio;

private:

	enum {registry_entry_count = 3};

	static void backup(
		void *context);

	int backup_interval;
	EntrySpec registry_entries[registry_entry_count];
};

#endif	/* _INC_PARAMS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\mutex.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mutex.cpp

Abstract:

    SIS Groveler named mutex class

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

NamedMutex::NamedMutex(
    const _TCHAR *name,
    SECURITY_ATTRIBUTES *security_attributes)
{
    ASSERT(this != 0);
    mutex_handle = CreateMutex(security_attributes, FALSE, name);
    if (mutex_handle == 0)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: CreateMutex() failed with error %d\n"), err));
    }
}

NamedMutex::~NamedMutex()
{
    ASSERT(this != 0);
    if (mutex_handle != 0)
    {
        int ok = CloseHandle(mutex_handle);
        if (!ok)
        {
            DWORD err = GetLastError();
            PRINT_DEBUG_MSG((_T("GROVELER: CloseHandle() failed with error %d\n"), err));
        }
        mutex_handle = 0;
    }
}

bool
NamedMutex::release()
{
    ASSERT(this != 0);
    if (mutex_handle == 0)
    {
        return false;
    }
    BOOL ok = ReleaseMutex(mutex_handle);
    if (!ok)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: ReleaseMutex() failed with error %d\n"), err));
    }
    return (ok != 0);
}

bool
NamedMutex::acquire(
    unsigned int timeout)
{
    ASSERT(this != 0);
    if (mutex_handle == 0)
    {
        return false;
    }
    ASSERT(signed(timeout) >= 0);
    DWORD result = WaitForSingleObject(mutex_handle, timeout);
    if (result != WAIT_TIMEOUT && result != WAIT_OBJECT_0)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: WaitForSingleObject() returned error %d\n"),
            result));
    }
    return (result == WAIT_OBJECT_0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\partctrl.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    partctrl.h

Abstract:

	SIS Groveler partition controller headers

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_PARTCTRL

#define _INC_PARTCTRL

class PartitionController
{
public:

	PartitionController(
		Groveler *groveler,
		GrovelStatus groveler_status,
		int target_entries_per_extraction,
		int max_extraction_interval,
		int base_grovel_interval,
		int max_grovel_interval,
		int low_confidence_grovel_interval,
		int low_disk_space_grovel_interval,
		int partition_info_update_interval,
		int base_restart_extraction_interval,
		int max_restart_extraction_interval,
		int base_restart_groveling_interval,
		int max_restart_groveling_interval,
		int base_regrovel_interval,
		int max_regrovel_interval,
		int volscan_regrovel_threshold,
		int partition_balance_time_constant,
		int read_time_increase_history_size,
		int read_time_decrease_history_size,
		int file_size_history_size,
		bool error_retry_log_extraction,
		bool error_retry_groveling,
		__int64 base_usn_log_size,
		__int64 max_usn_log_size,
		int sample_group_size,
		double acceptance_p_value,
		double rejection_p_value,
		double base_use_multiplier,
		double max_use_multiplier,
		double peak_finder_accuracy,
		double peak_finder_range,
		double base_cpu_load_threshold,
		double max_cpu_load_threshold,
		double *hash_match_ratio,
		double *compare_match_ratio,
		double *dequeue_hash_ratio,
		double *hash_read_time_estimate,
		double *compare_read_time_estimate,
		double *mean_file_size,
		double *read_time_confidence,
		int *volume_serial_number,
		int partition_index,
		double read_report_discard_threshold,
		int min_file_size,
		int min_file_age,
		bool allow_compressed_files,
		bool allow_encrypted_files,
		bool allow_hidden_files,
		bool allow_offline_files,
		bool allow_temporary_files,
		int num_excluded_paths,
		const _TCHAR **excluded_paths);

	~PartitionController();

	bool control_operation(
		DWORD grovel_duration,
		DWORD *count_of_files_hashed,
		DWORDLONG *bytes_of_files_hashed,
		DWORD *count_of_files_matching,
		DWORDLONG *bytes_of_files_matching,
		DWORD *count_of_files_compared,
		DWORDLONG *bytes_of_files_compared,
		DWORD *count_of_files_merged,
		DWORDLONG *bytes_of_files_merged,
		DWORD *count_of_files_enqueued,
		DWORD *count_of_files_dequeued,
		double cpu_load);

	void advance(
		int time_delta);

	double priority() const;

	int wait() const;

	void demarcate_foreground_batch();

	void command_full_volume_scan();

private:

	enum ReadType
	{
		RT_hash,
		RT_compare
	};

	static void control_extraction(
		void *context);

	static void restart_extraction(
		void *context);

	static void restart_groveling(
		void *context);

	static void update_partition_info(
		void *context);

	void initialize_groveling(
		GrovelStatus groveler_status);

	bool control_groveling(
		DWORD grovel_duration,
		DWORD *count_of_files_hashed,
		DWORDLONG *bytes_of_files_hashed,
		DWORD *count_of_files_matching,
		DWORDLONG *bytes_of_files_matching,
		DWORD *count_of_files_compared,
		DWORDLONG *bytes_of_files_compared,
		DWORD *count_of_files_merged,
		DWORDLONG *bytes_of_files_merged,
		DWORD *count_of_files_enqueued,
		DWORD *count_of_files_dequeued,
		double cpu_load);

	bool control_volume_scan(
		int scan_duration,
		DWORD *count_of_files_enqueued);

	void update_peak_finder(
		ReadType read_type,
		DWORD read_time,
		DWORD read_ops);

	void calculate_effective_max_grovel_interval();

	Groveler *groveler;
	int partition_index;

	IncidentFilter file_size_filter;
	ConfidenceEstimator read_time_confidence_estimator;
	DecayingAccumulator partition_grovel_accumulator;

	MeanComparator read_mean_comparator;
	PeakFinder *read_peak_finder[2];
	DirectedIncidentFilter *read_time_filter[2];
	double *read_time_estimate[2];

	bool initiate_full_volume_scan;
	bool performing_full_volume_scan;
	int target_entries_per_extraction;
	int max_extraction_interval;
	int extraction_interval;

	__int64 base_usn_log_size;
	__int64 max_usn_log_size;
	__int64 current_usn_log_size;

	int max_grovel_interval;
	int base_grovel_interval;
	int effective_max_grovel_interval;
	int grovel_interval;
	int remaining_grovel_interval;

	bool ok_to_record_measurement;
	int next_untrusted_measurement_time;
	int untrusted_measurement_interval;

	double log_max_grovel_interval;
	double log_low_confidence_slope;
	double low_disk_space_slope;

	double base_use_multiplier;
	double use_multiplier_slope;

	double base_cpu_load_threshold;
	double cpu_load_threshold_slope;

	bool error_retry_log_extraction;
	bool error_retry_groveling;
	bool restart_extraction_required;

	int base_restart_extraction_interval;
	int max_restart_extraction_interval;
	int base_restart_groveling_interval;
	int max_restart_groveling_interval;

	int restart_extraction_interval;
	int remaining_restart_extraction_interval;
	int restart_groveling_interval;

	double peak_finder_accuracy;

	int volscan_regrovel_threshold;
	int partition_info_update_interval;

	bool restart_volume_scan;
	bool first_extraction;
	bool log_extractor_dead;
	bool groveler_dead;
	bool extended_restart_in_progress;

	double volume_total_bytes;
	double volume_free_bytes;
	double *hash_match_ratio;
	double *compare_match_ratio;
	double *dequeue_hash_ratio;

	double *mean_file_size;
	double *read_time_confidence;
	double free_space_ratio;
	int *volume_serial_number;

	int base_regrovel_interval;
	int max_regrovel_interval;
	double read_report_discard_threshold;
	int min_file_size;
	int min_file_age;
	bool allow_compressed_files;
	bool allow_encrypted_files;
	bool allow_hidden_files;
	bool allow_offline_files;
	bool allow_temporary_files;
	int num_excluded_paths;
	const _TCHAR **excluded_paths;
};

#endif	/* _INC_PARTCTRL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\partctrl.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    partctrl.cpp

Abstract:

    SIS Groveler partition controller

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

PartitionController::PartitionController(
    Groveler *groveler,
    GrovelStatus groveler_status,
    int target_entries_per_extraction,
    int max_extraction_interval,
    int base_grovel_interval,
    int max_grovel_interval,
    int low_confidence_grovel_interval,
    int low_disk_space_grovel_interval,
    int partition_info_update_interval,
    int base_restart_extraction_interval,
    int max_restart_extraction_interval,
    int base_restart_groveling_interval,
    int max_restart_groveling_interval,
    int base_regrovel_interval,
    int max_regrovel_interval,
    int volscan_regrovel_threshold,
    int partition_balance_time_constant,
    int read_time_increase_history_size,
    int read_time_decrease_history_size,
    int file_size_history_size,
    bool error_retry_log_extraction,
    bool error_retry_groveling,
    __int64 base_usn_log_size,
    __int64 max_usn_log_size,
    int sample_group_size,
    double acceptance_p_value,
    double rejection_p_value,
    double base_use_multiplier,
    double max_use_multiplier,
    double peak_finder_accuracy,
    double peak_finder_range,
    double base_cpu_load_threshold,
    double max_cpu_load_threshold,
    double *hash_match_ratio,
    double *compare_match_ratio,
    double *dequeue_hash_ratio,
    double *hash_read_time_estimate,
    double *compare_read_time_estimate,
    double *mean_file_size,
    double *read_time_confidence,
    int *volume_serial_number,
    int partition_index,
    double read_report_discard_threshold,
    int min_file_size,
    int min_file_age,
    bool allow_compressed_files,
    bool allow_encrypted_files,
    bool allow_hidden_files,
    bool allow_offline_files,
    bool allow_temporary_files,
    int num_excluded_paths,
    const _TCHAR **excluded_paths)
:   read_mean_comparator(2, sample_group_size,
        acceptance_p_value, rejection_p_value, peak_finder_accuracy),
    file_size_filter(file_size_history_size, *mean_file_size),
    read_time_confidence_estimator(2, *read_time_confidence),
    partition_grovel_accumulator(partition_balance_time_constant)
{
    ASSERT(this != 0);
    unsigned int current_time = GET_TICK_COUNT();
    TRACE_PRINTF(TC_partctrl, 1, (_T("time: %d\n"), current_time));
    TRACE_PRINTF(TC_partctrl, 1,
        (_T("\tPC -\tconstructing PartitionController for drive %s\n"),
        sis_drives.partition_mount_name(partition_index)));
    ASSERT(groveler != 0);
    this->groveler = groveler;
    ASSERT(target_entries_per_extraction > 0);
    this->target_entries_per_extraction = target_entries_per_extraction;
    ASSERT(max_extraction_interval > 0);
    this->max_extraction_interval = max_extraction_interval;
    ASSERT(base_grovel_interval > 0);
    this->base_grovel_interval = base_grovel_interval;
    ASSERT(max_grovel_interval > 0);
    ASSERT(max_grovel_interval >= base_grovel_interval);
    this->max_grovel_interval = max_grovel_interval;
    ASSERT(partition_info_update_interval > 0);
    this->partition_info_update_interval = partition_info_update_interval;
    ASSERT(base_restart_extraction_interval > 0);
    this->base_restart_extraction_interval = base_restart_extraction_interval;
    ASSERT(max_restart_extraction_interval > 0);
    ASSERT(max_restart_extraction_interval >= base_restart_extraction_interval);
    this->max_restart_extraction_interval = max_restart_extraction_interval;
    ASSERT(base_restart_groveling_interval > 0);
    this->base_restart_groveling_interval = base_restart_groveling_interval;
    ASSERT(max_restart_groveling_interval > 0);
    ASSERT(max_restart_groveling_interval >= base_restart_groveling_interval);
    this->max_restart_groveling_interval = max_restart_groveling_interval;
    this->error_retry_log_extraction = error_retry_log_extraction;
    this->error_retry_groveling = error_retry_groveling;
    ASSERT(base_usn_log_size > 0);
    this->base_usn_log_size = base_usn_log_size;
    ASSERT(max_usn_log_size > 0);
    ASSERT(max_usn_log_size >= base_usn_log_size);
    this->max_usn_log_size = max_usn_log_size;
    ASSERT(hash_match_ratio != 0);
    ASSERT(*hash_match_ratio >= 0.0);
    ASSERT(*hash_match_ratio <= 1.0);
    this->hash_match_ratio = hash_match_ratio;
    ASSERT(compare_match_ratio != 0);
    ASSERT(*compare_match_ratio >= 0.0);
    ASSERT(*compare_match_ratio <= 1.0);
    this->compare_match_ratio = compare_match_ratio;
    ASSERT(dequeue_hash_ratio != 0);
    ASSERT(*dequeue_hash_ratio >= 0.0);
    ASSERT(*dequeue_hash_ratio <= 1.0);
    this->dequeue_hash_ratio = dequeue_hash_ratio;
    ASSERT(mean_file_size != 0);
    ASSERT(*mean_file_size >= 0.0);
    this->mean_file_size = mean_file_size;
    ASSERT(read_time_confidence != 0);
    ASSERT(*read_time_confidence >= 0.0);
    ASSERT(*read_time_confidence <= 1.0);
    this->read_time_confidence = read_time_confidence;
    ASSERT(base_use_multiplier > 0.0);
    this->base_use_multiplier = base_use_multiplier;
    ASSERT(partition_index >= 0);
    this->partition_index = partition_index;
    ASSERT(base_regrovel_interval > 0);
    this->base_regrovel_interval = base_regrovel_interval;
    ASSERT(max_regrovel_interval >= base_regrovel_interval);
    this->max_regrovel_interval = max_regrovel_interval;
    ASSERT(volscan_regrovel_threshold >= base_regrovel_interval);
    ASSERT(volscan_regrovel_threshold <= max_regrovel_interval);
    this->volscan_regrovel_threshold = volscan_regrovel_threshold;
    ASSERT(read_report_discard_threshold >= 0.0);
    ASSERT(read_report_discard_threshold <= 1.0);
    this->read_report_discard_threshold = read_report_discard_threshold;
    ASSERT(min_file_size >= 0);
    this->min_file_size = min_file_size;
    ASSERT(min_file_age >= 0);
    this->min_file_age = min_file_age;
    this->allow_compressed_files = allow_compressed_files;
    this->allow_encrypted_files = allow_encrypted_files;
    this->allow_hidden_files = allow_hidden_files;
    this->allow_offline_files = allow_offline_files;
    this->allow_temporary_files = allow_temporary_files;
    ASSERT(num_excluded_paths >= 0);
    this->num_excluded_paths = num_excluded_paths;
    ASSERT(excluded_paths != 0);
    this->excluded_paths = excluded_paths;
    ASSERT(peak_finder_accuracy > 0.0);
    ASSERT(peak_finder_accuracy <= 1.0);
    this->peak_finder_accuracy = peak_finder_accuracy;
    ASSERT(peak_finder_range >= 1.0);
    read_peak_finder[RT_hash] =
        new PeakFinder(peak_finder_accuracy, peak_finder_range);
    read_peak_finder[RT_compare] =
        new PeakFinder(peak_finder_accuracy, peak_finder_range);
    ASSERT(base_cpu_load_threshold >= 0.0);
    this->base_cpu_load_threshold = base_cpu_load_threshold;
    ASSERT(read_time_increase_history_size > 0);
    ASSERT(read_time_decrease_history_size > 0);
    ASSERT(hash_read_time_estimate != 0);
    ASSERT(*hash_read_time_estimate >= 0.0);
    read_time_filter[RT_hash] =
        new DirectedIncidentFilter(read_time_increase_history_size,
        read_time_decrease_history_size, *hash_read_time_estimate);
    ASSERT(compare_read_time_estimate != 0);
    ASSERT(*compare_read_time_estimate >= 0.0);
    read_time_filter[RT_compare] =
        new DirectedIncidentFilter(read_time_increase_history_size,
        read_time_decrease_history_size, *compare_read_time_estimate);
    read_time_estimate[RT_hash] = hash_read_time_estimate;
    read_time_estimate[RT_compare] = compare_read_time_estimate;
    log_max_grovel_interval = log(double(max_grovel_interval));
    ASSERT(low_confidence_grovel_interval > 0);
    log_low_confidence_slope =
        log_max_grovel_interval - log(double(low_confidence_grovel_interval));
    if (log_low_confidence_slope < 0.0)
    {
        log_low_confidence_slope = 0.0;
    }
    ASSERT(low_disk_space_grovel_interval > 0);
    low_disk_space_slope = max_grovel_interval - low_disk_space_grovel_interval;
    if (low_disk_space_slope < 0.0)
    {
        low_disk_space_slope = 0.0;
    }
    ASSERT(max_use_multiplier >= base_use_multiplier);
    use_multiplier_slope = max_use_multiplier - base_use_multiplier;
    ASSERT(max_cpu_load_threshold <= 1.0);
    ASSERT(max_cpu_load_threshold >= base_cpu_load_threshold);
    cpu_load_threshold_slope = max_cpu_load_threshold - base_cpu_load_threshold;
    ASSERT(volume_serial_number != 0);
    this->volume_serial_number = volume_serial_number;
    update_partition_info((void *)this);
    ASSERT(volume_total_bytes > 0.0);
    ASSERT(volume_free_bytes >= 0.0);
    current_usn_log_size = base_usn_log_size;
    restart_groveling_interval = base_restart_groveling_interval;
    remaining_grovel_interval = 0;
    restart_volume_scan = false;
    extended_restart_in_progress = false;
    initialize_groveling(groveler_status);
    log_extractor_dead = true;
    restart_extraction_interval = base_restart_extraction_interval;
    remaining_restart_extraction_interval = 0;
    restart_extraction((void *)this);
}

PartitionController::~PartitionController()
{
    ASSERT(read_peak_finder[RT_hash] != 0);
    delete read_peak_finder[RT_hash];
    read_peak_finder[RT_hash] = 0;
    ASSERT(read_peak_finder[RT_compare] != 0);
    delete read_peak_finder[RT_compare];
    read_peak_finder[RT_hash] = 0;
    ASSERT(read_time_filter[RT_hash] != 0);
    delete read_time_filter[RT_hash];
    read_time_filter[RT_hash] = 0;
    ASSERT(read_time_filter[RT_compare] != 0);
    delete read_time_filter[RT_compare];
    read_time_filter[RT_compare] = 0;
}

bool
PartitionController::control_operation(
    DWORD grovel_duration,
    DWORD *count_of_files_hashed,
    DWORDLONG *bytes_of_files_hashed,
    DWORD *count_of_files_matching,
    DWORDLONG *bytes_of_files_matching,
    DWORD *count_of_files_compared,
    DWORDLONG *bytes_of_files_compared,
    DWORD *count_of_files_merged,
    DWORDLONG *bytes_of_files_merged,
    DWORD *count_of_files_enqueued,
    DWORD *count_of_files_dequeued,
    double cpu_load)
{
    ASSERT(this != 0);
    ASSERT(grovel_duration > 0);
    ASSERT(count_of_files_hashed != 0);
    ASSERT(bytes_of_files_hashed != 0);
    ASSERT(count_of_files_matching != 0);
    ASSERT(bytes_of_files_matching != 0);
    ASSERT(count_of_files_compared != 0);
    ASSERT(bytes_of_files_compared != 0);
    ASSERT(count_of_files_merged != 0);
    ASSERT(bytes_of_files_merged != 0);
    ASSERT(count_of_files_enqueued != 0);
    ASSERT(count_of_files_dequeued != 0);
    ASSERT(cpu_load >= 0.0);
    ASSERT(cpu_load <= 1.0);
    ASSERT(!groveler_dead);
    unsigned int current_time = GET_TICK_COUNT();
    TRACE_PRINTF(TC_partctrl, 3, (_T("time: %d\n"), current_time));
    TRACE_PRINTF(TC_partctrl, 3, (_T("\tPCco -\toperating on drive %s\n"),
        sis_drives.partition_mount_name(partition_index)));
    int files_to_compare = groveler->count_of_files_to_compare();
    ASSERT(files_to_compare >= 0);
    int files_in_queue = groveler->count_of_files_in_queue();
    ASSERT(files_in_queue >= 0);
    int ready_time = groveler->time_to_first_file_ready();
    ASSERT(files_in_queue == 0 || ready_time >= 0);
    bool more_work_to_do = files_to_compare > 0 ||
        files_in_queue > 0 && ready_time < volscan_regrovel_threshold;
    if (log_extractor_dead && !performing_full_volume_scan && !more_work_to_do)
    {
        initiate_full_volume_scan = true;
    }
    partition_grovel_accumulator.increment();
    ASSERT(groveler != 0);
    bool ok;
    if (initiate_full_volume_scan ||
        performing_full_volume_scan && !more_work_to_do)
    {
        if (initiate_full_volume_scan)
        {
            TRACE_PRINTF(TC_partctrl, 1,
                (_T("\tPCco -\tinitiating full volume scan\n")));
            initiate_full_volume_scan = false;
            performing_full_volume_scan = true;
            restart_volume_scan = true;
        }
        TRACE_PRINTF(TC_partctrl, 4,
            (_T("\tPCco -\tperforming full volume scan\n")));
        ok = control_volume_scan(grovel_duration, count_of_files_enqueued);
        *count_of_files_hashed = 0;
        *bytes_of_files_hashed = 0;
        *count_of_files_matching = 0;
        *bytes_of_files_matching = 0;
        *count_of_files_compared = 0;
        *bytes_of_files_compared = 0;
        *count_of_files_merged = 0;
        *bytes_of_files_merged = 0;
        *count_of_files_dequeued = 0;
    }
    else
    {
        TRACE_PRINTF(TC_partctrl, 4, (_T("\tPCco -\tgroveling\n")));
        ok = control_groveling(grovel_duration,
            count_of_files_hashed, bytes_of_files_hashed,
            count_of_files_matching, bytes_of_files_matching,
            count_of_files_compared, bytes_of_files_compared,
            count_of_files_merged, bytes_of_files_merged,
            count_of_files_enqueued, count_of_files_dequeued,
            cpu_load);
    }
    if (groveler_dead)
    {
        TRACE_PRINTF(TC_partctrl, 1,
            (_T("\tPCco -\tconcluding foreground batch for drive %s\n"),
            sis_drives.partition_mount_name(partition_index)));
        SERVICE_SET_FOREGROUND_BATCH_IN_PROGRESS(partition_index, false);
    }
    else
    {
        files_to_compare = groveler->count_of_files_to_compare();
        ASSERT(files_to_compare >= 0);
        files_in_queue = groveler->count_of_files_in_queue();
        ASSERT(files_in_queue >= 0);
        ready_time = groveler->time_to_first_file_ready();
        ASSERT(files_in_queue == 0 || ready_time >= 0);
        more_work_to_do = files_to_compare > 0 ||
            files_in_queue > 0 && ready_time < volscan_regrovel_threshold;
        if (!performing_full_volume_scan && !more_work_to_do)
        {
            TRACE_PRINTF(TC_partctrl, 1,
                (_T("\tPCco -\tconcluding foreground batch for drive %s\n"),
                sis_drives.partition_mount_name(partition_index)));
            SERVICE_SET_FOREGROUND_BATCH_IN_PROGRESS(partition_index, false);
        }
    }
    return ok;
}

void
PartitionController::advance(
    int time_delta)
{
    ASSERT(this != 0);
    ASSERT(time_delta >= 0);
    unsigned int current_time = GET_TICK_COUNT();
    TRACE_PRINTF(TC_partctrl, 4, (_T("time: %d\n"), current_time));
    TRACE_PRINTF(TC_partctrl, 4,
        (_T("\tPCa -\tadvancing time for drive %s by %d\n"),
        sis_drives.partition_mount_name(partition_index), time_delta));
    if (groveler_dead)
    {
        return;
    }
    ASSERT(remaining_grovel_interval >= 0);
    remaining_grovel_interval -= time_delta;
    if (remaining_grovel_interval < 0)
    {
        remaining_grovel_interval = 0;
    }
    TRACE_PRINTF(TC_partctrl, 4,
        (_T("\tPCa -\tremaining grovel interval = %d\n"),
        remaining_grovel_interval));
}

double
PartitionController::priority() const
{
    ASSERT(this != 0);
    unsigned int current_time = GET_TICK_COUNT();
    TRACE_PRINTF(TC_partctrl, 4, (_T("time: %d\n"), current_time));
    TRACE_PRINTF(TC_partctrl, 4,
        (_T("\tPCp -\tcalculating priority on drive %s\n"),
        sis_drives.partition_mount_name(partition_index)));
    if (groveler_dead)
    {
        return DBL_MAX;
    }
    double accumulated_groveling =
        partition_grovel_accumulator.retrieve_value();
    ASSERT(accumulated_groveling >= 0.0);
    TRACE_PRINTF(TC_partctrl, 5,
        (_T("\tPCp -\taccumulated groveling = %f\n"), accumulated_groveling));
    double calculated_priority =
        (1.0 + accumulated_groveling) * (1.0 + volume_free_bytes);
    ASSERT(calculated_priority > 1.0);
    TRACE_PRINTF(TC_partctrl, 4,
        (_T("\tPCp -\tcalculated priority = %f\n"), calculated_priority));
    return calculated_priority;
}

int
PartitionController::wait() const
{
    ASSERT(this != 0);
    ASSERT(groveler != 0);
    unsigned int current_time = GET_TICK_COUNT();
    TRACE_PRINTF(TC_partctrl, 4, (_T("time: %d\n"), current_time));
    TRACE_PRINTF(TC_partctrl, 4,
        (_T("\tPCw -\tcalculating wait time for drive %s\n"),
        sis_drives.partition_mount_name(partition_index)));
    int time_until_groveler_ready = max_grovel_interval;
    if (!groveler_dead)
    {
        int files_to_compare = groveler->count_of_files_to_compare();
        ASSERT(files_to_compare >= 0);
        int files_in_queue = groveler->count_of_files_in_queue();
        ASSERT(files_in_queue >= 0);
        int ready_time = groveler->time_to_first_file_ready();
        ASSERT(files_in_queue == 0 || ready_time >= 0);
        bool more_work_to_do = files_to_compare > 0 ||
            files_in_queue > 0 && ready_time < volscan_regrovel_threshold;
        if (files_to_compare > 0 ||
            initiate_full_volume_scan && !more_work_to_do ||
            performing_full_volume_scan && !more_work_to_do ||
            log_extractor_dead && !more_work_to_do)
        {
            time_until_groveler_ready = 0;
            TRACE_PRINTF(TC_partctrl, 5, (_T("\tPCw -\tgroveler ready now\n")));
        }
        else if (files_in_queue > 0)
        {
            time_until_groveler_ready = ready_time;
            ASSERT(time_until_groveler_ready >= 0);
            TRACE_PRINTF(TC_partctrl, 5,
                (_T("\tPCw -\ttime until groveler ready = %d\n"),
                time_until_groveler_ready));
        }
    }
    TRACE_PRINTF(TC_partctrl, 5,
        (_T("\tPCw -\tremaining grovel interval = %d\n"),
        remaining_grovel_interval));
    int wait_time = __max(remaining_grovel_interval, time_until_groveler_ready);
    TRACE_PRINTF(TC_partctrl, 4, (_T("\tPCw -\twait time = %d\n"), wait_time));
    return wait_time;
}

void
PartitionController::demarcate_foreground_batch()
{
    ASSERT(this != 0);
    unsigned int current_time = GET_TICK_COUNT();
    if (!groveler_dead)
    {
        TRACE_PRINTF(TC_partctrl, 1, (_T("time: %d\n"), current_time));
        TRACE_PRINTF(TC_partctrl, 1,
            (_T("\tPCdfb -\tdemarcating foreground batch for drive %s\n"),
            sis_drives.partition_mount_name(partition_index)));
        SERVICE_SET_FOREGROUND_BATCH_IN_PROGRESS(partition_index, true);
    }
}

void
PartitionController::command_full_volume_scan()
{
    ASSERT(this != 0);
    unsigned int current_time = GET_TICK_COUNT();
    TRACE_PRINTF(TC_partctrl, 1, (_T("time: %d\n"), current_time));
    TRACE_PRINTF(TC_partctrl, 1,
        (_T("\tPCcfvs -\tcommanding full volume scan for drive %s\n"),
        sis_drives.partition_mount_name(partition_index)));
    initiate_full_volume_scan = true;
}

void
PartitionController::control_extraction(
    void *context)
{
    ASSERT(context != 0);
    unsigned int invokation_time = GET_TICK_COUNT();
    TRACE_PRINTF(TC_partctrl, 3, (_T("time: %d\n"), invokation_time));
    PartitionController *me = (PartitionController *)context;
    TRACE_PRINTF(TC_partctrl, 3, (_T("\tPCce -\textracting log on drive %s\n"),
        sis_drives.partition_mount_name(me->partition_index)));
    ASSERT(!me->log_extractor_dead);
    if (me->groveler_dead || me->restart_extraction_required)
    {
        TRACE_PRINTF(TC_partctrl, 4, (_T("\tPCce -\trestarting extraction\n")));
        me->log_extractor_dead = true;
        me->restart_extraction_interval = me->base_restart_extraction_interval;
        me->remaining_restart_extraction_interval = 0;
        restart_extraction(context);
        return;
    }
    DWORD num_entries_extracted;
    DWORDLONG num_bytes_extracted;
    DWORDLONG num_bytes_skipped;
    DWORD num_files_enqueued;
    DWORD num_files_dequeued;
    GrovelStatus status =
        me->groveler->extract_log(&num_entries_extracted, &num_bytes_extracted,
        &num_bytes_skipped, &num_files_enqueued, &num_files_dequeued);
    unsigned int completion_time = GET_TICK_COUNT();
    if (status == Grovel_overrun)
    {
        ASSERT(signed(num_entries_extracted) >= 0);
        ASSERT(signed(num_bytes_extracted) >= 0);
        ASSERT(signed(num_bytes_skipped) >= 0);
        ASSERT(signed(num_files_enqueued) >= 0);
        ASSERT(signed(num_files_dequeued) >= 0);
        TRACE_PRINTF(TC_partctrl, 1,
            (_T("\tPCce -\textract_log() returned Grovel_overrun\n")));
        me->initiate_full_volume_scan = true;
        eventlog.report_event(GROVMSG_USN_LOG_OVERRUN, ERROR_SUCCESS,
            1, sis_drives.partition_mount_name(me->partition_index));
        if (!me->first_extraction)
        {
            __int64 usn_log_size = num_bytes_extracted + num_bytes_skipped;
            ASSERT(me->base_usn_log_size > 0);
            ASSERT(me->max_usn_log_size > 0);
            ASSERT(me->current_usn_log_size >= me->base_usn_log_size);
            ASSERT(me->current_usn_log_size <= me->max_usn_log_size);
            if (usn_log_size > me->current_usn_log_size &&
                me->current_usn_log_size < me->max_usn_log_size)
            {
                if (usn_log_size > me->max_usn_log_size)
                {
                    usn_log_size = me->max_usn_log_size;
                }
                _TCHAR size_string[32];
                (void)StringCbPrintf(size_string, sizeof(size_string), _T("%d"), usn_log_size);
                eventlog.report_event(GROVMSG_SET_USN_LOG_SIZE, ERROR_SUCCESS,
                    2,
                    sis_drives.partition_mount_name(me->partition_index),
                    size_string);
                TRACE_PRINTF(TC_partctrl, 2,
                    (_T("\tPCce -\tincreasing USN log size from %d to %d\n"),
                    me->current_usn_log_size, usn_log_size));
                me->current_usn_log_size = usn_log_size;
                DWORD lstatus = me->groveler->set_usn_log_size(usn_log_size);
                if (lstatus != ERROR_SUCCESS)
                {
                    TRACE_PRINTF(TC_partctrl, 1,
                        (_T("\tPCce -\tset_usn_log_size() returned error, status=%d\n"),lstatus));
                    TRACE_PRINTF(TC_partctrl, 1,
                        (_T("\t\tsuspending control_extraction()\n")));
                    eventlog.report_event(GROVMSG_LOG_EXTRACTOR_DEAD, lstatus,
                        1,sis_drives.partition_mount_name(me->partition_index));

                    me->log_extractor_dead = true;
                    me->restart_extraction_interval =
                        me->base_restart_extraction_interval;
                    me->remaining_restart_extraction_interval =
                        me->restart_extraction_interval;
                    event_timer.schedule(
                        completion_time + me->max_extraction_interval,
                        context, restart_extraction);
                    return;
                }
            }
        }
    }
    else if (status != Grovel_ok)
    {
        ASSERT(status == Grovel_error);
        TRACE_PRINTF(TC_partctrl, 1,
            (_T("\tPCce -\textract_log() returned error\n")));
        TRACE_PRINTF(TC_partctrl, 1,
            (_T("\t\tsuspending control_extraction()\n")));
        eventlog.report_event(GROVMSG_LOG_EXTRACTOR_DEAD, GetLastError(),
            1,sis_drives.partition_mount_name(me->partition_index));
        me->log_extractor_dead = true;
        me->restart_extraction_interval = me->base_restart_extraction_interval;
        me->remaining_restart_extraction_interval =
            me->restart_extraction_interval;
        event_timer.schedule(completion_time + me->max_extraction_interval,
            context, restart_extraction);
        return;
    }
    unsigned int extraction_time = completion_time - invokation_time;
    ASSERT(signed(extraction_time) >= 0);
    shared_data->increment_value(me->partition_index,
        SDF_extract_time, extraction_time);
    shared_data->increment_value(me->partition_index,
        SDF_working_time, extraction_time);
    int queue_length = me->groveler->count_of_files_in_queue();
    ASSERT(queue_length >= 0);
    shared_data->set_value(me->partition_index, SDF_queue_length, queue_length);
    TRACE_PRINTF(TC_partctrl, 4,
        (_T("\tPCce -\tnum entries extracted = %d\n"), num_entries_extracted));
    TRACE_PRINTF(TC_partctrl, 4,
        (_T("\tPCce -\tnum files enqueued = %d\n"), num_files_enqueued));
    ASSERT(signed(num_entries_extracted) >= 0);
    ASSERT(signed(num_bytes_extracted) >= 0);
    ASSERT(signed(num_bytes_skipped) >= 0);
    ASSERT(signed(num_files_enqueued) >= 0);
    ASSERT(signed(num_files_dequeued) >= 0);
    ASSERT(num_bytes_extracted >= num_entries_extracted);
    ASSERT(num_files_enqueued <= num_entries_extracted);
    ASSERT(status == Grovel_overrun || num_bytes_skipped == 0);
    me->first_extraction = false;
    if (num_entries_extracted < 1)
    {
        num_entries_extracted = 1;
    }
    ASSERT(me->extraction_interval > 0);
    ASSERT(me->target_entries_per_extraction > 0);
    int ideal_extraction_interval = me->extraction_interval *
        me->target_entries_per_extraction / num_entries_extracted + 1;
    ASSERT(ideal_extraction_interval > 0);
    TRACE_PRINTF(TC_partctrl, 5,
        (_T("\tPCce -\tideal extraction interval = %d\n"),
        ideal_extraction_interval));
    if (ideal_extraction_interval < me->extraction_interval)
    {
        me->extraction_interval = ideal_extraction_interval;
    }
    else
    {
        me->extraction_interval = int(sqrt(double(me->extraction_interval)
            * double(ideal_extraction_interval)));
        ASSERT(me->max_extraction_interval > 0);
        if (me->extraction_interval > me->max_extraction_interval)
        {
            me->extraction_interval = me->max_extraction_interval;
        }
    }
    TRACE_PRINTF(TC_partctrl, 5,
        (_T("\tPCce -\textraction interval = %d\n"), me->extraction_interval));
    ASSERT(me->extraction_interval > 0);
    ASSERT(me->extraction_interval <= me->max_extraction_interval);
    event_timer.schedule(invokation_time + me->extraction_interval,
        context, control_extraction);
}

void
PartitionController::restart_extraction(
    void *context)
{
    ASSERT(context != 0);
    unsigned int invokation_time = GET_TICK_COUNT();
    TRACE_PRINTF(TC_partctrl, 3, (_T("time: %d\n"), invokation_time));
    PartitionController *me = (PartitionController *)context;
    TRACE_PRINTF(TC_partctrl, 3,
        (_T("\tPCre -\tconsidering restart extraction on drive %s\n"),
        sis_drives.partition_mount_name(me->partition_index)));
    ASSERT(me->log_extractor_dead);
    me->remaining_restart_extraction_interval -=
        __min(me->remaining_restart_extraction_interval,
        me->max_extraction_interval);
    TRACE_PRINTF(TC_partctrl, 4, (_T("\tPCre -\tremaining restart extraction interval = %d\n"),
        me->remaining_restart_extraction_interval));
    if (!me->groveler_dead && me->remaining_restart_extraction_interval == 0)
    {
        TRACE_PRINTF(TC_partctrl, 2, (_T("time: %d\n"), invokation_time));
        TRACE_PRINTF(TC_partctrl, 2,
            (_T("\tPCre -\tattempting restart extraction on drive %s\n"),
            sis_drives.partition_mount_name(me->partition_index)));

//  Disabled this message since it serves no purpose, nealch 4/17/02
//        eventlog.report_event(GROVMSG_USN_LOG_RETRY, ERROR_SUCCESS, 
//            1,sis_drives.partition_mount_name(me->partition_index));

        DWORD lstatus = me->groveler->set_usn_log_size(me->current_usn_log_size);
        if (lstatus == ERROR_SUCCESS)
        {
            TRACE_PRINTF(TC_partctrl, 2,
                (_T("\tPCre -\tset_usn_log_size() returned success\n")));
            _TCHAR size_string[32];
            (void)StringCbPrintf(size_string, sizeof(size_string), _T("%d"), me->current_usn_log_size);
            eventlog.report_event(GROVMSG_INIT_USN_LOG, ERROR_SUCCESS,
                2,
                sis_drives.partition_mount_name(me->partition_index),
                size_string);
            me->restart_extraction_required = false;
            me->log_extractor_dead = false;
            me->first_extraction = true;
            control_extraction(context);
            return;
        }
        else
        {
            TRACE_PRINTF(TC_partctrl, 3,
                (_T("\tPCre -\tset_usn_log_size() returned error, status=%d\n"),lstatus));
            ASSERT(lstatus != ERROR_SUCCESS);
            me->remaining_restart_extraction_interval =
                me->restart_extraction_interval;
            TRACE_PRINTF(TC_partctrl, 4,
                (_T("\tPCre -\tremaining restart extraction interval = %d\n"),
                me->remaining_restart_extraction_interval));
            me->restart_extraction_interval *= 2;
            if (me->restart_extraction_interval >
                me->max_restart_extraction_interval)
            {
                me->restart_extraction_interval =
                    me->max_restart_extraction_interval;
            }
            TRACE_PRINTF(TC_partctrl, 4,
                (_T("\tPCre -\tnext restart extraction interval = %d\n"),
                me->restart_extraction_interval));
        }
    }
    event_timer.schedule(invokation_time + me->max_extraction_interval,
        context, restart_extraction);
}

void
PartitionController::restart_groveling(
    void *context)
{
    ASSERT(context != 0);
    unsigned int invokation_time = GET_TICK_COUNT();
    TRACE_PRINTF(TC_partctrl, 2, (_T("time: %d\n"), invokation_time));
    PartitionController *me = (PartitionController *)context;
    TRACE_PRINTF(TC_partctrl, 2,
        (_T("\tPCrg -\tattempting to restart groveler on drive %s\n"),
        sis_drives.partition_mount_name(me->partition_index)));
    ASSERT(me->groveler_dead);
    me->groveler->close();
    eventlog.report_event(GROVMSG_GROVELER_RETRY, ERROR_SUCCESS,
        1,sis_drives.partition_mount_name(me->partition_index));
    GrovelStatus status = me->groveler->open(
        sis_drives.partition_guid_name(me->partition_index),
        sis_drives.partition_mount_name(me->partition_index),
        me->partition_index == log_drive->drive_index(),
        me->read_report_discard_threshold,
        me->min_file_size,
        me->min_file_age,
        me->allow_compressed_files,
        me->allow_encrypted_files,
        me->allow_hidden_files,
        me->allow_offline_files,
        me->allow_temporary_files,
        GrovelAllPaths,
        me->num_excluded_paths,
        me->excluded_paths,
        me->base_regrovel_interval,
        me->max_regrovel_interval);
    if (status == Grovel_ok)
    {
        TRACE_PRINTF(TC_partctrl, 2,
            (_T("\tPCrg -\topen() returned ok\n")));
        log_drive->partition_initialized(me->partition_index);
        eventlog.report_event(GROVMSG_GROVELER_STARTED, ERROR_SUCCESS,
            1,sis_drives.partition_mount_name(me->partition_index));
    }
    else if (status == Grovel_new)
    {
        TRACE_PRINTF(TC_partctrl, 2,
            (_T("\tPCrg -\topen() returned new\n")));
    }
    else
    {
        ASSERT(status == Grovel_error);
        TRACE_PRINTF(TC_partctrl, 3,
            (_T("\tPCrg -\topen() returned error\n")));
    }
    me->restart_volume_scan = true;
    me->initialize_groveling(status);
}

void
PartitionController::update_partition_info(
    void *context)
{
    ASSERT(context != 0);
    unsigned int invokation_time = GET_TICK_COUNT();
    TRACE_PRINTF(TC_partctrl, 3, (_T("time: %d\n"), invokation_time));
    PartitionController *me = (PartitionController *)context;
    TRACE_PRINTF(TC_partctrl, 3,
        (_T("\tPCupi -\tupdating partition info for drive %s\n"),
        sis_drives.partition_mount_name(me->partition_index)));
    ULARGE_INTEGER my_free_bytes;
    ULARGE_INTEGER total_bytes;
    ULARGE_INTEGER free_bytes;
    int ok = GetDiskFreeSpaceEx(
        sis_drives.partition_guid_name(me->partition_index),
        &my_free_bytes, &total_bytes, &free_bytes);
    if (ok)
    {
        me->volume_total_bytes = double(__int64(total_bytes.QuadPart));
        me->volume_free_bytes = double(__int64(free_bytes.QuadPart));
        ASSERT(me->volume_total_bytes > 0.0);
        ASSERT(me->volume_free_bytes >= 0.0);
        TRACE_PRINTF(TC_partctrl, 4, (_T("\tPCupi -\tvolume total bytes = %f\n"),
            me->volume_total_bytes));
        TRACE_PRINTF(TC_partctrl, 4, (_T("\tPCupi -\tvolume free bytes = %f\n"),
            me->volume_free_bytes));
    }
    else
    {
        TRACE_PRINTF(TC_partctrl, 3, (_T("\tPCupi -\tGetDiskFreeSpaceEx() returned error.\n")));
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: GetDiskFreeSpaceEx() failed with error %d\n"),
            err));
    }
    ASSERT(me->partition_info_update_interval > 0);
    event_timer.schedule(invokation_time + me->partition_info_update_interval,
        context, update_partition_info);
}

void
PartitionController::initialize_groveling(
    GrovelStatus groveler_status)
{
    ASSERT(this != 0);
    unsigned int invokation_time = GET_TICK_COUNT();
    TRACE_PRINTF(TC_partctrl, 3, (_T("time: %d\n"), invokation_time));
    TRACE_PRINTF(TC_partctrl, 3,
        (_T("\tPCig -\tinitializing groveling for drive %s\n"),
        sis_drives.partition_mount_name(partition_index)));
    if (groveler_status == Grovel_ok || groveler_status == Grovel_new)
    {
        TRACE_PRINTF(TC_partctrl, 3,
            (_T("\tPCig -\tgroveler_status indicates success\n")));
        groveler_dead = false;
        DWORD serial_number;
        int ok = GetVolumeInformation(
            sis_drives.partition_guid_name(partition_index),
            0, 0, &serial_number, 0, 0, 0, 0);
        if (!ok)
        {
            DWORD err = GetLastError();
            TRACE_PRINTF(TC_partctrl, 3,
                (_T("\tPCig -\tGetVolumeInformation() returned error %d\n"),
                err));
            PRINT_DEBUG_MSG((_T("GROVELER: GetVolumeInformation() failed with error %d\n"),
                err));
        }
        else
        {
            TRACE_PRINTF(TC_partctrl, 5,
                (_T("\tPCig -\tGetVolumeInformation() returned ")
                _T("serial number %d\n"), serial_number));
            TRACE_PRINTF(TC_partctrl, 5,
                (_T("\tPCig -\trecorded serial number is %d\n"),
                *volume_serial_number));
            if (volume_serial_number == 0)
            {
                TRACE_PRINTF(TC_partctrl, 3,
                    (_T("\tPCig -\tGetVolumeInformation() returned ")
                    _T("serial number 0\n")));
                PRINT_DEBUG_MSG((_T("GROVELER: GetVolumeInformation() returned ")
                    _T("volume serial number 0\n")));
            }
        }
        if (ok && int(serial_number) != *volume_serial_number)
        {
            TRACE_PRINTF(TC_partctrl, 5,
                (_T("\tPCig -\tresetting read time filters\n")));
            read_time_filter[RT_hash]->reset();
            read_time_filter[RT_compare]->reset();
            read_time_confidence_estimator.reset();
            *read_time_estimate[RT_hash] =
                read_time_filter[RT_hash]->retrieve_value();
            ASSERT(*read_time_estimate[RT_hash] == 0.0);
            *read_time_estimate[RT_compare] =
                read_time_filter[RT_compare]->retrieve_value();
            ASSERT(*read_time_estimate[RT_compare] == 0.0);
            *read_time_confidence = read_time_confidence_estimator.confidence();
            ASSERT(*read_time_confidence == 0.0);
            *volume_serial_number = serial_number;
        }
        extraction_interval = max_extraction_interval;
        free_space_ratio = 0.0;
        calculate_effective_max_grovel_interval();
        ASSERT(effective_max_grovel_interval > 0);
        ASSERT(effective_max_grovel_interval <= max_grovel_interval);
        grovel_interval = base_grovel_interval;
        remaining_grovel_interval = grovel_interval;
        ok_to_record_measurement = true;
        next_untrusted_measurement_time = invokation_time;
        restart_extraction_required = true;
        if (groveler_status == Grovel_new)
        {
            TRACE_PRINTF(TC_partctrl, 4,
                (_T("\tPCig -\tinitiating full volume scan\n")));
            initiate_full_volume_scan = true;
            performing_full_volume_scan = false;
            extended_restart_in_progress = true;
        }
        else
        {
            TRACE_PRINTF(TC_partctrl, 4,
                (_T("\tPCig -\tcontinuing full volume scan\n")));
            initiate_full_volume_scan = false;
            performing_full_volume_scan = true;
            extended_restart_in_progress = false;
            restart_groveling_interval = base_restart_groveling_interval;
        }
        TRACE_PRINTF(TC_partctrl, 5,
            (_T("\tPCig -\trestart groveling interval = %d\n"),
            restart_groveling_interval));
    }
    else
    {
        TRACE_PRINTF(TC_partctrl, 3,
            (_T("\tPCig -\tgroveler_status indicates error or disable\n")));
        ASSERT(groveler_status == Grovel_error
            || groveler_status == Grovel_disable);
        groveler_dead = true;
        if (groveler_status != Grovel_disable && error_retry_groveling)
        {
            TRACE_PRINTF(TC_partctrl, 5,
                (_T("\tPCig -\tscheduling restart groveling\n")));
            TRACE_PRINTF(TC_partctrl, 5,
                (_T("\tPCig -\trestart groveling interval = %d\n"),
                restart_groveling_interval));
            event_timer.schedule(invokation_time + restart_groveling_interval,
                (void *)this, restart_groveling);
        }
        restart_groveling_interval *= 2;
        if (restart_groveling_interval > max_restart_groveling_interval)
        {
            restart_groveling_interval = max_restart_groveling_interval;
        }
        TRACE_PRINTF(TC_partctrl, 5,
            (_T("\tPCig -\tnext restart groveling interval = %d\n"),
            restart_groveling_interval));
    }
}

bool
PartitionController::control_groveling(
    DWORD grovel_duration,
    DWORD *count_of_files_hashed,
    DWORDLONG *bytes_of_files_hashed,
    DWORD *count_of_files_matching,
    DWORDLONG *bytes_of_files_matching,
    DWORD *count_of_files_compared,
    DWORDLONG *bytes_of_files_compared,
    DWORD *count_of_files_merged,
    DWORDLONG *bytes_of_files_merged,
    DWORD *count_of_files_enqueued,
    DWORD *count_of_files_dequeued,
    double cpu_load)
{
    ASSERT(this != 0);
    ASSERT(grovel_duration > 0);
    ASSERT(count_of_files_hashed != 0);
    ASSERT(bytes_of_files_hashed != 0);
    ASSERT(count_of_files_matching != 0);
    ASSERT(bytes_of_files_matching != 0);
    ASSERT(count_of_files_compared != 0);
    ASSERT(bytes_of_files_compared != 0);
    ASSERT(count_of_files_merged != 0);
    ASSERT(bytes_of_files_merged != 0);
    ASSERT(count_of_files_enqueued != 0);
    ASSERT(count_of_files_dequeued != 0);
    ASSERT(cpu_load >= 0.0);
    ASSERT(cpu_load <= 1.0);
    ASSERT(!groveler_dead);
    unsigned int invokation_time = GET_TICK_COUNT();
    TRACE_PRINTF(TC_partctrl, 2,
        (_T("time: %d\n"), invokation_time));
    TRACE_PRINTF(TC_partctrl, 2, (_T("\tPCcg -\tgroveling on drive %s\n"),
        sis_drives.partition_mount_name(partition_index)));
    DWORD hash_read_ops;
    DWORD hash_read_time;
    DWORD compare_read_ops;
    DWORD compare_read_time;
    DWORD merge_time;
    GrovelStatus status = groveler->grovel(grovel_duration,
        &hash_read_ops, &hash_read_time,
        count_of_files_hashed, bytes_of_files_hashed,
        &compare_read_ops, &compare_read_time,
        count_of_files_compared, bytes_of_files_compared,
        count_of_files_matching, bytes_of_files_matching,
        &merge_time,
        count_of_files_merged, bytes_of_files_merged,
        count_of_files_enqueued, count_of_files_dequeued);
    unsigned int completion_time = GET_TICK_COUNT();
    if (status != Grovel_ok && status != Grovel_pending)
    {
        ASSERT(status == Grovel_error);
        *count_of_files_hashed = 0;
        *bytes_of_files_hashed = 0;
        *count_of_files_matching = 0;
        *bytes_of_files_matching = 0;
        *count_of_files_compared = 0;
        *bytes_of_files_compared = 0;
        *count_of_files_merged = 0;
        *bytes_of_files_merged = 0;
        *count_of_files_enqueued = 0;
        *count_of_files_dequeued = 0;
        TRACE_PRINTF(TC_partctrl, 1,
            (_T("\tPCcg -\tgrovel() returned error -- groveler dead\n")));
        eventlog.report_event(GROVMSG_GROVELER_DEAD, ERROR_SUCCESS,
            1,sis_drives.partition_mount_name(partition_index));
        groveler_dead = true;
        if (error_retry_groveling)
        {
            restart_groveling_interval = base_restart_groveling_interval;
            event_timer.schedule(invokation_time + restart_groveling_interval,
                (void *)this, restart_groveling);
            return true;
        }
        else
        {
            return false;
        }
    }
    ASSERT(hash_read_ops > 0 || hash_read_time == 0);
    ASSERT(compare_read_ops > 0 || compare_read_time == 0);
    ASSERT(*bytes_of_files_hashed >= *count_of_files_hashed);
    ASSERT(*bytes_of_files_matching >= *count_of_files_matching);
    ASSERT(*bytes_of_files_compared >= *count_of_files_compared);
    ASSERT(*bytes_of_files_merged >= *count_of_files_merged);
    ASSERT(*count_of_files_hashed >= *count_of_files_matching);
    ASSERT(*bytes_of_files_hashed >= *bytes_of_files_matching);
    ASSERT(*count_of_files_compared >= *count_of_files_merged);
    ASSERT(*bytes_of_files_compared >= *bytes_of_files_merged);
    ASSERT(*count_of_files_dequeued >= *count_of_files_hashed);
    unsigned int grovel_time = completion_time - invokation_time;
    ASSERT(signed(grovel_time) >= 0);
    shared_data->increment_value(partition_index,
        SDF_grovel_time, grovel_time);
    shared_data->increment_value(partition_index,
        SDF_working_time, grovel_time);
    shared_data->increment_value(partition_index,
        SDF_files_hashed, *count_of_files_hashed);
    shared_data->increment_value(partition_index,
        SDF_files_compared, *count_of_files_compared);
    shared_data->increment_value(partition_index,
        SDF_files_merged, *count_of_files_merged);
    int files_in_queue = groveler->count_of_files_in_queue();
    ASSERT(files_in_queue >= 0);
    int files_to_compare = groveler->count_of_files_to_compare();
    ASSERT(files_to_compare >= 0);
    shared_data->set_value(partition_index, SDF_queue_length, files_in_queue);
    TRACE_PRINTF(TC_partctrl, 4,
        (_T("\tPCcg -\thash read ops = %d\n"), hash_read_ops));
    TRACE_PRINTF(TC_partctrl, 4,
        (_T("\tPCcg -\thash read time = %d\n"), hash_read_time));
    TRACE_PRINTF(TC_partctrl, 4,
        (_T("\tPCcg -\tcompare read ops = %d\n"), compare_read_ops));
    TRACE_PRINTF(TC_partctrl, 4,
        (_T("\tPCcg -\tcompare read time = %d\n"), compare_read_time));
    shared_data->increment_value(partition_index,
        SDF_hash_read_time, hash_read_time);
    shared_data->increment_value(partition_index,
        SDF_hash_read_ops, hash_read_ops);
    shared_data->increment_value(partition_index,
        SDF_compare_read_time, compare_read_time);
    shared_data->increment_value(partition_index,
        SDF_compare_read_ops, compare_read_ops);
    update_peak_finder(RT_hash, hash_read_time, hash_read_ops);
    update_peak_finder(RT_compare, compare_read_time, compare_read_ops);
    shared_data->set_value(partition_index,
        SDF_hash_read_estimate, __int64(*read_time_estimate[RT_hash]));
    shared_data->set_value(partition_index,
        SDF_compare_read_estimate, __int64(*read_time_estimate[RT_compare]));
    int count_of_files_groveled =
        *count_of_files_hashed + *count_of_files_compared;
    ASSERT(mean_file_size != 0);
    if (count_of_files_groveled > 0)
    {
        __int64 bytes_of_files_groveled =
            *bytes_of_files_hashed + *bytes_of_files_compared;
        double sample_mean_file_size =
            double(bytes_of_files_groveled) / double(count_of_files_groveled);
        ASSERT(sample_mean_file_size > 0.0);
        file_size_filter.update_value(sample_mean_file_size,
            count_of_files_groveled);
        *mean_file_size = file_size_filter.retrieve_value();
        ASSERT(*mean_file_size > 0.0);
    }
    ASSERT(dequeue_hash_ratio != 0);
    ASSERT(*dequeue_hash_ratio >= 0.0);
    ASSERT(*dequeue_hash_ratio <= 1.0);
    double files_to_hash = *dequeue_hash_ratio * double(files_in_queue);
    ASSERT(*mean_file_size >= 0.0);
    double bytes_to_hash = *mean_file_size * files_to_hash;
    double bytes_to_compare = *mean_file_size * double(files_to_compare);
    double expected_bytes_to_free = *compare_match_ratio *
        (bytes_to_compare + *hash_match_ratio * bytes_to_hash);
    double expected_free_bytes = volume_free_bytes + expected_bytes_to_free;
    free_space_ratio = 0;
    if (expected_free_bytes > 0)
    {
        free_space_ratio = expected_bytes_to_free / expected_free_bytes;
    }
    ASSERT(free_space_ratio >= 0.0);
    ASSERT(free_space_ratio <= 1.0);
    calculate_effective_max_grovel_interval();
    ASSERT(effective_max_grovel_interval > 0);
    ASSERT(effective_max_grovel_interval <= max_grovel_interval);
    double use_multiplier =
        base_use_multiplier + use_multiplier_slope * free_space_ratio;
    ASSERT(use_multiplier >= 0.0);
    TRACE_PRINTF(TC_partctrl, 5,
        (_T("\tPCcg -\tuse multiplier = %f\n"), use_multiplier));
    double hash_comparison_time = use_multiplier * *read_time_estimate[RT_hash];
    ASSERT(hash_comparison_time >= 0.0);
    double compare_comparison_time =
        use_multiplier * *read_time_estimate[RT_compare];
    ASSERT(compare_comparison_time >= 0.0);
    TRACE_PRINTF(TC_partctrl, 5,
        (_T("\tPCcg -\thash comparison time = %f\n"), hash_comparison_time));
    TRACE_PRINTF(TC_partctrl, 5,
        (_T("\tPCcg -\tcompare comparison time = %f\n"),
        compare_comparison_time));
    TRACE_PRINTF(TC_partctrl, 5, (_T("\tPCcg -\tcpu load = %f\n"), cpu_load));
    double cpu_load_threshold = base_cpu_load_threshold +
        cpu_load_threshold_slope * free_space_ratio;
    TRACE_PRINTF(TC_partctrl, 5,
        (_T("\tPCcg -\tcpu load threshold = %f\n"), cpu_load_threshold));
    ASSERT(cpu_load_threshold >= 0.0);
    ASSERT(cpu_load_threshold <= 1.0);
    if (cpu_load > cpu_load_threshold || read_mean_comparator.exceeds(
        hash_comparison_time, compare_comparison_time))
    {
        TRACE_PRINTF(TC_partctrl, 3,
            (_T("\tPCcg -\tread time exceeds acceptable bounds\n")));
        TRACE_PRINTF(TC_partctrl, 3,
            (_T("\t\tor CPU load exceeds threshold\n")));
        ASSERT(grovel_interval > 0);
        remaining_grovel_interval = grovel_interval;
        read_mean_comparator.reset();
        grovel_interval *= 2;
        ok_to_record_measurement = false;
    }
    else if (read_mean_comparator.within(hash_comparison_time,
        compare_comparison_time))
    {
        TRACE_PRINTF(TC_partctrl, 3,
            (_T("\tPCcg -\tread time within acceptable bounds\n")));
        ASSERT(base_grovel_interval > 0);
        grovel_interval = base_grovel_interval;
        ok_to_record_measurement = true;
    }
    if (grovel_interval > effective_max_grovel_interval)
    {
        ASSERT(effective_max_grovel_interval > 0);
        grovel_interval = effective_max_grovel_interval;
    }
    TRACE_PRINTF(TC_partctrl, 4, (_T("\tPCcg -\tgrovel interval = %d\n"), grovel_interval));
    TRACE_PRINTF(TC_partctrl, 4, (_T("\tPCcg -\tremaining grovel interval = %d\n"),
        remaining_grovel_interval));
    return true;
}

bool
PartitionController::control_volume_scan(
    int scan_duration,
    DWORD *count_of_files_enqueued)
{
    ASSERT(this != 0);
    ASSERT(scan_duration > 0);
    ASSERT(count_of_files_enqueued != 0);
    ASSERT(!groveler_dead);
    unsigned int invokation_time = GET_TICK_COUNT();
    TRACE_PRINTF(TC_partctrl, 2, (_T("time: %d\n"), invokation_time));
    TRACE_PRINTF(TC_partctrl, 2,
        (_T("\tPCcvs -\tscanning volume on drive %s\n"),
        sis_drives.partition_mount_name(partition_index)));
    DWORD time_consumed;
    DWORD findfirst_count;
    DWORD findnext_count;
    GrovelStatus status = groveler->scan_volume(scan_duration,
        restart_volume_scan, &time_consumed, &findfirst_count, &findnext_count,
        count_of_files_enqueued);
    unsigned int completion_time = GET_TICK_COUNT();
    if (status == Grovel_ok || status == Grovel_pending)
    {
        if (extended_restart_in_progress)
        {
            log_drive->partition_initialized(partition_index);
            eventlog.report_event(GROVMSG_GROVELER_STARTED, ERROR_SUCCESS,
                1,sis_drives.partition_mount_name(partition_index));
            extended_restart_in_progress = false;
        }
        if (status == Grovel_ok)
        {
            TRACE_PRINTF(TC_partctrl, 1,
                (_T("\tPCcvs -\tcompleted volume scan\n")));
            performing_full_volume_scan = false;
        }
    }
    else
    {
        ASSERT(status == Grovel_error);
        *count_of_files_enqueued = 0;
        TRACE_PRINTF(TC_partctrl, 1,
            (_T("\tPCcvs -\tscan_volume() returned error -- groveler dead\n")));
        if (!extended_restart_in_progress)
        {
            eventlog.report_event(GROVMSG_GROVELER_DEAD, ERROR_SUCCESS,
                1,sis_drives.partition_mount_name(partition_index));
        }
        groveler_dead = true;
        if (error_retry_groveling)
        {
            if (!extended_restart_in_progress)
            {
                restart_groveling_interval = base_restart_groveling_interval;
            }
            event_timer.schedule(invokation_time + restart_groveling_interval,
                (void *)this, restart_groveling);
            if (extended_restart_in_progress)
            {
                restart_groveling_interval *= 2;
                if (restart_groveling_interval > max_restart_groveling_interval)
                {
                    restart_groveling_interval = max_restart_groveling_interval;
                }
                extended_restart_in_progress = false;
            }
            return true;
        }
        else
        {
            extended_restart_in_progress = false;
            return false;
        }
    }
    ASSERT(signed(time_consumed) >= 0);
    ASSERT(signed(findfirst_count) >= 0);
    ASSERT(signed(findnext_count) >= 0);
    ASSERT(signed(*count_of_files_enqueued) >= 0);
    unsigned int scan_time = completion_time - invokation_time;
    ASSERT(signed(scan_time) >= 0);
    shared_data->increment_value(partition_index, SDF_volscan_time, scan_time);
    shared_data->increment_value(partition_index, SDF_working_time, scan_time);
    shared_data->increment_value(partition_index,
        SDF_files_scanned, findfirst_count + findnext_count);
    int queue_length = groveler->count_of_files_in_queue();
    ASSERT(queue_length >= 0);
    shared_data->set_value(partition_index, SDF_queue_length, queue_length);
    restart_volume_scan = false;
    TRACE_PRINTF(TC_partctrl, 4,
        (_T("\tPCcvs -\ttime consumed = %d\n"), time_consumed));
    TRACE_PRINTF(TC_partctrl, 4,
        (_T("\tPCcvs -\tfindfirst count = %d\n"), findfirst_count));
    TRACE_PRINTF(TC_partctrl, 4,
        (_T("\tPCcvs -\tfindnext count = %d\n"), findnext_count));
    TRACE_PRINTF(TC_partctrl, 4,
        (_T("\tPCcvs -\tcount of files enqueued = %d\n"),
        *count_of_files_enqueued));
    return true;
}

void
PartitionController::update_peak_finder(
    ReadType read_type,
    DWORD read_time,
    DWORD read_ops)
{
    ASSERT(this != 0);
    unsigned int invokation_time = GET_TICK_COUNT();
    TRACE_PRINTF(TC_partctrl, 3, (_T("time: %d\n"), invokation_time));
    TRACE_PRINTF(TC_partctrl, 3,
        (_T("\tPCupf -\tupdating peak finder for drive %s\n"),
        sis_drives.partition_mount_name(partition_index)));
    ASSERT(read_type == RT_hash || read_type == RT_compare);
    ASSERT(signed(read_time) >= 0);
    ASSERT(signed(read_ops) >= 0);
    if (read_ops > 0)
    {
        double time_per_read = double(read_time)/double(read_ops);
        ASSERT(time_per_read >= 0.0);
        TRACE_PRINTF(TC_partctrl, 4, (_T("\tPCupf -\ttime per %s read = %f\n"),
            (read_type == RT_hash ? _T("hash") : _T("compare")),
            time_per_read));
        read_mean_comparator.sample(read_type, time_per_read);
        ASSERT(read_peak_finder[read_type] != 0);
        ASSERT(read_time_filter[read_type] != 0);
        ASSERT(read_time_estimate[read_type] != 0);
        ASSERT(read_time_confidence != 0);
        if (ok_to_record_measurement ||
            signed(invokation_time - next_untrusted_measurement_time) >= 0)
        {
            TRACE_PRINTF(TC_partctrl, 2,
                (_T("\tPCupf -\trecording %s measurement for drive %s\n"),
                (read_type == RT_hash ? _T("hash") : _T("compare")),
                sis_drives.partition_mount_name(partition_index)));
            read_peak_finder[read_type]->sample(time_per_read, read_ops);
            ASSERT(untrusted_measurement_interval > 0);
            ok_to_record_measurement = true;
            next_untrusted_measurement_time =
                invokation_time + untrusted_measurement_interval;
            TRACE_PRINTF(TC_partctrl, 5,
                (_T("\tPCupf -\tnext untrusted measurement time = %d\n"),
                next_untrusted_measurement_time));
        }
        if (read_peak_finder[read_type]->found())
        {
            double peak = read_peak_finder[read_type]->median();
            TRACE_PRINTF(TC_partctrl, 1,
                (_T("\tPCupf -\t%s read peak found: %f\n"),
                (read_type == RT_hash ? _T("hash") : _T("compare")), peak));
            if (peak > 0.0)
            {
                read_time_filter[read_type]->update_value(peak);
            }
            else
            {
                PRINT_DEBUG_MSG((_T("GROVELER: update_peak_finder() peak finder returned peak of zero\n")));
            }
            read_peak_finder[read_type]->reset();
            *read_time_estimate[read_type] =
                read_time_filter[read_type]->retrieve_value();
            ASSERT(*read_time_estimate[read_type] > 0.0);
            TRACE_PRINTF(TC_partctrl, 2,
                (_T("\tPCupf -\t%s read time estimate = %f\n"),
                (read_type == RT_hash ? _T("hash") : _T("compare")),
                *read_time_estimate[read_type]));
            double sample_peak_ratio = *read_time_estimate[read_type] / peak;
            double sample_read_time_confidence =
                (sample_peak_ratio + peak_finder_accuracy - 1.0) /
                peak_finder_accuracy;
            TRACE_PRINTF(TC_partctrl, 4,
                (_T("\tPCupf -\tsample read time confidence = %f\n"),
                sample_read_time_confidence));
            read_time_confidence_estimator.update(read_type,
                sample_read_time_confidence);
            *read_time_confidence = read_time_confidence_estimator.confidence();
            ASSERT(*read_time_confidence >= 0.0);
            ASSERT(*read_time_confidence <= 1.0);
            TRACE_PRINTF(TC_partctrl, 2,
                (_T("\tPCupf -\tread time confidence = %f\n"),
                *read_time_confidence));
            calculate_effective_max_grovel_interval();
            ASSERT(effective_max_grovel_interval > 0);
            ASSERT(effective_max_grovel_interval <= max_grovel_interval);
        }
    }
}

void
PartitionController::calculate_effective_max_grovel_interval()
{
    ASSERT(this != 0);
    ASSERT(read_time_confidence != 0);
    ASSERT(*read_time_confidence >= 0.0);
    ASSERT(*read_time_confidence <= 1.0);
    TRACE_PRINTF(TC_partctrl, 4,
        (_T("\tPCcemgi -\tread time confidence = %f\n"),
        *read_time_confidence));
    TRACE_PRINTF(TC_partctrl, 5,
        (_T("\tPCcemgi -\tfree space ratio = %f\n"), free_space_ratio));
    double log_untrusted_measurement_interval = log_max_grovel_interval -
        (1.0 - *read_time_confidence) * log_low_confidence_slope;
    untrusted_measurement_interval =
        int(exp(log_untrusted_measurement_interval));
    ASSERT(untrusted_measurement_interval > 0);
    TRACE_PRINTF(TC_partctrl, 5,
        (_T("\tPCcemgi -\tuntrusted measurement interval = %d\n"),
        untrusted_measurement_interval));
    int low_disk_space_interval = max_grovel_interval -
        int(free_space_ratio * low_disk_space_slope);
    ASSERT(low_disk_space_interval > 0);
    effective_max_grovel_interval =
        __min(untrusted_measurement_interval, low_disk_space_interval);
    ASSERT(effective_max_grovel_interval > 0);
    ASSERT(effective_max_grovel_interval <= max_grovel_interval);
    TRACE_PRINTF(TC_partctrl, 5,
        (_T("\tPCcemgi -\teffective max grovel interval = %d\n"),
        effective_max_grovel_interval));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\pathlist.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pathlist.h

Abstract:

	SIS Groveler path list headers

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_PATHLIST

#define _INC_PATHLIST

struct PathList
{
	PathList();
	~PathList();

	int *num_paths;
	const _TCHAR ***paths;

private:

	int num_partitions;
	BYTE *buffer;
	_TCHAR **partition_buffers;
};

#endif	/* _INC_PATHLIST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\pathlist.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pathlist.cpp

Abstract:

    SIS Groveler path list manager

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

static const _TCHAR *paths_ini_filename = _T("grovel.ini");
static const _TCHAR *paths_ini_section = _T("Excluded Paths");

static const _TCHAR *excluded_paths_path =
    _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Groveler\\Excluded Paths");

static const int default_excluded_path_count = 1;

static _TCHAR *default_path_tags[default_excluded_path_count] =
{
    _T("System Volume Information directory")
};

static _TCHAR *default_excluded_paths[default_excluded_path_count] =
{
    _T("\\System Volume Information")
};

PathList::PathList()
{
    ASSERT(this != 0);
    paths = 0;
    buffer = 0;
    num_partitions = sis_drives.partition_count();
    num_paths = new int[num_partitions];
    paths = new const _TCHAR **[num_partitions];
    partition_buffers = new _TCHAR *[num_partitions];
    for (int part_num = 0; part_num < num_partitions; part_num++)
    {
        num_paths[part_num] = 1;
        paths[part_num] = 0;
        partition_buffers[part_num] = 0;
    }
    int num_strings;
    _TCHAR **strings = 0;
    bool ok = Registry::read_string_set(HKEY_LOCAL_MACHINE,
        excluded_paths_path, &num_strings, &strings, &buffer);
    if (!ok)
    {
        Registry::write_string_set(HKEY_LOCAL_MACHINE, excluded_paths_path,
            default_excluded_path_count, default_excluded_paths,
            default_path_tags);
        num_strings = default_excluded_path_count;
        strings = default_excluded_paths;
        buffer = 0;
    }
    ASSERT(num_strings >= 0);
    ASSERT(strings != 0);

    int bLen = SIS_CSDIR_STRING_NCHARS + _tcslen(paths_ini_filename) + MAX_PATH;
    _TCHAR *ini_file_partition_path = new _TCHAR[bLen];

    int *num_partition_strings = new int[num_partitions];
    _TCHAR ***partition_strings = new _TCHAR **[num_partitions];

    for (part_num = 0; part_num < num_partitions; part_num++)
    {
        partition_strings[part_num] = NULL;

        //
        //  Construct the string
        //

        (void)StringCchCopy(ini_file_partition_path, bLen,
                      sis_drives.partition_guid_name(part_num));
        TrimTrailingChar(ini_file_partition_path,L'\\');
        (void)StringCchCat(ini_file_partition_path, bLen, SIS_CSDIR_STRING);
        (void)StringCchCat(ini_file_partition_path, bLen, paths_ini_filename);

        IniFile::read_string_set(ini_file_partition_path, paths_ini_section,
            &num_partition_strings[part_num], &partition_strings[part_num],
            &partition_buffers[part_num]);
        ASSERT(num_partition_strings[part_num] >= 0);
        ASSERT(num_partition_strings[part_num] == 0
            || partition_strings[part_num] != 0);
    }
    delete[] ini_file_partition_path;
    ini_file_partition_path = 0;

    for (part_num = 0; part_num < num_partitions; part_num++)
    {
        paths[part_num] = new const _TCHAR *[num_strings
            + num_partition_strings[part_num] + 1];
        paths[part_num][0] = SIS_CSDIR_STRING;
        for (int index = 0; index < num_strings; index++)
        {
            paths[part_num][num_paths[part_num]] = strings[index];
            num_paths[part_num]++;
        }
        int num_part_strings = num_partition_strings[part_num];
        _TCHAR **part_strings = partition_strings[part_num];
        for (index = 0; index < num_part_strings; index++)
        {
            paths[part_num][num_paths[part_num]] = part_strings[index];
            num_paths[part_num]++;
        }
        if (partition_strings[part_num] != 0)
        {
            delete[] partition_strings[part_num];
            partition_strings[part_num] = 0;
        }
    }
    ASSERT(num_partition_strings != 0);
    delete[] num_partition_strings;
    num_partition_strings = 0;
    ASSERT(partition_strings != 0);
    delete[] partition_strings;
    partition_strings = 0;

    if (buffer != 0)
    {
        ASSERT(strings != 0);
        ASSERT(strings != default_excluded_paths);
        delete[] strings;
        strings = 0;
    }
}

PathList::~PathList()
{
    ASSERT(this != 0);
    ASSERT(num_paths != 0);
    ASSERT(paths != 0);
    ASSERT(partition_buffers != 0);
    ASSERT(num_partitions > 0);
    for (int part_num = 0; part_num < num_partitions; part_num++)
    {
        ASSERT(paths[part_num] != 0);
        delete[] paths[part_num];
        paths[part_num] = 0;
        if (partition_buffers[part_num] != 0)
        {
            delete[] partition_buffers[part_num];
            partition_buffers[part_num] = 0;
        }
    }
    delete[] paths;
    paths = 0;
    delete[] partition_buffers;
    partition_buffers = 0;
    if (buffer != 0)
    {
        delete[] buffer;
        buffer = 0;
    }
    ASSERT(num_paths != 0);
    delete[] num_paths;
    num_paths = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\peakfind.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    peakfind.cpp

Abstract:

    SIS Groveler peak finder

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

PeakFinder::PeakFinder(
    double accuracy,
    double range)
{
    ASSERT(this != 0);
    ASSERT(accuracy > 0.0);
    ASSERT(accuracy < 1.0);
    ASSERT(range > 0.0);
    base = 1.0 + 2.0 * accuracy / (1.0 - accuracy);
    ASSERT(base >= 1.0);
    multiplier = 1.0 / log(base);
    num_bins = int(multiplier * log(range)) + 1;
    ASSERT(num_bins > 0);
    bins = new int[num_bins];
    target_sample_size = int(1.0 / (accuracy * accuracy));
    ASSERT(target_sample_size > 0);
    reset();
    ASSERT(floor_value >= 0.0);
    ASSERT(sample_size >= 0);
    ASSERT(total_weight >= 0);
}

PeakFinder::~PeakFinder()
{
    ASSERT(this != 0);
    ASSERT(num_bins > 0);
    ASSERT(bins != 0);
    ASSERT(base >= 1.0);
    ASSERT(target_sample_size > 0);
    ASSERT(floor_value >= 0.0);
    ASSERT(sample_size >= 0);
    ASSERT(total_weight >= 0);
    delete[] bins;
    bins = 0;
}

void
PeakFinder::reset()
{
    ASSERT(this != 0);
    ASSERT(num_bins > 0);
    ASSERT(bins != 0);
    ASSERT(base >= 1.0);
    ASSERT(target_sample_size > 0);
    floor_exp = int(multiplier * log(DBL_MAX));
    floor_value = pow(base, floor_exp);
    ASSERT(floor_value >= 0.0);
    sample_size = 0;
    total_weight = 0;
}

void
PeakFinder::sample(
    double value,
    int weight)
{
    ASSERT(this != 0);
    ASSERT(num_bins > 0);
    ASSERT(bins != 0);
    ASSERT(base >= 1.0);
    ASSERT(target_sample_size > 0);
    ASSERT(floor_value >= 0.0);
    ASSERT(sample_size >= 0);
    ASSERT(total_weight >= 0);
    ASSERT(value >= 0);
    ASSERT(weight > 0);
    if (value <= 0.0)
    {
        return;
    }
    if (value < floor_value)
    {
        int new_exp = int(multiplier * log(value));
        double new_floor = pow(base, new_exp);
        int shift = __min(floor_exp - new_exp, num_bins);
        for (int index = num_bins - shift - 1; index >= 0; index--)
        {
            bins[index + shift] = bins[index];
        }
        for (index = 0; index < shift; index++)
        {
            bins[index] = 0;
        }
        floor_exp = new_exp;
        floor_value = new_floor;
    }
    int bin_index = __max(int(multiplier * log(value / floor_value)), 0);
    if (bin_index < num_bins)
    {
        bins[bin_index] += weight;
    }
    ASSERT(total_weight >= 0);
    total_weight += weight;
    sample_size++;
}

bool
PeakFinder::found() const
{
    ASSERT(this != 0);
    ASSERT(num_bins > 0);
    ASSERT(bins != 0);
    ASSERT(base >= 1.0);
    ASSERT(target_sample_size > 0);
    ASSERT(floor_value >= 0.0);
    ASSERT(sample_size >= 0);
    ASSERT(total_weight >= 0);
    return sample_size > target_sample_size;
}

double
PeakFinder::mode() const
{
    ASSERT(this != 0);
    ASSERT(num_bins > 0);
    ASSERT(bins != 0);
    ASSERT(base >= 1.0);
    ASSERT(target_sample_size > 0);
    ASSERT(floor_value >= 0.0);
    ASSERT(sample_size >= 0);
    ASSERT(total_weight >= 0);
    double bin_width = base - 1.0;
    int max_index = -1;
    double max_height = 0.0;
    for (int index = 0; index < num_bins; index++)
    {
        double height = double(bins[index]) / bin_width;
        if (height > max_height)
        {
            max_index = index;
            max_height = height;
        }
        bin_width *= base;
    }
    if (max_index < 0)
    {
        return 0.0;
    }
    else
    {
        return 2 * base / (base + 1.0) * floor_value * pow(base, max_index);
    }
}

double
PeakFinder::median() const
{
    ASSERT(this != 0);
    ASSERT(num_bins > 0);
    ASSERT(bins != 0);
    ASSERT(base >= 1.0);
    ASSERT(target_sample_size > 0);
    ASSERT(floor_value >= 0.0);
    ASSERT(sample_size >= 0);
    ASSERT(total_weight >= 0);
    double remaining_weight = 0.5 * double(total_weight);
    for (int index = 0; index < num_bins; index++)
    {
        double current_weight = double(bins[index]);
        if (current_weight > remaining_weight)
        {
            return (1.0 + remaining_weight * (base - 1.0) / current_weight)
                * floor_value * pow(base, index);
        }
        remaining_weight -= current_weight;
    }
    return 0.0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\perfctrs.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    perfctrs.h

Abstract:

	SIS Groveler performance counters header

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_PERFCTRS

#define _INC_PERFCTRS

#define WIN32_LEAN_AND_MEAN 1

const int num_languages = 1;

struct CounterText
{
	_TCHAR *counter_name;
	_TCHAR *counter_help;
};

struct ObjectInformation
{
	unsigned int detail_level;
	CounterText text[num_languages];
};

struct CounterInformation
{
	SharedDataField source;
	unsigned int counter_type;
	unsigned int detail_level;
	CounterText text[num_languages];
};

const int num_perf_counters = 15;

extern const _TCHAR *language_codes[num_languages];

extern ObjectInformation object_info;

extern CounterInformation counter_info[num_perf_counters];

#endif	/* _INC_PERFCTRS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\peakfind.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    peakfind.h

Abstract:

	SIS Groveler peak finder headers

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_PEAKFIND

#define _INC_PEAKFIND

class PeakFinder
{
public:

	PeakFinder(
		double accuracy,
		double range);

	~PeakFinder();

	void reset();

	void sample(
		double value,
		int weight);

	bool found() const;

	double mode() const;

	double median() const;

private:

	int num_bins;
	int *bins;
	double base;
	double multiplier;
	int floor_exp;
	double floor_value;
	int target_sample_size;
	int sample_size;
	int total_weight;
};

#endif	/* _INC_PEAKFIND */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\perfctrs.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    perfctrs.cpp

Abstract:

    SIS Groveler performance counters

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

const _TCHAR *language_codes[num_languages] = {_T("009")};

extern ObjectInformation object_info =
{
    PERF_DETAIL_NOVICE,
    {
        {_T("Groveler"), _T("Single-Instance Store Groveler for one file system partition")}
    }
};

CounterInformation counter_info[num_perf_counters] =
{
    {
        SDF_grovel_time,
        PERF_100NSEC_TIMER,
        PERF_DETAIL_NOVICE,
        {
            {_T("% Time Groveling"), _T("Percentage of elapsed time spent groveling this partition")}
        }
    },
    {
        SDF_volscan_time,
        PERF_100NSEC_TIMER,
        PERF_DETAIL_NOVICE,
        {
            {_T("% Time Scanning Volume"), _T("Percentage of elapsed time spent scanning this partition volume")}
        }
    },
    {
        SDF_extract_time,
        PERF_100NSEC_TIMER,
        PERF_DETAIL_NOVICE,
        {
            {_T("% Time Extracting Log"), _T("Percentage of elapsed time spent extracting entries from the USN log of this partition")}
        }
    },
    {
        SDF_working_time,
        PERF_100NSEC_TIMER,
        PERF_DETAIL_NOVICE,
        {
            {_T("% Time Working"), _T("Percentage of elapsed time spent performing work on this partition (sum of % Time Groveling, % Time Scanning Volume, and % Time Extracting Log)")}
        }
    },
    {
        SDF_files_hashed,
        PERF_COUNTER_BULK_COUNT,
        PERF_DETAIL_NOVICE,
        {
            {_T("Files Hashed"), _T("Count of files on this partition whose hash values have been computed")}
        }
    },
    {
        SDF_files_compared,
        PERF_COUNTER_BULK_COUNT,
        PERF_DETAIL_NOVICE,
        {
            {_T("Files Compared"), _T("Count of files on this partition that have been compared against other files")}
        }
    },
    {
        SDF_files_merged,
        PERF_COUNTER_BULK_COUNT,
        PERF_DETAIL_NOVICE,
        {
            {_T("Files Merged"), _T("Count of files on this partition that have been merged with other files")}
        }
    },
    {
        SDF_files_scanned,
        PERF_COUNTER_BULK_COUNT,
        PERF_DETAIL_NOVICE,
        {
            {_T("Files Scanned"), _T("Count of files and directories on this partition that have been scanned")}
        }
    },
    {
        SDF_queue_length,
        PERF_COUNTER_LARGE_RAWCOUNT,
        PERF_DETAIL_NOVICE,
        {
            {_T("Queue Length"), _T("Count of files waiting in queue to be hashed")}
        }
    },
    {
        SDF_hash_read_time,
        PERF_AVERAGE_BULK,
        PERF_DETAIL_ADVANCED,
        {
            {_T("Measured Hash Read Time"), _T("Measured time to perform disk read for hash computation")}
        }
    },
    {
        SDF_hash_read_ops,
        PERF_AVERAGE_BASE,
        PERF_DETAIL_ADVANCED,
        {
            {_T(""), _T("")}
        }
    },
    {
        SDF_compare_read_time,
        PERF_AVERAGE_BULK,
        PERF_DETAIL_ADVANCED,
        {
            {_T("Measured Compare Read Time"), _T("Measured time to perform disk read for file comparison")}
        }
    },
    {
        SDF_compare_read_ops,
        PERF_AVERAGE_BASE,
        PERF_DETAIL_ADVANCED,
        {
            {_T(""), _T("")}
        }
    },
    {
        SDF_hash_read_estimate,
        PERF_COUNTER_LARGE_RAWCOUNT,
        PERF_DETAIL_ADVANCED,
        {
            {_T("Estimated Hash Read Time"), _T("Estimated time to perform disk read for hash computation")}
        }
    },
    {
        SDF_compare_read_estimate,
        PERF_COUNTER_LARGE_RAWCOUNT,
        PERF_DETAIL_ADVANCED,
        {
            {_T("Estimated Compare Read Time"), _T("Estimated time to perform disk read for file comparison")}
        }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\registry.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    registry.h

Abstract:

	SIS Groveler registry interface headers

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_REGISTRY

#define _INC_REGISTRY

#ifndef _DEF_ENTRY_INFO
#define _DEF_ENTRY_INFO

enum EntryType
{
	entry_bool,
	entry_char,
	entry_int,
	entry_int64,
	entry_double
};

struct EntrySpec
{
	const _TCHAR *identifier;
	EntryType type;
	const _TCHAR *default_value;
	void *pointer;
};

#endif	/* _DEF_ENTRY_INFO */

class Registry
{
public:

	static bool read(
		HKEY base_key,
		const _TCHAR *path,
		int num_entries,
		EntrySpec *entries);

	static bool write(
		HKEY base_key,
		const _TCHAR *path,
		int num_entries,
		EntrySpec *entries);

	static bool overwrite(
		HKEY base_key,
		const _TCHAR *path,
		int num_entries,
		EntrySpec *entries);

	static bool write_defaults(
		HKEY base_key,
		const _TCHAR *path,
		int num_entries,
		EntrySpec *entries);

	static bool overwrite_defaults(
		HKEY base_key,
		const _TCHAR *path,
		int num_entries,
		EntrySpec *entries);

	static bool read_string_set(
		HKEY base_key,
		const _TCHAR *path,
		int *num_strings,
		_TCHAR ***strings,
		BYTE **buffer);

	static bool write_string_set(
		HKEY base_key,
		const _TCHAR *path,
		int num_strings,
		_TCHAR **strings,
		_TCHAR **identifiers);

	static bool overwrite_string_set(
		HKEY base_key,
		const _TCHAR *path,
		int num_strings,
		_TCHAR **strings,
		_TCHAR **identifiers);

	static void create_key_ex(
		HKEY hKey,
		LPCTSTR lpSubKey,
		DWORD Reserved,
		LPTSTR lpClass,
		DWORD dwOptions,
		REGSAM samDesired,
		LPSECURITY_ATTRIBUTES lpSecurityAttributes,
		PHKEY phkResult,
		LPDWORD lpdwDisposition);

	static void open_key_ex(
		HKEY hKey,
		LPCTSTR lpSubKey,
		DWORD ulOptions,
		REGSAM samDesired,
		PHKEY phkResult);

	static void close_key(
		HKEY hKey);

	static void query_value_ex(
		HKEY hKey,
		LPCTSTR lpValueName,
		LPDWORD lpReserved,
		LPDWORD lpType,
		LPBYTE lpData,
		LPDWORD lpcbData);

	static void set_value_ex(
		HKEY hKey,
		LPCTSTR lpValueName,
		DWORD Reserved,
		DWORD dwType,
		CONST BYTE *lpData,
		DWORD cbData);

private:

	enum {id_buffer_length = 256};

	static void load_string_into_value(
		EntryType type,
		const _TCHAR *string,
		void *value);

	static void store_value_in_string(
		EntryType type,
		void *value,
		_TCHAR *string,
		int stringLen); //in bytes

	Registry() {}
	~Registry() {}

};

#endif	/* _INC_REGISTRY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\registry.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

    SIS Groveler/registry interface

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

bool
Registry::read(
    HKEY base_key,
    const _TCHAR *path,
    int num_entries,
    EntrySpec *entries)
{
    WCHAR id_buffer[id_buffer_length];

    ASSERT(base_key == HKEY_CLASSES_ROOT
        || base_key == HKEY_CURRENT_CONFIG
        || base_key == HKEY_CURRENT_USER
        || base_key == HKEY_LOCAL_MACHINE
        || base_key == HKEY_USERS);
    ASSERT(path != 0);
    ASSERT(num_entries > 0);
    ASSERT(entries != 0);
    for (int index = 0; index < num_entries; index++)
    {
        load_string_into_value(entries[index].type,
            entries[index].default_value, entries[index].pointer);
    }
    HKEY path_key;
    long result = RegOpenKeyEx(base_key, path, 0, KEY_ALL_ACCESS, &path_key);
    if (result != ERROR_SUCCESS)
    {
        return false;
    }
    ASSERT(path_key != 0);
    for (index = 0; index < num_entries; index++)
    {
        DWORD data_type;
        DWORD data_length = id_buffer_length;
        result = RegQueryValueEx(path_key, entries[index].identifier, 0,
            &data_type, (BYTE *)id_buffer, &data_length);
        if (result == ERROR_SUCCESS && data_type == REG_SZ)
        {
            load_string_into_value(entries[index].type, id_buffer,
                entries[index].pointer);
        }
    }
    ASSERT(path_key != 0);
    RegCloseKey(path_key);
    path_key = 0;
    return true;
}

bool
Registry::write(
    HKEY base_key,
    const _TCHAR *path,
    int num_entries,
    EntrySpec *entries)
{
    WCHAR id_buffer[id_buffer_length];

    ASSERT(base_key == HKEY_CLASSES_ROOT
        || base_key == HKEY_CURRENT_CONFIG
        || base_key == HKEY_CURRENT_USER
        || base_key == HKEY_LOCAL_MACHINE
        || base_key == HKEY_USERS);
    ASSERT(path != 0);
    ASSERT(num_entries > 0);
    ASSERT(entries != 0);
    HKEY path_key;
    DWORD disposition;
    long result = RegCreateKeyEx(base_key, path, 0, 0, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 0, &path_key, &disposition);
    if (result != ERROR_SUCCESS)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: RegCreateKeyEx() failed with error %d\n"),
            result));
        return false;
    }
    ASSERT(path_key != 0);
    for (int index = 0; index < num_entries; index++)
    {
        DWORD data_type;
        DWORD data_length = id_buffer_length;
        result = RegQueryValueEx(path_key, entries[index].identifier, 0,
            &data_type, (BYTE *)id_buffer, &data_length);
        if (result != ERROR_SUCCESS || data_type != REG_SZ)
        {
            store_value_in_string(entries[index].type, entries[index].pointer,
                id_buffer,sizeof(id_buffer));
            result =
                RegSetValueEx(path_key, entries[index].identifier, 0, REG_SZ,
                (BYTE *)id_buffer, (_tcslen(id_buffer) + 1) * sizeof(_TCHAR));

            if (result != ERROR_SUCCESS)
            {
                PRINT_DEBUG_MSG((_T("GROVELER: RegSetValueEx() failed with error %d\n"),
                    result));
            }
        }
    }
    ASSERT(path_key != 0);
    RegCloseKey(path_key);
    path_key = 0;
    return true;
}

bool
Registry::overwrite(
    HKEY base_key,
    const _TCHAR *path,
    int num_entries,
    EntrySpec *entries)
{
    WCHAR id_buffer[id_buffer_length];

    ASSERT(base_key == HKEY_CLASSES_ROOT
        || base_key == HKEY_CURRENT_CONFIG
        || base_key == HKEY_CURRENT_USER
        || base_key == HKEY_LOCAL_MACHINE
        || base_key == HKEY_USERS);
    ASSERT(path != 0);
    ASSERT(num_entries > 0);
    ASSERT(entries != 0);
    HKEY path_key;
    DWORD disposition;
    long result = RegCreateKeyEx(base_key, path, 0, 0, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 0, &path_key, &disposition);
    if (result != ERROR_SUCCESS)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: RegCreateKeyEx() failed with error %d\n"),
            result));
        return false;
    }
    ASSERT(path_key != 0);
    for (int index = 0; index < num_entries; index++)
    {
        store_value_in_string(entries[index].type, entries[index].pointer,
            id_buffer,sizeof(id_buffer));
        result =
            RegSetValueEx(path_key, entries[index].identifier, 0, REG_SZ,
            (BYTE *)id_buffer, (_tcslen(id_buffer) + 1) * sizeof(_TCHAR));
        if (result != ERROR_SUCCESS)
        {
            PRINT_DEBUG_MSG((_T("GROVELER: RegSetValueEx() failed with error %d\n"),
                result));
        }
    }
    ASSERT(path_key != 0);
    RegCloseKey(path_key);
    path_key = 0;
    return true;
}

bool
Registry::write_defaults(
    HKEY base_key,
    const _TCHAR *path,
    int num_entries,
    EntrySpec *entries)
{
    WCHAR id_buffer[id_buffer_length];

    ASSERT(base_key == HKEY_CLASSES_ROOT
        || base_key == HKEY_CURRENT_CONFIG
        || base_key == HKEY_CURRENT_USER
        || base_key == HKEY_LOCAL_MACHINE
        || base_key == HKEY_USERS);
    ASSERT(path != 0);
    ASSERT(num_entries > 0);
    ASSERT(entries != 0);
    HKEY path_key;
    DWORD disposition;
    long result = RegCreateKeyEx(base_key, path, 0, 0, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 0, &path_key, &disposition);
    if (result != ERROR_SUCCESS)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: RegCreateKeyEx() failed with error %d\n"),
            result));
        return false;
    }
    ASSERT(path_key != 0);
    for (int index = 0; index < num_entries; index++)
    {
        DWORD data_type;
        DWORD data_length = id_buffer_length;
        result = RegQueryValueEx(path_key, entries[index].identifier, 0,
            &data_type, (BYTE *)id_buffer, &data_length);
        if (result != ERROR_SUCCESS)
        {
            result = RegSetValueEx(path_key, entries[index].identifier, 0,
                REG_SZ, (BYTE *)entries[index].default_value,
                (_tcslen(entries[index].default_value) + 1) * sizeof(_TCHAR));
            if (result != ERROR_SUCCESS)
            {
                PRINT_DEBUG_MSG((_T("GROVELER: RegSetValueEx() failed with error %d\n"),
                    result));
            }
        }
    }
    ASSERT(path_key != 0);
    RegCloseKey(path_key);
    path_key = 0;
    return true;
}

bool
Registry::overwrite_defaults(
    HKEY base_key,
    const _TCHAR *path,
    int num_entries,
    EntrySpec *entries)
{
    ASSERT(base_key == HKEY_CLASSES_ROOT
        || base_key == HKEY_CURRENT_CONFIG
        || base_key == HKEY_CURRENT_USER
        || base_key == HKEY_LOCAL_MACHINE
        || base_key == HKEY_USERS);
    ASSERT(path != 0);
    ASSERT(num_entries > 0);
    ASSERT(entries != 0);
    HKEY path_key;
    DWORD disposition;
    long result = RegCreateKeyEx(base_key, path, 0, 0, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 0, &path_key, &disposition);
    if (result != ERROR_SUCCESS)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: RegCreateKeyEx() failed with error %d\n"),
            result));
        return false;
    }
    ASSERT(path_key != 0);
    for (int index = 0; index < num_entries; index++)
    {
        result = RegSetValueEx(path_key, entries[index].identifier, 0, REG_SZ,
            (BYTE *)entries[index].default_value,
            (_tcslen(entries[index].default_value) + 1) * sizeof(_TCHAR));
        if (result != ERROR_SUCCESS)
        {
            PRINT_DEBUG_MSG((_T("GROVELER: RegSetValueEx() failed with error %d\n"),
                result));
        }
    }
    ASSERT(path_key != 0);
    RegCloseKey(path_key);
    path_key = 0;
    return true;
}

bool
Registry::read_string_set(
    HKEY base_key,
    const _TCHAR *path,
    int *num_strings,
    _TCHAR ***strings,
    BYTE **buffer)
{
    ASSERT(base_key == HKEY_CLASSES_ROOT
        || base_key == HKEY_CURRENT_CONFIG
        || base_key == HKEY_CURRENT_USER
        || base_key == HKEY_LOCAL_MACHINE
        || base_key == HKEY_USERS);
    ASSERT(path != 0);
    ASSERT(num_strings != 0);
    ASSERT(strings != 0);
    ASSERT(buffer != 0);
    HKEY path_key;
    *num_strings = 0;
    *strings = 0;
    *buffer = 0;
    long result = RegOpenKeyEx(base_key, path, 0, KEY_ALL_ACCESS, &path_key);
    if (result != ERROR_SUCCESS)
    {
        return false;
    }
    unsigned long num_values;
    unsigned long max_value_length;
    unsigned long max_string_length;
    result = RegQueryInfoKey(path_key, 0, 0, 0, 0, 0, 0,
        &num_values, &max_value_length, &max_string_length, 0, 0);
    if (result != ERROR_SUCCESS || num_values == 0)
    {
        RegCloseKey(path_key);
        return true;
    }
    _TCHAR *value = new _TCHAR[max_value_length + 1];
    _TCHAR **string_set = new _TCHAR *[num_values];
    BYTE *string_buffer =
        new BYTE[num_values * max_string_length * sizeof(_TCHAR)];
    int string_index = 0;
    int buffer_offset = 0;
    for (unsigned int index = 0; index < num_values; index++)
    {
        DWORD value_length = max_value_length + 1;
        DWORD string_length = max_string_length;
        DWORD data_type;
        result = RegEnumValue(path_key, index, value, &value_length, 0,
            &data_type, &string_buffer[buffer_offset], &string_length);
        if (result == ERROR_SUCCESS && data_type == REG_SZ)
        {
            ASSERT(unsigned(string_index) < num_values);
            string_set[string_index] = (_TCHAR *)&string_buffer[buffer_offset];
            string_index++;
            buffer_offset += string_length;
        }
    }
    *num_strings = string_index;
    ASSERT(value != 0);
    delete[] value;
    value = 0;
    *strings = string_set;
    *buffer = string_buffer;

    ASSERT(path_key != 0);
    RegCloseKey(path_key);
    path_key = 0;
    return true;
}

bool
Registry::write_string_set(
    HKEY base_key,
    const _TCHAR *path,
    int num_strings,
    _TCHAR **strings,
    _TCHAR **identifiers)
{
    WCHAR id_buffer[id_buffer_length];

    ASSERT(base_key == HKEY_CLASSES_ROOT
        || base_key == HKEY_CURRENT_CONFIG
        || base_key == HKEY_CURRENT_USER
        || base_key == HKEY_LOCAL_MACHINE
        || base_key == HKEY_USERS);
    ASSERT(path != 0);
    ASSERT(num_strings > 0);
    ASSERT(strings != 0);
    ASSERT(identifiers != 0);
    HKEY path_key;
    DWORD disposition;
    long result = RegCreateKeyEx(base_key, path, 0, 0, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 0, &path_key, &disposition);
    if (result != ERROR_SUCCESS)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: RegCreateKeyEx() failed with error %d\n"),
            result));
        return false;
    }
    ASSERT(path_key != 0);
    for (int index = 0; index < num_strings; index++)
    {
        DWORD data_type;
        DWORD data_length = id_buffer_length;
        result = RegQueryValueEx(path_key, identifiers[index], 0,
            &data_type, (BYTE *)id_buffer, &data_length);
        if (result != ERROR_SUCCESS || data_type != REG_SZ)
        {
            result = RegSetValueEx(
                path_key, identifiers[index], 0, REG_SZ, (BYTE *)strings[index],
                (_tcslen(strings[index]) + 1) * sizeof(_TCHAR));
            if (result != ERROR_SUCCESS)
            {
                PRINT_DEBUG_MSG((_T("GROVELER: RegSetValueEx() failed with error %d\n"),
                    result));
            }
        }
    }
    ASSERT(path_key != 0);
    RegCloseKey(path_key);
    path_key = 0;
    return true;
}

bool
Registry::overwrite_string_set(
    HKEY base_key,
    const _TCHAR *path,
    int num_strings,
    _TCHAR **strings,
    _TCHAR **identifiers)
{
    ASSERT(base_key == HKEY_CLASSES_ROOT
        || base_key == HKEY_CURRENT_CONFIG
        || base_key == HKEY_CURRENT_USER
        || base_key == HKEY_LOCAL_MACHINE
        || base_key == HKEY_USERS);
    ASSERT(path != 0);
    ASSERT(num_strings > 0);
    ASSERT(strings != 0);
    ASSERT(identifiers != 0);
    HKEY path_key;
    DWORD disposition;
    long result = RegCreateKeyEx(base_key, path, 0, 0, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 0, &path_key, &disposition);
    if (result != ERROR_SUCCESS)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: RegCreateKeyEx() failed with error %d\n"),
            result));
        return false;
    }
    ASSERT(path_key != 0);
    for (int index = 0; index < num_strings; index++)
    {
        result = RegSetValueEx(
            path_key, identifiers[index], 0, REG_SZ, (BYTE *)strings[index],
            (_tcslen(strings[index]) + 1) * sizeof(_TCHAR));
        if (result != ERROR_SUCCESS)
        {
            PRINT_DEBUG_MSG((_T("GROVELER: RegSetValueEx() failed with error %d\n"),
                result));
        }
    }
    ASSERT(path_key != 0);
    RegCloseKey(path_key);
    path_key = 0;
    return true;
}

void
Registry::create_key_ex(
    HKEY hKey,
    LPCTSTR lpSubKey,
    DWORD Reserved,
    LPTSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition)
{
    DWORD result = RegCreateKeyEx(hKey, lpSubKey, Reserved, lpClass, dwOptions,
        samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
    if (result != ERROR_SUCCESS)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: RegCreateKeyEx() failed with error %d\n"),
            result));
        throw result;
    }
}

void
Registry::open_key_ex(
    HKEY hKey,
    LPCTSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult)
{
    DWORD result =
        RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);
    if (result != ERROR_SUCCESS)
    {
        throw result;
    }
}

void
Registry::close_key(
    HKEY hKey)
{
    DWORD result = RegCloseKey(hKey);
    if (result != ERROR_SUCCESS)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: RegCloseKey() failed with error %d\n"), result));
        throw result;
    }
}

void
Registry::query_value_ex(
    HKEY hKey,
    LPCTSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData)
{
    DWORD result = RegQueryValueEx(hKey, lpValueName,
        lpReserved, lpType, lpData, lpcbData);
    if (result != ERROR_SUCCESS)
    {
        throw result;
    }
}

void
Registry::set_value_ex(
    HKEY hKey,
    LPCTSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE *lpData,
    DWORD cbData)
{
    DWORD result =
        RegSetValueEx(hKey, lpValueName, Reserved, dwType, lpData, cbData);
    if (result != ERROR_SUCCESS)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: RegSetValueEx() failed with error %d\n"), result));
        throw result;
    }
}

void
Registry::load_string_into_value(
    EntryType type,
    const _TCHAR *string,
    void *value)
//
//  This routine can safely ignore if stscanf fails because a default value
//  has already been placed in value
//

{
    ASSERT(string != 0);
    ASSERT(value != 0);
    switch (type)
    {
    case entry_bool:
        *((bool *)value) = _ttoi(string) != 0;
        break;
    case entry_char:
        *((_TCHAR *)value) = string[0];
        break;
    case entry_int:
        (VOID)_stscanf(string, _T("%d"), (int *)value);
        break;
    case entry_int64:
        (VOID)_stscanf(string, _T("%I64d"), (__int64 *)value);
        break;
    case entry_double:
        (VOID)_stscanf(string, _T("%lf"), (double *)value);
        break;
    default:
        ASSERT(false);
    }
}

void
Registry::store_value_in_string(
    EntryType type,
    void *value,
    _TCHAR *string,
    int strSize)      //in bytes
{
    ASSERT(string != 0);
    ASSERT(value != 0);
    switch (type)
    {
    case entry_bool:
        (void)StringCbPrintf(string, strSize, *((bool *)value) ? _T("1") : _T("0"));
        break;
    case entry_char:
        (void)StringCbPrintf(string, strSize, _T("%c"), *((_TCHAR *)value));
        break;
    case entry_int:
        (void)StringCbPrintf(string, strSize, _T("%d"), *((int *)value));
        break;
    case entry_int64:
        (void)StringCbPrintf(string, strSize, _T("%I64d"), *((__int64 *)value));
        break;
    case entry_double:
        (void)StringCbPrintf(string, strSize, _T("%g"), *((double *)value));
        break;
    default:
        ASSERT(false);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\service.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    service.h

Abstract:

	SIS Groveler service headers

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_SERVICE

#define _INC_SERVICE

#if SERVICE

class Service
{
public:

	static int start();

	static void record_partition_indices();

	static void set_max_response_time(
		unsigned int max_response_time);

	static void checkpoint();

	static void report_start();

	static bool groveling_paused();

	static bool foreground_groveling();

	static void suspending_controller();

	static void suspending_exhorter();

	static bool partition_in_foreground(
		int partition_index);

	static void set_foreground_batch_in_progress(
		int partition_index,
		bool value);

	static void follow_command();

private:

	static void WINAPI control_handler(
		DWORD opcode);

	static void WINAPI service_main(
		DWORD argc,
		LPTSTR *argv);

	Service() {}
	~Service() {}

	enum {num_drive_letters = 26};

	static SERVICE_STATUS status;
	static SERVICE_STATUS_HANDLE status_handle;
	static int num_partitions;
	static int partition_indices[num_drive_letters];
	static unsigned int max_response_time;

	static volatile bool pause_commanded;
	static volatile bool grovel_paused;

	static volatile bool *full_volume_scan_commanded;

	static volatile bool *demarcate_foreground_batch;
	static volatile bool *foreground_batch_in_progress;
	static volatile bool *foreground_commanded;
	static volatile bool *foreground_acknowledged;
	static volatile int foreground_count;

	static volatile bool controller_suspended;
	static volatile bool exhorter_suspended;
};

#define SERVICE_RECORD_PARTITION_INDICES() Service::record_partition_indices();
#define SERVICE_SET_MAX_RESPONSE_TIME(time) Service::set_max_response_time(time);
#define SERVICE_CHECKPOINT() Service::checkpoint();
#define SERVICE_REPORT_START() Service::report_start();
#define SERVICE_GROVELING_PAUSED() Service::groveling_paused()
#define SERVICE_FOREGROUND_GROVELING() Service::foreground_groveling()
#define SERVICE_SUSPENDING_CONTROLLER() Service::suspending_controller()
#define SERVICE_SUSPENDING_EXHORTER() Service::suspending_exhorter()
#define SERVICE_PARTITION_IN_FOREGROUND(part_index) Service::partition_in_foreground(part_index)
#define SERVICE_SET_FOREGROUND_BATCH_IN_PROGRESS(part_index, value) Service::set_foreground_batch_in_progress(part_index, value)
#define SERVICE_FOLLOW_COMMAND() Service::follow_command()

#else // SERVICE

#define SERVICE_RECORD_PARTITION_INDICES()
#define SERVICE_SET_MAX_RESPONSE_TIME(time)
#define SERVICE_CHECKPOINT()
#define SERVICE_REPORT_START()
#define SERVICE_GROVELING_PAUSED() false
#define SERVICE_FOREGROUND_GROVELING() false
#define SERVICE_SUSPENDING_CONTROLLER()
#define SERVICE_SUSPENDING_EXHORTER()
#define SERVICE_PARTITION_IN_FOREGROUND(part_index) false
#define SERVICE_SET_FOREGROUND_BATCH_IN_PROGRESS(part_index, value)
#define SERVICE_FOLLOW_COMMAND()

#endif // SERVICE

#endif	/* _INC_SERVICE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\scan.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    scan.cpp

Abstract:

    SIS Groveler volume scanning function

Authors:

    Cedric Krumbein, 1998

Environment:

    User Mode

Revision History:

--*/

#include "all.hxx"

/*****************************************************************************/

// scan_volume() creates the initial queue for a volume.
// It enters every qualified file in the volume into the
// queue by doing a depth-first search of the directory tree.

enum DatabaseException {
    DATABASE_ERROR
};

GrovelStatus Groveler::scan_volume(
    IN  DWORD  time_allotted,
    IN  BOOL   start_over,
    OUT DWORD *time_consumed,
    OUT DWORD *findfirst_count,
    OUT DWORD *findnext_count,
    OUT DWORD *count_of_files_enqueued)
{
    SGNativeQueueEntry queueEntry;

    SGNativeStackEntry parentEntry,
                       subdirEntry;

    TFileName parentName,
              tempName;

    HANDLE dirHandle = NULL;

    WIN32_FIND_DATA findData;

    DWORD timeConsumed      = 0,
          findFirstCount    = 0,
          findNextCount     = 0,
          numQueueAdditions = 0,
          numActions        = 0;

    ULARGE_INTEGER fileSize,
                   createTime,
                   writeTime;

    LONG num;

    BOOL success;

    ASSERT(volumeHandle != NULL);
    ASSERT(sgDatabase   != NULL);
    ASSERT(databaseName != NULL);

#ifdef DEBUG_UNTHROTTLED
    timeAllotted = INFINITE;
#else
    timeAllotted = time_allotted;
#endif

    startAllottedTime = GetTickCount();

// If the start_over flag is set, delete the current database, then
// prepare for the new scan by pushing this volume's root onto the stack.

    try {

        if (start_over) {

// Sync up with the worker thread.  We don't want to delete the existing database
// (if one exists) while the worker thread is in the middle of an (suspended)
// operation.

            abortGroveling = TRUE;                      // also set TRUE in open()

            while (grovelStatus != Grovel_ok){
                DWORD tmpTimeAllotted = timeAllotted;

                timeAllotted = INFINITE;
                ASSERT(IsReset(grovelStartEvent));
                success = SetEvent(grovelStartEvent);
                ASSERT_ERROR(success);
                WaitForEvent(grovelStopEvent);
                timeAllotted = tmpTimeAllotted;
            }

            if (!CreateDatabase())
                return Grovel_error;

            inScan = TRUE;
            abortGroveling = FALSE;
        }

// The main loop for the scanning process. Pop a directory ID
// from the stack, open and scan it. Continue the loop until
// the time allotted is used up or the stack is empty.

        do {
            num = sgDatabase->StackGetTop(&parentEntry);
            if (num <  0)
                throw DATABASE_ERROR;

// If there are no more to-do entries in the stack,
// discard the completed entries and exit the loop.

            if (num == 0) {
                inScan = FALSE;
                num = sgDatabase->StackDelete(0);
                if (num < 0)
                    throw DATABASE_ERROR;
                timeConsumed = GetTickCount() - startAllottedTime;
                break;
            }

            ASSERT(num == 1);
            ASSERT(parentEntry.fileID != 0);
            ASSERT(parentEntry.order  >  0);

            if (!GetFileName(volumeHandle, parentEntry.fileID, &parentName)) {

                DPRINTF((_T("%s: can't get name for directory 0x%016I64x\n"),
                    driveName, parentEntry.fileID));

            } else if (IsAllowedName(parentName.name)) {
// Open the directory.

                ASSERT(dirHandle == NULL);

                tempName.assign(driveName);
                tempName.append(parentName.name);
                tempName.append(_T("\\*"));

                dirHandle = FindFirstFile(tempName.name, &findData);

                if (dirHandle == INVALID_HANDLE_VALUE) {

                    DPRINTF((_T("%s: can't read directory \"%s\": %lu\n"),
                        driveName, parentName.name, GetLastError()));
                    dirHandle = NULL;

                } else {

                    findFirstCount++;

// Scan the directory.

                    do {
                        findNextCount++;

// Push every subdirectory not already on the stack
// onto the stack. (extract_log() also adds directories
// to the stack as they are created, renamed, or moved.)

                        if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) {

                            if ((findData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&
                                (findData.dwReserved0 == IO_REPARSE_TAG_MOUNT_POINT))
                                continue;
                        
                            if (_tcscmp(findData.cFileName, _T("."))  == 0
                             || _tcscmp(findData.cFileName, _T("..")) == 0)
                                continue;

                            tempName.assign(driveName);
                            tempName.append(parentName.name);
                            tempName.append(_T("\\"));
                            tempName.append(findData.cFileName);

                            subdirEntry.fileID = GetFileID(NULL,tempName.name);
                            if (subdirEntry.fileID == 0) {
                                DPRINTF((_T("%s: can't get ID for directory \"%s\"\n"),
                                    driveName, tempName.name));
                                continue;
                            }

                            num = sgDatabase->StackGetFirstByFileID(&subdirEntry);
                            if (num < 0)
                                throw DATABASE_ERROR;
                            if (num > 0) {
                                ASSERT(num == 1);
                                continue;
                            }

                            if (numActions == 0) {
                                if (sgDatabase->BeginTransaction() < 0)
                                    throw DATABASE_ERROR;
                                numActions = 1;
                            }

                            num = sgDatabase->StackPut(subdirEntry.fileID, FALSE);
                            if (num < 0)
                                throw DATABASE_ERROR;
                            ASSERT(num == 1);
                            numActions++;
                        }

// Add every allowed file to the queue.

                        else {
                            fileSize.HighPart = findData.nFileSizeHigh;
                            fileSize.LowPart  = findData.nFileSizeLow;

                            if ((findData.dwFileAttributes & disallowedAttributes) == 0
                             &&  fileSize.QuadPart >= minFileSize) {

                                tempName.assign(parentName.name);
                                tempName.append(_T("\\"));
                                tempName.append(findData.cFileName);

                                if (IsAllowedName(tempName.name)) {

                                    queueEntry.fileID    = 0;
                                    queueEntry.parentID  = parentEntry.fileID;
                                    queueEntry.reason    = 0;
                                    queueEntry.fileName  = findData.cFileName;
                                    queueEntry.retryTime = 0;

                                    createTime.HighPart  = findData.ftCreationTime .dwHighDateTime;
                                    createTime.LowPart   = findData.ftCreationTime .dwLowDateTime;
                                    writeTime .HighPart  = findData.ftLastWriteTime.dwHighDateTime;
                                    writeTime .LowPart   = findData.ftLastWriteTime.dwLowDateTime;
                                    queueEntry.readyTime = (createTime.QuadPart > writeTime.QuadPart
                                                         ?  createTime.QuadPart : writeTime.QuadPart)
                                                          + minFileAge;

                                    if (numActions == 0) {
                                        if (sgDatabase->BeginTransaction() < 0)
                                            throw DATABASE_ERROR;
                                        numActions = 1;
                                    }

                                    num = sgDatabase->QueuePut(&queueEntry);
                                    if (num < 0)
                                        throw DATABASE_ERROR;
                                    ASSERT(num == 1);
                                    numQueueAdditions++;
                                    numActions++;
                                }
                            }
                        }

                        if (numActions >= MAX_ACTIONS_PER_TRANSACTION) {
                            if (!sgDatabase->CommitTransaction())
                                throw DATABASE_ERROR;
                            TPRINTF((_T("%s: committing %lu actions to \"%s\"\n"),
                                driveName, numActions, databaseName));
                            numActions = 0;
                        }
                    } while (FindNextFile(dirHandle, &findData));

// We've finished scanning this directory. Close the directory,
// move the stack entry from the to-do list to the completed
// list, and commit the changes to the stack and queue.

                    success = FindClose(dirHandle);
                    ASSERT(success);
                    dirHandle = NULL;
                }
            }

            if (numActions == 0) {
                if (sgDatabase->BeginTransaction() < 0)
                    throw DATABASE_ERROR;
                numActions = 1;
            }

            num = sgDatabase->StackDelete(parentEntry.order);
            if (num < 0)
                throw DATABASE_ERROR;
            ASSERT(num == 1);
            numActions++;

            num = sgDatabase->StackPut(parentEntry.fileID, TRUE);
            if (num < 0)
                throw DATABASE_ERROR;
            ASSERT(num == 1);
            numActions++;

            if (!sgDatabase->CommitTransaction())
                throw DATABASE_ERROR;
            TPRINTF((_T("%s: committing %lu actions to \"%s\"\n"),
                driveName, numActions, databaseName));
            numActions = 0;

// Continue scanning directories until the time
// allotted is used up or the stack is empty.

            timeConsumed = GetTickCount() - startAllottedTime;

        } while (timeConsumed < timeAllotted);
    }

// If a database error occured, close the directory and return an error status.

    catch (DatabaseException databaseException) {
        ASSERT(databaseException == DATABASE_ERROR);

        if (numActions > 0) {
            sgDatabase->AbortTransaction();
            numActions = 0;
        }

        if (dirHandle != NULL) {
            success = FindClose(dirHandle);
            ASSERT(success);
            dirHandle = NULL;
        }

        return Grovel_error;
    }

// Return the performance statistics.

    if (time_consumed           != NULL)
        *time_consumed           = timeConsumed;
    if (findfirst_count         != NULL)
        *findfirst_count         = findFirstCount;
    if (findnext_count          != NULL)
        *findnext_count          = findNextCount;
    if (count_of_files_enqueued != NULL)
        *count_of_files_enqueued = numQueueAdditions;

    TRACE_PRINTF(TC_scan, 2,
        (_T("%s: ScanTime=%lu.%03lu sec FindFirst=%lu FindNext=%lu FilesEnqueued=%lu%s\n"),
        driveName, timeConsumed / 1000, timeConsumed % 1000, findFirstCount,
        findNextCount, numQueueAdditions, inScan ? _T("") : _T(" DONE")));

    return inScan ? Grovel_pending : Grovel_ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\service.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    service.cpp

Abstract:

    SIS Groveler support for running as a system service

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

static _TCHAR *service_name = _T("Groveler");
static _TCHAR *service_path = _T("%SystemRoot%\\System32\\grovel.exe");

#if SERVICE

SERVICE_STATUS Service::status;
SERVICE_STATUS_HANDLE Service::status_handle = 0;
int Service::num_partitions = 0;
int Service::partition_indices[num_drive_letters];
unsigned int Service::max_response_time = 0;

volatile bool Service::pause_commanded = false;
volatile bool Service::grovel_paused = false;

volatile bool * Service::full_volume_scan_commanded;

volatile bool * Service::demarcate_foreground_batch;
volatile bool * Service::foreground_batch_in_progress;
volatile bool * Service::foreground_commanded;
volatile bool * Service::foreground_acknowledged;
volatile int Service::foreground_count = 0;

volatile bool Service::controller_suspended = false;
volatile bool Service::exhorter_suspended = true;

#endif // SERVICE

extern "C" __cdecl _tmain(int argc, _TCHAR **argv)
{

#if SERVICE

    return Service::start();

#else // SERVICE

    return _main(argc, argv);

#endif // SERVICE

}

#if SERVICE

int
Service::start()
{

#if DBG

    HKEY path_key;
    _TCHAR scm_path[1024];

    //
    //  See if the TYPE is interactive, if so then create a visible console
    //

    (void)StringCbPrintf(scm_path,sizeof(scm_path),
        L"SYSTEM\\CurrentControlSet\\Services\\%s", service_name);
    long result =
        RegOpenKeyEx(HKEY_LOCAL_MACHINE, scm_path, 0, KEY_READ, &path_key);
    if (result == ERROR_SUCCESS)
    {
        ASSERT(path_key != 0);
        DWORD service_type = 0;
        DWORD type_size = sizeof(DWORD);
        result = RegQueryValueEx(path_key, _T("Type"), 0, 0,
            (BYTE *)&service_type, &type_size);
        if (result == ERROR_SUCCESS)
        {
            ASSERT(type_size == sizeof(DWORD));
            if (service_type & SERVICE_INTERACTIVE_PROCESS)
            {
                FreeConsole();
                BOOL ok = AllocConsole();
                if (ok)
                {
                    //
                    //  fixup "stdout" to the new console
                    //

                    HANDLE out_fs_handle = GetStdHandle(STD_OUTPUT_HANDLE);
                    if (out_fs_handle != INVALID_HANDLE_VALUE)
                    {
                        int out_crt_handle =
                            _open_osfhandle((LONG_PTR)out_fs_handle, _O_TEXT);
                        if (out_crt_handle != -1)
                        {
                            //*stdout = *(_tfdopen(out_crt_handle, _T("w")));   //Fixing PREFIX bug
                            FILE *myStdout = _tfdopen(out_crt_handle, _T("w"));
                            if (myStdout != 0)
                            {
                                *stdout = *myStdout;
                                setvbuf(stdout, NULL, _IONBF, 0);
                            }
                            else
                            {
                                PRINT_DEBUG_MSG((_T("GROVELER: _tfdopen() failed\n")));
                            }
                        }
                        else
                        {
                            PRINT_DEBUG_MSG((_T("GROVELER: _open_osfhandle() failed\n")));
                        }
                    }
                    else
                    {
                        PRINT_DEBUG_MSG((_T("GROVELER: GetStdHandle() failed\n")));
                    }

                    //
                    //  fixup "stderr" to the new console
                    //

                    HANDLE err_fs_handle = GetStdHandle(STD_ERROR_HANDLE);
                    if (err_fs_handle != INVALID_HANDLE_VALUE)
                    {
                        int err_crt_handle =
                            _open_osfhandle((LONG_PTR)err_fs_handle, _O_TEXT);
                        if (err_crt_handle != -1)
                        {
                            //*stderr = *(_tfdopen(err_crt_handle, _T("w"))); //fixing PREFIX bug
                            FILE *myStderr = _tfdopen(err_crt_handle, _T("w"));
                            if (myStderr != 0)
                            {
                                *stderr = *myStderr;
                                setvbuf(stderr, NULL, _IONBF, 0);
                            }
                            else
                            {
                                PRINT_DEBUG_MSG((_T("GROVELER: _tfdopen() failed\n")));
                            }
                        }
                        else
                        {
                            PRINT_DEBUG_MSG((_T("GROVELER: _open_osfhandle() failed\n")));
                        }
                    }
                    else
                    {
                        PRINT_DEBUG_MSG((_T("GROVELER: GetStdHandle() failed\n")));
                    }
                }
                else
                {
                    DWORD err = GetLastError();
                    PRINT_DEBUG_MSG((_T("GROVELER: AllocConsole() failed with error %d\n"),
                        err));
                }
            }
        }
        else
        {
            PRINT_DEBUG_MSG((_T("GROVELER: RegQueryValueEx() failed with error %d\n"),
                result));
        }
        ASSERT(path_key != 0);
        RegCloseKey(path_key);
        path_key = 0;
    }
    else
    {
        PRINT_DEBUG_MSG((_T("GROVELER: RegOpenKeyEx() failed with error %d\n"), result));
    }

#endif

    static SERVICE_TABLE_ENTRY dispatch_table[] =
    {
        {service_name, service_main},
        {0, 0}
    };

    int ok = StartServiceCtrlDispatcher(dispatch_table);
    if (!ok)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: StartServiceCtrlDispatcher() failed with error %d\n"),
            err));
    }
    return !ok;
}

void
Service::record_partition_indices()
{
    //
    //  Get how many total partitions there are
    //

    num_partitions = sis_drives.partition_count();

    //
    //  Allocate structures based on the number of partitions
    //

    full_volume_scan_commanded = new bool[num_partitions];
    demarcate_foreground_batch = new bool[num_partitions];
    foreground_batch_in_progress = new bool[num_partitions];
    foreground_commanded = new bool[num_partitions];
    foreground_acknowledged = new bool[num_partitions];

    //
    //  Allocate those structures
    //

    for (int index = 0; index < num_partitions; index++)
    {
        full_volume_scan_commanded[index] = false;
        demarcate_foreground_batch[index] = false;
        foreground_batch_in_progress[index] = false;
        foreground_commanded[index] = false;
        foreground_acknowledged[index] = false;
    }

    //
    //  Initializes indexes for each "Drive Letter" partition
    //

    for (index = 0; index < num_drive_letters; index++)
    {
        partition_indices[index] = -1;
    }

    //
    //  This initilaizes an array that is indexed by drive letter
    //  that maps that drive letter to the internal order they are
    //  stored in.
    //

    int num_lettered_partitions = sis_drives.lettered_partition_count();
    for (index = 0; index < num_lettered_partitions; index++)
    {
        _TCHAR drive_letter = sis_drives.partition_mount_name(index)[0];
        int drive_letter_index = _totlower(drive_letter) - _T('a');
        ASSERT(drive_letter_index >= 0);
        ASSERT(drive_letter_index < num_drive_letters);
        ASSERT(partition_indices[drive_letter_index] == -1);
        partition_indices[drive_letter_index] = index;
    }
}

void
Service::set_max_response_time(
    unsigned int max_response_time)
{
    ASSERT(max_response_time > 0);
    Service::max_response_time = max_response_time;
}

void
Service::checkpoint()
{
    status.dwCheckPoint++;
    int ok = SetServiceStatus(status_handle, &status);
    if (!ok)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: SetServiceStatus() failed with error %d\n"), err));
        eventlog.report_event(GROVMSG_SET_STATUS_FAILURE, err, 0);
    }
}

void
Service::report_start()
{
    ASSERT(status.dwCurrentState == SERVICE_START_PENDING);
    status.dwCurrentState = SERVICE_RUNNING;

    int ok = SetServiceStatus(status_handle, &status);
    if (!ok)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: SetServiceStatus() failed with error %d\n"), err));
        eventlog.report_event(GROVMSG_SET_STATUS_FAILURE, err, 0);
    }
}

bool
Service::groveling_paused()
{
    return grovel_paused;
}

bool
Service::foreground_groveling()
{
    ASSERT(foreground_count >= 0);
    ASSERT(foreground_count <= num_partitions);
    return foreground_count > 0;
}

void
Service::suspending_controller()
{
    controller_suspended = true;
}

void
Service::suspending_exhorter()
{
    exhorter_suspended = true;
}

bool
Service::partition_in_foreground(
    int partition_index)
{
    ASSERT(partition_index >= 0);
    ASSERT(partition_index < num_partitions);
    return foreground_batch_in_progress[partition_index]
        && foreground_acknowledged[partition_index];
}

void
Service::set_foreground_batch_in_progress(
    int partition_index,
    bool value)
{
    ASSERT(partition_index >= 0);
    ASSERT(partition_index < num_partitions);
    ASSERT(foreground_count >= 0);
    ASSERT(foreground_count <= num_partitions);
    if (value)
    {
        if (!foreground_batch_in_progress[partition_index] &&
            foreground_acknowledged[partition_index])
        {
            foreground_count++;
        }
    }
    else
    {
        if (foreground_batch_in_progress[partition_index] &&
            foreground_acknowledged[partition_index])
        {
            foreground_count--;
        }
    }
    ASSERT(foreground_count >= 0);
    ASSERT(foreground_count <= num_partitions);
    foreground_batch_in_progress[partition_index] = value;
    if (!grovel_paused)
    {
        if (foreground_count == 0 && controller_suspended)
        {
            controller_suspended = false;
            CentralController::control_groveling((void *)controller);
        }
        if (foreground_count > 0 && exhorter_suspended)
        {
            exhorter_suspended = false;
            CentralController::exhort_groveling((void *)controller);
        }
    }
}

void
Service::follow_command()
{
    //
    //  If pause has been requested and we have not pause yet, do it
    //

    if (pause_commanded && !grovel_paused)
    {
        eventlog.report_event(GROVMSG_SERVICE_PAUSED, ERROR_SUCCESS, 0);
        grovel_paused = true;
        status.dwCurrentState = SERVICE_PAUSED;
        int ok = SetServiceStatus(status_handle, &status);
        if (!ok)
        {
            DWORD err = GetLastError();
            PRINT_DEBUG_MSG((_T("GROVELER: SetServiceStatus() failed with error %d\n"),
                err));
            eventlog.report_event(GROVMSG_SET_STATUS_FAILURE, err, 0);
        }
    }

    //
    //  If stop pausing has been requested and we are paused, unpause
    //

    if (!pause_commanded && grovel_paused)
    {
        eventlog.report_event(GROVMSG_SERVICE_CONTINUED, ERROR_SUCCESS, 0);
        grovel_paused = false;
        status.dwCurrentState = SERVICE_RUNNING;
        int ok = SetServiceStatus(status_handle, &status);
        if (!ok)
        {
            DWORD err = GetLastError();
            PRINT_DEBUG_MSG((_T("GROVELER: SetServiceStatus() failed with error %d\n"),
                err));
            eventlog.report_event(GROVMSG_SET_STATUS_FAILURE, err, 0);
        }
    }

    //
    //
    //

    for (int index = 0; index < num_partitions; index++)
    {
        ASSERT(foreground_count >= 0);
        ASSERT(foreground_count <= num_partitions);

        if (foreground_commanded[index] &&
            !foreground_acknowledged[index])
        {
            foreground_acknowledged[index] = true;
            if (foreground_batch_in_progress[index])
            {
                foreground_count++;
            }
        }

        if (!foreground_commanded[index] &&
            foreground_acknowledged[index])
        {
            foreground_acknowledged[index] = false;
            if (foreground_batch_in_progress[index])
            {
                foreground_count--;
            }
        }

        if (full_volume_scan_commanded[index])
        {
            controller->command_full_volume_scan(index);
            full_volume_scan_commanded[index] = false;
        }

        if (demarcate_foreground_batch[index])
        {
            controller->demarcate_foreground_batch(index);
            demarcate_foreground_batch[index] = false;
        }
    }

    ASSERT(foreground_count >= 0);
    ASSERT(foreground_count <= num_partitions);

    if (!grovel_paused)
    {
        if (foreground_count == 0 && controller_suspended)
        {
            controller_suspended = false;
            CentralController::control_groveling((void *)controller);
        }

        if (foreground_count > 0 && exhorter_suspended)
        {
            exhorter_suspended = false;
            CentralController::exhort_groveling((void *)controller);
        }
    }
}

void WINAPI
Service::control_handler(
    DWORD opcode)
{
    if (opcode == SERVICE_CONTROL_STOP || opcode == SERVICE_CONTROL_SHUTDOWN)
    {
        event_timer.halt();
        status.dwCurrentState = SERVICE_STOP_PENDING;
        status.dwWin32ExitCode = 0;
        status.dwWaitHint = max_response_time;
    }
    else if (opcode == SERVICE_CONTROL_PAUSE)
    {
        pause_commanded = true;
        status.dwCurrentState = SERVICE_PAUSE_PENDING;
        status.dwWaitHint = max_response_time;
    }
    else if (opcode == SERVICE_CONTROL_CONTINUE)
    {
        pause_commanded = false;
        status.dwCurrentState = SERVICE_CONTINUE_PENDING;
        status.dwWaitHint = max_response_time;
    }
    else if ((opcode & SERVICE_CONTROL_COMMAND_MASK) ==
        SERVICE_CONTROL_FOREGROUND)
    {
        int drive_letter_index = opcode & SERVICE_CONTROL_PARTITION_MASK;
        if (drive_letter_index == SERVICE_CONTROL_ALL_PARTITIONS)
        {
            for (int index = 0; index < num_partitions; index++)
            {
                demarcate_foreground_batch[index] = true;
                foreground_commanded[index] = true;
            }
        }
        else if (drive_letter_index < num_drive_letters)
        {
            int partition_index = partition_indices[drive_letter_index];
            if (partition_index >= 0)
            {
                demarcate_foreground_batch[partition_index] = true;
                foreground_commanded[partition_index] = true;
            }
        }
    }
    else if ((opcode & SERVICE_CONTROL_COMMAND_MASK) ==
        SERVICE_CONTROL_BACKGROUND)
    {
        int drive_letter_index = opcode & SERVICE_CONTROL_PARTITION_MASK;
        if (drive_letter_index == SERVICE_CONTROL_ALL_PARTITIONS)
        {
            for (int index = 0; index < num_partitions; index++)
            {
                foreground_commanded[index] = false;
            }
        }
        else if (drive_letter_index < num_drive_letters)
    {
            int partition_index = partition_indices[drive_letter_index];
            if (partition_index >= 0)
            {
                foreground_commanded[partition_index] = false;
            }
        }
    }
    else if ((opcode & SERVICE_CONTROL_COMMAND_MASK) ==
        SERVICE_CONTROL_VOLSCAN)
    {
        int drive_letter_index = opcode & SERVICE_CONTROL_PARTITION_MASK;
        if (drive_letter_index == SERVICE_CONTROL_ALL_PARTITIONS)
        {
            for (int index = 0; index < num_partitions; index++)
            {
                full_volume_scan_commanded[index] = true;
            }
        }
        else if (drive_letter_index < num_drive_letters)
        {
            int partition_index = partition_indices[drive_letter_index];
            if (partition_index >= 0)
            {
                full_volume_scan_commanded[partition_index] = true;
            }
        }
    }
    else if (opcode != SERVICE_CONTROL_INTERROGATE)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: Unrecognized SCM opcode: %lx\n"), opcode));
    }

    //
    //  Return our current status
    //

    int ok = SetServiceStatus(status_handle, &status);
    if (!ok)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: SetServiceStatus() failed with error %d\n"), err));
        eventlog.report_event(GROVMSG_SET_STATUS_FAILURE, err, 0);
    }

    sync_event.set();
}

void WINAPI
Service::service_main(
    DWORD argc,
    LPTSTR *argv)
{
    //
    //  Register the control handler
    //

    status_handle = RegisterServiceCtrlHandler(service_name, control_handler);
    if (status_handle == 0)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: RegisterServiceCtrlHandler() failed with error %d\n"),
            err));
        eventlog.report_event(GROVMSG_SERVICE_NOSTART, err, 0);
        return;
    }

    //
    //  Set Service status
    //

    status.dwServiceType = SERVICE_WIN32;
    status.dwCurrentState = SERVICE_START_PENDING;
    status.dwControlsAccepted = SERVICE_ACCEPT_STOP |
            SERVICE_ACCEPT_PAUSE_CONTINUE | SERVICE_ACCEPT_SHUTDOWN;
    status.dwWin32ExitCode = 0;
    status.dwServiceSpecificExitCode = 0;
    status.dwCheckPoint = 0;
    status.dwWaitHint = 0;

    int ok = SetServiceStatus(status_handle, &status);
    if (!ok)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: SetServiceStatus() failed with error %d\n"), err));
        eventlog.report_event(GROVMSG_SET_STATUS_FAILURE, err, 0);
    }

    //
    //  Start the main program of the service
    //

    int exit_code = _main(argc, argv);

    //
    //  When it returns, we are done
    //

    status.dwWin32ExitCode = exit_code;
    status.dwCurrentState  = SERVICE_STOPPED;
    ok = SetServiceStatus(status_handle, &status);
    if (!ok)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: SetServiceStatus() failed with error %d\n"), err));
        eventlog.report_event(GROVMSG_SET_STATUS_FAILURE, err, 0);
    }
}

#endif // SERVICE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\servctrl.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    servctrl.h

Abstract:

	SIS Groveler service control include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_SERVCTRL

#define _INC_SERVCTRL

#define SERVICE_CONTROL_VOLSCAN			0x00000080
#define SERVICE_CONTROL_FOREGROUND		0x000000a0
#define SERVICE_CONTROL_BACKGROUND		0x000000c0
#define SERVICE_CONTROL_RESERVED		0x000000e0

#define SERVICE_CONTROL_COMMAND_MASK	0xffffffe0
#define SERVICE_CONTROL_PARTITION_MASK	0x0000001f

#define SERVICE_CONTROL_ALL_PARTITIONS	0x0000001f

#endif	/* _INC_SERVCTRL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\share.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    share.h

Abstract:

	SIS Groveler shared data class header

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_SHARE

#define _INC_SHARE

#pragma pack (8)

enum SharedDataField
{
	SDF_grovel_time,
	SDF_volscan_time,
	SDF_extract_time,
	SDF_working_time,
	SDF_files_hashed,
	SDF_files_compared,
	SDF_files_merged,
	SDF_files_scanned,
	SDF_queue_length,
	SDF_hash_read_time,
	SDF_hash_read_ops,
	SDF_compare_read_time,
	SDF_compare_read_ops,
	SDF_hash_read_estimate,
	SDF_compare_read_estimate,

	num_shared_data_fields
};

struct SharedDataRecord
{
	_TCHAR *driveName;
	__int64 fields[num_shared_data_fields];
};

const int max_shared_data_records = 128;

#pragma pack ()

class SharedData
{
public:

	SharedData(
		int num_records = -1,
		_TCHAR **drive_names = 0);

	~SharedData();

	int count_of_records() const;

//	_TCHAR drive_letter(
//		int record_index) const;

	__int64 get_value(
		int record_index,
		SharedDataField field);

	void set_value(
		int record_index,
		SharedDataField field,
		__int64 value);

	void increment_value(
		int record_index,
		SharedDataField field,
		__int64 value);

	bool send_values();

	bool receive_values();

	bool extract_values(
		int *num_records,
		SharedDataRecord *records);

private:

	int local_num_records;
	int *shared_num_records;

	SharedDataRecord local_records[max_shared_data_records];
	SharedDataRecord *shared_records;

	NamedMutex *mutex;

	PSID security_identifier;
	PACL access_control_list;
	SECURITY_ATTRIBUTES security_attributes;
	SECURITY_DESCRIPTOR security_descriptor;

	bool map_ok;
	HANDLE map_handle;
	void *map_address;
};

#endif	/* _INC_SHARE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\share.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    share.cpp

Abstract:

    SIS Groveler shared data class

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

static const _TCHAR map_name[] = _T("Groveler Shared Memory");
static const _TCHAR mutex_name[] = _T("Groveler Shared Memory Mutex");
static const int mutex_timeout = 500;

#define ALIGN_INT64(x) \
    (((x+sizeof(__int64)-1)/sizeof(__int64))*sizeof(__int64))

SharedData::SharedData(
    int num_records,
    _TCHAR **drive_names)
{
    ASSERT(this != 0);
    ASSERT(num_records <= max_shared_data_records);
    map_ok = false;
    mutex = 0;
    map_handle = 0;
    map_address = 0;
    shared_num_records = 0;
    shared_records = 0;
    security_identifier = 0;
    access_control_list = 0;
    ZeroMemory(&security_attributes, sizeof(SECURITY_ATTRIBUTES));
    ZeroMemory(&security_descriptor, sizeof(SECURITY_DESCRIPTOR));

    //
    //  Initailize a Security descriptor so we can setup secure access
    //  to a shared file.
    //

    security_attributes.bInheritHandle = FALSE;
    security_attributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    security_attributes.lpSecurityDescriptor = (void *)&security_descriptor;

    BOOL success = InitializeSecurityDescriptor(&security_descriptor,
        SECURITY_DESCRIPTOR_REVISION);
    if (!success)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((
            _T("GROVELER: InitializeSecurityDescriptor() failed with error %d\n"), err));
        return;
    }

    SID_IDENTIFIER_AUTHORITY sid_authority = SECURITY_NT_AUTHORITY;
    success = AllocateAndInitializeSid(
        &sid_authority,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0,
        0,
        0,
        0,
        0,
        0,
        &security_identifier);
    if (!success)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((
            _T("GROVELER: AllocateAndInitializeSid() failed with error %d\n"), err));
        return;
    }

    //
    //  Create ACL
    //

    DWORD acl_size = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE)
                                        + GetLengthSid(security_identifier);
    access_control_list = (PACL)new BYTE[acl_size];

    success = InitializeAcl(
        access_control_list,
        acl_size,
        ACL_REVISION);
    if (!success)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: InitializeAcl() failed with error %d\n"), err));
        return;
    }

    success = AddAccessAllowedAce(
        access_control_list,
        ACL_REVISION,
        GENERIC_ALL,
        security_identifier);
    if (!success)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: AddAccessAllowedAce() failed with error %d\n"),
            err));
        return;
    }

    success = SetSecurityDescriptorDacl(
        &security_descriptor,
        TRUE,
        access_control_list,
        FALSE);
    if (!success)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: SetSecurityDescriptorDacl() failed with error %d\n"),
            err));
        return;
    }

    //
    //  Create a named mutex
    //

    mutex = new NamedMutex(mutex_name, &security_attributes);
    ASSERT(mutex != 0);

    //
    //  Calcualte size of mapped file
    //

    int map_size = ALIGN_INT64(sizeof(int))
                + ALIGN_INT64(max_shared_data_records * sizeof(SharedDataRecord));
    bool ok = mutex->acquire(mutex_timeout);
    if (!ok)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: Mutex::acquire() failed\n")));
        return;
    }

    //
    //  Create the mapped file.  Note that it will be backed by system paging
    //  files.
    //

    map_handle = CreateFileMapping((HANDLE)-1, &security_attributes,
        PAGE_READWRITE, 0, map_size, map_name);
    DWORD map_error = GetLastError();
    if (map_handle == 0)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: CreateFileMapping() failed with error %d\n"),
            map_error));
        return;
    }
    ASSERT(map_error == NO_ERROR || map_error == ERROR_ALREADY_EXISTS);

    //
    //  Map a view for this file
    //

    map_address =
        MapViewOfFile(map_handle, FILE_MAP_ALL_ACCESS, 0, 0, map_size);
    if (map_address == 0)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: MapViewOfFile() failed with error %d\n"), err));
        return;
    }

    shared_num_records = (int *)map_address;
    shared_records =
        (SharedDataRecord *)ALIGN_INT64((DWORD_PTR)(shared_num_records + 1));

    local_num_records = __max(num_records, 0);
    ZeroMemory(local_records, max_shared_data_records * sizeof(SharedDataRecord));

    ASSERT(local_num_records == 0 || drive_names != 0);

    for (int index = 0; index < local_num_records; index++)
    {
        local_records[index].driveName = drive_names[index];
    }

    map_ok = true;
    if (num_records >= 0 || map_error == NO_ERROR)
    {
        bool lok = send_values();
    }

    ok = mutex->release();
    if (!ok)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: Mutex::release() failed\n")));
    }
}

SharedData::~SharedData()
{
    ASSERT(this != 0);
    ASSERT(mutex != 0);
    delete mutex;
    mutex = 0;
    if (map_address != 0)
    {
        int ok = UnmapViewOfFile(map_address);
        if (!ok)
        {
            DWORD err = GetLastError();
            PRINT_DEBUG_MSG((_T("GROVELER: UnmapViewOfFile() failed with error %d\n"),
                err));
        }
        map_address = 0;
    }
    if (map_handle != 0)
    {
        int ok = CloseHandle(map_handle);
        if (!ok)
        {
            DWORD err = GetLastError();
            PRINT_DEBUG_MSG((_T("GROVELER: CloseHandle() failed with error %d\n"), err));
        }
        map_handle = 0;
    }
    if (security_identifier != 0)
    {
        FreeSid(security_identifier);
        security_identifier = 0;
    }
    if (access_control_list != 0)
    {
        delete[] access_control_list;
        access_control_list = 0;
    }
}

int
SharedData::count_of_records() const
{
    ASSERT(this != 0);
    return local_num_records;
}

//_TCHAR
//SharedData::drive_letter(
//  int record_index) const
//{
//  ASSERT(this != 0);
//  ASSERT(record_index >= 0);
//  ASSERT(record_index < max_shared_data_records);
//  ASSERT(record_index < local_num_records);
//  return local_records[record_index].drive_letter;
//}

__int64
SharedData::get_value(
    int record_index,
    SharedDataField field)
{
    ASSERT(this != 0);
    ASSERT(record_index >= 0);
    ASSERT(record_index < max_shared_data_records);
    ASSERT(record_index < local_num_records);
    ASSERT(field >= 0);
    ASSERT(field < num_shared_data_fields);
    return local_records[record_index].fields[field];
}

void
SharedData::set_value(
    int record_index,
    SharedDataField field,
    __int64 value)
{
    ASSERT(this != 0);
    ASSERT(record_index >= 0);
    ASSERT(record_index < max_shared_data_records);
    ASSERT(record_index < local_num_records);
    ASSERT(field >= 0);
    ASSERT(field < num_shared_data_fields);
    local_records[record_index].fields[field] = value;
}

void
SharedData::increment_value(
    int record_index,
    SharedDataField field,
    __int64 value)
{
    ASSERT(this != 0);
    ASSERT(record_index >= 0);
    ASSERT(record_index < max_shared_data_records);
    ASSERT(record_index < local_num_records);
    ASSERT(field >= 0);
    ASSERT(field < num_shared_data_fields);
    local_records[record_index].fields[field] += value;
}

bool
SharedData::send_values()
{
    ASSERT(this != 0);
    if (map_ok)
    {
        bool ok = mutex->acquire(mutex_timeout);
        if (ok)
        {
            ASSERT(shared_num_records != 0);
            *shared_num_records = local_num_records;
            ASSERT(shared_records != 0);
            ASSERT(local_records != 0);
            for (int index = 0; index < local_num_records; index++)
            {
                shared_records[index] = local_records[index];
            }
            ok = mutex->release();
            if (!ok)
            {
                PRINT_DEBUG_MSG((_T("GROVELER: Mutex::release() failed\n")));
            }
        }
        else
        {
            PRINT_DEBUG_MSG((_T("GROVELER: Mutex::acquire() failed\n")));
        }
        return ok;
    }
    else
    {
        return false;
    }
}

bool
SharedData::receive_values()
{
    ASSERT(this != 0);
    if (map_ok)
    {
        bool ok = mutex->acquire(mutex_timeout);
        if (ok)
        {
            ASSERT(shared_num_records != 0);
            local_num_records = *shared_num_records;
            ASSERT(shared_records != 0);
            ASSERT(local_records != 0);
            for (int index = 0; index < local_num_records; index++)
            {
                local_records[index] = shared_records[index];
            }
            ok = mutex->release();
            if (!ok)
            {
                PRINT_DEBUG_MSG((_T("GROVELER: Mutex::release() failed\n")));
            }
        }
        else
        {
            PRINT_DEBUG_MSG((_T("GROVELER: Mutex::acquire() failed\n")));
        }
        return ok;
    }
    else
    {
        return false;
    }
}

bool
SharedData::extract_values(
    int *num_records,
    SharedDataRecord *records)
{
    ASSERT(this != 0);
    if (map_ok)
    {
        bool ok = mutex->acquire(mutex_timeout);
        if (ok)
        {
            ASSERT(shared_num_records != 0);
            ASSERT(num_records != 0);
            *num_records = *shared_num_records;
            ASSERT(shared_records != 0);
            ASSERT(records != 0);
            for (int index = 0; index < *num_records; index++)
            {
                records[index] = shared_records[index];
            }
            ok = mutex->release();
            if (!ok)
            {
                PRINT_DEBUG_MSG((_T("GROVELER: Mutex::release() failed\n")));
            }
        }
        else
        {
            PRINT_DEBUG_MSG((_T("GROVELER: Mutex::acquire() failed\n")));
        }
        return ok;
    }
    else
    {
        return false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\sisdrive.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sisdrive.h

Abstract:

	SIS Groveler SIS drive checker include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_SISDRIVE

#define _INC_SISDRIVE

class SISDrives
{
public:

	SISDrives();

	void open();

	~SISDrives();

	int partition_count() const;

	int lettered_partition_count() const;

	_TCHAR *partition_guid_name(
		int partition_index) const;

	_TCHAR *partition_mount_name(
		int partition_index) const;

private:

	static bool is_sis_drive(
		_TCHAR *drive_name);

	void resize_buffer();

	int num_partitions;
	int num_lettered_partitions;
	int *partition_guid_names;
	int *partition_mount_names;

	int buffer_size;
	int buffer_index;
	_TCHAR *buffer;
};

#endif	/* _INC_SISDRIVE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\timeseq.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    timeseq.cpp

Abstract:

    SIS Groveler time sequencer

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

#if TIME_SEQUENCE_VIRTUAL

unsigned int TimeSequencer::virtual_time = 0;

void
TimeSequencer::VirtualSleep(
    unsigned int sleep_time)
{
    ASSERT(signed(sleep_time) >= 0);
    virtual_time += sleep_time;
}

unsigned int
TimeSequencer::GetVirtualTickCount()
{
    virtual_time++;
    unsigned int reported_time = 10 * (virtual_time / 10);
    ASSERT(reported_time % 10 == 0);
    return reported_time;
}

#endif // TIME_SEQUENCE_VIRTUAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\sisdrive.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sisdrive.cpp

Abstract:

    SIS Groveler SIS drive checker class

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

SISDrives::SISDrives()
{
    num_partitions = 0;
    num_lettered_partitions = 0;
    partition_guid_names = 0;
    partition_mount_names = 0;

    buffer_size = 0;
    buffer_index = 0;
    buffer = 0;
}

void
SISDrives::open()
{
    num_partitions = 0;
    num_lettered_partitions = 0;
    partition_mount_names = 0;

    int name_array_size = 1;
    partition_guid_names = new int[name_array_size];

    buffer_size = 256;
    buffer_index = 0;
    buffer = new _TCHAR[buffer_size];

    SERVICE_CHECKPOINT();
    Volumes volumes;
    bool done = false;

    //
    //  Enumerate all existing volumes getting their GUID names
    //

    while (!done)
    {
        DWORD error_code =
            volumes.find(&buffer[buffer_index], buffer_size - buffer_index);
        while (error_code != NO_ERROR)
        {
            if (error_code != ERROR_INSUFFICIENT_BUFFER &&
                error_code != ERROR_BUFFER_OVERFLOW &&
                error_code != ERROR_FILENAME_EXCED_RANGE)
            {
                done = true;
                break;
            }
            resize_buffer();
            SERVICE_CHECKPOINT();
            error_code =
                volumes.find(&buffer[buffer_index], buffer_size - buffer_index);
        }
        if (!done)
        {
            if (num_partitions >= name_array_size)
            {
                name_array_size *= 2;
                int *new_name_array = new int[name_array_size];
                memcpy(new_name_array,partition_guid_names,num_partitions * sizeof(int));
                delete[] partition_guid_names;
                partition_guid_names = new_name_array;
            }

            //TRACE_PRINTF(TC_sisdrive,2,
            //    (_T("Found volume \"%s\"\n"),&buffer[buffer_index]));

            partition_guid_names[num_partitions] = buffer_index;
            num_partitions++;
            buffer_index += _tcslen(&buffer[buffer_index]) + 1;
        }
        SERVICE_CHECKPOINT();
    }

    //
    //  Setup to scan for DRIVE LETTERS and MOUNT POINTS and correlate
    //  them with the GUID names.
    //

    partition_mount_names = new int[num_partitions];
    int *next_indices = new int[num_partitions + 3];
    int *work_list = &next_indices[num_partitions + 1];
    int *scan_list = &next_indices[num_partitions + 2];

    *scan_list = 0;
    for (int index = 0; index < num_partitions; index++)
    {
        partition_mount_names[index] = -1;
        next_indices[index] = index + 1;
    }
    next_indices[num_partitions - 1] = -1;

    *work_list = num_partitions;
    next_indices[num_partitions] = -1;
    int work_list_end = num_partitions;

    //
    //  Now that we have the GUID names, this will correlate the GUID names
    //  with the MOUNT names, this does both direct drive letters and
    //  mount point names.
    //

    while (*scan_list != -1 && *work_list != -1)
    {
        _TCHAR *mount_name = 0;
        int mount_size = 0;
        if (*work_list < num_partitions)
        {
            mount_name = &buffer[partition_mount_names[*work_list]];
            mount_size = _tcslen(mount_name);
            while (buffer_size - buffer_index <= mount_size)
            {
                resize_buffer();
            }
            _tcscpy(&buffer[buffer_index], mount_name);
        }

        VolumeMountPoints mount_points(mount_name);

        //
        //  We have the next name, scan the list looking for that name
        //

        done = false;
        while (!done)
        {
            DWORD error_code = mount_points.find(
                &buffer[buffer_index + mount_size],
                buffer_size - buffer_index - mount_size);
            while (error_code != NO_ERROR)
            {
                if (error_code != ERROR_INSUFFICIENT_BUFFER &&
                    error_code != ERROR_BUFFER_OVERFLOW &&
                    error_code != ERROR_FILENAME_EXCED_RANGE)
                {
                    done = true;
                    break;
                }
                resize_buffer();
                SERVICE_CHECKPOINT();
                error_code = mount_points.find(
                    &buffer[buffer_index + mount_size],
                    buffer_size - buffer_index - mount_size);
            }
            if (!done)
            {
                _TCHAR volume_guid_name[MAX_PATH + 1];

                //TRACE_PRINTF(TC_sisdrive,2,
                //    (_T("Correlating volume \"%s\"\n"),&buffer[buffer_index+mount_size]));

                BOOL ok = GetVolumeNameForVolumeMountPoint(
                    &buffer[buffer_index], volume_guid_name, MAX_PATH + 1);
                if (!ok)
                {
                    continue;
                }
                int scan_index = *scan_list;
                int prev_index = num_partitions + 2;
                while (scan_index >= 0)
                {
                    _TCHAR *scan_name =
                        &buffer[partition_guid_names[scan_index]];
                    if (_tcscmp(scan_name, volume_guid_name) == 0)
                    {
                        partition_mount_names[scan_index] = buffer_index;
                        buffer_index += _tcslen(&buffer[buffer_index]) + 1;
                        next_indices[prev_index] = next_indices[scan_index];
                        next_indices[scan_index] = -1;
                        next_indices[work_list_end] = scan_index;
                        work_list_end = scan_index;
                        if (mount_name) {
                            _tcscpy(&buffer[buffer_index], mount_name);     //get ready for next time through the loop
                        }
                        break;
                    }
                    prev_index = scan_index;
                    scan_index = next_indices[scan_index];
                    SERVICE_CHECKPOINT();
                }
            }
            SERVICE_CHECKPOINT();
        }
        *work_list = next_indices[*work_list];
        SERVICE_CHECKPOINT();
    }
    delete[] next_indices;
    next_indices = 0;

    //
    //  We are now going to sort all of the drive letter entries to the front
    //  this does keep the driver letter/guid name correlation intact.
    //

    index = 0;
    while (index < num_partitions)
    {
        if (partition_mount_names[index] < 0 ||
            !is_sis_drive(&buffer[partition_guid_names[index]]) ||
            (!GrovelAllPaths && 
             (!RISVolumeGuidName ||
              _wcsicmp(RISVolumeGuidName,&buffer[partition_guid_names[index]]) != 0)))
        {
            TRACE_PRINTF(TC_sisdrive,2,
                (_T("Ignoring: Name=\"%s\" GuidName=\"%s\"\n"),
                    (partition_mount_names[index] > 0) ? &buffer[partition_mount_names[index]] : NULL,
                    &buffer[partition_guid_names[index]]));

            //
            //  The given entry either doesn't have a name or SIS is
            //  not currently running on the volume.  Move it to the end
            //  of the list.

            int temp = partition_guid_names[index];
            partition_guid_names[index] =
                partition_guid_names[num_partitions - 1];
            partition_guid_names[num_partitions - 1] = temp;
            temp = partition_mount_names[index];
            partition_mount_names[index] =
                partition_mount_names[num_partitions - 1];
            partition_mount_names[num_partitions - 1] = temp;
            num_partitions--;
            continue;
        }
        if (buffer[partition_mount_names[index] + 3] == _T('\0'))
        {
            //
            //  If this is a drive letter (not a mount point) then
            //  it will be moved to the front of the list
            //

            int temp = partition_guid_names[index];
            partition_guid_names[index] =
                partition_guid_names[num_lettered_partitions];
            partition_guid_names[num_lettered_partitions] = temp;
            temp = partition_mount_names[index];
            partition_mount_names[index] =
                partition_mount_names[num_lettered_partitions];
            partition_mount_names[num_lettered_partitions] = temp;
            num_lettered_partitions++;
        }
        index++;
        SERVICE_CHECKPOINT();
    }

#if DBG
    TRACE_PRINTF(TC_sisdrive,2,
        (_T("Num Partitions=%d\nNum Lettered_partitions=%d\n"),
            num_partitions,
            num_lettered_partitions));
            
    for (index=0;index < num_partitions;index++)
    {
        TRACE_PRINTF(TC_sisdrive,2,
            (_T("Name=\"%s\" GuidName=\"%s\"\n"),
                &buffer[partition_mount_names[index]],
                &buffer[partition_guid_names[index]]));
    }
#endif
}

SISDrives::~SISDrives()
{
    if (partition_guid_names != 0)
    {
        delete[] partition_guid_names;
        partition_guid_names = 0;
    }
    if (partition_mount_names != 0)
    {
        delete[] partition_mount_names;
        partition_mount_names = 0;
    }
    if (buffer != 0)
    {
        delete[] buffer;
        buffer = 0;
    }
}

int SISDrives::partition_count() const
{
    return num_partitions;
}

int SISDrives::lettered_partition_count() const
{
    return num_lettered_partitions;
}

_TCHAR * SISDrives::partition_guid_name(
    int partition_index) const
{
    if (partition_index < num_partitions)
    {
        return &buffer[partition_guid_names[partition_index]];
    }
    else
    {
        return 0;
    }
}

_TCHAR * SISDrives::partition_mount_name(
    int partition_index) const
{
    if (partition_index < num_partitions)
    {
        return &buffer[partition_mount_names[partition_index]];
    }
    else
    {
        return 0;
    }
}

bool
SISDrives::is_sis_drive(
    _TCHAR *drive_name)
{
    UINT drive_type = GetDriveType(drive_name);
    if (drive_type != DRIVE_FIXED)
    {
        return false;
    }
    _TCHAR fs_name[8];
    BOOL ok = GetVolumeInformation(drive_name, 0, 0, 0, 0, 0, fs_name, 8);
    if (!ok)
    {
        DWORD err = GetLastError();
        PRINT_DEBUG_MSG((_T("GROVELER: GetVolumeInformation() failed with error %d\n"),
            err));
        return false;
    }
    if (_tcsicmp(fs_name, _T("NTFS")) != 0)
    {
        return false;
    }

    int bLen = SIS_CSDIR_STRING_NCHARS + wcslen(drive_name) + (sizeof(WCHAR)*2);
    _TCHAR *sis_directory = new _TCHAR[bLen];

    (void)StringCchCopy(sis_directory, bLen, drive_name);
    TrimTrailingChar(sis_directory, L'\\');
    (void)StringCchCat(sis_directory, bLen, SIS_CSDIR_STRING);

    ok = SetCurrentDirectory(sis_directory);
    delete[] sis_directory;
    sis_directory = 0;
    if (!ok)
    {
        return false;
    }
    BOOL sis_installed = Groveler::is_sis_installed(drive_name);
    if (!sis_installed)
    {
        return false;
    }
    return true;
}

void SISDrives::resize_buffer()
{
    buffer_size *= 2;
    _TCHAR *new_buffer = new _TCHAR[buffer_size];

    memcpy(new_buffer, buffer, buffer_index * sizeof(_TCHAR));

    delete[] buffer;
    buffer = new_buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\timeseq.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    timeseq.h

Abstract:

	SIS Groveler time sequencer include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_TIMESEQ

#define _INC_TIMESEQ

#if TIME_SEQUENCE_VIRTUAL

class TimeSequencer
{
public:

	static void VirtualSleep(
		unsigned int sleep_time);

	static unsigned int GetVirtualTickCount();

private:

	TimeSequencer() {}
	~TimeSequencer() {}

	static unsigned int virtual_time;
};

#define SLEEP(stime) TimeSequencer::VirtualSleep(stime)
#define GET_TICK_COUNT() TimeSequencer::GetVirtualTickCount()
#define WAIT_FOR_SINGLE_OBJECT(handle, timeout) \
	(TimeSequencer::VirtualSleep(timeout), WAIT_TIMEOUT)

#else // TIME_SEQUENCE_VIRTUAL

#define SLEEP(stime) Sleep(stime)
#define GET_TICK_COUNT() GetTickCount()
#define WAIT_FOR_SINGLE_OBJECT(handle, timeout) \
	WaitForSingleObject(handle, timeout)

#endif // TIME_SEQUENCE_VIRTUAL

#endif	/* _INC_TIMESEQ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\trace.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    trace.h

Abstract:

	SIS Groveler debugging trace include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_TRACE

#define _INC_TRACE

// The following lines are a temporary hack to allow the DPRINTF() and
// TPRINTF() macros in the database.cpp, extract.cpp, groveler.cpp, and
// scan.cpp files to continue to operate.  Each instance of the DPRINTF()
// or TPRINTF() macro should be replaced by an instance of the TRACE_PRINTF()
// macro, with an appropriate component parameter (TC_database, TC_extract,
// TC_groveler, or TC_scan) and an appropriate detail parameter.  Then, this
// comment block and all lines of code up to the next comment block should
// be deleted.

#define DPRINTF(args) TRACE_PRINTF(TC_groveler, 1, args)
#define TPRINTF(args) TRACE_PRINTF(TC_groveler, 2, args)

#if defined(TRACELEVEL) && DBG
#if TRACELEVEL == 3

#define TRACE_TYPE 2		// immediate printout
#define TRACE_IOSTREAM 2	// print to stderr

#define TRACE_GROVELER 2	// print DPRINTF() but not TPRINTF()

#define TRACE_DATABASE 1
#define TRACE_EXTRACT 1
#define TRACE_SCAN 2
#define TRACE_SISDRIVE 2

#endif // TRACELEVEL == 3
#endif /* TRACELEVEL */

/*
 *	Define TRACE_TYPE, TRACE_FILENAME, and TRACE_IOSTREAM in sources file.
 *	These settings take effect at compile time and cannot be changed thereafter.
 *
 *	TRACE_TYPE:
 *		If not defined, none
 *		0 == none
 *		1 == delayed
 *		2 == immediate
 *
 *	TRACE_FILENAME
 *		Name of destination file for output of trace prints.
 *		If not defined, then no output to file.
 *
 *	TRACE_IOSTREAM
 *		If not defined, no output to stream
 *		0 == no output to stream
 *		1 == stdout
 *		2 == stderr
 *
 *	Define trace contextual detail indicators in sources file if desired.
 *	These settings provide initial values for variables that may be changed by
 *	a debugger during run time.  Each contextual detail indicator indicates
 *	the level of trace detail that should be printed for that component.
 *	Greater numbers indicate greater levels of detail.  If an indicator is
 *	zero or not defined, then no trace information is printed for this
 *	component (unless the component has a TRACE_PRINTF() macro that specifies
 *	a detail level of zero, indicating that it should always be displayed in
 *	a trace).  The contextual detail indicators currently supported are:
 *		TRACE_MAIN
 *		TRACE_CENTCTRL
 *		TRACE_CONFEST
 *		TRACE_DATABASE
 *		TRACE_DECAYACC
 *		TRACE_DISKINFO
 *		TRACE_ETIMER
 *		TRACE_EVENT
 *		TRACE_EVENTLOG
 *		TRACE_EXTRACT
 *		TRACE_FILTER
 *		TRACE_GROVELER
 *		TRACE_MEANCOMP
 *		TRACE_MUTEX
 *		TRACE_PARAMS
 *		TRACE_PARTCTRL
 *		TRACE_PATHLIST
 *		TRACE_PEAKFIND
 *		TRACE_REGISTRY
 *		TRACE_SCAN
 *		TRACE_SERVICE
 *		TRACE_SHARE
 *		TRACE_SISDRIVE
 *		TRACE_UTILITY
 *
 *	To add a new component to the trace facility, follow these steps:
 *		1) add its name to the comment above
 *		2) add an entry to the TraceComponent enumeration below
 *		3) add an #ifndef-#define-#endif tuple to the list in trace.cpp
 *		4) add an initializer to the trace_components array in trace.cpp
 *
 *	To change the trace detail level for a given component during run time,
 *	set the element in the trace_detail[] array indexed by the TraceComponent
 *	enumeration for the desired component to the desired detail level.
 *
 */

#ifndef TRACE_TYPE
#define TRACE_TYPE 0
#endif /* TRACE_TYPE */

#ifndef TRACE_IOSTREAM
#define TRACE_IOSTREAM 0
#endif /* TRACE_IOSTREAM */

#if TRACE_TYPE > 0

enum TraceComponent
{
	TC_main,
	TC_centctrl,
	TC_confest,
	TC_database,
	TC_decayacc,
	TC_diskinfo,
	TC_etimer,
	TC_event,
	TC_eventlog,
	TC_extract,
	TC_filter,
	TC_groveler,
	TC_meancomp,
	TC_mutex,
	TC_params,
	TC_partctrl,
	TC_pathlist,
	TC_peakfind,
	TC_registry,
	TC_scan,
	TC_service,
	TC_share,
	TC_sisdrive,
	TC_utility,

	num_trace_components
};

class Tracer
{
public:

	static void trace_printf(
		_TCHAR *format,
		...);

#if TRACE_TYPE == 1

	static void print_trace_log();

#endif // TRACE_TYPE == 1

#ifdef TRACE_FILENAME

	static void open_trace_file();

	static void close_trace_file();

#endif /* TRACE_FILENAME */

private:

	Tracer() {}
	~Tracer() {}

#if TRACE_TYPE == 1

	enum
	{
		trace_buffer_size = 4000,
		trace_entry_limit = 256
	};

	struct TraceBuffer;

	friend struct TraceBuffer;

	struct TraceBuffer
	{
		TraceBuffer *next;
		_TCHAR buffer[trace_buffer_size];
	};

	static int position;
	static TraceBuffer *trace_log;
	static TraceBuffer *current_buffer;
	static TraceBuffer *free_list;

#endif // TRACE_TYPE == 1

#ifdef TRACE_FILENAME

	static FILE *file_stream;

#endif /* TRACE_FILENAME */

#if TRACE_IOSTREAM != 0

	static FILE *io_stream;

#endif // TRACE_IOSTREAM
};

extern int trace_detail[num_trace_components];

#define TRACE_PRINTF(component, detail, args) \
{ \
	if (detail <= trace_detail[component]) \
	{ \
		Tracer::trace_printf ## args ; \
	} \
}

#if TRACE_TYPE == 1

#define PRINT_TRACE_LOG() Tracer::print_trace_log()

#else // TRACE_TYPE == 1

#define PRINT_TRACE_LOG()

#endif // TRACE_TYPE == 1

#ifdef TRACE_FILENAME

#define OPEN_TRACE_FILE() Tracer::open_trace_file()
#define CLOSE_TRACE_FILE() Tracer::close_trace_file()

#else /* TRACE_FILENAME */

#define OPEN_TRACE_FILE()
#define CLOSE_TRACE_FILE()

#endif /* TRACE_FILENAME */

#else // TRACE_TYPE > 0

#define TRACE_PRINTF(component, detail, args)
#define PRINT_TRACE_LOG()
#define OPEN_TRACE_FILE()
#define CLOSE_TRACE_FILE()

#endif // TRACE_TYPE > 0

#endif	/* _INC_TRACE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\trace.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    trace.cpp

Abstract:

    SIS Groveler debugging tracer

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

#if TRACE_TYPE > 0

#ifndef TRACE_MAIN
#define TRACE_MAIN 0
#endif /* TRACE_MAIN */

#ifndef TRACE_CENTCTRL
#define TRACE_CENTCTRL 0
#endif /* TRACE_CENTCTRL */

#ifndef TRACE_CONFEST
#define TRACE_CONFEST 0
#endif /* TRACE_CONFEST */

#ifndef TRACE_DATABASE
#define TRACE_DATABASE 0
#endif /* TRACE_DATABASE */

#ifndef TRACE_DECAYACC
#define TRACE_DECAYACC 0
#endif /* TRACE_DECAYACC */

#ifndef TRACE_DISKINFO
#define TRACE_DISKINFO 0
#endif /* TRACE_DISKINFO */

#ifndef TRACE_ETIMER
#define TRACE_ETIMER 0
#endif /* TRACE_ETIMER */

#ifndef TRACE_EVENT
#define TRACE_EVENT 0
#endif /* TRACE_EVENT */

#ifndef TRACE_EVENTLOG
#define TRACE_EVENTLOG 0
#endif /* TRACE_EVENTLOG */

#ifndef TRACE_EXTRACT
#define TRACE_EXTRACT 0
#endif /* TRACE_EXTRACT */

#ifndef TRACE_FILTER
#define TRACE_FILTER 0
#endif /* TRACE_FILTER */

#ifndef TRACE_GROVELER
#define TRACE_GROVELER 0
#endif /* TRACE_GROVELER */

#ifndef TRACE_MEANCOMP
#define TRACE_MEANCOMP 0
#endif /* TRACE_MEANCOMP */

#ifndef TRACE_MUTEX
#define TRACE_MUTEX 0
#endif /* TRACE_MUTEX */

#ifndef TRACE_PARAMS
#define TRACE_PARAMS 0
#endif /* TRACE_PARAMS */

#ifndef TRACE_PARTCTRL
#define TRACE_PARTCTRL 0
#endif /* TRACE_PARTCTRL */

#ifndef TRACE_PATHLIST
#define TRACE_PATHLIST 0
#endif /* TRACE_PATHLIST */

#ifndef TRACE_PEAKFIND
#define TRACE_PEAKFIND 0
#endif /* TRACE_PEAKFIND */

#ifndef TRACE_REGISTRY
#define TRACE_REGISTRY 0
#endif /* TRACE_REGISTRY */

#ifndef TRACE_SCAN
#define TRACE_SCAN 0
#endif /* TRACE_SCAN */

#ifndef TRACE_SERVICE
#define TRACE_SERVICE 0
#endif /* TRACE_SERVICE */

#ifndef TRACE_SHARE
#define TRACE_SHARE 0
#endif /* TRACE_SHARE */

#ifndef TRACE_SISDRIVE
#define TRACE_SISDRIVE 0
#endif /* TRACE_SISDRIVE */

#ifndef TRACE_UTILITY
#define TRACE_UTILITY 0
#endif /* TRACE_UTILITY */

int trace_detail[num_trace_components] =
{
    TRACE_MAIN,
    TRACE_CENTCTRL,
    TRACE_CONFEST,
    TRACE_DATABASE,
    TRACE_DECAYACC,
    TRACE_DISKINFO,
    TRACE_ETIMER,
    TRACE_EVENT,
    TRACE_EVENTLOG,
    TRACE_EXTRACT,
    TRACE_FILTER,
    TRACE_GROVELER,
    TRACE_MEANCOMP,
    TRACE_MUTEX,
    TRACE_PARAMS,
    TRACE_PARTCTRL,
    TRACE_PATHLIST,
    TRACE_PEAKFIND,
    TRACE_REGISTRY,
    TRACE_SCAN,
    TRACE_SERVICE,
    TRACE_SHARE,
    TRACE_SISDRIVE,
    TRACE_UTILITY
};

#if TRACE_TYPE == 1

int Tracer::position = trace_buffer_size;
Tracer::TraceBuffer * Tracer::trace_log = 0;
Tracer::TraceBuffer * Tracer::current_buffer = 0;
Tracer::TraceBuffer * Tracer::free_list = 0;

#endif // TRACE_TYPE == 1

#ifdef TRACE_FILENAME

FILE * Tracer::file_stream = 0;

#endif /* TRACE_FILENAME */

#if TRACE_IOSTREAM == 1

FILE * Tracer::io_stream = stdout;

#elif TRACE_IOSTREAM != 0

FILE * Tracer::io_stream = stderr;

#endif // TRACE_IOSTREAM

void
Tracer::trace_printf(
    _TCHAR *format,
    ...)
{
    ASSERT(format != 0);
#if TRACE_TYPE == 1
    if (position >= trace_buffer_size - trace_entry_limit)
    {
        TraceBuffer *new_buffer;
        if (free_list == 0)
        {
            new_buffer = new TraceBuffer;
        }
        else
        {
            new_buffer = free_list;
            free_list = free_list->next;
        }
        ASSERT(new_buffer != 0);
        new_buffer->next = 0;
        if (current_buffer == 0)
        {
            trace_log = new_buffer;
        }
        else
        {
            current_buffer->next = new_buffer;
        }
        current_buffer = new_buffer;
        position = 0;
    }
    ASSERT(current_buffer != 0);
    va_list ap;
    va_start(ap, format);
    int result = _vsntprintf(&current_buffer->buffer[position],
        trace_entry_limit, format, ap);
    va_end(ap);
    if (result >= trace_entry_limit || result < 0)
    {
        position += trace_entry_limit;
        _tcscpy(&current_buffer->buffer[position - 4], _T("...\n"));
    }
    else
    {
        position += result;
    }
    ASSERT(position < trace_buffer_size);
#else // TRACE_TYPE == 1
    va_list ap;
#ifdef TRACE_FILENAME
    if (file_stream != 0)
    {
        va_start(ap, format);
        _vftprintf(file_stream, format, ap);
        va_end(ap);
    }
#endif /* TRACE_FILENAME */
#if TRACE_IOSTREAM != 0
    va_start(ap, format);
    _vftprintf(io_stream, format, ap);
    va_end(ap);
#endif // TRACE_IOSTREAM != 0
#endif // TRACE_TYPE == 1
}

#if TRACE_TYPE == 1

void
Tracer::print_trace_log()
{
    TraceBuffer *buffer = trace_log;
    while (buffer != 0)
    {
#ifdef TRACE_FILENAME
        if (file_stream != 0)
        {
            _ftprintf(file_stream, _T("%s"), buffer->buffer);
        }
#endif /* TRACE_FILENAME */
#if TRACE_IOSTREAM != 0
        ASSERT(io_stream != 0);
        _ftprintf(io_stream, _T("%s"), buffer->buffer);
#endif // TRACE_IOSTREAM != 0
        TraceBuffer *next_buffer = buffer->next;
        buffer->next = free_list;
        free_list = buffer;
        buffer = next_buffer;
    }
    trace_log = 0;
    current_buffer = 0;
    position = 0;
}

#endif // TRACE_TYPE == 1

#ifdef TRACE_FILENAME

void Tracer::open_trace_file()
{
    file_stream = _tfopen(_T(TRACE_FILENAME), _T("w"));
    if (file_stream == 0)
    {
        PRINT_DEBUG_MSG((_T("GROVELER: Unable to open trace file ") _T(TRACE_FILENAME)));
    }
}

void Tracer::close_trace_file()
{
    if (file_stream != 0)
    {
        fclose(file_stream);
    }
}

#endif /* TRACE_FILENAME */

#endif // TRACE_TYPE > 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\utility.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    utilities.h

Abstract:

    SIS Groveler general utilities include file

Authors:

    Cedric Krumbein, 1998

Environment:

    User Mode

Revision History:

--*/

/************************ General-purpose definitions ************************/

typedef DWORDLONG Signature;
typedef LONGLONG  PerfTime;

#define Clear(OBJECT) \
    memset(&(OBJECT), 0, sizeof(OBJECT))

#define IsSet(EVENT) \
    ((EVENT) != NULL && WaitForSingleObject(EVENT, 0) == WAIT_OBJECT_0)

#define IsReset(EVENT) \
    ((EVENT) != NULL && WaitForSingleObject(EVENT, 0) == WAIT_TIMEOUT)

#define ROTATE_LEFT(DATA, NUM_BITS) \
    ((DATA) << (NUM_BITS) | (DATA) >> (sizeof(DATA)*8 - (NUM_BITS)))

#define ROTATE_RIGHT(DATA, NUM_BITS) \
    ((DATA) >> (NUM_BITS) | (DATA) << (sizeof(DATA)*8 - (NUM_BITS)))

/************************ Utility function prototypes ************************/

#define PERF_TIME_TO_MSEC(VALUE) PerformanceTimeToMSec(VALUE)

#define PERF_TIME_TO_USEC(VALUE) PerformanceTimeToUSec(VALUE)

extern void TrimTrailingChar(PWCHAR name,WCHAR ch);

PerfTime GetPerformanceTime();

DWORD PerformanceTimeToMSec(PerfTime timeInterval);

LONGLONG PerformanceTimeToUSec(PerfTime timeInterval);

DWORDLONG GetTime();

TCHAR *PrintTime(TCHAR    *string,
                 DWORDLONG time);

DWORDLONG GetFileID(const TCHAR *volName,const TCHAR *fileName);

BOOL GetCSIndex(HANDLE fileHandle,
                CSID  *csIndex);

//
// A class to handle arbitrary length pathnames, as returned by NtQueryInformationFile()
//
class TFileName {

public:
    ULONG                   nameLenMax;                 // maximum length of name (in chars)
    ULONG                   nameLen;                    // actual length of name (not including NULL terminator) in chars
    TCHAR                  *name;                       // file name (ptr to nameInfo->FileName)
    FILE_NAME_INFORMATION  *nameInfo;                   // required by NtQueryInformationFile
    ULONG                   nameInfoSize;               // sizeof nameInfo buffer

    TFileName(void) : nameLenMax(0), nameLen(0), name(NULL), nameInfo(NULL), nameInfoSize(0) {}

    ~TFileName() {
        if (nameInfo)
            delete[] nameInfo;
    }

    void resize(int size = 900) {
        if (nameInfo)
            delete[] nameInfo;

        allocBuf(size);
    }

    void append(const TCHAR *s, int c = -1) {
        int slen;
        int n;

        if (0 == c || NULL == s)
            return;

        slen = _tcslen(s);

        if (-1 == c)
            n = slen;
        else
            n = min(slen, c);

        // If the combined size of the two strings is larger than our buffer,
        // realloc the buffer.

        if (nameLen + n + 1 > nameLenMax) {
            FILE_NAME_INFORMATION *ni = nameInfo;

            allocBuf(nameLen + n + 1 + 512);

            if (ni) {
                (void)StringCchCopy(name, nameLenMax, ni->FileName);
                delete[] ni;
            }
        }

        (void)StringCchCat(name, nameLenMax, s);
        nameLen += n;
        ASSERT(nameLen <= wcslen(name));
        name[nameLen] = _T('\0');
    }

    void assign(const TCHAR *s, int c = -1) {
        if (nameLenMax > 0) {
            nameLen = 0;
            name[0] = _T('\0');
        }
        append(s, c);
    }

private:

    // Allocate a buffer for nameInfo of the specified size.  Note that name will 
    // point into this buffer.

    void allocBuf(int size) {
        ASSERT(size >= 0);

        nameLenMax = size;
        nameLen = 0;

        if (size > 0) {
            nameInfoSize = (size * sizeof(TCHAR)) + sizeof(ULONG);

            nameInfo = (PFILE_NAME_INFORMATION) new BYTE[nameInfoSize + sizeof FILE_NAME_INFORMATION]; // conservative size

            ASSERT(nameInfo);               // new_handler should raise exception on out of memory
            ASSERT((((ULONG_PTR) nameInfo) % sizeof(ULONG)) == 0); // make sure alignment is correct

            name = (TCHAR *) nameInfo->FileName;
            name[0] = _T('\0');

            ASSERT(((UINT_PTR) &nameInfo->FileName[size] - (UINT_PTR) nameInfo) == nameInfoSize);
        } else {
            nameInfo = NULL;
            name = NULL;
            nameInfoSize = 0;
        }
    }
};

BOOL GetFileName(
    HANDLE     fileHandle,
    TFileName *tFileName);

BOOL GetFileName(
    HANDLE     volumeHandle,
    DWORDLONG  fileID,
    TFileName *tFileName);

TCHAR *GetCSName(CSID *csIndex);

VOID FreeCSName(TCHAR *rpcStr);

Signature Checksum(
    const VOID *buffer,
    DWORD       bufferLen,
    DWORDLONG   offset,
    Signature   firstWord);

/*********************** Hash table class declaration ************************/

#define TABLE_MIN_LOAD 4
#define TABLE_MAX_LOAD 5

#define TABLE_RANDOM_CONSTANT 314159269
#define TABLE_RANDOM_PRIME   1000000007

#define TABLE_DIR_SIZE 256

#define TABLE_SEGMENT_BITS  8
#define TABLE_SEGMENT_SIZE (1U << TABLE_SEGMENT_BITS)
#define TABLE_SEGMENT_MASK (TABLE_SEGMENT_SIZE - 1U)

class Table {

private:

    struct TableEntry {
        TableEntry *prevEntry,
                   *nextEntry,
                   *prevChain,
                   *nextChain;

        DWORD hashValue,
              keyLen;

        VOID *data;
    } *firstEntry,
      *lastEntry;

    DWORD numBuckets,
          dirSize,
          expandIndex,
          level,
          numEntries;

    struct TableSegment {
        TableEntry *slot[TABLE_SEGMENT_SIZE];
    } **directory;

    DWORD Hash(const VOID *key,
               DWORD       keyLen) const;

    DWORD BucketNum(DWORD hashValue) const;

    VOID Expand();

    VOID Contract();

public:

    Table();

    ~Table();

    BOOL Put(
        VOID *data,
        DWORD keyLen);

    VOID *Get(const VOID *key,
              DWORD       keyLen,
              BOOL        erase = FALSE);

    VOID *GetFirst(DWORD *keyLen = NULL,
                   BOOL   erase  = TRUE);

    DWORD Number() const;
};

/************************** FIFO class declaration ***************************/

class FIFO {

private:

    struct FIFOEntry {
        FIFOEntry *next;
        DWORD      size;
        VOID      *data;
    } *head, *tail;

    DWORD numEntries;

public:

    FIFO();

    ~FIFO();

    VOID Put(VOID *data);

    VOID *Get();

    DWORD Number() const;
};

/************************** LIFO class declaration ***************************/

class LIFO {

private:

    struct LIFOEntry {
        LIFOEntry *next;
        DWORD      size;
        VOID      *data;
    } *top;

    DWORD numEntries;

public:

    LIFO();

    ~LIFO();

    VOID Put(VOID *data);

    VOID *Get();

    DWORD Number() const;
};

BOOL GetParentName(const TCHAR *fileName,
                   TFileName   *parentName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\volumes.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    volumes.h

Abstract:

	SIS Groveler volume mount include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_VOLUMES

#define _INC_VOLUMES

class Volumes
{
public:

	Volumes();

	~Volumes();

	DWORD find(
		_TCHAR *volume_name,
		DWORD length);

private:

	HANDLE volume_handle;
};

class VolumeMountPoints
{
public:

	VolumeMountPoints(
		_TCHAR *volume_name);

	~VolumeMountPoints();

	DWORD find(
		_TCHAR *volume_mount_point,
		DWORD length);

private:

	_TCHAR *volume_name;
	DWORD drive_mask;
	_TCHAR drive_letter;
	HANDLE volume_handle;
};

#endif	/* _INC_VOLUMES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\volumes.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    volumes.cpp

Abstract:

    SIS Groveler SIS volume mount classes

Authors:

    John Douceur, 1998

Environment:

    User Mode


Revision History:


--*/

#include "all.hxx"

Volumes::Volumes()
{
    volume_handle = INVALID_HANDLE_VALUE;
}

Volumes::~Volumes()
{
    if (volume_handle != INVALID_HANDLE_VALUE)
    {
        FindVolumeClose(volume_handle);
        volume_handle = INVALID_HANDLE_VALUE;
    }
}

DWORD
Volumes::find(
    _TCHAR *volume_name,
    DWORD length)
{
    DWORD error_code = NO_ERROR;
    if (volume_handle == INVALID_HANDLE_VALUE)
    {
        volume_handle = FindFirstVolume(volume_name, length);
        if (volume_handle == INVALID_HANDLE_VALUE)
        {
            error_code = GetLastError();
        }
    }
    else
    {
        BOOL ok = FindNextVolume(volume_handle, volume_name, length);
        if (!ok)
        {
            error_code = GetLastError();
        }
    }
    return error_code;
}


VolumeMountPoints::VolumeMountPoints(
    _TCHAR *volume_name)
{
    this->volume_name = volume_name;
    drive_mask = 0;
    drive_letter = 0;
    volume_handle = INVALID_HANDLE_VALUE;
    if (volume_name == 0)
    {
        drive_mask = GetLogicalDrives();
        _TCHAR drive_name[4];
        drive_name[0] = _T('a');
        drive_name[1] = _T(':');
        drive_name[2] = _T('\\');
        drive_name[3] = _T('\0');
        DWORD drive_bit = 1;
        while (drive_name[0] <= _T('z'))
        {
            if ((drive_mask & drive_bit) != 0)
            {
                UINT drive_type = GetDriveType(drive_name);
                if (drive_type != DRIVE_FIXED)
                {
                    drive_mask &= ~drive_bit;
                }
            }
            drive_bit <<= 1;
            drive_name[0]++;
        }
        drive_mask <<= 1;
        drive_letter = _T('a') - 1;
    }
}

VolumeMountPoints::~VolumeMountPoints()
{
    if (volume_handle != INVALID_HANDLE_VALUE)
    {
        FindVolumeMountPointClose(volume_handle);
        volume_handle = INVALID_HANDLE_VALUE;
    }
}

DWORD
VolumeMountPoints::find(
    _TCHAR *volume_mount_point,
    DWORD length)
{
    if (volume_name == 0)
    {
        if ((drive_mask & 0xfffffffe) == 0)
        {
            return ERROR_NO_MORE_FILES;
        }
        if (length < 4)
        {
            return ERROR_FILENAME_EXCED_RANGE;
        }
        do
        {
            drive_mask >>= 1;
            drive_letter++;
        } while ((drive_mask & 1) == 0);
        volume_mount_point[0] = drive_letter;
        volume_mount_point[1] = _T(':');
        volume_mount_point[2] = _T('\\');
        volume_mount_point[3] = _T('\0');
        return NO_ERROR;
    }
    else
    {
        if (volume_handle == INVALID_HANDLE_VALUE)
        {
            volume_handle = FindFirstVolumeMountPoint(
                volume_name, volume_mount_point, length);
            if (volume_handle == INVALID_HANDLE_VALUE)
            {
                return GetLastError();
            }
        }
        else
        {
            BOOL ok = FindNextVolumeMountPoint(
                volume_handle, volume_mount_point, length);
            if (!ok)
            {
                return GetLastError();
            }
        }
        return NO_ERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\sisbkup\pool.h ===
/*++

Copyright (c) 1993-1999	Microsoft Corporation

Module Name:

	pool.h

Abstract:

	Fixed size memory allocator headers.

Author:

	Bill Bolosky		[bolosky]		1993

Revision History:

--*/


struct PoolEntry;
struct PoolBlob;

class Pool {
public:
			 Pool(
			    unsigned		 		 objectSize,
			    void * (*allocator)(unsigned) 	= NULL,
			    unsigned				 blobSize = 16334,	// a little under 16K
			    void (*destructor)(void *) 		= NULL);

			 Pool(
			    unsigned		 		 objectSize,
			    void * (*allocator)(void));

			~Pool(void);

    void		 preAllocate(
			    unsigned		 n);

    void		*allocate(void);

    void		 free(
			    void		*object);

    unsigned		 numAllocations(void);

    unsigned		 numFrees(void);

    unsigned		 numNews(void);

    unsigned		 getObjectSize(void);

private:

    PoolEntry		*getEntry(void);

    void		 releaseEntry(
			    PoolEntry		*entry);

    void		 allocateMoreObjects(void);

    unsigned		 objectSize;
    void *(*countAllocator)(unsigned);
    void *(*singleAllocator)(void);
    void  (*destructor)(void *);
    struct PoolEntry	*entries;		// PoolEntries with vaid data attached to them
    struct PoolEntry	*freeEntries;		// PoolEntries without valid data attached to them
    struct PoolBlob	*entriesBlobHead;	// The head of the blob list for PoolEntries
    unsigned		 entriesPerBlob;	// How many entries in an entry blob
    struct PoolBlob	*objectsBlobHead;	// The head of the blob list for the allocated objects
    unsigned		 objectsPerBlob;	// How many objects in an object blob

    unsigned		 allocations;
    unsigned		 frees;
    unsigned		 news;

    unsigned		 numFree;		// Current size of free list
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\sisbkup\avl.h ===
/*++

Copyright (c) 1993-1999	Microsoft Corporation

Module Name:

	avl.h

Abstract:

	AVL tree template class implementation

Author:

	Bill Bolosky		[bolosky]		1993

Revision History:

--*/

enum AVLBalance
{
    AVLNew,			// Not yet inserted in a tree
        AVLLeft,			// Left side is one deeper than the right
        AVLBalanced,		// Left and right sides are evenly balanced
        AVLRight,			// Right side is one deeper than left
};

template<class elementClass> class AVLElement;

template<class elementClass> class AVLTree
{

public:
    AVLTree( 
        unsigned		 preallocateSize = 0 );

    ~AVLTree( void );

    elementClass	*findFirstLessThanOrEqualTo( 
        elementClass		*element );

    elementClass	*findFirstGreaterThan( 
        elementClass	*element );

    elementClass	*findFirstGreaterThanOrEqualTo( 
        elementClass	*element );

    elementClass	*findMin( void );

    elementClass	*findMax( void );

    int			 empty( void );

    unsigned		 size( void );

    void		 check( void );

    BOOLEAN		 insert( 
        elementClass	*element );

    void		 remove( 
        elementClass	*element );

    void		 dumpPoolStats( void );

private:

    AVLElement<elementClass>		*tree;

    Pool		*avlElementPool;

    unsigned		 insertions;
    unsigned		 deletions;
    unsigned		 singleRotations;
    unsigned		 doubleRotations;

    friend class AVLElement<elementClass>;
};


// The AVLElement class would normally be declared in the avl.cpp file, except that because it's
// a template, it needs to be in the header file.  It can only be accessed (including creation and
// destruction) by the AVLTree friend class.

template<class elementClass> class AVLElement
{

private:

    AVLElement( void );

    ~AVLElement( void );

    void		 initialize( void );

    void		 insert( 
        AVLTree<elementClass>		*intoTree,
        elementClass			*element );

    void		 remove( 
        AVLTree<elementClass>		*fromTree );

    unsigned		 checkAndReturnDepth( 
        unsigned				*countedElements );

    int			 inTree( void );

    int			 operator<=(
        AVLElement<elementClass>		*peer);

    int			 operator<(
        AVLElement<elementClass>		*peer);

    int			 operator==(
        AVLElement<elementClass>		*peer);

    int			 operator>=(
        AVLElement<elementClass>		*peer);

    int			 operator>(
        AVLElement<elementClass>		*peer);


    AVLElement<elementClass>
        *findFirstLessThanOrEqualTo( 
        elementClass		*element );

    AVLElement<elementClass>
        *findFirstGreaterThan( 
        elementClass		*element );

    AVLElement<elementClass>
        *findFirstGreaterThanOrEqualTo( 
        elementClass		*element );

    void		 rightAdded( 
        AVLTree<elementClass>	*tree );

    void		 leftAdded( 
        AVLTree<elementClass>	*tree );

    void		 singleRotate( 
        AVLTree<elementClass>	*tree,
        AVLElement<elementClass>	*child,
        AVLBalance			 whichSide );

    void		 doubleRotate( 
        AVLTree<elementClass>	*tree,
        AVLElement<elementClass>	*child,
        AVLElement<elementClass>	*grandchild,
        AVLBalance			 whichSide );

    void		 gotOneShorter( 
        AVLTree<elementClass>	*tree,
        AVLBalance			 whichSide );

    AVLBalance		 balance;

    AVLElement<elementClass>		*left;
    AVLElement<elementClass>		*right;
    AVLElement<elementClass>		*parent;
    elementClass			*element;

    friend class AVLTree<elementClass>;
};

template<class elementClass>  elementClass *
AVLTree<elementClass>::findFirstLessThanOrEqualTo( 
    elementClass			*element )
{
    assert( element );
    if (!tree) 
        return( NULL );

    AVLElement<elementClass> *avlElement = tree->findFirstLessThanOrEqualTo( element );
    if (avlElement) {
        return( avlElement->element );
    } else {
        return( NULL );
    }
}

template<class elementClass>
AVLTree<elementClass>::AVLTree( 
    unsigned		 preallocateSize )
{
    tree = NULL;
    insertions = deletions = singleRotations = doubleRotations = 0;
    avlElementPool = new Pool( sizeof(AVLElement<elementClass>) );
    if (preallocateSize && (NULL != avlElementPool)) {
        avlElementPool->preAllocate( preallocateSize );
    }
}

template<class elementClass> AVLTree<elementClass>::~AVLTree( void )
{
    assert( tree == NULL );

    if (NULL != avlElementPool) {
        delete avlElementPool;
    }
}

//****************************************************************************
//*                                                                          *
//* Function:  findFirstLessThanOrEqualTo                                    *
//*                                                                          *
//* Syntax:    AVLElement * findFirstLessThanOrEqualTo(                      *
//*                         elementClass * element)                          *
//*                                                                          *
//* Input:     elementClass * element:                                       *
//*              A pointer to an element to compare against while searching. *
//*                                                                          *
//* Output:    AVLElement *:                                                 *
//*              The element in the tree that has a value less than or equal *
//*              to the one specified, or NULL on failure.                   *
//*                                                                          *
//* Synopsis:  This function finds the element in the tree that has a value  *
//*            less than or equal to the one specified.                      *
//*                                                                          *
//**************************************************************************** 
template<class elementClass> AVLElement<elementClass> *
AVLElement<elementClass>::findFirstLessThanOrEqualTo( elementClass * element )
{
    AVLElement<elementClass> * retVal = NULL;

    if (*this->element == element) {
        // We have a direct match (equal to).  It takes precidence over the
        // "first less than" part.
        return this;
    }
    if (*this->element < element) {
        // The current element is smaller than the one specified.
        // This might be it, but try to find a bigger one.
        if (right != NULL) {
            retVal = right->findFirstLessThanOrEqualTo( element );
        }

        // If nothing below us (to the right) was found, then we are the
        // next smallest one.
        if (retVal == NULL) {
            return this;
        } else {
            return retVal;
        }
    } else {
        // The current element is bigger than the one specified.
        // We have to find a smaller one.
        if (left != NULL) {
            return left->findFirstLessThanOrEqualTo( element );
        } else {
            return NULL;
        }
    }
}

template<class elementClass> elementClass *
AVLTree<elementClass>::findFirstGreaterThan( 
    elementClass			*element )
{
    assert( element );
    if (!tree) 
        return( NULL );

    AVLElement<elementClass> *avlElement = tree->findFirstGreaterThan( element );

    if (avlElement) {
        return( avlElement->element );
    } else {
        return( NULL );
    }
}

//****************************************************************************
//*                                                                          *
//* Function:  findFirstGreaterThan                                          *
//*                                                                          *
//* Syntax:    AVLElement * findFirstGreaterThan(elementClass * element)     *
//*                                                                          *
//* Input:     elementClass * element:                                       *
//*              A pointer to an element to compare against while searching. *
//*                                                                          *
//* Output:    AVLElement *:                                                 *
//*              The element in the tree that has a vlaue greater than the   *
//*              one specified, or NULL on failure.                          *
//*                                                                          *
//* Synopsis:  This function finds the element in the tree that has a value  *
//*            greater than the one specified.                               *
//*                                                                          *
//**************************************************************************** 
template<class elementClass> AVLElement<elementClass> *
AVLElement<elementClass>::findFirstGreaterThan( elementClass * element )
{
    AVLElement<elementClass> * retVal = NULL;

    if (*this->element > element) {
        // The current element is bigger than the one specified.
        // This might be it, but try to find a smaller one.
        if (left != NULL) {
            retVal = left->findFirstGreaterThan( element );
        }

        // If nothing below us (to the left) was found, then we are the
        // next biggest one.
        if (retVal == NULL) {
            return this;
        } else {
            return retVal;
        }
    } else {
        // The current element is smaller than (or equal) the one specified.
        // We have to find a bigger one.
        if (right != NULL) {
            return right->findFirstGreaterThan( element );
        } else {
            return NULL;
        }
    }
}

template<class elementClass> elementClass *
AVLTree<elementClass>::findFirstGreaterThanOrEqualTo( 
    elementClass			*element )
{
    assert( element );
    if (!tree) 
        return( NULL );

    AVLElement<elementClass> *avlElement = tree->findFirstGreaterThanOrEqualTo( element );

    if (avlElement) {
        return( avlElement->element );
    } else {
        return( NULL );
    }
}

//****************************************************************************
//*                                                                          *
//* Function:  findFirstGreaterThanOrEqualTo                                 *
//*                                                                          *
//* Syntax:    AVLElement * findFirstGreaterThanOrEqualTo(elementClass * element)
//*                                                                          *
//* Input:     elementClass * element:                                       *
//*              A pointer to an element to compare against while searching. *
//*                                                                          *
//* Output:    AVLElement *:                                                 *
//*              The element in the tree that has a vlaue greater than or    *
//*              equal to the one specified, or NULL on failure.             *
//*                                                                          *
//* Synopsis:  This function finds the element in the tree that has a value  *
//*            greater than or equal to the one specified.                   *
//*                                                                          *
//**************************************************************************** 
template<class elementClass> AVLElement<elementClass> *
AVLElement<elementClass>::findFirstGreaterThanOrEqualTo( elementClass * element )
{
    if (*this->element == element) {
        // We have a direct match (equal to).  It takes precidence over the
        // "first less than" part.
        return this;
    }

    AVLElement<elementClass> * retVal = NULL;

    if (*this->element > element) {
        // The current element is bigger than the one specified.
        // This might be it, but try to find a smaller one.
        if (left != NULL) {
            retVal = left->findFirstGreaterThanOrEqualTo( element );
        }

        // If nothing below us (to the left) was found, then we are the
        // next biggest one.
        if (retVal == NULL) {
            return this;
        } else {
            return retVal;
        }
    } else {
        // The current element is strictly smaller than the one specified.
        // We have to find a bigger one.
        if (right != NULL) {
            return right->findFirstGreaterThanOrEqualTo( element );
        } else {
            return NULL;
        }
    }
}

template<class elementClass> int
AVLTree<elementClass>::empty( void )
{
    assert( (tree == NULL) == (insertions == deletions) );
    return( tree == NULL );
}

template<class elementClass> unsigned
AVLTree<elementClass>::size( void )
{
    assert( insertions >= deletions );
    assert( (tree == NULL) == (insertions == deletions) );
    return( insertions - deletions );
}

template<class elementClass> elementClass *
AVLTree<elementClass>::findMin( void )
{
    if (!tree) {
        return( NULL );
    }

    AVLElement<elementClass> *candidate = tree;
    while (candidate->left) {
        assert( *candidate->left->element <= candidate->element );
        candidate = candidate->left;
    }
    return( candidate->element );
}

template<class elementClass> elementClass *
AVLTree<elementClass>::findMax( void )
{
    if (!tree) {
        return( NULL );
    }

    AVLElement<elementClass> *candidate = tree;
    while (candidate->right) {
        assert( *candidate->right->element >= candidate->element );
        candidate = candidate->right;
    }
    return( candidate->element );
}

template<class elementClass> void
AVLTree<elementClass>::check( void )
{
    AVLElement<elementClass> * currElement = NULL;
    AVLElement<elementClass> * nextElement = NULL;
    AVLElement<elementClass> * oldElement = NULL;

    unsigned countedElements = 0;
    if (tree) {
        assert( tree->parent == NULL );
        unsigned overallDepth = tree->checkAndReturnDepth( &countedElements );
    }
    assert( insertions-deletions == countedElements );

    // Check every element in the tree for consistance by verifying that it is in
    // the expected order.  If not, it is most likely that the element's operators
    // are not behaving as needed.
    for(currElement = tree; currElement != NULL; currElement = nextElement) {
        // Go left if we can (and have not already been here).
        if (currElement->left && oldElement == currElement->parent) {
            nextElement = currElement->left;
            assert( *nextElement < currElement && "The < operator appears to be broken" );
            assert( *currElement > nextElement && "The > operator appears to be broken" );
            assert( !(*nextElement == currElement) && "The == operator appears to be broken" );
        }
        // Otherwise go right if we can (and have not already been here).
        else if (currElement->right &&
            (oldElement == currElement->left || oldElement == currElement->parent)) {
            nextElement = currElement->right;
            assert( *nextElement > currElement && "The > operator appears to be broken" );
            assert( *currElement < nextElement && "The < operator appears to be broken" );
            assert( !(*nextElement == currElement) && "The == operator appears to be broken" );
        }
        // We are done below us, go up a node.
        else {
            nextElement = currElement->parent;
        }

        oldElement = currElement;
        assert( *oldElement == currElement && "The == operator appears to be broken" );
    }
}


template<class elementClass>
AVLElement<elementClass>::AVLElement( void )
{
    balance = AVLNew;
    left = right = parent = NULL;
}

template<class elementClass>
AVLElement<elementClass>::~AVLElement( void )
{
    assert( balance == AVLNew );
    assert( left == NULL && right == NULL && parent == NULL );
}

template<class elementClass> unsigned
AVLElement<elementClass>::checkAndReturnDepth( 
    unsigned			*countedElements )
{
    // We've been inserted and not deleted
    assert( balance != AVLNew );

    (*countedElements)++;

    // Assert that the links all match up.
    assert( !left || left->parent == this );
    assert( !right || right->parent == this );

    // The basic binary tree ordering property applies
    assert( !right || *this <= right );
    assert( !left || *this >= left );

    // The AVL balance property applies
    unsigned leftDepth;
    if (left) {
        leftDepth = left->checkAndReturnDepth( countedElements );
    } else {
        leftDepth = 0;
    }

    unsigned rightDepth;
    if (right) {
        rightDepth = right->checkAndReturnDepth( countedElements );
    } else {
        rightDepth = 0;
    }

    if (leftDepth == rightDepth) {
        assert( balance == AVLBalanced );
        return( leftDepth + 1 );
    }

    if (leftDepth == rightDepth + 1) {
        assert( balance == AVLLeft );
        return( leftDepth + 1 );
    }

    if (leftDepth + 1 == rightDepth) {
        assert( balance == AVLRight );
        return( rightDepth + 1 );
    }

    assert( !"AVL Tree out of balance" );
    return( 0 );
}

template<class elementClass> void
AVLElement<elementClass>::insert( 
    AVLTree<elementClass>		*intoTree,
    elementClass			*element )
{
    assert( intoTree );
    assert( left == NULL && right == NULL && parent == NULL );

    this->element = element;
    assert( this->element );

    intoTree->insertions++;

    // Special case the empty tree case.
    if (intoTree->tree == NULL) {
        intoTree->tree = this;
        balance = AVLBalanced;
        // We already know all of the links are NULL, which is correct for this case.
        return;
    }

    // Find the leaf position at which to do this insertion.

    AVLElement *currentNode = intoTree->tree;
    AVLElement *previousNode = NULL;
    while (currentNode) {
        previousNode = currentNode;
        if (*currentNode < this) {
            currentNode = currentNode->right;
        } else if (*currentNode > this) {
            currentNode = currentNode->left;
        } else {
            // An AVL tree gets all whacky if you try to insert duplicate values.
            assert( !"Trying to insert a duplicate item.  Use something other than an AVL tree." );
        }
    }

    balance = AVLBalanced;
    parent = previousNode;
    assert( parent );
    if (*previousNode <= this) {
        assert( !previousNode->right );
        previousNode->right = this;
        previousNode->rightAdded( intoTree );
        //	intoTree->check();
    } else {
        assert( !previousNode->left );
        previousNode->left = this;
        previousNode->leftAdded( intoTree );
        //	intoTree->check();
    }
}

template<class elementClass> void
AVLElement<elementClass>::rightAdded( 
    AVLTree<elementClass>	*tree )
{
    //We've just gotten one deeper on our right side.
    assert( balance != AVLNew );

    if (balance == AVLLeft) {
        balance = AVLBalanced;
        // The depth of the subtree rooted here hasn't changed, we're done
        return;
    }
    if (balance == AVLBalanced) {
        // We've just gotten one deeper, but are still balanced.  Update and recurse up the
        // tree.
        balance = AVLRight;
        if (parent) {
            if (parent->right == this) {
                parent->rightAdded( tree );
            } else {
                assert( parent->left == this );
                parent->leftAdded( tree );
            }
        }
        return;
    }
    assert( balance == AVLRight );
    // We've just gone to double right (ie, out of balance).
    assert( right );
    if (right->balance == AVLRight) {
        singleRotate( tree,right,AVLRight );
    } else {
        assert( right->balance == AVLLeft );	// Else we shouldn't have been AVLRight before the call
        doubleRotate( tree,right,right->left,AVLRight );
    }
}

template<class elementClass> void
AVLElement<elementClass>::leftAdded( 
    AVLTree<elementClass>	*tree )
{
    //We've just gotten one deeper on our right side.
    assert( balance != AVLNew );

    if (balance == AVLRight) {
        balance = AVLBalanced;
        // The depth of the subtree rooted here hasn't changed, we're done
        return;
    }
    if (balance == AVLBalanced) {
        // We've just gotten one deeper, but are still balanced.  Update and recurse up the
        // tree.
        balance = AVLLeft;
        if (parent) {
            if (parent->right == this) {
                parent->rightAdded( tree );
            } else {
                assert( parent->left == this );
                parent->leftAdded( tree );
            }
        }
        return;
    }
    assert( balance == AVLLeft );
    // We've just gone to double left (ie, out of balance).
    assert( left );
    if (left->balance == AVLLeft) {
        singleRotate( tree,left,AVLLeft );
    } else {
        assert( left->balance == AVLRight );	// Else we shouldn't have been AVLLeft before the call
        doubleRotate( tree,left,left->right,AVLLeft );
    }
}

template<class elementClass> void
AVLElement<elementClass>::singleRotate( 
    AVLTree<elementClass>	*tree,
    AVLElement			*child,
    AVLBalance			 whichSide )
{
    // We're the parent node.

    assert( tree );
    assert( child );
    assert( whichSide == AVLRight || whichSide == AVLLeft );

    assert( whichSide != AVLRight || right == child );
    assert( whichSide != AVLLeft || left == child );

    tree->singleRotations++;

    // Promote the child to our position in the tree.

    if (parent) {
        if (parent->left == this) {
            parent->left = child;
            child->parent = parent;
        } else {
            assert( parent->right == this );
            parent->right = child;
            child->parent = parent;
        }
    } else {
        // We're the root of the tree
        assert( tree->tree == this );
        tree->tree = child;
        child->parent = NULL;
    }

    // Attach the child's light subtree to our heavy side (ie., where the child is attached now)
    // Then, attach us to the child's light subtree
    if (whichSide == AVLRight) {
        right = child->left;
        if (right) {
            right->parent = this;
        }

        child->left = this;
        parent = child;
    } else {
        left = child->right;
        if (left) {
            left->parent = this;
        }

        child->right = this;
        parent = child;
    }

    // Finally, now both our and our (former) child's balance is "balanced"
    balance = AVLBalanced;
    child->balance = AVLBalanced;
    // NB. One of the cases in delete will result in the above balance settings being incorrect.  That
    // case fixes up the settings after we return.
}

template<class elementClass> void
AVLElement<elementClass>::doubleRotate( 
    AVLTree<elementClass>	*tree,
    AVLElement			*child,
    AVLElement			*grandchild,
    AVLBalance			 whichSide )
{
    assert( tree && child && grandchild );
    assert( whichSide == AVLLeft || whichSide == AVLRight );

    assert( whichSide != AVLLeft || (left == child && child->balance == AVLRight) );
    assert( whichSide != AVLRight || (right == child && child->balance == AVLLeft) );

    assert( child->parent == this );
    assert( grandchild->parent == child );

    tree->doubleRotations++;

    // Write down a copy of all of the subtrees; see Knuth v3 p454 for the picture.
    // NOTE: The alpha and delta trees are never moved, so we don't store them.
    AVLElement *beta;
    AVLElement *gamma;

    if (whichSide == AVLRight) {
        beta = grandchild->left;
        gamma = grandchild->right;
    } else {
        beta = grandchild->right;
        gamma = grandchild->left;
    }

    // Promote grandchild to our position
    if (parent) {
        if (parent->left == this) {
            parent->left = grandchild;
        } else {
            assert( parent->right == this );
            parent->right = grandchild;
        }
    } else {
        assert( tree->tree == this );
        tree->tree = grandchild;
    }
    grandchild->parent = parent;

    // Attach the appropriate children to grandchild
    if (whichSide == AVLRight) {
        grandchild->right = child;
        grandchild->left = this;
    } else {
        grandchild->right = this;
        grandchild->left = child;
    }
    parent = grandchild;
    child->parent = grandchild;

    // Attach beta and gamma to us and child.
    if (whichSide == AVLRight) {
        right = beta;
        if (beta) {
            beta->parent = this;
        }
        child->left = gamma;
        if (gamma) {
            gamma->parent = child;
        }
    } else {
        left = beta;
        if (beta) {
            beta->parent = this;
        }
        child->right = gamma;
        if (gamma) {
            gamma->parent = child;
        }
    }

    // Now update the balance fields.
    switch (grandchild->balance) {
        case AVLLeft:
            if (whichSide == AVLRight) {
                balance = AVLBalanced;
                child->balance = AVLRight;
            } else {
                balance = AVLRight;
                child->balance = AVLBalanced;
            }
            break;

        case  AVLBalanced:
            balance = AVLBalanced;
            child->balance = AVLBalanced;
            break;

        case AVLRight:
            if (whichSide == AVLRight) {
                balance = AVLLeft;
                child->balance = AVLBalanced;
            } else {
                balance = AVLBalanced;
                child->balance = AVLLeft;
            }
            break;

        default:
            assert( !"Bogus balance value" );
    }
    grandchild->balance = AVLBalanced;
}

template<class elementClass> void
AVLElement<elementClass>::remove( 
    AVLTree<elementClass>	*fromTree )
{
    assert( fromTree );
    assert( balance == AVLRight || balance == AVLLeft || balance == AVLBalanced );

    fromTree->deletions++;

    if (left == NULL) {
        // The right child either doesn't exist or is a leaf (because of the AVL balance property)
        assert( (!right && balance == AVLBalanced) ||
            (balance == AVLRight && right->balance == AVLBalanced && right->right == NULL && right->left == NULL) );
        if (right) {
            right->parent = parent;
        }
        if (parent) {
            if (parent->left == this) {
                parent->left = right;
                parent->gotOneShorter( fromTree,AVLLeft );
            } else {
                assert( parent->right == this );
                parent->right = right;
                parent->gotOneShorter( fromTree,AVLRight );
            }
        } else {
            assert( fromTree->tree == this );
            fromTree->tree = right;
        }
    } else if (right == NULL) {
        // The left child must be a left because of the AVL balance property
        assert( left && balance == AVLLeft && left->balance == AVLBalanced && left->right == NULL && left->left == NULL );
        left->parent = parent;
        if (parent) {
            if (parent->left == this) {
                parent->left = left;
                parent->gotOneShorter( fromTree,AVLLeft );
            } else {
                assert( parent->right == this );
                parent->right = left;
                parent->gotOneShorter( fromTree,AVLRight );
            }
        } else {
            assert( fromTree->tree == this );
            fromTree->tree = left;
        }
    } else {
        // Find the symmetric successor and promote it.  The symmetric successor is the smallest element in the right
        // subtree; it's found by following all left links in the right subtree until we find a node with no left link.
        // That node may be promoted to the place of this without corrupting the binary tree ordering properties. (We could
        // just as easily use the symmetric predecessor by finding the largest element in the right subtree, but there's
        // no point.)

        AVLElement *successorCandidate = right;
        while (successorCandidate->left) {
            successorCandidate = successorCandidate->left;
        }

        AVLElement *shorterRoot;
        AVLBalance shorterSide;
        if (successorCandidate->parent->left == successorCandidate) {
            // We need to promote the successor's child (if any) to its position, then
            // promote it to our position.
            shorterRoot = successorCandidate->parent;
            shorterSide = AVLLeft;
            successorCandidate->parent->left = successorCandidate->right;
            if (successorCandidate->right) {
                successorCandidate->right->parent = successorCandidate->parent;
            }

            successorCandidate->right = right;
            successorCandidate->left = left;
            successorCandidate->balance = balance;
            successorCandidate->right->parent = successorCandidate;
            successorCandidate->left->parent = successorCandidate;
            if (parent) {
                if (parent->left == this) {
                    parent->left = successorCandidate;
                } else {
                    assert( parent->right == this );
                    parent->right = successorCandidate;
                }
            } else {
                assert( fromTree->tree == this );
                fromTree->tree = successorCandidate;
            }
            successorCandidate->parent = parent;
        } else {
            // The successor was our child, just directly promote it.
            assert( successorCandidate->parent == this );
            if (parent) {
                if (parent->right == this) {
                    parent->right = successorCandidate;
                } else {
                    assert( parent->left == this );
                    parent->left = successorCandidate;
                }
            } else {
                assert( fromTree->tree == this );
                fromTree->tree = successorCandidate;
            }
            successorCandidate->parent = parent;
            successorCandidate->left = left;
            if (left) {
                left->parent = successorCandidate;
            }
            // We just made our right subtree shorter.
            successorCandidate->balance = balance;
            shorterRoot = successorCandidate;
            shorterSide = AVLRight;
        }
        if (shorterRoot) {
            shorterRoot->gotOneShorter( fromTree,shorterSide );
        }
    }

    balance = AVLNew;
    left = right = parent = NULL;
    element = NULL;
    //    fromTree->check();
}

template<class elementClass> void
AVLElement<elementClass>::gotOneShorter( 
    AVLTree<elementClass>	*tree,
    AVLBalance			 whichSide )
{
    assert( whichSide == AVLLeft || whichSide == AVLRight );

    if (balance == AVLBalanced) {
        // We've just shrunk one subttree, but our depth has stayed the same.
        // Reset our balance indicator and punt.
        if (whichSide == AVLRight) {
            balance = AVLLeft;
        } else {
            balance = AVLRight;
        }
        return;
    } else if (balance == whichSide) {
        // We just shrunk our heavy side; set our balance to neutral and recurse up the tree
        balance = AVLBalanced;
        if (parent) {
            if (parent->right == this) {
                parent->gotOneShorter( tree,AVLRight );
            } else {
                assert( parent->left == this );
                parent->gotOneShorter( tree,AVLLeft );
            }
        } // else we were the root; we're done
        return;
    } else {
        // We've just gone out of balance.  Figure out a rotation to do.  This is almost like having added a
        // node to the opposide side, except that the opposite side might be balanced.
        AVLBalance heavySide;
        AVLElement *heavyChild;
        AVLElement *replacement;
        if (whichSide == AVLRight) {
            heavySide = AVLLeft;
            heavyChild = left;
        } else {
            heavySide = AVLRight;
            heavyChild = right;
        }
        assert( heavyChild );
        if (heavyChild->balance == heavySide) {
            // Typical single rotation case
            singleRotate( tree,heavyChild,heavySide );
            replacement = heavyChild;
        } else if (heavyChild->balance == whichSide) {
            // Typical double rotation case
            AVLElement *grandchild;
            if (heavySide == AVLRight) {
                grandchild = heavyChild->left;
            } else {
                grandchild = heavyChild->right;
            }
            doubleRotate( tree,heavyChild,grandchild,heavySide );
            replacement = grandchild;
        } else {
            assert( heavyChild->balance == AVLBalanced );
            singleRotate( tree,heavyChild,heavySide );
            // singleRotate has incorrectly set the balances; reset them
            balance = heavySide;
            heavyChild->balance = whichSide;
            // Overall depth hasn't changed; we're done.
            return;
        }

        // NB: we have now changed position in the tree, so parent, right & left have changed!
        if (!replacement->parent) {
            // We just promoted our replacement to the root; we be done
            return;
        }
        if (replacement->parent->right == replacement) {
            replacement->parent->gotOneShorter( tree,AVLRight );
        } else {
            assert( replacement->parent->left == replacement );
            replacement->parent->gotOneShorter( tree,AVLLeft );
        }


    }
}

template<class elementClass> int
AVLElement<elementClass>::inTree( void )
{
    return( balance != AVLNew );
}

template <class elementClass> int
AVLElement<elementClass>::operator<=(
AVLElement<elementClass>		*peer)
{
    return( *element <= peer->element );
}

template <class elementClass> int
AVLElement<elementClass>::operator<(
AVLElement<elementClass>		*peer)
{
    return( *element < peer->element );
}

template <class elementClass> int
AVLElement<elementClass>::operator==(
AVLElement<elementClass>		*peer)
{
    return( *element == peer->element );
}

template <class elementClass> int
AVLElement<elementClass>::operator>=(
AVLElement<elementClass>		*peer)
{
    return( *element >= peer->element );
}

template <class elementClass> int
AVLElement<elementClass>::operator>(
AVLElement<elementClass>		*peer)
{
    return( *element > peer->element );
}

template <class elementClass> BOOLEAN
AVLTree<elementClass>::insert( 
    elementClass	*element )
{
    if (NULL == avlElementPool) {
        return FALSE;
    }

    assert( element );
    AVLElement<elementClass> *avlElement = (AVLElement<elementClass> *)avlElementPool->allocate( );
    if (NULL == avlElement) {
        return FALSE;
    }

    avlElement->initialize( );
    avlElement->insert( this,element );

    return TRUE;
}

template <class elementClass> void
AVLTree<elementClass>::remove( 
    elementClass	*element )
{
    assert( element );
    AVLElement<elementClass> *candidate = tree->findFirstLessThanOrEqualTo( element );
    assert( candidate && *candidate->element == element );
    candidate->remove( this );
    assert( avlElementPool );	// if this isn't true, then we could never have had a successful insert
    avlElementPool->free( (void *)candidate );
}

template <class elementClass> void
AVLElement<elementClass>::initialize( void )
{
    balance = AVLNew;
    left = right = parent = NULL;
    element = NULL;
}

template <class elementClass> void
AVLTree<elementClass>::dumpPoolStats( void )
{
    if (NULL == avlElementPool) {
        DbgPrint( "Unable to allocate avlElementPool; this AVL tree is essentially useless\n" );
    } else {
        DbgPrint( "AVLTree AVLElement pool: %d allocations, %d frees, %d news, objectSize %d\n",
            avlElementPool->numAllocations( ),
            avlElementPool->numFrees( ),
            avlElementPool->numNews( ),
            avlElementPool->getObjectSize( ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\sisbkup\sibp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sibp.h

Abstract:

    Internal headers for the SIS Backup dll.

Author:

    Bill Bolosky        [bolosky]       March 1998

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>

#include <windows.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <rpc.h>

#include "assert.h"
#include "sisbkup.h"
#include "..\filter\sis.h"
#include "pool.h"
#include "avl.h"



LONG
CsidCompare(
    IN PCSID                id1,
    IN PCSID                id2);

class BackupFileEntry {
    public:
                        BackupFileEntry(void) {}

                        ~BackupFileEntry(void) {}

    int                  operator<=(
                        BackupFileEntry     *peer)
                        {
                            return(CsidCompare(&CSid,&peer->CSid) <= 0);
                        }

    int                  operator<(
                        BackupFileEntry     *peer)
                        {
                            return(CsidCompare(&CSid,&peer->CSid) < 0);
                        }

    int                  operator==(
                        BackupFileEntry     *peer)
                        {
                            return(CsidCompare(&CSid,&peer->CSid) == 0);
                        }

    int                  operator>=(
                        BackupFileEntry     *peer)
                        {
                            return(CsidCompare(&CSid,&peer->CSid) >= 0);
                        }

    int                  operator>(
                        BackupFileEntry     *peer)
                        {
                            return(CsidCompare(&CSid,&peer->CSid) > 0);
                        }

    //
    // The index of the common store file.
    //
    CSID                CSid;

    PVOID               callerContext;
};

typedef struct _SIB_BACKUP_VOLUME_STRUCTURE {
    AVLTree<BackupFileEntry>                    *linkTree;

    PWCHAR                                      volumeRoot;

    CRITICAL_SECTION                            criticalSection[1];
} SIB_BACKUP_VOLUME_STRUCTURE, *PSIB_BACKUP_VOLUME_STRUCTURE;

struct PendingRestoredFile {
    PWCHAR                              fileName;

    LONGLONG                            CSFileChecksum;

    struct PendingRestoredFile          *next;
};


class RestoreFileEntry {
    public:
                        RestoreFileEntry(void) {}

                        ~RestoreFileEntry(void) {}

    int                  operator<=(
                        RestoreFileEntry        *peer)
                        {
                            return(CsidCompare(&CSid,&peer->CSid) <= 0);
                        }

    int                  operator<(
                        RestoreFileEntry        *peer)
                        {
                            return(CsidCompare(&CSid,&peer->CSid) < 0);
                        }

    int                  operator==(
                        RestoreFileEntry        *peer)
                        {
                            return(CsidCompare(&CSid,&peer->CSid) == 0);
                        }

    int                  operator>=(
                        RestoreFileEntry        *peer)
                        {
                            return(CsidCompare(&CSid,&peer->CSid) >= 0);
                        }

    int                  operator>(
                        RestoreFileEntry        *peer)
                        {
                            return(CsidCompare(&CSid,&peer->CSid) > 0);
                        }

    //
    // The index of the common store file.
    //
    CSID                CSid;

    //
    // The various files that have been restored that point at this CS file.
    //
    PendingRestoredFile *files;

};

typedef struct _SIB_RESTORE_VOLUME_STRUCTURE {
    AVLTree<RestoreFileEntry>                   *linkTree;

    PWCHAR                                      volumeRoot;

    CRITICAL_SECTION                            criticalSection[1];

    //
    // The sector size for this volume.
    //
    ULONG               VolumeSectorSize;

    //
    // A sector buffer to hold the backpointer stream data.
    //
    PSIS_BACKPOINTER    sector;

    //
    // An aligned sector buffer to use in extending ValidDataLength.
    //
    PVOID               alignedSectorBuffer;
    PVOID               alignedSector;

    //
    // If we're restoring SIS links, we need to assure that this is
    // a SIS enabled volume.  We do this check only once we've restored
    // a link.
    //
    BOOLEAN             checkedForSISEnabledVolume;
    BOOLEAN             isSISEnabledVolume;

} SIB_RESTORE_VOLUME_STRUCTURE, *PSIB_RESTORE_VOLUME_STRUCTURE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\groveler\utility.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    utilities.cpp

Abstract:

    SIS Groveler utility functions

Authors:

    Cedric Krumbein, 1998

Environment:

    User Mode

Revision History:

--*/

#include "all.hxx"

//
//  Remove a trailing slash if it exists from the given name
//

void TrimTrailingChar(
    PWCHAR name,
    WCHAR ch)
{
    int slen = wcslen(name);

    if ((slen > 0) && (name[slen-1] == ch))
        name[slen-1] = 0;
}


/*****************************************************************************/

// GetPerformanceTime() converts the time interval
// measured using QueryPerformanceCounter() into milliseconds.

PerfTime GetPerformanceTime()
{
    LARGE_INTEGER count;
    QueryPerformanceCounter(&count);
    return (PerfTime)count.QuadPart;
}

/*****************************************************************************/

// PerformanceTimeToMSec() converts the time interval measured
// using QueryPerformanceCounter() into milliseconds.
// PerformanceTimeToUSec() converts it into microseconds.

static DOUBLE frequency = 0.0;

DWORD PerformanceTimeToMSec(PerfTime timeInterval)
{
    if (frequency == 0.0) {
        LARGE_INTEGER intFreq;
        QueryPerformanceFrequency(&intFreq);
        frequency = (DOUBLE)intFreq.QuadPart;
    }

    return (DWORD)((DOUBLE)timeInterval * 1000.0 / frequency);
}

LONGLONG PerformanceTimeToUSec(PerfTime timeInterval)
{
    if (frequency == 0.0) {
        LARGE_INTEGER intFreq;
        QueryPerformanceFrequency(&intFreq);
        frequency = (DOUBLE)intFreq.QuadPart;
    }

    return (LONGLONG)((DOUBLE)timeInterval * 1000000.0 / frequency);
}

/*****************************************************************************/

// GetTime() returns the current file time.

DWORDLONG GetTime()
{
    SYSTEMTIME systemTime;

    FILETIME fileTime;

    ULARGE_INTEGER time;

    BOOL success;

    GetSystemTime(&systemTime);

    success = SystemTimeToFileTime(&systemTime, &fileTime);
    ASSERT_ERROR(success);

    time.HighPart = fileTime.dwHighDateTime;
    time.LowPart  = fileTime.dwLowDateTime;

    return time.QuadPart;
}

/*****************************************************************************/

// PrintTime() converts the supplied file time into a printable string.

TCHAR *PrintTime(
    TCHAR    *string,
    DWORDLONG time)
{
    FILETIME fileTime;

    SYSTEMTIME systemTime;

    DWORD strLen;

    BOOL success;

    fileTime.dwHighDateTime = ((ULARGE_INTEGER *)&time)->HighPart;
    fileTime.dwLowDateTime  = ((ULARGE_INTEGER *)&time)->LowPart;

    success = FileTimeToSystemTime(&fileTime, &systemTime);
    ASSERT_ERROR(success);

    strLen = _stprintf(string, _T("%02hu/%02hu/%02hu %02hu:%02hu:%02hu.%03hu"),
        systemTime.wYear % 100,
        systemTime.wMonth,
        systemTime.wDay,
        systemTime.wHour,
        systemTime.wMinute,
        systemTime.wSecond,
        systemTime.wMilliseconds);
    ASSERT(strLen == 21);

    return string;
}

/*****************************************************************************/

// GetParentName() extracts the parent directory
// name out of a full-path file name.

BOOL GetParentName(
    const TCHAR *fileName,
    TFileName   *parentName)
{
    DWORD hi, lo;

    ASSERT(fileName   != NULL);
    ASSERT(parentName != NULL);

    if (fileName[0] == _T('\\'))
        lo = 1;
    else if (_istalpha(fileName[0])
          && fileName[1] == _T(':')
          && fileName[2] == _T('\\'))
        lo = 3;
    else
        return FALSE;

    hi = _tcslen(fileName) - 1;
    if (hi < lo)
        hi = lo;
    else
        for (; hi > lo; hi--)
            if (fileName[hi] == _T('\\'))
                break;

    parentName->assign(fileName, hi);
    return TRUE;
}

/*****************************************************************************/

// GetFileID gets the file's ID given its name.

DWORDLONG GetFileID(
    const TCHAR *volName,
    const TCHAR *fileName)
{
    HANDLE fileHandle;
    TCHAR *fname = NULL;
    BOOL freeFname = FALSE;
    BY_HANDLE_FILE_INFORMATION fileInfo;
    ULARGE_INTEGER fileID;

    ASSERT(fileName != NULL && fileName[0] != _T('\0'));

    if (volName) {

        DWORD bfsz = wcslen(volName) + wcslen(fileName) + 1;
        fname = new WCHAR[bfsz];
        (void)StringCchCopy(fname,bfsz,volName);
        (void)StringCchCat(fname,bfsz,fileName);
        freeFname = TRUE;
    } else {
        fname = (TCHAR *)fileName;
    }

    __try {

        fileHandle = CreateFile(
            fname,
            0,
            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS,
            NULL);

        if (fileHandle == INVALID_HANDLE_VALUE) {
            fileID.QuadPart = 0;
            __leave;
        }

        if (GetFileInformationByHandle(fileHandle, &fileInfo)) {

            fileID.HighPart = fileInfo.nFileIndexHigh;
            fileID.LowPart  = fileInfo.nFileIndexLow;

        } else {

            fileID.QuadPart = 0;
        }

        CloseHandle(fileHandle);

    } __finally {

        if (freeFname) {

            delete[] fname;
        }
    }
    return fileID.QuadPart;
}

/*****************************************************************************/

// GetFileName gets the file's name given either
// an open handle to the file or the file's ID.

BOOL GetFileName(
    HANDLE     fileHandle,
    TFileName *tFileName)
{
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS ntStatus;

    for (int i = 2; i > 0; --i) {

        if (tFileName->nameLenMax < 8)              // sanity check
            tFileName->resize();

        ntStatus = NtQueryInformationFile(
                        fileHandle,
                        &ioStatusBlock,
                        tFileName->nameInfo,
                        tFileName->nameInfoSize,
                        FileNameInformation);

        if (ntStatus != STATUS_BUFFER_OVERFLOW)
            break;

        ASSERT(tFileName->nameInfo->FileNameLength > tFileName->nameInfoSize - sizeof(ULONG));

        tFileName->resize(tFileName->nameInfo->FileNameLength / sizeof(WCHAR) + 1);

    }

    if (ntStatus != STATUS_SUCCESS)
        return FALSE;

    tFileName->nameLen = tFileName->nameInfo->FileNameLength / sizeof(WCHAR);
    tFileName->name[tFileName->nameLen] = _T('\0');

    return TRUE;
}

BOOL GetFileName(
    HANDLE     volumeHandle,
    DWORDLONG  fileID,
    TFileName *tFileName)
{
    UNICODE_STRING fileIDString;

    OBJECT_ATTRIBUTES objectAttributes;

    IO_STATUS_BLOCK ioStatusBlock;

    HANDLE fileHandle;

    NTSTATUS ntStatus;

    BOOL success;

    fileIDString.Length        = sizeof(DWORDLONG);
    fileIDString.MaximumLength = sizeof(DWORDLONG);
    fileIDString.Buffer        = (WCHAR *)&fileID;

    objectAttributes.Length                   = sizeof(OBJECT_ATTRIBUTES);
    objectAttributes.RootDirectory            = volumeHandle;
    objectAttributes.ObjectName               = &fileIDString;
    objectAttributes.Attributes               = OBJ_CASE_INSENSITIVE;
    objectAttributes.SecurityDescriptor       = NULL;
    objectAttributes.SecurityQualityOfService = NULL;

    ntStatus = NtCreateFile(
        &fileHandle,
        GENERIC_READ,
        &objectAttributes,
        &ioStatusBlock,
        NULL,
        0,
        FILE_SHARE_VALID_FLAGS,
        FILE_OPEN,
        FILE_OPEN_BY_FILE_ID    |
        FILE_OPEN_REPARSE_POINT |
        FILE_NO_INTERMEDIATE_BUFFERING,
        NULL,
        0);
    if (ntStatus != STATUS_SUCCESS)
        return FALSE;

    success = GetFileName(fileHandle, tFileName);
    NtClose(fileHandle);
    return success;
}

/*****************************************************************************/

// GetCSIndex() returns the SIS reparse point's common store
// index. The file handle must point to an open reparse point.

BOOL GetCSIndex(
    HANDLE fileHandle,
    CSID  *csIndex)
{
    IO_STATUS_BLOCK ioStatusBlock;

    BYTE buffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];

    REPARSE_DATA_BUFFER *reparseBuffer;

    SI_REPARSE_BUFFER *sisReparseBuffer;

    ASSERT(fileHandle != NULL);
    ASSERT(csIndex    != NULL);

    if (NtFsControlFile(
        fileHandle,
        NULL,
        NULL,
        NULL,
        &ioStatusBlock,
        FSCTL_GET_REPARSE_POINT,
        NULL,
        0,
        buffer,
        MAXIMUM_REPARSE_DATA_BUFFER_SIZE) != STATUS_SUCCESS) {
        memset(csIndex, 0, sizeof(CSID));
        return FALSE;
    }

    reparseBuffer = (REPARSE_DATA_BUFFER *)buffer;
    if (reparseBuffer->ReparseTag != IO_REPARSE_TAG_SIS) {
        memset(csIndex, 0, sizeof(CSID));
        return FALSE;
    }

    sisReparseBuffer = (SI_REPARSE_BUFFER *)
        reparseBuffer->GenericReparseBuffer.DataBuffer;

    if (sisReparseBuffer->ReparsePointFormatVersion != SIS_REPARSE_BUFFER_FORMAT_VERSION) {
        memset(csIndex, 0, sizeof(CSID));
        return FALSE;
    }

    *csIndex = sisReparseBuffer->CSid;
    return TRUE;
}

/*****************************************************************************/

// GetCSName() converts the common store
// index into a dynamically allocated string.

TCHAR *GetCSName(CSID *csIndex)
{
    TCHAR *rpcStr;

    RPC_STATUS rpcStatus;

    ASSERT(csIndex != NULL);

    rpcStatus = UuidToString(csIndex, (unsigned short **)&rpcStr);
    if (rpcStatus != RPC_S_OK) {
        ASSERT(rpcStr == NULL);
        return NULL;
    }

    ASSERT(rpcStr != NULL);
    return rpcStr;
}

/*****************************************************************************/

// FreeCSName frees the string allocated by GetCSName().

VOID FreeCSName(TCHAR *rpcStr)
{
    RPC_STATUS rpcStatus;

    ASSERT(rpcStr != NULL);

    rpcStatus = RpcStringFree((unsigned short **)&rpcStr);
    ASSERT(rpcStatus == RPC_S_OK);
}

/*****************************************************************************/

// Checksum() generates a checksum on the data supplied in the buffer.
// The checksum function used is selected at compile-time; currently
// the 131-hash and the "Bill 32" hash functions are implemented.

#define HASH131
// #define BILL32HASH

Signature Checksum(
    const VOID *buffer,
    DWORD       bufferLen,
    DWORDLONG   offset,
    Signature   firstWord)
{
    Signature *bufferPtr,
               word,
               signature;

    DWORD numWords,
          numBytes,
          rotate;

    ASSERT(buffer != NULL);

    bufferPtr = (Signature *)buffer;
    numWords  = bufferLen / sizeof(Signature);
    numBytes  = bufferLen % sizeof(Signature);
    signature = firstWord;

#ifdef BILL32HASH
    rotate = (DWORD)(offset / sizeof(Signature) % (sizeof(Signature)*8-1));
#endif

    while (numWords-- > 0) {
        word       = *bufferPtr++;
#ifdef HASH131
        signature  = signature * 131 + word;
#endif
#ifdef BILL32HASH
        signature ^= ROTATE_RIGHT(word, rotate);
        rotate     = (rotate+1) % (sizeof(Signature)*8-1);
#endif
    }

    if (numBytes > 0) {
        word       = 0;
        memcpy(&word, bufferPtr, numBytes);
#ifdef HASH131
        signature  = signature * 131 + word;
#endif
#ifdef BILL32HASH
        signature ^= ROTATE_RIGHT(word, rotate);
#endif
    }

    return signature;
}

/*****************************************************************************/
/************************ Table class private methods ************************/
/*****************************************************************************/

DWORD Table::Hash(
    const VOID *key,
    DWORD       keyLen) const
{
    USHORT *keyPtr;

    DWORD hashValue;

    if (keyLen == 0)
        return 0;

    ASSERT(key != NULL);

    if (keyLen <= sizeof(DWORD)) {
        hashValue = 0;
        memcpy(&hashValue, key, keyLen);
        return hashValue;
    }

    keyPtr    = (USHORT *)key;
    hashValue = 0;

    while (keyLen >= sizeof(USHORT)) {
        hashValue = hashValue*37 + (DWORD)*keyPtr++;
        keyLen   -= sizeof(USHORT);
    }

    if (keyLen > 0)
        hashValue = hashValue*37 + (DWORD)*(BYTE *)keyPtr;

    hashValue *= TABLE_RANDOM_CONSTANT;
    if ((LONG)hashValue < 0)
        hashValue = (DWORD)-(LONG)hashValue;
    hashValue %= TABLE_RANDOM_PRIME;

    return hashValue;
}

/*****************************************************************************/

DWORD Table::BucketNum(DWORD hashValue) const
{
    DWORD bucketNum;

    ASSERT(expandIndex <   1U << level);
    ASSERT(numBuckets  == (1U << level) + expandIndex);

    bucketNum = hashValue & ~(~0U << level);
    if (bucketNum < expandIndex)
        bucketNum = hashValue & ~(~0U << (level+1));

    ASSERT(bucketNum < numBuckets);

    return bucketNum;
}

/*****************************************************************************/

VOID Table::Expand()
{
    TableEntry **oldSlotAddr,
               **newSlotAddr,
                *oldChain,
                *newChain,
                *entry;

    TableSegment **newDirectory,
                  *newSegment;

    DWORD oldNewMask;

#if DBG
    TableEntry *prevChain;
    DWORD       mask;
#endif

// Increase the directory size if necessary.

    ASSERT(directory != NULL);
    ASSERT(dirSize >= TABLE_SEGMENT_SIZE);
    ASSERT(dirSize %  TABLE_SEGMENT_SIZE == 0);

    if (numBuckets >= dirSize * TABLE_SEGMENT_SIZE) {
        newDirectory = new TableSegment * [dirSize + TABLE_DIR_SIZE];
        ASSERT(newDirectory != NULL);
        memcpy(newDirectory, directory, sizeof(TableSegment *) * dirSize);
        memset(newDirectory+dirSize, 0, sizeof(TableSegment *) * TABLE_DIR_SIZE);
        dirSize += TABLE_DIR_SIZE;
        delete directory;
        directory = newDirectory;
    }

// Find the old bucket to be expanded.

    ASSERT(expandIndex >> TABLE_SEGMENT_BITS < dirSize);

    oldSlotAddr = &directory[expandIndex >> TABLE_SEGMENT_BITS]
                      ->slot[expandIndex &  TABLE_SEGMENT_MASK];

    ASSERT(oldSlotAddr != NULL);

// Find the new bucket, and create a new segment if necessary.

    ASSERT(numBuckets >> TABLE_SEGMENT_BITS < dirSize);

    newSegment = directory[numBuckets >> TABLE_SEGMENT_BITS];

    if (newSegment == NULL) {
        newSegment = new TableSegment;
        ASSERT(newSegment != NULL);
        memset(newSegment, 0, sizeof(TableSegment));
        directory[numBuckets >> TABLE_SEGMENT_BITS] = newSegment;
    }

    newSlotAddr = &newSegment->slot[numBuckets & TABLE_SEGMENT_MASK];

    ASSERT(*newSlotAddr == NULL);

// Relocate entries from the old to the new bucket.

    oldNewMask = 1U << level;
    oldChain   = NULL;
    newChain   = NULL;
    entry      = *oldSlotAddr;

#if DBG
    prevChain = NULL;
    mask      = ~(~0U << (level+1));
#endif

    while (entry != NULL) {
        ASSERT((entry->hashValue & ~(~0U << level)) == expandIndex);
        ASSERT( entry->prevChain == prevChain);

// This entry moves to the new bucket.

        if ((entry->hashValue & oldNewMask) != 0) {
            if (newChain == NULL) {
                *newSlotAddr = entry;
                entry->prevChain = NULL;
            } else {
                newChain->nextChain = entry;
                entry   ->prevChain = newChain;
            }

            newChain = entry;

            ASSERT((entry->hashValue & mask) == numBuckets);
        }

// This entry stays in the old bucket.

        else {
            if (oldChain == NULL) {
                *oldSlotAddr = entry;
                entry->prevChain = NULL;
            } else {
                oldChain->nextChain = entry;
                entry   ->prevChain = oldChain;
            }

            oldChain = entry;

            ASSERT((entry->hashValue & mask) == expandIndex);
        }

#if DBG
        prevChain = entry;
#endif
        entry = entry->nextChain;
    }

// Finish off each bucket chain.

    if (oldChain == NULL)
        *oldSlotAddr = NULL;
    else
        oldChain->nextChain = NULL;

    if (newChain == NULL)
        *newSlotAddr = NULL;
    else
        newChain->nextChain = NULL;

// Adjust the expand index and level, and increment the number of buckets.

    if (++expandIndex == 1U << level) {
        level++;
        expandIndex = 0;
    }
    numBuckets++;

    ASSERT(expandIndex <   1U << level);
    ASSERT(numBuckets  == (1U << level) + expandIndex);
}

/*****************************************************************************/

VOID Table::Contract()
{
    TableEntry **targetSlotAddr,
               **victimSlotAddr,
                *firstVictimEntry,
                *prevChain,
                *entry;

    TableSegment **newDirectory;

#if DBG
    DWORD mask;
#endif

// Adjust the expand index and level, and decrement the number of buckets.

    ASSERT(expandIndex <   1U << level);
    ASSERT(numBuckets  == (1U << level) + expandIndex);

    if (expandIndex > 0)
        expandIndex--;
    else
        expandIndex = (1U << --level) - 1;
    numBuckets--;

    ASSERT(expandIndex <   1U << level);
    ASSERT(numBuckets  == (1U << level) + expandIndex);

// Find the target and victim buckets.

    ASSERT(directory != NULL);
    ASSERT(dirSize >= TABLE_SEGMENT_SIZE);
    ASSERT(dirSize %  TABLE_SEGMENT_SIZE == 0);

    targetSlotAddr = &directory[expandIndex >> TABLE_SEGMENT_BITS]
                         ->slot[expandIndex &  TABLE_SEGMENT_MASK];
    victimSlotAddr = &directory[numBuckets  >> TABLE_SEGMENT_BITS]
                         ->slot[numBuckets  &  TABLE_SEGMENT_MASK];

    ASSERT(targetSlotAddr != NULL);
    ASSERT(victimSlotAddr != NULL);

// If the victim buffer isn't empty, ...

    if ((firstVictimEntry = *victimSlotAddr) != NULL) {
#if DBG
        mask = ~(~0U << (level+1));
#endif
        ASSERT((firstVictimEntry->hashValue & mask) == numBuckets);
        ASSERT( firstVictimEntry->prevChain == NULL);

// ... find the end of the target bucket chain, ...

        entry     = *targetSlotAddr;
        prevChain = NULL;

        while (entry != NULL) {
            ASSERT((entry->hashValue & mask) == expandIndex);
            ASSERT( entry->prevChain == prevChain);

            prevChain = entry;
            entry     = entry->nextChain;
        }

// ... then add the victim bucket chain to the end of the target bucket chain.

        if (prevChain == NULL)
            *targetSlotAddr = firstVictimEntry;
        else {
            prevChain->nextChain = firstVictimEntry;
            firstVictimEntry->prevChain = prevChain;
        }
    }

// Delete the victim bucket, and delete the victim segment if no buckets remain.

    if ((numBuckets & TABLE_SEGMENT_MASK) == 0) {
        delete directory[numBuckets >> TABLE_SEGMENT_BITS];
        directory[numBuckets >> TABLE_SEGMENT_BITS] = NULL;
    } else
        *victimSlotAddr = NULL;

// Reduce the size of the directory if necessary.

    if (numBuckets <= (dirSize - TABLE_DIR_SIZE) * TABLE_SEGMENT_SIZE
     && dirSize > TABLE_DIR_SIZE) {
        dirSize -= TABLE_DIR_SIZE;
        newDirectory = new TableSegment * [dirSize];
        ASSERT(newDirectory != NULL);
        memcpy(newDirectory, directory, sizeof(TableSegment *) * dirSize);
        delete directory;
        directory = newDirectory;
    }
}

/*****************************************************************************/
/************************ Table class public methods *************************/
/*****************************************************************************/

Table::Table()
{
    firstEntry = NULL;
    lastEntry  = NULL;

    numEntries  = 0;
    numBuckets  = TABLE_SEGMENT_SIZE;
    expandIndex = 0;
    level       = TABLE_SEGMENT_BITS;

    dirSize   = TABLE_DIR_SIZE;
    directory = new TableSegment * [dirSize];
    ASSERT(directory != NULL);
    memset(directory, 0, sizeof(TableSegment *) * dirSize);

    directory[0] = new TableSegment;
    ASSERT(directory[0] != NULL);
    memset(directory[0], 0, sizeof(TableSegment));
}

/*****************************************************************************/

Table::~Table()
{
    TableEntry *entry,
               *prevEntry;

    DWORD numSegments,
          segmentNum,
          count;

    entry     = firstEntry;
    prevEntry = NULL;
    count     = 0;

    while (entry != NULL) {
        ASSERT(entry->prevEntry == prevEntry);
        prevEntry = entry;
        entry     = entry->nextEntry;
        delete prevEntry->data;
        delete prevEntry;
        count++;
    }
    ASSERT(count == numEntries);

    numSegments = numBuckets >> TABLE_SEGMENT_BITS;

    ASSERT(directory != NULL);
    ASSERT(dirSize >= TABLE_SEGMENT_SIZE);
    ASSERT(dirSize %  TABLE_SEGMENT_SIZE == 0);
    ASSERT(numSegments <= dirSize);

    for (segmentNum = 0; segmentNum < numSegments; segmentNum++) {
        ASSERT(directory[segmentNum] != NULL);
        delete directory[segmentNum];
    }

    delete directory;
}

/*****************************************************************************/

BOOL Table::Put(
    VOID *data,
    DWORD keyLen)
{
    TableEntry **slotAddr,
                *prevChain,
                *entry;

    DWORD hashValue,
          bucketNum;

#if DBG
    DWORD mask;
#endif

    ASSERT(data   != NULL);
    ASSERT(keyLen >  0);

// Find the bucket for this data.

    hashValue = Hash(data, keyLen);
    bucketNum = BucketNum(hashValue);

#if DBG
    mask = ~(~0U << (bucketNum < expandIndex || bucketNum >= 1U << level
                     ? level+1 : level));
#endif

    ASSERT(directory != NULL);

    slotAddr = &directory[bucketNum >> TABLE_SEGMENT_BITS]
                   ->slot[bucketNum &  TABLE_SEGMENT_MASK];

    ASSERT(slotAddr != NULL);

    entry     = *slotAddr;
    prevChain =  NULL;

// Look at each entry in the bucket to determine if the data is
// already present. If a matching entry is found, return FALSE.

    while (entry != NULL) {
        ASSERT((entry->hashValue & mask) == bucketNum);
        ASSERT( entry->prevChain == prevChain);

        if (hashValue == entry->hashValue
         && keyLen    == entry->keyLen
         && memcmp(data, entry->data, keyLen) == 0)
            return FALSE;

        prevChain = entry;
        entry     = entry->nextChain;
    }

// No entry with matching data was found in this bucket.
// Create a new entry and add it to the end of the bucket chain.

    entry = new TableEntry;
    ASSERT(entry != NULL);

    if (prevChain == NULL) {
        *slotAddr = entry;
        entry->prevChain = NULL;
    } else {
        prevChain->nextChain = entry;
        entry    ->prevChain = prevChain;
    }
    entry->nextChain = NULL;

// Add the entry to the end of the doubly-linked list.

    if (lastEntry == NULL) {
        ASSERT(firstEntry == NULL);
        ASSERT(numEntries == 0);
        firstEntry       = entry;
        entry->prevEntry = NULL;
    } else {
        ASSERT(firstEntry != NULL);
        ASSERT(numEntries >  0);
        lastEntry->nextEntry = entry;
        entry    ->prevEntry = lastEntry;
    }

    entry->nextEntry = NULL;
    lastEntry        = entry;
    numEntries++;

// Fill out the entry.

    entry->hashValue = hashValue;
    entry->keyLen    = keyLen;
    entry->data      = data;

// Expand the table if necessary.

    if (numEntries > numBuckets * TABLE_MAX_LOAD) {
        Expand();
        ASSERT(numEntries <= numBuckets * TABLE_MAX_LOAD);
    }

    return TRUE;
}

/*****************************************************************************/

VOID *Table::Get(
    const VOID *key,
    DWORD       keyLen,
    BOOL        erase)
{
    TableEntry **slotAddr,
                *entry,
                *prevChain;

    DWORD hashValue,
          bucketNum;

    VOID *dataPtr;

#if DBG
    DWORD mask;
#endif

    ASSERT(key    != NULL);
    ASSERT(keyLen >  0);

// Find the bucket for this data.

    hashValue = Hash(key, keyLen);
    bucketNum = BucketNum(hashValue);

#if DBG
    mask = ~(~0U << (bucketNum < expandIndex || bucketNum >= 1U << level
                     ? level+1 : level));
#endif

    ASSERT(directory != NULL);

    slotAddr = &directory[bucketNum >> TABLE_SEGMENT_BITS]
                   ->slot[bucketNum &  TABLE_SEGMENT_MASK];

    ASSERT(slotAddr != NULL);

    entry     = *slotAddr;
    prevChain = NULL;

// Look at each entry in the bucket.

    while (entry != NULL) {
        ASSERT((entry->hashValue & mask) == bucketNum);
        ASSERT( entry->prevChain == prevChain);

        if (hashValue == entry->hashValue
         && keyLen    == entry->keyLen
         && memcmp(key, entry->data, keyLen) == 0) {

// The entry with matching data has been found.

            dataPtr = entry->data;
            ASSERT(dataPtr != NULL);

// If erasure is disabled, remove the entry from the doubly-linked list ...

            if (erase) {
                if (entry->prevEntry == NULL) {
                    ASSERT(firstEntry == entry);
                    firstEntry = entry->nextEntry;
                } else
                    entry->prevEntry->nextEntry = entry->nextEntry;

                if (entry->nextEntry == NULL) {
                    ASSERT(lastEntry == entry);
                    lastEntry = entry->prevEntry;
                } else
                    entry->nextEntry->prevEntry = entry->prevEntry;

// ... and from the bucket chain, ...

                if (prevChain == NULL)
                    *slotAddr = entry->nextChain;
                else
                    prevChain->nextChain = entry->nextChain;

                if (entry->nextChain != NULL) {
                    ASSERT(entry->nextChain->prevChain == entry);
                    entry->nextChain->prevChain = prevChain;
                }

// ... then delete the entry.

                delete entry;

// Decrement the number of entries, and contract the table if necessary.

                numEntries--;
                if (numBuckets > TABLE_SEGMENT_SIZE
                 && numEntries < numBuckets * TABLE_MIN_LOAD) {
                    Contract();
                    ASSERT(numBuckets <= TABLE_SEGMENT_SIZE
                        || numEntries >= numBuckets * TABLE_MIN_LOAD);
                }
            }

            return dataPtr;
        }

// No entry with matching data has yet been found.
// Continue following the bucket chain.

        prevChain = entry;
        entry     = entry->nextChain;
    }

// No entry with matching data was found in this bucket.

    return NULL;
}

/*****************************************************************************/

VOID *Table::GetFirst(
    DWORD *keyLen,
    BOOL   erase)
{
    TableEntry **slotAddr,
                *entry;

    DWORD bucketNum;

    VOID *dataPtr;

// If the table is empty, then simply return.

    if (firstEntry == NULL) {
        ASSERT(lastEntry  == NULL);
        ASSERT(numEntries == 0);
        return NULL;
    }

    dataPtr = firstEntry->data;
    ASSERT(dataPtr != NULL);
    if (keyLen != NULL) {
        *keyLen = firstEntry->keyLen;
        ASSERT(firstEntry->keyLen > 0);
    }

// If erasure is enabled, remove the first entry from the doubly-linked list ...

    if (erase) {
        entry      = firstEntry;
        firstEntry = entry->nextEntry;

        if (firstEntry == NULL) {
            ASSERT(numEntries == 1);
            ASSERT(lastEntry  == entry);
            lastEntry = NULL;
        } else {
            ASSERT(numEntries >  1);
            ASSERT(firstEntry->prevEntry == entry);
            firstEntry->prevEntry = NULL;
        }

// ... and from the bucket chain, ...

        if (entry->prevChain == NULL) {
            bucketNum = BucketNum(entry->hashValue);
            ASSERT(directory != NULL);
            slotAddr = &directory[bucketNum >> TABLE_SEGMENT_BITS]
                           ->slot[bucketNum &  TABLE_SEGMENT_MASK];
            ASSERT( slotAddr != NULL);
            ASSERT(*slotAddr == entry);
            *slotAddr = entry->nextChain;
        } else {
            ASSERT(entry->prevChain->nextChain == entry);
            entry->prevChain->nextChain = entry->nextChain;
        }

        if (entry->nextChain != NULL) {
            ASSERT(entry->nextChain->prevChain == entry);
            entry->nextChain->prevChain = entry->prevChain;
        }

// ... then delete the entry.

        delete entry;

// Decrement the number of entries, and contract the table if necessary.

        numEntries--;
        if (numBuckets > TABLE_SEGMENT_SIZE
         && numEntries < numBuckets * TABLE_MIN_LOAD) {
            Contract();
            ASSERT(numBuckets <= TABLE_SEGMENT_SIZE
                || numEntries >= numBuckets * TABLE_MIN_LOAD);
        }
    }

    return dataPtr;
}

/*****************************************************************************/

DWORD Table::Number() const
{
    return numEntries;
}

/*****************************************************************************/
/************************* FIFO class public methods *************************/
/*****************************************************************************/

FIFO::FIFO()
{
    head = tail = NULL;
    numEntries = 0;
}

/*****************************************************************************/

FIFO::~FIFO()
{
    FIFOEntry *entry = head,
              *oldEntry;

    DWORD count = 0;

    while ((oldEntry = entry) != NULL) {
        entry = entry->next;
        delete oldEntry->data;
        delete oldEntry;
        count++;
    }

    ASSERT(count == numEntries);
}

/*****************************************************************************/

VOID FIFO::Put(VOID *data)
{
    FIFOEntry *newEntry;

    ASSERT(data != NULL);

    newEntry = new FIFOEntry;
    ASSERT(newEntry != NULL);
    newEntry->next = NULL;
    newEntry->data = data;

    if (tail != NULL)
        tail->next = newEntry;
    else
        head       = newEntry;
    tail = newEntry;

    numEntries++;
}

/*****************************************************************************/

VOID *FIFO::Get()
{
    FIFOEntry *oldHead;

    VOID *dataPtr;

    if (head == NULL) {
        ASSERT(tail == NULL);
        ASSERT(numEntries == 0);
        return NULL;
    }

    ASSERT(tail != NULL);
    ASSERT(numEntries > 0);

    dataPtr = head->data;

    oldHead = head;
    head    = head->next;
    delete oldHead;
    if (head == NULL)
        tail = NULL;
    numEntries--;

    return dataPtr;
}

/*****************************************************************************/

DWORD FIFO::Number() const
{
    return numEntries;
}

/*****************************************************************************/
/************************* LIFO class public methods *************************/
/*****************************************************************************/

LIFO::LIFO()
{
    top = NULL;
    numEntries = 0;
}

/*****************************************************************************/

LIFO::~LIFO()
{
    LIFOEntry *entry = top,
              *oldEntry;

    DWORD count = 0;

    while ((oldEntry = entry) != NULL) {
        entry = entry->next;
        delete oldEntry->data;
        delete oldEntry;
        count++;
    }

    ASSERT(count == numEntries);
}

/*****************************************************************************/

VOID LIFO::Put(VOID *data)
{
    LIFOEntry *newEntry;

    ASSERT(data != NULL);

    newEntry = new LIFOEntry;
    ASSERT(newEntry != NULL);
    newEntry->next = top;
    newEntry->data = data;
    top = newEntry;
    numEntries++;
}

/*****************************************************************************/

VOID *LIFO::Get()
{
    LIFOEntry *oldTop;

    VOID *dataPtr;

    if (top == NULL) {
        ASSERT(numEntries == 0);
        return NULL;
    }

    ASSERT(numEntries > 0);

    dataPtr = top->data;

    oldTop = top;
    top    = top->next;
    delete oldTop;
    numEntries--;

    return dataPtr;
}

/*****************************************************************************/

DWORD LIFO::Number() const
{
    return numEntries;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\sisbkup\pool.cpp ===
/*++

Copyright (c) 1993-1999	Microsoft Corporation

Module Name:

	pool.cpp

Abstract:

	Fixed size memory allocator.

Author:

	Bill Bolosky		[bolosky]		1993

Revision History:

--*/

#include "sibp.h"


struct PoolEntry {
    void		*object;
    struct PoolEntry	*next;
};

struct PoolBlob {
    struct PoolBlob	*next;
    void		*data;
};

Pool::Pool(
    unsigned		 objectSize,
    void *(*allocator)(unsigned),
    unsigned		 blobSize,
    void (*destructor)(void *))
{
    assert(objectSize > 0);

    assert(!destructor || allocator);	// Can't have a destructor without an allocator.  Allocator w/o destructor leaks objects on pool destruct.

    this->countAllocator = allocator;
    this->singleAllocator = NULL;
    this->destructor = destructor;
    this->objectSize = objectSize;
    entries = NULL;
    freeEntries = NULL;
    entriesBlobHead = NULL;
    objectsBlobHead = NULL;

    entriesPerBlob = blobSize / sizeof(PoolEntry);
    assert(entriesPerBlob > 0);

    objectsPerBlob = blobSize / objectSize;
    if (!objectsPerBlob) {
	objectsPerBlob = 1;
    }

    allocations = 0;
    frees = 0;
    news = 0;

    numFree = 0;
}


// This version of the pool constructor uses the old kind of allocator function that only returns one object.  Object blobs have one object,
// and the blob size for entry blobs is smaller so that we have finer grain memory allocation.
Pool::Pool(
    unsigned		 objectSize,
    void *(*allocator)(void))
{
    assert(objectSize > 0);

    assert(!destructor || allocator);	// Can't have a destructor without an allocator; allocator w/o destructor leaks objects on pool destruct

    this->singleAllocator = allocator;
    this->countAllocator = NULL;
    this->destructor = NULL;
    this->objectSize = objectSize;
    entries = NULL;
    freeEntries = NULL;
    entriesBlobHead = NULL;
    objectsBlobHead = NULL;

    unsigned blobSize = 1024 - 50;	// Our default allocation size; we leave the 50 byte headroom for the underlying allocator

    entriesPerBlob = blobSize / sizeof(PoolEntry);
    assert(entriesPerBlob > 0);

    objectsPerBlob = 1;

    allocations = 0;
    frees = 0;
    news = 0;

    numFree = 0;
}

Pool::~Pool(void)
{
    // Just delete the blob lists.  All objects that have been allocated from this pool will be destroyed.
    
    while (entriesBlobHead) {
	PoolBlob *blob = entriesBlobHead;
	assert(blob->data);
	delete [] blob->data;
	entriesBlobHead = blob->next;
	delete blob;
    }

    while (objectsBlobHead) {
	PoolBlob *blob = objectsBlobHead;
	assert(blob->data);
	if (destructor) {
	    (*destructor)(blob->data);
	} else if (!singleAllocator && !countAllocator) {
	    delete [] blob->data;
	} // else leak the objects
	objectsBlobHead = blob->next;
	delete blob;
    }

}

    void
Pool::allocateMoreObjects(void)
{
    assert(objectsPerBlob);

    PoolBlob *blob = new PoolBlob;
    if (!blob) {
	return;
    }

    if (countAllocator) {
	blob->data = (*countAllocator)(objectsPerBlob);
    } else if (singleAllocator) {
	assert(objectsPerBlob == 1);
	blob->data = (*singleAllocator)();
    } else {
	blob->data = (void *)new char[objectSize * objectsPerBlob];
    }

    if (!blob->data) {
	delete blob;
	return;
    }

    blob->next = objectsBlobHead;
    objectsBlobHead = blob;

    // Now put them on the free list.

    for (unsigned i = 0; i < objectsPerBlob; i++) {
        PoolEntry *entry = getEntry();
	if (!entry) {
	    return;		// This is kinda bogus, because it might leave some allocated objects unreachable.
	}
	entry->object = (void *)(((char *)blob->data) + i * objectSize);
	entry->next = entries;
	entries = entry;
    }

    news += objectsPerBlob;
    numFree += objectsPerBlob;
}


// Allocate entries until the free list is of size n (or until an allocation fails).
    void
Pool::preAllocate(
    unsigned		 n)
{
    assert(n);

    while (numFree < n) {
	unsigned oldNumFree = numFree;
	allocateMoreObjects();
	if (oldNumFree == numFree) {
	    // We can't allocate more; punt
	    return;
	}
    }
}

    PoolEntry *
Pool::getEntry(void)
{
    PoolEntry *entry = NULL;
    if (freeEntries) {
	entry = freeEntries;
	freeEntries = entry->next;
	assert(entry->object == NULL);
    } else {
	// Allocate a new entry blob and fill it in.
	PoolBlob *blob = new PoolBlob;
	if (blob) {
	    PoolEntry *blobEntries = new PoolEntry[entriesPerBlob];
	    if (blobEntries) {
		blob->data = (void *)blobEntries;
		// Release all of the newly allocated entries except the first one, which we'll return.
		for (unsigned i = 1; i < entriesPerBlob; i++) {
		    releaseEntry(&blobEntries[i]);
		}
		entry = &blobEntries[0];

		// Stick the new blob on the entries blob list.
		blob->next = entriesBlobHead;
		entriesBlobHead = blob;
	    } else {
		// Give up; we couldn't get memory
		delete blob;
	    }
	}
    }
    return(entry);
}

    void
Pool::releaseEntry(
    PoolEntry 		*entry)
{
    assert(entry);
    entry->object = NULL;
    entry->next = freeEntries;
    freeEntries = entry;
}

    void *
Pool::allocate(void)
{
    allocations++;

    assert((numFree == 0) == (entries == NULL));

    if (!entries) {
	allocateMoreObjects();
    }

    if (entries) {
	// We've got something
	struct PoolEntry *thisEntry = entries;
	entries = entries->next;
	void *object = thisEntry->object;

	assert(object);

	releaseEntry(thisEntry);

	assert(numFree);
	numFree--;

	return(object);
    } else {
	// Coudn't allocate more, we're out of memory.
	assert(numFree == 0);
	return NULL;
    }
}

    void
Pool::free(
    void		*object)
{
    assert(object);

    frees++;

    // No way to assert that this is the right kind (size) of object...

    // Get a PoolEntry.
    struct PoolEntry *entry = getEntry();
    if (!entry) {
	// We couldn't get an entry, so we can't add this object to the free list.  Leak it.
	return;
    }

    numFree++;

    entry->object = object;
    entry->next = entries;
    entries = entry;
}

    unsigned
Pool::numAllocations(void)
{
    return(allocations);
}

    unsigned
Pool::numFrees(void)
{
    return(frees);
}

    unsigned
Pool::numNews(void)
{
    return(news);
}

    unsigned
Pool::getObjectSize(void)
{
    return(objectSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\sisbkup\sisbkup.cpp ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    sisbackup.cpp

Abstract:

    The SIS Backup dll.

Author:

    Bill Bolosky        [bolosky]       March 1998

Revision History:

--*/


#include "sibp.h"

BOOLEAN
NonSISEnabledVolume(
    PSIB_RESTORE_VOLUME_STRUCTURE   restoreStructure)
/*++

Routine Description:

    Figure out if restoreStructure represents a SIS enabled volume.
    First, we check to see if we've already made the check, in which
    case we return the value we already stored.  If not, then we
    open a root handle, and send down a mal-formed SIS_COPYFILE request.
    If we get back ERROR_INVALID_FUNCTION then it's not SIS enabled.  If
    we get back ERROR_INVALID_PARAMETER, then it's a SIS-enabled volume.
    If we get back anything else, then we can't prove it's not SIS enabled,
    and we just retry the next time we're asked.

    Caller must hold the mutex in the restore volume structure.

Arguments:

    restoreStructure - A pointer to the restore structure representing
        the volume to check.

Return Value:

    Returns TRUE if this is not a SIS-enabled volume, FALSE if it is or
    if it can't be determined.
--*/
{
    if (restoreStructure->checkedForSISEnabledVolume) {
        return !restoreStructure->isSISEnabledVolume;
    }

    HANDLE volumeRootHandle;
    PWCHAR volumeRootName;

    //
    // Allocate space for a string containing the volume root name including the trailing
    // backslash.  It will be two (wide) characters longer than restoreStructure->volumeRoot
    // because of the backslash and null terminator.
    //

    int bLen = ((wcslen(restoreStructure->volumeRoot) + 2) * sizeof(WCHAR));  //in bytes

    volumeRootName = (PWCHAR)malloc(bLen);

    if (NULL == volumeRootName) {
        //
        // Guess we can't check, just assume it's OK.
        //
#if     DBG
        DbgPrint("SISBkup: NonSISEnabledVolume: unable to allocate space for volume root name\n");
#endif  // DBG
        return FALSE;
    }

    (void)StringCbCopyW(volumeRootName,bLen,restoreStructure->volumeRoot);
    (void)StringCbCatW(volumeRootName,bLen,L"\\");

    volumeRootHandle = CreateFileW(
                        volumeRootName,
                        0,                                                  // don't need any access for this check
                        FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                        NULL,                                               // security attributes
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS,                         // needed to open a directory
                        NULL);                                              // hTemplateFile


    free(volumeRootName);
    volumeRootName = NULL;

    if (INVALID_HANDLE_VALUE == volumeRootHandle) {
        return FALSE;
    }

    //
    // Send a malformed FSCTL_SIS_COPYFILE down on the handle we just opened.
    //
    DWORD bytesReturned;
    BOOL worked = DeviceIoControl(
                        volumeRootHandle,
                        FSCTL_SIS_COPYFILE,
                        NULL,                   // input buffer (this is a malformed request, after all)
                        0,                      // i.b. size
                        NULL,                   // output buffer
                        0,                      // o.b. size
                        &bytesReturned,
                        NULL);                  // lap

    CloseHandle(volumeRootHandle);

    if (worked) {
        //
        // This is bizarre!
        //

#if     DBG
        DbgPrint("SISBkup: malformed FSCTL_SIS_COPYFILE worked!\n");
#endif  // DBG

        return FALSE;
    }

    if (GetLastError() == ERROR_INVALID_FUNCTION) {
        //
        // No one recognized the copyfile request, or SIS decided that
        // this isn't a SIS enabled volume.  Say no.
        //
        restoreStructure->checkedForSISEnabledVolume = TRUE;
        restoreStructure->isSISEnabledVolume = FALSE;

        return TRUE;
    }

    if (GetLastError() == ERROR_INVALID_PARAMETER) {
        //
        // This means that SIS saw the request and thinks this is
        // a SIS enabled volume.  Say so.
        //

        restoreStructure->checkedForSISEnabledVolume = TRUE;
        restoreStructure->isSISEnabledVolume = TRUE;

        return FALSE;
    }

    //
    // Else, it's some weird error.  We can't prove it's not a SIS volume.
    //

#if     DBG
    DbgPrint("SISBkup: got unexpected error from SIS_FSCTL_COPYFILE, %d\n",GetLastError());
#endif  // DBG
            

    return FALSE;
}

VOID
SipComputeChecksum(
    IN PVOID                            buffer,
    IN ULONG                            size,
    IN OUT PLONGLONG                    checksum)
/*++

Routine Description:

    Compute a checksum for a buffer.  We use the "131 hash," which
    work by keeping a 64 bit running total, and for each 32 bits of
    data multiplying the 64 bits by 131 and adding in the next 32
    bits.  Must be called at PASSIVE_LEVEL, and all aruments
    may be pagable.

Arguments:

    buffer - pointer to the data to be checksummed

    size - size of the data to be checksummed

    checksum - pointer to large integer to receive the checksum.  This
        may be within the buffer, and SipComputeChecksum guarantees that
        the initial value will be used in computing the checksum.

Return Value:

    Returns STATUS_SUCCESS or an error returned from the actual disk write.
--*/
{
    LONGLONG runningTotal;
    PULONG ptr = (PULONG)buffer;
    ULONG bytesRemaining = size;

    runningTotal = *checksum;

    while (bytesRemaining >= sizeof(*ptr)) {
        runningTotal = runningTotal * 131 + *ptr;
        bytesRemaining -= sizeof(*ptr);
        ptr++;
    }

    if (bytesRemaining > 0) {
        ULONG extra;

        ASSERT(bytesRemaining < sizeof (ULONG));
        extra = 0;
        RtlMoveMemory(&extra, ptr, bytesRemaining);
        
        runningTotal = runningTotal * 131 + extra;
    }

    *checksum = runningTotal;
}


void
TryOpeningFile(
    PWCHAR          fileName)
{
    HANDLE      fileHandle;

    fileHandle = CreateFileW(
                    fileName,
                    GENERIC_READ,
                    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                    NULL,                   // security attributes
                    OPEN_EXISTING,
                    FILE_FLAG_BACKUP_SEMANTICS,
                    NULL);                  // template file

    if (INVALID_HANDLE_VALUE != fileHandle) {
        CloseHandle(fileHandle);
    }
}

LONG
CsidCompare(
    IN PCSID                id1,
    IN PCSID                id2)
{
    PLONGLONG keyValue1 = (PLONGLONG)id1;
    PLONGLONG keyValue2 = keyValue1 + 1;
    PLONGLONG nodeValue1 = (PLONGLONG)id2;
    PLONGLONG nodeValue2 = nodeValue1 + 1;

    if (*keyValue1 < *nodeValue1) {
        return -1;
    } else if (*keyValue1 > *nodeValue1) {
        return 1;
    } else {
        if (*keyValue2 < *nodeValue2) {
            return -1;
        } else if (*keyValue2 > *nodeValue2) {
            return 1;
        } else {
            return 0;
        }
    }
}

NTSTATUS
FilenameFromCSid(
    IN PCSID                        CSid,
    IN PWCHAR                       volumeRoot,
    OUT PWCHAR                      *fileName)
{
    PWCHAR uuidString;
    RPC_STATUS status;
    int bLen = ((wcslen(volumeRoot) * sizeof(WCHAR)) + 
                SIS_CSDIR_STRING_SIZE + 
                INDEX_MAX_NUMERIC_STRING_LENGTH + 
                sizeof(WCHAR));      //in bytes

    *fileName = (PWCHAR)malloc(bLen);

    if (NULL == *fileName) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    (void)StringCbCopyW(*fileName,bLen,volumeRoot);
    (void)StringCbCatW(*fileName,bLen,SIS_CSDIR_STRING);

    status = UuidToStringW(CSid,(unsigned short **)&uuidString);
    if (RPC_S_OK != status) {
        free(*fileName);
        *fileName = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    (void)StringCbCatW(*fileName,bLen,uuidString);
    (void)StringCbCatW(*fileName,bLen,L".sis");
    
    RpcStringFreeW((unsigned short **)&uuidString);

    return STATUS_SUCCESS;
}

NTSTATUS
CSidFromFilename(
    IN PWCHAR                       FileName,
    OUT PCSID                       CSid)
{
#define UUID_STRING_MAX_LENGTH  100// Should get this length from somewhere better...

    PWCHAR      trailingSlash;
    PWCHAR      dot;
    WCHAR       uuid[UUID_STRING_MAX_LENGTH];   
    DWORD       uuidChars = 0;


    trailingSlash = wcsrchr(FileName, '\\');

    if (NULL == trailingSlash) {
        //
        // Assume that it's just the CS file without the directory name, etc.
        //
        trailingSlash = FileName - 1;
    }

    dot = wcsrchr(FileName, '.');
    if (NULL != dot) {
        uuidChars = (DWORD)(dot - (trailingSlash + 1));
    }

    if ((uuidChars <= 0) || (uuidChars >= UUID_STRING_MAX_LENGTH)) {

        //
        // Something's bogus about the filename.  Give up.
        //
        return STATUS_OBJECT_NAME_INVALID;
    }

    memcpy(uuid,trailingSlash+1,uuidChars * sizeof(WCHAR));
    uuid[uuidChars] = 0;

    if (RPC_S_OK != UuidFromStringW((unsigned short *)uuid,CSid)) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SisCreateBackupStructureI(
    IN PWCHAR                       volumeRoot,
    OUT PVOID                       *sisBackupStructure,
    OUT PWCHAR                      *commonStoreRootPathname,
    OUT PULONG                      countOfCommonStoreFilesToBackup,
    OUT PWCHAR                      **commonStoreFilesToBackup)
{
    PSIB_BACKUP_VOLUME_STRUCTURE    backupVolumeStructure;

    backupVolumeStructure = (PSIB_BACKUP_VOLUME_STRUCTURE)malloc(sizeof(SIB_BACKUP_VOLUME_STRUCTURE));

    if (NULL == backupVolumeStructure) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    backupVolumeStructure->linkTree = new AVLTree<BackupFileEntry>;

    if (NULL == backupVolumeStructure->linkTree) {
        free(backupVolumeStructure);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Allocate space for our private copy of the volume root name, being sure to leave space for
    // the terminating NULL.
    //

    int bLen = (wcslen(volumeRoot) + 1) * sizeof(WCHAR);    //in bytes

    backupVolumeStructure->volumeRoot = (PWCHAR)malloc(bLen);
    if (NULL == backupVolumeStructure->volumeRoot) {
        delete backupVolumeStructure->linkTree;
        free(backupVolumeStructure);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    (void)StringCbCopyW(backupVolumeStructure->volumeRoot, bLen, volumeRoot);

    //
    // Allocate space for the common store root pathname that we return, being sure
    // to leave room for the terminating NULL.
    //
    bLen = (SIS_CSDIR_STRING_SIZE + ((wcslen(volumeRoot) + 1) * sizeof(WCHAR)));  //in bytes

    *commonStoreRootPathname = (PWCHAR) malloc(bLen);
    if (NULL == *commonStoreRootPathname) {
        free(backupVolumeStructure->volumeRoot);
        delete backupVolumeStructure->linkTree;
        free(backupVolumeStructure);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    (void)StringCbCopyW(*commonStoreRootPathname,bLen,volumeRoot);
    (void)StringCbCatW(*commonStoreRootPathname,bLen,SIS_CSDIR_STRING);

    InitializeCriticalSection(backupVolumeStructure->criticalSection);

    *countOfCommonStoreFilesToBackup = 0;
    *commonStoreFilesToBackup = NULL;
    *sisBackupStructure = backupVolumeStructure;

    return STATUS_SUCCESS;

}

NTSTATUS
SisCSFilesToBackupForLinkI(
    IN PVOID                        sisBackupStructure,
    IN PVOID                        reparseData,
    IN ULONG                        reparseDataSize,
    IN PVOID                        thisFileContext                     OPTIONAL,
    OUT PVOID                       *matchingFileContext                OPTIONAL,
    OUT PULONG                      countOfCommonStoreFilesToBackup,
    OUT PWCHAR                      **commonStoreFilesToBackup)
{
    PREPARSE_DATA_BUFFER            reparseDataBuffer = (PREPARSE_DATA_BUFFER)reparseData;
    PSI_REPARSE_BUFFER              sisReparseBuffer = (PSI_REPARSE_BUFFER)reparseDataBuffer->GenericReparseBuffer.DataBuffer;
    BackupFileEntry                 entry[1];
    BackupFileEntry                 *foundEntry, *newEntry;
    PSIB_BACKUP_VOLUME_STRUCTURE    backupVolumeStructure = (PSIB_BACKUP_VOLUME_STRUCTURE)sisBackupStructure;
    PVOID                           matchedContext = NULL;
    PWCHAR                          CSFileName[MAX_PATH];
    NTSTATUS                        status;

    EnterCriticalSection(backupVolumeStructure->criticalSection);

    if (reparseDataSize != SIS_REPARSE_DATA_SIZE) {
        //
        // It's the wrong size to contain a SIS reparse buffer, so we don't
        // want to add any CS files based on it.
        //

        status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    if (IO_REPARSE_TAG_SIS != reparseDataBuffer->ReparseTag ||
        sizeof(SI_REPARSE_BUFFER) != reparseDataBuffer->ReparseDataLength) {
        //
        // The size or tag is wrong.  Ignore it.
        //

        status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    if ((SIS_REPARSE_BUFFER_FORMAT_VERSION != sisReparseBuffer->ReparsePointFormatVersion) &&
        (4 != sisReparseBuffer->ReparsePointFormatVersion)) {
        //
        // We don't understand this format SIS reparse point.  This is probably an
        // old dll version.
        //

        status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    //
    // The only thing we really care about is the CSIndex of the file.  See if we've
    // already backed up a file with a matching CSIndex by looking in the tree.
    //
    entry->CSid = sisReparseBuffer->CSid;
    
    foundEntry = backupVolumeStructure->linkTree->findFirstLessThanOrEqualTo(entry);

    if ((NULL != foundEntry) && (*foundEntry == entry)) {
        //
        // We already returned the CS file that backs this link.  Return the caller's
        // context for that link.
        //
        matchedContext = foundEntry->callerContext;

        goto BackupNoCSFiles;
    }

    //
    // This is the first time we've seen this particular CS file, so back it up.
    //
    newEntry = new BackupFileEntry;
    if (NULL == newEntry) {
        LeaveCriticalSection(backupVolumeStructure->criticalSection);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    newEntry->callerContext = thisFileContext;
    newEntry->CSid = sisReparseBuffer->CSid;

    if (!backupVolumeStructure->linkTree->insert(newEntry)) {
        delete newEntry;

        LeaveCriticalSection(backupVolumeStructure->criticalSection);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NULL != matchingFileContext) {
        *matchingFileContext = NULL;
    }
    *countOfCommonStoreFilesToBackup = 1;

    *commonStoreFilesToBackup = (PWCHAR *)malloc(sizeof(PWCHAR) * *countOfCommonStoreFilesToBackup);

    if (NULL == *commonStoreFilesToBackup) {
        backupVolumeStructure->linkTree->remove(newEntry);
        delete newEntry;
        *countOfCommonStoreFilesToBackup = 0;

        LeaveCriticalSection(backupVolumeStructure->criticalSection);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = FilenameFromCSid(
                &sisReparseBuffer->CSid,
                backupVolumeStructure->volumeRoot,
                &(*commonStoreFilesToBackup)[0]);
                
    LeaveCriticalSection(backupVolumeStructure->criticalSection);

    return STATUS_SUCCESS;

BackupNoCSFiles:

    if (NULL != matchingFileContext) {
        *matchingFileContext = matchedContext;
    }
    *countOfCommonStoreFilesToBackup = 0;
    *commonStoreFilesToBackup = NULL;

    LeaveCriticalSection(backupVolumeStructure->criticalSection);

    return STATUS_SUCCESS;

Error:
    
    if (NULL != matchingFileContext) {
        *matchingFileContext = matchedContext;
    }
    *countOfCommonStoreFilesToBackup = 0;
    *commonStoreFilesToBackup = NULL;

    LeaveCriticalSection(backupVolumeStructure->criticalSection);

    return status;
}

NTSTATUS
SisFreeBackupStructureI(
    IN PVOID                        sisBackupStructure)
{
    PSIB_BACKUP_VOLUME_STRUCTURE backupVolumeStructure = (PSIB_BACKUP_VOLUME_STRUCTURE)sisBackupStructure;
    BackupFileEntry *entry;

    while (!backupVolumeStructure->linkTree->empty()) {
        entry = backupVolumeStructure->linkTree->findMin();

        assert(NULL != entry);

        backupVolumeStructure->linkTree->remove(entry);

        delete entry;
    }

    free(backupVolumeStructure->volumeRoot);
    delete backupVolumeStructure->linkTree;

    DeleteCriticalSection(backupVolumeStructure->criticalSection);

    free(backupVolumeStructure);

    return STATUS_SUCCESS;
}

NTSTATUS
SisCreateRestoreStructureI(
    IN PWCHAR                       volumeRoot,
    OUT PVOID                       *sisRestoreStructure,
    OUT PWCHAR                      *commonStoreRootPathname,
    OUT PULONG                      countOfCommonStoreFilesToRestore,
    OUT PWCHAR                      **commonStoreFilesToRestore)
{
    PSIB_RESTORE_VOLUME_STRUCTURE   restoreVolumeStructure;
    DWORD                           sectorsPerCluster, freeClusters, totalClusters;

    restoreVolumeStructure = (PSIB_RESTORE_VOLUME_STRUCTURE)malloc(sizeof(SIB_RESTORE_VOLUME_STRUCTURE));

    if (NULL == restoreVolumeStructure) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    restoreVolumeStructure->linkTree = new AVLTree<RestoreFileEntry>;

    if (NULL == restoreVolumeStructure->linkTree) {
        free(restoreVolumeStructure);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Allocate space for our private copy of the volume root name, being sure to leave space for
    // the terminating NULL.
    //
    int bLen = ((wcslen(volumeRoot) + 1) * sizeof(WCHAR));  //in bytes

    restoreVolumeStructure->volumeRoot = (PWCHAR)malloc(bLen);
    if (NULL == restoreVolumeStructure->volumeRoot) {
        delete restoreVolumeStructure->linkTree;
        free(restoreVolumeStructure);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    (void)StringCbCopyW(restoreVolumeStructure->volumeRoot, bLen, volumeRoot);

    //
    // Allocate space for the common store root pathname that we return, being sure
    // to leave room for the terminating NULL.
    //
    bLen = (SIS_CSDIR_STRING_SIZE + (wcslen(volumeRoot) + 1) * sizeof(WCHAR));
    *commonStoreRootPathname = (PWCHAR) malloc(bLen);
    if (NULL == *commonStoreRootPathname) {
        free(restoreVolumeStructure->volumeRoot);
        delete restoreVolumeStructure->linkTree;
        free(restoreVolumeStructure);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    (void)StringCbCopyW(*commonStoreRootPathname,bLen,volumeRoot);
    (void)StringCbCatW(*commonStoreRootPathname,bLen,SIS_CSDIR_STRING);

    InitializeCriticalSection(restoreVolumeStructure->criticalSection);

    *countOfCommonStoreFilesToRestore = 0;
    *commonStoreFilesToRestore = NULL;

    if (!GetDiskFreeSpaceW(
            volumeRoot,
            &sectorsPerCluster,
            &restoreVolumeStructure->VolumeSectorSize,
            &freeClusters,
            &totalClusters)) {
        //
        // The call failed.  Just assume it's 512 bytes.
        //
        restoreVolumeStructure->VolumeSectorSize = 512;
    }

    restoreVolumeStructure->sector = (PSIS_BACKPOINTER)malloc(restoreVolumeStructure->VolumeSectorSize);
    if (NULL == restoreVolumeStructure->sector) {
        free(restoreVolumeStructure->volumeRoot);
        delete restoreVolumeStructure->linkTree;
        free(restoreVolumeStructure);

        free(*commonStoreRootPathname);
        *commonStoreRootPathname = NULL;

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    restoreVolumeStructure->alignedSectorBuffer = (PVOID)malloc(restoreVolumeStructure->VolumeSectorSize * 2);
    if (NULL == restoreVolumeStructure->alignedSectorBuffer) {
        free(restoreVolumeStructure->sector);

        free(restoreVolumeStructure->volumeRoot);
        delete restoreVolumeStructure->linkTree;
        free(restoreVolumeStructure);

        free(*commonStoreRootPathname);
        *commonStoreRootPathname = NULL;

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    restoreVolumeStructure->alignedSector = (PVOID)((
            ((UINT_PTR)restoreVolumeStructure->alignedSectorBuffer +
                restoreVolumeStructure->VolumeSectorSize) /
                    restoreVolumeStructure->VolumeSectorSize) *
                    restoreVolumeStructure->VolumeSectorSize);

    ASSERT(restoreVolumeStructure->alignedSector >= restoreVolumeStructure->alignedSectorBuffer);
    ASSERT((PCHAR)restoreVolumeStructure->alignedSectorBuffer + restoreVolumeStructure->VolumeSectorSize >= (PCHAR)restoreVolumeStructure->alignedSector);

    memset(restoreVolumeStructure->alignedSector,255,restoreVolumeStructure->VolumeSectorSize);

    *sisRestoreStructure = restoreVolumeStructure;

    return STATUS_SUCCESS;
}

NTSTATUS
SisFixValidDataLengthI(
    PSIB_RESTORE_VOLUME_STRUCTURE   restoreVolumeStructure,
    IN HANDLE                       restoredFileHandle)
{
#define BIGGER_THAN_AN_ALLOCATION_REGION        (128 * 1024)    // should get this from somewhere else
    //
    // Figure out if we need to extend ValidDataLength.  We need to do this
    // if the final range of the file is unallocated.
    //
    FILE_STANDARD_INFORMATION       standardInfo[1];
    FILE_END_OF_FILE_INFORMATION    endOfFileInfo[1];
    FILE_ALLOCATED_RANGE_BUFFER     inArb[1];
    const unsigned                  outArbSize = 10;
    FILE_ALLOCATED_RANGE_BUFFER     outArb[outArbSize];
    NTSTATUS                        status;
    IO_STATUS_BLOCK                 Iosb[1];
    DWORD                           bytesReturned;
    LARGE_INTEGER                   rangeToZero;
    FILE_BASIC_INFORMATION          basicInfo[1];
    BOOLEAN                         basicInfoValid = FALSE;
    DWORD                           nBytesWritten;
    unsigned                        i;
    FILE_ZERO_DATA_INFORMATION      zeroInfo[1];
    LARGE_INTEGER                   WriteOffset;

    status = NtQueryInformationFile(
                restoredFileHandle,
                Iosb,
                standardInfo,
                sizeof(FILE_STANDARD_INFORMATION),
                FileStandardInformation);
    if (!NT_SUCCESS(status)) {
#if     DBG
        DbgPrint("SisFixValidDataLength: unable to query standard info on link file, 0x%x\n",status);
#endif  // DBG
        return status;
    }
    ASSERT(STATUS_PENDING != status);
    endOfFileInfo->EndOfFile = standardInfo->EndOfFile;

    if (standardInfo->EndOfFile.QuadPart > BIGGER_THAN_AN_ALLOCATION_REGION) {
        rangeToZero.QuadPart = inArb->FileOffset.QuadPart = standardInfo->EndOfFile.QuadPart - BIGGER_THAN_AN_ALLOCATION_REGION;
        rangeToZero.QuadPart -= rangeToZero.QuadPart % BIGGER_THAN_AN_ALLOCATION_REGION;    // round it down.
    } else {
        rangeToZero.QuadPart = inArb->FileOffset.QuadPart = 0;
    }
    inArb->Length.QuadPart = MAXLONGLONG - inArb->FileOffset.QuadPart;

    if (!DeviceIoControl(
            restoredFileHandle,
            FSCTL_QUERY_ALLOCATED_RANGES,
            inArb,
            sizeof(FILE_ALLOCATED_RANGE_BUFFER),
            outArb,
            sizeof(FILE_ALLOCATED_RANGE_BUFFER) * outArbSize,
            &bytesReturned,
            NULL)) {                        // lap
#if     DBG
        DbgPrint("SisFixValidDataLength: unable to query allocated ranges on link file, %d\n",GetLastError());
#endif  // DBG
        return STATUS_UNSUCCESSFUL;
    }

    ASSERT(bytesReturned / sizeof(FILE_ALLOCATED_RANGE_BUFFER) < outArbSize);   // this relies on knowledge about the minimum allocated range size
    ASSERT(bytesReturned % sizeof(FILE_ALLOCATED_RANGE_BUFFER) == 0);

    if (bytesReturned > 0) {
        unsigned lastElement = bytesReturned/sizeof(FILE_ALLOCATED_RANGE_BUFFER) - 1;
        ASSERT(lastElement < outArbSize);
        rangeToZero.QuadPart = outArb[lastElement].FileOffset.QuadPart + outArb[lastElement].Length.QuadPart;
    }

    status = NtQueryInformationFile(
                restoredFileHandle,
                Iosb,
                basicInfo,
                sizeof(FILE_BASIC_INFORMATION),
                FileBasicInformation);
    if (NT_SUCCESS(status)) {
        ASSERT(STATUS_PENDING != status);   // because we didn't open the file for overlapped.
        basicInfoValid = TRUE;
    } else {
#if     DBG
        DbgPrint("SisFixValidDataLength: unable to query basic info on link file, 0x%x\n",status);
#endif  // DBG
    }

    WriteOffset.QuadPart = ((standardInfo->EndOfFile.QuadPart +
                             restoreVolumeStructure->VolumeSectorSize +
                             BIGGER_THAN_AN_ALLOCATION_REGION) / restoreVolumeStructure->VolumeSectorSize) *
                                    restoreVolumeStructure->VolumeSectorSize;
    ASSERT(WriteOffset.QuadPart >= standardInfo->EndOfFile.QuadPart);
    ASSERT(standardInfo->EndOfFile.QuadPart + restoreVolumeStructure->VolumeSectorSize < WriteOffset.QuadPart);

    if ((WriteOffset.LowPart != SetFilePointer(
                                    restoredFileHandle,
                                    WriteOffset.LowPart,
                                    &WriteOffset.HighPart,
                                    FILE_BEGIN))
        || (NO_ERROR != GetLastError())) {
#if     DBG
        DbgPrint("SisFixValidDataLength: unable to SetFilePointer, %d\n",GetLastError());
#endif  // DBG
        return STATUS_UNSUCCESSFUL;
    }

    if (!WriteFile(restoredFileHandle,
                    restoreVolumeStructure->alignedSectorBuffer,
                    restoreVolumeStructure->VolumeSectorSize,                       // bytes to write
                    &nBytesWritten,
                    NULL)) {                // overlapped
#if     DBG
        DbgPrint("SisFixValidDataLength: unable to append a byte to advance ValidDataLength, %d\n",GetLastError());
#endif  // DBG
    }

    //
    // Truncate the file, erasing the sector we just wrote.
    //
    status = NtSetInformationFile(
                restoredFileHandle,
                Iosb,
                endOfFileInfo,
                sizeof(FILE_END_OF_FILE_INFORMATION),
                FileEndOfFileInformation);

    if (rangeToZero.QuadPart < standardInfo->EndOfFile.QuadPart) {
        //
        // Re-zero the end of the file in order to deallocate it.
        //
        zeroInfo->FileOffset = rangeToZero;
        zeroInfo->BeyondFinalZero.QuadPart = MAXLONGLONG;

        if (!DeviceIoControl(
                restoredFileHandle,
                FSCTL_SET_ZERO_DATA,
                zeroInfo,
                sizeof(FILE_ZERO_DATA_INFORMATION),
                NULL,                               // output buffer
                0,                                  // o.b. size
                &bytesReturned,
                NULL)) {                            // overlapped
#if     DBG
            DbgPrint("SisFixValidDataLength: unable to zero trailing portion of file, %d\n",GetLastError());
#endif  // DBG
        }
    }

#if     DBG
    if (!NT_SUCCESS(status)) {
        DbgPrint("SisFixValidDataLength: unable to truncate file after extending it to advance ValidDataLength, 0x%x\n",status);
    }
#endif  // DBG


    //
    // Reset the dates on the file.
    //
    status = NtSetInformationFile(
                restoredFileHandle,
                Iosb,
                basicInfo,
                sizeof(FILE_BASIC_INFORMATION),
                FileBasicInformation);
#if     DBG
    if (!NT_SUCCESS(status)) {
        DbgPrint("SisFixValidDataLength: unable to reset times after extending file to advance ValidDataLength, 0x%x\n",status);
    }
#endif  // DBG

    return status;
}


NTSTATUS
SisRestoredLinkI(
    IN PVOID                        sisRestoreStructure,
    IN PWCHAR                       restoredFileName,
    IN PVOID                        reparseData,
    IN ULONG                        reparseDataSize,
    OUT PULONG                      countOfCommonStoreFilesToRestore,
    OUT PWCHAR                      **commonStoreFilesToRestore)
{
    PSIB_RESTORE_VOLUME_STRUCTURE   restoreVolumeStructure = (PSIB_RESTORE_VOLUME_STRUCTURE)sisRestoreStructure;
    PREPARSE_DATA_BUFFER            reparseDataBuffer = (PREPARSE_DATA_BUFFER)reparseData;
    PSI_REPARSE_BUFFER              sisReparseBuffer = (PSI_REPARSE_BUFFER)reparseDataBuffer->GenericReparseBuffer.DataBuffer;
    RestoreFileEntry                entry[1];
    RestoreFileEntry                *foundEntry, *newEntry;
    PWCHAR                          CSFileName = NULL;
    BOOLEAN                         foundCSFile;
    HANDLE                          fileHandle;
    BOOLEAN                         openFile = TRUE;
    NTSTATUS                        status;
    DWORD                           bytesReturned;
    DWORD                           fileAttributes;
    BOOLEAN                         readonlyAttributeCleared = FALSE;

    EnterCriticalSection(restoreVolumeStructure->criticalSection);

    if (NonSISEnabledVolume(restoreVolumeStructure)) {
        //
        // This isn't a SIS enabled volume, so tell the user that.
        // There's no NT status code corresponding to ERROR_VOLUME_NOT_SIS_ENABLED,
        // so we set the win32 code and return STATUS_UNSUCCESSFUL, which makes
        // the wrapper function not change the win32 error.
        //

        SetLastError(ERROR_VOLUME_NOT_SIS_ENABLED);

        status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // Do consistency checks on the reparse point to see if we can understand it.
    //  

    if (reparseDataSize != SIS_REPARSE_DATA_SIZE) {
        //
        // It's the wrong size to contain a SIS reparse buffer, so we don't
        // want to restore any CS files based on it.
        //

        status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    if (IO_REPARSE_TAG_SIS != reparseDataBuffer->ReparseTag ||
        sizeof(SI_REPARSE_BUFFER) != reparseDataBuffer->ReparseDataLength) {
        //
        // The size or tag is wrong.  Ignore it.
        //

        status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    if ((SIS_REPARSE_BUFFER_FORMAT_VERSION != sisReparseBuffer->ReparsePointFormatVersion) &&
        (4 != sisReparseBuffer->ReparsePointFormatVersion)) {
        //
        // We don't understand this format SIS reparse point.  This is probably an
        // old dll version.
        //

        status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    //
    // The only thing we really care about is the CSid and checksum of the file.  See if we've
    // already returned a file with a matching CSid by looking in the tree.
    //
    entry->CSid = sisReparseBuffer->CSid;
    
    foundEntry = restoreVolumeStructure->linkTree->findFirstLessThanOrEqualTo(entry);

    if ((NULL != foundEntry) && (*foundEntry == entry)) {
        //
        // We already returned the CS file that backs this link.  Enter the name of this file
        // on the linked list for this CS file.
        //

        PendingRestoredFile *restoredFile = new PendingRestoredFile;
        if (NULL == restoredFile) {
            LeaveCriticalSection(restoreVolumeStructure->criticalSection);

#if     DBG
            DbgPrint("couldn't allocate restored file\n");
#endif  // DBG

            return STATUS_INSUFFICIENT_RESOURCES;
        }
        int bLen = ((wcslen(restoredFileName) + 1) * sizeof(WCHAR) );
        restoredFile->fileName = (PWCHAR) malloc(bLen);
        if (NULL == restoredFile->fileName) {
            delete restoredFile;

#if     DBG
            DbgPrint("couldn't allocate restored file filename\n");
#endif  // DBG
            LeaveCriticalSection(restoreVolumeStructure->criticalSection);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        (void)StringCbCopyW(restoredFile->fileName,bLen,restoredFileName);
        restoredFile->CSFileChecksum = sisReparseBuffer->CSChecksum;
        restoredFile->next = foundEntry->files;
        foundEntry->files = restoredFile;
        
        goto RestoreNoCSFiles;
    }

    //
    // This is the first time we've seen this particular CS file.  See if it still
    // exists in the \SIS Common Store directory.
    //

    status = FilenameFromCSid(&sisReparseBuffer->CSid,restoreVolumeStructure->volumeRoot,&CSFileName);

    if (!NT_SUCCESS(status)) {
        if (NULL != CSFileName) {
            free(CSFileName);
        }
        LeaveCriticalSection(restoreVolumeStructure->criticalSection);
        return status;
    }

    fileHandle = CreateFileW(
                    CSFileName,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_BACKUP_SEMANTICS|FILE_ATTRIBUTE_NORMAL,
                    NULL);

    free(CSFileName);
    CSFileName = NULL;    

    if (INVALID_HANDLE_VALUE == fileHandle) {
        if (GetLastError() == ERROR_SHARING_VIOLATION) {
            //
            // The file exists, we just couldn't open it.
            //
            foundCSFile = TRUE;
        } else {
            foundCSFile = FALSE;
        }
    } else {
        foundCSFile = TRUE;
        CloseHandle(fileHandle);
    }

    if (foundCSFile) {
        //
        // We don't add it to the tree here, even though that might speed up things somewhat.
        // The reason is that someone could come along and delete all of the references to the
        // file (including the one that we just created) and then the backing file would go away.
        // If we'd entered it in the tree, and we try to restore a subsequent link to the file,
        // we'd not notice that the backing file was gone and would restore a dangling link.
        //

        openFile = FALSE;   // There's no need to open this file, since it's a good link.

        HANDLE restoredFileHandle = CreateFileW(
                                        restoredFileName,
                                        GENERIC_READ | GENERIC_WRITE,
                                        FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_NO_BUFFERING|FILE_OPEN_REPARSE_POINT,
                                        NULL);

        if (INVALID_HANDLE_VALUE == restoredFileHandle) {
            fileAttributes = GetFileAttributesW(restoredFileName);

            if (fileAttributes & FILE_ATTRIBUTE_READONLY) {
                DWORD newFileAttributes = fileAttributes & ~FILE_ATTRIBUTE_READONLY;
                if (0 == newFileAttributes) {
                    newFileAttributes = FILE_ATTRIBUTE_NORMAL;
                }

                if (!SetFileAttributesW(restoredFileName,newFileAttributes)) {
#if     DBG
                    DbgPrint("sisbkup: SisRestoredLinkI: unable to reset read only attribute on link, %d\n",GetLastError());
#endif  DBG
                } else {
                    readonlyAttributeCleared = TRUE;
                }

                //
                // Now that we've (tried to) cleared the read only attribute, re-try the file open.
                //
                restoredFileHandle = CreateFileW(
                                        restoredFileName,
                                        GENERIC_READ | GENERIC_WRITE,
                                        FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_NO_BUFFERING|FILE_OPEN_REPARSE_POINT,
                                        NULL);
            }
        }

        if (INVALID_HANDLE_VALUE != restoredFileHandle) {
            
        } else {
#if     DBG
            DbgPrint("SisRestoredLinkI: Unable to open link file in order to fix ValidDataLength, %d\n",::GetLastError());
#endif  // DBG

            status = STATUS_UNSUCCESSFUL;   // This will leave the win32 error code undisturbed
            goto Error;
        }

        CHAR reparseBuffer[SIS_REPARSE_DATA_SIZE];
        
        if (!DeviceIoControl(
                restoredFileHandle,
                FSCTL_GET_REPARSE_POINT,
                0,
                NULL,
                reparseBuffer,
                SIS_REPARSE_DATA_SIZE,
                &bytesReturned,
                NULL)) {
#if     DBG
            DbgPrint("SisRestoredLinkI: Unable to get reparse point, %d\n",::GetLastError());
#endif  // DBG
            
            status = STATUS_UNSUCCESSFUL;   // This will leave the win32 error code undisturbed
            goto Error;
        }

        status = SisFixValidDataLengthI(restoreVolumeStructure,restoredFileHandle);


        if (!NT_SUCCESS(status)) {
#if     DBG
            DbgPrint("SisRestoredLink: unable to fix up valid data length, 0x%x, %d\n",status,::GetLastError());
#endif  // DBG
            CloseHandle(restoredFileHandle);
            goto Error;
        }

        //
        // Reset the reparse point, which has been destroyed by the last operation.
        //

        if (!DeviceIoControl(
                restoredFileHandle,
                FSCTL_SET_REPARSE_POINT,
                reparseData,
                reparseDataSize,
                NULL,
                0,
                &bytesReturned,
                NULL)) {
#if     DBG
            DbgPrint("SisRestoredLink: unable to reset reparse point, %d\n",::GetLastError());
#endif  // DBG
            CloseHandle(restoredFileHandle);
            status = STATUS_UNSUCCESSFUL;   // This will leave the win32 error code undisturbed

            goto Error;
        }

        CloseHandle(restoredFileHandle);

        if (readonlyAttributeCleared) {
            SetFileAttributesW(restoredFileName,fileAttributes);
            readonlyAttributeCleared = FALSE;
        }

        goto RestoreNoCSFiles;
    }

    //
    // It's not already in the common store directory.  Enter it in the tree and return it to
    // the user.
    //

    newEntry = new RestoreFileEntry;
    if (NULL == newEntry) {
        LeaveCriticalSection(restoreVolumeStructure->criticalSection);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    newEntry->CSid = sisReparseBuffer->CSid;

    newEntry->files = new PendingRestoredFile;
    if (NULL == newEntry->files) {
        LeaveCriticalSection(restoreVolumeStructure->criticalSection);

        delete newEntry;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    int bLen = ((wcslen(restoredFileName) + 1) * sizeof(WCHAR));
    newEntry->files->next = NULL;
    newEntry->files->fileName = (PWCHAR) malloc(bLen);
    newEntry->files->CSFileChecksum = sisReparseBuffer->CSChecksum;
    if (NULL == newEntry->files->fileName) {
        LeaveCriticalSection(restoreVolumeStructure->criticalSection);

        delete newEntry->files;
        delete newEntry;

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    (void)StringCbCopyW(newEntry->files->fileName,bLen,restoredFileName);

    if (!restoreVolumeStructure->linkTree->insert(newEntry)) {
        *countOfCommonStoreFilesToRestore = 0;
        
        LeaveCriticalSection(restoreVolumeStructure->criticalSection);

        delete newEntry->files;
        delete newEntry;        

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *countOfCommonStoreFilesToRestore = 1;

    *commonStoreFilesToRestore = (PWCHAR *)malloc(sizeof(PWCHAR) * *countOfCommonStoreFilesToRestore);

    if (NULL == *commonStoreFilesToRestore) {
        restoreVolumeStructure->linkTree->remove(newEntry);
        *countOfCommonStoreFilesToRestore = 0;
        
        LeaveCriticalSection(restoreVolumeStructure->criticalSection);

        delete newEntry->files;
        delete newEntry;

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = FilenameFromCSid(
                &sisReparseBuffer->CSid,
                restoreVolumeStructure->volumeRoot,
                &(*commonStoreFilesToRestore)[0]);

    if (!NT_SUCCESS(status)) {
        restoreVolumeStructure->linkTree->remove(newEntry);
        *countOfCommonStoreFilesToRestore = 0;
        
        LeaveCriticalSection(restoreVolumeStructure->criticalSection);

        free(*commonStoreFilesToRestore);

        delete newEntry->files;
        delete newEntry;

        return status;
    }
                
    if (openFile) {
        TryOpeningFile(restoredFileName);
    }

    LeaveCriticalSection(restoreVolumeStructure->criticalSection);

    return STATUS_SUCCESS;

RestoreNoCSFiles:

    *countOfCommonStoreFilesToRestore = 0;
    *commonStoreFilesToRestore = NULL;

    if (openFile) {
        TryOpeningFile(restoredFileName);
    }

    LeaveCriticalSection(restoreVolumeStructure->criticalSection);

    return STATUS_SUCCESS;

Error:

    *countOfCommonStoreFilesToRestore = 0;
    *commonStoreFilesToRestore = NULL;

    if (readonlyAttributeCleared) {
        SetFileAttributesW(restoredFileName,fileAttributes);
    }

    if (openFile) {
        TryOpeningFile(restoredFileName);
    }

    LeaveCriticalSection(restoreVolumeStructure->criticalSection);

    return status;
}

NTSTATUS
SisRestoredCommonStoreFileI(
    IN PVOID                        sisRestoreStructure,
    IN PWCHAR                       commonStoreFileName)
{
    PSIB_RESTORE_VOLUME_STRUCTURE   restoreVolumeStructure = (PSIB_RESTORE_VOLUME_STRUCTURE)sisRestoreStructure;
    HANDLE                          fileHandle = INVALID_HANDLE_VALUE;
    NTSTATUS                        status;
    DWORD                           bytesRead, bytesWritten;
    LONGLONG                        checksum;
    CSID                            CSid;
    RestoreFileEntry                entry[1];
    RestoreFileEntry                *foundEntry, *newEntry;
    PWCHAR                          BPStreamName = NULL;

    status = CSidFromFilename(commonStoreFileName,&CSid);

    if (!NT_SUCCESS(status)) {
        //
        // It was a bogus filename.  Punt.
        //

        return status;
    }

    int bLen ((wcslen(commonStoreFileName) + 1) * sizeof(WCHAR) + BACKPOINTER_STREAM_NAME_SIZE);    //in bytes
    BPStreamName = (PWCHAR) malloc(bLen);
    if (NULL == BPStreamName) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    (void)StringCbCopyW(BPStreamName, bLen, commonStoreFileName);
    (void)StringCbCatW(BPStreamName, bLen, BACKPOINTER_STREAM_NAME);

    //
    // We just need to reinitialize the backpointer stream for this file so that it looks like
    // it has no references.
    //

    EnterCriticalSection(restoreVolumeStructure->criticalSection);

    if (NonSISEnabledVolume(restoreVolumeStructure)) {
        //
        // This isn't a SIS enabled volume, so tell the user that.
        // There's no NT status code corresponding to ERROR_VOLUME_NOT_SIS_ENABLED,
        // so we set the win32 code and return STATUS_UNSUCCESSFUL, which makes
        // the wrapper function not change the win32 error.
        //

        SetLastError(ERROR_VOLUME_NOT_SIS_ENABLED);
        status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // Now open the file.
    //

    fileHandle = CreateFileW(
                    BPStreamName,
                    GENERIC_READ | GENERIC_WRITE,
                    0,                              // exclusive
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
                    NULL);

    free(BPStreamName);
    BPStreamName = NULL;

    if (INVALID_HANDLE_VALUE == fileHandle) {
        status = STATUS_UNSUCCESSFUL;       // This will cause the C wrapper to not call SetLastError
#if     DBG
        DbgPrint("SisRestoredCommonStoreFile: unable to open common store file, %d\n",GetLastError());
#endif  // DBG
        goto Error;
    }

    //
    // Read in the first sector.
    //
    if (!ReadFile(
            fileHandle,
            restoreVolumeStructure->sector,
            restoreVolumeStructure->VolumeSectorSize,
            &bytesRead,
            NULL)) {

        status = STATUS_UNSUCCESSFUL;       // This will cause the C wrapper to not call SetLastError
#if     DBG
        DbgPrint("SisRestoredCommonStoreFile: Unable to read in first BP sector, %d\n",GetLastError());
#endif  // DBG
        goto Error;
    }

    if (bytesRead < sizeof(SIS_BACKPOINTER_STREAM_HEADER)) {

        status = STATUS_UNSUCCESSFUL;       // This will cause the C wrapper to not call SetLastError
        goto Error;
    }

#define Header ((PSIS_BACKPOINTER_STREAM_HEADER)restoreVolumeStructure->sector)

    if ((BACKPOINTER_STREAM_FORMAT_VERSION != Header->FormatVersion) ||
        (BACKPOINTER_MAGIC != Header->Magic)) {
#undef  Header

#if     DBG
        DbgPrint("SisRectoredCommonStoreFile: restored CS file has bogus header format version/Magic\n");
#endif  // DBG
        
    } else {
        //
        // Fill in the backpointer portion of the sector with
        // null entries.
        //
        for (unsigned i = SIS_BACKPOINTER_RESERVED_ENTRIES;
             i < (restoreVolumeStructure->VolumeSectorSize / sizeof(SIS_BACKPOINTER));
             i++) {
            restoreVolumeStructure->sector[i].LinkFileIndex.QuadPart = MAXLONGLONG;
            restoreVolumeStructure->sector[i].LinkFileNtfsId.QuadPart = MAXLONGLONG;
        }

        //
        // Write out the new sector.
        //
        SetFilePointer(fileHandle,0,NULL,FILE_BEGIN);
    
        if (!WriteFile(
            fileHandle,
            restoreVolumeStructure->sector,
            restoreVolumeStructure->VolumeSectorSize,
            &bytesWritten,
            NULL)) {
#if     DBG 
            DbgPrint("SisRestoredCommonStoreFile: write failed %d\n",GetLastError());
#endif  // DBG
        }
    }

    //
    // Make the stream be exactly one sector long.
    //
    SetFilePointer(fileHandle,restoreVolumeStructure->VolumeSectorSize,NULL,FILE_BEGIN);
    SetEndOfFile(fileHandle);

    CloseHandle(fileHandle);
    fileHandle = INVALID_HANDLE_VALUE;

    //
    // Look up in the tree and find the files that we restored to this link.
    // Open them and rewrite their reparse points.
    //

    entry->CSid = CSid;

    foundEntry = restoreVolumeStructure->linkTree->findFirstLessThanOrEqualTo(entry);
    if ((NULL != foundEntry) && (*foundEntry == entry)) {
        //
        // We've got a match.  Cruise the list and set the reparse points on all of the
        // files.
        //


        while (NULL != foundEntry->files) {
            HANDLE                  restoredFileHandle;
            PendingRestoredFile     *thisFile = foundEntry->files;
            DWORD                   bytesReturned;
            DWORD                   fileAttributes;
            BOOLEAN                 readOnlyAttributeCleared = FALSE;

            restoredFileHandle = CreateFileW(
                                    thisFile->fileName,
                                    GENERIC_READ | GENERIC_WRITE,
                                    0,                              // exclusive
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_NO_BUFFERING,
                                    NULL);

            if (INVALID_HANDLE_VALUE == restoredFileHandle) {
                //
                // Check the read only file attribute, and reset it if necessary.
                //
                fileAttributes = GetFileAttributesW(thisFile->fileName);
                if (fileAttributes & FILE_ATTRIBUTE_READONLY) {
                    DWORD newFileAttributes = fileAttributes & ~FILE_ATTRIBUTE_READONLY;
                    if (0 == newFileAttributes) {
                        newFileAttributes = FILE_ATTRIBUTE_NORMAL;
                    }
                    if (!SetFileAttributesW(thisFile->fileName,newFileAttributes)) {
#if     DBG
                        DbgPrint("sisbkup: unable to clear read only attribute on file %ws\n",thisFile->fileName);
#endif  // DBG
                    }
                    readOnlyAttributeCleared = TRUE;

                    restoredFileHandle = CreateFileW(
                                            thisFile->fileName,
                                            GENERIC_READ | GENERIC_WRITE,
                                            0,                              // exclusive
                                            NULL,
                                            OPEN_EXISTING,
                                            FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_NO_BUFFERING,
                                            NULL);

                }
            } 

            if (INVALID_HANDLE_VALUE != restoredFileHandle) {
                SisFixValidDataLengthI(restoreVolumeStructure, restoredFileHandle);
                
                //
                // Rewrite the reparse point.
                //
                CHAR reparseBuffer[SIS_REPARSE_DATA_SIZE];
                PSI_REPARSE_BUFFER sisReparseBuffer;
#define reparseData ((PREPARSE_DATA_BUFFER)reparseBuffer)

                reparseData->ReparseTag = IO_REPARSE_TAG_SIS;
                reparseData->Reserved = 0xb010;     // ??
                reparseData->ReparseDataLength = sizeof(SI_REPARSE_BUFFER);

                sisReparseBuffer = (PSI_REPARSE_BUFFER)reparseData->GenericReparseBuffer.DataBuffer;

                sisReparseBuffer->ReparsePointFormatVersion = SIS_REPARSE_BUFFER_FORMAT_VERSION;
                sisReparseBuffer->Reserved = 0xb111b010;
                sisReparseBuffer->CSid = CSid;
                sisReparseBuffer->LinkIndex.QuadPart = 0;           // This just gets reset by the filter driver
                sisReparseBuffer->LinkFileNtfsId.QuadPart = 0;      // This just gets reset by the filter driver
                sisReparseBuffer->CSFileNtfsId.QuadPart = 0;        // This just gets reset by the filter driver

                //
                // Use the CS file checksum that was read from the reparse point on the backup
                // tape.  We need this for security reasons, because otherwise a bogus backed up
                // link could suddenly become valid.
                //

                sisReparseBuffer->CSChecksum = thisFile->CSFileChecksum;

                //
                // Compute the checksum.
                //
                sisReparseBuffer->Checksum.QuadPart = 0;
                SipComputeChecksum(
                    sisReparseBuffer,
                    sizeof(SI_REPARSE_BUFFER) - sizeof sisReparseBuffer->Checksum,
                    &sisReparseBuffer->Checksum.QuadPart);

                //
                // Set the reparse point.
                //
                if (!DeviceIoControl(
                        restoredFileHandle,
                        FSCTL_SET_REPARSE_POINT,
                        reparseBuffer,
                        FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) +
                            reparseData->ReparseDataLength,
                        NULL,
                        0,
                        &bytesReturned,
                        NULL)) {
#if     DBG
                    DbgPrint("sisbackup: SisRestoredCommonStoreFile: set reparse point failed %d\n",GetLastError());
#endif  // DBG
                }

                CloseHandle(restoredFileHandle);
                
#undef  reparseData
            } else {
#if     DBG
                DbgPrint("sisbackup: unable to open link file for file %ws, %d\n",thisFile->fileName,GetLastError());
#endif  // DBG
            }

            if (readOnlyAttributeCleared) {
                if (!SetFileAttributesW(thisFile->fileName,fileAttributes)) {
#if     DBG
                    DbgPrint("sisbackup: unable to reset read only attribute on %ws\n",thisFile->fileName);
#endif  // DBG
                }
            }

            foundEntry->files = thisFile->next;
            free(thisFile->fileName);
            delete thisFile;
        }

        restoreVolumeStructure->linkTree->remove(foundEntry);
        delete foundEntry;
    } else {
#if     DBG
        DbgPrint("restored common store file: didn't find tree match\n");
#endif  // DBG
    }


    LeaveCriticalSection(restoreVolumeStructure->criticalSection);

    return STATUS_SUCCESS;

Error:

    if (INVALID_HANDLE_VALUE != fileHandle) {
        CloseHandle(fileHandle);
    }

    LeaveCriticalSection(restoreVolumeStructure->criticalSection);

    return status;
}

NTSTATUS
SisFreeRestoreStructureI(
    IN PVOID                        sisRestoreStructure)
{
    PSIB_RESTORE_VOLUME_STRUCTURE   restoreVolumeStructure = (PSIB_RESTORE_VOLUME_STRUCTURE)sisRestoreStructure;
    RestoreFileEntry *entry;

    //
    // Cruise the link tree and clean up any remaining file entries.
    //
    while (NULL != (entry = restoreVolumeStructure->linkTree->findMin())) {

        while (NULL != entry->files) {
            PendingRestoredFile *thisFile = entry->files;

            entry->files = thisFile->next;

            free(thisFile->fileName);
            delete thisFile;
        }

        restoreVolumeStructure->linkTree->remove(entry);
    }

    DeleteCriticalSection(restoreVolumeStructure->criticalSection);

    free(restoreVolumeStructure->sector);
    free(restoreVolumeStructure->alignedSectorBuffer);
    free(restoreVolumeStructure->volumeRoot);
    delete restoreVolumeStructure->linkTree;
    free(restoreVolumeStructure);

    return STATUS_SUCCESS;
}


extern "C" {

BOOL __stdcall
SisCreateBackupStructure(
    IN PWCHAR                       volumeRoot,
    OUT PVOID                       *sisBackupStructure,
    OUT PWCHAR                      *commonStoreRootPathname,
    OUT PULONG                      countOfCommonStoreFilesToBackup,
    OUT PWCHAR                      **commonStoreFilesToBackup)
{
    NTSTATUS status;

    status = SisCreateBackupStructureI(
                        volumeRoot,
                        sisBackupStructure,
                        commonStoreRootPathname,
                        countOfCommonStoreFilesToBackup,
                        commonStoreFilesToBackup);

    if (STATUS_UNSUCCESSFUL != status) {
        SetLastError(RtlNtStatusToDosError(status));
    }
    return NT_SUCCESS(status);
}


BOOL __stdcall
SisCSFilesToBackupForLink(
    IN PVOID                        sisBackupStructure,
    IN PVOID                        reparseData,
    IN ULONG                        reparseDataSize,
    IN PVOID                        thisFileContext                     OPTIONAL,
    OUT PVOID                       *matchingFileContext                OPTIONAL,
    OUT PULONG                      countOfCommonStoreFilesToBackup,
    OUT PWCHAR                      **commonStoreFilesToBackup)
{
    NTSTATUS status;

    status = SisCSFilesToBackupForLinkI(
                        sisBackupStructure,
                        reparseData,
                        reparseDataSize,
                        thisFileContext,
                        matchingFileContext,
                        countOfCommonStoreFilesToBackup,
                        commonStoreFilesToBackup);

    if (STATUS_UNSUCCESSFUL != status) {
        SetLastError(RtlNtStatusToDosError(status));
    }
    return NT_SUCCESS(status);
}

BOOL __stdcall
SisFreeBackupStructure(
    IN PVOID                        sisBackupStructure)
{
    NTSTATUS status;

    status = SisFreeBackupStructureI(
                            sisBackupStructure);

    if (STATUS_UNSUCCESSFUL != status) {
        SetLastError(RtlNtStatusToDosError(status));
    }
    return NT_SUCCESS(status);
}

BOOL __stdcall
SisCreateRestoreStructure(
    IN PWCHAR                       volumeRoot,
    OUT PVOID                       *sisRestoreStructure,
    OUT PWCHAR                      *commonStoreRootPathname,
    OUT PULONG                      countOfCommonStoreFilesToRestore,
    OUT PWCHAR                      **commonStoreFilesToRestore)
{
    NTSTATUS status;

    status = SisCreateRestoreStructureI(
                        volumeRoot,
                        sisRestoreStructure,
                        commonStoreRootPathname,
                        countOfCommonStoreFilesToRestore,
                        commonStoreFilesToRestore);

    if (STATUS_UNSUCCESSFUL != status) {
        SetLastError(RtlNtStatusToDosError(status));
    }
    return NT_SUCCESS(status);
}

BOOL __stdcall
SisRestoredLink(
    IN PVOID                        sisRestoreStructure,
    IN PWCHAR                       restoredFileName,
    IN PVOID                        reparseData,
    IN ULONG                        reparseDataSize,
    OUT PULONG                      countOfCommonStoreFilesToRestore,
    OUT PWCHAR                      **commonStoreFilesToRestore)
{
    NTSTATUS status;

    status = SisRestoredLinkI(
                        sisRestoreStructure,
                        restoredFileName,
                        reparseData,
                        reparseDataSize,
                        countOfCommonStoreFilesToRestore,
                        commonStoreFilesToRestore);

    if (STATUS_UNSUCCESSFUL != status) {
        SetLastError(RtlNtStatusToDosError(status));
    }
    return NT_SUCCESS(status);
}

BOOL __stdcall
SisRestoredCommonStoreFile(
    IN PVOID                        sisRestoreStructure,
    IN PWCHAR                       commonStoreFileName)
{
    NTSTATUS status;

    status =  SisRestoredCommonStoreFileI(
                        sisRestoreStructure,
                        commonStoreFileName);

    if (STATUS_UNSUCCESSFUL != status) {
        SetLastError(RtlNtStatusToDosError(status));
    }
    return NT_SUCCESS(status);
}

BOOL __stdcall
SisFreeRestoreStructure(
    IN PVOID                        sisRestoreStructure)
{
    NTSTATUS status;

    status = SisFreeRestoreStructureI(
                        sisRestoreStructure);

    if (STATUS_UNSUCCESSFUL != status) {
        SetLastError(RtlNtStatusToDosError(status));
    }
    return NT_SUCCESS(status);
}

VOID __stdcall
SisFreeAllocatedMemory(
    IN PVOID                        allocatedSpace)
{
    if (NULL != allocatedSpace) {
        free(allocatedSpace);
    }
}

BOOL WINAPI DLLEntryPoint(HANDLE hDLL, DWORD dwReason, LPVOID lpReserved)
{
  return( TRUE );
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\tools\cf\cf.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cf.c


Abstract:

    This module implements a utlity that copies files using the
    Single Instance Store file system filter functionality.

Author:

    Scott Cutshall  [scottc]        8-July-1997

Revision History:

--*/

#include "cf.h"


//
//  We can have:   cf SrcPath DstPath {-o NtFileNameOfFileOnWhichToMakeTheCall}
//


#define	BUFF_SIZE 2048

void __cdecl
main(
    int argc,
    char **argv
    )

{
	NTSTATUS        Status;
	IO_STATUS_BLOCK IoStatusBlock;
	HANDLE          volHandle;
	UNICODE_STRING	srcFileName, dstFileName;
	UNICODE_STRING	srcDosFileName, dstDosFileName;
	UNICODE_STRING	callOnFileName;
	PSI_COPYFILE	copyFile;
	ULONG			NameBuffer[BUFF_SIZE];
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
	int i;

	copyFile = (PSI_COPYFILE) NameBuffer;

    if (argc != 3 && argc != 5)
	    Usage();

	if (argc == 5) {
		if (strcmp(argv[3],"-o")) {
			Usage();
		}
		
	}

    //
	// Convert the ansii names to unicode and place in the copyFile buffer.
    //

    RtlCreateUnicodeStringFromAsciiz( &srcDosFileName, argv[1] );
    RtlCreateUnicodeStringFromAsciiz( &dstDosFileName, argv[2] );

    RtlDosPathNameToNtPathName_U(
        srcDosFileName.Buffer,
        &srcFileName,
        NULL,
        NULL );

    RtlDosPathNameToNtPathName_U(
        dstDosFileName.Buffer,
        &dstFileName,
        NULL,
        NULL );

	copyFile->SourceFileNameLength = srcFileName.Length + sizeof(WCHAR);
	copyFile->DestinationFileNameLength = dstFileName.Length + sizeof(WCHAR);
	copyFile->Flags = COPYFILE_SIS_REPLACE;

	RtlCopyMemory(
		&copyFile->FileNameBuffer[0],
		srcFileName.Buffer,
		copyFile->SourceFileNameLength);

	RtlCopyMemory(
		&copyFile->FileNameBuffer[copyFile->SourceFileNameLength / sizeof(WCHAR)],
		dstFileName.Buffer,
		copyFile->DestinationFileNameLength);

#define	copyFileSize (FIELD_OFFSET(SI_COPYFILE, FileNameBuffer) +		\
					  copyFile->SourceFileNameLength +					\
					  copyFile->DestinationFileNameLength)

	if (argc == 3) {
		//
		// Get a handle to the source file's containing directory to pass into
		// FSCTL_SIS_COPYFILE,
		//

	    for (i = srcFileName.Length / sizeof(WCHAR) - 1;
			 i >= 0 && srcFileName.Buffer[i] != '\\';
			 --i)
			continue;

		srcFileName.Length = (USHORT)(i * sizeof(WCHAR));

	    InitializeObjectAttributes(
    	    &objectAttributes,
        	&srcFileName,
	        OBJ_CASE_INSENSITIVE,
    	    NULL,
        	NULL);
	} else {
		//
		// Get a handle to the NT file specified in argv[4] to send down the call on.
		//
		unsigned i;
		callOnFileName.MaximumLength = callOnFileName.Length = sizeof(WCHAR) * strlen(argv[4]);
		callOnFileName.Buffer = (PWCHAR)malloc(callOnFileName.MaximumLength);
		for (i = 0; i < strlen(argv[4]); i++) {
			callOnFileName.Buffer[i] = argv[4][i];
		}

	    InitializeObjectAttributes(
    	    &objectAttributes,
        	&callOnFileName,
	        OBJ_CASE_INSENSITIVE,
    	    NULL,
        	NULL);
	}

	Status = NtCreateFile(
                    &volHandle,
					GENERIC_READ,
                    &objectAttributes,
                    &ioStatusBlock,
                    NULL,
                    0,
					FILE_SHARE_READ|FILE_SHARE_WRITE,
					OPEN_EXISTING,
					0,
					NULL,
                    0);

	if (!NT_SUCCESS(Status)) {
		if (5 == argc) {
			fprintf(stderr, "Unable to open file, %.*ls (%x)\n",
					callOnFileName.Length / sizeof(WCHAR), callOnFileName.Buffer,  Status);
		} else {
			fprintf(stderr, "Unable to open directory, %.*ls (%x)\n",
					srcFileName.Length / sizeof(WCHAR), srcFileName.Buffer,  Status);
		}
		exit(1);
	}


    //
    //  Invoke the SIS CopyFile FsCtrl.
    //

    Status = NtFsControlFile(
                 volHandle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FSCTL_SIS_COPYFILE,
                 copyFile,		        // Input buffer
                 copyFileSize,			// Input buffer length
                 NULL,                  // Output buffer
                 0 );                   // Output buffer length

    if (NT_SUCCESS( Status )) {

        fprintf( stderr, "NtFsControlFile CopyFile succeeded\n" );

    } else {

        fprintf( stderr, "NtFsControlFile CopyFile failed %x\n", Status );

    }

    exit (0);

}  //  main


void
Usage( void )
{
    fprintf( stderr, "\n" );
    fprintf( stderr, "Usage: cf Path1 Path2 {-o NtFileNameOfFileOnWhichToMakeTheCall}\n" );
    fprintf( stderr, "       cf copies Path1 to Path2 using SIS links.\n" );
	fprintf( stderr, "          if -o is specified, opens that file to send down the call on,\n");
	fprintf( stderr, "          rather than using the directory containing the source file.\n");
    exit(1);

} // Usage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\siscompatibility\siscomprc.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    ftcomprc.h

Abstract:

    Resource ids definitions for ftcomp.rc

Author:

    Cristian Teodorescu   (cristiat)  6-July-2000
    
Notes:

Revision History:

--*/

#define SISCOMP_STR_DESCRIPTION 1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\tools\cf\cf.h ===
#include <stdlib.h>     //  Has exit()
#include <stdio.h>      //  Has printf() and related ...

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>

#include <windows.h>    //  Needs to come after the NT header files.  Has DWORD
#include <winbase.h>

//
//  Private #defines
//

#define SHARE_ALL              (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)
#define GetFileAttributeError  0xFFFFFFFF

#define ATTRIBUTE_TYPE DWORD    //  ULONG, really

#define GET_ATTRIBUTES(FileName, Attributes) Attributes = GetFileAttributes(FileName)

#define IF_GET_ATTR_FAILS(FileName, Attributes) GET_ATTRIBUTES(FileName, Attributes); if (Attributes == GetFileAttributeError)

//
//  Global flags shared throughout.
//
//  ParseArgs is the place where they get set and verified for mutual
//  consistency.
//

BOOLEAN  fAlternateCreateDefault = FALSE;
BOOLEAN  fCopy     = FALSE;
BOOLEAN  fCreate   = FALSE;
BOOLEAN  fDelete   = FALSE;
BOOLEAN  fDisplay  = FALSE;
BOOLEAN  fModify   = FALSE;
BOOLEAN  fRename   = FALSE;
BOOLEAN  fVerbose  = FALSE;
BOOLEAN  fVVerbose = FALSE;



//
//  Signatures of internal routines.
//


void
ParseArgs(
    int argc,
    char *argv[]
    );


void
Usage(
    void
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\siscompatibility\siscomp.c ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    ftcomp.cpp

Abstract:

    This compatibility dll is used by winnt32.exe in order to decide 
    if the SIS groveler is running.  If so it will stop the groveler
    and pop-up a dialog telling them we stopped it.  It will then allow
    the installation to proceed.

Author:

    Neal Christiansen (nealch)  02-May-2002
    
Environment:

    compatibility dll for sis groveler

Notes:

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h>
#include <comp.h>

#include "siscomprc.h"

#define LOCAL_DEBUG (DBG && 0)

//
//  Control local debug display (by default we 
//

#if LOCAL_DEBUG
    #define MyKdPrint( _string ) DbgPrint _string
#else
    #define MyKdPrint( _string )
#endif            

//
//  Global variables
//

SC_HANDLE scm = NULL;       //service control manager handle
HINSTANCE g_hinst = NULL;

//
//  Function prototypes
//

BOOL WINAPI 
SisCompatibilityCheck(
    IN PCOMPAIBILITYCALLBACK    CompatibilityCallback,
    IN LPVOID                   Context
    );

BOOL
StopGrovelerService(
    );

DllMain(
    HINSTANCE   hInstance,
    DWORD       dwReasonForCall,
    LPVOID      lpReserved
    )
{
    BOOL    status = TRUE;
    
    switch( dwReasonForCall )
    {
    case DLL_PROCESS_ATTACH:
        g_hinst = hInstance;
	    DisableThreadLibraryCalls(hInstance);       
        break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    }

    return status;
}


BOOL WINAPI 
SisCompatibilityCheck(
    IN PCOMPAIBILITYCALLBACK    CompatibilityCallback,
    IN LPVOID                   Context
    )

/*++

Routine Description:

    This routine is called by winnt32.exe in order to decide whether the user
    should be warned about the presence of FT sets in a Windows NT 4.0 system
    
Arguments:

    CompatibilityCallback   - Supplies the winnt32 callback

    Context                 - Supplies the compatibility context

Return Value:

    TRUE    if the CompatibilityCallback was called
    FALSE   if it was not

--*/

{   
    COMPATIBILITY_ENTRY ce;
    BOOL retval = FALSE;
    WCHAR description[128];
    
    //
    // Obtain a handle to the service control manager requesting all access
    //
    
    scm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (!scm) {

        //
        //  If we can't access the service control manager, just let the
        //  operation proceed
        //

        return FALSE;
    }

    try {

        if (StopGrovelerService()) {

            if (!LoadString(g_hinst, SISCOMP_STR_DESCRIPTION, description, sizeof(description)/sizeof(WCHAR))) {
                description[0] = 0;
            }

            MyKdPrint(("SisComp!SisCompatibilityCheck: Description=\"%S\"\n",description));

            //
            // The groveler was stopped, display the compatbility entry
            //
    
            ZeroMemory( &ce, sizeof(COMPATIBILITY_ENTRY) );
            ce.Description = description;
            ce.HtmlName = L"compdata\\groveler.htm";
            ce.TextName = L"compdata\\groveler.txt";
            CompatibilityCallback(&ce, Context);
            retval = TRUE;      //mark we called compatibility routine
        }

    } finally {

        CloseServiceHandle(scm);
    }

    return retval;
}


BOOL
StopGrovelerService(
    )
/*++

Routine Description:

    This routine will locate and try and STOP the groveler service.  This
    returns TRUE if the service was stopped, else FALSE (which means it
    was not found or couldn't be stopped)
    
Arguments:

Return Value:

    TRUE    If the service was stopped
    FALSE   if it was not found/stopped

--*/

{   
    SC_HANDLE hGroveler;
    SERVICE_STATUS grovelerStatus;
    BOOL retValue = FALSE;

    try {

        //
        //  Open the groveler service, if it does not exists, just return
        //

        hGroveler = OpenService( scm,
                                 L"groveler",
                                 SERVICE_ALL_ACCESS );

        if (hGroveler == NULL) {

            MyKdPrint(("SisComp!StopGrovelerService: Groveler service not found, status=%d\n",GetLastError()));
            leave;
        }

        MyKdPrint(("SisComp!StopGrovelerService: Groveler service detected\n"));

        //
        //  We opened the groveler service, tell the service to stop.
        //

        if (!ControlService( hGroveler, SERVICE_CONTROL_STOP, &grovelerStatus )) {

            MyKdPrint(("SisComp!StopGrovelerService: Groveler STOP request failed, status=%d\n",GetLastError()));
            leave;
        } 

        //
        //  It was successfully stopped, return correct value
        //

        MyKdPrint(("SisComp!StopGrovelerService: Groveler service stopped\n"));
        retValue = TRUE;

    } finally {

        //
        //  Close the service handle
        //

        if (hGroveler) {

            CloseServiceHandle( hGroveler );
        }
    }

    return retValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\tools\flink\flinks.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    flinks.c


Abstract:

    This module implements a utlity that creates, deletes, renames, lists
    symbolic links.

Author:

    Felipe Cabrera  [cabrera]        17-October-1996

Revision History:

--*/

#include "flinks.h"

//
//  We can have:       flinks ?
//  or,                flinks  Path1  Path2
//  We can also have:  flinks  [/dyv] Path2
//  or,                flinks  [/cmrv] Path1 Path2
//

unsigned LinkType = IO_REPARSE_TAG_SYMBOLIC_LINK;


void __cdecl
main(
    int argc,
    char **argv
    )

{
   NTSTATUS       Status;
   ATTRIBUTE_TYPE Attributes1,           //  Attributes of Path1
                  Attributes2;           //  Attributes of Path2

   char *Path1,                          //  Will point to the full path name.
        *Path2;                          //  Will point to the full path name.

   Attributes1 = GetFileAttributeError;
   Attributes2 = GetFileAttributeError;

   //
   //  Check argument validity and set global action flags.
   //

   ParseArgs( argc, argv );

   //
   //  Do the actions in turn.
   //

   if (fCopy) {

       //
       //  Check for the existence of Path1 getting its attributes.
       //

       IF_GET_ATTR_FAILS(argv[argc - 2], Attributes1) {

           //
           //  Path1 does not exist, hence we cannot copy it.
           //

           fprintf( stderr, "Cannot copy Path1, it does not exist.\n" );
           exit (1);
       }

       //
       //  Path1 needs to be a reparse point to copy a symbolic link.
       //

       if (Attributes1 & FILE_ATTRIBUTE_REPARSE_POINT) {

           //
           //  If Path2 does not exist, create it.
           //

           IF_GET_ATTR_FAILS(argv[argc - 1], Attributes2) {

               //
               //  Need to create this file preserving the kind (file or directory).
               //

               Status = CreateEmptyFile( argv[argc - 1], Attributes1, fVerbose );

               if (!NT_SUCCESS( Status )) {

                   fprintf( stderr, "Cannot create file for symbolic link. Status %x\n", Status );
                   exit (1);

               }
           }

           //
           //  Copy into Path2 the symbolic link in Path1.
           //  Build the full path for Path1 and Path2 and call the copy routine.
           //

           if ((Path1 = _strlwr(_fullpath( NULL, argv[argc - 2], 0))) == NULL) {
                Path1 = argv[argc - 2];
           }
           if ((Path2 = _strlwr(_fullpath( NULL, argv[argc - 1], 0))) == NULL) {
                Path2 = argv[argc - 1];
           }

           Status = CopySymbolicLink( Path1, Path2, Attributes1, fVerbose );

           if (!NT_SUCCESS( Status )) {
               fprintf( stderr, "Cannot copy symbolic link. Status %x\n", Status );
           }

       } else {

           fprintf( stderr, "Cannot copy, Path1 is not a symbolic link.\n" );
       }

       exit (1);
   }   // fCopy

   if (fCreate) {

       //
       //  Check for the existence of Path1 getting its attributes.
       //

       IF_GET_ATTR_FAILS(argv[argc - 2], Attributes1) {

           //
           //  Need to create this file object. As default we create it as a file.
           //

           if (fAlternateCreateDefault) {
               Attributes1 = FILE_ATTRIBUTE_DIRECTORY;
           } else {
               //
               //  We try to create it with the same characteristic of the target,
               //  when we are able to reach the target. Otherwise we use a file
               //  as default.
               //
               Attributes2 = 0xFFFFFFFF;
               IF_GET_ATTR_FAILS(argv[argc - 1], Attributes2) {

                   Attributes1 = FILE_ATTRIBUTE_NORMAL;

               } else {

                  if (Attributes2 & FILE_ATTRIBUTE_DIRECTORY) {

                      Attributes1 = FILE_ATTRIBUTE_DIRECTORY;

                  } else {

                      Attributes1 = FILE_ATTRIBUTE_NORMAL;
                  }
               }
           }

           Status = CreateEmptyFile( argv[argc - 2], Attributes1, fVerbose );

           if (!NT_SUCCESS( Status )) {

               fprintf( stderr, "Cannot create file for symbolic link. Status %x\n", Status );
               Attributes1 = FILE_ATTRIBUTE_REPARSE_POINT;
           }
       }

       //
       //  Path1 needs to be a non-reparse point to create a symbolic link.
       //

       if (!(Attributes1 & FILE_ATTRIBUTE_REPARSE_POINT)) {

           //
           //  Build the full path for Path1 and Path2.
           //

           if ((Path1 = _strlwr(_fullpath( NULL, argv[argc - 2], 0))) == NULL) {
               Path1 = argv[argc - 2];
           }
//           if ((Path2 = _strlwr(_fullpath( NULL, argv[argc - 1], 0))) == NULL) {
               Path2 = argv[argc - 1];
//           }

           Status = CreateSymbolicLink( Path1, Path2, Attributes1, fVerbose );

           if (!NT_SUCCESS( Status )) {
               fprintf( stderr, "Cannot create symbolic link. Status %x\n", Status );
           }

       } else {
           fprintf( stderr, "Cannot create, Path1 is a symbolic link.\n" );
       }

       exit (1);
   }   // fCreate

   if (fDelete) {

       //
       //  Check existence of Path2 path getting the attributes.
       //

       IF_GET_ATTR_FAILS(argv[argc - 1], Attributes2) {
           fprintf( stderr, "Could not find %s (error = %d)\n", argv[argc - 1], GetLastError() );
           exit(1);
       }

       //
       //  Path2 needs to be a reparse point to delete a symbolic link.
       //

       if (Attributes2 & FILE_ATTRIBUTE_REPARSE_POINT) {

           //
           //  Build the full path for Path2, the only path name.
           //

           if ((Path2 = _strlwr(_fullpath( NULL, argv[argc - 1], 0))) == NULL) {
               Path2 = argv[argc - 1];
           }

           Status = DeleteSymbolicLink( Path2, Attributes2, fVerbose );

           if (!NT_SUCCESS( Status )) {
               fprintf( stderr, "Cannot delete symbolic link. Status %x\n", Status );
           }

       } else {

           fprintf( stderr, "Cannot delete, Path2 is not a symbolic link.\n" );
       }

       exit (1);
   }   // fDelete

   if (fDisplay) {

       //
       //  Check existence of Path2 path getting the attributes.
       //

       IF_GET_ATTR_FAILS(argv[argc - 1], Attributes2) {
           fprintf( stderr, "Could not find %s (error = %d)\n", argv[argc - 1], GetLastError() );
           exit(1);
       }

       //
       //  Path2 needs to be a reparse point to display a symbolic link.
       //

       if (Attributes2 & FILE_ATTRIBUTE_REPARSE_POINT) {

           //
           //  Build the full path for Path2, the only path name.
           //

           if ((Path2 = _strlwr(_fullpath( NULL, argv[argc - 1], 0))) == NULL) {
               Path2 = argv[argc - 1];
           }

           Status = DisplaySymbolicLink( Path2, Attributes2, fVerbose );

           if (!NT_SUCCESS( Status )) {
               fprintf( stderr, "Cannot display symbolic link. Status %x\n", Status );
           }

       } else {

           fprintf( stderr, "Cannot display, Path2 is not a symbolic link.\n" );
       }

       exit (1);
   }   // fDisplay

   if (fModify) {

       //
       //  Check for the existence of Path1 getting its attributes.
       //

       IF_GET_ATTR_FAILS(argv[argc - 2], Attributes1) {
           fprintf( stderr, "Could not find Path1 %s (error = %d)\n", argv[argc - 2], GetLastError() );
           exit(1);
       }

       //
       //  Path1 needs to be a reparse point to modify a symbolic link.
       //

       if (Attributes1 & FILE_ATTRIBUTE_REPARSE_POINT) {

           //
           //  Build the full path for Path1 and Path2.
           //

           if ((Path1 = _strlwr(_fullpath( NULL, argv[argc - 2], 0))) == NULL) {
               Path1 = argv[argc - 2];
           }
           if ((Path2 = _strlwr(_fullpath( NULL, argv[argc - 1], 0))) == NULL) {
               Path2 = argv[argc - 1];
           }

           Status = CreateSymbolicLink( Path1, Path2, Attributes1, fVerbose );

           if (!NT_SUCCESS( Status )) {
               fprintf( stderr, "Cannot modify symbolic link. Status %x\n", Status );
           }

       } else {
           fprintf( stderr, "Cannot modify, Path1 is not a symbolic link.\n" );
       }

       exit (1);
   }   // fModify

   if (fRename) {

       //
       //  Check for the existence of Path1 getting its attributes.
       //

       IF_GET_ATTR_FAILS(argv[argc - 2], Attributes1) {
           fprintf( stderr, "Could not find Path1 %s (error = %d)\n", argv[argc - 2], GetLastError() );
           exit(1);
       }

       //
       //  Path1 needs to be a reparse point to rename a symbolic link.
       //

       if (Attributes1 & FILE_ATTRIBUTE_REPARSE_POINT) {

           //
           //  Build the full path for Path1 and Path2.
           //

           if ((Path1 = _strlwr(_fullpath( NULL, argv[argc - 2], 0))) == NULL) {
               Path1 = argv[argc - 2];
           }
           if ((Path2 = _strlwr(_fullpath( NULL, argv[argc - 1], 0))) == NULL) {
               Path2 = argv[argc - 1];
           }

           Status = RenameSymbolicLink( Path1, Path2, Attributes1, fVerbose );

           if (!NT_SUCCESS( Status )) {
               fprintf( stderr, "Cannot rename symbolic link. Status %x\n", Status );
           }

       } else {

           fprintf( stderr, "Cannot rename, Path1 is not a symbolic link.\n" );
       }

       exit (1);
   }   // fRename

   //
   //  We should never go through here ...
   //

   fprintf( stderr, "flinks : NO ACTION WAS PERFORMED!\n" );

}  //  main



void
ParseArgs(
    int argc,
    char *argv[]
    )
/*++

Routine Description:

    Parses the input setting global flags.

Return Value:

    void - no return.

--*/
{
    int ArgCount,
        FlagCount;

    ArgCount  = 1;
    FlagCount = 0;

    //
    // Check that the number of arguments is two or more.
    //

    if (argc < 2) {
        fprintf( stderr, "Too few arguments.\n" );
        Usage();
    }

    do {
        if (IsFlag( argv[ArgCount] )) {

            //
            //  We want all flags to be immediatelly after the command name flinks and
            //  before all other arguments.
            //

            if ((ArgCount > 1) && (FlagCount == 0)) {
                fprintf(stderr, "Flags need to precede the path arguments.\n" );
                Usage();
            }

            //
            //  Verify flag consistency.
            //

            if ((fCopy) && (fModify)) {
                fprintf(stderr, "Cannot do both copy and modify.\n" );
                Usage();
            }
            if ((fCopy) && (fRename)) {
                fprintf(stderr, "Cannot do both copy and rename.\n" );
                Usage();
            }
            if ((fCopy) && (fDelete)) {
                fprintf(stderr, "Cannot do both copy and delete.\n" );
                Usage();
            }
            if ((fDelete) && (fModify)) {
                fprintf(stderr, "Cannot do both delete and modify.\n" );
                Usage();
            }
            if ((fDelete) && (fRename)) {
                fprintf(stderr, "Cannot do both delete and rename.\n" );
                Usage();
            }
            if ((fModify) && (fRename)) {
                fprintf(stderr, "Cannot do both modify and rename.\n" );
                Usage();
            }

            //
            //  Account for this flag.
            //

            FlagCount++;

            //
            //  (IsFlag( argv[ArgCount] ))
            //

        } else {

            //
            //  No flags were passed as this argument to flinks.
            //
            //  When no flags are present the only valid call is: flinks path1 path2
            //
            //  When flags are present these are valid: flinks -flags- path1
            //        '                                 flinks -flags- path1 path2
            //
            //  For starters we only check that we have the correct number.
            //  We should also check that no more flags are present further along the way ...
            //

            if (FlagCount == 0) {

                if (argc == 2) {
                    fprintf( stderr, "Too few arguments.\n" );
                    Usage();
                }
                if (argc != 3) {
                    fprintf( stderr, "Wrong number of arguments with flags not preceding path arguments.\n" );
                    Usage();
                }

            } else {

                if (ArgCount + 3 <= argc) {
                    fprintf( stderr, "Too many arguments after flags.\n" );
                    Usage();
                }
            }
        }
    } while (ArgCount++ < argc - 1);

    //
    //  When there is only one path argument we have more constraints:
    //

    if ((ArgCount - FlagCount) == 2) {
        if (!fDelete   &&
            !fDisplay
           ) {
            fprintf( stderr, "One path argument requires the delete or display flag.\n" );
            Usage();
        }
    }

    //
    //  For delete or display we can only have one path name.
    //

    if (fDelete   ||
        fDisplay
       ) {
        if ((ArgCount - FlagCount) != 2) {
            fprintf( stderr, "Delete or display have only one path argument.\n" );
            Usage();
        }
    }

    //
    //  Set  fCreate  when there are no flags or no actions.
    //

    if (FlagCount == 0) {
        fCreate = TRUE;
    }
    if (!fCopy     &&
        !fDelete   &&
        !fModify   &&
        !fRename   &&
        !fDisplay
       ) {
        fCreate = TRUE;
    }

    //
    //  Every argument is correct.
    //  Print appropriate verbose messages.
    //

    if (fVVerbose) {
        fprintf( stdout, "\n" );
        fprintf( stdout, "Very verbose is set.\n" );
    }
    if (fVerbose) {
        if (!fVVerbose) {
            fprintf( stdout, "\n" );
        }
        if (fCopy) {
            fprintf( stdout, "Will do verbose copy.\n" );
        } else if (fCreate) {
            fprintf( stdout, "Will do verbose create.\n" );
        } else if (fDelete) {
            fprintf( stdout, "Will do verbose delete.\n" );
        } else if (fDisplay) {
            fprintf( stdout, "Will do verbose display.\n" );
        } else if (fModify) {
            fprintf( stdout, "Will do verbose modify.\n" );
        } else if (fRename) {
            fprintf( stdout, "Will do verbose rename.\n" );
        }
    }

} // ParseArgs



BOOLEAN
IsFlag(
    char *argv
    )
{
    char *TmpArg;


    if ((*argv == '/') || (*argv == '-')) {

        if (strchr( argv, '?' ))
            Usage();

        TmpArg = _strlwr(argv);

        while (*++TmpArg != '\0') {

            switch (*TmpArg) {

                case 'a' :
                case 'A' :
                    fAlternateCreateDefault = TRUE;
                    break;

                case 'c' :
                case 'C' :
                    fCopy = TRUE;
                    break;

                case 'd' :
                case 'D' :
                    fDelete = TRUE;
                    break;

                case 'm' :
                case 'M' :
                    fModify = TRUE;
                    break;

                case 'r' :
                case 'R' :
                    fRename = TRUE;
                    break;

				case 's' :
				case 'S' :
					LinkType = IO_REPARSE_TAG_SIS;
					break;

                case 'w' :
                case 'W' :
                    fVVerbose = TRUE;
                case 'v' :
                case 'V' :
                    fVerbose = TRUE;
                    break;

                case 'y' :
                case 'Y' :
                    fDisplay = TRUE;
                    break;

                case '/' :
                case '-' :
                    break;

                default :
                    fprintf( stderr, "Don't know flag(s) %s\n", argv );
                    Usage();
            }
        }
    }
    else return FALSE;

    return TRUE;

} // IsFlag


void
Usage( void )
{
    fprintf( stderr, "\n" );
    fprintf( stderr, "Usage: flink [/acdmrvy?] [Path1] Path2                                 \n" );
    fprintf( stderr, "       flink Path1 Path2 establishes at Path1 a symbolic link to Path2.\n" );
    fprintf( stderr, "              The file at Path1 is created if it does not exist.        \n" );
    fprintf( stderr, "    /a     sets the alternate default of creating a directory           \n" );
    fprintf( stderr, "    /c     copies in Path2 the symbolic link in Path1                   \n" );
    fprintf( stderr, "    /d     deletes the symbolic link in Path2                           \n" );
    fprintf( stderr, "    /m     modifies the symbolic link Path1 to Path2                    \n" );
    fprintf( stderr, "    /r     renames the symbolic link Path1 to Path2                     \n" );
    fprintf( stderr, "    /s     creates a SIS link rather than a symbolic link				  \n" );
    fprintf( stderr, "    /v     prints verbose output                                        \n" );
    fprintf( stderr, "    /w     prints very verbose output                                   \n" );
    fprintf( stderr, "    /y     displays the symbolic link in Path2                          \n" );
    fprintf( stderr, "    /?     prints this message                                          \n" );
    exit(1);

} // Usage


NTSTATUS
CreateSymbolicLink(
    CHAR           *SourceName,
    CHAR           *DestinationName,
    ATTRIBUTE_TYPE  FileAttributes,
    BOOLEAN         VerboseFlag
    )
/*++

Routine Description:

    Builds a symbolic link between SourceName and DestinationName.

    Opens the file named by SourceName and sets a reparse point of type symbolic link
    that points to DestinationName. No checks whatsoever are made in regards to the
    destination.

    If the symbolic link already exists, this routine will overwrite it.

Return Value:

    NTSTATUS - returns the appropriate NT return code.

--*/

{
    NTSTATUS  Status = STATUS_SUCCESS;

    HANDLE    FileHandle;
    ULONG     OpenOptions;

    UNICODE_STRING  uSourceName,
                    uDestinationName,
                    uNewName,
                    uOldName;

    IO_STATUS_BLOCK         IoStatusBlock;
    OBJECT_ATTRIBUTES       ObjectAttributes;

    PREPARSE_DATA_BUFFER    ReparseBufferHeader = NULL;
    UCHAR                   ReparseBuffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];

    //
    //  Allocate and initialize Unicode strings.
    //

    RtlCreateUnicodeStringFromAsciiz( &uSourceName, SourceName );
    RtlCreateUnicodeStringFromAsciiz( &uDestinationName, DestinationName );

    RtlDosPathNameToNtPathName_U(
        uSourceName.Buffer,
        &uOldName,
        NULL,
        NULL );

    //
    //  Open the existing (SourceName) pathname.
    //  Notice that symbolic links in the path they are traversed silently.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uOldName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    if (VerboseFlag) {
        fprintf( stdout, "Will set symbolic link from: %Z\n", &uOldName );
    }

    //
    //  Make sure that we call open with the appropriate flags for:
    //
    //    (1) directory versus non-directory
    //

    OpenOptions = FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT;

    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        OpenOptions |= FILE_DIRECTORY_FILE;
    } else {

        OpenOptions |= FILE_NON_DIRECTORY_FILE;
    }

    Status = NtOpenFile(
                 &FileHandle,
                 FILE_READ_DATA | SYNCHRONIZE,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 SHARE_ALL,
                 OpenOptions );

    if (!NT_SUCCESS( Status )) {

        RtlFreeUnicodeString( &uSourceName );
        RtlFreeUnicodeString( &uDestinationName );

        fprintf( stderr, "Open failed %s\n", SourceName );
        return Status;
    }

    //
    //  Verify that this is an empty file object:
    //  (a) If it is a file then it should not have data in the unnamed data stream
    //      nor should it have any named data streams.
    //  (b) If it is a directory, it has no entries.
    //      This case does not require code as the NTFS reparse point mechanism
    //      checks for it.
    //

    {
        FILE_STANDARD_INFORMATION   StandardInformation;
        PFILE_STREAM_INFORMATION    StreamInformation;
        CHAR                        Buffer[2048];

        Status = NtQueryInformationFile(
                     FileHandle,
                     &IoStatusBlock,
                     &StandardInformation,
                     sizeof ( FILE_STANDARD_INFORMATION ),
                     FileStandardInformation );

        if (!NT_SUCCESS( Status )) {

            RtlFreeUnicodeString( &uSourceName );
            RtlFreeUnicodeString( &uDestinationName );

            fprintf( stderr, "NtQueryInformation for standard information to %Z failed %x\n", &uSourceName, Status );
            return Status;
        }

        if (StandardInformation.EndOfFile.LowPart > 0) {

            //
            //  The unnamed data stream has bytes in it.
            //

            if (VerboseFlag) {
                fprintf( stdout, "The unnamed data stream of %Z has eof of %d\n",
                         &uOldName, StandardInformation.EndOfFile.LowPart );
            }

            fprintf( stderr, "Symbolic link not created. File has data.\n" );
            return Status;
        }

        //
        //  Go and get the stream information.
        //

        Status = NtQueryInformationFile(
                     FileHandle,
                     &IoStatusBlock,
                     Buffer,
                     2048,
                     FileStreamInformation );

        if (!NT_SUCCESS( Status )) {

            RtlFreeUnicodeString( &uSourceName );
            RtlFreeUnicodeString( &uDestinationName );

            fprintf( stderr, "NtQueryInformation for streams to %Z failed %x\n",
                     &uSourceName, Status );
            return Status;
        }

        //
        //  Process the Buffer of data.
        //

        if (VerboseFlag) {
            fprintf( stdout, "IoStatusBlock.Status %d  IoStatusBlock.Information %d\n",
                     IoStatusBlock.Status, IoStatusBlock.Information );
        }

        StreamInformation = (PFILE_STREAM_INFORMATION)Buffer;

        if (VerboseFlag) {
            fprintf( stdout, "StreamInformation->NextEntryOffset %d StreamInformation->StreamNameLength %d\n",
                     StreamInformation->NextEntryOffset, StreamInformation->StreamNameLength );
        }

        //
        //  There has to be exactly one data stream, the one called ::$DATA whose
        //  StreamNameLength is 14. If this is not the case fail the request.
        //

        if (StreamInformation->NextEntryOffset > 0) {

            RtlFreeUnicodeString( &uSourceName );
            RtlFreeUnicodeString( &uDestinationName );

            fprintf( stderr, "Symbolic link not created. There are named streams.\n",
                     &uSourceName, Status );
            return Status;
        }
    }

    //
    //  Build the appropriate target (DestinationName) name.
    //

    RtlDosPathNameToNtPathName_U(
        uDestinationName.Buffer,
        &uNewName,
        NULL,
        NULL );

    //
    // SIS hack
    //
    uNewName = uDestinationName;

    if (VerboseFlag) {
        fprintf( stdout, "Will set symbolic link to: %Z (%Z)\n", &uNewName, &uDestinationName );
    }

    //
    //  Verify that the name is not too long for the reparse point.
    //

    if (uNewName.Length > (MAXIMUM_REPARSE_DATA_BUFFER_SIZE - FIELD_OFFSET(REPARSE_DATA_BUFFER, RDB))) {

        RtlFreeUnicodeString( &uSourceName );
        RtlFreeUnicodeString( &uDestinationName );

        fprintf( stderr, "Input length too long %x\n", uNewName.Length );
        return STATUS_IO_REPARSE_DATA_INVALID;
    }

    //
    //  Verify that the target name:
    //
    //    (1) ends in a trailing backslash only for directories
    //    (2) does not contain more than one colon (:), thus denoting a complex name
    //
    {
        USHORT   Index          = (uNewName.Length / 2) - 1;
        BOOLEAN  SeenFirstColon = FALSE;

        if (!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

            if (uNewName.Buffer[Index] == L'\\') {

                RtlFreeUnicodeString( &uSourceName );
                RtlFreeUnicodeString( &uDestinationName );

                fprintf( stderr, "Name ends in backslash %Z\n", &uNewName );
                return STATUS_OBJECT_NAME_INVALID;
            }

            //
            //  We have the name of a directory to set a symbolic link.
            //

        } else {

            //
            //  Preserve the backslash that represents the root directory of a
            //  volume. We assume that the root of a volume is denoted by an
            //  identifier (a traditional drive letter) followed by a colon (:).
            //
            //  Silently avoid (delete for practical purposes) the trailing
            //  backlash file delimiter in all other cases.
            //  The backslash is two bytes long.
            //

            if ((uNewName.Buffer[Index - 1] != L':') &&
                (uNewName.Buffer[Index] == L'\\')) {

                uNewName.Length -= 2;
                Index            = (uNewName.Length / 2) - 1;
            }

            if (fVVerbose) {
                fprintf( stdout, "Directory name shortened to: %Z\n", &uNewName );
            }
        }

        while (Index > 0) {

            if (uNewName.Buffer[Index] == L':') {

                if (SeenFirstColon) {

                    RtlFreeUnicodeString( &uSourceName );
                    RtlFreeUnicodeString( &uDestinationName );

                    fprintf( stderr, "More than one colon in the name %Z\n", &uNewName );
                    return STATUS_OBJECT_NAME_INVALID;
                } else {

                    SeenFirstColon = TRUE;
                }
            }

            Index --;
        }
    }

    //
    //  Build the reparse point buffer.
    //

    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;
    ReparseBufferHeader->ReparseTag = LinkType;
    ReparseBufferHeader->ReparseDataLength = uNewName.Length;
    ReparseBufferHeader->Reserved = 0xcaf;
    RtlCopyMemory( ReparseBufferHeader->RDB,
                   uNewName.Buffer,
                   ReparseBufferHeader->ReparseDataLength );

    //
    //  Set a symbolic link reparse point.
    //

    Status = NtFsControlFile(
                 FileHandle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FSCTL_SET_REPARSE_POINT,
                 ReparseBuffer,
                 FIELD_OFFSET(REPARSE_DATA_BUFFER, RDB) + ReparseBufferHeader->ReparseDataLength,
                 NULL,                //  Output buffer
                 0 );                 //  Output buffer length

    if (!NT_SUCCESS( Status )) {

        fprintf( stderr, "NtFsControlFile set failed %s\n", DestinationName );

        //
        //  And return after cleaning up.
        //
    }

    //
    //  Clean up and return.
    //

    RtlFreeUnicodeString( &uSourceName );
    RtlFreeUnicodeString( &uDestinationName );
    NtClose( FileHandle );

    return Status;

}  // CreateSymbolicLink


NTSTATUS
DeleteSymbolicLink(
    CHAR           *DestinationName,
    ATTRIBUTE_TYPE  FileAttributes,
    BOOLEAN         VerboseFlag
    )
/*++

Routine Description:

    Deletes a symbolic link existing at DestinationName.
    DestinationName needs to denote a symbolic link.

    Opens the file named by DestinationName and deletes a reparse point of type
    symbolic link and also deletes the underlying file.

    If the reparse point is not a symbolic link this routine will leave it undisturbed.

Return Value:

    NTSTATUS - returns the appropriate NT return code.

--*/

{
    NTSTATUS  Status = STATUS_SUCCESS;

    HANDLE    FileHandle;
    ULONG     OpenOptions;

    UNICODE_STRING  uDestinationName,
                    uNewName;

    IO_STATUS_BLOCK         IoStatusBlock;
    OBJECT_ATTRIBUTES       ObjectAttributes;

    FILE_DISPOSITION_INFORMATION   DispositionInformation;
    BOOLEAN    foo = TRUE;

#define	REPARSE_BUFFER_LENGTH 45 * sizeof(WCHAR) + sizeof(REPARSE_DATA_BUFFER)
    PREPARSE_DATA_BUFFER    ReparseBufferHeader = NULL;
    UCHAR                   ReparseBuffer[REPARSE_BUFFER_LENGTH];

    //
    //  Allocate and initialize Unicode strings.
    //

    RtlCreateUnicodeStringFromAsciiz( &uDestinationName, DestinationName );

    RtlDosPathNameToNtPathName_U(
        uDestinationName.Buffer,
        &uNewName,
        NULL,
        NULL );

    //
    //  Open the existing (SourceName) pathname.
    //  Notice that if there are symbolic links in the path they are
    //  traversed silently.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uNewName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    if (VerboseFlag) {
        fprintf( stdout, "Will delete symbolic link in: %Z\n", &uNewName );
    }

    //
    //  Make sure that we call open with the appropriate flags for:
    //
    //    (1) directory versus non-directory
    //    (2) reparse point
    //

    OpenOptions = FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT;

    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        OpenOptions |= FILE_DIRECTORY_FILE;
    } else {

        OpenOptions |= FILE_NON_DIRECTORY_FILE;
    }

    Status = NtOpenFile(
                 &FileHandle,
                 (ACCESS_MASK)DELETE | FILE_READ_DATA | SYNCHRONIZE,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 SHARE_ALL,
                 OpenOptions );

    if (!NT_SUCCESS( Status )) {

        RtlFreeUnicodeString( &uDestinationName );

        fprintf( stderr, "Open failed %s\n", DestinationName );
        return Status;
    }

    //
    //  Build the reparse point buffer.
    //

    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;
    ReparseBufferHeader->ReparseTag = LinkType;
    ReparseBufferHeader->ReparseDataLength = 0;
    ReparseBufferHeader->Reserved = 0xcabd;

    //
    //  Delete a symbolic link reparse point.
    //

    Status = NtFsControlFile(
                 FileHandle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FSCTL_DELETE_REPARSE_POINT,
                 ReparseBuffer,
                 FIELD_OFFSET(REPARSE_DATA_BUFFER, RDB),
                 NULL,                //  Output buffer
                 0 );                 //  Output buffer length

    if (!NT_SUCCESS( Status )) {

        RtlFreeUnicodeString( &uDestinationName );

        fprintf( stderr, "NtFsControlFile delete failed %s\n", DestinationName );
        NtClose( FileHandle );
        return Status;
    }

    //
    //  Change the disposition of the file so as to delete it as well.
    //
    //  Look in flinks.h for the kludge I needed to do to make the following line
    //  of code work:
    //               #define DeleteFileA   DeleteFile
    //

    DispositionInformation.DeleteFile = TRUE;

    if (VerboseFlag) {
        fprintf( stdout, "Will set the delete flag for: %Z\n", &uNewName );
    }

    Status = NtSetInformationFile(
                 FileHandle,
                 &IoStatusBlock,
                 &DispositionInformation,
                 sizeof (FILE_DISPOSITION_INFORMATION),
                 FileDispositionInformation );

    //
    //  Clean up and return.
    //

    NtClose( FileHandle );
    RtlFreeUnicodeString( &uDestinationName );

    return Status;

}  // DeleteSymbolicLink


NTSTATUS
IntegerToBase36String(
		ULONG					Value,
		char					*String,
		ULONG					MaxLength)
/*++

Routine Description:

	This does what RtlIntegerToUnicodeString(Value,36,String) would do if it
	handled base 36.  We use the same rules for digits as are normally used
	in Hex: 0-9, followed by a-z.  Note that we're intentionally using Arabic
	numerals and English letters here rather than something localized because
	this is intended to generate filenames that are never seen by users, and
	are constant regardless of the language used on the machine.

Arguments:

	Value 	- The ULONG to be converted into a base36 string
	String 	- A pointer to a string to receive the result
	MaxLength - the total size of the area pointed to by String
	

Return Value:

	success or buffer overflow

--*/

{
	ULONG numChars;
	ULONG ValueCopy = Value;
	ULONG currentCharacter;

    // First, figure out the length by seeing how many times we can divide 36 into the value
	for (numChars = 0; ValueCopy != 0; ValueCopy /= 36, numChars++) {
		// No loop body
	}

	// Special case the value 0.
	if (numChars == 0) {
		ASSERT(Value == 0);
		if (MaxLength < 2) 
			return STATUS_BUFFER_OVERFLOW;
		String[0] = '0';
		String[1] = 0;

		return STATUS_SUCCESS;
	}

	// If the string is too short, quit now.
	if (numChars * sizeof(char) + 1 > MaxLength) {		// The +1 is for the terminating null
		return STATUS_BUFFER_OVERFLOW;
	}

	// Convert the string character-by-character starting at the lowest order (and so rightmost) "digit"
	ValueCopy = Value;
	for (currentCharacter = 0 ; currentCharacter < numChars; currentCharacter++) {
		ULONG digit = ValueCopy % 36;
		ASSERT(ValueCopy != 0);
		if (digit < 10) {
			String[numChars - (currentCharacter + 1)] = (char)('0' + (ValueCopy % 36));
		} else {
			String[numChars - (currentCharacter + 1)] = (char)('a' + ((ValueCopy % 36) - 10));
		}
		ValueCopy /= 36;
	}
	ASSERT(ValueCopy == 0);

	//
	// Fill in the terminating null and we're done.
	//
	String[numChars] = 0;
	
	return STATUS_SUCCESS;
}

	NTSTATUS
IndexToFileName(
	IN PLARGE_INTEGER		Index,
    OUT char			 	*fileName,
	IN ULONG				MaxLength
	)
/*++

Routine Description:

	Given an index, returns the corresponding fully qualified file name.

Arguments:

	Index 	         - The CSINDEX to convert
	fileName         - A pointer to a string to receive the result
	MaxLength		 - The size of the string printed to by fileName

Return Value:

	success or buffer overflow

--*/
{
	UNICODE_STRING 		substring;
    NTSTATUS 			status;
	ULONG				fileNameLength;

	//
	// We generate the filename as low.high, where low.high is the
	// base 36 representation of the CSIndex.  We use this bizarre format in order to
	// avoid (for as long as possible) filenames that are not unique 8.3 names.  ULONGS
	// in base 36 have at most 7 characters, so we don't exceed 8.3 until we hit an index
	// value of just over 2 * 10^14, which takes over 6000 years at 1 index/millisecond.
	//

	status = IntegerToBase36String(Index->LowPart,fileName,MaxLength);
	if (status != STATUS_SUCCESS) {
		return status;
	}
	fileNameLength = strlen(fileName);
	MaxLength -= fileNameLength;

	// Stick in the dot in the middle.
	if (MaxLength == 0) {
		return STATUS_BUFFER_OVERFLOW;
	}
	*(fileName + strlen(fileName)) = '.';
	fileNameLength++;
	MaxLength--;

	return IntegerToBase36String(Index->HighPart,(fileName + fileNameLength),MaxLength);
}

NTSTATUS
DisplaySymbolicLink(
    CHAR            *DestinationName,
    ATTRIBUTE_TYPE   FileAttributes,
    BOOLEAN          VerboseFlag
    )
/*++

Routine Description:

    Displays a symbolic link existing at DestinationName.
    DestinationName needs to denote a symbolic link.

    Opens the file named by DestinationName and gets a reparse point of type
    symbolic link.

    If the reparse point is not a symbolic link this routine will not display it.

Return Value:

    NTSTATUS - returns the appropriate NT return code.

--*/

{
    NTSTATUS  Status = STATUS_SUCCESS;

    HANDLE    FileHandle;
    ULONG     OpenOptions;

    UNICODE_STRING  uDestinationName,
                    uNewName;

    IO_STATUS_BLOCK         IoStatusBlock;
    OBJECT_ATTRIBUTES       ObjectAttributes;

    PREPARSE_DATA_BUFFER    ReparseBufferHeader = NULL;
    UCHAR                   ReparseBuffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];

    //
    //  Allocate and initialize Unicode string.
    //

    RtlCreateUnicodeStringFromAsciiz( &uDestinationName, DestinationName );

    RtlDosPathNameToNtPathName_U(
        uDestinationName.Buffer,
        &uNewName,
        NULL,
        NULL );

    //
    //  Open the existing (SourceName) pathname.
    //  Notice that if there are symbolic links in the path they are
    //  traversed silently.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uNewName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    if (VerboseFlag) {
        fprintf( stdout, "Will display symbolic link in: %Z\n", &uNewName );
    }

    //
    //  Make sure that we call open with the appropriate flags for:
    //
    //    (1) directory versus non-directory
    //    (2) reparse point
    //

    OpenOptions = FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT;

    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        OpenOptions |= FILE_DIRECTORY_FILE;
    } else {

        OpenOptions |= FILE_NON_DIRECTORY_FILE;
    }

    Status = NtOpenFile(
                 &FileHandle,
                 FILE_READ_DATA | SYNCHRONIZE,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 SHARE_ALL,
                 OpenOptions );

    if (!NT_SUCCESS( Status )) {

        RtlFreeUnicodeString( &uDestinationName );

        fprintf( stderr, "Open failed %s\n", DestinationName );
        return Status;
    }

    //
    //  Get the reparse point.
    //

    Status = NtFsControlFile(
                 FileHandle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FSCTL_GET_REPARSE_POINT,
                 NULL,                                //  Input buffer
                 0,                                   //  Input buffer length
                 ReparseBuffer,                       //  Output buffer
                 MAXIMUM_REPARSE_DATA_BUFFER_SIZE );  //  Output buffer length

    if (!NT_SUCCESS( Status )) {

        RtlFreeUnicodeString( &uDestinationName );

        fprintf( stderr, "NtFsControlFile get failed %x %s\n", IoStatusBlock.Information, DestinationName );
        return Status;
    }

    //
    //  Decode the reparse point buffer to display the data.
    //
    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;
	if (ReparseBufferHeader->ReparseTag == IO_REPARSE_TAG_SIS) {
		PSI_REPARSE_BUFFER	sisReparseBuffer = (PSI_REPARSE_BUFFER)ReparseBufferHeader->RDB;
		char stringBuffer[100];
		PCHAR guidString;
		FILE_INTERNAL_INFORMATION	internalInfo[1];

		printf("SIS Reparse point, format version %d\n",sisReparseBuffer->ReparsePointFormatVersion);

		if (RPC_S_OK != UuidToString(&sisReparseBuffer->CSid,&guidString)) {
			printf("CSid unable to stringify\n");
		} else {
			printf("CSid %s\n",guidString);
		}

		if (STATUS_SUCCESS != IndexToFileName(&sisReparseBuffer->LinkIndex,stringBuffer,100)) {
			printf("LinkIndex 0x%x.0x%x (unable to stringify)\n",sisReparseBuffer->LinkIndex.HighPart,
						sisReparseBuffer->LinkIndex.LowPart);
		} else {
			printf("LinkIndex 0x%x.0x%x (%s)\n",sisReparseBuffer->LinkIndex.HighPart,
						sisReparseBuffer->LinkIndex.LowPart,stringBuffer);
		}

		Status = NtQueryInformationFile(
					FileHandle,
					&IoStatusBlock,
					internalInfo,
					sizeof(FILE_INTERNAL_INFORMATION),
					FileInternalInformation);

		if (STATUS_SUCCESS != Status) {
			printf("LinkFileNtfsId 0x%x.0x%x (unable to query internal info, 0x%x)\n",
					sisReparseBuffer->LinkFileNtfsId.HighPart,sisReparseBuffer->LinkFileNtfsId.LowPart,
					Status);
		} else if (internalInfo->IndexNumber.QuadPart == sisReparseBuffer->LinkFileNtfsId.QuadPart) {
			printf("LinkFileNtfsId 0x%x.0x%x (matches actual id)\n",
					sisReparseBuffer->LinkFileNtfsId.HighPart,sisReparseBuffer->LinkFileNtfsId.LowPart);
		} else {
			printf("LinkFileNtfsId 0x%x.0x%x (!= actual Id 0x%x.0x%x)\n",
					sisReparseBuffer->LinkFileNtfsId.HighPart,sisReparseBuffer->LinkFileNtfsId.LowPart,
					internalInfo->IndexNumber.HighPart,internalInfo->IndexNumber.LowPart);
		}

		printf("CSFileNtfsId 0x%x.0x%x\n",sisReparseBuffer->CSFileNtfsId.HighPart,sisReparseBuffer->CSFileNtfsId.LowPart);
		printf("CSFileChecksum 0x%x.0x%x\n",sisReparseBuffer->CSChecksum.HighPart,sisReparseBuffer->CSChecksum.LowPart);

	} else if (ReparseBufferHeader->ReparseTag != LinkType) {

       fprintf( stderr, "Reparse point is not a symbolic link: tag %x\n", ReparseBufferHeader->ReparseTag );
       Status = STATUS_OBJECT_NAME_INVALID;

    } else {

       UNICODE_STRING  UniString;

       UniString.Length = ReparseBufferHeader->ReparseDataLength;
       UniString.Buffer = (PWCHAR)&ReparseBufferHeader->RDB[0];
       if (fVerbose) {
          fprintf( stdout, "The symbolic link is: " );
       }
       fprintf( stdout, "%Z\n", &UniString );
    }

    //
    //  Clean up and return.
    //

    NtClose( FileHandle );
    RtlFreeUnicodeString( &uDestinationName );

    return Status;

}  // DisplaySymbolicLink


NTSTATUS
CreateEmptyFile(
    CHAR           *DestinationName,
    ATTRIBUTE_TYPE  FileAttributes,
    BOOLEAN         VerboseFlag
    )
/*++

Routine Description:

    Creates an empty file or directory, according to fileAttributes.

Return Value:

    NTSTATUS - returns the appropriate NT return code.

--*/
{
    NTSTATUS           Status = STATUS_SUCCESS;

    OBJECT_ATTRIBUTES  ObjectAttributes;
    IO_STATUS_BLOCK    IoStatusBlock;
    HANDLE             FileHandle;

    ULONG DesiredAccess     = FILE_READ_DATA | SYNCHRONIZE;
    ULONG CreateDisposition = FILE_OPEN_IF | FILE_OPEN;
    ULONG CreateOptions;
    ULONG ShareAccess       = SHARE_ALL;

    UNICODE_STRING  uDestinationName,
                    uFileName;

    //
    //  Initialize CreateOptions correctly.
    //

    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        CreateOptions = FILE_DIRECTORY_FILE;
    } else {

        CreateOptions = FILE_NON_DIRECTORY_FILE;
    }

    //
    //  Allocate and initialize Unicode string.
    //

    RtlCreateUnicodeStringFromAsciiz( &uDestinationName, DestinationName );

    RtlDosPathNameToNtPathName_U(
        uDestinationName.Buffer,
        &uFileName,
        NULL,
        NULL );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uFileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    if (VerboseFlag) {
        if (CreateOptions & FILE_DIRECTORY_FILE) {
            fprintf( stdout, "Will create the empty directory: %Z\n", &uFileName );
        } else {
            fprintf( stdout, "Will create the empty file: %Z\n", &uFileName );
        }
    }

    Status = NtCreateFile(
                 &FileHandle,
                 DesiredAccess,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 NULL,                    // pallocationsize (none!)
                 FILE_ATTRIBUTE_NORMAL,
                 ShareAccess,
                 CreateDisposition,
                 CreateOptions,
                 NULL,                    // EA buffer (none!)
                 0 );

    NtClose( FileHandle );

    return Status;

}  // CreateEmptyFile


NTSTATUS
CopySymbolicLink(
    CHAR           *SourceName,
    CHAR           *DestinationName,
    ATTRIBUTE_TYPE  FileAttributes,
    BOOLEAN         VerboseFlag
    )
/*++

Routine Description:

    Copies the symbolic link existing at SourceName in DestinationName.
    SourceName needs to denote a symbolic link.
    DestinationName exists, and may or not be a symbolic link.

Return Value:

    NTSTATUS - returns the appropriate NT return code.

--*/
{
    NTSTATUS  Status = STATUS_SUCCESS;

    HANDLE    FileHandle;
    ULONG     OpenOptions;

    UNICODE_STRING  uName,
                    uFinalName;

    IO_STATUS_BLOCK         IoStatusBlock;
    OBJECT_ATTRIBUTES       ObjectAttributes;

    PREPARSE_DATA_BUFFER    ReparseBufferHeader = NULL;
    UCHAR                   ReparseBuffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];

    //
    //  Allocate and initialize Unicode string for SourceName.  We will open it
    //  and retrieve the symbolic link it stores.
    //

    RtlCreateUnicodeStringFromAsciiz( &uName, SourceName );

    RtlDosPathNameToNtPathName_U(
        uName.Buffer,
        &uFinalName,
        NULL,
        NULL );

    //
    //  Open Path1 assuming that it is a reparse point (as it should be).
    //  Notice that if there are symbolic links in the path they are
    //  traversed silently.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uFinalName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    if (VerboseFlag) {
        fprintf( stdout, "Will retrieve symbolic link in: %Z\n", &uFinalName );
    }

    //
    //  Make sure that we call open with the appropriate flags for:
    //
    //    (1) directory versus non-directory
    //    (2) reparse point
    //

    OpenOptions = FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT;

    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        OpenOptions |= FILE_DIRECTORY_FILE;
    } else {

        OpenOptions |= FILE_NON_DIRECTORY_FILE;
    }

    Status = NtOpenFile(
                 &FileHandle,
                 FILE_READ_DATA | SYNCHRONIZE,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 SHARE_ALL,
                 OpenOptions );

    if (!NT_SUCCESS( Status )) {

        RtlFreeUnicodeString( &uName );

        fprintf( stderr, "Open as reparse point failed %s\n", SourceName );
        return Status;
    }

    //
    //  Get the reparse point.
    //

    Status = NtFsControlFile(
                 FileHandle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FSCTL_GET_REPARSE_POINT,
                 NULL,                                //  Input buffer
                 0,                                   //  Input buffer length
                 ReparseBuffer,                       //  Output buffer
                 MAXIMUM_REPARSE_DATA_BUFFER_SIZE );  //  Output buffer length

    if (!NT_SUCCESS( Status )) {

        RtlFreeUnicodeString( &uName );

        fprintf( stderr, "NtFsControlFile get failed %x %s\n", IoStatusBlock.Information, SourceName );
        return Status;
    }

    //
    //  Free the name buffer.
    //

    RtlFreeUnicodeString( &uName );

    //
    //  Decode the reparse point buffer to display the data.
    //

    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;
    if (ReparseBufferHeader->ReparseTag != LinkType) {

        fprintf( stderr, "Reparse point is not a symbolic link: tag %x\n", ReparseBufferHeader->ReparseTag );
        NtClose( FileHandle );
        return STATUS_OBJECT_NAME_INVALID;

    } else {

        UNICODE_STRING  UniString;

        UniString.Length = ReparseBufferHeader->ReparseDataLength;
        UniString.Buffer = (PWCHAR)&ReparseBufferHeader->RDB[0];

        if (fVerbose) {
            fprintf( stdout, "The symbolic link is: %Z\n", &UniString );
        }
    }

    //
    //  Close Path1.
    //

    NtClose( FileHandle );

    //
    //  We now deal with Path2.
    //  Allocate and initialize Unicode string for DestinationName.  We will open it
    //  and set a reparse point in it.
    //

    RtlCreateUnicodeStringFromAsciiz( &uName, DestinationName );

    RtlDosPathNameToNtPathName_U(
        uName.Buffer,
        &uFinalName,
        NULL,
        NULL );

    //
    //  We fail if this file is not created.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uFinalName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    if (VerboseFlag) {
        fprintf( stdout, "Will set symbolic link in: %Z\n", &uFinalName );
    }

    //
    //  Make sure that we open with the same options as Path1.
    //  We first try the reparse point case and trap the corresponsing error code.
    //

    Status = NtOpenFile(
                 &FileHandle,
                 FILE_READ_DATA | SYNCHRONIZE,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 SHARE_ALL,
                 OpenOptions );

    if (!NT_SUCCESS( Status )) {

        RtlFreeUnicodeString( &uName );

        fprintf( stderr, "Open failed %s\n", DestinationName );
        return Status;
    }

    //
    //  The file in Path2 is open.  We set the reparse point of type symbolic link.
    //

    Status = NtFsControlFile(
                 FileHandle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FSCTL_SET_REPARSE_POINT,
                 ReparseBuffer,
                 FIELD_OFFSET(REPARSE_DATA_BUFFER, RDB) + ReparseBufferHeader->ReparseDataLength,
                 NULL,                //  Output buffer
                 0 );                 //  Output buffer length

    if (!NT_SUCCESS( Status )) {

        fprintf( stderr, "NtFsControlFile set failed %s\n", DestinationName );

        //
        //  And return after cleaning up.
        //
    }

    //
    //  Free the name buffer and close Path2.
    //

    RtlFreeUnicodeString( &uName );
    NtClose( FileHandle );

    return Status;

}  // CopySymbolicLink


NTSTATUS
RenameSymbolicLink(
    CHAR           *SourceName,
    CHAR           *DestinationName,
    ATTRIBUTE_TYPE  FileAttributes,
    BOOLEAN         VerboseFlag
    )
{
    NTSTATUS  Status = STATUS_SUCCESS;

    WCHAR  *pch,
            ch;

    BOOLEAN   LoopCondition     = TRUE,
              TranslationStatus = TRUE;

    HANDLE    FileHandle,
              RootDirHandle;

    ULONG     OpenOptions;

    USHORT    Index     = 0,
              LastIndex = 0;

    UNICODE_STRING  uName,
                    uRelative,
                    uFinalName;

    RTL_RELATIVE_NAME_U  RelativeName;

    IO_STATUS_BLOCK           IoStatusBlock;
    OBJECT_ATTRIBUTES         ObjectAttributes;
    FILE_RENAME_INFORMATION  *RenameInformation = NULL;

    //
    //  Allocate and initialize Unicode string for SourceName (Path1).
    //

    RtlCreateUnicodeStringFromAsciiz( &uName, SourceName );

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U( uName.Buffer,
                                                              &uFinalName,
                                                              NULL,
                                                              &RelativeName );
    if (!TranslationStatus) {
        RtlFreeUnicodeString( &uName );
        fprintf( stderr, "Path not translated: %s\n", SourceName );
        SetLastError(ERROR_PATH_NOT_FOUND);
        return STATUS_OBJECT_NAME_INVALID;
    }

    //
    //  Open Path1 as a reparse point; as it needs to be.
    //  Notice that if there are symbolic links in the path they are
    //  traversed silently.
    //

    if (RelativeName.RelativeName.Length) {

        uFinalName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        if (VerboseFlag) {
            fprintf( stdout, "Relative name is: %Z\n", &uFinalName );
        }
    } else {

        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uFinalName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL );

    if (VerboseFlag) {
        fprintf( stdout, "Will rename symbolic link in: %Z\n", &uFinalName );
    }

    //
    //  Make sure that we call open with the appropriate flags for:
    //
    //    (1) directory versus non-directory
    //    (2) reparse point
    //

    OpenOptions = FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT;

    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        OpenOptions |= FILE_DIRECTORY_FILE;
    } else {

        OpenOptions |= FILE_NON_DIRECTORY_FILE;
    }

    Status = NtOpenFile(
                 &FileHandle,
                 (ACCESS_MASK)DELETE | FILE_READ_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES| SYNCHRONIZE,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 SHARE_ALL,
                 OpenOptions );

    RtlReleaseRelativeName(&RelativeName);

    if (!NT_SUCCESS( Status )) {

        RtlFreeUnicodeString( &uName );

        fprintf( stderr, "Open as reparse point failed %Z\n", &uFinalName );
        return Status;
    }

    //
    //  Free the name for Path1.
    //

    RtlFreeUnicodeString( &uName );

    //
    //  We now build the appropriate Unicode name for Path2.
    //

    RtlCreateUnicodeStringFromAsciiz( &uName, DestinationName );

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            uName.Buffer,
                            &uFinalName,
                            NULL,
                            NULL );

    if (!TranslationStatus) {

        RtlFreeUnicodeString( &uName );
        fprintf( stderr, "Path not translated: %s\n", DestinationName );
        SetLastError(ERROR_PATH_NOT_FOUND);
        return STATUS_OBJECT_NAME_INVALID;
    }

    if (VerboseFlag) {
        fprintf( stdout, "The complete destination is: %Z\n", &uFinalName );
    }

    //
    //  We use the uFinalName to build the name for the directory where
    //  the target file resides.
    //  We will pass the handle in the link information.
    //  The rest of the path will be given relative to this root.
    //  We depend on paths looking like "\DosDevices\X:\path".
    //

    Index = uFinalName.Length / 2;    //  to account for the Unicode widths
    Index -= 1;                       //  as arrays begin from zero

    if ((uFinalName.Buffer[Index] == L'\\') || (Index <= 4)) {

        //
        //  Last character is a backslash or the full name is too short;
        //  this is not a valid name.
        //

        NtClose( FileHandle );
        RtlFreeUnicodeString( &uName );

        fprintf( stderr, "Bad Path2, ends in backslash or is too short (Index %d)  %s\n", Index, DestinationName );
        return STATUS_OBJECT_NAME_INVALID;
    }

    while ((Index > 0) && LoopCondition) {

        if (uFinalName.Buffer[Index] == L'\\') {

            LoopCondition = FALSE;
            LastIndex = Index;
        } else {

            Index --;
        }
    }

    uFinalName.Length = 2 * LastIndex;

    if (VerboseFlag) {
        fprintf( stdout, "The root directory is: %Z\n", &uFinalName );
    }

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uFinalName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    Status = NtCreateFile(
                 &RootDirHandle,
                 FILE_LIST_DIRECTORY | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 NULL,                                                 // pallocationsize (none!)
                 FILE_ATTRIBUTE_NORMAL,
                 SHARE_ALL,
                 FILE_OPEN_IF | FILE_OPEN,
                 FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT,
                 NULL,                                                 // EA buffer (none!)
                 0 );

    if (!NT_SUCCESS( Status )) {

        NtClose( FileHandle );
        RtlFreeUnicodeString( &uName );

        fprintf( stderr, "Could not get RootDirHandle %s\n", DestinationName );
        return Status;
    }

    //
    //  Now get the path relative to the root.
    //

    RtlInitUnicodeString( &uRelative, &uFinalName.Buffer[LastIndex + 1] );

    RenameInformation = malloc( sizeof(*RenameInformation) + uRelative.Length );

    if (NULL == RenameInformation) {

        NtClose( FileHandle );
        NtClose( RootDirHandle );
        RtlFreeUnicodeString( &uName );

        return STATUS_NO_MEMORY;
    }

    RenameInformation->ReplaceIfExists = TRUE;
    RenameInformation->RootDirectory   = RootDirHandle;
    RenameInformation->FileNameLength  = uRelative.Length;
    RtlMoveMemory( RenameInformation->FileName,
                   uRelative.Buffer,
                   uRelative.Length );

    //
    //  Do the rename.
    //

    if (VerboseFlag) {
        fprintf( stdout, "Will rename symbolic link to: %Z\n", &uRelative );
    }

    Status = NtSetInformationFile(
                 FileHandle,
                 &IoStatusBlock,
                 RenameInformation,
                 sizeof (FILE_RENAME_INFORMATION) + RenameInformation->FileNameLength,
                 FileRenameInformation );

    if (Status == STATUS_NOT_SAME_DEVICE) {

        fprintf( stderr, "Rename directed to a different device.\n" );
    }
    if (!NT_SUCCESS( Status )) {

        fprintf( stderr, "NtSetInformationFile failed (Status %X) %Z\n", Status, &uRelative );
    }

    //
    //  Close Path1 and the root of Path2, free the buffer and return.
    //

    NtClose( FileHandle );
    NtClose( RootDirHandle );
    RtlFreeUnicodeString( &uName );
    free( RenameInformation );

    return Status;

}  // RenameSymbolicLink
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\tools\chksis\chksis.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    chksis.cpp

Abstract:

    This module implements a utility that examines all SIS files on a volume
    looking for errors and optionally displaying file information.

Author:

    Scott Cutshall          Fall, 1997

--*/

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>

#include <windows.h>

using namespace std;

bool verbose = false;

typedef LONGLONG INDEX;

//
// Convert a 32bit value to a base 36 representation in
// the caller provided string.
//

void IntegerToBase36String(ULONG val, string& s) {

    //
    // Maximum number of "digits" in a base 36 representation of a 32 bit
    // value is 7.
    //

    char rs[8];
    ULONG v = val;

    rs[7] = 0;

    for (int i = 7; i == 7 || v != 0;) {

        ULONG d = v % 36;
        v = v / 36;

        --i;
        if (d < 10)
            rs[i] = '0' + d;
        else
            rs[i] = 'a' + d - 10;

    }

    s.assign(&rs[i]);

}


//
// A put operator for INDEX types.  Implemented as IndexToSISFileName().
//

#ifndef _WIN64
ostream& operator<<(ostream& out, INDEX& index)
{

    unsigned long lo = static_cast<unsigned long> (index);
    long hi = static_cast<long> (index >> 32);
    string s("1234567");

    IntegerToBase36String(lo, s);

    out << s << '.';

    IntegerToBase36String(hi, s);

    out << s;

    return out;
}
#endif

//
// A common store file object.  Holds the file's index, name, internal refcount,
// external refcount, and identity operations.
//

class CsFile {

public:

    CsFile(INDEX i = 0, int r = 0, string n = "") :
        index(i), internalRefCount(r), name(n), externalRefCount(0) {}

    void Validate() {
        if (internalRefCount != externalRefCount) {
            cout << name << " Reference Count: " << internalRefCount;
            cout << ".  " << externalRefCount << " external references identified." << endl;
        }
    }

    friend bool operator<(const CsFile& a, const CsFile& b) {
        return a.index < b.index;
    }

    friend bool operator>(const CsFile& a, const CsFile& b) {
        return a.index > b.index;
    }

    friend bool operator==(const CsFile& a, const CsFile& b) {
        return a.index == b.index;
    }

    void IncRefCount() {
        ++externalRefCount;
    }

    void display() {
        cout << "CS Index: " << (INDEX) index << "   Ref Count: " << internalRefCount << endl;
    }

private:

    //
    // Index of this entry's file.
    //

    INDEX   index;

    //
    // The file name.  This is somewhat redundant with the index (ie. the
    // name is derived from the index), so it isn't absolutely necessary.
    //

    string  name;

    //
    // Reference count read from the file's refcount stream.
    //

    int     internalRefCount;

    //
    // Number of valid references to this file detected during scan.
    //

    int     externalRefCount;

};


//
// The SIS Common Store object.  Holds all common store file objects, and
// validation and query operations.
//

class CommonStore {

public:

    CommonStore(int vsize = 0) : maxIndex(0) {
        if (vsize > 0) csFiles.resize(vsize);
    }

    //
    // Method to create a common store on a volume.
    //

    bool Create(string& Volume);

    //
    // Validate the common store directory and initialize this class.
    //

    void Validate(string& Volume);

    //
    // Validate the reference counts. Assumes all external references
    // have been identified.
    //

    void ValidateRefCounts();

    //
    // All indices must be less than maxIndex;
    //

    bool ValidateIndex(INDEX i) {
        return i <= maxIndex;
    }

    //
    // Lookup a common store index and add a ref if found.
    //

    CsFile *Query(INDEX index);

private:

    bool FileNameToIndex(string& fileName, INDEX& csIndex);

    //
    // Index from the MaxIndex file.
    //

    INDEX   maxIndex;

    //
    // Database of content files.  All CS files are examined and added to the database,
    // sorted, and subsequently used during the SIS link scan.
    //

    vector<CsFile> csFiles;

};

//
// Various SIS file and directory names.
//

const string  maxIndexFileName("MaxIndex");
const string  logFileName("LogFile");
const string  csDir("\\SIS Common Store\\");

//
// Create a common store directory on a volume.
//
// todo:
//      - Verify that the volume is ntfs.
//      - Verify that the SIS driver is loaded.
//

bool
CommonStore::Create(string& Volume)
{
    const string CommonStoreDir = Volume + "\\SIS Common Store";
    USHORT comp = COMPRESSION_FORMAT_DEFAULT;
    DWORD transferCount;
    bool rc;

    if (! CreateDirectory(CommonStoreDir.c_str(), NULL) ) {

        cout << "Cannot create Common Store directory, " << GetLastError() << endl;
        return false;

    }

    if (verbose)
        cout << CommonStoreDir << " created" << endl;

    //
    // Open the Common Store directory and enable compression.
    //

    HANDLE CSDirHandle = CreateFile(
                            CommonStoreDir.c_str(),
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_BACKUP_SEMANTICS,
                            NULL);

    if (CSDirHandle == INVALID_HANDLE_VALUE) {

        cout << "Can't open Common Store directory." << endl;
        rc = false;

    } else {

        rc = 0 != DeviceIoControl(
                     CSDirHandle,
                     FSCTL_SET_COMPRESSION,
                     &comp,
                     sizeof(comp),
                     NULL,
                     0,
                     &transferCount,
                     NULL);

        CloseHandle(CSDirHandle);

    }

    if (!rc)
        cout << "Cannot enable compression on Common Store directory, " << GetLastError() << endl;

    //
    // Chdir into the common store directory.
    //

    if (SetCurrentDirectory(CommonStoreDir.c_str()) == 0) {

        //
        // Unable to chdir into the common store.
        //

        cout << "\"\\SIS Common Store\" directory not found" << endl;

        return false;

    }

    rc = true;

    //
    // Create the MaxIndex file.
    //

    HANDLE hMaxIndex = CreateFile(
                            maxIndexFileName.c_str(),
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_NEW,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

    if (hMaxIndex == INVALID_HANDLE_VALUE) {

        cout << "Can't create \"\\SIS Common Store\\MaxIndex\"" << endl;

        rc = false;

    } else {

        DWORD bytesWritten;

        maxIndex = 1;

        if (! WriteFile(
                  hMaxIndex,
                  &maxIndex,
                  sizeof maxIndex,
                  &bytesWritten,
                  NULL) ||
            (bytesWritten < sizeof maxIndex)) {

            cout << "Can't write MaxIndex, " << GetLastError() << endl;

            rc = false;

        } else {

            CloseHandle(hMaxIndex);

            if (verbose)
                cout << "MaxIndex: " << (INDEX) maxIndex << endl;

            rc = true;
        }

    }

    return rc;

}


//
// Validate the common store directory.
//

void
CommonStore::Validate(string& Volume)
{

    WIN32_FIND_DATA findData;
    HANDLE findHandle;
    const string fileNameMatchAny = "*";
    const string CommonStoreDir = Volume + "\\SIS Common Store";

    cout << "Checking Common Store" << endl;

    //
    // Chdir into the common store directory.
    //

    if (SetCurrentDirectory(CommonStoreDir.c_str()) == 0) {

        //
        // Unable to chdir into the common store.
        //

        cout << "\"\\SIS Common Store\" directory not found" << endl;

        return;

    }

    //
    // Validate and read the contents of the MaxIndex file.
    //

    HANDLE hMaxIndex = CreateFile(
                            maxIndexFileName.c_str(),
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

    if (hMaxIndex == INVALID_HANDLE_VALUE) {

        cout << "Can't open \"\\SIS Common Store\\MaxIndex\"" << endl;

    } else {

        DWORD bytesRead;

        if (! ReadFile(
                  hMaxIndex,
                  &maxIndex,
                  sizeof maxIndex,
                  &bytesRead,
                  NULL)) {

            cout << "Can't read MaxIndex, " << GetLastError() << endl;

        }

        if (bytesRead < sizeof maxIndex) {

            cout << "Invalid MaxIndex" << endl;

        }

        CloseHandle(hMaxIndex);

        if (verbose)
            cout << "MaxIndex: " << (INDEX) maxIndex << endl;
    }

    //
    // Enumerate and validate all files in the common store directory.
    // Save the file name and reference count for later lookup when validating
    // the SIS link files.
    //

    findHandle = FindFirstFile( fileNameMatchAny.c_str(), &findData );

    if (INVALID_HANDLE_VALUE == findHandle) {

        cout << CommonStoreDir << " is empty." << endl;
        return;

    }

    do {

        ULONG refCount;
        string fileName;

        fileName = findData.cFileName;

        if ( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

            //
            // Ignore . and ..
            //

            if ( findData.cFileName[0] == '.' ) {

                if (( findData.cFileName[1] == 0 ) ||
                    (( findData.cFileName[1] == '.' ) && ( findData.cFileName[2] == 0 )))

                    continue;

            }

            cout << "Common Store directory skipped: " << fileName << endl;
            continue;

        }

        if ((_stricmp(maxIndexFileName.c_str(),fileName.c_str()) == 0) ||
            (_stricmp(logFileName.c_str(),fileName.c_str()) == 0)) {

            //
            // Skip the MaxIndex and LogFile files.
            //

            continue;

        }

        //
        // Verify that:
        //    - the file name is a valid index.
        //    - this is a normal file (ie. not a reparse point).
        //    - there is a refcount stream of proper format.
        //

        INDEX csIndex;

        refCount = 0;

        if (! FileNameToIndex(fileName, csIndex)) {

            cout << "Unknown file in Common Store: " << fileName << endl;
            continue;

        }

        if (! ValidateIndex(csIndex)) {

            cout << "Invalid CSIndex: " << fileName << endl;

        }

        if ( IO_REPARSE_TAG_SIS == findData.dwReserved0 ) {

            cout << "SIS link found in Common Store: " << fileName << endl;

        } else {

            //
            // Read in the refcount;
            //

            string refName(fileName + ":sisrefs$");

            HANDLE hRefCount = CreateFile(
                                    refName.c_str(),
                                    GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);

            if (hRefCount == INVALID_HANDLE_VALUE) {

                cout << "Can't open ref count stream, " << refName << ", " << GetLastError() << endl;

            } else {

                DWORD bytesRead;

                if (! ReadFile(
                          hRefCount,
                          &refCount,
                          sizeof refCount,
                          &bytesRead,
                          NULL)) {

                    cout << "Can't read " << refName << ", " << GetLastError() << endl;

                }

                if (bytesRead < sizeof refCount) {

                    cout << "Invalid ref count in " << refName << endl;

                }

                CloseHandle(hRefCount);

            }

            CsFile csFile(csIndex, refCount, fileName);

            //
            // Add this file to our database.  Expand the database if necessary.
            //

            if (0 == csFiles.capacity())
                csFiles.reserve(csFiles.size() + 200);

            csFiles.push_back(csFile);

            if (verbose)
                csFile.display();
        }

    } while ( FindNextFile( findHandle, &findData ) );

    FindClose( findHandle );


    //
    // Sort the database for subsequent lookups.
    //

    sort(csFiles.begin(), csFiles.end());
}


//
// Validate the reference counts. Assumes all external references
// have been identified.
//

void
CommonStore::ValidateRefCounts() {

    vector<CsFile>::iterator p;

    for (p = csFiles.begin(); p != csFiles.end(); ++p) {

        p->Validate();

    }
}

//
// Lookup the specified index in the common store.
//

CsFile *
CommonStore::Query(INDEX index)
{
    CsFile key(index);

    //
    // Use a binary search to lookup the index.
    //

    vector<CsFile>::iterator p = lower_bound(csFiles.begin(), csFiles.end(), key);

    if (p == csFiles.end() || *p > key)
        return NULL;                        // not found

    return p;
}


//
// Extract the index from a common store file name.
//

bool
CommonStore::FileNameToIndex(string& fileName, INDEX& csIndex)
{
    char c;
    const size_t len = fileName.length();
    ULONG hi = 0, lo = 0;

    //
    // Format: "_low.high", where low.high is the base 36 representation of
    // the index value.
    //

    size_t i = 0;

    if (len < 2 || fileName.at(i) != '_') {

        cout << "Invalid Common Store file name: " << fileName << endl;

        return false;

    }

    while (++i < len && (c = fileName.at(i)) != '.') {

        INDEX d;

        if (c >= '0' && c <= '9') {

            d = c - '0';

        } else if (c >= 'a' && c <= 'z') {

            d = c - 'a' + 10;

        } else {

            cout << "Invalid Common Store file name: " << fileName << endl;

            return false;

        }

        lo = lo * 36 + d;

    }

    if (c != '.') {

        cout << "Invalid Common Store file name: " << fileName << endl;

        return false;

    }

    while (++i < len) {

        INDEX d;

        c = fileName.at(i);

        if (c >= '0' && c <= '9') {

            d = c - '0';

        } else if (c >= 'a' && c <= 'z') {

            d = c - 'a' + 10;

        } else {

            cout << "Invalid Common Store file name: " << fileName << endl;

            return false;

        }

        hi = hi * 36 + d;

    }

    csIndex = (INDEX) hi << 32 | lo;

    return true;

}

class LinkFile {

public:

    LinkFile(INDEX i = 0, LONGLONG id = 0, INDEX cs = 0, int v = 0, string n = 0) :
      index(i), NtfsId(id), csIndex(cs), version(v), name(n) {}

    friend bool operator<(const LinkFile& a, const LinkFile& b) {
        return a.index < b.index;
    }

    friend bool operator>(const LinkFile& a, const LinkFile& b) {
        return a.index > b.index;
    }

    friend bool operator==(const LinkFile& a, const LinkFile& b) {
        return a.index == b.index;
    }

    INDEX& LinkIndex() {
        return index;
    }

    string& FileName() {
        return name;
    }

    void display() {
        cout << "Link: " << name <<
                "   CS Index: " << csIndex <<
                "   Link Index:" << index <<
                "   Id:" << NtfsId <<
                "   Version: " << version << endl;
    }

private:

    //
    // This file's Ntfs Id.
    //

    LONGLONG NtfsId;

    //
    // Link index associated with this file.
    //

    INDEX   index;

    //
    // The common store file (index) associated with this link.
    //

    INDEX   csIndex;

    //
    // The revision number of this link file.
    //

    ULONG   version;

    //
    // The fully qualified file name.
    //

    string  name;
};

//
// The SIS Volume object.
//

class SISVolume {

public:

    //
    // Validate all SIS files on the volume.
    //

    void Validate(string& Volume);

    //
    // Set up a volume for use with SIS.
    //

    bool Create(string& Volume);

private:

    //
    // The bits that are actually in a SIS reparse point.
    //
    //
    // Version 1
    //
    typedef struct _SI_REPARSE_BUFFER_V1 {
        //
        // A version number so that we can change the reparse point format
        // and still properly handle old ones.  This structure describes
        // version 1.
        //
        ULONG                           ReparsePointFormatVersion;

        //
        // The index of the common store file.
        //
        INDEX                           CSIndex;

        //
        // The index of this link file.
        //
        INDEX                          LinkIndex;

    } SI_REPARSE_BUFFER_V1, *PSI_REPARSE_BUFFER_V1;

    //
    // Version 2
    //
    typedef struct _SI_REPARSE_BUFFER_V2 {
	    //
	    // A version number so that we can change the reparse point format
	    // and still properly handle old ones.  This structure describes
	    // version 2.
	    //
	    ULONG							ReparsePointFormatVersion;

	    //
	    // The index of the common store file.
	    //
	    INDEX							CSIndex;

	    //
	    // The index of this link file.
	    //
	    INDEX							LinkIndex;

        //
        // The file ID of the link file.
        //
        LONGLONG                        LinkFileNtfsId;

        //
        // A "131 hash" checksum of this structure.
        // N.B.  Must be last.
        //
        LARGE_INTEGER                   Checksum;

    } SI_REPARSE_BUFFER_V2, *PSI_REPARSE_BUFFER_V2;

    //
    // The bits that are actually in a SIS reparse point.  Version 3.
    //
    typedef struct _SI_REPARSE_BUFFER {

    	//
    	// A version number so that we can change the reparse point format
    	// and still properly handle old ones.  This structure describes
    	// version 1.
    	//
    	ULONG							ReparsePointFormatVersion;

    	//
    	// The index of the common store file.
    	//
    	INDEX							CSIndex;

    	//
    	// The index of this link file.
    	//
    	INDEX							LinkIndex;

        //
        // The file ID of the link file.
        //
        LONGLONG                        LinkFileNtfsId;

        //
        // The file ID of the common store file.
        //
        LONGLONG                        CSFileNtfsId;

        //
        // A "131 hash" checksum of this structure.
        // N.B.  Must be last.
        //
        LARGE_INTEGER                   Checksum;

    } SI_REPARSE_BUFFER, *PSI_REPARSE_BUFFER;

    #define	SIS_REPARSE_BUFFER_FORMAT_VERSION_1			1
    #define	SIS_REPARSE_BUFFER_FORMAT_VERSION_2			2
    #define	SIS_REPARSE_BUFFER_FORMAT_VERSION			3
    #define	SIS_MAX_REPARSE_DATA_VALUE_LENGTH (sizeof(SI_REPARSE_BUFFER))
    #define SIS_REPARSE_DATA_SIZE (sizeof(REPARSE_DATA_BUFFER)+SIS_MAX_REPARSE_DATA_VALUE_LENGTH)

    void Walk(string& dirName);

    bool GetLinkInfo(string& fileName, SI_REPARSE_BUFFER& linkInfo);

    void ComputeChecksum(PVOID buffer, ULONG size, PLARGE_INTEGER checksum);

    void ValidateLink();

    //
    // The common store object associated with this volume.
    //

    CommonStore cs;

    //
    // Database of link files.  The link files are recorded to verify that
    // duplicate link indices do not occur, and also to be able to identify
    // all link files associated with a particular common store file.
    //

    vector<LinkFile> linkFiles;
};


void
SISVolume::Validate(string& Volume)
{
    string ntVolume("\\\\.\\" + Volume);

    //
    // See if we can open the volume.
    //

    HANDLE hVolume = CreateFile(
                         ntVolume.c_str(),
                         GENERIC_READ,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);

    if (hVolume == INVALID_HANDLE_VALUE) {

        cout << "Can't open " << Volume << endl;

        return;

    } else {

        CloseHandle(hVolume);

    }

    //
    // Check the common store directory and it's files.  This will also build
    // a database of common store files that will be used to validate the link
    // files.
    //

    cs.Validate(Volume);

    cout << "Checking Link Files" << endl;

    //
    // Enumerate all of the files on the volume looking for SIS links.
    //
    // if the file is a SIS reparse point then validate it:
    //     - link index (against MaxIndex and other link indices)
    //     - CS index (lookup in CommonStore)
    //

    Walk( Volume + "\\" );

    //
    // Now we can check the reference counts in the common store files.
    //

    cout << "Checking Reference Counts" << endl;

    cs.ValidateRefCounts();

    //
    // Check for duplicate link indices.
    //

    cout << "Checking Link Indices" << endl;

    sort(linkFiles.begin(), linkFiles.end());

    vector<LinkFile>::iterator p = linkFiles.begin();

    if (p != linkFiles.end()) {

        for (++p; p != linkFiles.end(); ++p) {

            if (p == (p-1)) {

                cout << "Duplicate link index (" << (INDEX) p->LinkIndex() << "): ";
                cout << p->FileName() << ", " << (p-1)->FileName() << endl;

            }

        }

    }
}


void
SISVolume::Walk(string& dirName)
{
    WIN32_FIND_DATA findData;
    HANDLE findHandle;
    const string fileNameMatchAny = dirName + "*";

    //
    // Enumerate all files in the specified directory, looking for SIS links.
    //

    findHandle = FindFirstFile( fileNameMatchAny.c_str(), &findData );

    if (INVALID_HANDLE_VALUE == findHandle) {

        //
        // Empty directory.
        //

        return;

    }

    do {

        //
        // Check for a SIS link.
        //

        if (( findData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) &&
            ( findData.dwReserved0 == IO_REPARSE_TAG_SIS )) {

            if ( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

                //
                // File is both a directory and a SIS link -- illegal.
                //

                cout << dirName << findData.cFileName << " SIS link directory." << endl;

            }

            SI_REPARSE_BUFFER linkInfo;

            //
            // Read the reparse point data to get the link index and
            // common store index.
            //

            if (! GetLinkInfo(dirName + findData.cFileName, linkInfo)) {

                cout << dirName << findData.cFileName << " : invalid link information." << endl;

                continue;

            }

            //
            // Create a LinkFile object.
            //

            LinkFile lf(linkInfo.LinkIndex,
                        linkInfo.LinkFileNtfsId,
                        linkInfo.CSIndex,
                        linkInfo.ReparsePointFormatVersion,
                        dirName + findData.cFileName);

            //
            // And add it to our database.  Expand the database first if necessary.
            //

            if (0 == linkFiles.capacity())
                linkFiles.reserve(linkFiles.size() + 200);

            linkFiles.push_back(lf);

            if (! cs.ValidateIndex(linkInfo.LinkIndex)) {

                cout << "Invalid Link index: " << lf.FileName() << "(" << (INDEX) linkInfo.LinkIndex << ")" << endl;

            }

            //
            // Find the common store file.
            //

            CsFile *pcsFile = cs.Query(linkInfo.CSIndex);

            if (pcsFile == 0) {

                //
                // cs file was not found.
                //

                cout << "Common Store file " << (INDEX) linkInfo.CSIndex << " not found." << endl;

            } else {

                //
                // Update the external reference count on the common store file.
                //

                pcsFile->IncRefCount();

            }

            //
            // Make sure the link index isn't in use as a common store index.
            //

            pcsFile = cs.Query(linkInfo.LinkIndex);

            if (pcsFile != 0) {

                cout << "Link index collision with common store file. Link: ";
                cout << lf.FileName() << ", index: " << (INDEX) linkInfo.LinkIndex << endl;

            }

            if (verbose)
                lf.display();

        } else if ( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

            //
            // Ignore \. and \..
            //

            if ( findData.cFileName[0] == '.' ) {

                if (( findData.cFileName[1] == 0 ) ||
                    (( findData.cFileName[1] == '.' ) && ( findData.cFileName[2] == 0 )))

                    continue;

            }

            //
            // Walk down this directory.
            //

            Walk( dirName + findData.cFileName + "\\" );

        }

    } while ( FindNextFile( findHandle, &findData ) );

    FindClose( findHandle );

}

#define SHARE_ALL              (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)

bool
SISVolume::GetLinkInfo(string& fileName, SI_REPARSE_BUFFER& linkInfo)
{
    NTSTATUS  Status = STATUS_SUCCESS;
    HANDLE    fileHandle;

    UNICODE_STRING  ufileName,
                    uNTName;

    IO_STATUS_BLOCK         IoStatusBlock;
    OBJECT_ATTRIBUTES       ObjectAttributes;

    PREPARSE_DATA_BUFFER    ReparseBufferHeader = NULL;
    UCHAR                   ReparseBuffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];

    LARGE_INTEGER Checksum;

    //
    //  Allocate and initialize Unicode string.
    //

    RtlCreateUnicodeStringFromAsciiz( &ufileName, fileName.c_str() );

    RtlDosPathNameToNtPathName_U(
        ufileName.Buffer,
        &uNTName,
        NULL,
        NULL );

    //
    //  Open the file.
    //  Notice that if there are symbolic links in the path they are
    //  traversed silently.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uNTName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    //
    //  Make sure that we call open with the appropriate flags for:
    //
    //    (1) directory versus non-directory
    //    (2) reparse point
    //

    ULONG OpenOptions = FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE;

    Status = NtOpenFile(
                 &fileHandle,
                 FILE_READ_DATA | SYNCHRONIZE,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 SHARE_ALL,
                 OpenOptions );

    RtlFreeUnicodeString( &ufileName );

    if (!NT_SUCCESS( Status )) {

        cout << "Unable to open SIS link file: " << fileName << endl;

        return false;
    }

    //
    //  Get the reparse point.
    //

    Status = NtFsControlFile(
                 fileHandle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FSCTL_GET_REPARSE_POINT,
                 NULL,                                //  Input buffer
                 0,                                   //  Input buffer length
                 ReparseBuffer,                       //  Output buffer
                 MAXIMUM_REPARSE_DATA_BUFFER_SIZE );  //  Output buffer length

    NtClose( fileHandle );

    if (!NT_SUCCESS( Status )) {

        cout << "FSCTL_GET_REPARSE_POINT failed, " << (ULONG)IoStatusBlock.Information << ", " << fileName << endl;

        return false;
    }

    //
    //  Copy the SIS link info from the reparse buffer to the caller's buffer.
    //

    ReparseBufferHeader = (PREPARSE_DATA_BUFFER) ReparseBuffer;

	if (ReparseBufferHeader->ReparseTag == IO_REPARSE_TAG_SIS) {

		PSI_REPARSE_BUFFER	sisReparseBuffer = (PSI_REPARSE_BUFFER) ReparseBufferHeader->GenericReparseBuffer.DataBuffer;

        linkInfo = *sisReparseBuffer;

	    //
	    // Now check to be sure that we understand this reparse point format version and
	    // that it has the correct size.
	    //
	    if (ReparseBufferHeader->ReparseDataLength != sizeof(SI_REPARSE_BUFFER)
		    || (sisReparseBuffer->ReparsePointFormatVersion != SIS_REPARSE_BUFFER_FORMAT_VERSION)) {
		    //
		    // We don't understand it, so either its corrupt or from a newer version of SIS.
		    // Either way, we can't understand it, so punt.
		    //
		    cout << "Invalid format version in " << fileName
                 << " Version: " << sisReparseBuffer->ReparsePointFormatVersion
                 << ", expected: " << SIS_REPARSE_BUFFER_FORMAT_VERSION << endl;

            return FALSE;
	    }

        //
        // Now check the checksum.
        //
        ComputeChecksum(
	        sisReparseBuffer,
	        sizeof(SI_REPARSE_BUFFER) - sizeof sisReparseBuffer->Checksum,
	        &Checksum);

        if (Checksum.QuadPart != sisReparseBuffer->Checksum.QuadPart) {

            cout << "Invalid checksum in " << fileName << endl;

            return FALSE;
        }

    } else {

        cout << "Unexpected error. " << fileName << " : expected SIS link file, tag: " << ReparseBufferHeader->ReparseTag << endl;
        return false;
    }

    return true;

}

VOID
SISVolume::ComputeChecksum(
	IN PVOID							buffer,
	IN ULONG							size,
	OUT PLARGE_INTEGER					checksum)
/*++

Routine Description:

	Compute a checksum for a buffer.  We use the "131 hash," which
	works by keeping a 64 bit running total, and for each 32 bits of
	data multiplying the 64 bits by 131 and adding in the next 32
	bits.  Must be called at PASSIVE_LEVEL, and all aruments
	may be pagable.

Arguments:

	buffer - pointer to the data to be checksummed

	size - size of the data to be checksummed

	checksum - pointer to large integer to receive the checksum.  This
		may be within the buffer, and SipComputeChecksum guarantees that
		the initial value will be used in computing the checksum.

Return Value:

	Returns STATUS_SUCCESS or an error returned from the actual disk write.
--*/
{
	LARGE_INTEGER runningTotal;
	ULONG *ptr = (ULONG *)buffer;
	ULONG bytesRemaining = size;

	runningTotal.QuadPart = 0;

	while (bytesRemaining >= sizeof(*ptr)) {
		runningTotal.QuadPart = runningTotal.QuadPart * 131 + *ptr;
		bytesRemaining -= sizeof(*ptr);
		ptr++;
	}

	if (bytesRemaining > 0) {
		ULONG extra;

		extra = 0;
		memmove(&extra, ptr, bytesRemaining);
		
		runningTotal.QuadPart = runningTotal.QuadPart * 131 + extra;
	}

	*checksum = runningTotal;
}

bool
SISVolume::Create(string& Volume)
{
    string ntVolume("\\\\.\\" + Volume);

    //
    // See if we can open the volume.
    //

    HANDLE hVolume = CreateFile(
                         ntVolume.c_str(),
                         GENERIC_READ,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);

    if (hVolume == INVALID_HANDLE_VALUE) {

        cout << "Can't open " << Volume << endl;

        return false;

    } else {

        CloseHandle(hVolume);

    }

    //
    // The common store is the only thing we need to create.
    //

    return cs.Create(Volume);

}

void
usage()
{
    cout << "Usage: chksis [-vc] [drive:]\n        -v: verbose\n        -c: create SIS volume" << endl;
}


int
__cdecl
main(int argc, char *argv[])
{
    string volume("C:");
    bool volumeArgSeen = false;
    bool create = false;
    SISVolume sis;

    for (int i = 1; i < argc; ++i) {

        if (argv[i][0] == '-') {

            if (volumeArgSeen) {
                usage();
                exit(1);
            }

            switch (argv[i][1]) {
            case 'v':
                verbose = true;
                break;
            case 'c':
                create = true;
                break;
            default:
                usage();
                exit(1);
            }

        } else {

            volumeArgSeen = true;

            volume.assign(argv[i]);

        }

    }

    if (create) {

        if (! volumeArgSeen) {
            cout << "Must specify volume with -c" << endl;
            exit(1);
        }

        sis.Create(volume);
        exit(0);

    }

    if (! volumeArgSeen)
        cout << "Checking " << volume << endl;


    sis.Validate(volume);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\tools\sisenum\sisenum.cxx ===
#include "std.hxx"


class CException
{
protected:
    CException(
        PCTSTR pcszDescription,
        PCTSTR pcszFile,
        const DWORD  dwLine) :
            m_pcszDescription(pcszDescription),
            m_pcszFile(pcszFile),
            m_dwLine(dwLine) {}
public:
    PCTSTR GetDescription()  { return m_pcszDescription; }
    PCTSTR GetFile()         { return m_pcszFile; }
    DWORD  GetLine()         { return m_dwLine; }

    virtual void Throw() = 0;
protected:
    PCTSTR m_pcszDescription;
    PCTSTR m_pcszFile;
    DWORD  m_dwLine;
};


class CMemoryException : public CException
{
public:
    CMemoryException(
        DWORD  dwSize,
        PCTSTR pcszDescription,
        PCTSTR pcszFile,
        DWORD  dwLine) :
            CException(pcszDescription, pcszFile, dwLine),
            m_dwSize(dwSize) {}
public:
    DWORD  GetSize() { return m_dwSize; }
    void Throw() { throw *this; }
protected:
    DWORD  m_dwSize;
};


class CApiException : public CException
{
public:
    CApiException(
        DWORD  dwGleCode,
        PCTSTR pcszDescription,
        PCTSTR pcszFile,
        DWORD  dwLine) :
            CException(pcszDescription, pcszFile, dwLine),
            m_dwGleCode(dwGleCode) {}
public:
    DWORD  GetError() { return m_dwGleCode; }
    void Throw() { throw *this; }
protected:
    DWORD  m_dwGleCode;
};


#define THROW_API_EXCEPTION(description) \
    throw CApiException(                 \
        GetLastError(),                  \
        description,                     \
        _T(__FILE__),                    \
        __LINE__)



void CountReparsePoints(PCTSTR pcszInput);
void xGetRootDirectory(PCTSTR pcszInput, PTSTR* pszRootDir);
HANDLE xOpenReparseIndex(PCTSTR pcszVolume);
BOOL xGetNextReparseRecord(
    HANDLE hIndex,
    PFILE_REPARSE_POINT_INFORMATION ReparseInfo);
HANDLE xOpenVolume(PCTSTR pcszVolume);
void DisplayFileName(
    PTSTR pszVolume,
    HANDLE hVolume,
    LONGLONG llFileId);


extern "C"
void __cdecl _tmain(int argc, PTSTR argv[], PTSTR envv[])
{
    if (argc==2)
    {
        CountReparsePoints(
                argv[1]);
    }
    else
    {
        _tprintf(
            _T("sisenum: Enumerates and lists all SIS files on a given volume.\n")
            _T("Usage: sisenum <location>"));
    }
}


void CountReparsePoints(PCTSTR pcszInput)
{
    PTSTR pszVolume = NULL;
    DWORD dwCount = 0;
    HANDLE hIndex = INVALID_HANDLE_VALUE;
    HANDLE hVolume = INVALID_HANDLE_VALUE;
    FILE_REPARSE_POINT_INFORMATION ReparseInfo;
    try
    {
        xGetRootDirectory(
            pcszInput,
            &pszVolume);

        hIndex = xOpenReparseIndex(
            pszVolume);

        hVolume = xOpenVolume(
            pszVolume);

        BOOL fDone = xGetNextReparseRecord(
            hIndex,
            &ReparseInfo);

        while (!fDone)
        {
            if (IO_REPARSE_TAG_SIS==ReparseInfo.Tag)
            {
                dwCount++;
                DisplayFileName(
                    pszVolume,
                    hVolume,
                    ReparseInfo.FileReference);
            }
            fDone = xGetNextReparseRecord(
                hIndex,
                &ReparseInfo);

        }

        CloseHandle(hIndex);
        hIndex = INVALID_HANDLE_VALUE;

        _tprintf(
            _T("This volume (%s) contains %u SIS files.\n"),
            pszVolume,
            dwCount);
    }
    catch (CApiException& e)
    {
        _tprintf(
            _T("Failure: %s\nFile:    %s\nLine:    %u\nError:   %u"),
            e.GetDescription(),
            e.GetFile(),
            e.GetLine(),
            e.GetError());
    }
    catch (CMemoryException& e)
    {
        _tprintf(
            _T("Out of memory.\n"));
    }

    if (hIndex!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(
            hIndex);
    }
    if (hVolume!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(
            hVolume);
    }
    delete []pszVolume;
}


void xGetRootDirectory(PCTSTR pcszInput, PTSTR* pszRootDir)
{
    DWORD dwBufferSize = MAX_PATH;
    PTSTR pszTemp;

    *pszRootDir = NULL;

    BOOL bResult;
    DWORD dwGleCode;

    do
    {
        pszTemp = new TCHAR[dwBufferSize];
        bResult = GetVolumePathName(
            pcszInput,
            pszTemp,
            dwBufferSize);

        if (!bResult)
        {
            delete []pszTemp;
            dwGleCode = GetLastError();
            if (ERROR_BUFFER_OVERFLOW==dwGleCode)
            {
                dwBufferSize *= 2;
            }
            else
            {
                THROW_API_EXCEPTION(_T("GetVolumePathName failed."));
            }
        }
    } while (!bResult);
    *pszRootDir = pszTemp;
}


HANDLE xOpenReparseIndex(PCTSTR pcszVolume)
{
    HANDLE hReparseIndex;
    PTSTR pszReparseIndex = NULL;

    pszReparseIndex = new TCHAR[_tcslen(pcszVolume)+64];
    _tcscpy(
        pszReparseIndex,
        pcszVolume);
    PathAddBackslash(pszReparseIndex);
    _tcscat(
        pszReparseIndex,
        _T("$Extend\\$Reparse:$R:$INDEX_ALLOCATION"));

   hReparseIndex = CreateFile(
       pszReparseIndex,
       GENERIC_READ,
       FILE_SHARE_READ,
       NULL,
       OPEN_EXISTING,
       FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
       NULL);

   delete []pszReparseIndex;

   if (INVALID_HANDLE_VALUE == hReparseIndex)
   {
       THROW_API_EXCEPTION(_T("Unable to open reparse index."));
   }

   return hReparseIndex;
}


HANDLE xOpenVolume(PCTSTR pcszVolume)
{
    HANDLE hVolume = INVALID_HANDLE_VALUE;
    PTSTR pszVolumeName = NULL;

    pszVolumeName = new TCHAR[MAX_PATH];

    BOOL bResult = GetVolumeNameForVolumeMountPoint(
        pcszVolume,
        pszVolumeName,
        MAX_PATH);

    if (bResult)
    {
        hVolume = CreateFile(
            pszVolumeName,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
            NULL);
    }

    delete []pszVolumeName;

    if (INVALID_HANDLE_VALUE == hVolume)
    {
        THROW_API_EXCEPTION(_T("Unable to open volume."));
    }

   return hVolume;
}


BOOL xGetNextReparseRecord(
    HANDLE hIndex,
    PFILE_REPARSE_POINT_INFORMATION ReparseInfo)
{
    BOOL bResult = FALSE;
    IO_STATUS_BLOCK ioStatus;

    NTSTATUS status = NtQueryDirectoryFile(hIndex,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        ReparseInfo,
        sizeof(FILE_REPARSE_POINT_INFORMATION),
        FileReparsePointInformation,
        TRUE,
        NULL,
        FALSE);
    if (!NT_SUCCESS(status))
    {
        SetLastError(RtlNtStatusToDosError(status));
        if (GetLastError() != ERROR_NO_MORE_FILES)
        {
            THROW_API_EXCEPTION(_T("Unable to open reparse index."));
        }
        bResult = TRUE;
    }

    return bResult;
}


void DisplayFileName(
    PTSTR pszVolume,
    HANDLE hVolume,
    LONGLONG llFileId)
{
    UNICODE_STRING          usIdString;
    NTSTATUS                status;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    HANDLE                  hFile = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK         IoStatusBlock;

    struct {
        FILE_NAME_INFORMATION   FileInformation;
        WCHAR                   FileName[MAX_PATH];
    } NameFile;

    ZeroMemory(
        &NameFile,
        sizeof(NameFile));

    usIdString.Length = sizeof(LONGLONG);
    usIdString.MaximumLength = sizeof(LONGLONG);
    usIdString.Buffer = (PWCHAR)&llFileId;

    InitializeObjectAttributes(
            &ObjectAttributes,
            &usIdString,
            OBJ_CASE_INSENSITIVE,
            hVolume,
            NULL);      // security descriptor

    status = NtCreateFile(
                &hFile,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,           // allocation size
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_NON_DIRECTORY_FILE | FILE_OPEN_BY_FILE_ID,
                NULL,           // EA buffer
                0);             // EA length

    if (NT_SUCCESS(status))
    {
        status = NtQueryInformationFile(
            hFile,
            &IoStatusBlock,
            &(NameFile.FileInformation),
            sizeof(NameFile),
            FileNameInformation);

        if (NT_SUCCESS(status))
        {
            wprintf(L"%s\n",NameFile.FileInformation.FileName);
        }
        else
        {
            _tprintf(_T("Unable to query file name.\n"));
        }
    }
    else
    {
        _tprintf(_T("Unable to open file by ID.\n"));
    }

    if (hFile!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\tools\sisinfo\sisinfo.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   sisSetup.c

Abstract:

   This module is used to install the SIS and GROVELER services.


Environment:

   User Mode Only

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>

#include <windows.h>
#include <strsafe.h>
#include <stdlib.h>
#include <objbase.h>

//
//  SIS reparse buffer definition
//

#define	SIS_REPARSE_BUFFER_FORMAT_VERSION 5

typedef struct _SIS_REPARSE_BUFFER {

	ULONG							ReparsePointFormatVersion;
	ULONG							Reserved;

	//
	// The id of the common store file.
	//
	GUID							CSid;

	//
	// The index of this link file.
	//
	LARGE_INTEGER   				LinkIndex;

    //
    // The file ID of the link file.
    //
    LARGE_INTEGER                   LinkFileNtfsId;

    //
    // The file ID of the common store file.
    //
    LARGE_INTEGER                   CSFileNtfsId;

	//
	// A "131 hash" checksum of the contents of the
	// common store file.
	//
	LARGE_INTEGER					CSChecksum;

    //
    // A "131 hash" checksum of this structure.
    // N.B.  Must be last.
    //
    LARGE_INTEGER                   Checksum;

} SIS_REPARSE_BUFFER, *PSIS_REPARSE_BUFFER;


//
//  Global variables
//

const wchar_t ReparseIndexName[] = L"$Extend\\$Reparse:$R:$INDEX_ALLOCATION";


//
//  Functions
//
                        
void
DisplayUsage (
    void
    )
/*++

Routine Description:

   This routine will display an error message based off of the Win32 error
   code that is passed in. This allows the user to see an understandable
   error message instead of just the code.

Arguments:

   None

Return Value:

   None.

--*/
{
    printf( "\nUsage:  sisInfo [/?] [/h] [drive:]\n"
            "  /? /h Display usage information (default if no operation specified).\n"
            " drive: The volume to display SIS information on\n"
          );
}


void
DisplayError (
   DWORD Code,
   LPSTR Msg,
   ...
   )
/*++

Routine Description:

    This routine will display an error message based off of the Win32 error
    code that is passed in. This allows the user to see an understandable
    error message instead of just the code.

Arguments:

    Msg - The error message to display       
    Code - The error code to be translated.

Return Value:

    None.

--*/
{
    wchar_t errmsg[128];
    DWORD count;
    va_list ap;

    //printf("\n");
    va_start( ap, Msg );
    vprintf( Msg, ap );
    va_end( ap );

    //
    // Translate the Win32 error code into a useful message.
    //

    count = FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    Code,
                    0,
                    errmsg,
                    sizeof(errmsg),
                    NULL );

    //
    // Make sure that the message could be translated.
    //

    if (count == 0) {

        printf( "(%d) Could not translate Error\n", Code );

    } else {

        //
        // Display the translated error.
        //

        printf( "(%d) %S", Code, errmsg );
    }
}


DWORD
OpenReparseInformation(
    IN wchar_t *name,
    OUT HANDLE *hReparseIndex,
    OUT HANDLE *hRootDirectory,
    OUT wchar_t *volName,
    OUT DWORD volNameSize       //in characters
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    BOOL bResult;
    DWORD status = ERROR_SUCCESS;
    wchar_t *idxName = NULL;
    DWORD bfSz;

    *hReparseIndex = INVALID_HANDLE_VALUE;
    *hRootDirectory = INVALID_HANDLE_VALUE;

    try {

        //
        //  Get the volume name from the given path
        //

        bResult = GetVolumePathName( name,
                                     volName,
                                     volNameSize );
    
        if (!bResult) {

            status = GetLastError();
            //ASSERT(status != ERROR_SUCCESS);
            DisplayError( status,
                          "Error calling GetVolumePathName on \"%s\"\n",
                          name );
            leave;
        }

        //
        //  Open the root directory of the volume
        //

        *hRootDirectory = CreateFile( volName,
                                      GENERIC_READ,
                                      FILE_SHARE_READ,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
                                      NULL );

        if (*hRootDirectory == INVALID_HANDLE_VALUE) {

            status = GetLastError();
            //ASSERT(status != ERROR_SUCCESS);
            DisplayError( status,
                          "Error opening \"%s\"\n",
                          volName );
            leave;
        }

        //
        //  Get the reparse index name to open
        //

        bfSz = wcslen(volName) + wcslen(ReparseIndexName) + 1;

        idxName = malloc(bfSz * sizeof(wchar_t));
        if (idxName == NULL) {

            status = ERROR_NOT_ENOUGH_MEMORY;
            DisplayError( status,
                          "Error allocating %d bytes of memory\n",
                          (bfSz * sizeof(wchar_t)) );
            leave;
        }

        StringCchCopy( idxName, bfSz, volName );
        StringCchCat( idxName, bfSz, ReparseIndexName );

        //
        //  Open the reparse index
        //

        *hReparseIndex = CreateFile( idxName,
                                     GENERIC_READ,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
                                     NULL );

        if (*hReparseIndex == INVALID_HANDLE_VALUE) {

            status = GetLastError();
            //ASSERT(status != ERROR_SUCCESS);
            DisplayError( status,
                          "Error opening \"%s\"\n",
                          idxName );
            leave;
        }

    } finally {

        //
        //  cleanup
        //

        if (idxName) {

            free(idxName);
        }

        //
        //  cleanup handles if the operation failed
        //

        if (status != STATUS_SUCCESS) {

            if (*hRootDirectory != INVALID_HANDLE_VALUE) {

                CloseHandle( *hRootDirectory );
                *hRootDirectory = INVALID_HANDLE_VALUE;
            }
            
            if (*hReparseIndex != INVALID_HANDLE_VALUE) {

                CloseHandle( *hReparseIndex );
                *hReparseIndex = INVALID_HANDLE_VALUE;
            }
        }
    }

    return status;
}


void
CloseReparseInformation(
    IN HANDLE *hReparseIndex,
    IN HANDLE *hRootDirectory
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    if (*hReparseIndex !=INVALID_HANDLE_VALUE)
    {

        CloseHandle( *hReparseIndex );
        *hReparseIndex = INVALID_HANDLE_VALUE;
    }

    if (*hRootDirectory !=INVALID_HANDLE_VALUE)
    {

        CloseHandle( *hRootDirectory );
        *hRootDirectory = INVALID_HANDLE_VALUE;
    }
}


DWORD
GetNextReparseRecord(
    HANDLE hReparseIdx,
    PFILE_REPARSE_POINT_INFORMATION ReparseInfo
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DWORD status = ERROR_SUCCESS;
    NTSTATUS ntStatus;
    IO_STATUS_BLOCK ioStatus;

    ntStatus = NtQueryDirectoryFile( hReparseIdx,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &ioStatus,
                                     ReparseInfo,
                                     sizeof(FILE_REPARSE_POINT_INFORMATION),
                                     FileReparsePointInformation,
                                     TRUE,
                                     NULL,
                                     FALSE );

    if (!NT_SUCCESS(ntStatus))
    {
        status = RtlNtStatusToDosError(ntStatus);
        SetLastError(status);

        if (status != ERROR_NO_MORE_FILES)
        {
            DisplayError(status,
                         "Error reading reparse point index\n");
        }
    }

    return status;
}


wchar_t *
GetCsFileName(
    IN GUID *Guid,
    IN wchar_t *Buffer,
    IN DWORD BufferSize     //in bytes
    )
/*++

Routine Description:

    This routine will convert the given sis guid into the name of the
    common store file.

Arguments:

Return Value:

--*/
{
    LPWSTR guidString;

    if (StringFromIID( Guid, &guidString ) != S_OK) {
        
        (void)StringCbCopy( Buffer, BufferSize, L"<Invalid GUID>" );
        
    } else {

        //
        //  I want to exclude the starting and ending brace
        //

        (void)StringCbCopyN( Buffer, BufferSize, guidString+1, (36 * sizeof(wchar_t)) );
        (void)StringCbCat( Buffer, BufferSize, L".sis" );
        CoTaskMemFree( guidString );
    }

    return Buffer;
}


void
DisplayFileName(
    HANDLE hRootDir,
    wchar_t *VolPathName,
    LONGLONG FileId)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    UNICODE_STRING idName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK ioStatusBlock;
    wchar_t csFileName[256];
    UCHAR reparseData[1024];
    PSIS_REPARSE_BUFFER sisReparseData;
    wchar_t *fname;
    
    struct {
        FILE_NAME_INFORMATION   FileInformation;
        wchar_t                 FileName[MAX_PATH];
    } NameFile;

    //
    //  Setup local parameters
    ZeroMemory( &NameFile, sizeof(NameFile) );

    idName.Length = sizeof(LONGLONG);
    idName.MaximumLength = sizeof(LONGLONG);
    idName.Buffer = (wchar_t *)&FileId;

    //
    //  Open the given file by ID
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                &idName,
                                OBJ_CASE_INSENSITIVE,
                                hRootDir,
                                NULL );      // security descriptor

    ntStatus = NtCreateFile( &hFile,
                             FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                             &ObjectAttributes,
                             &ioStatusBlock,
                             NULL,            // allocation size
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                             FILE_OPEN,
                             FILE_NON_DIRECTORY_FILE | FILE_OPEN_BY_FILE_ID | FILE_OPEN_REPARSE_POINT,
                             NULL,            // EA buffer
                             0 );             // EA length

    if (NT_SUCCESS(ntStatus)) {

        //
        //  Try to get its file name
        //

        ntStatus = NtQueryInformationFile( hFile,
                                           &ioStatusBlock,
                                           &NameFile.FileInformation,
                                           sizeof(NameFile),
                                           FileNameInformation );

        if (NT_SUCCESS(ntStatus)) {

            //
            //  Get the name to display, don't include the leading slash
            //  (it is in the volume name)
            //

            fname = (NameFile.FileInformation.FileName + 1);

            //
            //  Get reparse point information
            //

            ntStatus = NtFsControlFile( hFile,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &ioStatusBlock,
                                        FSCTL_GET_REPARSE_POINT,
                                        NULL,
                                        0,
                                        &reparseData,
                                        sizeof(reparseData) );

            if (NT_SUCCESS(ntStatus)) {

                //
                //  We received the reparse point information, display
                //  the name information
                //

                sisReparseData = (PSIS_REPARSE_BUFFER)&((PREPARSE_DATA_BUFFER)reparseData)->GenericReparseBuffer.DataBuffer;

                printf( "%S%S -> %SSIS Common Store\\%S\n",
                        VolPathName,
                        fname,
                        VolPathName,            
                        GetCsFileName( &sisReparseData->CSid, csFileName, sizeof(csFileName)) );

            } else {

                //
                //  Could not get REPARSE point information, just display name
                printf( "%S%S\n",
                        VolPathName,
                        fname );
            }

        } else {

            printf( "Unable to query file name for %S%04I64x.%012I64x (%d)\n",
                    VolPathName,
                    ((FileId >> 48) & 0xffff),
                    FileId & 0x0000ffffffffffff,
                    ntStatus );
        }

        CloseHandle(hFile);

    } else {

        printf( "Unable to open file by ID for %S%04I64x.%012I64x (%d)\n",
                VolPathName,
                ((FileId >> 48) & 0xffff),
                FileId & 0x0000ffffffffffff,
                ntStatus );
    }
}


void
DisplaySisFiles( 
    IN HANDLE hReparseIdx,
    IN HANDLE hRootDir,
    IN wchar_t *VolPathName
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DWORD status;
    DWORD tagCount = 0;
    FILE_REPARSE_POINT_INFORMATION reparseInfo;

    do {

        status = GetNextReparseRecord( hReparseIdx,
                                       &reparseInfo );

        if (status != ERROR_SUCCESS) {

            break;
        }

        if (reparseInfo.Tag == IO_REPARSE_TAG_SIS)
        {
            tagCount++;

            DisplayFileName( hRootDir,
                             VolPathName,
                             reparseInfo.FileReference );

        }
    } while (TRUE);

    printf( "\nThe volume \"%S\" contains %d SIS controled files.\n", VolPathName, tagCount );
}



void __cdecl 
wmain(
   int argc,
   wchar_t *argv[]
   )
/*++

Routine Description:

   Main program

Arguments:

   argc - The count of arguments passed into the command line.
   argv - Array of arguments passed into the command line.

Return Value:

   None.

--*/
{
    wchar_t *param;
    int i;
    DWORD status;
    HANDLE hReparseIdx = INVALID_HANDLE_VALUE;
    HANDLE hRootDir = INVALID_HANDLE_VALUE;
    wchar_t volPathName[256];    
    BOOL didSomething = FALSE;
    
    //
    //  Parase parameters then perform the operations that we can
    //

    for (i=1; i < argc; i++)  {

        param = argv[i];

        //
        //  See if a SWITCH
        //

        if ((param[0] == '-') || (param[0] == '/')) {

            //
            //  We have a switch header, make sure it is 1 character long
            //

            if (param[2] != 0) {
                DisplayError(ERROR_INVALID_PARAMETER,
                             "Parsing \"%s\", ",
                             param);
                DisplayUsage();
                return;
            }

            //
            //  Figure out the switch
            //

            switch (param[1]) {

                case '?':
                case 'h':
                case 'H':
                    DisplayUsage();
                    return;

                default:
                    DisplayError(ERROR_INVALID_PARAMETER,
                             "Parsing \"%s\", ",
                             param);
                    DisplayUsage();
                    return;
            }

        } else {

            didSomething = TRUE;

            //
            //  We had a parameter which should be a volume, handle it.
            //

            status = OpenReparseInformation( param,
                                             &hReparseIdx, 
                                             &hRootDir,
                                             volPathName, 
                                             (sizeof(volPathName)/sizeof(wchar_t)) );

            if (status != ERROR_SUCCESS) {

                return;
            }

            //
            //  display the SIS files
            //

            DisplaySisFiles( hReparseIdx, 
                             hRootDir,
                             volPathName );

            //
            //  close the files
            //

            CloseReparseInformation( &hReparseIdx, &hRootDir );

            break;
        }
    }

    //
    //  If it is still "1" then no parameter were given, display usage
    //    

    if (!didSomething) {

        DisplayUsage();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\tools\rpget\rpget.h ===
/*++

	Header file for reparse point stress test

	Modification History:

		08/18/97	anandn		created

--*/


//
// include system headers..
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>

#include <windows.h>
#include <winioctl.h>
#include <winbase.h>
#include <wtypes.h>
#include <winver.h>

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

#define THREAD __declspec(thread)	//thread local storage


typedef ULONG			TAG;	// define a datatype for Tag

#define NO_GLE			ERROR_SUCCESS

#define NO_TAG_SET		IO_REPARSE_TAG_RESERVED_ZERO

#define FILE_CLOSED		INVALID_HANDLE_VALUE	


//
// #def all our constants..
//


#define FIRST_USER_TAG	(0x02) // first user tag

#define MAX_USER_TAG	((TAG) 0xFFFF) // max tag settable by user

#define MAX_ULONGLONG	(~(ULONGLONG) 0)

#define MAX_ULONG		(~(ULONG) 0)

#define PAGE_SIZE		(0x1000)	// system page size

#define LINE_LENGTH		80		// 80 chars in a line
			
#define FS_NAME_SIZE	20		// max size for a FS name.eg:"NTFS","FAT" etc..

#define DRV_NAME_SIZE	2		// size of drive name string eg: "c:" 

#define MAX_DRIVES		26			// maximum number of drive letters

#define MAX_DELAY		50			// maximum delay time in msecs



#define MAX_TEST_FILES (1000)
#define MIN_TEST_FILES (50)

#define CHAR_CODES	"."

//
// number of check values for data verification..
//

#define NUM_CHECK_BYTES	5


//
// logging options
//

#define LOG_OPTIONS 	( TLS_REFRESH | TLS_SEV2 | TLS_WARN | TLS_PASS | \
						  TLS_MONITOR | TLS_VARIATION |	\
						  TLS_SYSTEM  | TLS_INFO )

#define LOG_INFO(m)		LogMessage( m, TLS_INFO, NO_GLE );
#define LOG_WARN(m)		LogMessage( m, TLS_WARN, NO_GLE );
#define LOG_SEV2(m)		LogMessage( m, TLS_SEV2, NO_GLE );

#define LOG_INFO_GLE(m)	LogMessage( m, TLS_INFO, GetLastError() );
#define LOG_WARN_GLE(m)	LogMessage( m, TLS_WARN, GetLastError() );
#define LOG_SEV2_GLE(m)	LogMessage( m, TLS_SEV2, GetLastError() );



//
// SZE returns the number of elements in an array 
//

#define SZE(a) (sizeof(a)/sizeof(a[0]))


//
// Loops over each value in table passed in 
// WARNING: Assumption here is x is root name of both global array and 
// index variable. i.e. if x is foo, ifoo is index and gafoo is gloabl 
// array being looped over 
//

#define FOR_EACH(x) for ( i##x = 0; i##x < SZE(ga##x); i##x++ )


//
// exception code raised for sev2 logging
//

#define EXCEPTION_CODE_SEV2	(0xE0000002) 


//
// raise a severity2 exception
//

#define RAISE_EXCEPTION_SEV2	RaiseException( EXCEPTION_CODE_SEV2, 0,0,0);



//
// free a pointer if not null
//

#define FREE(ptr)		if (NULL != (ptr)) { \
							free( ptr );	 \
							ptr = NULL;		 \
						}

//
// few sleep times..
//

#define FIVE_SECS	5000
#define TWO_SECS	2000
#define ONE_SECS	1000


enum TESTFILE_STATUS { FILE_LOCKED, FILE_FREE };
enum TESTFILE_TYPE   { ITS_A_FILE, ITS_A_DIR };

//
// the Options struct is filled from command line arguments 
//

typedef struct {

	CHAR szProgramName[MAX_PATH + 1];	// name of test program (ie argv[0])
	CHAR Drive;							// drive to test
	CHAR szTestDir[MAX_PATH + 1];		// test dir to use on specified drive

	DWORD dwMaxTestFiles;
	DWORD dwMinTestFiles;
	
} OPTIONS, *POPTIONS;


//
// Central struc that holds info for a test file..
//

struct TESTFILE_INFO_NODE {
	WORD wFileStatus;
	HANDLE hFile;
	TAG RPTag;
	USHORT usDataBuffSize;
	BYTE CheckBytes[NUM_CHECK_BYTES];
	struct TESTFILE_INFO_NODE* pNext;
	WCHAR FileName[1];
};


typedef struct TESTFILE_INFO_NODE  TESTFILE_INFO_NODE;

typedef TESTFILE_INFO_NODE* PTESTFILE_INFO_NODE;





//
// function prototypes
//


VOID 
ParseArgs(INT argc, CHAR* argv[], POPTIONS pOptions);						


VOID
PrintUsage( CHAR szProgramName[], CHAR szErrorString[] );


VOID
Initialize( OPTIONS Options );


VOID 
Stress( OPTIONS Options );


VOID
Cleanup( OPTIONS Options );


VOID
ExceptionHandler( DWORD dwExceptionCode );


HANDLE
GetNewHandleIfClosed( PTESTFILE_INFO_NODE pNode );


DWORD WINAPI
CreateFileThread( LPVOID lpvThreadParam );


DWORD WINAPI
CloseOrDeleteFileThread( LPVOID lpvThreadParam );


DWORD WINAPI
RPSetThread( LPVOID lpvThreadParam );


DWORD WINAPI
RPGetThread( LPVOID lpvThreadParam );


DWORD WINAPI
RPDelThread( LPVOID lpvThreadParam );


BOOL 
RPSet(PTESTFILE_INFO_NODE pNode, 
	  TAG RPTag, PUCHAR pDataBuff, USHORT usDataBuffSize);

BOOL
RPGet(CHAR szFileName[], BYTE **ppOutBuff); 


BOOL
RPDel( PTESTFILE_INFO_NODE pNode );


VOID
SelectAndLockRandomNode( TESTFILE_INFO_NODE **ppNode, CHAR s[] );


VOID
ReleaseNodeLock( PTESTFILE_INFO_NODE pNode );


BOOL
AddToTestFileList( HANDLE hFile, CHAR szFileName[] );


BOOL
DeleteFromTestFileList( PTESTFILE_INFO_NODE pNode );


TAG
GetTagToSet( VOID );


VOID
DumpBuff( PBYTE pData, WORD wSize );

VOID 
GenerateTempFileName( LPSTR lpFileName );


HANDLE
CreateRPFile( CHAR szFileName[] );


HANDLE 
OpenHandleToVolume(CHAR szVolName[]);


BOOL
IsFileSysNtfs(CHAR szVolRoot[]);


VOID
StartLogSession(CHAR szProgName[]);


VOID 
EndLogSession(DWORD dwExitCode);


ULONG 
HiPart(ULONGLONG n);


ULONG 
LoPart(ULONGLONG n);


VOID
LogMessage( CHAR szLogMsg[], ULONG dwLevel, DWORD gle );


VOID 
LogAtLevel( CHAR szOutMsg[], ULONG dwLevel );



VOID
GenerateReparsePoints( VOID );


VOID
SetReparsePoint( CHAR szFileName[],
				 TAG Tag,
				 UCHAR szData[] );

TAG
GetTagToSet( VOID );


VOID
GetReparsePoint( VOID );


VOID
DeleteReparsePoint( VOID );


VOID 
PrintError(char szWhatFailed[], int flag);


HANDLE 
RPOpen (LPSTR szFileName, LPSTR szOption );


VOID
SzToWsz ( OUT WCHAR *Unicode,
          IN char *Ansi ) ;


VOID
WszToSz ( OUT char *Ansi,
		  IN WCHAR *Unicode );


NTSTATUS OpenObject (
                    WCHAR *pwszFile,
                    ULONG CreateOptions,
                    ULONG DesiredAccess,
                    ULONG ShareAccess,
                    ULONG CreateDisposition,
                    IO_STATUS_BLOCK *IoStatusBlock,
                    HANDLE *ObjectHandle);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\tools\flink\flinks.h ===
#include <stdlib.h>     //  Has exit()
#include <stdio.h>      //  Has printf() and related ...

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>
#include <rpc.h>

#include <windows.h>    //  Needs to come after the NT header files.  Has DWORD

//#define	RDB DataBuffer	// This is a temp hack to allow differing underlying NT versions for Bill & Scott
#define RDB GenericReparseBuffer.DataBuffer	// Everyone Post-Bill.

//
//  Private #defines
//

#define SHARE_ALL              (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)
#define GetFileAttributeError  0xFFFFFFFF

#define ATTRIBUTE_TYPE DWORD    //  ULONG, really

#define GET_ATTRIBUTES(FileName, Attributes) Attributes = GetFileAttributes(FileName)

#define IF_GET_ATTR_FAILS(FileName, Attributes) GET_ATTRIBUTES(FileName, Attributes); if (Attributes == GetFileAttributeError)

//
//  FIX to pre-processor messing me up ...
//  Look at this some more!  97/01/23   --fc
//

#define DeleteFileA   DeleteFile

//
//  Global flags shared throughout.
//
//  ParseArgs is the place where they get set and verified for mutual
//  consistency.
//

BOOLEAN  fAlternateCreateDefault = FALSE;
BOOLEAN  fCopy     = FALSE;
BOOLEAN  fCreate   = FALSE;
BOOLEAN  fDelete   = FALSE;
BOOLEAN  fDisplay  = FALSE;
BOOLEAN  fModify   = FALSE;
BOOLEAN  fRename   = FALSE;
BOOLEAN  fVerbose  = FALSE;
BOOLEAN  fVVerbose = FALSE;



//
//  Signatures of internal routines.
//


void
ParseArgs(
    int argc,
    char *argv[]
    );


void
Usage(
    void
    );


BOOLEAN
IsFlag(
    char *argv
    );


NTSTATUS
CreateSymbolicLink(
    CHAR           *SourceName,
    CHAR           *DestinationName,
    ATTRIBUTE_TYPE  Attributes1,
    BOOLEAN         VerboseFlag
    );


NTSTATUS
DeleteSymbolicLink(
    CHAR           *DestinationName,
    ATTRIBUTE_TYPE  Attributes2,
    BOOLEAN         VerboseFlag
    );


NTSTATUS
DisplaySymbolicLink(
    CHAR            *DestinationName,
    ATTRIBUTE_TYPE   Attributes2,
    BOOLEAN          VerboseFlag
    );


NTSTATUS
CreateEmptyFile(
    CHAR           *DestinationName,
    ATTRIBUTE_TYPE  Attributes1,
    BOOLEAN         VerboseFlag
    );


NTSTATUS
CopySymbolicLink(
    CHAR           *SourceName,
    CHAR           *DestinationName,
    ATTRIBUTE_TYPE  Attributes1,
    BOOLEAN         VerboseFlag
    );


NTSTATUS
RenameSymbolicLink(
    CHAR           *SourceName,
    CHAR           *DestinationName,
    ATTRIBUTE_TYPE  Attributes1,
    BOOLEAN         VerboseFlag
    );
//
// Stuff crabbed from dd\sis\sfilter\sip.h
//

typedef GUID CSID, *PCSID;
typedef LARGE_INTEGER LINK_INDEX, *PLINK_INDEX;

typedef struct _SI_REPARSE_BUFFER {

	//
	// A version number so that we can change the reparse point format
	// and still properly handle old ones.  This structure describes
	// version 4.
	//
	ULONG							ReparsePointFormatVersion;

	ULONG							Reserved;

	//
	// The id of the common store file.
	//
	CSID							CSid;

	//
	// The index of this link file.
	//
	LINK_INDEX						LinkIndex;

    //
    // The file ID of the link file.
    //
    LARGE_INTEGER                   LinkFileNtfsId;

    //
    // The file ID of the common store file.
    //
    LARGE_INTEGER                   CSFileNtfsId;

	//
	// A "131 hash" checksum of the contents of the
	// common store file.
	//
	LARGE_INTEGER						CSChecksum;

    //
    // A "131 hash" checksum of this structure.
    // N.B.  Must be last.
    //
    LARGE_INTEGER                   Checksum;

} SI_REPARSE_BUFFER, *PSI_REPARSE_BUFFER;

#define	SIS_REPARSE_BUFFER_FORMAT_VERSION			4
#define	SIS_MAX_REPARSE_DATA_VALUE_LENGTH (sizeof(SI_REPARSE_BUFFER))
#define SIS_REPARSE_DATA_SIZE (sizeof(REPARSE_DATA_BUFFER)+SIS_MAX_REPARSE_DATA_VALUE_LENGTH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\tools\refcount\refcount.cpp ===
#include <stdio.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>

#include <windows.h>
#include <fcntl.h>
#include <string.h>

#include <assert.h>
#include "..\..\filter\sis.h"

void usage(void)
{
    fprintf(stderr,"usage: refcount CommonStoreFileName\n");
	fprintf(stderr,"          prints out the backpointer stream info for the given CS file.\n");
	exit(1);
}

void
printFileNameById(
	PLARGE_INTEGER			fileId,
	HANDLE					hFile)		// hFile is for any file on the same volume as fileId
{
	UNICODE_STRING			fileIdString[1];
	NTSTATUS				status;
	OBJECT_ATTRIBUTES		Obja[1];
	HANDLE					fileByIdHandle = NULL;
	IO_STATUS_BLOCK			Iosb[1];
    struct {
        FILE_NAME_INFORMATION   nameFileInfo[1];
        WCHAR                   nameBuffer[255];
    } nameFile;

	memset(&nameFile, 0, sizeof(nameFile));

	fileIdString->Length = fileIdString->MaximumLength = sizeof(LARGE_INTEGER);

	fileIdString->Buffer = (PWCHAR)fileId;

	InitializeObjectAttributes(
			Obja,
			fileIdString,
			OBJ_CASE_INSENSITIVE,
			hFile,
			NULL);		// security descriptor

	status = NtCreateFile(
				&fileByIdHandle,
				FILE_READ_ATTRIBUTES | SYNCHRONIZE,
				Obja,
				Iosb,
				NULL,			// allocation size
				FILE_ATTRIBUTE_NORMAL,
				FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
				FILE_OPEN,
				FILE_NON_DIRECTORY_FILE | FILE_OPEN_BY_FILE_ID,
				NULL,			// EA buffer
				0);				// EA length

	if (!NT_SUCCESS(status)) {
		printf("open failed 0x%x",status);
		return;
	}

	status = NtQueryInformationFile(
				fileByIdHandle,
				Iosb,
				nameFile.nameFileInfo,
				sizeof(nameFile),
				FileNameInformation);

	if (!NT_SUCCESS(status)) {
		printf("couldn't query name 0x%x",status);
		NtClose(fileByIdHandle);
		return;
	}

	printf("%ws",nameFile.nameFileInfo->FileName);

	NtClose(fileByIdHandle);

	return;
}


void __cdecl main(int argc, char **argv)
{
    if (argc != 2) usage();

	char *streamName;
	unsigned validReferences = 0;
	unsigned	consecutiveMaxIndicesSeen = 0;

	streamName = (char *)malloc(strlen(argv[1]) + 100);
    if (streamName == NULL) {
		fprintf(stderr,"Unable to allocate memory\n");
        exit(1);
    }

	strcpy(streamName,argv[1]);
	strcat(streamName,":sisBackpointers$");

	HANDLE hFile = 
			CreateFile(
				streamName,
				GENERIC_READ, 
				FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
				NULL, 
				OPEN_EXISTING,
				FILE_ATTRIBUTE_NORMAL,
				NULL);

	if (hFile == INVALID_HANDLE_VALUE) {
		fprintf(stderr,"Unable to open backpointer stream for file %s, %d\n",streamName,GetLastError());
		exit(1);
	}

	const int backpointerEntriesPerSector = 512 / sizeof(SIS_BACKPOINTER);

	PSIS_BACKPOINTER sector = (PSIS_BACKPOINTER)  malloc(512);

	int firstEntry = TRUE;

	assert(sector);

	ULONGLONG previousLinkIndex = 0;

	for (;;) {
		unsigned long bytesRead;

		if (!ReadFile(hFile,sector,512,&bytesRead,NULL)) {
			fprintf(stderr,"readFile of sector failed %d\n",GetLastError());
			exit(1);
		}

		if (0 == bytesRead) {
			break;
		}

		if (bytesRead < 512) {
			fprintf(stderr,"*** read %d of 512 bytes\n",bytesRead);
		}

		for (unsigned i = 0 ; i < backpointerEntriesPerSector; i++) {
			if (firstEntry) {
				firstEntry = FALSE;
				PSIS_BACKPOINTER_STREAM_HEADER header = (PSIS_BACKPOINTER_STREAM_HEADER)sector;

				printf("format version %d, magic 0x%x, checksum 0x%x.0x%x\n\n",
						header->FormatVersion,header->Magic,(DWORD)(header->FileContentChecksum >> 32),
						(DWORD)header->FileContentChecksum);

			} else {
				if (MAXLONGLONG != sector[i].LinkFileNtfsId.QuadPart) {

					if (0 != consecutiveMaxIndicesSeen) {
						printf("%d consecutive MaxIndices (ie., null entries)\n",consecutiveMaxIndicesSeen);
						consecutiveMaxIndicesSeen = 0;
					}

					printf("0x%08x.0x%08x -> 0x%08x.0x%08x\t%c ",sector[i].LinkFileIndex.HighPart,sector[i].LinkFileIndex.LowPart,
							sector[i].LinkFileNtfsId.HighPart,sector[i].LinkFileNtfsId.LowPart,
							sector[i].LinkFileIndex.QuadPart >= previousLinkIndex ? ' ' : '*');
				}

				previousLinkIndex = sector[i].LinkFileIndex.QuadPart;

				if (MAXLONGLONG == sector[i].LinkFileNtfsId.QuadPart) {

					if (0 == consecutiveMaxIndicesSeen) printf("\n");

					consecutiveMaxIndicesSeen++;
				} else {
					if (sector[i].LinkFileNtfsId.LowPart != 0xffffffff || sector[i].LinkFileNtfsId.HighPart != 0x7fffffff) {
						validReferences++;

						printFileNameById(&sector[i].LinkFileNtfsId,hFile);
					}
					printf("\n");
				}
			}
		}
	}

	if (0 != consecutiveMaxIndicesSeen) {
		printf("File ends with %d consecutive MaxIndices (ie., null entries)\n", consecutiveMaxIndicesSeen);
	}

	printf("%d Total valid references\n",validReferences);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\tools\sissetup\sissetup.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   sisSetup.c

Abstract:

   This module is used to install the SIS and GROVELER services.


Environment:

   User Mode Only

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <winioctl.h>

#include <aclapi.h>
//#include <winldap.h>


//
//  Global variables
//

SC_HANDLE scm = NULL;
BOOL MakeCommonStoreDirHidden = TRUE;
BOOL UseSystemACL = TRUE;
BOOL IsWhistlerOrLater = FALSE;
BOOL ForceGrovelAllPaths = FALSE;
BOOL ForceGrovelRISOnly = FALSE;
BOOL SetRISPath = FALSE;

const wchar_t CommonStoreDirName[] = L"\\SIS Common Store";
const wchar_t MaxIndexName[] = L"\\MaxIndex";
const wchar_t BackupExludeList[] = L"\\SIS Common Store\\*.* /s" L"\000";
const wchar_t GrovelerParameters[] = L"software\\Microsoft\\Windows NT\\CurrentVersion\\Groveler\\Parameters";
const wchar_t GrovelAllPaths[] = L"GrovelAllPaths";
const wchar_t OneStr[] = L"1";
const wchar_t ZeroStr[] = L"0";

const wchar_t TftpdServiceParameters[] = L"system\\CurrentControlSet\\Services\\tftpd\\parameters";
const wchar_t DirectoryStr[] = L"directory";

const wchar_t SISService[] = L"system\\CurrentControlSet\\Services\\SIS";
const wchar_t GrovelerService[] = L"system\\CurrentControlSet\\Services\\Groveler";

const wchar_t ImagePathStr[] = L"ImagePath";
const wchar_t StartStr[] = L"Start";
const wchar_t DisplayNameStr[] = L"DisplayName";
const wchar_t TypeStr[] = L"Type";

wchar_t RISPath[128] = {0};		//Holds RIS path to set



//
//  Functions
//
                        
VOID
DisplayUsage (
    void
    )

/*++

Routine Description:

   This routine will display an error message based off of the Win32 error
   code that is passed in. This allows the user to see an understandable
   error message instead of just the code.

Arguments:

   None

Return Value:

   None.

--*/

{
    printf( "\nUsage:  sisSetup [/?] [/h] [/s] [/i] [/u] [/n] [/a] [/g] [/r] [/p path] [drive: [...]]\n"
            "  /? /h    Display usage information.\n"
            "  /s       Display current groveler state (default if no operation specified).\n"
            "\n"
            "  /i       Create the SIS and GROVELER services. (if not already defined)\n"
            "  /u       Delete the SIS and GROVELER services.\n"
            "  /g       Have the groveler monitor all directories on all configured volumes.\n"
            "  /r       Have the groveler monitor only RIS directories on the RIS volume.\n"
            "  /p path  Specify the RIS volume and path to monitor.\n"
            "\n"
            "  /n       Do NOT make the \"SIS Common Store\" directory \"Hidden|System\".\n"
            "           Will unhide the directory if it already exists and is hidden.\n"
            "  /a       Do NOT set SYSTEM ACL on \"SIS Common Store \" directory, instead\n"
            "           set ADMINISTRATORS group ACL.\n"
            "           This will change the ACL setting for existing directories.\n"
            "\n"
            " drive:    A list of NTFS volumes you would like initialized for SIS.\n"
            "           If no drives are specified, only the services will be installed.\n"
            "           This will only initialize local hard drives with NTFS on them.\n"
            "           The BOOT volume is never initialized.\n"
            "\n"
            "           You must reboot for the changes to take affect.\n"
            "\n"
            "Example:   sisSetup /i /g f: g:\n"
            "           This will create the SIS and GROVELER services and initialize the\n"
            "           \"SIS Common Store\" directory on the specified volumes.\n"
          );
}


void
DisplayError (
   DWORD Code,
   LPSTR Msg,
   ...
   )

/*++

Routine Description:

    This routine will display an error message based off of the Win32 error
    code that is passed in. This allows the user to see an understandable
    error message instead of just the code.

Arguments:

    Msg - The error message to display       
    Code - The error code to be translated.

Return Value:

    None.

--*/

{
    wchar_t errmsg[128];
    DWORD count;
    va_list ap;

    //printf("\n");
    va_start( ap, Msg );
    vprintf( Msg, ap );
    va_end( ap );

    //
    // Translate the Win32 error code into a useful message.
    //

    count = FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    Code,
                    0,
                    errmsg,
                    sizeof(errmsg),
                    NULL );

    //
    // Make sure that the message could be translated.
    //

    if (count == 0) {

        printf( "(%d) Could not translate Error\n", Code );

    } else {

        //
        // Display the translated error.
        //

        printf( "(%d) %S", Code, errmsg );
    }
}


DWORD
SetRegistryValue(
    IN LPCTSTR RegistryKey,
    IN LPCTSTR DataName,
    IN DWORD DataType,
    IN CONST void *Data,
    IN DWORD DataSize
    )
{
    HKEY regHandle = NULL;
    DWORD status;

    //
    // Get a handle to the services registry key.
    //

    status = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                             RegistryKey,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &regHandle,
                             NULL );

    if (ERROR_SUCCESS != status) {

        DisplayError( status,
                      "\nError creating registry key \"%S\", ",
                      RegistryKey );

        return status;
    }

    try {
        //
        //  Set the data value
        //

        status = RegSetValueEx( regHandle,
                                DataName,
                                0,
                                DataType,
                                Data,
                                DataSize );

        if (ERROR_SUCCESS != status) {

            DisplayError( status,
                          "\nError setting registry data in the key \"%S\" and data \"%S\"",
                          RegistryKey,
                          DataName );
            leave;
        }

    } finally {

        //
        //  Close the registry key
        //

        RegCloseKey( regHandle );
    }

    return status;
}


DWORD
GetRegistryValue(
    IN LPCTSTR RegistryKey,
    IN LPCTSTR DataName,
    OUT DWORD *RetDataType,
    OUT void *Data,
	IN  CONST DWORD DataSize,
    OUT DWORD *RetSize
    )
{
    HKEY regHandle = NULL;
    DWORD status;

    //
    // Get a handle to the services registry key.
    //

    status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           RegistryKey,
                           0,
                           KEY_ALL_ACCESS,
                           &regHandle );

    if (ERROR_SUCCESS != status) {

//        DisplayError( status,
//                      "\nError opening registry key \"%S\", ",
//                      RegistryKey );
        return status;
    }

    try {

        //
        //  Set the data value
        //

	    *RetSize = DataSize;

        status = RegQueryValueEx( regHandle,
                                  DataName,
                                  0,
                                  RetDataType,
                                  Data,
                                  RetSize );

        if (ERROR_SUCCESS != status) {

    //        DisplayError( status,
    //                      "\nError getting registry data in the key \"%S\" and data \"%S\"",
    //                      RegistryKey,
    //                      DataName );
            leave;
        }

    } finally {

        //
        //  Close the registry key
        //

        RegCloseKey( regHandle );
    }

    return status;
}


DWORD
SetupService(
    LPCTSTR Name,
    LPCTSTR DisplayName,
    LPCTSTR DriverPath,
    LPCTSTR LoadOrderGroup,
    LPCTSTR Dependencies,
    DWORD ServiceType,
    DWORD StartType,
    LPCTSTR RegistryKey,
    LPCTSTR RegDescription
    )

/*++

Routine Description:

   This routine will initialize the given service.

Arguments:


Return Value:

   Status of operation

--*/

{    
    DWORD status;
    ULONG tag;
    SC_HANDLE srvHandle = NULL;
    HKEY regHandle = NULL;
    static CONST wchar_t DescriptionRegValue[] = L"Description";

    try {

        //
        // Create the given service
        //

        srvHandle = CreateService(
                        scm,
                        Name,
                        DisplayName,
                        STANDARD_RIGHTS_REQUIRED | SERVICE_START,
                        ServiceType,
                        StartType,
                        SERVICE_ERROR_NORMAL,
                        DriverPath,
                        LoadOrderGroup,
                        ((ServiceType == SERVICE_FILE_SYSTEM_DRIVER) ? &tag : NULL),
                        Dependencies,
                        NULL,
                        NULL );

        if ( !srvHandle ) {

            status = GetLastError();
            if (ERROR_SERVICE_EXISTS != status) {

                DisplayError( status,
                              "Creating the service \"%S\", ",
                              Name);
                return status;
            }
            printf( "The \"%S\" service already exists.\n", Name );
            return ERROR_SUCCESS;
        }

        //
        // Get a handle to the services registry key.
        //

        status = RegOpenKeyEx (
                            HKEY_LOCAL_MACHINE,
                            RegistryKey,
                            0,
                            KEY_ALL_ACCESS,
                            &regHandle);

        if (ERROR_SUCCESS != status) {

            DisplayError( status,
                          "Opening the registry key \"%S\", ",
                          RegistryKey);
            return status;
        }

        //
        //  Add the DESCRIPTION to the service
        //

        status = RegSetValueEx(
                            regHandle,
                            DescriptionRegValue,
                            0,
                            REG_SZ,
                            (CONST BYTE *)RegDescription,
                            (wcslen(RegDescription) * sizeof(wchar_t)));

        if (ERROR_SUCCESS != status) {
            DisplayError( status,
                          "Adding \"%S\" value to the \"%S\" registry key, ",
                          DescriptionRegValue,
                          RegistryKey);
            return status;
        }

    } finally {

        if (regHandle) {

            RegCloseKey( regHandle );
        }

        if (srvHandle)  {

            CloseServiceHandle( srvHandle );
        }
    }

    printf( "The \"%S\" service was successfully added.\n", Name );
    return ERROR_SUCCESS;
}



DWORD
CreateServices (
    void
    )

/*++

Routine Description:

   This will create the SIS and GROVELER service.

Arguments:

   None

Return Value:

   None.

--*/

{
    DWORD status;

    //
    //  Create SIS service
    //

    status = SetupService(
                    L"Sis",
                    L"Single Instance Storage",
                    L"%SystemRoot%\\system32\\drivers\\sis.sys",
                    (IsWhistlerOrLater) ? L"FSFilter System" :
                                          L"filter",
                    NULL,
                    SERVICE_FILE_SYSTEM_DRIVER,
                    SERVICE_BOOT_START,
                    L"SYSTEM\\CurrentControlSet\\Services\\Sis",
                    L"A File System Filter that manages duplicate copies of files on hard-disk volumes.  It copies one instance of the duplicate file into a central directory, and the duplicates are replaced with a link to the central copy in order to improve disk usage.  This service can not be stopped.  If this service is disabled, all linked files will no longer be accessible.  If the central directory is deleted, all linked files will become permanently inaccessible." );

    if (ERROR_SUCCESS != status) {

        return status;
    }


    //
    //  Create GROVELER service
    //

    status = SetupService(
                    L"Groveler",
                    L"Single Instance Storage Groveler",
                    L"%SystemRoot%\\system32\\grovel.exe",
                    NULL,
                    L"SIS\0",
                    SERVICE_WIN32_OWN_PROCESS,
                    SERVICE_AUTO_START,
                    L"SYSTEM\\CurrentControlSet\\Services\\Groveler",
                    L"Scans the hard-disk volumes on a Remote Installation Services (RIS) server for duplicate copies of files.  If found, one instance of the duplicate file is stored in a central directory, and the duplicates are replaced with a link to the central copy in order to improve disk usage. If this service is stopped, files will no longer be automatically linked in this manner, but the existing linked files will still be accessible." );

    if (ERROR_SUCCESS != status) {

        return status;
    }

    return ERROR_SUCCESS;
}


DWORD
RemoveService(
    LPCTSTR Name
    )

/*++

Routine Description:

   This will delete the given service.  This will make sure the given
   service is stopped first.

Arguments:

    None

Return Value:

   Status of operation

--*/

{
    DWORD status;
    SC_HANDLE srvHandle = NULL;
    BOOL state;
    SERVICE_STATUS servStatus;
    int retryLimit;

#   define RETRY_TIMEOUT    500             //1/2 second
#   define RETRY_COUNT      (6*2)           //try for a few seconds


    try {

        //
        //  Open the service
        //

        srvHandle = OpenService(
                        scm,
                        Name,
                        SERVICE_ALL_ACCESS );

        if ( !srvHandle )  {

            status = GetLastError();
            if (ERROR_SERVICE_DOES_NOT_EXIST != status)  {

                DisplayError( status,
                              "Opening the service \"%S\", ",
                              Name);
                return status;
            }

            printf( "The \"%S\" service does not exist.\n", Name );
            return ERROR_SUCCESS;
        }

        //
        //  Stop the service
        //

        state = ControlService(
                        srvHandle,
                        SERVICE_CONTROL_STOP,
                        &servStatus );

        if ( !state )  {

            status = GetLastError();
            if ((ERROR_SERVICE_NOT_ACTIVE != status) &&
                (ERROR_INVALID_SERVICE_CONTROL != status) )  {

                DisplayError( status,
                              "Stoping the \"%S\" service, ",
                              Name);
                return status;
            }
        }

        //
        //  Wait a few seconds for the service to stop.
        //

        for (retryLimit=0;
             (SERVICE_STOPPED != servStatus.dwCurrentState);
             )  {

            Sleep( RETRY_TIMEOUT );   //wait for 1/4 second

            state = QueryServiceStatus(
                            srvHandle,
                            &servStatus );

            if ( !state )  {
                    
                status = GetLastError();
                DisplayError( status,
                              "Querrying service status for the \"%S\" service, ",
                              Name);
                return status;
            }

            if (++retryLimit >= RETRY_COUNT)  {

                printf("The \"%S\" service could not be stopped.\n",Name);
                break;
            }
        }

        //
        //  Delete the service
        //

        state = DeleteService( srvHandle );

        if ( !state )  {

            status = GetLastError();
            DisplayError( status,
                          "Deleting the \"%S\" service, ",
                          Name);
            return status;
        }

    } finally {

        if (srvHandle)  {

            CloseServiceHandle( srvHandle );
        }
    }

    printf( "The \"%S\" service was successfully deleted.\n", Name );
    return ERROR_SUCCESS;
}


DWORD
DeleteServices(
    void
    )

/*++

Routine Description:

   This will delete the SIS and GROVELER services from the system

Arguments:

    None

Return Value:

   Status of operation

--*/

{
    DWORD status;


    status = RemoveService( L"Groveler" );

    if (ERROR_SUCCESS != status) {

        return status;
    }

    status = RemoveService( L"Sis" );

    if (ERROR_SUCCESS != status) {

        return status;
    }

    return ERROR_SUCCESS;
}


DWORD
InitVolume(
    wchar_t *DevName
    )
/*++

Routine Description:

    This routine will initialize SIS on the given volume.  This will verify
    that the volume is an NTFS volume and that it is not the BOOT volume.

Arguments:

    DevName - The name of the volume to init

Return Value:

   Status of operation

--*/
{
    HANDLE hVolume;
    HANDLE hCSDir;
    HANDLE hMaxIndex = INVALID_HANDLE_VALUE;
    DWORD status;
    DWORD transferCount;
    LONGLONG maxIndex;

    PSID pSid = NULL;
    PACL pAcl = NULL;
    EXPLICIT_ACCESS ExplicitEntries;
    SECURITY_ATTRIBUTES sa;
    SID_IDENTIFIER_AUTHORITY ntSidAuthority = SECURITY_NT_AUTHORITY;
    SECURITY_DESCRIPTOR SecDescriptor;

    BOOL state;
    USHORT compressionMode = COMPRESSION_FORMAT_DEFAULT;
    wchar_t name[MAX_PATH];
    wchar_t dirName[MAX_PATH];
    wchar_t fileSystemType[MAX_PATH];

    try {

        //
        //  Get the "SystemDrive" environemnt variable
        //

        status = GetEnvironmentVariable(
                        L"SystemDrive",
                        name,
                        (sizeof(name) / sizeof(wchar_t)));

        if (status <= 0)  {
            printf( "Unable to retrieve the environment variable \"SystemDrive\"." );
            return ERROR_INVALID_FUNCTION;
        }

        //
        //  See if they have requested the SYSTEM drive.  If so return an error
        //

        if (_wcsicmp(name,DevName) == 0)  {

            printf( "The volume \"%s\" is the BOOT volume, SIS not initialized on it.\n", DevName );
            return ERROR_SUCCESS;
        }

        //
        //  Get the TYPE of the drive, see if it is a local HARDDISK (fixed
        //  or removable).  If not return now.
        //

        wsprintf(name,L"%s\\",DevName);      //generate ROOTDIR name

        status = GetDriveType( name );

        if ((status == DRIVE_UNKNOWN) ||
            (status == DRIVE_NO_ROOT_DIR)) {

            printf("The volume \"%s\" does not exist.\n",DevName);
            return ERROR_SUCCESS;
        } else if ((status != DRIVE_FIXED) && 
            (status != DRIVE_REMOVABLE))  {

            printf("The volume \"%s\" is not a local hard drive, SIS not initialized on it.\n",DevName);
            return ERROR_SUCCESS;
        }

        //
        //  Get the type of the file system on the volume.  If not NTFS
        //  return now.
        //

        state = GetVolumeInformation(
                        name,
                        NULL,
                        0,
                        NULL,
                        NULL,
                        NULL,
                        fileSystemType,
                        sizeof(fileSystemType));

        if ( !state )  {

            status = GetLastError();
            if (ERROR_PATH_NOT_FOUND != status)  {
                DisplayError( status,
                              "Opening volume \"%s\", ",
                              DevName );
                return status;
            }
            printf("The volume \"%s\" does not exist.\n",DevName);
            return ERROR_SUCCESS;
        }

        if (_wcsnicmp(fileSystemType, L"NTFS", 4 ) != 0)  {

            printf("The volume \"%s\" is not an NTFS volume, SIS not initialized on it.\n",DevName);
            return ERROR_SUCCESS;
        }

        //
        //  Create the Common Store Directory.  Keep going if the directory
        //  already exits.
        //

        wsprintf( dirName, L"%s%s", DevName, CommonStoreDirName );

        state = CreateDirectory(dirName, NULL);

        if ( !state )  {

            status = GetLastError();
            if (ERROR_ALREADY_EXISTS != status)  {

                DisplayError( status,
                              "Creating directory \"%S\", ",
                              dirName);

                return status;
            }
        }

        //
        //  Mark the directory as SYSTEM and HIDDEN if requested.
        //

        state = SetFileAttributes( dirName, 
                    ((MakeCommonStoreDirHidden) ? 
                            FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM :
                            FILE_ATTRIBUTE_NORMAL) );
        if ( !state ) {

            status = GetLastError();
            DisplayError(
                    status,
                    "Setting attributes on directory \"%S\", ",
                    dirName);
        }

        //
        //  Set compression on the "SIS Common Store" directory
        //  Don't do it for now.
        //

//      //
//      // Open the directory
//      //
//
//      hCSDir = CreateFile(
//                  dirName,
//                  GENERIC_READ|GENERIC_WRITE,
//                  FILE_SHARE_READ | FILE_SHARE_WRITE,
//                  NULL,
//                  OPEN_EXISTING,
//                  FILE_FLAG_BACKUP_SEMANTICS,
//                  NULL);
//
//      if (INVALID_HANDLE_VALUE == hCSDir) {
//
//          DisplayError(
//                  status,
//                  "Opening directory \"%S\" to update compression, ",
//                  dirName);
//
//      } else {
//
//          //
//          //  Enable compression
//          //
//
//          state = DeviceIoControl(
//                       hCSDir,
//                       FSCTL_SET_COMPRESSION,
//                       &compressionMode,
//                       sizeof(compressionMode),
//                       NULL,
//                       0,
//                       &transferCount,
//                       NULL);
//
//          if ( !state )  {
//
//              status = GetLastError();
//              DisplayError(
//                      status,
//                      "Enabling compression on \"%S\", ",
//                      dirName);
//          }
//
//          //
//          //  Close directory handle
//          //
//
//          CloseHandle( hCSDir );
//      }

        //
        // Create the MaxIndex file
        //

        wsprintf( name, L"%s%s", dirName, MaxIndexName );

        hMaxIndex = CreateFile(
                        name,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        if (INVALID_HANDLE_VALUE == hMaxIndex) {

            status = GetLastError();
            if (ERROR_FILE_EXISTS != status) {

                DisplayError( status,
                              "Creating file \"%S\", ",
                              name);
                return status;
            }

        } else {

            //
            //  The MaxIndex file did not exist, init it.
            //

            maxIndex = 1;

            state = WriteFile(
                          hMaxIndex,
                          &maxIndex,
                          sizeof(maxIndex),
                          &transferCount,
                          NULL);

            if ( !state || (transferCount < sizeof(maxIndex)) ) {

                status = GetLastError();
                DisplayError( status,
                              "Writing file \"%S\", ",
                              name);
                return status;
            }

            //
            //  Close the file
            //

            CloseHandle( hMaxIndex );
            hMaxIndex = INVALID_HANDLE_VALUE;
        }


        //
        //  Set security information on the common store directory
        //

        //
        // build AccessEntry structure
        //

        ZeroMemory( &ExplicitEntries, sizeof(ExplicitEntries) );

        if (UseSystemACL) {

            state = AllocateAndInitializeSid(
                        &ntSidAuthority,
                        1,
                        SECURITY_LOCAL_SYSTEM_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &pSid );
        } else {

            state = AllocateAndInitializeSid(
                        &ntSidAuthority,
                        2,
                        SECURITY_BUILTIN_DOMAIN_RID,
                        DOMAIN_ALIAS_RID_ADMINS,
                        0, 0, 0, 0, 0, 0,
                        &pSid );
        }

        if ( !state || (pSid == NULL) ) {

            status = GetLastError();
            DisplayError( status,
                          "Creating SID, ");
            return status;
        }

        BuildTrusteeWithSid( &ExplicitEntries.Trustee, pSid );
        ExplicitEntries.grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitEntries.grfAccessMode = SET_ACCESS;
        ExplicitEntries.grfAccessPermissions = FILE_ALL_ACCESS;

        //
        // Set the Acl with the ExplicitEntry rights
        //

        status = SetEntriesInAcl( 1,
                                  &ExplicitEntries,
                                  NULL,
                                  &pAcl );

        if ( status != ERROR_SUCCESS ) {

            DisplayError( status, "Creating ACL, ");
            return status;
        }

        //
        // Create the Security Descriptor
        //

        InitializeSecurityDescriptor( &SecDescriptor, SECURITY_DESCRIPTOR_REVISION );

        state = SetSecurityDescriptorDacl( &SecDescriptor, TRUE, pAcl, FALSE );

        if ( !state ) {
            status = GetLastError();
            DisplayError( status, "Setting Security DACL, ");            

            return status;
        }


        //
        //  SET security on the Directory
        //

        state = SetFileSecurity(dirName,
                                DACL_SECURITY_INFORMATION,
                                &SecDescriptor);

        if ( !state )  {
            status = GetLastError();
            DisplayError( status, "Setting File Security, ");            

            return status;
        }

    } finally {

        //
        //  Cleanup
        //

        if (hMaxIndex != INVALID_HANDLE_VALUE)  {

            CloseHandle( hMaxIndex );
        }

        if ( pSid ) {

            FreeSid( pSid );
        }

        if ( pAcl ) {

            LocalFree( pAcl );
        }
    }

    printf( "The volume \"%s\" was successfully initialized.\n", DevName );
    return ERROR_SUCCESS;
}


void
SetRegistryValues()
{
    DWORD status;

    status = SetRegistryValue(
                    L"SYSTEM\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup",
                    L"Single Instance Storage",
                    REG_MULTI_SZ,
                    BackupExludeList,
                    sizeof(BackupExludeList) );

    //
    //  Set the apropriate "GrovelAllPaths" state
    //

    if (ForceGrovelAllPaths) {

        status = SetRegistryValue(
                        GrovelerParameters,
                        GrovelAllPaths,
                        REG_SZ,
                        OneStr,
                        sizeof(OneStr) );

    } else if (ForceGrovelRISOnly) {

        status = SetRegistryValue(
                        GrovelerParameters,
                        GrovelAllPaths,
                        REG_SZ,
                        ZeroStr,
                        sizeof(ZeroStr) );
    }


    if (SetRISPath) {

        status = SetRegistryValue(
                        TftpdServiceParameters,
                        DirectoryStr,
                        REG_SZ,
                        RISPath,
                        (wcslen(RISPath) * sizeof(wchar_t)) );
    } 
}


void
DisplayGrovelerRISState()
{
    DWORD status;
    DWORD dataType;
    DWORD dataSize;
    wchar_t data[128];
    wchar_t *endptr;
    BOOL doAllPaths = FALSE;
	BOOL hasPath = FALSE;
    BOOL sisConfigured = FALSE;
    BOOL grovelerConfigured = FALSE;

    printf("\n");

    //
    //  See if SIS service is configured
    //

    try {

		status = GetRegistryValue( SISService,
								   ImagePathStr,
								   &dataType,
								   data,
								   sizeof(data),
								   &dataSize );

        if (ERROR_SUCCESS != status) {

            leave;
        }

		status = GetRegistryValue( SISService,
								   StartStr,
								   &dataType,
								   data,
								   sizeof(data),
								   &dataSize );

        if (ERROR_SUCCESS != status) {

            leave;
        }

		status = GetRegistryValue( SISService,
								   DisplayNameStr,
								   &dataType,
								   data,
								   sizeof(data),
								   &dataSize );

        if (ERROR_SUCCESS != status) {

            leave;
        }

		status = GetRegistryValue( SISService,
								   TypeStr,
								   &dataType,
								   data,
								   sizeof(data),
								   &dataSize );

        if (ERROR_SUCCESS != status) {

            leave;
        }

        sisConfigured = TRUE;

    } finally {

        printf( (sisConfigured) ? 
                "The SIS Service is properly configured\n" :
                "The SIS Service is NOT properly configured\n" );
    }

    //
    //  See if GROVELER service is configured
    //

    try {

		status = GetRegistryValue( GrovelerService,
								   ImagePathStr,
								   &dataType,
								   data,
								   sizeof(data),
								   &dataSize );

        if (ERROR_SUCCESS != status) {

            leave;
        }

		status = GetRegistryValue( GrovelerService,
								   StartStr,
								   &dataType,
								   data,
								   sizeof(data),
								   &dataSize );

        if (ERROR_SUCCESS != status) {

            leave;
        }

		status = GetRegistryValue( GrovelerService,
								   DisplayNameStr,
								   &dataType,
								   data,
								   sizeof(data),
								   &dataSize );

        if (ERROR_SUCCESS != status) {

            leave;
        }

		status = GetRegistryValue( GrovelerService,
								   TypeStr,
								   &dataType,
								   data,
								   sizeof(data),
								   &dataSize );

        if (ERROR_SUCCESS != status) {

            leave;
        }

        grovelerConfigured = TRUE;

    } finally {

        printf( (grovelerConfigured) ? 
                "The GROVELER Service is properly configured\n" :
                "The GROVELER Service is NOT properly configured\n" );
    }

	//
	//	Get GrovelAllPaths value
	//


    try {

		status = GetRegistryValue( GrovelerParameters,
								   GrovelAllPaths,
								   &dataType,
								   data,
								   sizeof(data),
								   &dataSize );

        if (ERROR_SUCCESS != status) {

            leave;
        }

        //
        //  See if correct type of data, if not, assume NOT doing all paths
        //

        if (dataType != REG_SZ) {

            leave;
        }

        //
        //  Set appropriate state based on value

        doAllPaths = (wcstol( data, &endptr, 10 ) != 0);

    } finally {

	    printf( (doAllPaths) ?
	            "The \"Groveler\" will monitor all directories on all SIS configured volumes.\n" :
	            "The \"Groveler\" will only monitor the RIS directory tree on the RIS volume.\n" );
    }

	//
	//	Get RIS Path value
	//

	try {

		//
		//	Get the path to grovel
		//

		status = GetRegistryValue( TftpdServiceParameters,
								   DirectoryStr,
								   &dataType,
								   data,
								   sizeof(data),
								   &dataSize );

        if (ERROR_SUCCESS != status) {

            leave;
        }

        //
        //  See if correct type of data, if not, assume NOT doing all paths
        //

        if (dataType != REG_SZ) {

            leave;
        }

		if (dataSize > 0) {

			hasPath = TRUE;
		}


	} finally {

		printf( "The RIS volume and directory to monitor is: \"%S\"\n",
				(hasPath) ? data : L"<Unknown>" );
	}


    //
    //  Display correct message
    //

}


void
SetupOsVersion(
    void
    )
{
    OSVERSIONINFOEX versionInfo;
    ULONGLONG conditionMask = 0;


    versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    versionInfo.dwMajorVersion = 5;
    versionInfo.dwMinorVersion = 1; //testing to see if Whistler or later

    VER_SET_CONDITION( conditionMask, VER_MAJORVERSION, VER_GREATER_EQUAL );
    VER_SET_CONDITION( conditionMask, VER_MINORVERSION, VER_GREATER_EQUAL );


    if (VerifyVersionInfo( &versionInfo,
                           (VER_MAJORVERSION | VER_MINORVERSION),
                           conditionMask ))
    {
        printf("Running on Windows XP or later\n");
        IsWhistlerOrLater = TRUE;
    }
}


//
//  Main FUNCTION
//

void __cdecl 
wmain(
   int argc,
   wchar_t *argv[])

/*++

Routine Description:

   This is the program entry point and main processing routine for the
   installation console mode application. 

Arguments:

   argc - The count of arguments passed into the command line.
   argv - Array of arguments passed into the command line.

Return Value:

   None.

--*/

{
    wchar_t *param;
#       define OP_UNKNOWN   0
#       define OP_CREATE    1
#       define OP_DELETE    2
    int operation = OP_UNKNOWN;
    int servicesState = OP_UNKNOWN;
    int i;
    DWORD status;
    BOOL getRISPath = FALSE;
    
    //
    //  Handle different OS versions
    //
    
    SetupOsVersion();
    
    //
    // Obtain a handle to the service control manager requesting all access
    //
    
    scm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    
    //
    // Verify that a handle could be obtained.
    //
    
    if (!scm) {
                                 
      //
      // A handle could not be obtained, report error.
      //
    
      DisplayError(GetLastError(),
                   "The Service Control Manager could not be opened, ");
      return;
    }

    try {

        //
        //  Parase parameters then perform the operations that we can
        //

        for (i=1; i < argc; i++)  {

            param = argv[i];

            //
            //  See if a SWITCH
            //

            if ((param[0] == '-') || (param[0] == '/')) {

                //
                //  We have a switch header, make sure it is 1 character long
                //

                if (param[2] != 0) {

                    DisplayError(ERROR_INVALID_PARAMETER,
                                 "Parsing \"%S\", ",
                                 param);
                    DisplayUsage();
                    leave;
                }

                //
                //  Figure out the switch
                //

                switch (param[1]) {

                    case L'?':
                    case L'h':
                    case L'H':
                        DisplayUsage();
                        leave;

                    case L'i':
                    case L'I':
                        operation = OP_CREATE;
                        break;

                    case L'u':
                    case L'U':
                        operation = OP_DELETE;
                        break;

                    case L'n':
                    case L'N':
                        MakeCommonStoreDirHidden = FALSE;
                        break;

                    case L'a':
                    case L'A':
                        UseSystemACL = FALSE;
                        break;

                    case L'g':
                    case L'G':
                        ForceGrovelAllPaths = TRUE;
                        break;

                    case L'r':
                    case L'R':
                        ForceGrovelRISOnly = TRUE;
                        break;

                    case L'p':
                    case L'P':
                        SetRISPath = TRUE;
                        getRISPath = TRUE;	//the path is the next parameter
                        break;

                    case L's':
                    case L'S':
                        DisplayGrovelerRISState();
                        leave;

                    default:
                        DisplayError( ERROR_INVALID_PARAMETER,
                                      "Parsing \"%S\", ",
                                      param);
                        DisplayUsage();
                        leave;
                }

            } else if (getRISPath) {

                printf("param=\"%S\", #chars=%d\n",param,wcslen(param));

                wcscpy( RISPath, param );
                getRISPath = FALSE;

            } else {

                //
                //  Execute the given operation
                //

                switch (operation) {

                    case OP_CREATE:
                        if (servicesState != OP_CREATE)  {

                            status = CreateServices();
                            if (ERROR_SUCCESS != status) {

                                goto Cleanup;
                            }
                            servicesState = OP_CREATE;
                        }

                        status = InitVolume(param);
                        if (ERROR_SUCCESS != status) {

                            goto Cleanup;
                        }

                        SetRegistryValues();
                        DisplayGrovelerRISState();

                        break;

                    case OP_DELETE:
                        if (servicesState != OP_DELETE) {

                            status = DeleteServices();
                            if (ERROR_SUCCESS != status) {

                                goto Cleanup;
                            }
                            servicesState = OP_DELETE;
                        }
//                      status = CleanupVolume(param);
//                      if (ERROR_SUCCESS != status) {
//
//                          goto Cleanup;
//                      }
                        break;
                }
            }
        }

        if (getRISPath) {
             
            DisplayError( ERROR_INVALID_PARAMETER,
                          "Parsing \"%S\", ",
                          argv[i-1]);
            DisplayUsage();
            leave;
        }

        //
        //  See if any operation was performed.  If not then no drive letter
        //	was specified, so do what ever operation they said without a
        //	drive letter.
        //

        if (servicesState == OP_UNKNOWN)  {

            switch (operation)  {
                case OP_UNKNOWN:
                    SetRegistryValues();
                    DisplayGrovelerRISState();
                    break;

                case OP_CREATE:
                    CreateServices();
                    SetRegistryValues();
                    DisplayGrovelerRISState();
                    break;

                case OP_DELETE:
                    DeleteServices();
                    break;
            }
        }

        Cleanup: ;

    } finally {

        CloseServiceHandle(scm);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\tools\rpget\rpget.c ===
/*++

	Program Description:

        prints out rptag info..

	Modification History:

		09/29/97        anandn          created
        modified from rptag_stress.c code..

--*/


#include "rpget.h"


THREAD CHAR gszLogMsg[LINE_LENGTH];	// log message string, local to thread

USHORT gMaxDataBuffSize = MAXIMUM_REPARSE_DATA_BUFFER_SIZE -
			FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer);


//
// main
//
 
VOID __cdecl main(INT argc, CHAR* argv[]) {

	BOOL fSuccess;

	OPTIONS Options;	// command line options
	

	PBYTE pOutBuff = NULL;

	PUCHAR pDataBuff;
	USHORT usDataBuffSize;

    if (argc<2) {
        printf("Usage: %s filename\n",argv[0]);
        ExitProcess(1);
    }
    
	fSuccess = RPGet( argv[1], &pOutBuff );

	if ( ! fSuccess ) {
        printf("ERROR: RPGet failed\n");
        ExitProcess(1);
    }

	//
	// print out rp buffer
	//

    printf("\n");
    printf("ReparseTag = %Xh\n",  
        (((PREPARSE_DATA_BUFFER) pOutBuff)->ReparseTag));

    printf("ReparseDataLength = %d\n", 
        ((PREPARSE_DATA_BUFFER) pOutBuff)->ReparseDataLength);

    printf("Reserved = %d\n", 
        ((PREPARSE_DATA_BUFFER) pOutBuff)->Reserved);

    printf("Dumping GenericReparseBuffer:\n");

    DumpBuff((PBYTE) (((PREPARSE_DATA_BUFFER) pOutBuff)->GenericReparseBuffer.DataBuffer), 
        (WORD) ((PREPARSE_DATA_BUFFER) pOutBuff)->ReparseDataLength);

}




BOOL
RPGet( CHAR szFileName[], BYTE **ppOutBuff) 
{

	BOOL fSuccess;
	DWORD dwRc = 0;
	DWORD gle;
	DWORD dwOutBuffLen;

	HANDLE hFile;

	__try {


		hFile = RPOpen( szFileName, "rpf" );

        // if open fails..try as directory..

        if (hFile == INVALID_HANDLE_VALUE) {
            hFile = RPOpen( szFileName, "rpd" );
        }

        if (hFile == INVALID_HANDLE_VALUE) {
            printf("error opening %s\n", szFileName);
            return FALSE;
        }
		
		dwOutBuffLen = MAXIMUM_REPARSE_DATA_BUFFER_SIZE;

		*ppOutBuff = (PBYTE) calloc( dwOutBuffLen, 1);

		if (NULL == *ppOutBuff) {
            printf("error callocing OutBuff in RPGet\n");
			return FALSE;
		}


        SetLastError( ERROR_SUCCESS );

		//
		// try the fsctl..
		//
	
		fSuccess = DeviceIoControl( hFile,
			FSCTL_GET_REPARSE_POINT,
			NULL,
			0,
			*ppOutBuff,
			dwOutBuffLen,
			&dwRc,
			NULL);

        printf("dwRc= %ld\n", dwRc);

		if ( ! fSuccess ) {

			gle = GetLastError();

				    printf("ERROR: FSCTL_GET_REPARSE_POINT in RPGet\n");
                    printf("GLE  : %ld\n",GetLastError());
					return FALSE;
		}

		return TRUE;

	} __finally {

	}
}


VOID
DumpBuff( PBYTE pData, WORD wSize )
{

	WORD i=0;
	WORD j=0;
	CHAR szData[LINE_LENGTH];
    WORD NumLines;

    NumLines = wSize/8;
   
    if (NumLines) {
 
	for( i=0; i < NumLines; i++) {

		szData[0] = '\0';

		for( j=0; j<8; j++) {

    		sprintf(szData,TEXT("%s %02X"), szData, *(pData + i*8 + j));

			if (j==3) {
				sprintf(szData, TEXT("%s -"), szData);
			}

		}
		
		sprintf(szData, TEXT("%s  "), szData);

		for( j=0; j<8; j++) {

			if (*(pData + i*8 + j) >  ' ') {
				sprintf(szData,TEXT("%s%c"), szData, *(pData + i*8 + j));
			} else {
				sprintf(szData,TEXT("%s."), szData);
		    }

		}

	  sprintf(gszLogMsg, TEXT("%05d:%s"), i*8, szData);
	  printf("%s\n", gszLogMsg );

      }
    }

    wSize %= 8;

    if (wSize) { 

		szData[0] = '\0';

		for( j=0; j<8; j++) {

			if (j >= wSize) {
				sprintf(szData,TEXT("%s   "), szData);
			} else {
				sprintf(szData,TEXT("%s %02X"), szData, *(pData + i*8 + j));
			}

			if (j==3) {
				sprintf(szData, TEXT("%s -"), szData);
			}

		}
		
		sprintf(szData, TEXT("%s  "), szData);

		for( j=0; j<8; j++) {

			if (j >= wSize) {
				sprintf(szData,TEXT("%s "), szData);
			} else {

				if (*(pData + i*8 + j) >  ' ') {
					sprintf(szData,TEXT("%s%c"), szData, *(pData + i*8 + j));
				} else {
					sprintf(szData,TEXT("%s."), szData);
			    }
			}

		}

	sprintf(gszLogMsg, TEXT("%05d:%s"), i*8, szData);
	printf("%s\n", gszLogMsg );

    }
}




//
//  Simple wrapper for NtCreateFile
//

NTSTATUS
OpenObject (
           WCHAR *pwszFile,
           ULONG CreateOptions,
           ULONG DesiredAccess,
           ULONG ShareAccess,
           ULONG CreateDisposition,
           IO_STATUS_BLOCK *IoStatusBlock,
           HANDLE *ObjectHandle)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING str;

    RtlDosPathNameToNtPathName_U(
                                pwszFile,
                                &str,
                                NULL,
                                NULL);

    InitializeObjectAttributes(
                              &ObjectAttributes,
                              &str,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL);

    Status = NtCreateFile(
                         ObjectHandle,
                         DesiredAccess | SYNCHRONIZE,
                         &ObjectAttributes,
                         IoStatusBlock,
                         NULL,                    // pallocationsize (none!)
                         FILE_ATTRIBUTE_NORMAL,
                         ShareAccess,
                         CreateDisposition,
                         CreateOptions,
                         NULL,                    // EA buffer (none!)
                         0);

    RtlFreeHeap (RtlProcessHeap(), 0, str.Buffer);

    if (!NT_SUCCESS( Status )) {
        printf("NtCreateFile Status %Xh\n", Status);
    }

    return (Status);
}



//----------------------------------------------------------------------------
//
//  RPOpen
//
// This function opens a file / directory in the specified mode 
// and if unsuccessful returns NULL
// INPUT - NAME and OPTION
//
//----------------------------------------------------------------------------


HANDLE
RPOpen (LPSTR szFileName, 
        LPSTR szOption )
{
    DWORD   dwOption = 0;
    DWORD   dwAccess = 0;
    DWORD   dwDisposition = 0;
    HANDLE  hFile;
    NTSTATUS Status ;
    DWORD dwLastErr ;

    IO_STATUS_BLOCK IoStatusBlock ;

    WCHAR   wszFileName[MAX_PATH];


    if (!_stricmp (szOption, "rpf")) {

        dwOption      = FILE_NON_DIRECTORY_FILE |
                        FILE_OPEN_REPARSE_POINT;

        dwAccess      = FILE_READ_DATA |
                        FILE_WRITE_DATA |
                        FILE_WRITE_ATTRIBUTES |
                        FILE_READ_ATTRIBUTES;

        dwDisposition = FILE_OPEN_IF ;

    } else if (!_stricmp (szOption, "rpd")) {

        dwOption      = FILE_OPEN_REPARSE_POINT;


        dwAccess      = FILE_WRITE_DATA ;


        dwDisposition = FILE_OPEN_IF ;

    } else if (!_stricmp (szOption, "d")) {

        dwOption      =  FILE_OPEN_REPARSE_POINT ;

        dwAccess      =  FILE_WRITE_DATA ;

        dwDisposition = FILE_OPEN_IF ;

    } else if (!_stricmp (szOption, "f")) {

        dwOption      = FILE_NON_DIRECTORY_FILE;

        dwAccess      = FILE_READ_DATA |
                        FILE_WRITE_DATA    |
                        FILE_LIST_DIRECTORY |
                        FILE_WRITE_ATTRIBUTES |
                        FILE_READ_ATTRIBUTES;

        dwDisposition = OPEN_ALWAYS ;
    }

    SzToWsz (wszFileName, szFileName);   

    if ( (0 == lstrcmp ( szOption , "f") )  || 
         (0 == lstrcmp ( szOption , "rpf") ) ) {

        hFile = CreateFile ( szFileName ,
                             GENERIC_READ | GENERIC_WRITE   ,
							 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                             NULL ,
                             dwDisposition ,
                             dwOption | FILE_OPEN_NO_RECALL,
                             NULL ) ;


        if ( INVALID_HANDLE_VALUE == hFile ) {
          //  printf( TEXT("ERROR: CreateFile in RPOpen\n") );
		}

    } else {

        Status = OpenObject (wszFileName,
                             dwOption,
                             dwAccess,
                             FILE_SHARE_READ |
                             FILE_SHARE_WRITE |
                             FILE_SHARE_DELETE,
                             dwDisposition,
                             &IoStatusBlock,
                             &hFile);

        if (!NT_SUCCESS (Status)) {
            printf( TEXT("OpenObject in RPOpen\n") );
        }

    }

    return hFile;
}


VOID
SzToWsz (
        OUT WCHAR *Unicode,
        IN char *Ansi
        )
{
    while (*Unicode++ = *Ansi++)
        ;
}



VOID
WszToSz (
        OUT char *Ansi,
        IN WCHAR *Unicode
        )
{
    while (*Ansi++ = (char) *Unicode++)
        ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\tools\volreparsetest\volreparsetest.c ===
#include <stdio.h>
#include <nt.h>


VOID
DisplayUsage(
    wchar_t *ExeName
    )
{
    printf( "This program tests opening a Volume with FILE_OPEN_REPARSE_POINT CreatOptions\n");
    printf( "usage: %S [volume]\n", ExeName );
}


//
//  Main program for TEST program
//

int _cdecl wmain(int argc, wchar_t *argv[])
{
    NTSTATUS status;
    NTSTATUS closeStatus;
    HANDLE volHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING fname;
    wchar_t nameBuf[128];


    if (argc < 2)  {
        DisplayUsage( argv[0] );
        return 1;
    }

    //
    //  Create file normally
    //

    wcscpy(nameBuf,L"\\??\\");
    wcscat(nameBuf,argv[1]);


    fname.Buffer = nameBuf;
    fname.MaximumLength = (USHORT)(sizeof( nameBuf ) * sizeof( wchar_t ));
    fname.Length = (USHORT)(wcslen( nameBuf ) * sizeof( wchar_t ));

    InitializeObjectAttributes(
            &obja,
            &fname,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);


    status = NtCreateFile(
                &volHandle,
                (GENERIC_READ | GENERIC_EXECUTE | SYNCHRONIZE),
                &obja,
                &ioStatusBlock,
                NULL,                                                       //Initial allocation size
                FILE_ATTRIBUTE_NORMAL,                                      //FileAttributes
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,     //ShareMode
                FILE_OPEN,                                                  //CreateDisposition
                (FILE_OPEN_FOR_BACKUP_INTENT     |                          //CreateOptions
                 FILE_SEQUENTIAL_ONLY            |
                 FILE_OPEN_NO_RECALL             |
                 /*FILE_OPEN_REPARSE_POINT       |*/
                 FILE_SYNCHRONOUS_IO_NONALERT),
                NULL,0);                                                    //ea buffer and length


    if (status != 0)  {
        printf("Error opening \"%S\" without FILE_FLAG_OPEN_REPARSE_POINT flag, status=%08x\n",argv[1],status);
        return 0;
    }

    printf("Successfully opened \"%S\" without FILE_FLAG_OPEN_REPARSE_POINT set\n",argv[1]);


    closeStatus = NtClose( volHandle );
    if (closeStatus != 0)  {
        printf("Close failed, status=%08x\n",closeStatus);
    }


    //
    //  Create file with FILE_FLAG_OPEN_REPARSE_POINT flag.
    //

    status = NtCreateFile(
                &volHandle,
                (GENERIC_READ | GENERIC_EXECUTE | SYNCHRONIZE),
                &obja,
                &ioStatusBlock,
                NULL,                                                       //Initial allocation size
                FILE_ATTRIBUTE_NORMAL,                                      //FileAttributes
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,     //ShareMode
                FILE_OPEN,                                                  //CreateDisposition
                (FILE_OPEN_FOR_BACKUP_INTENT     |                          //CreateOptions
                 FILE_SEQUENTIAL_ONLY            |
                 FILE_OPEN_NO_RECALL             |
                 FILE_OPEN_REPARSE_POINT         |
                 FILE_SYNCHRONOUS_IO_NONALERT),
                NULL,0);                                                    //ea buffer and length

    if (status != 0)  {
        printf("Error opening \"%S\" with FILE_FLAG_OPEN_REPARSE_POINT flag, status=%08x\n",argv[1],status);
        return 0;
    }

    printf("Successfully opened \"%S\" with FILE_FLAG_OPEN_REPARSE_POINT set\n",argv[1]);

    closeStatus = NtClose( volHandle );
    if (closeStatus != 0)  {
        printf("Close failed, status=%08x\n",closeStatus);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\smbtrsup\makefile.inc ===
$(O)\smbtrsup.def: smbtrsup.src
    $(TARGET_CPP) /EP $(CDEFINES) smbtrsup.src > $(O)\smbtrsup.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\access.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    access.c

Abstract:

    This module contains routines for interfacing to the security
    system in NT.

--*/

#include "precomp.h"
#include "access.tmh"
#pragma hdrstop
#include <ntlmsp.h>
#include <hmac.h>

#define BugCheckFileId SRV_FILE_ACCESS

#if DBG
ULONG SrvLogonCount = 0;
ULONG SrvNullLogonCount = 0;
#endif


#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~((Pow2)-1)) )

typedef struct _LOGON_INFO {
    PWCH WorkstationName;
    ULONG WorkstationNameLength;
    PWCH DomainName;
    ULONG DomainNameLength;
    PWCH UserName;
    ULONG UserNameLength;
    PCHAR CaseInsensitivePassword;
    ULONG CaseInsensitivePasswordLength;
    PCHAR CaseSensitivePassword;
    ULONG CaseSensitivePasswordLength;
    CHAR EncryptionKey[MSV1_0_CHALLENGE_LENGTH];
    LUID LogonId;
    CtxtHandle  Token;
    USHORT Uid;
    BOOLEAN     HaveHandle;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER LogOffTime;
    USHORT Action;
    BOOLEAN GuestLogon;
    BOOLEAN EncryptedLogon;
    BOOLEAN NtSmbs;
    BOOLEAN IsNullSession;
    BOOLEAN IsAdmin;
    CHAR NtUserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    CHAR LanManSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
} LOGON_INFO, *PLOGON_INFO;

NTSTATUS
DoUserLogon (
    IN PLOGON_INFO LogonInfo,
    IN BOOLEAN SecuritySignatureDesired,
    IN PCONNECTION Connection OPTIONAL,
    IN PSESSION Session
    );

NTSTATUS
AcquireExtensibleSecurityCredentials (
    VOID
    );

NTSTATUS
SrvGetLogonId(
    PCtxtHandle  Handle,
    PLUID LogonId
    );

ULONG SrvHaveCreds = 0;

//
// 24 hours short of never, in case any utc/local conversions are done
//
#define SRV_NEVER_TIME  (0x7FFFFFFFFFFFFFFFI64 - 0xC92A69C000I64)

#define HAVENTLM        1
#define HAVEEXTENDED    2

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvValidateUser )
#pragma alloc_text( PAGE, DoUserLogon )
#pragma alloc_text( PAGE, SrvIsAdmin )
#pragma alloc_text( PAGE, SrvFreeSecurityContexts )
#pragma alloc_text( PAGE, AcquireLMCredentials )
#pragma alloc_text( PAGE, AcquireExtensibleSecurityCredentials )
#pragma alloc_text( PAGE, SrvValidateSecurityBuffer )
#pragma alloc_text( PAGE, SrvGetUserAndDomainName )
#pragma alloc_text( PAGE, SrvReleaseUserAndDomainName )
#pragma alloc_text( PAGE, SrvGetExtensibleSecurityNegotiateBuffer )
#pragma alloc_text( PAGE, SrvGetLogonId )
#pragma alloc_text( PAGE, SrvInitializeSmbSecuritySignature )
#pragma alloc_text( PAGE, SrvAddSecurityCredentials )
#endif


NTSTATUS
SrvValidateUser (
    OUT CtxtHandle *Token,
    IN PSESSION Session OPTIONAL,
    IN PCONNECTION Connection OPTIONAL,
    IN PUNICODE_STRING UserName OPTIONAL,
    IN PCHAR CaseInsensitivePassword,
    IN CLONG CaseInsensitivePasswordLength,
    IN PCHAR CaseSensitivePassword OPTIONAL,
    IN CLONG CaseSensitivePasswordLength,
    IN BOOLEAN SmbSecuritySignatureIfPossible,
    OUT PUSHORT Action  OPTIONAL
    )

/*++

Routine Description:

    Validates a username/password combination by interfacing to the
    security subsystem.

Arguments:

    Session - A pointer to a session block so that this routine can
        insert a user token.

    Connection - A pointer to the connection this user is on.

    UserName - ASCIIZ string corresponding to the user name to validate.

    CaseInsensitivePassword - ASCII (not ASCIIZ) string containing
        password for the user.

    CaseInsensitivePasswordLength - Length of Password, in bytes.
        This includes the null terminator when the password is not
        encrypted.

    CaseSensitivePassword - a mixed case, Unicode version of the password.
        This is only supplied by NT clients; for downlevel clients,
        it will be NULL.

    CaseSensitivePasswordLength - the length of the case-sensitive password.

    Action - This is part of the sessionsetupandx response.

Return Value:

    NTSTATUS from the security system.

--*/

{
    NTSTATUS status;
    LOGON_INFO logonInfo;
    PPAGED_CONNECTION pagedConnection;
    UNICODE_STRING domainName;

    PAGED_CODE( );

    INVALIDATE_SECURITY_HANDLE( *Token );

    RtlZeroMemory( &logonInfo, sizeof( logonInfo ) );

    //
    // Load input parameters for DoUserLogon into the LOGON_INFO struct.
    //
    // If this is the server's initialization attempt at creating a null
    // session, then the Connection and Session pointers will be NULL.
    //

    domainName.Buffer = NULL;
    domainName.Length = 0;

    if ( ARGUMENT_PRESENT(Connection) ) {

        pagedConnection = Connection->PagedConnection;

        logonInfo.WorkstationName =
                    Connection->ClientMachineNameString.Buffer;
        logonInfo.WorkstationNameLength =
                    Connection->ClientMachineNameString.Length;

        RtlCopyMemory(
            logonInfo.EncryptionKey,
            pagedConnection->EncryptionKey,
            MSV1_0_CHALLENGE_LENGTH
            );

        logonInfo.NtSmbs = CLIENT_CAPABLE_OF( NT_SMBS, Connection );

        ASSERT( ARGUMENT_PRESENT(Session) );

        SrvGetUserAndDomainName( Session, NULL, &domainName );

        logonInfo.DomainName = domainName.Buffer;
        logonInfo.DomainNameLength = domainName.Length;

    } else {

        ASSERT( !ARGUMENT_PRESENT(Session) );

        logonInfo.WorkstationName = StrNull;
        logonInfo.DomainName = StrNull;
    }

    if ( ARGUMENT_PRESENT(UserName) ) {
        logonInfo.UserName = UserName->Buffer;
        logonInfo.UserNameLength = UserName->Length;
    } else {
        logonInfo.UserName = StrNull;
    }

    logonInfo.CaseSensitivePassword = CaseSensitivePassword;
    logonInfo.CaseSensitivePasswordLength = CaseSensitivePasswordLength;

    logonInfo.CaseInsensitivePassword = CaseInsensitivePassword;
    logonInfo.CaseInsensitivePasswordLength = CaseInsensitivePasswordLength;

    INVALIDATE_SECURITY_HANDLE( logonInfo.Token );

    if ( ARGUMENT_PRESENT(Action) ) {
        logonInfo.Action = *Action;
    }

    if( ARGUMENT_PRESENT(Session) ) {
        logonInfo.Uid = Session->Uid;
    }

    //
    // Attempt the logon.
    //

    status = DoUserLogon( &logonInfo, SmbSecuritySignatureIfPossible, Connection, Session );

    if( logonInfo.HaveHandle ) {
        *Token = logonInfo.Token;
    }

    if( domainName.Buffer ) {
        SrvReleaseUserAndDomainName( Session, NULL, &domainName );
    }

    if ( NT_SUCCESS(status) ) {

        //
        // The logon succeeded.  Save output data.
        //

        if ( ARGUMENT_PRESENT(Session) ) {

            Session->LogonId = logonInfo.LogonId;

            Session->KickOffTime = logonInfo.KickOffTime;
            Session->LogOffTime = logonInfo.LogOffTime;

            Session->GuestLogon = logonInfo.GuestLogon;
            Session->EncryptedLogon = logonInfo.EncryptedLogon;
            Session->IsNullSession = logonInfo.IsNullSession;
            Session->IsAdmin = logonInfo.IsAdmin;

            RtlCopyMemory(
                Session->NtUserSessionKey,
                logonInfo.NtUserSessionKey,
                MSV1_0_USER_SESSION_KEY_LENGTH
                );
            RtlCopyMemory(
                Session->LanManSessionKey,
                logonInfo.LanManSessionKey,
                MSV1_0_LANMAN_SESSION_KEY_LENGTH
                );

            SET_BLOCK_STATE( Session, BlockStateActive );
        }

        if ( ARGUMENT_PRESENT(Action) ) {
            *Action = logonInfo.Action;
            if( logonInfo.GuestLogon ) {
                *Action |= SMB_SETUP_GUEST;
            }
        }
    }

    return status;

} // SrvValidateUser


NTSTATUS
DoUserLogon (
    IN PLOGON_INFO LogonInfo,
    IN BOOLEAN SecuritySignatureDesired,
    IN PCONNECTION Connection OPTIONAL,
    IN OPTIONAL PSESSION Session
    )

/*++

Routine Description:

    Validates a username/password combination by interfacing to the
    security subsystem.

Arguments:

    LogonInfo - Pointer to a block containing in/out information about
        the logon.

Return Value:

    NTSTATUS from the security system.

--*/

{
    NTSTATUS status, subStatus;
    ULONG actualUserInfoBufferLength;
    ULONG oldSessionCount;
    LUID LogonId;
    ULONG Catts = 0;
    LARGE_INTEGER Expiry;
    ULONG BufferOffset;
    SecBufferDesc InputToken;
    SecBuffer InputBuffers[3];
    SecBufferDesc OutputToken;
    SecBuffer OutputBuffer;
    PNTLM_AUTHENTICATE_MESSAGE NtlmInToken = NULL;
    PAUTHENTICATE_MESSAGE InToken = NULL;
    PNTLM_ACCEPT_RESPONSE OutToken = NULL;
    ULONG NtlmInTokenSize;
    ULONG InTokenSize;
    ULONG OutTokenSize;
    ULONG_PTR AllocateSize;

    ULONG profileBufferLength;

    PAGED_CODE( );

    LogonInfo->IsNullSession = FALSE;
    LogonInfo->IsAdmin = FALSE;

#if DBG
    SrvLogonCount++;
#endif

    //
    // If this is a null session request, use the cached null session
    // token, which was created during server startup ( if we got one! )
    //

    if ( (LogonInfo->UserNameLength == 0) &&
         (LogonInfo->CaseSensitivePasswordLength == 0) &&
         ( (LogonInfo->CaseInsensitivePasswordLength == 0) ||
           ( (LogonInfo->CaseInsensitivePasswordLength == 1) &&
             (*LogonInfo->CaseInsensitivePassword == '\0') ) ) ) {

        if( CONTEXT_NULL( SrvNullSessionToken ) ) {

            if( SrvFspActive ) {
                return STATUS_ACCESS_DENIED;
            }

        } else {

            LogonInfo->IsNullSession = TRUE;

#if DBG
            SrvNullLogonCount++;
#endif

            LogonInfo->HaveHandle = TRUE;
            LogonInfo->Token = SrvNullSessionToken;

            LogonInfo->KickOffTime.QuadPart = 0x7FFFFFFFFFFFFFFF;
            LogonInfo->LogOffTime.QuadPart = 0x7FFFFFFFFFFFFFFF;

            LogonInfo->GuestLogon = FALSE;
            LogonInfo->EncryptedLogon = FALSE;

            return STATUS_SUCCESS;
        }
    }

    //
    // First make sure we have a credential handle
    //

    if ((SrvHaveCreds & HAVENTLM) == 0) {

        status = AcquireLMCredentials();

        if (!NT_SUCCESS(status)) {
            goto error_exit;
        }
    }

    //
    // Figure out how big a buffer we need.  We put all the messages
    // in one buffer for efficiency's sake.
    //

    NtlmInTokenSize = sizeof(NTLM_AUTHENTICATE_MESSAGE);
    NtlmInTokenSize = (NtlmInTokenSize + 3) & 0xfffffffc;

    InTokenSize = sizeof(AUTHENTICATE_MESSAGE) +
            LogonInfo->UserNameLength +
            LogonInfo->WorkstationNameLength +
            LogonInfo->DomainNameLength +
            LogonInfo->CaseInsensitivePasswordLength +
            ROUND_UP_COUNT(LogonInfo->CaseSensitivePasswordLength, sizeof(USHORT));


    InTokenSize = (InTokenSize + 3) & 0xfffffffc;

    OutTokenSize = sizeof(NTLM_ACCEPT_RESPONSE);
    OutTokenSize = (OutTokenSize + 3) & 0xfffffffc;

    //
    // Round this up to 8 byte boundary because the out token needs to be
    // quad word aligned for the LARGE_INTEGER.
    //

    AllocateSize = ((NtlmInTokenSize + InTokenSize + 7) & 0xfffffff8) + OutTokenSize;

    status = STATUS_SUCCESS ;

    InToken = ExAllocatePool( PagedPool, AllocateSize );

    if ( InToken == NULL )
    {
        status = STATUS_NO_MEMORY ;

    }

    if ( !NT_SUCCESS(status) ) {

        actualUserInfoBufferLength = (ULONG)AllocateSize;

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvValidateUser: ExAllocatePool failed: %X\n.",
            status,
            NULL
            );

        SrvLogError(
            SrvDeviceObject,
            EVENT_SRV_NO_VIRTUAL_MEMORY,
            status,
            &actualUserInfoBufferLength,
            sizeof(ULONG),
            NULL,
            0
            );

        status = STATUS_INSUFF_SERVER_RESOURCES;
        goto error_exit;
    }

    //
    // Zero the input tokens
    //

    RtlZeroMemory(
        InToken,
        InTokenSize + NtlmInTokenSize
        );

    NtlmInToken = (PNTLM_AUTHENTICATE_MESSAGE) ((PUCHAR) InToken + InTokenSize);
    OutToken = (PNTLM_ACCEPT_RESPONSE) ((PUCHAR) (((ULONG_PTR) NtlmInToken + NtlmInTokenSize + 7) & ~7));

    //
    // First set up the NtlmInToken, since it is the easiest.
    //

    RtlCopyMemory(
        NtlmInToken->ChallengeToClient,
        LogonInfo->EncryptionKey,
        MSV1_0_CHALLENGE_LENGTH
        );

    NtlmInToken->ParameterControl = 0;


    //
    // Okay, now for the tought part - marshalling the AUTHENTICATE_MESSAGE
    //

    RtlCopyMemory(  InToken->Signature,
                    NTLMSSP_SIGNATURE,
                    sizeof(NTLMSSP_SIGNATURE));

    InToken->MessageType = NtLmAuthenticate;

    BufferOffset = sizeof(AUTHENTICATE_MESSAGE);

    //
    // LM password - case insensitive
    //

    InToken->LmChallengeResponse.Buffer = BufferOffset;
    InToken->LmChallengeResponse.Length =
        InToken->LmChallengeResponse.MaximumLength =
            (USHORT) LogonInfo->CaseInsensitivePasswordLength;

    RtlCopyMemory(  BufferOffset + (PCHAR) InToken,
                    LogonInfo->CaseInsensitivePassword,
                    LogonInfo->CaseInsensitivePasswordLength);

    BufferOffset += ROUND_UP_COUNT(LogonInfo->CaseInsensitivePasswordLength, sizeof(USHORT));

    //
    // NT password - case sensitive
    //

    InToken->NtChallengeResponse.Buffer = BufferOffset;
    InToken->NtChallengeResponse.Length =
        InToken->NtChallengeResponse.MaximumLength =
            (USHORT) LogonInfo->CaseSensitivePasswordLength;

    RtlCopyMemory(  BufferOffset + (PCHAR) InToken,
                    LogonInfo->CaseSensitivePassword,
                    LogonInfo->CaseSensitivePasswordLength);

    BufferOffset += LogonInfo->CaseSensitivePasswordLength;

    //
    // Domain Name
    //

    InToken->DomainName.Buffer = BufferOffset;
    InToken->DomainName.Length =
        InToken->DomainName.MaximumLength =
            (USHORT) LogonInfo->DomainNameLength;

    RtlCopyMemory(  BufferOffset + (PCHAR) InToken,
                    LogonInfo->DomainName,
                    LogonInfo->DomainNameLength);

    BufferOffset += LogonInfo->DomainNameLength;

    //
    // Workstation Name
    //

    InToken->Workstation.Buffer = BufferOffset;
    InToken->Workstation.Length =
        InToken->Workstation.MaximumLength =
            (USHORT) LogonInfo->WorkstationNameLength;

    RtlCopyMemory(  BufferOffset + (PCHAR) InToken,
                    LogonInfo->WorkstationName,
                    LogonInfo->WorkstationNameLength);

    BufferOffset += LogonInfo->WorkstationNameLength;


    //
    // User Name
    //

    InToken->UserName.Buffer = BufferOffset;
    InToken->UserName.Length =
        InToken->UserName.MaximumLength =
            (USHORT) LogonInfo->UserNameLength;

    RtlCopyMemory(  BufferOffset + (PCHAR) InToken,
                    LogonInfo->UserName,
                    LogonInfo->UserNameLength);

    BufferOffset += LogonInfo->UserNameLength;

    //
    // Setup all the buffers properly
    //

    InputToken.pBuffers = InputBuffers;
    if (Connection && (Connection->SockAddr[0] != 0))
    {
        InputToken.cBuffers = 3;
        InputBuffers[2].pvBuffer = Connection->SockAddr;
        InputBuffers[2].cbBuffer = SRV_CONNECTION_SOCKADDR_SIZE;
        InputBuffers[2].BufferType = SECBUFFER_IPADDRESS;
    }
    else
    {
        InputToken.cBuffers = 2;
    }
    InputToken.ulVersion = 0;
    InputBuffers[0].pvBuffer = InToken;
    InputBuffers[0].cbBuffer = InTokenSize;
    InputBuffers[0].BufferType = SECBUFFER_TOKEN;
    InputBuffers[1].pvBuffer = NtlmInToken;
    InputBuffers[1].cbBuffer = NtlmInTokenSize;
    InputBuffers[1].BufferType = SECBUFFER_TOKEN;

    OutputToken.pBuffers = &OutputBuffer;
    OutputToken.cBuffers = 1;
    OutputToken.ulVersion = 0;
    OutputBuffer.pvBuffer = OutToken;
    OutputBuffer.cbBuffer = OutTokenSize;
    OutputBuffer.BufferType = SECBUFFER_TOKEN;

    SrvStatistics.SessionLogonAttempts++;

    status = AcceptSecurityContext(
                &SrvLmLsaHandle,
                NULL,
                &InputToken,
                ASC_REQ_ALLOW_NON_USER_LOGONS | ASC_REQ_ALLOW_NULL_SESSION,
                SECURITY_NATIVE_DREP,
                &LogonInfo->Token,
                &OutputToken,
                &Catts,
                (PTimeStamp) &Expiry
                );

    status = MapSecurityError( status );

    if ( !NT_SUCCESS(status) ) {

        INVALIDATE_SECURITY_HANDLE( LogonInfo->Token );

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvValidateUser: LsaLogonUser failed: %X",
            status,
            NULL
            );

        ExFreePool( InToken );


        goto error_exit;
    }

    LogonInfo->KickOffTime = OutToken->KickoffTime;
    // Sspi will return time in LocalTime, convert to SystemTime
    ExLocalTimeToSystemTime( &Expiry, &LogonInfo->LogOffTime );
    //LogonInfo->LogOffTime = Expiry;
    LogonInfo->GuestLogon = (BOOLEAN)(OutToken->UserFlags & LOGON_GUEST);
    LogonInfo->EncryptedLogon = (BOOLEAN)!(OutToken->UserFlags & LOGON_NOENCRYPTION);
    LogonInfo->LogonId = OutToken->LogonId;
    LogonInfo->HaveHandle = TRUE;

    if ( (OutToken->UserFlags & LOGON_USED_LM_PASSWORD) &&
        LogonInfo->NtSmbs ) {

        ASSERT( MSV1_0_USER_SESSION_KEY_LENGTH >=
                MSV1_0_LANMAN_SESSION_KEY_LENGTH );

        RtlZeroMemory(
            LogonInfo->NtUserSessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );

        RtlCopyMemory(
            LogonInfo->NtUserSessionKey,
            OutToken->LanmanSessionKey,
            MSV1_0_LANMAN_SESSION_KEY_LENGTH
            );

        //
        // Turn on bit 1 to tell the client that we are using
        // the lm session key instead of the user session key.
        //

        LogonInfo->Action |= SMB_SETUP_USE_LANMAN_KEY;

    } else {

        RtlCopyMemory(
            LogonInfo->NtUserSessionKey,
            OutToken->UserSessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );

    }

    //
    // If we have a session and we didn't do a guest logon, start up
    //   security signatures if requested
    //

    if ( ARGUMENT_PRESENT( Connection ) &&
        SecuritySignatureDesired &&
        LogonInfo->GuestLogon == FALSE &&
        ( SrvSmbSecuritySignaturesRequired ||
          SrvEnableW9xSecuritySignatures   ||
          CLIENT_CAPABLE_OF(NT_STATUS, Connection) )
        )
        {

        if( ARGUMENT_PRESENT( Session ) )
        {
            if( SrvRequireExtendedSignatures ||
                (SrvEnableExtendedSignatures &&
                 IS_NT_DIALECT(Connection->SmbDialect) &&
                 CLIENT_CAPABLE_OF( EXTENDED_SECURITY, Connection ) ) )
            {
                // This session is going to be used as the key for signatures, mark it as unavailible until
                // the client tries to upgrade to extended signatures
                Session->SessionKeyState = SrvSessionKeyAuthenticating;
            }
            else
            {
                Session->SessionKeyState = SrvSessionKeyAvailible;
            }
        }

        SrvInitializeSmbSecuritySignature(
                    Connection,
                    LogonInfo->NtUserSessionKey,
                    ((OutToken->UserFlags & LOGON_USED_LM_PASSWORD) != 0) ?
                        LogonInfo->CaseInsensitivePassword :
                            LogonInfo->CaseSensitivePassword,
                    ((OutToken->UserFlags & LOGON_USED_LM_PASSWORD) != 0) ?
                        LogonInfo->CaseInsensitivePasswordLength :
                            LogonInfo->CaseSensitivePasswordLength
                    );
    }
    else
    {
        if( ARGUMENT_PRESENT(Session) )
        {
            // This key is not used for signing, so no work is necessary
            Session->SessionKeyState = SrvSessionKeyAvailible;
        }
    }

    RtlCopyMemory(
        LogonInfo->LanManSessionKey,
        OutToken->LanmanSessionKey,
        MSV1_0_LANMAN_SESSION_KEY_LENGTH
        );

    ExFreePool( InToken );

    //
    // Note whether or not this user is an administrator
    //

    LogonInfo->IsAdmin = SrvIsAdmin( LogonInfo->Token );

    //
    // One last check:  Is our session count being exceeded?
    //   We will let the session be exceeded by 1 iff the client
    //   is an administrator.
    //

    if( LogonInfo->IsNullSession == FALSE ) {

        oldSessionCount = ExInterlockedAddUlong(
                          &SrvStatistics.CurrentNumberOfSessions,
                          1,
                          &GLOBAL_SPIN_LOCK(Statistics)
                          );

        SrvInhibitIdlePowerDown();

        if ( ARGUMENT_PRESENT(Session) && (!Session->IsSessionExpired && oldSessionCount >= SrvMaxUsers) ) {
            if( oldSessionCount != SrvMaxUsers || !LogonInfo->IsAdmin ) {

                ExInterlockedAddUlong(
                    &SrvStatistics.CurrentNumberOfSessions,
                    (ULONG)-1,
                    &GLOBAL_SPIN_LOCK(Statistics)
                    );

                DeleteSecurityContext( &LogonInfo->Token );
                INVALIDATE_SECURITY_HANDLE( LogonInfo->Token );

                status = STATUS_REQUEST_NOT_ACCEPTED;
                SrvAllowIdlePowerDown();
                goto error_exit;
            }
        }
    }

    return STATUS_SUCCESS;

error_exit:

    return status;

} // DoUserLogon

BOOLEAN
SrvIsAdmin(
    CtxtHandle  Handle
)
/*++

Routine Description:

    Returns TRUE if the user represented by Handle is an
      administrator

Arguments:

    Handle - Represents the user we're interested in

Return Value:

    TRUE if the user is an administrator.  FALSE otherwise.

--*/
{
    NTSTATUS                 status;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    ACCESS_MASK              GrantedAccess;
    GENERIC_MAPPING          Mapping = {   FILE_GENERIC_READ,
                                           FILE_GENERIC_WRITE,
                                           FILE_GENERIC_EXECUTE,
                                           FILE_ALL_ACCESS
                                       };
    HANDLE                   NullHandle = NULL;
    BOOLEAN                  retval  = FALSE;

    PAGED_CODE();

    //
    // Impersonate the client
    //
    status = ImpersonateSecurityContext( &Handle );

    if( !NT_SUCCESS( status ) )
        return FALSE;

    SeCaptureSubjectContext( &SubjectContext );

    retval = SeAccessCheck( &SrvAdminSecurityDescriptor,
                            &SubjectContext,
                            FALSE,
                            FILE_GENERIC_READ,
                            0,
                            NULL,
                            &Mapping,
                            UserMode,
                            &GrantedAccess,
                            &status );

    SeReleaseSubjectContext( &SubjectContext );

    //
    // Revert back to our original identity
    //

    REVERT( );
    return retval;
}

BOOLEAN
SrvIsNullSession(
    CtxtHandle  Handle
)
/*++

Routine Description:

    Returns TRUE if the user represented by Handle is an
      anonymous logon

Arguments:

    Handle - Represents the user we're interested in

Return Value:

    TRUE if the user is an anonymous logon.  FALSE otherwise.

--*/
{
    NTSTATUS                 status;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    ACCESS_MASK              GrantedAccess;
    GENERIC_MAPPING          Mapping = {   FILE_GENERIC_READ,
                                           FILE_GENERIC_WRITE,
                                           FILE_GENERIC_EXECUTE,
                                           FILE_ALL_ACCESS
                                       };
    HANDLE                   NullHandle = NULL;
    BOOLEAN                  retval  = FALSE;

    PAGED_CODE();

    //
    // Impersonate the client
    //
    status = ImpersonateSecurityContext( &Handle );

    if( !NT_SUCCESS( status ) )
        return FALSE;

    SeCaptureSubjectContext( &SubjectContext );

    retval = SeAccessCheck( &SrvNullSessionSecurityDescriptor,
                            &SubjectContext,
                            FALSE,
                            FILE_GENERIC_READ,
                            0,
                            NULL,
                            &Mapping,
                            UserMode,
                            &GrantedAccess,
                            &status );

    SeReleaseSubjectContext( &SubjectContext );

    //
    // Revert back to our original identity
    //

    REVERT( );
    return retval;
}

NTSTATUS
SrvGetLogonId(
    PCtxtHandle  Handle,
    PLUID LogonId
)
/*++

Routine Description:

    Returns the Logon Id for the requested context.

Arguments:

    Handle - Represents the user we're interested in

Return Value:

    Error codes from ImpersonateSecurityContext and SeQueryAuthenticationId.

--*/
{
    NTSTATUS                 Status;
    SECURITY_SUBJECT_CONTEXT SubjectContext;

    PAGED_CODE();

    //
    // Impersonate the client
    //
    Status = ImpersonateSecurityContext( Handle );

    if( !NT_SUCCESS( Status ) )
        return MapSecurityError(Status);

    SeCaptureSubjectContext( &SubjectContext );

    SeLockSubjectContext( &SubjectContext );

    Status = SeQueryAuthenticationIdToken(
                SubjectContext.ClientToken,
                LogonId
                );

    SeUnlockSubjectContext( &SubjectContext );
    SeReleaseSubjectContext( &SubjectContext );

    REVERT( );

    return(Status);
}


NTSTATUS
SrvValidateSecurityBuffer(
    IN PCONNECTION Connection,
    IN OUT PCtxtHandle Handle,
    IN PSESSION Session,
    IN PCHAR Buffer,
    IN ULONG  BufferLength,
    IN BOOLEAN SecuritySignaturesRequired,
    OUT PCHAR ReturnBuffer,
    IN OUT PULONG ReturnBufferLength,
    OUT PLARGE_INTEGER Expiry,
    OUT PCHAR NtUserSessionKey,
    OUT PLUID LogonId,
    OUT PBOOLEAN IsGuest
    )

/*++

Routine Description:

    Validates a Security Buffer sent from the client

Arguments:

    Handle - On successful return, contains the security context handle
        associated with the user login.

    Session - Points to the session structure for this user

    Buffer - The Buffer to validate

    BufferLength - The length in bytes of Buffer

    SecuritySignaturesRequired - Are we required to generate a security
        signature for the SMBs?

    ReturnBuffer - On return, contains a security buffer to return to the
        client.

    ReturnBufferLength - On return, size in bytes of ReturnBuffer.  On entry,
            the largest buffer we can return.

    Expiry - The time after which this security buffer is no longer valid.

    NtUserSessionKey - If STATUS_SUCCESS, the session key is returned here. This
        must point to a buffer at least MSV1_0_USER_SESSION_KEY_LENGTH big.

    LogonId - If successful, receives the logon id for this context.

    IsGuest - If successful, TRUE if the client has been validated as a guest

Return Value:

    NTSTATUS from the security system.  If STATUS_SUCCESS is returned, the user
        has been completely authenticated.

Notes:

    BUGBUG

    AcceptSecurityContext() needs to return the KickOffTime (ie, the logon
    hours restriction) so that the server can enfore it. The contact person
    is MikeSw for this.

--*/

{
    NTSTATUS Status;
    ULONG Catts;
    PUCHAR AllocateMemory = NULL;
    ULONG maxReturnBuffer = *ReturnBufferLength;
    ULONG_PTR AllocateLength = MAX(BufferLength, maxReturnBuffer );
    BOOLEAN virtualMemoryAllocated = FALSE;
    SecBufferDesc InputToken;
    SecBuffer InputBuffer[2];
    SecBufferDesc OutputToken;
    SecBuffer OutputBuffer;
    SecPkgContext_NamesW SecNames;
    SecPkgContext_SessionKey SecKeys;
    ULONG oldSessionCount;
    TimeStamp LocalExpiry = {0};

    *ReturnBufferLength = 0;
    *IsGuest = FALSE;

    if ( (SrvHaveCreds & HAVEEXTENDED) == 0 ) {
        return STATUS_ACCESS_DENIED;
    }

    RtlZeroMemory( &SecKeys, sizeof( SecKeys ) );
    RtlZeroMemory( &SecNames, sizeof( SecNames ) );

    InputToken.pBuffers = InputBuffer;
    if( Connection->SockAddr[0] != 0 )
    {
        InputToken.cBuffers =  2;
        InputBuffer[1].pvBuffer = Connection->SockAddr;
        InputBuffer[1].cbBuffer = SRV_CONNECTION_SOCKADDR_SIZE;
        InputBuffer[1].BufferType = SECBUFFER_IPADDRESS;
    }
    else
    {
        InputToken.cBuffers =  1;
    }
    InputToken.ulVersion = 0;
    InputBuffer[0].pvBuffer = Buffer;
    InputBuffer[0].cbBuffer = BufferLength;
    InputBuffer[0].BufferType = SECBUFFER_TOKEN;

    OutputToken.pBuffers = &OutputBuffer;
    OutputToken.cBuffers = 1;
    OutputToken.ulVersion = 0;
    OutputBuffer.pvBuffer = ReturnBuffer ;
    OutputBuffer.cbBuffer = maxReturnBuffer ;
    OutputBuffer.BufferType = SECBUFFER_TOKEN;

    SrvStatistics.SessionLogonAttempts++;
    Catts = 0;

    Status = AcceptSecurityContext(
                    &SrvExtensibleSecurityHandle,
                    IS_VALID_SECURITY_HANDLE( *Handle ) ? Handle : NULL,
                    &InputToken,
                    ASC_REQ_EXTENDED_ERROR | ASC_REQ_ALLOW_NULL_SESSION |
                            ASC_REQ_DELEGATE | ASC_REQ_FRAGMENT_TO_FIT,
                    SECURITY_NATIVE_DREP,
                    Handle,
                    &OutputToken,
                    &Catts,
                    &LocalExpiry);

    Status = MapSecurityError( Status );

    //
    // If there is a return buffer to be sent back, copy it into the caller's
    // buffers now.
    //
    if ( NT_SUCCESS(Status) || (Catts & ASC_RET_EXTENDED_ERROR) ) {

        if( Status == STATUS_SUCCESS ) {
            NTSTATUS qcaStatus;
            SecPkgContext_UserFlags userFlags;

            // Sspi will return time in LocalTime, convert to UTC
            // Enable dynamic reauthentication if possible or required
            if( SrvEnforceLogoffTimes || CLIENT_CAPABLE_OF( DYNAMIC_REAUTH, Connection ) )
            {
                ExLocalTimeToSystemTime (&LocalExpiry, Expiry);
            }
            else
            {
                Expiry->QuadPart = SRV_NEVER_TIME ;
            }


            //
            // The user has been completely authenticated.  See if the session
            // count is being exceeded.  We'll allow it only if the new client
            // is an administrator.
            //

            oldSessionCount = ExInterlockedAddUlong(
                              &SrvStatistics.CurrentNumberOfSessions,
                              1,
                              &GLOBAL_SPIN_LOCK(Statistics)
                              );

            SrvInhibitIdlePowerDown();

            if ( !Session->IsSessionExpired && oldSessionCount >= SrvMaxUsers ) {
                if( oldSessionCount != SrvMaxUsers ||
                        !SrvIsAdmin( *Handle ) ) {

                    ExInterlockedAddUlong(
                        &SrvStatistics.CurrentNumberOfSessions,
                        (ULONG)-1,
                        &GLOBAL_SPIN_LOCK(Statistics)
                        );

                    DeleteSecurityContext( Handle );

                    INVALIDATE_SECURITY_HANDLE( *Handle );

                    Status = STATUS_REQUEST_NOT_ACCEPTED;
                    SrvAllowIdlePowerDown();
                    goto exit;
                }
            }

            //
            // Figure out if we validated the client as GUEST
            //
            qcaStatus = QueryContextAttributes(
                            Handle,
                            SECPKG_ATTR_USER_FLAGS,
                            &userFlags);


            if( NT_SUCCESS( MapSecurityError( qcaStatus ) ) ) {

                if( userFlags.UserFlags & LOGON_GUEST ) {
                    *IsGuest = TRUE;
                }

            } else {
                SrvLogServiceFailure( SRV_SVC_SECURITY_PKG_PROBLEM, qcaStatus );
            }

            //
            // Get the Logon Id for this context
            //
            Status = SrvGetLogonId( Handle, LogonId );

            //
            // Capture the session key for this context
            //
            RtlZeroMemory( (PVOID) NtUserSessionKey, MSV1_0_USER_SESSION_KEY_LENGTH );

            qcaStatus = QueryContextAttributes(
                            Handle,
                            SECPKG_ATTR_SESSION_KEY,
                            &SecKeys);

            if( NT_SUCCESS( MapSecurityError( qcaStatus ) ) ) {

                RtlCopyMemory(
                    (PVOID) NtUserSessionKey,
                    SecKeys.SessionKey,
                    MIN(MSV1_0_USER_SESSION_KEY_LENGTH, SecKeys.SessionKeyLength)
                    );

                //
                // Start the security signatures, if required.  We do not do security signatures
                //   if we have a null session or a guest logon.
                //
                if( NT_SUCCESS( Status ) &&
                    SecuritySignaturesRequired &&
                    *IsGuest == FALSE &&
                    Connection->SmbSecuritySignatureActive == FALSE &&
                    !SrvIsNullSession( *Handle ) ) {

                    if( SrvRequireExtendedSignatures ||
                        (SrvEnableExtendedSignatures &&
                         IS_NT_DIALECT(Connection->SmbDialect) &&
                         CLIENT_CAPABLE_OF( EXTENDED_SECURITY, Connection ) ) )
                    {
                        // This session is going to be used as the key for signatures, mark it as unavailible until
                        // the client tries to upgrade to extended signatures
                        Session->SessionKeyState = SrvSessionKeyAuthenticating;
                    }
                    else
                    {
                        Session->SessionKeyState = SrvSessionKeyAvailible;
                    }

                    //
                    // Start the sequence number generation
                    //
                    SrvInitializeSmbSecuritySignature(
                                    Connection,
                                    NULL,
                                    SecKeys.SessionKey,
                                    SecKeys.SessionKeyLength
                                    );
                }
                else
                {
                    // This key is not used for signing, so no work is necessary
                    Session->SessionKeyState = SrvSessionKeyAvailible;
                }

                FreeContextBuffer( SecKeys.SessionKey );

            } else {

                SrvLogServiceFailure( SRV_SVC_SECURITY_PKG_PROBLEM, qcaStatus );
            }

            if( !NT_SUCCESS( Status ) ) {
                DeleteSecurityContext( Handle );
                INVALIDATE_SECURITY_HANDLE( *Handle );
            }
        }

        ASSERT( OutputBuffer.cbBuffer <= maxReturnBuffer );

        //
        // If it fits, and a buffer was returned, send it to the client.  If it doesn't fit,
        //  then log the problem.
        //
        if( OutputBuffer.cbBuffer <= maxReturnBuffer ) {
            if( OutputBuffer.cbBuffer != 0 ) {
                *ReturnBufferLength = OutputBuffer.cbBuffer;
            }
        } else {
            SrvLogServiceFailure( SRV_SVC_SECURITY_PKG_PROBLEM, OutputBuffer.cbBuffer );
        }
    }

exit:

#if DBG

    //
    // RDR or SRV is sending in a corrupt security blob to LSA -- need to
    // find out what the source is.
    //

    if( NT_SUCCESS(Status) )
    {
        if( (OutputBuffer.pvBuffer != NULL) &&
            (OutputBuffer.cbBuffer >= sizeof(DWORD))
            )
        {
            PUCHAR pValidate = (PUCHAR) OutputBuffer.pvBuffer ;

            ASSERT( ( pValidate[0] != 0 ) ||
                    ( pValidate[1] != 0 ) ||
                    ( pValidate[2] != 0 ) ||
                    ( pValidate[3] != 0 ) );
        }
    }
#endif


    if( NT_SUCCESS( Status ) && Status != STATUS_SUCCESS ) {
        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    return Status;

} // SrvValidateSecurityBuffer

NTSTATUS
SrvGetUserAndDomainName (
    IN PSESSION Session,
    OUT PUNICODE_STRING UserName OPTIONAL,
    OUT PUNICODE_STRING DomainName OPTIONAL
    )
/*++

Routine Description

    Return the user and domain names associated with the Session

Arguments:
    IN PSESSION Session : The session

Return Value:
    IN OUT PUNICODE_STRING UserName
    IN OUT PUNICODE_STRING DomainName

Note:
    The caller must call SrvReleaseUserAndDomainName() when finished

--*/
{
    SecPkgContext_NamesW SecNames;
    NTSTATUS status;
    UNICODE_STRING fullName, tmpUserName, tmpDomainName;
    USHORT i, fullNameLength;
    BOOLEAN LockConn = FALSE;

    PAGED_CODE();

    if( Session->Connection != NULL )
    {
        ACQUIRE_LOCK( &Session->Connection->Lock );
        LockConn = TRUE;
    }

    if( Session->SecurityContext == NULL ||
        !IS_VALID_SECURITY_HANDLE( Session->SecurityContext->UserHandle ) ) {

        if( ARGUMENT_PRESENT( UserName ) ) {
            *UserName = Session->NtUserName;
        }
        if( ARGUMENT_PRESENT( DomainName ) ) {
            *DomainName = Session->NtUserDomain;
        }

        status = STATUS_SUCCESS;
        goto Cleanup;
    }

    if( ARGUMENT_PRESENT( UserName ) ) {
        UserName->Buffer = NULL;
        UserName->Length = 0;
    }

    if( ARGUMENT_PRESENT( DomainName ) ) {
        DomainName->Buffer = NULL;
        DomainName->Length = 0;
    }

    //
    // If it's the NULL session, then there are no names to be returned!
    //
    if( Session->IsNullSession == TRUE ) {
        status = STATUS_SUCCESS;
        goto Cleanup;
    }

    SecNames.sUserName = NULL;

    status = QueryContextAttributesW(
                    &Session->SecurityContext->UserHandle,
                    SECPKG_ATTR_NAMES,
                    &SecNames
            );

    status = MapSecurityError( status );

    if (!NT_SUCCESS(status)) {
        if( Session->LogonSequenceInProgress == FALSE ) {
            //
            // If the client is in the middle of an extended logon sequence,
            //   then failures of this type are expected and we don't want
            //   to clutter the event log with them
            //
            SrvLogServiceFailure( SRV_SVC_LSA_LOOKUP_PACKAGE, status );
        }
        status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // See if we have a NULL user names.  This shouldn't happen, but
    //  might if a security package is incomplete or something
    //
    if( SecNames.sUserName == NULL || *SecNames.sUserName == L'\0' ) {

        if( SecNames.sUserName != NULL ) {
            FreeContextBuffer( SecNames.sUserName );
        }
        status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // The return SecNames.sUserName should be in domainname\username format.
    //  We need to split it apart.
    //
    RtlInitUnicodeString( &fullName, SecNames.sUserName );

    fullNameLength = fullName.Length / sizeof(WCHAR);

    tmpDomainName.Buffer = fullName.Buffer;

    for (i = 0; i < fullNameLength && tmpDomainName.Buffer[i] != L'\\'; i++) {
         NOTHING;
    }

    if( tmpDomainName.Buffer[i] != L'\\' ) {
        FreeContextBuffer( SecNames.sUserName );
        status = STATUS_INVALID_ACCOUNT_NAME;
        goto Cleanup;
    }

    tmpDomainName.Length = i * sizeof(WCHAR);
    tmpDomainName.MaximumLength = tmpDomainName.Length;

    tmpUserName.Buffer = &tmpDomainName.Buffer[i + 1];
    tmpUserName.Length = fullName.Length - tmpDomainName.Length - sizeof(WCHAR);
    tmpUserName.MaximumLength = tmpUserName.Length;

    if( ARGUMENT_PRESENT( UserName ) ) {
        status = RtlUpcaseUnicodeString( UserName, &tmpUserName, TRUE);
        if( !NT_SUCCESS( status ) ) {
            SrvLogServiceFailure( SRV_SVC_LSA_LOOKUP_PACKAGE, status );
            FreeContextBuffer( SecNames.sUserName );
            goto Cleanup;
        }
    }

    if( ARGUMENT_PRESENT( DomainName ) ) {
        status = RtlUpcaseUnicodeString( DomainName, &tmpDomainName, TRUE );
        if( !NT_SUCCESS( status ) ) {
            SrvLogServiceFailure( SRV_SVC_LSA_LOOKUP_PACKAGE, status );
            FreeContextBuffer( SecNames.sUserName );
            if( UserName != NULL ) {
                RtlFreeUnicodeString( UserName );
            }
            goto Cleanup;
        }
    }

    FreeContextBuffer( SecNames.sUserName );

Cleanup:
    if( LockConn ) RELEASE_LOCK( &Session->Connection->Lock );
    return status;
}

VOID
SrvReleaseUserAndDomainName(
    IN PSESSION Session,
    IN OUT PUNICODE_STRING UserName OPTIONAL,
    IN OUT PUNICODE_STRING DomainName OPTIONAL
    )
/*++

Routine Description

    This is the complement of SrvGetUserAndDomainName.  It frees the memory
        if necessary.

--*/

{
    PAGED_CODE();

    if( ARGUMENT_PRESENT( UserName ) &&
        UserName->Buffer != NULL &&
        UserName->Buffer != Session->NtUserName.Buffer ) {

        RtlFreeUnicodeString( UserName );
    }

    if( ARGUMENT_PRESENT( DomainName ) &&
        DomainName->Buffer != NULL &&
        DomainName->Buffer != Session->NtUserDomain.Buffer ) {

        RtlFreeUnicodeString( DomainName );

    }
}


NTSTATUS
SrvFreeSecurityContexts (
    IN PSESSION Session
    )

/*++

Routine Description:

    Releases any context obtained for security purposes

Arguments:

    IN PSESSION Session : The session

Return Value:

    NTSTATUS

--*/

{
    if( Session->SecurityContext != NULL ) {

        if ( !CONTEXT_EQUAL( Session->SecurityContext->UserHandle, SrvNullSessionToken ) ) {

            if( !Session->LogonSequenceInProgress ) {

                ExInterlockedAddUlong(
                    &SrvStatistics.CurrentNumberOfSessions,
                    (ULONG)-1,
                    &GLOBAL_SPIN_LOCK(Statistics)
                    );

                SrvAllowIdlePowerDown();
            }
        }

        SrvDereferenceSecurityContext( Session->SecurityContext );
        Session->SecurityContext = NULL;
    }

    return STATUS_SUCCESS;

} // SrvFreeSecurityContexts


NTSTATUS
AcquireLMCredentials (
    VOID
    )
{
    UNICODE_STRING Ntlm;
    NTSTATUS status;
    TimeStamp Expiry;

    RtlInitUnicodeString( &Ntlm, L"NTLM" );

    //
    // We pass in 1 for the GetKeyArg to indicate that this is
    // downlevel NTLM, to distinguish it from NT5 NTLM.
    //

    status = AcquireCredentialsHandle(
                NULL,                   // Default principal
                (PSECURITY_STRING) &Ntlm,
                SECPKG_CRED_INBOUND,    // Need to define this
                NULL,                   // No LUID
                NULL,                   // No AuthData
                NULL,                   // No GetKeyFn
                NTLMSP_NTLM_CREDENTIAL, // GetKeyArg
                &SrvLmLsaHandle,
                &Expiry
                );

    if ( !NT_SUCCESS(status) ) {
        status = MapSecurityError(status);
        return status;
    }
    SrvHaveCreds |= HAVENTLM;

    return status;

} // AcquireLMCredentials

#ifndef EXTENSIBLESSP_NAME
#define EXTENSIBLESSP_NAME NEGOSSP_NAME_W
#endif


NTSTATUS
AcquireExtensibleSecurityCredentials (
    VOID
    )

/*++

Routine Description:

    Acquires the handle to the security negotiate package.

Arguments:

    none.

Return Value:

    NTSTATUS

--*/

{
    UNICODE_STRING NegotiateName;
    TimeStamp Expiry;
    NTSTATUS status ;


    RtlInitUnicodeString( &NegotiateName, EXTENSIBLESSP_NAME );

    status = AcquireCredentialsHandle(
                NULL,                   // Default principal
                (PSECURITY_STRING) &NegotiateName,
                SECPKG_CRED_INBOUND,    // Need to define this
                NULL,                   // No LUID
                NULL,                   // No AuthData
                NULL,                   // No GetKeyFn
                NULL,                   // No GetKeyArg
                &SrvExtensibleSecurityHandle,
                &Expiry
                );


    if ( !NT_SUCCESS(status) ) {
        status = MapSecurityError(status);
        return status;
    }
    SrvHaveCreds |= HAVEEXTENDED;

    return status;

} // AcquireExtensibleSecurityCredentials

VOID
SrvAddSecurityCredentials(
    IN PANSI_STRING ComputerNameA,
    IN PUNICODE_STRING DomainName,
    IN DWORD PasswordLength,
    IN PBYTE Password
)
/*++

Routine Description:

    In order for mutual authentication to work, the security subsystem needs to know
    all the names the server is using, as well as any passwords needed to decrypt
    the security information associated with the server name.  This routine informs
    the security subsystem.

Arguments:

    ComputerName, DomainName - these are the names the clients will be using to access this system

    PasswordLength, Password - this is the secret the security system needs to know to decode the
        passed security information

--*/
{
    NTSTATUS status;
    UNICODE_STRING ComputerName;
    PUSHORT p;
    PVOID VirtualMem ;
    SIZE_T Size ;
    PSEC_WINNT_AUTH_IDENTITY Auth ;
    PUCHAR Where ;
    UNICODE_STRING NegotiateName;
    TimeStamp Expiry;

    PAGED_CODE();

    status = RtlAnsiStringToUnicodeString( &ComputerName, ComputerNameA, TRUE );

    if( !NT_SUCCESS( status ) ) {
        IF_DEBUG( ERRORS ) {
            KdPrint(( "SRV: SrvAddSecurityCredentials, status %X at %d\n", status, __LINE__ ));
        }
        return;
    }

    if ((SrvHaveCreds & HAVEEXTENDED) == 0) {
        if (status = AcquireExtensibleSecurityCredentials()) {
            return ;
        }
    }

    //
    // Trim off any trailing blanks
    //
    for( p = &ComputerName.Buffer[ (ComputerName.Length / sizeof( WCHAR )) - 1 ];
         p > ComputerName.Buffer;
         p-- ) {

        if( *p != L' ' )
            break;
    }

    ComputerName.Length = (USHORT)((p - ComputerName.Buffer + 1) * sizeof( WCHAR ));

    if( ComputerName.Length ) {
        //
        // Tell the security subsystem about this name.
        //
        RtlInitUnicodeString( &NegotiateName, EXTENSIBLESSP_NAME );

        Size = ComputerName.Length + sizeof( WCHAR ) +
               DomainName->Length + sizeof( WCHAR ) +
               PasswordLength +
               sizeof( SEC_WINNT_AUTH_IDENTITY ) ;


        VirtualMem = NULL ;

        status = NtAllocateVirtualMemory(
                    NtCurrentProcess(),
                    &VirtualMem,
                    0,
                    &Size,
                    MEM_COMMIT,
                    PAGE_READWRITE );

        if ( NT_SUCCESS( status ) )
        {
            Auth = (PSEC_WINNT_AUTH_IDENTITY) VirtualMem ;

            Where = (PUCHAR) (Auth + 1);

            Auth->User = (PWSTR) Where ;

            Auth->UserLength = ComputerName.Length / sizeof( WCHAR );

            RtlCopyMemory(
                Where,
                ComputerName.Buffer,
                ComputerName.Length );

            Where += ComputerName.Length ;

            Auth->Domain = (PWSTR) Where ;

            Auth->DomainLength = DomainName->Length / sizeof( WCHAR );

            RtlCopyMemory(
                Where,
                DomainName->Buffer,
                DomainName->Length );

            Where += DomainName->Length ;

            Auth->Password = (PWSTR) Where ;

            Auth->PasswordLength = PasswordLength / sizeof( WCHAR );

            RtlCopyMemory(
                Where,
                Password,
                PasswordLength );

            Auth->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE ;


            status = AddCredentials(
                        &SrvExtensibleSecurityHandle,                   // Default principal
                        NULL,
                        (PSECURITY_STRING) &NegotiateName,
                        SECPKG_CRED_INBOUND,    // Need to define this
                        Auth,                   // Auth data
                        NULL,                   // No GetKeyFn
                        NULL,                   // No GetKeyArg
                        &Expiry );

            NtFreeVirtualMemory(
                NtCurrentProcess(),
                &VirtualMem,
                &Size,
                MEM_RELEASE );

        }

    }

    //
    // Free up our memory
    //
    RtlFreeUnicodeString( &ComputerName );
}

NTSTATUS
SrvGetExtensibleSecurityNegotiateBuffer(
    OUT PCtxtHandle Token,
    OUT PCHAR Buffer,
    IN OUT ULONG *BufferLength
    )

{

    NTSTATUS Status;
    ULONG Attributes;
    TimeStamp Expiry;
    SecBufferDesc OutputToken;
    SecBuffer OutputBuffer;
    ULONG MaxBufferSize = *BufferLength;

    if ((SrvHaveCreds & HAVEEXTENDED) == 0) {
        if (Status = AcquireExtensibleSecurityCredentials()) {
            *BufferLength = 0;
            return(Status);
        }
    }


    OutputToken.pBuffers = &OutputBuffer;
    OutputToken.cBuffers = 1;
    OutputToken.ulVersion = 0;
    OutputBuffer.pvBuffer = 0;
    OutputBuffer.cbBuffer = 0;
    OutputBuffer.BufferType = SECBUFFER_TOKEN;

    Status = AcceptSecurityContext (
                   &SrvExtensibleSecurityHandle,
                   NULL,
                   NULL,
                   ASC_REQ_INTEGRITY | ASC_REQ_CONFIDENTIALITY |
                        ASC_REQ_ALLOCATE_MEMORY | ASC_REQ_ALLOW_NULL_SESSION |
                        ASC_REQ_DELEGATE,
                   SECURITY_NATIVE_DREP,
                   Token,
                   &OutputToken,
                   &Attributes,
                   &Expiry);

     if (!NT_SUCCESS(Status)) {
        *BufferLength = 0;
        return(Status);
     }

     if (OutputBuffer.cbBuffer >=
            MaxBufferSize) {

         Status = STATUS_INVALID_BUFFER_SIZE;

         SrvLogServiceFailure( SRV_SVC_LSA_CALL_AUTH_PACKAGE, Status);

         *BufferLength = 0;

     } else {

         RtlCopyMemory(Buffer, OutputBuffer.pvBuffer, OutputBuffer.cbBuffer);

         *BufferLength = (USHORT) OutputBuffer.cbBuffer;

     }

#if DBG

    //
    // RDR or SRV is sending in a corrupt security blob to LSA -- need to
    // find out what the source is.
    //

    if( NT_SUCCESS(Status) )
    {
        if( (OutputBuffer.pvBuffer != NULL) &&
            (OutputBuffer.cbBuffer >= sizeof(DWORD))
            )
        {
            PDWORD pdwValidate = (DWORD*)OutputBuffer.pvBuffer;
            ASSERT( *pdwValidate != 0 );
        }
    }
#endif


     FreeContextBuffer(OutputBuffer.pvBuffer);

     return( Status );

}

VOID SRVFASTCALL
SrvInitializeSmbSecuritySignature(
    IN OUT PCONNECTION Connection,
    IN PUCHAR SessionKey OPTIONAL,
    IN PUCHAR ChallengeResponse,
    IN ULONG ChallengeResponseLength
    )
/*++

Routine Description:

    Initializes the security signature generator for a session by calling MD5Update
    on the session key, challenge response

Arguments:

    SessionKey - Either the LM or NT session key, depending on which
        password was used for authentication, must be at least 16 bytes
    ChallengeResponse - The challenge response used for authentication, must
        be at least 24 bytes

--*/
{
    RtlZeroMemory( &Connection->Md5Context, sizeof( Connection->Md5Context ) );

    MD5Init( &Connection->Md5Context );

    if( ARGUMENT_PRESENT( SessionKey ) ) {
        MD5Update( &Connection->Md5Context, SessionKey, USER_SESSION_KEY_LENGTH );
    }

    MD5Update( &Connection->Md5Context, ChallengeResponse, ChallengeResponseLength );

    Connection->SmbSecuritySignatureIndex = 0;
    Connection->SmbSecuritySignatureActive = TRUE;

    //
    // We don't know how to do RAW and security signatures
    //
    Connection->EnableRawIo = FALSE;

    IF_DEBUG( SECSIG ) {
        KdPrint(( "SRV: SMB sigs enabled for %wZ, conn %p, build %d\n",
                &Connection->ClientMachineNameString,
                Connection, Connection->PagedConnection->ClientBuildNumber ));
    }
}

VOID SRVFASTCALL
SrvAddSmbSecuritySignature(
    IN OUT PWORK_CONTEXT WorkContext,
    IN PMDL Mdl,
    IN ULONG SendLength
    )
/*++

Routine Description:

    Generates the next security signature

Arguments:

    WorkContext - the context to sign

Return Value:

    none.

--*/
{
    MD5_CTX Context;
    PSMB_HEADER Smb = MmGetSystemAddressForMdl( Mdl );

    IF_DEBUG( SECSIG ) {
        KdPrint(( "SRV: resp sig: cmd %x, index %u, len %d\n",
                Smb->Command, WorkContext->ResponseSmbSecuritySignatureIndex, SendLength ));
    }

#if DBG
    //
    // Put the index number right after the signature.  This allows us to figure out on the client
    //  side if we have a signature mismatch.
    //
    SmbPutUshort( &Smb->SecuritySignature[SMB_SECURITY_SIGNATURE_LENGTH],
        (USHORT)WorkContext->ResponseSmbSecuritySignatureIndex );

#endif

    //
    // Put the next index number into the SMB
    //
    SmbPutUlong( Smb->SecuritySignature, WorkContext->ResponseSmbSecuritySignatureIndex );
    RtlZeroMemory(  Smb->SecuritySignature + sizeof(ULONG),
                    SMB_SECURITY_SIGNATURE_LENGTH-sizeof(ULONG)
                 );

    //
    // Start out with our initial context
    //
    RtlCopyMemory( &Context, &WorkContext->Connection->Md5Context, sizeof( Context ) );

    //
    // Compute the signature for the SMB we're about to send
    //
    do {
        PCHAR SystemAddressForBuffer;

        ULONG len = MIN( SendLength, MmGetMdlByteCount( Mdl ) );

        SystemAddressForBuffer = MmGetSystemAddressForMdlSafe(Mdl,NormalPoolPriority);

        if (SystemAddressForBuffer == NULL) {
            // return without updating the security signature field. This will
            // in turn cause the client to reject the packet and tear down the
            // connection
            return;
        }

        MD5Update( &Context, SystemAddressForBuffer, len );

        SendLength -= len;

    } while( SendLength && (Mdl = Mdl->Next) != NULL );

    MD5Final( &Context );

    //
    // Put the signature into the SMB
    //
    RtlCopyMemory(
        Smb->SecuritySignature,
        Context.digest,
        SMB_SECURITY_SIGNATURE_LENGTH
        );
}

//
// Print the mismatched signature information to the debugger
//
VOID
SrvDumpSignatureError(
    IN PWORK_CONTEXT WorkContext,
    IN PUCHAR ExpectedSignature,
    IN PUCHAR ActualSignature,
    IN ULONG Length,
    IN ULONG ExpectedIndexNumber

    )
{
#if DBG
    DWORD i;
    PMDL Mdl = WorkContext->RequestBuffer->Mdl;
    ULONG requestLength = MIN( WorkContext->RequestBuffer->DataLength, 64 );
    PSMB_HEADER Smb = MmGetSystemAddressForMdl( Mdl );

    if( Smb->Command == SMB_COM_ECHO ) {
        return;
    }

    //
    // Security Signature Mismatch!
    //
    IF_DEBUG( ERRORS ) {
        KdPrint(( "SRV: Invalid security signature in request smb (cmd %X)", Smb->Command ));

        if( WorkContext->Connection && WorkContext->Connection->PagedConnection ) {
            KdPrint(( " from %wZ" ,
                        &WorkContext->Connection->ClientMachineNameString ));
        }
    }
    IF_DEBUG( SECSIG ) {
        KdPrint(( "\n\tExpected: " ));
        for( i = 0; i < SMB_SECURITY_SIGNATURE_LENGTH; i++ ) {
            KdPrint(( "%X ", ExpectedSignature[i] & 0xff ));
        }
        KdPrint(( "\n\tReceived: " ));
        for( i = 0; i < SMB_SECURITY_SIGNATURE_LENGTH; i++ ) {
            KdPrint(( "%X ", ActualSignature[i] & 0xff ));
        }
        KdPrint(( "\n\tLength %u, Expected Index Number %u\n", Length, ExpectedIndexNumber ));

        //
        // Dump out some of the errant SMB
        //
        i = 1;
        do {
            ULONG len = MIN( requestLength, Mdl->ByteCount );
            PBYTE p = MmGetSystemAddressForMdl( Mdl );
            PBYTE ep = (PBYTE)MmGetSystemAddressForMdl( Mdl ) + len;

            for( ; p < ep; p++, i++ ) {
                KdPrint(("%2.2x ", (*p) & 0xff ));
                if( !(i%32) ) {
                    KdPrint(( "\n" ));
                }
            }

            requestLength -= len;

        } while( requestLength != 0 && (Mdl = Mdl->Next) != NULL );

        KdPrint(( "\n" ));
    }

    IF_DEBUG( SECSIG ) {
        DbgPrint( "WorkContext: %p\n", WorkContext );
        DbgBreakPoint();
    }

#endif
}

BOOLEAN SRVFASTCALL
SrvCheckSmbSecuritySignature(
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    MD5_CTX Context;
    PMDL Mdl = WorkContext->RequestBuffer->Mdl;
    ULONG requestLength = WorkContext->RequestBuffer->DataLength;
    CHAR SavedSignature[ SMB_SECURITY_SIGNATURE_LENGTH ];
    PSMB_HEADER Smb = MmGetSystemAddressForMdl( Mdl );
    ULONG len;

    //
    // Initialize the Context
    //
    RtlCopyMemory( &Context, &WorkContext->Connection->Md5Context, sizeof( Context ) );

    //
    // Save the signature that's presently in the SMB
    //
    RtlCopyMemory( SavedSignature, Smb->SecuritySignature, sizeof( SavedSignature ));

    //
    // Put the correct (expected) signature index into the buffer
    //
    SmbPutUlong( Smb->SecuritySignature, WorkContext->SmbSecuritySignatureIndex );
    RtlZeroMemory(  Smb->SecuritySignature + sizeof(ULONG),
                    SMB_SECURITY_SIGNATURE_LENGTH-sizeof(ULONG)
                 );

    //
    // Compute what the signature should be
    //
    do {

        len = MIN( requestLength, Mdl->ByteCount );

        MD5Update( &Context, MmGetSystemAddressForMdl( Mdl ), len );

        requestLength -= len;

    } while( requestLength != 0 && (Mdl = Mdl->Next) != NULL );

    MD5Final( &Context );

    //
    // Put the signature back
    //
    RtlCopyMemory( Smb->SecuritySignature, SavedSignature, sizeof( Smb->SecuritySignature ));

    //
    // Now compare them!
    //
    if( RtlCompareMemory( Context.digest, SavedSignature, sizeof( SavedSignature ) ) !=
        sizeof( SavedSignature ) ) {

        SrvDumpSignatureError(  WorkContext,
                                Context.digest,
                                SavedSignature,
                                WorkContext->RequestBuffer->DataLength,
                                WorkContext->SmbSecuritySignatureIndex
                              );
        return FALSE;

    }

    return TRUE;
}

VOID
SrvHashUserSessionKey(
    PCHAR SessionKey
    )
{
    ULONG i;
    HMACMD5_CTX Ctx;
    BYTE SSKeyHash[256] = {
        0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x20, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x20, 0x4b, 0x65, 0x79, 0x20, 0x55, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x79, 0x07,
        0x6e, 0x28, 0x2e, 0x69, 0x88, 0x10, 0xb3, 0xdb, 0x01, 0x55, 0x72, 0xfb, 0x74, 0x14, 0xfb, 0xc4,
        0xc5, 0xaf, 0x3b, 0x41, 0x65, 0x32, 0x17, 0xba, 0xa3, 0x29, 0x08, 0xc1, 0xde, 0x16, 0x61, 0x7e,
        0x66, 0x98, 0xa4, 0x0b, 0xfe, 0x06, 0x83, 0x53, 0x4d, 0x05, 0xdf, 0x6d, 0xa7, 0x51, 0x10, 0x73,
        0xc5, 0x50, 0xdc, 0x5e, 0xf8, 0x21, 0x46, 0xaa, 0x96, 0x14, 0x33, 0xd7, 0x52, 0xeb, 0xaf, 0x1f,
        0xbf, 0x36, 0x6c, 0xfc, 0xb7, 0x1d, 0x21, 0x19, 0x81, 0xd0, 0x6b, 0xfa, 0x77, 0xad, 0xbe, 0x18,
        0x78, 0xcf, 0x10, 0xbd, 0xd8, 0x78, 0xf7, 0xd3, 0xc6, 0xdf, 0x43, 0x32, 0x19, 0xd3, 0x9b, 0xa8,
        0x4d, 0x9e, 0xaa, 0x41, 0xaf, 0xcb, 0xc6, 0xb9, 0x34, 0xe7, 0x48, 0x25, 0xd4, 0x88, 0xc4, 0x51,
        0x60, 0x38, 0xd9, 0x62, 0xe8, 0x8d, 0x5b, 0x83, 0x92, 0x7f, 0xb5, 0x0e, 0x1c, 0x2d, 0x06, 0x91,
        0xc3, 0x75, 0xb3, 0xcc, 0xf8, 0xf7, 0x92, 0x91, 0x0b, 0x3d, 0xa1, 0x10, 0x5b, 0xd5, 0x0f, 0xa8,
        0x3f, 0x5d, 0x13, 0x83, 0x0a, 0x6b, 0x72, 0x93, 0x14, 0x59, 0xd5, 0xab, 0xde, 0x26, 0x15, 0x6d,
        0x60, 0x67, 0x71, 0x06, 0x6e, 0x3d, 0x0d, 0xa7, 0xcb, 0x70, 0xe9, 0x08, 0x5c, 0x99, 0xfa, 0x0a,
        0x5f, 0x3d, 0x44, 0xa3, 0x8b, 0xc0, 0x8d, 0xda, 0xe2, 0x68, 0xd0, 0x0d, 0xcd, 0x7f, 0x3d, 0xf8,
        0x73, 0x7e, 0x35, 0x7f, 0x07, 0x02, 0x0a, 0xb5, 0xe9, 0xb7, 0x87, 0xfb, 0xa1, 0xbf, 0xcb, 0x32,
        0x31, 0x66, 0x09, 0x48, 0x88, 0xcc, 0x18, 0xa3, 0xb2, 0x1f, 0x1f, 0x1b, 0x90, 0x4e, 0xd7, 0xe1
    };

    ASSERT( MSV1_0_USER_SESSION_KEY_LENGTH == MD5DIGESTLEN );

    HMACMD5Init( &Ctx, SessionKey, MSV1_0_USER_SESSION_KEY_LENGTH );
    HMACMD5Update( &Ctx, SSKeyHash, 256 );
    HMACMD5Final( &Ctx, SessionKey );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\blkendp.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blkendp.c

Abstract:

    This module implements routines for managing endpoint blocks.

Author:

    Chuck Lenzmeier (chuckl) 4-Oct-1989

Revision History:

--*/

#include "precomp.h"
#include "blkendp.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKENDP

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateEndpoint )
#pragma alloc_text( PAGE, SrvCheckAndReferenceEndpoint )
#pragma alloc_text( PAGE, SrvCloseEndpoint )
#pragma alloc_text( PAGE, SrvDereferenceEndpoint )
#pragma alloc_text( PAGE, SrvFreeEndpoint )
#pragma alloc_text( PAGE, SrvReferenceEndpoint )
#pragma alloc_text( PAGE, SrvFindNamedEndpoint )
#endif
#if 0
NOT PAGEABLE -- EmptyFreeConnectionList
NOT PAGEABLE -- WalkConnectionTable
#endif


VOID
SrvAllocateEndpoint (
    OUT PENDPOINT *Endpoint,
    IN PUNICODE_STRING NetworkName,
    IN PUNICODE_STRING TransportName,
    IN PANSI_STRING TransportAddress,
    IN PUNICODE_STRING DomainName
    )

/*++

Routine Description:

    This function allocates an Endpoint Block from the system nonpaged
    pool.

Arguments:

    Endpoint - Returns a pointer to the endpoint block, or NULL if no
        pool was available.

    NetworkName - Supplies a pointer to the network name (e.g., NET1).

    TransportName - The fully qualified name of the transport device.
        For example, "\Device\Nbf".

    TransportAddress - The fully qualified address (or name ) of the
        server's endpoint.  This name is used exactly as specified.  For
        NETBIOS-compatible networks, the caller must upcase and
        blank-fill the name.  E.g., "\Device\Nbf\NTSERVERbbbbbbbb".

    DomainName - the domain being serviced by this endpoint

Return Value:

    None.

--*/

{
    CLONG length;
    PENDPOINT endpoint;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Attempt to allocate from nonpaged pool.
    //

    length = sizeof(ENDPOINT) +
                NetworkName->Length + sizeof(*NetworkName->Buffer) +
                TransportName->Length + sizeof(*TransportName->Buffer) +
                TransportAddress->Length + sizeof(*TransportAddress->Buffer) +
                RtlOemStringToUnicodeSize( TransportAddress ) +
                DNLEN * sizeof( *DomainName->Buffer ) +
                DNLEN + sizeof(CHAR);

    endpoint = ALLOCATE_NONPAGED_POOL( length, BlockTypeEndpoint );
    *Endpoint = endpoint;

    if ( endpoint == NULL ) {

        INTERNAL_ERROR (
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateEndpoint: Unable to allocate %d bytes from nonpaged "
                "pool.",
            length,
            NULL
            );

        return;
    }

    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvAllocateEndpoint: Allocated endpoint at %p\n",
                    endpoint );
    }

    //
    // Initialize the endpoint block.  Zero it first.
    //

    RtlZeroMemory( endpoint, length );

    SET_BLOCK_TYPE_STATE_SIZE( endpoint, BlockTypeEndpoint, BlockStateActive, length );
    endpoint->BlockHeader.ReferenceCount = 2;       // allow for Active status
                                                    //  and caller's pointer

    //
    // Allocate connection table.
    //

    SrvAllocateTable(
        &endpoint->ConnectionTable,
        6, // !!!
        TRUE
        );
    if ( endpoint->ConnectionTable.Table == NULL ) {
        DEALLOCATE_NONPAGED_POOL( endpoint );
        *Endpoint = NULL;
        return;
    }

    InitializeListHead( &endpoint->FreeConnectionList );
#if SRVDBG29
    UpdateConnectionHistory( "INIT", endpoint, NULL );
#endif

    //
    // Copy the network name, transport name, and server address, and domain
    // name into the block.
    //

    endpoint->NetworkName.Length = NetworkName->Length;
    endpoint->NetworkName.MaximumLength =
            (SHORT)(NetworkName->Length + sizeof(*NetworkName->Buffer));
    endpoint->NetworkName.Buffer = (PWCH)(endpoint + 1);
    RtlCopyMemory(
        endpoint->NetworkName.Buffer,
        NetworkName->Buffer,
        NetworkName->Length
        );

    endpoint->TransportName.Length = TransportName->Length;
    endpoint->TransportName.MaximumLength =
            (SHORT)(TransportName->Length + sizeof(*TransportName->Buffer));
    endpoint->TransportName.Buffer =
                            (PWCH)((PCHAR)endpoint->NetworkName.Buffer +
                                    endpoint->NetworkName.MaximumLength);
    RtlCopyMemory(
        endpoint->TransportName.Buffer,
        TransportName->Buffer,
        TransportName->Length
        );

    endpoint->ServerName.MaximumLength = (USHORT)RtlOemStringToUnicodeSize( TransportAddress );
    endpoint->ServerName.Length = 0;
    endpoint->ServerName.Buffer = endpoint->TransportName.Buffer +
                                    endpoint->TransportName.MaximumLength / sizeof( WCHAR );

    endpoint->TransportAddress.Length = TransportAddress->Length;
    endpoint->TransportAddress.MaximumLength =
                                (SHORT)(TransportAddress->Length + 1);
    endpoint->TransportAddress.Buffer =
                            (PCHAR)endpoint->ServerName.Buffer +
                                    endpoint->ServerName.MaximumLength;
    RtlCopyMemory(
        endpoint->TransportAddress.Buffer,
        TransportAddress->Buffer,
        TransportAddress->Length
        );

    status = RtlOemStringToUnicodeString( &endpoint->ServerName, TransportAddress, FALSE );

    if (!NT_SUCCESS(status)) {
        DbgPrint("SRv ENDPOINT Name translation failed status %lx\n",status);
        KdPrint(("SRv ENDPOINT Name translation failed status %lx\n",status));
    }

    //
    // Trim the trailing blanks off the end of servername
    //
    while( endpoint->ServerName.Length &&
        endpoint->ServerName.Buffer[ (endpoint->ServerName.Length / sizeof(WCHAR))-1 ] == L' ' ) {

        endpoint->ServerName.Length -= sizeof( WCHAR );
    }

    endpoint->DomainName.Length = DomainName->Length;
    endpoint->DomainName.MaximumLength =  DNLEN * sizeof( *endpoint->DomainName.Buffer );
    endpoint->DomainName.Buffer = (PWCH)((PCHAR)endpoint->TransportAddress.Buffer +
                                         TransportAddress->MaximumLength);
    RtlCopyMemory(
        endpoint->DomainName.Buffer,
        DomainName->Buffer,
        DomainName->Length
    );

    endpoint->OemDomainName.Length = (SHORT)RtlUnicodeStringToOemSize( DomainName );
    endpoint->OemDomainName.MaximumLength = DNLEN + sizeof( CHAR );
    endpoint->OemDomainName.Buffer = (PCHAR)endpoint->DomainName.Buffer +
                                     endpoint->DomainName.MaximumLength;

    status = RtlUnicodeStringToOemString(
                &endpoint->OemDomainName,
                &endpoint->DomainName,
                FALSE     // Do not allocate the OEM string
                );
    ASSERT( NT_SUCCESS(status) );


    //
    // Initialize the network address field.
    //

    endpoint->NetworkAddress.Buffer = endpoint->NetworkAddressData;
    endpoint->NetworkAddress.Length = sizeof( endpoint->NetworkAddressData ) -
                                      sizeof(endpoint->NetworkAddressData[0]);
    endpoint->NetworkAddress.MaximumLength = sizeof( endpoint->NetworkAddressData );

    //
    // Increment the count of endpoints in the server.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );
    SrvEndpointCount++;

    // If an endpoint is coming back after a NIC disconnect, reset the event
    if( SrvEndpointCount == 1 )
    {
        KeResetEvent( &SrvEndpointEvent );
    }

    RELEASE_LOCK( &SrvEndpointLock );

    INITIALIZE_REFERENCE_HISTORY( endpoint );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.EndpointInfo.Allocations );

    return;

} // SrvAllocateEndpoint


BOOLEAN SRVFASTCALL
SrvCheckAndReferenceEndpoint (
    PENDPOINT Endpoint
    )

/*++

Routine Description:

    This function atomically verifies that an endpoint is active and
    increments the reference count on the endpoint if it is.

Arguments:

    Endpoint - Address of endpoint

Return Value:

    BOOLEAN - Returns TRUE if the endpoint is active, FALSE otherwise.

--*/

{
    PAGED_CODE( );

    //
    // Acquire the lock that guards the endpoint's state field.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    //
    // If the endpoint is active, reference it and return TRUE.
    //

    if ( GET_BLOCK_STATE(Endpoint) == BlockStateActive ) {

        SrvReferenceEndpoint( Endpoint );

        RELEASE_LOCK( &SrvEndpointLock );

        return TRUE;

    }

    //
    // The endpoint isn't active.  Return FALSE.
    //

    RELEASE_LOCK( &SrvEndpointLock );

    return FALSE;

} // SrvCheckAndReferenceEndpoint


VOID
SrvCloseEndpoint (
    IN PENDPOINT Endpoint
    )

/*++

Routine Description:

    This function closes a transport endpoint.

    *** This function must be called with SrvEndpointLock held exactly
        once.  The lock is released on exit.

Arguments:

    Endpoint - Supplies a pointer to an Endpoint Block

Return Value:

    None.

--*/

{
    USHORT index;
    PCONNECTION connection;

    PAGED_CODE( );

    ASSERT( ExIsResourceAcquiredExclusiveLite(&RESOURCE_OF(SrvEndpointLock)) );

    if ( GET_BLOCK_STATE(Endpoint) == BlockStateActive ) {

        IF_DEBUG(BLOCK1) SrvPrint1( "Closing endpoint at %p\n", Endpoint );

        SET_BLOCK_STATE( Endpoint, BlockStateClosing );

        //
        // Close all active connections.
        //

        index = (USHORT)-1;

        while ( TRUE ) {

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            connection = WalkConnectionTable( Endpoint, &index );
            if ( connection == NULL ) {
                break;
            }

            //
            // We don't want to hold the endpoint lock while we close the
            // connection (this causes lock level problems).  Since we
            // already have a referenced pointer to the connection, this
            // is safe.
            //

            RELEASE_LOCK( &SrvEndpointLock );

#if SRVDBG29
            UpdateConnectionHistory( "CEND", Endpoint, connection );
#endif
            connection->DisconnectReason = DisconnectEndpointClosing;
            SrvCloseConnection( connection, FALSE );

            ACQUIRE_LOCK( &SrvEndpointLock );

            SrvDereferenceConnection( connection );

        }

        //
        // Close all free connections.
        //

        EmptyFreeConnectionList( Endpoint );

        //
        // We don't need to hold the endpoint lock anymore.
        //

        RELEASE_LOCK( &SrvEndpointLock );

        //
        // Close the endpoint file handle.  This causes all pending
        // requests to be aborted.  It also deregisters all event
        // handlers.
        //
        // *** Note that we have a separate reference to the file
        //     object, in addition to the handle.  We don't release that
        //     reference until all activity on the endpoint has ceased
        //     (in SrvDereferenceEndpoint).
        //

        SRVDBG_RELEASE_HANDLE( Endpoint->EndpointHandle, "END", 2, Endpoint );
        SrvNtClose( Endpoint->EndpointHandle, FALSE );
        if ( Endpoint->IsConnectionless ) {
            SRVDBG_RELEASE_HANDLE( Endpoint->NameSocketHandle, "END", 2, Endpoint );
            SrvNtClose( Endpoint->NameSocketHandle, FALSE );
        }

        //
        // Dereference the endpoint (to indicate that it's no longer
        // open).
        //

        SrvDereferenceEndpoint( Endpoint );

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.EndpointInfo.Closes );

    } else {

        RELEASE_LOCK( &SrvEndpointLock );

    }

    return;

} // SrvCloseEndpoint


VOID SRVFASTCALL
SrvDereferenceEndpoint (
    IN PENDPOINT Endpoint
    )

/*++

Routine Description:

    This function decrements the reference count on an endpoint.  If the
    reference count goes to zero, the endpoint block is deleted.

Arguments:

    Endpoint - Address of endpoint

Return Value:

    None.

--*/

{
    ULONG newEndpointCount;

    PAGED_CODE( );

    //
    // Enter a critical section and decrement the reference count on the
    // block.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Dereferencing endpoint %p; old refcnt %lx\n",
                    Endpoint, Endpoint->BlockHeader.ReferenceCount );
    }

    ASSERT( GET_BLOCK_TYPE( Endpoint ) == BlockTypeEndpoint );
    ASSERT( (LONG)Endpoint->BlockHeader.ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( Endpoint, TRUE );

    if ( --Endpoint->BlockHeader.ReferenceCount == 0 ) {

        //
        // The new reference count is 0, meaning that it's time to
        // delete this block.
        //

        ASSERT( GET_BLOCK_STATE(Endpoint) != BlockStateActive );

        //
        // Decrement the count of endpoints in the server.  If the new
        // count is zero, set the endpoint event.
        //

        ASSERT( SrvEndpointCount >= 1 );

        newEndpointCount = --SrvEndpointCount;

        if ( newEndpointCount == 0 ) {
            KeSetEvent( &SrvEndpointEvent, 0, FALSE );
        }

        RELEASE_LOCK( &SrvEndpointLock );

        //
        // Remove the endpoint from the global list of endpoints.
        //

        SrvRemoveEntryOrderedList( &SrvEndpointList, Endpoint );

        //
        // Dereference the file object pointer.  (The handle to the file
        // object was closed in SrvCloseEndpoint.)
        //

        ObDereferenceObject( Endpoint->FileObject );
        if ( Endpoint->IsConnectionless ) {
            ObDereferenceObject( Endpoint->NameSocketFileObject );
        }

        //
        // Free the endpoint block's storage.
        //

        SrvFreeEndpoint( Endpoint );

    } else {

        RELEASE_LOCK( &SrvEndpointLock );

    }

    return;

} // SrvDereferenceEndpoint


VOID
SrvFreeEndpoint (
    IN PENDPOINT Endpoint
    )

/*++

Routine Description:

    This function returns an Endpoint Block to the system nonpaged pool.

Arguments:

    Endpoint - Address of endpoint

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( Endpoint, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG Endpoint->BlockHeader.ReferenceCount = (ULONG)-1;
    TERMINATE_REFERENCE_HISTORY( Endpoint );

    if ( Endpoint->IpxMaxPacketSizeArray != NULL ) {
        FREE_HEAP( Endpoint->IpxMaxPacketSizeArray );
    }

    if ( Endpoint->ConnectionTable.Table != NULL ) {
        SrvFreeTable( &Endpoint->ConnectionTable );
    }

    DEALLOCATE_NONPAGED_POOL( Endpoint );
    IF_DEBUG(HEAP) SrvPrint1( "SrvFreeEndpoint: Freed endpoint block at %p\n", Endpoint );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.EndpointInfo.Frees );

    return;

} // SrvFreeEndpoint


VOID
SrvReferenceEndpoint (
    PENDPOINT Endpoint
    )

/*++

Routine Description:

    This function increments the reference count on an endpoint block.

Arguments:

    Endpoint - Address of endpoint

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Enter a critical section and increment the reference count on the
    // endpoint.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    ASSERT( (LONG)Endpoint->BlockHeader.ReferenceCount > 0 );
    ASSERT( GET_BLOCK_TYPE(Endpoint) == BlockTypeEndpoint );
    ASSERT( GET_BLOCK_STATE(Endpoint) == BlockStateActive );
    UPDATE_REFERENCE_HISTORY( Endpoint, FALSE );

    Endpoint->BlockHeader.ReferenceCount++;

    IF_DEBUG(REFCNT) SrvPrint2( "Referencing endpoint %p; new refcnt %lx\n",
            Endpoint, Endpoint->BlockHeader.ReferenceCount );

    RELEASE_LOCK( &SrvEndpointLock );

    return;

} // SrvReferenceEndpoint

BOOLEAN
SrvFindNamedEndpoint(
    IN PUNICODE_STRING ServerName,
    OUT PBOOLEAN RemapPipeNames OPTIONAL
)
/*++

Routine Description:

    This routine returns TRUE of any endpoint is supporting 'ServerName'.

    Additionally, set the RemapPipeNames variable from the found endpoint.

--*/
{
    PLIST_ENTRY listEntry;
    PENDPOINT endpoint = NULL;

    PAGED_CODE( );

    if( ARGUMENT_PRESENT( RemapPipeNames ) ) {
        *RemapPipeNames = FALSE;
    }

    //
    // Find an endpoint block supporting the specified name.
    //

    ACQUIRE_LOCK_SHARED( &SrvEndpointLock );

    for( listEntry = SrvEndpointList.ListHead.Flink;
         listEntry != &SrvEndpointList.ListHead;
         endpoint = NULL, listEntry = listEntry->Flink ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        //
        // Skip any inappropriate endpoints
        //
        if( GET_BLOCK_STATE( endpoint ) != BlockStateActive ||
            endpoint->IsConnectionless ||
            (ARGUMENT_PRESENT( RemapPipeNames ) && endpoint->IsNoNetBios) ) {

            continue;
        }

        //
        // See if this endpoint literally matches the name we're looking for
        //
        if( RtlEqualUnicodeString( ServerName, &endpoint->ServerName, TRUE ) ) {
            break;
        }

        //
        // We might have a case where the ServerName is something like
        //      server.dns.company.com
        //  but the endpoint netbios name is only 'server'.  We should match this
        //
        if( endpoint->ServerName.Length < ServerName->Length ) {
            UNICODE_STRING shortServerName;

            shortServerName = *ServerName;
            shortServerName.Length = endpoint->ServerName.Length;

            if (RtlEqualUnicodeString( &endpoint->ServerName, &shortServerName, TRUE)) {
                if (endpoint->ServerName.Length < ((NETBIOS_NAME_LEN - 1) * sizeof(WCHAR))) {
                    if (ServerName->Buffer[ shortServerName.Length / sizeof( WCHAR ) ] == L'.') {
                        break;
                    }
                } else {
                    if (endpoint->ServerName.Length == (NETBIOS_NAME_LEN - 1) * sizeof(WCHAR)) {
                        break;
                    }
                }
            }
        }

        //
        // See if this endpoint domain name literally matches the name we're
        // looking for. The following two tests against the domain name are
        // required to cover the case when there are certain components that
        // use the domain name to talk to the server. Given the way name resolution
        // records are setup this used to work before this checkin. This change
        // breaks them. These tests provide us the backward compatibility.
        //
        if( RtlEqualUnicodeString( ServerName, &endpoint->DomainName, TRUE ) ) {
            break;
        }

        //
        // We might have a case where the ServerName is something like
        //      server.dns.company.com
        //  but the endpoint netbios name is only 'server'.  We should match this
        //

        if( endpoint->DomainName.Length < ServerName->Length ) {
            UNICODE_STRING shortServerName;

            shortServerName = *ServerName;
            shortServerName.Length = endpoint->DomainName.Length;

            if (RtlEqualUnicodeString( &endpoint->DomainName, &shortServerName, TRUE)) {
                if (endpoint->DomainName.Length <= (NETBIOS_NAME_LEN * sizeof(WCHAR))) {
                    if (ServerName->Buffer[ shortServerName.Length / sizeof( WCHAR ) ] == L'.') {
                        break;
                    }
                } else {
                    if (endpoint->DomainName.Length == (NETBIOS_NAME_LEN - 1) * sizeof(WCHAR)) {
                        break;
                    }
                }
            }
        }

    }

    if( ARGUMENT_PRESENT( RemapPipeNames ) && endpoint != NULL ) {
        *RemapPipeNames = ( endpoint->RemapPipeNames == TRUE );
    }

    RELEASE_LOCK( &SrvEndpointLock );

    return endpoint != NULL;
}


VOID
EmptyFreeConnectionList (
    IN PENDPOINT Endpoint
    )
{
    PCONNECTION connection;
    PLIST_ENTRY listEntry;
    KIRQL oldIrql;

    //
    // *** In order to synchronize with the TDI connect handler in
    //     the FSD, which only uses a spin lock to serialize access
    //     to the free connection list (and does not check the
    //     endpoint state), we need to atomically capture the list
    //     head and empty the list.
    //

    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

    listEntry = Endpoint->FreeConnectionList.Flink;
    InitializeListHead( &Endpoint->FreeConnectionList );
#if SRVDBG29
    UpdateConnectionHistory( "CLOS", Endpoint, NULL );
#endif

    RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

    while ( listEntry != &Endpoint->FreeConnectionList ) {

        connection = CONTAINING_RECORD(
                        listEntry,
                        CONNECTION,
                        EndpointFreeListEntry
                        );

        listEntry = listEntry->Flink;
        SrvCloseFreeConnection( connection );

    }

    return;

} // EmptyFreeConnectionList


PCONNECTION
WalkConnectionTable (
    IN PENDPOINT Endpoint,
    IN OUT PUSHORT Index
    )
{
    USHORT i;
    PTABLE_HEADER tableHeader;
    PCONNECTION connection;
    KIRQL oldIrql;

    ACQUIRE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), &oldIrql );
    for ( i = 1; i < ENDPOINT_LOCK_COUNT ; i++ ) {
        ACQUIRE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
    }

    tableHeader = &Endpoint->ConnectionTable;

    for ( i = *Index + 1; i < tableHeader->TableSize; i++ ) {

        connection = (PCONNECTION)tableHeader->Table[i].Owner;
        if ( (connection != NULL) &&
             (GET_BLOCK_STATE(connection) == BlockStateActive) ) {
            *Index = i;
            SrvReferenceConnectionLocked( connection );
            goto exit;
        }
    }
    connection = NULL;

exit:

    for ( i = ENDPOINT_LOCK_COUNT-1 ; i > 0  ; i-- ) {
        RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
    }
    RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );

    return connection;
} // WalkConnectionTable
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\blkfile.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blkfile.c

Abstract:

    This module implements routines for managing various kinds of file
    control blocks.

    Master File Control Block (MFCB) -- one per named file that is open
        at least once.  Used to support compatibility mode and oplocks.

    Local File Control Block (LFCB) -- one for each local open instance.
        Represents local file object/handle.  There may be multiple
        LFCBs linked to a single MFCB.

    Remote File Control Block (RFCB) -- one for each remote open instance.
        Represents remote FID.  There is usually one RFCB per LFCB, but
        multiple compatibility mode RFCBs may be linked to a single LFCB.
        Multiple remote FCB opens for a single file from a single session
        are folded into one RFCB, because old DOS redirectors only send
        one close.

Author:

    Chuck Lenzmeier (chuckl) 4-Oct-1989

Revision History:

--*/

#include "precomp.h"
#include "blkfile.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKFILE

//
// Get the address of the SRV_LOCK which corresponds to FileNameHashValue bucket
//
#define MFCB_LOCK_ADDR( _hash ) SrvMfcbHashTable[ HASH_TO_MFCB_INDEX( _hash ) ].Lock

//
// Forward declarations of local functions.
//
VOID
AllocateMfcb(
    OUT PMFCB *Mfcb,
    IN PUNICODE_STRING FileName,
    IN ULONG FileNameHashValue,
    IN PWORK_CONTEXT WorkContext
    );

STATIC
VOID
CloseRfcbInternal (
    IN PRFCB Rfcb,
    IN KIRQL OldIrql
    );

STATIC
VOID
DereferenceRfcbInternal (
    IN PRFCB Rfcb,
    IN KIRQL OldIrql
    );

STATIC
VOID
ReferenceRfcbInternal (
    PRFCB Rfcb,
    IN KIRQL OldIrql
    );

STATIC
VOID
UnlinkLfcbFromMfcb (
    IN PLFCB Lfcb
    );

STATIC
VOID
UnlinkRfcbFromLfcb (
    IN PRFCB Rfcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AllocateMfcb )
#pragma alloc_text( PAGE, SrvCreateMfcb )
#pragma alloc_text( PAGE, SrvFindMfcb )
#pragma alloc_text( PAGE, SrvFreeMfcb )
#pragma alloc_text( PAGE, UnlinkLfcbFromMfcb )
#pragma alloc_text( PAGE, SrvDereferenceMfcb )
#pragma alloc_text( PAGE, SrvAllocateLfcb )
#pragma alloc_text( PAGE, SrvDereferenceLfcb )
#pragma alloc_text( PAGE, SrvFreeLfcb )
#pragma alloc_text( PAGE, UnlinkRfcbFromLfcb )
#pragma alloc_text( PAGE, SrvAllocateRfcb )
#pragma alloc_text( PAGE, SrvCloseRfcbsOnLfcb )
#pragma alloc_text( PAGE, SrvFreeRfcb )
#pragma alloc_text( PAGE8FIL, SrvCheckAndReferenceRfcb )
#pragma alloc_text( PAGE8FIL, SrvCloseRfcb )
#pragma alloc_text( PAGE8FIL, CloseRfcbInternal )
#pragma alloc_text( PAGE8FIL, SrvCompleteRfcbClose )
//#pragma alloc_text( PAGE8FIL, SrvDereferenceRfcb )
//#pragma alloc_text( PAGE8FIL, DereferenceRfcbInternal )
#pragma alloc_text( PAGE8FIL, SrvReferenceRfcb )
#pragma alloc_text( PAGE8FIL, ReferenceRfcbInternal )
#pragma alloc_text( PAGE8FIL, SrvCloseCachedRfcb )
//#pragma alloc_text( PAGE8FIL, SrvCloseCachedRfcbsOnConnection )
#pragma alloc_text( PAGE8FIL, SrvCloseCachedRfcbsOnLfcb )
#endif
#if 0
#pragma alloc_text( PAGECONN, SrvCloseRfcbsOnSessionOrPid )
#pragma alloc_text( PAGECONN, SrvCloseRfcbsOnTree )
#pragma alloc_text( PAGECONN, SrvFindCachedRfcb )
#endif

//
// Master File Control Block (MFCB) routines.
//
VOID
AllocateMfcb (
    OUT PMFCB *Mfcb,
    IN PUNICODE_STRING FileName,
    IN ULONG FileNameHashValue,
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function allocates an MFCB from pool and places it in the hash table.

    The bucket's Lock must be held exclusive when this is called!!

Arguments:

    Mfcb - Returns a pointer to the MFCB, or NULL if no space was
        available.

Return Value:

    None.

--*/

{
    CLONG blockLength;
    PMFCB mfcb;
    PNONPAGED_MFCB nonpagedMfcb = NULL;
    PWORK_QUEUE queue = WorkContext->CurrentWorkQueue;
    PLIST_ENTRY listHead;
    PSLIST_ENTRY listEntry;

    PAGED_CODE();

    //
    // Attempt to allocate from pool.
    //

    blockLength = sizeof(MFCB) + FileName->Length + sizeof(WCHAR);

    mfcb = ALLOCATE_HEAP( blockLength, BlockTypeMfcb );
    *Mfcb = mfcb;

    if ( mfcb == NULL ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "AllocateMfcb: Unable to allocate %d bytes from pool\n",
            blockLength,
            NULL
            );

        // The caller will log the error

        return;
    }

    nonpagedMfcb = (PNONPAGED_MFCB)InterlockedExchangePointer(
                                    &queue->CachedFreeMfcb,
                                    nonpagedMfcb );

    if( nonpagedMfcb == NULL ) {

        listEntry = ExInterlockedPopEntrySList(
                        &queue->MfcbFreeList,
                        &queue->SpinLock
                        );

        if( listEntry != NULL ) {

            InterlockedDecrement( &queue->FreeMfcbs );
            nonpagedMfcb = CONTAINING_RECORD( listEntry, NONPAGED_MFCB, SingleListEntry );

        } else {

            nonpagedMfcb = ALLOCATE_NONPAGED_POOL(
                                    sizeof(NONPAGED_MFCB),
                                    BlockTypeNonpagedMfcb );

            if ( nonpagedMfcb == NULL ) {

                INTERNAL_ERROR(
                    ERROR_LEVEL_EXPECTED,
                    "AllocateMfcb: Unable to allocate %d bytes from pool\n",
                    sizeof(NONPAGED_MFCB),
                    NULL
                    );

                // The caller will log the error

                FREE_HEAP( mfcb );
                *Mfcb = NULL;
                return;
            }

            IF_DEBUG(HEAP) {
                KdPrint(( "AllocateMfcb: Allocated MFCB at 0x%p\n", mfcb ));
            }

            nonpagedMfcb->Type = BlockTypeNonpagedMfcb;
        }
    }

    nonpagedMfcb->PagedBlock = mfcb;

    RtlZeroMemory( mfcb, blockLength );

    mfcb->NonpagedMfcb = nonpagedMfcb;

    //
    // Initialize the MFCB.
    //

    SET_BLOCK_TYPE_STATE_SIZE( mfcb, BlockTypeMfcb, BlockStateClosing, blockLength );
    mfcb->BlockHeader.ReferenceCount = 1;

    InitializeListHead( &mfcb->LfcbList );
    INITIALIZE_LOCK( &nonpagedMfcb->Lock, MFCB_LOCK_LEVEL, "MfcbLock" );

    //
    // Store the filename as it was passed into us
    //
    mfcb->FileName.Length = FileName->Length;
    mfcb->FileName.MaximumLength = (SHORT)(FileName->Length + sizeof(WCHAR));
    mfcb->FileName.Buffer = (PWCH)(mfcb + 1);
    RtlCopyMemory( mfcb->FileName.Buffer, FileName->Buffer, FileName->Length );

    //
    // Store the hash value for the filename
    //
    mfcb->FileNameHashValue = FileNameHashValue;

    //
    // Store the SnapShot time if set
    //
    mfcb->SnapShotTime.QuadPart = WorkContext->SnapShotTime.QuadPart;

    INITIALIZE_REFERENCE_HISTORY( mfcb );

    //
    // Add it to the hash table
    //
    listHead = &SrvMfcbHashTable[ HASH_TO_MFCB_INDEX( FileNameHashValue ) ].List;
    InsertHeadList( listHead, &mfcb->MfcbHashTableEntry );

#if SRVCATCH
    {
        UNICODE_STRING baseName;
        UNICODE_STRING syscacheName = { 6, 6, L"cac" };

        SrvGetBaseFileName( FileName, &baseName );

        if( SrvCatch.Length ) {
            if( RtlCompareUnicodeString( &SrvCatch, &baseName, TRUE ) == 0 ) {
                mfcb->SrvCatch = 1;
            }
        }
        if( SrvCatchExt.Length && WorkContext->TreeConnect->Share->IsCatchShare ) {
            if( baseName.Length > 6 )
            {
                baseName.Buffer += (baseName.Length-6)>>1;
                baseName.Length = 6;
                if( RtlCompareUnicodeString( &SrvCatchExt, &baseName, TRUE ) == 0 ) {
                    mfcb->SrvCatch = 2;
                }
            }
        }
#if SYSCACHE_DEBUGGING
        else {
            if( baseName.Length >= 6 )
            {
                USHORT length = baseName.Length;
                baseName.Length = 6;
                if( RtlEqualUnicodeString( &baseName, &syscacheName, TRUE ) )
                {
                    mfcb->SrvCatch = -1;
                    baseName.Length = length;

                    IF_SYSCACHE() {
                        KdPrint(("MFCB %p (%wZ) for Syscache\n", mfcb, &baseName ));
                    }
                }
            }
        }
#endif // SYSCACHE_DEBUGGING
    }
#endif // SRVCATCH

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.MfcbInfo.Allocations );

    return;

} // AllocateMfcb


PMFCB
SrvCreateMfcb(
    IN PUNICODE_STRING FileName,
    IN PWORK_CONTEXT WorkContext,
    IN ULONG HashValue
    )

/*++

Routine Description:

    Called when a file is about to be opened.  Searches the Master File
    Table to see if the named file is already open.  If it isn't, a
    Master File Control Block is allocated and added to the list.

    *** The MFCB list lock must be held when this routine is called.  It
        remains held on exit.

    *** Note that the master file list CANNOT be walked to find and
        possibly delete open file instances.  This is because new
        instances are added to the list before the file is actually
        opened.  The connection file tables must be used to find "real"
        open file instances.

Arguments:

    FileName - Fully qualified name of file being opened.  If a new
        master file block is created, the string data is copied to that
        block, so the original data is no longer needed.

    HashValue - the pre-computed hash value for this filename

Return Value:

    PMFCB - Pointer to existing or newly created MFCB; NULL if unable
        allocate space for MFCB.

--*/

{
    PMFCB mfcb;
    PLIST_ENTRY listEntryRoot, listEntry;

    PAGED_CODE( );

    //
    // Search the Hash File List to determine whether the named file
    // is already open.
    //

    ASSERT( ExIsResourceAcquiredExclusiveLite( MFCB_LOCK_ADDR( HashValue )) );

    listEntryRoot = &SrvMfcbHashTable[ HASH_TO_MFCB_INDEX( HashValue ) ].List;

    for( listEntry = listEntryRoot->Flink;
         listEntry != listEntryRoot;
         listEntry = listEntry->Flink ) {

        mfcb = CONTAINING_RECORD( listEntry, MFCB, MfcbHashTableEntry );

        if( mfcb->FileNameHashValue == HashValue &&
            mfcb->FileName.Length == FileName->Length &&
            mfcb->SnapShotTime.QuadPart == WorkContext->SnapShotTime.QuadPart &&
            RtlEqualMemory( mfcb->FileName.Buffer,
                            FileName->Buffer,
                            FileName->Length ) ) {
                //
                // We've found a matching entry!
                //
                return mfcb;
        }
    }

    //
    // The named file is not yet open.  Allocate an MFCB
    //

    AllocateMfcb( &mfcb, FileName, HashValue, WorkContext );

    return mfcb;

} // SrvCreateMfcb


PMFCB
SrvFindMfcb(
    IN PUNICODE_STRING FileName,
    IN BOOLEAN CaseInsensitive,
    OUT PSRV_LOCK *Lock,
    OUT PULONG HashValue,
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Searches the Master File Table to see if the named file is already
    open, returning the address of an MFCB if it is.

    *** The MFCB list lock will be acquire exclusively whether or not
        this routine succeeds.  The address of the lock is placed in *Lock

Arguments:

    FileName - Fully qualified name of file being opened.

    CaseInsensitive - TRUE if the search should be case-insensitive.

    HashValue - if the MFCB was NOT found, *HashValue filled in with the hash
        value derived from the filename.  This can then be passed into
        SrvCreateMfcb later

Return Value:

    PMFCB - Pointer to existing created MFCB, if the named file is
        already open; NULL otherwise.

--*/

{
    PLIST_ENTRY listEntry, listEntryRoot;
    ULONG localHashValue;
    PMFCB mfcb;

    PAGED_CODE( );

    //
    // Search the Master File List to determine whether the named file
    // is already open.  If the length of the file name is zero, then
    // do not actually look in the list--the prefix routines do not
    // work with zero-length strings, and we know that we'll never
    // open a file with a name length == 0.
    //
    // !!! For SMB 4.0 (NT-NT), do we need to worry about share root
    //     directories?


    if ( FileName->Length == 0 ) {
        *HashValue = 0;
        *Lock = NULL;
        return NULL;
    }

    COMPUTE_STRING_HASH( FileName, &localHashValue );
    listEntryRoot = &SrvMfcbHashTable[ HASH_TO_MFCB_INDEX( localHashValue ) ].List;

    *Lock = MFCB_LOCK_ADDR( localHashValue );
    ACQUIRE_LOCK( *Lock );

    //
    // Search the Hash File List to determine whether the named file
    // is already open.
    //
    for( listEntry = listEntryRoot->Flink;
         listEntry != listEntryRoot;
         listEntry = listEntry->Flink ) {

        mfcb = CONTAINING_RECORD( listEntry, MFCB, MfcbHashTableEntry );

        if( mfcb->FileNameHashValue == localHashValue &&
            mfcb->FileName.Length == FileName->Length &&
            mfcb->SnapShotTime.QuadPart == WorkContext->SnapShotTime.QuadPart &&
            RtlEqualUnicodeString( &mfcb->FileName, FileName,CaseInsensitive)) {
                //
                // We've found a matching entry!
                //
                ASSERT( GET_BLOCK_TYPE(mfcb) == BlockTypeMfcb );
                ASSERT( GET_BLOCK_STATE(mfcb) == BlockStateClosing );

                mfcb->BlockHeader.ReferenceCount++;

                UPDATE_REFERENCE_HISTORY( mfcb, FALSE );

                IF_DEBUG(REFCNT) {
                    KdPrint(( "Referencing MFCB %p; new refcnt %lx\n",
                                mfcb, mfcb->BlockHeader.ReferenceCount ));
                }

                return mfcb;
        }
    }

    //
    // We didn't find the entry!  The file is not open
    //
    *HashValue = localHashValue;

    return NULL;

} // SrvFindMfcb


VOID
SrvFreeMfcb (
    IN PMFCB Mfcb
    )

/*++

Routine Description:

    This function returns an MFCB to the FSP heap.
    If you change this code, you should also look in FreeIdleWorkItems
        in scavengr.c

Arguments:

    Mfcb - Address of MFCB

Return Value:

    None.

--*/

{
    PWORK_QUEUE queue = PROCESSOR_TO_QUEUE();
    PNONPAGED_MFCB nonpagedMfcb = Mfcb->NonpagedMfcb;

    PAGED_CODE();

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( Mfcb, BlockTypeGarbage, BlockStateDead, -1 );
    TERMINATE_REFERENCE_HISTORY( Mfcb );

    //
    // Delete the lock on the MFCB.  The lock must not be held.
    //

    ASSERT( RESOURCE_OF(nonpagedMfcb->Lock).ActiveCount == 0 );
    DELETE_LOCK( &nonpagedMfcb->Lock );

    nonpagedMfcb = (PNONPAGED_MFCB)InterlockedExchangePointer(
                            &queue->CachedFreeMfcb,
                            nonpagedMfcb );

    if( nonpagedMfcb != NULL ) {
        //
        // This check allows for the possibility that FreeMfcbs might exceed
        // MaxFreeMfcbs, but it's fairly unlikely given the operation of kernel
        // queue objects.  But even so, it probably won't exceed it by much and
        // is really only advisory anyway.
        //
        if( queue->FreeMfcbs < queue->MaxFreeMfcbs ) {

            ExInterlockedPushEntrySList(
                &queue->MfcbFreeList,
                &nonpagedMfcb->SingleListEntry,
                &queue->SpinLock
            );

            InterlockedIncrement( &queue->FreeMfcbs );

        } else {

            DEALLOCATE_NONPAGED_POOL( nonpagedMfcb );
        }
    }

    FREE_HEAP( Mfcb );
    IF_DEBUG(HEAP) KdPrint(( "SrvFreeMfcb: Freed MFCB at 0x%p\n", Mfcb ));

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.MfcbInfo.Frees );

    return;

} // SrvFreeMfcb


VOID
UnlinkLfcbFromMfcb (
    IN PLFCB Lfcb
    )

/*++

Routine Description:

    This function unlinks an LFCB from its parent MFCB and decrements
    the MFCB's reference count.  If the count goes to zero, the MFCB
    is removed from the Master File Table and deleted.

    *** The MFCB lock must be held when this routine is called.  It
        is released before exit.

Arguments:

    Lfcb - Address of LFCB

Return Value:

    None.

--*/

{
    PMFCB mfcb = Lfcb->Mfcb;

    PAGED_CODE( );

    ASSERT( mfcb != NULL );

    ASSERT( ExIsResourceAcquiredExclusiveLite(&RESOURCE_OF(mfcb->NonpagedMfcb->Lock)) );

    //
    // Remove the LFCB from the MFCB's list.  Decrement the reference
    // count on the MFCB.  The MFCB lock must be released before
    // dereferencing the MFCB, because that may cause the MFCB to be
    // deleted.
    //

    SrvRemoveEntryList( &mfcb->LfcbList, &Lfcb->MfcbListEntry );

    RELEASE_LOCK( &mfcb->NonpagedMfcb->Lock );

    SrvDereferenceMfcb( mfcb );

    return;

} // UnlinkLfcbFromMfcb


VOID
SrvDereferenceMfcb (
    IN PMFCB Mfcb
    )

/*++

Routine Description:

    This function decrements the reference count for an MFCB.  If
    the reference count reaches zero, the block is freed.

    *** The MFCB lock (not the MFCB _list_ lock) must not be held when
        this routine is called, unless the caller has an extra reference
        to the MFCB, because otherwise this routine could destroy the
        MFCB and the lock.  Note that sequences beginning in DoDelete
        and SrvMoveFile and coming here via SrvCloseRfcbsOnLfcb cause
        this routine to be called with the MFCB lock held.

Arguments:

    Mfcb - A pointer to the MFCB

Return Value:

    None.

--*/

{
    PSRV_LOCK lock = MFCB_LOCK_ADDR( Mfcb->FileNameHashValue );

    PAGED_CODE( );

    IF_DEBUG(REFCNT) {
        KdPrint(( "Dereferencing MFCB %p; old refcnt %lx\n",
                    Mfcb, Mfcb->BlockHeader.ReferenceCount ));
    }

    //
    // Acquire the MFCB table lock.  This lock protects the reference
    // count on the MFCB.
    //

    ACQUIRE_LOCK( lock );

    ASSERT( GET_BLOCK_TYPE( Mfcb ) == BlockTypeMfcb );
    ASSERT( (LONG)Mfcb->BlockHeader.ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( Mfcb, TRUE );

    if ( --Mfcb->BlockHeader.ReferenceCount == 0 ) {

        //
        // This is the last reference to the MFCB.  Delete the block.
        // Unlink the MFCB from the Master File Table.
        //
        ASSERT( Mfcb->LfcbList.Flink == &Mfcb->LfcbList );

        RemoveEntryList( &Mfcb->MfcbHashTableEntry );

        RELEASE_LOCK( lock );

        //
        // Free the MFCB.  Note that SrvFreeMfcb deletes the MFCB's
        // lock.
        //

        SrvFreeMfcb( Mfcb );

    } else {

        RELEASE_LOCK( lock );

    }

} // SrvDereferenceMfcb


//
// Local File Control Block (LFCB) routines.
//

VOID
SrvAllocateLfcb (
    OUT PLFCB *Lfcb,
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function allocates an LFCB from pool.

Arguments:

    Lfcb - Returns a pointer to the LFCB, or NULL if no space was
        available.

Return Value:

    None.

--*/

{
    PLFCB lfcb = NULL;
    PWORK_QUEUE queue = WorkContext->CurrentWorkQueue;

    PAGED_CODE();

    //
    // Attempt to allocate from pool.
    //

    lfcb = ALLOCATE_HEAP( sizeof(LFCB), BlockTypeLfcb );
    *Lfcb = lfcb;

    if ( lfcb == NULL ) {

        ULONG size = sizeof( LFCB );

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateLfcb: Unable to allocate %d bytes from paged pool.",
            sizeof( LFCB ),
            NULL
            );

        // The caller will log the error

        return;
    }

    IF_DEBUG(HEAP) {
        KdPrint(( "SrvAllocateLfcb: Allocated LFCB at 0x%p\n", lfcb ));
    }

    //
    // Initialize the LFCB.  Zero it first.
    //

    RtlZeroMemory( lfcb, sizeof(LFCB) );

    //
    // Initialize the LFCB.
    //

    SET_BLOCK_TYPE_STATE_SIZE( lfcb, BlockTypeLfcb, BlockStateClosing, sizeof( LFCB ) );

    //
    // !!! Note that the block's reference count is set to 1 to account
    //     for the open handle.  No other reference is needed
    //     because 1) the LFCB is a temporary object, and 2) the
    //     caller (SrvAddOpenFileInstance) doesn't really need to
    //     reference the block, because it owns the appropriate lock
    //     for the entire time that it's doing its thing.
    //

    lfcb->BlockHeader.ReferenceCount = 1;

    InitializeListHead( &lfcb->RfcbList );

    INITIALIZE_REFERENCE_HISTORY( lfcb );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.LfcbInfo.Allocations );

    return;

} // SrvAllocateLfcb


VOID
SrvDereferenceLfcb (
    IN PLFCB Lfcb
    )

/*++

Routine Description:

    This function dereference the LFCB and frees the LFCB if the reference
    count reaches 0.

    *** The caller of this function must own the MFCB lock for the file.
        The lock is released by this function.

Arguments:

    Lfcb - The LFCB to dereference

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    ASSERT( ExIsResourceAcquiredExclusiveLite(&RESOURCE_OF(Lfcb->Mfcb->NonpagedMfcb->Lock)) );
    ASSERT( GET_BLOCK_TYPE( Lfcb ) == BlockTypeLfcb );
    ASSERT( (LONG)Lfcb->BlockHeader.ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( Lfcb, TRUE );

    if ( --Lfcb->BlockHeader.ReferenceCount == 0 ) {

        //
        // This is the last reference to the LFCB.  Unlink the
        // LFCB from the MFCB's list.
        //

        ASSERT( Lfcb->RfcbList.Flink == &Lfcb->RfcbList );
        ASSERT( Lfcb->HandleCount == 0 );

        IF_DEBUG( CREATE ) {
            KdPrint(( "SrvDereferenceLfcb: deref %wZ fileObject\n",
                &Lfcb->Mfcb->FileName ));
        }

        //
        // UnlinkLfcbFromMfcb will release the MFCB lock that we hold.
        //

        UnlinkLfcbFromMfcb( Lfcb );

        //
        // Dereference the file object.
        //

        ObDereferenceObject( Lfcb->FileObject );
        DEBUG Lfcb->FileObject = NULL;

        //
        // Decrement the count of open files on the session and tree
        // connect.
        //

        ACQUIRE_LOCK( &Lfcb->Connection->Lock );

        ASSERT( Lfcb->Session->CurrentFileOpenCount != 0 );
        Lfcb->Session->CurrentFileOpenCount--;

        ASSERT( Lfcb->TreeConnect->CurrentFileOpenCount != 0 );
        Lfcb->TreeConnect->CurrentFileOpenCount--;

        RELEASE_LOCK( &Lfcb->Connection->Lock );

        //
        // Dereference the tree connect, session, and connection that
        // the LFCB points to.
        //

        SrvDereferenceTreeConnect( Lfcb->TreeConnect );
        DEBUG Lfcb->TreeConnect = NULL;

        SrvDereferenceSession( Lfcb->Session );
        DEBUG Lfcb->Session = NULL;

        SrvDereferenceConnection( Lfcb->Connection );
        DEBUG Lfcb->Connection = NULL;

        //
        // Free the LFCB.
        //

        SrvFreeLfcb( Lfcb, PROCESSOR_TO_QUEUE() );

    } else {

        RELEASE_LOCK( &Lfcb->Mfcb->NonpagedMfcb->Lock );

    }

} // SrvDereferenceLfcb


VOID
SrvFreeLfcb (
    IN PLFCB Lfcb,
    IN PWORK_QUEUE queue
    )

/*++

Routine Description:

    This function returns an LFCB to the system nonpaged pool.
    If you change this routine, look also in FreeIdleWorkItems in scavengr.c

Arguments:

    Lfcb - Address of LFCB

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ASSERT ( Lfcb->HandleCount == 0 );

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( Lfcb, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG Lfcb->BlockHeader.ReferenceCount = (ULONG)-1;
    TERMINATE_REFERENCE_HISTORY( Lfcb );

    FREE_HEAP( Lfcb );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.LfcbInfo.Frees );

    IF_DEBUG(HEAP) KdPrint(( "SrvFreeLfcb: Freed LFCB at 0x%p\n", Lfcb ));

    return;

} // SrvFreeLfcb


VOID
UnlinkRfcbFromLfcb (
    IN PRFCB Rfcb
    )

/*++

Routine Description:

    This function unlinks an RFCB from its parent LFCB and decrements
    the LFCB's reference count.  If the count goes to zero, the LFCB
    is unlinked from its parent MFCB and deleted.

Arguments:

    Rfcb - Address of RFCB

Return Value:

    None.

--*/

{
    PLFCB lfcb = Rfcb->Lfcb;
    LARGE_INTEGER offset;
    HANDLE handle;

    PAGED_CODE( );

    UpdateRfcbHistory( Rfcb, 'klnu' );

    ASSERT( lfcb != NULL );

    if( Rfcb->PagedRfcb->IpxSmartCardContext ) {
        IF_DEBUG( SIPX ) {
            KdPrint(("Calling Smart Card Close for Rfcb %p\n", Rfcb ));
        }
        SrvIpxSmartCard.Close( Rfcb->PagedRfcb->IpxSmartCardContext );
    }

    //
    // Acquire the lock that guards access to the LFCB's RFCB list.
    //

    ACQUIRE_LOCK( &lfcb->Mfcb->NonpagedMfcb->Lock );

    //
    // Decrement the active RFCB count for the LFCB.  This must be here
    // instead of in SrvCloseRfcb because the MFCB lock must be held to
    // update the count.
    //

    --lfcb->Mfcb->ActiveRfcbCount;
    UPDATE_REFERENCE_HISTORY( lfcb, FALSE );

    //
    // Decrement the open handle count on the LFCB.
    //

    if ( --lfcb->HandleCount == 0 ) {

        handle = lfcb->FileHandle;

        //
        // Other SMB processors may still have a referenced pointer to
        // the LFCB.  Ensure that any attempt to use the file handle fails.
        //

        lfcb->FileHandle = 0;

        //
        // This was the last open RFCB referencing the LFCB.  Close the
        // file handle.
        //

        SRVDBG_RELEASE_HANDLE( handle, "FIL", 3, lfcb );

        IF_DEBUG( CREATE ) {
            KdPrint(( "UnlinkRfcbFromLfcb: rfcb %p, close handle for %wZ\n",
                Rfcb, &lfcb->Mfcb->FileName ));
        }

        SrvNtClose( handle, TRUE );

        //
        // If this is a print spool file, schedule the job on the
        // printer.
        //

        if ( Rfcb->ShareType == ShareTypePrint ) {
            SrvSchedulePrintJob(
                lfcb->TreeConnect->Share->Type.hPrinter,
                lfcb->JobId
                );
        }

        //
        // Release the open handle reference to the LFCB.  The open
        // lock is release by SrvDereferenceLfcb().  Note that this
        // releases the MFCB lock.
        //

        SrvDereferenceLfcb( lfcb );

    } else {

        //
        // Other RFCBs have references to the LFCB, so we can't close
        // the file yet.  (This must be a compatibility mode open.)
        // Release all locks taken out by the process that opened the
        // file.
        //
        // *** Note that if any locks were taken out using PIDs other
        //     than that which opened the FID, those locks cannot be
        //     automatically deleted.  We count on the redirector to do
        //     the right thing in this case.
        //

        offset.QuadPart = 0;

        IF_SMB_DEBUG(LOCK1) {
            KdPrint(( "UnlinkRfcbFromLfcb: Issuing UnlockAllByKey for "
                        "file object 0x%p, key 0x%lx\n",
                        lfcb->FileObject,
                        Rfcb->ShiftedFid | Rfcb->Pid ));
        }
        (VOID)SrvIssueUnlockRequest(
                lfcb->FileObject,
                &lfcb->DeviceObject,
                IRP_MN_UNLOCK_ALL_BY_KEY,
                offset,
                offset,
                Rfcb->ShiftedFid | Rfcb->Pid
                );




        //
        // Release the MFCB lock.
        //

        RELEASE_LOCK( &lfcb->Mfcb->NonpagedMfcb->Lock );

    }

    return;

} // UnlinkRfcbFromLfcb


//
// Remote File Control Block (RFCB) routines.
//

VOID SRVFASTCALL
SrvAllocateRfcb (
    OUT PRFCB *Rfcb,
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function allocates an RFCB from nonpaged pool.  Nonpaged pool
    is used so that read/write completion can be handled in the FSD.

Arguments:

    Rfcb - Returns a pointer to the RFCB, or NULL if no space was
        available.

Return Value:

    None.

--*/

{
    PRFCB rfcb = NULL;
    PPAGED_RFCB pagedRfcb;
    PWORK_QUEUE queue = WorkContext->CurrentWorkQueue;

    PAGED_CODE();

    //
    // Attempt to grab an rfcb structure off the per-queue free list
    //
    rfcb = (PRFCB)InterlockedExchangePointer( &queue->CachedFreeRfcb,
                                              rfcb );

    if( rfcb != NULL ) {

        *Rfcb = rfcb;
        pagedRfcb = rfcb->PagedRfcb;

    } else {

        if( queue->FreeRfcbs ) {

            PSLIST_ENTRY listEntry;

            listEntry = ExInterlockedPopEntrySList(
                                    &queue->RfcbFreeList,
                                    &queue->SpinLock
                                    );

            if( listEntry != NULL ) {
                InterlockedIncrement( &queue->FreeRfcbs );
                rfcb = CONTAINING_RECORD( listEntry, RFCB, SingleListEntry );
                *Rfcb= rfcb;
                pagedRfcb = rfcb->PagedRfcb;
            }
        }

        if( rfcb == NULL ) {
            //
            // Attempt to allocate from nonpaged pool.
            //

            rfcb = ALLOCATE_NONPAGED_POOL( sizeof(RFCB), BlockTypeRfcb );
            *Rfcb = rfcb;

            if ( rfcb == NULL ) {
                INTERNAL_ERROR (
                    ERROR_LEVEL_EXPECTED,
                    "SrvAllocateRfcb: Unable to allocate %d bytes from nonpaged pool.",
                    sizeof( RFCB ),
                    NULL
                    );
                return;
            }

            pagedRfcb = ALLOCATE_HEAP( sizeof(PAGED_RFCB), BlockTypePagedRfcb );

            if ( pagedRfcb == NULL ) {
                INTERNAL_ERROR (
                    ERROR_LEVEL_EXPECTED,
                    "SrvAllocateRfcb: Unable to allocate %d bytes from paged pool.",
                    sizeof( PAGED_RFCB ),
                    NULL
                    );
                DEALLOCATE_NONPAGED_POOL( rfcb );
                *Rfcb = NULL;
                return;
            }

            IF_DEBUG(HEAP) {
                KdPrint(( "SrvAllocateRfcb: Allocated RFCB at 0x%p\n", rfcb ));
            }
        }
    }

    //
    // Initialize the RFCB.  Zero it first.
    //

    RtlZeroMemory( rfcb, sizeof( RFCB ));
    RtlZeroMemory( pagedRfcb, sizeof(PAGED_RFCB) );

    rfcb->PagedRfcb = pagedRfcb;
    pagedRfcb->PagedHeader.NonPagedBlock = rfcb;
    pagedRfcb->PagedHeader.Type = BlockTypePagedRfcb;

    SET_BLOCK_TYPE_STATE_SIZE( rfcb, BlockTypeRfcb, BlockStateActive, sizeof(RFCB) );
    rfcb->BlockHeader.ReferenceCount = 2;       // allow for Active status
                                                //  and caller's pointer

    INITIALIZE_REFERENCE_HISTORY( rfcb );

    rfcb->NewOplockLevel = NO_OPLOCK_BREAK_IN_PROGRESS;
    pagedRfcb->LastFailingLockOffset.QuadPart = -1;
    rfcb->IsCacheable = ( SrvCachedOpenLimit > 0 );

    InterlockedIncrement(
        (PLONG)&SrvStatistics.CurrentNumberOfOpenFiles
        );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.RfcbInfo.Allocations );

    //
    // Lock the file-based code section.
    //

    REFERENCE_UNLOCKABLE_CODE( 8FIL );

    InitializeListHead( &rfcb->RawWriteSerializationList );

    InitializeListHead( &rfcb->WriteMpx.GlomDelayList );

    return;

} // SrvAllocateRfcb


BOOLEAN SRVFASTCALL
SrvCheckAndReferenceRfcb (
    PRFCB Rfcb
    )

/*++

Routine Description:

    This function atomically verifies that an RFCB is active and
    increments the reference count on the RFCB if it is.

Arguments:

    Rfcb - Address of RFCB

Return Value:

    BOOLEAN - Returns TRUE if the RFCB is active, FALSE otherwise.

--*/

{
    KIRQL oldIrql;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Acquire the lock that guards the RFCB's state field.
    //

    ACQUIRE_SPIN_LOCK( &Rfcb->Connection->SpinLock, &oldIrql );

    //
    // If the RFCB is active, reference it and return TRUE.  Note that
    // ReferenceRfcbInternal releases the spin lock.
    //

    if ( GET_BLOCK_STATE(Rfcb) == BlockStateActive ) {

        ReferenceRfcbInternal( Rfcb, oldIrql );

        return TRUE;

    }

    //
    // The RFCB isn't active.  Return FALSE.
    //

    RELEASE_SPIN_LOCK( &Rfcb->Connection->SpinLock, oldIrql );

    return FALSE;

} // SrvCheckAndReferenceRfcb


VOID SRVFASTCALL
SrvCloseRfcb (
    PRFCB Rfcb
    )

/*++

Routine Description:

    This is the external routine for closing a file.  It acquires the
    appropriate spin lock, then calls CloseRfcbInternal.

Arguments:

    Rfcb - Supplies a pointer to the RFCB to be closed.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Acquire the lock that guards the RFCB's state field.  Call the
    // internal close routine.  That routine releases the spin lock.
    //

    IF_SYSCACHE_RFCB( Rfcb ) {
        KdPrint((" Closing Syscache RFCB %p\n", Rfcb ));
    }

    ACQUIRE_SPIN_LOCK( &Rfcb->Connection->SpinLock, &oldIrql );

    CloseRfcbInternal( Rfcb, oldIrql );

    return;

} // SrvCloseRfcb


VOID
CloseRfcbInternal (
    PRFCB Rfcb,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This internal function does the core of a file close.  It sets the
    state of the RFCB to Closing, unlinks it from its parent LFCB, and
    dereferences the RFCB.  The RFCB will be destroyed as soon as all
    other references to it are eliminated.

    *** This routine must be called with the spin lock synchronizing
        access to the RFCB's state field (the connection spin lock)
        held.  The lock is released on exit from this routine.

Arguments:

    Rfcb - Supplies a pointer to the RFCB to be closed.

    OldIrql - The previous IRQL value obtained when the spin lock was
        acquired.

Return Value:

    None.

--*/

{
    KIRQL oldIrql = OldIrql;
    LARGE_INTEGER cacheOffset;
    PMDL mdlChain;
    PCONNECTION connection = Rfcb->Connection;
    PWORK_CONTEXT workContext;
    ULONG i;
    ULONG writeLength;
    NTSTATUS status;

    UNLOCKABLE_CODE( 8FIL );

    ASSERT( GET_BLOCK_TYPE( Rfcb ) == BlockTypeRfcb );

    //
    // If the RFCB's state is still Active, change it to Closing and
    // cause cleanup to happen.
    //

    if ( GET_BLOCK_STATE(Rfcb) == BlockStateActive ) {

        IF_DEBUG(BLOCK1) KdPrint(( "Closing RFCB at 0x%p\n", Rfcb ));
        UpdateRfcbHistory( Rfcb, 'solc' );

        SET_BLOCK_STATE( Rfcb, BlockStateClosing );

        //
        // Invalidate the cached rfcb
        //

        if ( connection->CachedFid == (ULONG)Rfcb->Fid ) {
            connection->CachedFid = (ULONG)-1;
        }

        //
        // Don't cleanup if raw writes are still in progress
        //

        if ( Rfcb->RawWriteCount != 0 ) {

            //
            // Cleanup will happen in SrvDecrementRawWriteCount
            //

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
            return;

        }

        //
        // Do we have write mpx outstanding?
        //

        if ( Rfcb->WriteMpx.ReferenceCount != 0 ) {

            //
            // Cleanup will happen when the ref count drops to 0
            //

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
            return;

        } else if ( Rfcb->WriteMpx.Glomming ) {

            //
            // We need to complete this write mdl
            //

            Rfcb->WriteMpx.Glomming = FALSE;
            Rfcb->WriteMpx.GlomComplete = FALSE;

            //
            // Save the offset and MDL address.
            //

            cacheOffset.QuadPart = Rfcb->WriteMpx.StartOffset;
            mdlChain = Rfcb->WriteMpx.MdlChain;
            writeLength = Rfcb->WriteMpx.Length;

            DEBUG Rfcb->WriteMpx.MdlChain = NULL;
            DEBUG Rfcb->WriteMpx.StartOffset = 0;
            DEBUG Rfcb->WriteMpx.Length = 0;

            //
            // Now we can release the lock.
            //

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

            //
            // Tell the cache manager that we're done with this MDL write.
            //

            if( Rfcb->Lfcb->MdlWriteComplete == NULL ||
                Rfcb->Lfcb->MdlWriteComplete(
                    Rfcb->WriteMpx.FileObject,
                    &cacheOffset,
                    mdlChain,
                    Rfcb->Lfcb->DeviceObject ) == FALSE ) {

                status = SrvIssueMdlCompleteRequest( NULL, Rfcb->WriteMpx.FileObject,
                                            mdlChain,
                                            IRP_MJ_WRITE,
                                            &cacheOffset,
                                            writeLength
                                           );

                if( !NT_SUCCESS( status ) ) {
                    SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
                }
            }

        } else {

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
        }

        //
        // Do the actual close
        //

        SrvCompleteRfcbClose( Rfcb );

    } else {

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    }

    return;

} // CloseRfcbInternal


VOID
SrvCloseRfcbsOnLfcb (
    PLFCB Lfcb
    )

/*++

Routine Description:

    This routine closes all RFCBs on an LFCB.  It is used by Delete and
    Rename processors to close all open instances of a file opened in
    compability mode (or FCB).

    *** The MFCB lock of the MFCB corresponding to this LFCB must be
        held on entry to this routine; the lock remains held on exit.
        The caller must also have an additional reference to the MFCB,
        in order to prevent it from being deleted while the MFCB lock
        is held.

Arguments:

    Lfcb - Supplies a pointer to the LFCB whose RFCBs are to be closed.

Return Value:

    None.

--*/

{
    PPAGED_RFCB pagedRfcb;
    PPAGED_RFCB nextPagedRfcb;
    PRFCB rfcb;

    PAGED_CODE( );

    ASSERT( ExIsResourceAcquiredExclusiveLite(&RESOURCE_OF(Lfcb->Mfcb->NonpagedMfcb->Lock)) );

    //
    // Loop through the LFCB's RFCB list.  Note that the fact that we
    // hold the MFCB lock throughout this routine means that no changes
    // to the list, other than the ones we make, can occur.  This makes
    // it safe to capture the address of the next RFCB in the list
    // before closing the current one.
    //

    pagedRfcb = CONTAINING_RECORD(
                        Lfcb->RfcbList.Flink,
                        PAGED_RFCB,
                        LfcbListEntry
                        );

    while ( &pagedRfcb->LfcbListEntry != &Lfcb->RfcbList ) {

        nextPagedRfcb = CONTAINING_RECORD(
                        pagedRfcb->LfcbListEntry.Flink,
                        PAGED_RFCB,
                        LfcbListEntry
                        );

        //
        // A file owned by the specified LFCB has been found.  Close it.
        //

        rfcb = pagedRfcb->PagedHeader.NonPagedBlock;
        if ( GET_BLOCK_STATE(rfcb) == BlockStateActive ) {
            SrvCloseRfcb( rfcb );
        }

        //
        // Move to the next RFCB in the LFCB's list.
        //

        pagedRfcb = nextPagedRfcb;

    }

    //
    // Close cached RFCBs.  These aren't dealt with in the loop above
    // because their state is BlockStateClosing.
    //

    SrvCloseCachedRfcbsOnLfcb( Lfcb );

    return;

} // SrvCloseRfcbsOnLfcb


VOID
SrvCloseRfcbsOnSessionOrPid (
    IN PSESSION Session,
    IN PUSHORT Pid OPTIONAL
    )

/*++

Routine Description:

    This routine closes all files "owned" by the specified session and/or
    PID in response to a Process Exit SMB.  PIDs are unique within the
    session that creates them.  This routine walks the file table of the
    connection that owns the specified session, closing all RFCBs whose
    owning session and PID are equal to the PID passed to this routine.

    Each session has a unique UID, so we can compare Uid's instead of comparing
    the actual session pointer.

Arguments:

    Session - Supplies a pointer to the session block corresponding to
        the specified PID, if specified.

    Pid - if present, Supplies pointer to the PID for which files are
        to be closed.

Return Value:

    None.

--*/

{
    PTABLE_HEADER tableHeader;
    PCONNECTION connection;
    PRFCB rfcb;
    USHORT i;
    KIRQL oldIrql;
    USHORT Uid;
    PLIST_ENTRY listEntry;

    //UNLOCKABLE_CODE( CONN );

    //
    // Get the address of the connection's file table.
    //

    connection = Session->Connection;
    tableHeader = &connection->FileTable;
    Uid = Session->Uid;

    //
    // Acquire the lock that guards the file table.  This lock is held
    // while walking the table, in order to prevent the table from
    // changing.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    //
    // Walk the file table, looking for files owned by the specified
    // session and/or PID.
    //

    for ( i = 0; i < tableHeader->TableSize; i++ ) {

        rfcb = (PRFCB)tableHeader->Table[i].Owner;

        if((rfcb != NULL) &&
          (GET_BLOCK_STATE(rfcb) == BlockStateActive) &&
          (rfcb->Uid == Uid) &&
          (!ARGUMENT_PRESENT( Pid ) || (rfcb->Pid == *Pid)) ) {

            //
            // A file owned by the specified session/process has
            // been found.  Close the RFCB, and make sure it doesn't
            // end up in the RFCB cache.
            //

            rfcb->IsCacheable = FALSE;
            CloseRfcbInternal( rfcb, oldIrql );
            ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );
        }
    }

    //
    // Now walk the RFCB cache to see if we have cached files that refer
    //  to this session that need to be closed.
    //

again:

    IF_DEBUG(FILE_CACHE) KdPrint(( "SrvCloseRfcbsOnSessionOrPid: "
                                    "checking for cached RFCBS\n" ));

    for ( listEntry = connection->CachedOpenList.Flink;
          listEntry != &connection->CachedOpenList;
          listEntry = listEntry->Flink ) {

        rfcb = CONTAINING_RECORD( listEntry, RFCB, CachedOpenListEntry );

        if( (rfcb->Uid == Uid) &&
            ( !ARGUMENT_PRESENT( Pid ) || rfcb->Pid == *Pid) ) {

            //
            // This cached file is owned by session and/or process.
            // Close the RFCB.
            //
            SrvCloseCachedRfcb( rfcb, oldIrql );
            ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );
            goto again;
        }
    }

    //
    // All done.  Release the lock.
    //

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    return;

} // SrvCloseRfcbsOnSessionOrPid


VOID
SrvCloseRfcbsOnTree (
    PTREE_CONNECT TreeConnect
    )

/*++

Routine Description:

    This routine closes all files "owned" by the specified tree connect.
    It walks the file table of the connection that owns the tree
    connection.  Each file in that table that is owned by the tree
    connect is closed.

Arguments:

    TreeConnect - Supplies a pointer to the tree connect block for which
        files are to be closed.

Return Value:

    None.

--*/

{
    PRFCB rfcb;
    PTABLE_HEADER tableHeader;
    PCONNECTION connection;
    USHORT i;
    KIRQL oldIrql;
    PLIST_ENTRY listEntry;
    USHORT Tid;

    //UNLOCKABLE_CODE( CONN );

    //
    // Get the address of the connection's file table.
    //

    connection = TreeConnect->Connection;
    tableHeader = &connection->FileTable;
    Tid = TreeConnect->Tid;

    //
    // Acquire the lock that guards the file table.  This lock is held
    // while walking the table, in order to prevent the table from
    // changing.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    //
    // Walk the file table, looking for files owned by the specified
    // tree and PID.
    //

    for ( i = 0; i < tableHeader->TableSize; i++ ) {

        rfcb = (PRFCB)tableHeader->Table[i].Owner;

        if((rfcb != NULL) &&
           (GET_BLOCK_STATE(rfcb) == BlockStateActive) &&
           (rfcb->Tid == Tid )) {

             //
             // A file owned by the specified tree connect has been found.
             // Close the RFCB and make sure it doesn't get cached
             //

             rfcb->IsCacheable = FALSE;
             CloseRfcbInternal( rfcb, oldIrql );
             ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );
        }
    }

    //
    // Walk the cached open list, looking for files open on this tree
    //  Close any that we find.
    //

again:

    IF_DEBUG(FILE_CACHE) KdPrint(( "SrvCloseRfcbsOnTree: checking for cached RFCBS\n" ));

    for ( listEntry = connection->CachedOpenList.Flink;
          listEntry != &connection->CachedOpenList;
          listEntry = listEntry->Flink ) {

        rfcb = CONTAINING_RECORD( listEntry, RFCB, CachedOpenListEntry );

        if( rfcb->Tid == Tid ) {
            //
            // This cached file is owned by the specifiec tree connect.
            // Close the RFCB.
            //
            SrvCloseCachedRfcb( rfcb, oldIrql );
            ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );
            goto again;
        }
    }

    //
    // All done.  Release the lock.
    //

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    return;

} // SrvCloseRfcbsOnTree


VOID
SrvCompleteRfcbClose (
    IN PRFCB Rfcb
    )

/*++

Routine Description:

    This routine completes the rfcb close.

Arguments:

    Rfcb - Supplies a pointer to the RFCB to be closed.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    PCONNECTION connection = Rfcb->Connection;

    UNLOCKABLE_CODE( 8FIL );

    UpdateRfcbHistory( Rfcb, 'tlpc' );

    //
    // Remove the Rfcb from the oplockbreaksinprogresslist.  When the
    // Rfcb gets closed, we don't process any more oplock breaks
    // responses.
    //

    ACQUIRE_LOCK( &SrvOplockBreakListLock );
    if ( Rfcb->OnOplockBreaksInProgressList ) {

        Rfcb->NewOplockLevel = NO_OPLOCK_BREAK_IN_PROGRESS;
        Rfcb->OplockState = OplockStateNone;

        //
        // Remove the Rfcb from the Oplock breaks in progress list, and
        // release the Rfcb reference.
        //

        SrvRemoveEntryList( &SrvOplockBreaksInProgressList, &Rfcb->ListEntry );
        Rfcb->OnOplockBreaksInProgressList = FALSE;
#if DBG
        Rfcb->ListEntry.Flink = Rfcb->ListEntry.Blink = NULL;
#endif
        RELEASE_LOCK( &SrvOplockBreakListLock );
        SrvDereferenceRfcb( Rfcb );

        ExInterlockedAddUlong(
            &connection->OplockBreaksInProgress,
            (ULONG)-1,
            connection->EndpointSpinLock
            );

    } else {

        RELEASE_LOCK( &SrvOplockBreakListLock );

    }

    //
    // If this RFCB has a batch oplock, then it is eligible for caching.
    //

    if ( Rfcb->IsCacheable && Rfcb->NumberOfLocks == 0 &&
         ((Rfcb->OplockState == OplockStateOwnBatch) ||
          (Rfcb->OplockState == OplockStateOwnServerBatch)) &&
         (Rfcb->PagedRfcb->FcbOpenCount == 0) &&
          !Rfcb->Mfcb->CompatibilityOpen ) {

        ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

        if ( Rfcb->IsCacheable &&
             ((Rfcb->OplockState == OplockStateOwnBatch) ||
             (Rfcb->OplockState == OplockStateOwnServerBatch)) &&
             (GET_BLOCK_STATE(connection) == BlockStateActive) ) {

            //
            // Indicate that this RFCB now has a server-owned batch
            // oplock.  Indicate that it is on the cached-after-close
            // list.  Insert it on that list.
            //

            UpdateRfcbHistory( Rfcb, 'hcac' );

            Rfcb->OplockState = OplockStateOwnServerBatch;
            Rfcb->CachedOpen = TRUE;
            InsertHeadList(
                &connection->CachedOpenList,
                &Rfcb->CachedOpenListEntry
                );
            IF_DEBUG(FILE_CACHE) KdPrint(( "SrvCompleteRfcbClose: caching rfcb %p\n", Rfcb ));

            //
            // Increment the count of cached RFCBs.  If there are now
            // too many cached RFCBs, close the oldest one.
            //

            if ( ++connection->CachedOpenCount > SrvCachedOpenLimit ) {
                PRFCB rfcbToClose;
                rfcbToClose = CONTAINING_RECORD(
                                connection->CachedOpenList.Blink,
                                RFCB,
                                CachedOpenListEntry
                                );

                //
                // SrvCloseCachedRfcb releases the spin lock.
                //

                SrvCloseCachedRfcb( rfcbToClose, oldIrql );

            } else {
                RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
            }

            if( Rfcb->PagedRfcb->IpxSmartCardContext ) {
                IF_DEBUG( SIPX ) {
                    KdPrint(("Calling Smart Card Close for Rfcb %p\n", Rfcb ));
                }
                SrvIpxSmartCard.Close( Rfcb->PagedRfcb->IpxSmartCardContext );
                Rfcb->PagedRfcb->IpxSmartCardContext = NULL;
            }

            return;
        }

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );


    }
    IF_DEBUG(FILE_CACHE) KdPrint(( "SrvCompleteRfcbClose: can't cache rfcb %p, %wZ\n",
        Rfcb, &Rfcb->Lfcb->Mfcb->FileName ));

    //
    // Unlink the RFCB from the LFCB.  If this is the last RFCB for
    // this LFCB, this will force the file closed even if there are
    // still references to the RFCB.  This will unblock blocked I/O.
    //

    UnlinkRfcbFromLfcb( Rfcb );

    //
    // Now reacquire the spin lock so that we can release the "open"
    // reference to the Rfcb.  DereferenceRfcbInternal releases the
    // spin lock before returning.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );
    DereferenceRfcbInternal( Rfcb, oldIrql );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.RfcbInfo.Closes );

    return;

} // SrvCompleteRfcbClose


VOID SRVFASTCALL
SrvDereferenceRfcb (
    IN PRFCB Rfcb
    )

/*++

Routine Description:

    This function decrements the reference count on an RFCB.  If the
    reference count goes to zero, the RFCB is deleted.

Arguments:

    Rfcb - Address of RFCB.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Acquire the lock that guards the RFCB's reference count and the
    // connection's file table.  Then call the internal routine to
    // decrement the count and possibly delete the RFCB.  That function
    // releases the spin lock before returning.
    //

    //
    // !!! If you change the way this routine and
    //     DereferenceRfcbInternal work, make sure you check
    //     fsd.c\SrvFsdRestartSmbComplete to see if it needs to be
    //     changed too.
    //

    ACQUIRE_SPIN_LOCK( &Rfcb->Connection->SpinLock, &oldIrql );

    DereferenceRfcbInternal( Rfcb, oldIrql );

    return;

} // SrvDereferenceRfcb


VOID
DereferenceRfcbInternal (
    IN PRFCB Rfcb,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This internal function decrements the reference count on an RFCB.
    If the reference count goes to zero, the RFCB is deleted.  This
    function is called from other routines in this module.

    *** The spin lock synchronizing access to the RFCB's reference count
        must be held when this function is called.  The lock is released
        before this function returns.

Arguments:

    Rfcb - Address of RFCB.

    OldIrql - The previous IRQL value obtained when the spin lock was
        acquired.

Return Value:

    None.

--*/

{
    PLFCB lfcb;
    PPAGED_RFCB pagedRfcb;
    PCONNECTION connection;
    PWORK_QUEUE queue;

    UNLOCKABLE_CODE( 8FIL );

    ASSERT( GET_BLOCK_TYPE( Rfcb ) == BlockTypeRfcb );
    ASSERT( (LONG)Rfcb->BlockHeader.ReferenceCount > 0 );

    //
    // The lock that guards the RFCB's reference count is held when this
    // function is called.
    //
    // Decrement the reference count.  If it goes to zero, remove the
    // RFCB's entry in the file table, remove the RFCB from its parent
    // LFCB's list, and deallocate the RFCB.
    //

    //
    // !!! If you change the way this routine and SrvDereferenceRfcb
    //     work, make sure you check fsd.c\SrvFsdRestartSmbComplete to
    //     see if it needs to be changed too.
    //

    IF_DEBUG(REFCNT) {
        KdPrint(( "Dereferencing RFCB 0x%p; old refcnt 0x%lx\n",
                    Rfcb, Rfcb->BlockHeader.ReferenceCount ));
    }

    connection = Rfcb->Connection;
    queue = connection->CurrentWorkQueue;
    Rfcb->BlockHeader.ReferenceCount--;
    UPDATE_REFERENCE_HISTORY( Rfcb, TRUE );

    if ( Rfcb->BlockHeader.ReferenceCount != 0 ) {

        //
        // Release the spin lock.
        //

        RELEASE_SPIN_LOCK( &connection->SpinLock, OldIrql );

    } else {

        ASSERT( GET_BLOCK_STATE(Rfcb) == BlockStateClosing );
        ASSERT( Rfcb->ListEntry.Flink == NULL &&  \
                Rfcb->ListEntry.Blink == NULL );
        UpdateRfcbHistory( Rfcb, '0fer' );

        //
        // Remove the file entry from the appropriate connection file
        // table.
        //

        SrvRemoveEntryTable(
            &connection->FileTable,
            FID_INDEX( Rfcb->Fid )
            );

        //
        // Release the spin lock.
        //

        RELEASE_SPIN_LOCK( &connection->SpinLock, OldIrql );

        //
        // Free the IRP if one has been allocated.
        //

        if ( Rfcb->Irp != NULL ) {
            UpdateRfcbHistory( Rfcb, 'prif' );
            IoFreeIrp( Rfcb->Irp );
        }

        //
        // Remove the RFCB from the LFCB's list and dereference the LFCB.
        // Acquire the MFCB lock.  SrvDereferenceLfcb will release it.
        //

        pagedRfcb = Rfcb->PagedRfcb;
        lfcb = Rfcb->Lfcb;

        ACQUIRE_LOCK( &lfcb->Mfcb->NonpagedMfcb->Lock);

        //
        // Remove the RFCB from the global list of RFCBs.
        //

        SrvRemoveEntryOrderedList( &SrvRfcbList, Rfcb );

        SrvRemoveEntryList( &lfcb->RfcbList, &pagedRfcb->LfcbListEntry );
        SrvDereferenceLfcb( lfcb );
        DEBUG Rfcb->Lfcb = 0;

        //
        // Free the RFCB.
        //

        SrvFreeRfcb( Rfcb, queue );

    }

    return;

} // DereferenceRfcbInternal


VOID SRVFASTCALL
SrvFreeRfcb (
    IN PRFCB Rfcb,
    PWORK_QUEUE queue
    )

/*++

Routine Description:

    This function returns an RFCB to the system nonpaged pool.  If changes are
    made here, check out FreeIdleWorkItems in scavengr.c!

Arguments:

    Rfcb - Address of RFCB

Return Value:

    None.

--*/

{
    PAGED_CODE();

    IF_DEBUG(FILE_CACHE) KdPrint(( "SrvFreeRfcb: %p\n", Rfcb ));
    ASSERT( Rfcb->RawWriteCount == 0 );
    ASSERT( IsListEmpty(&Rfcb->RawWriteSerializationList) );
    UpdateRfcbHistory( Rfcb, 'eerf' );

    //
    // Free the the RFCB.
    //

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( Rfcb, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG Rfcb->BlockHeader.ReferenceCount = (ULONG)-1;
    TERMINATE_REFERENCE_HISTORY( Rfcb );

    Rfcb = (PRFCB)InterlockedExchangePointer( &queue->CachedFreeRfcb,
                                              Rfcb );

    if( Rfcb != NULL ) {
        //
        // This check allows for the possibility that FreeRfcbs might exceed
        // MaxFreeRfcbs, but it's fairly unlikely given the operation of kernel
        // queue objects.  But even so, it probably won't exceed it by much and
        // is really only advisory anyway.
        //
        if( queue->FreeRfcbs < queue->MaxFreeRfcbs ) {

            ExInterlockedPushEntrySList(
                &queue->RfcbFreeList,
                &Rfcb->SingleListEntry,
                &queue->SpinLock
            );

            InterlockedIncrement( &queue->FreeRfcbs );

        } else {

            FREE_HEAP( Rfcb->PagedRfcb );
            DEALLOCATE_NONPAGED_POOL( Rfcb );
            IF_DEBUG(HEAP) KdPrint(( "SrvFreeRfcb: Freed RFCB at 0x%p\n", Rfcb ));

            INCREMENT_DEBUG_STAT( SrvDbgStatistics.RfcbInfo.Frees );

        }
    }

    //
    // Unlock the file-based code section.
    //

    DEREFERENCE_UNLOCKABLE_CODE( 8FIL );

    InterlockedDecrement(
        (PLONG)&SrvStatistics.CurrentNumberOfOpenFiles
        );



    return;

} // SrvFreeRfcb


VOID SRVFASTCALL
SrvReferenceRfcb (
    PRFCB Rfcb
    )

/*++

Routine Description:

    This function increments the reference count on an RFCB.

Arguments:

    Rfcb - Address of RFCB

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Acquire the spin lock that protects the RFCB's reference count,
    // then call an internal routine to increment the RFCB's reference
    // count.  That routine releases the spin lock.
    //

    ACQUIRE_SPIN_LOCK( &Rfcb->Connection->SpinLock, &oldIrql );

    ReferenceRfcbInternal( Rfcb, oldIrql );

    return;

} // SrvReferenceRfcb


VOID
ReferenceRfcbInternal (
    PRFCB Rfcb,
    KIRQL OldIrql
    )

/*++

Routine Description:

    This function increments the reference count on an RFCB.

    *** The spin lock synchronizing access to the RFCB's reference count
        must be held when this function is called.  The lock is released
        before this function returns.

Arguments:

    Rfcb - Address of RFCB

Return Value:

    None.

--*/

{
    UNLOCKABLE_CODE( 8FIL );

    ASSERT( (LONG)Rfcb->BlockHeader.ReferenceCount > 0 );
    ASSERT( GET_BLOCK_TYPE(Rfcb) == BlockTypeRfcb );
    // ASSERT( GET_BLOCK_STATE(Rfcb) == BlockStateActive );
    UPDATE_REFERENCE_HISTORY( Rfcb, FALSE );

    //
    // Increment the RFCB's reference count.
    //

    Rfcb->BlockHeader.ReferenceCount++;

    IF_DEBUG(REFCNT) {
        KdPrint(( "Referencing RFCB 0x%p; new refcnt 0x%lx\n",
                    Rfcb, Rfcb->BlockHeader.ReferenceCount ));
    }

    //
    // Release the spin lock before returning to the caller.
    //

    RELEASE_SPIN_LOCK( &Rfcb->Connection->SpinLock, OldIrql );

    return;

} // ReferenceRfcbInternal


BOOLEAN
SrvFindCachedRfcb (
    IN PWORK_CONTEXT WorkContext,
    IN PMFCB Mfcb,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN OPLOCK_TYPE RequestedOplockType,
    OUT PNTSTATUS Status
    )

/*++

Routine Description:

    This routine searches a connection's cached-after-close RFCB list
    to attempt to find an existing handle that can be matched up with
    a new open attempt.  If one is found, it is removed from the list
    and reactivated.

Arguments:

    WorkContext - Pointer to work context block.

    Mfcb - Address of MFCB for file being opened.

    DesiredAccess - Desired access for new open.  Used for matching
        purposes.

    ShareAccess - Share access for new open.  Used for matching
        purposes.

    CreateDisposition - Create disposition for new open.  Used for
        matching purposes.

    CreateOptions - Create options for new open.  Used for matching
        purposes.

    RequestedOplockType - Oplock type requested by the client (or the
        server) for the new open.  Used for matching purposes.

    Status - Returns the status of the search.  Only valid if return
        value is TRUE.  Will be STATUS_SUCCESS if a cached open was
        found and taken out of the cache.  In this case, the RFCB
        address is stored in WorkContext->Rfcb.  Status will be
        STATUS_OBJECT_NAME_COLLISION if the file is cached but the
        caller wants the open to file if the file exists.

Return Value:

    BOOLEAN - TRUE if a cached open was found and returned.

--*/

{
    PCONNECTION connection = WorkContext->Connection;
    PLIST_ENTRY listEntry;
    PRFCB rfcb;
    KIRQL oldIrql;
    USHORT uid, tid;
    BOOLEAN wantsWriteThrough, isWriteThrough;
    ACCESS_MASK nongenericDesiredAccess;

    //UNLOCKABLE_CODE( CONN );

    IF_DEBUG(FILE_CACHE) KdPrint(( "SrvFindCachedRfcb: called for %wZ\n", &Mfcb->FileName ));

    //
    // If the client doesn't want an oplock, then the server should have
    // asked for its own batch oplock.
    //

    ASSERT( (RequestedOplockType == OplockTypeBatch) ||
            (RequestedOplockType == OplockTypeExclusive) ||
            (RequestedOplockType == OplockTypeServerBatch) );

    //
    // This routine must not be called for create dispositions that are
    // inconsistent with reusing a cached open.  Specifically, supersede
    // and overwrite are not allowed.
    //

    ASSERT( (CreateDisposition == FILE_OPEN) ||
            (CreateDisposition == FILE_CREATE) ||
            (CreateDisposition == FILE_OPEN_IF) );

    //
    // If the connection has no cached RFCBs, get out quick.
    //

    if ( connection->CachedOpenCount == 0 ) {
        IF_DEBUG(FILE_CACHE) KdPrint(( "SrvFindCachedRfcb: connection has no cached RFCBs\n" ));
        return FALSE;
    }

    //
    // The input DesiredAccess may include generic access modes, but the
    // RFCB has specific access modes, so we have to translate
    // DesiredAccess.
    //

    nongenericDesiredAccess = DesiredAccess;
    IoCheckDesiredAccess( &nongenericDesiredAccess, 0 );

    uid = WorkContext->Session->Uid;
    tid = WorkContext->TreeConnect->Tid;

    //
    // Lock the cached open list and look for a matching RFCB.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    for ( listEntry = connection->CachedOpenList.Flink;
          listEntry != &connection->CachedOpenList;
          listEntry = listEntry->Flink ) {

        rfcb = CONTAINING_RECORD( listEntry, RFCB, CachedOpenListEntry );

        IF_DEBUG(FILE_CACHE) KdPrint(( "SrvFindCachedRfcb: checking rfcb %p; mfcb = %p\n",
                                        rfcb, rfcb->Mfcb ));
        ASSERT( rfcb->OplockState == OplockStateOwnServerBatch );
        ASSERT( rfcb->CachedOpen );
        ASSERT( GET_BLOCK_STATE(rfcb) == BlockStateClosing );

        //
        // If this RFCB is for the right file, we can proceed with other
        // checks.
        //

        if ( rfcb->Mfcb == Mfcb ) {

            //
            // If the client asked for FILE_CREATE, we can fail the open
            // now, because the file exists.
            //

            if ( CreateDisposition == FILE_CREATE ) {
                IF_DEBUG(FILE_CACHE) KdPrint(( "SrvFindCachedRfcb: client wants to create\n" ));
                RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
                *Status = STATUS_OBJECT_NAME_COLLISION;
                return TRUE;
            }

            //
            // Check the access modes to make sure they're compatible.
            // The new open must:
            //
            //   a) have the same desired access as what was granted before;
            //   b) have the same share access;
            //   c) have the create disposition (in the bits we care about);
            //   d) be requesting a batch oplock;
            //   e) be for the same UID and TID.
            //

#define FILE_MODE_FLAGS (FILE_DIRECTORY_FILE |          \
                         FILE_SEQUENTIAL_ONLY |         \
                         FILE_NON_DIRECTORY_FILE |      \
                         FILE_NO_EA_KNOWLEDGE |         \
                         FILE_RANDOM_ACCESS |           \
                         FILE_OPEN_REPARSE_POINT | \
                         FILE_OPEN_FOR_BACKUP_INTENT)

            if ( (rfcb->GrantedAccess != nongenericDesiredAccess) ||
                 (rfcb->ShareAccess != ShareAccess) ||
                 ((rfcb->FileMode & FILE_MODE_FLAGS) !=
                  (CreateOptions & FILE_MODE_FLAGS)) ||
                 (RequestedOplockType == OplockTypeExclusive) ||
                 (rfcb->Uid != uid) ||
                 (rfcb->Tid != tid) ) {

#if 0
              IF_DEBUG(FILE_CACHE) {
                if ( rfcb->GrantedAccess != nongenericDesiredAccess )
                    KdPrint(( "SrvFindCachedRfcb: granted access %x doesn't match desired access %x\n",
                                rfcb->GrantedAccess, nongenericDesiredAccess ));
                if ( rfcb->ShareAccess != ShareAccess )
                    KdPrint(( "SrvFindCachedRfcb: share access %x doesn't match share access %x\n",
                                rfcb->ShareAccess, ShareAccess ));
                if ( (rfcb->FileMode & FILE_MODE_FLAGS) != (CreateOptions & FILE_MODE_FLAGS))
                    KdPrint(( "SrvFindCachedRfcb: share access %x doesn't match share access %x\n",
                                rfcb->FileMode&FILE_MODE_FLAGS, CreateOptions&FILE_MODE_FLAGS ));
                if ( RequestedOplockType == OplockTypeExclusive )
                    KdPrint(( "SrvFindCachedRfcb: client wants exclusive oplock\n" ));
                if ( rfcb->Uid != uid )
                    KdPrint(( "SrvFindCachedRfcb: UID %x doesn't match UID %x\n", rfcb->Uid, uid ));
                if ( rfcb->Tid != tid )
                    KdPrint(( "SrvFindCachedRfcb: TID %x doesn't match TID %x\n", rfcb->Tid, tid ));
              }
#endif

                //
                // The file is cached, but the new open is inconsistent
                // with the cached open.  We must not use the cached
                // open.  It would be more efficient to close the cached
                // RFCB here, since we know the caller is going to turn
                // around and open the file because we're returning
                // FALSE, thus breaking the batch oplock.  However, our
                // caller owns the MFCB lock, while closing an RFCB
                // requires obtaining the MFCB list lock.  Acquiring
                // these locks in this order leads to deadlock.
                //
                // Note that there is no need to continue the list walk.
                // We have a batch oplock, so we can only have the file
                // open once.
                //

#if 0
                SrvCloseCachedRfcb( rfcb, oldIrql );
#else
                RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
#endif
                return FALSE;
            }

            //
            // The file is cached and the new open is consistent with the
            // cached open.  Remove the open from the cache and give it
            // to the new opener.
            //

            IF_DEBUG(FILE_CACHE) KdPrint(( "SrvFindCachedRfcb: Reusing cached RFCB %p\n", rfcb ));

            UpdateRfcbHistory( rfcb, ' $nu' );

            RemoveEntryList( &rfcb->CachedOpenListEntry );
            connection->CachedOpenCount--;
            ASSERT( (LONG)connection->CachedOpenCount >= 0 );
            rfcb->CachedOpen = FALSE;

            if ( RequestedOplockType == OplockTypeBatch ) {
                rfcb->OplockState = OplockStateOwnBatch;
            }
            SET_BLOCK_STATE( rfcb, BlockStateActive );
            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

            WorkContext->Rfcb = rfcb;
            SrvReferenceRfcb( rfcb );

            rfcb->IsActive = FALSE;
            rfcb->WrittenTo = FALSE;
            wantsWriteThrough = (BOOLEAN)((CreateOptions & FILE_WRITE_THROUGH) != 0);
            isWriteThrough = (BOOLEAN)((rfcb->Lfcb->FileMode & FILE_WRITE_THROUGH) == 0);
            if ( wantsWriteThrough != isWriteThrough ) {
                SrvSetFileWritethroughMode( rfcb->Lfcb, wantsWriteThrough );
            }

            INCREMENT_DEBUG_STAT( SrvDbgStatistics.OpensSatisfiedWithCachedRfcb );

            WorkContext->Irp->IoStatus.Information = FILE_OPENED;

            *Status = STATUS_SUCCESS;
            return TRUE;

        }

    }

    //
    // We couldn't find the requested file in the cache.
    //

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
    return FALSE;

} // SrvFindCachedRfcb

ULONG
SrvCountCachedRfcbsForTid(
    PCONNECTION connection,
    USHORT Tid
)
/*++

Routine Description:

    This returns the number of RFCBS in the cache that are associated with Tid

Arguments:

    connection - Address of the CONNECTION structure of interest

Return Value:

    Count of cached RFCBs

--*/
{
    PLIST_ENTRY listEntry;
    PRFCB rfcb;
    KIRQL oldIrql;
    USHORT count = 0;

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    for ( listEntry = connection->CachedOpenList.Flink;
          listEntry != &connection->CachedOpenList;
          listEntry = listEntry->Flink ) {

        rfcb = CONTAINING_RECORD( listEntry, RFCB, CachedOpenListEntry );

        if( rfcb->Tid == Tid ) {
            ++count;
        }
    }

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    return count;
}

ULONG
SrvCountCachedRfcbsForUid(
    PCONNECTION connection,
    USHORT Uid
)
/*++

Routine Description:

    This returns the number of RFCBS in the cache that are associated with Uid

Arguments:

    connection - Address of the CONNECTION structure of interest

Return Value:

    Count of cached RFCBs

--*/
{
    PLIST_ENTRY listEntry;
    PRFCB rfcb;
    KIRQL oldIrql;
    ULONG count = 0;

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    for ( listEntry = connection->CachedOpenList.Flink;
          listEntry != &connection->CachedOpenList;
          listEntry = listEntry->Flink ) {

        rfcb = CONTAINING_RECORD( listEntry, RFCB, CachedOpenListEntry );

        if( rfcb->Uid == Uid ) {
            ++count;
        }
    }

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
    return count;
}


VOID
SrvCloseCachedRfcb (
    IN PRFCB Rfcb,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This routine closes a cached open.

    *** This routine must be called with the connection spin lock held.

Arguments:

    Rfcb - Address of RFCB to close.

    OldIrql - IRQL at which the called acquired the connection spin
        lock.  This must be lower than DISPATCH_LEVEL!

Return Value:

    None.

--*/

{
    PCONNECTION connection = Rfcb->Connection;
    KIRQL oldIrql;

    UNLOCKABLE_CODE( 8FIL );

    UpdateRfcbHistory( Rfcb, '$slc' );

    //
    // This routine must be called with the connection spin lock held.
    // The caller must have been at low IRQL before acquiring the spin
    // lock.
    //

    IF_DEBUG(FILE_CACHE) KdPrint(( "SrvCloseCachedRfcb called for rfcb %p", Rfcb ));
    ASSERT( OldIrql < DISPATCH_LEVEL );
    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Remove the RFCB from the connection's cache.
    //

    ASSERT( Rfcb->CachedOpen );
    Rfcb->CachedOpen = FALSE;
    Rfcb->OplockState = OplockStateNone;

    RemoveEntryList( &Rfcb->CachedOpenListEntry );
    connection->CachedOpenCount--;
    ASSERT( (LONG)connection->CachedOpenCount >= 0 );

    RELEASE_SPIN_LOCK( &connection->SpinLock, OldIrql );
    IF_DEBUG(FILE_CACHE) KdPrint(( "; file %wZ\n", &Rfcb->Mfcb->FileName ));

    //
    // Unlink the RFCB from the LFCB.  If this is the last RFCB for
    // this LFCB, this will force the file closed even if there are
    // still references to the RFCB.  This will unblock blocked I/O.
    //

    UnlinkRfcbFromLfcb( Rfcb );

    //
    // Now acquire the FSD spin lock so that we can release the "open"
    // reference to the Rfcb.  DereferenceRfcbInternal releases the spin
    // lock before returning.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );
    DereferenceRfcbInternal( Rfcb, oldIrql );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.RfcbInfo.Closes );

    return;

} // SrvCloseCachedRfcb


VOID
SrvCloseCachedRfcbsOnConnection (
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine closes all cached opens on a connection.

Arguments:

    Connection - Address of connection for which cached opens are to be closed.

Return Value:

    None.

--*/

{
    PLIST_ENTRY listEntry;
    PRFCB rfcb;
    KIRQL OldIrql;

    IF_DEBUG(FILE_CACHE) {
        KdPrint(( "SrvCloseCachedRfcbsOnConnection called for connection %p\n", Connection ));
    }

    //
    // Remove all RFCBs from the connection's open file cache.
    //

    // This routine needs to be protected from the situation where a Blocking Rename causes us to close all
    // cached opens, but an Oplock break comes during that time and sees that Cached Open is still set to TRUE
    // (Since we didn't hold the SpinLock during the operation)

    ACQUIRE_SPIN_LOCK( &Connection->SpinLock, &OldIrql );

    while ( IsListEmpty( &Connection->CachedOpenList ) == FALSE ) {

        listEntry = RemoveHeadList( &Connection->CachedOpenList );

        rfcb = CONTAINING_RECORD( listEntry, RFCB, CachedOpenListEntry );

        UpdateRfcbHistory( rfcb, 'nc$c' );

        //
        // Remove the RFCB from the connection's cache.
        //

        Connection->CachedOpenCount--;

        ASSERT( rfcb->CachedOpen );
        rfcb->CachedOpen = FALSE;

        ASSERT( rfcb->OplockState == OplockStateOwnServerBatch );
        rfcb->OplockState = OplockStateNone;

        IF_DEBUG(FILE_CACHE) {
            KdPrint(( "SrvCloseCachedRfcbsOnConnection; closing rfcb %p file %wZ\n",
                        rfcb, &rfcb->Mfcb->FileName ));
        }

        RELEASE_SPIN_LOCK( &Connection->SpinLock, OldIrql );

        //
        // Unlink the RFCB from the LFCB.  If this is the last RFCB for
        // this LFCB, this will force the file closed even if there are
        // still references to the RFCB.  This will unblock blocked I/O.
        //

        UnlinkRfcbFromLfcb( rfcb );

        //
        // Release the "open" reference to the Rfcb.
        //

        SrvDereferenceRfcb( rfcb );

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.RfcbInfo.Closes );

        ACQUIRE_SPIN_LOCK( &Connection->SpinLock, &OldIrql );
    }

    RELEASE_SPIN_LOCK( &Connection->SpinLock, OldIrql );

    return;

} // SrvCloseCachedRfcbsOnConnection


VOID
SrvCloseCachedRfcbsOnLfcb (
    IN PLFCB Lfcb
    )

/*++

Routine Description:

    This routine closes all cached opens associated with a specific LFCB.

Arguments:

    Lfcb - Address of LFCB for which cached opens are to be closed.

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY nextListEntry;
    PRFCB rfcb;
    KIRQL oldIrql;
    LIST_ENTRY rfcbsToClose;

    ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );

    connection = Lfcb->Connection;
    IF_DEBUG(FILE_CACHE) {
        KdPrint(( "SrvCloseCachedRfcbsOnLfcb called for lfcb %p connection %p", Lfcb, connection ));
    }

    InitializeListHead( &rfcbsToClose );

    //
    // Lock and walk the connection's cached open list.  We don't
    // actually closed the RFCBs on the first pass, since that would
    // require releasing the lock.  Instead, we remove them from the
    // connection list and add them to a local list.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    for ( listEntry = connection->CachedOpenList.Flink;
          listEntry != &connection->CachedOpenList;
          listEntry = nextListEntry ) {

        rfcb = CONTAINING_RECORD( listEntry, RFCB, CachedOpenListEntry );
        nextListEntry = listEntry->Flink;

        if ( rfcb->Lfcb == Lfcb ) {

            //
            // Remove the RFCB from the connection's cache.
            //

            UpdateRfcbHistory( rfcb, 'fl$c' );

            RemoveEntryList( listEntry );
            connection->CachedOpenCount--;

            InsertTailList( &rfcbsToClose, listEntry );

            ASSERT( rfcb->CachedOpen );
            rfcb->CachedOpen = FALSE;

            ASSERT( rfcb->OplockState == OplockStateOwnServerBatch );
            rfcb->OplockState = OplockStateNone;

        }

    }

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    //
    // Walk the local list and close each RFCB.
    //

    for ( listEntry = rfcbsToClose.Flink;
          listEntry != &rfcbsToClose;
          listEntry = nextListEntry ) {

        rfcb = CONTAINING_RECORD( listEntry, RFCB, CachedOpenListEntry );
        nextListEntry = listEntry->Flink;

        IF_DEBUG(FILE_CACHE) {
            KdPrint(( "SrvCloseCachedRfcbsOnConnection; closing rfcb %p file %wZ\n",
                        rfcb, &rfcb->Mfcb->FileName ));
        }

        //
        // Unlink the RFCB from the LFCB.  If this is the last RFCB for
        // this LFCB, this will force the file closed even if there are
        // still references to the RFCB.  This will unblock blocked I/O.
        //

        UnlinkRfcbFromLfcb( rfcb );

        //
        // Release the "open" reference to the Rfcb.
        //

        SrvDereferenceRfcb( rfcb );

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.RfcbInfo.Closes );

    }

    return;

} // SrvCloseCachedRfcbsOnLfcb


#ifdef SRVDBG_RFCBHIST
VOID
UpdateRfcbHistory (
    IN PRFCB Rfcb,
    IN ULONG Event
    )
{
    KIRQL oldIrql;
    ACQUIRE_SPIN_LOCK( &Rfcb->SpinLock, &oldIrql );
    Rfcb->History[Rfcb->HistoryIndex++] = Event;
    RELEASE_SPIN_LOCK( &Rfcb->SpinLock, oldIrql );
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\blkdebug.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blkdebug.c

Abstract:

    Contains routines for debugging reference count problems.

Author:

    David Treadwell (davidtr) 30-Sept-1991

Revision History:

--*/

#include "precomp.h"
#include "blkdebug.tmh"
#pragma hdrstop

//
// This entire module is conditionalized out if SRVDBG2 is not defined.
//

#if SRVDBG2

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvInitializeReferenceHistory )
#pragma alloc_text( PAGE, SrvTerminateReferenceHistory )
#endif
#if 0
NOT PAGEABLE -- SrvUpdateReferenceHistory
NOT PAGEABLE -- SrvdbgClaimOrReleaseHandle
#endif


VOID
SrvInitializeReferenceHistory (
    IN PBLOCK_HEADER Block,
    IN ULONG InitialReferenceCount
    )

{
    PVOID caller, callersCaller;

    ULONG historyTableSize = sizeof(REFERENCE_HISTORY_ENTRY) *
                                             REFERENCE_HISTORY_LENGTH;

    PAGED_CODE( );

    Block->History.HistoryTable = ALLOCATE_NONPAGED_POOL(
                                     historyTableSize,
                                     BlockTypeDataBuffer
                                     );
    //
    // It we weren't able to allocate the memory, don't track references
    // and dereferences.
    //

    if ( Block->History.HistoryTable == NULL ) {
        Block->History.NextEntry = -1;
    } else {
        Block->History.NextEntry = 0;
        RtlZeroMemory( Block->History.HistoryTable, historyTableSize );
    }

    Block->History.TotalReferences = 0;
    Block->History.TotalDereferences = 0;

    //
    // Account for the initial reference(s).
    //

    RtlGetCallersAddress( &caller, &callersCaller );

    while ( InitialReferenceCount-- > 0 ) {
        SrvUpdateReferenceHistory( Block, caller, callersCaller, FALSE );
    }

    return;

} // SrvInitializeReferenceHistory


VOID
SrvUpdateReferenceHistory (
    IN PBLOCK_HEADER Block,
    IN PVOID Caller,
    IN PVOID CallersCaller,
    IN BOOLEAN IsDereference
    )

{
    KIRQL oldIrql;

    ACQUIRE_GLOBAL_SPIN_LOCK( Debug, &oldIrql );

    if ( IsDereference ) {
        Block->History.TotalDereferences++;
    } else {
        Block->History.TotalReferences++;
    }

    if ( Block->History.HistoryTable != 0 ) {

        PREFERENCE_HISTORY_ENTRY entry;
        PREFERENCE_HISTORY_ENTRY priorEntry;

        entry = &Block->History.HistoryTable[ Block->History.NextEntry ];

        if ( Block->History.NextEntry == 0 ) {
            priorEntry =
                &Block->History.HistoryTable[ REFERENCE_HISTORY_LENGTH-1 ];
        } else {
            priorEntry =
                &Block->History.HistoryTable[ Block->History.NextEntry-1 ];
        }

        entry->Caller = Caller;
        entry->CallersCaller = CallersCaller;

        if ( IsDereference ) {
            entry->NewReferenceCount = priorEntry->NewReferenceCount - 1;
            entry->IsDereference = (ULONG)TRUE;
        } else {
            entry->NewReferenceCount = priorEntry->NewReferenceCount + 1;
            entry->IsDereference = (ULONG)FALSE;
        }

        Block->History.NextEntry++;

        if ( Block->History.NextEntry >= REFERENCE_HISTORY_LENGTH ) {
            Block->History.NextEntry = 0;
        }
    }

    RELEASE_GLOBAL_SPIN_LOCK( Debug, oldIrql );

} // SrvUpdateReferenceHistory


VOID
SrvTerminateReferenceHistory (
    IN PBLOCK_HEADER Block
    )

{
    PAGED_CODE( );

    if ( Block->History.HistoryTable != 0 ) {
        DEALLOCATE_NONPAGED_POOL( Block->History.HistoryTable );
    }

    return;

} // SrvTerminateReferenceHistory

#endif // SRVDBG2


#if SRVDBG_HANDLES

#define HANDLE_HISTORY_SIZE 512

struct {
    ULONG HandleTypeAndOperation;
    PVOID Handle;
    ULONG Location;
    PVOID Data;
} HandleHistory[HANDLE_HISTORY_SIZE];

ULONG HandleHistoryIndex = 0;

VOID
SrvdbgClaimOrReleaseHandle (
    IN HANDLE Handle,
    IN PSZ HandleType,
    IN ULONG Location,
    IN BOOLEAN Release,
    IN PVOID Data
    )
{
    ULONG index;
    KIRQL oldIrql;

    ACQUIRE_GLOBAL_SPIN_LOCK( Debug, &oldIrql );
    index = HandleHistoryIndex;
    if ( ++HandleHistoryIndex >= HANDLE_HISTORY_SIZE ) {
        HandleHistoryIndex = 0;
    }
    RELEASE_GLOBAL_SPIN_LOCK( Debug, oldIrql );

    HandleHistory[index].HandleTypeAndOperation =
        (*(PULONG)HandleType << 8) | (Release ? 'c' : 'o');
    HandleHistory[index].Handle = Handle;
    HandleHistory[index].Location = Location;
    HandleHistory[index].Data = Data;

    return;

} // SrvdbgClaimOrReleaseHandle

#endif // SRVDBG_HANDLES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\smbtrsup\smbtrsup.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    smbtrsup.c

Abstract:

    This module contains the code to implement the kernel mode SmbTrace
    component within the LanMan server and redirector.
    The interface between the kernel mode component and the
    server/redirector is found in nt\private\inc\smbtrsup.h
    The interface providing user-level access to SmbTrace is found in
    nt\private\inc\smbtrace.h

Author:

    Peter Gray (w-peterg)   23-March-1992

Revision History:

    Stephan Mueller (t-stephm)   21-July-1992

        Completed, fixed bugs, moved all associated declarations here
        from various places in the server, ported to the redirector
        and converted to a kernel DLL.

--*/

#include <ntifs.h>
#include <smbtrace.h>     // for names and structs shared with user-mode app

#define _SMBTRSUP_SYS_ 1  // to get correct definitions for exported variables
#include <smbtrsup.h>     // for functions exported to server/redirector

#if DBG
ULONG SmbtrsupDebug = 0;
#define TrPrint(x) if (SmbtrsupDebug) KdPrint(x)
#else
#define TrPrint(x)
#endif

//
// we assume all well-known names are #defined in Unicode, and require
// them to be so: in the SmbTrace application and the smbtrsup.sys package
//
#ifndef UNICODE
#error "UNICODE build required"
#endif


#if DBG
#define PAGED_DBG 1
#endif
#ifdef PAGED_DBG
#undef PAGED_CODE
#define PAGED_CODE() \
    struct { ULONG bogus; } ThisCodeCantBePaged; \
    ThisCodeCantBePaged; \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
        KdPrint(( "SMBTRSUP: Pageable code called at IRQL %d.  File %s, Line %d\n", KeGetCurrentIrql(), __FILE__, __LINE__ )); \
        ASSERT(FALSE); \
        }
#define PAGED_CODE_CHECK() if (ThisCodeCantBePaged) ;
ULONG ThisCodeCantBePaged;
#else
#define PAGED_CODE_CHECK()
#endif


#if PAGED_DBG
#define ACQUIRE_SPIN_LOCK(a, b) {               \
    PAGED_CODE_CHECK();                         \
    KeAcquireSpinLock(a, b);                    \
    }
#define RELEASE_SPIN_LOCK(a, b) {               \
    PAGED_CODE_CHECK();                         \
    KeReleaseSpinLock(a, b);                    \
    }

#else
#define ACQUIRE_SPIN_LOCK(a, b) KeAcquireSpinLock(a, b)
#define RELEASE_SPIN_LOCK(a, b) KeReleaseSpinLock(a, b)
#endif

//
// Increment shared variable in instance data using appropriate interlock
//
#define LOCK_INC_ID(var)                                     \
     ExInterlockedAddUlong( (PULONG)&ID(var),                \
                            1, &ID(var##Interlock) )

//
// Zero shared variable in instance data using appropriate interlock
//
#define LOCK_ZERO_ID(var) {                                  \
     ID(var) = 0;                                            \
     }


//
// The various states SmbTrace can be in.  These states are internal
// only.  The external SmbTraceActive variable contains much less
// detailed information:  it is TRUE when TraceRunning, FALSE in any other
// state.
//
typedef enum _SMBTRACE_STATE {
    TraceStopped,          // not running
    TraceStarting,         // preparing to run
    TraceStartStopFile,    // starting, but want to shut down immediately
                           // because the FileObject closed
    TraceStartStopNull,    // starting, but want to shut down immediately
                           // because a new fsctl came in
    TraceAppWaiting,       // waiting for application to die
    TraceRunning,          // processing SMBs
    TraceStopping          // waiting for smbtrace thread to stop
} SMBTRACE_STATE;


//
// Structure used to hold information regarding an SMB which is put into
// the SmbTrace thread queue.
//
typedef struct _SMBTRACE_QUEUE_ENTRY {
    LIST_ENTRY  ListEntry;      // usual doubly-linked list
    ULONG       SmbLength;      // the length of this SMB
    PVOID       Buffer;         // pointer into SmbTracePortMemoryHeap
                                // or non-paged pool
    PVOID       SmbAddress;     // address of real SMB, if SMB still
                                // available (i.e. if slow mode)
    BOOLEAN     BufferNonPaged; // TRUE if Buffer in non-paged pool, FALSE if
                                // Buffer in SmbTracePortMemoryHeap
                                // Redirector-specific
    PKEVENT     WaitEvent;      // pointer to worker thread event to be
                                // signalled when SMB has been processed
                                // slow mode specific
} SMBTRACE_QUEUE_ENTRY, *PSMBTRACE_QUEUE_ENTRY;


//
// Instance data is specific to the component being traced.  In order
// to unclutter the source code, use the following macro to access
// instance specific data.
// Every exported function either has an explicit parameter (named
// Component) which the caller provides, or is implicitly applicable
// only to one component, and has a local variable named Component
// which is always set to the appropriate value.
//
#define ID(field) (SmbTraceData[Component].field)

//
// Instance data.  The fields which need to be statically initialized
// are declared before those that we don't care to initialize.
//
typedef struct _INSTANCE_DATA {

    //
    // Statically initialized fields.
    //

    //
    // Names for identifying the component being traced in KdPrint messages,
    // and global objects
    //
    PCHAR ComponentName;
    PWSTR SharedMemoryName;
    PWSTR NewSmbEventName;
    PWSTR DoneSmbEventName;

    //
    //  Prevent reinitializing resources if rdr/srv reloaded
    //
    BOOLEAN InstanceInitialized;

    //
    // some tracing parameters, from SmbTrace application
    //
    BOOLEAN SingleSmbMode;
    CLONG   Verbosity;

    //
    // State of the current trace.
    //
    SMBTRACE_STATE TraceState;

    //
    // Pointer to file object of client who started the current trace.
    //
    PFILE_OBJECT StartersFileObject;

    //
    // Fsp process of the component we're tracing in.
    //
    PEPROCESS FspProcess;

    //
    // All subsequent fields are not expliticly statically initiliazed.
    //

    //
    // Current count of number of SMBs lost since last one output.
    // Use an interlock to access, cleared when an SMB is sent to
    // the client successfully.  This lock is used with ExInterlockedXxx
    // routines, so it cannot be treated as a real spin lock (i.e.
    // don't use KeAcquireSpinLock.)
    //
    KSPIN_LOCK SmbsLostInterlock;
    ULONG      SmbsLost;

    //
    // some events, only accessed within the kernel
    //
    KEVENT ActiveEvent;
    KEVENT TerminatedEvent;
    KEVENT TerminationEvent;
    KEVENT AppTerminationEvent;
    KEVENT NeedMemoryEvent;

    //
    // some events, shared with the outside world
    //
    HANDLE NewSmbEvent;
    HANDLE DoneSmbEvent;

    //
    // Handle to the shared memory used for communication between
    // the server/redirector and SmbTrace.
    //
    HANDLE SectionHandle;

    //
    // Pointers to control the shared memory for the SmbTrace application.
    // The port memory heap handle is initialized to NULL to indicate that
    // there is no connection with SmbTrace yet.
    //
    PVOID PortMemoryBase;
    ULONG_PTR PortMemorySize;
    ULONG TableSize;
    PVOID PortMemoryHeap;

    //
    // serialized access to the heap,
    // to allow clean shutdown (StateInterlock)
    //
    KSPIN_LOCK  HeapReferenceCountLock;
    PERESOURCE  StateInterlock;
    PERESOURCE  HeapInterlock;
    ULONG       HeapReferenceCount;
     
    WORK_QUEUE_ITEM    DereferenceWorkQueueItem;

    //
    // Pointers to the structured data, located in the shared memory.
    //
    PSMBTRACE_TABLE_HEADER  TableHeader;
    PSMBTRACE_TABLE_ENTRY   Table;

    //
    // Fields for the SmbTrace queue.  The server/redirector puts
    // incoming and outgoing SMBs into this queue (when
    // SmbTraceActive[Component] is TRUE and they are processed
    // by the SmbTrace thread.
    //
    LIST_ENTRY Queue;            // The queue itself
    KSPIN_LOCK QueueInterlock;   // Synchronizes access to queue
    KSEMAPHORE QueueSemaphore;   // Counts elements in queue

} INSTANCE_DATA;


#ifdef  ALLOC_DATA_PRAGMA
#pragma data_seg("PAGESMBD")
#endif
//
// Global variables for SmbTrace support
//

INSTANCE_DATA SmbTraceData[] = {

    //
    // Server data
    //

    {
        "Srv",                                 // ComponentName
        SMBTRACE_SRV_SHARED_MEMORY_NAME,       // SharedMemoryName
        SMBTRACE_SRV_NEW_SMB_EVENT_NAME,       // NewSmbEventName
        SMBTRACE_SRV_DONE_SMB_EVENT_NAME,      // DoneSmbEventName

        FALSE,                                 // InstanceInitialized

        FALSE,                                 // SingleSmbMode
        SMBTRACE_VERBOSITY_ERROR,              // Verbosity

        TraceStopped,                          // TraceState

        NULL,                                  // StartersFileObject
        NULL                                   // FspProcess

        // rest of fields expected to get 'all-zeroes'
    },

    //
    // Redirector data
    //

    {
        "Rdr",                                 // ComponentName
        SMBTRACE_LMR_SHARED_MEMORY_NAME,       // SharedMemoryName
        SMBTRACE_LMR_NEW_SMB_EVENT_NAME,       // NewSmbEventName
        SMBTRACE_LMR_DONE_SMB_EVENT_NAME,      // DoneSmbEventName

        FALSE,                                 // InstanceInitialized

        FALSE,                                 // SingleSmbMode
        SMBTRACE_VERBOSITY_ERROR,              // Verbosity

        TraceStopped,                          // TraceState

        NULL,                                  // StartersFileObject
        NULL                                   // FspProcess

        // rest of fields expected to get 'all-zeroes'
    }
};


//
// some state booleans, exported to clients.  For this reason,
// they're stored separately from the rest of the instance data.
// Initially, SmbTrace is neither active nor transitioning.
//
BOOLEAN SmbTraceActive[] = {FALSE, FALSE};
BOOLEAN SmbTraceTransitioning[] = {FALSE, FALSE};

HANDLE
SmbTraceDiscardableCodeHandle = 0;

HANDLE
SmbTraceDiscardableDataHandle = 0;

#ifdef  ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

//
// Forward declarations of internal routines
//

BOOLEAN
SmbTraceReferenceHeap(
    IN SMBTRACE_COMPONENT Component
    );

VOID
SmbTraceDereferenceHeap(
    IN SMBTRACE_COMPONENT Component
    );

VOID
SmbTraceDisconnect(
    IN SMBTRACE_COMPONENT Component
    );

VOID
SmbTraceEmptyQueue (
    IN SMBTRACE_COMPONENT Component
    );

VOID
SmbTraceThreadEntry(
    IN PVOID Context
    );

NTSTATUS
SmbTraceFreeMemory (
    IN SMBTRACE_COMPONENT Component
    );

VOID
SmbTraceToClient(
    IN PVOID Smb,
    IN CLONG SmbLength,
    IN PVOID SmbAddress,
    IN SMBTRACE_COMPONENT Component
    );

ULONG
SmbTraceMdlLength(
    IN PMDL Mdl
    );

VOID
SmbTraceCopyMdlContiguous(
    OUT PVOID Destination,
    IN  PMDL Mdl,
    IN  ULONG Length
    );

//NTSTATUS
//DriverEntry(
//    IN PDRIVER_OBJECT DriverObject,
//    IN PUNICODE_STRING RegistryPath
//    );

VOID
SmbTraceDeferredDereferenceHeap(
    IN PVOID Context
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbTraceInitialize)
#pragma alloc_text(PAGE, SmbTraceTerminate)
#pragma alloc_text(PAGE, SmbTraceStart)
#pragma alloc_text(PAGE, SmbTraceStop)
#pragma alloc_text(PAGE, SmbTraceCompleteSrv)
#pragma alloc_text(PAGE, SmbTraceDisconnect)
#pragma alloc_text(PAGE, SmbTraceEmptyQueue)
#pragma alloc_text(PAGE, SmbTraceThreadEntry)
#pragma alloc_text(PAGE, SmbTraceFreeMemory)
#pragma alloc_text(PAGE, SmbTraceToClient)
#pragma alloc_text(PAGE, SmbTraceDeferredDereferenceHeap)
#pragma alloc_text(PAGESMBC, SmbTraceCompleteRdr)
#pragma alloc_text(PAGESMBC, SmbTraceReferenceHeap)
#pragma alloc_text(PAGESMBC, SmbTraceDereferenceHeap)
#pragma alloc_text(PAGESMBC, SmbTraceMdlLength)
#pragma alloc_text(PAGESMBC, SmbTraceCopyMdlContiguous)
#endif



//
// Exported routines
//


NTSTATUS
SmbTraceInitialize (
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    This routine initializes the SmbTrace component-specific instance
    globals.  On first-ever invocation, it performs truly global
    initialization.

Arguments:

    Component - Context from which we're called: server or redirector

Return Value:

    NTSTATUS - Indicates failure if unable to allocate resources

--*/

{
    PAGED_CODE();

    if ( ID(InstanceInitialized) == FALSE ) {
        //
        // Component specific initialization -- events and locks.
        //

        KeInitializeEvent( &ID(ActiveEvent), NotificationEvent, FALSE);
        KeInitializeEvent( &ID(TerminatedEvent), NotificationEvent, FALSE);
        KeInitializeEvent( &ID(TerminationEvent), NotificationEvent, FALSE);
        KeInitializeEvent( &ID(AppTerminationEvent), NotificationEvent, FALSE);
        KeInitializeEvent( &ID(NeedMemoryEvent), NotificationEvent, FALSE);

        KeInitializeSpinLock( &ID(SmbsLostInterlock) );
        KeInitializeSpinLock( &ID(HeapReferenceCountLock) );

        ID(StateInterlock) = ExAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof(ERESOURCE),
                                'tbmS'
                                );
        if ( ID(StateInterlock) == NULL ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        ExInitializeResourceLite( ID(StateInterlock) );

        ID(HeapInterlock) = ExAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof(ERESOURCE),
                                'tbmS'
                                );
        if ( ID(HeapInterlock) == NULL ) {
            ExDeleteResourceLite( ID(StateInterlock) );
            ExFreePool( ID(StateInterlock) );
            ID(StateInterlock) = NULL;
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        ExInitializeResourceLite( ID(HeapInterlock) );

        ID(InstanceInitialized) = TRUE;
    }

    return STATUS_SUCCESS;

} // SmbTraceInitialize


VOID
SmbTraceTerminate (
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    This routine cleans up the SmbTrace component-specific instance
    globals.  It should be called by the component when the component
    is unloaded.

Arguments:

    Component - Context from which we're called: server or redirector

Return Value:

    None

--*/

{
    PAGED_CODE();

    if ( ID(InstanceInitialized) ) {

        ExDeleteResourceLite( ID(StateInterlock) );
        ExFreePool( ID(StateInterlock) );

        ExDeleteResourceLite( ID(HeapInterlock) );
        ExFreePool( ID(HeapInterlock) );

        ID(InstanceInitialized) = FALSE;
    }

    return;

} // SmbTraceTerminate


NTSTATUS
SmbTraceStart (
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength,
    IN OUT PVOID ConfigInOut,
    IN PFILE_OBJECT FileObject,
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    This routine performs all the work necessary to connect the server/
    redirector to SmbTrace.  It creates the section of shared memory to
    be used, then creates the events needed. All these objects are then
    opened by the client (smbtrace) program. This code initializes the
    table, the heap stored in the section and table header.  This routine
    must be called from an Fsp process.

Arguments:

    InputBufferLength - Length of the ConfigInOut packet

    OutputBufferLength - Length expected for the ConfigInOut packet returned

    ConfigInOut - A structure that has configuration information.

    FileObject - FileObject of the process requesting that SmbTrace be started,
                 used to automatically shut down when the app dies.

    Component - Context from which we're called: server or redirector

Return Value:

    NTSTATUS - result of operation.

--*/

// size of our one, particular, ACL
#define ACL_LENGTH  (ULONG)sizeof(ACL) +                 \
                    (ULONG)sizeof(ACCESS_ALLOWED_ACE) +  \
                    sizeof(LUID) +                       \
                    8

{
    NTSTATUS status;
    UNICODE_STRING memoryNameU;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    UCHAR Buffer[ACL_LENGTH];
    PACL AdminAcl = (PACL)(&Buffer[0]);
    SECURITY_DESCRIPTOR securityDescriptor;

    UNICODE_STRING eventNameU;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG i;
    LARGE_INTEGER sectionSize;
    PSMBTRACE_CONFIG_PACKET_REQ  ConfigPacket;
    PSMBTRACE_CONFIG_PACKET_RESP ConfigPacketResp;
    HANDLE threadHandle;

    PAGED_CODE();

    ASSERT( ID(InstanceInitialized) );

    //
    // Validate the buffer lengths passed in.
    //

    if ( ( InputBufferLength  != sizeof( SMBTRACE_CONFIG_PACKET_REQ ) )
      || ( OutputBufferLength != sizeof( SMBTRACE_CONFIG_PACKET_RESP ) )
    ) {

        TrPrint(( "%s!SmbTraceStart: config packet(s) of wrong size!\n",
                  ID(ComponentName) ));

        return STATUS_INFO_LENGTH_MISMATCH;

    }

    ExAcquireResourceExclusiveLite( ID(StateInterlock), TRUE );

    if ( ID(TraceState) != TraceStopped ) {
        ExReleaseResourceLite( ID(StateInterlock) );
        return STATUS_INVALID_DEVICE_STATE;
    }

    ASSERT(!SmbTraceActive[Component]);

    ASSERT (SmbTraceDiscardableDataHandle == NULL);

    ASSERT (SmbTraceDiscardableCodeHandle == NULL);

    SmbTraceDiscardableCodeHandle = MmLockPagableCodeSection(SmbTraceReferenceHeap);

    SmbTraceDiscardableDataHandle = MmLockPagableDataSection(SmbTraceData);

    ID(TraceState) = TraceStarting;

    //
    // Initialize global variables so that we know what to close on errexit
    //

    ID(SectionHandle) = NULL;
    ID(PortMemoryHeap) = NULL;
    ID(NewSmbEvent) = NULL;
    ID(DoneSmbEvent) = NULL;

    //
    // Caution! Both input and output packets are the same, we must
    // read all of the input before we write any output.
    //

    ConfigPacket = (PSMBTRACE_CONFIG_PACKET_REQ) ConfigInOut;
    ConfigPacketResp = (PSMBTRACE_CONFIG_PACKET_RESP) ConfigInOut;

    //
    // Set the mode of operation (read all values).
    //

    ID(SingleSmbMode)  = ConfigPacket->SingleSmbMode;
    ID(Verbosity)      = ConfigPacket->Verbosity;
    ID(PortMemorySize) = ConfigPacket->BufferSize;
    ID(TableSize)      = ConfigPacket->TableSize;

    //
    // Create a security descriptor containing a discretionary Acl
    // allowing administrator access.  This SD will be used to allow
    // Smbtrace access to the shared memory and the notification events.
    //

    // Create Acl allowing administrator access using well-known Sid.

    status = RtlCreateAcl( AdminAcl, ACL_LENGTH, ACL_REVISION2 );
    if ( !NT_SUCCESS(status) ) {
        TrPrint((
            "%s!SmbTraceStart: RtlCreateAcl failed: %X\n",
            ID(ComponentName), status ));
        goto errexit;
    }

    status = RtlAddAccessAllowedAce(
             AdminAcl,
             ACL_REVISION2,
             GENERIC_ALL,
             SeExports->SeAliasAdminsSid
             );
    if ( !NT_SUCCESS(status) ) {
        TrPrint((
            "%s!SmbTraceStart: RtlAddAccessAllowedAce failed: %X\n",
            ID(ComponentName), status ));
        goto errexit;
    }

    // Create SecurityDescriptor containing AdminAcl as a discrectionary ACL.

    RtlCreateSecurityDescriptor(
             &securityDescriptor,
             SECURITY_DESCRIPTOR_REVISION1
             );
    if ( !NT_SUCCESS(status) ) {
        TrPrint((
            "%s!SmbTraceStart: RtlCreateSecurityDescriptor failed: %X\n",
            ID(ComponentName), status ));
        goto errexit;
    }

    status = RtlSetDaclSecurityDescriptor(
             &securityDescriptor,
             TRUE,
             AdminAcl,
             FALSE
             );
    if ( !NT_SUCCESS(status) ) {
        TrPrint((
            "%s!SmbTraceStart: "
            "RtlSetDAclAllowedSecurityDescriptor failed: %X\n",
            ID(ComponentName), status ));
        goto errexit;
    }

    //
    // Create the section to be used for communication between the
    // server/redirector and SmbTrace.
    //

    // Define the object name.

    RtlInitUnicodeString( &memoryNameU, ID(SharedMemoryName) );

    // Define the object information, including security descriptor and name.

    InitializeObjectAttributes(
        &objectAttributes,
        &memoryNameU,
        OBJ_CASE_INSENSITIVE,
        NULL,
        &securityDescriptor
        );

    // Setup the section size.

    sectionSize.QuadPart = ID(PortMemorySize);

    // Create the named section of memory with all of our attributes.

    status = ZwCreateSection(
                &ID(SectionHandle),
                SECTION_MAP_READ | SECTION_MAP_WRITE,
                &objectAttributes,
                &sectionSize,
                PAGE_READWRITE,
                SEC_RESERVE,
                NULL                        // file handle
                );

    if ( !NT_SUCCESS(status) ) {
        TrPrint(( "%s!SmbTraceStart: ZwCreateSection failed: %X\n",
                  ID(ComponentName), status ));
        goto errexit;
    }

    // Now, map it into our address space.

    ID(PortMemoryBase) = NULL;

    status = ZwMapViewOfSection(
                    ID(SectionHandle),
                    NtCurrentProcess(),
                    &ID(PortMemoryBase),
                    0,                        // zero bits (don't care)
                    0,                        // commit size
                    NULL,                     // SectionOffset
                    &ID(PortMemorySize),      // viewSize
                    ViewUnmap,                // inheritDisposition
                    0L,                       // allocation type
                    PAGE_READWRITE            // protection
                    );

    if ( !NT_SUCCESS(status) ) {
        TrPrint(( "%s!SmbTraceStart: NtMapViewOfSection failed: %X\n",
                  ID(ComponentName), status ));
        goto errexit;
    }

    //
    // Set up the shared section memory as a heap.
    //
    // *** Note that the HeapInterlock for the client instance is passed
    //     to the heap manager to be used for serialization of
    //     allocation and deallocation.  It is necessary for the
    //     resource to be allocated FROM NONPAGED POOL externally to the
    //     heap manager, because if we let the heap manager allocate
    //     the resource, if would allocate it from process virtual
    //     memory.
    //

    ID(PortMemoryHeap) = RtlCreateHeap(
                              0,                            // Flags
                              ID(PortMemoryBase),           // HeapBase
                              ID(PortMemorySize),           // ReserveSize
                              PAGE_SIZE,                    // CommitSize
                              ID(HeapInterlock),            // Lock
                              0                             // Reserved
                              );

    //
    // Allocate and initialize the table and its header.
    //

    ID(TableHeader) = RtlAllocateHeap(
                                    ID(PortMemoryHeap), 0,
                                    sizeof( SMBTRACE_TABLE_HEADER )
                                    );

    ID(Table) = RtlAllocateHeap(
                        ID(PortMemoryHeap), 0,
                        sizeof( SMBTRACE_TABLE_ENTRY ) * ID(TableSize)
                        );

    if ( (ID(TableHeader) == NULL) || (ID(Table) == NULL) ) {
        TrPrint((
            "%s!SmbTraceStart: Not enough memory!\n",
            ID(ComponentName) ));

        status = STATUS_NO_MEMORY;

        goto errexit;
    }

    // Initialize the values inside.

    ID(TableHeader)->HighestConsumed = 0;
    ID(TableHeader)->NextFree = 1;
    ID(TableHeader)->ApplicationStop = FALSE;

    for ( i = 0; i < ID(TableSize); i++) {
        ID(Table)[i].BufferOffset = 0L;
        ID(Table)[i].SmbLength = 0L;
    }

    //
    // Create the required event handles.
    //

    // Define the object information.

    RtlInitUnicodeString( &eventNameU, ID(NewSmbEventName) );

    InitializeObjectAttributes(
        &objectAttributes,
        &eventNameU,
        OBJ_CASE_INSENSITIVE,
        NULL,
        &securityDescriptor
        );

    // Open the named object.

    status = ZwCreateEvent(
                &ID(NewSmbEvent),
                EVENT_ALL_ACCESS,
                &objectAttributes,
                NotificationEvent,
                FALSE                        // initial state
                );

    if ( !NT_SUCCESS(status) ) {
        TrPrint(( "%s!SmbTraceStart: ZwCreateEvent (1st) failed: %X\n",
                  ID(ComponentName), status ));

        goto errexit;
    }

    if ( ID(SingleSmbMode) ) {    // this event may not be required.

        // Define the object information.

        RtlInitUnicodeString( &eventNameU, ID(DoneSmbEventName) );

        InitializeObjectAttributes(
            &objectAttributes,
            &eventNameU,
            OBJ_CASE_INSENSITIVE,
            NULL,
            &securityDescriptor
            );

        // Create the named object.

        status = ZwCreateEvent(
                    &ID(DoneSmbEvent),
                    EVENT_ALL_ACCESS,
                    &objectAttributes,
                    NotificationEvent,
                    FALSE                    // initial state
                    );

        if ( !NT_SUCCESS(status) ) {
            TrPrint((
                "%s!SmbTraceStart: NtCreateEvent (2nd) failed: %X\n",
                 ID(ComponentName), status ));
            goto errexit;
        }
        TrPrint(( "%s!SmbTraceStart: DoneSmbEvent handle %x in process %x\n",
                ID(ComponentName), ID(DoneSmbEvent), PsGetCurrentProcess()));

    }

    //
    //  Reset any events that may be in the wrong state from a previous run.
    //

    KeResetEvent(&ID(TerminationEvent));
    KeResetEvent(&ID(TerminatedEvent));

    //
    // Connection was successful, now start the SmbTrace thread.
    //

    //
    // Create the SmbTrace thread and wait for it to finish
    // initializing (at which point SmbTraceActiveEvent is set)
    //

    status = PsCreateSystemThread(
        &threadHandle,
        THREAD_ALL_ACCESS,
        NULL,
        NtCurrentProcess(),
        NULL,
        (PKSTART_ROUTINE) SmbTraceThreadEntry,
        (PVOID)Component
        );

    if ( !NT_SUCCESS(status) ) {

        TrPrint((
            "%s!SmbTraceStart: PsCreateSystemThread failed: %X\n",
            ID(ComponentName), status ));

        goto errexit;
    }

    //
    // Wait until SmbTraceThreadEntry has finished initializing
    //

    (VOID)KeWaitForSingleObject(
            &ID(ActiveEvent),
            UserRequest,
            KernelMode,
            FALSE,
            NULL
            );

    //
    // Close the handle to the process so the object will be
    // destroyed when the thread dies.
    //

    ZwClose( threadHandle );


    //
    // Record who started SmbTrace so we can stop if he dies or otherwise
    // closes this handle to us.
    //

    ID(StartersFileObject) = FileObject;

    //
    // Record caller's process; which is always the appropriate Fsp
    // process.
    //

    ID(FspProcess) = PsGetCurrentProcess();


    //
    // Setup the response packet, since everything worked (write all values).
    //

    ConfigPacketResp->HeaderOffset = (ULONG)
                                ( (ULONG_PTR)ID(TableHeader)
                                - (ULONG_PTR)ID(PortMemoryBase) );

    ConfigPacketResp->TableOffset = (ULONG)
                                ( (ULONG_PTR)ID(Table)
                                - (ULONG_PTR)ID(PortMemoryBase) );

    TrPrint(( "%s!SmbTraceStart: SmbTrace started.\n", ID(ComponentName) ));

    ExReleaseResourceLite( ID(StateInterlock) );

    //
    // if someone wanted it shut down while it was starting, shut it down
    //

    switch ( ID(TraceState) ) {

    case TraceStartStopFile :
        SmbTraceStop( ID(StartersFileObject), Component );
        return STATUS_UNSUCCESSFUL;  // app closed, so we should shut down
        break;

    case TraceStartStopNull :
        SmbTraceStop( NULL, Component );
        return STATUS_UNSUCCESSFUL;  // someone requested a shut down
        break;

    default :
        ID(TraceState) = TraceRunning;
        SmbTraceActive[Component] = TRUE;
        return STATUS_SUCCESS;
    }

errexit:

    SmbTraceDisconnect( Component );

    ID(TraceState) = TraceStopped;

    ExReleaseResourceLite( ID(StateInterlock) );

    //
    // return original failure status code, not success of cleanup
    //

    return status;

} // SmbTraceStart

// constant only of interest while constructing the particular Acl
// in SmbTraceStart
#undef ACL_LENGTH


NTSTATUS
SmbTraceStop(
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    This routine stops tracing in the server/redirector.  If no
    FileObject is provided, the SmbTrace application is stopped.
    If a FileObject is provided, SmbTrace is stopped if the
    FileObject refers to the one who started it.

Arguments:

    FileObject - FileObject of a process that terminated.  If it's the process
                 that requested SmbTracing, we shut down automatically.

    Component - Context from which we're called: server or redirector

Return Value:

    NTSTATUS - result of operation.  Possible results are:
        STATUS_SUCCESS - SmbTrace was stopped
        STATUS_UNSUCCESSFUL - SmbTrace was not stopped because the
            provided FileObject did not refer to the SmbTrace starter
            or because SmbTrace was not running.

--*/

{
    PAGED_CODE();

    //
    // If we haven't been initialized, there's nothing to stop.  (And no
    // resource to acquire!)
    //

    if ( !ID(InstanceInitialized) ) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // If it's not the FileObject that started SmbTrace, we don't care.
    // From then on, if ARGUMENT_PRESENT(FileObject) it's the right one.
    //

    if ( ARGUMENT_PRESENT(FileObject) &&
         FileObject != ID(StartersFileObject)
    ) {
       return STATUS_UNSUCCESSFUL;
    }

    ExAcquireResourceExclusiveLite( ID(StateInterlock), TRUE );

    //
    // Depending on the current state of SmbTrace and whether this is
    // a FileObject or unconditional shutdown request, we do different
    // things.  It is always clear at this point, though, that
    // SmbTraceActive should be set to FALSE.
    //

    SmbTraceActive[Component] = FALSE;

    switch ( ID(TraceState) ) {
    case TraceStopped :
    case TraceStopping :
    case TraceStartStopFile :
    case TraceStartStopNull :

        // if we're not running or already in a mode where we know we'll
        // soon be shut down, ignore the request.
        ExReleaseResourceLite( ID(StateInterlock) );
        return STATUS_UNSUCCESSFUL;
        break;

    case TraceStarting :

        // inform starting SmbTrace that it should shut down immediately
        // upon finishing initialization.  It needs to know whether this
        // is a FileObject or unconditional shutdown request.

        ID(TraceState) = ARGUMENT_PRESENT(FileObject)
                       ? TraceStartStopFile
                       : TraceStartStopNull;
        ExReleaseResourceLite( ID(StateInterlock) );
        return STATUS_SUCCESS;
        break;

    case TraceAppWaiting :

        // we're waiting for the application to die already, so ignore
        // new unconditional requests.  But FileObject requests are
        // welcomed.  We cause the SmbTrace thread to kill itself.
        if ( ARGUMENT_PRESENT(FileObject) ) {
            break;  // thread kill code follows switch
        } else {
            ExReleaseResourceLite( ID(StateInterlock) );
            return STATUS_UNSUCCESSFUL;
        }
        break;

    case TraceRunning :

        // if it's a FileObject request, the app is dead, so we cause
        // the SmbTrace thread to kill itself.  Otherwise, we need to
        // signal the app to stop and return.  When the app is gone, we
        // will be called again; this time with a FileObject.

        if ( ARGUMENT_PRESENT(FileObject) ) {
            break;  // thread kill code follows switch
        } else {
            KeSetEvent( &ID(AppTerminationEvent), 2, FALSE );
            ID(TraceState) = TraceAppWaiting;
            ExReleaseResourceLite( ID(StateInterlock) );
            return STATUS_SUCCESS;
        }

        break;

    default :
        ASSERT(!"SmbTraceStop: invalid TraceState");
        break;
    }

    //
    // We reach here from within the switch only in the case where
    // we actually want to kill the SmbTrace thread.  Signal it to
    // wake up, and wait until it terminates.  Signal DoneSmbEvent
    // in case it is currently waiting for the application to signal
    // it in slow mode.
    //

    ID(StartersFileObject) = NULL;

    if ( ID(SingleSmbMode)) {

        BOOLEAN ProcessAttached = FALSE;

        if (PsGetCurrentProcess() != ID(FspProcess)) {
            KeAttachProcess(ID(FspProcess));
            ProcessAttached = TRUE;
        }

        TrPrint(( "%s!SmbTraceStop: Signal DoneSmbEvent, handle %x, process %x.\n",
                    ID(ComponentName), ID(DoneSmbEvent), PsGetCurrentProcess()));
        ZwSetEvent( ID(DoneSmbEvent), NULL );

        if (ProcessAttached) {
            KeDetachProcess();
        }

    }

    TrPrint(( "%s!SmbTraceStop: Signal Termination Event.\n", ID(ComponentName) ));
    ID(TraceState) = TraceStopping;
    KeSetEvent( &ID(TerminationEvent), 2, FALSE );

    ExReleaseResourceLite( ID(StateInterlock) );

    KeWaitForSingleObject(
        &ID(TerminatedEvent),
        UserRequest,
        KernelMode,
        FALSE,
        NULL
        );

    TrPrint(( "%s!SmbTraceStop: Terminated Event is set.\n", ID(ComponentName) ));
    ExAcquireResourceExclusiveLite( ID(StateInterlock), TRUE );

    ID(TraceState) = TraceStopped;

    ExReleaseResourceLite( ID(StateInterlock) );

    TrPrint(( "%s!SmbTraceStop: SmbTrace stopped.\n", ID(ComponentName) ));

    MmUnlockPagableImageSection(SmbTraceDiscardableCodeHandle);

    SmbTraceDiscardableCodeHandle = NULL;

    MmUnlockPagableImageSection(SmbTraceDiscardableDataHandle);

    SmbTraceDiscardableDataHandle = NULL;

    return STATUS_SUCCESS;

} // SmbTraceStop


VOID
SmbTraceCompleteSrv (
    IN PMDL SmbMdl,
    IN PVOID Smb,
    IN CLONG SmbLength
    )

/*++

Routine Description:

    Server version.

    Snapshot an SMB and export it to the SmbTrace application.  How
    this happens is determined by which mode (fast or slow) SmbTracing
    was requested in.  In the server, it is easy to guarantee that when
    tracing, a thread is always executing in the Fsp.

    Fast mode: the SMB is copied into shared memory and an entry for it
    is queued to the server SmbTrace thread, which asynchronously
    passes SMBs to the app.  If there is insufficient memory
    for anything (SMB, queue entry, etc.) the SMB is lost.

    Slow mode: identical to Fast mode except that this thread waits
    until the server SmbTrace thread signals that the app has finished
    processing the SMB.  Because each thread waits until its SMB has
    been completely processed, there is much less chance of running
    out of any resources.

    The SMB is either contained in SmbMdl, or at address Smb with length
    SmbLength.

Arguments:

    SmbMdl - an Mdl containing the SMB.

    Smb - a pointer to the SMB.

    SmbLength - the length of the SMB.

Return Value:

    None

--*/

{
    PSMBTRACE_QUEUE_ENTRY  queueEntry;
    PVOID  buffer;
    SMBTRACE_COMPONENT Component = SMBTRACE_SERVER;
    KEVENT WaitEvent;

    PAGED_CODE();

    //
    // This routine is server specific.
    //

    ASSERT( ID(TraceState) == TraceRunning );
    ASSERT( SmbTraceActive[SMBTRACE_SERVER] );

    //
    // We want either an Mdl, or a pointer and a length, or occasionally,
    // a completely NULL response.
    //

    ASSERT( ( SmbMdl == NULL  &&  Smb != NULL  &&  SmbLength != 0 )
         || ( SmbMdl != NULL  &&  Smb == NULL  &&  SmbLength == 0 )
         || ( SmbMdl == NULL  &&  Smb == NULL  &&  SmbLength == 0 ) );

    //
    // We've taken pains not to be at DPC level and to be in
    // the Fsp context too, for that matter.
    //

    ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL);
    ASSERT( PsGetCurrentProcess() == ID(FspProcess) );

    //
    // Ensure that SmbTrace really is still active and hence, the
    // shared memory is still around.
    //

    if ( SmbTraceReferenceHeap( Component ) == FALSE ) {
        return;
    }

    //
    // If the SMB is currently in an MDL, we don't yet have the length,
    // which we need, to know how much memory to allocate.
    //

    if ( SmbMdl != NULL ) {
        SmbLength = SmbTraceMdlLength(SmbMdl);
    }

    //
    // If we are in slow mode, then we wait after queuing the SMB
    // to the SmbTrace thread.  If we are set for fast mode we
    // garbage collect in case of no memory.
    //

    if ( ID(SingleSmbMode) ) {
        KeInitializeEvent( &WaitEvent, NotificationEvent, FALSE );
    }

    queueEntry = ExAllocatePoolWithTag( NonPagedPool,
                                        sizeof(SMBTRACE_QUEUE_ENTRY),
                                        'tbmS'
                                        );

    if ( queueEntry == NULL ) {
        // No free memory, this SMB is lost.  Record its loss.
        LOCK_INC_ID(SmbsLost);
        SmbTraceDereferenceHeap( Component );
        return;
    }

    //
    // Allocate the required amount of memory in our heap
    // in the shared memory.
    //

    buffer = RtlAllocateHeap( ID(PortMemoryHeap), 0, SmbLength );

    if ( buffer == NULL ) {
        // No free memory, this SMB is lost.  Record its loss.
        // Very unlikely in slow mode.
        LOCK_INC_ID(SmbsLost);
        ExFreePool( queueEntry );

        if ( !ID(SingleSmbMode) ) {
            //
            // Encourage some garbage collection.
            //
            KeSetEvent( &ID(NeedMemoryEvent), 0, FALSE );
        }

        SmbTraceDereferenceHeap( Component );
        return;
    }

    //
    // Copy the SMB to shared memory pointed to by the queue entry,
    // keeping in mind whether it's in an Mdl or contiguous to begin
    // with, and also preserving the address of the real SMB...
    //

    if ( SmbMdl != NULL ) {
        SmbTraceCopyMdlContiguous( buffer, SmbMdl, SmbLength );
        queueEntry->SmbAddress = SmbMdl;
    } else {
        RtlCopyMemory( buffer, Smb, SmbLength );
        queueEntry->SmbAddress = Smb;
    }

    queueEntry->SmbLength = SmbLength;
    queueEntry->Buffer = buffer;
    queueEntry->BufferNonPaged = FALSE;

    //
    // In slow mode, we want to wait until the SMB has been eaten,
    // in fast mode, we don't want to pass the address of the real
    // SMB along, since the SMB is long gone by the time it gets
    // decoded and printed.
    //

    if ( ID(SingleSmbMode) ) {
        queueEntry->WaitEvent = &WaitEvent;
    } else {
        queueEntry->WaitEvent = NULL;
        queueEntry->SmbAddress = NULL;
    }

    //
    // ...queue the entry to the SmbTrace thread...
    //

    ExInterlockedInsertTailList(
            &ID(Queue),
            &queueEntry->ListEntry,
            &ID(QueueInterlock)
            );

    KeReleaseSemaphore(
            &ID(QueueSemaphore),
            SEMAPHORE_INCREMENT,
            1,
            FALSE
            );

    //
    // ...and wait for the SMB to be eaten, in slow mode.
    //

    if ( ID(SingleSmbMode) ) {
        TrPrint(( "%s!SmbTraceCompleteSrv: Slow mode wait\n", ID(ComponentName) ));
        KeWaitForSingleObject(
            &WaitEvent,
            UserRequest,
            KernelMode,
            FALSE,
            NULL
            );
        TrPrint(( "%s!SmbTraceCompleteSrv: Slow mode wait done\n", ID(ComponentName) ));
    }

    SmbTraceDereferenceHeap( Component );

    return;

} // SmbTraceCompleteSrv


VOID
SmbTraceCompleteRdr (
    IN PMDL SmbMdl,
    IN PVOID Smb,
    IN CLONG SmbLength
    )

/*++

Routine Description:

    Redirector version

    Snapshot an SMB and export it to the SmbTrace application.  How
    this happens is determined by which mode (fast or slow) SmbTracing
    was requested in, and which context (DPC, Fsp or Fsd) the current
    thread is executing in.

    Fast mode: the SMB is copied into shared memory and an entry for it
    is queued to the redirector SmbTrace thread, which asynchronously
    passes SMBs to the app.  (When in DPC, the SMB is copied to non-paged
    pool instead of shared memory, and the SmbTrace thread deals with
    moving it to shared memory later.)  If there is insufficient memory
    for anything (SMB, queue entry, etc.) the SMB is lost.

    Slow mode: identical to Fast mode except that this thread waits
    until the server SmbTrace thread signals that the app has finished
    processing the SMB.  Because each thread waits until its SMB has
    been completely processed, there is much less chance of running
    out of any resources. If at DPC level, we behave exactly as in the
    fast mode case, because it would be a Bad Thing to block this thread
    at DPC level.

    The SMB is either contained in SmbMdl, or at address Smb with length
    SmbLength.

Arguments:

    SmbMdl - an Mdl containing the SMB.

    Smb - a pointer to the SMB.

    SmbLength - the length of the SMB.

Return Value:

    None

--*/

{
    PSMBTRACE_QUEUE_ENTRY  queueEntry;
    PVOID  buffer;
    BOOLEAN ProcessAttached = FALSE;
    BOOLEAN AtDpcLevel;
    SMBTRACE_COMPONENT Component = SMBTRACE_REDIRECTOR;
    KEVENT WaitEvent;

    //
    // This routine is redirector specific.
    //

    ASSERT( ID(TraceState) == TraceRunning );
    ASSERT( SmbTraceActive[SMBTRACE_REDIRECTOR] );

    //
    // We want either an Mdl, or a pointer and a length, or occasionally,
    // a completely NULL response
    //

    ASSERT( ( SmbMdl == NULL  &&  Smb != NULL  &&  SmbLength != 0 )
         || ( SmbMdl != NULL  &&  Smb == NULL  &&  SmbLength == 0 )
         || ( SmbMdl == NULL  &&  Smb == NULL  &&  SmbLength == 0 ) );

    //
    // Ensure that SmbTrace really is still active and hence, the
    // shared memory is still around.
    //

    if ( SmbTraceReferenceHeap( Component ) == FALSE ) {
        return;
    }

    //
    // To avoid multiple system calls, we find out once and for all.
    //

    AtDpcLevel = (BOOLEAN)(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    //
    // If the SMB is currently in an MDL, we don't yet have the length,
    // which we need to know how much memory to allocate.
    //

    if ( SmbMdl != NULL ) {
        SmbLength = SmbTraceMdlLength(SmbMdl);
    }

    //
    // If we are in slow mode, then we wait after queuing the SMB
    // to the SmbTrace thread.  If we are set for fast mode we
    // garbage collect in case of no memory.  If we're at DPC level,
    // we store the SMB in non-paged pool.
    //

    if ( ID(SingleSmbMode) ) {
        KeInitializeEvent( &WaitEvent, NotificationEvent, FALSE );
    }

    //
    // allocate queue entry
    //

    queueEntry = ExAllocatePoolWithTag(
                     NonPagedPool,
                     sizeof(SMBTRACE_QUEUE_ENTRY),
                     'tbmS'
                     );

    if ( queueEntry == NULL ) {
        // No free memory, this SMB is lost.  Record its loss.
        LOCK_INC_ID(SmbsLost);
        SmbTraceDereferenceHeap( Component );
        return;
    }

    //
    // allocate buffer for SMB, in non-paged pool or shared heap as
    // appropriate
    //

    if ( AtDpcLevel ) {

        buffer = ExAllocatePoolWithTag( NonPagedPool, SmbLength, 'tbmS' );
        queueEntry->BufferNonPaged = TRUE;

    } else {

        if ( PsGetCurrentProcess() != ID(FspProcess) ) {
            KeAttachProcess(ID(FspProcess));
            ProcessAttached = TRUE;
        }

        buffer = RtlAllocateHeap( ID(PortMemoryHeap), 0, SmbLength );
        queueEntry->BufferNonPaged = FALSE;

    }

    if ( buffer == NULL ) {

        if ( ProcessAttached ) {
            KeDetachProcess();
        }

        // No free memory, this SMB is lost.  Record its loss.
        LOCK_INC_ID(SmbsLost);

        if (!ID(SingleSmbMode)) {

            //
            // If it was shared memory we ran out of, encourage
            // some garbage collection.
            //
            if ( !queueEntry->BufferNonPaged ) {
                KeSetEvent( &ID(NeedMemoryEvent), 0, FALSE );
            }
        }

        ExFreePool( queueEntry );
        SmbTraceDereferenceHeap( Component );
        return;
    }

    //
    // Copy the SMB to shared or non-paged memory pointed to by the
    // queue entry, keeping in mind whether it's in an Mdl or contiguous
    // to begin with, and also preserving the address of the real SMB...
    //

    if ( SmbMdl != NULL ) {
        SmbTraceCopyMdlContiguous( buffer, SmbMdl, SmbLength );
        queueEntry->SmbAddress = SmbMdl;
    } else {
        RtlCopyMemory( buffer, Smb, SmbLength );
        queueEntry->SmbAddress = Smb;
    }

    if ( ProcessAttached ) {
        KeDetachProcess();
    }

    queueEntry->SmbLength = SmbLength;
    queueEntry->Buffer = buffer;

    //
    // In slow mode, we want to wait until the SMB has been eaten,
    // in fast mode, we don't want to pass the address of the real
    // SMB along, since the SMB is long gone by the time it gets
    // decoded and printed.
    //

    if ( ID(SingleSmbMode) && !AtDpcLevel ) {
        queueEntry->WaitEvent = &WaitEvent;
    } else {
        queueEntry->WaitEvent = NULL;
        queueEntry->SmbAddress = NULL;
    }

    //
    // ...queue the entry to the SmbTrace thread...
    //

    ExInterlockedInsertTailList(
            &ID(Queue),
            &queueEntry->ListEntry,
            &ID(QueueInterlock)
            );

    KeReleaseSemaphore(
            &ID(QueueSemaphore),
            SEMAPHORE_INCREMENT,
            1,
            FALSE
            );

    //
    // ...and wait for the SMB to be eaten, in slow mode.
    //

    if ( ID(SingleSmbMode) && !AtDpcLevel ) {
        TrPrint(( "%s!SmbTraceCompleteRdr: Slow mode wait\n", ID(ComponentName) ));
        KeWaitForSingleObject(
            &WaitEvent,
            UserRequest,
            KernelMode,
            FALSE,
            NULL
            );
        TrPrint(( "%s!SmbTraceCompleteRdr: Slow mode wait done\n", ID(ComponentName) ));
    }

    SmbTraceDereferenceHeap( Component );

    return;

} // SmbTraceCompleteRdr


//
// Internal routines
//


BOOLEAN
SmbTraceReferenceHeap(
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    This routine references the SmbTrace shared memory heap,
    ensuring it isn't disposed of while caller is using it.

Arguments:

    Component - Context from which we're called: server or redirector

Return Value:

    BOOLEAN - TRUE if SmbTrace is still active, and hence
              heap exists and was successfully referenced.
              FALSE otherwise.

--*/

{
    BOOLEAN retval = TRUE;  // assume we'll get it
    KIRQL OldIrql;

    ACQUIRE_SPIN_LOCK( &ID(HeapReferenceCountLock), &OldIrql );

    if ( ID(TraceState) != TraceRunning ) {
        retval = FALSE;
    } else {
        ASSERT( ID(HeapReferenceCount) > 0 );
        if( ID(HeapReferenceCount) > 0 )
        {
            ID(HeapReferenceCount)++;
            TrPrint(( "%s!SmbTraceReferenceHeap: Count now %lx\n",
                ID(ComponentName),
                ID(HeapReferenceCount) ));
        }
        else
        {
            retval = FALSE;
        }
    }

    RELEASE_SPIN_LOCK( &ID(HeapReferenceCountLock), OldIrql );

    return retval;

} // SmbTraceReferenceHeap


VOID
SmbTraceDeferredDereferenceHeap(
    IN PVOID Context
    )
/*++

Routine Description:

    If a caller dereferences a heap to 0 from DPC_LEVEL, this routine will
    be called in a system thread to complete the dereference at task time.

Arguments:

    Component - Context from which we're called: server or redirector

Return Value:

    None

--*/

{
    PAGED_CODE();

    SmbTraceDereferenceHeap((SMBTRACE_COMPONENT)Context);
}


VOID
SmbTraceDereferenceHeap(
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    This routine dereferences the SmbTrace shared memory heap,
    disposing of it when the reference count is zero.

Arguments:

    Component - Context from which we're called: server or redirector

Return Value:

    None

--*/

{
    ULONG oldCount;
    KIRQL OldIrql;

    ACQUIRE_SPIN_LOCK( &ID(HeapReferenceCountLock), &OldIrql );

    if (ID(HeapReferenceCount) > 1) {
        ID(HeapReferenceCount) --;

        TrPrint(( "%s!SmbTraceDereferenceHeap: Count now %lx\n",
            ID(ComponentName),
            ID(HeapReferenceCount) ));

        RELEASE_SPIN_LOCK( &ID(HeapReferenceCountLock), OldIrql );

        return;
    }

    RELEASE_SPIN_LOCK( &ID(HeapReferenceCountLock), OldIrql );

    //
    //  If we are executing at DPC_LEVEL, we cannot dereference the heap
    //  to 0.
    //

    if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
        ExInitializeWorkItem(&ID(DereferenceWorkQueueItem), SmbTraceDeferredDereferenceHeap, (PVOID)Component);

        ExQueueWorkItem(&ID(DereferenceWorkQueueItem), DelayedWorkQueue);

        return;

    }

    ACQUIRE_SPIN_LOCK( &ID(HeapReferenceCountLock), &OldIrql );

    oldCount = ID(HeapReferenceCount)--;

    TrPrint(( "%s!SmbTraceDereferenceHeap: Count now %lx\n",
        ID(ComponentName),
        ID(HeapReferenceCount) ));

    RELEASE_SPIN_LOCK( &ID(HeapReferenceCountLock), OldIrql );

    if ( oldCount == 1 ) {

        //
        // Free the section, release the handles and such.
        //

        SmbTraceDisconnect( Component );
    }

    return;

} // SmbTraceDereferenceHeap


VOID
SmbTraceDisconnect (
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    This routine reverses all the effects of SmbTraceStart. Mostly,
    it just needs to close certain handles to do this.

Arguments:

    Component - Context from which we're called: server or redirector

Return Value:

    None - always works

--*/

{
    BOOLEAN ProcessAttached = FALSE;

    PAGED_CODE();

    if (PsGetCurrentProcess() != ID(FspProcess)) {
        KeAttachProcess(ID(FspProcess));
        ProcessAttached = TRUE;

    }


    if ( ID(DoneSmbEvent) != NULL ) {
        // Worker thread may be blocked on this, so we set it first
        TrPrint(( "%s!SmbTraceDisconnect: Signal DoneSmbEvent, handle %x, process %x.\n",
                    ID(ComponentName), ID(DoneSmbEvent), PsGetCurrentProcess()));
        ZwSetEvent( ID(DoneSmbEvent), NULL );

        TrPrint(( "%s!SmbTraceDisconnect: Close DoneSmbEvent, handle %x, process %x.\n",
                    ID(ComponentName), ID(DoneSmbEvent), PsGetCurrentProcess()));
        ZwClose( ID(DoneSmbEvent) );
        ID(DoneSmbEvent) = NULL;
    }

    if ( ID(NewSmbEvent) != NULL ) {
        ZwClose( ID(NewSmbEvent) );
        ID(NewSmbEvent) = NULL;
    }

    if ( ID(PortMemoryHeap) != NULL ) {
        RtlDestroyHeap( ID(PortMemoryHeap) );
        ID(PortMemoryHeap) = NULL;
    }

    if ( ID(SectionHandle) != NULL ) {
        ZwClose( ID(SectionHandle) );
        ID(SectionHandle) = NULL;
    }

    if (ProcessAttached) {
        KeDetachProcess();
    }

    return;

} // SmbTraceDisconnect


VOID
SmbTraceEmptyQueue (
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    This routine empties the queue of unprocessed SMBs.

Arguments:

    Component - Context from which we're called: server or redirector

Return Value:

    None - always works

--*/

{
    PLIST_ENTRY            listEntry;
    PSMBTRACE_QUEUE_ENTRY  queueEntry;

    PAGED_CODE();

    while ( ( listEntry = ExInterlockedRemoveHeadList(
                              &ID(Queue),
                              &ID(QueueInterlock)
                              )
            ) != NULL
    ) {
        queueEntry = CONTAINING_RECORD(
                          listEntry,
                          SMBTRACE_QUEUE_ENTRY,
                          ListEntry
                          );

        //
        // If data for this entry is in non-paged pool, free it too.
        // This only ever happens in the redirector.
        //

        if ( queueEntry->BufferNonPaged ) {

            ASSERT( Component == SMBTRACE_REDIRECTOR );

            ExFreePool( queueEntry->Buffer );
        }

        //
        // If a worker thread is waiting on this event, let it go.
        // This only ever happens in slow mode.
        //

        if ( queueEntry->WaitEvent != NULL ) {

            ASSERT( ID(SingleSmbMode) == TRUE );

            KeSetEvent( queueEntry->WaitEvent, 0, FALSE );
        }

        ExFreePool( queueEntry );
    }

    return;

} // SmbTraceEmptyQueue


VOID
SmbTraceThreadEntry (
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is the entry point of the SmbTrace thread for the server/
    redirector.  It is started by SmbTraceStart. This thread loops
    continuously until the client SmbTrace dies or another SmbTrace sends
    an FsCtl to stop the trace.

Arguments:

    Context - pointer to context block containing component from which
              we're called: server or redirector

Return Value:

    None

--*/

// we wait for termination, work-to-do and need-memory events
#define NUMBER_OF_BLOCKING_OBJECTS 4

// keep these definitions in sync

#define INDEX_WAIT_TERMINATIONEVENT     0
#define INDEX_WAIT_APPTERMINATIONEVENT  1
#define INDEX_WAIT_NEEDMEMORYEVENT      2
#define INDEX_WAIT_QUEUESEMAPHORE       3

#define STATUS_WAIT_TERMINATIONEVENT    STATUS_WAIT_0
#define STATUS_WAIT_APPTERMINATIONEVENT STATUS_WAIT_1
#define STATUS_WAIT_NEEDMEMORYEVENT     STATUS_WAIT_2
#define STATUS_WAIT_QUEUESEMAPHORE      STATUS_WAIT_3

{
    NTSTATUS status;
    PLIST_ENTRY listEntry;
    PSMBTRACE_QUEUE_ENTRY    queueEntry;
    PVOID buffer;
    PVOID waitObjects[NUMBER_OF_BLOCKING_OBJECTS];
    SMBTRACE_COMPONENT Component;
    BOOLEAN Looping;

#if NUMBER_OF_BLOCKING_OBJECTS > THREAD_WAIT_OBJECTS
    //
    // If we try to wait on too many objects, we need to allocate
    // our own wait blocks.
    //

    KWAIT_BLOCK waitBlocks[NUMBER_OF_BLOCKING_OBJECTS];
#endif

    PAGED_CODE();

    //
    // Context is really just the component
    //
    Component = (SMBTRACE_COMPONENT)(UINT_PTR)Context;

    //
    // Initialize the queue.
    //

    InitializeListHead(    &ID(Queue) );
    KeInitializeSpinLock(  &ID(QueueInterlock) );
    KeInitializeSemaphore( &ID(QueueSemaphore), 0, 0x7FFFFFFF );

    //
    // Set up the array of objects to wait on.  We wait (in order)
    // for our termination event, the appliction termination event,
    // a no shared memory event or an SMB request to show up in the
    // SmbTrace queue.
    //

    waitObjects[INDEX_WAIT_TERMINATIONEVENT]    = &ID(TerminationEvent);
    waitObjects[INDEX_WAIT_APPTERMINATIONEVENT] = &ID(AppTerminationEvent);
    waitObjects[INDEX_WAIT_NEEDMEMORYEVENT]     = &ID(NeedMemoryEvent);
    waitObjects[INDEX_WAIT_QUEUESEMAPHORE]      = &ID(QueueSemaphore);

    //
    // No SMBs have been lost yet, and this thread is the first user
    // of the shared memory.  It's also a special user in that it gets
    // access before TraceState == TraceRunning, a requirement for all
    // subsequent referencers.
    //

    ID(SmbsLost) = 0L;
    ID(HeapReferenceCount) = 1;

    //
    // Signal to the FSP that we are ready to start capturing SMBs.
    //

    KeSetEvent( &ID(ActiveEvent), 0, FALSE );

    //
    // Main loop, executed until the thread is terminated.
    //

    TrPrint(( "%s!SmbTraceThread: Tracing started.\n", ID(ComponentName) ));

    Looping = TRUE;
    while( Looping ) {

        TrPrint(( "%s!SmbTraceThread: WaitForMultiple.\n", ID(ComponentName) ));
        status = KeWaitForMultipleObjects(
                    NUMBER_OF_BLOCKING_OBJECTS,
                    &waitObjects[0],
                    WaitAny,
                    UserRequest,
                    KernelMode,
                    FALSE,
                    NULL,
#if NUMBER_OF_BLOCKING_OBJECTS > THREAD_WAIT_OBJECTS
                    &waitBlocks[0]
#else
                    NULL
#endif
                    );

        if ( !NT_SUCCESS(status) ) {
            TrPrint((
                "%s!SmbTraceThreadEntry: KeWaitForMultipleObjectsfailed: %X\n",
                ID(ComponentName), status ));
        } else {
            TrPrint((
                "%s!SmbTraceThreadEntry: %lx\n",
                ID(ComponentName), status ));
        }

        switch( status ) {

        case STATUS_WAIT_TERMINATIONEVENT:

            //
            // Stop looping, and then proceed to clean up and die.
            //

            Looping = FALSE;
            break;

        case STATUS_WAIT_APPTERMINATIONEVENT:

            //  Turn off the event so we don't go in a tight loop
            KeResetEvent(&ID(AppTerminationEvent));

            //
            // Inform the app that it is time to die.  The NULL SMB
            // sent here may not be the next to be processed by the
            // app, but the ApplicationStop bit will be detected
            // immediately.
            //

            ID(TableHeader)->ApplicationStop = TRUE;
            SmbTraceToClient( NULL, 0, NULL, Component );

            break;

        case STATUS_WAIT_NEEDMEMORYEVENT:

            //  Turn off the event so we don't go in a loop.
            KeResetEvent(&ID(NeedMemoryEvent));
            //
            // Do a garbage collection, freeing all memory that is
            // allocated in the shared memory but that has been read
            // by the client.
            //

            SmbTraceFreeMemory( Component );

            break;

        case STATUS_WAIT_QUEUESEMAPHORE:

            //
            // If any get through once we've gone into AppWaiting
            // state, don't bother sending them on, they're not
            // going to get processed.
            //

            if ( ID(TraceState) == TraceAppWaiting ) {
                SmbTraceEmptyQueue( Component );
                break;
            }

            //
            // Remove the first element in the our queue.  A
            // work item is represented by our header followed by
            // an SMB. We must free the entry after we are done
            // with it.
            //

            listEntry = ExInterlockedRemoveHeadList(
                            &ID(Queue),
                            &ID(QueueInterlock)
                            );

            if ( listEntry != NULL ) {

                //
                // Get the address of the queue entry.
                //

                queueEntry = CONTAINING_RECORD(
                                  listEntry,
                                  SMBTRACE_QUEUE_ENTRY,
                                  ListEntry
                                  );

                //
                // If the data is in non-paged pool, move it to shared
                // memory and free the non-paged pool before passing
                // the SMB to the client.  Note that in this case,
                // there's no need to signal anyone.  They ain't waiting.
                //

                if ( queueEntry->BufferNonPaged ) {

                    //
                    // Server never uses non-paged pool.
                    //

                    ASSERT( Component != SMBTRACE_SERVER );

                    buffer = RtlAllocateHeap( ID(PortMemoryHeap), 0,
                                              queueEntry->SmbLength );

                    if ( buffer == NULL ) {

                        LOCK_INC_ID(SmbsLost);

                        ExFreePool( queueEntry->Buffer );
                        ExFreePool( queueEntry );

                        break;

                    }

                    RtlCopyMemory( buffer, queueEntry->Buffer,
                                   queueEntry->SmbLength );

                    ExFreePool( queueEntry->Buffer );

                    //
                    // Send it off.  Because the original SMB is long
                    // dead, we don't pass its real address along (not
                    // that we have it, anyway.)
                    //

                    ASSERT( queueEntry->SmbAddress == NULL );

                    SmbTraceToClient(
                            buffer,
                            queueEntry->SmbLength,
                            NULL,
                            Component
                            );

                } else {

                    //
                    // Enter the SMB into the table and send it to the
                    // client. Can block in slow mode.  When it does so, we'll
                    // signal the applicable thread.
                    //

                    SmbTraceToClient(
                            queueEntry->Buffer,
                            queueEntry->SmbLength,
                            queueEntry->SmbAddress,
                            Component
                            );

                    if ( queueEntry->WaitEvent != NULL ) {
                        KeSetEvent( queueEntry->WaitEvent, 0, FALSE );
                    }
                }

                //
                // Now, we must free the queue entry.
                //

                ExFreePool( queueEntry );

            }

            break;

        default:
            break;
        }

    }

    //
    // Clean up!
    //
    TrPrint(( "%s!SmbTraceThread: Tracing clean up.\n", ID(ComponentName) ));

    SmbTraceDereferenceHeap( Component );

    SmbTraceEmptyQueue( Component );

    //
    // Signal to SmbTraceStop that we're dying.
    //

    TrPrint(( "%s!SmbTraceThread: Tracing terminated.\n", ID(ComponentName) ));

    KeSetEvent( &ID(TerminatedEvent), 0, FALSE );

    //
    // Kill this thread.
    //

    status = PsTerminateSystemThread( STATUS_SUCCESS );

    // Shouldn't get here
    TrPrint((
        "%s!SmbTraceThreadEntry: PsTerminateSystemThread() failed: %X\n",
        ID(ComponentName), status ));

} // SmbTraceThreadEntry

// constant only of interest while constructing waitObject arrays
// in SmbTraceThreadEntry
#undef NUMBER_OF_BLOCKING_OBJECTS


NTSTATUS
SmbTraceFreeMemory (
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    This procedure frees any memory that may have been allocated to an
    SMB that the client has already consumed. It does not alter table
    entries, except to record that the memory buffer has been cleared.
    This routinue is not espectally fast, it should not be called often,
    only when needed.

Arguments:

    Component - Context from which we're called: server or redirector

Return Value:

    NTSTATUS - result of operation.

--*/

{
    PVOID    buffer;
    PSMBTRACE_TABLE_ENTRY    tableEntry;
    ULONG    tableIndex;

    PAGED_CODE();

    TrPrint(( "%s!SmbTraceFreeMemory: Called for garbage collection.\n",
              ID(ComponentName) ));

    //
    // No free memory in the heap, perhaps we can free some by freeing
    // memory in old table entries. This is expensive for time.
    //

    tableIndex = ID(TableHeader)->NextFree;

    while( tableIndex != ID(TableHeader)->HighestConsumed ) {

        tableEntry = ID(Table) + tableIndex;

        //
        // Check if this table entry has been used but its memory has not
        // been freed yet. If so, free it.
        //

        if ( tableEntry->BufferOffset != 0L ) {

            buffer = (PVOID)( (ULONG_PTR)tableEntry->BufferOffset
                        + (ULONG_PTR)ID(PortMemoryBase) );

            RtlFreeHeap( ID(PortMemoryHeap), 0, buffer);

            tableEntry->BufferOffset = 0L;
        }


        tableIndex = (tableIndex + 1) % ID(TableSize);
    }

    return( STATUS_SUCCESS );

} // SmbTraceFreeMemory


VOID
SmbTraceToClient(
    IN PVOID Smb,
    IN CLONG SmbLength,
    IN PVOID SmbAddress,
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    Enter an SMB already found in shared memory into the table.  Set
    an event for the client.  If there is no table space, the SMB is
    not saved.  If in slow mode, wait for the client to finish with
    and then free the memory occupied by the SMB.

Arguments:

    Smb - a pointer to the SMB (which is ALREADY in shared memory).
          Can be NULL, indicating no new SMB is to be added, but the
          application is to be signalled anyway.

    SmbLength - the length of the SMB.

    SmbAddress - the address of the real SMB, not in shared memory.

    Component - Context from which we're called: server or redirector

Return Value:

    None

--*/

{
    NTSTATUS status;
    PVOID    buffer;
    PSMBTRACE_TABLE_ENTRY    tableEntry;
    ULONG    tableIndex;

    PAGED_CODE();

    //
    //  Reset DoneSmbEvent so we can determine when the request has been processed
    //

    if ( ID(SingleSmbMode) ) {
        PKEVENT DoneEvent;

        TrPrint(( "%s!SmbTraceToClient: Reset DoneSmbEvent, handle %x, process %x.\n",
                    ID(ComponentName), ID(DoneSmbEvent), PsGetCurrentProcess()));

        status = ObReferenceObjectByHandle( ID(DoneSmbEvent),
                                            EVENT_MODIFY_STATE,
                                            NULL,
                                            KernelMode,
                                            (PVOID *)&DoneEvent,
                                            NULL
                                            );

        ASSERT ( NT_SUCCESS(status) );

        KeResetEvent(DoneEvent);

        ObDereferenceObject(DoneEvent);
    }

    if (Smb != NULL) {

        //
        // See if there is room in the table for a pointer to our SMB.
        //

        if ( ID(TableHeader)->NextFree == ID(TableHeader)->HighestConsumed ) {
            // Tough luck. No memory in the table, this SMB is lost.
            LOCK_INC_ID( SmbsLost );
            RtlFreeHeap( ID(PortMemoryHeap), 0, Smb );
            return;
        }

        tableIndex = ID(TableHeader)->NextFree;

        tableEntry = ID(Table) + tableIndex;

        //
        // Record the number of SMBs that were lost before this one and
        // (maybe) zero the count for the next one.
        //

        tableEntry->NumberMissed = ID(SmbsLost);

        if ( tableEntry->NumberMissed != 0 ) {
            LOCK_ZERO_ID(SmbsLost);
        }

        //
        // Check if this table entry has been used but its memory has not
        // been freed yet. If so, free it.
        //
        if ( tableEntry->BufferOffset != 0L ) {

            buffer = (PVOID)( (ULONG_PTR)tableEntry->BufferOffset
                        + (ULONG_PTR)ID(PortMemoryBase) );

            RtlFreeHeap( ID(PortMemoryHeap), 0, buffer);
            tableEntry->BufferOffset = 0L;
        }

        //
        // Record the location and size of this SMB in the table.
        //

        tableEntry->BufferOffset = (ULONG)((ULONG_PTR)Smb - (ULONG_PTR)ID(PortMemoryBase));
        tableEntry->SmbLength = SmbLength;

        //
        // Record the real address of the actual SMB (i.e. not the shared
        // memory copy) if it's available.
        //

        tableEntry->SmbAddress = SmbAddress;

        //
        // Increment the Next Free counter.
        //

        ID(TableHeader)->NextFree = (tableIndex + 1) % ID(TableSize);

    }


    //
    // Unlock the client so it will process this new SMB.
    //

    TrPrint(( "%s!SmbTraceToClient: Set NewSmbEvent.\n", ID(ComponentName) ));
    status = ZwSetEvent( ID(NewSmbEvent), NULL );

    //
    //  When stopping the trace we set TraceState to TraceStopping and then
    //  DoneSmbEvent. This prevents this routine from blocking indefinitely
    //  because it Resets DoneSmbEvent processes the Smb and then checks TraceState
    //  before blocking.
    //
    if (( ID(SingleSmbMode) ) &&
        ( ID(TraceState) == TraceRunning )) {

        //
        // Wait for the app to acknowledge that the SMB has been
        // processed.
        //

        TrPrint(( "%s!SmbTraceToClient: Waiting for DoneSmbEvent, handle %x, process %x.\n",
                    ID(ComponentName), ID(DoneSmbEvent), PsGetCurrentProcess()));
        status = ZwWaitForSingleObject(
                    ID(DoneSmbEvent),
                    FALSE,
                    NULL
                    );

        TrPrint(( "%s!SmbTraceToClient: DoneSmbEvent is set, handle %x, process %x.\n",
                    ID(ComponentName), ID(DoneSmbEvent), PsGetCurrentProcess()));
        ASSERT( NT_SUCCESS(status) );

        if (Smb != NULL) {

            tableEntry->BufferOffset = 0L;
            RtlFreeHeap( ID(PortMemoryHeap), 0, Smb);
        }

    }

    return;

} // SmbTraceToClient


ULONG
SmbTraceMdlLength(
    IN PMDL Mdl
    )

/*++

Routine Description:

    Determine the total number of bytes of data found in an Mdl.

Arguments:

    Mdl - a pointer to an Mdl whose length is to be calculated

Return Value:

    ULONG - total number of data bytes in Mdl

--*/

{
    ULONG Bytes = 0;

    while (Mdl != NULL) {
        Bytes += MmGetMdlByteCount(Mdl);
        Mdl = Mdl->Next;
    }

    return Bytes;
} // SmbTraceMdlLength


VOID
SmbTraceCopyMdlContiguous(
    OUT PVOID Destination,
    IN  PMDL Mdl,
    IN  ULONG Length
    )

/*++

Routine Description:

    Copy the data stored in Mdl into the contiguous memory at
    Destination.  Length is present to keep the same interface
    as RtlCopyMemory.

Arguments:

    Destination - a pointer to previously allocated memory into which
                  the Mdl is to be copied.

    Mdl - a pointer to an Mdl which is to be copied to Destination

    Length - number of data bytes expected in Mdl

Return Value:

    None

--*/

{
    PCHAR Dest = Destination;
    PCHAR Src  = NULL;

    UNREFERENCED_PARAMETER(Length);

    while (Mdl != NULL) {

        Src = MmGetSystemAddressForMdlSafe(Mdl,NormalPagePriority);

        if (Src != NULL) {
            RtlCopyMemory(
                Dest,
                Src,
                MmGetMdlByteCount(Mdl)
                );
        }

        Dest += MmGetMdlByteCount(Mdl);
        Mdl = Mdl->Next;
    }

    ASSERT((ULONG)(Dest - (PCHAR)Destination) == Length);

    return;

} // SmbTraceCopyMdlContiguous
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\blkconn.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blkconn.c

Abstract:

    This module implements routines for managing connection blocks.

Author:

    Chuck Lenzmeier (chuckl) 4-Oct-1989

Revision History:

--*/

#include "precomp.h"
#include "blkconn.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKCONN

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateConnection )
#pragma alloc_text( PAGE, SrvCloseConnectionsFromClient )

#if !defined(DBG) || DBG == 0
#pragma alloc_text( PAGE, SrvFreeConnection )
#endif

#endif
#if 0
NOT PAGEABLE -- SrvCloseConnection
NOT PAGEABLE -- SrvCloseFreeConnection
NOT PAGEABLE -- SrvDereferenceConnection
NOT PAGEABLE -- SrvQueryConnections
#endif

CHAR DisconnectReasonText[((USHORT)DisconnectReasons)+1][32] = {
    "Idle Connection",
    "Endpoint Closing",
    "2nd Sess Setup on Conn",
    "Transport Issued Disconnect",
    "Session Deleted",
    "Bad SMB Packet",
    "Suspected DOS",
    "Cancelled/Failed Receive",
    "Stale IPX Conn",
    "Unknown"
};

VOID
SrvAllocateConnection (
    OUT PCONNECTION *Connection
    )

/*++

Routine Description:

    This function allocates a Connection Block from the system nonpaged
    pool.

Arguments:

    Connection - Returns a pointer to the connection block, or NULL if
        no pool was available.

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    ULONG i;
    PPAGED_CONNECTION pagedConnection;

    PAGED_CODE( );

    //
    // Attempt to allocate from nonpaged pool.
    //

    connection = ALLOCATE_NONPAGED_POOL( sizeof(CONNECTION), BlockTypeConnection );
    *Connection = connection;

    if ( connection == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateConnection: Unable to allocate %d bytes from"
                "nonpaged pool",
            sizeof( CONNECTION ),
            NULL
            );
        return;
    }

    RtlZeroMemory( connection, sizeof(CONNECTION) );

    pagedConnection = ALLOCATE_HEAP_COLD(
                        sizeof(PAGED_CONNECTION),
                        BlockTypePagedConnection );

    if ( pagedConnection == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateConnection: Unable to allocate %d bytes from"
                "paged pool",
            sizeof( PAGED_CONNECTION ),
            NULL
            );
        goto error_exit;
    }


    IF_DEBUG(HEAP) {
        KdPrint(( "SrvAllocateConnection: Allocated connection at %p\n",
                    connection ));
    }

    RtlZeroMemory( pagedConnection, sizeof(PAGED_CONNECTION) );

    SET_BLOCK_TYPE_STATE_SIZE( connection, BlockTypeConnection, BlockStateInitializing, sizeof( CONNECTION ) );

    connection->PagedConnection = pagedConnection;
    pagedConnection->PagedHeader.NonPagedBlock = connection;
    pagedConnection->PagedHeader.Type = BlockTypePagedConnection;

    connection->BlockHeader.ReferenceCount = 2;  // allow for Active status
                                                    //  and caller's pointer

    InitializeListHead( &pagedConnection->TransactionList );

    connection->SmbDialect = SmbDialectIllegal;
    connection->CachedFid = (ULONG)-1;

    //
    // Allocate session table.
    //

    SrvAllocateTable(
        &pagedConnection->SessionTable,
        SrvInitialSessionTableSize,
        FALSE
        );
    if ( pagedConnection->SessionTable.Table == NULL ) {
        goto error_exit;
    }

    //
    // Allocate tree connect table.
    //

    SrvAllocateTable(
        &pagedConnection->TreeConnectTable,
        SrvInitialTreeTableSize,
        FALSE
        );
    if ( pagedConnection->TreeConnectTable.Table == NULL ) {
        goto error_exit;
    }

    //
    // Allocate file table.
    //

    SrvAllocateTable(
        &connection->FileTable,
        SrvInitialFileTableSize,
        TRUE
        );
    if ( connection->FileTable.Table == NULL ) {
        goto error_exit;
    }

    //
    // Allocate search table.
    //

    SrvAllocateTable(
        &pagedConnection->SearchTable,
        SrvInitialSearchTableSize,
        FALSE
        );
    if ( pagedConnection->SearchTable.Table == NULL ) {
        goto error_exit;
    }

    //
    // Initialize core search list heads
    //

    InitializeListHead( &pagedConnection->CoreSearchList );

    //
    // Initialize the locks that protect the connection and its data.
    //

    INITIALIZE_SPIN_LOCK( &connection->SpinLock );
    INITIALIZE_SPIN_LOCK( &connection->Interlock );

    INITIALIZE_LOCK( &connection->Lock, CONNECTION_LOCK_LEVEL, "ConnectionLock" );
    INITIALIZE_LOCK( &connection->LicenseLock, LICENSE_LOCK_LEVEL, "LicenseLock" );

    //
    // Initialize the client machine name string.
    //

    connection->ClientMachineNameString.Buffer =
                            connection->LeadingSlashes;
    connection->ClientMachineNameString.Length = 0;
    connection->ClientMachineNameString.MaximumLength =
            (USHORT)((2 + COMPUTER_NAME_LENGTH + 1) * sizeof(WCHAR));

    connection->LeadingSlashes[0] = '\\';
    connection->LeadingSlashes[1] = '\\';

    //
    // Initialize the oem client machine name string
    //

    connection->OemClientMachineNameString.Buffer =
                                            connection->OemClientMachineName;

    connection->OemClientMachineNameString.MaximumLength =
                                (USHORT)(COMPUTER_NAME_LENGTH + 1);


    //
    // Initialize count of sessions.
    //
    // *** Already done by RtlZeroMemory.

    //pagedConnection->CurrentNumberOfSessions = 0;

    //
    // Initialize the in-progress work item list, the outstanding
    // oplock breaks list, and the cached-after-close lists.
    //

    InitializeListHead( &connection->InProgressWorkItemList );
    InitializeListHead( &connection->OplockWorkList );
    InitializeListHead( &connection->CachedOpenList );
    InitializeListHead( &connection->CachedDirectoryList );

    // Initialize the CachedTransactionList
    ExInitializeSListHead( &connection->CachedTransactionList );

    SET_INVALID_CONTEXT_HANDLE(connection->NegotiateHandle);

    //
    // Indicate that security signatures are not active
    //
    connection->SmbSecuritySignatureActive = FALSE;

    //
    // Indicate that no IPX saved response buffer has been allocated.
    //

    connection->LastResponse = connection->BuiltinSavedResponse;

    //
    // Initialize the search hash table list.
    //

    for ( i = 0; i < SEARCH_HASH_TABLE_SIZE ; i++ ) {
        InitializeListHead( &pagedConnection->SearchHashTable[i].ListHead );
    }

    INITIALIZE_REFERENCE_HISTORY( connection );

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.ConnectionInfo.Allocations );

    return;

error_exit:

    if ( pagedConnection != NULL ) {
        if ( pagedConnection->SessionTable.Table != NULL ) {
            SrvFreeTable( &pagedConnection->SessionTable );
        }
        if ( pagedConnection->TreeConnectTable.Table != NULL ) {
            SrvFreeTable( &pagedConnection->TreeConnectTable );
        }
        if ( pagedConnection->SearchTable.Table != NULL ) {
            SrvFreeTable( &pagedConnection->SearchTable );
        }
        FREE_HEAP( pagedConnection );
    }

    if ( connection != NULL ) {
        if ( connection->FileTable.Table != NULL ) {
            SrvFreeTable( &connection->FileTable );
        }
        DEALLOCATE_NONPAGED_POOL( connection );
        *Connection = NULL;
    }

    return;

} // SrvAllocateConnection

VOID
SrvCloseConnection (
    IN PCONNECTION Connection,
    IN BOOLEAN RemoteDisconnect
    )

/*++

Routine Description:

    This function closes a connection (virtual circuit).

    *** This routine must NOT be entered with the connection lock held!
        It may be entered with the endpoint lock held.

Arguments:

    Connection - Supplies a pointer to a Connection Block

    RemoteDisconnect - Indicates whether this call is being made in
        response to a notification by the transport provider.

Return Value:

    None.

--*/

{
    PTABLE_HEADER tableHeader;
    PLIST_ENTRY listEntry;
    USHORT i;
    KIRQL oldIrql;
    PRFCB rfcb;

    ASSERT( !ExIsResourceAcquiredExclusiveLite(&RESOURCE_OF(Connection->Lock)) );

    ACQUIRE_LOCK( &Connection->Lock );

    //
    // If the connection hasn't already been closed, do so now.
    //

    if ( GET_BLOCK_STATE(Connection) == BlockStateActive ) {

#if SRVDBG29
        {
            ULONG conn = (ULONG)Connection;
            if (RemoteDisconnect) conn |= 1;
            if (Connection->DisconnectPending) conn |= 2;
            UpdateConnectionHistory( "CLOS", Connection->Endpoint, Connection );
        }
#endif
        IF_DEBUG(TDI) KdPrint(( "Closing connection (%s) at %p for %z\n",
                    DisconnectReasonText[(USHORT)Connection->DisconnectReason], Connection, (PCSTRING)&Connection->OemClientMachineNameString ));

        IF_DEBUG( ERRORS ) {
            if( RemoteDisconnect == FALSE ) {
                KdPrint(( "SrvCloseConnection: forcibly closing connection %p (%s)\n", Connection, DisconnectReasonText[(USHORT)Connection->DisconnectReason] ));
            }
        }

        SET_BLOCK_STATE( Connection, BlockStateClosing );

        RELEASE_LOCK( &Connection->Lock );

        //
        // If the connection is on the need-resource queue (waiting for
        // a work item) or the disconnect queue (a Disconnect having
        // been indicated by the transport), remove it now, and
        // dereference it.  (Note that the connection can't go away yet,
        // because the initial reference is still there.)
        //

        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

        //
        // Invalidate the cached connection
        //

        if ( Connection->OnNeedResourceQueue ) {

            SrvRemoveEntryList(
                &SrvNeedResourceQueue,
                &Connection->ListEntry
                );

            Connection->OnNeedResourceQueue = FALSE;
            DEBUG Connection->ReceivePending = FALSE;

            RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

            SrvDereferenceConnection( Connection );

        } else if ( Connection->DisconnectPending ) {

            SrvRemoveEntryList(
                &SrvDisconnectQueue,
                &Connection->ListEntry
                );

            DEBUG Connection->DisconnectPending = FALSE;

            RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

            SrvDereferenceConnection( Connection );

            //
            // If there's a disconnect pending, then don't try to shut
            // down the connection later.
            //

            RemoteDisconnect = TRUE;

        } else {

            RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

        }

        //
        // If this is not a remote disconnect, issue a TdiDisconnect
        // request now.
        //
        // *** This is currently done as a synchronous request.  It may
        //     be better to do this asynchronously.
        //

        if ( !RemoteDisconnect && !Connection->Endpoint->IsConnectionless ) {
            SrvDoDisconnect( Connection );
        }

        //
        // Close all active sessions.  (This also causes all open files
        // and pending transactions to be closed.)
        //

        SrvCloseSessionsOnConnection( Connection, NULL );

        //
        // Close all active tree connects.
        //
        // *** Reference the tree connect for the same reasons as we
        //     referenced the session; see above.

        tableHeader = &Connection->PagedConnection->TreeConnectTable;

        ACQUIRE_LOCK( &Connection->Lock );

        for ( i = 0; i < tableHeader->TableSize; i++ ) {

            PTREE_CONNECT treeConnect =
                        (PTREE_CONNECT)tableHeader->Table[i].Owner;

            if ( treeConnect != NULL &&
                    GET_BLOCK_STATE( treeConnect ) == BlockStateActive ) {

                SrvReferenceTreeConnect( treeConnect );
                RELEASE_LOCK( &Connection->Lock );

                SrvCloseTreeConnect( treeConnect );

                SrvDereferenceTreeConnect( treeConnect );
                ACQUIRE_LOCK( &Connection->Lock );
            }
        }

        //
        // If there is state associated with a extended security negotiate,
        // free it up.
        //

        if (IS_VALID_CONTEXT_HANDLE(Connection->NegotiateHandle)) {
            DeleteSecurityContext( &Connection->NegotiateHandle );
        }

        SET_INVALID_CONTEXT_HANDLE( Connection->NegotiateHandle );

        RELEASE_LOCK( &Connection->Lock );

        //
        // Cancel all outstanding oplock break requests.
        //

        while ( (listEntry = ExInterlockedRemoveHeadList(
                                &Connection->OplockWorkList,
                                Connection->EndpointSpinLock
                                )) != NULL ) {

            //
            // Remove this work item from the connection queue and
            // return it to the free queue.
            //

            rfcb = CONTAINING_RECORD( listEntry, RFCB, ListEntry );

#if DBG
            rfcb->ListEntry.Flink = rfcb->ListEntry.Blink = NULL;
#endif
            SrvDereferenceRfcb( rfcb );

        }

        //
        // Close RFCBs that are cached after having been closed by the
        // client.
        //

        SrvCloseCachedRfcbsOnConnection( Connection );

        //
        // Dereference the connection (to indicate that it's no longer
        // open).  This may cause the connection block to be deleted.
        //

        SrvDereferenceConnection( Connection );

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.ConnectionInfo.Closes );

    } else {

        RELEASE_LOCK( &Connection->Lock );
    }

    return;

} // SrvCloseConnection


VOID
SrvCloseConnectionsFromClient (
    IN PCONNECTION Connection,
    IN BOOLEAN OnlyIfNoSessions
    )

/*++

Routine Description:

    This routine closes all connections from a given remote machine name
    except the connection passed in.  This is used in the Session Setup
    SMB when the client indicates that he believes that he has exactly
    one connection to this server; if there are others, we know that
    they are not valid.

Arguments:

    Connection - Address of connection to keep around.  This is used
        for the machine name.

    OnlyIfNoSessions - Kill off the duplicate connections only if they do
        not have any established sessions.

Return Value:

    None.

--*/

{
    USHORT index;
    PENDPOINT endpoint;
    PLIST_ENTRY listEntry;
    PCONNECTION testConnection;
    BOOLEAN Connectionless = Connection->Endpoint->IsConnectionless == 1;
    BOOLEAN IsIPAddress = (Connection->ClientIPAddress != 0);

    PAGED_CODE( );

    //
    // We need to look at the name of every client for which the server
    // has a connection.  Connection lists are stored off endpoints, so
    // walk the global endpoint list and the list of connections on each
    // endpoint.
    //

    IF_DEBUG(TDI) {
        KdPrint(( "SrvCloseConnectionsFromClient entered for connection "
                    "%p, OemName %z, looking for %wZ\n", Connection,
                    (PCSTRING)&Connection->OemClientMachineNameString,
                    &Connection->ClientMachineNameString));
    }

    if( IsIPAddress )
    {
        UNICODE_STRING strippedName;
        strippedName = Connection->ClientMachineNameString;
        strippedName.Buffer += 2;
        strippedName.Length -= 2*sizeof(WCHAR);
        IsIPAddress = SrvIsDottedQuadAddress( &strippedName );
    }

    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( listEntry != &SrvEndpointList.ListHead ) {


        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        //
        // If this endpoint is closing, or if the types don't match,
        // skip to the next one.
        // Otherwise, reference the endpoint so that it can't go away.
        //

        if ( GET_BLOCK_STATE(endpoint) != BlockStateActive ||
             endpoint->IsConnectionless != Connectionless ) {
            listEntry = listEntry->Flink;
            continue;
        }

        //
        // If this endpoint doesn't have the same netbios name as the
        // endpoint of the passed-in connection then skip it.  This is
        // to allow servers to have more than one name on the network.
        //

        if( Connection->Endpoint->TransportAddress.Length !=
            endpoint->TransportAddress.Length ||

            !RtlEqualMemory( Connection->Endpoint->TransportAddress.Buffer,
                             endpoint->TransportAddress.Buffer,
                             endpoint->TransportAddress.Length ) ) {

            //
            // This connection is for an endpoint having a different network
            //  name than does this endpoint.  Skip this endpoint.
            //

            listEntry = listEntry->Flink;
            continue;
        }

#if 0
        //
        // If this endpoint doesn't have the same transport name as the one
        //  on which the client is connecting, then skip it.  This is for
        //  multihomed servers.
        //
        if( Connection->Endpoint->TransportName.Length !=
            endpoint->TransportName.Length ||

            !RtlEqualMemory( Connection->Endpoint->TransportName.Buffer,
                             endpoint->TransportName.Buffer,
                             endpoint->TransportName.Length ) ) {

                //
                // This connection is for an endpoint coming in over a different
                //  stack instance.
                //
                listEntry = listEntry->Flink;
                continue;
        }
#endif

        SrvReferenceEndpoint( endpoint );

        //
        // Walk the endpoint's connection table.
        //

        index = (USHORT)-1;

        while ( TRUE ) {

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            testConnection = WalkConnectionTable( endpoint, &index );
            if ( testConnection == NULL ) {
                break;
            }

            if( testConnection == Connection ) {
                //
                // Skip ourselves!
                //
                SrvDereferenceConnection( testConnection );
                continue;
            }

            if( OnlyIfNoSessions == TRUE &&
                testConnection->CurrentNumberOfSessions != 0 ) {

                //
                // This connection has sessions.  Skip it.
                //
                SrvDereferenceConnection( testConnection );
                continue;
            }
            else if( OnlyIfNoSessions == FALSE &&
                testConnection->CurrentNumberOfSessions == 0 ) {

                //
                // This connection has no sessions.  Skip it.  (It could be a session established from the
                // same machine that has not had its session setup reach yet.  Thus, the client may know about
                // this session, but SRV doesn't)
                //
                SrvDereferenceConnection( testConnection );
                continue;
            }

            if( Connectionless ) {
                //
                // Connectionless clients match on IPX address...
                //

                if( !RtlEqualMemory( &Connection->IpxAddress,
                                     &testConnection->IpxAddress,
                                     sizeof(Connection->IpxAddress) ) ) {

                    SrvDereferenceConnection( testConnection );
                    continue;
                }

            } else {

                //
                // If the IP address matches, then nuke this client
                //
                if( IsIPAddress &&
                       Connection->ClientIPAddress == testConnection->ClientIPAddress ) {
                    goto nuke_it;
                }

                //
                // If the computer name matches, then nuke this client
                //
                if ( RtlCompareUnicodeString(
                         &testConnection->ClientMachineNameString,
                         &Connection->ClientMachineNameString,
                         TRUE
                         ) == 0 ) {
                    goto nuke_it;
                }

                //
                // Neither the IP address nor the name match -- skip this client
                //
                SrvDereferenceConnection( testConnection );
                continue;
            }

nuke_it:
            //
            // We found a connection that we need to kill.  We
            // have to release the lock in order to close it.
            //

            RELEASE_LOCK( &SrvEndpointLock );

            IF_DEBUG(TDI) {
                KdPrint(( "SrvCloseConnectionsFromClient closing "
                            "connection %p, MachineNameString %Z\n",
                            testConnection,
                            &testConnection->ClientMachineNameString ));
            }

#if SRVDBG29
            UpdateConnectionHistory( "CFC1", testConnection->Endpoint, testConnection );
            UpdateConnectionHistory( "CFC2", testConnection->Endpoint, Connection );
#endif
            testConnection->DisconnectReason = DisconnectNewSessionSetupOnConnection;
            SrvCloseConnection( testConnection, FALSE );

            ACQUIRE_LOCK( &SrvEndpointLock );

            //
            // Dereference the connection to account for the reference
            // from WalkConnectionTable.
            //

            SrvDereferenceConnection( testConnection );

        } // walk connection table

        //
        // Capture a pointer to the next endpoint in the list (that one
        // can't go away because we hold the endpoint list), then
        // dereference the current endpoint.
        //

        listEntry = listEntry->Flink;
        SrvDereferenceEndpoint( endpoint );

    } // walk endpoint list

    RELEASE_LOCK( &SrvEndpointLock );

} // SrvCloseConnectionsFromClient


VOID
SrvCloseFreeConnection (
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This function closes a free connection.  This is a connection that
    is not active -- has already been closed via SrvCloseConnection --
    and is no longer needed.

    *** WARNING!  This routine frees the storage occupied by Connection!

Arguments:

    Connection - Supplies a pointer to a Connection Block

Return Value:

    None.

--*/

{
    PENDPOINT endpoint;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;
    KIRQL oldIrql;

    ASSERT( Connection->BlockHeader.ReferenceCount == 0 );

    endpoint = Connection->Endpoint;

    ACQUIRE_LOCK( &SrvEndpointLock );

    //
    // Remove the connection from the endpoint's connection table.
    //

    if ( Connection->Sid != 0 ) {
        ACQUIRE_SPIN_LOCK( Connection->EndpointSpinLock, &oldIrql );
        SrvRemoveEntryTable(
            &endpoint->ConnectionTable,
            Connection->SidIndex
            );
        RELEASE_SPIN_LOCK( Connection->EndpointSpinLock, oldIrql );
        Connection->Sid = 0;
    }

    //
    // Decrement the count of connections for the endpoint.
    //

    ExInterlockedAddUlong(
        &endpoint->TotalConnectionCount,
        (ULONG)-1,
        &GLOBAL_SPIN_LOCK(Fsd)
        );

    RELEASE_LOCK( &SrvEndpointLock );

    //
    // Close the connection file object.  Remove the additional
    // reference.
    //

    if ( !endpoint->IsConnectionless ) {
        SRVDBG_RELEASE_HANDLE( pagedConnection->ConnectionHandle, "CON", 1, Connection );
        SrvNtClose( pagedConnection->ConnectionHandle, FALSE );
        ObDereferenceObject( Connection->FileObject );
    }

    //
    // Dereference the endpoint.
    //

    SrvDereferenceEndpoint( endpoint );

    //
    // Free the storage occupied by the connection.
    //

    SrvFreeConnection( Connection );

    return;

} // SrvCloseFreeConnection


VOID
SrvDereferenceConnection (
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This function decrements the reference count on a connection.  If the
    reference count goes to zero, the connection block is deleted.

    The connection lock must not be held when this routine is called,
    because the global endpoint lock, which has a lower level, must be
    acquired.

Arguments:

    Connection - Address of connection

Return Value:

    None.

--*/

{
    ULONG oldCount;
    PENDPOINT endpoint;
    KIRQL oldIrql;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;

    ASSERT( GET_BLOCK_TYPE( Connection ) == BlockTypeConnection );
    ASSERT( (LONG)Connection->BlockHeader.ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( Connection, TRUE );

    //
    // Perform an interlocked decrement of the connection block's
    // reference count.
    //
    // *** Note that we don't hold a lock between the time we decrement
    //     the reference count and the time we delete the connection
    //     block.  Normally this would imply that the FSD could
    //     reference the block in between.  However, the transport
    //     provider guarantees that it won't deliver any more events
    //     after a remote Disconnect event or after a local
    //     TdiDisconnect request, and one of those two things has to
    //     happen before the reference count can go to 0 (see
    //     SrvCloseConnection).
    //

    oldCount = ExInterlockedAddUlong(
                   &Connection->BlockHeader.ReferenceCount,
                   (ULONG)-1,
                   Connection->EndpointSpinLock
                   );
    IF_DEBUG(REFCNT) {
        KdPrint(( "Dereferencing connection %p; old refcnt %lx\n",
                    Connection, oldCount ));
    }

    if ( oldCount == 1 ) {

        //
        // The new reference count is 0, meaning that it's time to
        // delete this block.
        //

        ASSERT( GET_BLOCK_STATE(Connection) != BlockStateActive );
#if SRVDBG29
        if ( GET_BLOCK_STATE(Connection) != BlockStateClosing ) {
            KdPrint(( "SRV: Connection is not CLOSING with refcnt 0!\n" ));
            DbgBreakPoint( );
        }
#endif

        //
        // Free the space allocated for client Domain, OS Name, and
        // LAN type.
        //

        if ( Connection->ClientOSType.Buffer != NULL ) {
            DEALLOCATE_NONPAGED_POOL( Connection->ClientOSType.Buffer );
            Connection->ClientOSType.Buffer = NULL;
        }

        //
        // Keep the WORK_QUEUE statistic correct
        //
        if( Connection->CurrentWorkQueue )
            InterlockedDecrement( &Connection->CurrentWorkQueue->CurrentClients );

        // (Always TRUE) ASSERT( Connection->CurrentWorkQueue->CurrentClients >= 0 );

        endpoint = Connection->Endpoint;

        ACQUIRE_LOCK( &SrvEndpointLock );

        //
        // If the connection hasn't been marked as not reusable (e.g.,
        // because a disconnect failed), and the endpoint isn't closing,
        // and it isn't already "full" of free connections, put this
        // connection on the endpoint's free connection list.
        // Otherwise, close the connection file object and free the
        // connection block.
        //

        if ( !Connection->NotReusable &&
             (GET_BLOCK_STATE(endpoint) == BlockStateActive) &&
             (endpoint->FreeConnectionCount < SrvFreeConnectionMaximum) ) {

            //
            // Reinitialize the connection state.
            //
            // !!! Should probably reset the connection's table sizes,
            //     if they've grown.
            //

            SET_BLOCK_STATE( Connection, BlockStateInitializing );
            pagedConnection->LinkInfoValidTime.QuadPart = 0;
            pagedConnection->Throughput.QuadPart = 0;
            pagedConnection->Delay.QuadPart = 0;
            Connection->CurrentNumberOfSessions = 0;
            Connection->ClientMachineNameString.Length = 0;
            Connection->ClientCapabilities = 0;
            Connection->SmbDialect = SmbDialectIllegal;
            Connection->DisconnectPending = FALSE;
            Connection->ReceivePending = FALSE;
            Connection->OplocksAlwaysDisabled = FALSE;
            Connection->CachedFid = (ULONG)-1;
            Connection->InProgressWorkContextCount = 0;
            Connection->IsConnectionSuspect = FALSE;
            Connection->DisconnectReason = DisconnectReasons;
            Connection->OperationsPendingOnTransport = 0;

            //
            // Put the connection on the free list.
            //

            ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

#if SRVDBG29
            UpdateConnectionHistory( "KEEP", endpoint, Connection );
#endif
            SrvInsertTailList(
                &endpoint->FreeConnectionList,
                &Connection->EndpointFreeListEntry
                );

            endpoint->FreeConnectionCount++;

            RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

            RELEASE_LOCK( &SrvEndpointLock );

        } else {

            RELEASE_LOCK( &SrvEndpointLock );

            SrvCloseFreeConnection( Connection );

        }

    }

    return;

} // SrvDereferenceConnection


VOID
SrvFreeConnection (
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This function returns a Connection Block to the system nonpaged
    pool.

Arguments:

    Connection - Address of connection

Return Value:

    None.

--*/

{
    PSLIST_ENTRY listEntry;
    PNONPAGED_HEADER header;
    PTRANSACTION transaction;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;

#if 0
    //
    // ENSURE WE ARE NOT STILL IN THE CONNECTION TABLE FOR THE ENDPOINT!
    //
    if( Connection->Endpoint ) {

        PTABLE_HEADER tableHeader = &Connection->Endpoint->ConnectionTable;
        USHORT i;
        KIRQL oldIrql;

        ACQUIRE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), &oldIrql );
        for ( i = 1; i < ENDPOINT_LOCK_COUNT ; i++ ) {
            ACQUIRE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
        }

        for( i = 0; i < tableHeader->TableSize; i++ ) {
            if( (PCONNECTION)tableHeader->Table[i].Owner == Connection ) {

                DbgPrint( "SRV: SrvFreeConnection(%p), but connection still in endpoint %p ConnectionTable\n",
                    Connection, Connection->Endpoint );

                DbgPrint( "    Entry number %d, addr %p\n", i, &tableHeader->Table[i] );
                DbgPrint( "    Connection->Sid %X, IPXSID %d\n", Connection->Sid, IPXSID_INDEX(Connection->Sid));

                DbgBreakPoint();
                break;
            }
        }

        for ( i = ENDPOINT_LOCK_COUNT-1 ; i > 0  ; i-- ) {
            RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
        }
        RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );
    }
#endif

    //
    // Free cached transactions.
    //

    listEntry = ExInterlockedPopEntrySList( &Connection->CachedTransactionList,
                                            &Connection->SpinLock );

    while ( listEntry != NULL ) {

        header = CONTAINING_RECORD( listEntry, NONPAGED_HEADER, ListEntry );
        transaction = header->PagedBlock;

        DEALLOCATE_NONPAGED_POOL( header );
        FREE_HEAP( transaction );
        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TransactionInfo.Frees );

        listEntry = ExInterlockedPopEntrySList(
                        &Connection->CachedTransactionList,
                        &Connection->SpinLock );

    }

    //
    // Free the search, session, tree, and file tables.
    //

    SrvFreeTable( &pagedConnection->SearchTable );
    SrvFreeTable( &Connection->FileTable );
    SrvFreeTable( &pagedConnection->TreeConnectTable );
    SrvFreeTable( &pagedConnection->SessionTable );

    //
    // Free the IPX saved response buffer, if there is one.
    //

    if ( Connection->DirectHostIpx == TRUE &&
         Connection->LastResponse != Connection->BuiltinSavedResponse ) {

        DEALLOCATE_NONPAGED_POOL( Connection->LastResponse );
    }

    //
    // Delete the lock on the connection.
    //

    DELETE_LOCK( &Connection->Lock );

    //
    // Delete the license server lock
    //
    DELETE_LOCK( &Connection->LicenseLock );

    //
    // Free the connection block.
    //

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( Connection, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG Connection->BlockHeader.ReferenceCount = (ULONG)-1;
    TERMINATE_REFERENCE_HISTORY( Connection );

    FREE_HEAP( pagedConnection );
    DEALLOCATE_NONPAGED_POOL( Connection );
    IF_DEBUG(HEAP) {
        KdPrint(( "SrvFreeConnection: Freed connection block at %p\n",
                    Connection ));
    }

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.ConnectionInfo.Frees );

    return;

} // SrvFreeConnection

#if DBG

NTSTATUS
SrvQueryConnections (
    OUT PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG BytesWritten
    )

{
    USHORT index;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY connectionListEntry;
    PBLOCK_INFORMATION blockInfo = Buffer;
    PENDPOINT endpoint;
    PCONNECTION connection;
    KIRQL oldIrql;

    *BytesWritten = 0;

    //
    // We need to look at the name of every client for which the server
    // has a connection.  Connection lists are stored off endpoints, so
    // walk the global endpoint list and the list of connections on each
    // endpoint.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( listEntry != &SrvEndpointList.ListHead ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        //
        // If this endpoint is closing, skip to the next one.
        // Otherwise, reference the endpoint so that it can't go away.
        //

        if ( GET_BLOCK_STATE(endpoint) != BlockStateActive ) {
            listEntry = listEntry->Flink;
            continue;
        }

        SrvReferenceEndpoint( endpoint );

        //
        // Put information about the endpoint into the output buffer.
        //

        if ( (PCHAR)(blockInfo + 1) <= (PCHAR)Buffer + BufferLength ) {
            blockInfo->Block = endpoint;
            blockInfo->BlockType = (ULONG)BlockTypeEndpoint;
            blockInfo->BlockState = (ULONG)endpoint->BlockHeader.State;
            blockInfo->ReferenceCount = endpoint->BlockHeader.ReferenceCount;
            blockInfo++;
        } else {
            SrvDereferenceEndpoint( endpoint );
            RELEASE_LOCK( &SrvEndpointLock );
            return STATUS_BUFFER_OVERFLOW;
        }

        //
        // Walk the connection table, writing information about each
        // connection to the output buffer.
        //

        index = (USHORT)-1;

        while ( TRUE ) {

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            connection = WalkConnectionTable( endpoint, &index );
            if ( connection == NULL ) {
                break;
            }

            if ( (PCHAR)(blockInfo + 1) <= (PCHAR)Buffer + BufferLength ) {
                blockInfo->Block = connection;
                blockInfo->BlockType = (ULONG)BlockTypeConnection;
                blockInfo->BlockState = (ULONG)connection->BlockHeader.State;
                blockInfo->ReferenceCount =
                    connection->BlockHeader.ReferenceCount;
                blockInfo++;
                SrvDereferenceConnection( connection );
            } else {
                SrvDereferenceConnection( connection );
                SrvDereferenceEndpoint( endpoint );
                RELEASE_LOCK( &SrvEndpointLock );
                return STATUS_BUFFER_OVERFLOW;
            }

        } // walk connection list

        //
        // Walk the free connection list, writing information about each
        // connection to the output buffer.
        //

        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

        for ( connectionListEntry = endpoint->FreeConnectionList.Flink;
              connectionListEntry != &endpoint->FreeConnectionList;
              connectionListEntry = connectionListEntry->Flink ) {

            connection = CONTAINING_RECORD(
                            connectionListEntry,
                            CONNECTION,
                            EndpointFreeListEntry
                            );

            if ( (PCHAR)(blockInfo + 1) <= (PCHAR)Buffer + BufferLength ) {
                blockInfo->Block = connection;
                blockInfo->BlockType = (ULONG)BlockTypeConnection;
                blockInfo->BlockState = (ULONG)connection->BlockHeader.State;
                blockInfo->ReferenceCount =
                    connection->BlockHeader.ReferenceCount;
                blockInfo++;
            } else {
                RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
                RELEASE_LOCK( &SrvEndpointLock );
                return STATUS_BUFFER_OVERFLOW;
            }

        } // walk free connection list

        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

        //
        // Capture a pointer to the next endpoint in the list (that one
        // can't go away because we hold the endpoint list), then
        // dereference the current endpoint.
        //

        listEntry = listEntry->Flink;
        SrvDereferenceEndpoint( endpoint );

    } // walk endpoint list

    RELEASE_LOCK( &SrvEndpointLock );

    *BytesWritten = (ULONG)((PCHAR)blockInfo - (PCHAR)Buffer);

    return STATUS_SUCCESS;

} // SrvQueryConnections
#endif // if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\blkdir.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blkdir.c

Abstract:

    This module implements routines for managing cached directory names

Author:

    Isaac Heizer

Revision History:

--*/

#include "precomp.h"
#include "blkdir.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKDIR

BOOLEAN
SrvIsDirectoryCached (
    IN  PWORK_CONTEXT     WorkContext,
    IN  PUNICODE_STRING   DirectoryName
)
{
    PLIST_ENTRY listEntry;
    PCACHED_DIRECTORY cd;
    ULONG directoryNameHashValue;
    PCONNECTION connection = WorkContext->Connection;
    KIRQL oldIrql;
    LARGE_INTEGER timeNow;

    //
    // DirectoryName must point to memory in nonpaged pool, else we can't touch
    //   it under spinlock control.  If the incomming SMB is UNICODE, we know that
    //   the name is in the smb buffer, and is therefore in nonpaged pool.  Otherwise
    //   we can't trust it and we're better off just not trying to cache it.
    //

    if( connection->CachedDirectoryCount == 0 || !SMB_IS_UNICODE( WorkContext ) ) {
        return FALSE;
    }

    KeQueryTickCount( &timeNow );
    timeNow.LowPart -= (SrvFiveSecondTickCount >> 1 );

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

top:
    for ( listEntry = connection->CachedDirectoryList.Flink;
          listEntry != &connection->CachedDirectoryList;
          listEntry = listEntry->Flink ) {

        cd = CONTAINING_RECORD( listEntry, CACHED_DIRECTORY, ListEntry );

        //
        // Is this element too old?
        //
        if( cd->TimeStamp < timeNow.LowPart ) {
            //
            // This element is more than 2.5 seconds old.  Toss it out
            //
            RemoveEntryList( listEntry );
            connection->CachedDirectoryCount--;
            DEALLOCATE_NONPAGED_POOL( cd );
            goto top;
        }

        if( cd->Tid != WorkContext->TreeConnect->Tid ) {
            continue;
        }

        //
        // Is the requested entry a subdir of this cache entry?
        //
        if( DirectoryName->Length < cd->DirectoryName.Length &&
            RtlCompareMemory( DirectoryName->Buffer, cd->DirectoryName.Buffer,
                              DirectoryName->Length ) == DirectoryName->Length &&
            cd->DirectoryName.Buffer[ DirectoryName->Length / sizeof( WCHAR ) ] == L'\\' ) {

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

            return TRUE;

        //
        // Not a subdir -- is it an exact match?
        //
        } else  if( DirectoryName->Length == cd->DirectoryName.Length &&
            RtlCompareMemory( cd->DirectoryName.Buffer, DirectoryName->Buffer,
                              DirectoryName->Length ) == DirectoryName->Length ) {

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
            return TRUE;
        }
    }

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    return FALSE;
}

VOID
SrvCacheDirectoryName (
    IN  PWORK_CONTEXT      WorkContext,
    IN  PUNICODE_STRING    DirectoryName
    )
/*++

Routine Description:

    This routine remembers 'DirectoryName' for further fast processing of the CheckPath SMB

Arguments:

    WorkContext - Pointer to the work context block

    DirectoryName - Fully canonicalized name of the directory we're caching

++*/

{
    CLONG blockLength;
    PCACHED_DIRECTORY cd;
    KIRQL oldIrql;
    PCONNECTION connection = WorkContext->Connection;
    PLIST_ENTRY listEntry;
    LARGE_INTEGER timeNow;
    USHORT tid;

    if( SrvMaxCachedDirectory == 0 ) {
        return;
    }

    //
    // DirectoryName must point to memory in nonpaged pool, else we can't touch
    //   it under spinlock control.  If the incomming SMB is UNICODE, we know that
    //   the name is in the smb buffer, and is therefore in nonpaged pool.  Otherwise
    //   we can't trust it and we're better off just not trying to cache it.
    //
    if( !SMB_IS_UNICODE( WorkContext ) ) {
        return;
    }

    KeQueryTickCount( &timeNow );
    timeNow.LowPart -= ( SrvFiveSecondTickCount >> 1 );

    tid = WorkContext->TreeConnect->Tid;

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    //
    // Search the directory cache and see if this directory is already cached. If so,
    //  don't cache it again.
    //

top:
    for ( listEntry = connection->CachedDirectoryList.Flink;
          listEntry != &connection->CachedDirectoryList;
          listEntry = listEntry->Flink ) {

        cd = CONTAINING_RECORD( listEntry, CACHED_DIRECTORY, ListEntry );

        //
        // Is this element too old?
        //
        if( cd->TimeStamp < timeNow.LowPart ) {
            //
            // This element is more than 2.5 seconds old.  Toss it out
            //
            RemoveEntryList( listEntry );
            connection->CachedDirectoryCount--;
            DEALLOCATE_NONPAGED_POOL( cd );
            goto top;
        }

        if( cd->Tid != tid ) {
            continue;
        }

        //
        // Is the new entry a subdir of this cache entry?
        //
        if( DirectoryName->Length < cd->DirectoryName.Length &&
            RtlCompareMemory( DirectoryName->Buffer, cd->DirectoryName.Buffer,
                              DirectoryName->Length ) == DirectoryName->Length &&
            cd->DirectoryName.Buffer[ DirectoryName->Length / sizeof( WCHAR ) ] == L'\\' ) {

            //
            // It is a subdir -- no need to cache it again
            //
            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

            return;
        }

        //
        // Is the cache entry a subdir of the new entry?
        //
        if( cd->DirectoryName.Length < DirectoryName->Length &&
            RtlCompareMemory( DirectoryName->Buffer, cd->DirectoryName.Buffer,
                              cd->DirectoryName.Length ) == cd->DirectoryName.Length &&
            DirectoryName->Buffer[ cd->DirectoryName.Length / sizeof( WCHAR ) ] == L'\\' ) {

            //
            // We can remove this entry
            //

            RemoveEntryList( listEntry );
            connection->CachedDirectoryCount--;
            DEALLOCATE_NONPAGED_POOL( cd );
    
            //
            // We want to cache this new longer entry
            //
            break;
        }

        //
        // Not a subdir -- is it an exact match?
        //
        if( cd->DirectoryName.Length == DirectoryName->Length &&
            RtlCompareMemory( cd->DirectoryName.Buffer, DirectoryName->Buffer,
                              DirectoryName->Length ) == DirectoryName->Length ) {

            //
            // This entry is already in the cache -- no need to recache
            //
            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
            return;
        }
    }

    //
    // This directory name is not already in the cache.  So add it.
    //

    blockLength = sizeof( CACHED_DIRECTORY ) + DirectoryName->Length + sizeof(WCHAR);

    cd = ALLOCATE_NONPAGED_POOL( blockLength, BlockTypeCachedDirectory );

    if( cd == NULL ) {

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvCacheDirectoryName: Unable to allocate %d bytes from pool",
            blockLength,
            NULL
            );

        return;
    }

    cd->Type = BlockTypeCachedDirectory;
    cd->State = BlockStateActive;
    cd->Size = (USHORT)blockLength;
    // cd->ReferenceCount = 1;              // not used

    //
    // Set the timestamp of this entry.  Remember, we subtracted 
    //  ticks up above from timeNow -- put them back in now.
    //
    cd->TimeStamp = timeNow.LowPart + ( SrvFiveSecondTickCount >> 1 );

    //
    // Store the directory name as it was passed into us
    //
    cd->DirectoryName.Length = DirectoryName->Length;
    cd->DirectoryName.MaximumLength = (USHORT)DirectoryName->MaximumLength;
    cd->DirectoryName.Buffer = (PWCH)(cd + 1);
    RtlCopyMemory( cd->DirectoryName.Buffer, DirectoryName->Buffer, DirectoryName->Length );

    cd->Tid = tid;

    InsertHeadList(
        &connection->CachedDirectoryList,
        &cd->ListEntry
    );

    //
    // Check the number of elements in the cache.  If getting too large, close oldest one.
    //
    if( connection->CachedDirectoryCount++ < SrvMaxCachedDirectory ) {
        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
        return;
    }

    //
    // Remove the last entry from the cache
    //
    cd = CONTAINING_RECORD(
                connection->CachedDirectoryList.Blink,
                CACHED_DIRECTORY,
                ListEntry
             );

    RemoveEntryList( &cd->ListEntry );
    connection->CachedDirectoryCount--;

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    DEALLOCATE_NONPAGED_POOL( cd );

    return;
}

VOID
SrvRemoveCachedDirectoryName(
    IN PWORK_CONTEXT    WorkContext,
    IN PUNICODE_STRING  DirectoryName
)
{
    PLIST_ENTRY listEntry;
    PCACHED_DIRECTORY cd;
    ULONG directoryNameHashValue;
    PCONNECTION connection = WorkContext->Connection;
    KIRQL oldIrql;
    USHORT tid;

    if( connection->CachedDirectoryCount == 0 ) {
        return;
    }

    //
    // DirectoryName must point to memory in nonpaged pool, else we can't touch
    //   it under spinlock control.  If the incomming SMB is UNICODE, we know that
    //   the name is in the smb buffer, and is therefore in nonpaged pool.  Otherwise
    //   we can't trust it and we're better off just not trying to cache it.
    //
    if( !SMB_IS_UNICODE( WorkContext ) ) {
        return;
    }

    COMPUTE_STRING_HASH( DirectoryName, &directoryNameHashValue );

    tid = WorkContext->TreeConnect->Tid;

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    for ( listEntry = connection->CachedDirectoryList.Flink;
          listEntry != &connection->CachedDirectoryList;
          listEntry = listEntry->Flink ) {

        cd = CONTAINING_RECORD( listEntry, CACHED_DIRECTORY, ListEntry );

        //
        // See if this entry is an exact match for what was requested
        //
        if( cd->DirectoryName.Length == DirectoryName->Length &&
            cd->Tid == tid &&
            RtlCompareMemory( cd->DirectoryName.Buffer, DirectoryName->Buffer,
                              DirectoryName->Length ) == DirectoryName->Length ) {

            //
            // Remove this entry from the list and adjust the count
            //
            RemoveEntryList( &cd->ListEntry );
            connection->CachedDirectoryCount--;

            ASSERT( (LONG)connection->CachedDirectoryCount >= 0 );

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

            DEALLOCATE_NONPAGED_POOL( cd );

            return;
        }

    }

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    return;
}

VOID
SrvCloseCachedDirectoryEntries(
    IN PCONNECTION Connection
    )
/*++
Routine Description:

    This routine closes all the cached directory entries on the connection

Arguments:

    Connection - Pointer to the connection structure having the cache

++*/
{
    KIRQL oldIrql;
    PCACHED_DIRECTORY cd;

    ACQUIRE_SPIN_LOCK( &Connection->SpinLock, &oldIrql );

    while( Connection->CachedDirectoryCount > 0 ) {

        cd = CONTAINING_RECORD( Connection->CachedDirectoryList.Flink, CACHED_DIRECTORY, ListEntry );

        RemoveEntryList( &cd->ListEntry );

        Connection->CachedDirectoryCount--;

        DEALLOCATE_NONPAGED_POOL( cd );
    }

    RELEASE_SPIN_LOCK( &Connection->SpinLock, oldIrql );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\blksec.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blksec.c

Abstract:

    This module implements routines for managing security tokens.

Author

    David Kruse (dkruse)  24-Apr-2002

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateSecurityContext )
#pragma alloc_text( PAGE, SrvSetSecurityContext )
#pragma alloc_text( PAGE, SrvReferenceSecurityContext )
#pragma alloc_text( PAGE, SrvDereferenceSecurityContext )
#endif


PSECURITY_CONTEXT
SrvAllocateSecurityContext()
{
    PSECURITY_CONTEXT Context;

    Context = ALLOCATE_HEAP( sizeof(SECURITY_CONTEXT), BlockTypeSession );
    if( !Context )
    {
        return NULL;
    }

    RtlZeroMemory( Context, sizeof(SECURITY_CONTEXT) );
    Context->BlockHeader.ReferenceCount = 1;
    SET_BLOCK_TYPE_STATE_SIZE( Context, BlockTypeSecurityContext, BlockStateActive, sizeof(SECURITY_CONTEXT) );
    INVALIDATE_SECURITY_HANDLE( Context->UserHandle );

    return Context;
}

VOID
SrvSetSecurityContext(
    PSECURITY_CONTEXT Context,
    PCtxtHandle handle
    )
{
    Context->UserHandle = *handle;
}

VOID
SrvReferenceSecurityContext(
    PSECURITY_CONTEXT Context
    )
{
    InterlockedIncrement( &Context->BlockHeader.ReferenceCount );
}

VOID
SrvDereferenceSecurityContext(
    PSECURITY_CONTEXT Context
    )
{
    ULONG Count = InterlockedDecrement( &Context->BlockHeader.ReferenceCount );

    if( Count == 0 )
    {
        if( !CONTEXT_EQUAL( SrvNullSessionToken, Context->UserHandle ) )
        {
            DeleteSecurityContext( &Context->UserHandle );
        }
        FREE_HEAP( Context );
    }
}

VOID
SrvReplaceSessionSecurityContext(
    PSESSION Session,
    PSECURITY_CONTEXT Context,
    OPTIONAL PWORK_CONTEXT WorkContext
    )
{
    if( Session->SecurityContext != NULL )
    {
        SrvDereferenceSecurityContext( Session->SecurityContext );
    }

    Session->SecurityContext = Context;

    if( WorkContext )
    {
        if( WorkContext->SecurityContext != NULL )
        {
            SrvDereferenceSecurityContext( WorkContext->SecurityContext );
        }

        WorkContext->SecurityContext = Context;
        SrvReferenceSecurityContext( Context );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\blksess.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blksess.c

Abstract:

    This module implements routines for managing session blocks.

Author:

    Chuck Lenzmeier (chuckl) 4-Oct-1989

Revision History:

--*/

#include "precomp.h"
#include "blksess.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKSESS

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateSession )
#pragma alloc_text( PAGE, SrvCheckAndReferenceSession )
#pragma alloc_text( PAGE, SrvCloseSession )
#pragma alloc_text( PAGE, SrvCloseSessionsOnConnection )
#pragma alloc_text( PAGE, SrvDereferenceSession )
#pragma alloc_text( PAGE, SrvFreeSession )
#endif


VOID
SrvAllocateSession (
    OUT PSESSION *Session,
    IN PUNICODE_STRING UserName OPTIONAL,
    IN PUNICODE_STRING Domain OPTIONAL
    )

/*++

Routine Description:

    This function allocates a Session Block from the FSP heap.

Arguments:

    Session - Returns a pointer to the session block, or NULL if
        no heap space was available.

Return Value:

    None.

--*/

{
    ULONG blockLength;
    PNONPAGED_HEADER header;
    PSESSION session;
    PWCH buffer;

    PAGED_CODE( );

    blockLength = sizeof(SESSION);
    if( ARGUMENT_PRESENT( UserName ) ) {
        blockLength += UserName->Length;
    }

    if( ARGUMENT_PRESENT( Domain ) ) {
        blockLength += Domain->Length;
    }

    //
    // Attempt to allocate from the heap.
    //

    session = ALLOCATE_HEAP( blockLength, BlockTypeSession );
    *Session = session;

    if ( session == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateSession: Unable to allocate %d bytes from heap",
            blockLength,
            NULL
            );
        return;
    }


    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvAllocateSession: Allocated session at %p\n", session );
    }

    //
    // Allocate the nonpaged header.
    //

    header = ALLOCATE_NONPAGED_POOL(
                sizeof(NONPAGED_HEADER),
                BlockTypeNonpagedHeader
                );
    if ( header == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateSession: Unable to allocate %d bytes from pool.",
            sizeof( NONPAGED_HEADER ),
            NULL
            );
        FREE_HEAP( session );
        *Session = NULL;
        return;
    }

    header->Type = BlockTypeSession;
    header->PagedBlock = session;

    RtlZeroMemory( session, blockLength );

    session->NonpagedHeader = header;
    SET_BLOCK_TYPE_STATE_SIZE( session, BlockTypeSession, BlockStateActive, blockLength );

    session->SecurityContext = NULL;

    header->ReferenceCount = 2; // allow for Active status and caller's pointer

    //
    // Initialize times for autologoff.
    //

    KeQuerySystemTime( &session->StartTime );
    session->LastUseTime.QuadPart = session->StartTime.QuadPart;

    buffer = (PWCH)( session + 1 );

    //
    // Initialize the user name.
    //
    if( ARGUMENT_PRESENT( UserName ) ) {
        session->NtUserName.Length = UserName->Length;
        session->NtUserName.MaximumLength = UserName->Length;
        session->NtUserName.Buffer = buffer;
        buffer += UserName->Length / sizeof( WCHAR );

        if( UserName->Length != 0 ) {
            RtlCopyUnicodeString( &session->NtUserName, UserName );
        }
    }

    //
    // Initialize the domain name.
    //
    if( ARGUMENT_PRESENT( Domain ) ) {
        session->NtUserDomain.Length = Domain->Length;
        session->NtUserDomain.MaximumLength = Domain->Length;
        session->NtUserDomain.Buffer = buffer;

        if( Domain->Buffer != NULL ) {
            RtlCopyUnicodeString( &session->NtUserDomain, Domain );
        }
    }

#if SRVDBG2
    session->BlockHeader.ReferenceCount = 2; // for INITIALIZE_REFERENCE_HISTORY
#endif
    INITIALIZE_REFERENCE_HISTORY( session );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.SessionInfo.Allocations );

    return;

} // SrvAllocateSession


BOOLEAN SRVFASTCALL
SrvCheckAndReferenceSession (
    PSESSION Session
    )

/*++

Routine Description:

    This function atomically verifies that a session is active and
    increments the reference count on the session if it is.

Arguments:

    Session - Address of session

Return Value:

    BOOLEAN - Returns TRUE if the session is active, FALSE otherwise.

--*/

{
    PAGED_CODE( );

    if( Session->LogonSequenceInProgress == FALSE ) {
        //
        // Acquire the lock that guards the session's state field.
        //

        ACQUIRE_LOCK( &Session->Connection->Lock );

        //
        // If the session is active, reference it and return TRUE.
        //

        if ( GET_BLOCK_STATE(Session) == BlockStateActive ) {

            SrvReferenceSession( Session );

            RELEASE_LOCK( &Session->Connection->Lock );

            return TRUE;

        }

        //
        // The session isn't active.  Return FALSE.
        //

        RELEASE_LOCK( &Session->Connection->Lock );
    }

    return FALSE;

} // SrvCheckAndReferenceSession


VOID
SrvCloseSession (
    PSESSION Session
    )

/*++

Routine Description:

    This routine does the core of a logoff (disconnect session).  It
    sets the state of the session to Closing, closes open files and
    pending transactions, and dereferences the session block.

Arguments:

    Session - Supplies a pointer to the session block that is to be
        closed.

Return Value:

    None.

--*/

{
    PCONNECTION connection = Session->Connection;
    PPAGED_CONNECTION pagedConnection = connection->PagedConnection;
    PAGED_CODE( );

    ACQUIRE_LOCK( &connection->Lock );

    if ( GET_BLOCK_STATE(Session) == BlockStateActive ) {

        IF_DEBUG(BLOCK1) SrvPrint1( "Closing session at %p\n", Session );

        SET_BLOCK_STATE( Session, BlockStateClosing );

        //
        // Free the session table entry.
        //
        // *** This must be done here, not in SrvDereferenceSession!
        //     This routine can be called from SrvSmbSessionSetupAndX
        //     when it needs to free up session table entry 0 for
        //     IMMEDIATE reuse.
        //

        SrvRemoveEntryTable(
            &pagedConnection->SessionTable,
            UID_INDEX( Session->Uid )
            );

        connection->CurrentNumberOfSessions--;

        RELEASE_LOCK( &connection->Lock );

        //
        // Disconnect the tree connects from this session
        //
        SrvDisconnectTreeConnectsFromSession( connection, Session );

        //
        // Close all open files.
        //

        SrvCloseRfcbsOnSessionOrPid( Session, NULL );

        //
        // Close all pending transactions.
        //

        SrvCloseTransactionsOnSession( Session );

        //
        // Close all DOS searches on this session.
        //

        SrvCloseSearches(
                connection,
                (PSEARCH_FILTER_ROUTINE)SrvSearchOnSession,
                (PVOID) Session,
                NULL
                );

        //
        // Close all cached directories on this session.
        //
        SrvCloseCachedDirectoryEntries( connection );

        //
        // Dereference the session (to indicate that it's no longer
        // open).
        //

        SrvDereferenceSession( Session );

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.SessionInfo.Closes );

    } else {

        RELEASE_LOCK( &connection->Lock );
    }

    return;

} // SrvCloseSession


VOID
SrvCloseSessionsOnConnection (
    IN PCONNECTION Connection,
    IN PUNICODE_STRING UserName OPTIONAL
    )

/*++

Routine Description:

    This function closes sessions on a connection.  It walks the
    connection's list of sessions, calling SrvCloseSession as
    appropriate.

Arguments:

    Connection - Supplies a pointer to a Connection Block

    UserName - if specified, only sessions with the given user name
        are closed.

Return Value:

    None.

--*/

{
    PTABLE_HEADER tableHeader;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;
    LONG i;
    UNICODE_STRING userName;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Close all active sessions.  (This also causes all open files
    // and pending transactions to be closed.)
    //
    // *** In order to prevent the session from being deallocated
    //     between when we find it in the table and the call to
    //     SrvCloseSession, we reference the session.  It is not
    //     legal to hold the connection lock while calling
    //     SrvCloseSession, so simply holding the lock while we walk
    //     the list is not legal.

    tableHeader = &pagedConnection->SessionTable;

    ACQUIRE_LOCK( &Connection->Lock );

    for ( i = 0; i < tableHeader->TableSize; i++ ) {

        PSESSION session = (PSESSION)tableHeader->Table[i].Owner;

        if( session == NULL || GET_BLOCK_STATE( session ) != BlockStateActive ) {
            //
            // This session either doesn't exist, or is already going away
            //
            continue;
        }

        if( UserName != NULL ) {
            //
            // Get the user name for this session.  We don't care about the
            //  domain name.
            //
            status = SrvGetUserAndDomainName( session, &userName, NULL );

            if( !NT_SUCCESS( status ) ) {
                //
                // We can't figure out the name for the user for this session.
                //  We probably shouldn't just blow it away, so let's just keep
                //  going.
                //
                continue;
            }

            if( RtlCompareUnicodeString( &userName, UserName, TRUE ) != 0 ) {
                //
                // This is not the user we're interested in. Skip it.
                //
                SrvReleaseUserAndDomainName( session, &userName, NULL );
                continue;
            }

            SrvReleaseUserAndDomainName( session, &userName, NULL );
        }

        SrvReferenceSession( session );
        RELEASE_LOCK( &Connection->Lock );

        SrvStatistics.SessionsErroredOut++;
        SrvCloseSession( session );

        SrvDereferenceSession( session );
        ACQUIRE_LOCK( &Connection->Lock );
    }

    RELEASE_LOCK( &Connection->Lock );

} // SrvCloseSessionsOnConnection


VOID SRVFASTCALL
SrvDereferenceSession (
    IN PSESSION Session
    )

/*++

Routine Description:

    This function decrements the reference count on a session.  If the
    reference count goes to zero, the session block is deleted.

    Since this routine may call SrvDereferenceConnection, the caller
    must be careful if he holds the connection lock that he also
    holds a referenced pointer to the connection.

Arguments:

    Session - Address of session

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    LONG result;

    PAGED_CODE( );

    //
    // Enter a critical section and decrement the reference count on the
    // block.
    //

    connection = Session->Connection;

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Dereferencing session %p; old refcnt %lx\n",
                    Session, Session->NonpagedHeader->ReferenceCount );
    }

    ASSERT( GET_BLOCK_TYPE( Session ) == BlockTypeSession );
    ASSERT( Session->NonpagedHeader->ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( Session, TRUE );

    result = InterlockedDecrement(
                &Session->NonpagedHeader->ReferenceCount
                );

    if ( result == 0 ) {

        //
        // The new reference count is 0, meaning that it's time to
        // delete this block.
        //
        // Remove the session from the global list of sessions.
        //

        SrvRemoveEntryOrderedList( &SrvSessionList, Session );

        //
        // Dereference the connection.
        //

        SrvDereferenceConnection( connection );
        DEBUG Session->Connection = NULL;

        //
        // Free the session block.
        //

        SrvFreeSession( Session );

    }

    return;

} // SrvDereferenceSession


VOID
SrvFreeSession (
    IN PSESSION Session
    )

/*++

Routine Description:

    This function returns a Session Block to the FSP heap.

Arguments:

    Session - Address of session

Return Value:

    None.

--*/

{
    KAPC_STATE ApcState;
    PEPROCESS process;

    PAGED_CODE( );

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( Session, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG Session->NonpagedHeader->ReferenceCount = -1;
    TERMINATE_REFERENCE_HISTORY( Session );

    //
    // Ensure we are in the system process
    //
    process = IoGetCurrentProcess();
    if ( process != SrvServerProcess ) {
        KeStackAttachProcess( SrvServerProcess, &ApcState );
    }

    //
    // Tell the License Server
    //
    SrvXsLSOperation( Session, XACTSRV_MESSAGE_LSRELEASE );

    //
    // Close the logon token
    //
    SrvFreeSecurityContexts( Session );

    //
    // Get back to where we were
    //
    if( process != SrvServerProcess ) {
        KeUnstackDetachProcess( &ApcState );
    }

    //
    // Deallocate the session's memory.
    //

    DEALLOCATE_NONPAGED_POOL( Session->NonpagedHeader );
    FREE_HEAP( Session );
    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvFreeSession: Freed session block at %p\n", Session );
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.SessionInfo.Frees );

    return;

} // SrvFreeSession
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\blksrch.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    blksrch.c

Abstract:

    This module implements routines for managing search blocks.

Author:

    David Treadwell (davidtr) 23-Feb-1990

Revision History:

--*/

#include "precomp.h"
#include "blksrch.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKSRCH

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateSearch )
#pragma alloc_text( PAGE, SrvCloseSearch )
#pragma alloc_text( PAGE, SrvCloseSearches )
#pragma alloc_text( PAGE, SrvDereferenceSearch )
#pragma alloc_text( PAGE, SrvFreeSearch )
#pragma alloc_text( PAGE, SrvReferenceSearch )
#pragma alloc_text( PAGE, SrvSearchOnDelete )
#pragma alloc_text( PAGE, SrvSearchOnPid )
#pragma alloc_text( PAGE, SrvSearchOnSession )
#pragma alloc_text( PAGE, SrvSearchOnTreeConnect )
#pragma alloc_text( PAGE, SrvTimeoutSearches )
#pragma alloc_text( PAGE, SrvForceTimeoutSearches )
#pragma alloc_text( PAGE, RemoveDuplicateCoreSearches )
#pragma alloc_text( PAGE, SrvAddToSearchHashTable )
#endif


VOID
SrvAllocateSearch (
    OUT PSEARCH *Search,
    IN PUNICODE_STRING SearchName,
    IN BOOLEAN IsCoreSearch
    )

/*++

Routine Description:

    This function allocates a Search Block from the FSP heap.

Arguments:

    Search - Returns a pointer to the search block, or NULL if no heap
        space was available.

    SearchName - Supplies a pointer to the string describing the search
        file name.

    IsCoreSearch - Indicates whether a core search block or regular
        search block should be allocated.  A core search block has a
        different block type and has the LastUsedTime field set.

Return Value:

    None.

--*/

{
    ULONG blockLength;
    PSEARCH search;

    PAGED_CODE( );

    blockLength = sizeof(SEARCH) + SearchName->Length +
                                            sizeof(*SearchName->Buffer);

    //
    // Attempt to allocate from the heap.
    //

    search = ALLOCATE_HEAP( blockLength, BlockTypeSearch );
    *Search = search;

    if ( search == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateSearch: Unable to allocate %d bytes from heap.",
            blockLength,
            NULL
            );

        // An error is logged by the caller

        return;
    }

    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvAllocateSearch: Allocated search block at %p\n",
                    search );
    }

    RtlZeroMemory( search, blockLength );

    search->BlockHeader.ReferenceCount = 2;

    //
    // If this is a core search, set the block type and the LastUsedTime
    // fields.
    //

    if ( IsCoreSearch ) {
        SET_BLOCK_TYPE_STATE_SIZE( search, BlockTypeSearchCore, BlockStateActive, blockLength );
        KeQuerySystemTime( &search->LastUseTime );
    } else {
        SET_BLOCK_TYPE_STATE_SIZE( search, BlockTypeSearch, BlockStateActive, blockLength );
    }

    //
    // Set the list entry fields to NULL.  They will stay this way in
    // OS/2-style searches (non-core), but will change to include the
    // search block in a last-use list if a core search.
    //
    // We zeroed the block above, so we don't have to do it here.
    //

    //search->LastUseListEntry.Flink = NULL;
    //search->LastUseListEntry.Blink = NULL;

    //
    // Set the Buffer field of the LastFileNameReturned field to NULL
    // so that we know that it is not in use.
    //
    // We zeroed the block above, so we don't have to do it here.
    //

    //search->LastFileNameReturned.Buffer == NULL;

    //
    // Set the directory cache pointer to NULL so that we don't try to
    // free it when the search block closes.
    //

    //search->DirectoryCache = NULL;

    //
    // Put search name after search block.
    //

    search->SearchName.Buffer = (PWCH)(search + 1);
    search->SearchName.Length = SearchName->Length;
    search->SearchName.MaximumLength = (SHORT)(SearchName->Length +
                                            sizeof(*SearchName->Buffer));

    RtlCopyMemory(
        search->SearchName.Buffer,
        SearchName->Buffer,
        SearchName->Length
        );

    INITIALIZE_REFERENCE_HISTORY( search );

    InterlockedIncrement(
        (PLONG)&SrvStatistics.CurrentNumberOfOpenSearches
        );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.SearchInfo.Allocations );

    return;

} // SrvAllocateSearch


VOID
SrvCloseSearch (
    IN PSEARCH Search
    )

/*++

Routine Description:

    This routine prepares a search block to be closed.  It changes the
    block state to closing and dereferences the search block so that is
    will be closed as soon as all other references are closed.

Arguments:

    Search - Supplies a pointer to the search block that is to be closed.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    ACQUIRE_LOCK( &Search->Session->Connection->Lock );

    if ( GET_BLOCK_STATE(Search) == BlockStateActive ) {

        IF_DEBUG(BLOCK1) {
            SrvPrint2( "Closing search block at %p, %wZ\n",
                          Search, &Search->SearchName );
        }

        SET_BLOCK_STATE( Search, BlockStateClosing );

        RELEASE_LOCK( &Search->Session->Connection->Lock );

        //
        // Dereference the search block (to indicate that it's no longer
        // open).
        //

        SrvDereferenceSearch( Search );

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.SearchInfo.Closes );

    } else {

        RELEASE_LOCK( &Search->Session->Connection->Lock );

    }

    return;

} // SrvCloseSearch


VOID
SrvCloseSearches (
    IN PCONNECTION Connection,
    IN PSEARCH_FILTER_ROUTINE SearchFilterRoutine,
    IN PVOID FunctionParameter1,
    IN PVOID FunctionParameter2
    )

/*++

Routine Description:

    This is the common routine to close searches based on the
    filter routine and the parameters passed.

Arguments:

    Connection - the connection which contains the search blocks to be
        closed.

    SearchFilterRoutine - a routine that determines whether the
        search block is to be closed or not.

    FunctionParameter1
    FunctionParameter2 -  parameters to be passed to the filter routine

Return Value:

    None.

--*/

{
    PLIST_ENTRY searchEntry;
    PLIST_ENTRY nextSearchEntry;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;
    PSEARCH search;
    ULONG i;

    PAGED_CODE( );

    ACQUIRE_LOCK( &Connection->Lock );

    //
    // Go through the list's search blocks, closing those which passes
    // the check in the filter routine.  While a search block is
    // being used it is taken off the lists, so there is no danger of
    // dereferencing a block whose last use time is about to be updated.
    //

    searchEntry = pagedConnection->CoreSearchList.Flink;

    while ( searchEntry != &pagedConnection->CoreSearchList ) {

        nextSearchEntry = searchEntry->Flink;

        search = CONTAINING_RECORD( searchEntry, SEARCH, LastUseListEntry );

        if ( SearchFilterRoutine(
                        search,
                        FunctionParameter1,
                        FunctionParameter2
                        ) ) {

            IF_SMB_DEBUG(SEARCH2) {
                SrvPrint1( "SrvCloseSearches: Closing search block at %p\n", search );
            }

            SrvCloseSearch( search );
        }

        searchEntry = nextSearchEntry;
    }

    //
    // Close all active non-core searches.
    //

    for ( i = 0; i < (ULONG)pagedConnection->SearchTable.TableSize; i++ ) {

        search = (PSEARCH)pagedConnection->SearchTable.Table[i].Owner;

        if ( (search != NULL) &&
             (GET_BLOCK_STATE( search ) == BlockStateActive) &&
             SearchFilterRoutine(
                            search,
                            FunctionParameter1,
                            FunctionParameter2
                            ) ) {

            IF_SMB_DEBUG(SEARCH2) {
                SrvPrint1( "SrvCloseSearches: Closing non-core search block at %p\n", search );
            }

            SrvCloseSearch( search );
        }
    }

    RELEASE_LOCK( &Connection->Lock );
    return;

} // SrvCloseSearches

VOID
SrvDereferenceSearch (
    IN PSEARCH Search
    )

/*++

Routine Description:

    This function decrements the reference count on a search block.  If
    the reference count goes to zero, the search block is deleted.

Arguments:

    Search - Address of search block

Return Value:

    None.

--*/

{
    PCONNECTION connection = Search->Session->Connection;
    PPAGED_CONNECTION pagedConnection = connection->PagedConnection;

    PAGED_CODE( );

    //
    // Enter a critical section and decrement the reference count on the
    // block.
    //

    ACQUIRE_LOCK( &connection->Lock );

    ASSERT( GET_BLOCK_TYPE(Search) == BlockTypeSearch ||
            GET_BLOCK_TYPE(Search) == BlockTypeSearchCore );

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Dereferencing search block %p; old refcnt %lx\n",
                    Search, Search->BlockHeader.ReferenceCount );
    }

    ASSERT( (LONG)Search->BlockHeader.ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( Search, TRUE );

    if ( --Search->BlockHeader.ReferenceCount == 0 ) {

        ASSERT( GET_BLOCK_STATE(Search) != BlockStateActive );

        //
        // The new reference count is 0, meaning that it's time to
        // delete this block.  Free the search block entry in the search
        // table.
        //
        // If the search block is for a find unique, then the table
        // index will be -1, indicating that it has no entry on the
        // search table.
        //

        if ( Search->TableIndex != -1 ) {

            SrvRemoveEntryTable(
                &pagedConnection->SearchTable,
                Search->TableIndex
                );
        }

        //
        // If it was an old-style search, remove it from the hash table and
        // the last-use list it was on.
        //

        if ( Search->BlockHeader.Type == BlockTypeSearchCore ) {

            if (Search->LastUseListEntry.Flink != NULL ) {

                SrvRemoveEntryList(
                    &pagedConnection->CoreSearchList,
                    &Search->LastUseListEntry
                    );

                DECREMENT_DEBUG_STAT2( SrvDbgStatistics.CoreSearches );

            }

            if (Search->HashTableEntry.Flink != NULL ) {

                SrvRemoveEntryList(
                    &pagedConnection->SearchHashTable[Search->HashTableIndex].ListHead,
                    &Search->HashTableEntry
                    );
            }

            pagedConnection->CurrentNumberOfCoreSearches--;
        }

        // Decrement the count of open files in the session.  Including
        // searches in the count of open files on the session ensures
        // that a session with an open search will not be closed.
        //

        ASSERT( Search->Session->CurrentSearchOpenCount != 0 );
        Search->Session->CurrentSearchOpenCount--;

        RELEASE_LOCK( &connection->Lock );

        //
        // Close the directory handle for the search.
        //

        if ( Search->DirectoryHandle != NULL ) {
            SRVDBG_RELEASE_HANDLE( Search->DirectoryHandle, "SCH", 7, Search );
            SrvNtClose( Search->DirectoryHandle, TRUE );
        }

        //
        // Dereference the session and tree connect.
        //

        SrvDereferenceSession( Search->Session );
        SrvDereferenceTreeConnect( Search->TreeConnect );

        //
        // Free the LastFileNameReturned buffer, if any.
        //

        if ( Search->LastFileNameReturned.Buffer != NULL ) {
            FREE_HEAP( Search->LastFileNameReturned.Buffer );
        }

        //
        // Free the directory cache, if any.
        //

        if ( Search->DirectoryCache != NULL ) {
            FREE_HEAP( Search->DirectoryCache );
        }

        //
        // Free the search block.
        //

        SrvFreeSearch( Search );

    } else {

        RELEASE_LOCK( &connection->Lock );

    }

    return;

} // SrvDereferenceSearch


VOID
SrvFreeSearch (
    IN PSEARCH Search
    )

/*++

Routine Description:

    This function returns a Search Block to the server heap.

Arguments:

    Search - Address of Search Block

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( Search, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG Search->BlockHeader.ReferenceCount = (ULONG)-1;
    TERMINATE_REFERENCE_HISTORY( Search );

    FREE_HEAP( Search );
    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvFreeSearch: Freed search block at %p\n", Search );
    }

    InterlockedDecrement(
        (PLONG)&SrvStatistics.CurrentNumberOfOpenSearches
        );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.SearchInfo.Frees );

    return;

} // SrvFreeSearch


VOID
SrvReferenceSearch (
    PSEARCH Search
    )

/*++

Routine Description:

    This function increments the reference count on a search block.

Arguments:

    Search - Address of search block.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    ACQUIRE_LOCK( &Search->Session->Connection->Lock );

    ASSERT( (LONG)Search->BlockHeader.ReferenceCount > 0 );
    ASSERT( GET_BLOCK_TYPE(Search) == BlockTypeSearch ||
            GET_BLOCK_TYPE(Search) == BlockTypeSearchCore );
    ASSERT( GET_BLOCK_STATE(Search) == BlockStateActive );
    UPDATE_REFERENCE_HISTORY( Search, FALSE );

    //
    // Enter a critical section and increment the reference count on the
    // search block.
    //

    Search->BlockHeader.ReferenceCount++;

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Referencing search block %p; new refcnt %lx\n",
                    Search, Search->BlockHeader.ReferenceCount );
    }

    RELEASE_LOCK( &Search->Session->Connection->Lock );

    return;

} // SrvReferenceSearch


BOOLEAN
SrvSearchOnDelete(
    IN PSEARCH Search,
    IN PUNICODE_STRING DirectoryName,
    IN PTREE_CONNECT TreeConnect
    )

/*++

Routine Description:

    Filter routine to determine to pick the search blocks on this
    directory.

Arguments:

    Search - the search block currently being looked at.
    DirectoryName - name of directory currently being deleted.
    TreeConnect - the TreeConnect which is currently being looked at.

Return Value:

    TRUE, if search block belongs to the TreeConnect.
    FALSE, otherwise.

--*/

{
    UNICODE_STRING searchDirectoryName;

    PAGED_CODE( );

    //
    // We'll use the same buffer as the SearchName string in the
    // search for the comparison, but use the length from the
    // passed-in directory name if it is less.  This allows
    // all searches on subdirectories of a deleted directory to
    // be closed.
    //

    searchDirectoryName = Search->SearchName;

    if ( searchDirectoryName.Length > DirectoryName->Length ) {
        searchDirectoryName.Length = DirectoryName->Length;
    }

    return ( Search->TreeConnect == TreeConnect &&
             RtlCompareUnicodeString(
                 &searchDirectoryName,
                 DirectoryName,
                 TRUE ) == 0 );
}

BOOLEAN
SrvSearchOnPid(
    IN PSEARCH Search,
    IN USHORT Pid,
    IN PVOID Dummy
    )

/*++

Routine Description:

    Filter routine to determine to pick the search blocks on this
    Pid.

Arguments:

    Search - the search block currently being looked at.
    Pid - the Pid which is currently being run down.

Return Value:

    TRUE, if search block belongs to the pid.
    FALSE, otherwise.

--*/

{
    PAGED_CODE( );

    return ( Search->Pid == Pid );
}

BOOLEAN
SrvSearchOnSession(
    IN PSEARCH Search,
    IN PSESSION Session,
    IN PVOID Dummy
    )

/*++

Routine Description:

    Filter routine to determine to pick the search blocks on this
    Session.

Arguments:

    Search - the search block currently being looked at.
    Session - the session which is currently being closed.

Return Value:

    TRUE, if search block belongs to the session.
    FALSE, otherwise.

--*/

{
    PAGED_CODE( );

    return ( Search->Session == Session );
}

BOOLEAN
SrvSearchOnTreeConnect(
    IN PSEARCH Search,
    IN PTREE_CONNECT TreeConnect,
    IN PVOID Dummy
    )

/*++

Routine Description:

    Filter routine to determine to pick the search blocks on this
    Tree Connect.

Arguments:

    Search - the search block currently being looked at.
    TreeConnect - the TreeConnect which is currently being run down.

Return Value:

    TRUE, if search block belongs to the TreeConnect.
    FALSE, otherwise.

--*/

{
    PAGED_CODE( );

    return ( Search->TreeConnect == TreeConnect );
}

ULONG
SrvTimeoutSearches (
    IN PLARGE_INTEGER SearchCutoffTime OPTIONAL,
    IN PCONNECTION Connection,
    IN BOOLEAN TimeoutAtLeastOne
    )

/*++

Routine Description:

    Goes through the lists of core search blocks, dereferencing those
    that have timed out.

Arguments:

    SearchCutoffTime - The cutoff time for closing core search blocks.

    Connection - the connection whose search blocks are to be
        checked for timeouts.

    TimeoutAtLeastOne - if TRUE, a minimum of one block is closed.  This
        is used when we are timing out because the search table is full
        and we need to allocate a search block and when the total number of
        search blocks have reached our limit.

Return Value:

    The number of search blocks that were timed out.

--*/

{

    LARGE_INTEGER currentTime;
    LARGE_INTEGER searchCutoffTime;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;
    PLIST_ENTRY searchEntry;
    PLIST_ENTRY nextSearchEntry;
    ULONG count = 0;

    PAGED_CODE( );

    //
    // First, get the current time, then subtract off the timeout
    // value.  Any block older than this result is too old.
    //

    if ( !ARGUMENT_PRESENT( SearchCutoffTime ) ) {
        KeQuerySystemTime( &currentTime );

        //
        // Get the current search timeout values.  This must be protected
        // by the configuration lock because these values are changed
        // dynamically.
        //

        ACQUIRE_LOCK( &SrvConfigurationLock );
        searchCutoffTime.QuadPart =
                        currentTime.QuadPart - SrvSearchMaxTimeout.QuadPart;
        RELEASE_LOCK( &SrvConfigurationLock );

    } else {
        searchCutoffTime = *SearchCutoffTime;
    }

    //
    // Acquire the connection lock.
    //

    ACQUIRE_LOCK( &Connection->Lock );

    IF_SMB_DEBUG(SEARCH2) {
        SrvPrint2( "Core blocks: Oldest valid time is %lx,%lx\n",
                    searchCutoffTime.HighPart,
                    searchCutoffTime.LowPart );
    }

    //
    // Go through the list's search blocks, dereferencing those who
    // are older than the list timeout.  While a search block
    // is being used it is taken off the lists, so there is no
    // danger of dereferencing a block whose last use time is
    // about to be updated.
    //

    searchEntry = pagedConnection->CoreSearchList.Flink;

    while ( searchEntry != &pagedConnection->CoreSearchList ) {

        PSEARCH search;

        nextSearchEntry = searchEntry->Flink;

        search = CONTAINING_RECORD( searchEntry, SEARCH, LastUseListEntry );

        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint2( "Comparing time %lx,%lx\n",
                        search->LastUseTime.HighPart,
                        search->LastUseTime.LowPart );
        }

        //
        // If the time on the current search block is greater than
        // the oldest valid time, it is sufficiently new, so
        // we can stop searching the list, as all further
        // search blocks are newer than this one.
        //

        if ( (search->LastUseTime.QuadPart > searchCutoffTime.QuadPart) &&
             ( !TimeoutAtLeastOne || (count != 0) ) ) {
            break;
        }

        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint1( "Closing search block at %p\n", search );
        }

        SrvCloseSearch( search );

        count++;

        searchEntry = nextSearchEntry;
    }

    RELEASE_LOCK( &Connection->Lock );
    return count;

} // SrvTimeoutSearches


VOID
SrvForceTimeoutSearches(
    IN PCONNECTION Connection
    )
/*++

Routine Description:

    Goes through the lists of core search blocks, closing those
    that have timed out.  This forces the close of at least one
    search block.

Arguments:

    Connection - Pointer to the connection from which a search
        block is to be closed first.

Return Value:

    None.

--*/

{
    USHORT index;
    PENDPOINT endpoint;
    PLIST_ENTRY listEntry;
    PCONNECTION testConnection;
    LARGE_INTEGER currentTime;
    LARGE_INTEGER searchCutoffTime;
    ULONG count;

    PAGED_CODE( );

    //
    // Attempt to timeout the oldest search block for this connection.
    //

    KeQuerySystemTime( &currentTime );

    //
    // Get the current search timeout values.  This must be protected
    // by the configuration lock because these values are changed
    // dynamically.
    //

    ACQUIRE_LOCK( &SrvConfigurationLock );
    searchCutoffTime.QuadPart =
                    currentTime.QuadPart - SrvSearchMaxTimeout.QuadPart;
    RELEASE_LOCK( &SrvConfigurationLock );

    count = SrvTimeoutSearches(
                            &searchCutoffTime,
                            Connection,
                            TRUE
                            );

    //
    // Walk each connection and determine if we should close it.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( listEntry != &SrvEndpointList.ListHead ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        //
        //
        // If this endpoint is closing, skip to the next one.
        // Otherwise, reference the endpoint so that it can't go away.
        //

        if ( GET_BLOCK_STATE(endpoint) != BlockStateActive ) {
            listEntry = listEntry->Flink;
            continue;
        }

        SrvReferenceEndpoint( endpoint );

        //
        // Walk the endpoint's connection table.
        //

        index = (USHORT)-1;

        while ( TRUE ) {

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            testConnection = WalkConnectionTable( endpoint, &index );
            if ( testConnection == NULL ) {
                break;
            }

            RELEASE_LOCK( &SrvEndpointLock );

            //
            // Time out old core search blocks.
            //

            count += SrvTimeoutSearches(
                                    &searchCutoffTime,
                                    testConnection,
                                    (BOOLEAN)(count == 0)
                                    );

            ACQUIRE_LOCK( &SrvEndpointLock );

            //
            // Dereference the connection to account for the reference
            // from WalkConnectionTable.
            //

            SrvDereferenceConnection( testConnection );

        } // walk connection table

        //
        // Capture a pointer to the next endpoint in the list (that one
        // can't go away because we hold the endpoint list), then
        // dereference the current endpoint.
        //

        listEntry = listEntry->Flink;
        SrvDereferenceEndpoint( endpoint );

    } // walk endpoint list

    RELEASE_LOCK( &SrvEndpointLock );

} // SrvForceTimeoutSearches


VOID
RemoveDuplicateCoreSearches(
    IN PPAGED_CONNECTION PagedConnection
    )

/*++

Routine Description:

    Goes through the connection hash table and removes duplicate searches.

    *** Connection lock assumed held.  Remains held on exit. ***

Arguments:

    PagedConnection - Pointer to the paged portion of the connection block.

Return Value:

    None.

--*/

{
    ULONG i, j;
    PSEARCH firstSearch;
    PSEARCH tmpSearch;
    PLIST_ENTRY listHead;
    PLIST_ENTRY searchEntry;
    PLIST_ENTRY nextSearchEntry;
    PTREE_CONNECT treeConnect;
    USHORT pid;
    PUNICODE_STRING searchName;

    PAGED_CODE( );

    for ( i = 0; i < SEARCH_HASH_TABLE_SIZE; i++ ) {

        //
        // If this slot has been idle, skip.
        //

        if ( !PagedConnection->SearchHashTable[i].Dirty ) {
            continue;
        }

        PagedConnection->SearchHashTable[i].Dirty = FALSE;
        listHead = &PagedConnection->SearchHashTable[i].ListHead;

        //
        // Skip the first 3 searches.  This will hopefully take care of
        // weird dos apps that plays with multiple search blocks. 3 is
        // an arbitrary number.
        //

        searchEntry = listHead->Flink;
        for ( j = 0; j < 3; j++) {

            if ( searchEntry != listHead ) {
                searchEntry = searchEntry->Flink;
            } else {
                continue;
            }
        }

next_search:

        firstSearch = CONTAINING_RECORD(
                                searchEntry,
                                SEARCH,
                                HashTableEntry
                                );

        //
        // Assign these to locals so they don't get recomputed each
        // time we go through the loop.
        //

        treeConnect = firstSearch->TreeConnect;
        pid = firstSearch->Pid;
        searchName = &firstSearch->SearchName;

        searchEntry = searchEntry->Flink;

        //
        // Close all duplicates.
        //

        while ( searchEntry != listHead ) {

            nextSearchEntry = searchEntry->Flink;
            tmpSearch = CONTAINING_RECORD(
                                    searchEntry,
                                    SEARCH,
                                    HashTableEntry
                                    );

            if ( ( tmpSearch->TreeConnect == treeConnect ) &&
                 ( tmpSearch->Pid == pid ) &&
                 ( RtlCompareUnicodeString(
                           searchName,
                           &tmpSearch->SearchName,
                           FALSE                       // case sensitive
                           ) == 0 ) ) {

                SrvCloseSearch( tmpSearch );
            }

            searchEntry = nextSearchEntry;
        }

        //
        // If we have another search candidate. Repeat.
        //

        if ( firstSearch->HashTableEntry.Flink != listHead ) {
            searchEntry = firstSearch->HashTableEntry.Flink;
            goto next_search;
        }
    }

} // RemoveDuplicateCoreSearches

VOID
SrvAddToSearchHashTable(
    IN PPAGED_CONNECTION PagedConnection,
    IN PSEARCH Search
    )

/*++

Routine Description:

    Inserts a search block into the connection hash table.

    *** Connection lock assumed held.  Remains held on exit. ***

Arguments:

    PagedConnection - Pointer to the paged portion of the connection block.

    Search - Pointer to the search block to be inserted.

Return Value:

    None.

--*/

{
    ULONG nameLength;
    ULONG lastChar;
    ULONG hashSum;
    ULONG i;

    PAGED_CODE( );

    //
    // Get the hash value
    //

    nameLength = Search->SearchName.Length / sizeof(WCHAR);

    //
    // add the length and the first 3 bytes of the tree connect block address
    //

    //
    // NT64: Note that before the port, this line read:
    //
    // hashSum = nameLength + (ULONG)Search->TreeConnect >> 4;
    //
    // It is likely true that the original author intended to right-shift
    // only the pointer, not the sum.  However, after discussion with the
    // current owners of this component, it was decided to leave the current
    // precedence intact.  As part of the 64-bit port, the actual precedence
    // has been made explicit.
    //

    hashSum = (ULONG)((nameLength + (ULONG_PTR)Search->TreeConnect) >> 4);

    //
    // If the length < 8, then this is probably not an interesting core
    // search.
    //

    if ( nameLength > 7 ) {

        lastChar = nameLength - 5;

        //
        // Add the last 5 characters
        //

        for ( i = nameLength-1 ; i >= lastChar ; i-- ) {
            hashSum += (ULONG)Search->SearchName.Buffer[i];
        }
    }

    //
    // get the slot number.
    //

    i = hashSum & (SEARCH_HASH_TABLE_SIZE-1);

    //
    // Tell the scavenger that a search has been inserted to this slot.
    //

    PagedConnection->SearchHashTable[i].Dirty = TRUE;

    //
    // Insert this new search block into the hash table
    //

    SrvInsertHeadList(
                &PagedConnection->SearchHashTable[i].ListHead,
                &Search->HashTableEntry
                );

    Search->HashTableIndex = (USHORT)i;
    return;

} // SrvAddToSearchHashTable
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\blktimer.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    blkwork.c

Abstract:

    This module implements routines for managing work context blocks.

Author:

    Chuck Lenzmeier (chuckl) 9-Feb-1994

Revision History:

--*/

#include "precomp.h"
#include "blktimer.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKTIMER

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateTimer )
#pragma alloc_text( PAGE, SrvCancelTimer )
#pragma alloc_text( PAGE, SrvSetTimer )
#endif


PSRV_TIMER
SrvAllocateTimer (
    VOID
    )

/*++

Routine Description:

    This routine allocates a timer structure.

Arguments:

    None.

Return Value:

    PSRV_TIMER -- pointer to the allocated timer structure, or NULL.

--*/

{
    PSLIST_ENTRY entry;
    PSRV_TIMER timer;

    PAGED_CODE( );

    entry = ExInterlockedPopEntrySList( &SrvTimerList, &GLOBAL_SPIN_LOCK(Timer) );
    if ( entry == NULL ) {
        timer = ALLOCATE_NONPAGED_POOL( sizeof(SRV_TIMER), BlockTypeTimer );
        if ( timer != NULL ) {
            KeInitializeEvent( &timer->Event, NotificationEvent, FALSE );
            KeInitializeTimer( &timer->Timer );
        }
    } else {
        timer = CONTAINING_RECORD( entry, SRV_TIMER, Next );
    }

    return timer;

} // SrvAllocateTimer


VOID
SrvCancelTimer (
    PSRV_TIMER Timer
    )

/*++

Routine Description:

    This routine cancels a timer.

Arguments:

    Timer -- pointer to the timer

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Cancel the timer.
    //

    if ( !KeCancelTimer( &Timer->Timer ) ) {

        //
        // We were unable to cancel the timer.  This means that the
        // timer routine has either already run or is scheduled to run.
        // We need to wait for the timer routine to complete before we
        // continue.
        //
        // We expect that if we couldn't cancel the timer (which
        // shouldn't happen often), then the timer routine has probably
        // already completed, so we call KeReadStateEvent first to avoid
        // the overhead of KeWaitForSingleObject.
        //

        if ( !KeReadStateEvent( &Timer->Event ) ) {
            KeWaitForSingleObject(
                &Timer->Event,
                UserRequest,
                KernelMode,     // don't let kernel stack be paged
                FALSE,          // not alertable
                NULL            // no timeout
                );
        }

    }

    return;

} // SrvCancelTimer


VOID
SrvSetTimer (
    IN PSRV_TIMER Timer,
    IN PLARGE_INTEGER Timeout,
    IN PKDEFERRED_ROUTINE TimeoutHandler,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine starts a timer.

Arguments:

    Timer -- pointer to the timer

    Timeout -- number of milliseconds to wait

    TimeoutHandler -- routine to call if the timer expires

    Context -- context value for the timer routine

Return Value:

    None.

--*/

{
    PRKDPC Dpc = &Timer->Dpc;

    PAGED_CODE( );

    //
    // Initialize the DPC associated with the timer.  Reset the event
    // that indicates that the timer routine has run.  Set the timer.
    //

    KeInitializeDpc( Dpc, TimeoutHandler, Context );

    KeSetTargetProcessorDpc( Dpc, (CCHAR)KeGetCurrentProcessorNumber() );

    KeClearEvent( &Timer->Event );

    KeSetTimer( &Timer->Timer, *Timeout, Dpc );

    return;

} // SrvSetTimer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\blktable.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blktable.c

Abstract:

    This module implements routines for managing tables.

Author:

    Chuck Lenzmeier (chuckl) 4-Oct-1989

Revision History:

--*/

#include "precomp.h"
#include "blktable.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKTABLE

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateTable )
#endif
#if 0
NOT PAGEABLE -- SrvGrowTable
NOT PAGEABLE -- SrvRemoveEntryTable
#endif


VOID
SrvAllocateTable (
    IN PTABLE_HEADER TableHeader,
    IN ULONG NumberOfEntries,
    IN BOOLEAN Nonpaged
    )

/*++

Routine Description:

    This routine allocates a table and sets those fields that it can.

Arguments:

    TableHeader - a pointer to the table header structure

    NumberOfEntries - the number of table entries to allocate

    Nonpaged - indicates whether the table should be allocated from
        nonpaged pool

Return Value:

    None.

--*/

{
    SHORT i;
    CLONG tableSize;
    PTABLE_ENTRY table;

    PAGED_CODE( );

    //
    // Allocate space for the table.
    //

    tableSize = sizeof(TABLE_ENTRY) * NumberOfEntries;

    if ( Nonpaged ) {
        table = ALLOCATE_NONPAGED_POOL( tableSize, BlockTypeTable );
    } else {
        table = ALLOCATE_HEAP_COLD( tableSize, BlockTypeTable );
    }

    if ( table == NULL ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateTable: Unable to allocate %d bytes from paged pool.",
            tableSize,
            NULL
            );

        TableHeader->Table = NULL;
        return;

    }

    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvAllocateTable: Allocated table at %p\n", table );
    }

    //
    // Initialize the table, creating a linked list of free entries.
    //

    RtlZeroMemory( table, tableSize );

    table[NumberOfEntries-1].NextFreeEntry = -1;

    for ( i = (SHORT)(NumberOfEntries - 2); i >= 0; i-- ) {
        table[i].NextFreeEntry = (SHORT)(i + 1);
    }

    //
    // Point the table header to the table and set the first and
    // free entry indexes.
    //

    TableHeader->Table = table;
    TableHeader->Nonpaged = Nonpaged;
    TableHeader->TableSize = (USHORT)NumberOfEntries;
    TableHeader->FirstFreeEntry = 0;
    TableHeader->LastFreeEntry = (SHORT)(NumberOfEntries-1);

    return;

} // SrvAllocateTable


BOOLEAN
SrvGrowTable (
    IN PTABLE_HEADER TableHeader,
    IN ULONG NumberOfNewEntries,
    IN ULONG MaxNumberOfEntries,
    OPTIONAL OUT NTSTATUS* pStatus
    )

/*++

Routine Description:

    This routine grows a table by the number of entries specified.  It
    allocates new space that is large enough to hold the expanded
    table, copies over the current table, initializes the entries
    that were added, and frees the old table.

    WARNING: The calling routine *must* hold a lock for the table to
    prevent access to the table while it is being copied over.

Arguments:

    TableHeader - a pointer to the table header structure

    NumberOfNewEntries - the number of table entries to add to the table

    MaxNumberOfEntries - the maximum allowable size for the table
    
    pStatus - Optional return value.  INSUFFICIENT_RESOURCES means mem allocation error,
              while INSUFF_SERVER_RESOURCES means we're over our table limit

Return Value:

    BOOLEAN - TRUE if the table was successfully grown, FALSE otherwise.

--*/

{
    ULONG newTableSize, totalEntries, oldNumberOfEntries;
    USHORT i;
    PTABLE_ENTRY table;

    oldNumberOfEntries = TableHeader->TableSize;
    totalEntries = oldNumberOfEntries + NumberOfNewEntries;

    //
    // If the table is already at the maximum size, kick out the request.
    //

    if ( oldNumberOfEntries >= MaxNumberOfEntries ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvGrowTable: Unable to grow table at max size (%ld).",
            MaxNumberOfEntries,
            NULL
            );
        if( ARGUMENT_PRESENT(pStatus) )
        {
            *pStatus = STATUS_INSUFF_SERVER_RESOURCES;
        }
        return FALSE;
    }

    //
    // If adding the requested number would put the table size over the
    // maximum, allocate to the maximum size.
    //

    if ( totalEntries > MaxNumberOfEntries ) {
        totalEntries = MaxNumberOfEntries;
        NumberOfNewEntries = totalEntries - oldNumberOfEntries;
    }

    newTableSize = totalEntries * sizeof(TABLE_ENTRY);

    //
    // Allocate space for the new table.
    //

    if ( TableHeader->Nonpaged ) {
        table = ALLOCATE_NONPAGED_POOL( newTableSize, BlockTypeTable );
    } else {
        table = ALLOCATE_HEAP_COLD( newTableSize, BlockTypeTable );
    }

    if ( table == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvGrowTable: Unable to allocate %d bytes from paged pool",
            sizeof( BLOCK_HEADER ) + newTableSize,
            NULL
            );
        if( ARGUMENT_PRESENT(pStatus) )
        {
            *pStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        return FALSE;
    }

    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvGrowTable: Allocated new table at %p\n", table );
    }

    //
    // Copy over the information from the old table.  Zero the remainder
    // of the table.
    //

    RtlCopyMemory(
        table,
        TableHeader->Table,
        oldNumberOfEntries * sizeof(TABLE_ENTRY)
        );

    RtlZeroMemory(
        (PCHAR)table + (oldNumberOfEntries * sizeof(TABLE_ENTRY)),
        (totalEntries - oldNumberOfEntries) * sizeof(TABLE_ENTRY)
        );

    //
    // Free the old table.
    //

    SrvFreeTable( TableHeader );

    //
    // Initialize the new table locations in the free list of the table.
    //

    table[totalEntries-1].NextFreeEntry = -1;

    for ( i = (USHORT)(totalEntries-2); i >= oldNumberOfEntries; i-- ) {
        table[i].NextFreeEntry = (SHORT)(i + 1);
    }

    //
    // Reinitialize the fields of the table header.  It is assumed that
    // the table did not previously have any free entries.
    //

    TableHeader->Table = table;
    TableHeader->TableSize = (USHORT)totalEntries;
    TableHeader->FirstFreeEntry = (SHORT)oldNumberOfEntries;
    TableHeader->LastFreeEntry = (SHORT)(totalEntries-1);

    if( ARGUMENT_PRESENT( pStatus ) )
    {
        *pStatus = STATUS_SUCCESS;
    }
    return TRUE;

} // SrvGrowTable


VOID
SrvRemoveEntryTable (
    IN PTABLE_HEADER TableHeader,
    IN USHORT Index
    )

/*++

Routine Description:

    This function removes an entry from a table.

    *** The lock controlling access to the table must be held when this
        function is called.

Arguments:

    Table - Address of table header.

    Index - Index within table of entry to remove.

Return Value:

    None.

--*/

{
    PTABLE_ENTRY entry;

    ASSERT( Index < TableHeader->TableSize );

    entry = &TableHeader->Table[Index];

    if ( TableHeader->LastFreeEntry >= 0 ) {

        //
        // Free list was not empty.
        //

        TableHeader->Table[TableHeader->LastFreeEntry].NextFreeEntry = Index;
        TableHeader->LastFreeEntry = Index;

    } else {

        //
        // Free list was empty.
        //

        TableHeader->FirstFreeEntry = Index;
        TableHeader->LastFreeEntry = Index;
    }

    entry->Owner = NULL;
    entry->NextFreeEntry = -1;

    return;

} // SrvRemoveEntryTable
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\blktree.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blktree.c

Abstract:

    This module implements routines for managing tree connect blocks.

Author:

    Chuck Lenzmeier (chuckl) 4-Oct-1989

Revision History:

--*/

#include "precomp.h"
#include "blktree.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKTREE

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateTreeConnect )
#pragma alloc_text( PAGE, SrvCheckAndReferenceTreeConnect )
#pragma alloc_text( PAGE, SrvCloseTreeConnect )
#pragma alloc_text( PAGE, SrvCloseTreeConnectsOnShare )
#pragma alloc_text( PAGE, SrvDereferenceTreeConnect )
#pragma alloc_text( PAGE, SrvFreeTreeConnect )
#endif


VOID
SrvAllocateTreeConnect (
    OUT PTREE_CONNECT *TreeConnect,
    IN PUNICODE_STRING ServerName OPTIONAL
    )

/*++

Routine Description:

    This function allocates a TreeConnect Block from the FSP heap.

Arguments:

    TreeConnect - Returns a pointer to the tree connect block, or NULL
        if no heap space was available.

    ServerName - the name of the server to which the client is connecting

Return Value:

    None.

--*/

{
    PNONPAGED_HEADER header;
    PTREE_CONNECT treeConnect;
    CLONG numberOfBytes; 

    PAGED_CODE( );

    //
    // Attempt to allocate from the heap.
    //

    numberOfBytes = sizeof( TREE_CONNECT );
    if( ARGUMENT_PRESENT( ServerName ) ) {
        numberOfBytes += ServerName->Length;
    }

    treeConnect = ALLOCATE_HEAP( numberOfBytes, BlockTypeTreeConnect );
    *TreeConnect = treeConnect;

    if ( treeConnect == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateTreeConnect: Unable to allocate %d bytes from heap",
            sizeof( TREE_CONNECT ),
            NULL
            );

        // An error will be logged by the caller.

        return;
    }
    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvAllocateTreeConnect: Allocated tree connect at %p\n",
                    treeConnect );
    }

    //
    // Allocate the nonpaged header.
    //

    header = ALLOCATE_NONPAGED_POOL(
                sizeof(NONPAGED_HEADER),
                BlockTypeNonpagedHeader
                );
    if ( header == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateTreeConnect: Unable to allocate %d bytes from pool.",
            sizeof( NONPAGED_HEADER ),
            NULL
            );
        FREE_HEAP( treeConnect );
        *TreeConnect = NULL;
        return;
    }

    header->Type = BlockTypeTreeConnect;
    header->PagedBlock = treeConnect;

    RtlZeroMemory( treeConnect, numberOfBytes );

    treeConnect->NonpagedHeader = header;

    SET_BLOCK_TYPE_STATE_SIZE( treeConnect, BlockTypeTreeConnect, BlockStateActive, sizeof( TREE_CONNECT) );
    header->ReferenceCount = 2; // allow for Active status and caller's pointer

    //
    // Set up the time at which the tree connect block was allocated.
    //
    KeQuerySystemTime( &treeConnect->StartTime );

    //
    // Save the ServerName, if supplied
    //
    if( ARGUMENT_PRESENT( ServerName ) ) {
        treeConnect->ServerName.Buffer = (PWCHAR)(treeConnect + 1);
        treeConnect->ServerName.MaximumLength = ServerName->Length;
        RtlCopyUnicodeString( &treeConnect->ServerName, ServerName );
    }

#if SRVDBG2
    treeConnect->BlockHeader.ReferenceCount = 2; // for INITIALIZE_REFERENCE_HISTORY
#endif
    INITIALIZE_REFERENCE_HISTORY( treeConnect );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TreeConnectInfo.Allocations );

    return;

} // SrvAllocateTreeConnect


BOOLEAN SRVFASTCALL
SrvCheckAndReferenceTreeConnect (
    PTREE_CONNECT TreeConnect
    )

/*++

Routine Description:

    This function atomically verifies that a tree connect is active and
    increments the reference count on the tree connect if it is.

Arguments:

    TreeConnect - Address of tree connect

Return Value:

    BOOLEAN - Returns TRUE if the tree connect is active, FALSE otherwise.

--*/

{
    PAGED_CODE( );

    //
    // Acquire the lock that guards the tree connect's state field.
    //

    ACQUIRE_LOCK( &TreeConnect->Connection->Lock );

    //
    // If the tree connect is active, reference it and return TRUE.
    //

    if ( GET_BLOCK_STATE(TreeConnect) == BlockStateActive ) {

        SrvReferenceTreeConnect( TreeConnect );

        RELEASE_LOCK( &TreeConnect->Connection->Lock );

        return TRUE;

    }

    //
    // The tree connect isn't active.  Return FALSE.
    //

    RELEASE_LOCK( &TreeConnect->Connection->Lock );

    return FALSE;

} // SrvCheckAndReferenceTreeConnect


VOID
SrvCloseTreeConnect (
    IN PTREE_CONNECT TreeConnect
    )

/*++

Routine Description:

    This routine does the core of a tree disconnect.  It sets the state
    of the tree connect to Closing, closes all files open on the tree
    connect, and dereferences the tree connect block.  The block will be
    destroyed as soon as all other references to it are eliminated.

Arguments:

    TreeConnect - Supplies a pointer to the tree connect block that is
        to be closed.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    ACQUIRE_LOCK( &TreeConnect->Connection->Lock );

    if ( GET_BLOCK_STATE(TreeConnect) == BlockStateActive ) {

        IF_DEBUG(BLOCK1) SrvPrint1( "Closing tree at %p\n", TreeConnect );

        SET_BLOCK_STATE( TreeConnect, BlockStateClosing );

        RELEASE_LOCK( &TreeConnect->Connection->Lock );
        //
        // Close any open files or pending transactions on this tree
        // connect.
        //

        SrvCloseRfcbsOnTree( TreeConnect );

        SrvCloseTransactionsOnTree( TreeConnect );

        //
        // Close any open DOS searches on this tree connect.
        //

        SrvCloseSearches(
            TreeConnect->Connection,
            (PSEARCH_FILTER_ROUTINE)SrvSearchOnTreeConnect,
            (PVOID)TreeConnect,
            NULL
            );

        //
        // Close any cached directories on this connection
        //
        SrvCloseCachedDirectoryEntries( TreeConnect->Connection );

        //
        // Dereference the tree connect (to indicate that it's no longer
        // open).
        //

        SrvDereferenceTreeConnect( TreeConnect );

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TreeConnectInfo.Closes );

    } else {

        RELEASE_LOCK( &TreeConnect->Connection->Lock );

    }

    return;

} // SrvCloseTreeConnect


VOID
SrvCloseTreeConnectsOnShare (
    IN PSHARE Share
    )

/*++

Routine Description:

    This function close all tree connects on a given share.

Arguments:

    Share - A pointer to the share block.

Return Value:

    None.

--*/

{
    PLIST_ENTRY treeConnectEntry, nextTreeConnectEntry;
    PTREE_CONNECT treeConnect;

    PAGED_CODE( );

    //
    // Acquire the lock that protects the share's tree connect list.
    //
    // *** Note that this routine can be called with this lock already
    //     held by SrvCloseShare from SrvNetShareDel.
    //

    ACQUIRE_LOCK( &SrvShareLock );

    //
    // Loop through the list of TreeConnects for the given share,
    // closing all of them.  The share block and the list are guaranteed
    // to remain valid because we hold the share lock.
    //

    treeConnectEntry = Share->TreeConnectList.Flink;

    while ( treeConnectEntry != &Share->TreeConnectList ) {

        //
        // Capture the address of the next tree connect now, because
        // we're about to close the current one, and we can look at it
        // after we've done that.
        //

        nextTreeConnectEntry = treeConnectEntry->Flink;

        //
        // Close the tree connect.  This will close all files open on
        // this tree connect, and will stop blocked activity on the tree
        // connect.  The tree connect itself will not be removed from
        // the share's TreeConnect list until its reference count
        // reaches zero.
        //

        treeConnect = CONTAINING_RECORD(
                          treeConnectEntry,
                          TREE_CONNECT,
                          ShareListEntry
                          );

        SrvCloseTreeConnect( treeConnect );

        //
        // Point to the next tree connect.
        //

        treeConnectEntry = nextTreeConnectEntry;

    }

    //
    // Release the share's tree connect list lock.
    //

    RELEASE_LOCK( &SrvShareLock );

} // SrvCloseTreeConnectsOnShare


VOID SRVFASTCALL
SrvDereferenceTreeConnect (
    IN PTREE_CONNECT TreeConnect
    )

/*++

Routine Description:

    This function decrements the reference count on a tree connect.  If
    the reference count goes to zero, the tree connect block is deleted.

    Since this routine may call SrvDereferenceConnection, the caller
    must be careful if he holds the connection lock that he also
    holds a referenced pointer to the connection.

Arguments:

    TreeConnect - Address of tree connect

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    LONG result;

    PAGED_CODE( );

    //
    // Enter a critical section and decrement the reference count on the
    // block.
    //

    connection = TreeConnect->Connection;

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Dereferencing tree connect %p; old refcnt %lx\n",
                    TreeConnect, TreeConnect->NonpagedHeader->ReferenceCount );
    }

    ASSERT( GET_BLOCK_TYPE( TreeConnect ) == BlockTypeTreeConnect );
    ASSERT( TreeConnect->NonpagedHeader->ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( TreeConnect, TRUE );

    result = InterlockedDecrement(
                &TreeConnect->NonpagedHeader->ReferenceCount
                );

    if ( result == 0 ) {

        //
        // The new reference count is 0, meaning that it's time to
        // delete this block.
        //
        // Free the tree connect entry in the tree table.  (Note that
        // the connection lock guards this table.)
        //

        ACQUIRE_LOCK( &connection->Lock );

        SrvRemoveEntryTable(
            &connection->PagedConnection->TreeConnectTable,
            TID_INDEX( TreeConnect->Tid )
            );

        if( TreeConnect->Session )
        {
            DEBUG TreeConnect->Session = NULL;

            RELEASE_LOCK( &connection->Lock );

            SrvDereferenceSession( TreeConnect->Session );
        }
        else
        {
            RELEASE_LOCK( &connection->Lock );
        }

        //
        // Remove the tree connect from the list of active tree connects
        // for the share.
        //

        SrvRemoveEntryOrderedList( &SrvTreeConnectList, TreeConnect );

        //
        // Take the tree connect off the list of tree connects for the
        // share and decrement the count of active uses of the share.
        //

        ACQUIRE_LOCK( &SrvShareLock );

        SrvRemoveEntryList(
            &TreeConnect->Share->TreeConnectList,
            &TreeConnect->ShareListEntry
            );

        RELEASE_LOCK( &SrvShareLock );

        //
        // Dereference the share and the connection.
        //

        SrvDereferenceShareForTreeConnect( TreeConnect->Share );
        DEBUG TreeConnect->Share = NULL;

        SrvDereferenceConnection( connection );
        DEBUG TreeConnect->Connection = NULL;       

        //
        // Free the tree connect block.
        //

        SrvFreeTreeConnect( TreeConnect );

    }

    return;

} // SrvDereferenceTreeConnect


VOID
SrvFreeTreeConnect (
    IN PTREE_CONNECT TreeConnect
    )

/*++

Routine Description:

    This function returns a TreeConnect Block to the FSP heap.

Arguments:

    TreeConnect - Address of tree connect

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( TreeConnect, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG TreeConnect->NonpagedHeader->ReferenceCount = -1;

    TERMINATE_REFERENCE_HISTORY( TreeConnect );

    DEALLOCATE_NONPAGED_POOL( TreeConnect->NonpagedHeader );
    FREE_HEAP( TreeConnect );
    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvFreeTreeConnect: Freed tree connect block at %p\n",
                    TreeConnect );
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TreeConnectInfo.Frees );

    return;

} // SrvFreeTreeConnect


VOID
SrvDisconnectTreeConnectsFromSession (
    PCONNECTION connection,
    PSESSION Session
    )

/*++

Routine Description:

    This routine removes the session association on all associated
    TreeConnects and dereferences the session, allowing the session
    to exit normally.  The caller MUST have the Connection Lock acquired.
    
Arguments:

    Connection - The connection we're walking           
    Session - Supplies a pointer to the session block for which
        transactions are to be closed.

Return Value:

    None.

--*/

{
    PTABLE_HEADER tableHeader;
    PLIST_ENTRY entry;
    USHORT i;

    PAGED_CODE( );

    SrvReferenceSession( Session );

    tableHeader = &connection->PagedConnection->SessionTable;

    for ( i = 0; i < tableHeader->TableSize; i++ ) {

        PTREE_CONNECT treeConnect =
                    (PTREE_CONNECT)tableHeader->Table[i].Owner;

        if ( treeConnect != NULL  ) {

            if( treeConnect->Session == Session )
            {
                SrvDereferenceSession( Session );
                treeConnect->Session = NULL;
            }
        }
    }

    SrvDereferenceSession( Session );

} // SrvDisconnectTreeConnectsFromSession
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\blkshare.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blkshare.c

Abstract:

    This module implements routines for managing share blocks.

Author:

    Chuck Lenzmeier (chuckl) 4-Oct-1989
    David Treadwell (davidtr)

Revision History:

--*/

#include "precomp.h"
#include "blkshare.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKSHARE

VOID
GetShareQueryNamePrefix (
    PSHARE Share
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateShare )
#pragma alloc_text( PAGE, SrvCloseShare )
#pragma alloc_text( PAGE, SrvDereferenceShare )
#pragma alloc_text( PAGE, SrvDereferenceShareForTreeConnect )
#pragma alloc_text( PAGE, SrvFreeShare )
#pragma alloc_text( PAGE, SrvReferenceShare )
#pragma alloc_text( PAGE, SrvReferenceShareForTreeConnect )
#pragma alloc_text( PAGE, SrvFillInFileSystemName )
#pragma alloc_text( PAGE, SrvGetShareRootHandle )
#pragma alloc_text( PAGE, SrvRefreshShareRootHandle )
#pragma alloc_text( PAGE, GetShareQueryNamePrefix )
#endif


VOID
SrvAllocateShare (
    OUT PSHARE *Share,
    IN PUNICODE_STRING ShareName,
    IN PUNICODE_STRING NtPathName,
    IN PUNICODE_STRING DosPathName,
    IN PUNICODE_STRING Remark,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSECURITY_DESCRIPTOR FileSecurityDescriptor OPTIONAL,
    IN SHARE_TYPE ShareType
    )

/*++

Routine Description:

    This function allocates a Share Block from the FSP heap.

Arguments:

    Share - Returns a pointer to the share block, or NULL if no
        heap space was available.

    ShareName - Supplies the name of the share.

    NtPathName - Supplies a fully qualified directory path in NT format
        to the share.

    DosPathName - Supplies a fully qualified directory path in DOS
        format to the share.

    Remark - a comment to store with the share.

    SecurityDescriptor - security descriptor used for determining whether
        a user can connect to this share.

    FileSecurityDescriptor - security descriptor used for determining the
        permissions of clients on files in this share.

    ShareType - Enumerated type indicating type of resource.

Return Value:

    None.

--*/

{
    CLONG blockSize;
    PSHARE share;
    ULONG securityDescriptorLength;
    ULONG fileSdLength;

    PAGED_CODE( );

    //
    // Attempt to allocate from the heap.  Note that space for the
    // remark (if any) is allocated separately.  Allocate extra space
    // for the security descriptor since it must be longword aligned,
    // and there may be padding between the DOS path name and the
    // security descriptor.
    //

    securityDescriptorLength = RtlLengthSecurityDescriptor( SecurityDescriptor );

    blockSize = sizeof(SHARE) +
                    ShareName->Length + sizeof(WCHAR) +
                    NtPathName->Length + sizeof(WCHAR) +
                    DosPathName->Length + sizeof(WCHAR) +
                    securityDescriptorLength + sizeof(ULONG);

    share = ALLOCATE_HEAP( blockSize, BlockTypeShare );
    *Share = share;

    if ( share == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateShare: Unable to allocate %d bytes from heap.",
             blockSize,
             NULL
             );
        return;
    }

    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvAllocateShare: Allocated share at %p\n", share );
    }

    RtlZeroMemory( share, blockSize );

    SET_BLOCK_TYPE_STATE_SIZE( share, BlockTypeShare, BlockStateActive, blockSize );
    share->BlockHeader.ReferenceCount = 2;      // allow for Active status
                                                //  and caller's pointer

    //
    // Save the share type.
    //

    share->ShareType = ShareType;

    //
    // Indicate that we've haven't determined the share's query name prefix yet.
    //

    share->QueryNamePrefixLength = -1;

    //
    // Put the share name after the share block.
    //

    share->ShareName.Buffer = (PWSTR)(share + 1);
    share->ShareName.Length = ShareName->Length;
    share->ShareName.MaximumLength =
                            (SHORT)(ShareName->Length + sizeof(WCHAR));

    RtlCopyMemory(
        share->ShareName.Buffer,
        ShareName->Buffer,
        ShareName->Length
        );

    //
    // Put the NT path name after share name.  If no NT path name was
    // specified, just set the path name string to NULL.
    //

   share->NtPathName.Buffer = (PWSTR)((PCHAR)share->ShareName.Buffer +
                                        share->ShareName.MaximumLength);

    share->NtPathName.Length = NtPathName->Length;
    share->NtPathName.MaximumLength = (SHORT)(NtPathName->Length +
                                                        sizeof(WCHAR));

    RtlCopyMemory(
        share->NtPathName.Buffer,
        NtPathName->Buffer,
        NtPathName->Length
        );


    //
    // Put the DOS path name after share name.  If no DOS path name was
    // specified, just set the path name string to NULL.
    //

    share->DosPathName.Buffer = (PWSTR)((PCHAR)share->NtPathName.Buffer +
                                        share->NtPathName.MaximumLength);
    share->DosPathName.Length = DosPathName->Length;
    share->DosPathName.MaximumLength = (SHORT)(DosPathName->Length +
                                                        sizeof(WCHAR));

    RtlCopyMemory(
        share->DosPathName.Buffer,
        DosPathName->Buffer,
        DosPathName->Length
        );

    //
    // Initialize the security RESOURCE for the share
    //
    share->SecurityDescriptorLock = ALLOCATE_NONPAGED_POOL( sizeof(ERESOURCE), BlockTypeShare );
    if( !share->SecurityDescriptorLock )
    {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateShare: Unable to allocate %d bytes from NP pool.",
             sizeof(ERESOURCE),
             NULL
             );
        SrvFreeShare( share );
        *Share = NULL;
        return;
    }
    INITIALIZE_LOCK( share->SecurityDescriptorLock, 1,  "Share Security Descriptor Lock" );

    share->SnapShotLock = ALLOCATE_NONPAGED_POOL( sizeof(SRV_LOCK), BlockTypeShare );
    if( !share->SnapShotLock )
    {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateShare: Unable to allocate %d bytes from NP pool.",
             sizeof(ERESOURCE),
             NULL
             );
        SrvFreeShare( share );
        *Share = NULL;
        return;
    }
    INITIALIZE_LOCK( share->SnapShotLock, 1,  "Share SnapShot Lock" );



    //
    // Allocate space for the remark and copy over the remark.  We
    // cannot put the remark after the share block because the remark is
    // settable by NetShareSetInfo.  It is possible for the storage
    // required for the remark to increase.
    //
    // If no remark was passed in, do not allocate space.  Just set up
    // a null string to describe it.
    //

    if ( ARGUMENT_PRESENT( Remark ) ) {

        share->Remark.Buffer = ALLOCATE_HEAP(
                                    Remark->Length + sizeof(*Remark->Buffer),
                                    BlockTypeShareRemark
                                    );

        if ( share->Remark.Buffer == NULL ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvAllocateShare: Unable to allocate %d bytes from heap.",
                 blockSize,
                 NULL
                 );
            SrvFreeShare( share );
            *Share = NULL;
            return;
        }

        share->Remark.Length = Remark->Length;
        share->Remark.MaximumLength =
                        (SHORT)(Remark->Length + sizeof(*Remark->Buffer));

        RtlCopyMemory(
            share->Remark.Buffer,
            Remark->Buffer,
            Remark->Length
            );

        *(PWCH)((PCHAR)share->Remark.Buffer + share->Remark.Length) = 0;

    } else {

        RtlInitUnicodeString( &share->Remark, NULL );

    }

    //
    // Set up the security descriptor for the share.  It must be longword-
    // aligned to be used in various calls.
    //

    share->SecurityDescriptor =
        (PSECURITY_DESCRIPTOR)( ((ULONG_PTR)share->DosPathName.Buffer +
                                share->DosPathName.MaximumLength + 3) & ~3);

    RtlCopyMemory(
        share->SecurityDescriptor,
        SecurityDescriptor,
        securityDescriptorLength
        );

    //
    // Set up the file security descriptor for the share.  We did not allocate
    // space for the file SD because this is settable and thus cannot have
    // preallocated space.
    //

    ASSERT( share->FileSecurityDescriptor == NULL );

    if ( ARGUMENT_PRESENT( FileSecurityDescriptor) ) {

        fileSdLength = RtlLengthSecurityDescriptor( FileSecurityDescriptor );

        share->FileSecurityDescriptor = ALLOCATE_HEAP(
                                                fileSdLength,
                                                BlockTypeShareSecurityDescriptor
                                                );

        if ( share->FileSecurityDescriptor == NULL ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvAllocateShare: Unable to allocate %d bytes from heap.",
                 fileSdLength,
                 NULL
                 );

            SrvFreeShare( share );
            *Share = NULL;
            return;
        }

        RtlCopyMemory(
            share->FileSecurityDescriptor,
            FileSecurityDescriptor,
            fileSdLength
            );
    }

    //
    // Indicate whether or not this share potentially contains the system directory.
    //
    if( DosPathName->Length != 0 && SrvSystemRoot.Length != 0 ) {

        UNICODE_STRING tmpString;

        if( DosPathName->Length == SrvSystemRoot.Length ) {
            //
            // If the two names are the same, then the share is exactly at the system
            //   directory.  All files within this share are system files!
            //
            if( RtlCompareUnicodeString( DosPathName, &SrvSystemRoot, TRUE ) == 0 ) {
                share->PotentialSystemFile = TRUE;
            }

        } else if( DosPathName->Length < SrvSystemRoot.Length ) {
            //
            // If the share path is a substring of the system root path...
            //
            if( DosPathName->Buffer[ DosPathName->Length/sizeof(WCHAR) - 1 ] ==
                  OBJ_NAME_PATH_SEPARATOR ||
                SrvSystemRoot.Buffer[ DosPathName->Length/sizeof(WCHAR) ] ==
                  OBJ_NAME_PATH_SEPARATOR ) {

                //
                // .. and if the share path is for the root of the drive...
                //
                tmpString = SrvSystemRoot;
                tmpString.Length = DosPathName->Length;
                //
                // ... and if the system root is on the same drive...
                //
                if( RtlCompareUnicodeString( DosPathName, &tmpString, TRUE ) == 0 ) {
                    //
                    // ... then we potentially are accessing system files
                    //
                    share->PotentialSystemFile = TRUE;
                }

            }

        } else {
            //
            // If the system root path is a substring of the share path, then every file
            //  within the share is a system file.
            //
            if( DosPathName->Buffer[ SrvSystemRoot.Length / sizeof( WCHAR ) ] ==
                OBJ_NAME_PATH_SEPARATOR ) {

                tmpString = *DosPathName;
                tmpString.Length = SrvSystemRoot.Length;

                if( RtlCompareUnicodeString( DosPathName, &tmpString, TRUE ) == 0 ) {
                    //
                    // Every file in the share is a system file
                    //
                    share->PotentialSystemFile = TRUE;
                }
            }
        }
    }

    //
    // Initialize the share's tree connect list.
    //

    InitializeListHead( &share->TreeConnectList );

    //
    // Initialize the SnapShot list
    //
    InitializeListHead( &share->SnapShots );

    share->ShareVolumeHandle = NULL;
    share->RelativePath.Length = share->RelativePath.MaximumLength = 0;
    share->RelativePath.Buffer = NULL;
    share->SnapShotEpic = -1;

    INITIALIZE_REFERENCE_HISTORY( share );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.ShareInfo.Allocations );

#ifdef SRVCATCH
    SrvIsMonitoredShare( share );
#endif

    return;

} // SrvAllocateShare


VOID
SrvCloseShare (
    IN PSHARE Share
    )

/*++

Routine Description:

    This function closes a share.

Arguments:

    Share - Supplies a pointer to a share Block

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    ACQUIRE_LOCK( &SrvShareLock );

    //
    // If the share hasn't already been closed, do so now.
    //

    if ( GET_BLOCK_STATE(Share) == BlockStateActive ) {

        IF_DEBUG(BLOCK1) SrvPrint1( "Closing share at %p\n", Share );

        SET_BLOCK_STATE( Share, BlockStateClosing );

        RELEASE_LOCK( &SrvShareLock );

        //
        // Close all the tree connects on this share.
        //

        SrvCloseTreeConnectsOnShare( Share );

        //
        // Dereference the share--this will cause it to be freed when
        // all other references are closed.
        //

        SrvDereferenceShare( Share );

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.ShareInfo.Closes );

    } else {

        RELEASE_LOCK( &SrvShareLock );

    }

    return;

} // SrvCloseShare


VOID
SrvDereferenceShare (
    IN PSHARE Share
    )

/*++

Routine Description:

    This function decrements the reference count on a share.  If the
    reference count goes to zero, the share block is deleted.

Arguments:

    Share - Address of share

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Enter a critical section and decrement the reference count on the
    // block.
    //

    ACQUIRE_LOCK( &SrvShareLock );

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Dereferencing share %p; old refcnt %lx\n",
                    Share, Share->BlockHeader.ReferenceCount );
    }

    ASSERT( GET_BLOCK_TYPE(Share) == BlockTypeShare );
    ASSERT( (LONG)Share->BlockHeader.ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( Share, TRUE );

    if ( --Share->BlockHeader.ReferenceCount == 0 ) {

        //
        // The new reference count is 0, meaning that it's time to
        // delete this block.
        //

        ASSERT( Share->CurrentUses == 0 );
        ASSERT( GET_BLOCK_STATE( Share ) != BlockStateActive );

        RELEASE_LOCK( &SrvShareLock );

        //
        // Remove the block from the global list.
        //

        SrvRemoveShare( Share );

        //
        // Free the share block.
        //

        SrvFreeShare( Share );

    } else {

        RELEASE_LOCK( &SrvShareLock );

    }

    return;

} // SrvDereferenceShare


VOID
SrvDereferenceShareForTreeConnect (
    PSHARE Share
    )

/*++

Routine Description:

    This function decrements the reference count on a share block for
    the referenced pointer in a tree connect block.  If this is the last
    reference by a tree connect to the share, the share root directory
    is closed.

Arguments:

    Share - Address of share

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    ACQUIRE_LOCK( &SrvShareLock );

    //
    // Update the count of tree connects on the share.
    //

    ASSERT( Share->CurrentUses > 0 );

    Share->CurrentUses--;

    //
    // If this is the last reference by a tree connect to the share and
    // this is a disk share, close the share root directory handle.
    //

    if ( Share->CurrentUses == 0 && Share->ShareType == ShareTypeDisk ) {
        if ( !Share->Removable ) {
            SRVDBG_RELEASE_HANDLE( Share->RootDirectoryHandle, "RTD", 5, Share );
            SrvNtClose( Share->RootDirectoryHandle, FALSE );
        }
        Share->RootDirectoryHandle = NULL;
    }

    //
    // Dereference the share and return.
    //

    SrvDereferenceShare( Share );

    RELEASE_LOCK( &SrvShareLock );

    return;

} // SrvDereferenceShareForTreeConnect

VOID
SrvFreeShare (
    IN PSHARE Share
    )

/*++

Routine Description:

    This function returns a Share Block to the FSP heap.

Arguments:

    Share - Address of share

Return Value:

    None.

--*/

{
    PLIST_ENTRY shareList;

    PAGED_CODE( );

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( Share, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG Share->BlockHeader.ReferenceCount = (ULONG)-1;
    TERMINATE_REFERENCE_HISTORY( Share );

    // Delete all the SnapShot shares
    shareList = Share->SnapShots.Flink;
    while( shareList != &Share->SnapShots )
    {
        PSHARE_SNAPSHOT snapShare = CONTAINING_RECORD( shareList, SHARE_SNAPSHOT, SnapShotList );
        shareList = shareList->Flink;
        SrvSnapRemoveShare( snapShare );
    }

    if( Share->ShareVolumeHandle != NULL )
    {
        NtClose( Share->ShareVolumeHandle );
        Share->ShareVolumeHandle = NULL;
    }

    //
    // Remove storage for the remark, if any.
    //

    if ( Share->Remark.Buffer != NULL ) {
        FREE_HEAP( Share->Remark.Buffer );
    }

    //
    // Remove storage for the file security descriptor, if any.
    //

    if ( Share->FileSecurityDescriptor != NULL ) {
        FREE_HEAP( Share->FileSecurityDescriptor );
    }

    //
    // Cleanup the file security descriptor lock
    //
    if( Share->SecurityDescriptorLock )
    {
        DELETE_LOCK( Share->SecurityDescriptorLock );
        DEALLOCATE_NONPAGED_POOL( Share->SecurityDescriptorLock );
    }

    //
    // Cleanup the SnapShot lock
    //
    if( Share->SnapShotLock )
    {
        DELETE_LOCK( Share->SnapShotLock );
        DEALLOCATE_NONPAGED_POOL( Share->SnapShotLock );
    }

    //
    // Remove storage for the filesystem name
    //

    if ( Share->Type.FileSystem.Name.Buffer != NULL ) {
        FREE_HEAP( Share->Type.FileSystem.Name.Buffer );
    }

    FREE_HEAP( Share );
    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvFreeShare: Freed share block at %p\n", Share );
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.ShareInfo.Frees );

    return;

} // SrvFreeShare


VOID
SrvReferenceShare (
    PSHARE Share
    )

/*++

Routine Description:

    This function increments the reference count on a share block.

Arguments:

    Share - Address of share

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Enter a critical section and increment the reference count on the
    // share.
    //

    ACQUIRE_LOCK( &SrvShareLock );

    ASSERT( (LONG)Share->BlockHeader.ReferenceCount > 0 );
    ASSERT( GET_BLOCK_TYPE(Share) == BlockTypeShare );
    // ASSERT( GET_BLOCK_STATE(Share) == BlockStateActive );
    UPDATE_REFERENCE_HISTORY( Share, FALSE );

    Share->BlockHeader.ReferenceCount++;

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Referencing share %p; new refcnt %lx\n",
                    Share, Share->BlockHeader.ReferenceCount );
    }

    RELEASE_LOCK( &SrvShareLock );

    return;

} // SrvReferenceShare


NTSTATUS
SrvReferenceShareForTreeConnect (
    PSHARE Share
    )

/*++

Routine Description:

    This function increments the reference count on a share block for
    the referenced pointer in a tree connect block.  If this is the
    first tree connect to reference the share, the share root directory
    is opened.

Arguments:

    Share - Address of share

Return Value:

    None.

--*/

{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    PFILE_FS_ATTRIBUTE_INFORMATION attributeInfo;
    CHAR buffer[ FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) + 32 ];
    PVOID allocatedBuffer = NULL;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE( );

    ACQUIRE_LOCK( &SrvShareLock );

    //
    // Update the count of tree connects on the share.
    //

    Share->CurrentUses++;

    //
    // Check if this is the first tree connect to the share.
    //

    if ( Share->CurrentUses > 1 ) {

        //
        // There are already open tree connects on the share.  Just
        // reference the share and return.
        //

        SrvReferenceShare( Share );

        goto done;
    }

    //
    // If this is not a disk share, then we do not need to open the
    // share root directory, so reference the share and return.
    //

    if ( Share->ShareType != ShareTypeDisk || Share->Removable ) {
        SrvReferenceShare( Share );
        goto done;
    }

    //
    // This is the first tree connect, so we need to open the share root
    // directory.  Future opens of files within the share will be relative
    // to the root of the share.
    //
    Share->RootDirectoryHandle = NULL;

    if( SrvRefreshShareRootHandle( Share, &status ) == FALSE ) {
        Share->CurrentUses--;
        RELEASE_LOCK( &SrvShareLock );
        return status;
    }

    //
    // All is well -- we are now going to return STATUS_SUCCESS no matter what!
    //

    SrvReferenceShare( Share );

    if ( Share->QueryNamePrefixLength == -1 ) {

        //
        // Query the name associated with the share root directory.
        // The prefix is removed whenever the name of a file in the
        // share is queried.  (The logical root must be preserved
        // for remote clients.)
        //

        GetShareQueryNamePrefix( Share );
    }

    //
    // Now extract the name of the file system, so that it can be returned
    // in the TreeConnectAndX response.
    //
    //
    if ( Share->Type.FileSystem.Name.Buffer == NULL ) {

        attributeInfo = (PFILE_FS_ATTRIBUTE_INFORMATION)buffer;

        status = NtQueryVolumeInformationFile(
                     Share->RootDirectoryHandle,
                     &iosb,
                     attributeInfo,
                     sizeof( buffer ),
                     FileFsAttributeInformation
                     );

        if ( status == STATUS_BUFFER_OVERFLOW ) {

            //
            // The file system information was too large to fit in our small
            // stack buffer.  Allocate an ample buffer and try again.
            //

            allocatedBuffer = ALLOCATE_HEAP(
                                 FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION,FileSystemName) +
                                     attributeInfo->FileSystemNameLength,
                                 BlockTypeVolumeInformation
                                 );

            if ( allocatedBuffer == NULL ) {

                //
                // Couldn't allocate the buffer.  Give up.
                //

                goto done;
            }

            status = NtQueryVolumeInformationFile(
                         Share->RootDirectoryHandle,
                         &iosb,
                         allocatedBuffer,
                         FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName) +
                                     attributeInfo->FileSystemNameLength,
                         FileFsAttributeInformation
                         );

            if ( !NT_SUCCESS( status ) ) {
                goto done;
            }

            attributeInfo = (PFILE_FS_ATTRIBUTE_INFORMATION)allocatedBuffer;

        } else if ( !NT_SUCCESS( status ) ) {

            //
            // Some other, unexpected error occured.  Give up.
            //

            goto done;
        }

        //
        // Fill in the file system name
        //

        SrvFillInFileSystemName(
                            Share,
                            attributeInfo->FileSystemName,
                            attributeInfo->FileSystemNameLength
                            );
    }

done:

    if ( allocatedBuffer != NULL ) {
        FREE_HEAP( allocatedBuffer );
    }

    RELEASE_LOCK( &SrvShareLock );
    return STATUS_SUCCESS;

} // SrvReferenceShareForTreeConnect


VOID
SrvFillInFileSystemName (
            IN PSHARE Share,
            IN PWSTR FileSystemName,
            IN ULONG FileSystemNameLength
            )

/*++

Routine Description:

    This function fills in the stores the given file system name into the
    share block.

Arguments:

    Share - Address of share

    FileSystemName - A string containing the name of the file system

    FileSystemNameLength - Length of the above string

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // If we have a FATxx filesystem, we need to return FAT back to the clients,
    //  else they will not believe they can create long names.  I know, I know....
    //
    if( (FileSystemNameLength > 3 * sizeof( WCHAR ) ) &&
        (FileSystemName[0] == L'F' || FileSystemName[0] == L'f') &&
        (FileSystemName[1] == L'A' || FileSystemName[0] == L'a') &&
        (FileSystemName[2] == L'T' || FileSystemName[0] == L't') ) {

        FileSystemNameLength = 3 * sizeof( WCHAR );
        FileSystemName[3] = UNICODE_NULL;
    }

    //
    // Allocate enough storage for the ANSI and Unicode representations.
    //

    Share->Type.FileSystem.Name.Length = (USHORT)FileSystemNameLength;
    Share->Type.FileSystem.Name.MaximumLength =
            (USHORT)(FileSystemNameLength + sizeof( UNICODE_NULL ));

    Share->Type.FileSystem.Name.Buffer = FileSystemName;
    Share->Type.FileSystem.OemName.MaximumLength =
        (USHORT)RtlUnicodeStringToOemSize( &Share->Type.FileSystem.Name );

    Share->Type.FileSystem.Name.Buffer =
        ALLOCATE_HEAP(
            Share->Type.FileSystem.Name.MaximumLength +
                            Share->Type.FileSystem.OemName.MaximumLength,
            BlockTypeFSName
            );

    if ( Share->Type.FileSystem.Name.Buffer == NULL) {
        return;
    }


    RtlCopyMemory(
        Share->Type.FileSystem.Name.Buffer,
        FileSystemName,
        FileSystemNameLength
        );

    //
    // Generate the OEM version of the string to return to non-unicode
    // clients.
    //

    Share->Type.FileSystem.OemName.Buffer =
        (PCHAR)Share->Type.FileSystem.Name.Buffer +
             Share->Type.FileSystem.Name.MaximumLength;

    RtlUnicodeStringToOemString(
        &Share->Type.FileSystem.OemName,
        &Share->Type.FileSystem.Name,
        FALSE
        );

    //
    // Append a NUL character to the strings.
    //

    {
        PCHAR endOfBuffer;

        endOfBuffer = (PCHAR)Share->Type.FileSystem.Name.Buffer +
                            Share->Type.FileSystem.Name.Length;

        *(PWCH)endOfBuffer = UNICODE_NULL;

        Share->Type.FileSystem.Name.Length += sizeof( UNICODE_NULL );
    }

    Share->Type.FileSystem.OemName.Length++;

    return;

} // SrvFillInFileSystemName


NTSTATUS
SrvGetShareRootHandle (
    IN PSHARE Share
    )
/*++

Routine Description:

    This routine returns the root handle for a given share.  If the
    root has been opened, return the existing handle.  If not, open
    the share root directory and return the handle obtained.

Arguments:

    Share - The share for which the root directory handle is to be returned.

Return Value:

    Status of request.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE( );

    if ( Share->ShareType != ShareTypeDisk ) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if ( Share->Removable ) {

        ACQUIRE_LOCK( &SrvShareLock );

        ++Share->CurrentRootHandleReferences;

        //
        // This is the first open
        //

        if ( Share->CurrentRootHandleReferences == 1 ) {

            ASSERT( Share->RootDirectoryHandle == NULL );

            //
            // Make sure we have a good handle to the media
            //
            SrvRefreshShareRootHandle( Share, &status );

            if( NT_SUCCESS( status ) ) {

                SrvReferenceShare( Share );

                if ( Share->QueryNamePrefixLength == -1 ) {

                    //
                    // Query the name associated with the share root directory.
                    // The prefix is removed whenever the name of a file in the
                    // share is queried.  (The logical root must be preserved
                    // for remote clients.)
                    //

                    GetShareQueryNamePrefix( Share );
                }

            } else {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvGetShareRootHandle: NtOpenFile failed %x.\n",
                                status ));
                }

                Share->CurrentRootHandleReferences--;
            }

        }

        RELEASE_LOCK( &SrvShareLock );
    }

    return status;

} // SrvGetShareRootHandle

BOOLEAN
SrvRefreshShareRootHandle (
    IN PSHARE Share,
    OUT PNTSTATUS Status
)
/*++

Routine Description:

    This routine tries to obtain a fresh share root handle, replacing the
    one that was there.  The handle will need to be refreshed if, for instance,
    the volume has been dismounted and remounted.

Arguments:

    Share - The share for which the root directory handle is to be refreshed.

Returns:
    TRUE - if a new handle was generated
    FALSE - if a new handle was not generated

--*/
{
    HANDLE h;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    *Status = STATUS_SUCCESS;

    if( Share->ShareType != ShareTypeDisk ) {
        return FALSE;
    }

    //
    // Open the root directory of the share.  Future opens of files within
    // the share will be relative to the root of the share.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &Share->NtPathName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    *Status = NtOpenFile(
                &h,
                FILE_TRAVERSE,
                &objectAttributes,
                &iosb,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE
                );

    if( !NT_SUCCESS( *Status ) ) {
        return FALSE;
    }

    //
    // Check the irp stack size needed to access this share.
    // If it is bigger than what we have allocated, fail
    // this share.
    //

    *Status = SrvVerifyDeviceStackSize(
                h,
                FALSE,
                &fileObject,
                &deviceObject,
                NULL
                );

    if ( !NT_SUCCESS( *Status )) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvReferenceShareForTreeConnect: Verify Device Stack Size failed: %X\n",
            *Status,
            NULL
            );

        NtClose( h );
        return FALSE;
    }

    //
    // This handle looks suitable for use.  Set it to be the handle
    // for this share
    //
    h = (PRFCB)InterlockedExchangePointer( &Share->RootDirectoryHandle, h );

    //
    // If we have picked up a different handle, we need to close it
    //
    if( h != 0 ) {
        NtClose( h );
    }

    return TRUE;
}


VOID
GetShareQueryNamePrefix (
    IN PSHARE Share
    )
/*++

Routine Description:

    This routine queries the name associated with the share root
    directory.  The prefix is removed whenever the name of a file in the
    share is queried.  (The logical root must be preserved for remote
    clients.) For example, if the root of the share X is c:\shares\x,
    then for a query of \\server\x\y, the file system will return
    \shares\x\y, and we need to remove \shares\x and return just \y.

    It is not sufficient to just remove the local path (e.g.,
    \shares\x), because the file system may have a different idea of the
    name of the root directory.  For example, the Netware client
    redirector prefixes the name with volume information from the
    Netware server.  So we have to query the filesystem's idea of the
    name of the root to know what to strip off.

Arguments:

    Share - The share for which the query name prefix length is desired.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    IO_STATUS_BLOCK iosb;
    ULONG localBuffer[ (FIELD_OFFSET(FILE_NAME_INFORMATION,FileName) + 20) / sizeof( ULONG ) ];
    PFILE_NAME_INFORMATION nameInfo;
    ULONG nameInfoLength;

    PAGED_CODE( );

    //
    // Do a short query to get the length of the name.  This query will
    // fail with STATUS_BUFFER_OVERFLOW unless the path to the share
    // root is short (10 characters or less).
    //

    nameInfo = (PFILE_NAME_INFORMATION)localBuffer;
    nameInfoLength = sizeof(localBuffer);

    status = NtQueryInformationFile(
                 Share->RootDirectoryHandle,
                 &iosb,
                 nameInfo,
                 nameInfoLength,
                 FileNameInformation
                 );

    if ( status == STATUS_BUFFER_OVERFLOW ) {

        //
        // We got an expected buffer overflow error.  Allocate a buffer
        // to hold the entire file name and redo the query.
        //

        nameInfoLength = sizeof(FILE_NAME_INFORMATION) + nameInfo->FileNameLength;
        nameInfo = ALLOCATE_HEAP( nameInfoLength, BlockTypeNameInfo );

        if ( nameInfo == NULL ) {
            status = STATUS_INSUFF_SERVER_RESOURCES;
        } else {
            status = NtQueryInformationFile(
                         Share->RootDirectoryHandle,
                         &iosb,
                         nameInfo,
                         nameInfoLength,
                         FileNameInformation
                         );
        }

    }

    if ( NT_SUCCESS(status) ) {

        //
        // We have the name.  The length of this name is the length we
        // want to strip from each query, unless the last character of
        // the name is \, in which case we need to strip up to, but not
        // including, the \.
        //

        Share->QueryNamePrefixLength = nameInfo->FileNameLength;
        if ( nameInfo->FileName[nameInfo->FileNameLength/sizeof(WCHAR) - 1] == L'\\') {
            Share->QueryNamePrefixLength -= sizeof(WCHAR);
        }

    } else {

        //
        // An unexpected error occurred.  Just set the prefix length to 0.
        //

        Share->QueryNamePrefixLength = 0;

    }

    //
    // If we allocated a temporary buffer, free it now.
    //

    if ( (nameInfo != NULL) && (nameInfo != (PFILE_NAME_INFORMATION)localBuffer) ) {
        FREE_HEAP( nameInfo );
    }

    return;

} // GetShareQueryNamePrefix
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\blktrans.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    blktrans.c

Abstract:

    This module implements routines for managing transaction blocks.

Author:

    Chuck Lenzmeier (chuckl) 23-Feb-1990

Revision History:

--*/

#include "precomp.h"
#include "blktrans.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKTRANS

//
// If a transaction block has no space for extra data, and its name is
// the null string, it is eligible to be cached when it is free.  This
// means that instead of freeing the transaction block, a pointer to the
// block is stored in the connection block.
//
// An eligible transaction will be four bytes longer than the base
// transaction block size.  This allows for a Unicode string terminator
// padded to a longword.
//

#define CACHED_TRANSACTION_BLOCK_SIZE sizeof(TRANSACTION) + 4

//
// We allow up to four transactions to be cached.
//
// !!! This should be a configuration parameter.
//

#define CACHED_TRANSACTION_LIMIT 4

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvCloseTransaction )
#pragma alloc_text( PAGE, SrvCloseTransactionsOnSession )
#pragma alloc_text( PAGE, SrvCloseTransactionsOnTree )
#pragma alloc_text( PAGE, SrvDereferenceTransaction )
#pragma alloc_text( PAGE, SrvAllocateTransaction )
#pragma alloc_text( PAGE, SrvFreeTransaction )
#endif
#if 0
#endif


VOID
SrvAllocateTransaction (
    OUT PTRANSACTION *Transaction,
    OUT PVOID *TrailingBytes,
    IN PCONNECTION Connection,
    IN CLONG TrailingByteCount,
    IN PVOID TransactionName,
    IN PVOID EndOfSourceBuffer OPTIONAL,
    IN BOOLEAN SourceIsUnicode,
    IN BOOLEAN RemoteApiRequest
    )

/*++

Routine Description:

    This function allocates a Transaction block from the FSP heap.

Arguments:

    Transaction - Returns a pointer to the transaction block, or NULL if
        no heap space was available.

    TrailingBytes - Returns a pointer to the trailing bytes allocated at
        the end of the transaction block.  Invalid if *Transaction is
        NULL.

    TrailingByteCount - Supplies the count of bytes (not including the
        transaction name) to be allocated at the tail end of the
        transaction block.

    TransactionName - Supplies a pointer to the null-terminated
        transaction name string.  Is SourceIsUnicode is TRUE, this must
        be an aligned pointer.

    EndOfSourceBuffer - A pointer to the end of the SMB buffer.  Used to
        protect the server from accessing beyond the end of the SMB buffer,
        if the format is invalid.  If NULL, indicates that checking is not
        necessary.

    SourceIsUnicode - Indicates whether the TransactionName buffer contains
        Unicode characters.

    RemoteApiRequest - TRUE if this is a remote API request and should
        hence be allocated from the shared memory that XACTSRV can see.

Return Value:

    None.

--*/

{
    USHORT nameLength;
    CLONG extraLength;
    CLONG blockSize;
    PSLIST_ENTRY listEntry;
    PNONPAGED_HEADER header;
    PTRANSACTION transaction;

    PAGED_CODE();

    //
    // Get the length of the name (in bytes) including the null terminator.
    //

    if ( EndOfSourceBuffer == NULL ) {

        //
        // No checking is required
        //

        if ( SourceIsUnicode ) {
            nameLength = (USHORT)(wcslen( (PWCH)TransactionName ) + 1);
        } else {
            nameLength = (USHORT)(strlen( (PCHAR)TransactionName ) + 1);
        }
        nameLength *= sizeof(WCHAR);

    } else {

        nameLength = SrvGetStringLength(
                             TransactionName,
                             EndOfSourceBuffer,
                             SourceIsUnicode,
                             TRUE               // include null terminator
                             );

        if ( nameLength == (USHORT)-1 ) {

            //
            // If the name is messed up, assume L'\0'
            //

            nameLength = sizeof(WCHAR);

        } else if ( !SourceIsUnicode ) {

            nameLength *= sizeof(WCHAR);
        }
    }

    extraLength = ((nameLength + 3) & ~3) + TrailingByteCount;
    blockSize = sizeof(TRANSACTION) + extraLength;

    //
    // Attempt to allocate from the heap.  Make sure they aren't asking for
    //  too much memory
    //

    if( TrailingByteCount > MAX_TRANSACTION_TAIL_SIZE ) {

        transaction = NULL;

    } else if ( !RemoteApiRequest ) {

        //
        // If the extra length required allows us to use a cached
        // transaction block, try to get one of those first.
        //

        if ( blockSize == CACHED_TRANSACTION_BLOCK_SIZE ) {

            listEntry = ExInterlockedPopEntrySList( &Connection->CachedTransactionList, &Connection->SpinLock );

            if ( listEntry != NULL ) {

                ASSERT( Connection->CachedTransactionCount > 0 );
                InterlockedDecrement( &Connection->CachedTransactionCount );

                header = CONTAINING_RECORD(
                            listEntry,
                            NONPAGED_HEADER,
                            ListEntry
                            );
                transaction = header->PagedBlock;

                IF_DEBUG(HEAP) {
                    SrvPrint1( "SrvAllocateTransaction: Found cached transaction block at %p\n", transaction );
                }

                *Transaction = transaction;
                goto got_cached_transaction;

            }
        }

        transaction = ALLOCATE_HEAP( blockSize, BlockTypeTransaction );

    } else {

        NTSTATUS status;    // ignore this
        transaction = SrvXsAllocateHeap( blockSize, &status );

    }

    *Transaction = transaction;

    if ( transaction == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateTransaction: Unable to allocate %d bytes from heap.",
            blockSize,
            NULL
            );

        // An error will be logged by the caller

        return;
    }
    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvAllocateTransaction: Allocated transaction block at %p\n", transaction );
    }

    //
    // Allocate the nonpaged header.
    //

    header = ALLOCATE_NONPAGED_POOL(
                sizeof(NONPAGED_HEADER),
                BlockTypeNonpagedHeader
                );
    if ( header == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateTransaction: Unable to allocate %d bytes from pool.",
            sizeof( NONPAGED_HEADER ),
            NULL
            );
        if ( !RemoteApiRequest ) {
            FREE_HEAP( transaction );
        } else {
            SrvXsFreeHeap( transaction );
        }
        *Transaction = NULL;
        return;
    }

    header->Type = BlockTypeTransaction;
    header->PagedBlock = transaction;

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TransactionInfo.Allocations );

#if SRVDBG2
    transaction->BlockHeader.ReferenceCount = 2; // for INITIALIZE_REFERENCE_HISTORY
#endif
    INITIALIZE_REFERENCE_HISTORY( transaction );

got_cached_transaction:

    RtlZeroMemory( transaction, sizeof(TRANSACTION) );

    transaction->NonpagedHeader = header;

    SET_BLOCK_TYPE_STATE_SIZE( transaction, BlockTypeTransaction, BlockStateActive, blockSize );
    header->ReferenceCount = 2; // allow for Active status and caller's pointer

    transaction->RemoteApiRequest = RemoteApiRequest;

    //
    // Put transaction name after main part of transaction block.
    //

    transaction->TransactionName.Buffer = (PWCH)( transaction + 1 );
    transaction->TransactionName.MaximumLength = (USHORT)nameLength;
    transaction->TransactionName.Length = (USHORT)(nameLength - sizeof(WCHAR));

    if ( nameLength == sizeof(WCHAR) ) {

        transaction->TransactionName.Buffer = L'\0';

    } else {

        if ( SourceIsUnicode ) {

            RtlCopyMemory(
                (PVOID)transaction->TransactionName.Buffer,
                TransactionName,
                nameLength
                );

        } else {

            ANSI_STRING ansiName;

            ansiName.Buffer = (PCHAR)TransactionName;
            ansiName.Length = (nameLength / sizeof(WCHAR)) - 1;

            RtlOemStringToUnicodeString(
                &transaction->TransactionName,
                &ansiName,
                FALSE
                );

        }

    }

    //
    // Set address of trailing bytes.
    //

    *TrailingBytes = (PCHAR)transaction + sizeof(TRANSACTION) +
                        ((nameLength + 3) & ~3);

    return;

} // SrvAllocateTransaction


VOID
SrvCloseTransaction (
    IN PTRANSACTION Transaction
    )

/*++

Routine Description:

    This routine closes a pending transaction.  It sets the state of the
    transaction to Closing and dereferences the transaction block.  The
    block will be destroyed as soon as all other references to it are
    eliminated.

Arguments:

    Transaction - Supplies a pointer to the transaction block that is
        to be closed.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    ACQUIRE_LOCK( &Transaction->Connection->Lock );

    if ( GET_BLOCK_STATE(Transaction) == BlockStateActive ) {

        IF_DEBUG(BLOCK1) {
            SrvPrint1( "Closing transaction at %p\n", Transaction );
        }

        SET_BLOCK_STATE( Transaction, BlockStateClosing );

        RELEASE_LOCK( &Transaction->Connection->Lock );

        //
        // If the transaction request indicated that the tree connect
        // should be closed on completion, do so now.
        //

        if ( Transaction->Flags & SMB_TRANSACTION_DISCONNECT ) {
            SrvCloseTreeConnect( Transaction->TreeConnect );
        }

        //
        // Dereference the transaction (to indicate that it's no longer
        // open).
        //

        SrvDereferenceTransaction( Transaction );

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TransactionInfo.Closes );

    } else {

        RELEASE_LOCK( &Transaction->Connection->Lock );

    }

    return;

} // SrvCloseTransaction


VOID
SrvCloseTransactionsOnSession (
    PSESSION Session
    )

/*++

Routine Description:

    This routine closes all pending transactions that are "owned" by the
    specified session.  It walks the transaction list of the connection
    that owns the session.  Each transaction in that list that is owned
    by the session is closed.

Arguments:

    Session - Supplies a pointer to the session block for which
        transactions are to be closed.

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    PPAGED_CONNECTION pagedConnection;
    PLIST_ENTRY entry;
    PTRANSACTION previousTransaction;
    PTRANSACTION transaction = NULL;

    PAGED_CODE( );

    //
    // Get the address of the owning connection.
    //

    connection = Session->Connection;
    pagedConnection = connection->PagedConnection;

    //
    // Walk the transaction list, looking for transactions owned by the
    // specified session.
    //
    // *** This routine is complicated by the following requirements:
    //
    //      1) We must hold the transaction lock while looking at the
    //         list, and we must ensure the integrity of the list as
    //         we walk it.
    //
    //      2) The transaction lock must NOT be held when closing or
    //         dereferencing a transaction, because its lock level is
    //         higher than that of other locks that may need to be
    //         taken out as a result of the close or dereference.
    //
    //     We work around these problems in the following way:
    //
    //      1) We hold the transaction lock while we search for a
    //         transaction to close.
    //
    //      2) We reference the transaction we're about to close, then
    //         release the lock.  This prevents someone else from
    //         invalidating the transaction after we release the lock
    //         but before we close it ourselves.
    //
    //      3) We close the transaction.  Our extra reference to the
    //         transaction prevents it from being deleted.  This also
    //         keeps it on the transaction list.
    //
    //      4) We retake the lock, find another transaction (using the
    //         previous transaction as a starting point), reference it,
    //         then release the lock.
    //
    //      5) We dereference the original transaction and go to step 3.
    //
    // Note that the loop below is NOT structured in exactly the same
    // way as the steps above are listed.
    //

    entry = &pagedConnection->TransactionList;
    previousTransaction = NULL;

    while ( TRUE ) {

        ACQUIRE_LOCK( &connection->Lock );

        //
        // Find a transaction that is owned by the specified session.
        //

        while ( TRUE ) {

            //
            // Get the address of the next list entry.  If we hit the
            // end of the list, exit the inner loop.
            //

            entry = entry->Flink;
            if ( entry == &pagedConnection->TransactionList ) goto main_loop_exit;

            //
            // Get the address of the transaction.  If it's owned by
            // the specified session and currently active, exit the
            // inner loop.  If it is closing don't touch it.
            //

            transaction = CONTAINING_RECORD(
                            entry,
                            TRANSACTION,
                            ConnectionListEntry
                            );

            if ( transaction->Session == Session &&
                 GET_BLOCK_STATE(transaction) == BlockStateActive) {

                 break;
            }

        }

        //
        // Reference the transaction to ensure that it isn't deleted
        // when we close it.
        //

        SrvReferenceTransaction( transaction );

        //
        // Unlock the transaction list, so that we can dereference the
        // previous transaction and close the current one.
        //

        RELEASE_LOCK( &connection->Lock );

        //
        // If this is not the first matching transaction that we've
        // found, dereference the previous one now.
        //

        if ( previousTransaction != NULL ) {
            SrvDereferenceTransaction( previousTransaction );
        }

        //
        // Close the current transaction and mark that we need to
        // dereference it.
        //

        SrvCloseTransaction( transaction );

        previousTransaction = transaction;

        //
        // Go find another matching transaction.
        //

    } // while ( TRUE )

main_loop_exit:

    //
    // We have hit the end of the transaction list.  Release the
    // transaction lock.  If we have a transaction that needs to be
    // dereferenced, do so.  Then return to the caller.
    //

    RELEASE_LOCK( &connection->Lock );

    if ( previousTransaction != NULL ) {
        SrvDereferenceTransaction( previousTransaction );
    }

    return;

} // SrvCloseTransactionsOnSession


VOID
SrvCloseTransactionsOnTree (
    IN PTREE_CONNECT TreeConnect
    )

/*++

Routine Description:

    This routine closes all pending transactions that are "owned" by the
    specified tree connect.  It walks the transaction list of the
    connection that owns the tree connect.  Each transaction in that
    list that is owned by the tree connect is closed.

Arguments:

    TreeConnect - Supplies a pointer to the tree connect block for which
        transactions are to be closed.

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    PPAGED_CONNECTION pagedConnection;
    PLIST_ENTRY entry;
    PTRANSACTION previousTransaction;
    PTRANSACTION transaction = NULL;

    PAGED_CODE( );

    //
    // Get the address of the owning connection.
    //

    connection = TreeConnect->Connection;
    pagedConnection = connection->PagedConnection;

    //
    // Walk the transaction list, looking for transactions owned by the
    // specified tree connect.
    //
    // *** See the description of SrvCloseTransactionsOnSession, which
    //     explains why this loop is so complicated.
    //

    entry = &pagedConnection->TransactionList;
    previousTransaction = NULL;

    while ( TRUE ) {

        ACQUIRE_LOCK( &connection->Lock );

        //
        // Find a transaction that is owned by the specified tree
        // connect.
        //

        while ( TRUE ) {

            //
            // Get the address of the next list entry.  If we hit the
            // end of the list, exit the inner loop.
            //

            entry = entry->Flink;
            if ( entry == &pagedConnection->TransactionList ) goto main_loop_exit;

            //
            // Get the address of the transaction.  If it's owned by
            // the specified tree connect and currently active, exit
            // the inner loop.
            //

            transaction = CONTAINING_RECORD(
                            entry,
                            TRANSACTION,
                            ConnectionListEntry
                            );
            if ( transaction->TreeConnect == TreeConnect &&
                  GET_BLOCK_STATE(transaction) == BlockStateActive) {

                  break;

            }

        }

        //
        // Reference the transaction to ensure that it isn't deleted
        // when we close it.
        //

        SrvReferenceTransaction( transaction );

        //
        // Unlock the transaction list, so that we can dereference the
        // previous transaction and close the current one.
        //

        RELEASE_LOCK( &connection->Lock );

        //
        // If this is not the first matching transaction that we've
        // found, dereference the previous one now.
        //

        if ( previousTransaction != NULL ) {
            SrvDereferenceTransaction( previousTransaction );
        }

        //
        // Close the current transaction and mark that we need to
        // dereference it.
        //

        SrvCloseTransaction( transaction );

        previousTransaction = transaction;

        //
        // Go find another matching transaction.
        //

    } // while ( TRUE )

main_loop_exit:

    //
    // We have hit the end of the transaction list.  Release the
    // transaction lock.  If we have a transaction that needs to be
    // dereferenced, do so.  Then return to the caller.
    //

    RELEASE_LOCK( &connection->Lock );

    if ( previousTransaction != NULL ) {
        SrvDereferenceTransaction( previousTransaction );
    }

    return;

} // SrvCloseTransactionsOnTree


VOID
SrvDereferenceTransaction (
    IN PTRANSACTION Transaction
    )

/*++

Routine Description:

    This function decrements the reference count on a transaction.  If
    the reference count goes to zero, the transaction block is deleted.

Arguments:

    Transaction - Address of transaction

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    LONG result;

    PAGED_CODE( );

    //
    // Decrement the reference count on the block.
    //

    connection = Transaction->Connection;

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Dereferencing transaction %p; old refcnt %lx\n",
                    Transaction, Transaction->NonpagedHeader->ReferenceCount );
    }

    ASSERT( GET_BLOCK_TYPE( Transaction ) == BlockTypeTransaction );
    ASSERT( Transaction->NonpagedHeader->ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( Transaction, TRUE );

    result = InterlockedDecrement(
                &Transaction->NonpagedHeader->ReferenceCount
                );

    if ( result == 0 ) {

        //
        // The new reference count is 0, meaning that it's time to
        // delete this block.
        //
        // If the transaction is on the connection's pending transaction
        // list, remove it and dereference the connection, session, and
        // tree connect.  If the transaction isn't on the list, then the
        // session and tree connect pointers are not referenced
        // pointers, but just copies from the (single) work context
        // block associated with the transaction.
        //

        if ( Transaction->Inserted ) {

            ACQUIRE_LOCK( &connection->Lock );

            SrvRemoveEntryList(
                &connection->PagedConnection->TransactionList,
                &Transaction->ConnectionListEntry
                );

            RELEASE_LOCK( &connection->Lock );

            if ( Transaction->Session != NULL ) {
                SrvDereferenceSession( Transaction->Session );
                DEBUG Transaction->Session = NULL;
            }

            if ( Transaction->TreeConnect != NULL ) {
                SrvDereferenceTreeConnect( Transaction->TreeConnect );
                DEBUG Transaction->TreeConnect = NULL;
            }

        } else {

            DEBUG Transaction->Session = NULL;
            DEBUG Transaction->TreeConnect = NULL;

        }

        //
        // Free the transaction block, then release the transaction's
        // reference to the connection.  Note that we have to do the
        // dereference after calling SrvFreeConnection because that
        // routine may try to put the transaction on the connection's
        // cached transaction list.
        //

        SrvFreeTransaction( Transaction );

        SrvDereferenceConnection( connection );

    }

    return;

} // SrvDereferenceTransaction


VOID
SrvFreeTransaction (
    IN PTRANSACTION Transaction
    )

/*++

Routine Description:

    This function returns a Transaction block to the server heap.

Arguments:

    Transaction - Address of Transaction block

Return Value:

    None.

--*/

{
    ULONG blockSize;
    PCONNECTION connection;
    PNONPAGED_HEADER header;

    PAGED_CODE();

    blockSize = GET_BLOCK_SIZE( Transaction );

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( Transaction, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG Transaction->NonpagedHeader->ReferenceCount = -1;
    TERMINATE_REFERENCE_HISTORY( Transaction );

    connection = Transaction->Connection;

    //
    // If the transaction was not allocated from the XACTSRV heap and
    // its block size is correct, cache this transaction instead of
    // freeing it back to pool.
    //

    header = Transaction->NonpagedHeader;

    if( Transaction->OutDataAllocated == TRUE ) {
        FREE_HEAP( Transaction->OutData );
        Transaction->OutData = NULL;
    }

    if ( !Transaction->RemoteApiRequest ) {

        if ( blockSize == CACHED_TRANSACTION_BLOCK_SIZE ) {
            //
            // Check the count of cached transactions on the connection.
            // If there aren't already enough transactions cached, link
            // this transaction to the list.  Otherwise, free the
            // transaction block.
            //

            if ( connection->CachedTransactionCount < CACHED_TRANSACTION_LIMIT ) {

                if ( connection->CachedTransactionCount < CACHED_TRANSACTION_LIMIT ) {

                    ExInterlockedPushEntrySList(
                        &connection->CachedTransactionList,
                        (PSLIST_ENTRY)&header->ListEntry,
                        &connection->SpinLock
                        );
                    InterlockedIncrement( &connection->CachedTransactionCount );

                    return;
                }
            }
        }

        FREE_HEAP( Transaction );

    } else {

        SrvXsFreeHeap( Transaction );

    }

    DEALLOCATE_NONPAGED_POOL( header );

    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvFreeTransaction: Freed transaction block at %p\n",
                    Transaction );
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TransactionInfo.Frees );

    return;

} // SrvFreeTransaction
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\blkwork.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blkwork.c

Abstract:

    This module implements routines for managing work context blocks.

Author:

    Chuck Lenzmeier (chuckl) 4-Oct-1989
    David Treadwell (davidtr)

Revision History:

--*/

#include "precomp.h"
#include "blkwork.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKWORK

#define FREE_EXTRA_SMB_BUFFER( _wc ) {                                  \
        ASSERT( (_wc)->UsingExtraSmbBuffer );                           \
        ASSERT( (_wc)->ResponseBuffer != NULL );                        \
        DEALLOCATE_NONPAGED_POOL( (_wc)->ResponseBuffer );              \
        DEBUG (_wc)->ResponseBuffer = NULL;                             \
        DEBUG (_wc)->ResponseHeader = NULL;                             \
        DEBUG (_wc)->ResponseParameters = NULL;                         \
        (_wc)->UsingExtraSmbBuffer = FALSE;                             \
    }
//
// Local functions.
//

#define TransportHeaderSize 80


PWORK_CONTEXT
InitializeWorkItem (
    IN PVOID WorkItem,
    IN UCHAR BlockType,
    IN CLONG TotalSize,
    IN CLONG IrpSize,
    IN CCHAR IrpStackSize,
    IN CLONG MdlSize,
    IN CLONG BufferSize,
    IN PVOID Buffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateInitialWorkItems )
#pragma alloc_text( PAGE, SrvAllocateRawModeWorkItem )
#pragma alloc_text( PAGE, SrvFreeInitialWorkItems )
#pragma alloc_text( PAGE, SrvFreeNormalWorkItem )
#pragma alloc_text( PAGE, SrvFreeRawModeWorkItem )
//#pragma alloc_text( PAGE, SrvDereferenceWorkItem )
#pragma alloc_text( PAGE, SrvAllocateExtraSmbBuffer )
#pragma alloc_text( PAGE, SrvGetRawModeWorkItem )
#pragma alloc_text( PAGE, SrvRequeueRawModeWorkItem )
#endif
#if 0
NOT PAGEABLE -- SrvFsdDereferenceWorkItem
#endif


NTSTATUS
SrvAllocateInitialWorkItems (
    VOID
    )

/*++

Routine Description:

    This routine allocates the initial set of normal server work items.
    It allocates one large block of memory to contain the entire set.
    The purpose of this single allocation is to eliminate the wasted
    space inherent in the allocation of a single work item.  (Normal
    work items occupy about 5K bytes.  Because of the way nonpaged pool
    is managed, allocating 5K actually uses 8K.)

    Each normal work item includes enough memory to hold the following:

        - work context block,
        - IRP,
        - buffer descriptor,
        - two MDLs, and
        - buffer for sends and receives

    This routine also queues each of the work items to the receive
    work item list.

Arguments:

    None.

Return Value:

    NTSTATUS - Returns STATUS_INSUFFICIENT_RESOURCES if unable to
        allocate nonpaged pool; STATUS_SUCCESS otherwise.

--*/

{
    CLONG totalSize;
    CLONG workItemSize = 0;
    CLONG irpSize = SrvReceiveIrpSize;
    CLONG mdlSize = SrvMaxMdlSize;
    CLONG bufferSize = SrvReceiveBufferSize;
    ULONG cacheLineSize = SrvCacheLineSize;

    PVOID workItem;
    PVOID buffer;
    PWORK_CONTEXT workContext;
    CLONG i;
    PWORK_QUEUE queue;

    PAGED_CODE();

    //
    // If the initial set of work items is to be empty, don't do
    // anything.
    //
    // *** This will almost certainly never happen, but let's be
    //     prepared just in case.
    //

    if ( SrvInitialReceiveWorkItemCount == 0 ) {
        return STATUS_SUCCESS;
    }

    while( SrvInitialWorkItemBlock == NULL && SrvInitialReceiveWorkItemCount != 0 ) {

        //
        // Find out the sizes of the IRP, the SMB buffer, and the MDLs.  The
        // MDL size is "worst case" -- the actual MDL size may be smaller,
        // but this calculation ensures that the MDL will be large enough.
        //
        // *** Note that the space allocated for the SMB buffer must be made
        //     large enough to allow the buffer to be aligned such that it
        //     falls, alone, within a set of cache-line-sized blocks.  This
        //     allows I/O to be performed to or from the buffer without
        //     concern for cache line tearing.  (Note the assumption below
        //     that the cache line size is a power of two.)
        //

        //
        // Determine how large a buffer is needed for a single work item,
        // not including the SMB buffer.  Round this number to a quadword
        // boundary.
        //

        workItemSize = sizeof(WORK_CONTEXT) + irpSize + sizeof(BUFFER) +
                        (mdlSize * 2);
        workItemSize = (workItemSize + (MEMORY_ALLOCATION_ALIGNMENT - 1)) & ~(MEMORY_ALLOCATION_ALIGNMENT - 1);

        //
        // Determine the total amount of space needed.  The allocation
        // must be padded in order to allow the SMB buffers to be aligned
        // on cache line boundaries.
        //


        totalSize = (bufferSize + TransportHeaderSize + workItemSize) * SrvInitialReceiveWorkItemCount +
                    cacheLineSize;

        IF_DEBUG(HEAP) {
            SrvPrint0( "SrvAllocateInitialWorkItems:\n" );
            SrvPrint1( "  work item size = 0x%lx bytes\n", workItemSize );
            SrvPrint1( "  buffer size = 0x%lx bytes\n", bufferSize );
            SrvPrint1( "  Backfill size = 0x%lx bytes\n", TransportHeaderSize );
            SrvPrint1( "  number of work items = %ld\n",
                        SrvInitialReceiveWorkItemCount );
            SrvPrint1( "  total allocation = 0x%lx bytes\n", totalSize );
            SrvPrint1( "  wasted space = 0x%p bytes\n",
                        (PVOID)(ROUND_TO_PAGES( totalSize ) - totalSize) );
            SrvPrint1( "  amount saved over separate allocation = 0x%p bytes\n",
                        (PVOID)(((ROUND_TO_PAGES( workItemSize ) +
                          ROUND_TO_PAGES( bufferSize )) *
                                            SrvInitialReceiveWorkItemCount) -
                            ROUND_TO_PAGES( totalSize )) );
        }

        //
        // Attempt to allocate from nonpaged pool.
        //

        SrvInitialWorkItemBlock = ALLOCATE_NONPAGED_POOL(
                                    totalSize,
                                    BlockTypeWorkContextInitial
                                    );

        if ( SrvInitialWorkItemBlock == NULL ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvAllocateInitialWorkItems: Unable to allocate %d bytes "
                    "from nonpaged pool.",
                totalSize,
                NULL
                );

            //
            // Let's try reducing the count and give it another shot.
            //
            SrvInitialReceiveWorkItemCount /= 2;
        }
    }

    if( SrvInitialWorkItemBlock == 0 ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Round the allocation to a cache line boundary, then reserve
    // space for SMB buffers and control structures.
    //

    buffer = (PVOID)(((ULONG_PTR)SrvInitialWorkItemBlock + cacheLineSize) &
                                                    ~((LONG_PTR)cacheLineSize));

    workItem = (PCHAR)buffer + ((bufferSize + TransportHeaderSize) * SrvInitialReceiveWorkItemCount);

    //
    // Initialize the work items and update the count of work items in
    // the server.
    //
    // *** Note that the update is not synchronized -- that shouldn't be
    //     necessary at this stage of server initialization.
    //

    queue = SrvWorkQueues;
    for ( i = 0; i < SrvInitialReceiveWorkItemCount; i++ ) {

        if (((PAGE_SIZE - 1) - BYTE_OFFSET(buffer)) < (TransportHeaderSize + sizeof(SMB_HEADER))) {

           buffer = (PCHAR)buffer + PAGE_SIZE - BYTE_OFFSET(buffer);
           i++;
           IF_DEBUG(HEAP) {
              SrvPrint2("buffer adjusted!! %p offset %x \n",buffer,BYTE_OFFSET(buffer));
           }
        }

        workContext = InitializeWorkItem(
                            workItem,
                            BlockTypeWorkContextInitial,
                            workItemSize,
                            irpSize,
                            SrvReceiveIrpStackSize,
                            mdlSize,
                            bufferSize,
                            buffer
                            );

        workContext->PartOfInitialAllocation = TRUE;
        workContext->FreeList = &queue->InitialWorkItemList;
        workContext->CurrentWorkQueue = queue;

        if( ++queue == eSrvWorkQueues )
            queue = SrvWorkQueues;

        //
        // Setup the work item and queue it to the free list
        //

        SrvPrepareReceiveWorkItem( workContext, TRUE );

        buffer = (PCHAR)buffer + TransportHeaderSize + bufferSize;

        workItem = (PCHAR)workItem + workItemSize;

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.WorkContextInfo.Allocations );

    }

    return STATUS_SUCCESS;

} // SrvAllocateInitialWorkItems


NTSTATUS
SrvAllocateNormalWorkItem (
    OUT PWORK_CONTEXT *WorkContext,
    PWORK_QUEUE queue
    )

/*++

Routine Description:

    This routine allocates a normal server work item.  It allocates
    enough memory to hold the following:

        - work context block,
        - IRP,
        - buffer descriptor,
        - two MDLs, and
        - buffer for sends and receives

    It then initializes each of these blocks in the buffer.

    If the number of normal work items in the server is already at the
    configured maximum, this routine refuses to create a new one.

Arguments:

    WorkContext - Returns a pointer to the Work Context Block, or NULL
        if the limit has been reached or if no space is available.  The
        work context block has pointers to the other blocks.

Return Value:

    None.

--*/

{
    CLONG totalSize;
    CLONG workItemSize;
    CLONG irpSize = SrvReceiveIrpSize;
    CLONG mdlSize = SrvMaxMdlSize;
    CLONG bufferSize = SrvReceiveBufferSize;
    CLONG cacheLineSize = SrvCacheLineSize;

    PVOID workItem;
    PVOID buffer;
    CLONG oldWorkItemCount;

    //
    // If we're already at the limit of how many work items we can
    // have, don't create another one.
    //
    // *** Note that the method used below leaves a small window in
    //     which we may refuse to create a work item when we're not
    //     really at the limit -- we increment the value, another thread
    //     frees a work item and decrements the value, yet another
    //     thread tests to see whether it can create a new work item.
    //     Both testing threads will refuse to create a new work item,
    //     even though the final number of work items is one less than
    //     the maximum.
    //

    if ( queue->AllocatedWorkItems >= queue->MaximumWorkItems ) {

        //
        // Can't create any more work items just now.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint0( "SrvAllocateNormalWorkItem: Work item limit reached\n" );
        }

        *WorkContext = NULL;
        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    InterlockedIncrement( &queue->AllocatedWorkItems );

    //
    // Find out the sizes of the IRP, the SMB buffer, and the MDLs.  The
    // MDL size is "worst case" -- the actual MDL size may be smaller,
    // but this calculation ensures that the MDL will be large enough.
    //
    // *** Note that the space allocated for the SMB buffer must be made
    //     large enough to allow the buffer to be aligned such that it
    //     falls, alone, within a set of cache-line-sized blocks.  This
    //     allows I/O to be performed to or from the buffer without
    //     concern for cache line tearing.  (Note the assumption below
    //     that the cache line size is a power of two.)
    //

    //
    // Determine how large a buffer is needed for the SMB buffer and
    // control structures.  The allocation must be padded in order to
    // allow the SMB buffer to be aligned on a cache line boundary.
    //

    workItemSize = sizeof(WORK_CONTEXT) + irpSize + sizeof(BUFFER) +
                    (mdlSize * 2);
    totalSize = workItemSize + bufferSize + TransportHeaderSize+ cacheLineSize;


    //
    // Attempt to allocate from nonpaged pool.
    //

    workItem = ALLOCATE_NONPAGED_POOL( totalSize, BlockTypeWorkContextNormal );

    if ( workItem == NULL ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateNormalWorkItem: Unable to allocate %d bytes "
                "from nonpaged pool.",
            totalSize,
            NULL
            );

        InterlockedDecrement( &queue->AllocatedWorkItems );

        *WorkContext = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Reserve space for the SMB buffer on a cache line boundary.
    //


    buffer = (PVOID)(((ULONG_PTR)workItem + workItemSize + cacheLineSize) &
                                                ~((LONG_PTR)cacheLineSize));

    if (((PAGE_SIZE - 1) - BYTE_OFFSET(buffer)) < (TransportHeaderSize + sizeof(SMB_HEADER))) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateNormalWorkItem: Unable to allocate header with in a page ",
            totalSize,
            NULL
            );

        InterlockedDecrement( &queue->AllocatedWorkItems );
        DEALLOCATE_NONPAGED_POOL( workItem );
        *WorkContext = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Initialize the work item and increment the count of work items in
    // the server.
    //

    *WorkContext = InitializeWorkItem(
                        workItem,
                        BlockTypeWorkContextNormal,
                        workItemSize,
                        irpSize,
                        SrvReceiveIrpStackSize,
                        mdlSize,
                        bufferSize,
                        buffer
                        );

    (*WorkContext)->PartOfInitialAllocation = FALSE;

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.WorkContextInfo.Allocations );

    (*WorkContext)->FreeList = &queue->NormalWorkItemList;
    (*WorkContext)->CurrentWorkQueue = queue;

    return STATUS_SUCCESS;

} // SrvAllocateNormalWorkItem


VOID
SrvAllocateRawModeWorkItem (
    OUT PWORK_CONTEXT *WorkContext,
    IN PWORK_QUEUE queue
    )

/*++

Routine Description:

    This routine allocates a raw mode work item.  It allocates enough
    memory to hold the following:

        - work context block,
        - IRP,
        - buffer descriptor, and
        - one MDL

    It then initializes each of these blocks in the buffer.

    If the number of raw mode work items in the server is already at the
    configured maximum, this routine refuses to create a new one.

Arguments:

    WorkContext - Returns a pointer to the Work Context Block, or NULL
        if no space was available.  The work context block has pointers
        to the other blocks.

Return Value:

    None.

--*/

{
    CLONG workItemSize;
    CLONG irpSize = SrvReceiveIrpSize;
    CLONG mdlSize = SrvMaxMdlSize;

    PVOID workItem;
    CLONG oldWorkItemCount;

    PAGED_CODE( );

    //
    // If we're already at the limit of how many work items we can
    // have, don't create another one.
    //
    // *** Note that the method used below leaves a small window in
    //     which we may refuse to create a work item when we're not
    //     really at the limit -- we increment the value, another thread
    //     frees a work item and decrements the value, yet another
    //     thread tests to see whether it can create a new work item.
    //     Both testing threads will refuse to create a new work item,
    //     even though the final number of work items is one less than
    //     the maximum.
    //

    if ( (ULONG)queue->AllocatedRawModeWorkItems >=
                 SrvMaxRawModeWorkItemCount / SrvNumberOfProcessors ) {

        //
        // Can't create any more work items just now.
        //
        // !!! This should be logged somehow, but we don't want to
        //     breakpoint the server when it happens.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint0( "SrvAllocateRawModeWorkItem: Work item limit reached\n" );
        }

        *WorkContext = NULL;
        return;

    }

    InterlockedIncrement( &queue->AllocatedRawModeWorkItems );

    //
    // Find out the sizes of the IRP and the MDL.  The MDL size is
    // "worst case" -- the actual MDL size may be smaller, but this
    // calculation ensures that the MDL will be large enough.
    //

    workItemSize = sizeof(WORK_CONTEXT) + sizeof(BUFFER) + irpSize + mdlSize;

    //
    // Attempt to allocate from nonpaged pool.
    //

    workItem = ALLOCATE_NONPAGED_POOL( workItemSize, BlockTypeWorkContextRaw );

    if ( workItem == NULL ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateRawModeWorkItem: Unable to allocate %d bytes "
                "from nonpaged pool.",
            workItemSize,
            NULL
            );

        InterlockedDecrement( &queue->AllocatedRawModeWorkItems );

        *WorkContext = NULL;
        return;
    }

    //
    // Initialize the work item and increment the count of work items in
    // the server.
    //

    *WorkContext = InitializeWorkItem(
                        workItem,
                        BlockTypeWorkContextRaw,
                        workItemSize,
                        irpSize,
                        SrvReceiveIrpStackSize,
                        mdlSize,
                        0,
                        NULL
                        );

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.WorkContextInfo.Allocations );

    (*WorkContext)->FreeList = &queue->RawModeWorkItemList;
    (*WorkContext)->CurrentWorkQueue = queue;

} // SrvAllocateRawModeWorkItem


PWORK_CONTEXT
SrvGetRawModeWorkItem ()
{
    PSLIST_ENTRY listEntry;
    PWORK_CONTEXT workContext;
    PWORK_QUEUE queue = PROCESSOR_TO_QUEUE();

    PAGED_CODE();

    //
    // Attempt to allocate a raw mode work item off the current processor's queue
    //

    listEntry = ExInterlockedPopEntrySList( &queue->RawModeWorkItemList, &queue->SpinLock );
    if( listEntry != NULL ) {

        workContext = CONTAINING_RECORD( listEntry, WORK_CONTEXT, SingleListEntry );
        InterlockedDecrement( &queue->FreeRawModeWorkItems );
        ASSERT( queue->FreeRawModeWorkItems >= 0 );

    } else {

        SrvAllocateRawModeWorkItem( &workContext, queue );
    }

    if( workContext != NULL || SrvNumberOfProcessors == 1 ) {
        return workContext;
    }

    //
    // We were unable to get or allocate a raw mode workitem off the current
    // work queue.  We're a multiprocessor system, so look around for one off
    // of a different work queue.
    //
    for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {

        listEntry = ExInterlockedPopEntrySList( &queue->RawModeWorkItemList, &queue->SpinLock );

        if ( listEntry != NULL ) {

                InterlockedDecrement( &queue->FreeRawModeWorkItems );
                ASSERT( queue->FreeRawModeWorkItems >= 0 );
                workContext = CONTAINING_RECORD( listEntry, WORK_CONTEXT, SingleListEntry );

                return workContext;
        }
    }

    //
    // We were unable to get a free raw mode workitem off a different processor's
    //  raw work item queue.  See if any of the queues allow allocation of a new one.
    //
    for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {

        SrvAllocateRawModeWorkItem( &workContext, queue );

        if( workContext != NULL ) {
            break;
        }

    }

    return workContext;

} // SrvGetRawModeWorkItem


VOID
SrvRequeueRawModeWorkItem (
    PWORK_CONTEXT WorkContext
    )
{
    PWORK_QUEUE queue = CONTAINING_RECORD( WorkContext->FreeList,
                                         WORK_QUEUE, RawModeWorkItemList );

    PAGED_CODE();

    InterlockedIncrement( &queue->FreeRawModeWorkItems );

    ExInterlockedPushEntrySList( &queue->RawModeWorkItemList,
                                 &WorkContext->SingleListEntry,
                                 &queue->SpinLock
                               );


    return;

} // SrvRequeueRawModeWorkItem


VOID
SrvFreeInitialWorkItems (
    VOID
    )

/*++

Routine Description:

    This function deallocates the large block of work items allocated
    at server startup.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    if ( SrvInitialWorkItemBlock != NULL ) {

        IF_DEBUG(BLOCK1) {
            SrvPrint1( "Releasing initial work item block at 0x%p\n",
                        SrvInitialWorkItemBlock );
        }

        DEALLOCATE_NONPAGED_POOL( SrvInitialWorkItemBlock );
        IF_DEBUG(HEAP) {
            SrvPrint1( "SrvFreeInitialWorkItems: Freed initial work item block at 0x%p\n", SrvInitialWorkItemBlock );
        }

        SrvInitialWorkItemBlock = NULL;

    }

    return;

} // SrvFreeInitialWorkItems


VOID
SrvFreeNormalWorkItem (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function deallocates a work item block.

Arguments:

    WorkContext - Address of Work Context block that heads up the work
        item.

Return Value:

    None.

--*/

{
    PWORK_QUEUE queue = WorkContext->CurrentWorkQueue;

    PAGED_CODE( );

    IF_DEBUG(BLOCK1) {
        SrvPrint1( "Closing work item at 0x%p\n", WorkContext );
    }

    ASSERT( GET_BLOCK_STATE( WorkContext ) == BlockStateActive );
    ASSERT( !WorkContext->PartOfInitialAllocation );

    //
    // Free the work item block itself.
    //

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( WorkContext, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG WorkContext->BlockHeader.ReferenceCount = (ULONG)-1;

    DEALLOCATE_NONPAGED_POOL( WorkContext );
    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvFreeNormalWorkItem: Freed Work Item block at 0x%p\n",
                    WorkContext );
    }

    //
    // Update the count of work items in the server.
    //

    InterlockedDecrement( &queue->AllocatedWorkItems );
    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.WorkContextInfo.Frees );

    return;

} // SrvFreeNormalWorkItem


VOID
SrvFreeRawModeWorkItem (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function deallocates a raw mode work item block.

Arguments:

    WorkContext - Address of Work Context block that heads up the work
        item.

Return Value:

    None.

--*/

{
    PWORK_QUEUE queue = CONTAINING_RECORD( WorkContext->FreeList,
                                         WORK_QUEUE, RawModeWorkItemList );
    PAGED_CODE( );

    IF_DEBUG(BLOCK1) {
        SrvPrint1( "Closing workitem at 0x%p\n", WorkContext );
    }

    ASSERT( GET_BLOCK_STATE( WorkContext ) == BlockStateActive );
    ASSERT( !WorkContext->PartOfInitialAllocation );

    //
    // Free the work item block itself.
    //

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( WorkContext, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG WorkContext->BlockHeader.ReferenceCount = (ULONG)-1;

    DEALLOCATE_NONPAGED_POOL( WorkContext );
    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvFreeRawModeWorkItem: Freed Work Item block at 0x%p\n",
                    WorkContext );
    }

    //
    // Update the count of work items in the server.
    //
    InterlockedDecrement( &queue->AllocatedRawModeWorkItems );
    ASSERT( queue->AllocatedRawModeWorkItems >= 0 );

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.WorkContextInfo.Frees );

    return;

} // SrvFreeRawModeWorkItem


PWORK_CONTEXT
InitializeWorkItem (
    IN PVOID WorkItem,
    IN UCHAR BlockType,
    IN CLONG WorkItemSize,
    IN CLONG IrpSize,
    IN CCHAR IrpStackSize,
    IN CLONG MdlSize,
    IN CLONG BufferSize,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This routine initializes the following components of a work item:
        - a work context block,
        - an IRP,
        - the CurrentWorkQueue
        - optionally, a buffer descriptor,
        - one or two MDLs, and
        - optionally, a buffer for sends and receives

    The storage for these components must have been allocated by the
    caller, in contiguous storage starting at WorkContext.

Arguments:

    WorkItem - Supplies a pointer to the storage allocated to the
        work item.

    BlockType - The type of work item being initialized.

    WorkItemSize - Indicates the total amount of space allocated to the
        work item control structures (i.e., not including the data
        buffer, if any).

    IrpSize - Indicates the amount of space in the work item to be
        reserved for the IRP.

    IrpStackSize - Indicates the number of stack locations in the IRP.

    MdlSize - Indicates the amount of space in the work item to be
        reserved for each MDL.  One MDL is created if Buffer is NULL;
        two are created if Buffer is not NULL.

    BufferSize - Indicates the amount of space allocated to be
        data buffer.  This parameter is ignored if Buffer is NULL.

    Buffer - Supplies a pointer to a data buffer.  NULL indicates that
        no data buffer was allocated.  (This is used for raw mode work
        items.)

Return Value:

    PWORK_CONTEXT - Returns a pointer to the work context block that
        forms the "root" of the work item.

--*/

{
    PVOID nextAddress;
    PWORK_CONTEXT workContext;
    PIRP irp;
    PBUFFER bufferDescriptor;
    PMDL fullMdl;
    PMDL partialMdl;

    ASSERT( ((ULONG_PTR)WorkItem & 7) == 0 );

    //
    // Zero the work item control structures.
    //

    RtlZeroMemory( WorkItem, WorkItemSize );

    //
    // Allocate and initialize the work context block.
    //

    workContext = WorkItem;
    nextAddress = workContext + 1;
    ASSERT( ((ULONG_PTR)nextAddress & 7) == 0 );

    SET_BLOCK_TYPE_STATE_SIZE( workContext, BlockType, BlockStateActive, sizeof(WORK_CONTEXT) );
    workContext->BlockHeader.ReferenceCount = 0;

    INITIALIZE_REFERENCE_HISTORY( workContext );

    INITIALIZE_SPIN_LOCK( &workContext->SpinLock );

    //
    // Allocate and initialize an IRP.
    //

    irp = nextAddress;
    nextAddress = (PCHAR)irp + IrpSize;
    ASSERT( ((ULONG_PTR)nextAddress & 7) == 0 );

    workContext->Irp = irp;

    IoInitializeIrp( irp, (USHORT)IrpSize, IrpStackSize );

    CHECKIRP( irp );

    //
    // Allocate a buffer descriptor.  It will be initialized as we
    // find out the necessary information.
    //

    bufferDescriptor = nextAddress;
    nextAddress = bufferDescriptor + 1;
    ASSERT( ((ULONG_PTR)nextAddress & 7) == 0 );

    workContext->RequestBuffer = bufferDescriptor;
    workContext->ResponseBuffer = bufferDescriptor;

    //
    // Allocate an MDL.  In normal work items, this is the "full MDL"
    // describing the entire SMB buffer.  In raw mode work items, this
    // MDL is used to describe raw buffers.
    //

    fullMdl = nextAddress;
    nextAddress = (PCHAR)fullMdl + MdlSize;
    ASSERT( ((ULONG_PTR)nextAddress & 7) == 0 );

    bufferDescriptor->Mdl = fullMdl;

    //
    // If this is a normal work item, initialize the first MDL and
    // allocate and initialize a second MDL and the SMB buffer.
    //

    if ( Buffer != NULL ) {

        partialMdl = nextAddress;

        bufferDescriptor->Buffer = TransportHeaderSize + (PCHAR)Buffer;
        MmInitializeMdl( fullMdl, TransportHeaderSize + (PCHAR)Buffer, BufferSize );
        memset(Buffer,'N', TransportHeaderSize);

        bufferDescriptor->PartialMdl = partialMdl;
        MmInitializeMdl( partialMdl, (PVOID)(PAGE_SIZE-1), MAX_PARTIAL_BUFFER_SIZE );

        bufferDescriptor->BufferLength = BufferSize;
        MmBuildMdlForNonPagedPool( fullMdl );

        fullMdl->MdlFlags|=MDL_NETWORK_HEADER;
        ASSERT( fullMdl->ByteOffset >= TransportHeaderSize );
    }

    //
    // Initialize the client address pointer
    //

    workContext->ClientAddress = &workContext->ClientAddressData;

    //
    // Initialize the processor
    //
    workContext->CurrentWorkQueue = PROCESSOR_TO_QUEUE();

    //
    // Print debugging information.
    //

    IF_DEBUG(HEAP) {

        SrvPrint2( "  InitializeWorkItem: work item of 0x%lx bytes at 0x%p\n", WorkItemSize, WorkItem );
        SrvPrint2( "    Work Context: 0x%lx bytes at 0x%p\n",
                    sizeof(WORK_CONTEXT), workContext );
        SrvPrint2( "    IRP: 0x%lx bytes at 0x%p\n",
                    workContext->Irp->Size, workContext->Irp );

        SrvPrint2( "    Buffer Descriptor: 0x%lx bytes at 0x%p\n",
                    sizeof(BUFFER), workContext->RequestBuffer );
        SrvPrint2( "    Full MDL: 0x%lx bytes at 0x%p\n",
                    MdlSize, workContext->RequestBuffer->Mdl );
        if ( Buffer != NULL ) {
            SrvPrint2( "    Partial MDL: 0x%lx bytes at 0x%p\n",
                        MdlSize, workContext->ResponseBuffer->PartialMdl );
            SrvPrint2( "    Buffer: 0x%lx bytes at 0x%p\n",
                        workContext->RequestBuffer->BufferLength,
                        workContext->RequestBuffer->Buffer );
        } else {
            SrvPrint0( "    No buffer allocated\n" );
        }

    }

    //
    // Return the address of the work context block, which is the "root"
    // of the work item.
    //

    return workContext;

} // InitializeWorkItem


VOID SRVFASTCALL
SrvDereferenceWorkItem (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function decrements the reference count of a work context block.

    *** This routine must not be called at DPC level!  Use
        SrvFsdDereferenceWorkItem from DPC level.

Arguments:

    WorkContext - Pointer to the work context block to reference.

Return Value:

    None.

--*/

{
    ULONG oldCount;

    PAGED_CODE( );

    ASSERT( (LONG)WorkContext->BlockHeader.ReferenceCount > 0 );
    ASSERT( (GET_BLOCK_TYPE(WorkContext) == BlockTypeWorkContextInitial) ||
            (GET_BLOCK_TYPE(WorkContext) == BlockTypeWorkContextNormal) ||
            (GET_BLOCK_TYPE(WorkContext) == BlockTypeWorkContextRaw) );
    UPDATE_REFERENCE_HISTORY( WorkContext, TRUE );

    //
    // Decrement the WCB's reference count.
    //

    oldCount = ExInterlockedAddUlong(
                (PULONG)&WorkContext->BlockHeader.ReferenceCount,
                (ULONG)-1,
                &WorkContext->SpinLock
                );

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Dereferencing WorkContext 0x%p; new refcnt 0x%lx\n",
                    WorkContext, WorkContext->BlockHeader.ReferenceCount );
    }

    if ( oldCount == 1 ) {

        //
        // We are done with the work context, replace it on the free queue.
        //
        // If we are using an extra SMB buffer, free it now.
        //
        SrvWmiTraceEvent(WorkContext);

        if ( WorkContext->UsingExtraSmbBuffer ) {
            FREE_EXTRA_SMB_BUFFER( WorkContext );
        }

        ASSERT( !WorkContext->UsingExtraSmbBuffer );

        //
        // Release references.
        //

        SrvReleaseContext( WorkContext );

        SrvFsdRequeueReceiveWorkItem( WorkContext );

    }

    return;

} // SrvDereferenceWorkItem


VOID
SrvFsdDereferenceWorkItem (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function decrements the reference count of a work context block.

Arguments:

    WorkContext - Pointer to the work context block to reference.

Return Value:

    None.

--*/

{
    ULONG oldCount;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    ASSERT( (LONG)WorkContext->BlockHeader.ReferenceCount > 0 );
    ASSERT( (GET_BLOCK_TYPE(WorkContext) == BlockTypeWorkContextInitial) ||
            (GET_BLOCK_TYPE(WorkContext) == BlockTypeWorkContextNormal) ||
            (GET_BLOCK_TYPE(WorkContext) == BlockTypeWorkContextRaw) );
    UPDATE_REFERENCE_HISTORY( WorkContext, TRUE );

    //
    // Decrement the WCB's reference count.
    //

    oldCount = ExInterlockedAddUlong(
                (PULONG)&WorkContext->BlockHeader.ReferenceCount,
                (ULONG)-1,
                &WorkContext->SpinLock
                );

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Dereferencing WorkContext 0x%p; new refcnt 0x%lx\n",
                    WorkContext, WorkContext->BlockHeader.ReferenceCount );
    }

    if ( oldCount == 1 ) {

        //
        // We are done with the work context, replace it on the free queue.
        //
        // If we are using an extra SMB buffer, free it now.
        //

        if ( WorkContext->UsingExtraSmbBuffer ) {
            FREE_EXTRA_SMB_BUFFER( WorkContext );
        }

        ASSERT( !WorkContext->UsingExtraSmbBuffer );

        //
        // If the work context block has references to a share, a
        // session, or a tree connect, queue it to the FSP immediately.
        // These blocks are not in nonpaged pool, so they can't be
        // touched at DPC level.
        //

        if ( (WorkContext->Share != NULL) ||
             (WorkContext->Session != NULL) ||
             (WorkContext->TreeConnect != NULL) ||
             (WorkContext->SecurityContext != NULL) ) {

            UPDATE_REFERENCE_HISTORY( WorkContext, FALSE );

            ExInterlockedAddUlong(
                (PULONG)&WorkContext->BlockHeader.ReferenceCount,
                1,
                &WorkContext->SpinLock
                );

            WorkContext->QueueToHead = TRUE;
            WorkContext->FspRestartRoutine = SrvDereferenceWorkItem;
            QUEUE_WORK_TO_FSP( WorkContext );

        } else {

            //
            // Try to requeue the work item.  This will fail if the
            // reference count on the connection goes to zero.
            //
            // *** Note that even if the requeueing fails, the work item
            //     is still removed from the in-progress list, so we
            //     can't just requeue to SrvDereferenceWorkItem.
            //

            SrvFsdRequeueReceiveWorkItem( WorkContext );

        }
    }

    return;

} // SrvFsdDereferenceWorkItem

NTSTATUS
SrvAllocateExtraSmbBuffer (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    ULONG cacheLineSize = SrvCacheLineSize;
    ULONG bufferSize = SrvReceiveBufferSize;
    ULONG mdlSize = SrvMaxMdlSize;
    PBUFFER bufferDescriptor;
    PMDL fullMdl;
    PMDL partialMdl;
    PVOID data;

    PAGED_CODE( );

    ASSERT( !WorkContext->UsingExtraSmbBuffer );

    //
    // Allocate an SMB buffer for use with SMB's that require a separate
    // request and response buffer.
    //

    bufferDescriptor = ALLOCATE_NONPAGED_POOL(
                            sizeof(BUFFER) +
                                mdlSize * 2 +
                                bufferSize +
                                TransportHeaderSize +
                                cacheLineSize,
                            BlockTypeDataBuffer
                            );
    if ( bufferDescriptor == NULL) {
        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    //
    // Initialize one MDL.  This is the "full MDL" describing the
    // entire SMB buffer.
    //

    fullMdl = (PMDL)(bufferDescriptor + 1);
    partialMdl = (PMDL)( (PCHAR)fullMdl + mdlSize );
    data = (PVOID)( ((ULONG_PTR)partialMdl + mdlSize + TransportHeaderSize + cacheLineSize) & ~(LONG_PTR)(cacheLineSize) );

    bufferDescriptor->Mdl = fullMdl;
    MmInitializeMdl( fullMdl, data, bufferSize );

    fullMdl->MdlFlags |= MDL_NETWORK_HEADER;


    //
    // Initialize a second MDL and the SMB buffer.
    //

    bufferDescriptor->PartialMdl = partialMdl;
    MmInitializeMdl( partialMdl, (PVOID)(PAGE_SIZE-1), MAX_PARTIAL_BUFFER_SIZE );

    MmBuildMdlForNonPagedPool( fullMdl );

    bufferDescriptor->Buffer = data;
    bufferDescriptor->BufferLength = bufferSize;

    WorkContext->ResponseBuffer = bufferDescriptor;
    WorkContext->ResponseHeader = bufferDescriptor->Buffer;
    WorkContext->ResponseParameters = (PCHAR)bufferDescriptor->Buffer +
                                                sizeof( SMB_HEADER );

    WorkContext->UsingExtraSmbBuffer = TRUE;

    return STATUS_SUCCESS;

} // SrvAllocateExtraSmbBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\ea.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ea.c

Abstract:

    This module contains various support routines for extended attributes.

Author:

    David Treadwell (davidtr) 5-Apr-1990

Revision History:

--*/

#include "precomp.h"
#include "ea.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_EA

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAreEasNeeded )
#pragma alloc_text( PAGE, SrvGetOs2FeaOffsetOfError )
#pragma alloc_text( PAGE, SrvGetOs2GeaOffsetOfError )
#pragma alloc_text( PAGE, SrvOs2FeaListToNt )
#pragma alloc_text( PAGE, SrvOs2FeaListSizeToNt )
#pragma alloc_text( PAGE, SrvOs2FeaToNt )
#pragma alloc_text( PAGE, SrvOs2GeaListToNt )
#pragma alloc_text( PAGE, SrvOs2GeaListSizeToNt )
#pragma alloc_text( PAGE, SrvOs2GeaToNt )
#pragma alloc_text( PAGE, SrvNtFullEaToOs2 )
#pragma alloc_text( PAGE, SrvGetNumberOfEasInList )
#pragma alloc_text( PAGE, SrvQueryOs2FeaList )
#pragma alloc_text( PAGE, SrvSetOs2FeaList )
#pragma alloc_text( PAGE, SrvConstructNullOs2FeaList )
#endif


BOOLEAN
SrvAreEasNeeded (
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    )

/*++

Routine Description:

    This routine checks whether any of the full EAs in the list have the
    FILE_NEED_EA bit set in the flags field.

Arguments:

    NtFullEa - a pointer to a pointer to where the NT-style full EA list
        is stored.

Return Value:

    BOOLEAN - TRUE if any EA has FILE_NEED_EA set, FALSE otherwise.

--*/

{
    PFILE_FULL_EA_INFORMATION lastEa;

    PAGED_CODE( );

    do {

        if ( NtFullEa->Flags & FILE_NEED_EA ) {
            return TRUE;
        }

        lastEa = NtFullEa;
        NtFullEa = (PFILE_FULL_EA_INFORMATION)(
                       (PCHAR)NtFullEa + NtFullEa->NextEntryOffset );

    } while ( lastEa->NextEntryOffset != 0 );

    return FALSE;

} // SrvAreEasNeeded


USHORT
SrvGetOs2FeaOffsetOfError (
    IN ULONG NtErrorOffset,
    IN PFILE_FULL_EA_INFORMATION NtFullEa,
    IN PFEALIST FeaList
    )

/*++

Routine Description:

    Finds the offset in a FEALIST that corresponds to an offset into
    a list of FILE_FULL_EA_INFORMATION structures.  This is used when
    NtSetEaFile returns an offset to an EA that caused an error, and we
    need to return the offset into the list of EAs given to us by the
    client.

Arguments:

    NtErrorOffset - offset of the EA in the NT full EA list that caused
        the error.

    NtFullEa - a pointer to a pointer to where the NT-style full EA list
        is stored.  A buffer is allocated and pointer to by *NtFullEa.

    FeaList - pointer to the OS/2 1.2 FEALIST.

Return Value:

    USHORT - offset into the FEALIST.

--*/

{
    PFEA fea = FeaList->list;
    PFEA lastFeaStartLocation;
    PFILE_FULL_EA_INFORMATION offsetLocation;

    PAGED_CODE( );

    //
    // If the NT error offset is zero, return 0 for the FEA error offset.
    //
    // !!! this shouldn't be necessary if the loop below is written
    //     correctly.

    //if ( NtErrorOffset == 0 ) {
    //    return 0;
    //}

    //
    // Find where in the NT full EA list the error occurred and the
    // last possible start location for an FEA in the FEALIST.
    //

    offsetLocation = (PFILE_FULL_EA_INFORMATION)(
                         (PCHAR)NtFullEa + NtErrorOffset);
    lastFeaStartLocation = (PFEA)( (PCHAR)FeaList +
                               SmbGetUlong( &FeaList->cbList ) -
                               sizeof(FEA) - 1 );

    //
    // Walk through both lists simultaneously until one of three conditions
    // is true:
    //     - we reach or pass the offset in the NT full EA list
    //     - we reach the end of the NT full EA list
    //     - we reach the end of the FEALIST.
    //

    while ( NtFullEa < offsetLocation &&
            NtFullEa->NextEntryOffset != 0 &&
            fea <= lastFeaStartLocation ) {

        NtFullEa = (PFILE_FULL_EA_INFORMATION)(
                       (PCHAR)NtFullEa + NtFullEa->NextEntryOffset );
        fea = (PFEA)( (PCHAR)fea + sizeof(FEA) + fea->cbName + 1 +
                      SmbGetUshort( &fea->cbValue ) );
    }

    //
    // If NtFullEa is not equal to the offset location we calculated,
    // somebody messed up.
    //

    //ASSERT( NtFullEa == offsetLocation );

    return PTR_DIFF_SHORT(fea, FeaList );

} // SrvGetOs2FeaOffsetOfError


USHORT
SrvGetOs2GeaOffsetOfError (
    IN ULONG NtErrorOffset,
    IN PFILE_GET_EA_INFORMATION NtGetEa,
    IN PGEALIST GeaList
    )

/*++

Routine Description:

    Finds the offset in a GEALIST that corresponds to an offset into
    a list of FILE_GET_EA_INFORMATION structures.  This is used when
    NtQueryEaFile returns an offset to an EA that caused an error, and we
    need to return the offset into the list of EAs given to us by the
    client.

Arguments:

    NtErrorOffset - offset of the EA in the NT get EA list that caused
        the error.

    NtGetEa - a pointer to a pointer to where the NT-style get EA list
        is stored.  A buffer is allocated and pointer to by *NtGetEa.

    GeaList - pointer to the OS/2 1.2 GEALIST.

Return Value:

    USHORT - offset into the GEALIST.

--*/

{
    PGEA gea = GeaList->list;
    PGEA lastGeaStartLocation;
    PFILE_GET_EA_INFORMATION offsetLocation;

    PAGED_CODE( );

    //
    // Find where in the NT get EA list the error occurred and the
    // last possible start location for an GEA in the GEALIST.
    //

    offsetLocation = (PFILE_GET_EA_INFORMATION)((PCHAR)NtGetEa + NtErrorOffset);
    lastGeaStartLocation = (PGEA)( (PCHAR)GeaList +
                               SmbGetUlong( &GeaList->cbList ) - sizeof(GEA) );


    //
    // Walk through both lists simultaneously until one of three conditions
    // is true:
    //     - we reach or pass the offset in the NT full EA list
    //     - we reach the end of the NT get EA list
    //     - we reach the end of the GEALIST.
    //

    while ( NtGetEa < offsetLocation &&
            NtGetEa->NextEntryOffset != 0 &&
            gea <= lastGeaStartLocation ) {

        NtGetEa = (PFILE_GET_EA_INFORMATION)(
                      (PCHAR)NtGetEa + NtGetEa->NextEntryOffset );
        gea = (PGEA)( (PCHAR)gea + sizeof(GEA) + gea->cbName );
    }

    //
    // If NtGetEa is not equal to the offset location we calculated,
    // somebody messed up.
    //

//    ASSERT( NtGetEa == offsetLocation );

    return PTR_DIFF_SHORT(gea, GeaList);

} // SrvGetOs2GeaOffsetOfError


NTSTATUS
SrvOs2FeaListToNt (
    IN PFEALIST FeaList,
    OUT PFILE_FULL_EA_INFORMATION *NtFullEa,
    OUT PULONG BufferLength,
    OUT PUSHORT EaErrorOffset
    )

/*++

Routine Description:

    Converts a list of OS/2 1.2 FEAs to NT style.  Memory is allocated from
    non-paged pool to hold the NT full EA list.  The calling routine is
    responsible for deallocating this memory when it is done with it.

    WARNING!  It is the responsibility of the calling routine to ensure
    that the value in FeaList->cbList will fit within the buffer allocated
    to FeaList.  This prevents malicious redirectors from causing an
    access violation in the server.

Arguments:

    FeaList - pointer to the OS/2 1.2 FEALIST to convert.

    NtFullEa - a pointer to a pointer to where the NT-style full EA list
        is stored.  A buffer is allocated and pointer to by *NtFullEa.

    BufferLength - length of the allocated buffer.


Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_INSUFF_SERVER_RESOURCES.

--*/

{
    PFEA lastFeaStartLocation;
    PFEA fea = NULL;
    PFEA lastFea = NULL;
    PFILE_FULL_EA_INFORMATION ntFullEa = NULL;
    PFILE_FULL_EA_INFORMATION lastNtFullEa = NULL;

    PAGED_CODE( );

    //
    // Find out how large the OS/2 1.2 FEALIST will be after it is
    // converted to NT format.  This is necessary in order to
    // determine how large a buffer to allocate to receive the NT
    // EAs.
    //

    *BufferLength = SrvOs2FeaListSizeToNt( FeaList );

    //
    // It is possible for SrvOs2FeaListSizeToNt to return 0 in the event
    // that the very first FEA in the list is corrupt.  Return an error
    // if this is the case with an appropriate EaErrorOffset value.
    //

    if (*BufferLength == 0) {
        *EaErrorOffset = 0;
        return STATUS_OS2_EA_LIST_INCONSISTENT;
    }

    //
    // Allocate a buffer to hold the NT list.  This is allocated from
    // non-paged pool so that it may be used in IRP-based IO requests.
    //

    *NtFullEa = ALLOCATE_NONPAGED_POOL( *BufferLength, BlockTypeDataBuffer );

    if ( *NtFullEa == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvOs2FeaListToNt: Unable to allocate %d bytes from nonpaged "
                "pool.",
            *BufferLength,
            NULL
            );

        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    //
    // Find the last location at which an FEA can start.  The -1 is to
    // account for the zero terminator on the name field of the FEA.
    //

    lastFeaStartLocation = (PFEA)( (PCHAR)FeaList +
                               SmbGetUlong( &FeaList->cbList ) -
                               sizeof(FEA) - 1 );

    //
    // Go through the FEA list, converting from OS/2 1.2 format to NT
    // until we pass the last possible location in which an FEA can start.
    //

    for ( fea = FeaList->list, ntFullEa = *NtFullEa, lastNtFullEa = ntFullEa;
          fea <= lastFeaStartLocation;
          fea = (PFEA)( (PCHAR)fea + sizeof(FEA) +
                        fea->cbName + 1 + SmbGetUshort( &fea->cbValue ) ) ) {

        //
        // Check for an invalid flag bit.  If set, return an error.
        //

        if ( (fea->fEA & ~FEA_NEEDEA) != 0 ) {
            *EaErrorOffset = PTR_DIFF_SHORT(fea, FeaList);
            DEALLOCATE_NONPAGED_POOL( *NtFullEa );
            return STATUS_INVALID_PARAMETER;
        }

        lastNtFullEa = ntFullEa;
        lastFea = fea;
        ntFullEa = SrvOs2FeaToNt( ntFullEa, fea );
    }

    //
    // Make sure that the FEALIST size parameter was correct.  If we ended
    // on an EA that was not the first location after the end of the
    // last FEA, then the size parameter was wrong.  Return an offset to
    // the EA that caused the error.
    //

    if ( (PCHAR)fea != (PCHAR)FeaList + SmbGetUlong( &FeaList->cbList ) ) {
        *EaErrorOffset = PTR_DIFF_SHORT(lastFea, FeaList);
        DEALLOCATE_NONPAGED_POOL( *NtFullEa );
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Set the NextEntryOffset field of the last full EA to 0 to indicate
    // the end of the list.
    //

    lastNtFullEa->NextEntryOffset = 0;

    return STATUS_SUCCESS;

} // SrvOs2FeaListToNt


ULONG
SrvOs2FeaListSizeToNt (
    IN PFEALIST FeaList
    )

/*++

Routine Description:

    Get the number of bytes that would be required to represent the
    FEALIST in NT format.

    WARNING: This routine makes no checks on the size of the FEALIST
    buffer.  It is assumed that FeaList->cbList is a legitimate value.

    WARNING: The value returned by this routine may be as much as three
    higher than the actual size needed to hold the FEAs in NT format.
    See comments below.

Arguments:

    Fea - a pointer to the list of FEAs.

Return Value:

    ULONG - number of bytes required to hold the EAs in NT format.

--*/

{
    ULONG size = 0;

    PCHAR lastValidLocation;
    PCHAR variableBuffer;
    PFEA  fea;

    PAGED_CODE( );

    //
    // Find the last valid location in the FEA buffer.
    //

    lastValidLocation = (PCHAR)FeaList + SmbGetUlong( &FeaList->cbList );

    //
    // Go through the FEA list until we pass the last location
    //   indicated in the buffer.
    //

    for ( fea = FeaList->list;
          fea < (PFEA)lastValidLocation;
          fea = (PFEA)( (PCHAR)fea + sizeof(FEA) +
                          fea->cbName + 1 + SmbGetUshort( &fea->cbValue ) ) ) {

        //
        //  Be very careful accessing the embedded FEA since there are so many possibly
        //    conflicting sizes running around here.  The first part of the conditional
        //    below makes sure that the cbName and cbValue fields of the FEA buffer can
        //    actually be dereferenced.  The second part verifies that they contain
        //    reasonable values.
        //

        variableBuffer = (PCHAR)fea + sizeof(FEA);

        if (variableBuffer >= lastValidLocation ||
            (variableBuffer + fea->cbName + 1 + SmbGetUshort(&fea->cbValue)) > lastValidLocation) {

            //
            //  The values in this part of the buffer indicate a range outside the
            //    buffer.  Don't calculate a size, and shrink the cbList value to
            //    include only the prior FEA.
            //

            SmbPutUshort( &FeaList->cbList, PTR_DIFF_SHORT(fea, FeaList) );
            break;

        }

        //
        // SmbGetNtSizeOfFea returns the number of bytes needed to hold
        // a single FEA in NT format, including any padding needed for
        // longword-alignment.  Since the size of the buffer needed to
        // hold the NT EA list does not include any padding after the
        // last EA, the value returned by this routine may be as much as
        // three higher than the size actually needed.
        //

        size += SmbGetNtSizeOfFea( fea );
    }

    return size;

} // SrvOs2FeaListSizeToNt


PVOID
SrvOs2FeaToNt (
    OUT PFILE_FULL_EA_INFORMATION NtFullEa,
    IN PFEA Fea
    )

/*++

Routine Description:

    Converts a single OS/2 FEA to NT full EA style.  The FEA need not have
    any particular alignment.  This routine makes no checks on buffer
    overrunning--this is the responsibility of the calling routine.

Arguments:

    NtFullEa - a pointer to where the NT full EA is to be written.

    Fea - pointer to the OS/2 1.2 FEA to convert.

Return Value:

    A pointer to the location after the last byte written.

--*/

{
    PCHAR ptr;

    PAGED_CODE( );

    NtFullEa->Flags = Fea->fEA;
    NtFullEa->EaNameLength = Fea->cbName;
    NtFullEa->EaValueLength = SmbGetUshort( &Fea->cbValue );

    ptr = NtFullEa->EaName;
    RtlMoveMemory( ptr, (PVOID)(Fea+1), Fea->cbName );

    ptr += NtFullEa->EaNameLength;
    *ptr++ = '\0';

    //
    // Copy the EA value to the NT full EA.
    //

    RtlMoveMemory(
        ptr,
        (PCHAR)(Fea+1) + NtFullEa->EaNameLength + 1,
        NtFullEa->EaValueLength
        );

    ptr += NtFullEa->EaValueLength;

    //
    // Longword-align ptr to determine the offset to the next location
    // for an NT full EA.
    //

    ptr = (PCHAR)( ((ULONG_PTR)ptr + 3) & ~3 );
    NtFullEa->NextEntryOffset = (ULONG)( ptr - (PCHAR)NtFullEa );

    return ptr;

} // SrvOs2FeaToNt


NTSTATUS
SrvOs2GeaListToNt (
    IN PGEALIST GeaList,
    OUT PFILE_GET_EA_INFORMATION *NtGetEa,
    OUT PULONG BufferLength,
    OUT PUSHORT EaErrorOffset
    )

/*++

Routine Description:

    Converts a list of OS/2 1.2 GEAs to NT style.  Memory is allocated from
    non-paged pool to hold the NT get EA list.  The calling routine is
    responsible for deallocating this memory when it is done with it.

    WARNING!  It is the responsibility of the calling routine to ensure
    that the value in GeaList->cbList will fit within the buffer allocated
    to GeaList.  This prevents malicious redirectors from causing an
    access violation in the server.

Arguments:

    GeaList - pointer to the OS/2 1.2 GEALIST to convert.

    NtGetEa - a pointer to a pointer to where the NT-style get EA list
        is stored.  A buffer is allocated and pointer to by *NtGetEa.

    BufferLength - length of the allocated buffer.

Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_INSUFF_SERVER_RESOURCES.

--*/

{
    PGEA lastGeaStartLocation;
    PGEA gea = NULL;
    PGEA lastGea = NULL;
    PFILE_GET_EA_INFORMATION ntGetEa = NULL;
    PFILE_GET_EA_INFORMATION lastNtGetEa = NULL;

    PAGED_CODE( );

    //
    // Find out how large the OS/2 1.2 GEALIST will be after it is
    // converted to NT format.  This is necessary in order to
    // determine how large a buffer to allocate to receive the NT
    // EAs.
    //

    *BufferLength = SrvOs2GeaListSizeToNt( GeaList );

    if ( *BufferLength == 0 ) {
        *EaErrorOffset = 0;
        return STATUS_OS2_EA_LIST_INCONSISTENT;
    }

    //
    // Allocate a buffer to hold the NT list.  This is allocated from
    // non-paged pool so that it may be used in IRP-based IO requests.
    //

    *NtGetEa = ALLOCATE_NONPAGED_POOL( *BufferLength, BlockTypeDataBuffer );

    if ( *NtGetEa == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvOs2GeaListToNt: Unable to allocate %d bytes from nonpaged "
                "pool.",
            *BufferLength,
            NULL
            );

        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    //
    // Find the last location at which a GEA can start.  The zero
    // terminator on the name field of the GEA is accounted for by the
    // szName[0] field in the GEA structure.
    //

    lastGeaStartLocation = (PGEA)( (PCHAR)GeaList +
                               SmbGetUlong( &GeaList->cbList ) - sizeof(GEA) );

    //
    // Go through the GEA list, converting from OS/2 1.2 format to NT
    // until we pass the last possible location in which an GEA can start.
    //

    for ( gea = GeaList->list, ntGetEa = *NtGetEa, lastNtGetEa = ntGetEa;
          gea <= lastGeaStartLocation;
          gea = (PGEA)( (PCHAR)gea + sizeof(GEA) + gea->cbName ) ) {

        lastNtGetEa = ntGetEa;
        lastGea = gea;
        ntGetEa = SrvOs2GeaToNt( ntGetEa, gea );
    }

    //
    // Make sure that the GEALIST size parameter was correct.  If we ended
    // on an EA that was not the first location after the end of the
    // last GEA, then the size parameter was wrong.  Return an offset to
    // the EA that caused the error.
    //

    if ( (PCHAR)gea != (PCHAR)GeaList + SmbGetUlong( &GeaList->cbList ) ) {
        DEALLOCATE_NONPAGED_POOL(*NtGetEa);
        *EaErrorOffset = PTR_DIFF_SHORT(lastGea, GeaList);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Set the NextEntryOffset field of the last get EA to 0 to indicate
    // the end of the list.
    //

    lastNtGetEa->NextEntryOffset = 0;

    return STATUS_SUCCESS;

} // SrvOs2GeaListToNt


ULONG
SrvOs2GeaListSizeToNt (
    IN PGEALIST GeaList
    )

/*++

Routine Description:

    Get the number of bytes that would be required to represent the
    GEALIST in NT format.

    WARNING: This routine makes no checks on the size of the GEALIST
    buffer.  It is assumed that GeaList->cbList is a legitimate value.

    WARNING: The value returned by this routine may be as much as three
    higher than the actual size needed to hold the GEAs in NT format.
    See comments below.

Arguments:

    Gea - a pointer to the list of GEAs.

    Size - number of bytes required to hold the EAs in NT format.

Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_BUFFER_OVERFLOW if the GEA list was
        larger than it's buffer.

--*/

{
    ULONG size = 0;

    PCHAR lastValidLocation;
    PCHAR variableBuffer;
    PGEA gea;

    PAGED_CODE( );

    //
    // Find the last location in the GEA buffer.
    //

    lastValidLocation = (PCHAR)GeaList + SmbGetUlong( &GeaList->cbList );


    //
    // Go through the GEA list until we pass the last possible location
    // in which an GEA can start.
    //

    for ( gea = GeaList->list;
          gea < (PGEA)lastValidLocation;
          gea = (PGEA)( (PCHAR)gea + sizeof(GEA) + gea->cbName ) ) {

        //
        //  Be very careful accessing the embedded GEA.  The first part of the conditional
        //    below makes sure that the cbName field of the GEA buffer can
        //    actually be dereferenced.  The second part verifies that it contains
        //    reasonable values.
        //

        variableBuffer = (PCHAR)gea + sizeof(GEA);

        if ( variableBuffer >= lastValidLocation ||
             variableBuffer + gea->cbName > lastValidLocation ) {

           //
           //  If there's a bogus value in the buffer stop processing the size
           //    and reset the cbList value to only enclose the previous GEA.
           //

           SmbPutUshort(&GeaList->cbList, PTR_DIFF_SHORT(gea, GeaList));
           break;

        }


        //
        // SmbGetNtSizeOfGea returns the number of bytes needed to hold
        // a single GEA in NT format.  This includes any padding needed
        // for longword-alignment.  Since the size of the buffer needed
        // to hold the NT EA list does not include any padding after the
        // last EA, the value returned by this routine may be as much as
        // three higher than the size actually needed.
        //

        size += SmbGetNtSizeOfGea( gea );
    }

    return size;

} // SrvOs2GeaListSizeToNt


PVOID
SrvOs2GeaToNt (
    OUT PFILE_GET_EA_INFORMATION NtGetEa,
    IN PGEA Gea
    )

/*++

Routine Description:

    Converts a single OS/2 GEA to NT get EA style.  The GEA need not have
    any particular alignment.  This routine makes no checks on buffer
    overrunning--this is the responsibility of the calling routine.

Arguments:

    NtGetEa - a pointer to where the NT get EA is to be written.

    Gea - pointer to the OS/2 1.2 GEA to convert.

Return Value:

    A pointer to the location after the last byte written.

--*/

{
    PCHAR ptr;

    PAGED_CODE( );

    NtGetEa->EaNameLength = Gea->cbName;

    ptr = NtGetEa->EaName;
    RtlMoveMemory( ptr, Gea->szName, Gea->cbName );

    ptr += NtGetEa->EaNameLength;
    *ptr++ = '\0';

    //
    // Longword-align ptr to determine the offset to the next location
    // for an NT full EA.
    //

    ptr = (PCHAR)( ((ULONG_PTR)ptr + 3) & ~3 );
    NtGetEa->NextEntryOffset = (ULONG)( ptr - (PCHAR)NtGetEa );

    return ptr;

} // SrvOs2GeaToNt


PVOID
SrvNtFullEaToOs2 (
    OUT PFEA Fea,
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    )

/*++

Routine Description:

    Converts a single NT full EA to OS/2 FEA style.  The FEA need not have
    any particular alignment.  This routine makes no checks on buffer
    overrunning--this is the responsibility of the calling routine.

Arguments:

    Fea - a pointer to the location where the OS/2 FEA is to be written.

    NtFullEa - a pointer to the NT full EA.

Return Value:

    A pointer to the location after the last byte written.

--*/

{
    PCHAR ptr;
    ULONG i;

    PAGED_CODE( );

    Fea->fEA = (UCHAR)NtFullEa->Flags;
    Fea->cbName = NtFullEa->EaNameLength;
    SmbPutUshort( &Fea->cbValue, NtFullEa->EaValueLength );

    //
    // Copy the attribute name.
    //

    for ( i = 0, ptr = (PCHAR) (Fea + 1);
          i < (ULONG) NtFullEa->EaNameLength;
          i++, ptr++) {

        *ptr = RtlUpperChar( NtFullEa->EaName[i] );

    }

    *ptr++ = '\0';

    RtlMoveMemory(
        ptr,
        NtFullEa->EaName + NtFullEa->EaNameLength + 1,
        NtFullEa->EaValueLength
        );

    return (ptr + NtFullEa->EaValueLength);

} // SrvNtFullEaToOs2


CLONG
SrvGetNumberOfEasInList (
    IN PVOID List
    )

/*++

Routine Description:

    Finds the number of EAs in an NT get or full EA list.  The list
    should have already been verified to be legitimate to prevent access
    violations.

Arguments:

    List - a pointer to the NT get or full EA list.

Return Value:

    CLONG - the number of EAs in the list.

--*/

{
    CLONG count = 1;
    PULONG ea;

    PAGED_CODE( );

    //
    // Walk through the list.  The first longword of each EA is the offset
    // to the next EA.
    //

    for ( ea = List; *ea != 0; ea = (PULONG)( (PCHAR)ea + *ea ) ) {
        count++;
    }

    return count;

} // SrvGetNumberOfEasInList


NTSTATUS
SrvQueryOs2FeaList (
    IN HANDLE FileHandle,
    IN PGEALIST GeaList OPTIONAL,
    IN PFILE_GET_EA_INFORMATION NtGetEaList OPTIONAL,
    IN ULONG GeaListLength OPTIONAL,
    IN PFEALIST FeaList,
    IN ULONG BufferLength,
    OUT PUSHORT EaErrorOffset
    )

/*++

Routine Description:

    Converts a single NT full EA list to OS/2 FEALIST style.  The FEALIST
    need not have any particular alignment.

Arguments:

    FileHandle - handle to a file open with FILE_READ_EA access.

    GeaList - if non-NULL, an OS/2 1.2 style GEALIST used to get only
        a subset of the files EAs rather than all the EAs.  Only the
        EAs listed in GEALIST are returned.

    NtGetEaList - if non-NULL, an NT style get EA list used to get only
        a subset of the files EAs rather than all the EAs.  Only the
        EAs listed in GEALIST are returned.

    GeaListLength - the maximum possible length of the GeaList (used to
        prevent access violations) or the actual size of the NtGetEaList.

    FeaList - where to write the OS/2 1.2 style FEALIST for the file.

    BufferLength - length of Buffer.

Return Value:

    NTSTATUS - STATUS_SUCCESS, STATUS_BUFFER_OVERFLOW if the EAs wouldn't
        fit in Buffer, or a value returned by NtQuery{Information,Ea}File.

--*/

{
    NTSTATUS status;

    PFEA fea = FeaList->list;
    PFILE_FULL_EA_INFORMATION ntFullEa;

    PFILE_GET_EA_INFORMATION ntGetEa = NULL;
    ULONG ntGetEaBufferLength = 0;

    FILE_EA_INFORMATION eaInfo;
    IO_STATUS_BLOCK ioStatusBlock;

    PSRV_EA_INFORMATION eaInformation = NULL;
    ULONG eaBufferSize;
    ULONG errorOffset;

    BOOLEAN isFirstCall = TRUE;

    PAGED_CODE( );

    *EaErrorOffset = 0;

    //
    // Find out how big a buffer we need to get the EAs.
    //

    status = NtQueryInformationFile(
                 FileHandle,
                 &ioStatusBlock,
                 &eaInfo,
                 sizeof(FILE_EA_INFORMATION),
                 FileEaInformation
                 );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvQueryOs2FeaList: NtQueryInformationFile(ea information) "
                "returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
        goto exit;
    }

    //
    // If the file has no EAs, return an FEA size = 4 (that's what OS/2
    // does--it accounts for the size of the cbList field of an
    // FEALIST).  Also, store the NT EA size in case there is a buffer
    // overflow and we need to return the total EA size to the client.
    //

    if ( eaInfo.EaSize == 0 ) {
        SmbPutUlong( &FeaList->cbList, 4 );
    } else {
        SmbPutUlong( &FeaList->cbList, eaInfo.EaSize );
    }

    if ( eaInfo.EaSize == 0 && GeaList == NULL && NtGetEaList == NULL ) {
        status = STATUS_SUCCESS;
        goto exit;
    }

    //
    // If a GEALIST was specified, convert it to NT style.
    //

    if ( ARGUMENT_PRESENT(GeaList) ) {

        //
        // Make sure that the value in GeaList->cbList is legitimate
        // (allows the GEALIST to fit within its buffer).
        //

        if ( GeaListLength < sizeof(GEALIST) ||
             SmbGetUlong( &GeaList->cbList ) < sizeof(GEALIST) ||
             SmbGetUlong( &GeaList->cbList ) > GeaListLength ) {
            status = STATUS_OS2_EA_LIST_INCONSISTENT;
            goto exit;
        }

        //
        // Convert the GEALIST to NT style.  SrvOs2GeaListToNt allocates
        // space to hold the NT get EA list, so remember to deallocate
        // this before exiting this routine.
        //

        status = SrvOs2GeaListToNt(
                     GeaList,
                     &ntGetEa,
                     &ntGetEaBufferLength,
                     EaErrorOffset
                     );

        if ( !NT_SUCCESS(status) ) {
            return status;
        }
    }

    //
    // If an NT-style get EA list was specified, use it.
    //

    if ( ARGUMENT_PRESENT(NtGetEaList) ) {
        ntGetEa = NtGetEaList;
        ntGetEaBufferLength = GeaListLength;
    }

    //
    // HACKHACK: eaInfo.EaSize is the size needed by OS/2.  For NT,
    // the system has no way of telling us how big a buffer we need.
    // According to BrianAn, this should not be bigger than twice
    // what OS/2 needs.
    //

    eaBufferSize = eaInfo.EaSize * EA_SIZE_FUDGE_FACTOR;

    //
    // If a get EA list was specified, a larger buffer is needed to hold
    // all the EAs.  This is because some or all of the specified EAs
    // may not exist, yet they will still be returned by the file system
    // with value length = 0.  Add to the EA size the amount of space the
    // get EA list would use if it were converted to a full EA list.
    //

    if ( ntGetEa != NULL ) {
        eaBufferSize += ntGetEaBufferLength +
                             ( SrvGetNumberOfEasInList( ntGetEa ) *
                              ( sizeof(FILE_FULL_EA_INFORMATION) -
                                sizeof(FILE_GET_EA_INFORMATION) ));
    }

    //
    // Allocate a buffer to receive the EAs.  If the total EA size is
    // small enough to get it all in one call to NtQueryEaFile, allocate
    // a buffer that large.  If The EAs are large, use a buffer size that
    // is the smallest size guaranteed to hold at least one EA.
    //
    // The buffer must be allocated from non-paged pool for the IRP
    // request built below.
    //

    eaBufferSize = MIN( MAX_SIZE_OF_SINGLE_EA, eaBufferSize ) +
                       sizeof(SRV_EA_INFORMATION);

    eaInformation = ALLOCATE_NONPAGED_POOL( eaBufferSize, BlockTypeDataBuffer );

    if ( eaInformation == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvQueryOs2FeaList: Unable to allocate %d bytes from nonpaged "
                "pool.",
            eaBufferSize,
            NULL
            );

        status = STATUS_INSUFF_SERVER_RESOURCES;
        goto exit;
    }

    //
    // Get the EAs.
    //

    while(1) {

        ULONG feaSize;

        status = SrvQueryEaFile(
                     isFirstCall,
                     FileHandle,
                     ntGetEa,
                     ntGetEaBufferLength,
                     eaInformation,
                     eaBufferSize,
                     &errorOffset
                     );

        if ( status == STATUS_NO_MORE_EAS ) {
            break;
        }

        if ( !NT_SUCCESS(status) ) {

            if ( ARGUMENT_PRESENT(GeaList) ) {
                *EaErrorOffset = SrvGetOs2GeaOffsetOfError(
                                     errorOffset,
                                     ntGetEa,
                                     GeaList
                                     );
                //
                // SrvQueryEaFile has already logged the error.  Do not
                // create another log entry here.
                //

                IF_DEBUG(SMB_ERRORS) {
                    PGEA errorGea = (PGEA)( (PCHAR)GeaList + *EaErrorOffset );
                    SrvPrint1( "EA error offset in GEALIST: 0x%lx\n", *EaErrorOffset );
                    SrvPrint1( "name: %s\n", errorGea->szName );
                }
            }

            goto exit;
        }

        isFirstCall = FALSE;
        ntFullEa = eaInformation->CurrentEntry;

        //
        // See if there is enough room to hold the EA in the user buffer.
        //
        // *** STATUS_BUFFER_OVERFLOW is a special status code for the
        //     find2 logic.  See that code before making changes here.

        feaSize = SmbGetOs2SizeOfNtFullEa( ntFullEa );
        if ( feaSize > (ULONG)( (PCHAR)FeaList + BufferLength - (PCHAR)fea ) ) {
            status = STATUS_BUFFER_OVERFLOW;
            goto exit;
        }

        //
        // Copy the NT format EA to OS/2 1.2 format and set the fea
        // pointer for the next iteration.
        //

        fea = SrvNtFullEaToOs2( fea, ntFullEa );

        ASSERT( (ULONG_PTR)fea <= (ULONG_PTR)FeaList + BufferLength );
    }

    //
    // Set the number of bytes in the FEALIST.
    //

    SmbPutUlong(
        &FeaList->cbList,
        PTR_DIFF(fea, FeaList)
        );

    status = STATUS_SUCCESS;

exit:
    //
    // Deallocate the buffers used to hold the NT get and full EA lists.
    //

    if ( ntGetEa != NULL && ARGUMENT_PRESENT(GeaList) ) {
        DEALLOCATE_NONPAGED_POOL( ntGetEa );
    }

    if ( eaInformation != NULL ) {
        DEALLOCATE_NONPAGED_POOL( eaInformation );
    }

    return status;

} // SrvQueryOs2FeaList


NTSTATUS
SrvSetOs2FeaList (
    IN HANDLE FileHandle,
    IN PFEALIST FeaList,
    IN ULONG BufferLength,
    OUT PUSHORT EaErrorOffset
    )

/*++

Routine Description:

    Sets the EAs on a file given an OS/2 1.2 representation of the EAs.

Arguments:

    FileHandle - handle to a file open with FILE_WRITE_EA access whose
        EAs are to be set.

    FeaList - a pointer to the location where the OS/2 FEALIST is stored.

    BufferLength - maximum size of the buffer the FEALIST structure can
        have.  This is used to prevent a malicious redirector from causing
        an access violation in the server.

Return Value:

    NTSTATUS - what happened

--*/

{
    NTSTATUS status;

    PFILE_FULL_EA_INFORMATION ntFullEa;
    ULONG ntFullEaBufferLength;
    ULONG errorOffset;

    PAGED_CODE( );

    *EaErrorOffset = 0;

    //
    // Special case for too-small FEALIST: don't set anything.
    // sizeof(FEALIST) will cover the buffer size and one FEA structure.
    // Without at least this much info there isn't anything to do here.
    //
    // NOTE:  If there is space for at least one FEA in the list, but the
    //        FEA is corrupt, we'll return an error below, i.e. insufficient
    //        information is not an error condition while corrupt info is.
    //

    if ( BufferLength <= sizeof(FEALIST) ||
         SmbGetUlong( &FeaList->cbList ) <= sizeof(FEALIST)) {
        return STATUS_SUCCESS;
    }

    //
    // Make sure that the value in Fealist->cbList is legitimate.
    //

    if ( SmbGetUlong( &FeaList->cbList ) > BufferLength ) {
        DEBUG SrvPrint2(
            "SrvSetOs2FeaList: EA list size is inconsistent.  Actual size"
                "is %d, expected maximum size is %d",
            SmbGetUlong( &FeaList->cbList ),
            BufferLength
            );
        return STATUS_OS2_EA_LIST_INCONSISTENT;
    }

    //
    // Convert the FEALIST to NT style.
    //

    status = SrvOs2FeaListToNt(
                 FeaList,
                 &ntFullEa,
                 &ntFullEaBufferLength,
                 EaErrorOffset
                 );

    if ( !NT_SUCCESS(status) ) {

        //
        // SrvOs2FeaListToNt has already logged the error.  Do not
        // create another log entry here.
        //

        return status;

    }

    //
    // Set the file's EAs with a directly-built IRP.  Doing this rather
    // than calling the NtSetEaFile system service prevents a copy of
    // the input data from occurring.
    //
    // *** The operation is performed synchronously.
    //

    status = SrvIssueSetEaRequest(
                FileHandle,
                ntFullEa,
                ntFullEaBufferLength,
                &errorOffset
                );

    if ( !NT_SUCCESS(status) ) {

        //
        // An error occurred.  Find the offset into the EA list of the
        // error.
        //

        *EaErrorOffset = SrvGetOs2FeaOffsetOfError(
                             errorOffset,
                             ntFullEa,
                             FeaList
                             );

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvSetOs2FeaList: SrvIssueSetEaRequest returned %X",
            status,
            NULL
            );

        /*
        This logging can potentially crash the server on a bad packet.  Removed.
        IF_DEBUG(ERRORS) {
            PFEA errorFea = (PFEA)( (PCHAR)FeaList + *EaErrorOffset );
            SrvPrint1( "EA error offset in FEALIST: 0x%lx\n", *EaErrorOffset );
            SrvPrint3( "name: %s, value len: %ld, value: %s", (PCHAR)(errorFea+1),
                          SmbGetUshort( &errorFea->cbValue ),
                          (PCHAR)(errorFea+1) + errorFea->cbName + 1 );
        }
        */
    }

    //
    // Deallocate the buffer used to hold the NT full EA list.
    //

    DEALLOCATE_NONPAGED_POOL( ntFullEa );

    return status;

} // SrvSetOs2FeaList


NTSTATUS
SrvConstructNullOs2FeaList (
    IN PFILE_GET_EA_INFORMATION NtGeaList,
    OUT PFEALIST FeaList,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    Converts a single NT full EA list to OS/2 FEALIST style for files
    with no eas.  When a file has no eas but a GEAlist was supplied,
    we need to return an ealist that has all the attributes specified
    in the GEAlist present but with CbValues of 0.  This routine was
    specifically written for the files . and .. but can be used to get
    the FEAlist of a no ea file given the NT Gea list.

Arguments:

    NtGetEaList - if non-NULL, an NT style get EA list used to get only
        a subset of the files EAs rather than all the EAs.  Only the
        EAs listed in GEALIST are returned.

    FeaList - where to write the OS/2 1.2 style FEALIST for the file.

    BufferLength - length of Buffer.

Return Value:

    NTSTATUS - STATUS_SUCCESS, STATUS_BUFFER_OVERFLOW if the EAs wouldn't
        fit in Buffer, or a value returned by NtQuery{Information,Ea}File.

--*/

{

    PCHAR ptr;
    PFEA fea = FeaList->list;
    PFILE_GET_EA_INFORMATION currentGea = NtGeaList;
    LONG remainingBytes = BufferLength;
    ULONG i;

    PAGED_CODE( );

    //
    // Get the EAs.
    //

    for ( ; ; ) {

        //
        // Is our buffer big enough?
        //

        remainingBytes -= ( sizeof( FEA ) + currentGea->EaNameLength + 1 );

        if ( remainingBytes < 0 ) {

            return  STATUS_BUFFER_OVERFLOW;

        }

        //
        // We know what these are.
        //

        fea->fEA = 0;
        fea->cbName = currentGea->EaNameLength;
        SmbPutUshort( &fea->cbValue, 0);

        //
        // Copy the attribute name.
        //

        for ( i = 0, ptr = (PCHAR) (fea + 1);
              i < (ULONG) currentGea->EaNameLength;
              i++, ptr++) {

            *ptr = RtlUpperChar( currentGea->EaName[i] );

        }

        *ptr++ = '\0';

        fea = (PFEA) ptr;

        //
        // Is this the last one?
        //

        if ( currentGea->NextEntryOffset == 0 ) {
            break;
        }

        //
        // Move to the next attribute
        //

        currentGea = (PFILE_GET_EA_INFORMATION)
                        ((PCHAR) currentGea + currentGea->NextEntryOffset);

    }

    //
    // Set the number of bytes in the FEALIST.
    //

    SmbPutUlong(
        &FeaList->cbList,
        (ULONG)((ULONG_PTR)fea - (ULONG_PTR)FeaList)
        );

    return STATUS_SUCCESS;

} // SrvConstructNullOs2FeaList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\copy.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    copy.c

Abstract:

    This module contains the routine to copy a file.

Author:

    David Treadwell (davidtr) 24-Jan-1990

Revision History:

--*/

#include "precomp.h"
#include "copy.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_COPY

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvCopyFile )
#endif

#define EOF 0x1A                    // Control-Z == end of file


NTSTATUS
SrvCopyFile (
    IN HANDLE SourceHandle,
    IN HANDLE TargetHandle,
    IN USHORT SmbOpenFunction,
    IN USHORT SmbFlags,
    IN ULONG ActionTaken
    )

/*++

Routine Description:

    This routine copies or appends from the source file to the target file.
    It does the following:

        read sources EAs, attributes, size
        create/open target using source's info
        read data from source and write it to target

Arguments:

    SourceHandle - handle to source file opened with SRV_COPY_SOURCE_ACCESS
        for synchronous access.

    TargetHandle - handle to target file opened with SRV_COPY_SOURCE_ACCESS
        for synchronous access.

    SmbOpenFunction - used to determine whether the source should be
        appended to the end of the target.

    ActionTaken - Information field of IO status block from the NtCreateFile
        where the target was opened.  This is used to determine whether
        the target should be deleted if an error occurs.


Return Value:

    NTSTATUS - STATUS_SUCCESS or error.

--*/

{

    NTSTATUS status;
    NTSTATUS readStatus = STATUS_SUCCESS;
    NTSTATUS writeStatus = STATUS_SUCCESS;

    IO_STATUS_BLOCK ioStatusBlock;
    FILE_EA_INFORMATION eaInfo;
    SRV_NETWORK_OPEN_INFORMATION sourceNetworkOpenInformation;
    SRV_NETWORK_OPEN_INFORMATION targetNetworkOpenInformation;
    FILE_POSITION_INFORMATION positionInfo;
    FILE_ALLOCATION_INFORMATION allocationInfo;
    LARGE_INTEGER fileOffset;

    BOOLEAN append;
    BOOLEAN sourceIsAscii;
    BOOLEAN targetIsAscii;

    PCHAR ioBuffer;
    ULONG ioBufferSize;
    ULONG offset = 0;
    ULONG bytesRead;

    BOOLEAN eofFound = FALSE;
    CHAR lastByte;

    PAGED_CODE( );

    //
    // Find out if we are supposed to append to the target file or
    // overwrite it, and whether this is a binary or ASCII copy for
    // the source and target.  In a binary copy for the source, we stop
    // the first time we see EOF (control-Z).  In a binary copy for the
    // target, we must make sure that there is exactly one EOF in the
    // file and that this is the last character of the file.
    //

    append = SmbOfunAppend( SmbOpenFunction );
    sourceIsAscii = (BOOLEAN)((SmbFlags & SMB_COPY_SOURCE_ASCII) != 0);
    targetIsAscii = (BOOLEAN)((SmbFlags & SMB_COPY_TARGET_ASCII) != 0);

    //
    // Find the size of the EAs on the source.
    //

    status = NtQueryInformationFile(
                 SourceHandle,
                 &ioStatusBlock,
                 &eaInfo,
                 sizeof(eaInfo),
                 FileEaInformation
                 );

    if ( !NT_SUCCESS(status) ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvCopyFile: NtQueryInformationFile (source EA size) failed: %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
        return status;
    }

    //
    // If the source file has EAs, get them and write them to the target
    // file.
    //

    if ( eaInfo.EaSize > 0 ) {

        PCHAR eaBuffer;
        ULONG eaBufferSize;

        //
        // Allocate a buffer large enough to hold the EAs.
        //
        //
        // HACKHACK: eaInfo.EaSize is the size needed by OS/2.  For NT,
        // the system has no way of telling us how big a buffer we need.
        // According to BrianAn, this should not be bigger than twice
        // what OS/2 needs.
        //

        eaBufferSize = eaInfo.EaSize * EA_SIZE_FUDGE_FACTOR;

        eaBuffer = ALLOCATE_NONPAGED_POOL( eaBufferSize, BlockTypeDataBuffer );
        if ( eaBuffer == NULL ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvCopyFile:  Unable to allocate %d bytes nonpaged pool",
                eaBufferSize,
                NULL
                );

            return STATUS_INSUFF_SERVER_RESOURCES;
        }

        status = SrvIssueQueryEaRequest(
                     SourceHandle,
                     eaBuffer,
                     eaBufferSize,
                     NULL,
                     0L,
                     FALSE,
                     NULL
                     );

        if ( NT_SUCCESS(status) ) {
            status = ioStatusBlock.Status;
        }

        if ( !NT_SUCCESS(status) ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvCopyFile: SrvIssueQueryEaRequest failed: %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_EAS, status );
            DEALLOCATE_NONPAGED_POOL( eaBuffer );
            return status;
        }

        status = SrvIssueSetEaRequest(
                     TargetHandle,
                     eaBuffer,
                     eaBufferSize,
                     NULL
                     );

        if ( NT_SUCCESS(status) ) {
            status = ioStatusBlock.Status;
        }

        if ( status == STATUS_EAS_NOT_SUPPORTED ||
                 status == STATUS_NOT_IMPLEMENTED ) {

            if ( SrvAreEasNeeded( (PFILE_FULL_EA_INFORMATION)eaBuffer ) ) {
                DEALLOCATE_NONPAGED_POOL( eaBuffer );
                return STATUS_EAS_NOT_SUPPORTED;
            }

            status = STATUS_SUCCESS;
        }

        DEALLOCATE_NONPAGED_POOL( eaBuffer );

        if ( !NT_SUCCESS(status) ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvCopyFile: SrvIssueSetEaRequest failed: %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_SET_EAS, status );
            return status;
        }

    }

    //
    // Get the various attributes of the source file--size, times, etc.
    // These are used later on to set attributes of the target file.
    //

    status = SrvQueryNetworkOpenInformation(
                                            SourceHandle,
                                            NULL,
                                            &sourceNetworkOpenInformation,
                                            FALSE
                                            );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvCopyFile: NtQueryInformationFile "
                "returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
        return status;
    }

    //
    // If target was opened and we're in append mode, save the target's
    // original size and time and set target file pointer to the end of
    // the file.
    //

    if ( append ) {

        status = SrvQueryNetworkOpenInformation(
                                                TargetHandle,
                                                NULL,
                                                &targetNetworkOpenInformation,
                                                FALSE
                                                );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvCopyFile: NtQueryInformationFile "
                    "for target returned %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
            return status;
        }

        //
        // If the target is in ASCII mode, then see if the last character
        // of the target file is EOF (^Z).  If so, then set EndOfFile
        // such that this character will be overwritten.
        //

        if ( targetIsAscii && (targetNetworkOpenInformation.EndOfFile.QuadPart > 0) ) {

            LARGE_INTEGER eofFileOffset;

            eofFileOffset.QuadPart = targetNetworkOpenInformation.EndOfFile.QuadPart - 1;

            status = NtReadFile(
                         TargetHandle,
                         NULL,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         &lastByte,
                         sizeof(lastByte),
                         &eofFileOffset,
                         NULL
                         );

            if ( !NT_SUCCESS(status) ) {
                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SrvCopyFile: NtReadFile for target last byte"
                        "returned %X",
                    status,
                    NULL
                    );

                SrvLogServiceFailure( SRV_SVC_NT_READ_FILE, status );
                return status;
            }

            if ( lastByte == EOF ) {
                targetNetworkOpenInformation.EndOfFile = eofFileOffset;
            }
        }

        positionInfo.CurrentByteOffset = targetNetworkOpenInformation.EndOfFile;
        status = NtSetInformationFile(
                     TargetHandle,
                     &ioStatusBlock,
                     &positionInfo,
                     sizeof(positionInfo),
                     FilePositionInformation
                     );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvCopyFile: NtSetInformationFile(position information)"
                    "for target returned %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );
            return status;
        }
    }

    //
    // Set the new size of the output file.  Doing this avoids forcing
    // the file system to automatically extend the file bit by bit.
    //

    if ( append ) {
        allocationInfo.AllocationSize.QuadPart =
            targetNetworkOpenInformation.EndOfFile.QuadPart +
            sourceNetworkOpenInformation.EndOfFile.QuadPart;
    } else {
        allocationInfo.AllocationSize = sourceNetworkOpenInformation.EndOfFile;
    }

    if ( 0 ) {
        KdPrint(( "SrvCopyFile: Setting allocation size of target to "
                    "%ld (0x%lx) bytes\n",
                    allocationInfo.AllocationSize.LowPart,
                    allocationInfo.AllocationSize.LowPart
                    ));
        KdPrint(( "             %ld (0x%lx) blocks + %ld (0x%lx) bytes\n",
                    allocationInfo.AllocationSize.LowPart / 512,
                    allocationInfo.AllocationSize.LowPart / 512,
                    allocationInfo.AllocationSize.LowPart % 512,
                    allocationInfo.AllocationSize.LowPart % 512
                    ));
    }

    status = NtSetInformationFile(
                 TargetHandle,
                 &ioStatusBlock,
                 &allocationInfo,
                 sizeof(allocationInfo),
                 FileAllocationInformation
                 );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvCopyFile: NtSetInformationFile(allocation information)"
                "for target returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );
        return status;
    }

    //
    // Allocate a buffer from server heap to use for the data copy.
    //

    ioBufferSize = 4096;

    ioBuffer = ALLOCATE_HEAP_COLD( ioBufferSize, BlockTypeDataBuffer );
    if ( ioBuffer == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvCopyFile: Unable to allocate %d bytes from heap.",
            ioBufferSize,
            NULL
            );

        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    //
    // Copy data--read from source, write to target.  Do this until
    // all the data is written or an error occurs.
    //

    fileOffset.QuadPart = (LONG)FILE_USE_FILE_POINTER_POSITION;

    while ( !eofFound ) {

        if ( 0 ) {
            KdPrint(( "SrvCopyFile: reading %ld (0x%lx) bytes at "
                        "offset %ld (0x%lx)\n",
                        ioBufferSize, ioBufferSize, offset, offset ));
        }

        readStatus = NtReadFile(
                         SourceHandle,
                         NULL,                // Event
                         NULL,                // ApcRoutine
                         NULL,                // ApcContext
                         &ioStatusBlock,
                         ioBuffer,
                         ioBufferSize,
                         &fileOffset,
                         NULL                 // Key
                         );

        if ( !NT_SUCCESS(readStatus) && readStatus != STATUS_END_OF_FILE ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvCopyFile: NtReadFile returned %X",
                readStatus,
                NULL
                );
            FREE_HEAP( ioBuffer );

            SrvLogServiceFailure( SRV_SVC_NT_READ_FILE, readStatus );
            return readStatus;
        }

        IF_SMB_DEBUG(FILE_CONTROL2) {
            KdPrint(( "NtReadFile:  Read %p bytes from source file\n",
                         (PVOID)ioStatusBlock.Information ));
        }
        if ( ioStatusBlock.Information == 0 ||
             readStatus == STATUS_END_OF_FILE ) {
            break;
        }

        bytesRead = (ULONG)ioStatusBlock.Information;
        if ( 0 ) {
            IO_STATUS_BLOCK iosb;

            status = NtQueryInformationFile(
                         SourceHandle,
                         &iosb,
                         &positionInfo,
                         sizeof(positionInfo),
                         FilePositionInformation
                         );

            if ( !NT_SUCCESS( status ) ) {
                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SrvCopyFile: NtQueryInformationFile returned %X",
                    status,
                    NULL
                    );

                FREE_HEAP( ioBuffer );

                SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
                return status;
            }

            if ( positionInfo.CurrentByteOffset.LowPart !=
                    offset + bytesRead ) {
                KdPrint(( "SrvCopyFile: SOURCE FILE POSITION NOT PROPERLY "
                            "UPDATED!!!\n" ));
                KdPrint(( "             expected %ld + %ld = %ld (0x%lx); ",
                            offset, bytesRead,
                            offset + bytesRead, offset + bytesRead ));
                KdPrint(( "got %ld (0x%lx)\n",
                            positionInfo.CurrentByteOffset.LowPart,
                            positionInfo.CurrentByteOffset.LowPart ));
            }
            KdPrint(( "SrvCopyFile: writing 0x%p bytes at offset %ld (0x%lx)\n",
                        (PVOID)ioStatusBlock.Information, 
                        offset, offset ));
        }

        //
        // If the source file is in ASCII mode, then search for EOF in the
        // buffer.  We copy until we hit the first EOF, at which point
        // we quit.
        //

        if ( sourceIsAscii ) {

            ULONG i;

            for ( i = 0; i < bytesRead; i++ ) {
                if ( ((PCHAR)ioBuffer)[i] == EOF ) {
                    bytesRead = i + 1;
                    eofFound = TRUE;
                    break;
                }
            }
        }

        //
        // Save the last byte read.  This is useful to make sure that
        // there is an EOF character if the target file is ASCII.
        //

        lastByte = ((PCHAR)ioBuffer)[bytesRead-1];

        writeStatus = NtWriteFile(
                          TargetHandle,
                          NULL,               // Event
                          NULL,               // ApcRoutine
                          NULL,               // ApcContext
                          &ioStatusBlock,
                          ioBuffer,
                          bytesRead,
                          &fileOffset,
                          NULL                // Key
                          );

        if ( !NT_SUCCESS(writeStatus) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvCopyFile: NtWriteFile returned %X",
                writeStatus,
                NULL
                );
            FREE_HEAP( ioBuffer );

            SrvLogServiceFailure( SRV_SVC_NT_WRITE_FILE, writeStatus );
            return writeStatus;
        }

        IF_SMB_DEBUG(FILE_CONTROL2) {
            KdPrint(( "NtWriteFile:  wrote %p bytes to target file\n",
                          (PVOID)ioStatusBlock.Information ));
        }

        if ( 0 ) {
            IO_STATUS_BLOCK iosb;
            if ( ioStatusBlock.Information != bytesRead ) {
                KdPrint(( "SrvCopyFile: WRITE COUNT MISMATCH!!!\n" ));
                KdPrint(( "             Bytes read: %ld (0x%lx); Bytes written: 0x%p \n",
                            bytesRead, bytesRead,
                            (PVOID)ioStatusBlock.Information ));
            }
            status = NtQueryInformationFile(
                        SourceHandle,
                        &iosb,
                        &positionInfo,
                        sizeof(positionInfo),
                        FilePositionInformation
                        );

            if ( !NT_SUCCESS( status ) ) {
                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SrvCopyFile: NtQueryInformationFile returned %X",
                    status,
                    NULL
                    );
                FREE_HEAP( ioBuffer );

                SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
                return status;
            }

            if ( positionInfo.CurrentByteOffset.LowPart !=
                    offset + ioStatusBlock.Information ) {

                KdPrint(( "SrvCopyFile: TARGET FILE POSITION NOT PROPERLY "
                            "UPDATED!!!\n" ));
                KdPrint(( "             expected 0x%lx + 0x%p = 0x%p; ",
                            offset, (PVOID)(ioStatusBlock.Information),
                            (PVOID)(offset + ioStatusBlock.Information) ));
                KdPrint(( "got %ld (0x%lx)\n",
                            positionInfo.CurrentByteOffset.LowPart,
                            positionInfo.CurrentByteOffset.LowPart ));
            }
        }

        offset += bytesRead;

    }

    FREE_HEAP( ioBuffer );

    //
    // If target was created or replaced, set its time to that of the source.
    //

    if ( ActionTaken == FILE_CREATED || ActionTaken == FILE_SUPERSEDED ) {

        FILE_BASIC_INFORMATION basicInfo;

        basicInfo.CreationTime = sourceNetworkOpenInformation.CreationTime;
        basicInfo.LastAccessTime = sourceNetworkOpenInformation.LastAccessTime;
        basicInfo.LastWriteTime = sourceNetworkOpenInformation.LastWriteTime;
        basicInfo.ChangeTime = sourceNetworkOpenInformation.ChangeTime;
        basicInfo.FileAttributes = sourceNetworkOpenInformation.FileAttributes;

        status = NtSetInformationFile(
                     TargetHandle,
                     &ioStatusBlock,
                     &basicInfo,
                     sizeof(basicInfo),
                     FileBasicInformation
                     );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvCopyFile: NtSetInformationFile(basic information) for"
                    "target returned %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );
            return status;
        }
    }

    //
    // If the target is ASCII and the last byte was not an EOF, then
    // put on an EOF character.
    //

    if ( targetIsAscii && lastByte != EOF ) {

        lastByte = EOF;

        status = NtWriteFile(
                     TargetHandle,
                     NULL,
                     NULL,
                     NULL,
                     &ioStatusBlock,
                     &lastByte,
                     sizeof(lastByte),
                     NULL,
                     NULL
                     );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvCopyFile: NtWriteFile returned %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_WRITE_FILE, status );
            return status;
        }
    }

    return STATUS_SUCCESS;

} // SrvCopyFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\fsddisp.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fsddisp.c

Abstract:

    This module implements the File System Driver for the LAN Manager
    server.

Author:

    David Treadwell (davidtr)    20-May-1990

Revision History:

--*/

#include "precomp.h"
#include "wmikm.h"
#include <dfsfsctl.h>
#include "fsddisp.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_FSDDISP

#define CHANGE_HEURISTIC(heuristic) \
            (newValues->HeuristicsChangeMask & SRV_HEUR_ ## heuristic) != 0

//
// LWIO Context
//
PBYTE SrvLWIOContext = NULL;
ULONG SrvLWIOContextLength = 0;
PSRV_RESUME_CONTEXT_CALLBACK SrvLWIOCallback = NULL;

// Used for WMI event tracing
//
UNICODE_STRING SrvDeviceName;
UNICODE_STRING SrvRegistryPath;
ULONG          SrvWmiInitialized  = FALSE;
ULONG          SrvWmiEnableLevel  = 0;
ULONG          SrvWmiEnableFlags  = 0;
TRACEHANDLE    LoggerHandle       = 0;

GUID SrvCounterGuid  =  /* f7c3b22a-5992-44d6-968b-d3757dbab6f7 */
{ 0xf7c3b22a, 0x5992, 0x44d6, 0x96, 0x8b, 0xd3, 0x75, 0x7d, 0xba, 0xb6, 0xf7 };
GUID SrvControlGuid  =  /* 3121cf5d-c5e6-4f37-be86-57083590c333 */
{ 0x3121cf5d, 0xc5e6, 0x4f37, 0xbe, 0x86, 0x57, 0x08, 0x35, 0x90, 0xc3, 0x33 };
GUID SrvEventGuid    =  /* e09074ae-0a98-4805-9a41-a8940af97086 */
{ 0xe09074ae, 0x0a98, 0x4805, 0x9a, 0x41, 0xa8, 0x94, 0x0a, 0xf9, 0x70, 0x86 };

WMIGUIDREGINFO SrvPerfGuidList[] =
{
  { & SrvCounterGuid, 1, 0 },
  { & SrvControlGuid, 0,   WMIREG_FLAG_TRACED_GUID
                         | WMIREG_FLAG_TRACE_CONTROL_GUID }
};

#define SrvPerfGuidCount (sizeof(SrvPerfGuidList) / sizeof(WMIGUIDREGINFO))

typedef struct _SRV_WMI_EVENT_TRACE {
    EVENT_TRACE_HEADER EventHeader;
    MOF_FIELD          MofField[3];
} SRV_WMI_EVENT_TRACE, * PSRV_WMI_EVENT_TRACE;

//
// Forward declarations
//

STATIC
NTSTATUS
SrvFsdDispatchFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
QueueConfigurationIrp (
    IN PIRP Irp,
    IN PIO_WORKITEM pIoWorkItem
    );

NTSTATUS
SrvQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );
NTSTATUS
SrvQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvFsdDispatch )
#pragma alloc_text( PAGE, SrvFsdDispatchFsControl )
#pragma alloc_text( PAGE, QueueConfigurationIrp )
#pragma alloc_text( PAGE, SrvWmiTraceEvent )
#pragma alloc_text( PAGE, SrvQueryWmiRegInfo )
#pragma alloc_text( PAGE, SrvQueryWmiDataBlock )
#pragma alloc_text( PAGE, SrvWmiDispatch )
#endif

// These 2 routines can be called at DISPATCH_LEVEL, so they are non-paged
// NONPAGED - SrvWmiStartContext
// NONPAGED - SrvWmiEndContext

void
SrvWmiInitContext(
    PWORK_CONTEXT WorkContext
    )
{
    if (!SrvWmiInitialized || !(SrvWmiEnableFlags == SRV_WMI_FLAG_CAPACITY)) {
        return;
    }

    if ( SRV_WMI_LEVEL( SPARSE ) ) {
        WorkContext->PreviousSMB          = EVENT_TYPE_SMB_LAST_EVENT;
        WorkContext->bAlreadyTrace        = FALSE;
        WorkContext->ElapseKCPU           = 0;
        WorkContext->ElapseUCPU           = 0;
        WorkContext->FileNameSize         = 0;
        WorkContext->ClientAddr           = 0;
        WorkContext->FileObject           = NULL;
        WorkContext->G_StartTime.QuadPart =
                        (ULONGLONG) WmiGetClock(WMICT_DEFAULT, NULL);
    }
}

void
SrvWmiStartContext(
    PWORK_CONTEXT   WorkContext
    )
{
    LARGE_INTEGER ThreadTime;

    if (!SrvWmiInitialized || !(SrvWmiEnableFlags == SRV_WMI_FLAG_CAPACITY)) {
        return;
    }

    if ( SRV_WMI_LEVEL( SPARSE ) ) {
        if (WorkContext->G_StartTime.QuadPart == 0) {
            WorkContext->G_StartTime.QuadPart =
                            (ULONGLONG) WmiGetClock(WMICT_DEFAULT, NULL);
        }
    }

    if ( SRV_WMI_LEVEL( VERBOSE ) ) {
        ThreadTime.QuadPart    = (ULONGLONG) WmiGetClock(WMICT_THREAD, NULL);
        WorkContext->KCPUStart = ThreadTime.HighPart;
        WorkContext->UCPUStart = ThreadTime.LowPart;
    }
}

void
SrvWmiEndContext(
    PWORK_CONTEXT   WorkContext
    )
{
    LARGE_INTEGER     TimeEnd;
    BOOL NotDispatch = (KeGetCurrentIrql() < DISPATCH_LEVEL);

    if (!SrvWmiInitialized || !(SrvWmiEnableFlags == SRV_WMI_FLAG_CAPACITY)) {
        return;
    }

    if ( SRV_WMI_LEVEL( SPARSE ) ) {
        if ( NotDispatch && WorkContext && WorkContext->Rfcb && WorkContext->Rfcb->Lfcb) {
            WorkContext->FileObject = WorkContext->Rfcb->Lfcb->FileObject;
        }
    }

    if ( SRV_WMI_LEVEL( VERBOSE ) ) {
        TimeEnd.QuadPart        = (ULONGLONG) WmiGetClock(WMICT_THREAD, NULL);
        WorkContext->ElapseKCPU = TimeEnd.HighPart - WorkContext->KCPUStart;
        WorkContext->ElapseUCPU = TimeEnd.LowPart  - WorkContext->UCPUStart;

        if( NotDispatch )
        {
            if (WorkContext && WorkContext->Rfcb
                            && WorkContext->Rfcb->Lfcb
                            && WorkContext->Rfcb->Lfcb->Mfcb
                            && WorkContext->Rfcb->Lfcb->Mfcb->FileName.Buffer
                            && WorkContext->Rfcb->Lfcb->Mfcb->FileName.Length > 0)
            {
                LPWSTR strFileName = WorkContext->Rfcb->Lfcb->Mfcb->FileName.Buffer;
                WorkContext->FileNameSize =
                        (USHORT) ((wcslen(strFileName) + 1) * sizeof(WCHAR));
                if (WorkContext->FileNameSize > 1024 * sizeof(WCHAR)) {
                    WorkContext->FileNameSize = 1024 * sizeof(WCHAR);
                }
                RtlCopyMemory(WorkContext->strFileName,
                              strFileName,
                              WorkContext->FileNameSize);
                WorkContext->strFileName[1023] = L'\0';
            }
        }
        else
        {
            WorkContext->strFileName[0] = L'\0';
        }
    }
}

void
SrvWmiTraceEvent(
    PWORK_CONTEXT WorkContext
    )
{

    PAGED_CODE();

    if (!SrvWmiInitialized || !(SrvWmiEnableFlags == SRV_WMI_FLAG_CAPACITY)) {
        return;
    }

    if ( SRV_WMI_LEVEL( SPARSE ) ) {
        NTSTATUS             status;
        SRV_WMI_EVENT_TRACE  Wnode;

        if (WorkContext->PreviousSMB >= EVENT_TYPE_SMB_LAST_EVENT) {
            return;
        }

        if (WorkContext->Connection->DirectHostIpx) {
            WorkContext->ClientAddr =
                    WorkContext->Connection->IpxAddress.NetworkAddress;
        }
        else {
            WorkContext->ClientAddr =
                    WorkContext->Connection->ClientIPAddress;
        }

        RtlZeroMemory(& Wnode, sizeof(SRV_WMI_EVENT_TRACE));
        if (WorkContext->FileNameSize > 0) {
            Wnode.EventHeader.Size = sizeof(SRV_WMI_EVENT_TRACE);
        }
        else {
            Wnode.EventHeader.Size = sizeof(EVENT_TRACE_HEADER)
                                   + sizeof(MOF_FIELD);
        }
        Wnode.EventHeader.Flags      = WNODE_FLAG_TRACED_GUID
                                     | WNODE_FLAG_USE_GUID_PTR
                                     | WNODE_FLAG_USE_MOF_PTR;
        Wnode.EventHeader.GuidPtr    = (ULONGLONG) & SrvEventGuid;
        Wnode.EventHeader.Class.Type = WorkContext->PreviousSMB;

        ((PWNODE_HEADER) (& Wnode.EventHeader))->HistoricalContext =
                        LoggerHandle;

        Wnode.MofField[0].Length  = sizeof(LARGE_INTEGER) // G_StartTime
                                  + sizeof(ULONG)         // ElapseKCPU
                                  + sizeof(ULONG)         // ElapseUCPU
                                  + sizeof(ULONG)         // ClientAddr
                                  + sizeof(PFILE_OBJECT); // FileObject
        Wnode.MofField[0].DataPtr = (ULONGLONG) (& WorkContext->G_StartTime);

        if (WorkContext->FileNameSize > 0) {
            Wnode.MofField[1].Length  = sizeof(USHORT);
            Wnode.MofField[1].DataPtr =
                            (ULONGLONG) (& WorkContext->FileNameSize);
            Wnode.MofField[2].Length  = WorkContext->FileNameSize;
            Wnode.MofField[2].DataPtr =
                            (ULONGLONG) (WorkContext->strFileName);
        }

        // Call TraceLogger to  write this event
        //
        status = IoWMIWriteEvent((PVOID) & Wnode);
        if (!NT_SUCCESS(status)) {
            DbgPrint("SrvWmiTraceEvent(0x%08X,%d) fails 0x%08X\n",
                            WorkContext, WorkContext->PreviousSMB, status);
        }
    }
}

NTSTATUS
SrvQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned unmodified. If a value is returned then
        it is NOT freed.
        The MOF file is assumed to be already included in wmicore.mof

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION pDeviceExtension = (PDEVICE_EXTENSION)
                                         DeviceObject->DeviceExtension;
    PAGED_CODE();

    if (! SrvWmiInitialized) {
        return STATUS_DEVICE_NOT_READY;
    }

    pDeviceExtension->TestCounter ++;

    * RegFlags     = WMIREG_FLAG_EXPENSIVE;
    InstanceName->MaximumLength = SrvDeviceName.Length
                                + sizeof(UNICODE_NULL);
    InstanceName->Buffer = ExAllocatePool(PagedPool,
                                          InstanceName->MaximumLength);
    if (InstanceName->Buffer != NULL) {
        InstanceName->Length = InstanceName->MaximumLength
                             - sizeof(UNICODE_NULL);
        RtlCopyUnicodeString(InstanceName, & SrvDeviceName);
    }
    else {
        InstanceName->MaximumLength = InstanceName->Length = 0;
    }

    MofResourceName->MaximumLength = 0;
    MofResourceName->Length        = 0;
    MofResourceName->Buffer        = NULL;

    * RegistryPath = & SrvRegistryPath;

    return STATUS_SUCCESS;
}

NTSTATUS
SrvQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. When the driver has finished filling the
    data block it must call WmiCompleteRequest to complete the irp. The
    driver can return STATUS_PENDING if the irp cannot be completed
    immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry.


Return Value:

    status

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION pDeviceExtension = (PDEVICE_EXTENSION)
                                         DeviceObject->DeviceExtension;
    ULONG SizeNeeded = sizeof(ULONG);

    PAGED_CODE();

    if (! SrvWmiInitialized) {
        return STATUS_DEVICE_NOT_READY;
    }

    pDeviceExtension->TestCounter ++;

    if (GuidIndex == 0) {
        * InstanceLengthArray = SizeNeeded;
        * ((PULONG) Buffer)   = pDeviceExtension->TestCounter;
    }
    else {
        Status = STATUS_WMI_GUID_NOT_FOUND;
    }

    Status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                Status,
                                SizeNeeded,
                                IO_NO_INCREMENT);
    return Status;
}

NTSTATUS
SrvWmiDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION irpSp      = IoGetCurrentIrpStackLocation(Irp);
    ULONG              BufferSize = irpSp->Parameters.WMI.BufferSize;
    PVOID              Buffer     = irpSp->Parameters.WMI.Buffer;
    ULONG              ReturnSize = 0;
    NTSTATUS           Status     = STATUS_SUCCESS;
    PWNODE_HEADER      pWnode     = NULL;
    PDEVICE_EXTENSION  pDeviceExtension = (PDEVICE_EXTENSION)
                                          DeviceObject->DeviceExtension;
    SYSCTL_IRP_DISPOSITION disposition;

    PAGED_CODE();

    switch (irpSp->MinorFunction) {
    case IRP_MN_ENABLE_EVENTS:
        pWnode = (PWNODE_HEADER) Buffer;
        if (BufferSize >= sizeof(WNODE_HEADER)) {
            LoggerHandle = pWnode->HistoricalContext;
            InterlockedExchange(& SrvWmiEnableLevel,
                    ((PTRACE_ENABLE_CONTEXT) (& LoggerHandle))->Level + 1);
            InterlockedExchange(& SrvWmiEnableFlags,
                    ((PTRACE_ENABLE_CONTEXT) (& LoggerHandle))->EnableFlags );
        }
        Irp->IoStatus.Status      = Status;
        Irp->IoStatus.Information = ReturnSize;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;

    case IRP_MN_DISABLE_EVENTS:
        InterlockedExchange(& SrvWmiEnableLevel, 0);
        LoggerHandle = 0;
        Irp->IoStatus.Status      = Status;
        Irp->IoStatus.Information = ReturnSize;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;

    default:
        Status = WmiSystemControl(& pDeviceExtension->WmiLibContext,
                                    DeviceObject,
                                    Irp,
                                  & disposition);
        switch(disposition) {
        case IrpProcessed:
            break;

        case IrpNotCompleted:
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;

        case IrpForward:
        case IrpNotWmi:
        default:
            ASSERT(FALSE);
            Irp->IoStatus.Status = Status = STATUS_NOT_SUPPORTED;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }
        break;
    }
    return Status;
}


NTSTATUS
SrvFsdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for the LAN Manager server FSD.  At the
    present time, the server FSD does not accept any I/O requests.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp;
    PIO_WORKITEM pWorkItem;

    PAGED_CODE( );

    DeviceObject;   // prevent compiler warnings

    if( SrvSvcProcess == NULL &&
        SeSinglePrivilegeCheck( SeExports->SeLoadDriverPrivilege, Irp->RequestorMode ) ) {

        //
        // This is the first fsctl to the server from a process having
        //  driver load/unload privileges -- it must be from
        //  the service controller.  Remember the process id of the
        //  service controller to validate future fsctls
        //

        SrvSvcProcess = IoGetCurrentProcess();
    }

    irpSp = IoGetCurrentIrpStackLocation( Irp );

#if defined( _WIN64 )
    // There is no reason for us to support downlevel clients because all communication with the
    // server (that is not network packets) goes through the Server Service via RPC resulting in
    // it being serialized and interpreted correctly.  If we get IOCTL's called directly, it must
    // be a hack attempt, so we're free to turn it away.

    // It ends up we do need to support some 32-bit functionality for old perf monitoring utilities.  Allow
    // through Create,Cleanup,Close, and the GetStatistics FSCTL's.
    if ( IoIs32bitProcess( Irp ) )
    {
        switch( irpSp->MajorFunction )
        {
        case IRP_MJ_CREATE:
        case IRP_MJ_CLEANUP:
        case IRP_MJ_CLOSE:
            break;

        case IRP_MJ_FILE_SYSTEM_CONTROL:
            {
                if( !( (irpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_SRV_GET_STATISTICS) ||
                       (irpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_SRV_GET_QUEUE_STATISTICS) ) )
                {
                    status = STATUS_NOT_SUPPORTED;
                    Irp->IoStatus.Status = status;
                    IoCompleteRequest( Irp, 2 );
                    return status;
                }
            }
            break;

        default:
            {
                status = STATUS_NOT_SUPPORTED;
                Irp->IoStatus.Status = status;
                IoCompleteRequest( Irp, 2 );
                return status;
            }

        }
    }
#endif

    switch ( irpSp->MajorFunction ) {

    case IRP_MJ_CREATE:

        FsRtlEnterFileSystem();
        ACQUIRE_LOCK( &SrvConfigurationLock );

        do {

            if( SrvOpenCount == 0 ) {
                //
                // This is the first open.  Let's not allow it if the server
                // seems to be in a weird state.
                //
                if( SrvFspActive != FALSE || SrvFspTransitioning != FALSE ) {
                    //
                    // How can this be?  Better not let anybody in, since we're sick
                    //
                    status = STATUS_ACCESS_DENIED;
                    break;
                }

            } else if( SrvFspActive && SrvFspTransitioning ) {
                //
                // We currently have some open handles, but
                // we are in the middle of terminating. Don't let new
                // opens in
                //
                status = STATUS_ACCESS_DENIED;
                break;
            }

            SrvOpenCount++;

        } while( 0 );

        RELEASE_LOCK( &SrvConfigurationLock );
        FsRtlExitFileSystem();

        break;

    case IRP_MJ_CLEANUP:

        break;

    case IRP_MJ_CLOSE:
        FsRtlEnterFileSystem();
        ACQUIRE_LOCK( &SrvConfigurationLock );
        if( --SrvOpenCount == 0 ) {
            if( SrvFspActive && !SrvFspTransitioning ) {
                //
                // Uh oh.  This is our last close, and we think
                //  we're still running.  We can't run sensibly
                //  without srvsvc to help out.  Suicide time!
                //
                pWorkItem = IoAllocateWorkItem( SrvDeviceObject );
                if( !pWorkItem )
                {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    RELEASE_LOCK( &SrvConfigurationLock );
                    FsRtlExitFileSystem();
                    goto exit;
                }

                SrvXsActive = FALSE;
                SrvFspTransitioning = TRUE;
                IoMarkIrpPending( Irp );
                QueueConfigurationIrp( Irp, pWorkItem );
                RELEASE_LOCK( &SrvConfigurationLock );
                status = STATUS_PENDING;
                FsRtlExitFileSystem();
                goto exit;
            }
        }
        RELEASE_LOCK( &SrvConfigurationLock );
        FsRtlExitFileSystem();
        break;

    case IRP_MJ_FILE_SYSTEM_CONTROL:

        status = SrvFsdDispatchFsControl( DeviceObject, Irp, irpSp );
        goto exit;

    case IRP_MJ_SYSTEM_CONTROL:
        if (SrvWmiInitialized) {
            status = SrvWmiDispatch(DeviceObject, Irp);
            goto exit;
        }
        // else fall through default processing
        //

    default:

        IF_DEBUG(ERRORS) {
            SrvPrint1(
                "SrvFsdDispatch: Invalid major function %lx\n",
                irpSp->MajorFunction
                );
        }
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, 2 );

exit:

    return status;

} // SrvFsdDispatch


NTSTATUS
SrvFsdDispatchFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine handles device IO control requests to the server,
    including starting the server, stopping the server, and more.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

    IrpSp - Pointer to the current IRP stack location

Return Value:

    NTSTATUS -- Indicates whether the request was successfully handled.

--*/

{
    NTSTATUS status;
    ULONG code;
    PIO_WORKITEM pWorkItem;

    DeviceObject;   // prevent compiler warnings

    //
    // Initialize the I/O status block.
    //

    Irp->IoStatus.Status = STATUS_PENDING;
    Irp->IoStatus.Information = 0;

    FsRtlEnterFileSystem();

    //
    // Process the request if possible.
    //

    code = IrpSp->Parameters.FileSystemControl.FsControlCode;

    //
    // Only the serice controller can issue most of the FSCTL requests.
    //
    if( Irp->RequestorMode != KernelMode &&
        IoGetCurrentProcess() != SrvSvcProcess ) {

        if( code != FSCTL_SRV_SEND_DATAGRAM &&
            code != FSCTL_SRV_GET_QUEUE_STATISTICS &&
            code != FSCTL_SRV_GET_STATISTICS &&
            code != FSCTL_SRV_IPX_SMART_CARD_START &&
            code != FSCTL_SRV_GET_CHALLENGE &&
            code != FSCTL_SRV_INTERNAL_TEST_REAUTH &&
            code != FSCTL_SRV_QUERY_LWIO_CONTEXT &&
            code != FSCTL_SRV_SET_LWIO_CONTEXT &&
            code != FSCTL_SRV_REQUEST_HANDLE_DUP &&
            code != FSCTL_DFS_UPDATE_SHARE_TABLE &&
            code != FSCTL_DFS_RELEASE_SHARE_TABLE ) {

            status = STATUS_ACCESS_DENIED;
            goto exit_without_lock;
        }
    }

    //
    // Acquire the configuration lock.
    //
    ACQUIRE_LOCK( &SrvConfigurationLock );

    switch ( code ) {

    case FSCTL_SRV_STARTUP: {

        PSERVER_REQUEST_PACKET srp;
        ULONG srpLength;
        PVOID inputBuffer;
        ULONG inputBufferLength;
        PMDL InputMdl = NULL;

        PDEVICE_EXTENSION pDeviceExtension;
        PWMILIB_CONTEXT   pWmiLibContext;

        //
        // Get a pointer to the SRP that describes the set info request
        // for the startup server configuration, and the buffer that
        // contains this information.
        //

        srp = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
        srpLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
        inputBuffer = Irp->UserBuffer;
        inputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

        //
        // If the server FSP is already started, or is in the process of
        // starting up, reject this request.
        //

        if ( SrvFspActive || SrvFspTransitioning ) {

            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP already started.\n" );
            //}

            try {
                status = STATUS_SUCCESS;
                srp->ErrorCode = NERR_ServiceInstalled;
            }
            except( EXCEPTION_EXECUTE_HANDLER )
            {
                status = STATUS_INVALID_PARAMETER;
            }
            goto exit_with_lock;
        }

        //
        // Make sure that the buffer was large enough to be an SRP.
        //

        if ( srpLength < sizeof(SERVER_REQUEST_PACKET) ) {
            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        // SRP is unused by the below routine.  Remove its parsing to lower attack surface

        //
        // Lets lock the input data into memory
        //
        InputMdl = IoAllocateMdl( inputBuffer, inputBufferLength, FALSE, TRUE, NULL );
        if( InputMdl == NULL )
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit_with_lock;
        }

        try {
            MmProbeAndLockPages( InputMdl, Irp->RequestorMode, IoReadAccess );
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            status = STATUS_INVALID_PARAMETER;
            IoFreeMdl( InputMdl );
            goto exit_with_lock;
        }

        //
        // Call SrvNetServerSetInfo to set the initial server configuration
        // information.
        //

        status = SrvNetServerSetInfo(
                     NULL,
                     inputBuffer,
                     inputBufferLength
                     );

        MmUnlockPages( InputMdl );
        IoFreeMdl( InputMdl );

        //
        // Indicate that the server is starting up.  This prevents
        // further startup requests from being issued.
        //

        SrvFspTransitioning = TRUE;

        // Setup device extension for Perf counter registration and register
        // with WMI here
        //
        pDeviceExtension = (PDEVICE_EXTENSION) SrvDeviceObject->DeviceExtension;
        RtlZeroMemory(pDeviceExtension, sizeof(DEVICE_EXTENSION));
        pDeviceExtension->pDeviceObject = SrvDeviceObject;

        pWmiLibContext = & pDeviceExtension->WmiLibContext;
        RtlZeroMemory(pWmiLibContext, sizeof(WMILIB_CONTEXT));
        pWmiLibContext->GuidCount         = SrvPerfGuidCount;
        pWmiLibContext->GuidList          = SrvPerfGuidList;
        pWmiLibContext->QueryWmiDataBlock = SrvQueryWmiDataBlock;
        pWmiLibContext->QueryWmiRegInfo   = SrvQueryWmiRegInfo;

        SrvWmiInitialized = TRUE;
        status = IoWMIRegistrationControl(
                        SrvDeviceObject, WMIREG_ACTION_REGISTER);
        if (!NT_SUCCESS(status)) {
            DbgPrint("SRV: Failed to register for WMI support\n");
        }

        break;
    }

    case FSCTL_SRV_SHUTDOWN: {

        //
        // If the server is not running, or if it is in the process
        // of shutting down, ignore this request.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {

            //
            // If there is more than one handle open to the server
            // device (i.e., any handles other than the server service's
            // handle), return a special status code to the caller (who
            // should be the server service).  This tells the caller to
            // NOT unload the driver, in order prevent weird situations
            // where the driver is sort of unloaded, so it can't be used
            // but also can't be reloaded, thus preventing the server
            // from being restarted.
            //

            if ( SrvOpenCount != 1 ) {
                status = STATUS_SERVER_HAS_OPEN_HANDLES;
            } else {
                status = STATUS_SUCCESS;
            }

            goto exit_with_lock;

        }

        //
        // Indicate that the server is shutting down.  This prevents
        // further requests from being issued until the server is
        // restarted.
        //

        SrvFspTransitioning = TRUE;

        break;
    }

    case FSCTL_SRV_REGISTRY_CHANGE:
    case FSCTL_SRV_BEGIN_PNP_NOTIFICATIONS:
    case FSCTL_SRV_XACTSRV_CONNECT:
    {
        if( !SrvFspActive || SrvFspTransitioning ) {
            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP not started.\n" );
            //}
            status = STATUS_SERVER_NOT_STARTED;
            goto exit_with_lock;
        }
        break;
    }
    case FSCTL_SRV_XACTSRV_DISCONNECT: {

        //
        // If the server is not running, or if it is in the process
        // of shutting down, ignore this request.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {

            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP not started.\n" );
            //}

            status = STATUS_SUCCESS;
            goto exit_with_lock;
        }

        break;
    }

    case FSCTL_SRV_IPX_SMART_CARD_START: {

        //
        // If the server is not running, or if it is in the process of
        //  shutting down, ignore this request.
        //
        if( !SrvFspActive || SrvFspTransitioning ) {
            status = STATUS_SERVER_NOT_STARTED;
            goto exit_with_lock;
        }

        //
        // Make sure the caller is a driver
        //
        if( Irp->RequestorMode != KernelMode ) {
            status = STATUS_ACCESS_DENIED;
            goto exit_with_lock;
        }

        //
        // Make sure the buffer is big enough
        //
        if( IrpSp->Parameters.FileSystemControl.InputBufferLength <
            sizeof( SrvIpxSmartCard ) ) {

            status = STATUS_BUFFER_TOO_SMALL;
            goto exit_with_lock;
        }

        if( SrvIpxSmartCard.Open == NULL ) {

            PSRV_IPX_SMART_CARD pSipx;

            //
            // Load up the pointers
            //

            pSipx = (PSRV_IPX_SMART_CARD)(Irp->AssociatedIrp.SystemBuffer);

            if( pSipx == NULL ) {
                status = STATUS_INVALID_PARAMETER;
                goto exit_with_lock;
            }

            if( pSipx->Read && pSipx->Close && pSipx->DeRegister && pSipx->Open ) {

                IF_DEBUG( SIPX ) {
                    KdPrint(( "Accepting entry points for IPX Smart Card:\n" ));
                    KdPrint(( "    Open %p, Read %p, Close %p, DeRegister %p",
                                SrvIpxSmartCard.Open,
                                SrvIpxSmartCard.Read,
                                SrvIpxSmartCard.Close,
                                SrvIpxSmartCard.DeRegister
                            ));
                }

                //
                // First set our entry point
                //
                pSipx->ReadComplete = SrvIpxSmartCardReadComplete;

                //
                // Now accept the card's entry points.
                //
                SrvIpxSmartCard.Read = pSipx->Read;
                SrvIpxSmartCard.Close= pSipx->Close;
                SrvIpxSmartCard.DeRegister = pSipx->DeRegister;
                SrvIpxSmartCard.Open = pSipx->Open;

                status = STATUS_SUCCESS;
            } else {
                status = STATUS_INVALID_PARAMETER;
            }

        } else {

            status = STATUS_DEVICE_ALREADY_ATTACHED;
        }

        goto exit_with_lock;

        break;
    }

    case FSCTL_SRV_SEND_DATAGRAM:
    {
        PVOID systemBuffer;
        ULONG systemBufferLength;
        PVOID buffer1;
        ULONG buffer1Length;
        PVOID buffer2;
        ULONG buffer2Length;
        PSERVER_REQUEST_PACKET srp;

        //
        // Ignore this request if the server is not active.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {
            status = STATUS_SUCCESS;
            goto exit_with_lock;
        }


        //
        // Determine the input buffer lengths, and make sure that the
        // first buffer is large enough to be an SRP.
        //

        buffer1Length = IrpSp->Parameters.FileSystemControl.InputBufferLength;
        buffer2Length = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

        //
        // Make sure that the buffer was large enough to be a SRP.
        //
        if ( buffer1Length < sizeof(SERVER_REQUEST_PACKET) ) {
            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        // Make sure the lengths are nominally reasonable.
        //
        if( buffer1Length >= MAXUSHORT ||
            buffer2Length >= MAXUSHORT ) {

            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        //
        // Make the first buffer size is properly aligned so that the second
        // buffer will be aligned as well.
        //

        buffer1Length = ALIGN_UP( buffer1Length, PVOID );
        systemBufferLength = buffer1Length + buffer2Length;

        //
        // Make sure the lengths are nominally reasonable.
        //
        if( buffer1Length >= MAXUSHORT ||
            buffer2Length >= MAXUSHORT ||
            systemBufferLength == 0 ) {

            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        if( Irp->RequestorMode != KernelMode ) {
            try {

                ProbeForRead( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                              buffer1Length, sizeof( CHAR )
                            );

                if( buffer2Length ) {
                    ProbeForRead( Irp->UserBuffer, buffer2Length, sizeof( CHAR ) );
                }

            } except( EXCEPTION_EXECUTE_HANDLER ) {
                status = GetExceptionCode();
                goto exit_with_lock;
            }
        }

        //
        // Allocate a single buffer that will hold both input buffers.
        //

        systemBuffer = ExAllocatePoolWithTagPriority( PagedPool, systemBufferLength, TAG_FROM_TYPE(BlockTypeMisc), LowPoolPriority );

        if ( systemBuffer == NULL ) {
            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto exit_with_lock;
        }

        buffer1 = systemBuffer;
        buffer2 = (PCHAR)systemBuffer + buffer1Length;

        //
        // Copy the information into the buffers.
        //

        try {

            RtlCopyMemory(
                buffer1,
                IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                IrpSp->Parameters.FileSystemControl.InputBufferLength
                );
            if ( buffer2Length > 0 ) {
                RtlCopyMemory( buffer2, Irp->UserBuffer, buffer2Length );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {
            status = GetExceptionCode();
            ExFreePool( buffer1 );
            goto exit_with_lock;
        }

        //
        // If a name was specified in the SRP, the buffer field will
        // contain an offset rather than a pointer.  Convert the offset
        // to a pointer and verify that that it is a legal pointer.
        //

        srp = buffer1;

        OFFSET_TO_POINTER( srp->Name1.Buffer, srp );

        if ( !POINTER_IS_VALID( srp->Name1.Buffer, srp, buffer1Length ) ) {
            status = STATUS_ACCESS_VIOLATION;
            ExFreePool( buffer1 );
            goto exit_with_lock;
        }

        OFFSET_TO_POINTER( srp->Name2.Buffer, srp );

        if ( !POINTER_IS_VALID( srp->Name2.Buffer, srp, buffer1Length ) ) {
            status = STATUS_ACCESS_VIOLATION;
            ExFreePool( buffer1 );
            goto exit_with_lock;
        }

        Irp->AssociatedIrp.SystemBuffer = systemBuffer;

        break;
    }

    case FSCTL_SRV_CHANGE_DOMAIN_NAME:
    {
        ULONG srpLength;
        PSERVER_REQUEST_PACKET srp;
        PSHARE share;
        PLIST_ENTRY listEntry;
        PENDPOINT endpoint;

        if ( !SrvFspActive || SrvFspTransitioning ) {
            status = STATUS_SUCCESS;
            goto exit_with_lock;
        }

        srp = Irp->AssociatedIrp.SystemBuffer;
        srpLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

        //
        // Make sure that the buffer was large enough to be a SRP.
        //

        if ( srpLength < sizeof(SERVER_REQUEST_PACKET) ||
             srp->Name1.Length == 0) {

            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        //
        // Adjust the buffer pointer to the srp address
        //
        (UINT_PTR) (srp->Name1.Buffer) += (UINT_PTR) srp;
        (UINT_PTR) (srp->Name2.Buffer) += (UINT_PTR) srp;

        if( (PCHAR) (srp->Name1.Buffer) < (PCHAR) srp ||
            srp->Name1.Length > srpLength ||
            (PCHAR) (srp->Name1.Buffer) > (PCHAR)srp + srpLength - srp->Name1.Length ||
            (((UINT_PTR)(srp->Name1.Buffer) & ((sizeof(WCHAR)) - 1)) != 0) ) {

            status = STATUS_ACCESS_VIOLATION;
            goto exit_with_lock;
        }

        if( (PCHAR) (srp->Name2.Buffer) < (PCHAR) srp ||
            srp->Name2.Length > srpLength ||
            (PCHAR) (srp->Name2.Buffer) > (PCHAR)srp + srpLength - srp->Name2.Length ||
            (((UINT_PTR)(srp->Name2.Buffer) & ((sizeof(WCHAR)) - 1)) != 0) ) {

            status = STATUS_ACCESS_VIOLATION;
            goto exit_with_lock;
        }

        //
        // Run the endpoints and change the domain name for any endpoint having
        //  the original domain name.  Note that the endpoint's domain name string buffers
        //  have already been allocated to the largest possible domain name.
        //
        ACQUIRE_LOCK( &SrvEndpointLock );

        for(    listEntry = SrvEndpointList.ListHead.Flink;
                listEntry != &SrvEndpointList.ListHead;
                listEntry = listEntry->Flink
            ) {

            endpoint = CONTAINING_RECORD(
                            listEntry,
                            ENDPOINT,
                            GlobalEndpointListEntry
                            );

            if( GET_BLOCK_STATE(endpoint) == BlockStateActive ) {

                if( RtlEqualUnicodeString( &srp->Name1, &endpoint->DomainName, TRUE ) ) {

                    //
                    // Update the UNICODE domain name string
                    //
                    RtlCopyUnicodeString( &endpoint->DomainName, &srp->Name2 );

                    //
                    // Update the Oem domain name string
                    //
                    endpoint->OemDomainName.Length =
                                (SHORT)RtlUnicodeStringToOemSize( &endpoint->DomainName );

                    ASSERT( endpoint->OemDomainName.Length <=
                            endpoint->OemDomainName.MaximumLength );

                    RtlUnicodeStringToOemString(
                                &endpoint->OemDomainName,
                                &endpoint->DomainName,
                                FALSE                   // no allocate
                                );
                }
            }
        }

        RELEASE_LOCK( &SrvEndpointLock );

        break;
    }

    case FSCTL_SRV_CHANGE_DNS_DOMAIN_NAME:
    {
        ULONG srpLength;
        PSERVER_REQUEST_PACKET srp;
        PSHARE share;
        PLIST_ENTRY listEntry;
        PENDPOINT endpoint;
        PUNICODE_STRING pStr;

        if ( !SrvFspActive || SrvFspTransitioning ) {
            status = STATUS_SUCCESS;
            goto exit_with_lock;
        }

        srp = Irp->AssociatedIrp.SystemBuffer;
        srpLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

        //
        // Make sure that the buffer was large enough to be a SRP.
        //

        if ( srpLength < sizeof(SERVER_REQUEST_PACKET) ||
             srp->Name1.Length == 0) {

            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        //
        // Adjust the buffer pointer to the srp address
        //
        (UINT_PTR) (srp->Name1.Buffer) += (UINT_PTR) srp;
        (UINT_PTR) (srp->Name2.Buffer) += (UINT_PTR) srp;

        if( (PCHAR) (srp->Name1.Buffer) < (PCHAR) srp ||
            srp->Name1.Length > srpLength ||
            (PCHAR) (srp->Name1.Buffer) > (PCHAR)srp + srpLength - srp->Name1.Length ||
            (((UINT_PTR)(srp->Name1.Buffer) & ((sizeof(WCHAR)) - 1)) != 0) ) {

            status = STATUS_ACCESS_VIOLATION;
            goto exit_with_lock;
        }

        if( (PCHAR) (srp->Name2.Buffer) < (PCHAR) srp ||
            srp->Name2.Length > srpLength ||
            (PCHAR) (srp->Name2.Buffer) > (PCHAR)srp + srpLength - srp->Name2.Length ||
            (((UINT_PTR)(srp->Name2.Buffer) & ((sizeof(WCHAR)) - 1)) != 0) ) {

            status = STATUS_ACCESS_VIOLATION;
            goto exit_with_lock;
        }

        if( RtlEqualUnicodeString( &srp->Name1, &srp->Name2, TRUE ) )
        {
            // The DNS name is equal to the Netbios name, so avoid the check
            ACQUIRE_LOCK( &SrvEndpointLock );

            if( SrvDnsDomainName )
            {
                DEALLOCATE_NONPAGED_POOL( SrvDnsDomainName );
                SrvDnsDomainName = NULL;
            }

            RELEASE_LOCK( &SrvEndpointLock );

            status = STATUS_SUCCESS;
        }
        else
        {
            //
            // Change the DNS domain name
            //
            pStr = (PUNICODE_STRING)ALLOCATE_NONPAGED_POOL( sizeof(UNICODE_STRING) + srp->Name2.Length, BlockTypeMisc );
            if( !pStr )
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit_with_lock;
            }

            pStr->MaximumLength = pStr->Length = srp->Name2.Length;
            pStr->Buffer = (PWSTR)(pStr+1);
            RtlCopyMemory( pStr->Buffer, srp->Name2.Buffer, srp->Name2.Length );

            ACQUIRE_LOCK( &SrvEndpointLock );

            if( SrvDnsDomainName )
            {
                DEALLOCATE_NONPAGED_POOL( SrvDnsDomainName );
            }

            SrvDnsDomainName = pStr;

            RELEASE_LOCK( &SrvEndpointLock );

            status = STATUS_SUCCESS;
        }

        break;
    }

    case FSCTL_SRV_GET_QUEUE_STATISTICS:
    {
        PSRV_QUEUE_STATISTICS qstats;
        SRV_QUEUE_STATISTICS  tmpqstats;
        PWORK_QUEUE queue;
        LONG timeIncrement = (LONG)KeQueryTimeIncrement();

        //
        // Make sure the server is active.
        //
        if ( !SrvFspActive || SrvFspTransitioning ) {

            status = STATUS_SERVER_NOT_STARTED;
            goto exit_with_lock;
        }

        if ( IrpSp->Parameters.FileSystemControl.OutputBufferLength <
                 (SrvNumberOfProcessors+1) * sizeof( *qstats ) ) {

            status = STATUS_BUFFER_TOO_SMALL;
            goto exit_with_lock;
        }

        qstats = Irp->AssociatedIrp.SystemBuffer;

        //
        // Get the data for the normal processor queues
        //
        for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++, qstats++ ) {

            tmpqstats.QueueLength      = KeReadStateQueue( &queue->Queue );
            tmpqstats.ActiveThreads    = queue->Threads - queue->AvailableThreads;
            tmpqstats.AvailableThreads = queue->Threads;
            tmpqstats.FreeWorkItems    = queue->FreeWorkItems;                 // no lock!
            tmpqstats.StolenWorkItems  = queue->StolenWorkItems;               // no lock!
            tmpqstats.NeedWorkItem     = queue->NeedWorkItem;
            tmpqstats.CurrentClients   = queue->CurrentClients;

            tmpqstats.BytesReceived.QuadPart    = queue->stats.BytesReceived;
            tmpqstats.BytesSent.QuadPart        = queue->stats.BytesSent;
            tmpqstats.ReadOperations.QuadPart   = queue->stats.ReadOperations;
            tmpqstats.BytesRead.QuadPart        = queue->stats.BytesRead;
            tmpqstats.WriteOperations.QuadPart  = queue->stats.WriteOperations;
            tmpqstats.BytesWritten.QuadPart     = queue->stats.BytesWritten;
            tmpqstats.TotalWorkContextBlocksQueued = queue->stats.WorkItemsQueued;
            tmpqstats.TotalWorkContextBlocksQueued.Count *= STATISTICS_SMB_INTERVAL;
            tmpqstats.TotalWorkContextBlocksQueued.Time.QuadPart *= timeIncrement;

            RtlCopyMemory( qstats, &tmpqstats, sizeof(tmpqstats) );
        }

        //
        // Get the data for the blocking work queue
        //

        RtlZeroMemory( &tmpqstats, sizeof(tmpqstats) );

        for( queue = SrvBlockingWorkQueues; queue < eSrvBlockingWorkQueues; queue++ )
        {
            tmpqstats.QueueLength += KeReadStateQueue( &queue->Queue );
            tmpqstats.ActiveThreads += queue->Threads - queue->AvailableThreads;
            tmpqstats.AvailableThreads += queue->AvailableThreads;
            tmpqstats.BytesReceived.QuadPart += queue->stats.BytesReceived;
            tmpqstats.BytesSent.QuadPart += queue->stats.BytesSent;
            tmpqstats.ReadOperations.QuadPart += queue->stats.ReadOperations;
            tmpqstats.BytesRead.QuadPart += queue->stats.BytesRead;
            tmpqstats.WriteOperations.QuadPart += queue->stats.WriteOperations;
            tmpqstats.BytesWritten.QuadPart += queue->stats.BytesWritten;
            tmpqstats.TotalWorkContextBlocksQueued.Count += queue->stats.WorkItemsQueued.Count;
            tmpqstats.TotalWorkContextBlocksQueued.Time.QuadPart  += queue->stats.WorkItemsQueued.Time.QuadPart;
        }

        tmpqstats.TotalWorkContextBlocksQueued.Count *= STATISTICS_SMB_INTERVAL;
        tmpqstats.TotalWorkContextBlocksQueued.Time.QuadPart *= timeIncrement;

        RtlCopyMemory( qstats, &tmpqstats, sizeof(tmpqstats) );

        Irp->IoStatus.Information = (SrvNumberOfProcessors + 1) * sizeof( *qstats );

        status = STATUS_SUCCESS;
        goto exit_with_lock;

        break;

    }

    case FSCTL_SRV_GET_STATISTICS:

        //
        // Make sure that the server is active.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {
            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP not started.\n" );
            //}

            status = STATUS_SERVER_NOT_STARTED;
            goto exit_with_lock;
        }

        {
            SRV_STATISTICS tmpStatistics;
            ULONG size;

            //
            // Make sure that the user buffer is large enough to hold some of the
            // statistics database.
            //

            size = MIN( IrpSp->Parameters.FileSystemControl.OutputBufferLength,
                        sizeof( tmpStatistics ) );

            if ( size == 0 ) {
                status = STATUS_BUFFER_TOO_SMALL;
                goto exit_with_lock;
            }

            //
            // Copy the statistics database to the user buffer.  Store
            // the statistics in a temporary buffer so we can convert
            // the tick count stored to system time.
            //

            SrvUpdateStatisticsFromQueues( &tmpStatistics );

            tmpStatistics.TotalWorkContextBlocksQueued.Time.QuadPart *=
                                                (LONG)KeQueryTimeIncrement();

            RtlCopyMemory(
                Irp->AssociatedIrp.SystemBuffer,
                &tmpStatistics,
                size
                );

            Irp->IoStatus.Information = size;

        }

        status = STATUS_SUCCESS;
        goto exit_with_lock;

#if SRVDBG_STATS || SRVDBG_STATS2
    case FSCTL_SRV_GET_DEBUG_STATISTICS:

        //
        // Make sure that the server is active.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {
            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP not started.\n" );
            //}

            status = STATUS_SERVER_NOT_STARTED;
            goto exit_with_lock;
        }

        {
            PSRV_STATISTICS_DEBUG stats;

            //
            // Make sure that the user buffer is large enough to hold the
            // statistics database.
            //

            if ( IrpSp->Parameters.FileSystemControl.OutputBufferLength <
                     FIELD_OFFSET(SRV_STATISTICS_DEBUG,QueueStatistics) ) {

                status = STATUS_BUFFER_TOO_SMALL;
                goto exit_with_lock;
            }

            //
            // Acquire the statistics lock, then copy the statistics database
            // to the user buffer.
            //

            stats = (PSRV_STATISTICS_DEBUG)Irp->AssociatedIrp.SystemBuffer;

            RtlCopyMemory(
                stats,
                &SrvDbgStatistics,
                FIELD_OFFSET(SRV_STATISTICS_DEBUG,QueueStatistics) );

            Irp->IoStatus.Information =
                    FIELD_OFFSET(SRV_STATISTICS_DEBUG,QueueStatistics);

            if ( IrpSp->Parameters.FileSystemControl.OutputBufferLength >=
                     sizeof(SrvDbgStatistics) ) {
                PWORK_QUEUE queue;
                ULONG i, j;
                i = 0;
                stats->QueueStatistics[i].Depth = 0;
                stats->QueueStatistics[i].Threads = 0;
#if SRVDBG_STATS2
                stats->QueueStatistics[i].ItemsQueued = 0;
                stats->QueueStatistics[i].MaximumDepth = 0;
#endif
                for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {
                    stats->QueueStatistics[i].Depth += KeReadStateQueue( &queue->Queue );
                    stats->QueueStatistics[i].Threads += queue->Threads;
#if SRVDBG_STATS2
                    stats->QueueStatistics[i].ItemsQueued += queue->ItemsQueued;
                    stats->QueueStatistics[i].MaximumDepth += queue->MaximumDepth + 1;
#endif
                }
                Irp->IoStatus.Information = sizeof(SrvDbgStatistics);
            }

        }

        status = STATUS_SUCCESS;
        goto exit_with_lock;
#endif // SRVDBG_STATS || SRVDBG_STATS2
    //
    // The follwing APIs must be processed in the server FSP because
    // they open or close handles.
    //

    case FSCTL_SRV_NET_FILE_CLOSE:
    case FSCTL_SRV_NET_SERVER_XPORT_ADD:
    case FSCTL_SRV_NET_SERVER_XPORT_DEL:
    case FSCTL_SRV_NET_SESSION_DEL:
    case FSCTL_SRV_NET_SHARE_ADD:
    case FSCTL_SRV_NET_SHARE_DEL:

    {
        PSERVER_REQUEST_PACKET srp;
        PVOID buffer1;
        PVOID buffer2;
        PVOID systemBuffer;
        ULONG buffer1Length;
        ULONG buffer2Length;
        ULONG systemBufferLength;

        //
        // Get the server request packet pointer.
        //

        srp = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;

        //
        // If the server is not running, or if it is in the process
        // of shutting down, reject this request.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {
            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP not started.\n" );
            //}

            srp->ErrorCode = NERR_ServerNotStarted;
            status = STATUS_SUCCESS;
            goto exit_with_lock;
        }

        //
        // Determine the input buffer lengths, and make sure that the
        // first buffer is large enough to be an SRP.
        //

        buffer1Length = IrpSp->Parameters.FileSystemControl.InputBufferLength;
        buffer2Length = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

        if ( buffer1Length < sizeof(SERVER_REQUEST_PACKET) ) {
            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        //
        // Make the first buffer size is properly aligned so that the second
        // buffer will be aligned as well.
        //

        buffer1Length = ALIGN_UP( buffer1Length, PVOID );

        //
        // Allocate a single buffer that will hold both input buffers.
        // Note that the SRP part of the first buffer is copied back
        // to the user as an output buffer.
        //

        systemBufferLength = buffer1Length + buffer2Length;

        if( buffer1Length > SrvMaxFsctlBufferSize ||
            buffer2Length > SrvMaxFsctlBufferSize ) {

            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;

        }

        systemBuffer = ExAllocatePoolWithTagPriority( PagedPool, systemBufferLength, TAG_FROM_TYPE(BlockTypeMisc), LowPoolPriority );

        if ( systemBuffer == NULL ) {
            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto exit_with_lock;
        }

        buffer1 = systemBuffer;
        buffer2 = (PCHAR)systemBuffer + buffer1Length;

        //
        // Copy the information into the buffers.
        //

        try {
            RtlCopyMemory(
                buffer1,
                srp,
                IrpSp->Parameters.FileSystemControl.InputBufferLength
                );
            if ( buffer2Length > 0 ) {
                RtlCopyMemory( buffer2, Irp->UserBuffer, buffer2Length );
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            status = STATUS_INVALID_PARAMETER;
            ExFreePool( systemBuffer );
            goto exit_with_lock;
        }

        //
        // If a name was specified in the SRP, the buffer field will
        // contain an offset rather than a pointer.  Convert the offset
        // to a pointer and verify that that it is a legal pointer.
        //

        srp = buffer1;

        OFFSET_TO_POINTER( srp->Name1.Buffer, srp );

        if ( !POINTER_IS_VALID( srp->Name1.Buffer, srp, buffer1Length ) ) {
            status = STATUS_ACCESS_VIOLATION;
            ExFreePool( buffer1 );
            goto exit_with_lock;
        }

        OFFSET_TO_POINTER( srp->Name2.Buffer, srp );

        if ( !POINTER_IS_VALID( srp->Name2.Buffer, srp, buffer1Length ) ) {
            status = STATUS_ACCESS_VIOLATION;
            ExFreePool( buffer1 );
            goto exit_with_lock;
        }
        //
        // Set up pointers in the IRP.  The system buffer points to the
        // buffer we just allocated to contain the input buffers.  User
        // buffer points to the SRP from the server service.  This
        // allows the SRP to be used as an output buffer-- the number of
        // bytes specified by the Information field of the IO status
        // block are copied from the system buffer to the user buffer at
        // IO completion.
        //

        Irp->AssociatedIrp.SystemBuffer = systemBuffer;
        Irp->UserBuffer = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;

        //
        // Set up other fields in the IRP so that the SRP is copied from
        // the system buffer to the user buffer, and the system buffer
        // is deallocated by IO completion.
        //

        Irp->Flags |= IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER |
                          IRP_INPUT_OPERATION;
        Irp->IoStatus.Information = sizeof(SERVER_REQUEST_PACKET);

        break;
    }

    //
    // The following APIs should be processed in the server FSP because
    // they reference and dereference structures, which could lead to
    // handles being closed.  However, it was too hard to change this
    // (because of the need to return a separate SRP and data buffer) at
    // the time this was realized (just before Product 1 shipment), so
    // they are processed in the FSD, and all calls to NtClose attach to
    // the server process first if necessary.
    //

    case FSCTL_SRV_NET_CONNECTION_ENUM:
    case FSCTL_SRV_NET_FILE_ENUM:
    case FSCTL_SRV_NET_SERVER_DISK_ENUM:
    case FSCTL_SRV_NET_SERVER_XPORT_ENUM:
    case FSCTL_SRV_NET_SESSION_ENUM:
    case FSCTL_SRV_NET_SHARE_ENUM:

    //
    // These APIs are processed here in the server FSD.
    //

    case FSCTL_SRV_NET_SERVER_SET_INFO:
    case FSCTL_SRV_NET_SHARE_SET_INFO:
    case FSCTL_SRV_NET_STATISTICS_GET:
    {
        PSERVER_REQUEST_PACKET srp;
        ULONG buffer1Length, buffer2Length;
        PBYTE inputBuffer = NULL, outputBuffer = NULL;
        PMDL OutputMdl = NULL;
        BOOLEAN OutputLocked = FALSE;

        //
        // Get the server request packet pointer.
        //
        srp = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;

        //
        // If the server is not running, or if it is in the process
        // of shutting down, reject this request.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {

            try {
                srp->ErrorCode = NERR_ServerNotStarted;
                status = STATUS_SUCCESS;

            }
            except( EXCEPTION_EXECUTE_HANDLER )
            {
                status = STATUS_INVALID_PARAMETER;
            }

            goto exit_with_lock;
        }

        buffer1Length = IrpSp->Parameters.FileSystemControl.InputBufferLength;
        buffer2Length = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

        //
        // Make sure that the buffer was large enough to be an SRP.
        //

        if ( buffer1Length < sizeof(SERVER_REQUEST_PACKET) ) {
            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        //
        // Copy out the SRP.  THis is to make sure they can't change that buffer while we're accessing it, since we
        // place a pointer in there.
        //
        inputBuffer = ExAllocatePoolWithTagPriority( PagedPool, buffer1Length, TAG_FROM_TYPE(BlockTypeMisc), LowPoolPriority );
        if( inputBuffer == NULL )
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit_with_lock;
        }

        //
        // Try to copy the input memory into our own buffer
        //
        try {

            RtlCopyMemory( inputBuffer, srp, buffer1Length );
            srp = (SERVER_REQUEST_PACKET*)inputBuffer;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            ExFreePool(inputBuffer);
            goto exit_with_lock;
        }

        //
        // Increment the count of API requests in the server FSD.
        //

        SrvApiRequestCount++;

        status = STATUS_INSUFFICIENT_RESOURCES;


        //
        // If the output buffer length is 0, do not allocate an MDL,
        // just go through the rest of the code so that the required buffer length
        // and error are returned properly
        //
        if ( buffer2Length <= 0 ) {
            OutputMdl = NULL;
            outputBuffer = Irp->UserBuffer;
        }
        else {
            OutputMdl = IoAllocateMdl( Irp->UserBuffer, buffer2Length, FALSE, TRUE, NULL );

            // Try to lock down the pages
            try {
                MmProbeAndLockPages( OutputMdl, Irp->RequestorMode, IoWriteAccess );
                OutputLocked = TRUE;
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                // Catch the faults
                status = GetExceptionCode();
                goto finish_api_dispatch;
            }

            outputBuffer = MmGetMdlVirtualAddress( OutputMdl );
        }

        // Perform the operation

        //
        // If a name was specified in the SRP, the buffer field will
        // contain an offset rather than a pointer.  Convert the offset
        // to a pointer and verify that that it is a legal pointer.
        //

        OFFSET_TO_POINTER( srp->Name1.Buffer, srp );

        if ( !POINTER_IS_VALID( srp->Name1.Buffer, srp, buffer1Length ) ) {
            status = STATUS_ACCESS_VIOLATION;
            goto finish_api_dispatch;
        }

        OFFSET_TO_POINTER( srp->Name2.Buffer, srp );

        if ( !POINTER_IS_VALID( srp->Name2.Buffer, srp, buffer1Length ) ) {
            status = STATUS_ACCESS_VIOLATION;
            goto finish_api_dispatch;
        }

        //
        // We don't need the configuration lock any more.
        //

        RELEASE_LOCK( &SrvConfigurationLock );

        //
        // Dispatch the API request to the appripriate API processing
        // routine.  All these API requests are handled in the FSD.
        //

        status = SrvApiDispatchTable[ SRV_API_INDEX(code) ](
                     srp,
                     outputBuffer,
                     buffer2Length
                     );

        //
        // Decrement the count of outstanding API requests in the
        // server.  Hold the configuration lock while doing this, as it
        // protects the API count variable.
        //

        ACQUIRE_LOCK( &SrvConfigurationLock );
        SrvApiRequestCount--;

        //
        // Check to see whether the server is transitioning from started
        // to not started.  If so, and if this is the last API request
        // to be completed, then set the API completion event which the
        // shutdown code is waiting on.
        //
        // Since we checked SrvFspTransitioning at the start of the
        // request, we know that the shutdown came after we started
        // processing the API.  If SrvApiRequestCount is 0, then there
        // are no other threads in the FSD processing API requests.
        // Therefore, it is safe for the shutdown code to proceed with
        // the knowledge that no other thread in the server is
        // operating.
        //

        if ( SrvFspTransitioning && SrvApiRequestCount == 0 ) {
            KeSetEvent( &SrvApiCompletionEvent, 0, FALSE );
        }

        //
        // Copy the SRP back into the buffer
        //
        try {
            RtlCopyMemory( IrpSp->Parameters.FileSystemControl.Type3InputBuffer, srp, buffer1Length );
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            status = GetExceptionCode();
        }



finish_api_dispatch:

        if( OutputLocked )
        {
            MmUnlockPages( OutputMdl );
        }

        if ( OutputMdl != NULL ) {
            IoFreeMdl( OutputMdl );
            OutputMdl = NULL;
        }

        if( inputBuffer )
        {
            ExFreePool( inputBuffer );
            inputBuffer = NULL;
            srp = NULL;
        }

        goto exit_with_lock;
    }

    case FSCTL_SRV_PAUSE:

        //
        // If the server is not running, or if it is in the process
        // of shutting down, reject this request.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {
            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP not started.\n" );
            //}

            status = STATUS_SERVER_NOT_STARTED;
            goto exit_with_lock;
        }

        SrvPaused = TRUE;

        status = STATUS_SUCCESS;
        goto exit_with_lock;

    case FSCTL_SRV_CONTINUE:

        //
        // If the server is not running, or if it is in the process
        // of shutting down, reject this request.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {
            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP not started.\n" );
            //}

            status = STATUS_SERVER_NOT_STARTED;
            goto exit_with_lock;
        }

        SrvPaused = FALSE;

        status = STATUS_SUCCESS;
        goto exit_with_lock;

    case FSCTL_SRV_GET_CHALLENGE:
    {
        PLIST_ENTRY sessionEntry;
        PLUID inputLuid;
        PSESSION session;

        //
        // If the server is not running, or if it is in the process
        // of shutting down, reject this request.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {
            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP not started.\n" );
            //}

            status = STATUS_SERVER_NOT_STARTED;
            goto exit_with_lock;
        }

        if ( IrpSp->Parameters.FileSystemControl.InputBufferLength <
                 sizeof(LUID) ||
             IrpSp->Parameters.FileSystemControl.OutputBufferLength <
                 sizeof(session->NtUserSessionKey) ) {

            status = STATUS_BUFFER_TOO_SMALL;
            goto exit_with_lock;
        }

        RELEASE_LOCK( &SrvConfigurationLock );

        inputLuid = (PLUID)Irp->AssociatedIrp.SystemBuffer;

        //
        // Acquire the lock that protects the session list and walk the
        // list looking for a user token that matches the one specified
        // in the input buffer.
        //

        ACQUIRE_LOCK( SrvSessionList.Lock );

        for ( sessionEntry = SrvSessionList.ListHead.Flink;
              sessionEntry != &SrvSessionList.ListHead;
              sessionEntry = sessionEntry->Flink ) {

            session = CONTAINING_RECORD(
                          sessionEntry,
                          SESSION,
                          GlobalSessionListEntry
                          );

            if ( RtlEqualLuid( inputLuid, &session->LogonId ) ) {

                // Only give out the session key if its availible for giving out.
                // This means that either:
                //   A) This key is not being used for signing   or
                //   B) The key is being used for signing, and has either been encrypted or the other
                //      side doesn't support encryption
                if( session->SessionKeyState == SrvSessionKeyAvailible )
                {
                    //
                    // We found a match.  Write the NT user session key into
                    // the output buffer.
                    //

                    RtlCopyMemory(
                        Irp->AssociatedIrp.SystemBuffer,
                        session->NtUserSessionKey,
                        sizeof(session->NtUserSessionKey)
                        );

                    RELEASE_LOCK( SrvSessionList.Lock );

                    Irp->IoStatus.Information = sizeof(session->NtUserSessionKey);
                    status = STATUS_SUCCESS;
                }
                else
                {
                    RELEASE_LOCK( SrvSessionList.Lock );

                    Irp->IoStatus.Information = 0;
                    status = STATUS_ACCESS_DENIED;
                }

                goto exit_without_lock;
            }
        }

        RELEASE_LOCK( SrvSessionList.Lock );

        //
        // There was no matching token in our session list.  Fail the
        // request.
        //

        status = STATUS_NO_TOKEN;
        goto exit_without_lock;
    }

    case FSCTL_SRV_INTERNAL_TEST_REAUTH:
    {
        PSRV_REAUTH_TEST pReauthData;
        ULONG BufferLength;

        pReauthData = (PSRV_REAUTH_TEST)Irp->AssociatedIrp.SystemBuffer;
        BufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

        // Make sure the buffer size is good
        if( BufferLength < sizeof(SRV_REAUTH_TEST) )
        {
            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        // Pull out the parameters
        SessionInvalidateCommand = pReauthData->InvalidateCommand;
        SessionInvalidateMod = pReauthData->InvalidateModulo;
        status = STATUS_SUCCESS;
        goto exit_with_lock;
    }

    case FSCTL_DFS_RELEASE_SHARE_TABLE:
        {
            RELEASE_LOCK( &SrvConfigurationLock );

            ACQUIRE_LOCK( &SrvShareLock );

            status = SrvClearDfsOnShares();

            RELEASE_LOCK( &SrvShareLock );

            goto exit_without_lock;
        }

    case FSCTL_DFS_UPDATE_SHARE_TABLE:
        {
            PSHARE share;
            PDFS_ATTACH_SHARE_BUFFER pBuffer = (PDFS_ATTACH_SHARE_BUFFER)Irp->AssociatedIrp.SystemBuffer;
            UNICODE_STRING shareName;
            ULONG BufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

            RELEASE_LOCK( &SrvConfigurationLock );

            if( (BufferLength < sizeof(DFS_ATTACH_SHARE_BUFFER)) ||
                (BufferLength < sizeof(DFS_ATTACH_SHARE_BUFFER) + pBuffer->ShareNameLength - sizeof(WCHAR)) )
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                shareName.Buffer = pBuffer->ShareName;
                shareName.Length = shareName.MaximumLength = pBuffer->ShareNameLength;

                ACQUIRE_LOCK( &SrvShareLock );

                share = SrvFindShare( &shareName );
                if( !share )
                {
                    status = STATUS_OBJECT_NAME_NOT_FOUND;
                }
                else
                {
                    share->IsDfsRoot = share->IsDfs = pBuffer->fAttach;
                    status = STATUS_SUCCESS;
                }

                RELEASE_LOCK( &SrvShareLock );
            }

            goto exit_without_lock;
        }

    case FSCTL_SRV_QUERY_LWIO_CONTEXT:
        {
            ULONG BufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
            PSRV_QUERY_RESUME_CONTEXT pBuffer = (PSRV_QUERY_RESUME_CONTEXT)Irp->AssociatedIrp.SystemBuffer;

            if (BufferLength < sizeof(SRV_QUERY_RESUME_CONTEXT)) {
                status = STATUS_INVALID_PARAMETER;
            } else if (BufferLength < SrvLWIOContextLength) {
        pBuffer->ContextLength = SrvLWIOContextLength;
        status = STATUS_BUFFER_OVERFLOW;
                Irp->IoStatus.Information = sizeof(SRV_QUERY_RESUME_CONTEXT);
        } else {
        pBuffer->ContextLength = SrvLWIOContextLength;
        RtlCopyMemory(pBuffer->Context, SrvLWIOContext, SrvLWIOContextLength);
        status = STATUS_SUCCESS;
                Irp->IoStatus.Information = sizeof(SRV_QUERY_RESUME_CONTEXT) + SrvLWIOContextLength;
            }

            goto exit_with_lock;
        }

    case FSCTL_SRV_SET_LWIO_CONTEXT:
        {
            ULONG BufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
            PSRV_SET_RESUME_CONTEXT pBuffer = (PSRV_SET_RESUME_CONTEXT)Irp->AssociatedIrp.SystemBuffer;

            if( (BufferLength < sizeof(SRV_SET_RESUME_CONTEXT)) ||
                (BufferLength < FIELD_OFFSET( SRV_SET_RESUME_CONTEXT, Context ) + pBuffer->ContextLength) )
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                // If a Callback is specified, caller must be kernel mode
                if( (pBuffer->Callback != NULL) &&
                    (IoGetCurrentProcess() != SrvServerProcess) )
                {
                    status = STATUS_INVALID_PARAMETER;
                }
                else
                {
                    if( SrvLWIOContext )
                    {
                        FREE_HEAP( SrvLWIOContext );
                    }

                    SrvLWIOContext = ALLOCATE_HEAP( pBuffer->ContextLength, BlockTypeMisc );

                    if( SrvLWIOContext ) {
                        RtlCopyMemory( SrvLWIOContext, pBuffer->Context, pBuffer->ContextLength );
            SrvLWIOContextLength = pBuffer->ContextLength;
            if (IoGetCurrentProcess() == SrvServerProcess)
                SrvLWIOCallback = pBuffer->Callback;
                        status = STATUS_SUCCESS;
                    }
                    else
                    {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            }

            goto exit_with_lock;
        }

    case FSCTL_SRV_REQUEST_HANDLE_DUP:
        {
            PSRV_REQUEST_HANDLE_DUP pDupRequest = (PSRV_REQUEST_HANDLE_DUP)Irp->AssociatedIrp.SystemBuffer;
            ULONG InBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
            ULONG OutBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

            RELEASE_LOCK( &SrvConfigurationLock );

            if( (InBufferLength < sizeof(SRV_REQUEST_HANDLE_DUP)) ||
                (OutBufferLength < sizeof(SRV_RESPONSE_HANDLE_DUP)) )
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                PSRV_RESPONSE_HANDLE_DUP pDupResponse = (PSRV_RESPONSE_HANDLE_DUP)(Irp->UserBuffer);
                status = SrvProcessHandleDuplicateRequest( Irp, IrpSp, pDupRequest, pDupResponse );
            }

            goto exit_without_lock;
        }


    default:

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvFsdDispatchFsControl: Invalid I/O control "
                "code received: %lx\n",
            IrpSp->Parameters.FileSystemControl.FsControlCode,
            NULL
            );
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_lock;
    }

    pWorkItem = IoAllocateWorkItem( SrvDeviceObject );
    if( !pWorkItem )
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit_with_lock;
    }

    //
    // Queue the request to the FSP for processing.
    //
    // *** Note that the request must be queued while the configuration
    //     lock is held in order to prevent an add/delete/etc request
    //     from checking the server state before a shutdown request, but
    //     being queued after that request.
    //

    IoMarkIrpPending( Irp );

    QueueConfigurationIrp( Irp, pWorkItem );

    RELEASE_LOCK( &SrvConfigurationLock );

    FsRtlExitFileSystem();

    return STATUS_PENDING;

exit_with_lock:

    RELEASE_LOCK( &SrvConfigurationLock );

exit_without_lock:

    FsRtlExitFileSystem();

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, 2 );

    return status;

} // SrvFsdDispatchFsControl


VOID
QueueConfigurationIrp (
    IN PIRP Irp,
    IN PIO_WORKITEM pWorkItem
    )
{
    PAGED_CODE( );

    InterlockedIncrement( (PLONG)&SrvConfigurationIrpsInProgress );

    SrvInsertTailList(
        &SrvConfigurationWorkQueue,
        &Irp->Tail.Overlay.ListEntry
        );


    IoQueueWorkItem( pWorkItem, SrvConfigurationThread, DelayedWorkQueue, (PVOID)pWorkItem );

} // QueueConfigurationIrp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\errorlog.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    errorlog.c

Abstract:

    This module implements the error logging in the server.

Author:

    Manny Weiser (mannyw)    11-Feb-92

Revision History:

--*/

#include "precomp.h"
#include "errorlog.tmh"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvLogInvalidSmbDirect )
#pragma alloc_text( PAGE, SrvLogServiceFailureDirect )
#if DBG
#pragma alloc_text( PAGE, SrvLogTableFullError )
#endif
#endif
#if 0
NOT PAGEABLE -- SrvLogError
NOT PAGEABLE -- SrvCheckSendCompletionStatus
NOT PAGEABLE -- SrvIsLoggableError
#endif


VOID
SrvLogInvalidSmbDirect (
    IN PWORK_CONTEXT WorkContext,
    IN ULONG LineNumber
    )
{
    UNICODE_STRING unknownClient;
    PUNICODE_STRING clientName;
    ULONG LocalBuffer[ 13 ];
    ULONG count;

    PAGED_CODE( );

    if( !SrvEnableInvalidSmbLogging )
    {
        return;
    }

    //
    // Let this client log at most one SMB error
    //
    if( ARGUMENT_PRESENT( WorkContext ) ) {

        if( WorkContext->Connection->PagedConnection->LoggedInvalidSmb ) {
            return;
        }

        WorkContext->Connection->PagedConnection->LoggedInvalidSmb = TRUE;
    }

    if ( ARGUMENT_PRESENT(WorkContext) &&
         (WorkContext->Connection->ClientMachineNameString.Length != 0) ) {

        clientName = &WorkContext->Connection->ClientMachineNameString;

    } else {

        RtlInitUnicodeString( &unknownClient, StrUnknownClient );
        clientName = &unknownClient;

    }

    if ( ARGUMENT_PRESENT(WorkContext) ) {

        LocalBuffer[0] = LineNumber;

        RtlCopyMemory(
            &LocalBuffer[1],
            WorkContext->RequestHeader,
            MIN( WorkContext->RequestBuffer->DataLength, sizeof( LocalBuffer ) - sizeof( LocalBuffer[0] ) )
            );

        SrvLogError(
            SrvDeviceObject,
            EVENT_SRV_INVALID_REQUEST,
            STATUS_INVALID_SMB,
            LocalBuffer,
            (USHORT)MIN( WorkContext->RequestBuffer->DataLength + sizeof( LocalBuffer[0] ), sizeof( LocalBuffer ) ),
            clientName,
            1
            );

    } else {

        SrvLogError(
            SrvDeviceObject,
            EVENT_SRV_INVALID_REQUEST,
            STATUS_INVALID_SMB,
            &LineNumber,
            (USHORT)sizeof( LineNumber ),
            clientName,
            1
            );
    }

    return;

} // SrvLogInvalidSmb

BOOLEAN
SrvIsLoggableError( IN NTSTATUS Status )
{
    NTSTATUS *pstatus;
    BOOLEAN ret = TRUE;

    for( pstatus = SrvErrorLogIgnore; *pstatus; pstatus++ ) {
        if( *pstatus == Status ) {
            ret = FALSE;
            break;
        }
    }

    return ret;
}


VOID
SrvLogServiceFailureDirect (
    IN ULONG LineAndService,
    IN NTSTATUS Status
    )
/*++

Routine Description:

    This function logs a srv svc error.  You should use the 'SrvLogServiceFailure'
      macro instead of calling this routine directly.

Arguments:
    LineAndService consists of the line number of the original call in the highword, and
      the service code in the lowword

    Status is the status code of the called routine

Return Value:

    None.

--*/
{
    PAGED_CODE( );

    //
    // Don't log certain errors that are expected to happen occasionally.
    //

    if( (LineAndService & 01) || SrvIsLoggableError( Status ) ) {

        SrvLogError(
            SrvDeviceObject,
            EVENT_SRV_SERVICE_FAILED,
            Status,
            &LineAndService,
            sizeof(LineAndService),
            NULL,
            0
            );

    }

    return;

} // SrvLogServiceFailure

//
// I have disabled this for retail builds because it is not a good idea to
//   allow an evil client to so easily fill the server's system log
//
VOID
SrvLogTableFullError (
    IN ULONG Type
    )
{
#if DBG
    PAGED_CODE( );

    SrvLogError(
        SrvDeviceObject,
        EVENT_SRV_CANT_GROW_TABLE,
        STATUS_INSUFFICIENT_RESOURCES,
        &Type,
        sizeof(ULONG),
        NULL,
        0
        );

    return;
#endif

} // SrvLogTableFullError

VOID
SrvLogError(
    IN PVOID DeviceOrDriverObject,
    IN ULONG UniqueErrorCode,
    IN NTSTATUS NtStatusCode,
    IN PVOID RawDataBuffer,
    IN USHORT RawDataLength,
    IN PUNICODE_STRING InsertionString OPTIONAL,
    IN ULONG InsertionStringCount
    )

/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.

Arguments:



Return Value:

    None.


--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    ULONG insertionStringLength = 0;
    ULONG i;
    PWCHAR buffer;
    USHORT paddedRawDataLength = 0;

    //
    // Update the server error counts
    //

    if ( UniqueErrorCode == EVENT_SRV_NETWORK_ERROR ) {
        SrvUpdateErrorCount( &SrvNetworkErrorRecord, TRUE );
    } else {
        SrvUpdateErrorCount( &SrvErrorRecord, TRUE );
    }

    for ( i = 0; i < InsertionStringCount ; i++ ) {
        insertionStringLength += (InsertionString[i].Length + sizeof(WCHAR));
    }

    //
    // pad the raw data buffer so that the insertion string starts
    // on an even address.
    //

    if ( ARGUMENT_PRESENT( RawDataBuffer ) ) {
        paddedRawDataLength = (RawDataLength + 1) & ~1;
    }

    errorLogEntry = IoAllocateErrorLogEntry(
                        DeviceOrDriverObject,
                        (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                                paddedRawDataLength + insertionStringLength)
                        );

    if (errorLogEntry != NULL) {

        //
        // Fill in the error log entry
        //

        errorLogEntry->ErrorCode = UniqueErrorCode;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = 0;
        errorLogEntry->FinalStatus = NtStatusCode;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->DeviceOffset.QuadPart = 0;
        errorLogEntry->DumpDataSize = RawDataLength;
        errorLogEntry->StringOffset =
            (USHORT)(FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData) + paddedRawDataLength);
        errorLogEntry->NumberOfStrings = (USHORT)InsertionStringCount;

        errorLogEntry->SequenceNumber = 0;

        //
        // Append the extra information.  This information is typically
        // an SMB header.
        //

        if ( ARGUMENT_PRESENT( RawDataBuffer ) ) {

            RtlCopyMemory(
                errorLogEntry->DumpData,
                RawDataBuffer,
                RawDataLength
                );
        }

        buffer = (PWCHAR)((PCHAR)errorLogEntry->DumpData + paddedRawDataLength);

        for ( i = 0; i < InsertionStringCount ; i++ ) {

            RtlCopyMemory(
                buffer,
                InsertionString[i].Buffer,
                InsertionString[i].Length
                );

            buffer += (InsertionString[i].Length/2);
            *buffer++ = L'\0';
        }

        //
        // Write the entry
        //

        IoWriteErrorLogEntry(errorLogEntry);
    }

} // SrvLogError

VOID
SrvCheckSendCompletionStatus(
    IN NTSTATUS Status,
    IN ULONG LineNumber
    )

/*++

Routine Description:

    Routine to log send completion errors.

Arguments:


Return Value:

    None.

--*/

{
    if( SrvIsLoggableError( Status ) ) {

        SrvLogError( SrvDeviceObject,
                     EVENT_SRV_NETWORK_ERROR,
                     Status,
                     &LineNumber, sizeof(LineNumber),
                     NULL, 0 );
    }

} // SrvCheckSendCompletionStatus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\dfs.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dfs.c

Abstract:

    This module contains various support routines for processing Dfs related operations.

--*/

#include "precomp.h"
#include "dfs.tmh"
#pragma hdrstop

#include    <dfsfsctl.h>

#define BugCheckFileId SRV_FILE_DFS

NTSTATUS
DfsGetReferrals(
    ULONG ClientIPAddress,
    PUNICODE_STRING DfsName,
    USHORT MaxReferralLevel,
    PVOID ReferralListBuffer,
    PULONG SizeReferralListBuffer
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvInitializeDfs )
#pragma alloc_text( PAGE, SrvTerminateDfs )
#pragma alloc_text( PAGE, SrvSmbGetDfsReferral )
#pragma alloc_text( PAGE, SrvSmbReportDfsInconsistency )
#pragma alloc_text( PAGE, DfsGetReferrals )
#pragma alloc_text( PAGE, DfsNormalizeName )
#pragma alloc_text( PAGE, DfsFindShareName )
#pragma alloc_text( PAGE, SrvIsShareInDfs )
#endif

//
// Initialize with the Dfs driver.  Called at startup
//
VOID
SrvInitializeDfs()
{
    NTSTATUS status;
    HANDLE dfsHandle;
    UNICODE_STRING dfsDriverName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    PAGED_CODE();

    //
    // Get the DFS dispatch entry for file control operations
    //
    RtlInitUnicodeString( &dfsDriverName, DFS_SERVER_NAME );

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &dfsDriverName,
        0,
        NULL,
        NULL
        );

    status = IoCreateFile(
                &dfsHandle,
                GENERIC_READ | GENERIC_WRITE,
                &objectAttributes,
                &ioStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                0,                      // Create Options
                NULL,                   // EA Buffer
                0,                      // EA Length
                CreateFileTypeNone,     // File type
                NULL,                   // ExtraCreateParameters
                IO_FORCE_ACCESS_CHECK   // Options
                );

    if( NT_SUCCESS( status ) ) {

        //
        // Get a pointer to the fast Device Control entry point of the Dfs driver so
        //  we can quickly perform Dfs operations
        //

        status = ObReferenceObjectByHandle(
                    dfsHandle,
                    0,
                    NULL,
                    KernelMode,
                    (PVOID *)&SrvDfsFileObject,
                    NULL
                    );

        if( NT_SUCCESS( status ) ) {

            PFAST_IO_DISPATCH fastIoDispatch;

            SrvDfsDeviceObject = IoGetRelatedDeviceObject( SrvDfsFileObject );
            fastIoDispatch = SrvDfsDeviceObject->DriverObject->FastIoDispatch;

            if( fastIoDispatch != NULL &&
                fastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET( FAST_IO_DISPATCH, FastIoDeviceControl ) ) {

                SrvDfsFastIoDeviceControl = fastIoDispatch->FastIoDeviceControl;

            }

            if( SrvDfsFastIoDeviceControl == NULL ) {
                ObDereferenceObject( SrvDfsFileObject );
                SrvDfsFileObject = NULL;
                SrvDfsDeviceObject = NULL;
            }
        }

        SrvNtClose( dfsHandle, FALSE );
    }

    IF_DEBUG( DFS ) {
        if( SrvDfsFastIoDeviceControl == NULL ) {
            KdPrint(( "SRV: Dfs operations unavailable, status %X\n", status ));
        }
    }
}

//
// De-initialize with the Dfs driver.  Called at server shutdown
//
VOID
SrvTerminateDfs()
{
    PAGED_CODE();

    //
    // Disconnect from the Dfs driver
    //
    if( SrvDfsFileObject != NULL ) {
        SrvDfsFastIoDeviceControl = NULL;
        SrvDfsDeviceObject = NULL;
        ObDereferenceObject( SrvDfsFileObject );
        SrvDfsFileObject = NULL;
    }
}

SMB_TRANS_STATUS
SrvSmbGetDfsReferral (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    PTRANSACTION transaction;
    UNICODE_STRING dfsName;
    PREQ_GET_DFS_REFERRAL request;
    NTSTATUS status = STATUS_SUCCESS;
    PTREE_CONNECT treeConnect;
    PSHARE share;
    PVOID referrals;
    ULONG size;
    ULONG dataCount;
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;

    PAGED_CODE();

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_GET_DFS_REFERRALS;
    SrvWmiStartContext(WorkContext);

    transaction = WorkContext->Parameters.Transaction;

    request = (PREQ_GET_DFS_REFERRAL)transaction->InParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    // The +1 is to ensure that there is at least room for a single unicode
    // character in the supplied buffer, since this assumption is implicitly
    // made below.
    //

    if( (transaction->ParameterCount <
            sizeof( REQ_GET_DFS_REFERRAL ) + 1) ||

        !SMB_IS_UNICODE( WorkContext ) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG( DFS ) {
            KdPrint(( "SrvSmbGetDfsReferral: bad parameter byte counts: "
                        "%ld\n",
                        transaction->ParameterCount ));

            if( !SMB_IS_UNICODE( WorkContext ) ) {
                KdPrint(( "SrvSmbGetDfsReferral: NOT UNICODE!\n" ));
            }
        }

        SrvLogInvalidSmb( WorkContext );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        SmbStatus = SmbTransStatusErrorWithoutData;
        status    = STATUS_INVALID_SMB;
        goto Cleanup;
    }

    //
    // This SMB can only be sent over IPC$, by a logged-in user
    //
    treeConnect = transaction->TreeConnect;
    share = treeConnect->Share;

    if( share->ShareType != ShareTypePipe ) {

        IF_DEBUG( DFS ) {
            if( share->ShareType != ShareTypePipe ) {
                KdPrint(( "SrvSmbGetDfsReferral: Wrong share type %d\n", share->ShareType ));
            }
        }

        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        SmbStatus = SmbTransStatusErrorWithoutData;
        status    = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    dfsName.Buffer = (PWCHAR)ALIGN_SMB_WSTR( request->RequestFileName );
    dfsName.Length = MIN( (USHORT)( END_OF_TRANSACTION_PARAMETERS( transaction ) - (PCHAR)dfsName.Buffer + 1) & ~0x1, 0xFFEE );
    dfsName.MaximumLength = dfsName.Length;
    dfsName.Length -= sizeof(UNICODE_NULL);

    dataCount = transaction->MaxDataCount;

    status = DfsGetReferrals( WorkContext->Connection->ClientIPAddress,
                                        &dfsName, request->MaxReferralLevel,
                                        transaction->OutData,
                                        &dataCount );

    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    transaction->SetupCount = 0;
    transaction->ParameterCount = 0;
    transaction->DataCount = dataCount;
    SmbStatus = SmbTransStatusSuccess;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
}

NTSTATUS
DfsGetReferrals(
    ULONG IPAddress,
    PUNICODE_STRING DfsName,
    USHORT MaxReferralLevel,
    PVOID  ReferralListBuffer,
    PULONG SizeReferralListBuffer
)
{
    DFS_GET_REFERRALS_INPUT_ARG dfsArgs;
    IO_STATUS_BLOCK ioStatus;
    PRESP_GET_DFS_REFERRAL pResp;
    PUCHAR eBuffer;
    ULONG i;

    PAGED_CODE();

    if( SrvDfsFastIoDeviceControl == NULL ) {
        return STATUS_FS_DRIVER_REQUIRED;
    }

    IF_DEBUG( DFS ) {
        KdPrint(( "SRV: Referral sought for: <%wZ>\n", DfsName ));
    }

    //
    // Call DFS, getting back the vector of referrals
    //
    RtlZeroMemory( &dfsArgs, sizeof(dfsArgs) );
    dfsArgs.DfsPathName = *DfsName;
    dfsArgs.MaxReferralLevel = MaxReferralLevel;

    if( IPAddress != 0 ) {
        dfsArgs.IpAddress.IpFamily = TDI_ADDRESS_TYPE_IP;
        dfsArgs.IpAddress.IpLen = sizeof( IPAddress );
        RtlCopyMemory( dfsArgs.IpAddress.IpData, &IPAddress, sizeof( IPAddress ) );
    }

    SrvDfsFastIoDeviceControl(
        SrvDfsFileObject,
        TRUE,
        &dfsArgs,
        sizeof( dfsArgs ),
        ReferralListBuffer,
        *SizeReferralListBuffer,
        FSCTL_DFS_GET_REFERRALS,
        &ioStatus,
        SrvDfsDeviceObject
    );

    if( NT_SUCCESS( ioStatus.Status ) ||
        ioStatus.Status == STATUS_BUFFER_OVERFLOW ) {

        *SizeReferralListBuffer = (ULONG)ioStatus.Information;

    } else {

        IF_DEBUG( DFS ) {
            KdPrint(("\tSrvDfsFastIoDeviceControl returned %X, 0x%p\n",
                      ioStatus.Status, (PVOID)ioStatus.Information ));
        }

    }

    return ioStatus.Status;
}

SMB_TRANS_STATUS
SrvSmbReportDfsInconsistency (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    //
    // We no longer support middle triangles in DFS
    //
    SrvSetSmbError( WorkContext, STATUS_NOT_SUPPORTED );
    return SmbTransStatusErrorWithoutData;

#if XXX
    PTRANSACTION transaction;
    UNICODE_STRING dfsName;
    PREQ_REPORT_DFS_INCONSISTENCY request;
    PDFS_REFERRAL_V1 ref;
    PTREE_CONNECT treeConnect;
    PSHARE share;
    DFS_REPORT_INCONSISTENCY_ARG dfsArgs;
    IO_STATUS_BLOCK ioStatus;

    PAGED_CODE();

    transaction = WorkContext->Parameters.Transaction;

    request = (PREQ_REPORT_DFS_INCONSISTENCY)transaction->InParameters;
    ref = (PDFS_REFERRAL_V1)transaction->InData;

    //
    // Verify that enough parameter bytes were sent and the SMB is unicode
    //

    if( transaction->ParameterCount < sizeof( *request ) ||
        !SMB_IS_UNICODE( WorkContext ) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG( DFS ) {
            KdPrint(( "SrvSmbReportDfsInconsistency: bad parameter byte counts: "
                        "%ld %ld\n",
                        transaction->ParameterCount, sizeof( *request ) ));

            if( !SMB_IS_UNICODE( WorkContext ) ) {
                KdPrint(( "SrvSmbReportDfsInconsistency: NOT UNICODE!\n" ));
            }
        }

        SrvLogInvalidSmb( WorkContext );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // This SMB can only be sent over IPC$, by a logged-in user
    //
    treeConnect = transaction->TreeConnect;
    share = treeConnect->Share;

    if( share->ShareType != ShareTypePipe ||
        transaction->Session->IsNullSession ) {

        IF_DEBUG( DFS ) {
            if( share->ShareType != ShareTypePipe ) {
                KdPrint(( "SrvSmbReportDfsInconsistency: Wrong share type %d\n", share->ShareType ));
            }
            if( transaction->Session->IsNullSession ) {
                KdPrint(( "SrvSmbReportDfsInconsistency: NULL session!\n" ));
            }
        }

        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        return SmbTransStatusErrorWithoutData;
    }

    dfsName.Buffer = ALIGN_SMB_WSTR( request->RequestFileName );
    dfsName.Length = (USHORT)transaction->TotalParameterCount -
                        sizeof(UNICODE_NULL);
    dfsName.MaximumLength = dfsName.Length;

    IF_DEBUG( DFS ) {
        KdPrint(( "SrvSmbReportDfsInconsistency: %wZ\n", &dfsName ));
    }

    dfsArgs.DfsPathName = dfsName;
    dfsArgs.Ref = (PBYTE) ref;

    if (SrvDfsFastIoDeviceControl != NULL) {

        SrvDfsFastIoDeviceControl(
            SrvDfsFileObject,
            TRUE,
            &dfsArgs,
            sizeof( dfsArgs ),
            NULL,
            0,
            FSCTL_DFS_REPORT_INCONSISTENCY,
            &ioStatus,
            SrvDfsDeviceObject
            );

    }

    transaction->ParameterCount = 0;
    transaction->DataCount = 0;
    return SmbTransStatusSuccess;
#endif
}

NTSTATUS SRVFASTCALL
DfsNormalizeName(
    IN PSHARE Share,
    IN PUNICODE_STRING RelatedPath OPTIONAL,
    IN BOOLEAN StripLastComponent,
    IN PUNICODE_STRING String
    )
{
    DFS_TRANSLATE_PATH_ARG dfsArgs;
    IO_STATUS_BLOCK ioStatus;

#if DBG
    UNICODE_STRING save = *String;
#endif

    PAGED_CODE();

    //
    // If Share->NtPathName covers String, then the remaining pathname in String->Buffer should
    //  be moved to String->Buffer and String->Length should be adjusted.  In other words, on return
    //  the value of String->Buffer must not be changed, but the contents of String->Buffer needs to
    //  be adjusted.
    //

    ASSERT( String->Buffer != NULL );

    IF_DEBUG( DFS ) {
        KdPrint(( "DfsNormalizeName: %p, Share: %wZ\n", String, &Share->NtPathName ));
    }

    if( Share->ShareType == ShareTypeDisk &&
        SrvDfsFastIoDeviceControl != NULL ) {
        //
        // Make an FSCTL to the DFS driver to normalize the name
        //

        dfsArgs.Flags = 0;

        if (StripLastComponent)
            dfsArgs.Flags |= DFS_TRANSLATE_STRIP_LAST_COMPONENT;

        dfsArgs.SubDirectory = Share->NtPathName;
        if (ARGUMENT_PRESENT(RelatedPath)) {
            UNICODE_STRING Parent;

            //ASSERT(RelatedPath->Length >= Share->DosPathName.Length);

            if (RelatedPath->Length <= Share->DosPathName.Length) {
                Parent.MaximumLength = Parent.Length = sizeof(WCHAR);
                Parent.Buffer = L"\\";
            } else {
                Parent.MaximumLength = Parent.Length =
                           RelatedPath->Length - Share->DosPathName.Length;
                Parent.Buffer =
                    &RelatedPath->Buffer[ Share->DosPathName.Length/sizeof(WCHAR) ];
            }

            dfsArgs.ParentPathName = Parent;

        } else {
            dfsArgs.ParentPathName.Length = 0;
            dfsArgs.ParentPathName.MaximumLength = 0;
            dfsArgs.ParentPathName.Buffer = NULL;
        }
        dfsArgs.DfsPathName = *String;

        SrvDfsFastIoDeviceControl(
            SrvDfsFileObject,
            TRUE,
            &dfsArgs,
            sizeof( dfsArgs ),
            NULL,
            0,
            FSCTL_DFS_TRANSLATE_PATH,
            &ioStatus,
            SrvDfsDeviceObject
            );

        if (NT_SUCCESS(ioStatus.Status)) {

            ASSERT( dfsArgs.DfsPathName.Buffer == String->Buffer );
            ASSERT( dfsArgs.DfsPathName.Length <= String->Length );
            ASSERT( dfsArgs.DfsPathName.MaximumLength >= dfsArgs.DfsPathName.Length );

            *String = dfsArgs.DfsPathName;

            IF_DEBUG( DFS ) {
                KdPrint(( "\t%wZ\n", String ));
            }
        }

    } else {
        ioStatus.Status = STATUS_FS_DRIVER_REQUIRED;
    }

    ASSERT( save.Buffer == String->Buffer );
    ASSERT( save.Length >= String->Length );

    if( !NT_SUCCESS( ioStatus.Status ) ) {
        IF_DEBUG( DFS ) {
            KdPrint(( "\tStatus %X\n", ioStatus.Status ));
        }
    }

    return ioStatus.Status;
}

NTSTATUS SRVFASTCALL
DfsFindShareName(
    IN PUNICODE_STRING ShareName
    )
{
    NTSTATUS status = STATUS_BAD_NETWORK_NAME;
    DFS_FIND_SHARE_ARG dfsArgs;
    IO_STATUS_BLOCK ioStatus;
    KAPC_STATE ApcState;
    PEPROCESS process;

    //
    // Ensure we are in the system process
    //
    process = IoGetCurrentProcess();
    if ( process != SrvServerProcess ) {
        KeStackAttachProcess( SrvServerProcess, &ApcState );
    }

    //
    // If 'shareName' is known to the DFS driver, then we must return
    //  STATUS_PATH_NOT_COVERED.  Otherwise we must return STATUS_BAD_NETWORK_NAME.
    //  This will cause the DFS client to come back and ask for a referral through
    //  the normal mechanism.
    //

    IF_DEBUG( DFS ) {
        KdPrint(( "SRV: DfsFindShareName: %wZ\n", ShareName ));
    }

    if( SrvDfsFastIoDeviceControl != NULL ) {

        dfsArgs.ShareName = *ShareName;

        SrvDfsFastIoDeviceControl(
            SrvDfsFileObject,
            TRUE,
            &dfsArgs,
            sizeof( dfsArgs ),
            NULL,
            0,
            FSCTL_DFS_FIND_SHARE,
            &ioStatus,
            SrvDfsDeviceObject
            );

        if( ioStatus.Status == STATUS_PATH_NOT_COVERED ) {
            status = ioStatus.Status;
        }
    }

    IF_DEBUG( DFS ) {
        KdPrint(( "SRV: DfsFindShareName: status %X\n", status ));
    }

    //
    // Get back to where we were
    //
    if( process != SrvServerProcess ) {
        KeUnstackDetachProcess( &ApcState );
    }

    return status;
}

VOID SRVFASTCALL
SrvIsShareInDfs(
    IN PSHARE Share,
    OUT BOOLEAN *IsDfs,
    OUT BOOLEAN *IsDfsRoot
)
{
    DFS_IS_SHARE_IN_DFS_ARG dfsArgs;
    IO_STATUS_BLOCK ioStatus;
    KAPC_STATE ApcState;
    PEPROCESS process;

    PAGED_CODE();

    *IsDfs = FALSE;
    *IsDfsRoot = FALSE;

    if( Share->ShareType != ShareTypeDisk ||
        SrvDfsFastIoDeviceControl == NULL ) {

        return;
    }

    dfsArgs.ServerType = 1;         // SMB server
    dfsArgs.ShareName = Share->ShareName;
    dfsArgs.SharePath = Share->NtPathName;

    //
    // Ensure we are in the system process
    //
    process = IoGetCurrentProcess();
    if ( process != SrvServerProcess ) {
        KeStackAttachProcess( SrvServerProcess, &ApcState );
    }

    SrvDfsFastIoDeviceControl(
        SrvDfsFileObject,
        TRUE,
        &dfsArgs,
        sizeof( dfsArgs ),
        NULL,
        0,
        FSCTL_DFS_IS_SHARE_IN_DFS,
        &ioStatus,
        SrvDfsDeviceObject
        );

    //
    // Get back to where we were
    //
    if( process != SrvServerProcess ) {
        KeUnstackDetachProcess( &ApcState );
    }

    if (NT_SUCCESS(ioStatus.Status)) {

        if (dfsArgs.ShareType & DFS_SHARE_TYPE_DFS_VOLUME)
            *IsDfs = TRUE;

        if (dfsArgs.ShareType & DFS_SHARE_TYPE_ROOT)
            *IsDfsRoot = TRUE;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\fsdraw.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    fsdraw.c

Abstract:

    This module contains routines for processing the following SMBs in
    the server FSD:

        Read Block Raw
        Write Block Raw

    The routines in this module generally work closely with the routines
    in smbraw.c.

    *** There is no support here for raw writes from MS-NET 1.03 clients.
        There are very few of these machines in existence, and raw mode
        is only a performance issue, so it is not worth the trouble to
        add the necessary hacks for MS-NET 1.03, which sends raw write
        requests in a different format.

Author:

    Chuck Lenzmeier (chuckl) 8-Sep-1990
    Manny Weiser (mannyw)
    David Treadwell (davidtr)

Revision History:

--*/

#include "precomp.h"
#include "fsdraw.tmh"
#pragma hdrstop

//
// Forward declarations.
//

STATIC
VOID SRVFASTCALL
RestartWriteCompleteResponse (
    IN OUT PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE8FIL, SrvFsdBuildWriteCompleteResponse )
#pragma alloc_text( PAGE8FIL, RestartWriteCompleteResponse )
#endif
#if 0
NOT PAGEABLE -- RestartCopyReadRawResponse
NOT PAGEABLE -- SrvFsdRestartPrepareRawMdlWrite
NOT PAGEABLE -- SrvFsdRestartReadRaw
NOT PAGEABLE -- SrvFsdRestartWriteRaw
#endif

#if DBG
VOID
DumpMdlChain(
    IN PMDL mdl
    );
#endif


VOID
SrvFsdBuildWriteCompleteResponse (
    IN OUT PWORK_CONTEXT WorkContext,
    IN NTSTATUS Status,
    IN ULONG BytesWritten
    )

/*++

Routine Description:

    Sets up a final response to a Write Block Raw/Mpx request.

    This routine is called in both the FSP and the FSD.  It can be called
    in the FSD only if Status == STATUS_SUCCESS.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

    Status - Supplies a status value to be returned to the client.

    BytesWritten - Supplies the number of bytes actually written.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - Returns SmbStatusSendResponse.

--*/

{
    PSMB_HEADER header;
    PRESP_WRITE_COMPLETE response;

    if ( WorkContext->Rfcb != NULL ) {
        UNLOCKABLE_CODE( 8FIL );
    } else {
        ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );
    }

    //
    // Get pointers to the header and the response parameters area.
    // Note that Write Block Raw/Mpx can't be chained to an AndX SMB.
    //

    header = WorkContext->ResponseHeader;
    response = (PRESP_WRITE_COMPLETE)WorkContext->ResponseParameters;

    //
    // Change the SMB command code to Write Complete.
    //

    header->Command = SMB_COM_WRITE_COMPLETE;

    //
    // Put the error code in the header.  Note that SrvSetSmbError
    // writes a null parameter area to the end of the SMB; we overwrite
    // that with our own parameter area.
    //

    if ( Status != STATUS_SUCCESS ) {
        ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );
        SrvSetSmbError2( WorkContext, Status, TRUE );
    }

    //
    // Build the response SMB.
    //

    response->WordCount = 1;
    SmbPutUshort( &response->Count, (USHORT)BytesWritten );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_WRITE_COMPLETE,
                                        0
                                        );

    return;

} // SrvFsdBuildWriteCompleteResponse


NTSTATUS
RestartCopyReadRawResponse (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the restart routine that is invoked when the send of a
    Read Block Raw response completes.

    This routine is called in the FSD.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    WorkContext - Caller-specified context parameter associated with IRP.
        This is actually a pointer to a Work Context block.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED.

--*/

{
    KIRQL oldIrql;
    PCONNECTION connection;

    IF_DEBUG(FSD1) SrvPrint0( " - RestartCopyReadRawResponse\n" );

    //
    // Check the status of the send completion.
    //

    CHECK_SEND_COMPLETION_STATUS( Irp->IoStatus.Status );

    //
    // Reset the IRP cancelled bit.
    //

    Irp->Cancel = FALSE;

    //
    // Deallocate the raw buffer, if the original SMB buffer was not
    // used.  Note that we do not need to unlock the raw buffer, because
    // it was allocated out of nonpaged pool and locked using
    // MmBuildMdlForNonPagedPool, which doesn't increment reference
    // counts and therefore has no inverse.
    //

    if ( WorkContext->Parameters.ReadRaw.SavedResponseBuffer != NULL ) {

        DEALLOCATE_NONPAGED_POOL( WorkContext->ResponseBuffer->Buffer );

        IoFreeMdl( WorkContext->ResponseBuffer->Mdl );

        DEALLOCATE_NONPAGED_POOL( WorkContext->ResponseBuffer );
        WorkContext->ResponseBuffer =
                        WorkContext->Parameters.ReadRaw.SavedResponseBuffer;

    }

    //
    // If there is an oplock break request pending, then we must go to the
    // FSP to initiate the break, otherwise complete processing in the FSD.
    //

    connection = WorkContext->Connection;

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
    ACQUIRE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

    if ( IsListEmpty( &connection->OplockWorkList ) ) {

        //
        // Dereference control blocks and put the work item back on the
        // receive queue.
        //

        WorkContext->Connection->RawReadsInProgress--;
        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        SrvFsdRestartSmbComplete( WorkContext );

    } else {

        //
        // Send this work context to the FSP for completion.
        //

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        WorkContext->FspRestartRoutine = SrvRestartReadRawComplete;
        QUEUE_WORK_TO_FSP( WorkContext );

    }

    IF_DEBUG(TRACE2) SrvPrint0( "RestartCopyReadRawResponse complete\n" );

    KeLowerIrql( oldIrql );
    return STATUS_MORE_PROCESSING_REQUIRED;

} // RestartCopyReadRawResponse


VOID SRVFASTCALL
SrvFsdRestartPrepareRawMdlWrite(
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Restart routine for completion of a "prepare MDL write" I/O request.
    Prepares a work context block and an IRP describing the raw receive,
    posts the receive, and sends a "go-ahead" response.

    This routine is called in both the FSP and the FSD.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PREQ_WRITE_RAW request;
    PRESP_WRITE_RAW_INTERIM response;

    PVOID finalResponseBuffer;
    PWORK_CONTEXT rawWorkContext;
    ULONG writeLength;
    ULONG immediateLength;
    BOOLEAN immediateWriteDone;
    PMDL mdl;

    PCHAR src;
    PCHAR dest;
    ULONG lengthToCopy;

    PIO_STACK_LOCATION irpSp;
    BOOLEAN       bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE_RAW;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    IF_DEBUG(FSD1) SrvPrint0( " - SrvFsdRestartPrepareRawMdlWrite\n" );

    //
    // Get request parameters and saved context.
    //

    request = (PREQ_WRITE_RAW)WorkContext->RequestParameters;

    rawWorkContext = WorkContext->Parameters.WriteRawPhase1.RawWorkContext;

    writeLength = SmbGetUshort( &request->Count );
    immediateLength = SmbGetUshort( &request->DataLength );
    immediateWriteDone = rawWorkContext->Parameters.WriteRaw.ImmediateWriteDone;
    if ( immediateWriteDone ) {
        writeLength -= immediateLength;
    }

    finalResponseBuffer =
        rawWorkContext->Parameters.WriteRaw.FinalResponseBuffer;

    //
    // If the prepare MDL write I/O failed, send an error response.
    //

    if ( !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvFsdRestartPrepareRawMdlWrite: Write failed: %X\n",
                        WorkContext->Irp->IoStatus.Status );
        }

        //
        // We won't be needing the final response buffer or the raw mode
        // work item.
        //

        if ( finalResponseBuffer != NULL ) {
            DEALLOCATE_NONPAGED_POOL( finalResponseBuffer );
        }

        rawWorkContext->ResponseBuffer->Buffer = NULL;
        RestartWriteCompleteResponse( rawWorkContext );

        //
        // Build and send the response.
        //

        if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
            WorkContext->Irp->IoStatus.Information =
                                    immediateWriteDone ? immediateLength : 0;
            WorkContext->FspRestartRoutine = SrvBuildAndSendWriteCompleteResponse;
            WorkContext->FsdRestartRoutine = SrvFsdRestartSmbComplete; // after response
            QUEUE_WORK_TO_FSP( WorkContext );
        } else {
            SrvFsdBuildWriteCompleteResponse(
                WorkContext,
                WorkContext->Irp->IoStatus.Status,
                immediateWriteDone ? immediateLength : 0
                );
            SrvFsdSendResponse( WorkContext );
        }

        IF_DEBUG(TRACE2) {
            SrvPrint0( "SrvFsdRestartPrepareRawMdlWrite complete\n" );
        }
        goto Cleanup;

    }

    //
    // If a final response is going to be sent, save information from
    // the request in the final response buffer.
    //

    if ( finalResponseBuffer != NULL ) {
        RtlCopyMemory(
            (PSMB_HEADER)finalResponseBuffer,
            WorkContext->RequestHeader,
            sizeof(SMB_HEADER)
            );
    }

    //
    // If the immediate data has not yet been written, copy it now.
    //

    mdl = WorkContext->Irp->MdlAddress;
#if DBG
    IF_SMB_DEBUG(RAW2) {
        KdPrint(( "SrvFsdRestartPrepareRawMdlWrite: input chain:\n" ));
        DumpMdlChain( mdl );
    }
#endif
    rawWorkContext->Parameters.WriteRaw.FirstMdl = mdl;

    if ( !immediateWriteDone ) {

        src = (PCHAR)WorkContext->RequestHeader +
                                    SmbGetUshort( &request->DataOffset );

        while ( immediateLength ) {

            lengthToCopy = MIN( immediateLength, mdl->ByteCount );
            dest = MmGetSystemAddressForMdlSafe( mdl,NormalPoolPriority );

            if (dest == NULL) {
                WorkContext->Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                WorkContext->Irp->IoStatus.Information = 0;
                WorkContext->FspRestartRoutine = SrvBuildAndSendWriteCompleteResponse;
                WorkContext->FsdRestartRoutine = SrvFsdRestartSmbComplete; // after response
                QUEUE_WORK_TO_FSP( WorkContext );
                goto Cleanup;
            }

            RtlCopyMemory( dest, src, lengthToCopy );

            src += lengthToCopy;
            immediateLength -= lengthToCopy;
            writeLength -= lengthToCopy;

            if ( lengthToCopy == mdl->ByteCount ) {

                mdl = mdl->Next;

            } else {

                PCHAR baseVa;
                ULONG lengthOfMdl;
                PMDL rawMdl;

                ASSERT( immediateLength == 0 );
                baseVa = (PCHAR)MmGetMdlVirtualAddress(mdl) + lengthToCopy;
                lengthOfMdl = mdl->ByteCount - lengthToCopy;
                ASSERT( lengthOfMdl <= 65535 );

                rawMdl = rawWorkContext->RequestBuffer->Mdl;
                rawMdl->Size = (CSHORT)(sizeof(MDL) + (sizeof(ULONG_PTR) *
                    ADDRESS_AND_SIZE_TO_SPAN_PAGES( baseVa, lengthOfMdl )));

                IoBuildPartialMdl( mdl, rawMdl, baseVa, lengthOfMdl );

                rawMdl->Next = mdl->Next;
#if DBG
                IF_SMB_DEBUG(RAW2) {
                    KdPrint(( "SrvFsdRestartPrepareRawMdlWrite: built partial MDL at 0x%p\n", rawMdl ));
                    DumpMdlChain( rawMdl );
                }
#endif

                mdl = rawMdl;

            }

        }

    }

    //
    // Save the length of the raw write.
    //

    rawWorkContext->RequestBuffer->BufferLength = writeLength;

    //
    // Set up the restart routines in the work context.
    //

    rawWorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    rawWorkContext->FspRestartRoutine = SrvRestartRawReceive;

    //
    // Build the TdiReceive request packet.
    //


    {
        PIRP irp = rawWorkContext->Irp;
        PTDI_REQUEST_KERNEL_RECEIVE parameters;

        irp->Tail.Overlay.OriginalFileObject = NULL;
        irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
        DEBUG irp->RequestorMode = KernelMode;

        //
        // Get a pointer to the next stack location.  This one is used to
        // hold the parameters for the device I/O control request.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Set up the completion routine.
        //

        IoSetCompletionRoutine(
            irp,
            SrvFsdIoCompletionRoutine,
            rawWorkContext,
            TRUE,
            TRUE,
            TRUE
            );

        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpSp->MinorFunction = (UCHAR)TDI_RECEIVE;

        irpSp->FileObject = NULL;
        irpSp->DeviceObject = NULL;

        //
        // Copy the caller's parameters to the service-specific portion of the
        // IRP for those parameters that are the same for all three methods.
        //

        parameters = (PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters;
        parameters->ReceiveLength = writeLength;
        parameters->ReceiveFlags = 0;

        irp->MdlAddress = mdl;
        irp->AssociatedIrp.SystemBuffer = NULL;
        irp->Flags = (ULONG)IRP_BUFFERED_IO;
    }

    IF_SMB_DEBUG(RAW2) {
        KdPrint(( "Issuing receive with MDL %p\n", rawWorkContext->Irp->MdlAddress ));
    }

    irpSp = IoGetNextIrpStackLocation( rawWorkContext->Irp );

    //
    // If this is a writebehind write, tell the transport that we don't
    // plan to reply to the received message.
    //

    if ( finalResponseBuffer == NULL ) {
        ((PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters)->ReceiveFlags |=
                                                TDI_RECEIVE_NO_RESPONSE_EXP;
    }

    //
    // Post the receive.
    //

    irpSp->Flags = 0;
    irpSp->DeviceObject = rawWorkContext->Connection->DeviceObject;
    irpSp->FileObject = rawWorkContext->Connection->FileObject;

    ASSERT( rawWorkContext->Irp->StackCount >=
                                    irpSp->DeviceObject->StackSize );

    (VOID)IoCallDriver( irpSp->DeviceObject, rawWorkContext->Irp );

    //
    // Send the interim (go-ahead) response.
    //

    response = (PRESP_WRITE_RAW_INTERIM)WorkContext->ResponseParameters;

    response->WordCount = 1;
    SmbPutUshort( &response->Remaining, (USHORT)-1 );
    SmbPutUshort( &response->ByteCount, 0 );
    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_WRITE_RAW_INTERIM,
                                        0
                                        );

    SrvFsdSendResponse( WorkContext );

    IF_DEBUG(TRACE2) SrvPrint0( "SrvFsdRestartPrepareRawMdlWrite complete\n" );

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // SrvFsdRestartPrepareRawMdlWrite


VOID SRVFASTCALL
SrvFsdRestartReadRaw (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file read completion for the Read Block Raw SMB.

    This routine is called in both the FSP and the FSD.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PRFCB rfcb;
    KIRQL oldIrql;
    USHORT readLength;
    BOOLEAN       bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ_RAW;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    IF_DEBUG(FSD1) SrvPrint0( " - SrvFsdRestartReadRaw\n" );

    //
    // Get the file pointer.
    //

    rfcb = WorkContext->Rfcb;
    IF_DEBUG(TRACE2) {
        SrvPrint2( "  connection 0x%p, RFCB 0x%p\n",
                    WorkContext->Connection, rfcb );
    }

    //
    // Calculate the amount of data read.
    //

    if ( WorkContext->Irp->IoStatus.Status == STATUS_END_OF_FILE ) {

        readLength = 0;
        IF_SMB_DEBUG(RAW2) {
            SrvPrint0( "SrvFsdRestartReadRaw: 0 bytes read, at end-of-file\n" );
        }

    } else if ( !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ) {

        readLength = 0;
        IF_SMB_DEBUG(ERRORS) {
            SrvPrint1( "SrvFsdRestartReadRaw: read request failed: %X\n",
                           WorkContext->Irp->IoStatus.Status );
        }

    } else if ( WorkContext->Parameters.ReadRaw.MdlRead ) {

        //
        // For an MDL read, we have to walk the MDL chain in order to
        // determine how much data was read.  This is because the
        // operation may have happened in multiple step, with the MDLs
        // being chained together.  For example, part of the read may
        // have been satisfied by the fast path, while the rest was
        // satisfied using an IRP.
        //

#if DBG
        ULONG mdlCount = 0;
#endif
        PMDL mdl = WorkContext->Irp->MdlAddress;

        readLength = 0;

        while ( mdl != NULL ) {
            IF_SMB_DEBUG(RAW2) {
#if DBG
                SrvPrint3( "  mdl %ld at 0x%p, %ld bytes\n",
                            mdlCount,
                            mdl, MmGetMdlByteCount(mdl) );
#else
                SrvPrint3( "  mdl 0x%p, %ld bytes\n",
                            mdl, MmGetMdlByteCount(mdl) );
#endif
            }
            readLength += (USHORT)MmGetMdlByteCount(mdl);
#if DBG
            mdlCount++;
#endif
            mdl = mdl->Next;
        }
        IF_SMB_DEBUG(RAW2) {
#if DBG
            SrvPrint2( "SrvFsdRestartReadRaw: %ld bytes in %ld MDLs\n",
                        readLength, mdlCount );
#else
            SrvPrint2( "SrvFsdRestartReadRaw: %ld bytes\n",
                        readLength );
#endif
            SrvPrint1( "                      info = 0x%p\n",
                        (PVOID)WorkContext->Irp->IoStatus.Information );
        }

    } else {

        //
        // Copy read.  The I/O status block has the length.
        //

        readLength = (USHORT)WorkContext->Irp->IoStatus.Information;
        IF_SMB_DEBUG(RAW2) {
            SrvPrint1( "SrvFsdRestartReadRaw: %ld bytes read\n", readLength );
        }

    }

    //
    // Update the file position.
    //
    // *** Note that we ignore the status of the operation, except to
    //     check for end-of-file, since we can't tell the client what
    //     the status was.  We simply return as many bytes as the file
    //     system says were read.
    //
    // !!! Should we save the error and return it when the client
    //     retries?
    //
    // !!! Need to worry about wraparound?
    //

    if ( rfcb->ShareType == ShareTypeDisk ) {

        rfcb->CurrentPosition =
            WorkContext->Parameters.ReadRaw.ReadRawOtherInfo.Offset.LowPart +
            readLength;

    }

    //
    // Save the count of bytes read, to be used to update the server
    // statistics database.
    //

    UPDATE_READ_STATS( WorkContext, readLength );

    //
    // Send the raw read data as the response.
    //

    WorkContext->ResponseBuffer->DataLength = readLength;

    //
    // There is no header on this SMB, do not generate a security signature
    //
    WorkContext->NoResponseSmbSecuritySignature = TRUE;

    if ( WorkContext->Parameters.ReadRaw.MdlRead ) {

        //
        // MDL read.  The data is described by the MDL returned by the
        // file system (in irp->MdlAddress).
        //
        // *** Note that if the read failed completely (which happens if
        //     the read starts beyond EOF), there is no MDL.
        //     SrvStartSend handles this appropriately.  So must
        //     RestartMdlReadRawResponse.
        //

        //
        // Send the response.
        //

        SRV_START_SEND(
            WorkContext,
            WorkContext->Irp->MdlAddress,
            0,
            SrvQueueWorkToFspAtSendCompletion,
            NULL,
            RestartMdlReadRawResponse
            );

    } else {

        //
        // Copy read.  The data is described by the MDL allocated in
        // SrvFsdSmbReadRaw.
        //
        // *** Changing Mdl->ByteCount like this would be a problem if
        //     we had to unlock the pages in RestartCopyReadRawResponse,
        //     because we might end up unlocking fewer pages than we
        //     locked.  But we don't actually lock the pages to build
        //     the MDL -- the buffer is allocated from nonpaged pool, so
        //     we use MmBuildMdlForNonPagedPool rather than
        //     MmProbeAndLockPages.  So the pages haven't been
        //     referenced to account for the MDL, so there's no need to
        //     unlock them, so changing ByteCount isn't a problem.
        //

        //
        // Send the response.
        //

        SRV_START_SEND_2(
            WorkContext,
            RestartCopyReadRawResponse,
            NULL,
            NULL
            );

    }

    //
    // The response send has been started.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "SrvFsdRestartReadRaw complete\n" );

    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // SrvFsdRestartReadRaw


VOID SRVFASTCALL
RestartWriteCompleteResponse (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine attempts, at DPC level, to clean up after a Write Raw
    completes.  It tries to dereference control blocks referenced by the
    raw mode work item.  If this cannot be done at DPC level (e.g., a
    reference count goes to zero), this routine queues the work item to
    the FSP for processing.

    This routine is called in the FSD.  Its FSP counterpart is
    SrvRestartWriteCompleteResponse.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    KIRQL oldIrql;
    PRFCB rfcb;
    PWORK_QUEUE queue;

    UNLOCKABLE_CODE( 8FIL );

    IF_DEBUG(FSD1) SrvPrint0( " - RestartWriteCompleteResponse\n" );

    connection = WorkContext->Connection;
    queue = connection->CurrentWorkQueue;

    //
    // If a final response was sent, check the status and deallocate the
    // buffer.
    //

    if ( WorkContext->ResponseBuffer->Buffer != NULL ) {

        //
        // If the I/O request failed or was canceled, print an error
        // message.
        //
        // !!! If I/O failure, should we drop the connection?
        //

        if ( WorkContext->Irp->Cancel ||
             !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ) {

            IF_DEBUG(FSD1) {
                if ( WorkContext->Irp->Cancel ) {
                    SrvPrint0( "  I/O canceled\n" );
                } else {
                    SrvPrint1( "  I/O failed: %X\n",
                                WorkContext->Irp->IoStatus.Status );
                }
            }

        }

        //
        // Deallocate the final response buffer.
        //
        // *** Note that we don't need to unlock it, because it was
        //     allocated from nonpaged pool.
        //

        DEALLOCATE_NONPAGED_POOL( WorkContext->ResponseBuffer->Buffer );

    }

    //
    // If the work context block has references to a share, a session,
    // or a tree connect, queue it to the FSP immediately.  These blocks
    // are not in nonpaged pool, so they can't be touched at DPC level.
    //

    if ( (WorkContext->Share != NULL) ||
         (WorkContext->Session != NULL) ||
         (WorkContext->TreeConnect != NULL) ) {

        goto queueToFsp;

    }

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    //
    // See if we can dereference the RawWriteCount here.  If the raw
    // write count goes to 0, and the RFCB is closing, or if there are
    // work items queued waiting for the raw write to complete, we need
    // to do this in the FSP.
    //
    // NOTE: The FSP decrements the count if WorkContext->Rfcb != NULL.
    //

    rfcb = WorkContext->Rfcb;
    --rfcb->RawWriteCount;

    if ( (rfcb->RawWriteCount == 0) &&
         ( (GET_BLOCK_STATE(rfcb) == BlockStateClosing) ||
           !IsListEmpty(&rfcb->RawWriteSerializationList) ) ) {

        rfcb->RawWriteCount++;

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
        goto queueToFsp;

    }

    //
    // Dereference the file block.  It is safe to decrement the count here
    // because either the rfcb is not closed or RawWriteCount is not zero
    // which means that the active reference is still there.
    //

    UPDATE_REFERENCE_HISTORY( rfcb, TRUE );
    --rfcb->BlockHeader.ReferenceCount;
    ASSERT( rfcb->BlockHeader.ReferenceCount > 0 );

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
    WorkContext->Rfcb = NULL;

    //
    // Attempt to dereference the connection.
    //

    ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );

    if ( connection->BlockHeader.ReferenceCount == 1 ) {
        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );
        goto queueToFsp;
    }

    --connection->BlockHeader.ReferenceCount;
    RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

    UPDATE_REFERENCE_HISTORY( connection, TRUE );

    WorkContext->Connection = NULL;
    WorkContext->Endpoint = NULL;       // not a referenced pointer

    //
    // Put the work item back on the raw mode work item list.
    //

    InterlockedIncrement( &queue->FreeRawModeWorkItems );

    ExInterlockedPushEntrySList( &queue->RawModeWorkItemList,
                                 &WorkContext->SingleListEntry,
                                 &queue->SpinLock );

    IF_DEBUG(FSD2) SrvPrint0( "RestartWriteCompleteResponse complete\n" );
    return;

queueToFsp:

    //
    // We were unable to do all the necessary cleanup at DPC level.
    // Queue the work item to the FSP.
    //

    WorkContext->FspRestartRoutine = SrvRestartWriteCompleteResponse;

    SrvQueueWorkToFsp( WorkContext );

    IF_DEBUG(FSD2) SrvPrint0( "RestartWriteCompleteResponse complete\n" );
    return;

} // RestartWriteCompleteResponse


VOID SRVFASTCALL
SrvFsdRestartWriteRaw (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file write completion for the Write Block Raw SMB.

    This routine is called in both the FSP and the FSD.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    ULONG writeLength;
    ULONG immediateLength;
    BOOLEAN immediateWriteDone;
    SHARE_TYPE shareType;
    PMDL mdl;
    ULONG sendLength;
    PVOID finalResponseBuffer;
    NTSTATUS status = STATUS_SUCCESS;
    PRFCB rfcb = WorkContext->Rfcb;

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE_RAW;
    SrvWmiStartContext(WorkContext);
    IF_DEBUG(FSD1) SrvPrint0( " - SrvFsdRestartWriteRaw\n" );

    //
    // Find out the file type that we are dealing with.  If it is a pipe
    // then we have not prewritten the immediate data.
    //
    // immediateLength is the length of the data sent with the write
    // block raw request.
    //

    shareType = rfcb->ShareType;
    immediateLength = WorkContext->Parameters.WriteRaw.ImmediateLength;
    immediateWriteDone = WorkContext->Parameters.WriteRaw.ImmediateWriteDone;

    //
    // Deallocate the raw receive buffer.  Note that we do not need to
    // unlock the raw buffer, because it was allocated out of nonpaged
    // pool and locked using MmBuildMdlForNonPagedPool, which doesn't
    // increment reference counts and therefore has no inverse.
    //

    if ( !WorkContext->Parameters.WriteRaw.MdlWrite ) {

        //
        // If this is a named pipe the request buffer actually points
        // "immediateLength" bytes into the write buffer.
        //

        if ( immediateWriteDone ) {
            DEALLOCATE_NONPAGED_POOL( WorkContext->RequestBuffer->Buffer );
            IF_SMB_DEBUG(RAW2) {
                SrvPrint1( "raw buffer 0x%p deallocated\n",
                            WorkContext->RequestBuffer->Buffer );
            }
        } else {
            DEALLOCATE_NONPAGED_POOL(
               (PCHAR)WorkContext->RequestBuffer->Buffer - immediateLength );
            IF_SMB_DEBUG(RAW2) {
                SrvPrint1( "raw buffer 0x%p deallocated\n",
                 (PCHAR)WorkContext->RequestBuffer->Buffer - immediateLength );
            }
        }

    }

    status = WorkContext->Irp->IoStatus.Status;

    //
    // If this is not a pipe we have already successfully written the
    // immediate pipe data, so return the total bytes written by the two
    // write operations.
    //

    writeLength = (ULONG)WorkContext->Irp->IoStatus.Information;

    if( NT_SUCCESS( status ) && writeLength == 0 ) {

        writeLength = WorkContext->Parameters.WriteRaw.Length;

    } else {

        if ( immediateWriteDone ) {
            writeLength += immediateLength;
        }
    }

    UPDATE_WRITE_STATS( WorkContext, writeLength );

    finalResponseBuffer = WorkContext->Parameters.WriteRaw.FinalResponseBuffer;

    //
    // Update the file position.
    //
    // !!! Need to worry about wraparound?
    //

    if ( shareType == ShareTypeDisk || shareType == ShareTypePrint ) {

        rfcb->CurrentPosition =
                WorkContext->Parameters.WriteRaw.Offset.LowPart + writeLength;

    }

    if ( finalResponseBuffer == NULL ) {

        //
        // Update server statistics.
        //

        UPDATE_STATISTICS( WorkContext, 0, SMB_COM_WRITE_RAW );

        //
        // Save the write behind error, if any.
        //

        if ( !NT_SUCCESS( status ) ) {

            //
            // because of our assumption that the cached rfcb does
            // not have a write behind error stored.  This saves us
            // a compare on our critical path.
            //

            if ( WorkContext->Connection->CachedFid == (ULONG)rfcb->Fid ) {
                WorkContext->Connection->CachedFid = (ULONG)-1;
            }
            rfcb->SavedError = status;
        }

        //
        // Dereference control blocks, etc.
        //

        WorkContext->ResponseBuffer->Buffer = NULL;

        RestartWriteCompleteResponse( WorkContext );

        IF_DEBUG(TRACE2) SrvPrint0( "SrvFsdRestartWriteRaw complete\n" );
        goto Cleanup;

    }

    //
    // Writethrough mode.  Send a response to the client.  We have to
    // get a little tricky here, to make the raw mode work item look
    // enough like a normal one to be able to send using it.  Note that
    // the header from the original request SMB was copied into the
    // final response buffer.
    //

    WorkContext->ResponseHeader = (PSMB_HEADER)finalResponseBuffer;
    WorkContext->ResponseParameters = WorkContext->ResponseHeader + 1;

    ASSERT( WorkContext->RequestBuffer == WorkContext->ResponseBuffer );

    WorkContext->ResponseBuffer->Buffer = finalResponseBuffer;
    sendLength = (ULONG)( (PCHAR)NEXT_LOCATION(
                                    WorkContext->ResponseParameters,
                                    RESP_WRITE_COMPLETE,
                                    0
                                    ) - (PCHAR)finalResponseBuffer );
    WorkContext->ResponseBuffer->DataLength = sendLength;

    //
    // Remap the MDL to describe the final response buffer.
    //

    mdl = WorkContext->ResponseBuffer->Mdl;

    MmInitializeMdl( mdl, finalResponseBuffer, sendLength );
    MmBuildMdlForNonPagedPool( mdl );

    //
    // Set the bit in the SMB that indicates this is a response from the
    // server.
    //

    WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

    //
    // Send the response.  When the send completes, the restart routine
    // RestartWriteCompleteResponse is called.  We then dereference
    // control blocks and put the raw mode work item back on the free
    // list.
    //

    if ( (status != STATUS_SUCCESS) &&
         (KeGetCurrentIrql() >= DISPATCH_LEVEL) ) {
        WorkContext->Irp->IoStatus.Status = status;
        WorkContext->Irp->IoStatus.Information = writeLength;
        WorkContext->FspRestartRoutine = SrvBuildAndSendWriteCompleteResponse;
        WorkContext->FsdRestartRoutine = RestartWriteCompleteResponse; // after response
        QUEUE_WORK_TO_FSP( WorkContext );
    } else {
        SrvFsdBuildWriteCompleteResponse(
            WorkContext,
            status,
            writeLength
            );
        SRV_START_SEND_2(
            WorkContext,
            SrvFsdSendCompletionRoutine,
            RestartWriteCompleteResponse,
            NULL
            );
    }

Cleanup:
    SrvWmiEndContext(WorkContext);
    return;

} // SrvFsdRestartWriteRaw
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\errorlog.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    errorlog.h

Abstract:

    This module contains the manifests and macros used for error logging
    in the server.

Author:

    Manny Weiser (mannyw)    11-Feb-92

Revision History:

--*/

//
// Routines for writing error log entries.
//

VOID
SrvLogError (
    IN PVOID DeviceOrDriverObject,
    IN ULONG UniqueErrorCode,
    IN NTSTATUS NtStatusCode,
    IN PVOID RawDataBuffer,
    IN USHORT RawDataLength,
    IN PUNICODE_STRING InsertionString,
    IN ULONG InsertionStringCount
    );

VOID
SrvLogInvalidSmbDirect (
    IN PWORK_CONTEXT WorkContext,
    IN ULONG LineNumber
    );

VOID
SrvLogServiceFailureDirect (
    IN ULONG LineAndService,
    IN NTSTATUS Status
    );

#define SrvLogSimpleEvent( _event, _status ) SrvLogError( SrvDeviceObject, (_event), (_status), NULL, 0, NULL, 0 )
#define SrvLogServiceFailure( _Service, _Status ) SrvLogServiceFailureDirect( (__LINE__<<16) | _Service, _Status )
#define SrvLogInvalidSmb( _Context ) SrvLogInvalidSmbDirect( _Context, __LINE__ )

VOID
SrvLogTableFullError (
    IN ULONG Type
    );

VOID
SrvCheckSendCompletionStatus(
    IN NTSTATUS status,
    IN ULONG LineNumber
    );

//
// Error log raw data constants.  Used to describe allocation type or
// service call that failed.  These codes are encoded in the lower word
// by the 'SrvLogServiceFailure' macro above, therefore the value must
// fit into 2 bytes.
//
// Not every error is logged.  There is an error code filter that weeds out
//  some of the most common, and somewhat expected, error codes.  However,
//  a component bypasses this error code weeding if the 0x1 bit is set in
//  the constant.
//
// These numeric codes are arbitrary, just ensure they are unique
//
//

#define SRV_TABLE_FILE                      0x300
#define SRV_TABLE_SEARCH                    0x302
#define SRV_TABLE_SESSION                   0x304
#define SRV_TABLE_TREE_CONNECT              0x306

#define SRV_RSRC_BLOCKING_IO                0x308
#define SRV_RSRC_FREE_CONNECTION            0x30a
#define SRV_RSRC_FREE_RAW_WORK_CONTEXT      0x30c
#define SRV_RSRC_FREE_WORK_CONTEXT          0x30e

#define SRV_SVC_IO_CREATE_FILE              0x310
#define SRV_SVC_KE_WAIT_MULTIPLE            0x312
#define SRV_SVC_KE_WAIT_SINGLE              0x314
#define SRV_SVC_LSA_CALL_AUTH_PACKAGE       0x317       // log all codes
#define SRV_SVC_NT_IOCTL_FILE               0x31a
#define SRV_SVC_NT_QUERY_EAS                0x31c
#define SRV_SVC_NT_QUERY_INFO_FILE          0x31e
#define SRV_SVC_NT_QUERY_VOL_INFO_FILE      0x320
#define SRV_SVC_NT_READ_FILE                0x322
#define SRV_SVC_NT_REQ_WAIT_REPLY_PORT      0x324
#define SRV_SVC_NT_SET_EAS                  0x326
#define SRV_SVC_NT_SET_INFO_FILE            0x328
#define SRV_SVC_NT_SET_INFO_PROCESS         0x32a
#define SRV_SVC_NT_SET_INFO_THREAD          0x32c
#define SRV_SVC_NT_SET_VOL_INFO_FILE        0x32e
#define SRV_SVC_NT_WRITE_FILE               0x330
#define SRV_SVC_OB_REF_BY_HANDLE            0x333       // log all codes
#define SRV_SVC_PS_CREATE_SYSTEM_THREAD     0x334
#define SRV_SVC_SECURITY_PKG_PROBLEM        0x337       // log all codes
#define SRV_SVC_LSA_LOOKUP_PACKAGE          0x339       // log all codes
#define SRV_SVC_IO_CREATE_FILE_NPFS         0x33a
#define SRV_SVC_PNP_TDI_NOTIFICATION        0x33c
#define SRV_SVC_IO_FAST_QUERY_NW_ATTRS      0x33e
#define SRV_SVC_PS_TERMINATE_SYSTEM_THREAD  0x341       // log all codes
#define SRV_SVC_MDL_COMPLETE                0x342
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\fsd.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fsd.c

Abstract:

    This module implements the File System Driver for the LAN Manager
    server.

Author:

    Chuck Lenzmeier (chuckl)    22-Sep-1989

Revision History:

--*/

//
//  This module is laid out as follows:
//      Includes
//      Local #defines
//      Local type definitions
//      Forward declarations of local functions
//      Device driver entry points
//      Server I/O completion routine
//      Server transport event handlers
//      SMB processing support routines
//

#include "precomp.h"
#include "fsd.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_FSD
#define LOOPBACK_IP_ADDRESS 0x0100007f

extern UNICODE_STRING SrvDeviceName;
extern UNICODE_STRING SrvRegistryPath;

// We allow a connection a couple extra work contexts to cover the MAILSLOT and ECHO operation cases
#define MAX_MPX_MARGIN 10

//
// Forward declarations
//

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
UnloadServer (
    IN PDRIVER_OBJECT DriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( PAGE, UnloadServer )
#pragma alloc_text( PAGE, SrvPnpBindingHandler )
#pragma alloc_text( PAGE8FIL, SrvFsdOplockCompletionRoutine )
#pragma alloc_text( PAGE8FIL, SrvFsdRestartSendOplockIItoNone )
#endif
#if 0
NOT PAGEABLE -- SrvFsdIoCompletionRoutine
NOT PAGEABLE -- SrvFsdSendCompletionRoutine
NOT PAGEABLE -- SrvFsdTdiConnectHandler
NOT PAGEABLE -- SrvFsdTdiDisconnectHandler
NOT PAGEABLE -- SrvFsdTdiReceiveHandler
NOT PAGEABLE -- SrvFsdGetReceiveWorkItem
NOT PAGEABLE -- SrvFsdRestartSmbComplete
NOT PAGEABLE -- SrvFsdRestartSmbAtSendCompletion
NOT PAGEABLE -- SrvFsdServiceNeedResourceQueue
NOT PAGEABLE -- SrvAddToNeedResourceQueue
#endif

#if SRVDBG_STATS2
ULONG IndicationsCopied = 0;
ULONG IndicationsNotCopied = 0;
#endif

extern BOOLEAN RunSuspectConnectionAlgorithm;


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the LAN Manager server file
    system driver.  This routine creates the device object for the
    LanmanServer device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS status;
    CLONG i;

    PAGED_CODE( );

    //
    // Make sure we haven't messed up the size of a WORK_QUEUE structure.
    //  Really needs to be a multiple of CACHE_LINE_SIZE bytes to get
    //  proper performance on MP systems.
    //
    // This code gets optimized out when the size is correct.
    //
    if( sizeof( WORK_QUEUE ) & (CACHE_LINE_SIZE-1) ) {
        KdPrint(( "sizeof(WORK_QUEUE) == %d!\n", sizeof( WORK_QUEUE )));
        KdPrint(("Fix the WORK_QUEUE structure to be multiple of CACHE_LINE_SIZE!\n" ));
#if DBG
        DbgBreakPoint();
#endif
    }

#if SRVDBG_BREAK
    KdPrint(( "SRV: At DriverEntry\n" ));
    DbgBreakPoint( );
#endif

#if 0
    SrvDebug.QuadPart = DEBUG_ERRORS | DEBUG_SMB_ERRORS | DEBUG_TDI | DEBUG_PNP;
#endif

    IF_DEBUG(FSD1) KdPrint(( "SrvFsdInitialize entered\n" ));

#ifdef MEMPRINT
    //
    // Initialize in-memory printing.
    //

    MemPrintInitialize( );
#endif

    //
    // Create the device object.  (IoCreateDevice zeroes the memory
    // occupied by the object.)
    //
    // !!! Apply an ACL to the device object.
    //

    RtlInitUnicodeString(& SrvDeviceName, StrServerDevice);

    status = IoCreateDevice(
                 DriverObject,                   // DriverObject
                 sizeof(DEVICE_EXTENSION),       // DeviceExtension
                 & SrvDeviceName,                // DeviceName
                 FILE_DEVICE_NETWORK,            // DeviceType
                 0,                              // DeviceCharacteristics
                 FALSE,                          // Exclusive
                 &SrvDeviceObject                // DeviceObject
                 );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvFsdInitialize: Unable to create device object: %X",
            status,
            NULL
            );

        SrvLogError(
            DriverObject,
            EVENT_SRV_CANT_CREATE_DEVICE,
            status,
            NULL,
            0,
            NULL,
            0
            );
        return status;
    }

    IF_DEBUG(FSD1) {
        KdPrint(( "  Server device object: 0x%p\n", SrvDeviceObject ));
    }

    //
    // Initialize the driver object for this file system driver.
    //

    DriverObject->DriverUnload = UnloadServer;
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = SrvFsdDispatch;
    }

    //
    // Initialize global data fields.
    //

    SrvInitializeData( );

    // Remember registry path
    //
    SrvRegistryPath.MaximumLength = RegistryPath->Length + sizeof(UNICODE_NULL);
    SrvRegistryPath.Buffer = ExAllocatePool(PagedPool,
                                            SrvRegistryPath.MaximumLength);
    if (SrvRegistryPath.Buffer != NULL) {
        RtlCopyUnicodeString(& SrvRegistryPath, RegistryPath);
    }
    else {
        SrvRegistryPath.Length = SrvRegistryPath.MaximumLength = 0;
    }

    IF_DEBUG(FSD1) KdPrint(( "SrvFsdInitialize complete\n" ));

    return (status);

} // DriverEntry


VOID
UnloadServer (
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This is the unload routine for the server driver.

Arguments:

    DriverObject - Pointer to server driver object.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    if (SrvRegistryPath.Buffer != NULL ) ExFreePool(SrvRegistryPath.Buffer);

    //
    // If we are using a smart card to accelerate direct host IPX clients,
    //   let it know we are going away.
    //
    if( SrvIpxSmartCard.DeRegister ) {
        IF_DEBUG( SIPX ) {
            KdPrint(("Calling Smart Card DeRegister\n" ));
        }
        SrvIpxSmartCard.DeRegister();
    }


    //
    // Clean up global data structures.
    //

    SrvTerminateData( );

    //
    // Delete the server's device object.
    //

    IoDeleteDevice( SrvDeviceObject );

    return;

} // UnloadServer


NTSTATUS
SrvFsdIoCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the I/O completion routine for the server.  It is specified
    as the completion routine for asynchronous I/O requests issued by
    the server.  It simply calls the restart routine specified for the
    work item when the asynchronous request was started.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    Context - Caller-specified context parameter associated with IRP.
        This is actually a pointer to a Work Context block.

Return Value:

    NTSTATUS - If STATUS_MORE_PROCESSING_REQUIRED is returned, I/O
        completion processing by IoCompleteRequest terminates its
        operation.  Otherwise, IoCompleteRequest continues with I/O
        completion.

--*/

{
    KIRQL oldIrql;

    DeviceObject;   // prevent compiler warnings

    IF_DEBUG(FSD2) {
        KdPrint(( "SrvFsdIoCompletionRoutine entered for IRP 0x%p\n", Irp ));
    }

#if DBG
    if( Irp->Type != (CSHORT) IO_TYPE_IRP ) {
        DbgPrint( "SRV: Irp->Type = %u!\n", Irp->Type );
        DbgBreakPoint();
    }
#endif

    //
    // Reset the IRP cancelled bit.
    //

    Irp->Cancel = FALSE;

    //
    // Call the restart routine associated with the work item.
    //

    IF_DEBUG(FSD2) {
        KdPrint(( "FSD working on work context 0x%p", Context ));
    }
    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
    ((PWORK_CONTEXT)Context)->FsdRestartRoutine( (PWORK_CONTEXT)Context );
    KeLowerIrql( oldIrql );

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // SrvFsdIoCompletionRoutine


NTSTATUS
SrvFsdSendCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the TDI send completion routine for the server. It simply
    calls the restart routine specified for the work item when the
    send request was started.

    !!! This routine does the exact same thing as SrvFsdIoCompletionRoutine.
        It offers, however, a convienient network debugging routine since
        it completes only sends.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    Context - Caller-specified context parameter associated with IRP.
        This is actually a pointer to a Work Context block.

Return Value:

    NTSTATUS - If STATUS_MORE_PROCESSING_REQUIRED is returned, I/O
        completion processing by IoCompleteRequest terminates its
        operation.  Otherwise, IoCompleteRequest continues with I/O
        completion.

--*/

{
    KIRQL oldIrql;
    PWORK_CONTEXT WorkContext = (PWORK_CONTEXT)(Context);
    DeviceObject;   // prevent compiler warnings

    IF_DEBUG(FSD2) {
        KdPrint(( "SrvFsdSendCompletionRoutine entered for IRP 0x%p\n", Irp ));
    }

    //
    // Check the status of the send completion.
    //

    CHECK_SEND_COMPLETION_STATUS( Irp->IoStatus.Status );

    //
    // Reset the IRP cancelled bit.
    //

    Irp->Cancel = FALSE;

    //
    // Call the restart routine associated with the work item.
    //

    IF_DEBUG(FSD2) {
        KdPrint(( "FSD working on work context 0x%p", Context ));
    }
    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
    ((PWORK_CONTEXT)Context)->FsdRestartRoutine( (PWORK_CONTEXT)Context );
    KeLowerIrql( oldIrql );

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // SrvFsdSendCompletionRoutine


NTSTATUS
SrvFsdOplockCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the I/O completion routine oplock requests.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    Context - A pointer to the oplock context block.

Return Value:

    NTSTATUS - If STATUS_MORE_PROCESSING_REQUIRED is returned, I/O
        completion processing by IoCompleteRequest terminates its
        operation.  Otherwise, IoCompleteRequest continues with I/O
        completion.

--*/

{
    PRFCB rfcb = Context;

    UNLOCKABLE_CODE( 8FIL );

    DeviceObject;   // prevent compiler warnings

    IF_DEBUG(FSD2) {
        KdPrint(( "SrvFsdOplockCompletionRoutine entered for IRP 0x%p\n", Irp ));
    }

    //
    // Queue the oplock context to the FSP work queue, except in the
    // following special case: If a level I oplock request failed, and
    // we want to retry for level II, simply set the oplock retry event
    // and dismiss IRP processing.  This is useful because it eliminates
    // a trip to an FSP thread and necessary in order to avoid a
    // deadlock where all of the FSP threads are waiting for their
    // oplock retry events.
    //

    IF_DEBUG(FSD2) {
        KdPrint(( "FSD working on work context 0x%p", Context ));
    }

    if ( (rfcb->RetryOplockRequest != NULL) &&
         !NT_SUCCESS(Irp->IoStatus.Status) ) {

        //
        // Set the event that tells the oplock request routine that it
        // is OK to retry the request.
        //

        IF_DEBUG(OPLOCK) {
            KdPrint(( "SrvFsdOplockCompletionRoutine: oplock retry event "
                        "set for RFCB %p\n", rfcb ));
        }

        KeSetEvent(
            rfcb->RetryOplockRequest,
            EVENT_INCREMENT,
            FALSE );

        return STATUS_MORE_PROCESSING_REQUIRED;

    }

    //
    // Insert the RFCB at the tail of the nonblocking work queue.
    //

    rfcb->FspRestartRoutine = SrvOplockBreakNotification;

    SrvInsertWorkQueueTail(
        rfcb->Connection->PreferredWorkQueue,
        (PQUEUEABLE_BLOCK_HEADER)rfcb
        );

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // SrvFsdOplockCompletionRoutine


NTSTATUS
SrvFsdTdiConnectHandler(
    IN PVOID TdiEventContext,
    IN int RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN int UserDataLength,
    IN PVOID UserData,
    IN int OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    )

/*++

Routine Description:

    This is the transport connect event handler for the server.  It is
    specified as the connect handler for all endpoints opened by the
    server.  It attempts to dequeue a free connection from a list
    anchored in the endpoint.  If successful, it returns the connection
    to the transport.  Otherwise, the connection is rejected.

Arguments:

    TdiEventContext -

    RemoteAddressLength -

    RemoteAddress -

    UserDataLength -

    UserData -

    OptionsLength -

    Options -

    ConnectionContext -

Return Value:

    NTSTATUS - !!! (apparently ignored by transport driver)

--*/

{
    PENDPOINT endpoint;
    PLIST_ENTRY listEntry;
    PCONNECTION connection;
    PWORK_CONTEXT workContext;
    PTA_NETBIOS_ADDRESS address;
    KIRQL oldIrql;
    PWORK_QUEUE queue = PROCESSOR_TO_QUEUE();

    UserDataLength, UserData;               // avoid compiler warnings
    OptionsLength, Options;

    endpoint = (PENDPOINT)TdiEventContext;

    IF_DEBUG(FSD2) {
        KdPrint(( "SrvFsdTdiConnectHandler entered for endpoint 0x%p\n",
                    endpoint ));
    }

    if( SrvCompletedPNPRegistration == FALSE ) {
        //
        // Do not become active on any single transport until all of the
        //   transports have been registered
        //
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    //
    // Take a receive work item off the free list.
    //

    ALLOCATE_WORK_CONTEXT( queue, &workContext );

    if ( workContext == NULL ) {

        //
        // We're out of WorkContext structures, and we aren't able to allocate
        // any more just now.  Let's at least cause a worker thread to allocate some more
        // by incrementing the NeedWorkItem counter.  This will cause the next
        // freed WorkContext structure to get dispatched to SrvServiceWorkItemShortage.
        // While SrvServiceWorkItemShortage probably won't find any work to do, it will
        // allocate more WorkContext structures if it can.  Clients generally retry
        // on connection attempts -- perhaps we'll have a free WorkItem structure next time.
        //

        InterlockedIncrement( &queue->NeedWorkItem );

        // Set it up to refill the connection cache
        // We need to do this because previous attempts could have failed due to
        // out-of-memory, leaving us in a state where we don't try to refill anymore
        if( GET_BLOCK_STATE(endpoint) == BlockStateActive )
        {
            SrvResourceAllocConnection = TRUE;
            SrvFsdQueueExWorkItem(
                &SrvResourceAllocThreadWorkItem,
                &SrvResourceAllocThreadRunning,
                CriticalWorkQueue
                );
        }

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvFsdTdiConnectHandler: no work item available",
            NULL,
            NULL
            );

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    ACQUIRE_DPC_GLOBAL_SPIN_LOCK( Fsd );

    //
    // Take a connection off the endpoint's free connection list.
    //
    // *** Note that all of the modifications done to the connection
    //     block are done with the spin lock held.  This ensures that
    //     closing of the endpoint's connections will work properly
    //     if it happens simultaneously.  Note that we assume that the
    //     endpoint is active here.  When the TdiAccept completes, we
    //     check the endpoint state.
    //

    listEntry = RemoveHeadList( &endpoint->FreeConnectionList );

    if ( listEntry == &endpoint->FreeConnectionList ) {

        //
        // Unable to get a free connection.
        //
        // Dereference the work item manually.  We cannot call
        // SrvDereferenceWorkItem from here.
        //

        RELEASE_DPC_GLOBAL_SPIN_LOCK( Fsd );
        KeLowerIrql( oldIrql );

        ASSERT( workContext->BlockHeader.ReferenceCount == 1 );
        workContext->BlockHeader.ReferenceCount = 0;

        RETURN_FREE_WORKITEM( workContext );


        IF_DEBUG(TDI) {
            KdPrint(( "SrvFsdTdiConnectHandler: no connection available\n" ));
        }

        SrvOutOfFreeConnectionCount++;

        // Set it up to refill the connection cache
        // We need to do this because previous attempts could have failed due to
        // out-of-memory, leaving us in a state where we don't try to refill anymore
        if( GET_BLOCK_STATE(endpoint) == BlockStateActive )
        {
            SrvResourceAllocConnection = TRUE;
            SrvFsdQueueExWorkItem(
                &SrvResourceAllocThreadWorkItem,
                &SrvResourceAllocThreadRunning,
                CriticalWorkQueue
                );
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    endpoint->FreeConnectionCount--;

    //
    // Wake up the resource thread to create a new free connection for
    // the endpoint.
    //

    if ( (endpoint->FreeConnectionCount < SrvFreeConnectionMinimum) &&
         (GET_BLOCK_STATE(endpoint) == BlockStateActive) ) {
        SrvResourceAllocConnection = TRUE;
        SrvFsdQueueExWorkItem(
            &SrvResourceAllocThreadWorkItem,
            &SrvResourceAllocThreadRunning,
            CriticalWorkQueue
            );
    }

    RELEASE_DPC_GLOBAL_SPIN_LOCK( Fsd );

    //
    // Reference the connection twice -- once to account for its being
    // "open", and once to account for the Accept request we're about
    // to issue.
    //

    connection = CONTAINING_RECORD(
                    listEntry,
                    CONNECTION,
                    EndpointFreeListEntry
                    );


    ACQUIRE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

#if SRVDBG29
    if ( GET_BLOCK_STATE(connection) == BlockStateActive ) {
        KdPrint(( "SRV: Connection %x is ACTIVE on free connection list!\n", connection ));
        DbgBreakPoint( );
    }
    if ( connection->BlockHeader.ReferenceCount != 0 ) {
        KdPrint(( "SRV: Connection %x has nonzero refcnt on free connection list!\n", connection ));
        DbgBreakPoint( );
    }
    UpdateConnectionHistory( "CONN", endpoint, connection );
#endif

    SrvReferenceConnectionLocked( connection );
    SrvReferenceConnectionLocked( connection );

    //
    // Indicate that we are a VC-oriented connection
    //
    connection->DirectHostIpx = FALSE;

    //
    // Set the processor affinity
    //
    connection->PreferredWorkQueue = queue;
    connection->CurrentWorkQueue = queue;

    InterlockedIncrement( &queue->CurrentClients );

#if MULTIPROCESSOR
    //
    // Get this client onto the best processor
    //
    SrvBalanceLoad( connection );
#endif

    //
    // Initialize the SMB security signature handling
    //
    connection->SmbSecuritySignatureActive = FALSE;

    //
    // Put the work item on the in-progress list.
    //

    SrvInsertTailList(
        &connection->InProgressWorkItemList,
        &workContext->InProgressListEntry
        );
    connection->InProgressWorkContextCount++;

    //
    // Set the last used timestamp for this connection
    //
    GET_SERVER_TIME( connection->CurrentWorkQueue, &connection->LastRequestTime );

    //
    // Mark the connection active.
    //

    SET_BLOCK_STATE( connection, BlockStateActive );

    //
    // Now we can release the spin lock.
    //

    RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

    //
    // Save the client's address/name in the connection block.
    //
    // *** This code only handles NetBIOS names!
    //

    address = (PTA_NETBIOS_ADDRESS)RemoteAddress;
    ASSERT( address->TAAddressCount == 1 );
    ASSERT( address->Address[0].AddressType == TDI_ADDRESS_TYPE_NETBIOS );
    ASSERT( address->Address[0].AddressLength == sizeof(TDI_ADDRESS_NETBIOS) );
    ASSERT( address->Address[0].Address[0].NetbiosNameType ==
                                            TDI_ADDRESS_NETBIOS_TYPE_UNIQUE );

    //
    // Copy the oem name at this time.  We convert it to unicode when
    // we get to the fsp.
    //

    {
        ULONG len;
        PCHAR oemClientName = address->Address[0].Address[0].NetbiosName;
        ULONG oemClientNameLength =
                    (MIN( RemoteAddressLength, COMPUTER_NAME_LENGTH ));

        PCHAR clientMachineName = connection->OemClientMachineName;

        RtlCopyMemory(
                clientMachineName,
                oemClientName,
                oemClientNameLength
                );

        clientMachineName[oemClientNameLength] = '\0';

        //
        // Determine the number of characters that aren't blanks.  This is
        // used by the session APIs to simplify their processing.
        //

        for ( len = oemClientNameLength;
              len > 0 &&
                 (clientMachineName[len-1] == ' ' ||
                  clientMachineName[len-1] == '\0');
              len-- ) ;

        connection->OemClientMachineNameString.Length = (USHORT)len;

    }

    IF_DEBUG(TDI) {
        KdPrint(( "SrvFsdTdiConnectHandler accepting connection from %z on connection %p\n",
                    (PCSTRING)&connection->OemClientMachineNameString, connection ));
    }

    //
    // Convert the prebuilt TdiReceive request into a TdiAccept request.
    //

    workContext->Connection = connection;
    workContext->Endpoint = endpoint;

    (VOID)SrvBuildIoControlRequest(
            workContext->Irp,                   // input IRP address
            connection->FileObject,             // target file object address
            workContext,                        // context
            IRP_MJ_INTERNAL_DEVICE_CONTROL,     // major function
            TDI_ACCEPT,                         // minor function
            NULL,                               // input buffer address
            0,                                  // input buffer length
            NULL,                               // output buffer address
            0,                                  // output buffer length
            NULL,                               // MDL address
            NULL                                // completion routine
            );

    //
    // Make the next stack location current.  Normally IoCallDriver would
    // do this, but since we're bypassing that, we do it directly.
    //

    IoSetNextIrpStackLocation( workContext->Irp );

    //
    // Set up the restart routine.  This routine will verify that the
    // endpoint is active when the TdiAccept completes; if it isn't, the
    // connection will be closed at that time.
    //

    workContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    workContext->FspRestartRoutine = SrvRestartAccept;

    //
    // Return the connection context (the connection address) to the
    // transport.  Return a pointer to the Accept IRP.  Indicate that
    // the Connect event has been handled.
    //

    *ConnectionContext = connection;
    *AcceptIrp = workContext->Irp;

    KeLowerIrql( oldIrql );
    return STATUS_MORE_PROCESSING_REQUIRED;

} // SrvFsdTdiConnectHandler


NTSTATUS
SrvFsdTdiDisconnectHandler(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN int DisconnectDataLength,
    IN PVOID DisconnectData,
    IN int DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    )

/*++

Routine Description:

    This is the transport disconnect event handler for the server.  It
    is specified as the disconnect handler for all endpoints opened by
    the server.  It attempts to dequeue a preformatted receive item from
    a list anchored in the device object.  If successful, it turns this
    receive item into a disconnect item and queues it to the FSP work
    queue.  Otherwise, the resource thread is started to format
    additional work items and service pended (dis)connections.

Arguments:

    TransportEndpoint - Pointer to file object for receiving endpoint

    ConnectionContext - Value associated with endpoint by owner.  For
        the server, this points to a Connection block maintained in
        nonpaged pool.

    DisconnectIndicators - Set of flags indicating the status of the
        disconnect

Return Value:

    NTSTATUS - !!! (apparently ignored by transport driver)

--*/

{
    PCONNECTION connection;
    KIRQL oldIrql;

    TdiEventContext, DisconnectDataLength, DisconnectData;
    DisconnectInformationLength, DisconnectInformation, DisconnectFlags;

    if( DisconnectFlags & TDI_DISCONNECT_ABORT ) {
        SrvAbortiveDisconnects++;
    }

    connection = (PCONNECTION)ConnectionContext;

#if SRVDBG29
    UpdateConnectionHistory( "DISC", connection->Endpoint, connection );
#endif

    IF_DEBUG(FSD2) {
        KdPrint(( "SrvFsdTdiDisconnectHandler entered for endpoint 0x%p, connection 0x%p\n", TdiEventContext, connection ));
    }

    IF_DEBUG(TDI) {
        KdPrint(( "SrvFsdTdiDisconnectHandler received disconnect from %z on connection %p\n",
                    (PCSTRING)&connection->OemClientMachineNameString, connection ));
    }

    //
    // Mark the connection and wake up the resource thread so that it
    // can service the pending (dis)connections.
    //

    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
    ACQUIRE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

    //
    // If the connection is already closing, don't bother queueing it to
    // the disconnect queue.
    //

    if ( GET_BLOCK_STATE(connection) != BlockStateActive ) {

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
        return STATUS_SUCCESS;

    }

    if ( connection->DisconnectPending ) {

        //
        // Error! Error! Error!  This connection is already on
        // a queue for processing.  Ignore the disconnect request.
        //

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvFsdTdiDisconnectHandler:  Received unexpected disconnect"
                "indication",
            NULL,
            NULL
            );

        SrvLogSimpleEvent( EVENT_SRV_UNEXPECTED_DISC, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    connection->DisconnectPending = TRUE;

    if ( connection->OnNeedResourceQueue ) {

        //
        // This connection is waiting for a resource.  Take it
        // off the need resource queue before putting it on the
        // disconnect queue.
        //
        // *** Note that the connection has already been referenced to
        //     account for its being on the need-resource queue, so we
        //     don't reference it again here.
        //

        SrvRemoveEntryList(
            &SrvNeedResourceQueue,
            &connection->ListEntry
            );
        connection->OnNeedResourceQueue = FALSE;

        DEBUG connection->ReceivePending = FALSE;

    } else {

        //
        // The connection isn't already on the need-resource queue, so
        // we need to reference it before we put it on the disconnect
        // queue.  This is necessary in order to make the code in
        // scavengr.c that removes things from the queue work right.
        //

        SrvReferenceConnectionLocked( connection );

    }

    connection->DisconnectReason = DisconnectTransportIssuedDisconnect;
    SrvInsertTailList(
        &SrvDisconnectQueue,
        &connection->ListEntry
        );

    RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

    SrvResourceDisconnectPending = TRUE;
    SrvFsdQueueExWorkItem(
        &SrvResourceThreadWorkItem,
        &SrvResourceThreadRunning,
        CriticalWorkQueue
        );

    RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

    return STATUS_SUCCESS;

} // SrvFsdTdiDisconnectHandler

BOOLEAN
SrvFsdAcceptReceive(
    PCONNECTION Connection,
    PBYTE Data,
    ULONG BytesIndicated,
    ULONG BytesAvailible
    )
/*++

Routine Description:

    This routine allows us to trivially reject a receive if we don't think its valid.
    This can be expanded later to include maintaining a list of bad IP addresses and other
    such DoS schemes to help protect us more.

Arguments:

    Connection - the connection this was received on

    Data - Pointer to the availible data

    BytesIndicated - the total size of the receive

    Bytes Availible - How much is currently pointed at by the Data pointer.

Return Value:

    TRUE - Accept receive, FALSE = reject receive

--*/

{
    PSMB_HEADER pHeader = (PSMB_HEADER)Data;

    //
    // Trivially reject certain packets
    //
    if( BytesIndicated < sizeof(SMB_HEADER)+sizeof(BYTE) )
    {
        return FALSE;
    }

    if( BytesAvailible > sizeof(SMB_HEADER) )
    {
        if( SmbGetUlong(Data) != SMB_HEADER_PROTOCOL )
        {
            return FALSE;
        }

        if( Connection->SmbDialect == SmbDialectIllegal &&
            pHeader->Command != SMB_COM_NEGOTIATE )
        {
            return FALSE;
        }
        else if( Connection->SmbDialect != SmbDialectIllegal &&
                 pHeader->Command == SMB_COM_NEGOTIATE )
        {
            return FALSE;
        }

        if( SrvSmbIndexTable[pHeader->Command] == ISrvSmbIllegalCommand )
        {
            return FALSE;
        }
    }

    return TRUE;
} // SrvFsdAcceptReceive


NTSTATUS
SrvFsdTdiReceiveHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )

/*++

Routine Description:

    This is the transport receive event handler for the server.  It is
    specified as the receive handler for all endpoints opened by the
    server.  It attempts to dequeue a preformatted work item from a list
    anchored in the device object.  If this is successful, it returns
    the IRP associated with the work item to the transport provider to
    be used to receive the data.  Otherwise, the resource thread is
    awakened to format additional receive work items and service pended
    connections.

Arguments:

    TransportEndpoint - Pointer to file object for receiving endpoint

    ConnectionContext - Value associated with endpoint by owner.  For
        the server, this points to a Connection block maintained in
        nonpaged pool.

    ReceiveIndicators - Set of flags indicating the status of the
        received message

    Tsdu - Pointer to received data.

    Irp - Returns a pointer to I/O request packet, if the returned
        status is STATUS_MORE_PROCESSING_REQUIRED.  This IRP is
        made the 'current' Receive for the connection.

Return Value:

    NTSTATUS - If STATUS_SUCCESS, the receive handler completely
        processed the request.  If STATUS_MORE_PROCESSING_REQUIRED,
        the Irp parameter points to a formatted Receive request to
        be used to receive the data.  If STATUS_DATA_NOT_ACCEPTED,
        no IRP is returned, but the transport provider should check
        for previously queued Receive requests.

--*/

{
    NTSTATUS status;
    PCONNECTION connection;
    PWORK_CONTEXT workContext;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PWORK_QUEUE queue;
    ULONG receiveLength;
    LONG OplocksInProgress;
    PMDL mdl;
    PSMB_HEADER pHeader = (PSMB_HEADER)Tsdu;

    KIRQL oldIrql;

    TdiEventContext;    // prevent compiler warnings

    connection = (PCONNECTION)ConnectionContext;

    IF_DEBUG(FSD2) {
        KdPrint(( "SrvFsdTdiReceiveHandler entered for endpoint 0x%p, "
                    "connection 0x%p\n", TdiEventContext, connection ));
    }

    //
    // If the connection is closing, don't bother servicing this
    // indication.
    //

    if ( GET_BLOCK_STATE(connection) == BlockStateActive ) {

        // See if we can trivially reject this receive
        if( !SrvFsdAcceptReceive( connection, Tsdu, BytesIndicated, BytesAvailable ) )
        {
            // Mark them as suspect.  If a DoS is triggered, they will be nuked first.
            connection->IsConnectionSuspect = TRUE;
            return STATUS_DATA_NOT_ACCEPTED;
        }

        //
        // Set the last used timestamp for this connection
        //
        GET_SERVER_TIME( connection->CurrentWorkQueue, &connection->LastRequestTime );

        if ( !(ReceiveFlags & TDI_RECEIVE_AT_DISPATCH_LEVEL) ) {
            KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
        }

#if MULTIPROCESSOR
        //
        // See if it's time to home this connection to another
        // processor
        //
        if( --(connection->BalanceCount) == 0 ) {
            SrvBalanceLoad( connection );
        }
#endif

        queue = connection->CurrentWorkQueue;

        //
        // We're going to either get a free work item and point it to
        // the connection, or put the connection on the need-resource
        // queue, so we'll need to reference the connection block.
        //
        // *** Note that we are able to access the connection block
        //     because it's in nonpaged pool.  Referencing the
        //     connection block here accounts for the I/O request we're
        //     'starting', and prevents the block from being deleted
        //     until the FSP processes the completed Receive.  To make
        //     all this work right, the transport provider must
        //     guarantee that it won't deliver any events after it
        //     delivers a Disconnect event or completes a client-issued
        //     Disconnect request.
        //
        // *** Note that we don't reference the endpoint file object
        //     directly.  The connection block, which we do reference,
        //     references an endpoint block, which in turn references
        //     the file object.
        //

        //
        // Try to dequeue a work item from the free list.
        //

        // Make sure we're not trying to do too much

        // Note the 2x in this calculation.  The reason for this is that if you have a fast client and a busy server,
        // the client can actually turn around and re-use the MID for an operation while the completion call for this
        // operation is still stuck in our queue.  This means that it is possible for the client to legally have up to
        // 2x MpxCt items in our queue.  This is an upper-bound to ensure compatibility.  Note that this is only the first
        // line of defense against DoS, so it is not too bad to allow this many ops through.  If they actually get multiple
        // connections going and run us out of resources, we will kick in and start aggressively disconnecting suspicious
        // connections.
        if( (connection->InProgressWorkContextCount > 2*(SrvMaxMpxCount + MAX_MPX_MARGIN)) && !SrvDisableDoSChecking )
        {
            PSMB_HEADER SmbHeader = (PSMB_HEADER)Tsdu;

            // We normally don't overrun the above bounds.  If we do, lets validate that we are truly exceeding our
            // bounds including oplock breaks.  Still no good way to include Mailslot operations and echos, so we have a fudge factor.
            // Note that the need to do 2x covers this too.
            OplocksInProgress = InterlockedCompareExchange( &connection->OplockBreaksInProgress, 0, 0 );

            if( !(connection->InProgressWorkContextCount > 2*(SrvMaxMpxCount + OplocksInProgress + MAX_MPX_MARGIN)) )
            {
                goto abort_dos;
            }

            if( connection->ClientIPAddress == LOOPBACK_IP_ADDRESS )
            {
                // The loopback transport is very bad about getting us send completions in a timely manner.  Thus
                // we don't enforce this portion of the DoS detection against a loopback connection.
                goto abort_dos;
            }

            // We're going to enforce the max number of work-items a single client can claim
            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvFsdTdiReceiveHandler: client overruning their WorkItem limit",
                NULL,
                NULL
                );

            connection->IsConnectionSuspect = TRUE;
            RunSuspectConnectionAlgorithm = TRUE;
            status = STATUS_DATA_NOT_ACCEPTED;
        }
        else
        {
abort_dos:
            ALLOCATE_WORK_CONTEXT( queue, &workContext );

            if ( workContext != NULL ) {

                //
                // We found a work item to handle this receive.  Reference
                // the connection.  Put the work item on the in-progress
                // list.  Save the connection and endpoint block addresses
                // in the work context block.
                //

                ACQUIRE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
                SrvReferenceConnectionLocked( connection );

                SrvInsertTailList(
                    &connection->InProgressWorkItemList,
                    &workContext->InProgressListEntry
                    );

                connection->InProgressWorkContextCount++;

                RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

                //
                // Keep track of the amount of data that was indicated
                //
                workContext->BytesAvailable = BytesAvailable;

                irp = workContext->Irp;

                workContext->Connection = connection;
                workContext->Endpoint = connection->Endpoint;

                if( connection->SmbSecuritySignatureActive &&
                    BytesIndicated >= FIELD_OFFSET( SMB_HEADER, Command ) ) {

                    //
                    // Save this security signature index
                    //
                    workContext->SmbSecuritySignatureIndex =
                            connection->SmbSecuritySignatureIndex++;

                    //
                    // And if we don't have a CANCEL smb, save the response
                    //  security signature index.  We skip this for CANCEL, because
                    //  CANCEL has no response SMB
                    //
                    if( ((PSMB_HEADER)Tsdu)->Command != SMB_COM_NT_CANCEL ) {
                        workContext->ResponseSmbSecuritySignatureIndex =

                            connection->SmbSecuritySignatureIndex++;
                    }
                }

                //
                // If the entire SMB has been received, and it is completely
                // within the indicated data, copy it directly into the
                // buffer, avoiding the overhead of passing an IRP down to
                // the transport.
                //

                if ( ((ReceiveFlags & TDI_RECEIVE_ENTIRE_MESSAGE) != 0) &&
                     (BytesIndicated == BytesAvailable) &&
                     BytesAvailable <= workContext->RequestBuffer->BufferLength ) {

                    TdiCopyLookaheadData(
                        workContext->RequestBuffer->Buffer,
                        Tsdu,
                        BytesIndicated,
                        ReceiveFlags
                        );

    #if SRVDBG_STATS2
                    IndicationsCopied++;
    #endif

                    //
                    // Pretend the transport completed an IRP by doing what
                    // the restart routine, which is known to be
                    // SrvQueueWorkToFspAtDpcLevel, would do.
                    //

                    irp->IoStatus.Status = STATUS_SUCCESS;
                    irp->IoStatus.Information = BytesIndicated;

                    irp->Cancel = FALSE;

                    IF_DEBUG(FSD2) {
                        KdPrint(( "FSD working on work context 0x%p", workContext ));
                    }
                    ASSERT( workContext->FsdRestartRoutine == SrvQueueWorkToFspAtDpcLevel );

                    //
                    // *** THE FOLLOWING IS COPIED FROM SrvQueueWorkToFspAtDpcLevel.
                    //
                    // Increment the processing count.
                    //

                    workContext->ProcessingCount++;

                    //
                    // Insert the work item at the tail of the nonblocking
                    // work queue.
                    //

                    SrvInsertWorkQueueTail(
                        workContext->CurrentWorkQueue,
                        (PQUEUEABLE_BLOCK_HEADER)workContext
                        );

                    //
                    // Tell the transport that we copied the data.
                    //

                    *BytesTaken = BytesIndicated;
                    *IoRequestPacket = NULL;

                    status = STATUS_SUCCESS;

                } else {

                    PTDI_REQUEST_KERNEL_RECEIVE parameters;

    #if SRVDBG_STATS2
                    IndicationsNotCopied++;
    #endif

                    *BytesTaken = 0;
                    receiveLength = workContext->RequestBuffer->BufferLength;
                    mdl = workContext->RequestBuffer->Mdl;

                    //
                    // We can't copy the indicated data.  Set up the receive
                    // IRP.
                    //

                    irp->Tail.Overlay.OriginalFileObject = NULL;
                    irp->Tail.Overlay.Thread = queue->IrpThread;
                    DEBUG irp->RequestorMode = KernelMode;

                    //
                    // Get a pointer to the next stack location.  This one is used to
                    // hold the parameters for the device I/O control request.
                    //

                    irpSp = IoGetNextIrpStackLocation( irp );

                    //
                    // Set up the completion routine.
                    //

                    IoSetCompletionRoutine(
                        irp,
                        SrvFsdIoCompletionRoutine,
                        workContext,
                        TRUE,
                        TRUE,
                        TRUE
                        );

                    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                    irpSp->MinorFunction = (UCHAR)TDI_RECEIVE;

                    //
                    // Copy the caller's parameters to the service-specific portion of the
                    // IRP for those parameters that are the same for all three methods.
                    //

                    parameters = (PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters;
                    parameters->ReceiveLength = receiveLength;
                    parameters->ReceiveFlags = 0;

                    irp->MdlAddress = mdl;
                    irp->AssociatedIrp.SystemBuffer = NULL;

                    //
                    // Make the next stack location current.  Normally
                    // IoCallDriver would do this, but since we're bypassing
                    // that, we do it directly.  Load the target device
                    // object address into the stack location.  This
                    // especially important because the server likes to
                    // reuse IRPs.
                    //

                    irpSp->Flags = 0;
                    irpSp->DeviceObject = connection->DeviceObject;
                    irpSp->FileObject = connection->FileObject;

                    IoSetNextIrpStackLocation( irp );

                    ASSERT( irp->StackCount >= irpSp->DeviceObject->StackSize );

                    //
                    // Return STATUS_MORE_PROCESSING_REQUIRED so that the
                    // transport provider will use our IRP to service the
                    // receive.
                    //

                    *IoRequestPacket = irp;

                    status = STATUS_MORE_PROCESSING_REQUIRED;
                }

            } else {

                //
                // No preformatted work items are available.  Mark the
                // connection, put it on a queue of connections waiting for
                // work items, and wake up the resource thread so that it
                // can format some more work items and service pended
                // connections.
                //

                INTERNAL_ERROR(
                    ERROR_LEVEL_EXPECTED,
                    "SrvFsdTdiReceiveHandler: no receive work items available",
                    NULL,
                    NULL
                    );

                connection->NoResponseSignatureIndex =
                    (((PSMB_HEADER)Tsdu)->Command == SMB_COM_NT_CANCEL);

                //
                // Remember the amount of data available, so we can set it
                //  in the workcontext when we eventually find one to use
                //
                connection->BytesAvailable = BytesAvailable;

                // If we've been under DOS attacks recently, queue a tear-down
                if( SrvDoSWorkItemTearDown > SRV_DOS_TEARDOWN_MIN )
                {
                    SrvCheckForAndQueueDoS( queue );
                }

                (VOID)SrvAddToNeedResourceQueue( connection, ReceivePending, NULL );

                status = STATUS_DATA_NOT_ACCEPTED;
            }
        }

        if ( !(ReceiveFlags & TDI_RECEIVE_AT_DISPATCH_LEVEL) ) {
            KeLowerIrql( oldIrql );
        }

    } else {

        //
        // The connection is not active.  Ignore this message.
        //

        status = STATUS_DATA_NOT_ACCEPTED;

    }

    return status;

} // SrvFsdTdiReceiveHandler

VOID
SrvPnpBindingHandler(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  DeviceName,
    IN PWSTR            MultiSZBindList
)
{
    KAPC_STATE ApcState;
    BOOLEAN Attached = FALSE;

    PAGED_CODE();

    switch( PnPOpcode ) {
    case TDI_PNP_OP_DEL:
    case TDI_PNP_OP_ADD:
    case TDI_PNP_OP_UPDATE:

        IF_DEBUG( PNP ) {
            KdPrint(("SRV: SrvPnpBindingHandler( %wZ, %u ) entered\n", DeviceName, PnPOpcode ));
        }

        if( IoGetCurrentProcess() != SrvServerProcess ) {
            IF_DEBUG( PNP ) {
                KdPrint(("SRV: attach to system process\n" ));
            }
            FsRtlEnterFileSystem();
            KeStackAttachProcess( SrvServerProcess, &ApcState );
            Attached = TRUE;
        }

        if ((PnPOpcode == TDI_PNP_OP_DEL) ||
            (PnPOpcode == TDI_PNP_OP_ADD)) {
            SrvXsPnpOperation( DeviceName, (BOOLEAN)(PnPOpcode == TDI_PNP_OP_ADD) );
        }

        SrvpNotifyChangesToNetBt(PnPOpcode,DeviceName,MultiSZBindList);

        if( Attached == TRUE ) {
            KeUnstackDetachProcess( &ApcState );
            FsRtlExitFileSystem();
        }

        IF_DEBUG( PNP ) {
            KdPrint(("SRV: SrvPnpBindingHandler( %p, %u ) returning\n", DeviceName, PnPOpcode ));
        }

        break;

    default:
        break;
    }

}

//
// This routine can not be pageable, since the set power state calls can
// come through with the disk already disabled.  We need to make sure that
// no pageable code is invoked.  Fortunately, we don't need to do anything
// on a set power state
//
NTSTATUS
SrvPnpPowerHandler(
    IN PUNICODE_STRING  DeviceName,
    IN PNET_PNP_EVENT   PnPEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
)
{
    NET_DEVICE_POWER_STATE powerState;
    NTSTATUS status = STATUS_SUCCESS;
    PLIST_ENTRY listEntry;

    IF_DEBUG( PNP ) {
        KdPrint(( "SRV: SrvPnpPowerHandler( %wZ, %u )\n", DeviceName, PnPEvent->NetEvent ));
    }

    switch( PnPEvent->NetEvent ) {
    case NetEventQueryPower:

        if( PnPEvent->BufferLength != sizeof( powerState ) ) {
            IF_DEBUG( ERRORS ) {
                KdPrint(( "SRV: NetEventQueryPower BufferLength %u (should be %u)\n",
                            PnPEvent->BufferLength, sizeof( powerState ) ));
            }
            break;
        }

        powerState = *(PNET_DEVICE_POWER_STATE)(PnPEvent->Buffer);

        //
        // Powering up is always OK!
        //
        if( powerState == NetDeviceStateD0 ) {
            break;
        }

        //
        // Lack of break is intentional
        //
    case NetEventQueryRemoveDevice:

    //
    // The following code is disabled, because we couldn't come up with a reasonable
    //  way to present UI to the user on failure.  We know this leg of the code is only
    //  executed when the user specifically wants to standby the system or remove a device.
    //  The analogy is that of a TV set -- if the user wants to turn off the system, then who
    //  are we to say "no"?
    //
    // If this is really the decision, then IMHO the system shouldn't even ask us.  But
    //  that's a battle long lost.
    //
#if 0
        //
        // Run through the endpoints using this device.  If any clients are
        //  connected, refuse the change.
        //

        ACQUIRE_LOCK( &SrvEndpointLock );

        listEntry = SrvEndpointList.ListHead.Flink;

        while( listEntry != &SrvEndpointList.ListHead ) {

            PENDPOINT endpoint = CONTAINING_RECORD( listEntry,
                                                    ENDPOINT,
                                                    GlobalEndpointListEntry
                                                    );

            if( GET_BLOCK_STATE( endpoint ) == BlockStateActive &&
                RtlEqualUnicodeString( DeviceName, &endpoint->TransportName, TRUE ) ) {

                USHORT index = (USHORT)-1;
                PCONNECTION connection = WalkConnectionTable( endpoint, &index );

                if( connection != NULL ) {
                    IF_DEBUG( PNP ) {
                        KdPrint(("    Endpoint %X, Connection %X\n", endpoint, connection ));
                        KdPrint(("    SRV rejects power down request!\n" ));
                    }
                    //
                    // We have found a connected client.  Cannot allow powerdown.
                    //
                    SrvDereferenceConnection( connection );
                    status = STATUS_UNSUCCESSFUL;
                    break;
                }
            }

            listEntry = listEntry->Flink;
        }

        RELEASE_LOCK( &SrvEndpointLock );
#endif

        break;
    }

    IF_DEBUG( PNP ) {
        KdPrint(( "    SrvPnpPowerHandler status %X\n", status ));
    }

    return status;
}


PWORK_CONTEXT SRVFASTCALL
SrvFsdGetReceiveWorkItem (
    IN PWORK_QUEUE queue
    )

/*++

Routine Description:

    This function removes a receive work item from the free queue.  It can
    be called at either Passive or DPC level

Arguments:

    None.

Return Value:

    PWORK_CONTEXT - A pointer to a WORK_CONTEXT structure,
         or NULL if none exists.
--*/

{
    PSLIST_ENTRY listEntry;
    PWORK_CONTEXT workContext;
    ULONG i;
    KIRQL oldIrql;
    NTSTATUS Status;
    BOOLEAN AllocFailed = FALSE;

    ASSERT( queue >= SrvWorkQueues && queue < eSrvWorkQueues );

    //
    // Try to get a work context block from the initial work queue first.
    // If this fails, try the normal work queue.  If this fails, try to allocate
    // one.  If we still failed, schedule a worker thread to allocate some later.
    //

    listEntry = ExInterlockedPopEntrySList( &queue->InitialWorkItemList, &queue->SpinLock );

    if ( listEntry == NULL ) {

        listEntry = ExInterlockedPopEntrySList( &queue->NormalWorkItemList, &queue->SpinLock );

        if( listEntry == NULL ) {

            IF_DEBUG( WORKITEMS ) {
                KdPrint(("No workitems for queue %p\n", (PVOID)(queue-SrvWorkQueues) ));
            }

            Status = SrvAllocateNormalWorkItem( &workContext, queue );
            if( workContext != NULL ) {
                IF_DEBUG( WORKITEMS ) {
                    KdPrint(("SrvFsdGetReceiveWorkItem: new work context %p\n",
                              workContext ));
                }
                SrvPrepareReceiveWorkItem( workContext, FALSE );
                INITIALIZE_WORK_CONTEXT( queue, workContext );
                return workContext;
            }
            else
            {
                if( Status == STATUS_INSUFFICIENT_RESOURCES )
                {
                    AllocFailed = TRUE;
                }
            }

            //
            // Before we steal from another processor, ensure that
            //  we're setup to replenish this exhausted free list
            //
            ACQUIRE_SPIN_LOCK( &queue->SpinLock, &oldIrql );
            if( queue->AllocatedWorkItems < queue->MaximumWorkItems &&
                GET_BLOCK_TYPE(&queue->CreateMoreWorkItems) == BlockTypeGarbage ) {

                SET_BLOCK_TYPE( &queue->CreateMoreWorkItems, BlockTypeWorkContextSpecial );
                queue->CreateMoreWorkItems.FspRestartRoutine = SrvServiceWorkItemShortage;
                SrvInsertWorkQueueHead( queue, &queue->CreateMoreWorkItems );
            }
            RELEASE_SPIN_LOCK( &queue->SpinLock, oldIrql );

#if MULTIPROCESSOR
            //
            // We couldn't find a work item on our processor's free queue.
            //   See if we can steal one from another processor
            //

            IF_DEBUG( WORKITEMS ) {
                KdPrint(("Looking for workitems on other processors\n" ));
            }

            //
            // Look around for a workitem we can borrow
            //
            for( i = SrvNumberOfProcessors; i > 1; --i ) {

                if( ++queue == eSrvWorkQueues )
                    queue = SrvWorkQueues;


                listEntry = ExInterlockedPopEntrySList( &queue->InitialWorkItemList,
                                                        &queue->SpinLock );

                if( listEntry == NULL ) {
                    listEntry = ExInterlockedPopEntrySList( &queue->NormalWorkItemList,
                                                            &queue->SpinLock );
                    if( listEntry == NULL ) {

                        Status = SrvAllocateNormalWorkItem( &workContext, queue );

                        if( workContext != NULL ) {
                            //
                            // Got a workItem from another processor's queue!
                            //
                            ++(queue->StolenWorkItems);

                            IF_DEBUG( WORKITEMS ) {
                                KdPrint(("SrvFsdGetReceiveWorkItem: new work context %p\n",
                                          workContext ));
                            }

                            SrvPrepareReceiveWorkItem( workContext, FALSE );
                            INITIALIZE_WORK_CONTEXT( queue, workContext );
                            return workContext;
                        }
                        else
                        {
                            if( Status == STATUS_INSUFFICIENT_RESOURCES )
                            {
                                AllocFailed = TRUE;
                            }
                        }

                        //
                        // Make sure this processor knows it is low on workitems
                        //
                        ACQUIRE_SPIN_LOCK( &queue->SpinLock, &oldIrql );
                        if( queue->AllocatedWorkItems < queue->MaximumWorkItems &&
                            GET_BLOCK_TYPE(&queue->CreateMoreWorkItems) == BlockTypeGarbage ) {

                            SET_BLOCK_TYPE( &queue->CreateMoreWorkItems,
                                            BlockTypeWorkContextSpecial );

                            queue->CreateMoreWorkItems.FspRestartRoutine
                                            = SrvServiceWorkItemShortage;
                            SrvInsertWorkQueueHead( queue, &queue->CreateMoreWorkItems );
                        }

                        RELEASE_SPIN_LOCK( &queue->SpinLock, oldIrql );
                        continue;
                    }
                }

                //
                // Got a workItem from another processor's queue!
                //
                ++(queue->StolenWorkItems);

                break;
            }
#endif

            if( listEntry == NULL ) {
                //
                // We didn't have any free workitems on our queue, and
                //  we couldn't borrow a workitem from another processor.
                //  Give up!
                //

                IF_DEBUG( WORKITEMS ) {
                    KdPrint(("No workitems anywhere!\n" ));
                }
                ++SrvStatistics.WorkItemShortages;

                if( !AllocFailed )
                {
                    SrvCheckForAndQueueDoS( queue );
                }

                return NULL;
            }
        }
    }

    //
    // We've successfully gotten a free workitem of a processor's queue.
    //  (it may not be our processor).
    //

    IF_DEBUG( WORKITEMS ) {
        if( queue != PROCESSOR_TO_QUEUE() ) {
            KdPrint(("\tGot WORK_ITEM from processor %p\n" , (PVOID)(queue - SrvWorkQueues) ));
        }
    }

    //
    // Decrement the count of free receive work items.
    //
    InterlockedDecrement( &queue->FreeWorkItems );

    if( queue->FreeWorkItems < queue->MinFreeWorkItems &&
        queue->AllocatedWorkItems < queue->MaximumWorkItems &&
        GET_BLOCK_TYPE(&queue->CreateMoreWorkItems) == BlockTypeGarbage ) {

        ACQUIRE_SPIN_LOCK( &queue->SpinLock, &oldIrql );

        if( queue->FreeWorkItems < queue->MinFreeWorkItems &&
            queue->AllocatedWorkItems < queue->MaximumWorkItems &&
            GET_BLOCK_TYPE(&queue->CreateMoreWorkItems) == BlockTypeGarbage ) {

            //
            // We're running short of free workitems. Queue a request to
            // allocate more of them.
            //
            SET_BLOCK_TYPE( &queue->CreateMoreWorkItems, BlockTypeWorkContextSpecial );

            queue->CreateMoreWorkItems.FspRestartRoutine = SrvServiceWorkItemShortage;
            SrvInsertWorkQueueHead( queue, &queue->CreateMoreWorkItems );
        }

        RELEASE_SPIN_LOCK( &queue->SpinLock, oldIrql );
    }


    workContext = CONTAINING_RECORD( listEntry, WORK_CONTEXT, SingleListEntry );
    ASSERT( workContext->BlockHeader.ReferenceCount == 0 );
    ASSERT( workContext->CurrentWorkQueue != NULL );

    INITIALIZE_WORK_CONTEXT( queue, workContext );

    return workContext;

} // SrvFsdGetReceiveWorkItem

VOID SRVFASTCALL
SrvFsdRequeueReceiveWorkItem (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine requeues a Receive work item to the queue in the server
    FSD device object.  This routine is called when processing of a
    receive work item is done.

Arguments:

    WorkContext - Supplies a pointer to the work context block associated
        with the receive buffer and IRP.  The following fields must be
        valid:

            Connection
            TdiRequest
            Irp
            RequestBuffer
                RequestBuffer->BufferLength
                RequestBuffer->Mdl

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    PSMB_HEADER header;
    KIRQL oldIrql;
    PBUFFER requestBuffer;

    IF_DEBUG(TRACE2) KdPrint(( "SrvFsdRequeueReceiveWorkItem entered\n" ));
    IF_DEBUG(NET2) {
        KdPrint(( "  Work context %p, request buffer %p\n",
                    WorkContext, WorkContext->RequestBuffer ));
        KdPrint(( "  IRP %p, MDL %p\n",
                    WorkContext->Irp, WorkContext->RequestBuffer->Mdl ));
    }

    //
    // Save the connection pointer before reinitializing the work item.
    //

    connection = WorkContext->Connection;
    ASSERT( connection != NULL );

    ASSERT( WorkContext->Share == NULL );
    ASSERT( WorkContext->Session == NULL );
    ASSERT( WorkContext->TreeConnect == NULL );
    ASSERT( WorkContext->Rfcb == NULL );

    //
    // Reset the IRP cancelled bit, in case it was set during
    // operation.
    //

    WorkContext->Irp->Cancel = FALSE;

    //
    // Set up the restart routine in the work context.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = SrvRestartReceive;

    //
    // Make sure the length specified in the MDL is correct -- it may
    // have changed while sending a response to the previous request.
    // Call an I/O subsystem routine to build the I/O request packet.
    //

    requestBuffer = WorkContext->RequestBuffer;
    requestBuffer->Mdl->ByteCount = requestBuffer->BufferLength;

    //
    // Replace the Response buffer.
    //

    WorkContext->ResponseBuffer = requestBuffer;

    header = (PSMB_HEADER)requestBuffer->Buffer;

    //WorkContext->RequestHeader = header;
    ASSERT( WorkContext->RequestHeader == header );

    WorkContext->ResponseHeader = header;
    WorkContext->ResponseParameters = (PVOID)(header + 1);
    WorkContext->RequestParameters = (PVOID)(header + 1);

    //
    // Initialize this to zero so this will not be mistakenly cancelled
    // by SrvSmbNtCancel.
    //

    SmbPutAlignedUshort( &WorkContext->RequestHeader->Uid, (USHORT)0 );

    //
    // Remove the work item from the in-progress list.
    //

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
    ACQUIRE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

    SrvRemoveEntryList(
        &connection->InProgressWorkItemList,
        &WorkContext->InProgressListEntry
        );
    connection->InProgressWorkContextCount--;

    //
    // Attempt to dereference the connection.
    //

    if ( --connection->BlockHeader.ReferenceCount == 0 ) {

        //
        // The refcount went to zero.  We can't handle this with the
        // spin lock held.  Reset the refcount, then release the lock,
        // then check to see whether we can continue here.
        //

        connection->BlockHeader.ReferenceCount++;

        //
        // We're in the FSD, so we can't do this here.  We need
        // to tell our caller this.
        //

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

        //
        // orphaned.  Send to Boys Town.
        //

        DispatchToOrphanage( (PVOID)connection );
        connection = NULL;

    } else {

        UPDATE_REFERENCE_HISTORY( connection, TRUE );
        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
    }

    KeLowerIrql( oldIrql );

    //
    // Requeue the work item.
    //

    RETURN_FREE_WORKITEM( WorkContext );

    return;

} // SrvFsdRequeueReceiveWorkItem


NTSTATUS
SrvFsdRestartSendOplockIItoNone(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine is the send completion routine for oplock breaks from
    II to None.  This is handled differently from other oplock breaks
    in that we don't queue it to the OplockBreaksInProgressList but
    increment our count so we will not have raw reads while this is
    being sent.


    This is done in such a manner as to be safe at DPC level.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    WorkContext - Caller-specified context parameter associated with IRP.
        This is actually a pointer to a Work Context block.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    PCONNECTION connection;

    UNLOCKABLE_CODE( 8FIL );

    IF_DEBUG(OPLOCK) {
        KdPrint(("SrvFsdRestartSendOplockIItoNone: Oplock send complete.\n"));
    }

    //
    // Check the status of the send completion.
    //

    CHECK_SEND_COMPLETION_STATUS( Irp->IoStatus.Status );

    //
    // Reset the IRP cancelled bit.
    //

    Irp->Cancel = FALSE;

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    //
    // Mark the connection to indicate that we just sent a break II to
    // none.  If the next SMB received is a raw read, we will return a
    // zero-byte send.  This is necessary because the client doesn't
    // respond to this break, so we don't really know when they've
    // received it.  But when we receive an SMB, we know that they've
    // gotten it.  Note that a non-raw SMB could be on its way when we
    // send the break, and we'll clear the flag, but since the client
    // needs to lock the VC to do the raw read, it must receive the SMB
    // response (and hence the oplock break) before it can send the raw
    // read.  If a raw read crosses with the oplock break, it will be
    // rejected because the OplockBreaksInProgress count is nonzero.
    //

    connection = WorkContext->Connection;
    connection->BreakIIToNoneJustSent = TRUE;

    ExInterlockedAddUlong(
        &connection->OplockBreaksInProgress,
        (ULONG)-1,
        connection->EndpointSpinLock
        );

    SrvFsdRestartSmbComplete( WorkContext );

    KeLowerIrql( oldIrql );
    return(STATUS_MORE_PROCESSING_REQUIRED);

} // SrvFsdRestartSendOplockIItoNone


VOID SRVFASTCALL
SrvFsdRestartSmbComplete (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine is called when all request processing on an SMB is
    complete, including sending a response, if any.  This routine
    dereferences control blocks and requeues the work item to the
    receive work item list.

    This is done in such a manner as to be safe at DPC level.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        containing information about the SMB.

Return Value:

    None.

--*/

{
    PRFCB rfcb;
    ULONG oldCount;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    IF_DEBUG(FSD2) KdPrint(( "SrvFsdRestartSmbComplete entered\n" ));

    //
    // If we may have backlogged oplock breaks to send, do the work
    // in the FSP.
    //

    if ( WorkContext->OplockOpen ) {
        goto queueToFsp;
    }

    //
    // Attempt to dereference the file block.
    //

    rfcb = WorkContext->Rfcb;

    if ( rfcb != NULL ) {
        oldCount = ExInterlockedAddUlong(
            &rfcb->BlockHeader.ReferenceCount,
            (ULONG)-1,
            &rfcb->Connection->SpinLock
            );

        UPDATE_REFERENCE_HISTORY( rfcb, TRUE );

        if ( oldCount == 1 ) {
            UPDATE_REFERENCE_HISTORY( rfcb, FALSE );
            (VOID) ExInterlockedAddUlong(
                    &rfcb->BlockHeader.ReferenceCount,
                    (ULONG) 1,
                    &rfcb->Connection->SpinLock
                    );
            goto queueToFsp;
        }

        WorkContext->Rfcb = NULL;
    }

    //
    // If this was a blocking operation, update the blocking i/o count.
    //

    if ( WorkContext->BlockingOperation ) {
        InterlockedDecrement( &SrvBlockingOpsInProgress );
        WorkContext->BlockingOperation = FALSE;
    }

    //
    // !!! Need to handle failure of response send -- kill connection?
    //

    //
    // Attempt to dereference the work item.  This will fail (and
    // automatically be queued to the FSP) if it cannot be done from
    // within the FSD.
    //

    SrvFsdDereferenceWorkItem( WorkContext );

    return;

queueToFsp:

    //
    // We were unable to do all the necessary cleanup at DPC level.
    // Queue the work item to the FSP.
    //

    WorkContext->FspRestartRoutine = SrvRestartFsdComplete;
    SrvQueueWorkToFspAtDpcLevel( WorkContext );

    IF_DEBUG(FSD2) KdPrint(( "SrvFsdRestartSmbComplete complete\n" ));
    return;

} // SrvFsdRestartSmbComplete

NTSTATUS
SrvFsdRestartSmbAtSendCompletion (
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PIRP Irp,
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Send completion routine for all request processing on an SMB is
    complete, including sending a response, if any.  This routine
    dereferences control blocks and requeues the work item to the
    receive work item list.

    This is done in such a manner as to be safe at DPC level.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    WorkContext - Caller-specified context parameter associated with IRP.
        This is actually a pointer to a Work Context block.

Return Value:

    None.

--*/

{
    PRFCB rfcb;
    KIRQL oldIrql;

    ULONG oldCount;

    IF_DEBUG(FSD2)KdPrint(( "SrvFsdRestartSmbComplete entered\n" ));

    //
    // Check the status of the send completion.
    //

    CHECK_SEND_COMPLETION_STATUS( Irp->IoStatus.Status );

    //
    // Reset the IRP cancelled bit.
    //

    Irp->Cancel = FALSE;

    //
    // Free any associated buffers
    //
    if( Irp->AssociatedIrp.SystemBuffer != NULL &&
        (Irp->Flags & IRP_DEALLOCATE_BUFFER) ) {

        ExFreePool( Irp->AssociatedIrp.SystemBuffer );
        Irp->AssociatedIrp.SystemBuffer = NULL;
        Irp->Flags &= ~IRP_DEALLOCATE_BUFFER;
    }

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    //
    // If we may have backlogged oplock breaks to send, do the work
    // in the FSP.
    //

    if ( WorkContext->OplockOpen ) {
        goto queueToFsp;
    }

    //
    // Attempt to dereference the file block.  We can do this without acquiring
    // SrvFsdSpinlock around the decrement/increment pair since the ref
    // count cannot be zero unless the rfcb is closed and we are the last
    // reference to it.  None of our code references the rfcb when it has been
    // closed.
    //

    rfcb = WorkContext->Rfcb;

    if ( rfcb != NULL ) {
        oldCount = ExInterlockedAddUlong(
            &rfcb->BlockHeader.ReferenceCount,
            (ULONG)-1,
            &rfcb->Connection->SpinLock
            );

        UPDATE_REFERENCE_HISTORY( rfcb, TRUE );

        if ( oldCount == 1 ) {
            UPDATE_REFERENCE_HISTORY( rfcb, FALSE );
            (VOID) ExInterlockedAddUlong(
                    &rfcb->BlockHeader.ReferenceCount,
                    (ULONG) 1,
                    &rfcb->Connection->SpinLock
                    );
            goto queueToFsp;
        }

        WorkContext->Rfcb = NULL;
    }

    //
    // If this was a blocking operation, update the blocking i/o count.
    //

    if ( WorkContext->BlockingOperation ) {
        InterlockedDecrement( &SrvBlockingOpsInProgress );
        WorkContext->BlockingOperation = FALSE;
    }

    //
    // !!! Need to handle failure of response send -- kill connection?
    //

    //
    // Attempt to dereference the work item.  This will fail (and
    // automatically be queued to the FSP) if it cannot be done from
    // within the FSD.
    //

    SrvFsdDereferenceWorkItem( WorkContext );

    KeLowerIrql( oldIrql );
    return(STATUS_MORE_PROCESSING_REQUIRED);

queueToFsp:

    //
    // We were unable to do all the necessary cleanup at DPC level.
    // Queue the work item to the FSP.
    //

    WorkContext->FspRestartRoutine = SrvRestartFsdComplete;
    SrvQueueWorkToFspAtDpcLevel( WorkContext );

    KeLowerIrql( oldIrql );
    IF_DEBUG(FSD2) KdPrint(( "SrvFsdRestartSmbComplete complete\n" ));
    return(STATUS_MORE_PROCESSING_REQUIRED);

} // SrvFsdRestartSmbAtSendCompletion


VOID
SrvFsdServiceNeedResourceQueue (
    IN PWORK_CONTEXT *WorkContext,
    IN PKIRQL OldIrql
    )

/*++

Routine Description:

    This function attempts to service a receive pending by creating
    a new SMB buffer and passing it on to the transport provider.

    *** SrvFsdSpinLock held when called.  Held on exit ***
    *** EndpointSpinLock held when called.  Held on exit ***

Arguments:

    WorkContext - A pointer to the work context block that will be used
                  to service the connection. If the work context supplied
                  was used, a null will be returned here.
                  *** The workcontext block must be referencing the
                      connection on entry. ***

    OldIrql -

Return Value:

    TRUE, if there is still work left for this connection.
    FALSE, otherwise.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PIRP irp;
    PWORK_CONTEXT workContext = *WorkContext;
    PCONNECTION connection = workContext->Connection;

    IF_DEBUG( OPLOCK ) {
        KdPrint(("SrvFsdServiceNeedResourceQueue: entered. WorkContext %p , Connection = %p.\n", workContext, connection ));
    }

    //
    // If there are any oplock break sends pending, supply the WCB.
    //

restart:

    if ( !IsListEmpty( &connection->OplockWorkList ) ) {

        PLIST_ENTRY listEntry;
        PRFCB rfcb;

        //
        // Dequeue the oplock context from the list of pending oplock
        // sends.
        //

        listEntry = RemoveHeadList( &connection->OplockWorkList );

        rfcb = CONTAINING_RECORD( listEntry, RFCB, ListEntry );

#if DBG
        rfcb->ListEntry.Flink = rfcb->ListEntry.Blink = NULL;
#endif

        IF_DEBUG( OPLOCK ) {
            KdPrint(("SrvFsdServiceNeedResourceQueue: rfcb %p removed from OplockWorkList.\n", rfcb ));
        }

        //
        // The connection spinlock guards the rfcb block header.
        //

        ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock);

        if ( GET_BLOCK_STATE( rfcb ) != BlockStateActive ) {

            //
            // This file is closing, don't bother send the oplock break
            //
            // Attempt to dereference the file block.
            //

            IF_DEBUG( OPLOCK ) {
                KdPrint(("SrvFsdServiceNeedResourceQueue: rfcb %p closing.\n", rfcb));
            }

            UPDATE_REFERENCE_HISTORY( rfcb, TRUE );

            connection->OplockBreaksInProgress--;
            if ( --rfcb->BlockHeader.ReferenceCount == 0 ) {

                //
                // Put the work item on the in-progress list.
                //

                SrvInsertTailList(
                    &connection->InProgressWorkItemList,
                    &workContext->InProgressListEntry
                    );
                connection->InProgressWorkContextCount++;

                UPDATE_REFERENCE_HISTORY( rfcb, FALSE );
                rfcb->BlockHeader.ReferenceCount++;

                RELEASE_DPC_SPIN_LOCK( &connection->SpinLock);
                RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock);
                RELEASE_GLOBAL_SPIN_LOCK( Fsd, *OldIrql );

                //
                // Send this to the Fsp
                //

                workContext->Rfcb = rfcb;
                workContext->FspRestartRoutine = SrvRestartFsdComplete;
                SrvQueueWorkToFsp( workContext );
                goto exit_used;

            } else {

                //
                // Before we get rid of the workcontext block, see
                // if we need to do more work for this connection.
                //

                if ( !IsListEmpty(&connection->OplockWorkList) ||
                      connection->ReceivePending) {

                    IF_DEBUG( OPLOCK ) {
                        KdPrint(("SrvFsdServiceNeedResourceQueue: Reusing WorkContext block %p.\n", workContext ));
                    }

                    RELEASE_DPC_SPIN_LOCK( &connection->SpinLock);
                    goto restart;
                }

                RELEASE_DPC_SPIN_LOCK( &connection->SpinLock);
                RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock);
                RELEASE_GLOBAL_SPIN_LOCK( Fsd, *OldIrql );

                IF_DEBUG( OPLOCK ) {
                    KdPrint(("SrvFsdServiceNeedResourceQueue: WorkContext block not used.\n"));
                }

                SrvDereferenceConnection( connection );
                workContext->Connection = NULL;
                workContext->Endpoint = NULL;
                goto exit_not_used;
            }
        }

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock);

        //
        // Put the work item on the in-progress list.
        //

        SrvInsertTailList(
            &connection->InProgressWorkItemList,
            &workContext->InProgressListEntry
            );
        connection->InProgressWorkContextCount++;

        //
        // Copy the oplock work queue RFCB reference to the work
        // context block.  There is no need to re-reference the RFCB.
        //

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock);
        RELEASE_GLOBAL_SPIN_LOCK( Fsd, *OldIrql );
        workContext->Rfcb = rfcb;

        IF_DEBUG( OPLOCK ) {
            KdPrint(("SrvFsdServiceNeedResourceQueue: Sending oplock break.\n"));
        }

        SrvRestartOplockBreakSend( workContext );

    } else {

        IF_DEBUG( OPLOCK ) {
            KdPrint(("SrvFsdServiceNeedResourceQueue: Have ReceivePending.\n"));
        }

        //
        // Offer the newly free, or newly created, SMB buffer to the
        // transport to complete the receive.
        //
        // *** Note that the connection has already been referenced in
        //     SrvFsdTdiReceiveHandler.
        //

        connection->ReceivePending = FALSE;

        //
        // Check the request security signature, and calculate the response signature
        //
        if( connection->SmbSecuritySignatureActive ) {

            //
            // Save this security signature index
            //
            workContext->SmbSecuritySignatureIndex =
                    connection->SmbSecuritySignatureIndex++;

            //
            // Save the response signature index, if we require one
            //
            if( connection->NoResponseSignatureIndex == FALSE ) {

                workContext->ResponseSmbSecuritySignatureIndex =
                    connection->SmbSecuritySignatureIndex++;
            }
        }

        SET_OPERATION_START_TIME( &workContext );

        //
        // Put the work item on the in-progress list.
        //

        SrvInsertTailList(
            &connection->InProgressWorkItemList,
            &workContext->InProgressListEntry
            );
        connection->InProgressWorkContextCount++;

        //
        // Remember the amount of data that is avilable, in case it
        //  turns out to be a LargeIndication.
        //
        workContext->BytesAvailable = connection->BytesAvailable;

        //
        // Finish setting up the IRP.  This involves putting the
        // file object and device object addresses in the IRP.
        //

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock);
        RELEASE_GLOBAL_SPIN_LOCK( Fsd, *OldIrql );

        irp = workContext->Irp;

        //
        // Build the receive irp
        //

        (VOID)SrvBuildIoControlRequest(
                  irp,                                // input IRP address
                  NULL,                               // target file object address
                  workContext,                        // context
                  IRP_MJ_INTERNAL_DEVICE_CONTROL,     // major function
                  TDI_RECEIVE,                        // minor function
                  NULL,                               // input buffer address
                  0,                                  // input buffer length
                  workContext->RequestBuffer->Buffer, // output buffer address
                  workContext->RequestBuffer->BufferLength,  // output buffer length
                  workContext->RequestBuffer->Mdl,    // MDL address
                  NULL                                // completion routine
                  );

        //
        // Get a pointer to the next stack location.  This one is used to
        // hold the parameters for the receive request.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        irpSp->Flags = 0;
        irpSp->DeviceObject = connection->DeviceObject;
        irpSp->FileObject = connection->FileObject;

        ASSERT( irp->StackCount >= irpSp->DeviceObject->StackSize );

        //
        // Pass the SMB buffer to the driver.
        //

        IoCallDriver( irpSp->DeviceObject, irp );

    }

exit_used:

    //
    // We made good use of the work context block.
    //

    *WorkContext = NULL;

    IF_DEBUG( OPLOCK ) {
        KdPrint(("SrvFsdServiceNeedResourceQueue: WorkContext block used.\n"));
    }

exit_not_used:

    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, OldIrql );
    ACQUIRE_DPC_SPIN_LOCK( connection->EndpointSpinLock);
    return;

} // SrvFsdServiceNeedResourceQueue


BOOLEAN
SrvAddToNeedResourceQueue(
    IN PCONNECTION Connection,
    IN RESOURCE_TYPE ResourceType,
    IN PRFCB Rfcb OPTIONAL
    )

/*++

Routine Description:

    This function appends a connection to the need resource queue.
    The connection is marked indicating what resource is needed,
    and the resource thread is started to do the work.

Arguments:

    Connection - The connection that need a resource.
    Resource - The resource that is needed.
    Rfcb - A pointer to the RFCB that needs the resource.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
    ACQUIRE_DPC_SPIN_LOCK( Connection->EndpointSpinLock );

    IF_DEBUG( WORKITEMS ) {
        KdPrint(("SrvAddToNeedResourceQueue entered. connection = %p, type %d\n", Connection, ResourceType));
    }

    //
    // Check again to see if the connection is closing.  If it is,
    // don't bother putting it on the need resource queue.
    //
    // *** We have to do this while holding the need-resource queue
    //     spin lock in order to synchronize with
    //     SrvCloseConnection.  We don't want to queue this
    //     connection after SrvCloseConnection tries to take it off
    //     the queue.
    //

    if ( GET_BLOCK_STATE(Connection) != BlockStateActive ||
         Connection->DisconnectPending ) {

        RELEASE_DPC_SPIN_LOCK( Connection->EndpointSpinLock );
        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

        IF_DEBUG( WORKITEMS ) {
            KdPrint(("SrvAddToNeedResourceQueue: connection closing. Not queued\n"));
        }

        return FALSE;

    }

    //
    // Mark the connection so that the resource thread will know what to
    // do with this connection.
    //

    switch ( ResourceType ) {

    case ReceivePending:

        ASSERT( !Connection->ReceivePending );
        Connection->ReceivePending = TRUE;
        break;

    case OplockSendPending:

        //
        // Queue the context information to the connection, if necessary.
        //

        ASSERT( ARGUMENT_PRESENT( Rfcb ) );

        SrvInsertTailList( &Connection->OplockWorkList, &Rfcb->ListEntry );

        break;

    }

    //
    // Put the connection on the need-resource queue and increment its
    // reference count.
    //

    if( Connection->OnNeedResourceQueue == FALSE ) {

        Connection->OnNeedResourceQueue = TRUE;

        SrvInsertTailList(
            &SrvNeedResourceQueue,
            &Connection->ListEntry
            );

        SrvReferenceConnectionLocked( Connection );

        IF_DEBUG( WORKITEMS ) {
            KdPrint(("SrvAddToNeedResourceQueue: connection %p inserted on the queue.\n", Connection));
        }
    }

    RELEASE_DPC_SPIN_LOCK( Connection->EndpointSpinLock );

    RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

    //
    // Make sure we know that this connection needs a WorkItem
    //
    InterlockedIncrement( &Connection->CurrentWorkQueue->NeedWorkItem );

    IF_DEBUG( WORKITEMS ) {
        KdPrint(("SrvAddToNeedResourceQueue complete: NeedWorkItem = %d\n",
                  Connection->CurrentWorkQueue->NeedWorkItem ));
    }

    return TRUE;

} // SrvAddToNeedResourceQueue

VOID
SrvCheckForAndQueueDoS(
    PWORK_QUEUE queue
    )
{
    KIRQL oldIrql;
    LARGE_INTEGER CurrentTime;
    BOOLEAN LogEvent = FALSE;

    if( !SrvDisableDoSChecking &&
        queue->AllocatedWorkItems >= queue->MaximumWorkItems )
    {
        // Potential DoS
        SrvDoSDetected = TRUE;

        // Make sure we only queue one of these at a time globally
        if( SRV_DOS_CAN_START_TEARDOWN() )
        {

            KeQuerySystemTime( &CurrentTime );

            if( CurrentTime.QuadPart > SrvDoSLastRan.QuadPart + SRV_DOS_MINIMUM_DOS_WAIT_PERIOD )
            {
                // Setup a refresher/DOS item
                ACQUIRE_SPIN_LOCK( &queue->SpinLock, &oldIrql );
                ACQUIRE_DPC_SPIN_LOCK( &SrvDosSpinLock );

                if( GET_BLOCK_TYPE(&SrvDoSWorkItem) == BlockTypeGarbage ) {

                    SET_BLOCK_TYPE( &SrvDoSWorkItem, BlockTypeWorkContextSpecial );

                    if( SrvDoSLastRan.QuadPart + SRV_ONE_DAY < CurrentTime.QuadPart )
                    {
                        // Only log events when there has been no DoS for 24 hours
                        LogEvent = TRUE;
                    }

                    SrvDoSLastRan = CurrentTime;
                    SrvDoSWorkItem.FspRestartRoutine = SrvServiceDoSTearDown;
                    SrvDoSWorkItem.CurrentWorkQueue = queue;
                    SrvInsertWorkQueueHead( queue, &SrvDoSWorkItem );
                }
                else
                {
                    // Some error occurred, leave t