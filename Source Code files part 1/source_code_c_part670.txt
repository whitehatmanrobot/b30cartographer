         if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_UDPTABLE))
            {
                dwResult = ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                pOutEntry->dwId = UDP_TABLE;

                pUdpTable->dwNumEntries = 0;

                dwResult = NO_ERROR;
            }

            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_UDPTABLE);

            break;
        }
        
        if(*pOutEntrySize <
           MAX_MIB_OFFSET + SIZEOF_UDPTABLE(g_UdpInfo.pUdpTable->dwNumEntries))
        {
            *pOutEntrySize =
                MAX_MIB_OFFSET + SIZEOF_UDPTABLE(g_UdpInfo.pUdpTable->dwNumEntries);
            
            dwResult = ERROR_INSUFFICIENT_BUFFER;

            break;
        }
        
        *pOutEntrySize =
            MAX_MIB_OFFSET + SIZEOF_UDPTABLE(g_UdpInfo.pUdpTable->dwNumEntries);
        
        pOutEntry->dwId = UDP_TABLE;
        
        for(i = 0; i < g_UdpInfo.pUdpTable->dwNumEntries; i++)
        {
            pUdpTable->table[i] = g_UdpInfo.pUdpTable->table[i];
        }
        
        pUdpTable->dwNumEntries = g_UdpInfo.pUdpTable->dwNumEntries;
        
        dwResult = NO_ERROR;
        
    }while(FALSE);

    EXIT_LOCK(UDPCACHE);
    
    TraceLeave("AccessUdpTable");
    
    return dwResult;

}

DWORD 
AccessUdpRow(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to retrieve a UDP Row

Locks

    Takes the UDP Cache lock as READER
    
Arguments

    dwQueryType     Can be ACCESS_GET, ACCESS_GET_NEXT or ACCESS_GET_FIRST
    pInEntry        LocalAddr & LocalPort for the row filled in the
                    rgdwVarIndex field. 
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_UDPROW);

Return Value:
  
    NO_ERROR or some error code defined in iprtrmib

--*/ 
{
    PMIB_UDPROW pUdpRow;
    DWORD       dwResult, dwIndex, dwNumIndices;

    TraceEnter("AccessUdpRow");

    pUdpRow = (PMIB_UDPROW)(pOutEntry->rgbyData);
    
    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_UDPROW))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_UDPROW);

        TraceLeave("AccessUdpRow");
        
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_UDPROW);
    
    pOutEntry->dwId = UDP_ROW;
    
    if((dwResult = UpdateCache(UDPCACHE,pbCache)) isnot NO_ERROR)
    {
        Trace1(MIB,
               "AccessUdpRow: Couldnt update Udp Cache. Error %d", dwResult);

        TraceLeave("AccessUdpRow");
        
        return dwResult;
    }
    
    do
    {
        ENTER_READER(UDPCACHE);
        
        dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;
               
        dwResult = LocateUdpRow(dwQueryType,
                                dwNumIndices,
                                pInEntry->rgdwVarIndex,
                                &dwIndex);
        
        if(dwResult is NO_ERROR)
        {
            *pUdpRow = g_UdpInfo.pUdpTable->table[dwIndex];
            
            dwResult = NO_ERROR;
        }
        
    }while(FALSE);

    EXIT_LOCK(UDPCACHE);
    
    TraceLeave("AccessUdpRow");
    
    return dwResult;

}

DWORD 
AccessTcpStats(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to get TCP statistics

Locks

    None, since the stats are not cached

Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_TCPSTATS)

Return Value:         

    NO_ERROR or some error code defined in iprtrmib

--*/

{
    PMIB_TCPSTATS   pTcpStats;
    DWORD           dwResult;
    
    TraceEnter("AccessTcpStats");

    pTcpStats = (PMIB_TCPSTATS)(pOutEntry->rgbyData);
    
    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessTcpStats");
        
        return ERROR_INVALID_PARAMETER;
    }

    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_TCPSTATS))
    {
        dwResult = ERROR_INSUFFICIENT_BUFFER;
    }
    else
    {
        pOutEntry->dwId = TCP_STATS;

        *pbCache = TRUE;

        dwResult = GetTcpStatsFromStack(pTcpStats);
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_TCPSTATS);

    TraceLeave("AccessTcpStats");

    return dwResult;
}

DWORD 
AccessTcpTable(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to get TCP Table

Locks

    TCP Cache lock as READER
    
Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + SIZEOF_TCPTABLE(NumTcpEntries)

Return Value:         

    NO_ERROR

--*/

{

    PMIB_TCPTABLE   pTcpTable;
    DWORD           i, dwResult;

    TraceEnter("AccessTcpTable");

    pTcpTable = (PMIB_TCPTABLE)(pOutEntry->rgbyData);
    
    if(dwQueryType isnot ACCESS_GET)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    if((dwResult = UpdateCache(TCPCACHE,pbCache)) isnot NO_ERROR)
    {
        
        Trace1(MIB,
               "AccessTcpTable: Couldnt update Tcp Cache. Error %d",
               dwResult);

        TraceLeave("AccessTcpTable");
        
        return dwResult;
    }
    
    do
    {
        ENTER_READER(TCPCACHE);
        
        if((g_TcpInfo.pTcpTable is NULL) or
           (g_TcpInfo.pTcpTable->dwNumEntries is 0))
        {
            Trace0(MIB,"AccessTcpTable: No valid entries found");
            
            if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_TCPTABLE))
            {
                dwResult = ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                pOutEntry->dwId = TCP_TABLE;

                pTcpTable->dwNumEntries = 0;
                
                dwResult = NO_ERROR;
            }

            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_TCPTABLE);
            
            break;
        }
        
        if(*pOutEntrySize <
           MAX_MIB_OFFSET + SIZEOF_TCPTABLE(g_TcpInfo.pTcpTable->dwNumEntries))
        {
            *pOutEntrySize =
                MAX_MIB_OFFSET + SIZEOF_TCPTABLE(g_TcpInfo.pTcpTable->dwNumEntries);

            dwResult = ERROR_INSUFFICIENT_BUFFER;

            break;
        }
        
        pOutEntry->dwId = TCP_TABLE;
        
        *pOutEntrySize =
            MAX_MIB_OFFSET + SIZEOF_TCPTABLE(g_TcpInfo.pTcpTable->dwNumEntries);
        
        for(i = 0; i < g_TcpInfo.pTcpTable->dwNumEntries; i++)
        {
            pTcpTable->table[i] = g_TcpInfo.pTcpTable->table[i];
        }
        
        pTcpTable->dwNumEntries = g_TcpInfo.pTcpTable->dwNumEntries;
        
        dwResult = NO_ERROR;
        
    }while(FALSE);

    EXIT_LOCK(TCPCACHE);
    
    TraceLeave("AccessTcpTable");
    
    return dwResult;
}

DWORD 
AccessTcpRow(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to retrieve or set a TCP Row

Locks

    Takes the TCP Cache lock as READER for queries and as a WRITER for
    Sets
    
Arguments

    dwQueryType     Can be anything except ACCESS_DELETE_ENTRY and
                    ACCESS_CREATE_ENTRY.
                    For ACCESS_SET, the state is the only thing that can
                    be set and it can only be set to TCP_DELETE_TCB
    pInEntry        LocalAddr, LocalPort, RemoteAddr, RemotePort for the
                    row filled in the rgdwVarIndex field. 
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_TCPROW);
                    For Sets, the OutEntry contains the row to set

Return Value:
  
    NO_ERROR or some error code defined in iprtrmib

--*/ 
{
    DWORD       dwResult, dwNumIndices, dwIndex;
    PMIB_TCPROW pTcpRow;

    TraceEnter("AccessTcpRow");

    pTcpRow = (PMIB_TCPROW)(pOutEntry->rgbyData);
    
    if(dwQueryType isnot ACCESS_DELETE_ENTRY)
    {
        if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_TCPROW))
        {
            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_TCPROW);

            TraceLeave("AccessTcpRow");
        
            return ERROR_INSUFFICIENT_BUFFER;
        }
    
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_TCPROW);
    
        pOutEntry->dwId = TCP_ROW;
    }
    
    if((dwResult = UpdateCache(TCPCACHE,pbCache)) isnot NO_ERROR)
    {   
        Trace1(MIB,
               "AccessTcpRow: Couldnt update Tcp Cache. Error %d",
               dwResult);

        TraceLeave("AccessTcpRow");
        
        return dwResult;
    }
    

    do
    {
        if(dwQueryType is ACCESS_SET)
        {
            ENTER_WRITER(TCPCACHE);
        }
        else
        {
            ENTER_READER(TCPCACHE);
        }
        
        dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;
        
        dwResult = LocateTcpRow(dwQueryType,
                                dwNumIndices,
                                pInEntry->rgdwVarIndex,
                                &dwIndex);
        
        if(dwResult is NO_ERROR)
        {
            switch(dwQueryType)
            {
                case ACCESS_GET:
                case ACCESS_GET_NEXT:
                case ACCESS_GET_FIRST:
                {
                    *pTcpRow = g_TcpInfo.pTcpTable->table[dwIndex];

                    dwResult = NO_ERROR;

                    break;
                }
                case ACCESS_SET:
                {
                    //
                    // The only thing you can do is set it to a state and that 
                    // too only to TCP_DELETE_TCB
                    //
                    
                    if(pTcpRow->dwState isnot TCP_DELETE_TCB)
                    {
                        Trace1(ERR,
                               "AccessTcpRow: TCP State can only be set to delete. Tried to set to %d",
                               pTcpRow->dwState);
                        
                        dwResult = ERROR_INVALID_DATA;

                        break;
                    }
                    
                    dwResult = SetTcpEntryToStack(pTcpRow);
                    
                    if(dwResult is NO_ERROR)
                    {
                        g_TcpInfo.pTcpTable->table[dwIndex].dwState = 
                            pTcpRow->dwState;
                    }
                    
                    break;
                }
                default:
                {
                    Trace1(ERR,
                           "AccessTcpRow: Query type %d is wrong",
                           dwQueryType);
                    
                    dwResult = ERROR_INVALID_PARAMETER;

                    break;
                }
            }
        }
        
    }while(FALSE);

    EXIT_LOCK(TCPCACHE);
        
    TraceLeave("AccessTcpRow");
        
    return dwResult;
}

DWORD  
AccessIpStats(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO     pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to get IP statistics

Locks

    None, since the stats are not cached

Arguments

    dwQueryType     ACCESS_GET or ACCESS_SET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IPSTATS)

Return Value:         

    NO_ERROR or some error code defined in iprtrmib

--*/

{
    PMIB_IPSTATS    pIpStats;
    DWORD           dwResult;
    
    TraceEnter("AccessIpStats");

    pIpStats = (PMIB_IPSTATS)(pOutEntry->rgbyData);
    
    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPSTATS))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPSTATS);

        TraceLeave("AccessIpStats");
        
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPSTATS);
    
    pOutEntry->dwId = IP_STATS;
    
    switch(dwQueryType)
    {
        case ACCESS_GET:
        {
            //
            // Since we need to write the number of routes addresses etc
            // Update the two caches
            //

            UpdateCache(IPADDRCACHE,pbCache);
            UpdateCache(IPFORWARDCACHE,pbCache);

            dwResult = GetIpStatsFromStack(pIpStats);
  
            pIpStats->dwNumIf = g_ulNumInterfaces;
            
            pIpStats->dwNumRoutes = 0;

            if(g_IpInfo.pForwardTable)
            {
                pIpStats->dwNumRoutes = g_IpInfo.pForwardTable->dwNumEntries;
            }

            pIpStats->dwNumAddr = 0;

            if(g_IpInfo.pAddrTable)
            {
                pIpStats->dwNumAddr = g_IpInfo.pAddrTable->dwNumEntries;
            }
 
            TraceLeave("AccessIpStats");
          
            return dwResult;
        }
        
        case ACCESS_SET:
        {
            MIB_IPSTATS CurrentIpStats;
            DWORD       dwErr;
          
            dwErr = GetIpStatsFromStack(&CurrentIpStats);
          
            if(dwErr isnot NO_ERROR)
            {
                Trace1(ERR,
                       "AccessIpStats: Couldnt get IPSNMP info from stack to initiate set. Error %d",
                       dwErr);
              
                return dwErr;
            }
          
            //
            // See what the current forwarding status is. We allow one to go
            // Forward -> notForward but not the other way.
            //
          
            if(pIpStats->dwDefaultTTL isnot MIB_USE_CURRENT_TTL)
            {
                if(pIpStats->dwDefaultTTL > 255)
                {
                    Trace0(ERR,"AccessIpStats: Cant set TTL > 255");
                  
                    TraceLeave("AccessIpStats");
                  
                    return ERROR_INVALID_DATA;
                }


                dwErr = SetIpStatsToStack(pIpStats);

                if(dwErr isnot NO_ERROR)
                {
                    Trace1(ERR,
                           "AccessIpStats: Error %d setting TTL in stack",
                           dwErr);
                }
            }

            if(pIpStats->dwForwarding isnot MIB_USE_CURRENT_FORWARDING)
            {
                if((pIpStats->dwForwarding isnot MIB_IP_FORWARDING) and
                   (pIpStats->dwForwarding isnot MIB_IP_NOT_FORWARDING))
                {
                    Trace1(ERR,
                           "AccessIpStats: Fwding state %d is invalid",
                           pIpStats->dwForwarding);

                    return ERROR_INVALID_DATA;
                }

                //
                // See if its to switch off forwarding
                //
             
                EnterCriticalSection(&g_csFwdState);
 
                g_bEnableFwdRequest = (pIpStats->dwForwarding is MIB_IP_FORWARDING);

                Trace1(GLOBAL,
                       "AccessIpStats: Signalling worker to %s forwarding",
                       g_bEnableFwdRequest ? "enable" : "disable");

                SetEvent(g_hSetForwardingEvent);

                LeaveCriticalSection(&g_csFwdState);
            }

            TraceLeave("AccessIpStats");
                  
            return dwErr;
        }
        
        default:
        {
            Trace1(ERR,
                   "AccessIpStats: Query type %d is wrong",
                   dwQueryType);

            return ERROR_INVALID_PARAMETER;
        }
    }
}


DWORD  
AccessIpAddrTable(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to get IP Address Table

Locks

    IP Address Cache lock as READER
    
Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + SIZEOF_IPADDRTABLE(NumIpAddrEntries)

Return Value:  

    NO_ERROR

--*/

{
    PMIB_IPADDRTABLE    pIpAddrTable;
    DWORD               dwResult, i;

    TraceEnter("AccessIpAddrTable");

    pIpAddrTable = (PMIB_IPADDRTABLE)(pOutEntry->rgbyData);
    
    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessIpAddrTable");
        
        return ERROR_INVALID_PARAMETER;
    }
    
    if((dwResult = UpdateCache(IPADDRCACHE,pbCache)) isnot NO_ERROR)
    {
        Trace1(MIB,
               "AccessIpAddrTable: Error %d updating IpAddr Cache",
               dwResult);

        TraceLeave("AccessIpAddrTable");
        
        return dwResult;
    }
    
    do
    {
        ENTER_READER(IPADDRCACHE);
   
        if((g_IpInfo.pAddrTable is NULL) or
           (g_IpInfo.pAddrTable->dwNumEntries is 0)) 
        {
            Trace0(MIB,"No valid entries found");
            
            if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPADDRTABLE))
            {
                dwResult = ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                pOutEntry->dwId = IP_ADDRTABLE;
                
                pIpAddrTable->dwNumEntries = 0;
                
                dwResult = NO_ERROR;
            }

            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPADDRTABLE);

            break;
        }
        
        if(*pOutEntrySize <
           MAX_MIB_OFFSET + SIZEOF_IPADDRTABLE(g_IpInfo.pAddrTable->dwNumEntries))
        {
            *pOutEntrySize = MAX_MIB_OFFSET +
                             SIZEOF_IPADDRTABLE(g_IpInfo.pAddrTable->dwNumEntries);
            
            dwResult = ERROR_INSUFFICIENT_BUFFER;
            
            break;
        }
        
        pOutEntry->dwId = IP_ADDRTABLE;
        
        *pOutEntrySize = MAX_MIB_OFFSET +
                         SIZEOF_IPADDRTABLE(g_IpInfo.pAddrTable->dwNumEntries);
        
        for(i = 0; i < g_IpInfo.pAddrTable->dwNumEntries; i ++)
        {
            pIpAddrTable->table[i] = g_IpInfo.pAddrTable->table[i];
        }
        
        pIpAddrTable->dwNumEntries = g_IpInfo.pAddrTable->dwNumEntries;
        
        dwResult = NO_ERROR;
        
    }while(FALSE);

    EXIT_LOCK(IPADDRCACHE);

    TraceLeave("AccessIpAddrTable");
    
    return dwResult;

}

DWORD  
AccessIpForwardNumber(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
{
    PMIB_IPFORWARDNUMBER pNum;
    DWORD   dwResult;

    TraceEnter("AccessIpForwardNumber");
    
    pNum = (PMIB_IPFORWARDNUMBER)pOutEntry;

    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessIpForwardNumber");
    
        return ERROR_INVALID_PARAMETER;
    }

    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPFORWARDNUMBER))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPFORWARDNUMBER);

        TraceLeave("AccessIpForwardNumber");

        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPFORWARDNUMBER);
    
    if((dwResult = UpdateCache(IPFORWARDCACHE,pbCache)) isnot NO_ERROR)
    {
        Trace1(MIB,
               "AccessIpForwardNumber: Couldnt update IpForward Cache. Error %d", 
               dwResult);

        TraceLeave("AccessIpForwardNumber");

        return dwResult;
    }

    ENTER_READER(IPFORWARDCACHE);

    pNum->dwValue = 0;

    if(g_IpInfo.pForwardTable)
    {
        pNum->dwValue = g_IpInfo.pForwardTable->dwNumEntries;
    }

    pOutEntry->dwId = IP_FORWARDNUMBER;

    *pbCache = TRUE;

    EXIT_LOCK(IPFORWARDCACHE);

    TraceLeave("AccessIpForwardNumber");
    
    return NO_ERROR;
}


DWORD  
AccessIpForwardTable(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

      Function used to get IFTable

Arguments
    dwQueryType     Can only be ACCESS_GET
    dwInEntrySize   Size of pInEntry in bytes
    pInEntry       Nothing important since the whole table is retrieved
    pOutEntrySize  IN: Size of pOutEntry in bytes
                      OUT:Size of information filled in OR size of memory needed 
    pOutEntry      Points to information filled into an MIB_IFTABLE structure
    pbCache        Unused

Return Value:         

    NO_ERROR or some error code defined in iprtrmib

--*/ 
{         
    PMIB_IPFORWARDTABLE pIpForwardTable;
    DWORD               i,dwResult;

    TraceEnter("AccessIpForwardTable");
    
    pIpForwardTable = (PMIB_IPFORWARDTABLE)(pOutEntry->rgbyData);

    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessIpForwardTable");
        
        return ERROR_INVALID_PARAMETER;
    }
    
    if((dwResult = UpdateCache(IPFORWARDCACHE,pbCache)) isnot NO_ERROR)
    {
        Trace1(MIB,
               "AccessIpForwardTable: Couldnt update IpForward Cache. Error %d",
               dwResult);

        TraceLeave("AccessIpForwardTable");
        
        return dwResult;
    }
    
    do
    {
        ENTER_READER(IPFORWARDCACHE);
   
        if((g_IpInfo.pForwardTable is NULL) or
           (g_IpInfo.pForwardTable->dwNumEntries is 0))
        {
            Trace0(MIB,"No valid entries found");

            if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPFORWARDTABLE))
            {
                dwResult = ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                pOutEntry->dwId = IP_FORWARDTABLE;

                pIpForwardTable->dwNumEntries = 0;

                dwResult = NO_ERROR;
            }

            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPFORWARDTABLE);

            break;
        }
        
        if(*pOutEntrySize < MAX_MIB_OFFSET + SIZEOF_IPFORWARDTABLE(g_IpInfo.pForwardTable->dwNumEntries))
        {
            *pOutEntrySize = MAX_MIB_OFFSET + SIZEOF_IPFORWARDTABLE(g_IpInfo.pForwardTable->dwNumEntries);
                                                                                        
            dwResult = ERROR_INSUFFICIENT_BUFFER;
            
            break;
        }
        
        pOutEntry->dwId = IP_FORWARDTABLE;
        
        *pOutEntrySize = MAX_MIB_OFFSET + SIZEOF_IPFORWARDTABLE(g_IpInfo.pForwardTable->dwNumEntries);
        
        for(i = 0; i < g_IpInfo.pForwardTable->dwNumEntries; i ++)
        {
            pIpForwardTable->table[i] = g_IpInfo.pForwardTable->table[i];
        }
        
        pIpForwardTable->dwNumEntries = g_IpInfo.pForwardTable->dwNumEntries;
        
        dwResult = NO_ERROR;
        
    }while(FALSE);

    EXIT_LOCK(IPFORWARDCACHE);

    TraceLeave("AccessIpForwardTable");
        
    return dwResult;
}


DWORD  
AccessIpNetTable(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to get ARP Table

Locks

    IP Net Cache lock as READER
    
Arguments

    dwQueryType     ACCESS_GET or ACCESS_DELETE_ENTRY
    dwInEntrySize   (only for delete)
    pOutEntrySize   MAX_MIB_OFFSET + SIZEOF_IPNETTABLE(NumArpEntries)

Return Value:  

    NO_ERROR

--*/

{
    PMIB_IPNETTABLE pIpNetTable;
    DWORD           i,dwResult;

    TraceEnter("AccessIpNetTable");

    pIpNetTable = (PMIB_IPNETTABLE)(pOutEntry->rgbyData);
    
    if((dwQueryType isnot ACCESS_GET) and
       (dwQueryType isnot ACCESS_DELETE_ENTRY))
    {
        TraceLeave("AccessIpNetTable");
        
        return ERROR_INVALID_PARAMETER;
    }

    if(dwQueryType is ACCESS_GET)
    { 
        dwResult = UpdateCache(IPNETCACHE,pbCache);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(MIB,
                   "AccessIpNetTable: Couldnt update IpNet Cache. Error %d",
                   dwResult);

            TraceLeave("AccessIpNetTable");
        
            return dwResult;
        }
    }
    else
    {
        DWORD   dwIfIndex;
        PICB    pIcb;

        if(dwInEntrySize < sizeof(MIB_OPAQUE_QUERY))
        {
            TraceLeave("AccessIpNetTable");

            return ERROR_INVALID_PARAMETER;
        
        }

        dwIfIndex = pInEntry->rgdwVarIndex[0];

        ENTER_READER(ICB_LIST);

        pIcb = InterfaceLookupByIfIndex(dwIfIndex);

        if((pIcb is NULL) or
           (pIcb->bBound is FALSE))
        {
            EXIT_LOCK(ICB_LIST);

            TraceLeave("AccessIpNetTable");
        
            return ERROR_INVALID_INDEX;
        }

        dwIfIndex = pIcb->dwIfIndex;

        EXIT_LOCK(ICB_LIST);

        dwResult = FlushIpNetTableFromStack(dwIfIndex);

        TraceLeave("AccessIpNetTable");

        return dwResult;
    }
        
    
    do
    {
        ENTER_READER(IPNETCACHE);
        
        if((g_IpInfo.pNetTable is NULL) or
           (g_IpInfo.pNetTable->dwNumEntries is 0))
        {
            Trace0(MIB,"No valid entries found");

            if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPNETTABLE))
            {
                dwResult = ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                pOutEntry->dwId = IP_NETTABLE;

                pIpNetTable->dwNumEntries = 0;

                dwResult = NO_ERROR;
            }

            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPNETTABLE);

            break;
        }
        
        if(*pOutEntrySize <
           MAX_MIB_OFFSET + SIZEOF_IPNETTABLE(g_IpInfo.pNetTable->dwNumEntries))
        {
            *pOutEntrySize = MAX_MIB_OFFSET + 
                             SIZEOF_IPNETTABLE(g_IpInfo.pNetTable->dwNumEntries);
            
            dwResult = ERROR_INSUFFICIENT_BUFFER;
            
            break;
        }
        
        pOutEntry->dwId = IP_NETTABLE;

        *pOutEntrySize =
            MAX_MIB_OFFSET + SIZEOF_IPNETTABLE(g_IpInfo.pNetTable->dwNumEntries);
    
        for(i = 0; i < g_IpInfo.pNetTable->dwNumEntries; i ++)
        {
            pIpNetTable->table[i] = g_IpInfo.pNetTable->table[i];
        }
        
        pIpNetTable->dwNumEntries = g_IpInfo.pNetTable->dwNumEntries;

        dwResult = NO_ERROR;
        
    }while(FALSE);

    EXIT_LOCK(IPNETCACHE);

    TraceLeave("AccessIpNetTable");
    
    return dwResult;
}


DWORD 
AccessIpAddrRow(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to retrieve a IP Address Row

Locks

    Takes the IP Address Cache lock as READER
    
Arguments

    dwQueryType     Can be ACCESS_GET, ACCESS_GET_NEXT or ACCESS_GET_FIRST
    pInEntry        Address for the row filled in the rgdwVarIndex field. 
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IPADDRROW)

Return Value:
  
    NO_ERROR or some error code defined in iprtrmib

--*/ 
{
    DWORD           dwResult, dwNumIndices, dwIndex;
    PMIB_IPADDRROW  pIpAddrRow;

    TraceEnter("AccessIpAddrRow");

    pIpAddrRow = (PMIB_IPADDRROW)(pOutEntry->rgbyData);
    
    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPADDRROW))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPADDRROW);

        TraceLeave("AccessIpAddrRow");
        
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPADDRROW);
    
    pOutEntry->dwId = IP_ADDRROW;
    
    if((dwResult = UpdateCache(IPADDRCACHE,pbCache)) isnot NO_ERROR)
    {   
        Trace1(MIB,
               "AccessIpAddrRow: Couldnt update Ip Addr Cache. Error %d",
               dwResult);

        TraceLeave("AccessIpAddrRow");
        
        return dwResult;
    }
    
    
    do
    {
        ENTER_READER(IPADDRCACHE);

        dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;
        
        dwResult = LocateIpAddrRow(dwQueryType,
                                   dwNumIndices,
                                   pInEntry->rgdwVarIndex,
                                   &dwIndex);
        
        if(dwResult is NO_ERROR)
        {
            *pIpAddrRow = g_IpInfo.pAddrTable->table[dwIndex];
            
            dwResult = NO_ERROR;
        }
        
    }while(FALSE);

    EXIT_LOCK(IPADDRCACHE);
    
    TraceLeave("AccessIpAddrRow");
    
    return dwResult;
    
}


DWORD 
AccessIpForwardRow(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to retrieve or set a route (IP Forward Row)

Locks

    Takes the IP Forward Cache lock as READER for queries, WRITER for sets
    
Arguments

    dwQueryType     All permitted
    pInEntry        Dest, Proto, Policy and NextHop for the row filled in the
                    rgdwVarIndex field. 
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IPFORWARDROW). For Sets the
                    OutBuffer has the row to set

Return Value:
  
    NO_ERROR or some error code defined in iprtrmib

--*/

{
    DWORD               dwResult,dwNumIndices,dwIndex;
    PMIB_IPFORWARDROW   pIpForwardRow;

    TraceEnter("AccessIpForwardRow");

    pIpForwardRow = (PMIB_IPFORWARDROW)(pOutEntry->rgbyData);

    if(dwQueryType isnot ACCESS_DELETE_ENTRY)
    {
        if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPFORWARDROW))
        {
            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPFORWARDROW);

            TraceLeave("AccessIpForwardRow");
        
            return ERROR_INSUFFICIENT_BUFFER;
        }
    
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPFORWARDROW);
    
        pOutEntry->dwId = IP_FORWARDROW;
    }
    
    if((dwResult = UpdateCache(IPFORWARDCACHE,pbCache)) isnot NO_ERROR)
    {   
        Trace1(MIB,
               "AccessIpForwardRow: Error %d updating IpForward Cache",
               dwResult);

        TraceLeave("AccessIpForwardRow");
        
        return dwResult;
    }

    
    do
    {
        if(dwQueryType > ACCESS_GET_NEXT)
        {
            ENTER_WRITER(IPFORWARDCACHE);
        }
        else
        {
            ENTER_READER(IPFORWARDCACHE);
        }

        dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;
        
        dwResult = LocateIpForwardRow(dwQueryType,
                                      dwNumIndices,
                                      pInEntry->rgdwVarIndex,
                                      &dwIndex);
        
        if(dwResult is NO_ERROR)
        {
            switch(dwQueryType)
            {
                case ACCESS_GET:
                case ACCESS_GET_NEXT:
                case ACCESS_GET_FIRST:
                {
                    *pIpForwardRow = g_IpInfo.pForwardTable->table[dwIndex];
                    
                    break;
                }
                case ACCESS_SET:
                {
                    dwResult =
                        SetIpForwardRow(&(g_IpInfo.pForwardTable->table[dwIndex]),
                                        pIpForwardRow);
                    
                    if(dwResult is NO_ERROR)
                    {
                        g_IpInfo.pForwardTable->table[dwIndex] = *pIpForwardRow;
                    }
                    
                    break;
                }
                case ACCESS_DELETE_ENTRY:
                {
                    dwResult =
                        DeleteIpForwardRow(&(g_IpInfo.pForwardTable->table[dwIndex]));
                    
                    if(dwResult is NO_ERROR)
                    {
                        g_LastUpdateTable[IPFORWARDCACHE] = 0;
                    }
                    
                    break;
                }
                case ACCESS_CREATE_ENTRY:
                {
                    // 
                    // 
                    // This is the case where you have tried to create a
                    // route which matches an existing entry
                    //

                    dwResult = ERROR_ALREADY_EXISTS;

                    break;
                }
            }
        }
        else
        {
            if((dwQueryType is ACCESS_CREATE_ENTRY) or
               (dwQueryType is ACCESS_SET))
            {
                // 
                // Cannot set PROTO_IP_LOCAL routes (other protos will
                // be weeded out when we search for the RTM handle)
                //
                
                if(pIpForwardRow->dwForwardProto is PROTO_IP_LOCAL)
                {
                    dwResult = ERROR_INVALID_PARAMETER;
                    
                    break;
                }

                dwResult = SetIpForwardRow(NULL,
                                           pIpForwardRow);
                
                //
                // Since its too much hassle to create, malloc (possibly)
                // sorted insert we make just invalidate the route cache
                //
                
                if(dwResult is NO_ERROR)
                {
                    g_LastUpdateTable[IPFORWARDCACHE] = 0;
                }
            }
        }
        
    }while(FALSE);

    EXIT_LOCK(IPFORWARDCACHE);

    TraceLeave("AccessIpForwardRow");
        
    return dwResult;

}


DWORD 
AccessIpNetRow(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to retrieve or set an ARP entry (IP Net Row)

Locks

    Takes the IP Net Cache lock as READER for queries, as WRITER for sets
    
Arguments

    dwQueryType     All permitted
    pInEntry        IfIndex and IPAddress for the row filled in the
                    rgdwVarIndex field. 
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IPNETROW);
                    For Sets, the OutEntry contains the row to set

Return Value:
  
    NO_ERROR or some error code defined in iprtrmib

--*/ 
{
    DWORD           dwResult, dwNumIndices, dwIndex;
    PMIB_IPNETROW   pIpNetRow;
    PICB            pIcb;

    TraceEnter("AccessIpNetRow");

    pIpNetRow = (PMIB_IPNETROW)(pOutEntry->rgbyData);
    
    if(dwQueryType isnot ACCESS_DELETE_ENTRY)
    {
        if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPNETROW))
        {
            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPNETROW);

            TraceLeave("AccessIpNetRow");
        
            return ERROR_INSUFFICIENT_BUFFER;
        }
    
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPNETROW);
    
        pOutEntry->dwId = IP_NETROW;
    }
    
    if((dwResult = UpdateCache(IPNETCACHE,pbCache)) isnot NO_ERROR)
    {   
        Trace1(MIB,
               "AccessIpNetRow: Couldnt update Ip Addr Cache. Error %d", 
               dwResult);

        TraceLeave("AccessIpNetRow");
        
        return dwResult;
    }


    do
    {
        if(dwQueryType > ACCESS_GET_NEXT)
        {
            ENTER_WRITER(IPNETCACHE);
        }
        else
        {
            ENTER_READER(IPNETCACHE);
        }
        
        dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;
        
        dwResult = LocateIpNetRow(dwQueryType,
                                  dwNumIndices,
                                  pInEntry->rgdwVarIndex,
                                  &dwIndex);
        
        if(dwResult is NO_ERROR)
        {
            switch(dwQueryType)
            {
                case ACCESS_GET:
                case ACCESS_GET_NEXT:
                case ACCESS_GET_FIRST:
                {
          
                    *pIpNetRow = g_IpInfo.pNetTable->table[dwIndex];
                    
                    break;
                }

                case ACCESS_SET:
                {
                    if((pIpNetRow->dwType isnot MIB_IPNET_TYPE_DYNAMIC) and
                       (pIpNetRow->dwType isnot MIB_IPNET_TYPE_STATIC))
                    {
                        dwResult = ERROR_INVALID_DATA;

                        break;
                    }

                    //
                    // Need to map the interface index to the adapter index
                    //

                    ENTER_READER(ICB_LIST);
                   
                    pIcb = InterfaceLookupByIfIndex(pIpNetRow->dwIndex);

                    if((pIcb is NULL) or
                       (!pIcb->bBound))
                    {
                        //
                        // Could not find interface
                        //

                        dwResult = ERROR_INVALID_INDEX;

                        EXIT_LOCK(ICB_LIST);

                        break;
                    }
                    
                    EXIT_LOCK(ICB_LIST);

                    //
                    // No need to force cache updates
                    //
                    
                    dwResult = SetIpNetEntryToStack(pIpNetRow, FALSE);
                    
                    if(dwResult is NO_ERROR)
                    {
                        g_IpInfo.pNetTable->table[dwIndex] = *pIpNetRow;
                    }
                    
                    break;
                }
                
                case ACCESS_DELETE_ENTRY:
                {
                    MIB_IPNETROW    tempRow;

                    g_IpInfo.pNetTable->table[dwIndex].dwType =
                        MIB_IPNET_TYPE_INVALID;

                    tempRow = g_IpInfo.pNetTable->table[dwIndex];

                    dwResult = SetIpNetEntryToStack(&tempRow,
                                                    FALSE);
                    
                    if(dwResult is NO_ERROR)
                    {
                        g_LastUpdateTable[IPNETCACHE] = 0;
                    }
                    
                    break;
                }

                case ACCESS_CREATE_ENTRY:
                {
                    dwResult = ERROR_ALREADY_EXISTS;
            
                    break;
                }
            }
        }
        else
        {
            if((dwQueryType is ACCESS_CREATE_ENTRY) or
               (dwQueryType is ACCESS_SET))
            {
                ENTER_READER(ICB_LIST);
                   
                pIcb = InterfaceLookupByIfIndex(pIpNetRow->dwIndex);

                if((pIcb is NULL) or
                   (!pIcb->bBound))
                {
                    //
                    // Could not find interface
                    //

                    dwResult = ERROR_INVALID_INDEX;

                    EXIT_LOCK(ICB_LIST);

                    break;
                }

                EXIT_LOCK(ICB_LIST);
                    
                dwResult = SetIpNetEntryToStack(pIpNetRow,
                                                FALSE);
                
                if(dwResult is NO_ERROR)
                {
                    g_LastUpdateTable[IPNETCACHE] = 0;
                }
            }
        }
        
    }while(FALSE);

    EXIT_LOCK(IPNETCACHE);

    TraceLeave("AccessIpNetRow");
    
    return dwResult;

}

//
// The ACCESS_SETs and ACCESS_CREATEs require a bit more work in that the
// values have to be written back to the stack. The actual code for setting
// to stack (or RTM) is elsewhere, the following functions are merely
// wrappers around the actual calls
//

DWORD 
SetIpForwardRow(
    PMIB_IPFORWARDROW pOldIpForw,
    PMIB_IPFORWARDROW pNewIpForw
    )
{
    DWORD           i, dwResult, dwMask;
    HANDLE          hRtmHandle;
    PICB            pIcb;

    TraceEnter("SetIpForwardRow");

    hRtmHandle = NULL;

    for(i = 0;
        i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
        i++)
    {
        if(pNewIpForw->dwForwardProto is g_rgRtmHandles[i].dwProtoId)
        {
            hRtmHandle = g_rgRtmHandles[i].hRouteHandle;

            break;
        }
    }


    if(hRtmHandle is NULL)
    {
        Trace1(ERR,
               "SetIpForwardRow: Protocol %d not valid",
               pNewIpForw->dwForwardProto);
               
        TraceLeave("SetIpForwardRow");

        return ERROR_INVALID_PARAMETER;
    }

    if((pNewIpForw->dwForwardDest & pNewIpForw->dwForwardMask) isnot pNewIpForw->dwForwardDest)
    {
        Trace2(ERR,
               "SetIpForwardRow: Dest %d.%d.%d.%d and Mask %d.%d.%d.%d wrong",
               PRINT_IPADDR(pNewIpForw->dwForwardDest),
               PRINT_IPADDR(pNewIpForw->dwForwardMask));

        TraceLeave("SetIpForwardRow");

        return ERROR_INVALID_PARAMETER;
    }

    if(((DWORD)(pNewIpForw->dwForwardDest & 0x000000FF)) >= (DWORD)0x000000E0)
    {
        //
        // This will catch the CLASS D/E and all 1's bcast
        //

        Trace1(ERR,
               "SetIpForwardRow: Dest %d.%d.%d.%d is invalid",
               PRINT_IPADDR(pNewIpForw->dwForwardDest));

        TraceLeave("SetIpForwardRow");

        return ERROR_INVALID_PARAMETER;
    }

#if 0
    // Removed this since metric=0 is legal for routes to the loopback
    // interface.
    if(pNewIpForw->dwForwardMetric1 is 0)
    {
        Trace0(ERR,
               "SetIpForwardRow: Metric1 cant be 0");

        TraceLeave("SetIpForwardRow");

        return ERROR_INVALID_PARAMETER;
    }
#endif

    //
    // If we are changing values, we need to blow the old row away.
    // Just a quirk of how
    // RTM and our stack works
    //
    
    if(pOldIpForw isnot NULL)
    {
        dwResult = DeleteIpForwardRow(pOldIpForw);
        
        if(dwResult isnot NO_ERROR)
        {
            Trace1(MIB,
                   "SetIpForwardRow: Unable to delete route from RTM. Error %d",
                   dwResult);
    
            TraceLeave("SetIpForwardRow");

            return ERROR_CAN_NOT_COMPLETE;
        }

        UpdateStackRoutesToRestoreList(pOldIpForw, IRNO_FLAG_DELETE);
    }

    if(pNewIpForw->dwForwardProto isnot PROTO_IP_NETMGMT)
    {
        pNewIpForw->dwForwardAge = INFINITE;
    }

    //
    // Add the RTM route from the ip forward entry
    //

    ENTER_READER(ICB_LIST);
    
    dwMask = GetBestNextHopMaskGivenIndex(pNewIpForw->dwForwardIfIndex,
                                          pNewIpForw->dwForwardNextHop);
   
    pIcb = InterfaceLookupByIfIndex(pNewIpForw->dwForwardIfIndex);

    if(pIcb is NULL)
    {
        EXIT_LOCK(ICB_LIST);

        Trace1(ERR,
               "SetIpForwardRow: I/f 0x%x doesnt exist", 
               pNewIpForw->dwForwardIfIndex);

        TraceLeave("SetIpForwardRow");

        return ERROR_INVALID_PARAMETER;
    }

    if(IsIfP2P(pIcb->ritType))
    {
        pNewIpForw->dwForwardNextHop = 0;
    }

    EXIT_LOCK(ICB_LIST);

    dwResult = AddRtmRoute(hRtmHandle,
                           ConvertMibRouteToRouteInfo(pNewIpForw),
                           IP_VALID_ROUTE | IP_STACK_ROUTE,
                           dwMask,
                           pNewIpForw->dwForwardAge,
                           NULL);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(MIB,
               "SetIpForwardRow: Could not set route to RTM: Dest %x\n",
               pNewIpForw->dwForwardDest) ;
    }

    else
    {
        UpdateStackRoutesToRestoreList(pNewIpForw, IRNO_FLAG_ADD);
    }
    
    TraceLeave("SetIpForwardRow");

    return dwResult;
}

DWORD 
DeleteIpForwardRow(
    PMIB_IPFORWARDROW pIpForw
    )
{
    DWORD            i, dwResult;
    HANDLE           hRtmHandle;

    hRtmHandle = NULL;

    for(i = 0;
        i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
        i++)
    {
        if(pIpForw->dwForwardProto is g_rgRtmHandles[i].dwProtoId)
        {
            hRtmHandle = g_rgRtmHandles[i].hRouteHandle;

            break;
        }
    }


    if(hRtmHandle is NULL)
    {
        Trace1(ERR,
               "DeleteIpForwardRow: Protocol %d not valid",
               pIpForw->dwForwardProto);

        return ERROR_INVALID_PARAMETER;
    } 
    
    //
    // Delete the RTM route corr. to the ip forward entry
    //
    
    dwResult = DeleteRtmRoute(hRtmHandle, 
                              ConvertMibRouteToRouteInfo(pIpForw));
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(MIB,
               "DeleteIpForwardRow: RtmDeleteRoute returned %d", dwResult);
    }
    else
    {
        UpdateStackRoutesToRestoreList(pIpForw, IRNO_FLAG_DELETE);
    }
    
    return dwResult;
}

DWORD
AccessMcastMfe(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++

Routine Description

    This

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    DWORD           dwResult,dwNumIndices,dwIndex;
    DWORD           dwOutBufferSize, dwNumMfes;
    MIB_IPMCAST_MFE mimInMfe;

    TraceEnter("AccessMcastMfe");

#if 1
     
    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    switch(dwQueryType)
    {
        case ACCESS_GET:
        {
            //
            // The in index better be a good size
            // The user must specify Group, Source and SrcMask. The
            // SrcMask is not used and MUST be 0xFFFFFFFF
            //

            if(dwNumIndices < 3)
            {
                TraceLeave("AccessMcastMfe");

                return ERROR_INVALID_INDEX;
            }

            ZeroMemory(&mimInMfe, sizeof(mimInMfe));

            mimInMfe.dwGroup      = pInEntry->rgdwVarIndex[0];
            mimInMfe.dwSource     = pInEntry->rgdwVarIndex[1];

            //
            // NOTE: Change when doing source aggregation
            //

            mimInMfe.dwSrcMask = 0xFFFFFFFF;

            dwOutBufferSize = 
                (*pOutEntrySize < MAX_MIB_OFFSET)? 0 : (*pOutEntrySize - MAX_MIB_OFFSET);

            dwResult = MgmGetMfe(
                        &mimInMfe, &dwOutBufferSize, pOutEntry->rgbyData
                        );

            if (dwResult == ERROR_INSUFFICIENT_BUFFER)
            {
                *pOutEntrySize = MAX_MIB_OFFSET + dwOutBufferSize;
            }
            
            break;
        }

        case ACCESS_GET_FIRST:
        {
            PMIB_MFE_TABLE      pMfeTable;

            //
            // We always gets chunks of 1KB
            //

            if(*pOutEntrySize < MIB_MFE_BUFFER_SIZE)
            {
                *pOutEntrySize = MIB_MFE_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

            //
            // MGM wants a flat buffer for MFEs. We however return a 
            // MIB_MFE_TABLE to the user that starts (in the worst case) after
            // MAX_MIB_OFFSET bytes of the input buffer
            //

#define _MIN_SIZE  \
    (MAX_MIB_OFFSET + FIELD_OFFSET(MIB_MFE_TABLE,table[0]))

            dwOutBufferSize =  *pOutEntrySize - _MIN_SIZE;

#undef _MIN_SIZE

            pMfeTable = (PMIB_MFE_TABLE)pOutEntry->rgbyData;

            pMfeTable->dwNumEntries = 0;

            // pMfe = (PMIB_IPMCAST_MFE)(pMfeTable->table);

            dwNumMfes = 0;

            dwResult = MgmGetFirstMfe(
                        &dwOutBufferSize, (PBYTE)pMfeTable->table,
                        &dwNumMfes
                        );

           
            //
            // We should NEVER get back ERROR_INSUFFICIENT_BUFFER
            //

            IpRtAssert(dwResult isnot ERROR_INSUFFICIENT_BUFFER);
 
            if((dwResult is ERROR_MORE_DATA) or
               (dwResult is ERROR_NO_MORE_ITEMS))
            {
                pMfeTable->dwNumEntries = dwNumMfes;

                dwResult = NO_ERROR;
            }

            break;
        }

        case ACCESS_GET_NEXT:
        {
            PMIB_MFE_TABLE      pMfeTable;

            //
            // For this, too we always get chunks of 1K pages
            //

            if(*pOutEntrySize < MIB_MFE_BUFFER_SIZE)
            {
                *pOutEntrySize = MIB_MFE_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

#define _MIN_SIZE  \
    (MAX_MIB_OFFSET + FIELD_OFFSET(MIB_MFE_TABLE,table[0]))

            dwOutBufferSize =  *pOutEntrySize - _MIN_SIZE;

#undef _MIN_SIZE

            pMfeTable = (PMIB_MFE_TABLE)pOutEntry->rgbyData;

            pMfeTable->dwNumEntries = 0;

            // pMfe = (PMIB_IPMCAST_MFE)(pMfeTable->table);

            dwNumMfes = 0;

            //
            // Set up the "first" mfe
            //

            ZeroMemory(&mimInMfe, sizeof(mimInMfe));

            //
            // NOTE: Change when doing source aggregation
            //

            mimInMfe.dwSrcMask = 0xFFFFFFFF;        

            switch(dwNumIndices)
            {
                case 0:
                {
                    break;
                }

                case 1:
                {
                    mimInMfe.dwGroup    = pInEntry->rgdwVarIndex[0];

                    break;
                }

                default:
                {
                    //
                    // 2 or more indices
                    //

                    mimInMfe.dwGroup    = pInEntry->rgdwVarIndex[0];
                    mimInMfe.dwSource   = pInEntry->rgdwVarIndex[1];

                    break;
                }
            }

            dwResult = MgmGetNextMfe(
                        &mimInMfe, &dwOutBufferSize, (PBYTE)pMfeTable->table, 
                        &dwNumMfes
                        );


            //
            // We should NEVER get back ERROR_INSUFFICIENT_BUFFER
            //

            IpRtAssert(dwResult isnot ERROR_INSUFFICIENT_BUFFER);

            if((dwResult is ERROR_MORE_DATA) or
               (dwResult is ERROR_NO_MORE_ITEMS))
            {
                pMfeTable->dwNumEntries = dwNumMfes;

                dwResult = NO_ERROR;
            }

            break;
        }
        
        case ACCESS_SET:
        {
            //
            // Validate the MFE size
            //

            if(dwInEntrySize < SIZEOF_BASIC_MFE)
            {
            }

            //dwResult = SetMfe(pMfe);
            
            break;
        }

        case ACCESS_DELETE_ENTRY:
        {
            
            break;
        }
        case ACCESS_CREATE_ENTRY:
        {
            // 
            // 
            // This is the case where you have tried to create a route which 
            // matches an existing entry
            //

            dwResult = ERROR_ALREADY_EXISTS;

            break;
        }
    }

#endif

    TraceLeave("AccessMcastMfe");
        
    //return dwResult;

    return NO_ERROR;
    
}


DWORD
AccessMcastMfeStats(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
{
    return AccessMcastMfeStatsInternal(
                dwQueryType,
                dwInEntrySize,
                pInEntry,
                pOutEntrySize,
                pOutEntry,
                pbCache,
                MGM_MFE_STATS_0
                );
}


DWORD
AccessMcastMfeStatsEx(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
{
    return AccessMcastMfeStatsInternal(
                dwQueryType,
                dwInEntrySize,
                pInEntry,
                pOutEntrySize,
                pOutEntry,
                pbCache,
                MGM_MFE_STATS_1
                );
}


DWORD
AccessMcastMfeStatsInternal(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache,
    DWORD               dwStatsFlag
    )

/*++

Routine Description

    This

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    DWORD           dwResult = NO_ERROR,dwNumIndices,dwIndex;
    DWORD           dwOutBufferSize, dwNumMfes;
    MIB_IPMCAST_MFE mimInMfe;


    TraceEnter("AccessMcastMfeStatsInternal");
#if 1

    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    switch(dwQueryType)
    {
        case ACCESS_GET:
        {
            //
            // The in index better be a good size
            // The user must specify Group, Source and SrcMask. The
            // SrcMask is not used and MUST be 0xFFFFFFFF
            //

            if(dwNumIndices < 3)
            {
                TraceLeave("AccessMcastMfeStatsInternal");

                return ERROR_INVALID_INDEX;
            }

            ZeroMemory(&mimInMfe, sizeof(mimInMfe));

            mimInMfe.dwGroup      = pInEntry->rgdwVarIndex[0];
            mimInMfe.dwSource     = pInEntry->rgdwVarIndex[1];

            //
            // NOTE: Change when doing source aggregation
            //

            mimInMfe.dwSrcMask = 0xFFFFFFFF;

            dwOutBufferSize = 
                (*pOutEntrySize < MAX_MIB_OFFSET)? 0 : (*pOutEntrySize - MAX_MIB_OFFSET);


            dwResult = MgmGetMfeStats(
                            &mimInMfe, &dwOutBufferSize, 
                            pOutEntry->rgbyData, dwStatsFlag
                            ); 

            if (dwResult == ERROR_INSUFFICIENT_BUFFER)
            {
                *pOutEntrySize = MAX_MIB_OFFSET + dwOutBufferSize;
            }
            
            break;
        }

        case ACCESS_GET_FIRST:
        {
            PMIB_MFE_STATS_TABLE  pMfeStatsTable;

            //
            // We always get chunks of 1KB
            //

            if (*pOutEntrySize < MIB_MFE_BUFFER_SIZE) 
            {
                *pOutEntrySize = MIB_MFE_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

            //
            // MGM wants a flat buffer for MFEs. We however return a 
            // MIB_MFE_TABLE to the user that starts (in the worst case) after
            // MAX_MIB_OFFSET bytes of the input buffer
            //

#define _MIN_SIZE  \
    (MAX_MIB_OFFSET + FIELD_OFFSET(MIB_MFE_STATS_TABLE,table[0]))

            dwOutBufferSize =  *pOutEntrySize - _MIN_SIZE;

#undef _MIN_SIZE

            pMfeStatsTable = (PMIB_MFE_STATS_TABLE)pOutEntry->rgbyData;

            pMfeStatsTable->dwNumEntries = 0;

            // pMfeStats = (PMIB_IPMCAST_MFE_STATS)(pMfeStatsTable->table);

            dwNumMfes = 0;

            dwResult = MgmGetFirstMfeStats(
                            &dwOutBufferSize, (PBYTE)pMfeStatsTable->table,
                            &dwNumMfes, dwStatsFlag
                            );
           
            //
            // We should NEVER get back ERROR_INSUFFICIENT_BUFFER
            //

            IpRtAssert(dwResult isnot ERROR_INSUFFICIENT_BUFFER);
 
            if((dwResult is ERROR_MORE_DATA) or
               (dwResult is ERROR_NO_MORE_ITEMS))
            {
                pMfeStatsTable->dwNumEntries = dwNumMfes;

                dwResult = NO_ERROR;
            }

            break;
        }

        case ACCESS_GET_NEXT:
        {
            PMIB_MFE_STATS_TABLE  pMfeStatsTable;

            //
            // For this, too we always get chunks of 1K pages
            //

            if (*pOutEntrySize < MIB_MFE_BUFFER_SIZE) 
            {
                *pOutEntrySize = MIB_MFE_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

#define _MIN_SIZE  \
    (MAX_MIB_OFFSET + FIELD_OFFSET(MIB_MFE_TABLE,table[0]))

            dwOutBufferSize =  *pOutEntrySize - _MIN_SIZE;

#undef _MIN_SIZE

            pMfeStatsTable = (PMIB_MFE_STATS_TABLE)pOutEntry->rgbyData;

            pMfeStatsTable->dwNumEntries = 0;

            //pMfeStats = (PIPMCAST_MFE_STATS)(pMfeStatsTable->table);

            dwNumMfes = 0;

            //
            // Set up the "first" mfe
            //

            ZeroMemory(&mimInMfe, sizeof(mimInMfe));

            //
            // NOTE: Change when doing source aggregation
            //

            mimInMfe.dwSrcMask = 0xFFFFFFFF;        

            switch(dwNumIndices)
            {
                case 0:
                {
                    break;
                }

                case 1:
                {
                    mimInMfe.dwGroup      = pInEntry->rgdwVarIndex[0];

                    break;
                }

                default:
                {
                    //
                    // 2 or more indices
                    //

                    mimInMfe.dwGroup      = pInEntry->rgdwVarIndex[0];
                    mimInMfe.dwSource     = pInEntry->rgdwVarIndex[1];

                    break;
                }
            }

            dwResult = MgmGetNextMfeStats(
                            &mimInMfe, &dwOutBufferSize,
                            (PBYTE)pMfeStatsTable->table, &dwNumMfes, 
                            dwStatsFlag
                            );

            //
            // We should NEVER get back ERROR_INSUFFICIENT_BUFFER
            //

            IpRtAssert(dwResult isnot ERROR_INSUFFICIENT_BUFFER);

            if((dwResult is ERROR_MORE_DATA) or
               (dwResult is ERROR_NO_MORE_ITEMS))
            {
                pMfeStatsTable->dwNumEntries = dwNumMfes;

                dwResult = NO_ERROR;
            }

            break;
        }
        
        case ACCESS_SET:
        {
            //
            // Validate the MFE size
            //

            if(dwInEntrySize < SIZEOF_BASIC_MFE)
            {
            }

            //dwResult = SetMfe(pMfe);
            
            break;
        }

        case ACCESS_DELETE_ENTRY:
        {
            
            break;
        }
        case ACCESS_CREATE_ENTRY:
        {
            // 
            // 
            // This is the case where you have tried to create a route which 
            // matches an existing entry
            //

            dwResult = ERROR_ALREADY_EXISTS;

            break;
        }
    }

#endif

    TraceLeave("AccessMcastMfeStatsInternal");
    return dwResult;
}

DWORD
AccessMcastIfStats(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++

Routine Description

    Retrieves the IP Multicast Interface table

Locks

    Takes ICB list lock as READER

Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IFTABLE)

Return Value

    None    

--*/
{
    PICB        picb;
    PMIB_IPMCAST_IF_ENTRY pIfRow;
    DWORD       dwNumIndices, dwResult;

    TraceEnter("AccessMcastIfTable");

    pIfRow = (PMIB_IPMCAST_IF_ENTRY)(pOutEntry->rgbyData);
    
    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPMCAST_IF_ENTRY))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPMCAST_IF_ENTRY);
        TraceLeave("AccessMcastIfTable");
        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPMCAST_IF_ENTRY);
        
    pOutEntry->dwId = MCAST_IF_ENTRY;
    
    do
    {
        if(dwQueryType is ACCESS_SET)
        {
            ENTER_WRITER(ICB_LIST);
        }
        else
        {
            ENTER_READER(ICB_LIST);
        }
        
        dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;
        
        dwResult = LocateIfRow(dwQueryType,
                               dwNumIndices,
                               pInEntry->rgdwVarIndex,
                               &picb,
                               FALSE);
        
        if(dwResult is NO_ERROR)
        {
            switch(dwQueryType)
            {
                case ACCESS_GET:
                case ACCESS_GET_NEXT:
                case ACCESS_GET_FIRST:
                {
                    dwResult = GetInterfaceMcastStatistics(picb,pIfRow);
                    
                    break;
                }
                
                case ACCESS_SET:
                {
                    dwResult = SetInterfaceMcastStatistics(picb,pIfRow);
                    
                    break;
                }
                
                default:
                {
                    Trace1(MIB,
                           "AccessIfRow: Wrong query type %d",dwQueryType);
                    
                    dwResult = ERROR_INVALID_PARAMETER;
                    
                    break;
                }
            }
        }
        
    }while(FALSE);

    EXIT_LOCK(ICB_LIST);
        
    *pbCache = TRUE;
    
    TraceLeave("AccessMcastIfTable");
    
    return dwResult;
}

DWORD
AccessMcastStats(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
/*++

Routine Description

    Retrieves the IP Multicast scalar information

Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IPMCAST_GLOBAL)

Return Value

    None    

--*/
{
    PMIB_IPMCAST_GLOBAL pMcastStats;
    DWORD           dwResult;
    
    TraceEnter("AccessMcastStats");

    if (dwQueryType isnot ACCESS_GET) {
        TraceLeave("AccessMcastStats");
        return ERROR_INVALID_PARAMETER;
    }

    pMcastStats = (PMIB_IPMCAST_GLOBAL)(pOutEntry->rgbyData);
    
    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPMCAST_GLOBAL))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPMCAST_GLOBAL);

        TraceLeave("AccessMcastStats");
        
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPMCAST_GLOBAL);
    
    pOutEntry->dwId = MCAST_GLOBAL;
    
    dwResult = NO_ERROR;

    // Retrieve statistics
    pMcastStats->dwEnable = (g_hMcastDevice isnot NULL)? 1 : 2;

    return dwResult;
}

DWORD
AccessMcastBoundary(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
/*++

Routine Description

    Retrieves multicast boundary information

Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IPMCAST_BOUNDARY)

Return Value

    None    

--*/
{
    DWORD            dwResult = NO_ERROR,dwNumIndices,dwIndex;
    DWORD            dwOutBufferSize, dwNumBoundaries;
    MIB_IPMCAST_BOUNDARY imInBoundary;

    TraceEnter("AccessMcastBoundary");

    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    switch(dwQueryType)
    {
        case ACCESS_GET:
        {
            //
            // The in index better be a good size
            // The user must specify IfIndex, Group, GrpMask.
            //

            if(dwNumIndices < 3)
            {
                TraceLeave("AccessMcastBoundary");

                return ERROR_INVALID_INDEX;
            }

            //
            // We always get chunks of 1KB
            //

            if (*pOutEntrySize < MIB_BOUNDARY_BUFFER_SIZE) 
            {
                *pOutEntrySize = MIB_BOUNDARY_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

            ZeroMemory(&imInBoundary, sizeof(imInBoundary));

            imInBoundary.dwIfIndex      = pInEntry->rgdwVarIndex[0];
            imInBoundary.dwGroupAddress = pInEntry->rgdwVarIndex[1];
            imInBoundary.dwGroupMask    = pInEntry->rgdwVarIndex[2];

            dwOutBufferSize = (*pOutEntrySize < MAX_MIB_OFFSET)
                ? 0 
                : (*pOutEntrySize - MAX_MIB_OFFSET);

            dwResult = RmGetBoundary(&imInBoundary,
                                 &dwOutBufferSize,
                                 pOutEntry->rgbyData);

            break;
        }

        case ACCESS_GET_FIRST:
        {
#ifdef USE_BOUNDARY_TABLE
            PMIB_IPMCAST_BOUNDARY_TABLE pBoundaryTable;
#endif
            PMIB_IPMCAST_BOUNDARY       pBoundary;

            //
            // We always get chunks of 1KB
            //

            if (*pOutEntrySize < MIB_BOUNDARY_BUFFER_SIZE) 
            {
                *pOutEntrySize = MIB_BOUNDARY_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

#ifdef USE_BOUNDARY_TABLE
            //
            // RM wants a flat buffer for boundaries. We however return a 
            // MIB_IPMCAST_BOUNDARY_TABLE to the user that starts (in the worst case) 
            // after MAX_MIB_OFFSET bytes of the input buffer
            //

#define _MIN_SIZE  \
    (MAX_MIB_OFFSET + FIELD_OFFSET(MIB_IPMCAST_BOUNDARY_TABLE,table[0]))

            dwOutBufferSize =  *pOutEntrySize - _MIN_SIZE;

#undef _MIN_SIZE

            pBoundaryTable = (PMIB_IPMCAST_BOUNDARY_TABLE)pOutEntry->rgbyData;

            pBoundaryTable->dwNumEntries = 0;

            pBoundary = (PMIB_IPMCAST_BOUNDARY)(pBoundaryTable->table);
#else
            pBoundary = (PMIB_IPMCAST_BOUNDARY)pOutEntry->rgbyData;

            dwOutBufferSize = (*pOutEntrySize < MAX_MIB_OFFSET)
                ? 0 
                : (*pOutEntrySize - MAX_MIB_OFFSET);
#endif

            dwNumBoundaries = 1; // get one

            dwResult = RmGetFirstBoundary(&dwOutBufferSize,
                                      (PBYTE)pBoundary,
                                      &dwNumBoundaries);

           
            //
            // We should NEVER get back ERROR_INSUFFICIENT_BUFFER
            //

            IpRtAssert(dwResult isnot ERROR_INSUFFICIENT_BUFFER);
 
#ifdef USE_BOUNDARY_TABLE
            if((dwResult is ERROR_MORE_DATA) or
               (dwResult is ERROR_NO_MORE_ITEMS))
            {
                pBoundaryTable->dwNumEntries = dwNumBoundaries;

                dwResult = NO_ERROR;
            }
#endif

            break;
        }

        case ACCESS_GET_NEXT:
        {
            PMIB_IPMCAST_BOUNDARY    pBoundary;
#ifdef USE_BOUNDARY_TABLE
            PMIB_IPMCAST_BOUNDARY_TABLE  pBoundaryTable;
#endif

            //
            // For this, too we always get chunks of 1K pages
            //

            if (*pOutEntrySize < MIB_BOUNDARY_BUFFER_SIZE) 
            {
                *pOutEntrySize = MIB_BOUNDARY_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

#ifdef USE_BOUNDARY_TABLE
#define _MIN_SIZE  \
    (MAX_MIB_OFFSET + FIELD_OFFSET(MIB_IPMCAST_BOUNDARY_TABLE,table[0]))

            dwOutBufferSize =  *pOutEntrySize - _MIN_SIZE;

#undef _MIN_SIZE

            pBoundaryTable = (PMIB_IPMCAST_BOUNDARY_TABLE)pOutEntry->rgbyData;

            pBoundaryTable->dwNumEntries = 0;

            pBoundary = (PMIB_IPMCAST_BOUNDARY)(pBoundaryTable->table);
#else
            pBoundary = (PMIB_IPMCAST_BOUNDARY)pOutEntry->rgbyData;

            dwOutBufferSize = (*pOutEntrySize < MAX_MIB_OFFSET)
                ? 0 
                : (*pOutEntrySize - MAX_MIB_OFFSET);
#endif

            dwNumBoundaries = 1; // get one

            //
            // Set up the "first" boundary
            //

            ZeroMemory(&imInBoundary, sizeof(imInBoundary));

            switch(dwNumIndices)
            {
                case 0:
                {
                    break;
                }

                case 1:
                {
                    imInBoundary.dwIfIndex = pInEntry->rgdwVarIndex[0];

                    break;
                }

                case 2:
                {
                    imInBoundary.dwIfIndex      = pInEntry->rgdwVarIndex[0];
                    imInBoundary.dwGroupAddress = pInEntry->rgdwVarIndex[1];

                    break;
                }

                default:
                {
                    //
                    // 3 or more indices
                    //

                    imInBoundary.dwIfIndex      = pInEntry->rgdwVarIndex[0];
                    imInBoundary.dwGroupAddress = pInEntry->rgdwVarIndex[1];
                    imInBoundary.dwGroupMask    = pInEntry->rgdwVarIndex[2];

                    break;
                }
            }

            dwResult = RmGetNextBoundary(&imInBoundary,
                                     &dwOutBufferSize,
                                     (PBYTE)pBoundary,
                                     &dwNumBoundaries);

            //
            // We should NEVER get back ERROR_INSUFFICIENT_BUFFER
            //

            IpRtAssert(dwResult isnot ERROR_INSUFFICIENT_BUFFER);

#ifdef USE_BOUNDARY_TABLE
            if((dwResult is ERROR_MORE_DATA) or
               (dwResult is ERROR_NO_MORE_ITEMS))
            {
                pBoundaryTable->dwNumEntries = dwNumBoundaries;

                dwResult = NO_ERROR;
            }
#endif

            break;
        }
        
        case ACCESS_SET:
        {
            PMIB_IPMCAST_BOUNDARY pBound;
            PICB picb;

            //
            // Validate the buffer size
            //

            if (*pOutEntrySize < sizeof(MIB_IPMCAST_BOUNDARY)) {
                return ERROR_INVALID_INDEX;
            }

            //
            // Make sure the ifIndex is a valid one
            //

            dwResult = LocateIfRow(dwQueryType,
                                   1,
                                   (PDWORD)pOutEntry->rgbyData,
                                   &picb,
                                   FALSE);

            if (dwResult isnot NO_ERROR)
                return dwResult;

            pBound = (PMIB_IPMCAST_BOUNDARY)(pOutEntry->rgbyData);
            if (pBound->dwStatus == ROWSTATUS_CREATEANDGO) {
               dwResult = SNMPAddBoundaryToInterface(pBound->dwIfIndex,
                pBound->dwGroupAddress, pBound->dwGroupMask);
            } else if (pBound->dwStatus == ROWSTATUS_DESTROY) {
               dwResult =SNMPDeleteBoundaryFromInterface(pBound->dwIfIndex,
                pBound->dwGroupAddress, pBound->dwGroupMask);
            } 

            break;
        }

        case ACCESS_DELETE_ENTRY:
        {
            break;
        }
        case ACCESS_CREATE_ENTRY:
        {
            // 
            // 
            // This is the case where you have tried to create a boundary which 
            // matches an existing entry
            //

            dwResult = ERROR_ALREADY_EXISTS;

            break;
        }

        default:
        {
            dwResult = ERROR_INVALID_PARAMETER;
            break;
        }
    }

    TraceLeave("AccessMcastBoundary");
    return dwResult;
}

DWORD
AccessMcastScope(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
/*++

Routine Description

    Retrieves multicast scope information

Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IPMCAST_SCOPE)

Return Value

    None    

--*/
{
    DWORD            dwResult = NO_ERROR,
                     dwNumIndices,dwIndex;
    DWORD            dwOutBufferSize, dwNumScopes;
    MIB_IPMCAST_SCOPE imInScope;

    TraceEnter("AccessMcastScope");

    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    switch(dwQueryType)
    {
        case ACCESS_GET:
        {
            //
            // The in index better be a good size
            // The user must specify Group, GrpMask.
            //

            if(dwNumIndices < 2)
            {
                TraceLeave("AccessMcastScope");

                return ERROR_INVALID_INDEX;
            }

            //
            // We always get chunks of 1KB
            //

            if (*pOutEntrySize < MIB_SCOPE_BUFFER_SIZE) 
            {
                *pOutEntrySize = MIB_SCOPE_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

            ZeroMemory(&imInScope, sizeof(imInScope));

            imInScope.dwGroupAddress = pInEntry->rgdwVarIndex[0];
            imInScope.dwGroupMask    = pInEntry->rgdwVarIndex[1];

            dwOutBufferSize = (*pOutEntrySize < MAX_MIB_OFFSET)
                ? 0 
                : (*pOutEntrySize - MAX_MIB_OFFSET);

            dwResult = RmGetScope(&imInScope,
                                  &dwOutBufferSize,
                                  pOutEntry->rgbyData);

            break;
        }

        case ACCESS_GET_FIRST:
        {
#ifdef USE_SCOPE_TABLE
            PMIB_IPMCAST_SCOPE_TABLE pScopeTable;
#endif
            PMIB_IPMCAST_SCOPE       pScope;

            //
            // We always get chunks of 1KB
            //

            if (*pOutEntrySize < MIB_SCOPE_BUFFER_SIZE) 
            {
                *pOutEntrySize = MIB_SCOPE_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

#ifdef USE_SCOPE_TABLE
            //
            // RM wants a flat buffer for scopes. We however return a 
            // MIB_IPMCAST_SCOPE_TABLE to the user that starts (in the worst case) 
            // after MAX_MIB_OFFSET bytes of the input buffer
            //

#define _MIN_SIZE  \
    (MAX_MIB_OFFSET + FIELD_OFFSET(MIB_IPMCAST_SCOPE_TABLE,table[0]))

            dwOutBufferSize =  *pOutEntrySize - _MIN_SIZE;

#undef _MIN_SIZE

            pScopeTable = (PMIB_IPMCAST_SCOPE_TABLE)pOutEntry->rgbyData;

            pScopeTable->dwNumEntries = 0;

            pScope = (PMIB_IPMCAST_SCOPE)(pScopeTable->table);
#else
            pScope = (PMIB_IPMCAST_SCOPE)pOutEntry->rgbyData;

            dwOutBufferSize = (*pOutEntrySize < MAX_MIB_OFFSET)
                ? 0 
                : (*pOutEntrySize - MAX_MIB_OFFSET);
#endif

            dwNumScopes = 1; // get one

            dwResult = RmGetFirstScope(&dwOutBufferSize,
                                      (PBYTE)pScope,
                                      &dwNumScopes);

           
            //
            // We should NEVER get back ERROR_INSUFFICIENT_BUFFER
            //

            IpRtAssert(dwResult isnot ERROR_INSUFFICIENT_BUFFER);
 
#ifdef USE_SCOPE_TABLE
            if((dwResult is ERROR_MORE_DATA) or
               (dwResult is ERROR_NO_MORE_ITEMS))
            {
                pScopeTable->dwNumEntries = dwNumScopes;

                dwResult = NO_ERROR;
            }
#endif

            break;
        }

        case ACCESS_GET_NEXT:
        {
            PMIB_IPMCAST_SCOPE    pScope;
#ifdef USE_SCOPE_TABLE
            PMIB_IPMCAST_SCOPE_TABLE  pScopeTable;
#endif

            //
            // For this, too we always get chunks of 1K pages
            //

            if (*pOutEntrySize < MIB_SCOPE_BUFFER_SIZE) 
            {
                *pOutEntrySize = MIB_SCOPE_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

#ifdef USE_SCOPE_TABLE
#define _MIN_SIZE  \
    (MAX_MIB_OFFSET + FIELD_OFFSET(MIB_IPMCAST_SCOPE_TABLE,table[0]))

            dwOutBufferSize =  *pOutEntrySize - _MIN_SIZE;

#undef _MIN_SIZE

            pScopeTable = (PMIB_IPMCAST_Scope_TABLE)pOutEntry->rgbyData;

            pScopeTable->dwNumEntries = 0;

            pScope = (PMIB_IPMCAST_SCOPE)(pScopeTable->table);
#else
            pScope = (PMIB_IPMCAST_SCOPE)pOutEntry->rgbyData;

            dwOutBufferSize = (*pOutEntrySize < MAX_MIB_OFFSET)
                ? 0 
                : (*pOutEntrySize - MAX_MIB_OFFSET);
#endif

            dwNumScopes = 1; // get one

            //
            // Set up the "first" scope
            //

            ZeroMemory(&imInScope, sizeof(imInScope));

            switch(dwNumIndices)
            {
                case 0:
                {
                    break;
                }

                case 1:
                {
                    imInScope.dwGroupAddress = pInEntry->rgdwVarIndex[0];

                    break;
                }

                default:
                {
                    //
                    // 2 or more indices
                    //

                    imInScope.dwGroupAddress = pInEntry->rgdwVarIndex[0];
                    imInScope.dwGroupMask    = pInEntry->rgdwVarIndex[1];

                    break;
                }
            }

            dwResult = RmGetNextScope(&imInScope,
                                      &dwOutBufferSize,
                                      (PBYTE)pScope,
                                      &dwNumScopes);

            //
            // We should NEVER get back ERROR_INSUFFICIENT_BUFFER
            //

            IpRtAssert(dwResult isnot ERROR_INSUFFICIENT_BUFFER);

#ifdef USE_SCOPE_TABLE
            if((dwResult is ERROR_MORE_DATA) or
               (dwResult is ERROR_NO_MORE_ITEMS))
            {
                pScopeTable->dwNumEntries = dwNumScopes;

                dwResult = NO_ERROR;
            }
#endif

            break;
        }
        
        case ACCESS_SET:
        {
            PMIB_IPMCAST_SCOPE pScope;

            //
            // Validate the buffer size
            //

            if (*pOutEntrySize < sizeof(MIB_IPMCAST_SCOPE)) {
                return ERROR_INVALID_INDEX;
            }

            pScope = (PMIB_IPMCAST_SCOPE)(pOutEntry->rgbyData);
            if ( !pScope->dwStatus )
            {
               dwResult = SNMPSetScope( pScope->dwGroupAddress, 
                                        pScope->dwGroupMask,
                                        pScope->snNameBuffer 
                                      );
            } else if (pScope->dwStatus == ROWSTATUS_CREATEANDGO) 
            {
               PSCOPE_ENTRY pNew;

               dwResult = SNMPAddScope( pScope->dwGroupAddress, 
                                        pScope->dwGroupMask,
                                        pScope->snNameBuffer,
                                        &pNew
                                      );
            } 
            else if (pScope->dwStatus == ROWSTATUS_DESTROY) 
            {
               dwResult = SNMPDeleteScope( pScope->dwGroupAddress, 
                                           pScope->dwGroupMask
                                         );
            }
            else
            {
                return ERROR_INVALID_PARAMETER;
            }

            break;
        }

        case ACCESS_DELETE_ENTRY:
        {
            
            break;
        }
        case ACCESS_CREATE_ENTRY:
        {
            // 
            // 
            // This is the case where you have tried to create a scope which 
            // matches an existing entry
            //

            dwResult = ERROR_ALREADY_EXISTS;

            break;
        }
    }

    TraceLeave("AccessMcastScope");
    return dwResult;
}


DWORD
AccessBestIf(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++

Routine Description

    This function services the BEST_IF var id

Locks

    Takes the ICB_LIST as READER to map from adapter to interface index

Arguments

    dwQueryType     Can only be ACCESS_GET
    pInEntry        Destination address filled in the rgdwVarIndex field.
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_BEST_IF)

Return Value

    None

--*/

{
    DWORD   dwNumIndices, dwResult;
    DWORD   dwIfIndex;
    PICB    pIcb;

    PMIB_BEST_IF  pBestIf;

    TraceEnter("AccessBestIf");
    
    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_BEST_IF))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_BEST_IF);

        TraceLeave("AccessBestIf");

        return ERROR_INSUFFICIENT_BUFFER;
    }


    if((dwNumIndices < 1) or
       (dwQueryType isnot ACCESS_GET))
    {
        TraceLeave("AccessBestIf");
        
        return ERROR_INVALID_PARAMETER;
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_BEST_IF);
        
    dwResult = GetBestInterfaceFromStack(pInEntry->rgdwVarIndex[0],
                                         &dwIfIndex);

    if(dwResult is NO_ERROR)
    {

#if DBG
       
        ENTER_READER(ICB_LIST);

        pIcb = InterfaceLookupByIfIndex(dwIfIndex);
 
        if(pIcb is NULL)
        {
            Trace2(ERR,
                   "AccessBestIf: Couldnt find i/f for Index %d for dest %d.%d.%d.%d\n",
                   dwIfIndex,
                   PRINT_IPADDR(pInEntry->rgdwVarIndex[0]));

        }

        EXIT_LOCK(ICB_LIST);

#endif

        pBestIf = (PMIB_BEST_IF)(pOutEntry->rgbyData);

        pOutEntry->dwId = BEST_IF;

        pBestIf->dwDestAddr = pInEntry->rgdwVarIndex[0];
        pBestIf->dwIfIndex  = dwIfIndex;

    }

    TraceLeave("AccessBestIf");
        
    return dwResult;
}

DWORD
AccessBestRoute(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++

Routine Description

    This function services the BEST_IF var id

Locks

    Takes the ICB_LIST as READER to map from adapter to interface index

Arguments

    dwQueryType     Can only be ACCESS_GET
    pInEntry        Destination address filled in the rgdwVarIndex field.
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_BEST_IF)

Return Value

    None

--*/

{
    DWORD             dwNumIndices, dwResult;
    PICB              pIcb;
    RTM_NET_ADDRESS   rnaDest;
    RTM_DEST_INFO     rdiInfo;
    PRTM_ROUTE_INFO   prriInfo;
    RTM_NEXTHOP_INFO  rniInfo;
    RTM_ENTITY_INFO   reiInfo;
    PINTERFACE_ROUTE_INFO pRoute;

    TraceEnter("AccessBestRoute");
    
    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(INTERFACE_ROUTE_INFO))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(INTERFACE_ROUTE_INFO);

        TraceLeave("AccessBestRoute");

        return ERROR_INSUFFICIENT_BUFFER;
    }


    if((dwNumIndices < 2) or
       (dwQueryType isnot ACCESS_GET))
    {
        TraceLeave("AccessBestRoute");
        
        return ERROR_INVALID_PARAMETER;
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(INTERFACE_ROUTE_INFO);

    pRoute = (PINTERFACE_ROUTE_INFO)(pOutEntry->rgbyData);

    // Get the best route from RTM instead of the stack (chaitk)

    // dwResult = GetBestRouteFromStack(pInEntry->rgdwVarIndex[0],
    //                                  pInEntry->rgdwVarIndex[0],
    //                                  pRoute);

    RTM_IPV4_MAKE_NET_ADDRESS(&rnaDest, pInEntry->rgdwVarIndex[0], 32);

    dwResult = RtmGetMostSpecificDestination(g_hLocalRoute,
                                             &rnaDest,
                                             RTM_BEST_PROTOCOL,
                                             RTM_VIEW_MASK_UCAST,
                                             &rdiInfo);

    if(dwResult is NO_ERROR)
    {
        ASSERT(rdiInfo.ViewInfo[0].ViewId is RTM_VIEW_ID_UCAST);

        prriInfo = HeapAlloc(
                    IPRouterHeap,
                    0,
                    RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                    );

        if ( prriInfo != NULL)
        {
            dwResult = RtmGetRouteInfo(g_hLocalRoute,
                                       rdiInfo.ViewInfo[0].Route,
                                       prriInfo,
                                       NULL);

            if (dwResult is NO_ERROR)
            {
                dwResult = RtmGetEntityInfo(g_hLocalRoute,
                                            prriInfo->RouteOwner,
                                            &reiInfo);

                if (dwResult is NO_ERROR)
                {
                    // We are working on the first nexthop only
                    
                    ASSERT(prriInfo->NextHopsList.NumNextHops > 0);
                    
                    dwResult = RtmGetNextHopInfo(g_hLocalRoute,
                                                 prriInfo->NextHopsList.NextHops[0],
                                                 &rniInfo);

                    if (dwResult is NO_ERROR)
                    {
                        ConvertRtmToRouteInfo(reiInfo.EntityId.EntityProtocolId,
                                                 &rdiInfo.DestAddress,
                                                 prriInfo,
                                                 &rniInfo,
                                                 pRoute);

                        RtmReleaseNextHopInfo(g_hLocalRoute, &rniInfo);
                    }
                }

                RtmReleaseRouteInfo(g_hLocalRoute, prriInfo);
            }

            HeapFree(IPRouterHeap, 0, prriInfo);
        }

        else
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
        }
        
        RtmReleaseDestInfo(g_hLocalRoute, &rdiInfo);
    }

    if(dwResult is NO_ERROR)
    {

#if DBG

        ENTER_READER(ICB_LIST);

        pIcb = InterfaceLookupByIfIndex(pRoute->dwRtInfoIfIndex);

        if(pIcb is NULL)
        {
            Trace2(ERR,
                   "AccessBestRoute: Couldnt find i/f for index %d for dest %d.%d.%d.%d\n",
                   pRoute->dwRtInfoIfIndex,
                   PRINT_IPADDR(pInEntry->rgdwVarIndex[0]));
        }

        EXIT_LOCK(ICB_LIST);

#endif // DBG

        //
        // Not need to map since the indices are the same
        //

        // pRoute->dwRtInfoIfIndex = dwIfIndex;
    }

    TraceLeave("AccessBestRoute");
        
    return dwResult;
}

DWORD
AccessProxyArp(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++

Routine Description

    This function services the PROXY_ARP id

Locks

    Takes the ICB_LIST as READER to map from interface to adapter index

Arguments

    dwQueryType     Can only be ACCESS_CREATE_ENTRY or ACCESS_DELETE_ENTRY
    pInEntry        Destination address filled in the rgdwVarIndex field.
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_BEST_IF)

Return Value

    None

--*/
{
    MIB_PROXYARP    mpEntry;
    PMIB_PROXYARP   pProxyEntry;
    PADAPTER_INFO   pBinding;
    BOOL            bAdd;
    DWORD           dwResult;
    
    TraceEnter("AccessProxyArp");


    if(dwQueryType is ACCESS_DELETE_ENTRY)
    {
        mpEntry.dwAddress  = pInEntry->rgdwVarIndex[0];
        mpEntry.dwMask     = pInEntry->rgdwVarIndex[1];
        mpEntry.dwIfIndex  = pInEntry->rgdwVarIndex[2];

        pProxyEntry = &mpEntry;

        bAdd = FALSE;
    }
    else
    {
        if(dwQueryType is ACCESS_CREATE_ENTRY)
        {
            if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_PROXYARP))
            {
                *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_PROXYARP);

                TraceLeave("AccessProxyArp");
        
                return ERROR_INSUFFICIENT_BUFFER;
            }

            pProxyEntry = (PMIB_PROXYARP)(pOutEntry->rgbyData);
            
            bAdd = TRUE;

            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_PROXYARP);
    
            pOutEntry->dwId = PROXY_ARP;
        }
        else
        {
            TraceLeave("AccessProxyArp");
        
            return ERROR_INVALID_PARAMETER;
        }
    }

    ENTER_READER(BINDING_LIST);

    pBinding = GetInterfaceBinding(pProxyEntry->dwIfIndex);
    
    if(pBinding is NULL)
    {
        Trace1(ERR,
               "AccessProxyArp: Cant find binding for i/f %d",
               pProxyEntry->dwIfIndex);

        EXIT_LOCK(BINDING_LIST);

        TraceLeave("AccessProxyArp");
        
        return ERROR_INVALID_INDEX;
    }

    if(!pBinding->bBound)
    {
        Trace1(ERR,
               "AccessProxyArp: I/f %d is not bound",
               pProxyEntry->dwIfIndex);
        
        EXIT_LOCK(BINDING_LIST);
        
        TraceLeave("AccessProxyArp");
        
        return ERROR_NOT_READY;
    }

    EXIT_LOCK(BINDING_LIST);

    dwResult = SetProxyArpEntryToStack(pProxyEntry->dwAddress,
                                       pProxyEntry->dwMask,
                                       pProxyEntry->dwIfIndex,
                                       bAdd,
                                       TRUE);

    TraceLeave("AccessProxyArp");

    return dwResult;
}

DWORD
AccessIfStatus(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++

Routine Description

    This function services the BEST_IF var id

Locks

    Takes the ICB_LIST as READER to map from adapter to interface index

Arguments

    dwQueryType     Can be ACCESS_GET, ACCESS_GET_FIRST or ACCESS_GET_NEXT
    pInEntry        Destination address filled in the rgdwVarIndex field.
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_BEST_IF)

Return Value

    None

--*/

{
    DWORD   dwNumIndices, dwResult;
    DWORD   dwIfIndex;
    PICB    picb;
    
    PMIB_IFSTATUS   pIfStatus;
    SYSTEMTIME      stSysTime;
    ULARGE_INTEGER  uliTime;

    
    TraceEnter("AccessIfStatus");

    if(dwQueryType > ACCESS_GET_NEXT)
    {
        TraceLeave("AccessIfStatus");
        
        return ERROR_INVALID_PARAMETER;
    }
    
    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IFSTATUS))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IFSTATUS);

        TraceLeave("AccessIfStatus");

        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IFSTATUS);

    pIfStatus = (PMIB_IFSTATUS)(pOutEntry->rgbyData);

    ENTER_READER(ICB_LIST);

    dwResult = LocateIfRow(dwQueryType,
                           dwNumIndices,
                           pInEntry->rgdwVarIndex,
                           &picb,
                           FALSE);


    if(dwResult is NO_ERROR)
    {
        pIfStatus->dwIfIndex            = picb->dwIfIndex;
        pIfStatus->dwAdminStatus        = picb->dwAdminState;
        pIfStatus->dwOperationalStatus  = picb->dwOperationalState;
        
        pIfStatus->bMHbeatActive    = picb->mhcHeartbeatInfo.bActive;

        
        if(pIfStatus->bMHbeatActive)
        {
               GetSystemTime(&stSysTime);

               SystemTimeToFileTime(&stSysTime,
                                    (PFILETIME)&uliTime);

               //
               // Its alive if the currenttime - lastheard < deadinterval
               //
               
               pIfStatus->bMHbeatAlive =
                   (uliTime.QuadPart - picb->mhcHeartbeatInfo.ullLastHeard < picb->mhcHeartbeatInfo.ullDeadInterval);
        }

        EXIT_LOCK(ICB_LIST);
    }

    TraceLeave("AccessIfStatus");
        
    return dwResult;
}


DWORD
AccessSetRouteState(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++

Routine Description

    This function services ROUTE_STATE id

Locks

    Takes the g_csFwdState lock

Arguments

    dwQueryType     Can be ACCESS_GET only
    pInEntry        Destination address filled in the rgdwVarIndex field.
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_ROUTESTATE)

Return Value

    None

--*/

{
    DWORD   dwResult;
    
    PMIB_ROUTESTATE pState;
    
    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessSetRouteState");
        
        return ERROR_INVALID_PARAMETER;
    }
    
    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_ROUTESTATE))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_ROUTESTATE);

        TraceLeave("AccessSetRouteState");

        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_ROUTESTATE);

    pOutEntry->dwId = ROUTE_STATE;
    
    pState = (PMIB_ROUTESTATE)(pOutEntry->rgbyData);

    EnterCriticalSection(&g_csFwdState);

    pState->bRoutesSetToStack = g_bSetRoutesToStack;

    LeaveCriticalSection(&g_csFwdState);
    
    TraceLeave("AccessSetRouteState");
    
    return NO_ERROR;
}

DWORD
AddDestinationRows( 
    IN  PRTM_DEST_INFO      pRdi,
    IN  RTM_VIEW_SET        dwViews,
    OUT DWORD              *pdwCount,
    IN  DWORD               dwSpaceCount,
    OUT PMIB_IPDESTTABLE    pDestTable 
    )
{
    DWORD               dwFinalResult, dwResult, i, j, k;
    PRTM_ROUTE_INFO     pri;
    RTM_NEXTHOP_INFO    nhi;
    PMIB_IPDESTROW      pRow;

    pri = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                );

    if ( pri == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // XXX how do I walk all next hops which get added to the stack???
    // For now, let's assume only one route per view.

    dwFinalResult = NO_ERROR;

    for (i = 0; i < pRdi->NumberOfViews; i++)
    {
        if (pRdi->ViewInfo[i].Route == NULL)
        {
            continue;
        }

        // Skip if we have seen this route already

        for (k = 0; k < i; k++)
        {
            if (pRdi->ViewInfo[k].Route == pRdi->ViewInfo[i].Route)
            {
                break;
            }
        }

        if (k < i)
        {
            continue;
        }

        dwResult = RtmGetRouteInfo( g_hLocalRoute,
                                    pRdi->ViewInfo[i].Route,
                                    pri,
                                    NULL );
        
        if (dwResult isnot NO_ERROR)
        {
            dwFinalResult = dwResult;
            continue;
        }

        *pdwCount += pri->NextHopsList.NumNextHops;

        if (dwSpaceCount >= *pdwCount)
        {
            ULARGE_INTEGER      now, then;
            ULONG               age;
            RTM_ENTITY_INFO     rei;

            RtmGetEntityInfo( g_hLocalRoute,
                              pri->RouteOwner,
                              &rei );

            GetSystemTimeAsFileTime( (LPFILETIME)&now );

            //
            // Explicit copy reqd as '&pRdi->LastChanged' 
            // might not be 64-bit aligned (its FILETIME)
            //
            (*(FILETIME *)&then) = *(&pRdi->LastChanged);

            age = (ULONG)((now.QuadPart - then.QuadPart) / 10000000);
    
            for (j=0; j<pri->NextHopsList.NumNextHops; j++)
            {
                if (RtmGetNextHopInfo( g_hLocalRoute,
                                       pri->NextHopsList.NextHops[j],
                                       &nhi )  is NO_ERROR )
                {
                    pRow = &pDestTable->table[pDestTable->dwNumEntries++];

                    RTM_IPV4_GET_ADDR_AND_MASK( pRow->dwForwardDest,
                                                pRow->dwForwardMask,
                                                (&pRdi->DestAddress) );

                    pRow->dwForwardPolicy = 0;
                    pRow->dwForwardNextHop 
                        = *((ULONG*)nhi.NextHopAddress.AddrBits);

                    pRow->dwForwardIfIndex  = nhi.InterfaceIndex;
                    pRow->dwForwardType  
                        = (pri->RouteOwner == g_hLocalRoute)?3:4;

                    pRow->dwForwardProto 
                        = PROTO_FROM_PROTO_ID(rei.EntityId.EntityProtocolId);

                    pRow->dwForwardAge = age;

                    pRow->dwForwardNextHopAS= 0; // XXX
                    pRow->dwForwardPreference = pri->PrefInfo.Preference;
                    pRow->dwForwardMetric1  = pri->PrefInfo.Metric;
                    pRow->dwForwardMetric2  = 0;
                    pRow->dwForwardMetric3  = 0;
                    pRow->dwForwardMetric4  = 0;
                    pRow->dwForwardMetric5  = 0;

                    pRow->dwForwardViewSet  = pri->BelongsToViews;

                    RtmReleaseNextHopInfo( g_hLocalRoute, &nhi );
                }
            }
        }

        RtmReleaseRouteInfo( g_hLocalRoute, pri );
    }

    HeapFree(IPRouterHeap, 0, pri);
    
    return dwFinalResult;
}

DWORD 
AccessDestMatching(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++

Routine Description

    Retrieves all destinations matching a given criteria

Locks

    XXX

Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IPDESTTABLE)

Return Value

    NO_ERROR

--*/

{
    PMIB_IPDESTTABLE    pDestTable;
    DWORD               count, i;
    DWORD               dwNumDests, dwResult, dwNumIndices, dwSpaceCount;
    RTM_NET_ADDRESS     naDest;
    DWORD               dwOffset = MAX_MIB_OFFSET + sizeof(DWORD);
    PRTM_DEST_INFO      prdi;
   
    TraceEnter("AccessDestMatching");

    count = dwSpaceCount = 0;

    pDestTable = NULL;

    if (*pOutEntrySize > dwOffset)
    {
        dwSpaceCount = (*pOutEntrySize - dwOffset) 
                         / sizeof(MIB_IPDESTROW);

        pDestTable = (PMIB_IPDESTTABLE)(pOutEntry->rgbyData);

        pDestTable->dwNumEntries = 0;
    }

    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    if ((dwNumIndices < 4) or
        (dwQueryType isnot ACCESS_GET))
    {
        TraceLeave("AccessDestMatching");
        
        return ERROR_INVALID_PARAMETER;
    }

    RTM_IPV4_SET_ADDR_AND_MASK(&naDest,
                               pInEntry->rgdwVarIndex[0],  // Addr
                               pInEntry->rgdwVarIndex[1]); // Mask
    prdi = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
                );

    if (prdi != NULL)
    {
        dwResult = RtmGetExactMatchDestination( g_hLocalRoute,
                                                &naDest,
                                                pInEntry->rgdwVarIndex[3], // Proto
                                                pInEntry->rgdwVarIndex[2], // Views
                                                prdi );
        if (dwResult is ERROR_NOT_FOUND)
        {
            dwResult = NO_ERROR;
        }
        else
        if (dwResult is NO_ERROR)
        {
            AddDestinationRows( prdi,
                                pInEntry->rgdwVarIndex[2],
                                &count,
                                dwSpaceCount,
                                pDestTable );

            RtmReleaseDestInfo( g_hLocalRoute, prdi );
        }

        *pOutEntrySize = dwOffset + count * sizeof(MIB_IPDESTROW);

        if (dwSpaceCount < count)
        {
            dwResult = ERROR_INSUFFICIENT_BUFFER;
        }

        HeapFree(IPRouterHeap, 0, prdi);
    }

    else
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    TraceLeave("AccessDestMatching");

    return dwResult;
}

DWORD
AccessDestShorter(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
{
    PMIB_IPDESTTABLE    pDestTable;
    DWORD               count, i;
    DWORD               dwNumDests, dwResult, dwNumIndices, dwSpaceCount;
    RTM_NET_ADDRESS     naDest;
    DWORD               dwOffset = MAX_MIB_OFFSET + sizeof(DWORD);
    PRTM_DEST_INFO      prdi1, prdi2;
   
    TraceEnter("AccessDestShorter");

    count = dwSpaceCount = 0;

    pDestTable = NULL;

    if (*pOutEntrySize > dwOffset)
    {
        dwSpaceCount = (*pOutEntrySize - dwOffset) 
                         / sizeof(MIB_IPDESTROW);

        pDestTable = (PMIB_IPDESTTABLE)(pOutEntry->rgbyData);

        pDestTable->dwNumEntries = 0;
    }

    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    if ((dwNumIndices < 4) or
        (dwQueryType isnot ACCESS_GET))
    {
        TraceLeave("AccessDestShorter");
        
        return ERROR_INVALID_PARAMETER;
    }

    prdi1 = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
                );

    if ( prdi1 == NULL)
    {
        TraceLeave("AccessDestShorter");

        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    prdi2 = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
                );

    if ( prdi2 == NULL)
    {
        TraceLeave("AccessDestShorter");

        HeapFree(IPRouterHeap, 0, prdi1);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RTM_IPV4_SET_ADDR_AND_MASK(&naDest,
                               pInEntry->rgdwVarIndex[0],  // Addr
                               pInEntry->rgdwVarIndex[1]); // Mask

    dwResult = RtmGetMostSpecificDestination( g_hLocalRoute,
                                              &naDest,
                                              pInEntry->rgdwVarIndex[3],//Proto
                                              pInEntry->rgdwVarIndex[2],//Views
                                              prdi1 );
    while (dwResult is NO_ERROR)
    {
        AddDestinationRows( prdi1,
                            pInEntry->rgdwVarIndex[2],
                            &count,
                            dwSpaceCount,
                            pDestTable );

        dwResult = RtmGetLessSpecificDestination( g_hLocalRoute,
                                                  prdi1->DestHandle,
                                                  pInEntry->rgdwVarIndex[3],
                                                  pInEntry->rgdwVarIndex[2],
                                                  prdi2);

        RtmReleaseDestInfo( g_hLocalRoute, prdi1 );

        if (dwResult != NO_ERROR)
        {
            break;
        }

        AddDestinationRows( prdi2,
                            pInEntry->rgdwVarIndex[2],
                            &count,
                            dwSpaceCount,
                            pDestTable );

        dwResult = RtmGetLessSpecificDestination( g_hLocalRoute,
                                                  prdi2->DestHandle,
                                                  pInEntry->rgdwVarIndex[3],
                                                  pInEntry->rgdwVarIndex[2],
                                                  prdi1);

        RtmReleaseDestInfo( g_hLocalRoute, prdi2 );

        if (dwResult != NO_ERROR)
        {
            break;
        }
    }

    if (dwResult is ERROR_NOT_FOUND)
    {
        dwResult = NO_ERROR;
    }

    *pOutEntrySize = dwOffset + count * sizeof(MIB_IPDESTROW);

    if (dwSpaceCount < count)
    {
        dwResult = ERROR_INSUFFICIENT_BUFFER;
    }

    HeapFree(IPRouterHeap, 0, prdi1);
    
    HeapFree(IPRouterHeap, 0, prdi2);
    
    TraceLeave("AccessDestShorter");

    return dwResult;
}

DWORD
AccessDestLonger(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
{
    PMIB_IPDESTTABLE    pDestTable;
    DWORD               count, i;
    DWORD               dwNumDests, dwResult, dwNumIndices, dwSpaceCount;
    DWORD               dwViews;
    RTM_NET_ADDRESS     naDest;
    ULONG               ulNumViews, ulNumInfos, ulDestInfoSize;
    RTM_DEST_HANDLE     hDest;
    RTM_ENUM_HANDLE     hEnum;
    PRTM_DEST_INFO      pDestInfos, pRdi;
    DWORD               dwOffset = MAX_MIB_OFFSET + sizeof(DWORD);
   
    TraceEnter("AccessDestLonger");

    count = dwSpaceCount = 0;

    pDestTable = NULL;

    if (*pOutEntrySize > dwOffset)
    {
        dwSpaceCount = (*pOutEntrySize - dwOffset) 
                         / sizeof(MIB_IPDESTROW);

        pDestTable = (PMIB_IPDESTTABLE)(pOutEntry->rgbyData);

        pDestTable->dwNumEntries = 0;
    }

    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    if ((dwNumIndices < 4) or
        (dwQueryType isnot ACCESS_GET))
    {
        TraceLeave("AccessDestLonger");
        
        return ERROR_INVALID_PARAMETER;
    }

    RTM_IPV4_SET_ADDR_AND_MASK(&naDest,
                               pInEntry->rgdwVarIndex[0],  // Addr
                               pInEntry->rgdwVarIndex[1]); // Mask

    dwResult = RtmCreateDestEnum( g_hLocalRoute,
                                  pInEntry->rgdwVarIndex[2], // Views
                                  RTM_ENUM_RANGE,
                                  &naDest,
                                  pInEntry->rgdwVarIndex[3], // Proto
                                  &hEnum );

    if (dwResult is NO_ERROR)
    {
        //
        // Count the number of views as we have list of dests in buffer
        //

        dwViews = pInEntry->rgdwVarIndex[2];
        ulNumViews = 0;
        while (dwViews)
        {
            dwViews &= (dwViews - 1);
            ulNumViews++;
        }

        ulDestInfoSize = RTM_SIZE_OF_DEST_INFO(ulNumViews);

        pDestInfos = (PRTM_DEST_INFO) HeapAlloc(
                        IPRouterHeap,
                        0,
                        ulDestInfoSize * 
                            g_rtmProfile.MaxHandlesInEnum
                        );

        if ( pDestInfos != NULL)
        {
            do 
            {
                ulNumInfos = g_rtmProfile.MaxHandlesInEnum;

                dwResult = RtmGetEnumDests( g_hLocalRoute,
                                            hEnum,
                                            &ulNumInfos,
                                            pDestInfos );

                for (i=0; i<ulNumInfos; i++)
                {
                    pRdi=(PRTM_DEST_INFO)(((PUCHAR)pDestInfos)+(i*ulDestInfoSize));

                    AddDestinationRows( pRdi,
                                        pInEntry->rgdwVarIndex[2],
                                        &count,
                                        dwSpaceCount,
                                        pDestTable );
                }

                RtmReleaseDests( g_hLocalRoute,
                                 ulNumInfos,
                                 pDestInfos );

            } while (dwResult is NO_ERROR);

            HeapFree(IPRouterHeap, 0, pDestInfos);
        }

        else
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
        }
        
        RtmDeleteEnumHandle( g_hLocalRoute, hEnum );
    }

    if (dwResult is ERROR_NO_MORE_ITEMS)
    {
        dwResult = NO_ERROR;
    }

    *pOutEntrySize = dwOffset + count * sizeof(MIB_IPDESTROW);

    if (dwSpaceCount < count)
    {
        dwResult = ERROR_INSUFFICIENT_BUFFER;
    }

    TraceLeave("AccessDestLonger");

    return dwResult;
}

DWORD
AddRouteRows( 
    IN  PRTM_ROUTE_HANDLE   hRoute,
    IN  DWORD               dwProtocolId,
    OUT DWORD              *pdwCount,
    IN  DWORD               dwSpaceCount,
    OUT PMIB_IPDESTTABLE    pRouteTable 
    )
{
    DWORD               dwResult, dwRouteProto, j;
    PRTM_ROUTE_INFO     pri;
    RTM_NEXTHOP_INFO    nhi;
    PMIB_IPDESTROW      pRow;
    RTM_NET_ADDRESS     naDest;
    RTM_ENTITY_INFO     rei;

    pri = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                );

    if ( pri == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwResult = RtmGetRouteInfo( g_hLocalRoute,
                                hRoute,
                                pri,
                                &naDest );

    if (dwResult is NO_ERROR)
    {
        RtmGetEntityInfo( g_hLocalRoute,
                          pri->RouteOwner,
                          &rei );

        dwRouteProto = PROTO_FROM_PROTO_ID(rei.EntityId.EntityProtocolId);

        if ((dwProtocolId is 0) 
         || (dwRouteProto is dwProtocolId))
        {
            *pdwCount += pri->NextHopsList.NumNextHops;

            if (dwSpaceCount >= *pdwCount)
            {
                for (j=0; j<pri->NextHopsList.NumNextHops; j++)
                {
                    if (RtmGetNextHopInfo( g_hLocalRoute,
                                           pri->NextHopsList.NextHops[j],
                                           &nhi )  is NO_ERROR )
                    {
                        pRow= &pRouteTable->table[pRouteTable->dwNumEntries++];
    
                        RTM_IPV4_GET_ADDR_AND_MASK( pRow->dwForwardDest,
                                                    pRow->dwForwardMask,
                                                    &naDest );
    
                        pRow->dwForwardPolicy   = 0;
                        pRow->dwForwardNextHop  
                            = *((ULONG*)nhi.NextHopAddress.AddrBits);

                        pRow->dwForwardIfIndex  = nhi.InterfaceIndex;
                        pRow->dwForwardType     
                            = (pri->RouteOwner == g_hLocalRoute)?3:4;

                        pRow->dwForwardProto    = dwRouteProto;
                        pRow->dwForwardAge      = 0;
                        pRow->dwForwardNextHopAS= 0; // XXX
                        pRow->dwForwardPreference = pri->PrefInfo.Preference;
                        pRow->dwForwardMetric1  = pri->PrefInfo.Metric;
                        pRow->dwForwardMetric2  = 0;
                        pRow->dwForwardMetric3  = 0;
                        pRow->dwForwardMetric4  = 0;
                        pRow->dwForwardMetric5  = 0;
                        pRow->dwForwardViewSet  = pri->BelongsToViews;

                        RtmReleaseNextHopInfo( g_hLocalRoute, &nhi );
                    }
                }
            }
        }

        RtmReleaseRouteInfo( g_hLocalRoute, pri );
    }

    HeapFree(IPRouterHeap, 0, pri);
    
    return dwResult;
}

DWORD
AddRouteRowsOnDest( 
    IN  PRTM_DEST_INFO      prdi,
    IN  PMIB_OPAQUE_QUERY   pInEntry, 
    OUT DWORD              *pdwCount,
    IN  DWORD               dwSpaceCount,
    OUT PMIB_IPDESTTABLE    pRouteTable 
    )
{
    DWORD               count, i;
    PHANDLE             RouteHandles;
    ULONG               ulNumHandles;
    RTM_ENUM_HANDLE     hEnum;
    DWORD               dwResult;

    RouteHandles = HeapAlloc(
                    IPRouterHeap,
                    0,
                    g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                    );

    if ( RouteHandles == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwResult = RtmCreateRouteEnum( g_hLocalRoute,
                                   prdi->DestHandle,
                                   pInEntry->rgdwVarIndex[2], // Views
                                   RTM_ENUM_ALL_ROUTES,
                                   NULL,
                                   RTM_MATCH_NONE,
                                   NULL,
                                   0,
                                   &hEnum );

    if (dwResult is NO_ERROR)
    {      
        do 
        {
            ulNumHandles = g_rtmProfile.MaxHandlesInEnum;

            dwResult = RtmGetEnumRoutes( g_hLocalRoute,
                                         hEnum,
                                         &ulNumHandles,
                                         RouteHandles );

            for (i=0; i<ulNumHandles; i++)
            {
                AddRouteRows( RouteHandles[i],
                              pInEntry->rgdwVarIndex[3],//Proto
                              pdwCount,
                              dwSpaceCount,
                              pRouteTable );
            }
    
            RtmReleaseRoutes( g_hLocalRoute,
                              ulNumHandles,
                              RouteHandles );
    
        } while (dwResult is NO_ERROR);

        if (dwResult is ERROR_NO_MORE_ITEMS)
        {
            dwResult = NO_ERROR;
        }

        RtmDeleteEnumHandle( g_hLocalRoute, hEnum );
    }

    HeapFree(IPRouterHeap, 0, RouteHandles);
    
    return dwResult;
}

DWORD
AccessRouteMatching(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
{
    PMIB_IPDESTTABLE    pRouteTable;
    DWORD               dwResult, dwNumIndices, dwSpaceCount;
    DWORD               count;
    RTM_NET_ADDRESS     naDest;
    DWORD               dwOffset = MAX_MIB_OFFSET + sizeof(DWORD);
    PRTM_DEST_INFO      prdi;
    
    TraceEnter("AccessRouteMatching");

    count = dwSpaceCount = 0;

    pRouteTable = NULL;

    if (*pOutEntrySize > dwOffset)
    {
        dwSpaceCount = (*pOutEntrySize - dwOffset) 
                         / sizeof(MIB_IPDESTROW);

        pRouteTable = (PMIB_IPDESTTABLE)(pOutEntry->rgbyData);

        pRouteTable->dwNumEntries = 0;
    }

    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    if ((dwNumIndices < 4) or
        (dwQueryType isnot ACCESS_GET))
    {
        TraceLeave("AccessRouteMatching");
        
        return ERROR_INVALID_PARAMETER;
    }

    prdi = HeapAlloc(
            IPRouterHeap,
            0,
            RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
            );

    if ( prdi == NULL)
    {
        TraceLeave("AccessRouteMatching");

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RTM_IPV4_SET_ADDR_AND_MASK(&naDest,
                               pInEntry->rgdwVarIndex[0],  // Addr
                               pInEntry->rgdwVarIndex[1]); // Mask

    dwResult = RtmGetExactMatchDestination( g_hLocalRoute,
                                            &naDest,
                                            pInEntry->rgdwVarIndex[3],
                                            pInEntry->rgdwVarIndex[2],
                                            prdi );

    if (dwResult is ERROR_NOT_FOUND)
    {
        dwResult = NO_ERROR;
    }
    else
    if (dwResult is NO_ERROR)
    {
        dwResult = AddRouteRowsOnDest( prdi,
                                       pInEntry,
                                       &count,
                                       dwSpaceCount,
                                       pRouteTable );
    }

    *pOutEntrySize = dwOffset + count * sizeof(MIB_IPDESTROW);

    if (dwSpaceCount < count)
    {
        dwResult = ERROR_INSUFFICIENT_BUFFER;
    }

    HeapFree(IPRouterHeap, 0, prdi);
    
    TraceLeave("AccessRouteMatching");

    return dwResult;
}

DWORD
AccessRouteShorter(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
{
    PMIB_IPDESTTABLE    pRouteTable;
    DWORD               dwResult, dwNumIndices, dwSpaceCount;
    DWORD               count;
    RTM_NET_ADDRESS     naDest;
    DWORD               dwOffset = MAX_MIB_OFFSET + sizeof(DWORD);
    PRTM_DEST_INFO      prdi1, prdi2;
   
    TraceEnter("AccessRouteShorter");

    count = dwSpaceCount = 0;

    pRouteTable = NULL;

    if (*pOutEntrySize > dwOffset)
    {
        dwSpaceCount = (*pOutEntrySize - dwOffset) 
                         / sizeof(MIB_IPDESTROW);

        pRouteTable = (PMIB_IPDESTTABLE)(pOutEntry->rgbyData);

        pRouteTable->dwNumEntries = 0;
    }

    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    if ((dwNumIndices < 4) or
        (dwQueryType isnot ACCESS_GET))
    {
        TraceLeave("AccessRouteShorter");
        
        return ERROR_INVALID_PARAMETER;
    }

    prdi1 = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
                );

    if ( prdi1 == NULL)
    {
        TraceLeave("AccessRouteShorter");
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    prdi2 = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
                );

    if ( prdi2 == NULL)
    {
        TraceLeave("AccessRouteShorter");
        
        HeapFree(IPRouterHeap, 0, prdi1);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    RTM_IPV4_SET_ADDR_AND_MASK(&naDest,
                               pInEntry->rgdwVarIndex[0],  // Addr
                               pInEntry->rgdwVarIndex[1]); // Mask

    dwResult = RtmGetMostSpecificDestination( g_hLocalRoute,
                                              &naDest,
                                              pInEntry->rgdwVarIndex[3],//Proto
                                              pInEntry->rgdwVarIndex[2],//Views
                                              prdi1 );
    while (dwResult is NO_ERROR)
    {
        AddRouteRowsOnDest( prdi1,
                            pInEntry,
                            &count,
                            dwSpaceCount,
                            pRouteTable );

        dwResult = RtmGetLessSpecificDestination( g_hLocalRoute,
                                                  prdi1->DestHandle,
                                                  pInEntry->rgdwVarIndex[3],
                                                  pInEntry->rgdwVarIndex[2],
                                                  prdi2);

        RtmReleaseDestInfo( g_hLocalRoute, prdi1 );

        if (dwResult != NO_ERROR)
        {
            break;
        }

        AddRouteRowsOnDest( prdi2,
                            pInEntry,
                            &count,
                            dwSpaceCount,
                            pRouteTable );

        dwResult = RtmGetLessSpecificDestination( g_hLocalRoute,
                                                  prdi2->DestHandle,
                                                  pInEntry->rgdwVarIndex[3],
                                                  pInEntry->rgdwVarIndex[2],
                                                  prdi1);

        RtmReleaseDestInfo( g_hLocalRoute, prdi2 );

        if (dwResult != NO_ERROR)
        {
            break;
        }
    }

    if (dwResult is ERROR_NOT_FOUND)
    {
        dwResult = NO_ERROR;
    }

    *pOutEntrySize = dwOffset + count * sizeof(MIB_IPDESTROW);

    if (dwSpaceCount < count)
    {
        dwResult = ERROR_INSUFFICIENT_BUFFER;
    }

    HeapFree(IPRouterHeap, 0, prdi1);
    HeapFree(IPRouterHeap, 0, prdi2);

    TraceLeave("AccessRouteShorter");

    return dwResult;
}

DWORD
AccessRouteLonger(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
{
    PMIB_IPDESTTABLE    pRouteTable;
    DWORD               count, i;
    DWORD               dwResult, dwNumIndices, dwSpaceCount;
    RTM_NET_ADDRESS     naDest;
    ULONG               ulNumHandles;
    RTM_ENUM_HANDLE     hEnum;
    PHANDLE             RouteHandles;
    DWORD               dwOffset = MAX_MIB_OFFSET + sizeof(DWORD);
    
    TraceEnter("AccessRouteLonger");

    count = dwSpaceCount = 0;

    pRouteTable = NULL;

    if (*pOutEntrySize > dwOffset)
    {
        dwSpaceCount = (*pOutEntrySize - dwOffset) 
                         / sizeof(MIB_IPDESTROW);

        pRouteTable = (PMIB_IPDESTTABLE)(pOutEntry->rgbyData);

        pRouteTable->dwNumEntries = 0;
    }

    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    if ((dwNumIndices < 4) or
        (dwQueryType isnot ACCESS_GET))
    {
        TraceLeave("AccessRouteLonger");
        
        return ERROR_INVALID_PARAMETER;
    }

    RouteHandles = HeapAlloc(
                    IPRouterHeap,
                    0,
                    g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                    );

    if ( RouteHandles == NULL)
    {
        TraceLeave("AccessRouteLonger");

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RTM_IPV4_SET_ADDR_AND_MASK(&naDest,
                               pInEntry->rgdwVarIndex[0],  // Addr
                               pInEntry->rgdwVarIndex[1]); // Mask

    dwResult = RtmCreateRouteEnum( g_hLocalRoute,
                                   NULL,
                                   pInEntry->rgdwVarIndex[2], // Views
                                   RTM_ENUM_RANGE,
                                   &naDest,
                                   RTM_MATCH_NONE,
                                   NULL,
                                   0,
                                   &hEnum );

    if (dwResult is NO_ERROR)
    {
        do 
        {
            ulNumHandles = g_rtmProfile.MaxHandlesInEnum;

            dwResult = RtmGetEnumRoutes( g_hLocalRoute,
                                         hEnum,
                                         &ulNumHandles,
                                         RouteHandles );

            for (i=0; i<ulNumHandles; i++)
            {
                AddRouteRows( RouteHandles[i],
                              pInEntry->rgdwVarIndex[3], // Proto
                              &count,
                              dwSpaceCount,
                              pRouteTable );
            }

            RtmReleaseRoutes( g_hLocalRoute,
                              ulNumHandles,
                              RouteHandles );

        } while (dwResult is NO_ERROR);

        RtmDeleteEnumHandle( g_hLocalRoute, hEnum );
    }

    if (dwResult is ERROR_NO_MORE_ITEMS)
    {
        dwResult = NO_ERROR;
    }

    *pOutEntrySize = dwOffset + count * sizeof(MIB_IPDESTROW);

    if (dwSpaceCount < count)
    {
        dwResult = ERROR_INSUFFICIENT_BUFFER;
    }

    HeapFree(IPRouterHeap, 0, RouteHandles);
    
    TraceLeave("AccessRouteLonger");

    return dwResult;
}

PINTERFACE_ROUTE_INFO
ConvertDestRowToRouteInfo(
    IN  PMIB_IPDESTROW pMibRow
    )
{
    PINTERFACE_ROUTE_INFO pRouteInfo = (PINTERFACE_ROUTE_INFO)pMibRow;

    //
    // Note that it is important to note that here
    // the source and dest buffers are the same
    //

    pRouteInfo->dwRtInfoPreference = pMibRow->dwForwardPreference;
    pRouteInfo->dwRtInfoViewSet = pMibRow->dwForwardViewSet;

#if 0
    // Removed this since metric=0 is legal for routes to the loopback
    // interface.

    // Make sure Metric1 isn't 0

    if (pRouteInfo->dwForwardMetric1 is 0)
    {
        pRouteInfo->dwForwardMetric1 = 1;
    }

#endif

    return pRouteInfo;
}

DWORD 
AccessIpMatchingRoute(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to add, delete or set a route (IP Dest Row)

Arguments

    dwQueryType     Create, Set, Delete permitted
    pInEntry        Dest, Mask, IfIndex, and NextHop for the row filled in the
                    rgdwVarIndex field. 
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IPDESTROW). For Sets the
                    OutBuffer has the row to set

Return Value:
  
    NO_ERROR or some error code defined in iprtrmib

--*/

{
    PMIB_IPDESTROW   pIpRouteRow;
    DWORD            dwMask, i;
    DWORD            dwResult;
    HANDLE           hRtmHandle;

    TraceEnter("AccessIpMatchingRoute");

    pIpRouteRow = (PMIB_IPDESTROW)(pOutEntry->rgbyData);

    if (dwQueryType != ACCESS_DELETE_ENTRY)
    {
        // Make sure we have a buffer of the right size

        if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPDESTROW))
        {
            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPDESTROW);

            TraceLeave("AccessIpMatchingRoute");
        
            return ERROR_INSUFFICIENT_BUFFER;
        }
    
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPDESTROW);
    
        pOutEntry->dwId = ROUTE_MATCHING;
    }
    else
    {
        MIB_IPDESTROW  IpRouteRow;
        
        pIpRouteRow = &IpRouteRow;

        // Do you need to check the input buffer size here ?

        pIpRouteRow->dwForwardDest    = pInEntry->rgdwVarIndex[0];
        pIpRouteRow->dwForwardMask    = pInEntry->rgdwVarIndex[1];
        pIpRouteRow->dwForwardIfIndex = pInEntry->rgdwVarIndex[2];
        pIpRouteRow->dwForwardNextHop = pInEntry->rgdwVarIndex[3];
        pIpRouteRow->dwForwardProto   = pInEntry->rgdwVarIndex[4];
    }

    //
    // Do validation before adding or deleting the route
    //

    if((pIpRouteRow->dwForwardDest & pIpRouteRow->dwForwardMask) isnot 
        pIpRouteRow->dwForwardDest)
    {
        Trace2(ERR,
          "AccessIpMatchingRoute: Dest %d.%d.%d.%d and Mask %d.%d.%d.%d wrong",
           PRINT_IPADDR(pIpRouteRow->dwForwardDest),
           PRINT_IPADDR(pIpRouteRow->dwForwardMask));

        TraceLeave("AccessIpMatchingRoute");

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the RTM handle used to add or delete the route
    //

    hRtmHandle = NULL;

    for(i = 0;
        i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
        i++)
    {
        if(pIpRouteRow->dwForwardProto is g_rgRtmHandles[i].dwProtoId)
        {
            hRtmHandle = g_rgRtmHandles[i].hRouteHandle;

            break;
        }
    }

    if(hRtmHandle is NULL)
    {
        Trace1(ERR,
               "AccessIpMatchingRoute: Protocol %d not valid",
               pIpRouteRow->dwForwardProto);
               
        return ERROR_INVALID_PARAMETER;
    }

    switch (dwQueryType)
    {
    case ACCESS_CREATE_ENTRY:
    case ACCESS_SET:

        //
        // Add the RTM route from the ip row entry
        //

        ENTER_READER(ICB_LIST);
    
        dwMask = GetBestNextHopMaskGivenIndex(pIpRouteRow->dwForwardIfIndex,
                                              pIpRouteRow->dwForwardNextHop);
    
        EXIT_LOCK(ICB_LIST);

        //
        // Convert input to INTERFACE_ROUTE_INFO and add
        //

        dwResult = AddRtmRoute(hRtmHandle,
                               ConvertDestRowToRouteInfo(pIpRouteRow),
                               IP_VALID_ROUTE | IP_STACK_ROUTE,
                               dwMask,
                               pIpRouteRow->dwForwardAge,
                               NULL);
    
        if(dwResult isnot NO_ERROR)
        {
            Trace1(MIB,
                "AccessIpMatchingRoute: Could not set route to RTM: Dest %x\n",
                pIpRouteRow->dwForwardDest);
        }

        break;

    case ACCESS_DELETE_ENTRY:

        dwResult = DeleteRtmRoute(hRtmHandle,
                                  ConvertDestRowToRouteInfo(pIpRouteRow));
        break;

    default:

        dwResult = ERROR_INVALID_FUNCTION;
    }

    TraceLeave("AccessIpMatchingRoute");

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\asyncwrk.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\asyncwrk.h

Abstract:

    All functions called spooled to a worker function

Revision History:

    Gurdeep Singh Pall          6/15/95  Created

--*/

typedef struct _RESTORE_INFO_CONTEXT
{
    DWORD   dwIfIndex;
}RESTORE_INFO_CONTEXT, *PRESTORE_INFO_CONTEXT;


VOID 
RestoreStaticRoutes(
    PVOID pvContext
    );

VOID
ResolveHbeatName(
    PVOID pvContext
    );

DWORD
QueueAsyncFunction(
    WORKERFUNCTION   pfnFunction,
    PVOID            pvContext,
    BOOL             bAlertable
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\close.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\close.c

Abstract:

    Function related to shutdown

Revision History:

    Gurdeep Singh Pall          6/14/95  Created

--*/

#include "allinc.h"

VOID
ReinstallOldRoutes(
    );


VOID
RouterManagerCleanup(
    VOID
    )
/*++

Routine Description

    The main cleanup function

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    HANDLE hRtmHandle;
    DWORD  i;

    TraceEnter("RouterManagerCleanup");

    DeleteAllInterfaces();
    
    UnloadRoutingProtocols();
    
    UnInitHashTables();

    CloseIPDriver();

    CloseMcastDriver();

    MIBCleanup();

#ifdef KSL_IPINIP
    CloseIpIpKey();
#endif //KSL_IPINIP
    
    if (!RouterRoleLanOnly) 
    {
        //
        // WAN related cleanups
        //
        
        CloseWanArp() ;

        if (g_bEnableNetbtBcastFrowarding)
        {
            RestoreNetbtBcastForwardingMode();
            g_bEnableNetbtBcastFrowarding = FALSE;
        }
    }
  
    if(g_hMprConfig isnot NULL)
    {
        MprConfigServerDisconnect(g_hMprConfig);
        g_hMprConfig = NULL;
    }
 
    MgmDeInitialize ();

    if (g_hNotification isnot NULL)
    {
        RtmDeregisterFromChangeNotification(g_hLocalRoute,
                                            g_hNotification);

        g_hNotification = NULL;
    }


    if (g_hDefaultRouteNotification isnot NULL)
    {
        RtmDeregisterFromChangeNotification(g_hNetMgmtRoute,
                                            g_hDefaultRouteNotification);

        g_hDefaultRouteNotification = NULL;
    }

    // Cleanup and deregister all RTM registrations
    
    for(i = 0;
        i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
        i++)
    {
        hRtmHandle = g_rgRtmHandles[i].hRouteHandle;

        if (hRtmHandle isnot NULL)
        {
            // Delete all routes added by this regn
            DeleteRtmRoutes(hRtmHandle, 0, TRUE);
        
            // Delete all nexthops added by this regn
            DeleteRtmNexthops(hRtmHandle, 0, TRUE);

            // Deregister this registration from RTM
            RtmDeregisterEntity(hRtmHandle);

            g_rgRtmHandles[i].dwProtoId    = 0;
            g_rgRtmHandles[i].hRouteHandle = NULL;
        }
    }

    // Null out the aliases to the above regn handles
    
    g_hLocalRoute       = NULL;
    g_hAutoStaticRoute  = NULL;
    g_hStaticRoute      = NULL;
    g_hNonDodRoute      = NULL;
    g_hNetMgmtRoute     = NULL;

    //
    // When last entity deregisters, the route table is automatically deleted
    //

    //
    // Close handles used for notification
    //
    
    if(g_hDemandDialEvent isnot NULL)
    {
        CloseHandle(g_hDemandDialEvent) ;
        g_hDemandDialEvent = NULL;
    }

#ifdef KSL_IPINIP
    if(g_hIpInIpEvent isnot NULL)
    {
        CloseHandle(g_hIpInIpEvent);
        g_hIpInIpEvent = NULL;
    }
#endif //KSL_IPINIP

    if(g_hSetForwardingEvent isnot NULL)
    {
        CloseHandle(g_hSetForwardingEvent);
        g_hSetForwardingEvent = NULL;
    }

    if(g_hForwardingChangeEvent isnot NULL)
    {
        CloseHandle(g_hForwardingChangeEvent);

        g_hForwardingChangeEvent = NULL;
    }

    if(g_hStackChangeEvent isnot NULL)
    {
        CloseHandle(g_hStackChangeEvent);
        g_hStackChangeEvent = NULL;
    }

    if(g_hRoutingProtocolEvent isnot NULL)
    {
        CloseHandle(g_hRoutingProtocolEvent) ;
        g_hRoutingProtocolEvent = NULL;
    }
    
    if(g_hStopRouterEvent isnot NULL)
    {
        CloseHandle(g_hStopRouterEvent) ;
        g_hStopRouterEvent = NULL;
    }
   
    if(g_hRtrDiscSocketEvent isnot NULL)
    {
        CloseHandle(g_hRtrDiscSocketEvent);
        g_hRtrDiscSocketEvent = NULL;
    }

    if(g_hMcMiscSocketEvent isnot NULL)
    {
        CloseHandle(g_hMcMiscSocketEvent);
        g_hMcMiscSocketEvent = NULL;
    }

    if(g_hRtrDiscTimer isnot NULL)
    {
        CloseHandle(g_hRtrDiscTimer);
        g_hRtrDiscTimer = NULL;
    }

    for(i = 0; i < NUM_MCAST_IRPS; i++)
    {
        if(g_hMcastEvents[i] isnot NULL)
        {
            CloseHandle(g_hMcastEvents[i]);

            g_hMcastEvents[i] = NULL;
        }
    }
 
    for(i = 0; i < NUM_ROUTE_CHANGE_IRPS; i++)
    {
        if(g_hRouteChangeEvents[i] isnot NULL)
        {
            CloseHandle(g_hRouteChangeEvents[i]);

            g_hRouteChangeEvents[i] = NULL;
        }
    }


    if(WSACleanup() isnot NO_ERROR)
    {
        Trace1(ERR,
               "RouterManagerCleanup: WSACleanup returned %d",
               WSAGetLastError());
    }
    
    for(i = 0; i < NUM_LOCKS; i++)
    {
        RtlDeleteResource(&g_LockTable[i]);
    }

    //
    // reinstall all the routes that existed before we started. The memory 
    // was from route heap so will get freed
    //

    if(!IsListEmpty(&g_leStackRoutesToRestore))
    {
        Sleep(0);
        Trace0(GLOBAL, "Reinstalling stack routes");
        ReinstallOldRoutes();
    }

    //
    // This cleans out the interface structures, since they are all
    // allocated from this heap
    //
    
    if(IPRouterHeap isnot NULL)
    {
        HeapDestroy (IPRouterHeap) ;
        IPRouterHeap = NULL;
    }
    
    Trace0(GLOBAL, "IP Router Manager cleanup done");

    TraceLeave("RouterManagerCleanup");
    
    TraceDeregister (TraceHandle) ;
}

VOID
ReinstallOldRoutes(
    )
{
    DWORD               dwResult;
    PROUTE_LIST_ENTRY   prl;
    
    TraceEnter("ReinstallOldRoutes");
    
    while (!IsListEmpty(&g_leStackRoutesToRestore))
    {
        prl = (PROUTE_LIST_ENTRY) RemoveHeadList(
                &g_leStackRoutesToRestore
                );

        Trace2(
            ROUTE, "%d.%d.%d.%d/%d.%d.%d.%d",
            PRINT_IPADDR( prl->mibRoute.dwForwardDest ),
            PRINT_IPADDR( prl->mibRoute.dwForwardMask )
            );
                
        dwResult = SetIpForwardEntryToStack(&(prl->mibRoute));
        
        if (dwResult isnot NO_ERROR) 
        {
            Trace2(ERR,
                   "ReinstallOldRoutes: Failed to add route to %x from "
                   " init table. Error %x",
                   prl->mibRoute.dwForwardDest,
                   dwResult);
        }
    }

    TraceLeave("ReinstallOldRoutes");
}


VOID
MIBCleanup(
    VOID
    )
{
    TraceEnter("MIBCleanup");
    
    if(g_hIfHeap isnot NULL)
    {
        HeapDestroy(g_hIfHeap);
        g_hIfHeap = NULL;
    }
    
    if(g_hUdpHeap isnot NULL)
    {
        HeapDestroy(g_hUdpHeap);
        g_hUdpHeap = NULL;
    }
    
    if(g_hIpAddrHeap isnot NULL)
    {
        HeapDestroy(g_hIpAddrHeap);
        g_hIpAddrHeap = NULL;
    }
    
    if(g_hIpForwardHeap isnot NULL)
    {
        HeapDestroy(g_hIpForwardHeap);
        g_hIpForwardHeap = NULL;
    }
    
    if(g_hIpNetHeap isnot NULL)
    {
        HeapDestroy(g_hIpNetHeap);
        g_hIpNetHeap = NULL;
    }

    TraceLeave("MIBCleanup");
}

//* UnloadRoutingProtocols()
//
//  Function: 1. Calls stopprotocol for each routing protocol
//            2. Waits for protocols to stop
//            3. Unloads the routing protocol dlls.
//
//  Returns:  Nothing.
//*
VOID
UnloadRoutingProtocols()
{
    PLIST_ENTRY currentlist ;
    PPROTO_CB protptr ;

    TraceEnter("UnloadRoutingProtocols");

    while (!IsListEmpty(&g_leProtoCbList)) 
    {
        
        currentlist = RemoveHeadList(&g_leProtoCbList);

        protptr = CONTAINING_RECORD (currentlist, PROTO_CB, leList) ;

        //
        // relenquish CPU to enable DLL threads to finish
        //
        Sleep(0);
        
        FreeLibrary (protptr->hiHInstance) ;       // unload dll
        
        HeapFree (IPRouterHeap, 0, protptr) ;       // free cb
        
    }

    TraceLeave("UnloadRoutingProtocols");
}


VOID
CloseIPDriver(
    VOID
    )
{
    TraceEnter("CloseIPDriver");
    
    if(g_hIpDevice isnot NULL)
    {
        CloseHandle(g_hIpDevice) ;
    }

    if (g_hIpRouteChangeDevice isnot NULL)
    {
        CloseHandle(g_hIpRouteChangeDevice);
    }

    TraceLeave("CloseIPDriver");
    
}

VOID
CloseMcastDriver(
    VOID
    )
{
    TraceEnter("CloseMcastDriver");

    if(g_hMcastDevice isnot NULL)
    {
        CloseHandle(g_hMcastDevice);
    }

    TraceLeave("CloseMcastDriver");

}


DWORD
StopDriverAndCloseHandle(
    PCHAR   pszServiceName,
    HANDLE  hDevice
    )
{
    NTSTATUS            status;
    UNICODE_STRING      nameString;
    IO_STATUS_BLOCK     ioStatusBlock;
    OBJECT_ATTRIBUTES   objectAttributes;
    SC_HANDLE           schSCManager, schService;
    DWORD               dwErr;
    SERVICE_STATUS      ssStatus;

    TraceEnter("StopDriverAndCloseHandle");
    
    if(hDevice isnot NULL)
    {
        CloseHandle(hDevice);
    }
    
    schSCManager = OpenSCManager(NULL, 
                                 NULL, 
                                 SC_MANAGER_ALL_ACCESS);
        
    if(schSCManager is NULL)
    {
        dwErr = GetLastError();
        
        Trace2(ERR,
               "StopDriver: Error %d opening service controller for %s", 
               dwErr,
               pszServiceName);

        TraceLeave("StopDriver");
        
        return dwErr;
    }
    
    schService = OpenService(schSCManager,
                             pszServiceName,
                             SERVICE_ALL_ACCESS);
    
    if(schService is NULL)
    {
        dwErr = GetLastError();
        
        Trace2(ERR,
               "StopDriver: Error %d opening %s",
               dwErr,
               pszServiceName);
        
        CloseServiceHandle(schSCManager);

        TraceLeave("StopDriver");
        
        return dwErr;
    }
    
    if(!ControlService(schService,
                       SERVICE_CONTROL_STOP,
                       &ssStatus))
    {
        dwErr = GetLastError();
        
        Trace2(ERR,
               "StopDriver: Error %d stopping %s",
               dwErr,
               pszServiceName);

        TraceLeave("StopDriver");
        
        return dwErr;
    }

    TraceLeave("StopDriver");
    
    return NO_ERROR ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\compare.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\compare.c

Abstract:
         File contains the following functions
	      PortCmp
	      Cmp
	      InetCmp
	      UdpCmp
	      TcpCmp
	      IpNetCmp
	
	All these functions behave like strcmp. They return >0 if first argument is greater
	than the second, <0 if the second is greater than the first and 0 if they are equal
	
	These functions should be revised to make them more effecient

Revision History:

    Amritansh Raghav          6/8/95  Created
    Amritansh Raghav          10/18/95 The functions now return >0,0,<0 instead of +1,0,-1

--*/

#include "allinc.h"
#include "winsock2.h"

LONG 
UdpCmp(
       DWORD dwAddr1, 
       DWORD dwPort1, 
       DWORD dwAddr2, 
       DWORD dwPort2
       )
{
    LONG lResult;
    
    if(InetCmp(dwAddr1,dwAddr2,lResult))
    {
        return lResult;
    }
    else
    {
        return PortCmp(dwPort1,dwPort2,lResult);
    }
}

LONG 
TcpCmp(
       DWORD dwLocalAddr1, 
       DWORD dwLocalPort1, 
       DWORD dwRemAddr1, 
       DWORD dwRemPort1,
       DWORD dwLocalAddr2, 
       DWORD dwLocalPort2, 
       DWORD dwRemAddr2, 
       DWORD dwRemPort2
       )
{
    LONG lResult;
    
    if(InetCmp(dwLocalAddr1,dwLocalAddr2,lResult) isnot 0)
    {
        return lResult;
    }
    else
    {
        if(PortCmp(dwLocalPort1,dwLocalPort2,lResult) isnot 0)
        {
            return lResult;
        }
        else
        {
            if(InetCmp(dwRemAddr1,dwRemAddr2,lResult) isnot 0)
            {
                return lResult;
            }
            else
            {
                return PortCmp(dwRemPort1,dwRemPort2,lResult);
            }
        }
    }
}

LONG 
IpNetCmp(
         DWORD dwIfIndex1, 
         DWORD dwAddr1, 
         DWORD dwIfIndex2, 
         DWORD dwAddr2
         )
{
    LONG lResult;
    
    //
    // Index is a simple DWORD, not a port
    //

    if(dwIfIndex1 != dwIfIndex2)
    {
        if(dwIfIndex1 < dwIfIndex2)
        {
            return -1;
        }
        else
        {
            return 1;
        }
    }
    else
    {
        return InetCmp(dwAddr1,dwAddr2,lResult);
    }
}

LONG
IpForwardCmp(
             DWORD dwIpDest1, 
             DWORD dwProto1, 
             DWORD dwPolicy1, 
             DWORD dwIpNextHop1,
             DWORD dwIpDest2, 
             DWORD dwProto2, 
             DWORD dwPolicy2, 
             DWORD dwIpNextHop2
             )
{
    LONG lResult;
    
    if(InetCmp(dwIpDest1,dwIpDest2,lResult) isnot 0)
    {
        return lResult;
    }
    else
    {
        if(Cmp(dwProto1,dwProto2,lResult) isnot 0)
        {
            return lResult;
        }
        else
        {
            if(Cmp(dwPolicy1,dwPolicy2,lResult) isnot 0)
            {
                return lResult;
            }
            else
            {
                return InetCmp(dwIpNextHop1,dwIpNextHop2,lResult);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\cache.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:


Abstract:
         File contains the following functions
	      ActionCache
	      CacheToA

Revision History:

    Amritansh Raghav          6/8/95  Created

--*/


//
// Include files
//

#include "allinc.h"

DWORD
UpdateCache(
    DWORD dwCache,
    BOOL *fUpdate
    )

/*++

Routine Description

    Function used to update a cache. It checks to see if the last time
    the cache was updated is greater than the time out (A value of 0
    for the last time of update means the cache is invalid), calls the
    function that loads the cache and then sets the last update time

Locks



Arguments

    dwCache     This is one of the Cache Ids defined in rtrmgr/defs.h. It
                is used to index into the table of locks protecting the caches,
                the table  of function pointers that holds a pointer to a
                function that loads the cache andthe table of last update times

    fUpdate     Is Set to true if the cache is updated

Return Value

    None

--*/

{
    DWORD  dwResult = NO_ERROR;
    LONG   dwNeed;
    LONG   dwSpace;


    //
    // BUG put in a bounds check here otherwise effects can be disastrous
    //

    // Trace1(MIB,"Trying to update %s cache", CacheToA(dwCache));

    __try
    {
        ENTER_READER(dwCache);

        if((g_LastUpdateTable[dwCache] isnot 0) and
           ((GetCurrentTime() - g_LastUpdateTable[dwCache]) < g_TimeoutTable[dwCache]))
        {
            *fUpdate = FALSE;
            dwResult = NO_ERROR;
            __leave;
        }

        READER_TO_WRITER(dwCache);

        // Trace0(MIB,"Cache out of date");

        dwResult = (*g_LoadFunctionTable[dwCache])();

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,"Error %d loading %s cache",
                   dwResult,
                   CacheToA(dwCache));

            g_LastUpdateTable[dwCache] = 0;

            __leave;
        }

        g_LastUpdateTable[dwCache] = GetCurrentTime();

        dwResult = NO_ERROR;
    }
    __finally
    {
        EXIT_LOCK(dwCache);
    }

    return dwResult; //to keep compiler happy
}


PSZ
CacheToA(
         DWORD dwCache
         )
{
    static PSZ cacheName[] = {"Ip Address Table",
                              "Ip Forward Table",
                              "Ip Net To Media table",
                              "Tcp Table",
                              "Udp Table",
                              "Arp Entity Table",
                              "Illegal Cache Number - ABORT!!!!"};

    return( (dwCache >= NUM_CACHE - 1)?
           cacheName[NUM_CACHE-1] : cacheName[dwCache]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\defs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\defs.c

Abstract:

    IP Router Manager defines

Revision History:

    Gurdeep Singh Pall          6/16/95  Created

--*/

#ifndef __DEFS_H__
#define __DEFS_H__

#include "logtrdef.h"

//
// Neat macros to avoid errors
//

#define is      ==
#define isnot   !=
#define and     &&
#define or      ||

#define INVALID_INDEX_OR_INSTANCE   0xffffffff

#define INVALID_ADAPTER_ID          INVALID_INDEX_OR_INSTANCE
#define INVALID_IF_INSTANCE         INVALID_INDEX_OR_INSTANCE
#define INVALID_AT_INSTANCE         INVALID_INDEX_OR_INSTANCE
#define INVALID_IF_INDEX            INVALID_INDEX_OR_INSTANCE

#define INVALID_IP_ADDRESS          0x00000000

#define HOST_ROUTE_MASK             0xFFFFFFFF
#define IP_LOOPBACK_ADDRESS         0x0100007F
#define ALL_ONES_BROADCAST          0xFFFFFFFF
#define ALL_ONES_MASK               0xFFFFFFFF
#define LOCAL_NET_MULTICAST         0x000000E0
#define LOCAL_NET_MULTICAST_MASK    0x000000F0

#define CLASSA_ADDR(a)  (( (*((uchar *)&(a))) & 0x80) == 0)
#define CLASSB_ADDR(a)  (( (*((uchar *)&(a))) & 0xc0) == 0x80)
#define CLASSC_ADDR(a)  (( (*((uchar *)&(a))) & 0xe0) == 0xc0)
#define CLASSE_ADDR(a)  ((( (*((uchar *)&(a))) & 0xf0) == 0xf0) && \
                        ((a) != 0xffffffff))

#define CLASSA_MASK     0x000000ff
#define CLASSB_MASK     0x0000ffff
#define CLASSC_MASK     0x00ffffff
#define CLASSD_MASK     0x000000e0
#define CLASSE_MASK     0xffffffff

#define INET_CMP(a,b,c)                                                     \
            (((c) = (((a) & 0x000000ff) - ((b) & 0x000000ff))) ? (c) :      \
            (((c) = (((a) & 0x0000ff00) - ((b) & 0x0000ff00))) ? (c) :      \
            (((c) = (((a) & 0x00ff0000) - ((b) & 0x00ff0000))) ? (c) :      \
            (((c) = ((((a)>>8) & 0x00ff0000) - (((b)>>8) & 0x00ff0000)))))))

#define GetClassMask(a)\
    (CLASSA_ADDR((a)) ? CLASSA_MASK : \
        (CLASSB_ADDR((a)) ? CLASSB_MASK : \
            (CLASSC_ADDR((a)) ? CLASSC_MASK : CLASSE_MASK)))

#define IsValidIpAddress(a)                                     \
    ((((ULONG)((a) & 0x000000FF)) <  ((ULONG)0x000000E0)) &&    \
     (((a) & 0x000000FF) != 0))

//
// Number of pending IRPs
//

#define NUM_MCAST_IRPS              3
#define NUM_ROUTE_CHANGE_IRPS       3

#define EVENT_DEMANDDIAL            0
#ifdef KSL_IPINIP
#define EVENT_IPINIP                (EVENT_DEMANDDIAL       + 1)
#endif //KSL_IPINIP
#define EVENT_STOP_ROUTER           (EVENT_DEMANDDIAL       + 1)
#define EVENT_SET_FORWARDING        (EVENT_STOP_ROUTER      + 1)
#define EVENT_FORWARDING_CHANGE     (EVENT_SET_FORWARDING   + 1)
#define EVENT_STACK_CHANGE          (EVENT_FORWARDING_CHANGE + 1)
#define EVENT_ROUTINGPROTOCOL       (EVENT_STACK_CHANGE     + 1)
#define EVENT_RTRDISCTIMER          (EVENT_ROUTINGPROTOCOL  + 1)
#define EVENT_RTRDISCSOCKET         (EVENT_RTRDISCTIMER     + 1)
#define EVENT_MCMISCSOCKET          (EVENT_RTRDISCSOCKET    + 1)
#define EVENT_MHBEAT                (EVENT_MCMISCSOCKET     + 1)
#define EVENT_MZAPTIMER             (EVENT_MHBEAT           + 1)
#define EVENT_MZAPSOCKET            (EVENT_MZAPTIMER        + 1)
#define EVENT_RASADVTIMER           (EVENT_MZAPSOCKET       + 1)
#define EVENT_MCAST_0               (EVENT_RASADVTIMER      + 1)
#define EVENT_MCAST_1               (EVENT_MCAST_0          + 1)
#define EVENT_MCAST_2               (EVENT_MCAST_1          + 1)
#define EVENT_ROUTE_CHANGE_0        (EVENT_MCAST_2          + 1)
#define EVENT_ROUTE_CHANGE_1        (EVENT_ROUTE_CHANGE_0   + 1)
#define EVENT_ROUTE_CHANGE_2        (EVENT_ROUTE_CHANGE_1   + 1)


//
// Last one + 1
//

#define NUMBER_OF_EVENTS            (EVENT_ROUTE_CHANGE_2   + 1)

//
// The polling time to see if all interfaces have been deleted
//

#define INTERFACE_DELETE_POLL_TIME  2500

//
// Number of times we try to read the server adapter address
//

#define MAX_SERVER_INIT_TRIES       1

//
// Number of millisecs we sleep between tries
//

#define SERVER_INIT_SLEEP_TIME      3000


#define REGISTER                    register

#define IP_ROUTE_HASH_TABLE_SIZE    257
#define IP_ROUTE_TABLE_MEMORY       64 * 50000  // 64 approx size of route, 50000 routes

#define MGM_IF_TABLE_SIZE           29
#define MGM_GROUP_TABLE_SIZE        257
#define MGM_SOURCE_TABLE_SIZE       257

#define ICB_HASH_TABLE_SIZE         57

#define BINDING_HASH_TABLE_SIZE     57

#define BIND_HASH(X)                ((X) % BINDING_HASH_TABLE_SIZE)

//#define ADAPTER_HASH_TABLE_SIZE     57
//#define ADAPTER_HASH(X)             ((X) % ADAPTER_HASH_TABLE_SIZE)


//
// A coherency number put into the ICBs. It is incremented with each added
// interface. The internal interface is 1, and the loopback interface is 2
// hence this must be > 2
//

#define LOOPBACK_INTERFACE_INDEX    1
//#define SERVER_INTERFACE_INDEX      2
#define INITIAL_SEQUENCE_NUMBER         1

//
// For links we dont know about, we set the MTU to 1500
//

#define DEFAULT_MTU                 1500


#define LOOPBACK_STRID              9990
#define INTERNAL_STRID              9991
#define WAN_STRID                   9992
#ifdef KSL_IPINIP
#define IPIP_STRID                  9993
#endif //KSL_IPINIP

//
// Macros called each time an api is called and exited. This is to
// facilitate RouterStop() functionality.
//

#define EnterRouterApi() {                               \
            EnterCriticalSection(&RouterStateLock) ;     \
            if (RouterState.IRS_State == RTR_STATE_RUNNING) {      \
                RouterState.IRS_RefCount++ ;             \
                LeaveCriticalSection(&RouterStateLock) ; \
            } else {                                     \
                LeaveCriticalSection(&RouterStateLock) ; \
                Trace1(ANY, "error %d on RM API", ERROR_ROUTER_STOPPED);    \
                return ERROR_ROUTER_STOPPED ;            \
            }                                            \
        }

#define ExitRouterApi() {                                \
            EnterCriticalSection(&RouterStateLock) ;     \
            RouterState.IRS_RefCount-- ;                 \
            LeaveCriticalSection(&RouterStateLock) ;     \
        }


//++
//
//  BOOL
//  IsIfP2P(
//      IN  DWORD   dwRouterIfType
//      )
//
//--


#define IsIfP2P(t)                              \
    (((t) == ROUTER_IF_TYPE_FULL_ROUTER) ||     \
     ((t) == ROUTER_IF_TYPE_HOME_ROUTER) ||     \
     ((t) == ROUTER_IF_TYPE_DIALOUT))


//
// Additional flags for the IP route structure
// These are not in RTM.H because we dont want to expose them
// to the public's prying eyes.
//
// NOTE IP_VALID_ROUTE is #defined as 0x00000001
//

#define IP_VALID_ROUTE      0x00000001
#define IP_STACK_ROUTE      0x00000002
#define IP_P2P_ROUTE        0x00000004
#define RTM_NOT_STACK_ROUTE 0xFFFF0001
#define HOST_MASK_LENGTH    32

#define IP_SETTABLE_ROUTE   (IP_VALID_ROUTE | IP_STACK_ROUTE)

#define ClearRouteFlags(pRoute)         \
    ((pRoute)->Flags1 = 0x00000000)


#define IsRouteValid(pRoute)            \
    ((pRoute)->Flags1 & IP_VALID_ROUTE)

#define SetRouteValid(pRoute)           \
    ((pRoute)->Flags1 |= IP_VALID_ROUTE)

#define ClearRouteValid(pRoute)         \
    ((pRoute)->Flags1 &= ~IP_VALID_ROUTE)


#define IsRouteStack(pRoute)            \
    ((pRoute)->Flags1 & IP_STACK_ROUTE)

#define SetRouteStack(pRoute)           \
    ((pRoute)->Flags1 |= IP_STACK_ROUTE)

#define ClearRouteStack(pRoute)         \
    ((pRoute)->Flags1 &= ~IP_STACK_ROUTE)


#define IsRouteP2P(pRoute)              \
    ((pRoute)->Flags1 & IP_P2P_ROUTE)

#define SetRouteP2P(pRoute)             \
    ((pRoute)->Flags1 |= IP_P2P_ROUTE)

#define ClearRouteP2P(pRoute)           \
    ((pRoute)->Flags1 &= ~IP_P2P_ROUTE)

/*

//
// VOID 
// ConvertRTMToForward(PMIB_IPFORWARDROW forwardRow, RTM_IP_ROUTE *route)
//

#define ConvertRTMToForward(f,route){                                       \
    (f)->dwForwardDest      = (route)->RR_Network.N_NetNumber;              \
    (f)->dwForwardIfIndex   = (route)->RR_InterfaceID;                      \
    (f)->dwForwardMetric1   = (route)->RR_FamilySpecificData.FSD_Metric1;   \
    (f)->dwForwardMetric2   = (route)->RR_FamilySpecificData.FSD_Metric2;   \
    (f)->dwForwardMetric3   = (route)->RR_FamilySpecificData.FSD_Metric3;   \
    (f)->dwForwardMetric4   = (route)->RR_FamilySpecificData.FSD_Metric4;   \
    (f)->dwForwardMetric5   = (route)->RR_FamilySpecificData.FSD_Metric5;   \
    (f)->dwForwardNextHop   = (route)->RR_NextHopAddress.N_NetNumber;       \
    (f)->dwForwardType	    = (route)->RR_FamilySpecificData.FSD_Type;      \
    (f)->dwForwardProto     = (route)->RR_RoutingProtocol;                  \
    (f)->dwForwardAge       = RtmGetRouteAge((route));                      \
    (f)->dwForwardMask      = (route)->RR_Network.N_NetMask;                \
    (f)->dwForwardNextHopAS = (route)->RR_FamilySpecificData.FSD_NextHopAS; \
    (f)->dwForwardPolicy    = (route)->RR_FamilySpecificData.FSD_Policy;}

//
// VOID 
// ConvertForwardToRTM(PMIB_IPFORWARDROW forwardRow, 
//                     RTM_IP_ROUTE       *route, 
//                     DWORD              dwNextHopMask)
//

#define ConvertForwardToRTM(f,route,mask){                                  \
    (route)->RR_Network.N_NetNumber               = (f)->dwForwardDest;     \
    (route)->RR_InterfaceID                       = (f)->dwForwardIfIndex;  \
    (route)->RR_FamilySpecificData.FSD_Metric     =                         \
    (route)->RR_FamilySpecificData.FSD_Metric1    = (f)->dwForwardMetric1;  \
    (route)->RR_FamilySpecificData.FSD_Metric2    = (f)->dwForwardMetric2;  \
    (route)->RR_FamilySpecificData.FSD_Metric3    = (f)->dwForwardMetric3;  \
    (route)->RR_FamilySpecificData.FSD_Metric4    = (f)->dwForwardMetric4;  \
    (route)->RR_FamilySpecificData.FSD_Metric5    = (f)->dwForwardMetric5;  \
    (route)->RR_FamilySpecificData.FSD_Priority   = 0;                      \
    (route)->RR_NextHopAddress.N_NetNumber        = (f)->dwForwardNextHop;  \
    (route)->RR_NextHopAddress.N_NetMask          = (mask);                 \
    (route)->RR_Network.N_NetMask                 = (f)->dwForwardMask;     \
    (route)->RR_FamilySpecificData.FSD_Policy     = (f)->dwForwardPolicy;   \
    (route)->RR_FamilySpecificData.FSD_NextHopAS  = (f)->dwForwardNextHopAS;\
    (route)->RR_FamilySpecificData.FSD_Type       = (f)->dwForwardType;     \
    (route)->RR_RoutingProtocol                   = (f)->dwForwardProto;    \
    ClearRouteFlags((route));                                               \
    SetRouteValid((route));                                                 \
    SetRouteStack((route)); }

//
// VOID 
// ConvertStackToRTM(RTM_IP_ROUTE   *route,
//                   IPRouteEntry   *ipreRow
//                   DWORD          dwNextHopMask)
//

#define ConvertStackToRTM(route,ipreRow,mask){                                  \
    (route)->RR_Network.N_NetNumber               = (ipreRow)->ire_dest;    \
    (route)->RR_InterfaceID                       = (ipreRow)->ire_index;   \
    (route)->RR_FamilySpecificData.FSD_Metric     =                         \
    (route)->RR_FamilySpecificData.FSD_Metric1    = (ipreRow)->ire_metric1; \
    (route)->RR_FamilySpecificData.FSD_Metric2    = (ipreRow)->ire_metric2; \
    (route)->RR_FamilySpecificData.FSD_Metric3    = (ipreRow)->ire_metric3; \
    (route)->RR_FamilySpecificData.FSD_Metric4    = (ipreRow)->ire_metric4; \
    (route)->RR_FamilySpecificData.FSD_Metric5    = (ipreRow)->ire_metric5; \
    (route)->RR_FamilySpecificData.FSD_Priority   = 0;                      \
    (route)->RR_NextHopAddress.N_NetNumber        = (ipreRow)->ire_nexthop; \
    (route)->RR_NextHopAddress.N_NetMask          = (mask);                 \
    (route)->RR_Network.N_NetMask                 = (ipreRow)->ire_mask;    \
    (route)->RR_FamilySpecificData.FSD_Policy     = 0;                      \
    (route)->RR_FamilySpecificData.FSD_NextHopAS  = 0;                      \
    (route)->RR_FamilySpecificData.FSD_Type       = (ipreRow)->ire_type;    \
    (route)->RR_RoutingProtocol                   = (ipreRow)->ire_proto;   \
    ClearRouteFlags((route));                                               \
    SetRouteValid((route));                                                 \
    SetRouteStack((route)); }

//
// VOID 
// ConvertStackToForward(PMIB_IPFORWARDROW forwardRow,
//                       IPRouteEntry       *ipreRow)
//

#define ConvertStackToForward(forwardRow,ipreRow) {              \
    (forwardRow)->dwForwardDest      = (ipreRow)->ire_dest;      \
    (forwardRow)->dwForwardIfIndex   = (ipreRow)->ire_index;     \
    (forwardRow)->dwForwardMetric1   = (ipreRow)->ire_metric1;   \
    (forwardRow)->dwForwardMetric2   = (ipreRow)->ire_metric2;   \
    (forwardRow)->dwForwardMetric3   = (ipreRow)->ire_metric3;   \
    (forwardRow)->dwForwardMetric4   = (ipreRow)->ire_metric4;   \
    (forwardRow)->dwForwardMetric5   = (ipreRow)->ire_metric5;   \
    (forwardRow)->dwForwardNextHop   = (ipreRow)->ire_nexthop;   \
    (forwardRow)->dwForwardType	     = (ipreRow)->ire_type;      \
    (forwardRow)->dwForwardProto     = (ipreRow)->ire_proto;     \
    (forwardRow)->dwForwardAge       = (ipreRow)->ire_age;       \
    (forwardRow)->dwForwardMask      = (ipreRow)->ire_mask;      \
    (forwardRow)->dwForwardNextHopAS = 0;                        \
    (forwardRow)->dwForwardPolicy    = 0; }

*/

#define IPADDRCACHE                 0
#define IPFORWARDCACHE              IPADDRCACHE    + 1
#define IPNETCACHE                  IPFORWARDCACHE + 1
#define TCPCACHE                    IPNETCACHE     + 1
#define UDPCACHE                    TCPCACHE       + 1

//
// Last Cache + 1
//

#define NUM_CACHE                   UDPCACHE    + 1

//
// We tag the ICB_LIST and the PROTOCOL_CB_LIST locks at the end of the 
// locks used by the MIB handler.
//

#define ICB_LIST                    NUM_CACHE
#define PROTOCOL_CB_LIST            ICB_LIST            + 1
#define BINDING_LIST                PROTOCOL_CB_LIST    + 1
#define BOUNDARY_TABLE              BINDING_LIST        + 1
#define MZAP_TIMER                  BOUNDARY_TABLE      + 1
#define ZBR_LIST                    MZAP_TIMER          + 1
#define ZLE_LIST                    ZBR_LIST            + 1
#define ZAM_CACHE                   ZLE_LIST            + 1
#define STACK_ROUTE_LIST            ZAM_CACHE           + 1

//
// Number of locks
//

#define NUM_LOCKS                   STACK_ROUTE_LIST    + 1

#define IPADDRCACHE_TIMEOUT         1000
#define IPFORWARDCACHE_TIMEOUT      1000
#define IPNETCACHE_TIMEOUT          1000
#define TCPCACHE_TIMEOUT            1000   
#define UDPCACHE_TIMEOUT            1000   
#define ARPENTCACHE_TIMEOUT         300 * IPNETCACHE_TIMEOUT

#define SPILLOVER                   5
#define MAX_DIFF                    5

//
// All ACCESS_XXX > ACCESS_GET_NEXT are SETS
// All ACCESS_XXX which have bit0 set require an EXACT MATCH
//

#define ACCESS_GET                  1 
#define ACCESS_GET_FIRST            2
#define ACCESS_GET_NEXT             4
#define ACCESS_SET                  5
#define ACCESS_CREATE_ENTRY         7
#define ACCESS_DELETE_ENTRY         9

#define EXACT_MATCH(X)              ((X) & 0x00000001)

#ifdef DEADLOCK_DEBUG

extern PBYTE   g_pszLockNames[];

#define EXIT_LOCK(id) {                                     \
    Trace1(LOCK,"Exit lock %s",g_pszLockNames[id]);         \
    RtlReleaseResource(&(g_LockTable[(id)]));               \
    Trace1(LOCK,"Exited lock %s",g_pszLockNames[id]);       \
}

#define READER_TO_WRITER(id) {                              \
    Trace1(LOCK,"Reader To Writer %s",g_pszLockNames[id]);  \
    RtlConvertSharedToExclusive(&(g_LockTable[(id)]));      \
    Trace1(LOCK,"Promoted for %s",g_pszLockNames[id]);      \
}

#define ENTER_READER(id) {                                  \
    Trace1(LOCK,"Entering Reader %s",g_pszLockNames[id]);   \
    RtlAcquireResourceShared(&(g_LockTable[(id)]),TRUE);    \
    Trace1(LOCK,"Entered %s",g_pszLockNames[id]);           \
}

#define ENTER_WRITER(id) {                                  \
    Trace1(LOCK,"Entering Writer %s",g_pszLockNames[id]);   \
    RtlAcquireResourceExclusive(&(g_LockTable[(id)]),TRUE); \
    Trace1(LOCK,"Entered %s",g_pszLockNames[id]);           \
}

#define WRITER_TO_READER(id) {                              \
    Trace1(LOCK,"Writer To Reader %s",g_pszLockNames[id]);  \
    RtlConvertExclusiveToShared(&(g_LockTable[(id)]));      \
    Trace1(LOCK,"Demoted for %s",g_pszLockNames[id]);       \
}

#else   // DEADLOCK_DEBUG

#define EXIT_LOCK(id)           RtlReleaseResource(&(g_LockTable[(id)]))
#define READER_TO_WRITER(id)    RtlConvertSharedToExclusive(&(g_LockTable[(id)]))
#define ENTER_READER(id)        RtlAcquireResourceShared(&(g_LockTable[(id)]),TRUE)
#define ENTER_WRITER(id)        RtlAcquireResourceExclusive(&(g_LockTable[(id)]),TRUE)
#define WRITER_TO_READER(id)    RtlConvertExclusiveToShared(&(g_LockTable[(id)]))

#endif  // DEADLOCK_DEBUG


#if DBG

#define IpRtAssert(exp){                                               \
    if(!(exp))                                                          \
    {                                                                   \
        TracePrintf(TraceHandle,                                        \
                    "Assertion failed in %s : %d \n",__FILE__,__LINE__);\
        RouterAssert(#exp,__FILE__,__LINE__,NULL);                      \
    }                                                                   \
}

#else

#define IpRtAssert(exp) 

#endif

//
// Registry defines
//

#define REGISTRY_ENABLE_DHCP           "EnableDHCP"
#define REGISTRY_IPADDRESS             "IPAddress"
#define REGISTRY_SUBNETMASK            "SubnetMask"
#define REGISTRY_DHCPSUBNETMASK        "DhcpSubnetMask"
#define REGISTRY_DHCPIPADDRESS         "DhcpIPAddress"
#define REGISTRY_AUTOCONFIGSUBNETMASK  "IPAutoconfigurationMask"
#define REGISTRY_AUTOCONFIGIPADDRESS   "IPAutoconfigurationAddress"
#define REG_KEY_TCPIP_INTERFACES        \
    "System\\CurrentControlSet\\Services\\TCPIP\\Parameters\\Interfaces"

#define net_long(x) (((((ulong)(x))&0xffL)<<24) | \
                     ((((ulong)(x))&0xff00L)<<8) | \
                     ((((ulong)(x))&0xff0000L)>>8) | \
                     ((((ulong)(x))&0xff000000L)>>24))

#define SIZEOF_ROUTEINFO(X)     ((X) * sizeof (MIB_IPFORWARDROW))
#define MAX_ROUTES_IN_BUFFER(X) ((X) / sizeof (MIB_IPFORWARDROW))

#define PRINT_IPADDR(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

//
// VOID
// PrintRoute(IPMultihopRouteEntry pRoute)
//

#define PrintRoute(ID,p)                                                    \
{                                                                           \
    ULONG   _i;                                                             \
    Trace4(ID,"%d.%d.%d.%d/%d.%d.%d.%d Proto: %d Metric %d",                \
           PRINT_IPADDR((p)->imre_routeinfo.ire_dest),                      \
           PRINT_IPADDR((p)->imre_routeinfo.ire_mask),                      \
           (p)->imre_routeinfo.ire_proto, (p)->imre_routeinfo.ire_metric1); \
    Trace4(ID,"Via %d.%d.%d.%d/0x%x Type %d Context 0x%x",                  \
           PRINT_IPADDR((p)->imre_routeinfo.ire_nexthop),                   \
           (p)->imre_routeinfo.ire_index,                                   \
           (p)->imre_routeinfo.ire_type,                                    \
           (p)->imre_routeinfo.ire_context);                                \
    for(_i = 1; _i < (p)->imre_numnexthops; i++) {                          \
        Trace4(ID,"Via %d.%d.%d.%d/0x%x Type %d Context 0x%x\n",            \
               PRINT_IPADDR((p)->imre_morenexthops[_i].ine_nexthop),        \
               (p)->imre_morenexthops[_i].ine_ifindex,                      \
               (p)->imre_morenexthops[_i].ine_iretype,                      \
               (p)->imre_morenexthops[_i].ine_context);}                    \
}

//
// System Unit is in 100s of NanoSecs = 1 * 10^7
//

#define SYS_UNITS_IN_1_SEC 10000000

#define SecsToSysUnits(X)  RtlEnlargedIntegerMultiply((X),SYS_UNITS_IN_1_SEC)


#endif // __DEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\demand.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\routing\ip\rtrmgr\demand.c

Abstract:

    Handles demand dial/connection events from WANARP driver.

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/

#include "allinc.h"

DWORD
InitializeWanArp(
    VOID
    )

/*++

Routine Description:

    Creates a handle to WANARP and posts an IRP for notification
    Since the IRP is completed asynchrnously and uses DemandDialEvent for
    notification, the event must have already been created

Arguments:

    None

Return Value:

    NO_ERROR or some error code

--*/

{
    DWORD       dwResult;
    ULONG       ulSize, ulCount, i;
    NTSTATUS    Status;

    IO_STATUS_BLOCK     IoStatusBlock;
    PWANARP_QUEUE_INFO  pQueueInfo;

    TraceEnter("InitializeWanArp");

    g_hWanarpRead = CreateFile(WANARP_DOS_NAME_T,
                               GENERIC_READ,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               FILE_FLAG_OVERLAPPED,
                               NULL);

    if(g_hWanarpRead is INVALID_HANDLE_VALUE)
    {
        g_hWanarpRead  = NULL;

        dwResult = GetLastError();

        Trace1(ERR,
               "InitializeWanArp: Could not open WANARP for read - %d",
               dwResult);

        TraceLeave("InitializeWanArp");

        return dwResult;
    }

    g_hWanarpWrite = CreateFile(WANARP_DOS_NAME_T,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_OVERLAPPED,
                                NULL);

    if(g_hWanarpWrite is INVALID_HANDLE_VALUE)
    {
        CloseHandle(g_hWanarpRead);

        g_hWanarpRead  = NULL;
        g_hWanarpWrite = NULL;

        dwResult = GetLastError();

        Trace1(ERR,
               "InitializeWanArp: Could not open WANARP for write - %d",
               dwResult);

        TraceLeave("InitializeWanArp");

        return dwResult;
    }

    //
    // Get the number of call out interfaces and start queueing notifications
    //

    ulCount = 5;
    i       = 0;

    while(i < 3)
    {
        ulSize  = FIELD_OFFSET(WANARP_QUEUE_INFO, rgIfInfo) + 
                  (ulCount * sizeof(WANARP_IF_INFO));

        pQueueInfo = HeapAlloc(IPRouterHeap,
                               0,
                               ulSize);

        if(pQueueInfo is NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;

            break;
        }

        pQueueInfo->fQueue = 1;

        Status = NtDeviceIoControlFile(g_hWanarpWrite,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &IoStatusBlock,
                                       IOCTL_WANARP_QUEUE,
                                       pQueueInfo,
                                       sizeof(WANARP_QUEUE_INFO),
                                       pQueueInfo,
                                       ulSize);

        if(Status isnot STATUS_SUCCESS)
        {
            if(Status is STATUS_MORE_ENTRIES)
            {
                IpRtAssert(ulCount > pQueueInfo->ulNumCallout);

                i++;

                ulCount = pQueueInfo->ulNumCallout + (i * 5);

                HeapFree(IPRouterHeap,
                         0,
                         pQueueInfo);

                pQueueInfo = NULL;

                //
                // Go to the top of while()
                //
                
                continue;

            }
            else
            {
                HeapFree(IPRouterHeap,
                         0,
                         pQueueInfo);

                pQueueInfo = NULL;

                break;
            }
        }
        else
        {
            break;
        }
    }
   
    if(Status isnot STATUS_SUCCESS)
    {
        //
        // Close the device and return failure
        //

        CloseHandle(g_hWanarpRead);
        CloseHandle(g_hWanarpWrite);

        g_hWanarpRead  = NULL;
        g_hWanarpWrite = NULL;

        return Status;
    }
 
    //
    // Create any dial out interfaces
    //

    for(i = 0; i < pQueueInfo->ulNumCallout; i++)
    {
        UNICODE_STRING  usTempName;
        PICB            pIcb;

        dwResult = RtlStringFromGUID(&(pQueueInfo->rgIfInfo[i].InterfaceGuid),
                                     &usTempName);

        if(dwResult isnot STATUS_SUCCESS)
        {
            continue;
        }

        //
        // RtlString... returns a NULL terminated buffer
        //

        dwResult = 
            CreateDialOutInterface(usTempName.Buffer,
                                   pQueueInfo->rgIfInfo[i].dwAdapterIndex,
                                   pQueueInfo->rgIfInfo[i].dwLocalAddr,
                                   pQueueInfo->rgIfInfo[i].dwLocalMask,
                                   pQueueInfo->rgIfInfo[i].dwRemoteAddr,
                                   &pIcb);
    }


    HeapFree(IPRouterHeap,
             0,
             pQueueInfo);

    //
    // Post an irp for demand dial notifications.
    //

    PostIoctlForDemandDialNotification() ;

    TraceLeave("InitializeWanArp");

    return NO_ERROR ;
}

VOID
CloseWanArp(
    VOID
    )
{
    NTSTATUS    Status;

    IO_STATUS_BLOCK     IoStatusBlock;
    WANARP_QUEUE_INFO   QueueInfo;

    TraceEnter("CloseWanArp");

    if(g_hWanarpRead)
    {
        CloseHandle(g_hWanarpRead);

        g_hWanarpRead = NULL;
    }

    if(g_hWanarpWrite)
    {
        QueueInfo.fQueue = 0;

        Status = NtDeviceIoControlFile(g_hWanarpWrite,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &IoStatusBlock,
                                       IOCTL_WANARP_QUEUE,
                                       &QueueInfo,
                                       sizeof(WANARP_QUEUE_INFO),
                                       &QueueInfo,
                                       sizeof(WANARP_QUEUE_INFO));

        if(Status isnot STATUS_SUCCESS)
        {
        }

        CloseHandle(g_hWanarpWrite);

        g_hWanarpWrite = NULL;
    }

    TraceLeave("CloseWanArp");
}

DWORD
HandleDemandDialEvent(
    VOID
    )

/*++

Routine Description:

    Called by the main thread whenever a demand dial event is received
    We mereley dispatch it to the right handler
    
Locks:

    None

Arguments:

    None

Return Value:

    None    

--*/

{
    PICB            picb;
    DWORD           dwResult;
    DWORD           Status, NumBytes;
    BOOL            bPost;
    
    //
    // drain all demand dial events queued up in WANARP
    //

    TraceEnter("HandleDemandDialEvent");

    Status = GetOverlappedResult(g_hWanarpWrite, &WANARPOverlapped, &NumBytes, FALSE);
    if (Status == FALSE || NumBytes<sizeof(WANARP_NOTIFICATION))
    {
        if (NumBytes < sizeof(WANARP_NOTIFICATION))
        {
            Trace1(ENTER, "HandleDemandDialEvent. Error. Returned IRP "
                    "small:%d", NumBytes);
            return ERROR_CAN_NOT_COMPLETE;
        }

        Status = GetLastError();

        if (Status == ERROR_OPERATION_ABORTED)
        {
            //
            // cancel IO called for some reason. post another IRP.
            //
            PostIoctlForDemandDialNotification();
            TraceLeave("HandleDemandDialEvent");
        }
        else if (Status == ERROR_FILE_NOT_FOUND)
        {
            //
            // wanarp handle closed
            //
            TraceLeave("HandleDemandDialEvent. IRP cancelled. Wanarp device closed");
        }
        else
        {
            //
            // some other error. do not post any more IRPs
            //
            Trace1(ENTER, "Leaving HandleDemandDialEvent. Error in completed "
                            "IRP:%d", Status);
        }

        return Status;
    }
    

    bPost = TRUE;
    
    //
    // Since, potentially, this can cause stuff to be written in the ICB,
    // we take lock as a WRITER
    //
    
    // *** Exclusion Begin ***
    ENTER_WRITER(ICB_LIST);

    EnterCriticalSection(&RouterStateLock);

    if(RouterState.IRS_State isnot RTR_STATE_RUNNING)
    {
        if(wnWanarpMsg.ddeEvent isnot DDE_INTERFACE_DISCONNECTED)
        {
            Trace1(IF,
                   "ProcessDemandDialEvent: Shutting down. Ignoring event %d",
                   wnWanarpMsg.ddeEvent);

            LeaveCriticalSection(&RouterStateLock);

            return NO_ERROR;
        }
        else
        {
            bPost = FALSE;
        }
    }

    LeaveCriticalSection(&RouterStateLock);

    picb = InterfaceLookupByICBSeqNumber( wnWanarpMsg.dwUserIfIndex );

    if ((wnWanarpMsg.ddeEvent is DDE_CONNECT_INTERFACE) or
        (wnWanarpMsg.ddeEvent is DDE_INTERFACE_CONNECTED) or
        (wnWanarpMsg.ddeEvent is DDE_INTERFACE_DISCONNECTED))
    {
        IpRtAssert(picb);
        
        if (picb isnot NULL)
        {
            switch(wnWanarpMsg.ddeEvent)
            {
                case DDE_CONNECT_INTERFACE:
                {
                    HandleConnectionRequest(picb);

                    break ;
                }

                case DDE_INTERFACE_CONNECTED:
                {
                    HandleConnectionNotification(picb);

                    break ;
                }
                
                case DDE_INTERFACE_DISCONNECTED:
                {
                    HandleDisconnectionNotification(picb);
                    
                    break ;
                }
                
                default:
                {
                    Trace1(ERR,
                           "ProcessDemandDialEvent: Illegal event %d from WanArp",
                           wnWanarpMsg.ddeEvent);
                    
                    break;
                }
            }
        }

        else
        {
            Trace2(
                ANY, "Event %d, could not find interface with ICB %d",
                wnWanarpMsg.ddeEvent, wnWanarpMsg.dwUserIfIndex
                );
        }
    }

    else
    {
        switch(wnWanarpMsg.ddeEvent)
        {
            case DDE_CALLOUT_LINKUP:
            {
                HandleDialOutLinkUp();

                break ;
            }

            case DDE_CALLOUT_LINKDOWN:
            {
                HandleDialOutLinkDown();

                break ;
            }

            default:
            {
                Trace1(ERR,
                       "ProcessDemandDialEvent: Illegal event %d from WanArp",
                       wnWanarpMsg.ddeEvent);
                
                break;
            }
        }
    }

    
    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);

    if(bPost)
    {
        PostIoctlForDemandDialNotification();
    }
    
    TraceLeave("HandleDemandDialEvent");
    
    return NO_ERROR;
}

VOID
HandleConnectionRequest(
    PICB    picb
    )

/*++

Routine Description:

    Called when we get a connection request from WANARP.

Locks:

    ICB_LIST lock held as WRITER. This function releases the lock before 
    calling ConnectInterface() and takes the lock again.

    Note: you need to get the picb entry again after acquiring the lock. 
    Remember to have the lock before you return from this function.

Arguments:

    None

Return Value:

    None    

--*/

{
    BOOL        bRet;
    HANDLE      hDim;
    DWORD       dwResult;
    NTSTATUS    nStatus;
    DWORD       dwPicbSeqNumber;
    
    Trace2(IF,
           "HandleConnectionRequest: Connection request for %S, %d",
           picb->pwszName, picb->dwSeqNumber);

    if(picb->dwOperationalState is CONNECTED)
    {
        //
        // Really weird. Connection attempt for an i/f that
        // WANARP knows is already connected
        //

        Trace2(IF,
               "HandleConnectionRequest: Connection request for %S but %S is already UP",
               picb->pwszName, picb->pwszName);

        return;
    }

    bRet = FALSE;
    
    do
    {
        dwResult = ProcessPacketFromWanArp(picb);

        if(dwResult isnot NO_ERROR)
        {
            //
            // Demand dial filter rules are to drop this packet
            //

            break;
        }
        
        if ((picb->dwAdminState is IF_ADMIN_STATUS_DOWN) or
            (picb->dwOperationalState is UNREACHABLE))
        {
            Trace3(IF,
                   "HandleConnectionRequest: %S has admin state %d and operational state %d. Failing connection request",
                   picb->pwszName,
                   picb->dwAdminState,
                   picb->dwOperationalState);
            
            break;
        }

#if DBG

        if(picb->dwOperationalState is CONNECTING)
        {
            Trace2(IF,
                   "HandleConnectionRequest: RACE CONDITION %S is connecting. Notifications %d",
                   picb->pwszName,
                   picb->fConnectionFlags);
        }
        
#endif
                
        Trace1(DEMAND, "Calling DIM to connect %S",
               picb->pwszName);
        
        //
        // Call DIM to make the connection. Let go of the ICB lock
        //

        hDim = picb->hDIMHandle;

        dwPicbSeqNumber = picb->dwSeqNumber;

        EXIT_LOCK(ICB_LIST);
        
        dwResult = (ConnectInterface)(hDim,
                                      PID_IP);
        
        ENTER_WRITER(ICB_LIST);

        //
        // get the picb again after reacquiring the lock.
        // if Null break and return from this function
        //
        
        picb = InterfaceLookupByICBSeqNumber( dwPicbSeqNumber );
        if (picb == NULL)
        {
            break;
        }

        if(dwResult isnot NO_ERROR)
        {
            if(dwResult is PENDING)
            {
                //
                // We dont clear notification flags because there may be a
                // race condition and we may have already gotten
                // InterfaceConnected() from DIM
                //
                        
                Trace1(DEMAND,
                       "HandleConnectionRequest: Conn attempt for %S pending",
                       picb->pwszName);
            }
            else
            {
                break;
            }
        }
        
        //
        // So bRet is TRUE if DIM returned NO_ERROR or PENDING
        //
        
        bRet = TRUE;
        
    }while(FALSE);
    

    if (picb == NULL)
    {
        return;
    }
    
    if(!bRet)
    {
        nStatus = NotifyWanarpOfFailure(picb);
        
        if((nStatus isnot STATUS_PENDING) and
           (nStatus isnot STATUS_SUCCESS))
        {
            Trace2(ERR,
                   "HandleConnectionRequest: %X for connection failed for %S",
                   nStatus,
                   picb->pwszName);
        }
                        
        //
        // If it was connecting, then the stack has set the 
        // interface context to something other than 0xffffffff. 
        // Hence he wont dial out on that route We need to change 
        // the context in the stack back to invalid so that new
        // packets cause the demand dial 
        //
        
        ChangeAdapterIndexForDodRoutes(picb->dwIfIndex);
        
    }
    else
    {
        picb->dwOperationalState = CONNECTING;
    }
}

VOID
HandleConnectionNotification(
    PICB    picb
    )

/*++

Routine Description:

    Called when WANARP informs us that an interface is connected

Locks:

    None

Arguments:

    None

Return Value:

    None    

--*/

{
    PADAPTER_INFO   pBindNode;

    //
    // Plug in the Adapter info we get from the LINE_UP indication.
    // There is only one address for a WAN interface
    //

    ENTER_WRITER(BINDING_LIST);
   
    picb->bBound            = TRUE; 
    picb->dwNumAddresses    = wnWanarpMsg.dwLocalAddr?1:0;
    
    IpRtAssert(picb->dwIfIndex is wnWanarpMsg.dwAdapterIndex);

    if(picb->dwNumAddresses)
    {
        picb->pibBindings[0].dwAddress  = wnWanarpMsg.dwLocalAddr;
        picb->pibBindings[0].dwMask     = wnWanarpMsg.dwLocalMask;

        IpRtAssert(picb->pibBindings[0].dwMask is 0xFFFFFFFF);
    }
    else
    {
        picb->pibBindings[0].dwAddress  = 0;
        picb->pibBindings[0].dwMask     = 0;
    }
    
    if(picb->ritType is ROUTER_IF_TYPE_FULL_ROUTER)
    {
        picb->dwRemoteAddress   = wnWanarpMsg.dwRemoteAddr;
    }
    else
    {
        picb->dwRemoteAddress   = 0;
    } 

    Trace4(IF,
           "HandleConnNotif: Connection notification for %S. Local %d.%d.%d.%d. Remote %d.%d.%d.%d",
           picb->pwszName,
           PRINT_IPADDR(picb->pibBindings[0].dwAddress),
           PRINT_IPADDR(picb->dwRemoteAddress),
           picb->dwSeqNumber);

    //
    // For wan interfaces we always have a binding struct in the hash
    // table. So retrieve that
    //
    
    pBindNode = GetInterfaceBinding(picb->dwIfIndex);
    
    if(!pBindNode)
    {
        Trace1(ERR,
               "HandleConnNotif: Binding not found for %S",
               picb->pwszName);
        
        IpRtAssert(FALSE);
                
        //
        // Something really bad happened and we didnt have a
        // bind block for the interface
        //
        
        AddBinding(picb);
    }
    else
    {
        //
        // Good a binding was found. Assert that it is ours
        // and then update it
        //
        
        IpRtAssert(pBindNode->dwIfIndex is picb->dwIfIndex);
        IpRtAssert(pBindNode->pInterfaceCB is picb);
       
        pBindNode->bBound           = TRUE; 
        pBindNode->dwNumAddresses   = picb->dwNumAddresses;
        pBindNode->dwRemoteAddress  = picb->dwRemoteAddress ;
        
        //
        // struct copy out the address and mask
        //
        
        pBindNode->rgibBinding[0]   = picb->pibBindings[0];

        //
        // We dont take the IP_ADDR_TABLE lock here because we have the
        // ICB lock. During SNMP get we first take the addr lock then
        // the icb lock. So we cant do the opposite here else we will
        // deadlock. This may cause inconsistent information for one
        // request, but we can live with that
        //

        g_LastUpdateTable[IPADDRCACHE] = 0;

    }
    
    EXIT_LOCK(BINDING_LIST);
    
    if(picb->dwOperationalState is UNREACHABLE)
    {
        //
        // going from unreachable to connecting
        //
        
        WanInterfaceDownToInactive(picb);
    }
    
    if(picb->dwOperationalState isnot CONNECTING)
    {
        //
        // We can get a LinkUp without getting a ConnectionRequest
        // This is the case when a user explicitly brings up a 
        // connection.
        //
        
        picb->dwOperationalState = CONNECTING;
    }
    
    SetNdiswanNotification(picb);
    
    if(HaveAllNotificationsBeenReceived(picb))
    {
        picb->dwOperationalState = CONNECTED ;
        
        WanInterfaceInactiveToUp(picb) ;
    }
}

VOID
HandleDisconnectionNotification(
    PICB    picb
    )

/*++

Routine Description:

    Handles a disconnection notification from WANARP
    If the interface was connected, we make it inactive
    We remove and bindings on the interface. This removal doesnt free the
    bindings, only set the state to unbound
    If the interface was marked for deletion, we go ahead and delete the
    interface
    
Locks:

    None

Arguments:

    None

Return Value:

    None    

--*/

{
    Trace2(IF,
           "HandleDisconnectionNotif: Disconnection notification for %S %d",
           picb->pwszName, picb->dwSeqNumber);
    
    
    if(picb->dwOperationalState is CONNECTED)
    {
        //
        // We would have called InactiveToUp
        //
        
        WanInterfaceUpToInactive(picb,
                                 FALSE);
    }   
    else    
    {
        //
        // We have only set the addresses, clear those out
        //
        
        DeAllocateBindings(picb);
    }
    
    picb->dwOperationalState = DISCONNECTED ;
    
    g_LastUpdateTable[IPADDRCACHE] = 0;
    
    if(IsInterfaceMarkedForDeletion(picb))
    {
        RemoveInterfaceFromLists(picb);

        DeleteSingleInterface(picb);
       
        HeapFree(IPRouterHeap, 0, picb);
    }
    else
    {
        ClearNotificationFlags(picb);
    }
}

DWORD
HandleDialOutLinkUp(
    VOID
    )

/*++

Routine Description:

    Handles the notification from wanarp that we have a new dial out interface

Locks:

    ICB list lock as writer

Arguments:

    None

Return Value:

    NO_ERROR

--*/

{
    DWORD   dwResult;
    PICB    pNewIcb;

    INTERFACE_ROUTE_INFO    rifRoute;

    Trace4(IF,
           "DialOutLinkUp: Connection notification for 0x%x %d.%d.%d.%d/%d.%d.%d.%d %d.%d.%d.%d",
           wnWanarpMsg.dwAdapterIndex,
           PRINT_IPADDR(wnWanarpMsg.dwLocalAddr),
           PRINT_IPADDR(wnWanarpMsg.dwLocalMask),
           PRINT_IPADDR(wnWanarpMsg.dwRemoteAddr));
            
    dwResult =  CreateDialOutInterface(wnWanarpMsg.rgwcName,
                                       wnWanarpMsg.dwAdapterIndex,
                                       wnWanarpMsg.dwLocalAddr,
                                       wnWanarpMsg.dwLocalMask,
                                       wnWanarpMsg.dwRemoteAddr,
                                       &pNewIcb);

    if(dwResult isnot NO_ERROR)
    {
        return dwResult;
    }

    AddAutomaticRoutes(pNewIcb,
                       wnWanarpMsg.dwLocalAddr,
                       wnWanarpMsg.dwLocalMask);

#if 0
    //
    // Add the route to the server
    //

    if(pNewIcb->dwRemoteAddress isnot INVALID_IP_ADDRESS)
    {
        rifRoute.dwRtInfoMask          = HOST_ROUTE_MASK;
        rifRoute.dwRtInfoNextHop       = pNewIcb->dwRemoteAddress;
        rifRoute.dwRtInfoDest          = pNewIcb->dwRemoteAddress;
        rifRoute.dwRtInfoIfIndex       = pNewIcb->dwIfIndex;
        rifRoute.dwRtInfoMetric1       = 1;
        rifRoute.dwRtInfoMetric2       = 0;
        rifRoute.dwRtInfoMetric3       = 0;
        rifRoute.dwRtInfoPreference    = 
            ComputeRouteMetric(MIB_IPPROTO_NETMGMT);
        rifRoute.dwRtInfoViewSet       = RTM_VIEW_MASK_UCAST |
                                          RTM_VIEW_MASK_MCAST; // XXX config
        rifRoute.dwRtInfoType          = MIB_IPROUTE_TYPE_DIRECT;
        rifRoute.dwRtInfoProto         = MIB_IPPROTO_NETMGMT;
        rifRoute.dwRtInfoAge           = 0;
        rifRoute.dwRtInfoNextHopAS     = 0;
        rifRoute.dwRtInfoPolicy        = 0;

        dwResult = AddSingleRoute(pNewIcb->dwIfIndex,
                                  &rifRoute,
                                  pNewIcb->pibBindings[0].dwMask,
                                  0,        // RTM_ROUTE_INFO::Flags
                                  TRUE,     // Valid route
                                  TRUE,
                                  TRUE,
                                  NULL);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "HandleDialOutLinkUp: Couldnt add server route for 0x%x",
                   pNewIcb->dwIfIndex);
        }
    }

    if(wnWanarpMsg.fDefaultRoute)
    {
        INTERFACE_ROUTE_INFO    rifRoute;

        ChangeDefaultRouteMetrics(TRUE);

        pNewIcb->bChangedMetrics = TRUE;

        //
        // Add route to def gateway
        //

        rifRoute.dwRtInfoDest          = 0;
        rifRoute.dwRtInfoMask          = 0;
        rifRoute.dwRtInfoNextHop       = wnWanarpMsg.dwLocalAddr;
        rifRoute.dwRtInfoIfIndex       = wnWanarpMsg.dwAdapterIndex;
        rifRoute.dwRtInfoMetric1       = 1;
        rifRoute.dwRtInfoMetric2       = 0;
        rifRoute.dwRtInfoMetric3       = 0;
        rifRoute.dwRtInfoPreference    = 
            ComputeRouteMetric(PROTO_IP_LOCAL);
        rifRoute.dwRtInfoViewSet       = RTM_VIEW_MASK_UCAST |
                                          RTM_VIEW_MASK_MCAST; // XXX config

        rifRoute.dwRtInfoType          = MIB_IPROUTE_TYPE_DIRECT;
        rifRoute.dwRtInfoProto         = PROTO_IP_NETMGMT;
        rifRoute.dwRtInfoAge           = INFINITE;
        rifRoute.dwRtInfoNextHopAS     = 0;
        rifRoute.dwRtInfoPolicy        = 0;

        dwResult = AddSingleRoute(wnWanarpMsg.dwAdapterIndex,
                                  &rifRoute,
                                  ALL_ONES_MASK,
                                  0,        // RTM_ROUTE_INFO::Flags
                                  TRUE,
                                  FALSE,
                                  FALSE,
                                  NULL);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "HandleDialOutLinkUp: Couldnt add default route for 0x%x",
                   wnWanarpMsg.dwAdapterIndex);
        }
    }
    else
    {
        DWORD   dwAddr, dwMask;

        dwMask  = GetClassMask(wnWanarpMsg.dwLocalAddr);
        dwAddr  = wnWanarpMsg.dwLocalAddr & dwMask;

        //
        // Add route to class subnet
        //

        rifRoute.dwRtInfoDest          = dwAddr;
        rifRoute.dwRtInfoMask          = dwMask;
        rifRoute.dwRtInfoNextHop       = wnWanarpMsg.dwLocalAddr;
        rifRoute.dwRtInfoIfIndex       = wnWanarpMsg.dwAdapterIndex;
        rifRoute.dwRtInfoMetric1       = 1;
        rifRoute.dwRtInfoMetric2       = 0;
        rifRoute.dwRtInfoMetric3       = 0;
        rifRoute.dwRtInfoPreference    = ComputeRouteMetric(PROTO_IP_LOCAL);
        rifRoute.dwRtInfoViewSet       = RTM_VIEW_MASK_UCAST |
                                          RTM_VIEW_MASK_MCAST; // XXX config
        rifRoute.dwRtInfoType          = MIB_IPROUTE_TYPE_DIRECT;
        rifRoute.dwRtInfoProto         = PROTO_IP_LOCAL;
        rifRoute.dwRtInfoAge           = INFINITE;
        rifRoute.dwRtInfoNextHopAS     = 0;
        rifRoute.dwRtInfoPolicy        = 0;

        dwResult = AddSingleRoute(wnWanarpMsg.dwAdapterIndex,
                                  &rifRoute,
                                  ALL_ONES_MASK,
                                  0,        // RTM_ROUTE_INFO::Flags
                                  TRUE,
                                  FALSE,
                                  FALSE,
                                  NULL);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "HandleDialOutLinkUp: Couldnt add subnet route for 0x%x",
                   wnWanarpMsg.dwAdapterIndex);
        }
    }
#endif

    return NO_ERROR;
}

DWORD
CreateDialOutInterface(
    IN  PWCHAR  pwszIfName,
    IN  DWORD   dwIfIndex,
    IN  DWORD   dwLocalAddr,
    IN  DWORD   dwLocalMask,
    IN  DWORD   dwRemoteAddr,
    OUT ICB     **ppIcb
    )

/*++

Routine Description:

    Creates an ICB for a dial out interface
    We check to see that the interface doesnt already exist and if so, we
    add the interface to our list using the index and name supplied by
    wanarp.

Locks:

    ICB list lock as writer

Arguments:


Return Value:

    NO_ERROR

--*/

{
    PICB            pNewIcb;
    PADAPTER_INFO   pBindNode;
    PICB_BINDING    pBinding;

#if DBG

    pNewIcb = InterfaceLookupByIfIndex(dwIfIndex);

    IpRtAssert(pNewIcb is NULL);

#endif // DBG

    pNewIcb = CreateIcb(pwszIfName,
                        NULL,
                        ROUTER_IF_TYPE_DIALOUT,
                        IF_ADMIN_STATUS_UP,
                        dwIfIndex);

    if(pNewIcb is NULL)
    {
        *ppIcb = NULL;

        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Set up the bindings
    //

    pNewIcb->bBound            = TRUE;
    pNewIcb->dwNumAddresses    = dwLocalAddr ? 1 : 0;

    pNewIcb->dwRemoteAddress   = dwRemoteAddr;

    IpRtAssert(pNewIcb->dwIfIndex is dwIfIndex);

    if(pNewIcb->dwNumAddresses)
    {
        pNewIcb->pibBindings[0].dwAddress  = dwLocalAddr;
        pNewIcb->pibBindings[0].dwMask     = dwLocalMask;
    }
    else
    {
        pNewIcb->pibBindings[0].dwAddress  = 0;
        pNewIcb->pibBindings[0].dwMask     = 0;
    }

    ENTER_WRITER(BINDING_LIST);

    pBindNode = GetInterfaceBinding(pNewIcb->dwIfIndex);

    if(pBindNode is NULL)
    {
        IpRtAssert(FALSE);

        AddBinding(pNewIcb);
    }
    else
    {
        IpRtAssert(pBindNode->dwIfIndex is pNewIcb->dwIfIndex);
        IpRtAssert(pBindNode->pInterfaceCB is pNewIcb);

        pBindNode->bBound           = TRUE;
        pBindNode->dwNumAddresses   = pNewIcb->dwNumAddresses;
        pBindNode->dwRemoteAddress  = pNewIcb->dwRemoteAddress;

        //
        // struct copy out the address and mask
        //

        pBindNode->rgibBinding[0]   = pNewIcb->pibBindings[0];
    }

    EXIT_LOCK(BINDING_LIST);

    //
    // Insert pNewIcb in interface list and hash table
    // This increments the interface count and sets the seq number
    //

    InsertInterfaceInLists(pNewIcb);

    *ppIcb = pNewIcb;

    //
    // Update the address cache
    //

    g_LastUpdateTable[IPADDRCACHE] = 0;

    return NO_ERROR;
}

DWORD
HandleDialOutLinkDown(
    VOID
    )

/*++

Routine Description:

    Handles the linkdown notification for a dial out interface.

Locks:

    ICB list lock as writer

Arguments:

    None

Return Value:

    NO_ERROR

--*/

{
    PICB    pIcb;

    Trace1(IF,
           "DialOutLinkDown: Disconnection notification for %d",
           wnWanarpMsg.dwAdapterIndex);
            
    pIcb = InterfaceLookupByIfIndex(wnWanarpMsg.dwAdapterIndex);

    if(pIcb is NULL)
    {
        IpRtAssert(FALSE);

        return NO_ERROR;
    }

    RemoveInterfaceFromLists(pIcb);

    //
    // This will delete the default route if there was one
    //

    DeleteSingleInterface(pIcb);

    if(pIcb->bChangedMetrics)
    {
        ChangeDefaultRouteMetrics(FALSE);
    }

    HeapFree(IPRouterHeap,
             0,
             pIcb);

    return NO_ERROR;
}

NTSTATUS
NotifyWanarpOfFailure(
    PICB    picb
    )

/*++

Routine Description:

    Sends an IOCTL_WANARP_CONNECT_FAILED to WANARP

Locks:

    None

Arguments:

    picb    ICB of the interface on whom the connection failed

Return Value:

    None    

--*/

{
    NTSTATUS        Status;
    IO_STATUS_BLOCK IoStatusBlock;

    WANARP_CONNECT_FAILED_INFO  ConnectInfo;
 
    ConnectInfo.dwUserIfIndex = picb->dwSeqNumber;
 
    Status = NtDeviceIoControlFile(g_hWanarpWrite,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_WANARP_CONNECT_FAILED,
                                   &ConnectInfo,
                                   sizeof(WANARP_CONNECT_FAILED_INFO),
                                   NULL,
                                   0);

    IpRtAssert(Status isnot STATUS_PENDING);

    return Status;
}

DWORD
ProcessPacketFromWanArp(
    PICB    picb
    )

/*++
  
Routine Description:

    Filters the packet which is causing a demand dial connection. If the
    packet is valid, logs the packet

Locks:

    ICB_LIST held as READER

Arguments:

    picb    ICB of interface to dial
    
Return Value:

    NO_ERROR            Dial out
    ERROR_INVALID_DATA  Dont dial out
    
--*/

{
    CHAR    pszSrc[20], pszDest[20], pszProto[5], pszLength[32]; 
    CHAR    pszName[MAX_INTERFACE_NAME_LEN + 1];
    DWORD   dwSize, dwResult;
    BYTE    rgbyPacket[sizeof(IP_HEADER) + MAX_PACKET_COPY_SIZE];
    PBYTE   pbyData;
    
    PFFORWARD_ACTION    faAction; 
    PIP_HEADER          pHeader;
    
    TraceEnter("ProcessPacketFromWanArp");

    //
    // Now create a packet
    //

    dwSize = min(wnWanarpMsg.ulPacketLength,
                 MAX_PACKET_COPY_SIZE);

    if(picb->ihDemandFilterInterface isnot INVALID_HANDLE_VALUE)
    {
        IpRtAssert(picb->pDemandFilter);

        //
        // TCP/IP seems to not give us a packet sometimes
        //

        if(!dwSize)
        {
            Trace3(ERR, 
                   "ProcPktFromWanarp: Packet from %d.%d.%d.%d to %d.%d.%d.%d protocol 0x%02x had 0 size!!",
                   PRINT_IPADDR(wnWanarpMsg.dwPacketSrcAddr),
                   PRINT_IPADDR(wnWanarpMsg.dwPacketDestAddr),
                   wnWanarpMsg.byPacketProtocol); 

            TraceLeave("ProcessPacketFromWanArp");

            return ERROR_INVALID_DATA;
        }

        pHeader = (PIP_HEADER)rgbyPacket;

        //
        // Zero out the header
        //
    
        ZeroMemory(rgbyPacket,
                   sizeof(IP_HEADER));
    
        //
        // Set the header with the info we have
        //
    
        pHeader->byVerLen   = 0x45;
        pHeader->byProtocol = wnWanarpMsg.byPacketProtocol;
        pHeader->dwSrc      = wnWanarpMsg.dwPacketSrcAddr;
        pHeader->dwDest     = wnWanarpMsg.dwPacketDestAddr;
        pHeader->wLength    = htons((WORD)(dwSize + sizeof(IP_HEADER)));
    
        //
        // Copy out the data portion
        //
    
        pbyData = rgbyPacket + sizeof(IP_HEADER);
        
        CopyMemory(pbyData,
                   wnWanarpMsg.rgbyPacket,
                   dwSize);
    
        dwResult = PfTestPacket(picb->ihDemandFilterInterface,
                                NULL,
                                dwSize + sizeof(IP_HEADER),
                                rgbyPacket,
                                &faAction);
    
        //
        // If the call succeeded and the action was drop, no need to process
        // futher
        //
    
        if(dwResult is NO_ERROR)
        {
            if(faAction is PF_ACTION_DROP)
            {
                Trace5(DEMAND,
                       "ProcPktFromWanarp: Result %d action %s for packet from %d.%d.%d.%d to %d.%d.%d.%d protocol 0x%02x",
                       dwResult, faAction == PF_ACTION_DROP? "Drop": "RtInfo",
                       PRINT_IPADDR(wnWanarpMsg.dwPacketSrcAddr),
                       PRINT_IPADDR(wnWanarpMsg.dwPacketDestAddr),
                       wnWanarpMsg.byPacketProtocol); 

                TraceLeave("ProcessPacketFromWanarp");
        
                return ERROR_INVALID_DATA;
            }
        }
        else
        {
            //
            // In case of error we fall through and bring the link up
            //

            Trace4(DEMAND,
                   "ProcPktFromWanarp: Result %d for packet from %d.%d.%d.%d to %d.%d.%d.%d protocol 0x%02x",
                   dwResult,
                   PRINT_IPADDR(wnWanarpMsg.dwPacketSrcAddr),
                   PRINT_IPADDR(wnWanarpMsg.dwPacketDestAddr),
                   wnWanarpMsg.byPacketProtocol); 
        }
    }

    strcpy(pszSrc,
           inet_ntoa(*((PIN_ADDR)(&(wnWanarpMsg.dwPacketSrcAddr)))));
    
    strcpy(pszDest,
           inet_ntoa(*((PIN_ADDR)(&(wnWanarpMsg.dwPacketDestAddr)))));
    
    sprintf(pszProto,"%02x",wnWanarpMsg.byPacketProtocol);
    
    WideCharToMultiByte(CP_ACP,
                        0,
                        picb->pwszName,
                        -1,
                        pszName,
                        MAX_INTERFACE_NAME_LEN,
                        NULL,
                        NULL);
    
    pszName[MAX_INTERFACE_NAME_LEN] = '\0';
    
    sprintf(pszLength,"%d",dwSize);
    
    LogWarnData5(DEMAND_DIAL_PACKET,
                 pszSrc,
                 pszDest,
                 pszProto,
                 pszName,
                 pszLength,
                 dwSize,
                 wnWanarpMsg.rgbyPacket);

    TraceLeave("ProcessPacketFromWanarp");

    return NO_ERROR;
}


DWORD
PostIoctlForDemandDialNotification(
    VOID
    )

/*++
  
Routine Description:

    Posts a notification irp with WANARP.
  
Arguments:

    None

Return Value:

--*/

{
    DWORD   bytesrecvd ;
    DWORD   retcode = NO_ERROR;

    TraceEnter("PostIoctlForDemandDialNotification");

    ZeroMemory(&WANARPOverlapped,
               sizeof (OVERLAPPED));

    ZeroMemory(&wnWanarpMsg, sizeof(WANARP_NOTIFICATION));

    WANARPOverlapped.hEvent = g_hDemandDialEvent ;

    if (!DeviceIoControl(g_hWanarpWrite,
                         (DWORD) IOCTL_WANARP_NOTIFICATION,
                         &wnWanarpMsg,
                         sizeof(wnWanarpMsg),
                         &wnWanarpMsg,
                         sizeof(wnWanarpMsg),
                          (LPDWORD) &bytesrecvd,
                          &WANARPOverlapped))
    {
        retcode = GetLastError();
        
        if(retcode isnot ERROR_IO_PENDING)
        {
            Trace1(ERR, 
                   "PostIoctlForDemandDialNotification: Couldnt post irp with WANARP: %d\n",
                   retcode) ;
        }
        else
        {
            Trace0(IF, "PostIoctlForDemandDialNotification: Notification pending in WANARP");

        }
    }

    TraceLeave("PostIoctlForDemandDialNotification");
    
    return retcode ;
}

DWORD
AddInterfaceToWanArp(
    PICB    picb
    )

/*++
  
Routine Description:

    Adds the given interface with WANARP
    Has a side effect of getting an interface index
  
Arguments:

    The ICB of the interface to add

Return Value:

--*/

{
    DWORD               out,dwResult;
    IO_STATUS_BLOCK     IoStatusBlock;
    NTSTATUS            nStatus;
    PADAPTER_INFO       pBindNode;
    
    WANARP_ADD_INTERFACE_INFO   info;

    TraceEnter("AddInterfaceToWanArp");

    Trace1(IF,
           "AddInterfaceToWanArp: Adding %S to WanArp",
           picb->pwszName);
    
    info.dwUserIfIndex  = picb->dwSeqNumber;
    info.dwAdapterIndex = INVALID_IF_INDEX;
    
    if(picb->ritType is ROUTER_IF_TYPE_INTERNAL)
    {
        info.bCallinInterface = TRUE;
             
    }
    else
    {
        info.bCallinInterface = FALSE;
    }
   
    nStatus = NtDeviceIoControlFile(g_hWanarpWrite,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    IOCTL_WANARP_ADD_INTERFACE,
                                    &info,
                                    sizeof(WANARP_ADD_INTERFACE_INFO),
                                    &info,
                                    sizeof(WANARP_ADD_INTERFACE_INFO));
 
    if(nStatus isnot STATUS_SUCCESS) 
    {
        Trace2(ERR,
               "AddInterfaceToWANARP: Status %x adding %S to WanArp",
               nStatus,
               picb->pwszName);

        return RtlNtStatusToDosError(nStatus);
    }

    IpRtAssert(info.dwAdapterIndex isnot 0);
    IpRtAssert(info.dwAdapterIndex isnot INVALID_IF_INDEX);
    
    picb->dwIfIndex = info.dwAdapterIndex;
    
    //
    // If this was the internal interface allocate memory and copy out
    // the name
    //

    if(picb->ritType is ROUTER_IF_TYPE_INTERNAL)
    {
        info.rgwcDeviceName[WANARP_MAX_DEVICE_NAME_LEN] = UNICODE_NULL;
 
        picb->pwszDeviceName =
            HeapAlloc(IPRouterHeap,
                      HEAP_ZERO_MEMORY,
                      (wcslen(info.rgwcDeviceName) + 1) * sizeof(WCHAR));


        if(picb->pwszDeviceName is NULL)
        {
            Trace2(ERR,
                   "AddInterfaceToWANARP: Unable to allocate %d bytes when adding %S to wanarp",
                   (wcslen(info.rgwcDeviceName) + 1) * sizeof(WCHAR),
                   picb->pwszName);

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(picb->pwszDeviceName,
               info.rgwcDeviceName);


        Trace2(DEMAND,
               "AddInterfaceToWANARP: %S device name %S\n",
               picb->pwszName,
               picb->pwszDeviceName);

        g_pInternalInterfaceCb = picb;
               
    }

        
    TraceLeave("AddInterfaceToWANARP");
    
    return NO_ERROR;
}

DWORD
DeleteInterfaceWithWanArp(
    PICB  picb
    )

/*++
  
Routine Description:

    Deletes the given interface with WANARP
  
Arguments:

    The ICB of the interface to delete

Return Value:

--*/

{
    DWORD       out,dwResult;
    OVERLAPPED  overlapped ;

    WANARP_DELETE_INTERFACE_INFO    DeleteInfo;

    TraceEnter("DeleteInterfaceWithWANARP");
    
    DeleteInfo.dwUserIfIndex = picb->dwSeqNumber;

    memset (&overlapped, 0, sizeof(OVERLAPPED)) ;

    if (!DeviceIoControl (g_hWanarpWrite,
                          IOCTL_WANARP_DELETE_INTERFACE,
                          &DeleteInfo,
                          sizeof(WANARP_DELETE_INTERFACE_INFO),
                          NULL,
                          0,
                          &out,
                          &overlapped)) 
    {
        dwResult = GetLastError();
        
        Trace2(ERR,
               "DeleteInterfaceWithWANARP: Error %d deleting %S",
               dwResult,
               picb->pwszName);

        return dwResult;
    }

    TraceLeave("DeleteInterfaceWithWANARP");
    
    return NO_ERROR;
}

#ifdef KSL_IPINIP

DWORD
CreateInternalInterfaceIcb(
    PWCHAR  pwszName,
    ICB     **ppicb
    )

/*++
  
Routine Description:

    This routine parses the TCPIP Parameters\Interfaces key to figure out 
    the name of the Internal Interface (ServerAdapter). The internal interface 
    has the substring "IPIN"
    
Arguments:

    None

Return Value:

    NO_ERROR
    
--*/

{
    HKEY    hIfKey;
    DWORD   i, dwResult, dwSize, dwNumEntries, dwMaxKeyLen;
    BOOL    bFoundAdapter;
    CHAR    *pbyKeyName, pszServerAdapter[256];
    PICB    pInterfaceCb;

    TraceEnter("CreateInternalInterfaceIcb");

    *ppicb = NULL;

    dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            REG_KEY_TCPIP_INTERFACES,
                            0,
                            KEY_ALL_ACCESS,
                            &hIfKey);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "CreateInternalIcb: Error %d opening %s\n",
               dwResult,
               REG_KEY_TCPIP_INTERFACES);

        return dwResult;
    }
    
    dwResult = RegQueryInfoKey(hIfKey,
                               NULL,
                               NULL,
                               NULL,
                               &dwNumEntries,
                               &dwMaxKeyLen,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "CreateIpIpInterface: Error %d querying key",
               dwResult);

        return dwResult;
    }

    //
    // Have to have some interfaces
    //

    IpRtAssert(dwNumEntries isnot 0)

    //
    // Allocate enough memory for max key len
    //

    dwSize = (dwMaxKeyLen + 4) * sizeof(CHAR);

    pbyKeyName = HeapAlloc(IPRouterHeap,
                           HEAP_ZERO_MEMORY,
                           dwSize);


    if(pbyKeyName is NULL)
    {
        Trace1(ERR,
               "CreateIpIpInterface: Error allocating %d bytes",
               dwSize);

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for(i = 0; ; i++)
    {
        DWORD       dwKeyLen;
        FILETIME    ftLastTime;
    

        dwKeyLen = dwMaxKeyLen;

        dwResult = RegEnumKeyExA(hIfKey,
                                 i,
                                 pbyKeyName,
                                 &dwKeyLen,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &ftLastTime);

        if(dwResult isnot NO_ERROR)
        {
            if(dwResult is ERROR_NO_MORE_ITEMS)
            {
                //
                // Done
                //

                break;
            }
    
            continue;
        }

        //
        // See if this is the server adapter. That is known by the fact that it contains
        // IPIN as a substring
        //

        //           
        // Upcase the string
        //

        _strupr(pbyKeyName);
        
        if(strstr(pbyKeyName,SERVER_ADAPTER_SUBSTRING) is NULL)
        {
            //
            // This is not the server adapter
            //

            continue;
        }
        
        //
        // Well we have a server adapter
        //
        
        ZeroMemory(pszServerAdapter,256);

        strcpy(pszServerAdapter,"\\DEVICE\\");
            
        strcat(pszServerAdapter,pbyKeyName);

        Trace1(IF,
               "InitInternalInterface: Using %s as the dial in adapter",
               pszServerAdapter);
        
        bFoundAdapter = TRUE;
        
        break;
    }

    HeapFree(IPRouterHeap,
             0,
             pbyKeyName);

    RegCloseKey(hIfKey); 

    if(!bFoundAdapter)
    {
        return ERROR_NOT_FOUND;
    }
    else
    {
        WCHAR           pwszTempName[256];
        DWORD           dwICBSize, dwNameLen;
        UNICODE_STRING  usTempString,usIcbName;

        usTempString.MaximumLength      = 256 * sizeof(WCHAR);
        usTempString.Buffer             = pwszTempName;
        usIcbName.MaximumLength         = 256 * sizeof(WCHAR);

        //
        // Only copy out the name and not the \Device\ part
        //

        MultiByteToWideChar(CP_ACP,
                            0,
                            pszServerAdapter + strlen(ADAPTER_PREFIX_STRING),
                            -1,
                            pwszTempName,
                            256);
      
        //
        // Add a WCHAR each for UNICODE_NULL for name and device name
        // Add 2 bytes for alignment issues
        //

        dwNameLen = 
            (sizeof(WCHAR) * (wcslen(pwszName) + wcslen(pwszTempName) + 2)) + 2;

        dwICBSize = sizeof(ICB) + dwNameLen;

        pInterfaceCb = (PICB)HeapAlloc(IPRouterHeap,
                                       HEAP_ZERO_MEMORY,
                                       dwICBSize);

        if(pInterfaceCb is NULL)
        {
            Trace1(ERR,
                   "InitInternalInterface: Error allocating %d bytes for ICB",
                   dwICBSize);

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        // 
        // Save the DIM name in the pwszName field
        //

        pInterfaceCb->pwszName  = (PWCHAR) ((PBYTE)pInterfaceCb + sizeof(ICB));
       
        //
        // Word align the pointer
        //

        pInterfaceCb->pwszName = 
            (PWCHAR)(((UINT_PTR)pInterfaceCb->pwszName + 1) & ~0x1);

        CopyMemory(pInterfaceCb->pwszName,
                   pwszName,
                   wcslen(pwszName) * sizeof(WCHAR));

        //
        // 1 WCHAR for UNICODE_NULL and 1 byte for alignment
        //

        pInterfaceCb->pwszDeviceName = 
            (PWCHAR)((PBYTE)pInterfaceCb->pwszName +  
                     ((wcslen(pwszName) + 1) * sizeof(WCHAR)) + 1);

        //
        // And align this, too
        //

        pInterfaceCb->pwszDeviceName = 
            (PWCHAR)(((UINT_PTR)pInterfaceCb->pwszDeviceName + 1) & ~0x1);
        
            
        usTempString.Length = sizeof(WCHAR) * wcslen(pwszTempName);
        usIcbName.Buffer    = pInterfaceCb->pwszDeviceName;

        RtlUpcaseUnicodeString(&usIcbName,
                               &usTempString,
                               FALSE);

        pInterfaceCb->pwszDeviceName[wcslen(pwszTempName)] = UNICODE_NULL;

        *ppicb = pInterfaceCb;
    }
   
    TraceLeave("CreateInternalInterfaceIcb");

    
    return NO_ERROR;
}

#endif //KSL_IPINIP

DWORD
AccessIfEntryWanArp(
    IN      DWORD dwAction,
    IN      PICB  picb,
    IN OUT  PMIB_IFROW lpOutBuf
    )

/*++
  
Routine Description:

    Gets or sets the statistics from the wanarp

Arguments:

    dwAction   Can be SET_IF or GET_IF
    picb       the Interface Control Block
    pOutBuf

Return Value:

    NO_ERROR or some error code
    
--*/

{
    NTSTATUS                    Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK             IoStatusBlock;
    WANARP_GET_IF_STATS_INFO    GetStatsInfo;

    
    TraceEnter("AccessIfEntryWanArp");
   
    GetStatsInfo.dwUserIfIndex = picb->dwSeqNumber;

    if(dwAction is ACCESS_GET)
    {
        Status = NtDeviceIoControlFile(g_hWanarpRead,
                                       NULL,
                                       NULL,    
                                       NULL,        
                                       &IoStatusBlock,
                                       IOCTL_WANARP_GET_IF_STATS,
                                       &GetStatsInfo,
                                       sizeof(WANARP_GET_IF_STATS_INFO),
                                       &GetStatsInfo,
                                       sizeof(WANARP_GET_IF_STATS_INFO));

        RtlCopyMemory(&(lpOutBuf->dwIndex),
                      &(GetStatsInfo.ifeInfo),
                      sizeof(IFEntry));
        
    }
    else
    {
        // To be implemented: return SUCCESS for now
    }
    
    if(Status isnot STATUS_SUCCESS)
    {
        IpRtAssert(Status isnot STATUS_PENDING);

        Trace2(ERR,
               "AccessIfEntryWanArp: NtStatus %x when getting information for %S",
               Status,
               picb->pwszName);

        TraceLeave("AccessIfEntryWanArp");

        return Status;
    }   

    TraceLeave("AccessIfEntryWanArp");

    return NO_ERROR;
}

DWORD
DeleteInternalInterface(
    VOID
    )

/*++
  
Routine Description:

    Deletes the ServerAdapter (internal) interface
  
Locks: 


Arguments:
      

Return Value:

    NO_ERROR

--*/

{

    if(g_pInternalInterfaceCb is NULL)
    {
        return NO_ERROR;
    }

    if(g_pInternalInterfaceCb->pwszDeviceName isnot NULL)
    {
        HeapFree(IPRouterHeap,
                 0,
                 g_pInternalInterfaceCb->pwszDeviceName);

        g_pInternalInterfaceCb->pwszDeviceName = NULL;
    }

    //
    // Call DeleteSingleInterface to do the same thing as is done
    // for LAN interfaces
    //

    DeleteSingleInterface(g_pInternalInterfaceCb);

    RemoveInterfaceLookup(g_pInternalInterfaceCb);
    
    HeapFree(IPRouterHeap,
             0,
             g_pInternalInterfaceCb);


    g_pInternalInterfaceCb = NULL;

    return NO_ERROR;
}


DWORD
AddDemandFilterInterface(
    PICB                    picb,
    PRTR_INFO_BLOCK_HEADER  pInterfaceInfo
    )

/*++

Routine Description:

    Adds an interface to the filter driver. This interface is never bound to
    an IP interface, instead we add demand dial filters to it and when a
    request is made to dial out, we match the packet causing the dialling
    against the filters (using the TestPacket() function) and use the returned
    action to determine whether we should dial out or not.
    
    If there are no filters, the interface is not added to the driver.
    Otherwise, a copy of the filters is kept with the picb, and a transformed
    set of filters is added to the driver
    The handle associated with the interface and the driver is kept in the
    picb
    
Arguments:

    picb
    pInterfaceInfo
    
Return Value:

    NO_ERROR
    
--*/

{
    DWORD                   dwResult;
    PPF_FILTER_DESCRIPTOR   pfdFilters;
    PFFORWARD_ACTION        faAction;
    PRTR_TOC_ENTRY          pToc;
    PFILTER_DESCRIPTOR      pInfo;
    ULONG                   i, j, ulSize, ulNumFilters;
    
    TraceEnter("AddDemandFilterInterface");

    IpRtAssert((picb->ritType is ROUTER_IF_TYPE_HOME_ROUTER) or
               (picb->ritType is ROUTER_IF_TYPE_FULL_ROUTER));
    
    IpRtAssert(picb->pDemandFilter is NULL);
    
    picb->ihDemandFilterInterface = INVALID_HANDLE_VALUE;

    pToc  = GetPointerToTocEntry(IP_DEMAND_DIAL_FILTER_INFO,
                                 pInterfaceInfo);
  
    //
    // We dont add if there is no INFO, or if the info size is 0 or
    // if the number of filters is 0 AND the default action is DROP
    //
 
    if((pToc is NULL) or (pToc->InfoSize is 0))
    {
        //
        // Either there is no filter info (TOC is NULL) or the user
        // wanted the filters deleted (which they have been)
        //
        
        Trace1(IF,
               "AddDemandFilterInterface: filter info NULL or info size 0 for %S, so leaving",
               picb->pwszName);
       
        TraceLeave("AddDemandFilterInterface");

        return NO_ERROR;
    }
    
    pInfo = GetInfoFromTocEntry(pInterfaceInfo,
                                pToc);

    if(pInfo is NULL)
    {
        Trace1(IF,
               "AddDemandFilterInterface: filter info NULL for %S, so leaving",
               picb->pwszName);
       
        TraceLeave("AddDemandFilterInterface");

        return NO_ERROR;
    }

    
    //
    // See how many filters we have
    //
    
    pfdFilters  = NULL;

    ulNumFilters = pInfo->dwNumFilters;

    if((ulNumFilters is 0) and
       (pInfo->faDefaultAction is PF_ACTION_FORWARD))
    {
        Trace1(IF,
               "AddDemandFilterInterface: 0 filters and default of FORWARD for %S, so leaving",
               picb->pwszName);
       
        TraceLeave("AddDemandFilterInterface");

        return NO_ERROR;
    }

    //
    // The size we need for these many filters
    //
        
    ulSize = FIELD_OFFSET(FILTER_DESCRIPTOR,fiFilter[0]) +
             (ulNumFilters * sizeof(FILTER_INFO));

    //
    // The infosize must be atleast as large as the filters
    //
        
    IpRtAssert(ulSize <= pToc->InfoSize);
    
    //
    // Copy out the info for ourselves
    //
    
    picb->pDemandFilter = HeapAlloc(IPRouterHeap,
                                    0,
                                    ulSize);
        
    if(picb->pDemandFilter is NULL)
    {
        Trace1(ERR,
               "AddDemandFilterInterface: Error allocating %d bytes for demand dial filters",
               ulSize);

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(picb->pDemandFilter,
               pInfo,
               ulSize);
        
    faAction = pInfo->faDefaultAction;
    
    if(ulNumFilters isnot 0)
    {
        PDWORD  pdwAddr;

        //
        // We have filters, so copy them to the new format
        // The address and mask will come at the end of all of the filters
        // so we allocate 16 bytes extra for each filter. Then we add a
        // 8 bytes so that we can align the block
        //
            

        ulSize = ulNumFilters * (sizeof(PF_FILTER_DESCRIPTOR) + 16) + 8;
        
        
        pfdFilters = HeapAlloc(IPRouterHeap,
                               0,
                               ulSize);
            
        if(pfdFilters is NULL)
        {
            HeapFree(IPRouterHeap,
                     0,
                     picb->pDemandFilter);
            
            Trace1(ERR,
                   "AddDemandFilterInterface: Error allocating %d bytes",
                   ulSize);
            
            return ERROR_NOT_ENOUGH_MEMORY;
        }
            
        //
        // Pointer to the start of the address block
        //
        
        pdwAddr = (PDWORD)&(pfdFilters[ulNumFilters]);
        
        //
        // Now convert the filters
        //
        
        for(i = 0, j = 0; i < ulNumFilters; i++)
        {
            pfdFilters[i].dwFilterFlags = 0;
            pfdFilters[i].dwRule        = 0;
            pfdFilters[i].pfatType      = PF_IPV4;

            //
            // Set the pointers
            //
            
            pfdFilters[i].SrcAddr = (PBYTE)&(pdwAddr[j++]);
            pfdFilters[i].SrcMask = (PBYTE)&(pdwAddr[j++]);
            pfdFilters[i].DstAddr = (PBYTE)&(pdwAddr[j++]);
            pfdFilters[i].DstMask = (PBYTE)&(pdwAddr[j++]);
            
            //
            // Copy in the src/dst addr/masks
            //
            
            *(PDWORD)pfdFilters[i].SrcAddr = pInfo->fiFilter[i].dwSrcAddr;
            *(PDWORD)pfdFilters[i].SrcMask = pInfo->fiFilter[i].dwSrcMask;
            *(PDWORD)pfdFilters[i].DstAddr = pInfo->fiFilter[i].dwDstAddr;
            *(PDWORD)pfdFilters[i].DstMask = pInfo->fiFilter[i].dwDstMask;
            
            //
            // Copy the protocol
            //
            
            pfdFilters[i].dwProtocol = pInfo->fiFilter[i].dwProtocol;

            //
            // Late bound makes no sense for this
            //
            
            pfdFilters[i].fLateBound = 0;

            //
            // The ports
            //
            
            pfdFilters[i].wSrcPort  = pInfo->fiFilter[i].wSrcPort;
            pfdFilters[i].wDstPort  = pInfo->fiFilter[i].wDstPort;
            
            //
            // Since we dont support ranges, set to 0
            //
            
            pfdFilters[i].wSrcPortHighRange = 0;
            pfdFilters[i].wDstPortHighRange = 0;
        }   
    }


    //
    // Now add create the interace and set the info
    //

    dwResult = PfCreateInterface(0,
                                 faAction,
                                 PF_ACTION_FORWARD,
                                 FALSE,
                                 FALSE,
                                 &(picb->ihDemandFilterInterface));

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "AddDemandFilterInterface: Err %d creating filter i/f for %S",
               dwResult,
               picb->pwszName);
    }
    else
    {
        //
        // Set the filters
        //

        if(ulNumFilters isnot 0)
        {
            dwResult = PfAddFiltersToInterface(picb->ihDemandFilterInterface,
                                               ulNumFilters,
                                               pfdFilters,
                                               0,
                                               NULL,
                                               NULL);
        
            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "AddDemandFilterInterface: Err %d setting filters on %S",
                       dwResult,
                       picb->pwszName);

                PfDeleteInterface(picb->ihDemandFilterInterface);
            }
        }
    }

    if(pfdFilters)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pfdFilters);
    }   

    if(dwResult isnot NO_ERROR)
    {
        //
        // Something bad happened. Set the handles to invalid so that
        // we know we did not add the filters
        //

        picb->ihDemandFilterInterface = INVALID_HANDLE_VALUE;
        
        if(picb->pDemandFilter)
        {
            HeapFree(IPRouterHeap,
                     0,
                     picb->pDemandFilter);

            picb->pDemandFilter = NULL;
        }
    }

    TraceLeave("SetInterfaceFilterInfo");
        
    return dwResult;
}

     
DWORD
DeleteDemandFilterInterface(
    PICB picb
    )

/*++

Routine Description:

    This function deletes a filter interface (and all associated filters)
    Also frees the memory holding the filters

Locks:

    ICB_LIST held as WRITER

Arguments:

    None

Return Value:

    None    

--*/

{
    TraceEnter("DeleteDemandFilterInterface");

    IpRtAssert((picb->ritType is ROUTER_IF_TYPE_HOME_ROUTER) or
               (picb->ritType is ROUTER_IF_TYPE_FULL_ROUTER));
    
    if(picb->pDemandFilter isnot NULL)
    {
        HeapFree(IPRouterHeap,
                 0,
                 picb->pDemandFilter);
        
        picb->pDemandFilter = NULL;
    }

    if(picb->ihDemandFilterInterface is INVALID_HANDLE_VALUE)
    {
        Trace1(IF,
               "DeleteDemandFilterInterface: No context, assuming interface %S not added to filter driver",
               picb->pwszName);
    
        return NO_ERROR;
    }

    PfDeleteInterface(picb->ihDemandFilterInterface);
    
    picb->ihDemandFilterInterface  = INVALID_HANDLE_VALUE;

    TraceLeave("DeleteDemandFilterInterface");
    
    return NO_ERROR;
}

DWORD
SetDemandDialFilters(
    PICB                     picb, 
    PRTR_INFO_BLOCK_HEADER   pInterfaceInfo
    )
{
    DWORD           dwResult;
    PRTR_TOC_ENTRY  pToc;
    
    if((picb->ritType isnot ROUTER_IF_TYPE_HOME_ROUTER) and
       (picb->ritType isnot ROUTER_IF_TYPE_FULL_ROUTER))
    {
        return NO_ERROR;
    }
    
    TraceEnter("SetDemandDialFilters");

    pToc  = GetPointerToTocEntry(IP_DEMAND_DIAL_FILTER_INFO,
                                 pInterfaceInfo);

    if(pToc is NULL)
    {
        //
        // Both NULL, means we dont need to change anything
        //
        
        Trace1(DEMAND,
               "SetDemandDialFilters: No filters for %S, so leaving",
               picb->pwszName);
       
        TraceLeave("SetDemandDialFilters");

        return NO_ERROR;
    }

    if(picb->ihDemandFilterInterface isnot INVALID_HANDLE_VALUE)
    {
        //
        // This interface was added to the filter driver,
        // Delete it so that the filters are all deleted and then readd
        // the filters
        //

        IpRtAssert(picb->pDemandFilter isnot NULL);

        dwResult = DeleteDemandFilterInterface(picb);

        //
        // This better succeed, we dont have a failure path here
        //
        
        IpRtAssert(dwResult is NO_ERROR);
        
    }

    dwResult = AddDemandFilterInterface(picb,
                                        pInterfaceInfo);

    if(dwResult isnot NO_ERROR)
    {
        CHAR   Name[MAX_INTERFACE_NAME_LEN + 1];
        PCHAR  pszName;

        pszName = Name;

        WideCharToMultiByte(CP_ACP,
                            0,
                            picb->pwszName,
                            -1,
                            pszName,
                            MAX_INTERFACE_NAME_LEN,
                            NULL,
                            NULL);

        LogErr1(CANT_ADD_DD_FILTERS,
                pszName,
                dwResult);
    }

    TraceLeave("SetDemandDialFilters");
        
    return dwResult;
}

DWORD
GetDemandFilters(
    PICB                      picb, 
    PRTR_TOC_ENTRY            pToc, 
    PBYTE                     pbDataPtr, 
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    PDWORD                    pdwSize
    )

/*++

Routine Description:

    This function copies out the demand dial filters and set the TOC

Locks:

    ICB_LIST lock held as READER

Arguments:

    None

Return Value:

    None    

--*/

{
    DWORD                       dwInBufLen,i;
    PFILTER_DESCRIPTOR          pFilterDesc;
    
    TraceEnter("GetDemandFilters");
   
    IpRtAssert((picb->ritType is ROUTER_IF_TYPE_HOME_ROUTER) or
               (picb->ritType is ROUTER_IF_TYPE_FULL_ROUTER));
    
    //
    // Set size returned to 0
    //
    
    *pdwSize = 0;

    //
    // Safe init of both the TOCs. 
    //
    
    //pToc[0].InfoVersion = IP_DEMAND_DIAL_FILTER_INFO;
    pToc[0].InfoType    = IP_DEMAND_DIAL_FILTER_INFO;
    pToc[0].Count       = 0;
    pToc[0].InfoSize    = 0;
    
    if((picb->ihDemandFilterInterface is INVALID_HANDLE_VALUE) or
       (picb->pDemandFilter is NULL))
    {
        Trace1(IF,
               "GetDemandFilters: No context or no filters for %S",
               picb->pwszName);
        
        return ERROR_NO_DATA;
    }

    //
    // Set the offset in the TOC
    //
    
    pToc[0].Offset   = (ULONG) (pbDataPtr - (PBYTE)pInfoHdrAndBuffer);
    pToc[0].Count    = 1;
    pToc[0].InfoSize = FIELD_OFFSET(FILTER_DESCRIPTOR,fiFilter[0]) +
                       (picb->pDemandFilter->dwNumFilters * sizeof(FILTER_INFO));
    //pToc[0].Version  = IPRTR_INFO_VERSION_5;
   
    //
    // Just copy out the filters
    //
    
    CopyMemory(pbDataPtr,
               picb->pDemandFilter,
               pToc[0].InfoSize);

    //
    // The size copied in
    //
    
    *pdwSize = pToc[0].InfoSize;
        
    TraceLeave("GetDemandFilters");
        
    return NO_ERROR;
}

VOID
TryUpdateInternalInterface(
    VOID
    )

/*++

Routine Description:

    This function is called when a client dials in and we have not
    bound the internal interface
    The way of doing this is as follows:
    If the server adapter is not initialized, read the address from the
    registry. If we read the address, all is good, break out and move on
    If no address was found, wait on the DHCP event with a time out
    If someone configures the server adapter in the meantime, we will get
    the DHCP event, if we miss the event (since it is PULSED), we will
    timeout and we loop back and retry the steps above.
    Now we do this N times. If we fail, then we just wait for the next
    client to dial in

Locks:

    ICB_LIST held as WRITER

Arguments:

    None

Return Value:

    None    

--*/

{
    DWORD dwResult, dwInitCount;

    TraceEnter("TryUpdateInternalInterface");

    dwInitCount = 0;
     
    //
    // This is only called when the server is not initialized
    //

    IpRtAssert(g_bUninitServer);
 
    while(g_bUninitServer)
    {
        Trace0(ERR,
               "TryUpdateInternalInterface: Server adapter not init");
        
        dwResult = UpdateBindingInformation(g_pInternalInterfaceCb);
        
        if(dwResult isnot NO_ERROR)
        {
            if((dwResult is ERROR_ADDRESS_ALREADY_ASSOCIATED) and
               (g_pInternalInterfaceCb->bBound is TRUE)) 
            {
                //
                // This means that the worker thread found an address
                //
               
                IpRtAssert(g_pInternalInterfaceCb->dwNumAddresses is 1);
 
                Trace1(IF,
                       "TryUpdateInternalInterface: Address already present for %S",
                       g_pInternalInterfaceCb->pwszName);
                
                g_bUninitServer = FALSE;
                
                break;
            }
            else
            {
                Trace2(ERR,
                       "TryUpdateInternalInterface: Err %d trying to update binding for %S",
                       dwResult,
                       g_pInternalInterfaceCb->pwszName);
            }   
            
            dwInitCount++;
            
            if(dwInitCount >= MAX_SERVER_INIT_TRIES)
            {
                //
                // We try x times and then give up. Next client around
                // things should work
                //
                
                break;
            }
            else
            {
                Sleep(SERVER_INIT_SLEEP_TIME);
            }
        }
        else
        {
            g_bUninitServer = FALSE;
        }
    }

    //
    // If we broke out because the interface was initialized, bring it up
    //

    if(!g_bUninitServer)
    {
        dwResult = LanEtcInterfaceDownToUp(g_pInternalInterfaceCb,
                                           FALSE);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "TryUpdateInternalInterface: Error %d bringing up server if",
                   dwResult);
        }
    }

    TraceLeave("TryUpdateInternalInterface");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\demand.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\demand.h

Abstract:

    Header for demand.c

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/


#define REGISTRY_WANARP_LINKAGE     \
    "System\\CurrentControlSet\\Services\\WanArp\\Linkage"

#define REGISTRY_BIND_VALUE_NAME    \
    "Bind"

#define SERVER_ADAPTER_SUBSTRING    \
    "NDISWANIPIN"

#define REGISTRY_ROUTER_SERVICE_KEY \
    "System\\CurrentControlSet\\Services\\Router\\"


DWORD
InitializeWanArp(
    VOID
    );

VOID
CloseWanArp(
    VOID
    );

DWORD
AddInterfaceToWanArp(
    PICB    picb
    );

DWORD
HandleDemandDialEvent(
    VOID
    );

VOID
HandleConnectionRequest(
    PICB    picb
    );

VOID
HandleConnectionNotification(
    PICB    picb
    );

VOID
HandleDisconnectionNotification(
    PICB    picb
    );

DWORD
HandleDialOutLinkUp(
    VOID
    );

DWORD
CreateDialOutInterface(
    IN  PWCHAR  pwszIfName,
    IN  DWORD   dwIfIndex,
    IN  DWORD   dwLocalAddress,
    IN  DWORD   dwLocalMask,
    IN  DWORD   dwRemoteAddr,
    OUT ICB     **ppIcb
    );

DWORD
HandleDialOutLinkDown(
    VOID
    );

NTSTATUS
NotifyWanarpOfFailure(
    PICB    picb
    );

DWORD
ProcessPacketFromWanArp(
    PICB    picb 
    );

DWORD
PostIoctlForDemandDialNotification(
    VOID
    );

DWORD
DeleteInterfaceWithWanArp(
    PICB  picb
    );

DWORD
DisableInterfaceWithWanArp(
    PICB picb
    );

DWORD
AddDemandFilterInterface(
    PICB                    picb,
    PRTR_INFO_BLOCK_HEADER  pInterfaceInfo
    );

DWORD
DeleteDemandFilterInterface(
    PICB picb
    );

DWORD
SetDemandDialFilters(
    PICB                     picb,
    PRTR_INFO_BLOCK_HEADER   pInterfaceInfo
    );

DWORD
GetDemandFilters(
    PICB                      picb,
    PRTR_TOC_ENTRY            pToc,
    PBYTE                     pbDataPtr,
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    PDWORD                    pdwSize
    );

VOID
TryUpdateInternalInterface(
    VOID
    );

DWORD
DeleteInternalInterface(
    VOID
    );

DWORD
AccessIfEntryWanArp(
    IN      DWORD dwAction,
    IN      PICB  picb,
    IN OUT  PMIB_IFROW lpOutBuf
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\disctest.c ===
#include "allinc.h"

static WORD
Compute16BitXSum(
                 IN PVOID pvData,
                 IN DWORD dwNumBytes
                 )
/*++
  Routine Description
  

  Arguments
      

  Return Value
      16 Bit one's complement of the one's complement sum of dwNumBytes starting at pData
--*/
{
    REGISTER PWORD  pwStart;
    REGISTER DWORD  dwNumWords,i;
    REGISTER DWORD  dwSum = 0;
    
    pwStart = (PWORD)pvData;
    
    // 
    // If there are odd numbered bytes, that has to be handled differently
    // However we can never have odd numbered bytes in our case so we optimize.
    //
    

    dwNumWords = dwNumBytes/2;
    
    for(i = 0; i < dwNumWords; i++)
    {
        dwSum += pwStart[i];
        
        if(dwSum & 0x80000000)
        {
            dwSum = (dwSum & 0x0000FFFF) + (dwSum >> 16);
        }
    }
    
    return (WORD)~dwSum;
}

int __cdecl
main()
{
    SOCKET                  Socket;
    DWORD                   dwResult,dwNumBytesSent,dwBytesRead,dwAns,dwAddrLen,dwFlags;
    LONG                    i;
    DWORD                   dwSizeOfHeader;
    BOOL                    bOption;
    SOCKADDR_IN             sinSourceAddr, sinSockAddr;
    WSABUF                  wsaBuf;
    DWORD                   pdwIpAndIcmpBuf[ICMP_RCV_BUFFER_LEN+2];
    PIP_HEADER              pIpHeader;
    PICMP_ROUTER_ADVT_MSG   pIcmpAdvt;
    ICMP_ROUTER_SOL_MSG     icmpSolMsg;
    WORD                    wVersion = MAKEWORD(2,0); //Winsock version 2.0 minimum
    WSADATA                 wsaData;
    struct ip_mreq          imOption;
    
    
    icmpSolMsg.byType = 0x0A;
    icmpSolMsg.byCode = 0x00;
    icmpSolMsg.dwReserved = 0;
    icmpSolMsg.wXSum = 0x0000;
    
    icmpSolMsg.wXSum = Compute16BitXSum((PVOID)&icmpSolMsg,
                                        8);
    
    if(WSAStartup(wVersion,&wsaData) isnot NO_ERROR)
    {
        printf("WSAStartup failed\n");
        exit(1);
    }
    
    Socket = WSASocket(AF_INET,
                       SOCK_RAW,
                       IPPROTO_ICMP,
                       NULL,
                       0,
                       RTR_DISC_SOCKET_FLAGS);
    
    if(Socket is INVALID_SOCKET)
    {
        dwResult = WSAGetLastError();
        
        printf("Couldnt create socket. Error %d\n",
               dwResult);
        
        exit(1);
    }
    
    //
    // Set to SO_REUSEADDR
    //
    
    bOption = TRUE;
    
    if(setsockopt(Socket,
                  SOL_SOCKET,
                  SO_REUSEADDR,
                  (const char FAR*)&bOption,
                  sizeof(BOOL)) is SOCKET_ERROR)
    {
        printf("Couldnt set linger option. Error %d\n",
               WSAGetLastError());
    }
    
    //
    // Bind to the addresses on the interface
    //
    
    sinSourceAddr.sin_family      = AF_INET;
    sinSourceAddr.sin_addr.s_addr = INADDR_ANY;
    sinSourceAddr.sin_port        = 0;
    
    if(bind(Socket,
            (const struct sockaddr FAR*)&sinSourceAddr,
            sizeof(SOCKADDR_IN)) is SOCKET_ERROR)
    {
        dwResult = WSAGetLastError();
        
        printf("Couldnt bind. Error %d\n",
               dwResult);
        
        exit(1);
    }
   
#if 0
    //
    // Join the multicast session on ALL_SYSTEMS_MULTICAST
    //

    sinSockAddr.sin_family      = AF_INET;
    sinSockAddr.sin_addr.s_addr = ALL_SYSTEMS_MULTICAST_GROUP;
    sinSockAddr.sin_port        = 0;
        
    if(WSAJoinLeaf(Socket,
                   (const struct sockaddr FAR*)&sinSockAddr,
                   sizeof(SOCKADDR_IN),
                   NULL,
                   NULL,
                   NULL,
                   NULL,
                   JL_BOTH) is INVALID_SOCKET)
    {
        dwResult = WSAGetLastError();
            
        printf("Error %d joining ALL_SYSTEMS  multicast group on socket for %s",
               dwResult,
               inet_ntoa(*(PIN_ADDR)&(sinSourceAddr.sin_addr)));
        

            
        closesocket(Socket);

        exit(1);
    }

#endif
    
    if(setsockopt(Socket,
                  IPPROTO_IP, 
                  IP_MULTICAST_IF,
                  (PBYTE)&sinSourceAddr.sin_addr, 
                  sizeof(IN_ADDR)) is SOCKET_ERROR)
    {
        dwResult = WSAGetLastError();
        
        printf("Couldnt join multicast group on socket for %s",
               inet_ntoa(*(PIN_ADDR)&(sinSourceAddr.sin_addr)));
        
        exit(1);
    }
    
    imOption.imr_multiaddr.s_addr = ALL_SYSTEMS_MULTICAST_GROUP;
    imOption.imr_interface.s_addr = sinSourceAddr.sin_addr.s_addr;
    
    if(setsockopt(Socket,
                  IPPROTO_IP, 
                  IP_ADD_MEMBERSHIP,
                  (PBYTE)&imOption, 
                  sizeof(imOption)) is SOCKET_ERROR)
    {
        dwResult = WSAGetLastError();
        
        printf("Couldnt join multicast group on socket for %s",
               inet_ntoa(*(PIN_ADDR)&(sinSourceAddr.sin_addr)));
        
        exit(1);
    } 

    
    while(TRUE)
    {
        printf("Send Solicitation? (1 - yes, 0 - no) ");

        dwResult = scanf("%d",&dwAns);
        if ( dwResult != 1 )
        {
            break;
        }
        
        if(!dwAns)
        {
            break;
        }
        
        sinSourceAddr.sin_family      = AF_INET;
        sinSourceAddr.sin_addr.s_addr = ALL_ROUTERS_MULTICAST_GROUP;
        sinSourceAddr.sin_port        = 0;
    
        wsaBuf.buf = (PBYTE)&icmpSolMsg;  
        wsaBuf.len = sizeof(ICMP_ROUTER_SOL_MSG);

        if(WSASendTo(Socket,
                     &wsaBuf,
                     1,
                     &dwNumBytesSent,
                     MSG_DONTROUTE,
                     (const struct sockaddr FAR*)&sinSourceAddr,
                     sizeof(SOCKADDR_IN),
                     NULL,
                     NULL
                     ) is SOCKET_ERROR)
        {
            dwResult = WSAGetLastError();
            
            printf("WSASendTo failed with %d\n",
                   dwResult);
            break;
        }
        
        while(TRUE)
        {
            dwAddrLen = sizeof(SOCKADDR_IN);
            dwFlags = 0;
            
            pIpHeader  = (PIP_HEADER)pdwIpAndIcmpBuf;
            wsaBuf.buf = (PBYTE)pIpHeader;
            wsaBuf.len = (ICMP_RCV_BUFFER_LEN+2) * sizeof(DWORD);
            
            if(WSARecvFrom(Socket,
                           &wsaBuf,
                           1,
                           &dwBytesRead,
                           &dwFlags,
                           (struct sockaddr FAR*)&sinSourceAddr,
                           &dwAddrLen,
                           NULL,
                           NULL) is SOCKET_ERROR)
            {
                dwResult = WSAGetLastError();
                
                printf("Error %d doing a receive\n",
                       dwResult);
                
                break;
            }
            
            dwSizeOfHeader = ((pIpHeader->byVerLen)&0x0f)<<2;
            
            pIcmpAdvt = (PICMP_ROUTER_ADVT_MSG)(((PBYTE)pIpHeader) + dwSizeOfHeader);
                    
            if(pIcmpAdvt->byType is 0x9)
            {
                for(i = 0; i < MAKELONG(MAKEWORD(pIcmpAdvt->byNumAddrs,0x00),0x0000); i++)
                {
                    printf("Router Address %s \t Preference %d Lifetime %d\n",
                           inet_ntoa(*(PIN_ADDR)&(pIcmpAdvt->iaAdvt[i].dwRtrIpAddr)),
                           ntohl(pIcmpAdvt->iaAdvt[i].lPrefLevel),
                           ntohs(pIcmpAdvt->wLifeTime));
                }
                
                break;
            }
        }
    }  
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\exdeclar.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\exdeclar.h

Abstract:

       This file contains the data definitions used by IP Router Manager
                	    

Revision History:

    Amritansh Raghav          7/8/95  Created

--*/

#ifndef __EXDECLAR_H__
#define __EXDECLAR_H__

//
// This table holds the timeout values for all the caches. Currently they are 
// #defined
//

DWORD g_TimeoutTable[NUM_CACHE] =   {
                                        IPADDRCACHE_TIMEOUT,
                                        IPFORWARDCACHE_TIMEOUT, 
                                        IPNETCACHE_TIMEOUT,   
                                        TCPCACHE_TIMEOUT,        
                                        UDPCACHE_TIMEOUT,
                                    };

//
// This table holds pointers to functions that load each of the caches
//

DWORD (*g_LoadFunctionTable[NUM_CACHE])() = {
                                                LoadIpAddrTable,
                                                LoadIpForwardTable,
                                                LoadIpNetTable,
                                                LoadTcpTable,
                                                LoadUdpTable,
                                            };

//
// This table holds the time when each of the cache's were last updated
//
                    
DWORD g_LastUpdateTable[NUM_CACHE];

//
// This is a table of locks around each of the caches and it also hold the 
// ICB_LIST and the PROTOCOL_CB_LIST locks
//

RTL_RESOURCE g_LockTable[NUM_LOCKS];

//
// This table holds the functions that are used to access the MIB variables 
// made visible by IP Router Manager
//

DWORD 
(*g_AccessFunctionTable[NUMBER_OF_EXPORTED_VARIABLES])(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    ) = {
            AccessIfNumber,
            AccessIfTable,
            AccessIfRow,
            AccessIpStats,
            AccessIpAddrTable,
            AccessIpAddrRow,
            AccessIpForwardNumber,
            AccessIpForwardTable, 
            AccessIpForwardRow, 
            AccessIpNetTable, 
            AccessIpNetRow, 
            AccessIcmpStats, 
            AccessTcpStats,
            AccessTcpTable,
            AccessTcpRow,
            AccessUdpStats,
            AccessUdpTable,
            AccessUdpRow,
            AccessMcastMfe,
            AccessMcastMfeStats,
            AccessBestIf,
            AccessBestRoute,
            AccessProxyArp,
            AccessMcastIfStats,
            AccessMcastStats,
            AccessIfStatus,
            AccessMcastBoundary,
            AccessMcastScope,
            AccessDestMatching,
            AccessDestLonger,
            AccessDestShorter,
            AccessRouteMatching,
            AccessRouteLonger,
            AccessRouteShorter,
            AccessSetRouteState,
            AccessMcastMfeStatsEx
        };


#ifdef DEADLOCK_DEBUG

PBYTE   g_pszLockNames[NUM_LOCKS] = {"IP Address Lock",
                                     "IP Forward Lock",
                                     "IP Net Lock",
                                     "TCP Lock",
                                     "UDP Lock",
                                     "ICB List Lock",
                                     "ProtocolCB List Lock",
                                     "Binding List Lock",
                                     "Boundary Table Lock",
                                     "MZAP Timer Lock",
                                     "ZBR List Lock",
                                     "ZLE List Lock",
                                     "ZAM Cache Lock"
                                    };

#endif // DEADLOCK_DEBUG

//
// The following is the time the Router Manager started
//

DWORD  g_dwStartTime;



HANDLE g_hIpDevice;
HANDLE g_hMcastDevice;
HANDLE g_hIpRouteChangeDevice;


//
// These various caches
//

IP_CACHE  g_IpInfo;
TCP_CACHE g_TcpInfo;
UDP_CACHE g_UdpInfo;

//
// Each of the groups have a private heap
//

HANDLE  g_hIfHeap;
HANDLE  g_hIpAddrHeap;
HANDLE  g_hIpForwardHeap;
HANDLE  g_hIpNetHeap;
HANDLE  g_hTcpHeap;
HANDLE  g_hUdpHeap;

PICB    g_pInternalInterfaceCb;
PICB    g_pLoopbackInterfaceCb;

DWORD   g_dwNextICBSeqNumberCounter;

ULONG   g_ulNumBindings;
ULONG   g_ulNumInterfaces;
ULONG   g_ulNumNonClientInterfaces;
    
LIST_ENTRY          g_leStackRoutesToRestore;

SUPPORT_FUNCTIONS       g_sfnDimFunctions;
PICMP_ROUTER_ADVT_MSG   g_pIcmpAdvt;
SOCKADDR_IN             g_sinAllSystemsAddr;
WSABUF                  g_wsabufICMPAdvtBuffer;
WSABUF                  g_wsaIpRcvBuf;

BOOL                    g_bUninitServer;

MCAST_OVERLAPPED    g_rginMcastMsg[NUM_MCAST_IRPS];

IPNotifyData        g_IpNotifyData;
ROUTE_CHANGE_INFO   g_rgIpRouteNotifyOutput[NUM_ROUTE_CHANGE_IRPS];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\filter.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\rtrmgr\filter.c

Abstract:
    All filters related code lives here.

Revision History:

    Gurdeep Singh Pall          6/15/95  Created

--*/

#include "allinc.h"


DWORD
AddFilterInterface(
    PICB                    picb,
    PRTR_INFO_BLOCK_HEADER  pInterfaceInfo
    )

/*++

Routine Description

    Adds an interface to the filter driver and sets the filters on the
    interface.
    If there are no filters, the interface is not added to the driver.
    Otherwise, a copy of the filters is kept with the picb, and a transformed
    set of filters is added to the driver
    The handle associated with the interface and the driver is kept in the
    picb
    
Arguments

    picb
    pInterfaceInfo
    
Return Value

    NO_ERROR
    
--*/

{
    DWORD                   dwResult;
    PPF_FILTER_DESCRIPTOR   pfdInFilters, pfdOutFilters;
    PFFORWARD_ACTION        faInAction,faOutAction;
    PRTR_TOC_ENTRY          pInToc, pOutToc;
    ULONG                   i, j, ulSize, ulNumInFilters, ulNumOutFilters;
    PFILTER_DESCRIPTOR      pInfo;
    PDWORD                  pdwAddr;
    BOOL                    bAdd;
    WCHAR                   rgwcName[MAX_INTERFACE_NAME_LEN + 2];
    PWCHAR                  pName;

    TraceEnter("AddFilterInterface");

    //
    // We dont add the following interfaces to the stack
    //
    
    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK));

    //
    // There should be no turds lying around
    //
    
    IpRtAssert(picb->pInFilter is NULL);
    IpRtAssert(picb->pOutFilter is NULL);

    //
    // Safe init
    //
    
    picb->ihFilterInterface = INVALID_HANDLE_VALUE;

    //
    // First thing, just add the frag filter. Since we arent added to 
    // the filter driver, all this will do is set the value in the
    // picb
    //

    SetGlobalFilterOnIf(picb,
                        pInterfaceInfo);

    //
    // Get the TOCs for in and out filters
    //
    
    pInToc  = GetPointerToTocEntry(IP_IN_FILTER_INFO,
                                   pInterfaceInfo);

    pOutToc = GetPointerToTocEntry(IP_OUT_FILTER_INFO,
                                   pInterfaceInfo);

  
    //
    // We only add the interface if there is atleast one (input or output)
    // filter infoblock and it has either non zero filters or its default
    // action is DROP
    //
 
    bAdd = FALSE;

    do
    {
        if((pInToc isnot NULL) and 
           (pInToc->InfoSize isnot 0))
        {
            pInfo = GetInfoFromTocEntry(pInterfaceInfo,
                                        pInToc);

            if ((pInfo isnot NULL) and
                ((pInfo->dwNumFilters isnot 0) or
                 (pInfo->faDefaultAction is PF_ACTION_DROP)))
            {
                bAdd = TRUE;

                break;
            }
        }


        if((pOutToc isnot NULL) and 
           (pOutToc->InfoSize isnot 0))
        {
            pInfo = GetInfoFromTocEntry(pInterfaceInfo,
                                        pOutToc);

            if ((pInfo isnot NULL) and
                ((pInfo->dwNumFilters isnot 0) or
                 (pInfo->faDefaultAction is PF_ACTION_DROP)))
            {
                bAdd = TRUE;

                break;
            }
        }

    }while(FALSE);

    if(!bAdd)
    {
        //
        // Either there is no filter info (both are NULL) or the user
        // wanted the filters deleted (which they have been)
        //
        
        Trace1(IF,
               "AddFilterInterface: Both filters info are NULL or info size 0 for both for %S, so leaving",
               picb->pwszName);
       
        TraceLeave("AddFilterInterface");

        return NO_ERROR;
    }

    //
    // Some more init
    //
    
    faInAction  = PF_ACTION_FORWARD;
    faOutAction = PF_ACTION_FORWARD;

    pfdInFilters  = NULL;
    pfdOutFilters = NULL;
    
    ulNumInFilters  = 0;
    ulNumOutFilters = 0;
    
    if((pInToc) and (pInToc->InfoSize))
    {
        //
        // So we have in filter info
        //
        
        pInfo = GetInfoFromTocEntry(pInterfaceInfo,
                                    pInToc);

        if (pInfo isnot NULL)
        {
            ulNumInFilters = pInfo->dwNumFilters;

            //
            // The size we need for these many filters
            //
            
            ulSize = FIELD_OFFSET(FILTER_DESCRIPTOR,fiFilter[0]) +
                     (ulNumInFilters * sizeof(FILTER_INFO));

            //
            // The infosize must be atleast as large as the filters
            //
            
            IpRtAssert(ulSize <= pInToc->InfoSize);
            
            //
            // Copy out the info for ourselves
            //

            picb->pInFilter = HeapAlloc(IPRouterHeap,
                                        0,
                                        ulSize);
            
            if(picb->pInFilter is NULL)
            {
                Trace1(ERR,
                       "AddFilterInterface: Error allocating %d bytes for in filters",
                       ulSize);

                return ERROR_NOT_ENOUGH_MEMORY;
            }

            CopyMemory(picb->pInFilter,
                       pInfo,
                       ulSize);
            
            //
            // Save a copy of the default action.
            // If there is not TOC/Info for the filter set, then the action
            // is set to FORWARD (initialization done before this block)
            //
            
            faInAction = pInfo->faDefaultAction;

            if(ulNumInFilters isnot 0)
            {
                //
                // We have filters, so copy them to the new format
                // The address and mask will come at the end of all of the filters
                // so we allocate 16 bytes extra for each filter. Then we add a
                // 8 bytes so that we can align the block
                //
                

                ulSize = ulNumInFilters * (sizeof(PF_FILTER_DESCRIPTOR) + 16) + 8;
                
                
                pfdInFilters = HeapAlloc(IPRouterHeap,
                                         0,
                                         ulSize);
                
                if(pfdInFilters is NULL)
                {
                    HeapFree(IPRouterHeap,
                             0,
                             picb->pInFilter);

                    picb->pInFilter = NULL;

                    Trace1(ERR,
                           "AddFilterInterface: Error allocating %d bytes",
                           ulSize);

                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                
                //
                // Pointer to the start of the address block
                //
                
                pdwAddr = (PDWORD)&(pfdInFilters[ulNumInFilters]);
                
                //
                // Now convert the filters
                //

                for(i = 0, j = 0; i < ulNumInFilters; i++)
                {
                    pfdInFilters[i].dwFilterFlags = 0;
                    pfdInFilters[i].dwRule        = 0;
                    pfdInFilters[i].pfatType      = PF_IPV4;

                    //
                    // Set the pointers
                    //
                
                    pfdInFilters[i].SrcAddr = (PBYTE)&(pdwAddr[j++]);
                    pfdInFilters[i].SrcMask = (PBYTE)&(pdwAddr[j++]);
                    pfdInFilters[i].DstAddr = (PBYTE)&(pdwAddr[j++]);
                    pfdInFilters[i].DstMask = (PBYTE)&(pdwAddr[j++]);

                    //
                    // Copy in the src/dst addr/masks
                    //
                    
                    *(PDWORD)pfdInFilters[i].SrcAddr =
                        pInfo->fiFilter[i].dwSrcAddr;
                    
                    *(PDWORD)pfdInFilters[i].SrcMask =
                        pInfo->fiFilter[i].dwSrcMask;
                    
                    *(PDWORD)pfdInFilters[i].DstAddr =
                        pInfo->fiFilter[i].dwDstAddr;
                    
                    *(PDWORD)pfdInFilters[i].DstMask =
                        pInfo->fiFilter[i].dwDstMask;

                    //
                    // Copy the protocol and flag
                    //
                    
                    pfdInFilters[i].dwProtocol = pInfo->fiFilter[i].dwProtocol;
                    pfdInFilters[i].fLateBound = pInfo->fiFilter[i].fLateBound;

                    if(pfdInFilters[i].dwProtocol is FILTER_PROTO_TCP)
                    {
                        if(IsTcpEstablished(&(pInfo->fiFilter[i])))
                        {
                            pfdInFilters[i].dwFilterFlags |= FD_FLAGS_NOSYN;
                        }
                    }

                    pfdInFilters[i].fLateBound = pInfo->fiFilter[i].fLateBound;

                    //
                    // The ports
                    //
                    
                    pfdInFilters[i].wSrcPort  = pInfo->fiFilter[i].wSrcPort;
                    pfdInFilters[i].wDstPort  = pInfo->fiFilter[i].wDstPort;
                    
                    //
                    // Since we dont support ranges, set the high to 0
                    //
                    
                    pfdInFilters[i].wSrcPortHighRange = 0;
                    
                    pfdInFilters[i].wDstPortHighRange = 0;
                }
            }
        }
    }

    if((pOutToc) and (pOutToc->InfoSize))
    {
        pInfo = GetInfoFromTocEntry(pInterfaceInfo,
                                    pOutToc);

        
        if (pInfo isnot NULL)
        {
            ulNumOutFilters = pInfo->dwNumFilters;

            //
            // The size we need for these many filters
            //
            
            ulSize = FIELD_OFFSET(FILTER_DESCRIPTOR,fiFilter[0]) +
                     (ulNumOutFilters * sizeof(FILTER_INFO));

            //
            // The infosize must be atleast as large as the filters
            //
            
            IpRtAssert(ulSize <= pOutToc->InfoSize);
            
            //
            // Copy out the info for ourselves
            //

            picb->pOutFilter = HeapAlloc(IPRouterHeap,
                                         0,
                                         ulSize);

            if(picb->pOutFilter is NULL)
            {
                //
                // Free any in filter related memory
                //
                
                if(picb->pInFilter)
                {
                    HeapFree(IPRouterHeap,
                             0,
                             picb->pInFilter);

                    picb->pInFilter = NULL;
                }

                if(pfdInFilters)
                {
                    HeapFree(IPRouterHeap,
                             0,
                             pfdInFilters);
                }

                Trace1(ERR,
                       "AddFilterInterface: Error allocating %d bytes for out filters",
                       ulSize);

                return ERROR_NOT_ENOUGH_MEMORY;
            }


            CopyMemory(picb->pOutFilter,
                       pInfo,
                       ulSize);
            
            faOutAction = pInfo->faDefaultAction;
            
            if(ulNumOutFilters isnot 0)
            {   
                ulSize = ulNumOutFilters * (sizeof(PF_FILTER_DESCRIPTOR) + 16) + 8;
                
                pfdOutFilters = HeapAlloc(IPRouterHeap,
                                          0,
                                          ulSize);

                if(pfdOutFilters is NULL)
                {
                    if(picb->pInFilter)
                    {
                        HeapFree(IPRouterHeap,
                                 0,
                                 picb->pInFilter);

                        picb->pInFilter = NULL;
                    }

                    if(pfdInFilters)
                    {
                        HeapFree(IPRouterHeap,
                                 0,
                                 pfdInFilters);
                    }

                    HeapFree(IPRouterHeap,
                             0,
                             picb->pOutFilter);

                    picb->pOutFilter = NULL;

                    Trace1(ERR,
                           "AddFilterInterface: Error allocating %d bytes",
                           ulSize);

                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                
                //
                // The address and masks come at the end
                //

                pdwAddr = (PDWORD)&(pfdOutFilters[ulNumOutFilters]);
                

                //
                // Now convert the filters
                //

                for(i = 0, j = 0; i < ulNumOutFilters; i++)
                {
                    pfdOutFilters[i].dwFilterFlags = 0;
                    pfdOutFilters[i].dwRule        = 0;
                    pfdOutFilters[i].pfatType      = PF_IPV4;

                    //
                    // Set the pointers
                    //
                
                    pfdOutFilters[i].SrcAddr = (PBYTE)&(pdwAddr[j++]);
                    pfdOutFilters[i].SrcMask = (PBYTE)&(pdwAddr[j++]);
                    pfdOutFilters[i].DstAddr = (PBYTE)&(pdwAddr[j++]);
                    pfdOutFilters[i].DstMask = (PBYTE)&(pdwAddr[j++]);

                    //
                    // Copy in the src/dst addr/masks
                    //
                    
                    *(PDWORD)pfdOutFilters[i].SrcAddr =
                        pInfo->fiFilter[i].dwSrcAddr;
                    
                    *(PDWORD)pfdOutFilters[i].SrcMask =
                        pInfo->fiFilter[i].dwSrcMask;
                    
                    *(PDWORD)pfdOutFilters[i].DstAddr =
                        pInfo->fiFilter[i].dwDstAddr;
                    
                    *(PDWORD)pfdOutFilters[i].DstMask =
                        pInfo->fiFilter[i].dwDstMask;

                    //
                    // Copy the protocol and flag
                    //
                    
                    pfdOutFilters[i].dwProtocol = pInfo->fiFilter[i].dwProtocol;
                    pfdOutFilters[i].fLateBound = pInfo->fiFilter[i].fLateBound;

                    if(pfdOutFilters[i].dwProtocol is FILTER_PROTO_TCP)
                    {
                        if(IsTcpEstablished(&(pInfo->fiFilter[i])))
                        {
                            pfdOutFilters[i].dwFilterFlags |= FD_FLAGS_NOSYN;
                        }
                    }

                    //
                    // The ports
                    //
                    
                    pfdOutFilters[i].wSrcPort  = pInfo->fiFilter[i].wSrcPort;
                    pfdOutFilters[i].wDstPort  = pInfo->fiFilter[i].wDstPort;
                    
                    //
                    // Since we dont support ranges, set the high  to 0
                    //
                    
                    pfdOutFilters[i].wSrcPortHighRange = 0;
                    
                    pfdOutFilters[i].wDstPortHighRange = 0;
                }
            }
        }
    }

    if(MprConfigGetFriendlyName(g_hMprConfig,
                                picb->pwszName,
                                rgwcName,
                                sizeof(rgwcName)) is NO_ERROR)
    {
        pName = rgwcName;
    }
    else
    {
        pName = picb->pwszName;
    }

    //
    // Now add create the interace and set the info
    //

    dwResult = PfCreateInterface(0,
                                 faInAction,
                                 faOutAction,
                                 FALSE,
                                 FALSE,
                                 &(picb->ihFilterInterface));

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "AddFilterInterface: Err %d creating filter i/f for %S",
               dwResult,
               picb->pwszName);

        RouterLogEventEx(g_hLogHandle,
                         EVENTLOG_ERROR_TYPE,
                         dwResult,
                         ROUTERLOG_IP_CANT_ADD_PFILTERIF,
                         TEXT("%S"),
                         pName);
    }
    else
    {
        //
        // Set the filters
        //

        if((ulNumInFilters + ulNumOutFilters) isnot 0)
        {
            dwResult = PfAddFiltersToInterface(picb->ihFilterInterface,
                                               ulNumInFilters,
                                               pfdInFilters,
                                               ulNumOutFilters,
                                               pfdOutFilters,
                                               NULL);
        
            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "AddFilterInterface: Err %d setting filters on %S",
                       dwResult,
                       picb->pwszName);

                RouterLogEventEx(g_hLogHandle,
                                 EVENTLOG_ERROR_TYPE,
                                 dwResult,
                                 ROUTERLOG_IP_CANT_ADD_PFILTERIF,
                                 TEXT("%S"),
                                 pName);

                PfDeleteInterface(picb->ihFilterInterface);
            }
        }
       
        if(dwResult is NO_ERROR) 
        {
            if(picb->bBound)
            {
                dwResult = BindFilterInterface(picb);
        
                if(dwResult isnot NO_ERROR)
                {
                    Trace2(ERR,
                           "AddFilterInterface: Err %d binding filters on %S",
                           dwResult,
                           picb->pwszName);

                    RouterLogEventEx(g_hLogHandle,
                                     EVENTLOG_ERROR_TYPE,
                                     dwResult,
                                     ROUTERLOG_IP_CANT_ADD_PFILTERIF,
                                     TEXT("%S"),
                                     pName);

                    PfDeleteInterface(picb->ihFilterInterface);
                }
            }
        }

        //
        // So if we successfully added filters, enable frag checking if the
        // user had asked for it. Note that the bFragCheckEnable is set up
        // in the SetFilterInterfaceInfo call.
        //

        if((dwResult is NO_ERROR) and
           (picb->bFragCheckEnable))
        {
            dwResult = PfAddGlobalFilterToInterface(picb->ihFilterInterface,
                                                    GF_FRAGCACHE);

            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "SetGlobalFilterOnIf: Error %d adding frag filter to %S",
                       dwResult,
                       picb->pwszName);

                picb->bFragCheckEnable = FALSE;

                dwResult = NO_ERROR;
            }
        }
    }

    if(pfdInFilters)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pfdInFilters);
    }   

    if(pfdOutFilters)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pfdOutFilters);
    }


    if(dwResult isnot NO_ERROR)
    {
        //
        // Something bad happened
        //

        picb->ihFilterInterface = INVALID_HANDLE_VALUE;
        
        if(picb->pInFilter)
        {
            HeapFree(IPRouterHeap,
                     0,
                     picb->pInFilter);

            picb->pInFilter = NULL;
        }
        
        if(picb->pOutFilter)
        {
            HeapFree(IPRouterHeap,
                     0,
                     picb->pOutFilter);

            picb->pOutFilter = NULL;
        }
    }

    TraceLeave("SetInterfaceFilterInfo");
        
    return dwResult;
}

DWORD
SetGlobalFilterOnIf(
    PICB                    picb,
    PRTR_INFO_BLOCK_HEADER  pInterfaceInfo
    )

/*++

Routine Description


Arguments

    picb
    pInterfaceInfo

Return Value

    NO_ERROR

--*/

{
    DWORD           dwResult;    
    PRTR_TOC_ENTRY  pFragToc;
    PIFFILTER_INFO  pGlobFilter;
    BOOL            bEnable;

    pFragToc  = GetPointerToTocEntry(IP_IFFILTER_INFO,
                                     pInterfaceInfo);

    //
    // Add global filters if any
    //

    if(pFragToc is NULL)
    {
        return NO_ERROR;
    }

    dwResult = NO_ERROR;

    if(pFragToc->InfoSize is 0)
    {
        bEnable = FALSE;
    }
    else
    {
        pGlobFilter = GetInfoFromTocEntry(pInterfaceInfo,
                                          pFragToc);

        bEnable = (pGlobFilter isnot NULL) ? pGlobFilter->bEnableFragChk :
                                             FALSE;
    }

    //
    // If the interface has not been added to the filter driver
    // just set the info
    //

    if(picb->ihFilterInterface is INVALID_HANDLE_VALUE)
    {
        picb->bFragCheckEnable = bEnable;

        return NO_ERROR;
    }


    if(!bEnable)
    {
        dwResult = NO_ERROR;

        if(picb->bFragCheckEnable)
        {
            dwResult = 
                PfRemoveGlobalFilterFromInterface(picb->ihFilterInterface,
                                                  GF_FRAGCACHE);

            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "SetGlobalFilterOnIf: Error %d removing frag filter from %S",
                       dwResult,
                       picb->pwszName);
            }
            else
            {
                picb->bFragCheckEnable = FALSE;
            }
        }

        return dwResult;
    }
    else
    {
        if(picb->bFragCheckEnable is FALSE)
        {
            dwResult = PfAddGlobalFilterToInterface(picb->ihFilterInterface,
                                                    GF_FRAGCACHE);

            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "SetGlobalFilterOnIf: Error %d adding frag filter to %S",
                       dwResult,
                       picb->pwszName);
            }
            else
            {
                picb->bFragCheckEnable = TRUE;
            }
        }
    }

    return dwResult;
}

DWORD
DeleteFilterInterface(
    PICB picb
    )

/*++

Routine Description

    This function deletes a filter interface (and all associated filters)
    Also frees the memory holding the filters

Locks

    ICB_LIST held as WRITER

Arguments

    None

Return Value

    None    

--*/

{
    DWORD                           dwInBufLen;

    TraceEnter("DeleteFilterInterface");

    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK));

    if(picb->pInFilter isnot NULL)
    {
        HeapFree(IPRouterHeap,
                 0,
                 picb->pInFilter);
        
        picb->pInFilter = NULL;
    }

    if(picb->pOutFilter isnot NULL)
    {
        HeapFree(IPRouterHeap,
                 0,
                 picb->pOutFilter);
        
        picb->pOutFilter = NULL;
    }


    if(picb->ihFilterInterface is INVALID_HANDLE_VALUE)
    {
        Trace1(IF,
               "DeleteFilterInterface: No context, assuming interface %S not added to filter driver",
               picb->pwszName);
    
        return NO_ERROR;
    }

    PfDeleteInterface(picb->ihFilterInterface);
    
    picb->ihFilterInterface  = INVALID_HANDLE_VALUE;

    TraceLeave("DeleteFilterInterface");
    
    return NO_ERROR;
}

DWORD
SetFilterInterfaceInfo(
    PICB                     picb, 
    PRTR_INFO_BLOCK_HEADER   pInterfaceInfo
    )
{
    DWORD           dwResult;
    PRTR_TOC_ENTRY  pInToc, pOutToc, pFragToc;
    
    TraceEnter("SetInterfaceFilterInfo");

    if((picb->ritType is ROUTER_IF_TYPE_DIALOUT) or
       (picb->ritType is ROUTER_IF_TYPE_LOOPBACK) or
       (picb->ritType is ROUTER_IF_TYPE_INTERNAL))
    {
        return NO_ERROR;
    }

    
    pInToc   = GetPointerToTocEntry(IP_IN_FILTER_INFO,
                                    pInterfaceInfo);

    pOutToc  = GetPointerToTocEntry(IP_OUT_FILTER_INFO,
                                    pInterfaceInfo);

    pFragToc = GetPointerToTocEntry(IP_IFFILTER_INFO,
                                    pInterfaceInfo);

    if((pInToc is NULL) and
       (pOutToc is NULL))
    {
        dwResult = NO_ERROR;

        if(pFragToc is NULL)
        {
            //
            // All NULL, means we dont need to change anything
            //
        
            Trace1(IF,
                   "SetInterfaceFilterInfo: Both filters info are NULL for %S, so leaving",
                   picb->pwszName);
       
            TraceLeave("SetInterfaceFilterInfo");
        }
        else
        {
            dwResult = SetGlobalFilterOnIf(picb,
                                           pInterfaceInfo);
        }
    
        return dwResult;
    }


    if(picb->ihFilterInterface isnot INVALID_HANDLE_VALUE)
    {
        //
        // This interface was added to the filter driver,
        // Delete it so that the filters are all deleted and then readd
        // the filters
        //

        IpRtAssert((picb->pInFilter isnot NULL) or
                   (picb->pOutFilter isnot NULL));

        dwResult = DeleteFilterInterface(picb);

        //
        // This better succeed, we dont have a failure path here
        //
        
        IpRtAssert(dwResult is NO_ERROR);
        
    }

    dwResult = AddFilterInterface(picb,
                                  pInterfaceInfo);



    TraceLeave("SetInterfaceFilterInfo");
        
    return dwResult;
}

DWORD
BindFilterInterface(
    PICB  picb
    )

/*++

Routine Description

    This function binds a filter interface to an IP interface. The IP
    interface is identified by the adapter index.
    The code assumes that the picb has a valid adapter index
    If the interface is a WAN link, the late binding information is also
    set.
    
Locks

    The ICB_LIST (which protects the ICB) needs to be locked as READER

Arguments

    picb    The ICB for the interface to be bound

Return Value

    NO_ERROR

--*/

{
    DWORD   dwResult, dwIfIndex, dwNHop;
    
    TraceEnter("BindFilterInterface");

    if (picb->ritType is ROUTER_IF_TYPE_INTERNAL)
    {
        TraceLeave("BindFilterInterface");

        return NO_ERROR;
    }
    
    IpRtAssert(picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK);

    if(picb->ihFilterInterface is INVALID_HANDLE_VALUE)
    {
        Trace1(IF,
               "BindFilterInterface: No context, assuming interface %S not added to filter driver",
               picb->pwszName);

        TraceLeave("BindFilterInterface");
        
        return NO_ERROR;
    }

    //
    // Bind the interface by index
    //

    IpRtAssert(picb->bBound);

   
    if(picb->ritType is ROUTER_IF_TYPE_CLIENT)
    {
        dwIfIndex = g_pInternalInterfaceCb->dwIfIndex;
        dwNHop    = picb->pibBindings[0].dwAddress;
    }
    else
    {
        dwIfIndex = picb->dwIfIndex;
        dwNHop    = 0;
    }

    dwResult = PfBindInterfaceToIndex(picb->ihFilterInterface,
                                      dwIfIndex,
                                      PF_IPV4,
                                      (PBYTE)&dwNHop);

    if(dwResult isnot NO_ERROR)
    {
        //
        // Some error trying to bind. Bail out of here
        //

        Trace4(ERR,
               "BindFilterInterface: Err %d binding %S to %d/%d.%d.%d.%d",
               dwResult,
               picb->pwszName,
               dwIfIndex,
               PRINT_IPADDR(dwNHop));

        TraceLeave("BindFilterInterface");
        
        return dwResult;
    }

    //
    // If this is a WAN interface, also set the late binding info
    //

#if 0    
    if(((picb->ritType is ROUTER_IF_TYPE_HOME_ROUTER) or
        (picb->ritType is ROUTER_IF_TYPE_FULL_ROUTER)) and
       (picb->dwNumAddresses isnot 0))
    {
        DWORD               rgdwLateInfo[sizeof(PF_LATEBIND_INFO)/sizeof(DWORD) + 1 + 3 + 4];

        PPF_LATEBIND_INFO   pLateBindInfo;

        pLateBindInfo = rgdwLateInfo;

        pvStart = (PBYTE)pLateBindInfo + 3 
        lateBindInfo.dwSrcAddr  = picb->pibBindings[0].dwAddress;
        lateBindInfo.dwDstAddr  = picb->dwRemoteAddress;
        lateBindInfo.dwMask     = picb->pibBindings[0].dwMask;

        dwResult = PfRebindFilters(picb->ihFilterInterface,
                                   &lateBindInfo);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "BindFilterInterface: Err %d rebinding to %S",
                   dwResult,
                   picb->pwszName);
        }
    }

#endif
            
    TraceLeave("BindFilterInterface");

    return dwResult;
}


DWORD
UnbindFilterInterface(
    PICB  picb
    )

/*++

Routine Description

    This function unbinds a filter interface 
    
Locks

    The ICB_LIST (which protects the ICB) needs to be locked as READER

Arguments

    picb    The ICB for the interface to be bound

Return Value

    NO_ERROR

--*/

{
    DWORD   dwResult;
    
    TraceEnter("UnbindFilterInterface");
    
    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK) and
               (picb->ritType isnot ROUTER_IF_TYPE_CLIENT))

    if(picb->ihFilterInterface is INVALID_HANDLE_VALUE)
    {
        Trace1(IF,
               "UnbindFilterInterface: No context, assuming interface %S not added to filter driver",
               picb->pwszName);

        TraceLeave("UnbindFilterInterface");
        
        return NO_ERROR;
    }

    dwResult = PfUnBindInterface(picb->ihFilterInterface);
    
    if(dwResult isnot NO_ERROR)
    {
        //
        // Some error trying to bind. Bail out of here
        //

        Trace2(ERR,
               "UnbindFilterInterface: Err %d binding to %S",
               dwResult,
               picb->pwszName);
    }
            
    TraceLeave("UnbindFilterInterface");

    return dwResult;
}

DWORD
GetInFilters(
    PICB                      picb, 
    PRTR_TOC_ENTRY            pToc, 
    PBYTE                     pbDataPtr, 
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    PDWORD                    pdwSize
    )
{
    DWORD                       dwInBufLen,i;
    
    TraceEnter("GetInFilters");
   
    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK));

    //
    // Set size returned to 0
    //
    
    *pdwSize = 0;

    //
    // Safe init of both the TOCs. 
    //
    
    // pToc->InfoVersion = IP_IN_FILTER_INFO;
    pToc->InfoType    = IP_IN_FILTER_INFO;
    pToc->Count       = 0;
    pToc->InfoSize    = 0;
    
    if((picb->ihFilterInterface is INVALID_HANDLE_VALUE) or
       (picb->pInFilter is NULL))
    {
        Trace1(IF,
               "GetInFilters: No context or no filters for %S",
               picb->pwszName);
    
        return ERROR_NO_DATA;
    }

    //
    // Set the offset in the TOC
    //
    
    pToc->Offset   = (ULONG)(pbDataPtr - (PBYTE)pInfoHdrAndBuffer);
    pToc->Count    = 1;
    pToc->InfoSize = FIELD_OFFSET(FILTER_DESCRIPTOR,fiFilter[0]) +
                       (picb->pInFilter->dwNumFilters * sizeof(FILTER_INFO));
   
    //
    // Just copy out the filters
    //
    
    CopyMemory(pbDataPtr,
               picb->pInFilter,
               pToc->InfoSize);

    //
    // The size copied in
    //
    
    *pdwSize = pToc->InfoSize;
        
    TraceLeave("GetInFilters");
        
    return NO_ERROR;
}

DWORD
GetOutFilters(
    PICB                      picb, 
    PRTR_TOC_ENTRY            pToc, 
    PBYTE                     pbDataPtr, 
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    PDWORD                    pdwSize
    )
{
    DWORD       dwInBufLen,i;
    
    TraceEnter("GetOutFilters");
   
    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK));

    //
    // Set size returned to 0
    //
    
    *pdwSize = 0;

    //
    // Safe init of both the TOCs. 
    //
    
    //pToc->InfoVersion = IP_OUT_FILTER_INFO;
    pToc->InfoType    = IP_OUT_FILTER_INFO;
    pToc->Count       = 0;
    pToc->InfoSize    = 0;
    
    if((picb->ihFilterInterface is INVALID_HANDLE_VALUE) or
       (picb->pOutFilter is NULL))
    {
        Trace1(IF,
               "GetOutFilters: No context or no filters for %S",
               picb->pwszName);
        
        return ERROR_NO_DATA;
    }

    //
    // Set the offset in the TOC
    //
    
    pToc->Offset   = (ULONG)(pbDataPtr - (PBYTE)pInfoHdrAndBuffer);
    pToc->Count    = 1;
    pToc->InfoSize = FIELD_OFFSET(FILTER_DESCRIPTOR,fiFilter[0]) +
                       (picb->pOutFilter->dwNumFilters * sizeof(FILTER_INFO));
   
    //
    // Just copy out the filters
    //
    
    CopyMemory(pbDataPtr,
               picb->pOutFilter,
               pToc->InfoSize);

    //
    // The size copied in
    //
    
    *pdwSize = pToc->InfoSize;
        
    TraceLeave("GetOutFilters");
        
    return NO_ERROR;
}

DWORD
GetGlobalFilterOnIf(
    PICB                      picb, 
    PRTR_TOC_ENTRY            pToc, 
    PBYTE                     pbDataPtr, 
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    PDWORD                    pdwSize
    )
{
    DWORD       dwInBufLen,i;
    
    TraceEnter("GetGlobalFilterOnIf");
   
    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK) and
               (picb->ritType isnot ROUTER_IF_TYPE_CLIENT));

    
    //pToc->InfoVersion = IP_IFFILTER_INFO;
    pToc->InfoType = IP_IFFILTER_INFO;
    pToc->Offset   = (ULONG)(pbDataPtr - (PBYTE)pInfoHdrAndBuffer);
    pToc->Count    = 1;
    pToc->InfoSize = sizeof(IFFILTER_INFO);
   
    
    ((PIFFILTER_INFO)pbDataPtr)->bEnableFragChk = picb->bFragCheckEnable;

    //
    // The size copied in
    //
    
    *pdwSize = pToc->InfoSize;
        
    TraceLeave("GetOutFilters");
        
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\filter.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\filter.h

Abstract:

    Function declarations for filter.c

Revision History:

    Gurdeep Singh Pall          6/15/95  Created

--*/


DWORD
AddFilterInterface(
    PICB                    picb,
    PRTR_INFO_BLOCK_HEADER  pInterfaceInfo
    );

DWORD
SetGlobalFilterOnIf(
    PICB                    picb,
    PRTR_INFO_BLOCK_HEADER  pInterfaceInfo
    );

DWORD
DeleteFilterInterface(
    PICB picb
    );

DWORD
SetFilterInterfaceInfo(
    PICB                   picb,
    PRTR_INFO_BLOCK_HEADER pInterfaceInfo
    );

DWORD
BindFilterInterface(
    PICB  picb
    );

DWORD
UnbindFilterInterface(
    PICB  picb
    );

DWORD
GetInFilters(
    PICB                      picb,
    PRTR_TOC_ENTRY            pToc,
    PBYTE                     pbDataPtr,
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    PDWORD                    pdwSize
    );

DWORD
GetOutFilters(
    PICB                      picb,
    PRTR_TOC_ENTRY            pToc,
    PBYTE                     pbDataPtr,
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    PDWORD                    pdwSize
    );

DWORD
GetGlobalFilterOnIf(
    PICB                      picb,
    PRTR_TOC_ENTRY            pToc,
    PBYTE                     pbDataPtr,
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    PDWORD                    pdwSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\globals.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\globals.h

Abstract:

    Header for IP Router Manager globals

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/

#ifndef __GLOBALS_H__
#define __GLOBALS_H__

//
// Interface Control Block (ICB) list.
//

LIST_ENTRY  ICBList ;

//
// Hash lookup for mapping interfaceids to picb
//

LIST_ENTRY  ICBHashLookup[ICB_HASH_TABLE_SIZE];

//
// Hash lookup for mapping ICB sequence number to picb
//

LIST_ENTRY  ICBSeqNumLookup[ICB_HASH_TABLE_SIZE];

//
// Hash lookup for bindings
//

LIST_ENTRY  g_leBindingTable[BINDING_HASH_TABLE_SIZE];


//
// Hash table for interface to adapter mapping
//

//LIST_ENTRY  g_rgleAdapterMapTable[ADAPTER_HASH_TABLE_SIZE];

//
// Routing Protocols list
//

LIST_ENTRY  g_leProtoCbList;

//
// Timer Queue for Router Discovery advts
//

LIST_ENTRY g_leTimerQueueHead;

//
// Trace Handle used for traces/logging
//

DWORD  TraceHandle ;

//
// Handle used for logging events
//

HANDLE g_hLogHandle;

//
// Level of logging 
//

DWORD g_dwLoggingLevel;

//
// Flag indicating if the router is being started in LAN only or 
// LAN and WAN mode.
//

BOOL    RouterRoleLanOnly ;

//
// Handle to the heap used for all allocations
//

HANDLE  IPRouterHeap ;

//
// Info useful in making RTMv2 calls
//

RTM_REGN_PROFILE  g_rtmProfile;

//
// RTM Handle for static/admin routes
//

HANDLE  g_hLocalRoute;
HANDLE  g_hAutoStaticRoute;
HANDLE  g_hStaticRoute;
HANDLE  g_hNonDodRoute;
HANDLE  g_hNetMgmtRoute;

// RTM handle for obtaining notifications

HANDLE  g_hNotification;

//
// RTM handle for obtaining default route notifications
//

HANDLE  g_hDefaultRouteNotification;

//
// Handle to event used for stopping the IP Router
//

HANDLE  g_hStopRouterEvent ;

//
// Handle to event used for demand dial
//

HANDLE  g_hDemandDialEvent ;

#ifdef KSL_IPINIP
//
// Handle to event used for demand dial
//

HANDLE  g_hIpInIpEvent;
#endif //KSL_IPINIP

//
// Handle to event used for stack change notifications
//

HANDLE  g_hStackChangeEvent;

//
// Handle to event used request forwarding change from worker
//

HANDLE  g_hSetForwardingEvent;

//
// Handle to event used to get notification about forwarding changes
//

HANDLE  g_hForwardingChangeEvent;

//
// Handle to event used by Routing Protocols for notification
//

HANDLE  g_hRoutingProtocolEvent ;

//
// Timer to handle Router discover advts
//

HANDLE g_hRtrDiscTimer;

//
// Timer to handle Ras Server advertisements
//

HANDLE g_hRasAdvTimer;

//
// Timer to handle MZAP advertisements
//

HANDLE g_hMzapTimer;

//
// Event for Winsock2
//

HANDLE g_hRtrDiscSocketEvent;

//
// Event for mrinfo/mtrace services
//

HANDLE g_hMcMiscSocketEvent;
WSABUF g_wsaMcRcvBuf;
BYTE   g_byMcMiscBuffer[1500];


HANDLE g_hMcastEvents[NUM_MCAST_IRPS];

//
// Events for Route Change notifications
//

HANDLE g_hRouteChangeEvents[NUM_ROUTE_CHANGE_IRPS];


//
// Handle to WANARP device
//

HANDLE  g_hWanarpRead;
HANDLE  g_hWanarpWrite;

//
// Count of all routing protocols configured
//

DWORD TotalRoutingProtocols ;

//
// Lock for tracking router usage: this facilitates stop router functionality
//

CRITICAL_SECTION    RouterStateLock ;

//
// Structure keeping the router state
//

IPRouterState         RouterState ;

//
// used for WANARP demand dial mechanism
//

WANARP_NOTIFICATION     wnWanarpMsg;
OVERLAPPED              WANARPOverlapped;

//
// Critical section for the forwarding state data
//

CRITICAL_SECTION        g_csFwdState;

//
// The last request to the worker thread
//

BOOL                    g_bEnableFwdRequest;

//
// The last action by the worker
//

BOOL                    g_bFwdEnabled;

//
// Should we set routes to the stack?
//

BOOL                    g_bSetRoutesToStack;

//
// Flag indicating if NETBT proxy should be enabled
//

BOOL                    g_bEnableNetbtBcastFrowarding;

//
// The NETBT proxy mode prior to starting RRAS
//

DWORD                   g_dwOldNetbtProxyMode;

//
// copy of the support functions Routing Protocols need
//

extern SUPPORT_FUNCTIONS        g_sfnDimFunctions;

//
// Router Discovery stuff
//

extern PICMP_ROUTER_ADVT_MSG    g_pIcmpAdvt;
extern SOCKADDR_IN              g_sinAllSystemsAddr;
extern WSABUF                   g_wsabufICMPAdvtBuffer;
extern WSABUF                   g_wsaIpRcvBuf;

//
// Buffer to hold maximum length IP header and 8 bytes of the ICMP packet
//

DWORD  g_pdwIpAndIcmpBuf[ICMP_RCV_BUFFER_LEN];

PIP_HEADER g_pIpHeader;

//
// externs defined in exdeclar.h
//

//
// The CB for the Internal Interface
//

extern PICB   g_pInternalInterfaceCb;

//
// The CB for the Loopback Interface
//

extern PICB   g_pLoopbackInterfaceCb;

//
// Counter for sequence numbers
//

extern DWORD    g_dwNextICBSeqNumberCounter;

//
// Number of addresses in the system
//

extern ULONG    g_ulNumBindings;
extern ULONG    g_ulNumInterfaces;
extern ULONG    g_ulNumNonClientInterfaces;

extern HANDLE g_hIpDevice;
extern HANDLE g_hMcastDevice;
extern HANDLE g_hIpRouteChangeDevice;

extern BOOL   g_bUninitServer;

extern IP_CACHE  g_IpInfo;
extern TCP_CACHE g_TcpInfo;
extern UDP_CACHE g_UdpInfo;

extern HANDLE   g_hIfHeap;
extern HANDLE   g_hIpAddrHeap;
extern HANDLE   g_hIpForwardHeap;
extern HANDLE   g_hIpNetHeap;
extern HANDLE   g_hTcpHeap;
extern HANDLE   g_hUdpHeap;

LIST_ENTRY          g_leStackRoutesToRestore;

ULONG   g_ulGatewayCount;
ULONG   g_ulGatewayMaxCount;

PGATEWAY_INFO   g_pGateways;


extern HANDLE    g_hMibRtmHandle;

extern DWORD g_TimeoutTable[NUM_CACHE];

extern DWORD (*g_LoadFunctionTable[NUM_CACHE])();

extern DWORD 
(*g_AccessFunctionTable[NUMBER_OF_EXPORTED_VARIABLES])(DWORD dwQueryType, 
                                                       DWORD dwInEntrySize, 
                                                       PMIB_OPAQUE_QUERY lpInEntry, 
                                                       LPDWORD lpOutEntrySize, 
                                                       PMIB_OPAQUE_INFO lpOutEntry,
                                                       LPBOOL lpbCache);

                    
extern DWORD g_LastUpdateTable[NUM_CACHE];
extern DWORD g_dwStartTime;

extern RTL_RESOURCE g_LockTable[NUM_LOCKS];

extern MCAST_OVERLAPPED g_rginMcastMsg[NUM_MCAST_IRPS];

extern IPNotifyData g_IpNotifyData;
extern ROUTE_CHANGE_INFO g_rgIpRouteNotifyOutput[NUM_ROUTE_CHANGE_IRPS];

#ifdef KSL_IPINIP
extern HKEY         g_hIpIpIfKey;
#endif //KSL_IPINIP

extern HANDLE       g_hMHbeatSocketEvent;

extern HANDLE       g_hMzapSocketEvent;

//
// Entrypoints into DIM
//

DWORD (*ConnectInterface)(IN HANDLE hDIMInterface, IN DWORD dwProtocolId);

DWORD (*DisconnectInterface)(IN HANDLE hDIMInterface, IN DWORD dwProtocolId);

DWORD
(*SaveInterfaceInfo)(
    IN HANDLE hDIMInterface,
    IN DWORD dwProtocolId,
    IN LPVOID pInterfaceInfo,
    IN DWORD cBInterfaceInfoSize
    );

DWORD
(*RestoreInterfaceInfo)(
    IN HANDLE hDIMInterface,
    IN DWORD dwProtocolId,
    IN LPVOID lpInterfaceInfo,
    IN LPDWORD lpcbInterfaceInfoSize
    );


VOID  (*RouterStopped)(IN DWORD dwProtocolId, IN DWORD dwError);


DWORD
(APIENTRY *SaveGlobalInfo)(
            IN      DWORD           dwProtocolId,
            IN      LPVOID          pGlobalInfo,
            IN      DWORD           cbGlobalInfoSize );

VOID
(APIENTRY *EnableInterfaceWithDIM)(
            IN      HANDLE          hDIMInterface,
            IN      DWORD           dwProtocolId,
            IN      BOOL            fEnabled);


//
// Callbacks into MGM
//

PMGM_INDICATE_MFE_DELETION          g_pfnMgmMfeDeleted;
PMGM_NEW_PACKET_INDICATION          g_pfnMgmNewPacket;
PMGM_BLOCK_GROUPS                   g_pfnMgmBlockGroups;
PMGM_UNBLOCK_GROUPS                 g_pfnMgmUnBlockGroups;
PMGM_WRONG_IF_INDICATION            g_pfnMgmWrongIf;


INFO_CB     g_rgicInfoCb[NUM_INFO_CBS];

CHAR    g_rgcLoopbackString[MAXLEN_IFDESCR + 1];
CHAR    g_rgcInternalString[MAXLEN_IFDESCR + 1];
CHAR    g_rgcWanString[MAXLEN_IFDESCR + 1];
#ifdef KSL_IPINIP
CHAR    g_rgcIpIpString[MAXLEN_IFDESCR + 1];
#endif //KSL_IPINIP

HINSTANCE   g_hOwnModule;

HANDLE      g_hMprConfig;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\info.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\info.h

Abstract:

    Header for info.c

Revision History:

    Gurdeep Singh Pall          6/15/95  Created

--*/

//
// Routes, filters, demand filters, nat, mcast boundaries
//

#define NUM_INFO_CBS    5
#ifdef KSL_IPINIP
#define NUM_INFO_CBS    6
#endif //KSL_IPINIP

typedef 
DWORD
(*PINFOCB_GET_IF_INFO)(
    IN     PICB                   picb,
    IN OUT PRTR_TOC_ENTRY         pToc,
    IN OUT PDWORD                 pdwTocIndex,
    IN OUT PBYTE                  pbDataPtr,
    IN     PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwInfoSize
    );


typedef 
DWORD
(*PINFOCB_SET_IF_INFO)(
    IN  PICB                    picb,
    IN  PRTR_INFO_BLOCK_HEADER  pInterfaceInfo
    );

typedef
DWORD
(*PINFOCB_BIND_IF)(
    IN  PICB                    picb
    );

typedef 
DWORD
(*PINFOCB_GET_GLOB_INFO)(
    IN OUT PRTR_TOC_ENTRY         pToc,
    IN OUT PDWORD                 pdwTocIndex,
    IN OUT PBYTE                  pbDataPtr,
    IN     PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwInfoSize
    );

typedef struct _INFO_CB
{
    PCHAR                   pszInfoName;
    PINFOCB_GET_IF_INFO     pfnGetInterfaceInfo;
    PINFOCB_SET_IF_INFO     pfnSetInterfaceInfo;
    PINFOCB_BIND_IF         pfnBindInterface;
    PINFOCB_GET_GLOB_INFO   pfnGetGlobalInfo;

}INFO_CB, *PINFO_CB;


PRTR_TOC_ENTRY
GetPointerToTocEntry(
    DWORD                     dwType, 
    PRTR_INFO_BLOCK_HEADER    pInfoHdr
    );

DWORD
GetSizeOfInterfaceConfig(
    PICB   picb
    );


DWORD
GetInterfaceConfiguration(
    PICB                      picb,
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    DWORD                     dwInfoSize
    );

DWORD
GetInterfaceRoutingProtoInfo(
    PICB                   picb, 
    PPROTO_CB              pProtoCbPtr,
    PRTR_TOC_ENTRY         pToc,
    PBYTE                  pbDataPtr, 
    PRTR_INFO_BLOCK_HEADER pInfoHdrAndBuffer,
    PDWORD                 pdwSize
    );


DWORD
GetGlobalConfiguration(
    PRTR_INFO_BLOCK_HEADER   pInfoHdrAndBuffer,
    DWORD                    dwInfoSize
    );

DWORD
GetSizeOfGlobalInfo(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\info.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\rtrmgr\info.c

Abstract:
    All info structure related code lives here

Revision History:

    Gurdeep Singh Pall          6/15/95  Created

--*/

#include "allinc.h"

PRTR_TOC_ENTRY
GetPointerToTocEntry(
    DWORD                     dwType, 
    PRTR_INFO_BLOCK_HEADER    pInfoHdr
    )

/*++

Routine Description

    Given a pointer to an InfoBlock, this returns a pointer to the
    TOC of a given type

Locks

    None

Arguments

    dwType      InfoType for TOC
    pInfoHdr    Pointer to the InfoBlock header
    
Return Value

    NULL if the structure was not found
    Pointer to TOC other wise

--*/

{
    DWORD   i;

    if(pInfoHdr is NULL)
    {
        return NULL;
    }

    for(i = 0; i < pInfoHdr->TocEntriesCount; i++) 
    {
        if(pInfoHdr->TocEntry[i].InfoType is dwType) 
        {
            return &(pInfoHdr->TocEntry[i]);
        }
    }

    return NULL;
}


DWORD
GetSizeOfInterfaceConfig(
    PICB   picb
    )

/*++

Routine Description

    This function figures out the size of interface configuration

Locks

    ICB_LIST lock taken as READER
    Takes the PROTOCOL_CB_LIST lock as reader
    
Arguments

    picb    ICB for the interface

Return Value

    None    

--*/

{
    DWORD        dwRoutProtInfoSize,dwRouteCount;
    PLIST_ENTRY  pleNode;
    DWORD        dwSize = 0, dwNumFilters;
    DWORD        dwResult;
    DWORD        dwInfoSize, i;
    ULONG        ulStructureSize, ulStructureVersion, ulStructureCount;
    TraceEnter("GetSizeOfInterfaceConfig");

    //
    // Start with just the header (no TOC entry)
    //
    
    dwSize = FIELD_OFFSET(RTR_INFO_BLOCK_HEADER,
                          TocEntry[0]);
    
    //
    // Static Routes:
    // Get the count, figure out the size needed to hold those, add the
    // size of a TOC and an ALIGN_SIZE added for alignment
    //
    
    dwRouteCount = GetNumStaticRoutes(picb);
    
    dwSize += (SIZEOF_ROUTEINFO(dwRouteCount) +
               sizeof(RTR_TOC_ENTRY) +
               ALIGN_SIZE);

    //
    // Router Discovery info
    //
    
    dwSize += (sizeof(RTR_DISC_INFO) +
               sizeof(RTR_TOC_ENTRY) +
               ALIGN_SIZE);

    //
    // Interface Status info
    //

    dwSize += (sizeof(INTERFACE_STATUS_INFO) +
               sizeof(RTR_TOC_ENTRY) +
               ALIGN_SIZE);

#ifdef KSL_IPINIP
    //
    // If this is an ip in ip interface, add that info
    //

    if(picb->ritType is ROUTER_IF_TYPE_TUNNEL1)
    {
        dwSize += (sizeof(IPINIP_CONFIG_INFO) +
                   sizeof(RTR_TOC_ENTRY) +
                   ALIGN_SIZE);
    }
#endif //KSL_IPINIP

    for(i = 0; i < NUM_INFO_CBS; i++)
    {
        if (!g_rgicInfoCb[i].pfnGetInterfaceInfo)
            continue;

        dwInfoSize = 0;

        dwResult = g_rgicInfoCb[i].pfnGetInterfaceInfo(picb,
                                                       NULL,
                                                       NULL,
                                                       NULL,
                                                       NULL,
                                                       &dwInfoSize);

        if((dwResult isnot NO_ERROR) and
           (dwResult isnot ERROR_INSUFFICIENT_BUFFER))
        {
            //
            // The only errors which will tell us the size needed are
            // NO_ERROR and ERROR_INSUFFICIENT_BUFFER. Anything else means
            // we didnt get the right size
            //
            
            Trace2(ERR,
                   "GetSizeOfInterfaceConfig: Error %d in GetIfInfo for %s\n",
                   dwResult,
                   g_rgicInfoCb[i].pszInfoName);
            
            continue;
        }

        dwSize += (dwInfoSize +
                   sizeof(RTR_TOC_ENTRY) +
                   ALIGN_SIZE); 
    }

    //
    // Information for all routing protocols ON THIS interface
    //
    
    ENTER_READER(PROTOCOL_CB_LIST);

    for(pleNode = picb->leProtocolList.Flink;
        pleNode isnot &(picb->leProtocolList);
        pleNode = pleNode->Flink)
    {
        PIF_PROTO  pProto;
        
        pProto = CONTAINING_RECORD(pleNode,IF_PROTO,leIfProtoLink);
       
        if(pProto->bPromiscuous)
        {
            //
            // This interface was added merely because of promiscuous mode
            //

            continue;
        }

        //
        // Call the routing protocol's GetInterfaceConfigInfo() entrypoint
        // with a NULL buffer. This will cause it to tell us the size of
        // its config
        //
        
        dwRoutProtInfoSize = 0;

        dwResult = (pProto->pActiveProto->pfnGetInterfaceInfo)(
                       picb->dwIfIndex, 
                       NULL, 
                       &dwRoutProtInfoSize,
                       &ulStructureVersion,
                       &ulStructureSize,
                       &ulStructureCount);
        
        if((dwResult isnot NO_ERROR) and
           (dwResult isnot ERROR_INSUFFICIENT_BUFFER))
        {
            //
            // The only errors which will tell us the size needed are
            // NO_ERROR and ERROR_INSUFFICIENT_BUFFER. Anything else means
            // we didnt get the right size
            //
            
            Trace2(ERR,
                   "GetSizeOfInterfaceConfig: Error %d in GetIfInfo for %S\n",
                   dwResult,
                   pProto->pActiveProto->pwszDisplayName);
            
            continue;
        }
        
        dwSize += (dwRoutProtInfoSize +
                   sizeof(RTR_TOC_ENTRY) +
                   ALIGN_SIZE); 
    }

    EXIT_LOCK(PROTOCOL_CB_LIST);

    //
    // If we have filters on this interface, add that info
    //
    
    if(picb->pInFilter)
    {
        dwNumFilters = picb->pInFilter->dwNumFilters;

        
        dwSize += (sizeof(RTR_TOC_ENTRY) +
                   FIELD_OFFSET(FILTER_DESCRIPTOR, fiFilter[0]) +
                   (dwNumFilters * sizeof(FILTER_INFO)) +
                   ALIGN_SIZE);
    }

    if(picb->pOutFilter)
    {
        dwNumFilters = picb->pOutFilter->dwNumFilters;

        
        dwSize += (sizeof(RTR_TOC_ENTRY) +
                   FIELD_OFFSET(FILTER_DESCRIPTOR, fiFilter[0]) +
                   (dwNumFilters * sizeof(FILTER_INFO)) +
                   ALIGN_SIZE);
    }

    //
    // Always report the fragmentation filter.
    //

    dwSize += (sizeof(IFFILTER_INFO) +
               sizeof(RTR_TOC_ENTRY) +
               ALIGN_SIZE);

    
    if(picb->pDemandFilter)
    {
        dwNumFilters = picb->pDemandFilter->dwNumFilters;

        
        dwSize += (sizeof(RTR_TOC_ENTRY) +
                   FIELD_OFFSET(FILTER_DESCRIPTOR, fiFilter[0]) +
                   (dwNumFilters * sizeof(FILTER_INFO)) +
                   ALIGN_SIZE);
    }

    return dwSize;
}


DWORD
GetInterfaceConfiguration(
    PICB                      picb,
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    DWORD                     dwInfoSize
    )
{
    DWORD                   i,dwErr, dwRet;
    DWORD                   dwTocIndex;
    PBYTE                   pbyDataPtr , pbyEndPtr;
    DWORD                   dwNumTocEntries;
    LONG                    lSize;
    PLIST_ENTRY             pleNode;

    TraceEnter("GetInterfaceConfiguration");
   
    dwRet = NO_ERROR;
 
    //
    // First calculate number of TOCs
    //

    //
    // for static routes, router discovery, interface info and frag info
    //
    
    dwNumTocEntries = TOCS_ALWAYS_IN_INTERFACE_INFO;

    //
    // One TOC for each filter that exists
    //
    
    if(picb->pInFilter)
    {
        dwNumTocEntries++;
    }

    if(picb->pOutFilter)
    {
        dwNumTocEntries++;
    }

    if(picb->pDemandFilter)
    {
        dwNumTocEntries++;
    }

#ifdef KSL_IPINIP
    if(picb->ritType is ROUTER_IF_TYPE_TUNNEL1)
    {
        dwNumTocEntries++;
    }
#endif //KSL_IPINIP

    for(i = 0; i < NUM_INFO_CBS; i++)
    {
        if (!g_rgicInfoCb[i].pfnGetInterfaceInfo)
            continue;

        lSize = 0;

        dwErr = g_rgicInfoCb[i].pfnGetInterfaceInfo(picb,
                                     NULL,
                                     &dwNumTocEntries,
                                     NULL,
                                     NULL,
                                     &lSize);
    }


    //
    // One TOC for each configured protocol
    //

    // *** Exclusion Begin ***
    ENTER_READER(PROTOCOL_CB_LIST);

    for(pleNode = picb->leProtocolList.Flink;
        pleNode isnot &(picb->leProtocolList);
        pleNode = pleNode->Flink)
    {
        PIF_PROTO  pProto;

        pProto = CONTAINING_RECORD(pleNode,IF_PROTO,leIfProtoLink);

        if(pProto->bPromiscuous)
        {
            continue;
        }

        dwNumTocEntries++;
    }

    //
    // fill in RTR_INFO_BLOCK_HEADER
    //
    
    dwTocIndex = 0;

    pInfoHdrAndBuffer->Version          = IP_ROUTER_MANAGER_VERSION;
    pInfoHdrAndBuffer->TocEntriesCount  = dwNumTocEntries;
    pInfoHdrAndBuffer->Size             = dwInfoSize;
    
    //
    // Data begins after TocEntry[dwNumTocEntries - 1]
    //
    
    pbyDataPtr = ((PBYTE) &(pInfoHdrAndBuffer->TocEntry[dwNumTocEntries]));

    //
    // Align to an 8byte boundary
    //
    
    ALIGN_POINTER(pbyDataPtr);
    
    pbyEndPtr = (PBYTE)pInfoHdrAndBuffer + dwInfoSize;
    
    //
    // So the size of buffer left for information is
    //
    
    lSize =  (LONG)(pbyEndPtr - pbyDataPtr);
    
    //
    // fill in routing protocol info
    //
    
    
    for(pleNode = picb->leProtocolList.Flink;
        pleNode isnot &(picb->leProtocolList);
        pleNode = pleNode->Flink)
    {
        PIF_PROTO  pProto;
        
        pProto = CONTAINING_RECORD(pleNode,IF_PROTO,leIfProtoLink);
        
        if(pProto->bPromiscuous)
        {
            //
            // This interface was added merely because of promiscuous mode
            //

            continue;
        }

        if(lSize <= 0)
        {
            Trace0(ERR,
                   "GetInterfaceConfiguration: There is no more space left to fill in config info even though there are more protocols");

            break;
        }
            
        dwErr = GetInterfaceRoutingProtoInfo(
                    picb, 
                    pProto->pActiveProto, 
                    &pInfoHdrAndBuffer->TocEntry[dwTocIndex++], 
                    pbyDataPtr, 
                    pInfoHdrAndBuffer, 
                    &lSize);
        
        if(dwErr isnot NO_ERROR)
        {
            Trace2(ERR,
                   "GetInterfaceConfiguration: Info from %S. Error %d",
                   pProto->pActiveProto->pwszDisplayName,
                   dwErr);

            dwRet = ERROR_MORE_DATA;
        }
        else
        {
            pbyDataPtr += lSize;
            ALIGN_POINTER(pbyDataPtr);
        }
            
        lSize =  (LONG)(pbyEndPtr - pbyDataPtr);
    }

    EXIT_LOCK(PROTOCOL_CB_LIST);

    if(lSize <= 0)
    {
        Trace0(ERR,
               "GetInterfaceConfiguration: There is no more space left to fill in config info");
        
        return ERROR_MORE_DATA;
    }


    for(i = 0; i < NUM_INFO_CBS; i++)
    {
        if (!g_rgicInfoCb[i].pfnGetInterfaceInfo)
            continue;

        dwErr = g_rgicInfoCb[i].pfnGetInterfaceInfo(picb,
                                     &pInfoHdrAndBuffer->TocEntry[dwTocIndex],
                                     &dwTocIndex,
                                     pbyDataPtr,
                                     pInfoHdrAndBuffer,
                                     &lSize);

        if(dwErr isnot NO_ERROR)
        {
            Trace2(ERR,
                   "GetInterfaceConfiguration: Error %d getting %s info.",
                   dwErr,
                   g_rgicInfoCb[i].pszInfoName);

            if(dwErr isnot ERROR_NO_DATA)
            {
                dwRet = ERROR_MORE_DATA;
            }
        }
        else
        {
            pbyDataPtr += lSize;

            ALIGN_POINTER(pbyDataPtr);
        }

        lSize =  (LONG) (pbyEndPtr - pbyDataPtr);
    }

#ifdef KSL_IPINIP
    if(picb->ritType is ROUTER_IF_TYPE_TUNNEL1)
    {
        dwErr = GetInterfaceIpIpInfo(picb,
                                     &pInfoHdrAndBuffer->TocEntry[dwTocIndex++],
                                     pbyDataPtr,
                                     pInfoHdrAndBuffer,
                                     &lSize);

        if(dwErr isnot NO_ERROR)
        {
            Trace1(ERR,
                   "GetInterfaceConfiguration: Couldnt ipip info. Error %d",
                   dwErr);

            if(dwErr isnot ERROR_NO_DATA)
            {
                dwRet = ERROR_MORE_DATA;
            }
        }
        else
        {
            pbyDataPtr += lSize;

            ALIGN_POINTER(pbyDataPtr);
        }

        lSize =  (LONG) (pbyEndPtr - pbyDataPtr);
    }
#endif //KSL_IPINIP

        
    //
    // fill in route info
    //

    
    dwErr = GetInterfaceRouteInfo(picb, 
                                  &pInfoHdrAndBuffer->TocEntry[dwTocIndex++], 
                                  pbyDataPtr, 
                                  pInfoHdrAndBuffer,
                                  &lSize);
    
    if(dwErr isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetInterfaceConfiguration: Couldnt Interface route info. Error %d",
               dwErr);

        if(dwErr isnot ERROR_NO_DATA)
        {
            dwRet = ERROR_MORE_DATA;
        }
    }
    else
    {
        pbyDataPtr += lSize;
        
        ALIGN_POINTER(pbyDataPtr);
    }
        
    lSize =  (LONG) (pbyEndPtr - pbyDataPtr);

    if(lSize <= 0)
    {
        Trace0(ERR,
               "GetInterfaceConfiguration: There is no more space left to fill in config info");
        
        return ERROR_MORE_DATA;
    }
     
    //
    // Fill in the status info
    //

    dwErr = GetInterfaceStatusInfo(picb,
                                   &pInfoHdrAndBuffer->TocEntry[dwTocIndex++],
                                   pbyDataPtr,
                                   pInfoHdrAndBuffer,
                                   &lSize);

    if(dwErr isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetInterfaceConfiguration: Error %d getting Interface status",
               dwErr);

        if(dwErr isnot ERROR_NO_DATA)
        {
            dwRet = ERROR_MORE_DATA;
        }
    }
    else
    {
        pbyDataPtr += lSize;

        ALIGN_POINTER(pbyDataPtr);
    }

    lSize =  (LONG) (pbyEndPtr - pbyDataPtr);

    if(lSize <= 0)
    {
        Trace0(ERR,
               "GetInterfaceConfiguration: There is no more space left to fill in config info");
        
        return ERROR_MORE_DATA;
    }
     
    //
    // Fill in the Router Discovery information
    //
    
    dwErr = GetInterfaceRouterDiscoveryInfo(
                picb, 
                &pInfoHdrAndBuffer->TocEntry[dwTocIndex++],
                pbyDataPtr, 
                pInfoHdrAndBuffer,
                &lSize);

    if(dwErr isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetInterfaceConfiguration: Couldnt Interface router discovery info. Error %d",
               dwErr);

        if(dwErr isnot ERROR_NO_DATA)
        {
            dwRet = ERROR_MORE_DATA;
        }
    }
    else
    {
        pbyDataPtr += lSize;

        ALIGN_POINTER(pbyDataPtr);
    }

    lSize =  (LONG) (pbyEndPtr - pbyDataPtr);

    if(lSize <= 0)
    {
        Trace0(ERR,
               "GetInterfaceConfiguration: There is no more space left to fill in config info");
        
        return ERROR_MORE_DATA;
    }
     
    if(picb->pInFilter)
    {
        dwErr = GetInFilters(picb,
                             &pInfoHdrAndBuffer->TocEntry[dwTocIndex], 
                             pbyDataPtr, 
                             pInfoHdrAndBuffer, 
                             &lSize);
        
        if(dwErr is NO_ERROR)
        {
            dwTocIndex++;
            
            pbyDataPtr += lSize;
            
            ALIGN_POINTER(pbyDataPtr);
        }
        else
        {
            if(dwErr isnot ERROR_NO_DATA)
            {
                dwRet = ERROR_MORE_DATA;
            }
        }
        
        lSize =  (LONG) (pbyEndPtr - pbyDataPtr);

        if(lSize <= 0)
        {
            Trace0(ERR,
                   "GetInterfaceConfiguration: There is no more space left to fill in config info");
        
            return ERROR_MORE_DATA;
        }
    }
     
    if(picb->pOutFilter)
    {
        dwErr = GetOutFilters(picb,
                              &pInfoHdrAndBuffer->TocEntry[dwTocIndex], 
                              pbyDataPtr, 
                              pInfoHdrAndBuffer, 
                              &lSize);
        
        if(dwErr is NO_ERROR)
        {
            dwTocIndex++;
            
            pbyDataPtr += lSize;
            
            ALIGN_POINTER(pbyDataPtr);
        }
        else
        {
            if(dwErr isnot ERROR_NO_DATA)
            {
                dwRet = ERROR_MORE_DATA;
            }
        }
        
        lSize =  (LONG) (pbyEndPtr - pbyDataPtr);

        if(lSize <= 0)
        {
            Trace0(ERR,
                   "GetInterfaceConfiguration: There is no more space left to fill in config info");
        
            return ERROR_MORE_DATA;
        }
    }
   
    if((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
       (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK) and
       (picb->ritType isnot ROUTER_IF_TYPE_CLIENT))
    {
        dwErr = GetGlobalFilterOnIf(picb,
                                    &pInfoHdrAndBuffer->TocEntry[dwTocIndex],
                                    pbyDataPtr,
                                    pInfoHdrAndBuffer,
                                    &lSize);

        if(dwErr is NO_ERROR)
        {
            dwTocIndex++;

            pbyDataPtr += lSize;

            ALIGN_POINTER(pbyDataPtr);
        }
        else
        {
            if(dwErr isnot ERROR_NO_DATA)
            {
                dwRet = ERROR_MORE_DATA;
            }
        }

        lSize =  (LONG) (pbyEndPtr - pbyDataPtr);

        if(lSize <= 0)
        {
            Trace0(ERR,
                   "GetInterfaceConfiguration: There is no more space left to fill in config info");

            return ERROR_MORE_DATA;
        }
    }

    if(picb->pDemandFilter)
    {
        dwErr = GetDemandFilters(picb,
                                 &pInfoHdrAndBuffer->TocEntry[dwTocIndex], 
                                 pbyDataPtr, 
                                 pInfoHdrAndBuffer, 
                                 &lSize);
        
        if(dwErr is NO_ERROR)
        {
            dwTocIndex++;
            
            pbyDataPtr += lSize;
            
            ALIGN_POINTER(pbyDataPtr);
        }
        else
        {
            if(dwErr isnot ERROR_NO_DATA)
            {
                dwRet = ERROR_MORE_DATA;
            }
        }
        
        lSize =  (LONG) (pbyEndPtr - pbyDataPtr);
    }

    if(pInfoHdrAndBuffer->TocEntriesCount != dwTocIndex)
    {
        pInfoHdrAndBuffer->TocEntriesCount = dwTocIndex;
    }
    

    return dwRet;
}


DWORD
GetInterfaceRoutingProtoInfo(
    PICB                   picb, 
    PPROTO_CB     pProtoCbPtr,
    PRTR_TOC_ENTRY         pToc,
    PBYTE                  pbyDataPtr, 
    PRTR_INFO_BLOCK_HEADER pInfoHdrAndBuffer,
    PDWORD                 pdwSize
    )
{
    ULONG   ulStructureSize, ulStructureCount, ulStructureVersion;
    DWORD   dwError = NO_ERROR;

    TraceEnter("GetInterfaceRoutingProtoInfo");
    
    dwError = (pProtoCbPtr->pfnGetInterfaceInfo)(picb->dwIfIndex,
                                                 pbyDataPtr,
                                                 pdwSize,
                                                 &ulStructureVersion,
                                                 &ulStructureSize,
                                                 &ulStructureCount);
    
    if(dwError isnot NO_ERROR) 
    {
        Trace1(ERR,
               "GetInterfaceRoutingProtoInfo: GetIfConfigInfo() failed for protocol %S", 
               pProtoCbPtr->pwszDisplayName);

        return dwError;
    }

    //IpRtAssert(*pdwSize is (ulStructureSize * ulStructureCount));

    pToc->InfoSize  = ulStructureSize;
    pToc->InfoType  = pProtoCbPtr->dwProtocolId;
    pToc->Count     = ulStructureCount;
    pToc->Offset    = (ULONG)(pbyDataPtr - (PBYTE)pInfoHdrAndBuffer);
    //pToc->InfoVersion   = ulStructureVersion;

    return NO_ERROR;
}


DWORD
GetGlobalConfiguration(
    PRTR_INFO_BLOCK_HEADER   pInfoHdrAndBuffer,
    DWORD                    dwInfoSize
    )
{
    DWORD               dwRoutProtInfoSize;
    PPROTO_CB  pProtoCbPtr;
    DWORD               dwNumTocEntries, i;
    DWORD               dwTocIndex,dwResult;
    DWORD               dwBufferRemaining,dwSize,dwIndex;
    PBYTE               pbyDataPtr, pbyEndPtr;
    PLIST_ENTRY         pleNode;
    PGLOBAL_INFO        pGlobalInfo;
    ULONG               ulStructureVersion, ulStructureSize, ulStructureCount;
 
    TraceEnter("GetGlobalConfiguration");

    // 
    // First calculate number of TOCs
    //

    dwNumTocEntries = TotalRoutingProtocols + TOCS_ALWAYS_IN_GLOBAL_INFO;
    
    for(i = 0; i < NUM_INFO_CBS; i++)
    {
        if (!g_rgicInfoCb[i].pfnGetGlobalInfo)
            continue;

        dwSize = 0;

        dwResult = g_rgicInfoCb[i].pfnGetGlobalInfo(NULL,
                                                    &dwNumTocEntries,
                                                    NULL,
                                                    NULL,
                                                    &dwSize);
    }
    
    //
    // Fill Header, RTR_TOC_ENTRYs for global, priority and each of the protos
    //
    
    pInfoHdrAndBuffer->Version          = IP_ROUTER_MANAGER_VERSION;
    pInfoHdrAndBuffer->TocEntriesCount  = dwNumTocEntries;


    //
    // Fill in TOCs. Data starts after the last TOC
    //
    
    pbyDataPtr   = (PBYTE)&(pInfoHdrAndBuffer->TocEntry[pInfoHdrAndBuffer->TocEntriesCount]);

    pbyEndPtr    = (PBYTE)pInfoHdrAndBuffer + dwInfoSize;

    ALIGN_POINTER(pbyDataPtr);
    
    dwTocIndex        = 0;
    dwBufferRemaining = (DWORD)(pbyEndPtr - pbyDataPtr);
                        

    //
    // Fill in Routing Protocol Priority infoblock
    //
    
    dwRoutProtInfoSize = dwBufferRemaining;

    dwResult = GetPriorityInfo(pbyDataPtr, &dwRoutProtInfoSize);
    
    //pInfoHdrAndBuffer->TocEntry[dwTocIndex].InfoVersion  = dwRoutProtInfoSize;
    pInfoHdrAndBuffer->TocEntry[dwTocIndex].InfoSize  = dwRoutProtInfoSize;
    pInfoHdrAndBuffer->TocEntry[dwTocIndex].InfoType  = IP_PROT_PRIORITY_INFO;
    pInfoHdrAndBuffer->TocEntry[dwTocIndex].Count     = 1;
    
    pInfoHdrAndBuffer->TocEntry[dwTocIndex].Offset    =
        (ULONG)(pbyDataPtr - (PBYTE)pInfoHdrAndBuffer);
    
    dwTocIndex++;
    
    pbyDataPtr           += dwRoutProtInfoSize;
    
    ALIGN_POINTER(pbyDataPtr);

    dwBufferRemaining = (DWORD)(pbyEndPtr - pbyDataPtr);

    for(i = 0; i < NUM_INFO_CBS; i++)
    {
        if (!g_rgicInfoCb[i].pfnGetGlobalInfo)
            continue;

        dwSize = dwBufferRemaining;

        dwResult = g_rgicInfoCb[i].pfnGetGlobalInfo(
                                     &pInfoHdrAndBuffer->TocEntry[dwTocIndex],
                                     &dwTocIndex,
                                     pbyDataPtr,
                                     pInfoHdrAndBuffer,
                                     &dwSize);

        pbyDataPtr += dwSize;
    
        ALIGN_POINTER(pbyDataPtr);

        dwBufferRemaining = (DWORD)(pbyEndPtr - pbyDataPtr);
    }

    dwSize = sizeof(GLOBAL_INFO);

    pInfoHdrAndBuffer->TocEntry[dwTocIndex].InfoSize  = dwSize;
    pInfoHdrAndBuffer->TocEntry[dwTocIndex].InfoType  = IP_GLOBAL_INFO;
    pInfoHdrAndBuffer->TocEntry[dwTocIndex].Count     = 1;
    //pInfoHdrAndBuffer->TocEntry[dwTocIndex].InfoVersion = 1;
    
    pInfoHdrAndBuffer->TocEntry[dwTocIndex].Offset    =
        (ULONG)(pbyDataPtr - (PBYTE) pInfoHdrAndBuffer);
    
    pGlobalInfo = (PGLOBAL_INFO)pbyDataPtr;

    //
    // unused
    //
    
    pGlobalInfo->bFilteringOn   = 0;
    
    pGlobalInfo->dwLoggingLevel = g_dwLoggingLevel;
 
    dwTocIndex++;
    
    pbyDataPtr           += dwSize;
    
    ALIGN_POINTER(pbyDataPtr);

    dwBufferRemaining = (DWORD)(pbyEndPtr - pbyDataPtr);
    
    //
    // fill in global info for all routing protocols
    //
    
    for(pleNode = g_leProtoCbList.Flink; 
        pleNode != &g_leProtoCbList; 
        pleNode = pleNode->Flink) 
    {
        
        pProtoCbPtr = CONTAINING_RECORD(pleNode,
                                        PROTO_CB,
                                        leList);

        if(pProtoCbPtr->posOpState isnot RTR_STATE_RUNNING)
        {
            //
            // if the protocol is in the process of stopping
            //  skip it
            //
            
            continue;
        }
        
        dwRoutProtInfoSize = dwBufferRemaining;

        dwResult = (pProtoCbPtr->pfnGetGlobalInfo)(pbyDataPtr,
                                                   &dwRoutProtInfoSize,
                                                   &ulStructureVersion,
                                                   &ulStructureSize,
                                                   &ulStructureCount);
        
        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "GetGlobalConfiguration: Error %d getting global info from %s",
                   dwResult,
                   pProtoCbPtr->pwszDllName);
            
            continue;
        }
        
        // pInfoHdrAndBuffer->TocEntry[dwTocIndex].InfoVersion = ulStructureVersion;
        
        pInfoHdrAndBuffer->TocEntry[dwTocIndex].InfoSize =
            ulStructureSize;
        
        pInfoHdrAndBuffer->TocEntry[dwTocIndex].InfoType =
            pProtoCbPtr->dwProtocolId;
        
        pInfoHdrAndBuffer->TocEntry[dwTocIndex].Offset   =
            (ULONG)(pbyDataPtr - (PBYTE)pInfoHdrAndBuffer);

        pInfoHdrAndBuffer->TocEntry[dwTocIndex].Count = ulStructureCount;

        dwTocIndex++;
        
        pbyDataPtr += dwRoutProtInfoSize;

        ALIGN_POINTER(pbyDataPtr);

        dwBufferRemaining = (DWORD)(pbyEndPtr - pbyDataPtr);
    }

    pInfoHdrAndBuffer->Size = (ULONG) ((ULONG_PTR)pbyDataPtr - (ULONG_PTR)pInfoHdrAndBuffer);

    return NO_ERROR;
}

DWORD
GetSizeOfGlobalInfo(
    VOID
    )
{
    DWORD               dwSize = 0, dwResult;
    DWORD               dwRoutProtInfoSize;
    PICB                picb;
    PPROTO_CB  pProtoCbPtr;
    PLIST_ENTRY         pleNode;
    DWORD               dwInfoSize, i;
    ULONG               ulStructureVersion, ulStructureSize, ulStructureCount;

    TraceEnter("GetSizeOfGlobalInfo");
    
    dwSize = sizeof(RTR_INFO_BLOCK_HEADER) - sizeof(RTR_TOC_ENTRY);
    
    //
    // get size of Routing Protocol Priority info
    //
    
    dwRoutProtInfoSize = 0;
    
    GetPriorityInfo(NULL,
                    &dwRoutProtInfoSize);
    
    //
    // ALIGN_SIZE added for alignment
    //

    dwSize += (dwRoutProtInfoSize +
               sizeof(RTR_TOC_ENTRY) +
               ALIGN_SIZE); 

    for(i = 0; i < NUM_INFO_CBS; i++)
    {
        if (!g_rgicInfoCb[i].pfnGetGlobalInfo)
            continue;

        dwInfoSize = 0;

        dwResult = g_rgicInfoCb[i].pfnGetGlobalInfo(NULL,
                                                    NULL,
                                                    NULL,
                                                    NULL,
                                                    &dwInfoSize);

        if((dwResult isnot NO_ERROR) and
           (dwResult isnot ERROR_INSUFFICIENT_BUFFER))
        {
            //
            // The only errors which will tell us the size needed are
            // NO_ERROR and ERROR_INSUFFICIENT_BUFFER. Anything else means
            // we didnt get the right size
            //
            
            Trace2(ERR,
                   "GetSizeOfGlobalInfo: Error %d in GetGlobInfo for %s\n",
                   dwResult,
                   g_rgicInfoCb[i].pszInfoName);
            
            continue;
        }

        dwSize += (dwInfoSize +
                   sizeof(RTR_TOC_ENTRY) +
                   ALIGN_SIZE); 
    }


    //
    // The names of the Dlls - part of Global Info
    //
    
    dwSize += (sizeof(GLOBAL_INFO) +
               sizeof(RTR_TOC_ENTRY) +
               ALIGN_SIZE);
    
    //
    // get size of infoblocks for all routing protocols
    //
    
    for(pleNode  = g_leProtoCbList.Flink; 
        pleNode isnot &g_leProtoCbList; 
        pleNode = pleNode->Flink) 
    {
        pProtoCbPtr = CONTAINING_RECORD(pleNode,
                                        PROTO_CB,
                                        leList);
        
        if(pProtoCbPtr->posOpState isnot RTR_STATE_RUNNING)
        {
            //
            // if the protocol is in the process of stopping
            //  skip it
            //
            
            continue;
        }
        
        
        //
        // Call the routing protocol's GetGlobalConfigInfo() entrypoint
        // with NULL. This should return the buffer size needed
        //
        
        dwRoutProtInfoSize = 0;

        dwResult = (pProtoCbPtr->pfnGetGlobalInfo)(NULL,
                                                   &dwRoutProtInfoSize,
                                                   &ulStructureVersion,
                                                   &ulStructureSize,
                                                   &ulStructureCount);

        if((dwResult is NO_ERROR) or
           (dwResult is ERROR_INSUFFICIENT_BUFFER))
        {
            dwSize += (dwRoutProtInfoSize +
                       sizeof(RTR_TOC_ENTRY) +
                       ALIGN_SIZE);
        }
    }

    return dwSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\if.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\if.h

Abstract:

    Header for if.c

Revision History:

    Gurdeep Singh Pall          6/26/95  Created

--*/

#define ADAPTER_PREFIX_STRING           "\\DEVICE\\"
#define ADAPTER_PREFIX_UNICODE_STRING   L"\\DEVICE\\"


PICB
CreateIcb(
    PWSTR                   pwszInterfaceName,
    HANDLE                  hDIMInterface,
    ROUTER_INTERFACE_TYPE   InterfaceType,
    DWORD                   dwAdminState,
    DWORD                   dwIfIndex OPTIONAL
    );

DWORD
CreateDefaultIcb(
    PWCHAR  pwszName,
    ICB     **ppicb
    );

DWORD
AllocateIcb(
    PWCHAR  pwszName,
    ICB     **ppicb
    );

DWORD
CreateBindingForNewIcb(
    PICB    pNewIcb
    );

VOID
InsertInterfaceInLists(
    PICB     pNewIcb
    );

VOID
RemoveInterfaceFromLists(
    PICB    picb
    );

DWORD
BindInterfaceInAllProtocols(
    PICB picb
    );

DWORD
BindInterfaceInProtocol(
    PICB                        pIcb,
    PPROTO_CB                   pProto,
    PIP_ADAPTER_BINDING_INFO    pBindInfo
    );

DWORD
UnbindInterfaceInAllProtocols(
    PICB picb
    );

DWORD
AddInterfaceToAllProtocols(
    PICB                     picb,
    PRTR_INFO_BLOCK_HEADER   pInfoHdr
    );

DWORD
AddInterfaceToProtocol(
    IN  PICB            picb,
    IN  PPROTO_CB       pProtocolCb,
    IN  PVOID           pvProtoInfo,
    IN  ULONG           ulInfoVersion,
    IN  ULONG           ulInfoSize,
    IN  ULONG           ulInfoCount
    );

DWORD
DeleteInterfaceFromAllProtocols(
    PICB picb
    );

DWORD
DisableInterfaceWithAllProtocols(
    PICB   picb
    );

DWORD
EnableInterfaceWithAllProtocols(
    PICB    picb
    );

VOID
DeleteAllInterfaces(
    VOID
    );

DWORD
DeleteSingleInterface(
    PICB picb
    );

DWORD
LanEtcInterfaceDownToUp(
    PICB   picb,
    BOOL   bAdding
    );

DWORD
WanInterfaceInactiveToUp(
    PICB   picb
    );

DWORD
GenericInterfaceComingUp(
    PICB   picb
    );

DWORD
LanEtcInterfaceUpToDown(
    PICB picb,
    BOOL bDeleted
    );

DWORD
WanInterfaceUpToInactive(
    PICB   picb,
    BOOL   bDeleted
    );

DWORD
GenericInterfaceNoLongerUp(
    PICB picb,
    BOOL bDeleted
    );

DWORD
WanInterfaceInactiveToDown(
    PICB picb,
    BOOL bDeleted
    );

DWORD
WanInterfaceDownToInactive(
    PICB picb
    );

DWORD
GetInterfaceStatusInfo(
    IN     PICB                   picb,
    IN     PRTR_TOC_ENTRY         pToc,
    IN     PBYTE                  pbDataPtr,
    IN OUT PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwInfoSize
    );

DWORD
SetInterfaceStatusInfo(
    IN  PICB                    picb,
    IN  PRTR_INFO_BLOCK_HEADER  pInfoHdr,
    OUT PBOOL                   pbUpdateDIM
    );

VOID
DeAllocateBindings(
    PICB  picb
    );

DWORD
GetInterfaceStatistics(
    IN   PICB       picb,
    OUT  PMIB_IFROW pOutBuffer
    );

DWORD
SetInterfaceStatistics(
    IN PICB     picb,
    IN PMIB_IFROW lpInBuffer,
    OUT PBOOL   pbUpdateDIM
    );

DWORD
SetInterfaceAdminStatus(
    IN PICB     picb,
    IN DWORD    dwAdminStatus,
    OUT PBOOL   pbUpdateDIM
    );

DWORD
InterfaceAdminStatusSetToUp(
    IN  PICB    picb,
    OUT PBOOL   pbUpdateDIM
    );

DWORD
InterfaceAdminStatusSetToDown(
    IN  PICB    picb,
    OUT PBOOL   pbUpdateDIM
    );

VOID
HandleAddressChangeNotification(
    VOID
    );

DWORD
UpdateBindingInformation(
    PICB picb
    );

DWORD
GetAdapterInfo(
    DWORD    dwIpAddress,
    PDWORD   pdwAdapterId,
    PDWORD   pdwBCastBit,
    PDWORD   pdwReasmSize
    );

DWORD
GetIpInfoForInterface(
    IN  DWORD   dwIfIndex,
    OUT PULONG  pulNumAddresses,
    OUT ICB_BINDING **ppAddresses,
    OUT PDWORD  pdwBCastBit,
    OUT PDWORD  pdwReasmSize
    );

DWORD
GetBestNextHopMaskGivenICB(
    PICB     picb,
    DWORD    dwNextHopAddr
    );

DWORD
GetBestNextHopMaskGivenIndex(
    DWORD  dwIfIndex,
    DWORD  dwNextHopAddr
    );

DWORD
InitializeLoopbackInterface(
    PICB    picb
    );

DWORD
DeleteLoopbackInterface(
    VOID
    );

DWORD
LanEtcInterfaceInitToDown(
    PICB picb
    );

DWORD
ReadAddressFromRegistry(
    IN  PWCHAR          pwszIfName,
    OUT PDWORD          pdwNumAddresses,
    OUT ICB_BINDING     **ppibAddressInfo,
    IN  BOOL            bInternalIf
    );

DWORD
ReadAddressAndMaskValues(
    IN  HKEY        hkeyAdapterSection,
    IN  PSZ         pszRegAddressValue,
    IN  PSZ         pszRegMaskValue,
    OUT ICB_BINDING **ppibAddressInfo,
    OUT PDWORD      pdwNumAddresses
    );


DWORD
ParseAddressAndMask(
    IN  PBYTE       pbyAddresses,
    IN  DWORD       dwAddressSize,
    IN  PBYTE       pbyMasks,
    IN  DWORD       dwMaskSize,
    OUT ICB_BINDING **ppibAddressInfo,
    OUT PDWORD      pdwNumAddresses
    );

DWORD
SetInterfaceReceiveType(
    IN  DWORD   dwProtocolId,
    IN  DWORD   dwIfIndex,
    IN  DWORD   dwInterfaceReceiveType,
    IN  BOOL    bActivate
    );

DWORD
HandleMediaSenseEvent(
    IN  PICB    pIcb,
    IN  BOOL    bSensed
    );

#define IS_ROUTABLE(ipAddr)  ((ipAddr) != htonl(INADDR_LOOPBACK))

DWORD
GetRouterId(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\if.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\if.c

Abstract:

    IP Router Manager interface related functions

Revision History:

    Gurdeep Singh Pall          6/26/95  Created

--*/

#include "allinc.h"

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The interface state machine:                                             //
//                                                                          //
//                           ----------                                     //
//                          | Unbound  |                                    //
//             ------------>| Disabled |<---------------                    //
//            |              ----------                 |                   //
//            V                                         V                   //
//       ----------                                  ---------              //
//      | Bound    |                                | Unbound |             //
//      | Disabled |                                | Enabled |             //
//       ----------                                  ---------              //
//           ^                                          ^                   //
//           |               ---------                  |                   //
//            ------------->| Bound   |<----------------                    //
//                          | Enabled |                                     //
//                           ---------                                      //
//                                                                          //
//                                                                          //
//  LAN interfaces:                                                         //
//                                                                          //
//  Characteristics    UP (Operational)    DOWN (Non-Operational)           //
//  ------------------------------------------------------------------      //
//  Binding (IP Address)    Yes                 No                          //
//  Protocols Added         Yes                 Yes                         //
//  Static Routes           Yes                 No                          //
//  Other Routes            Yes                 No                          //
//  Added to Filter Driver  Yes                 Yes                         //
//  Filters                 Added               Not added                   //
//  Filter Ctxt in IP Stack Set (Valid)         Not Set (Invalid)           //
//  Router Discovery        Active (if necc)    Inactive                    //
//  Adapter ID (and Map)    Valid               Invalid                     //
//                                                                          //
//  WAN interfaces:                                                         //
//                                                                          //
//  Characteristics       CONNECTED     DISCON/CONNECTING     UNREACHABLE   //
//  -------------------------------------------------------------------     //
//  Binding (IP Address)    Yes             No                  No          //
//  Protocols Added         Yes             Yes                 Yes         //
//  Static Routes           Yes             Yes                 No          //
//  Other Routes            Yes             No                  No          //
//  Added to Filter Driver  Yes             Yes                 Yes         //
//  Filters                 Yes             Yes                 No          //
//  Filter Ctxt in IP Stack Set (Valid)     Not Set (Invalid)   Not Set     //
//  Router Discovery        Active          Inactive            Inactive    //
//  Adapter ID (and Map)    Valid           Invalid             Invalid     //
//                                                                          //
//  Enabled/Disabled depends upon the AdminState and not upon the           //
//  operational state                                                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#if __PIX__
BOOL
IsRemoteAddressPrivate(PICB pIcb);
#endif

PICB
CreateIcb(
    PWSTR                   pwszInterfaceName,
    HANDLE                  hDIMInterface,
    ROUTER_INTERFACE_TYPE   InterfaceType,
    DWORD                   dwAdminState,
    DWORD                   dwIfIndex OPTIONAL
    )

/*++

Routine Description

    This function creates an interface control block

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    DWORD           dwResult;
    PICB            pNewInterfaceCb;
    GUID            Guid;

#ifdef KSL_IPINIP
    //
    // Make sure this is a valid name
    //

    if(InterfaceType is ROUTER_IF_TYPE_TUNNEL1)
    {
        UNICODE_STRING  usTempName;

        //
        // For now only these interfaces are GUIDs
        //

        usTempName.Length        = wcslen(pwszInterfaceName) * sizeof(WCHAR);
        usTempName.MaximumLength = usTempName.Length + sizeof(WCHAR);
        usTempName.Buffer        = pwszInterfaceName;

        if(RtlGUIDFromString(&usTempName,
                             &Guid) isnot STATUS_SUCCESS)
        {
            Trace1(ERR,
                   "CreateIcb: %S is not a GUID\n",
                   pwszInterfaceName);
 
            return NULL;
        }
    }
#endif //KSL_IPINIP

    //
    // Allocate an ICB
    //
   
    dwResult = AllocateIcb(pwszInterfaceName,
                           &pNewInterfaceCb);

    if(dwResult isnot NO_ERROR)
    {
        return NULL;
    }

    pNewInterfaceCb->dwIfIndex    = INVALID_IF_INDEX;
    pNewInterfaceCb->hDIMHandle   = hDIMInterface;
    pNewInterfaceCb->ritType      = InterfaceType;
    pNewInterfaceCb->dwMcastTtl   = 1;


    //
    // "Unique" interface ID used for ICBs.
    // This ID is passed to WANARP and DIM and they in
    // turn pass this back to Router Manager when 
    // requesting/indicating actions on the interface.
    //
    
    pNewInterfaceCb->dwSeqNumber = g_dwNextICBSeqNumberCounter;


    //
    // Initialize the filter, and wanarp contexts to invalid values
    // (NAT invalid is NULL)
    //

    pNewInterfaceCb->ihFilterInterface         = INVALID_HANDLE_VALUE;
    pNewInterfaceCb->ihDemandFilterInterface   = INVALID_HANDLE_VALUE;

    //
    // Initialize the lists of which async notifications and
    // the protocol blocks are queued
    //
    
    InitializeListHead(&pNewInterfaceCb->lePendingResultList);
    InitializeListHead(&pNewInterfaceCb->leProtocolList);

    //
    // Since we HEAP zeroed the ICB, all our binding related
    // stuff is already zero, the bBound is FALSE and dwNumAddress is 0
    // The adapter id was set to invalid in InitializeInterfaceContext
    //


    //
    // set the operational status based on the interface type
    // Also figure out the interface index
    //

    dwResult = NO_ERROR;
    
    switch(pNewInterfaceCb->ritType) 
    {
        case ROUTER_IF_TYPE_CLIENT:
        {
            //
            // Clients come up in connecting, since we dont get a LINE_UP for
            // them.  We also set the notification flags to fake the LINE UP
            //

            pNewInterfaceCb->dwAdminState       = IF_ADMIN_STATUS_UP;
            pNewInterfaceCb->dwOperationalState = CONNECTING; 
            pNewInterfaceCb->nitProtocolType    = REMOTE_WORKSTATION_DIAL;

            SetNdiswanNotification(pNewInterfaceCb);

            pNewInterfaceCb->dwBCastBit       = 1;
            pNewInterfaceCb->dwReassemblySize = DEFAULT_MTU;

            //
            // We dont really care about dial out ifIndex
            // so clients will have an index of -1 (since we init to -1)
            //
            
            break;
        }

        case ROUTER_IF_TYPE_HOME_ROUTER:
        case ROUTER_IF_TYPE_FULL_ROUTER:
        {
            //
            // HOME and FULL routers are disconnected
            //

            pNewInterfaceCb->dwAdminState       = dwAdminState;
            pNewInterfaceCb->dwOperationalState = DISCONNECTED;
            pNewInterfaceCb->nitProtocolType    = DEMAND_DIAL;

            pNewInterfaceCb->dwBCastBit       = 1;
            pNewInterfaceCb->dwReassemblySize = DEFAULT_MTU;

            //
            // WANARP reserves and index when we add an interface to it
            //
            
            dwResult = AddInterfaceToWanArp(pNewInterfaceCb);

            break;
        }

        case ROUTER_IF_TYPE_DEDICATED:
        {
            //
            // LAN interfaces come up as NON_OPERATIONAL. If the admin
            // wants them up we will try to do a LanInterfaceDownToUp()
            // If that succeeds, it will set the operational state
            // correctly
            //

            pNewInterfaceCb->dwAdminState       = dwAdminState;
            pNewInterfaceCb->dwOperationalState = NON_OPERATIONAL;
            pNewInterfaceCb->nitProtocolType    = PERMANENT;

            dwResult = NhpGetInterfaceIndexFromStack(
                            pNewInterfaceCb->pwszName,
                            &(pNewInterfaceCb->dwIfIndex)
                            );

            break;
        }

        case ROUTER_IF_TYPE_INTERNAL:
        {
            
            pNewInterfaceCb->dwAdminState       = IF_ADMIN_STATUS_UP;
            pNewInterfaceCb->dwOperationalState = DISCONNECTED;
            pNewInterfaceCb->nitProtocolType    = LOCAL_WORKSTATION_DIAL;

            pNewInterfaceCb->dwBCastBit       = 1;
            pNewInterfaceCb->dwReassemblySize = DEFAULT_MTU;

            //
            // WANARP reserves and index when we add an interface to it
            //
            
            dwResult = AddInterfaceToWanArp(pNewInterfaceCb);

            break;
        }
        
        case ROUTER_IF_TYPE_LOOPBACK:
        {
            
            pNewInterfaceCb->dwAdminState       = IF_ADMIN_STATUS_UP;
            pNewInterfaceCb->dwOperationalState = OPERATIONAL;
            pNewInterfaceCb->nitProtocolType    = PERMANENT;

            //
            // Note that IP uses 1
            //

            pNewInterfaceCb->dwIfIndex = LOOPBACK_INTERFACE_INDEX;
            
            break;
        }

#ifdef KSL_IPINIP
        case ROUTER_IF_TYPE_TUNNEL1:
        {
  
            pNewInterfaceCb->dwAdminState       = dwAdminState;
            pNewInterfaceCb->dwOperationalState = NON_OPERATIONAL;
            pNewInterfaceCb->nitProtocolType    = PERMANENT;

            pNewInterfaceCb->dwBCastBit       = 1;
            pNewInterfaceCb->dwReassemblySize = DEFAULT_MTU;

            //
            // IP in IP does the same thing as WANARP
            //

            dwResult = AddInterfaceToIpInIp(&Guid,
                                            pNewInterfaceCb);

            break;
        }
#endif //KSL_IPINIP

        case ROUTER_IF_TYPE_DIALOUT:
        {
            //
            // Dial out interface are not known to DIM. We learn about
            // them via a back door mechanism.
            //

            IpRtAssert(dwIfIndex isnot INVALID_IF_INDEX);
            IpRtAssert(dwIfIndex isnot 0);

            pNewInterfaceCb->dwAdminState       = IF_ADMIN_STATUS_UP;
            pNewInterfaceCb->dwOperationalState = CONNECTED;
            pNewInterfaceCb->nitProtocolType    = REMOTE_WORKSTATION_DIAL;
            pNewInterfaceCb->dwIfIndex          = dwIfIndex;

            pNewInterfaceCb->dwBCastBit       = 1;
            pNewInterfaceCb->dwReassemblySize = DEFAULT_MTU;

            break;
        }

         
        default:
        {
            IpRtAssert(FALSE);

            break;
        }
    }

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "CreateIcb: Error %d in getting index for %S\n",
               dwResult,
               pNewInterfaceCb->pwszName);

        HeapFree(IPRouterHeap,
                 0,
                 pNewInterfaceCb);

        return NULL;
    }
        
    //
    // Once the interface index is done we can Initialize the bindings
    //

    dwResult = CreateBindingForNewIcb(pNewInterfaceCb);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "CreateIcb: Error %d in creating binding for %S\n",
               dwResult,
               pNewInterfaceCb->pwszName);

        HeapFree(IPRouterHeap, 
                 0,
                 pNewInterfaceCb);

        return NULL;
    }

    return pNewInterfaceCb;
}

DWORD
AllocateIcb(
    PWCHAR  pwszName,
    ICB     **ppIcb
    )

/*++

Routine Description

    Allocates memory for the ICB

Locks

    None

Arguments

    pwszName    Interface name
    ppIcb       OUT: pointer to allocate ICB

Return Value

    NO_ERROR
    
--*/

{
    DWORD   dwNameLen, dwAllocSize;
    PICB    pNewInterfaceCb;

    *ppIcb = NULL;
    
    dwNameLen       = sizeof(WCHAR) * (wcslen(pwszName) + 1); // +1 for NULL
    dwNameLen       = min(dwNameLen, MAX_INTERFACE_NAME_LEN);
    dwAllocSize     = sizeof (ICB) + dwNameLen + 4; // +4 for alignment
    
    pNewInterfaceCb = HeapAlloc(IPRouterHeap, 
                                HEAP_ZERO_MEMORY, 
                                dwAllocSize);

    if(pNewInterfaceCb is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // The interface name is after the ICB
    //
    
    pNewInterfaceCb->pwszName = (PWCHAR)((PBYTE)pNewInterfaceCb +
                                         sizeof (ICB));
    
    //
    // Align it to DWORD boundary - easier to copy out the name
    //
    
    pNewInterfaceCb->pwszName = 
        (PWCHAR)(((ULONG_PTR)pNewInterfaceCb->pwszName + 3) & ~((ULONG_PTR)0x3));
    
    //
    // Initialize the name
    //
    
    CopyMemory(pNewInterfaceCb->pwszName,
               pwszName,
               dwNameLen);
    
    pNewInterfaceCb->pwszName[wcslen(pwszName)] = UNICODE_NULL;

    *ppIcb = pNewInterfaceCb;
    
    return NO_ERROR;
}

DWORD
CreateBindingForNewIcb(
    PICB    pNewIcb
    )

/*++

Routine Description

    Creates a binding and bind node for the ICB

    LAN interfaces get the binding setup when they are being brought UP.
    Since the other interfaces will ALWAYS have ONLY 1 address, we can
    set their binding info here, even if we dont have the address
    
    We skip INTERNAL, too because of the way the internal address is 
    got. Otherwise we will get an assert in UpdateBindingInformation
    when we find an existing binding with no address 
    
Locks

    

Arguments

    

Return Value


--*/

{
    PADAPTER_INFO   pBindNode;
    PICB_BINDING    pBinding;

#ifdef KSL_IPINIP
    if((pNewIcb->ritType is ROUTER_IF_TYPE_TUNNEL1) or
#endif //KSL_IPINIP
    if((pNewIcb->ritType is ROUTER_IF_TYPE_HOME_ROUTER) or
       (pNewIcb->ritType is ROUTER_IF_TYPE_FULL_ROUTER) or
       (pNewIcb->ritType is ROUTER_IF_TYPE_LOOPBACK) or
       (pNewIcb->ritType is ROUTER_IF_TYPE_DIALOUT))
    {

        IpRtAssert(pNewIcb->dwIfIndex isnot INVALID_IF_INDEX);

        pBindNode   = HeapAlloc(IPRouterHeap,
                                HEAP_ZERO_MEMORY,
                                SIZEOF_ADAPTER_INFO(1));
       
        pBinding    = HeapAlloc(IPRouterHeap,
                                HEAP_ZERO_MEMORY,
                                sizeof(ICB_BINDING)); 

        if((pBinding is NULL) or
           (pBindNode is NULL))
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        pBindNode->pInterfaceCB             = pNewIcb;
        pBindNode->dwIfIndex                = pNewIcb->dwIfIndex;
        pBindNode->dwSeqNumber              = pNewIcb->dwSeqNumber;
        pBindNode->bBound                   = pNewIcb->bBound;
       
        pBindNode->dwRemoteAddress          = INVALID_IP_ADDRESS;
        pBindNode->rgibBinding[0].dwAddress = INVALID_IP_ADDRESS;
        pBindNode->rgibBinding[0].dwMask    = INVALID_IP_ADDRESS;

        pBindNode->dwBCastBit               = pNewIcb->dwBCastBit;
        pBindNode->dwReassemblySize         = pNewIcb->dwReassemblySize;

        pBindNode->ritType                  = pNewIcb->ritType;

        pNewIcb->pibBindings                = pBinding;
        
        //
        // Set the binding in the hash table
        //
        
        ENTER_WRITER(BINDING_LIST);

        InsertHeadList(
            &g_leBindingTable[BIND_HASH(pNewIcb->dwIfIndex)],
            &(pBindNode->leHashLink)
            );

        g_ulNumBindings++;

        g_LastUpdateTable[IPADDRCACHE] = 0;

        EXIT_LOCK(BINDING_LIST);

        return NO_ERROR;
    }
   
    //
    // For client (dial in our out) interfaces, we only create the BINDING
    //

    if((pNewIcb->ritType is ROUTER_IF_TYPE_CLIENT) or
       (pNewIcb->ritType is ROUTER_IF_TYPE_DIALOUT))
    {
        pBinding = HeapAlloc(IPRouterHeap,
                             HEAP_ZERO_MEMORY,
                             sizeof(ICB_BINDING));

        if(pBinding is NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        pNewIcb->pibBindings  = pBinding;

        return NO_ERROR;
    }

    return NO_ERROR;
}

VOID    
InsertInterfaceInLists(
    PICB     pNewIcb
    )

/*++

Routine Description

    Insert the new ICB. The newicb must have a valid interface
    index. The code walks all the current ICBs and inserts this
    ICB in increasing ifIndex order. It also sets a sequence
    number in the ICB and increments the global counter. 
  
Locks

    ICB_LIST as writer
      
Arguments

    newicb          The ICB of the interface to init

Return Value

    None
    
--*/

{
    PLIST_ENTRY pleNode;
    PICB        pIcb;

    for(pleNode = &ICBList;
        pleNode->Flink != &ICBList;
        pleNode = pleNode->Flink)
    {
        pIcb = CONTAINING_RECORD(pleNode->Flink, 
                                 ICB, 
                                 leIfLink);

        if(pIcb->dwIfIndex > pNewIcb->dwIfIndex)
        {
            break;
        }
    }

    InsertHeadList(pleNode, 
                   &pNewIcb->leIfLink);

    AddInterfaceLookup(pNewIcb);


    //
    // Find next unassigned ICB number
    //
    
    do
    {
        InterlockedIncrement(&g_dwNextICBSeqNumberCounter);

        //
        // WANARP considers 0 to be an invalid value for an
        // interface
        //
        
        if ((g_dwNextICBSeqNumberCounter == 0) or
            (g_dwNextICBSeqNumberCounter == INVALID_IF_INDEX))
        {
            InterlockedIncrement(&g_dwNextICBSeqNumberCounter);
        }

    } while(InterfaceLookupByICBSeqNumber(g_dwNextICBSeqNumberCounter) != NULL);
    
    //
    // Increment total number of interfaces
    //
    
    InterlockedIncrement(&g_ulNumInterfaces);


    //
    // Count for non client interfaces
    //

    if(pNewIcb->ritType isnot ROUTER_IF_TYPE_CLIENT)
    {
        InterlockedIncrement(&g_ulNumNonClientInterfaces);
    }
}

VOID
RemoveInterfaceFromLists(
    PICB    pIcb
    )

/*++

Routine Description

    This

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    RemoveEntryList(&(pIcb->leIfLink));

    pIcb->leIfLink.Flink = NULL;
    pIcb->leIfLink.Blink = NULL;

    RemoveInterfaceLookup(pIcb);

    if(pIcb->ritType isnot ROUTER_IF_TYPE_CLIENT)
    {
        InterlockedDecrement(&g_ulNumNonClientInterfaces);
    }

    InterlockedDecrement(&g_ulNumInterfaces);
}

DWORD
BindInterfaceInAllProtocols(
    PICB pIcb
    )

/*++

Routine Description

    Binds the interface in all protocols running over the interface
      
Locks 

    The ICB_LIST lock must be held as READER. 
    Acquires the PROTOCOL_CB_LIST as READER

Arguments

    pIcb  ICB of the interface to bind

Return Value

    NO_ERROR

--*/

{
    IP_ADAPTER_BINDING_INFO *pBindInfo;
    DWORD                   i = 0 ;
    DWORD                   dwResult,dwReturn;
    PLIST_ENTRY             pleNode;
    
    TraceEnter("BindInterfaceInAllProtocols");

    CheckBindingConsistency(pIcb);
    
    if(!pIcb->bBound)
    {
        //
        // This may happen if we are in non operational state
        // It is not an error. We could do this check at the place
        // we called the function but it would make it tougher
        //

        Trace1(IF,
               "BindInterfaceInAllProtocols: Not binding %S since no addresses present",
               pIcb->pwszName);

        return NO_ERROR;
    }

    pBindInfo = HeapAlloc(IPRouterHeap,
                          0,
                          SIZEOF_IP_BINDING(pIcb->dwNumAddresses));

    if(pBindInfo is NULL)
    {
        
        Trace1(ERR,
               "BindInterfaceInAllProtocols: Error allocating %d bytes for bindings",
               SIZEOF_IP_BINDING(pIcb->dwNumAddresses));

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    
    pBindInfo->AddressCount  = pIcb->dwNumAddresses ;
    pBindInfo->RemoteAddress = pIcb->dwRemoteAddress;

    pBindInfo->Mtu           = pIcb->ulMtu;
    pBindInfo->Speed         = pIcb->ullSpeed;

    for (i = 0; i < pIcb->dwNumAddresses; i++) 
    {
        pBindInfo->Address[i].Address = pIcb->pibBindings[i].dwAddress;
        pBindInfo->Address[i].Mask    = pIcb->pibBindings[i].dwMask;
    }

    
    
    //
    // walk the array of routing protocols to activate
    //
    
    dwReturn = NO_ERROR;
    
    // *** Exclusion Begin ***
    ENTER_READER(PROTOCOL_CB_LIST);

    for(pleNode = pIcb->leProtocolList.Flink;
        pleNode isnot &(pIcb->leProtocolList);
        pleNode = pleNode->Flink)
    {
        PIF_PROTO   pProto;
        
        pProto = CONTAINING_RECORD(pleNode,
                                   IF_PROTO,
                                   leIfProtoLink);

        dwResult = BindInterfaceInProtocol(pIcb,
                                           pProto->pActiveProto,
                                           pBindInfo);

        if(dwResult isnot NO_ERROR)
        {
            Trace3(ERR,
                   "BindInterfaceInAllProtocols: Couldnt bind interface %S to %S. Error %d",
                   pIcb->pwszName,
                   pProto->pActiveProto->pwszDisplayName,
                   dwResult);
            
            dwReturn = ERROR_CAN_NOT_COMPLETE;
        }
    }

    HeapFree(IPRouterHeap,
             0,
             pBindInfo);
    
    // *** Exclusion End ***
    EXIT_LOCK(PROTOCOL_CB_LIST);

    return dwReturn;
}

DWORD
BindInterfaceInProtocol(
    PICB                        pIcb,
    PPROTO_CB                   pProto,
    PIP_ADAPTER_BINDING_INFO    pBindInfo
    )

/*++

Routine Description

    Binds the interface in the given protocol

Locks

    The ICB_LIST lock must be held as READER.
    The PROTOCOL_CB_LIST lock must also be held as READER

Arguments

    pIcb        ICB of the interface to bind
    pProto      PROTO_CB of the protocol
    pBindInfo   Binding info

Return Value

    NO_ERROR

--*/

{
    DWORD   dwResult;
 
    //
    // If this is a mcast protocol and the interface is not
    // mcast enabled, do so now
    //

    if((pIcb->bMcastEnabled is FALSE) and
       (TYPE_FROM_PROTO_ID(pProto->dwProtocolId) is PROTO_TYPE_MCAST))
    {
        dwResult = SetMcastOnIf(pIcb,
                                TRUE);

        if(dwResult isnot NO_ERROR)
        {
            WCHAR   rgwcName[MAX_INTERFACE_NAME_LEN + 2];
            PWCHAR  pName;

            Trace2(ERR,
                   "BindInterfaceInProtocol: Err %d activating mcast on %S",
                   dwResult,
                   pIcb->pwszName);

            if(MprConfigGetFriendlyName(g_hMprConfig,
                                        pIcb->pwszName,
                                        rgwcName,
                                        sizeof(rgwcName)) is NO_ERROR)
            {
                pName = rgwcName;
            }
            else
            {
                pName = pIcb->pwszName;
            }

            RouterLogEventEx(g_hLogHandle,
                             EVENTLOG_ERROR_TYPE,
                             dwResult,
                             ROUTERLOG_IP_MCAST_NOT_ENABLED,
                             TEXT("%S%S"),
                             pName,
                             pProto->pwszDisplayName);

            //
            // Dont add this protocol
            //

            return dwResult;
        }

        pIcb->bMcastEnabled = TRUE;
    }

    //
    // Call the routing protocol's BindInterface() entrypoint
    //

    dwResult = (pProto->pfnInterfaceStatus)(
                    pIcb->dwIfIndex,
                    (pIcb->dwOperationalState >= CONNECTED),
                    RIS_INTERFACE_ADDRESS_CHANGE,
                    pBindInfo
                    );

    if(dwResult isnot NO_ERROR)
    {
        Trace3(ERR,
               "BindInterfaceInProtocol: Couldnt bind interface %S to %S.Error %d",
               pIcb->pwszName,
               pProto->pwszDisplayName,
               dwResult);

    }

    return dwResult;
}

DWORD
UnbindInterfaceInAllProtocols(
    PICB pIcb
    )

/*++
  
Routine Description

    Removes the binding information from the protocols on this interface
  
Locks 

    ICB_LIST lock as READER
    Acquires the PROTOCOL_CB_LIST as READER

Arguments
      

Return Value

    NO_ERROR

--*/

{
    PLIST_ENTRY pleNode;
    DWORD       dwResult,dwReturn = NO_ERROR;

    IP_ADAPTER_BINDING_INFO BindInfo;

    BindInfo.AddressCount = 0;
    
    TraceEnter("UnbindInterfaceInAllProtocols");

    // *** Exclusion Begin ***
    ENTER_READER(PROTOCOL_CB_LIST);


    for(pleNode = pIcb->leProtocolList.Flink;
        pleNode isnot &(pIcb->leProtocolList);
        pleNode = pleNode->Flink)
    {
        PIF_PROTO  pProto;
        
        pProto = CONTAINING_RECORD(pleNode,IF_PROTO,leIfProtoLink);

        dwResult = (pProto->pActiveProto->pfnInterfaceStatus)(
                        pIcb->dwIfIndex,
                        FALSE,
                        RIS_INTERFACE_ADDRESS_CHANGE,
                        &BindInfo
                        );

        if(dwResult isnot NO_ERROR)
        {
            Trace3(ERR,
                   "UnbindInterfaceInAllProtocols: Error %d unbinding %S in %S",
                   dwResult,
                   pIcb->pwszName,
                   pProto->pActiveProto->pwszDisplayName);

            dwReturn = ERROR_CAN_NOT_COMPLETE;
        }
    }

    
    // *** Exclusion Begin ***
    EXIT_LOCK(PROTOCOL_CB_LIST);

    return dwReturn;
}


DWORD
AddInterfaceToAllProtocols(
    PICB                     pIcb, 
    PRTR_INFO_BLOCK_HEADER   pInfoHdr
    )

/*++

Routine Description

    Walks thru list of  routing protocols and calls AddInterface if
    TOC and info for that protocol exists
  
Locks 

    ICB_LIST lock as WRITER
    Acquires PROTOCOL_CB_LIST as READER

Arguments
      

Return Value

    NO_ERROR

--*/

{
    DWORD           i = 0 , dwResult;
    LPVOID          pvProtoInfo ;
    PPROTO_CB       pProtoCbPtr ;
    PLIST_ENTRY     pleNode;
    PRTR_TOC_ENTRY  pToc;
    ULONG           ulStructureVersion, ulStructureSize, ulStructureCount;
    
    TraceEnter("AddInterfaceToAllProtocols");

    if(!ARGUMENT_PRESENT(pInfoHdr))
    {
        Trace1(IF,
               "AddInterfaceToAllProtocols: No interface info for %S. Not adding to any protocols",
               pIcb->pwszName);

        return NO_ERROR;
    }

    // *** Exclusion Begin ***
    ENTER_READER(PROTOCOL_CB_LIST);
    
    for(pleNode = g_leProtoCbList.Flink; 
        pleNode != &g_leProtoCbList; 
        pleNode = pleNode->Flink) 
    {
        pProtoCbPtr = CONTAINING_RECORD(pleNode, PROTO_CB, leList);
      
        pToc = GetPointerToTocEntry(pProtoCbPtr->dwProtocolId, 
                                    pInfoHdr);

        pvProtoInfo = NULL;

        if(pToc and (pToc->InfoSize > 0))
        {
            pvProtoInfo = GetInfoFromTocEntry(pInfoHdr,
                                              pToc);

            //ulStructureVersion = pInfoHdr->TocEntry[i].InfoVersion;
            ulStructureVersion = 0x500;
            ulStructureSize  = pInfoHdr->TocEntry[i].InfoSize;
            ulStructureCount = pInfoHdr->TocEntry[i].Count;

        }

        //
        // If the protocol block is found, add the interface with the
        // routing protocol.
        //
        
        if((pProtoCbPtr->fSupportedFunctionality & RF_ADD_ALL_INTERFACES) or
           (pvProtoInfo))
        {
            dwResult = AddInterfaceToProtocol(pIcb,
                                              pProtoCbPtr,
                                              pvProtoInfo,
                                              ulStructureVersion,
                                              ulStructureSize,
                                              ulStructureCount);

            if(dwResult isnot NO_ERROR)
            {
                Trace3(ERR,
                       "AddInterfaceToAllProtocols: Error %d adding %S to %S",
                       dwResult,
                       pIcb->pwszName,
                       pProtoCbPtr->pwszDisplayName);
            }
        }
    }
    
    // *** Exclusion End ***
    EXIT_LOCK(PROTOCOL_CB_LIST);

    return NO_ERROR;
}

DWORD
AddInterfaceToProtocol(
    IN  PICB            pIcb,
    IN  PPROTO_CB       pProtocolCb,
    IN  PVOID           pvProtoInfo,
    IN  ULONG           ulStructureVersion,
    IN  ULONG           ulStructureSize,
    IN  ULONG           ulStructureCount
    )

/*++

Routine Description

    Adds an interface to a single routing protocol

Locks

    

Arguments

    

Return Value


--*/

{
    PIF_PROTO   pProto;
    DWORD       dwResult;

        
    pProto = HeapAlloc(IPRouterHeap,
                       0,
                       sizeof(IF_PROTO));
                
    if(pProto is NULL)
    {
        Trace3(ERR,
               "AddInterfaceToProtocol: Error allocating %d bytes to add %S to %S",
               sizeof(IF_PROTO),
               pIcb->pwszName,
               pProtocolCb->pwszDisplayName);

        return ERROR_NOT_ENOUGH_MEMORY;
    }
            
    //
    // The protocol wants all the interfaces indicated to it or
    // there is info for this protocol
    //
            
    Trace2(IF,
           "AddInterfaceToProtocol: Adding %S to %S",
           pIcb->pwszName,
           pProtocolCb->pwszDisplayName);
    
    dwResult = (pProtocolCb->pfnAddInterface)(pIcb->pwszName,
                                              pIcb->dwIfIndex,
                                              pIcb->nitProtocolType,
                                              pIcb->dwMediaType,
                                              pIcb->wAccessType,
                                              pIcb->wConnectionType,
                                              pvProtoInfo,
                                              ulStructureVersion,
                                              ulStructureSize,
                                              ulStructureCount);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace3(ERR,
               "AddInterfaceToProtocol: Error %d adding %S to %S",
               dwResult,
               pIcb->pwszName,
               pProtocolCb->pwszDisplayName);

        HeapFree(IPRouterHeap,
                 0,
                 pProto);
    }   
    else
    {
        pProto->pActiveProto = pProtocolCb;
            
        //
        // Mark this block as being added, because of prom.
        // mode, if that is the case
        //
            
        pProto->bPromiscuous = (pvProtoInfo is NULL);
        
        InsertTailList(&(pIcb->leProtocolList),
                       &(pProto->leIfProtoLink));
    }

    return dwResult;
}   

DWORD
DeleteInterfaceFromAllProtocols(
    PICB pIcb
    )

/*++
  
Routine Description

    Deletes the interface from all protocols running on it
    Frees the protocol info on the interface
  
Locks 

    Called with ICB_LIST as WRITER
    Acquires PROTOCOL_CB_LIST as READER

Arguments

    pIcb  ICB of interface

Return Value

    NO_ERROR

--*/

{
    DWORD       i = 0 ;
    PLIST_ENTRY pleNode;
    
    TraceEnter("DeleteInterfaceFromAllProtocols");
    
    //
    // If the router has stopped we do not need to delete the interface
    // from the routing protocol. This is handled before we get here by
    // the UnloadRoutingProtocol()
    //
    
    if (RouterState.IRS_State is RTR_STATE_STOPPED)
    {
        return NO_ERROR;
    }

    // *** Exclusion Begin ***
    ENTER_READER(PROTOCOL_CB_LIST);
    
    
    while(!(IsListEmpty(&(pIcb->leProtocolList))))
    {
        PIF_PROTO  pProto;
        
        pleNode = RemoveHeadList(&(pIcb->leProtocolList));
        
        pProto = CONTAINING_RECORD(pleNode,IF_PROTO,leIfProtoLink);
        
        //
        // Call the routing protocol's deleteinterface entrypoint
        //
        
        (pProto->pActiveProto->pfnDeleteInterface) (pIcb->dwIfIndex);
        
        //
        // Delete this protocol from the list of protocols in the Interface
        //
        
        HeapFree(IPRouterHeap,0,pProto);
    }

    // *** Exclusion End ***
    EXIT_LOCK(PROTOCOL_CB_LIST);

    return NO_ERROR;
}


DWORD
DisableInterfaceWithAllProtocols(
    PICB   pIcb
    )
{
    PLIST_ENTRY pleNode;
    DWORD       dwResult,dwReturn = NO_ERROR;

    TraceEnter("DisableInterfaceWithAllProtocols");

    ENTER_READER(PROTOCOL_CB_LIST);

    for(pleNode = pIcb->leProtocolList.Flink;
        pleNode isnot &(pIcb->leProtocolList);
        pleNode = pleNode->Flink)
    {
        PIF_PROTO  pProto;
        
        pProto = CONTAINING_RECORD(pleNode,IF_PROTO,leIfProtoLink);

        //
        // Call the routing protocol's DisableInterface() entrypoint
        //
    
        dwResult = (pProto->pActiveProto->pfnInterfaceStatus)(
                        pIcb->dwIfIndex,
                        FALSE,
                        RIS_INTERFACE_DISABLED,
                        NULL
                        );
    
        if(dwResult isnot NO_ERROR)
        {
            Trace3(ERR, 
                   "DisableInterfaceWithAllProtocols: Couldnt disable %S with %S. Error %d",
                   pIcb->pwszName,
                   pProto->pActiveProto->pwszDisplayName,
                   dwResult);
            
            dwReturn = ERROR_CAN_NOT_COMPLETE;
        }
    }

    EXIT_LOCK(PROTOCOL_CB_LIST);
   
    return dwReturn;
}


DWORD
EnableInterfaceWithAllProtocols(
    PICB    pIcb
    )
{
    PLIST_ENTRY pleNode;
    DWORD       dwResult, dwReturn = NO_ERROR;

    TraceEnter("EnableInterfaceWithAllProtocols");

    ENTER_READER(PROTOCOL_CB_LIST);
    
    for(pleNode = pIcb->leProtocolList.Flink;
        pleNode isnot &(pIcb->leProtocolList);
        pleNode = pleNode->Flink)
    {
        PIF_PROTO  pProto;

        pProto = CONTAINING_RECORD(pleNode,IF_PROTO,leIfProtoLink);

        dwResult = (pProto->pActiveProto->pfnInterfaceStatus)(
                    pIcb->dwIfIndex,
                    (pIcb->dwOperationalState >= CONNECTED),
                    RIS_INTERFACE_ENABLED,
                    NULL
                    );

        if(dwResult isnot NO_ERROR)
        {
            Trace3(ERR, 
                   "EnableInterfaceWithAllProtocols: Couldnt enable %S with %S. Error %d",
                   pIcb->pwszName,
                   pProto->pActiveProto->pwszDisplayName,
                   dwResult);
            
            dwReturn = ERROR_CAN_NOT_COMPLETE;

            continue;
        }
    }

    EXIT_LOCK(PROTOCOL_CB_LIST);
    
    return dwReturn;
}

        
VOID
DeleteAllInterfaces(
    VOID
    )
{

    PLIST_ENTRY pleNode ;
    PICB        pIcb ;
    
    TraceEnter("DeleteAllInterfaces");

    // *** Exclusion Begin ***
    ENTER_WRITER(ICB_LIST);


    //
    // We do this backwards. Quick hack for fixing OSPF
    //

    //
    // First we unlink the internal interface because if the worker function
    // finds the ICB list non empty, it loops, waiting for the interfaces
    // to get deleted. After all interfaces are deleted it deletes the
    // internal interface
    // Hence we remove the i/f from the list here and decrement the count.
    //

    if(g_pInternalInterfaceCb)
    {
        RemoveEntryList(&(g_pInternalInterfaceCb->leIfLink));

        InterlockedDecrement(&g_ulNumInterfaces);
    }

    if(g_pLoopbackInterfaceCb)
    {
        g_pLoopbackInterfaceCb = NULL;
    }

    for(pleNode = ICBList.Blink; pleNode != &ICBList;) 
    {
        pIcb = CONTAINING_RECORD (pleNode, ICB, leIfLink) ;

        if((pIcb->dwOperationalState is CONNECTED) and
           ((pIcb->ritType is ROUTER_IF_TYPE_HOME_ROUTER) or
            (pIcb->ritType is ROUTER_IF_TYPE_FULL_ROUTER)))
        {

            MarkInterfaceForDeletion(pIcb);
            
            pleNode = pleNode->Blink;

            continue;
        }
        
        pleNode = pleNode->Blink;

        RemoveInterfaceFromLists(pIcb);

        DeleteSingleInterface(pIcb);      // clean up interface.

        //
        // Free the ICB
        //

        HeapFree(IPRouterHeap, 
                 0, 
                 pIcb);
    }

    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);

}

DWORD
DeleteSingleInterface(
    PICB pIcb
    )
{
    PICB_BINDING    pBinding;
    PADAPTER_INFO   pBindNode;
    DWORD           dwResult;
    
    TraceEnter("DeleteSingleInterface");

    if(pIcb->ritType is ROUTER_IF_TYPE_CLIENT)
    { 
        IpRtAssert(g_pInternalInterfaceCb);
 
        if(pIcb->bBound)
        { 
            PLIST_ENTRY         pleNode;
            IP_LOCAL_BINDING    clientAddr;

            clientAddr.Address = pIcb->pibBindings->dwAddress;
            clientAddr.Mask    = pIcb->pibBindings->dwMask;

#if 0
            //
            // Remove the client host route
            //

            DeleteSingleRoute(g_pInternalInterfaceCb->dwIfIndex,
                              clientAddr.Address,
                              HOST_ROUTE_MASK,
                              clientAddr.Address,
                              MIB_IPPROTO_NETMGMT,
                              FALSE);
#endif

            if (g_pInternalInterfaceCb isnot NULL)
            {
                ENTER_READER(PROTOCOL_CB_LIST);


                //
                // Call ConnectClient for all the protocols configured
                // over the ServerInterface
                //

                for(pleNode = g_pInternalInterfaceCb->leProtocolList.Flink;
                    pleNode isnot &(g_pInternalInterfaceCb->leProtocolList);
                    pleNode = pleNode->Flink)
                {
                    PIF_PROTO   pIfProto;

                    pIfProto = CONTAINING_RECORD(pleNode,
                                                 IF_PROTO,
                                                 leIfProtoLink);

                    if(pIfProto->pActiveProto->pfnDisconnectClient)
                    {
                        pIfProto->pActiveProto->pfnDisconnectClient(
                            g_pInternalInterfaceCb->dwIfIndex,
                            &clientAddr
                            );
                    }
                }

                EXIT_LOCK(PROTOCOL_CB_LIST);

                //
                // Delete static routes from RTM (and the stack)
                //

                DeleteAllClientRoutes(pIcb,
                                      g_pInternalInterfaceCb->dwIfIndex);
            }

            if(pIcb->pStoredRoutes)
            {
                HeapFree(IPRouterHeap,
                         0,
                         pIcb->pStoredRoutes);
        
                pIcb->pStoredRoutes = NULL;
            }


            HeapFree(IPRouterHeap,
                     0,
                     pIcb->pibBindings);

            pIcb->pibBindings = NULL;
        }


        //
        // Delete the interface from the filter driver
        //

        DeleteFilterInterface(pIcb);

        return NO_ERROR;
    }

    if(pIcb->ritType is ROUTER_IF_TYPE_DIALOUT)
    {
        IpRtAssert(pIcb->bBound);

        pBinding = pIcb->pibBindings;

        IpRtAssert(pBinding);

        DeleteAutomaticRoutes(pIcb,
                              pBinding[0].dwAddress,
                              pBinding[0].dwMask);

        DeleteAllRoutes(pIcb->dwIfIndex,
                        FALSE);

        ENTER_WRITER(BINDING_LIST);

#if DBG

        pBindNode = GetInterfaceBinding(pIcb->dwIfIndex);

        IpRtAssert(pBindNode);

#endif // DBG

        RemoveBinding(pIcb);

        EXIT_LOCK(BINDING_LIST);

        HeapFree(IPRouterHeap,
                 0,
                 pBinding);

        pIcb->pibBindings = NULL;

        return NO_ERROR;
    }


    //
    // So at this point we are only dealing with FULL_ROUTER, HOME_ROUTER and
    // DEDICATED type interfaces
    //

    //
    // Delete static routes from RTM (and the stack)
    //

    DeleteAllRoutes(pIcb->dwIfIndex,
                    FALSE);

    //
    // WAN interfaces: bringing down an interface will not delete
    // the binding. Hence we do it here
    //
    
    pBinding    = NULL;
    pBindNode   = NULL;

    if((pIcb->ritType is ROUTER_IF_TYPE_FULL_ROUTER) or
       (pIcb->ritType is ROUTER_IF_TYPE_HOME_ROUTER))
    {
        pBinding    = pIcb->pibBindings;
        pBindNode   = GetInterfaceBinding(pIcb->dwIfIndex);
    }
   
    //
    // Bringing down the interfaces clears out stack contexts
    //

    if((pIcb->ritType is ROUTER_IF_TYPE_DEDICATED) or
       (pIcb->ritType is ROUTER_IF_TYPE_LOOPBACK) or
#ifdef KSL_IPINIP       
       (pIcb->ritType is ROUTER_IF_TYPE_TUNNEL1) or
#endif //KSL_IPINIP       
       (pIcb->ritType is ROUTER_IF_TYPE_INTERNAL))
    {
        LanEtcInterfaceUpToDown(pIcb,
                                TRUE);
    }
    else
    {
        WanInterfaceInactiveToDown(pIcb,
                                   TRUE);
    }

    
    //
    // This also frees up the list of IF_PROTO blocks
    //

    DeleteInterfaceFromAllProtocols(pIcb);

    //
    // Now remove the interface from the stack components
    //

    if((pIcb->ritType is ROUTER_IF_TYPE_FULL_ROUTER) or
       (pIcb->ritType is ROUTER_IF_TYPE_HOME_ROUTER) or
       (pIcb->ritType is ROUTER_IF_TYPE_INTERNAL))
    {
        if(pIcb->ritType isnot ROUTER_IF_TYPE_INTERNAL)
        {
            DeleteDemandFilterInterface(pIcb);
        }

        DeleteInterfaceWithWanArp(pIcb);
    }

   
    if((pIcb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
       (pIcb->ritType isnot ROUTER_IF_TYPE_LOOPBACK))
    {
        dwResult = DeleteFilterInterface(pIcb);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "Error %d deleting %S from the filter driver",
                   dwResult,
                   pIcb->pwszName);
        }
    }

#ifdef KSL_IPINIP
    if(pIcb->ritType is ROUTER_IF_TYPE_TUNNEL1)
    {
        dwResult = DeleteInterfaceFromIpInIp(pIcb);
                                             

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "Error %d deleting %S from the IpInIp driver",
                   dwResult,
                   pIcb->pwszName);
        }

        RemoveBinding(pIcb);
    }
#endif //KSL_IPINIP

    //
    // Delete the binding for wan interfaces
    //
    
    if(pBindNode)
    {
        ENTER_WRITER(BINDING_LIST);
        
        RemoveBinding(pIcb);

        EXIT_LOCK(BINDING_LIST);
    }

    if(pBinding)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pBinding);
    }

    if(pIcb->pRtrDiscAdvt)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pIcb->pRtrDiscAdvt);

        pIcb->pRtrDiscAdvt = NULL;
    }

    return NO_ERROR;
}

#ifdef KSL_IPINIP
DWORD
IpIpTunnelDownToUp(
    PICB    pIcb
    )
{
    return NO_ERROR;
}
#endif //KSL_IPINIP

DWORD
LanEtcInterfaceDownToUp(
    PICB   pIcb,
    BOOL   bAdding
    )

/*++

Routine Description

    The interface's admin state MUST be UP or this function will simply
    return
    
    The interface to adapter map MUST have already been stored before this
    is called

Locks

    ICB_LIST lock held as writer

Arguments

    pIcb    ICB of the interface to bring up
    bAdding Set to TRUE if we are adding the interface (as opposed to bringing
            it up when the admin state changed etc)   

Return Value

    NO_ERROR
    
--*/

{
    DWORD                   dwResult;
    PRESTORE_INFO_CONTEXT   pricInfo;
    
    TraceEnter("LanInterfaceDownToUp");
   
    if(pIcb->dwAdminState isnot IF_ADMIN_STATUS_UP)
    {
        Trace2(ERR,
               "LanInterfaceDownToUp: Tried to bring up %S when its admin state is %d",
               pIcb->pwszName,
               pIcb->dwAdminState);

        return ERROR_INVALID_PARAMETER;
    }
 
    //
    // Read the address from the registry for LAN interfaces. This function
    // is also called for the INTERNAL interface, whose address is already
    // plumbed by the time it is called and for TUNNEL which currently
    // run in unnumbered mode
    //

    if(pIcb->ritType is ROUTER_IF_TYPE_DEDICATED)
    {
        IpRtAssert(!pIcb->bBound);
        IpRtAssert(pIcb->dwNumAddresses is 0);

        CheckBindingConsistency(pIcb);
    
        dwResult = UpdateBindingInformation(pIcb);
   
        if(dwResult isnot NO_ERROR)
        {
            //
            // UpdateBindingInf can return ERROR_ALREADY_ASSOC, 
            // but since we have asserted earlier that we dont have
            // an address, that error only means we still dont have an
            // address
            //

            if(dwResult isnot ERROR_ADDRESS_ALREADY_ASSOCIATED)
            {
                Trace1(ERR,
                       "LanInterfaceDownToUp: Couldnt read binding information for %S",
                       pIcb->pwszName);
            }
       
            pIcb->dwOperationalState = IF_OPER_STATUS_NON_OPERATIONAL;
        
            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    IpRtAssert(pIcb->bBound);

    if(pIcb->ritType isnot ROUTER_IF_TYPE_INTERNAL)
    {
        pIcb->dwOperationalState = IF_OPER_STATUS_OPERATIONAL;
    }
    else
    {
        pIcb->dwOperationalState = IF_OPER_STATUS_CONNECTED;
    }

    //
    // First do the generic interface to up stuff
    //
    
    GenericInterfaceComingUp(pIcb);

    //
    // We restore routes even when this function is being called from
    // add interface, because that is the only way to pick up stack
    // routes
    //

    pricInfo = HeapAlloc(IPRouterHeap,
                         0,
                         sizeof(RESTORE_INFO_CONTEXT));

    if(pricInfo isnot NULL)
    {
        pricInfo->dwIfIndex     = pIcb->dwIfIndex;

        pIcb->bRestoringRoutes  = TRUE;

        dwResult = QueueAsyncFunction(RestoreStaticRoutes,
                                      (PVOID)pricInfo,
                                      FALSE);

        if(dwResult isnot NO_ERROR)
        {
            pIcb->bRestoringRoutes = FALSE;

            IpRtAssert(FALSE);

            Trace2(ERR,
                   "LanInterfaceDownToUp: Error %d queueing function for %S",
                   dwResult,
                   pIcb->pwszName);
        }
    }
    else
    {
        IpRtAssert(FALSE);

        Trace1(ERR,
               "LanInterfaceDownToUp: Error allocating context for %S",
               pIcb->pwszName);
    }   

    return NO_ERROR;
}

DWORD
WanInterfaceInactiveToUp(
    PICB   pIcb
    )

/*++

Routine Description

    This function does things slighlty differently from above because, for
    one, there is no UpdateBindingInfo() call for such adapters

Locks

    

Arguments

    

Return Value


--*/

{
    PRESTORE_INFO_CONTEXT pricInfo;
    DWORD                 dwResult;
    INTERFACE_ROUTE_INFO  rifRoute;
    
    TraceEnter("WanInterfaceInactiveToUp");

    CheckBindingConsistency(pIcb);
    
    Trace1(IF,
           "WanInterfaceInactiveToUp: %S coming up",
           pIcb->pwszName);

    //
    // quick look up of interface given the adapter index.
    // This is done in UpdateBindingInfo for LAN interfaces.
    //

    //StoreAdapterToInterfaceMap(pIcb->dwAdapterId, 
    //                           pIcb->dwIfIndex);
    

    //
    // First do the generic thing
    //
    
    GenericInterfaceComingUp(pIcb);

    //
    // Delete all static routes.  These will be re-added
    // by RestoreStaticRoutes (below) with the correct next hop
    //

    DeleteAllRoutes(pIcb->dwIfIndex, TRUE);

    //
    // Restore all static and NON-Dod routes on this interface
    //

    pricInfo = HeapAlloc(IPRouterHeap,
                         0,
                         sizeof(RESTORE_INFO_CONTEXT));

    if(pricInfo isnot NULL)
    {
        pricInfo->dwIfIndex     = pIcb->dwIfIndex;

        pIcb->bRestoringRoutes  = TRUE;

        dwResult = QueueAsyncFunction(RestoreStaticRoutes,
                                      (PVOID)pricInfo,
                                      FALSE);

        if(dwResult isnot NO_ERROR)
        {
            pIcb->bRestoringRoutes = FALSE;

            IpRtAssert(FALSE);

            Trace2(ERR,
                   "WanInterfaceInactiveToUp: Error %d queueing function for %S",
                   dwResult,
                   pIcb->pwszName);
        }
    }
    else
    {
        IpRtAssert(FALSE);

        Trace1(ERR,
               "WanInterfaceInactiveToUp: Error allocating context for %S",
               pIcb->pwszName);
    }   

    //
    // Change Static route so that it uses the correct adapter index
    //
    
    // ChangeAdapterIndexForDodRoutes(pIcb->dwIfIndex);

    //
    // Add a host route for the remote side
    //
    
    if(pIcb->dwRemoteAddress isnot INVALID_IP_ADDRESS
#if __PIX__
        && (IsRemoteAddressPrivate(pIcb)))
#else
        )
#endif
    {
        rifRoute.dwRtInfoMask          = HOST_ROUTE_MASK;
        rifRoute.dwRtInfoNextHop       = pIcb->pibBindings[0].dwAddress;
        rifRoute.dwRtInfoDest          = pIcb->dwRemoteAddress;
        rifRoute.dwRtInfoIfIndex       = pIcb->dwIfIndex;
        rifRoute.dwRtInfoMetric1       = 1;
        rifRoute.dwRtInfoMetric2       = 0;
        rifRoute.dwRtInfoMetric3       = 0;
        rifRoute.dwRtInfoPreference    = 
            ComputeRouteMetric(MIB_IPPROTO_NETMGMT);
        rifRoute.dwRtInfoViewSet       = RTM_VIEW_MASK_UCAST |
                                          RTM_VIEW_MASK_MCAST; // XXX config
        rifRoute.dwRtInfoType          = MIB_IPROUTE_TYPE_DIRECT;
        rifRoute.dwRtInfoProto         = MIB_IPPROTO_NETMGMT;
        rifRoute.dwRtInfoAge           = 0;
        rifRoute.dwRtInfoNextHopAS     = 0;
        rifRoute.dwRtInfoPolicy        = 0;
        
        dwResult = AddSingleRoute(pIcb->dwIfIndex,
                                  &rifRoute,
                                  pIcb->pibBindings[0].dwMask,
                                  0,        // RTM_ROUTE_INFO::Flags
                                  TRUE,     // Valid route 
                                  TRUE,
                                  TRUE,
                                  NULL);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "WanInterfaceInactiveToUp: Couldnt add host route for %x",
                   pIcb->dwRemoteAddress);
        }
    }

    return NO_ERROR;
}


DWORD
GenericInterfaceComingUp(
    PICB   pIcb
    )

/*++

Routine Description

    This function has the common code for bringing up an interface.
    It assumes that the interface is bound.

    If NAT is running and we have an address (not unnumbered) we add the
    address to NAT.
    We activate router discovery and multicast heartbeat (if they are present)
    Then we add
        (i)   local loopback
        (ii)  local multicast
        (iii) all subnets broadcast
        (iv)  all 1's broadcast
    routes
    Then we call out to the routing protocols and the filter driver to inform
    them of the binding
    
Locks

    ICB_LIST lock held as WRITER

Arguments

    pIcb    ICB of the interface to bring up

Return Value


--*/

{
    DWORD               dwResult, i;
    MIB_IPFORWARDROW    rifRoute;
    PADAPTER_INFO       pBinding;
    
    TraceEnter("GenericInterfaceComingUp");
    
    Trace1(IF,
           "GenericInterfaceComingUp: %S coming UP",
           pIcb->pwszName);

    // Join the All-Routers multicast group

    {
        extern SOCKET McMiscSocket;

        Trace1(IF,
               "CreateSockets: Joining ALL_ROUTERS on %S",
               pIcb->pwszName);
    
        if ( McJoinGroupByIndex( McMiscSocket, 
                                 SOCK_RAW, 
                                 ALL_ROUTERS_MULTICAST_GROUP,
                                 pIcb->dwIfIndex ) is SOCKET_ERROR )
        {
            Trace2(ERR,
                   "GenericInterfaceComingUp: Error %d joining all-routers group on %S",
                   WSAGetLastError(),
                   pIcb->pwszName);
        }
    }
   
    //
    // Start router discovery on this interface. This will cause
    // the advertisement to get updated
    //
    
    dwResult = ActivateRouterDiscovery(pIcb);

        
    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "GenericInterfaceComingUp: Error %d activating router discovery on %S",
               dwResult,
               pIcb->pwszName);
    }

    dwResult = ActivateMHeartbeat(pIcb);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "GenericInterfaceComingUp: Error %d activating router discovery on %S",
               dwResult,
               pIcb->pwszName);
    }

    //
    // Add default routes for the connected network 
    //

    for(i = 0; i < pIcb->dwNumAddresses; i++)
    {
        if(pIcb->pibBindings[i].dwAddress is INVALID_IP_ADDRESS)
        {
            continue;
        }

        AddAutomaticRoutes(pIcb,
                           pIcb->pibBindings[i].dwAddress,
                           pIcb->pibBindings[i].dwMask);
        
    }

    //
    // Interfaces going to UP must have valid binding information.
    // This is passed to the routing protocols
    //
    
    BindInterfaceInAllProtocols(pIcb);
   
    // Set Multicast limits in stack

    ActivateMcastLimits(pIcb);

    for (i=0; i<NUM_INFO_CBS; i++)
    {
        if (!g_rgicInfoCb[i].pfnBindInterface)
        {
            continue;
        }

        dwResult = g_rgicInfoCb[i].pfnBindInterface(pIcb);

        if (dwResult isnot NO_ERROR)
        {
            Trace3(ERR,
                   "GenericInterfaceComingUp: Error %d binding %S for %s info",
                   dwResult,
                   pIcb->pwszName,
                   g_rgicInfoCb[i].pszInfoName);
        }
    }

    return NO_ERROR ;
}


DWORD
LanEtcInterfaceUpToDown(
    PICB pIcb,
    BOOL bDeleted
    )

/*++

Routine Description

    This function is called when a LAN, INTERNAL or LOOPBACK interface goes
    down.

    If the interface is not being deleted, we delete all the static routes.
    We then disable the interface with the routing protocols and call
    the generic routing to handle all the rest
    
Locks

    ICB_LOCK held as WRITER

Arguments

    pIcb
    bDeleted

Return Value

    None    

--*/

{
    DWORD   i,dwResult;

    TraceEnter("LanInterfaceUpToDown");

    if(!bDeleted)
    {
        DeleteAllRoutes(pIcb->dwIfIndex,
                        FALSE);
    }

    GenericInterfaceNoLongerUp(pIcb,
                               bDeleted);

    pIcb->dwOperationalState = IF_OPER_STATUS_NON_OPERATIONAL;

    return NO_ERROR;
}

DWORD
WanInterfaceUpToInactive(
    PICB   pIcb,
    BOOL   bDeleted
    )
{
    DWORD                   dwResult;
    PRESTORE_INFO_CONTEXT   pricInfo;
    

    TraceEnter("WanInterfaceUpToInactive");

    //
    // Delete the route before deallocating the address (which is called in
    // GenericInterfaceNoLongerUp), because that will set Remote addr to
    // invalid and then this route will never be deleted
    //
   
    CheckBindingConsistency(pIcb);

    //
    // If it was up, it should be bound
    //

    IpRtAssert(pIcb->bBound);
    
    if(!bDeleted and
       (pIcb->dwRemoteAddress isnot INVALID_IP_ADDRESS))
    {
        dwResult = DeleteSingleRoute(pIcb->dwIfIndex,
                                     pIcb->dwRemoteAddress,
                                     HOST_ROUTE_MASK,
                                     pIcb->pibBindings[0].dwAddress,
                                     PROTO_IP_NETMGMT,
                                     TRUE);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "WanInterfaceUpToInactive: Couldnt delete host route for %d.%d.%d.%d",
                   PRINT_IPADDR(pIcb->dwRemoteAddress));
        }
    }

    
    GenericInterfaceNoLongerUp(pIcb,
                               bDeleted);

    if(!bDeleted)
    {
#if 1
        //
        // Delete all static routes/nexthops
        //

        DeleteAllRoutes(pIcb->dwIfIndex, FALSE);


/*
        //
        // Delete all netmgmt routes/nexthops
        //
        
        dwResult = DeleteRtmRoutes(g_hNetMgmtRoute, pIcb->dwIfIndex, FALSE);

        if (dwResult is NO_ERROR)
        {
            dwResult = DeleteRtmNexthopsOnInterface(
                        g_hNetMgmtRoute, pIcb->dwIfIndex
                        );
            if (dwResult isnot NO_ERROR)
            {
                Trace1(
                    ERR,
                    "WanInterfaceUpToInactive: Couldnt delete next hops for "
                    "Interface 0x%x",
                     pIcb->dwIfIndex
                     );
            }
        }
*/
        //
        // Restore all static and NON-Dod routes on this interface
        //

        pricInfo = HeapAlloc(
                    IPRouterHeap, 0, sizeof(RESTORE_INFO_CONTEXT)
                    );

        if(pricInfo isnot NULL)
        {
            pricInfo->dwIfIndex     = pIcb->dwIfIndex;

            pIcb->bRestoringRoutes  = TRUE;

            dwResult = QueueAsyncFunction(RestoreStaticRoutes,
                                          (PVOID)pricInfo,
                                          FALSE);

            if(dwResult isnot NO_ERROR)
            {
                pIcb->bRestoringRoutes = FALSE;

                IpRtAssert(FALSE);

                Trace2(ERR,
                       "WanInterfaceUpToInactive: Error %d queueing"
                       " function for %S",
                       dwResult,
                       pIcb->pwszName);
            }
        }
        else
        {
            IpRtAssert(FALSE);

            Trace1(ERR,
                   "WanInterfaceInactiveToUp: Error allocating context for %S",
                   pIcb->pwszName);
        }   

#else
        //
        // Delete all NON-Dod, Netmgmt routes on this interface
        //
        
        DeleteRtmRoutes(g_hNonDodRoute,  pIcb->dwIfIndex, FALSE);
        DeleteRtmRoutes(g_hNetMgmtRoute, pIcb->dwIfIndex, FALSE);

        ChangeAdapterIndexForDodRoutes(pIcb->dwIfIndex);
#endif
    }

    pIcb->dwOperationalState = IF_OPER_STATUS_DISCONNECTED;
 
    return NO_ERROR;
}
    
DWORD
GenericInterfaceNoLongerUp(
    PICB pIcb,
    BOOL bDeleted
    )

/*++

Routine Description

    This function is called by all interfaces (other than CLIENT) when
    they go to DOWN state (The actual state depends upon the interface). This
    may happen because of state change or because the interface is being
    deleted

    If we are not deleting the interface, we delete all the automatically
    generated routes

    We deactivate router discovery and multicast hearbeat.
    If NAT is running, we remove the FIREWALL context for the interface
    from IP and THEN unbind the address in NAT
    (This MUST be done in this order)

    Then we Unbind the interface in the routing protocols running over it.
    We delete the Adapter->Interface map, deallocate the bindings (which does
    different things depending on LAN/WAN) and if there is a DIM event we
    set the event

Locks

    ICB_LIST lock held as WRITER

Arguments

    pIcb     ICB of the interface
    bDeleted Set to TRUE if the state change is because of deletion

Return Value

    None    

--*/

{
    DWORD           dwResult;
    DWORD           i, j;

    TraceEnter("GenericInterfaceNoLongerUp");

    Trace1(IF,
           "GenericInterfaceNoLongerUp: %S no longer UP",
           pIcb->pwszName);

    if(pIcb->bMcastEnabled)
    {
        pIcb->bMcastEnabled = FALSE;

        dwResult = SetMcastOnIf(pIcb,
                                FALSE);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "GenericIfNoLongerUp: Error %d deactivating mcast on %S",
                   dwResult,
                   pIcb->pwszName);
        }
    }

    if(!bDeleted)
    {
        for (i = 0; i < pIcb->dwNumAddresses; i++)
        {
            if(pIcb->pibBindings[i].dwAddress isnot INVALID_IP_ADDRESS)
            {
                DeleteAutomaticRoutes(pIcb,
                                      pIcb->pibBindings[i].dwAddress,
                                      pIcb->pibBindings[i].dwMask);
            }
        }
    }
   
    //
    // Delete any gateways on this
    //

    for(i = 0; i < g_ulGatewayMaxCount; i++)
    {
        if(g_pGateways[i].dwIfIndex is pIcb->dwIfIndex)
        {
            g_pGateways[i].dwAddress = 0;
        }
    }

    //
    // Compress the array
    //

    for(i = 0, j = 1; j < g_ulGatewayMaxCount;j++)
    {
        if(g_pGateways[i].dwAddress isnot 0)
        {
            i++;
        }
        else
        {
            if(g_pGateways[j].dwAddress isnot 0)
            {
                g_pGateways[i] = g_pGateways[j];

                g_pGateways[j].dwAddress = 0;

                i++;
            }
        }
    }

    g_ulGatewayCount = i;

    dwResult = DeActivateRouterDiscovery(pIcb);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "GenericInterfaceNoLongerUp: Error %d deactivating router discovery on %S",
               dwResult,
               pIcb->pwszName);
    }

    dwResult = DeActivateMHeartbeat(pIcb);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "GenericInterfaceNoLongerUp: Error %d deactivating multicast heartbeat on %S",
               dwResult,
               pIcb->pwszName);
    }
   
    if((pIcb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
       (pIcb->ritType isnot ROUTER_IF_TYPE_LOOPBACK))
    {
        UnbindFilterInterface(pIcb);
    }

    //
    // When going out of UP state, the interface loses its address
    //
   
    UnbindInterfaceInAllProtocols(pIcb);

    //if(pIcb->pibBindings) 
    //{
    //    DeleteAdapterToInterfaceMap(pIcb->dwAdapterId) ;
    //}
    
    DeAllocateBindings(pIcb);

    if(pIcb->hDIMNotificationEvent isnot NULL)
    {
        //
        // There was an update pending. Set the event, when the user asks us
        // for info, we will fail the request
        //
        
        if(!SetEvent(pIcb->hDIMNotificationEvent))
        {
            Trace1(ERR,
                   "GenericInterfaceNoLongerUp: Error %d setting update route event",
                   GetLastError());
        }

        CloseHandle(pIcb->hDIMNotificationEvent);

        pIcb->hDIMNotificationEvent = NULL;

    }
    
    return NO_ERROR ;
}

DWORD
WanInterfaceInactiveToDown(
    PICB pIcb,
    BOOL bDeleted
    )
{
    TraceEnter("WanInterfaceInactiveToDown");

    CheckBindingConsistency(pIcb);
    
    IpRtAssert(!pIcb->bBound);
    
    if(!bDeleted)
    { 
        DeleteAllRoutes(pIcb->dwIfIndex,
                        FALSE);
    }

    pIcb->dwOperationalState = UNREACHABLE;

    //DisableInterfacewithWanArp(pIcb);
    
    return NO_ERROR;
}

DWORD
WanInterfaceDownToInactive(
    PICB pIcb
    )
{
    PRESTORE_INFO_CONTEXT   pricInfo;
    DWORD                   dwResult;
    PADAPTER_INFO           pBinding;

    TraceEnter("WanInterfaceDownToInactive");

#if STATIC_RT_DBG

    ENTER_WRITER(BINDING_LIST);

    pBinding = GetInterfaceBinding(pIcb->dwIfIndex);

    pBinding->bUnreach = FALSE;

    EXIT_LOCK(BINDING_LIST);

#endif

    //
    // Set the state before calling restore
    //

    pIcb->dwOperationalState = DISCONNECTED;

    pricInfo = HeapAlloc(IPRouterHeap,
                         0,
                         sizeof(RESTORE_INFO_CONTEXT));

    if(pricInfo isnot NULL)
    {
        pricInfo->dwIfIndex     = pIcb->dwIfIndex;

        pIcb->bRestoringRoutes  = TRUE;

        dwResult = QueueAsyncFunction(RestoreStaticRoutes,
                                      (PVOID)pricInfo,
                                      FALSE);

        if(dwResult isnot NO_ERROR)
        {
            pIcb->bRestoringRoutes = FALSE;

            IpRtAssert(FALSE);

            Trace2(ERR,
                   "WanInterfaceDownToInactive: Error %d queueing function for %S",
                   dwResult,
                   pIcb->pwszName);

            HeapFree(
                IPRouterHeap,
                0,
                pricInfo
                );
        }
    }
    else
    {
        IpRtAssert(FALSE);

        Trace1(ERR,
               "WanInterfaceDownToInactive: Error allocating context for %S",
               pIcb->pwszName);
    }   
    
    return NO_ERROR;
}
      
DWORD
GetInterfaceStatusInfo(
    IN     PICB                   pIcb,
    IN     PRTR_TOC_ENTRY         pToc,
    IN     PBYTE                  pbDataPtr,
    IN OUT PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwInfoSize
    )
{
    PINTERFACE_STATUS_INFO  pisiInfo;

    TraceEnter("GetInterfaceStatusInfo");
    
    if(*pdwInfoSize < sizeof(INTERFACE_STATUS_INFO))
    {
        *pdwInfoSize = sizeof(INTERFACE_STATUS_INFO);
        
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    *pdwInfoSize    = sizeof(INTERFACE_STATUS_INFO);
    
    //pToc->InfoVersion sizeof(INTERFACE_STATUS_INFO);
    pToc->InfoSize  = sizeof(INTERFACE_STATUS_INFO);
    pToc->InfoType  = IP_INTERFACE_STATUS_INFO;
    pToc->Count     = 1;
    pToc->Offset    = (ULONG)(pbDataPtr - (PBYTE) pInfoHdr) ;

    pisiInfo = (PINTERFACE_STATUS_INFO)pbDataPtr;

    pisiInfo->dwAdminStatus         = pIcb->dwAdminState;
    
    return NO_ERROR;
}
    
DWORD
SetInterfaceStatusInfo(
    PICB                    pIcb,
    PRTR_INFO_BLOCK_HEADER  pInfoHdr,
    PBOOL                   pbUpdateDIM
    )
{
    PINTERFACE_STATUS_INFO  pisiInfo;
    PRTR_TOC_ENTRY          pToc;
    DWORD                   dwResult;
    
    TraceEnter("SetInterfaceStatusInfo");

    
    pToc = GetPointerToTocEntry(IP_INTERFACE_STATUS_INFO, pInfoHdr);

    if((pToc is NULL) or
       (pToc->InfoSize is 0))
    {
        //
        // No TOC means no change. Also empty TOC means no change (IN THIS
        // ONE CASE ONLY)
        //

        return NO_ERROR;
    }


    pisiInfo = (PINTERFACE_STATUS_INFO)GetInfoFromTocEntry(pInfoHdr,
                                                           pToc);

    if (pisiInfo is NULL)
    {
        //
        // no info block means no change.
        //

        return NO_ERROR;
    }
    
    dwResult = SetInterfaceAdminStatus(pIcb,
                                       pisiInfo->dwAdminStatus,
                                       pbUpdateDIM);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "SetInterfaceStatusInfo: Error %d setting admin status for %S",
               dwResult,
               pIcb->pwszName);
    }

    return dwResult;
}
    
VOID
DeAllocateBindings(
    PICB  pIcb
    )
{
    PADAPTER_INFO pBinding;
    
    TraceEnter("DeAllocateBindings");

    ENTER_WRITER(BINDING_LIST);

    //
    // For LAN interfaces we remove the binding from the
    // list and free the addresses
    // For WAN  interfaces, to avoid allocations when 
    // connections are coming up and down, we zero out the fields and keep 
    // the memory around. Which means we need to free the memory and the 
    // binding when the interface is deleted
    //
    
    if((pIcb->ritType is ROUTER_IF_TYPE_DEDICATED) or
       (pIcb->ritType is ROUTER_IF_TYPE_INTERNAL) or
       (pIcb->ritType is ROUTER_IF_TYPE_LOOPBACK))
    {
        if(pIcb->bBound)
        {
            //
            // These can not be unnumbered
            //

            IpRtAssert(pIcb->dwNumAddresses isnot 0);
            IpRtAssert(pIcb->pibBindings);

            RemoveBinding(pIcb);
            
            HeapFree(IPRouterHeap, 0, pIcb->pibBindings);

            pIcb->pibBindings     = NULL;
            pIcb->dwNumAddresses  = 0;
            pIcb->bBound          = FALSE;
            pIcb->dwRemoteAddress = INVALID_IP_ADDRESS;
        }
    }
    else
    {
        pBinding = GetInterfaceBinding(pIcb->dwIfIndex);

        if (pBinding) {
            IpRtAssert(pBinding isnot NULL);
        
            pIcb->bBound        = FALSE;
            pBinding->bBound    = FALSE;

            pIcb->dwNumAddresses      = 0;
            pBinding->dwNumAddresses  = 0;
        
            pIcb->dwRemoteAddress     = INVALID_IP_ADDRESS;
            pBinding->dwRemoteAddress = INVALID_IP_ADDRESS;
        
            pIcb->pibBindings[0].dwAddress     = INVALID_IP_ADDRESS;
            pIcb->pibBindings[0].dwMask        = INVALID_IP_ADDRESS;
            pBinding->rgibBinding[0].dwAddress = INVALID_IP_ADDRESS;
            pBinding->rgibBinding[0].dwMask    = INVALID_IP_ADDRESS;

            g_LastUpdateTable[IPADDRCACHE] = 0;
        }
    }

    EXIT_LOCK(BINDING_LIST);

}

DWORD 
GetInterfaceStatistics(
    IN   PICB       pIcb, 
    OUT  PMIB_IFROW pOutBuffer
    )
{
    DWORD           dwResult;

    dwResult = NO_ERROR;
    
    TraceEnter("GetInterfaceStatistics");

    switch(pIcb->ritType)
    {
        case ROUTER_IF_TYPE_HOME_ROUTER:
        case ROUTER_IF_TYPE_FULL_ROUTER:
        {
            dwResult = AccessIfEntryWanArp(ACCESS_GET,
                                           pIcb,
                                           pOutBuffer);

            pOutBuffer->dwIndex        = pIcb->dwIfIndex;

            wcscpy(pOutBuffer->wszName, pIcb->pwszName);

            pOutBuffer->dwAdminStatus  = pIcb->dwAdminState;
            pOutBuffer->dwOperStatus   = pIcb->dwOperationalState;
       
            strncpy(pOutBuffer->bDescr,
                    g_rgcWanString,
                    MAXLEN_IFDESCR - 1);

            pOutBuffer->dwDescrLen =
                min((MAXLEN_IFDESCR-1),strlen(g_rgcWanString));

            pOutBuffer->bDescr[MAXLEN_IFDESCR -1] = '\0';
 
            break;
        }
            
        case ROUTER_IF_TYPE_DEDICATED:
#ifdef KSL_IPINIP
        case ROUTER_IF_TYPE_TUNNEL1:
#endif //KSL_IPINIP
        case ROUTER_IF_TYPE_DIALOUT:
        {
            //
            // A Lan Interface that is up
            //
            
            dwResult = GetIfEntryFromStack(pOutBuffer,
                                           pIcb->dwIfIndex,
                                           FALSE);
            
            if(dwResult is NO_ERROR)
            {
                //
                // Bug 486465
                //
                //  The stack and user mode RRAS service are out
                //  of sync. with respect to IF indices.  This
                //  problem appears to be PnP related.
                //  For now, flag this error and return.
                //  Investigate this further in the next release.
                //
                
                if(pOutBuffer->dwIndex isnot pIcb->dwIfIndex)
                {
                    Trace2(ERR,
                           "GetInterfaceStatistics: failed due to i/f index "
                           "mistmatch, stack %d, IP Router Manager %d",
                           pOutBuffer->dwIndex,
                           pIcb->dwIfIndex);
                           
                    dwResult = ERROR_INVALID_PARAMETER;
                    break;
                }

                //IpRtAssert(pOutBuffer->dwIndex is pIcb->dwIfIndex);

                //
                // Copy out the name too
                //
                
                wcscpy(pOutBuffer->wszName, pIcb->pwszName);

                //
                // Set the user mode status
                //
                
                pOutBuffer->dwAdminStatus  = pIcb->dwAdminState;

#ifdef KSL_IPINIP
                //
                // Till the notification from ipinip to router is done
                // pass the driver status back for tunnels
                //pOutBuffer->dwOperStatus   = pIcb->dwOperationalState;

                if(pIcb->ritType is ROUTER_IF_TYPE_TUNNEL1)
                {
                    strncpy(pOutBuffer->bDescr,
                            g_rgcIpIpString,
                            MAXLEN_IFDESCR - 1);

                    pOutBuffer->dwDescrLen =
                        min((MAXLEN_IFDESCR-1),
                            strlen(g_rgcIpIpString));

                    pOutBuffer->bDescr[MAXLEN_IFDESCR -1] = '\0';

                }
                else
                {
                    pOutBuffer->dwOperStatus = pIcb->dwOperationalState;
                }
#endif //KSL_IPINIP
                pOutBuffer->dwOperStatus = pIcb->dwOperationalState;
            }
            
            break;
        }
        
        case ROUTER_IF_TYPE_INTERNAL:
        {
            
            pOutBuffer->dwIndex = pIcb->dwIfIndex;
            
            wcscpy(pOutBuffer->wszName, pIcb->pwszName);

            pOutBuffer->dwAdminStatus  = pIcb->dwAdminState;
            pOutBuffer->dwOperStatus   = pIcb->dwOperationalState;

            strncpy(pOutBuffer->bDescr,
                    g_rgcInternalString,
                    MAXLEN_IFDESCR - 1);

            pOutBuffer->dwDescrLen =
                min((MAXLEN_IFDESCR-1),strlen(g_rgcInternalString));

            pOutBuffer->bDescr[MAXLEN_IFDESCR -1] = '\0';

            pOutBuffer->dwType = IF_TYPE_PPP;

            dwResult = NO_ERROR;
            
            break;
        }
        
        case ROUTER_IF_TYPE_LOOPBACK:
        {
            
            pOutBuffer->dwIndex = pIcb->dwIfIndex;
            wcscpy(pOutBuffer->wszName, pIcb->pwszName);

            pOutBuffer->dwAdminStatus  = pIcb->dwAdminState;
            pOutBuffer->dwOperStatus   = pIcb->dwOperationalState;

            strncpy(pOutBuffer->bDescr,
                    g_rgcLoopbackString,
                    MAXLEN_IFDESCR - 1);

            pOutBuffer->dwDescrLen =
                min((MAXLEN_IFDESCR-1),strlen(g_rgcLoopbackString));

            pOutBuffer->bDescr[MAXLEN_IFDESCR - 1] = '\0';

            pOutBuffer->dwType  = IF_TYPE_SOFTWARE_LOOPBACK;
            pOutBuffer->dwMtu   = 32768;
            pOutBuffer->dwSpeed = 10000000;

            dwResult = NO_ERROR;
            
            break;
        }

        case ROUTER_IF_TYPE_CLIENT:
        {
            RtlZeroMemory(pOutBuffer,
                          sizeof(MIB_IFROW));

            pOutBuffer->dwIndex        = pIcb->dwIfIndex;

            wcscpy(pOutBuffer->wszName, pIcb->pwszName);

            pOutBuffer->dwAdminStatus  = pIcb->dwAdminState;
            pOutBuffer->dwOperStatus   = pIcb->dwOperationalState;

            pOutBuffer->dwType     = IF_TYPE_PPP;

            dwResult = NO_ERROR;
        }

        default:
        {
            IpRtAssert(FALSE);
        }
    }

    if((dwResult isnot NO_ERROR) and
       ((pIcb->dwOperationalState is NON_OPERATIONAL) or
        (pIcb->dwAdminState is IF_ADMIN_STATUS_DOWN)))
    {
        RtlZeroMemory(pOutBuffer,
                      sizeof(MIB_IFROW));

        pOutBuffer->dwIndex        = pIcb->dwIfIndex;

        wcscpy(pOutBuffer->wszName, pIcb->pwszName);

        pOutBuffer->dwAdminStatus  = pIcb->dwAdminState;
        pOutBuffer->dwOperStatus   = pIcb->dwOperationalState;

        if(pIcb->ritType is ROUTER_IF_TYPE_CLIENT)
        {
            pOutBuffer->dwType     = IF_TYPE_PPP;
        }
        else
        {
#ifdef KSL_IPINIP
            if(pIcb->ritType is ROUTER_IF_TYPE_TUNNEL1)
            {
                strncpy(pOutBuffer->bDescr,
                        g_rgcIpIpString,
                        MAXLEN_IFDESCR - 1);

                pOutBuffer->dwDescrLen =
                    min((MAXLEN_IFDESCR-1),
                        strlen(g_rgcIpIpString));

                pOutBuffer->bDescr[MAXLEN_IFDESCR -1] = '\0';

                pOutBuffer->dwType     = IF_TYPE_TUNNEL;
            }
#endif //KSL_IPINIP
            pOutBuffer->dwType     = IF_TYPE_OTHER;
        }

        dwResult = NO_ERROR;
    }


    return dwResult;
}



DWORD 
SetInterfaceStatistics(
    IN PICB         pIcb, 
    IN PMIB_IFROW   lpInBuffer,
    OUT PBOOL       pbUpdateDIM
    )
{
    DWORD dwResult = NO_ERROR;

    TraceEnter("SetInterfaceStatistics");

    dwResult = SetInterfaceAdminStatus(pIcb,
                                       lpInBuffer->dwAdminStatus,
                                       pbUpdateDIM);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "SetInterfaceStatistics: Error %d setting admin status for %S",
               dwResult,
               pIcb->pwszName);
    }

    return dwResult;
}

DWORD
SetInterfaceAdminStatus(
    IN PICB     pIcb, 
    IN DWORD    dwAdminStatus,
    OUT PBOOL   pbUpdateDIM
    )
{
    DWORD   dwResult;

    TraceEnter("SetInterfaceAdminStatus");
        
    //
    // Not allowed to set to TESTING in NT
    //

    CheckBindingConsistency(pIcb);
    
    if(!((dwAdminStatus is IF_ADMIN_STATUS_DOWN) or
         (dwAdminStatus is IF_ADMIN_STATUS_UP)))
    {

        return ERROR_INVALID_PARAMETER;
    }
    
    dwResult = NO_ERROR;
    *pbUpdateDIM = FALSE;
    
    if((pIcb->dwAdminState is IF_ADMIN_STATUS_UP) and
       (dwAdminStatus is IF_ADMIN_STATUS_DOWN))
    {
        //
        // Going from up to down
        //

        dwResult = InterfaceAdminStatusSetToDown(pIcb, pbUpdateDIM);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "SetInterfaceAdminStatus: Error %d bringing down %S",
                   dwResult,
                   pIcb->pwszName);
        }
    }

    
    if((pIcb->dwAdminState is IF_ADMIN_STATUS_DOWN) and
       (dwAdminStatus is IF_ADMIN_STATUS_UP))
    {
        //
        // Going from down to up
        //

        dwResult = InterfaceAdminStatusSetToUp(pIcb, pbUpdateDIM);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "SetInterfaceAdminStatus: Error %d bringing up %S",
                   dwResult,
                   pIcb->pwszName);
        }
    }
    

    //
    // Check the state after you leave
    //

    CheckBindingConsistency(pIcb);
    
    //
    // All other cases, no change
    //
    
    return dwResult;
}

DWORD
InterfaceAdminStatusSetToUp(
    IN  PICB    pIcb,
    OUT PBOOL   pbUpdateDIM
    )
{
    DWORD       dwResult;
    MIB_IFROW   riInBuffer;

    TraceEnter("InterfaceAdminStatusSetToUp");
    
    riInBuffer.dwIndex       = pIcb->dwIfIndex;
    riInBuffer.dwAdminStatus = IF_ADMIN_STATUS_UP;

    //
    // Going from Down to UP
    //

    dwResult = NO_ERROR;

    //
    // Set the state to UP first so that any functions that checks it sees that
    // we want to be up
    //
    
    pIcb->dwAdminState = IF_ADMIN_STATUS_UP;
    
    switch(pIcb->ritType)
    {
        case ROUTER_IF_TYPE_HOME_ROUTER:
        case ROUTER_IF_TYPE_FULL_ROUTER:
        {
            //
            // Couldnt be in down state and have been connecting or
            // connected
            //
            
            IpRtAssert((pIcb->dwOperationalState isnot CONNECTING) and
                       (pIcb->dwOperationalState isnot CONNECTED));
           

            dwResult = AccessIfEntryWanArp(ACCESS_SET,
                                           pIcb,
                                           &riInBuffer);
            
            if(dwResult isnot NO_ERROR)
            {
                Trace1(ERR,
                       "InterfaceAdminStatusSetToUp: Couldnt set IFEntry for %S",
                       pIcb->pwszName);

                pIcb->dwAdminState = IF_ADMIN_STATUS_DOWN;
            }   
            else
            {
                WanInterfaceDownToInactive(pIcb);
            }
            
            break;
        }

        case ROUTER_IF_TYPE_DEDICATED:
#ifdef KSL_IPINIP
        case ROUTER_IF_TYPE_TUNNEL1:
#endif //KSL_IPINIP        
        {
            //
            // Bring the stuff up in stack
            // We need to set to stack before we add routes etc
            //

            riInBuffer.dwIndex = pIcb->dwIfIndex;

            //
            // Force an update
            //
            
            dwResult = SetIfEntryToStack(&riInBuffer,
                                         TRUE);
            
            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "InterfaceAdminStatusSetToDown: Couldnt set IFEntry for %S. Error %d",
                       pIcb->pwszName,
                       dwResult);

                LanEtcInterfaceUpToDown(pIcb,
                                        FALSE);

                pIcb->dwAdminState = IF_ADMIN_STATUS_DOWN;

                dwResult = ERROR_CAN_NOT_COMPLETE;

                break;
            }

            dwResult = LanEtcInterfaceDownToUp(pIcb,
                                               FALSE);

            if(dwResult isnot NO_ERROR)
            {
                Trace1(ERR,
                       "InterfaceAdminStatusSetToUp: Error %d bringing up LanInterface",
                       dwResult);
                
                pIcb->dwAdminState = IF_ADMIN_STATUS_DOWN;
            }

            break;
        }
        
        default:
        {
            // TBD: Handle other types too

            Trace1(ERR,
                   "InterfaceAdminStatusSetToUp: Tried to set status for %S",
                   pIcb->pwszName);
            
            break;
        }
    }
 
    //
    // If we succeeded in setting status, let DIM know
    //
 
    if(dwResult is NO_ERROR)
    {
        IpRtAssert(pIcb->dwAdminState is IF_ADMIN_STATUS_UP);

        EnableInterfaceWithAllProtocols(pIcb);
        
        *pbUpdateDIM = TRUE;

        //EnableInterfaceWithDIM(pIcb->hDIMHandle,
        //                       PID_IP,
        //                       TRUE);
    }

    return dwResult;
}

DWORD
InterfaceAdminStatusSetToDown(
    IN  PICB    pIcb,
    OUT PBOOL   pbUpdateDIM
    )
{
    DWORD           dwResult;
    MIB_IFROW       riInBuffer;
    
    TraceEnter("InterfaceAdminStatusSetToDown");
    
    riInBuffer.dwIndex       = pIcb->dwIfIndex;
    riInBuffer.dwAdminStatus = IF_ADMIN_STATUS_DOWN;
    
    //
    // Going from up to down
    //
       
    dwResult = NO_ERROR;

    switch(pIcb->ritType)
    {
        case ROUTER_IF_TYPE_DEDICATED:
#ifdef KSL_IPINIP
        case ROUTER_IF_TYPE_TUNNEL1:
#endif //KSL_IPINIP        
        {
            //
            // A Lan Interface that is up or non operational. We can only go
            // to stack if we have an IP Address
            //
          
            if(pIcb->bBound)
            {
                riInBuffer.dwIndex = pIcb->dwIfIndex;

                //
                // Force an update
                //
            
                dwResult = SetIfEntryToStack(&riInBuffer,
                                             TRUE);
            }
                
            if(dwResult isnot NO_ERROR)
            {
                Trace1(ERR,
                       "InterfaceAdminStatusSetToDown: Couldnt set IFEntry for %S",
                       pIcb->pwszName);
            }
            else
            {
                LanEtcInterfaceUpToDown(pIcb,
                                        FALSE);
                
                pIcb->dwAdminState = IF_ADMIN_STATUS_DOWN;
            }

            break;
        }
            
        case ROUTER_IF_TYPE_HOME_ROUTER:
        case ROUTER_IF_TYPE_FULL_ROUTER:
        {
            //
            // A Wan Interface that is down.We need to disable
            // the interface and set the status in WANARP
            //

            if((pIcb->dwOperationalState is CONNECTED) or
               (pIcb->dwOperationalState is CONNECTING))
            {
                Trace1(ERR,
                       "InterfaceAdminStatusSetToDown: Can set %S down since it is a connected WAN interface",
                       pIcb->pwszName);

                dwResult = ERROR_INVALID_DATA;

                break;
            }
                
            dwResult = AccessIfEntryWanArp(ACCESS_SET,
                                           pIcb,
                                           &riInBuffer);
                
            if(dwResult isnot NO_ERROR)
            {
                Trace1(ERR,
                       "InterfaceAdminStatusSetToDown: Couldnt set IFEntry for %S",
                       pIcb->pwszName);
            }
            else
            {
                WanInterfaceInactiveToDown(pIcb,
                                           FALSE);
                    
                pIcb->dwAdminState = IF_ADMIN_STATUS_DOWN;
            }

            break;
        }

        default:
        {
            // TBD: Handle other types too
            
            Trace1(ERR,
                   "InterfaceAdminStatusSetToDown: Tried to set status for %S",
                   pIcb->pwszName);

            break;
        }
            
    }

    //
    // If we succeeded in setting status, let DIM know
    //

    if(dwResult is NO_ERROR)
    {
        IpRtAssert(pIcb->dwAdminState is IF_ADMIN_STATUS_DOWN);
        
        DisableInterfaceWithAllProtocols(pIcb);

        *pbUpdateDIM = TRUE;
        
        //EnableInterfaceWithDIM(pIcb->hDIMHandle,
        //                       PID_IP,
        //                       FALSE);
    }

    return dwResult;
}

VOID
HandleAddressChangeNotification(
    VOID
    )

/*++

Routine Description

    Called in the context of the worker thread when we get a address change
    notification from winsock

Locks

    Acquires the ICB LOCK as WRITER

Arguments

    None

Return Value

    None

--*/

{
    DWORD       dwResult;
    PLIST_ENTRY pleNode;
    PICB        pIcb;

    ENTER_WRITER(ICB_LIST);

    if(g_pInternalInterfaceCb isnot NULL)
    {
        dwResult = UpdateBindingInformation(g_pInternalInterfaceCb);

        if(dwResult isnot NO_ERROR)
        {
            //
            // Cases in which no address was found
            //

            if(dwResult is ERROR_ADDRESS_ALREADY_ASSOCIATED)
            {
                //
                // This may mean that the i/f had no
                // address and still has no address
                //

                Trace1(IF,
                       "AddressChange: No address change for %S",
                       g_pInternalInterfaceCb->pwszName);

            }
            else
            {
                if(dwResult is ERROR_NO_DATA)
                {
                    //
                    // No data means we had an address and now have none
                    //

                    IpRtAssert(!g_bUninitServer);

                    dwResult = LanEtcInterfaceUpToDown(g_pInternalInterfaceCb,
                                                       FALSE);

                    g_bUninitServer = TRUE;

                    if(dwResult isnot NO_ERROR)
                    {
                        Trace2(ERR,
                               "AddressChange: Error %d bringing down interface %S",
                               dwResult,
                               g_pInternalInterfaceCb->pwszName);
                    }
                }
                else
                {
                    //
                    // All others
                    //

                    Trace2(ERR,
                           "AddressChange: Error %d trying to update binding for %S",
                           dwResult,
                           g_pInternalInterfaceCb->pwszName);
                }
            }
        }
        else
        {
            //
            // Cases in which an address was actually read out
            //

            if(g_bUninitServer)
            {
                //
                // First time we are getting an address
                //

                g_bUninitServer = FALSE;

                dwResult = LanEtcInterfaceDownToUp(g_pInternalInterfaceCb,
                                                   FALSE);

                if(dwResult isnot NO_ERROR)
                {
                    Trace1(ERR,
                           "AddressChange: Error %d bringing up server if",
                           dwResult);
                }
            }
            else
            {
                //
                // We had an address, it is changing
                //

                UnbindInterfaceInAllProtocols(g_pInternalInterfaceCb);

                BindInterfaceInAllProtocols(g_pInternalInterfaceCb);
            }
        }
    }

    for(pleNode = &ICBList;
        pleNode->Flink isnot &ICBList;
        pleNode = pleNode->Flink)
    {
        pIcb = CONTAINING_RECORD(pleNode->Flink,
                                 ICB,
                                 leIfLink);


        //
        // Already handled the INTERNAL case above, We only
        // handle LAN cards here
        //

        if(pIcb->ritType isnot ROUTER_IF_TYPE_DEDICATED)
        {
            continue;
        }

        if(pIcb->dwOperationalState is IF_OPER_STATUS_NON_OPERATIONAL)
        {
            //
            // If the admin state is down, we skip the interface
            //

            if(pIcb->dwAdminState isnot IF_ADMIN_STATUS_UP)
            {
                continue;
            }

            //
            // If the interface is DOWN, maybe this DHCP event will get it 
            // up. So lets try that first
            //

            IpRtAssert(pIcb->bBound is FALSE);

            dwResult = LanEtcInterfaceDownToUp(pIcb,
                                               FALSE);

            if(dwResult isnot NO_ERROR)
            {
                Trace2(IF,
                       "AddressChange: Tried to bring up %S on receiving DHCP notification. However LanInterfaceDownToUp() returned error %d",
                       pIcb->pwszName,
                       dwResult);
            }
            else
            {
                Trace1(IF,
                       "AddressChange: Succesfully brought up %S",
                       pIcb->pwszName);
            }

            continue;
        }

        //
        // This interface was already up. Maybe the
        // address is changing
        //

        IpRtAssert(pIcb->bBound);

        dwResult = UpdateBindingInformation(pIcb);

        CheckBindingConsistency(pIcb);

        if(dwResult isnot NO_ERROR)
        {
            if(dwResult is ERROR_ADDRESS_ALREADY_ASSOCIATED)
            {
                //
                // This may mean that the i/f had no
                // address and still has no address
                //

                Trace1(IF,
                       "AddressChange: No address change for %S",
                       pIcb->pwszName);

                continue;
            }

            if(dwResult is ERROR_NO_DATA)
            {
                //
                // No data means we lost addresses
                //

                dwResult = LanEtcInterfaceUpToDown(pIcb,
                                                   FALSE);

                if(dwResult isnot NO_ERROR)
                {
                    Trace2(ERR,
                           "AddressChange: Error %d bringing down interface %S",
                           dwResult,
                           pIcb->pwszName);
                }

                continue;
            }

            Trace2(ERR,
                   "AddressChange: Error %d trying to update binding for %S",
                   dwResult,
                   pIcb->pwszName);

            continue;
        }

        //
        // Addresses changed so bind and unbind
        // with all protocols
        //

        UnbindInterfaceInAllProtocols(pIcb);

        BindInterfaceInAllProtocols(pIcb);

        UpdateAdvertisement(pIcb);
    }

    EXIT_LOCK(ICB_LIST);

}

DWORD
UpdateBindingInformation(
    PICB pIcb
    )

/*++
  
Routine Description

    Reads the registry for the ip address and mask associated with the
    interface. Then calls down into the stack to get a valid index
  
Locks 


Arguments
      

Return Value

    NO_ERROR        There was an address change and a new address was found
    ERROR_NO_DATA   No addresses were found (and there were addresses on
                    this interface originally) 
    ERROR_ADDRESS_ALREADY_ASSOCIATED 
        If there is no change in addresses. Also returned if the interface
        had no addresses to begin with and still has no addresses


--*/

{
    DWORD           dwResult, dwNumNewAddresses, dwNumOldAddresses;
    PICB_BINDING    pNewBinding,pOldBinding;
    DWORD           dwNewIfIndex,dwBCastBit,dwReasmSize;
    BOOL            bFound, bChange, bStack;
    DWORD           i, j;
    PWCHAR          pwszName;

    DWORD           dwAddr, dwLen;

    TraceEnter("UpdateBindingInformation");

    CheckBindingConsistency(pIcb);
   
    //
    // Only called for LAN and ras server interfaces. These DO NOT run in
    // unnumbered mode. Thus we can continue making assumptions that
    // if bound, dwNumAddresses != 0
    //
 
    if((pIcb->ritType isnot ROUTER_IF_TYPE_DEDICATED) and
       (pIcb->ritType isnot ROUTER_IF_TYPE_INTERNAL))
    {
        Trace2(IF,
               "UpdateBindingInformation: %S is type %d so not updating binding information",
               pIcb->pwszName,
               pIcb->ritType);

        return ERROR_ADDRESS_ALREADY_ASSOCIATED;
    }

    IpRtAssert((pIcb->dwIfIndex isnot 0) and 
               (pIcb->dwIfIndex isnot INVALID_IF_INDEX));

    dwNumNewAddresses   = 0;
    pNewBinding         = NULL;
    pOldBinding         = pIcb->pibBindings;
    dwNumOldAddresses   = pIcb->dwNumAddresses;


    dwResult = GetIpInfoForInterface(pIcb->dwIfIndex,
                                     &dwNumNewAddresses,
                                     &pNewBinding,
                                     &dwBCastBit,
                                     &dwReasmSize);

    if(dwResult isnot NO_ERROR)
    {
        if(dwResult isnot ERROR_NO_DATA)
        {
            Trace2(ERR,
                   "UpdateBindingInformation: Error %d getting IP info for interface %S",
                   dwResult,
                   pIcb->pwszName);
        }
        else
        {
            //
            // If no addresses were found and there were no addresses to begin
            // with, then change the error code
            //

            if(pIcb->dwNumAddresses is 0)
            {
                dwResult = ERROR_ADDRESS_ALREADY_ASSOCIATED;
            }
        }

        return dwResult;
    }
            
    IpRtAssert(dwNumNewAddresses);
    IpRtAssert(pNewBinding);

    //
    // Make sure you will find an adapter index. Otherwise all this is no use
    //


#if DBG
        
    for(i = 0; i < dwNumNewAddresses; i++)
    {
        Trace4(IF,
               "UpdateBindingInformation: Interface: %S, Address: %d.%d.%d.%d Mask: %d.%d.%d.%d Index: 0x%x", 
               pIcb->pwszName, 
               PRINT_IPADDR(pNewBinding[i].dwAddress),
               PRINT_IPADDR(pNewBinding[i].dwMask),
               pIcb->dwIfIndex);
    }

#endif
    
    //
    // At this point the interface can be considered bound
    //

    pIcb->bBound = TRUE;
    
    //
    // Go through the address you have and if they dont appear in the list of 
    // the ones you read out, delete the associated static route
    //

    bChange = FALSE;

    for(i = 0; i < dwNumOldAddresses; i++)
    {
        bFound = FALSE;
        
        for(j = 0; j < dwNumNewAddresses; j++)
        {
            //
            // Check both the mask and the address
            //

            if((pOldBinding[i].dwAddress is pNewBinding[j].dwAddress) and
               (pOldBinding[i].dwMask is pNewBinding[j].dwMask))
            {
                bFound = TRUE;

                break;
            }
        }

        if(!bFound)
        {
            bChange = TRUE;
            
            //
            // Only delete routes we would have added in the first place
            //

            Trace2(IF,
                   "UpdateBindingInformation: Address %d.%d.%d.%d existed on %S earlier, but is now absent",
                   PRINT_IPADDR(pOldBinding[i].dwAddress),
                   pIcb->pwszName);
            
            DeleteAutomaticRoutes(pIcb,
                                  pOldBinding[i].dwAddress,
                                  pOldBinding[i].dwMask);
        }
    }

    //
    // Now go through the stuff read out from the registry and see if you 
    // already have the address(es). 
    //
    
    for(i = 0; i < dwNumNewAddresses; i++)
    {
        bFound = FALSE;
        
        for(j = 0; j < dwNumOldAddresses; j++)
        {
            if((pNewBinding[i].dwAddress is pOldBinding[j].dwAddress) and
               (pNewBinding[i].dwMask is pOldBinding[j].dwMask))
            {
                bFound = TRUE;

                break;
            }
        }

        if(!bFound)
        {
            bChange = TRUE;
        }
    }

    if(!bChange)
    {
        //
        // No change so we can leave
        //

        if(pNewBinding)
        {
            HeapFree(IPRouterHeap,
                     0,
                     pNewBinding);
        }

        return ERROR_ADDRESS_ALREADY_ASSOCIATED;
    }
    
    //
    // So there has been some change
    // At this point we need to add the binding to the hash table
    //

    ENTER_WRITER(BINDING_LIST);

    //
    // If you had old bindings, remove them
    // Also remove the adapter to Interface map
    //

    if(pOldBinding)
    {
        RemoveBinding(pIcb);
    }

    pIcb->pibBindings         = pNewBinding;
    pIcb->dwNumAddresses      = dwNumNewAddresses;
    pIcb->dwBCastBit          = dwBCastBit;
    pIcb->dwReassemblySize    = dwReasmSize;
        
    
    AddBinding(pIcb);

    //
    // We do the same thing we did above, but now we add the routes.
    // We cant do this before because the adapter id and binding info
    // hasnt been set in the hash table
    //

    for(i = 0; i < dwNumNewAddresses; i++)
    {
        bFound = FALSE;
        
        for(j = 0; j < dwNumOldAddresses; j++)
        {
            if((pNewBinding[i].dwAddress is pOldBinding[j].dwAddress) and
               (pNewBinding[i].dwMask is pOldBinding[j].dwMask))
            {
                bFound = TRUE;
            }
        }

        if(!bFound)
        {
            Trace3(IF,
                   "UpdateBindingInformation: Address %d.%d.%d.%d/%d.%d.%d.%d new for %S",
                   PRINT_IPADDR(pNewBinding[i].dwAddress),
                   PRINT_IPADDR(pNewBinding[i].dwMask),
                   pIcb->pwszName);
            
            AddAutomaticRoutes(pIcb,
                               pNewBinding[i].dwAddress,
                               pNewBinding[i].dwMask);
        }
    }
   
    if(pOldBinding)
    { 
        HeapFree(IPRouterHeap,
                 0,
                 pOldBinding);
    }

    //
    // Such interfaces can not have a kernel context
    //
        
    EXIT_LOCK(BINDING_LIST);

    return NO_ERROR;
}


DWORD
GetAdapterInfo(
    DWORD    dwIpAddress,
    PDWORD   pdwAdapterId,
    PDWORD   pdwBCastBit,
    PDWORD   pdwReasmSize
    )

/*++
  
Routine Description

    Queries the tcpip driver with IP_MIB_STATS to figure out the
    adapter index for the adapter with the given ip address.
  
Locks 


Arguments
      

Return Value

    Index if successfule
    INVALID_IF_INDEX otherwise
    
--*/

{
    DWORD   i, dwNumEntries, MatchIndex, dwResult, Size;
    
    PMIB_IPADDRTABLE pAddrTable;
    
    *pdwAdapterId    = INVALID_ADAPTER_ID;
    *pdwBCastBit     = 1;
    *pdwReasmSize    = 0;
    
    dwResult = AllocateAndGetIpAddrTableFromStack(&pAddrTable,
                                                  FALSE,
                                                  IPRouterHeap,
                                                  0);
    
    if(dwResult isnot NO_ERROR) 
    {

        Trace1(ERR,
               "GetAdapterInfo: Error %d getting IP Address table from stack",
               dwResult);

        return dwResult;
    }
    
    for (i = 0; i < pAddrTable->dwNumEntries; i++) 
    {
        if(pAddrTable->table[i].dwAddr is dwIpAddress) 
        {
            *pdwAdapterId       = pAddrTable->table[i].dwIndex;
            *pdwBCastBit        = pAddrTable->table[i].dwBCastAddr;
            *pdwReasmSize       = pAddrTable->table[i].dwReasmSize;

            HeapFree(IPRouterHeap,
                     0,
                     pAddrTable);
            
            return NO_ERROR;
        }
    }

    HeapFree(IPRouterHeap,
             0,
             pAddrTable);
            
    return ERROR_INVALID_DATA;
}

DWORD
GetBestNextHopMaskGivenICB(
    PICB     pIcb,
    DWORD    dwNextHopAddr
    )

/*++

Routine Description

    Gets the longest mask for the next hop
  
Locks 


Arguments

    pIcb           the Interface Control Block over which the route goes out
    dwNextHopAddr  The next hop addr

Return Value

    0xFFFFFFFF if not found

--*/

{
    DWORD           i, dwLastMask;
    
#if DBG
    
    BOOL    bFound = FALSE;
    
#endif

    CheckBindingConsistency(pIcb);
    
    dwLastMask = 0;
    
    for(i = 0; i < pIcb->dwNumAddresses; i++)
    {
        if((pIcb->pibBindings[i].dwAddress & pIcb->pibBindings[i].dwMask) is
           (dwNextHopAddr & pIcb->pibBindings[i].dwMask))
        {

#if DBG            
            bFound = TRUE;
#endif
            if(pIcb->pibBindings[i].dwMask > dwLastMask)
            {
                dwLastMask = pIcb->pibBindings[i].dwMask;
            }
        }
    }

#if DBG
    
    if(!bFound)
    {
        Trace2(ERR,
               "GetBestNextHopMaskGivenICB: Didnt find match. I/f 0x%x Nexthop %x",
               pIcb->dwIfIndex,
               dwNextHopAddr);
    }
    
#endif

    if(dwLastMask is 0x00000000)
    {
        return 0xFFFFFFFF;
    }
    else
    {
        return dwLastMask;
    }
}

DWORD
GetBestNextHopMaskGivenIndex(
    DWORD  dwIfIndex,
    DWORD  dwNextHopAddr
    )

/*++

Routine Description

    Gets the longest mask for the next hop
  
Locks 


Arguments

    pIcb           the Interface Control Block over which the route goes out
    dwNextHopAddr  The next hop addr

Return Value

    0x00000000 if not found

--*/

{
    PICB pIcb;

    pIcb = InterfaceLookupByIfIndex(dwIfIndex);

    if(pIcb is NULL)
    {
        Trace1(ERR,
               "GetBestNextHopMaskGivenIndex: Couldnt find pIcb for index 0x%x",
               dwIfIndex);

        return 0x00000000;
    }

    return GetBestNextHopMaskGivenICB(pIcb,
                                      dwNextHopAddr);
}

DWORD
InitializeLoopbackInterface(
    PICB    pIcb
    )
{
    DWORD               dwResult, i, j;
    PADAPTER_INFO       pBindNode;
    INTERFACE_ROUTE_INFO rifRoute;
    PLIST_ENTRY         pleNode;

    TraceEnter("InitLoopIf");
    
    g_pLoopbackInterfaceCb = pIcb;
    
    dwResult = GetAdapterInfo(IP_LOOPBACK_ADDRESS,
                              &(pIcb->dwIfIndex),
                              &(pIcb->dwBCastBit),
                              &(pIcb->dwReassemblySize));

    if(dwResult isnot NO_ERROR)
    {
        Trace0(ERR,
               "InitLoopIf: Couldnt find adapter id for loopback interface");

        return ERROR_CAN_NOT_COMPLETE;
    }

    IpRtAssert(pIcb->dwIfIndex is LOOPBACK_INTERFACE_INDEX);

    IpRtAssert(pIcb->pibBindings isnot NULL);

    //
    // This will always have one address
    //

    pIcb->dwNumAddresses = 1;
    pIcb->bBound         = TRUE;
    
    //
    // Loopback interfaces have a class A mask
    //

    pIcb->pibBindings[0].dwAddress   = IP_LOOPBACK_ADDRESS;
    pIcb->pibBindings[0].dwMask      = CLASSA_MASK;
        
    ENTER_WRITER(BINDING_LIST);

    pBindNode = GetInterfaceBinding(pIcb->dwIfIndex);

    if(!pBindNode)
    {
        Trace1(ERR,
               "IniteLoopIf: Binding not found for %S",
               pIcb->pwszName);

        IpRtAssert(FALSE);

        //
        // Something really bad happened and we didnt have a
        // bind block for the interface
        //

        AddBinding(pIcb);
    }
    else
    {
        pBindNode->bBound                   = TRUE;
        pBindNode->dwNumAddresses           = 1;
        pBindNode->dwRemoteAddress          = INVALID_IP_ADDRESS;
        pBindNode->rgibBinding[0].dwAddress = IP_LOOPBACK_ADDRESS;
        pBindNode->rgibBinding[0].dwMask    = CLASSA_MASK;

        pBindNode->dwBCastBit               = pIcb->dwBCastBit;
        pBindNode->dwReassemblySize         = pIcb->dwReassemblySize;
        pBindNode->ritType                  = pIcb->ritType;
    }
    
    EXIT_LOCK(BINDING_LIST);
    
    rifRoute.dwRtInfoMask          = CLASSA_MASK;
    rifRoute.dwRtInfoNextHop       = IP_LOOPBACK_ADDRESS;
    rifRoute.dwRtInfoDest          = (IP_LOOPBACK_ADDRESS & CLASSA_MASK);
    rifRoute.dwRtInfoIfIndex       = pIcb->dwIfIndex;
    rifRoute.dwRtInfoMetric1       = 1;
    rifRoute.dwRtInfoMetric2       = 0;
    rifRoute.dwRtInfoMetric3       = 0;
    rifRoute.dwRtInfoViewSet       = RTM_VIEW_MASK_UCAST |
                                      RTM_VIEW_MASK_MCAST; // XXX config
    rifRoute.dwRtInfoPreference    = ComputeRouteMetric(MIB_IPPROTO_LOCAL);
    rifRoute.dwRtInfoType          = MIB_IPROUTE_TYPE_DIRECT;
    rifRoute.dwRtInfoProto         = MIB_IPPROTO_LOCAL;
    rifRoute.dwRtInfoAge           = 0;
    rifRoute.dwRtInfoNextHopAS     = 0;
    rifRoute.dwRtInfoPolicy        = 0;

    dwResult = AddSingleRoute(pIcb->dwIfIndex,
                              &rifRoute,
                              CLASSA_MASK,
                              0,     // RTM_ROUTE_INFO::Flags
                              FALSE, // We dont know what protocols might do
                              FALSE, // No need to add to stack
                              FALSE,
                              NULL);

    //
    // Now we need to go through all the bindings that are there
    // and add the loopback route for them. We do this here because
    // the loopback interface may be add AFTER the other interfaces
    //
    
    //
    // NOTE - this is going to take a lock recursively when it goes
    // to rtmif.c
    //

    ENTER_READER(BINDING_LIST);

    for(i = 0; i < BINDING_HASH_TABLE_SIZE; i++)
    {
        for(pleNode = g_leBindingTable[i].Flink;
            pleNode isnot &g_leBindingTable[i];
            pleNode = pleNode->Flink)
        {
            PADAPTER_INFO   pBinding;

            pBinding = CONTAINING_RECORD(pleNode, ADAPTER_INFO, leHashLink);

            for(j = 0; j < pBinding->dwNumAddresses; j++)
            {
                if(pBinding->rgibBinding[j].dwAddress is INVALID_IP_ADDRESS)
                {
                    continue;
                }

                AddLoopbackRoute( 
                    pBinding->rgibBinding[j].dwAddress,
                    pBinding->rgibBinding[j].dwMask
                    );
            }
        }
    }
    
    EXIT_LOCK(BINDING_LIST);
    
    return NO_ERROR;
}

#ifdef KSL_IPINIP
DWORD
IpIpTunnelInitToDown(
    PICB    pIcb
    )
{
    return NO_ERROR;
}
#endif //KSL_IPINIP

DWORD
LanEtcInterfaceInitToDown(
    PICB pIcb
    )
{
    DWORD           dwResult, dwNumAddresses, dwMask;
    PICB_BINDING    pBinding;
    DWORD           dwIfIndex = INVALID_IF_INDEX,dwBCastBit,dwReasmSize;
    DWORD           i;
    MIB_IFROW       riInBuffer;
    PWCHAR          pwszName;
    PLIST_ENTRY     ple;
    PROUTE_LIST_ENTRY prl;
    
    IPRouteEntry    *pRouteEntry;

    TraceEnter("LanInterfaceInitToDown");

    dwNumAddresses  = 0;
    pBinding        = NULL;
    pwszName        = pIcb->pwszName;
    
    dwResult = ReadAddressFromRegistry(pwszName,
                                       &dwNumAddresses,
                                       &pBinding,
                                       FALSE);
    
    if(dwResult isnot NO_ERROR) 
    {
        //
        // If there is no data, means the lan card wasnot UP anyway
        //

        if(dwResult is ERROR_NO_DATA)
        {
            return NO_ERROR;
        }
        
        Trace2(ERR, 
               "LanInterfaceInitToDown: Error %d reading IP Address information for interface %S",
               dwResult,
               pIcb->pwszName);

        return dwResult;
    }

    //
    // Make sure you will find an adapter index. Otherwise all this is no use
    //

    for(i = 0; i < dwNumAddresses; i++)
    {
        //
        // Try to get an index using all possible addresses
        //
        
        dwResult = GetAdapterInfo(pBinding[i].dwAddress,
                                  &dwIfIndex,
                                  &dwBCastBit,
                                  &dwReasmSize);

        if(dwResult is NO_ERROR)
        {
            //
            // Ok so we found a valid index from a good address
            //

            break;
        }
    }
        
    if((dwIfIndex is INVALID_IF_INDEX) or
       (dwIfIndex isnot pIcb->dwIfIndex))
    {
        Trace2(ERR, 
               "LanInterfaceInitToDown: Couldnt find adapter index for interface %S using %d.%d.%d.%d",
               pIcb->pwszName,
               PRINT_IPADDR(pBinding[0].dwAddress));
        
        HeapFree(IPRouterHeap,
                 0,
                 pBinding);
        
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Delete all the routes in the stack
    //

    for (ple = g_leStackRoutesToRestore.Flink;
         ple != &g_leStackRoutesToRestore;
         ple = ple->Flink)
    {
        prl = (PROUTE_LIST_ENTRY) 
                CONTAINING_RECORD(ple, ROUTE_LIST_ENTRY, leRouteList); 

        TraceRoute2(
            ROUTE, "%d.%d.%d.%d/%d.%d.%d.%d",
            PRINT_IPADDR( prl->mibRoute.dwForwardDest ),
            PRINT_IPADDR( prl->mibRoute.dwForwardMask )
            );
                
        if(prl->mibRoute.dwForwardIfIndex isnot dwIfIndex)
        {
            //
            // Not going out over this interface
            //
            
            continue;
        }

        prl->mibRoute.dwForwardType = MIB_IPROUTE_TYPE_INVALID;
        
        dwResult = SetIpForwardEntryToStack(&(prl->mibRoute));
        
        if (dwResult isnot NO_ERROR) 
        {
            Trace2(ERR,
                   "ReinstallOldRoutes: Failed to add route to %x from "
                   " init table. Error %x",
                   prl->mibRoute.dwForwardDest,
                   dwResult);
        }
    }


    //
    // Dont really need it anymore
    //
    
    HeapFree(IPRouterHeap,
             0,
             pBinding);
        

    //
    // Going from up to down
    //

    riInBuffer.dwIndex          = dwIfIndex;
    riInBuffer.dwAdminStatus    = IF_ADMIN_STATUS_DOWN;


    dwResult = SetIfEntryToStack(&riInBuffer,
                                 TRUE);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "LanInterfaceInitToDown: Couldnt set IFEntry for %S",
               pIcb->pwszName);
    }
    
    DeleteAllRoutes(pIcb->dwIfIndex,
                    FALSE);

    return dwResult;
}

DWORD
GetIpInfoForInterface(
    IN  DWORD   dwIfIndex,
    OUT PULONG  pulNumAddresses,
    OUT ICB_BINDING **ppAddresses,
    OUT PDWORD  pdwBCastBit,
    OUT PDWORD  pdwReasmSize
    )

/*++

Routine Description

    Gets the addresses and other ip information for an interface

Locks

    None needed

Arguments

    dwIfIndex,
    pdwNumAddresses
    ppAddresses
    pdwBCastBit
    pdwReasmSize

Return Value

    NO_ERROR
    Win32 Errorcode

--*/

{
    DWORD   dwResult, i;
    ULONG   ulAddrIndex, ulCount, ulValid;

    PMIB_IPADDRTABLE pAddrTable;

    *pulNumAddresses = 0;
    *pdwBCastBit     = 1;
    *pdwReasmSize    = 0;
    *ppAddresses     = NULL;

    dwResult = AllocateAndGetIpAddrTableFromStack(&pAddrTable,
                                                  TRUE,
                                                  IPRouterHeap,
                                                  0);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetIpInfoForInterface: Error %d getting IP Address table from stack",
               dwResult);

        return dwResult;
    }

    ulCount = 0;
    ulValid = 0;

    for (i = 0; i < pAddrTable->dwNumEntries; i++)
    {
        if(pAddrTable->table[i].dwIndex is dwIfIndex)
        {
            ulCount++;

            if(!(IsValidIpAddress(pAddrTable->table[i].dwAddr)) or
               (pAddrTable->table[i].dwMask is 0))
            {
                //
                // Since this is only called for numbered links
                //

                continue;
            }

            //
            // Make sure this is not a duplicate. Since this is ordered, we
            // merely check the next address
            //

            if((i isnot (pAddrTable->dwNumEntries - 1)) and
               (pAddrTable->table[i].dwAddr is pAddrTable->table[i + 1].dwAddr))
            {
                Trace1(ERR,
                       "GetIpInfoForInterface: %d.%d.%d.%d duplicate address",
                       PRINT_IPADDR(pAddrTable->table[i].dwAddr));

                continue;
            }

            ulValid++;
        }
    }

    //
    // See if we have good addresses
    //

    if(ulValid is 0)
    {
        if(ulCount isnot 0)
        {
            Trace1(ERR,
                   "GetIpInfoForInterface: If 0x%x has addresses entries which are 0s",
                   dwIfIndex);
        }

        HeapFree(IPRouterHeap,
                 0,
                 pAddrTable);

        return ERROR_NO_DATA;
    }  

    //
    // Allocate from private heap
    //

    *ppAddresses = HeapAlloc(IPRouterHeap,
                             HEAP_ZERO_MEMORY,
                             (sizeof(ICB_BINDING) * ulValid));

    if(*ppAddresses is NULL)
    {
        Trace0(ERR,
               "GetIpInfoForInterface: Error allocating memory");

        HeapFree(IPRouterHeap,
                 0,
                 pAddrTable);

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Now copy out the valid addresses
    //

    ulAddrIndex = 0;

    for (i = 0; i < pAddrTable->dwNumEntries; i++)
    {
        if(pAddrTable->table[i].dwIndex is dwIfIndex)
        {

            if(!(IsValidIpAddress(pAddrTable->table[i].dwAddr)) or
               (pAddrTable->table[i].dwMask is 0))
            {
                continue;
            }

            if((i isnot (pAddrTable->dwNumEntries - 1)) and
               (pAddrTable->table[i].dwAddr is pAddrTable->table[i + 1].dwAddr))
            {
                continue;
            }

            if(!(*pdwReasmSize))
            {
                *pdwReasmSize = pAddrTable->table[i].dwReasmSize;
                *pdwBCastBit  = pAddrTable->table[i].dwBCastAddr;
            }

            (*ppAddresses)[ulAddrIndex].dwAddress = pAddrTable->table[i].dwAddr;
            (*ppAddresses)[ulAddrIndex].dwMask    = pAddrTable->table[i].dwMask;

            ulAddrIndex++;
        }
    }

    IpRtAssert(ulAddrIndex is ulValid);

    *pulNumAddresses = ulValid;

    HeapFree(IPRouterHeap,
             0,
             pAddrTable);

    return NO_ERROR;
}

DWORD
ReadAddressFromRegistry(
    IN  PWCHAR          pwszIfName,
    OUT PDWORD          pdwNumAddresses,
    OUT ICB_BINDING     **ppibAddressInfo,
    IN  BOOL            bInternalIf
    )
{
    HKEY    hadapkey ;
    CHAR    buff[512], pszInterfaceName[256];
    DWORD   dwDhcp, dwResult, dwSize, dwType;
    
    TraceEnter("ReadAddressFromRegistry");

    Trace1(IF,
           "ReadAddressFromRegistry: Reading address for %S",
           pwszIfName);

    wcstombs(pszInterfaceName, pwszIfName, wcslen(pwszIfName));

    pszInterfaceName[wcslen(pwszIfName)] = '\0';

    
    *pdwNumAddresses    = 0;
    *ppibAddressInfo    = NULL;
    
    //
    // The IP address should be in the registry
    //
    
    strcpy(buff, REG_KEY_TCPIP_INTERFACES);
    strcat(buff,"\\");
    strcat(buff, pszInterfaceName) ;


    dwResult = RegOpenKey(HKEY_LOCAL_MACHINE,
                          buff,
                          &hadapkey);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "ReadAddressFromRegistry: Unable to open key %s",
               buff);

        return dwResult;
    }

    dwDhcp = 0;
  
    if(!bInternalIf)
    {
        //
        // Get the EnableDHCP flag
        //

        dwSize = sizeof(DWORD);

        dwResult = RegQueryValueEx(hadapkey,
                                   REGISTRY_ENABLE_DHCP,
                                   NULL,
                                   &dwType,
                                   (PBYTE)&dwDhcp,
                                   &dwSize);

        if(dwResult isnot NO_ERROR)
        {
            Trace0(ERR,
                   "ReadAddressFromRegistry: Unable to read DHCP Enabled key");

            RegCloseKey(hadapkey);

            return dwResult;
        }
    }
    else
    {
        //
        // tcpcfg writes server adapter address as DHCP but
        // does not set dhcp enable
        //

        dwDhcp = 1;
    }
  
    //
    // Get the ip address for the net interface
    //
    
    dwSize = 0 ;

    if(dwDhcp == 0) 
    {
        dwResult = ReadAddressAndMaskValues(hadapkey,
                                            REGISTRY_IPADDRESS,
                                            REGISTRY_SUBNETMASK,
                                            ppibAddressInfo,
                                            pdwNumAddresses);
    }
    else 
    {

        //
        // First try autonet, and if that fails, read the DHCP
        // This needs to be done because the DHCP address is not cleared
        // out when running in autonet mode, but the autonet address is set
        // to 0.0.0.0 when in DHCP mode
        //

        dwResult = ReadAddressAndMaskValues(hadapkey,
                                            REGISTRY_AUTOCONFIGIPADDRESS,
                                            REGISTRY_AUTOCONFIGSUBNETMASK,
                                            ppibAddressInfo,
                                            pdwNumAddresses);

        if(dwResult isnot NO_ERROR)
        {
            dwResult = ReadAddressAndMaskValues(hadapkey,
                                                REGISTRY_DHCPIPADDRESS,
                                                REGISTRY_DHCPSUBNETMASK,
                                                ppibAddressInfo,
                                                pdwNumAddresses);
        }
    }   

    RegCloseKey(hadapkey);

    if(dwResult isnot NO_ERROR)
    {
        Trace3(ERR,
               "ReadAddressFromRegistry: Couldnt read address for %S. Error %d. DHCP %d",
               pwszIfName,
               dwResult,
               dwDhcp);
        
        return dwResult;
    }
    else
    {
#if DBG
        DWORD i;

        Trace2(IF,
               "--%d addresses on %S\n",
               *pdwNumAddresses,
               pwszIfName);

        for(i = 0; i < *pdwNumAddresses; i++)
        {
            Trace1(IF, "%d.%d.%d.%d",
                   PRINT_IPADDR((*ppibAddressInfo)[i].dwAddress));
        }
#endif
    }
    
    
    return dwResult;
}

DWORD
ReadAddressAndMaskValues(
    IN  HKEY        hkeyAdapterSection,
    IN  PSZ         pszRegAddressValue,
    IN  PSZ         pszRegMaskValue,
    OUT ICB_BINDING **ppibAddressInfo,
    OUT PDWORD      pdwNumAddresses
    )
{
    DWORD   dwResult, dwType;
    PBYTE   pbyAddresses,pbyMasks;
    DWORD   dwAddressSize, dwMaskSize;

    dwAddressSize = dwMaskSize  = 0;
    
    dwResult = RegQueryValueEx(hkeyAdapterSection,
                               pszRegAddressValue,
                               NULL,
                               &dwType,
                               NULL,
                               &dwAddressSize);

    if((dwAddressSize is 0) or (dwResult isnot NO_ERROR))
    {
        Trace3(ERR,
               "ReadAddressAndMaskValues: Registry reported size = %d with error %d for size of %s",
               dwAddressSize,
               dwResult,
               pszRegAddressValue);
        
        return ERROR_REGISTRY_CORRUPT;
    }
    
    //
    // We allocate size+4 so that even if we read out a REG_SZ, it looks
    // like a REG_MULTI_SZ to the parse routine because we guarantee atleast
    // 2 terminating NULLS
    // 

    pbyAddresses = HeapAlloc(IPRouterHeap,
                             HEAP_ZERO_MEMORY,
                             dwAddressSize + 4);
    
    if(pbyAddresses is NULL)
    {
        Trace2(ERR,
               "ReadAddressAndMaskValues: Error allocating %d bytes for %s",
               dwAddressSize + 4,
               pszRegAddressValue);

        return ERROR_NOT_ENOUGH_MEMORY;
    }
     
    dwResult = RegQueryValueEx(hkeyAdapterSection,
                               pszRegAddressValue,                               
                               NULL,
                               &dwType,
                               pbyAddresses,
                               &dwAddressSize);

    if(dwResult isnot NO_ERROR)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pbyAddresses);

        Trace2(ERR,
               "ReadAddressAndMaskValues: Error %d reading %s from registry",
               dwResult,
               pszRegAddressValue);
        
        
        return dwResult;
    }
    
    //
    // Now get the subnet mask for the net interface
    //
    
    dwResult = RegQueryValueEx(hkeyAdapterSection,
                               pszRegMaskValue,
                               NULL,
                               &dwType,
                               NULL,
                               &dwMaskSize);
    
    if((dwMaskSize is 0) or (dwResult isnot NO_ERROR))
    {
        HeapFree(IPRouterHeap,
                 0,
                 pbyAddresses);
        
        Trace3(ERR,
               "ReadAddressAndMaskValues: Registry reported size = %d with error %d for size of %s",
               dwMaskSize,
               dwResult,
               pszRegMaskValue);
        
        return ERROR_REGISTRY_CORRUPT;
    }
    
    pbyMasks = HeapAlloc(IPRouterHeap,
                         HEAP_ZERO_MEMORY,
                         dwMaskSize + 4);
    
    if(pbyMasks is NULL)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pbyAddresses);

        
        Trace2(ERR,
               "ReadAddressAndMaskValues: Error allocating %d bytes for %s",
               dwMaskSize + 4,
               pszRegMaskValue);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    dwResult = RegQueryValueEx(hkeyAdapterSection,
                               pszRegMaskValue,
                               NULL,
                               &dwType,
                               pbyMasks,
                               &dwMaskSize) ;
    
    if(dwResult isnot NO_ERROR)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pbyAddresses);
        
        HeapFree(IPRouterHeap,
                 0,
                 pbyMasks);

        
        Trace2(ERR,
               "ReadAddressAndMaskValues: Error %d reading %s from registry",
               dwResult,
               pszRegMaskValue);
        
        return dwResult;
    }

    dwResult = ParseAddressAndMask(pbyAddresses,
                                   dwAddressSize,
                                   pbyMasks,
                                   dwMaskSize,
                                   ppibAddressInfo,
                                   pdwNumAddresses);
    
    HeapFree(IPRouterHeap,
             0,
             pbyAddresses);
    
    HeapFree(IPRouterHeap,
             0,
             pbyMasks);
    
    return dwResult;
}

DWORD
ParseAddressAndMask(
    IN  PBYTE       pbyAddresses,
    IN  DWORD       dwAddressSize,
    IN  PBYTE       pbyMasks,
    IN  DWORD       dwMaskSize,
    OUT ICB_BINDING **ppibAddressInfo,
    OUT PDWORD      pdwNumAddresses
    )
{
    DWORD   dwAddrCount, dwMaskCount, dwTempLen, dwAddrIndex;
    DWORD   dwMask, dwAddr, i, j;
    PBYTE   pbyTempAddr, pbyTempMask;
    BOOL    bDuplicate;


    *pdwNumAddresses = 0;
    *ppibAddressInfo = NULL;
    
    //
    // If there are only two characters in the string or if the
    // the first two are NULL, we have no data. Due to tcp/ip config
    // we may be passed a REG_SZ instead of a REG_MULTI_SZ. The code works
    // around that by assuming that if a REG_SZ was read out then extra 
    // padding was added to the end so that we ALWAYS have 2 terminating NULLs
    //
    
    if((dwAddressSize < 2) or
       ((pbyAddresses[0] is '\0') and
        (pbyAddresses[1] is '\0')))
    {
        Trace0(IF,
               "ParseAddressAndMask: No addresses found");
        
        return ERROR_NO_DATA;
    }


    //
    // The mask should also have some data
    //

    
    if((dwMaskSize < 2) or
       ((pbyMasks[0] is '\0') and
        (pbyMasks[1] is '\0')))
    {
        Trace0(IF,
               "ParseAddressAndMask: No masks found");
        
        return ERROR_NO_DATA;
    }
    
        
    //
    // Count the number of addresses
    //
    
    dwAddrCount = 0;
    pbyTempAddr = pbyAddresses;
    dwTempLen   = dwAddressSize;
        
    while(dwTempLen)
    {
        if(*pbyTempAddr == '\0')
        {
            dwAddrCount++;
            
            if(*(pbyTempAddr+1) == '\0')
            {
                break;
            }
        }

        pbyTempAddr++ ;
        
        dwTempLen-- ;
    }

    
    if(dwAddrCount is 0)
    {
        Trace0(IF,
               "ParseAddressAndMask: No addresses found");
        
        return ERROR_NO_DATA;
    }

    //
    // Count the number of masks
    //
    
    dwMaskCount = 0;
    pbyTempMask = pbyMasks;
    dwTempLen   = dwMaskSize;
        
    while(dwTempLen)
    {
        if(*pbyTempMask is '\0')
        {
            dwMaskCount++;
            
            if(*(pbyTempMask+1) is '\0')
            {
                break;
            }
        }

        pbyTempMask++ ;
        
        dwTempLen-- ;
    }

    //
    // Make sure that the two are the same
    //

    if(dwAddrCount isnot dwMaskCount)
    {
        Trace0(IF,
               "ParseAddressAndMask: Address and mask count is not same");
        
        return ERROR_NO_DATA;
    }
            
    //
    // Allocate the memory required to store all the addresses
    //

    *ppibAddressInfo = HeapAlloc(IPRouterHeap,
                                 HEAP_ZERO_MEMORY,
                                 (sizeof(ICB_BINDING) * dwAddrCount));

    if(*ppibAddressInfo is NULL)
    {
        Trace1(ERR,
               "ParseAddressAndMask: Error allocating %d bytes for AddressInfo",
               sizeof(ICB_BINDING) * dwAddrCount);

        return ERROR_NOT_ENOUGH_MEMORY;
    }
     
    pbyTempAddr = pbyAddresses;
    pbyTempMask = pbyMasks;

    dwAddrIndex = 0;
 
    for (i = 0; i < dwAddrCount; i++)
    {
        dwAddr = inet_addr(pbyTempAddr);
        dwMask = inet_addr(pbyTempMask);

        pbyTempAddr = strchr(pbyTempAddr, '\0');
        pbyTempMask = strchr(pbyTempMask, '\0');

        pbyTempAddr++;
        pbyTempMask++;

        bDuplicate = FALSE;

        for(j = 0; j < dwAddrIndex; j++)
        {
            if((*ppibAddressInfo)[j].dwAddress is dwAddr)
            {

                Trace1(ERR,
                       "ParseAddressAndMask: Addr %x is duplicate",
                       dwAddr);

                bDuplicate = TRUE;
                
                break;
            }
        }
        
        if(bDuplicate or
           (dwAddr is INVALID_IP_ADDRESS) or
           (dwMask is 0x00000000))
        {
            continue;
        }

        (*ppibAddressInfo)[dwAddrIndex].dwAddress    = dwAddr;
        (*ppibAddressInfo)[dwAddrIndex].dwMask       = dwMask;

        dwAddrIndex++;
    }

    *pdwNumAddresses = dwAddrIndex; 
   
    
    //
    // Make sure that there is atleast one valid address
    //


    if(dwAddrIndex is 0)
    {
        Trace0(ERR,
               "ParseAddressAndMask: No valid addresses found");
        
        HeapFree(IPRouterHeap,
                 0,
                 *ppibAddressInfo);
        
        *ppibAddressInfo    = NULL;

        return ERROR_NO_DATA;
    }

    return NO_ERROR;
}

DWORD
SetInterfaceReceiveType(
    IN  DWORD   dwProtocolId,
    IN  DWORD   dwIfIndex,
    IN  DWORD   dwInterfaceReceiveType,
    IN  BOOL    bActivate
    )

{
    DWORD                       dwResult;
    IO_STATUS_BLOCK             ioStatus;
    IP_SET_IF_PROMISCUOUS_INFO  PromInfo;
    HANDLE                      hEvent;

    hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);

    if(hEvent is NULL)
    {
        dwResult = GetLastError();

        Trace1(ERR,
               "SetInterfaceReceiveType: Error %d creating event",
               dwResult);

        return dwResult;
    }

    if(dwInterfaceReceiveType is IR_PROMISCUOUS_MULTICAST)
    {
        PromInfo.Type  = PROMISCUOUS_MCAST;
    }
    else
    {
        if(dwInterfaceReceiveType is IR_PROMISCUOUS)
        {
            PromInfo.Type  = PROMISCUOUS_BCAST;
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    PromInfo.Index = dwIfIndex;
    PromInfo.Add   = bActivate?1:0;

    dwResult = NtDeviceIoControlFile(g_hIpDevice,
                                     hEvent,
                                     NULL,
                                     NULL,
                                     &ioStatus,
                                     IOCTL_IP_SET_IF_PROMISCUOUS,
                                     (PVOID)&PromInfo,
                                     sizeof(IP_SET_IF_PROMISCUOUS_INFO),
                                     NULL,
                                     0);

    if(dwResult is STATUS_PENDING)
    {
        Trace0(ERR,
               "SetInterfaceReceiveType: Pending from ioctl");

        dwResult = WaitForSingleObject(hEvent,
                                       INFINITE);

        if(dwResult isnot WAIT_OBJECT_0) // 0
        {
            Trace1(ERR,
                   "SetInterfaceReceiveType: Error %d from wait",
                   dwResult);

            dwResult = GetLastError();
        }
        else
        {
            dwResult = STATUS_SUCCESS;
        }
    }

    if(dwResult isnot STATUS_SUCCESS)
    {
        Trace4(ERR,
               "SetInterfaceReceiveType: NtStatus %x while %s i/f %x into %s mode",
               dwResult,
               (PromInfo.Add == 1) ? "activating" : "deactivating",
               dwIfIndex,
               (PromInfo.Type == PROMISCUOUS_MCAST) ? "prom mcast" : "prom all");

        return dwResult;
    }

    return NO_ERROR;
} 

DWORD
HandleMediaSenseEvent(
    IN  PICB    pIcb,
    IN  BOOL    bSensed
    )
    
/*++

Routine Description:

    Called when media sense status changes for a LAN interface

Locks:

    Called with the ICB list lock held as WRITER

Arguments:

    pIcb    ICB of the interface for which the event it
    bSensed TRUE is cable is present

Return Value:

    NO_ERROR

--*/

{
    DWORD   dwErr;

    return NO_ERROR;

    //
    // Not for NT 5.0
    //

    if(pIcb->ritType isnot ROUTER_IF_TYPE_DEDICATED)
    {
        IpRtAssert(FALSE);

        return ERROR_INVALID_PARAMETER;
    }

    if(bSensed)
    {
        //
        // Bring the interface up
        //

        dwErr = LanEtcInterfaceDownToUp(pIcb,
                                        FALSE);
    }
    else
    {
        dwErr = LanEtcInterfaceUpToDown(pIcb,
                                        FALSE);
    }

    if(dwErr isnot NO_ERROR)
    {
        Trace2(ERR,
               "HandleMediaSense: Err %d when changing status for %S",
               dwErr,
               pIcb->pwszName);
    }

    return dwErr;
}

DWORD
GetRouterId()
{
    PLIST_ENTRY pleNode;
    PICB        picb;
    ULONG       ulIdx;
    DWORD       dwRouterId      = -1; // lower is better
    DWORD       dwRouterTypePri = -1; // lower is better
    DWORD       dwTypePri;
    
    TraceEnter("GetRouterId");

    ENTER_READER(ICB_LIST);

    for (pleNode = ICBList.Flink;   // walk the ICBList
         pleNode isnot &ICBList;
         pleNode = pleNode->Flink)
    {
        picb = CONTAINING_RECORD (pleNode, ICB, leIfLink) ;

        // Get Type priority
        switch(picb->ritType) {
        case ROUTER_IF_TYPE_LOOPBACK : dwTypePri = 0;  break; // best
        case ROUTER_IF_TYPE_INTERNAL : dwTypePri = 1;  break;
#ifdef KSL_IPINIP
        case ROUTER_IF_TYPE_TUNNEL1  : dwTypePri = 2;  break; 
#endif //KSL_IPINIP
        case ROUTER_IF_TYPE_DEDICATED: dwTypePri = 2;  break; 
        default:                       dwTypePri = 10; break; // worst
        }

        // Walk addresses
        for (ulIdx=0; ulIdx<picb->dwNumAddresses; ulIdx++)
        {
            if (!IS_ROUTABLE(picb->pibBindings[ulIdx].dwAddress))
            {
                continue;
            }

            // update if better
            if (dwTypePri < dwRouterTypePri
             || (dwTypePri==dwRouterTypePri 
                  && picb->pibBindings[ulIdx].dwAddress<dwRouterId))
            {
                dwRouterTypePri = dwTypePri;
                dwRouterId      = picb->pibBindings[ulIdx].dwAddress;
            }
        }
    }

    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);

    TraceLeave("GetRouterId");

    return dwRouterId;
}

#if __PIX__
BOOL
IsRemoteAddressPrivate(
    PICB    pIcb
    )
/*++

Routine Description:

    Checks to see if the address of the remote end point of the DoD (VPN/PPP) 
    interface is private.

    This is done by querying the TCPIP stack for the forwarding table and 
    ensuring that a host route does not already exist for the remote end-point.
    
    This is at best a heuristic to solve the following problem:
    - Third party VPN/PPP servers e.g. Cisco PIX firewall return the public 
      address rather than the address of the PPP interface or the private 
      network address as the remote address of the PPP link.
      
    - Adding a host route to the public address of the VPN/PPP server over the 
      PPP interface causes the host route added by PPTP (for its control 
      traffic) to be overwritten.  This causes PPTP control packets
      to be routed over the PPP interface rather than the public interface.  
      This in turn causes the control traffic to loop in the TCPIP stack and
      never make it to the other end.
      
--*/
{
    DWORD dwErr, dwSize = 0, dwCount = 0;
    MIB_IPFORWARDROW mibRoute;

    TraceEnter("IsRemoteAddressPrivate");
    
    //
    // Query stack for route table
    //

    SecureZeroMemory(&mibRoute, sizeof(MIB_IPFORWARDROW));
    
    dwErr = GetBestRouteFromStack(
                pIcb->dwRemoteAddress,
                0,
                &mibRoute
                );
                
    if(dwErr isnot NO_ERROR)
    {
        Trace1(
            ERR, "IsRemoteAddressPrivate: error %d querying best route",
            dwErr
            );

        TraceLeave("IsRemoteAddressPrivate");

        return FALSE;
    }

    TraceRoute4(
        ROUTE, "%d.%d.%d.%d/%d.%d.%d.%d via %d.%d.%d.%d over %d",
        PRINT_IPADDR( mibRoute.dwForwardDest ),
        PRINT_IPADDR( mibRoute.dwForwardMask ),
        PRINT_IPADDR( mibRoute.dwForwardNextHop ),
        mibRoute.dwForwardIfIndex
        );

    //
    // Check if this is host route and that is dest is the remote address
    //

    if((mibRoute.dwForwardMask is ALL_ONES_MASK) and
       (mibRoute.dwForwardDest is pIcb->dwRemoteAddress))
    {
        //
        // A host route to the remote address of the PPP interface
        // is already present
        //

        Trace0(
            IF, "IsRemoteAddressPrivate: matching host route already "
            "present in the stack"
            );

        TraceLeave("IsRemoteAddressPrivate");
        
        return FALSE;
    }

    Trace0(
        IF, "IsRemoteAddressPrivate: no matching host route present "
        "in the stack"
        );

    TraceLeave("IsRemoteAddressPrivate");
    
    return TRUE;
}    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\init.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\rtrmgr\init.c

Abstract:
    IP Router Manager code

Revision History:

    Gurdeep Singh Pall          6/14/95  Created

--*/

#include "allinc.h"


DWORD
RtrMgrMIBEntryCreate(
    IN DWORD           dwRoutingPid,
    IN DWORD           dwEntrySize,
    IN LPVOID          lpEntry
    );


DWORD
RtrMgrMIBEntryDelete(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwEntrySize,
    IN      LPVOID          lpEntry
    );

DWORD
RtrMgrMIBEntryGet(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwInEntrySize,
    IN      LPVOID          lpInEntry,
    IN OUT  LPDWORD         lpOutEntrySize,
    OUT     LPVOID          lpOutEntry
    );

DWORD
RtrMgrMIBEntryGetFirst(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwInEntrySize,
    IN      LPVOID          lpInEntry,
    IN OUT  LPDWORD         lpOutEntrySize,
    OUT     LPVOID          lpOutEntry
    );

DWORD
RtrMgrMIBEntryGetNext(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwInEntrySize,
    IN      LPVOID          lpInEntry,
    IN OUT  LPDWORD         lpOutEntrySize,
    OUT     LPVOID          lpOutEntry
    );

DWORD
RtrMgrMIBEntrySet(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwEntrySize,
    IN      LPVOID          lpEntry
    );


DWORD
InitRouter(
    PRTR_INFO_BLOCK_HEADER pGlobalInfo
    )

/*++

Routine Description:

    Loads routing protocols, loads bootp agent, opens the approp. drivers,
    and starts the worker thread.

Arguments:

    GlobalInfo passed in by DIM

Return Value:

    NO_ERROR or some error code

--*/

{
    HANDLE          hThread;
    DWORD           dwResult, dwTid, i;
    PGLOBAL_INFO    pInfo;
    PRTR_TOC_ENTRY  pToc;
    IPSNMPInfo      ipsiInfo;

    RTM_ENTITY_INFO entityInfo;

    PIP_NAT_GLOBAL_INFO     pNatInfo;
    PMIB_IPFORWARDTABLE     pInitRouteTable;
    PROUTE_LIST_ENTRY       prl;
    MGM_CALLBACKS           mgmCallbacks;
    ROUTER_MANAGER_CONFIG   mgmConfig;

    TraceEnter("InitRouter");

    //
    // Initialize all the locks (MIB handlers and ICB_LIST/PROTOCOL_CB_LIST)
    // VERY IMPORTANT, since we break out of this and try and do a cleanup
    // which needs the lists and the locks, WE MUST initialize the lists
    // and the locks BEFORE the first abnormal exit from this function
    //

    for(i = 0; i < NUM_LOCKS; i++)
    {
        RtlInitializeResource(&g_LockTable[i]);
    }

    //
    // Init the list head for interfaces
    //

    InitializeListHead(&ICBList);

    //
    // Initialize ICB Hash lookup table and the Adapter to Interface Hash
    //

    for (i=0; i<ICB_HASH_TABLE_SIZE; i++)
    {
        InitializeListHead(&ICBHashLookup[i]);
        InitializeListHead(&ICBSeqNumLookup[i]);
    }

    InitHashTables();

    //
    // Initialize the list of NETMGMT routes to be retrieved from the stack
    //
    
    InitializeListHead( &g_leStackRoutesToRestore );

    //
    // Initialize Routing protocol List
    //

    InitializeListHead(&g_leProtoCbList);

    //
    // Initialize the Router Discovery Timer Queue
    //

    InitializeListHead(&g_leTimerQueueHead);


    pToc = GetPointerToTocEntry(IP_GLOBAL_INFO, pGlobalInfo);

    if(!pToc or (pToc->InfoSize is 0))
    {
        LogErr0(NO_GLOBAL_INFO,
                ERROR_NO_DATA);

        Trace0(ERR,
               "InitRouter: No Global Info - can not start router");

        TraceLeave("InitRouter");

        return ERROR_CAN_NOT_COMPLETE;
    }

    pInfo = (PGLOBAL_INFO)GetInfoFromTocEntry(pGlobalInfo,
                                              pToc);
    if(pInfo is NULL)
    {
        LogErr0(NO_GLOBAL_INFO,
                ERROR_NO_DATA);

        Trace0(ERR,
               "InitRouter: No Global Info - can not start router");

        TraceLeave("InitRouter");
        
        return ERROR_CAN_NOT_COMPLETE;
    }

#pragma warning(push)
#pragma warning(disable:4296)

    if((pInfo->dwLoggingLevel > IPRTR_LOGGING_INFO) or
       (pInfo->dwLoggingLevel < IPRTR_LOGGING_NONE))

#pragma warning(pop)

    {
        Trace1(ERR,
               "InitRouter: Global info has invalid logging level of %d",
               pInfo->dwLoggingLevel);

        g_dwLoggingLevel = IPRTR_LOGGING_INFO;
    }
    else
    {
        g_dwLoggingLevel = pInfo->dwLoggingLevel;
    }


    //
    // Allocate private heap
    //

    IPRouterHeap = HeapCreate(0, 5000, 0);

    if(IPRouterHeap is NULL)
    {
        dwResult = GetLastError() ;

        Trace1(ERR,
               "InitRouter: Error %d creating IPRouterHeap",
               dwResult) ;

        TraceLeave("InitRouter");

        return dwResult ;
    }


    //
    // Create the events needed to talk to the routing protocols,
    // DIM and WANARP
    //

    g_hRoutingProtocolEvent     = CreateEvent(NULL,FALSE,FALSE,NULL);
    g_hStopRouterEvent          = CreateEvent(NULL,FALSE,FALSE,NULL);
    g_hSetForwardingEvent       = CreateEvent(NULL,FALSE,FALSE,NULL);
    g_hForwardingChangeEvent    = CreateEvent(NULL,FALSE,FALSE,NULL);
    g_hDemandDialEvent          = CreateEvent(NULL,FALSE,FALSE,NULL);
#ifdef KSL_IPINIP
    g_hIpInIpEvent              = CreateEvent(NULL,FALSE,FALSE,NULL);
#endif //KSL_IPINIP
    g_hStackChangeEvent         = CreateEvent(NULL,FALSE,FALSE,NULL);
    g_hRtrDiscSocketEvent       = CreateEvent(NULL,FALSE,FALSE,NULL);
    g_hMHbeatSocketEvent        = CreateEvent(NULL,FALSE,FALSE,NULL);
    g_hMcMiscSocketEvent        = CreateEvent(NULL,FALSE,FALSE,NULL);
    g_hMzapSocketEvent          = CreateEvent(NULL,FALSE,FALSE,NULL);

    for(i = 0; i < NUM_MCAST_IRPS; i++)
    {
        g_hMcastEvents[i] = CreateEvent(NULL,FALSE,FALSE,NULL);
    }

    for(i = 0; i < NUM_ROUTE_CHANGE_IRPS; i++)
    {
        g_hRouteChangeEvents[i] = CreateEvent(NULL,FALSE,FALSE,NULL);
    }


    g_hRtrDiscTimer = CreateWaitableTimer(NULL,
                                          FALSE,
                                          NULL);

    g_hRasAdvTimer = CreateWaitableTimer(NULL,
                                         FALSE,
                                         NULL);

    g_hMzapTimer = CreateWaitableTimer(NULL,
                                       FALSE,
                                       NULL);

    if((g_hRoutingProtocolEvent is NULL) or
       (g_hStopRouterEvent is NULL) or
       (g_hSetForwardingEvent is NULL) or
       (g_hForwardingChangeEvent is NULL) or
       (g_hDemandDialEvent is NULL) or
#ifdef KSL_IPINIP
       (g_hIpInIpEvent is NULL) or
#endif //KSL_IPINIP       
       (g_hStackChangeEvent is NULL) or
       (g_hRtrDiscSocketEvent is NULL) or
       (g_hRtrDiscTimer is NULL) or
       (g_hRasAdvTimer is NULL) or
       (g_hMcMiscSocketEvent is NULL) or
       (g_hMzapSocketEvent is NULL) or
       (g_hMHbeatSocketEvent is NULL))
    {
        Trace0(ERR,
               "InitRouter: Couldnt create the needed events and timer");

        TraceLeave("InitRouter");

        return ERROR_CAN_NOT_COMPLETE;
    }

    for(i = 0; i < NUM_MCAST_IRPS; i++)
    {
        if(g_hMcastEvents[i] is NULL)
        {
            Trace0(ERR,
                   "InitRouter: Couldnt create the mcast events");

            TraceLeave("InitRouter");

            return ERROR_CAN_NOT_COMPLETE;
        }
    }


    for(i = 0; i < NUM_ROUTE_CHANGE_IRPS; i++)
    {
        if(g_hRouteChangeEvents[i] is NULL)
        {
            Trace0(ERR,
                   "InitRouter: Couldnt create the mcast events");

            TraceLeave("InitRouter");

            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    
    Trace0(GLOBAL,
           "InitRouter: Created necessary events and timer");

    dwResult = MprConfigServerConnect(NULL,
                                      &g_hMprConfig);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter:  Error %d calling MprConfigServerConnect",
               dwResult);

        return dwResult;
    }

    g_sinAllSystemsAddr.sin_family      = AF_INET;
    g_sinAllSystemsAddr.sin_addr.s_addr = ALL_SYSTEMS_MULTICAST_GROUP;
    g_sinAllSystemsAddr.sin_port        = 0;

    g_pIpHeader = (PIP_HEADER)g_pdwIpAndIcmpBuf;

    g_wsaIpRcvBuf.buf = (PBYTE)g_pIpHeader;
    g_wsaIpRcvBuf.len = ICMP_RCV_BUFFER_LEN * sizeof(DWORD);

    g_wsaMcRcvBuf.buf = g_byMcMiscBuffer;
    g_wsaMcRcvBuf.len = sizeof(g_byMcMiscBuffer);


    //
    // Get all the routes that are in the stack and store them away
    //

    pInitRouteTable = NULL;

    dwResult = AllocateAndGetIpForwardTableFromStack(&pInitRouteTable,
                                                     FALSE,
                                                     IPRouterHeap,
                                                     0);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: Couldnt get initial routes. Error %d",
               dwResult);
    }

    else
    {
        if(pInitRouteTable->dwNumEntries isnot 0)
        {
            TraceRoute1( ROUTE, "%d stack routes on startup\n", pInitRouteTable->dwNumEntries);
            
            for ( i = 0; i < pInitRouteTable-> dwNumEntries; i++ )
            {
                if (pInitRouteTable->table[i].dwForwardProto != 
                        MIB_IPPROTO_NETMGMT)
                {
                    continue;
                }

                TraceRoute3(
                    ROUTE, "NETMGMT route %d.%d.%d.%d/%d.%d.%d.%d, type 0x%x",
                    PRINT_IPADDR( pInitRouteTable-> table[i].dwForwardDest ),
                    PRINT_IPADDR( pInitRouteTable-> table[i].dwForwardMask ),
                    pInitRouteTable-> table[i].dwForwardType
                    );

                //
                // Allocate and store route in a linked list
                //

                prl = HeapAlloc(
                        IPRouterHeap, HEAP_ZERO_MEMORY, 
                        sizeof(ROUTE_LIST_ENTRY)
                        );

                if (prl is NULL)
                {
                    Trace2(
                        ERR, 
                        "InitRouter: error %d allocating %d bytes "
                        "for stack route entry",
                        ERROR_NOT_ENOUGH_MEMORY,
                        sizeof(ROUTE_LIST_ENTRY)
                        );

                    dwResult = ERROR_NOT_ENOUGH_MEMORY;

                    break;                        
                }

                InitializeListHead( &prl->leRouteList );

                prl->mibRoute = pInitRouteTable-> table[i];

                InsertTailList( 
                    &g_leStackRoutesToRestore, &prl->leRouteList 
                    );
            }

            if (dwResult isnot NO_ERROR)
            {
                while (!IsListEmpty(&g_leStackRoutesToRestore))
                {
                    prl = (PROUTE_LIST_ENTRY) RemoveHeadList(
                                &g_leStackRoutesToRestore
                                );

                    HeapFree(IPRouterHeap, 0, prl);
                }
            }
        }

        HeapFree(IPRouterHeap, 0, pInitRouteTable);
        pInitRouteTable = NULL;
    }



    //
    // The route table is created implicitly by RTM at the
    // time of the first registration call (see call below)
    //

    //
    // Setup common params for all registrations with RTMv2
    //

    entityInfo.RtmInstanceId = 0; // routerId;
    entityInfo.AddressFamily = AF_INET;
    entityInfo.EntityId.EntityInstanceId = 0;

    //
    // Register with RTM using the appropriate proto ids
    //

    //
    // This 1st registration is also used for performing
    // RTM operations common for all these registrations,
    // As an example it is used to get any changed dests.
    //

    entityInfo.EntityId.EntityProtocolId = PROTO_IP_LOCAL;

    dwResult = RtmRegisterEntity(&entityInfo,
                                 NULL,
                                 RtmEventCallback,
                                 FALSE,
                                 &g_rtmProfile,
                                 &g_hLocalRoute);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: RtmRegisterClient for local routes failed %d",
               dwResult) ;

        TraceLeave("InitRouter");

        return dwResult ;
    }

    // Also register for dest change notifications

    dwResult = RtmRegisterForChangeNotification(g_hLocalRoute,
                                                RTM_VIEW_MASK_UCAST,
                                                RTM_CHANGE_TYPE_FORWARDING,
                                                NULL,
                                                &g_hNotification);

    if (dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: RtmRegisterForChangeNotificaition failed %d",
               dwResult) ;

        TraceLeave("InitRouter");

        return dwResult ;
    }

    //
    // Register more times for each type of route
    //

    entityInfo.EntityId.EntityProtocolId = PROTO_IP_NT_AUTOSTATIC;

    dwResult = RtmRegisterEntity(&entityInfo,
                                 NULL,
                                 NULL,
                                 FALSE,
                                 &g_rtmProfile,
                                 &g_hAutoStaticRoute);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: RtmRegisterClient for AutoStatic routes failed %d",
               dwResult) ;

        TraceLeave("InitRouter");

        return dwResult ;
    }


    entityInfo.EntityId.EntityProtocolId = PROTO_IP_NT_STATIC;

    dwResult = RtmRegisterEntity(&entityInfo,
                                 NULL,
                                 NULL,
                                 FALSE,
                                 &g_rtmProfile,
                                 &g_hStaticRoute);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: RtmRegisterClient for Static routes failed %d",
               dwResult) ;

        TraceLeave("InitRouter");

        return dwResult ;
    }


    entityInfo.EntityId.EntityProtocolId = PROTO_IP_NT_STATIC_NON_DOD;

    dwResult = RtmRegisterEntity(&entityInfo,
                                 NULL,
                                 NULL,
                                 FALSE,
                                 &g_rtmProfile,
                                 &g_hNonDodRoute);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: RtmRegisterClient for DOD routes failed %d",
               dwResult) ;

        TraceLeave("InitRouter");

        return dwResult ;
    }


    entityInfo.EntityId.EntityProtocolId = PROTO_IP_NETMGMT;

    dwResult = RtmRegisterEntity(&entityInfo,
                                 NULL,
                                 RtmEventCallback,
                                 TRUE,
                                 &g_rtmProfile,
                                 &g_hNetMgmtRoute);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: RtmRegisterClient for NetMgmt routes failed %d",
               dwResult) ;

        TraceLeave("InitRouter");

        return dwResult ;
    }

    // Also register for marked dest change notifications

    dwResult = RtmRegisterForChangeNotification(g_hNetMgmtRoute,
                                                RTM_VIEW_MASK_UCAST,
                                                RTM_CHANGE_TYPE_ALL |
                                                RTM_NOTIFY_ONLY_MARKED_DESTS,
                                                NULL,
                                                &g_hDefaultRouteNotification);

    if (dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: RtmRegisterForChangeNotificaition failed %d",
               dwResult) ;

        TraceLeave("InitRouter");

        return dwResult ;
    }


    g_rgRtmHandles[0].dwProtoId     = PROTO_IP_LOCAL;
    g_rgRtmHandles[0].hRouteHandle  = g_hLocalRoute;
    g_rgRtmHandles[0].bStatic       = FALSE;

    g_rgRtmHandles[1].dwProtoId     = PROTO_IP_NT_AUTOSTATIC;
    g_rgRtmHandles[1].hRouteHandle  = g_hAutoStaticRoute;
    g_rgRtmHandles[1].bStatic       = TRUE;

    g_rgRtmHandles[2].dwProtoId     = PROTO_IP_NT_STATIC;
    g_rgRtmHandles[2].hRouteHandle  = g_hStaticRoute;
    g_rgRtmHandles[2].bStatic       = TRUE;

    g_rgRtmHandles[3].dwProtoId     = PROTO_IP_NT_STATIC_NON_DOD;
    g_rgRtmHandles[3].hRouteHandle  = g_hNonDodRoute;
    g_rgRtmHandles[3].bStatic       = TRUE;

    g_rgRtmHandles[4].dwProtoId     = PROTO_IP_NETMGMT;
    g_rgRtmHandles[4].hRouteHandle  = g_hNetMgmtRoute;
    g_rgRtmHandles[4].bStatic       = FALSE;


    //
    // Initialize MGM
    //

    mgmConfig.dwLogLevel                = g_dwLoggingLevel;

    mgmConfig.dwIfTableSize             = MGM_IF_TABLE_SIZE;
    mgmConfig.dwGrpTableSize            = MGM_GROUP_TABLE_SIZE;
    mgmConfig.dwSrcTableSize            = MGM_SOURCE_TABLE_SIZE;

    mgmConfig.pfnAddMfeCallback         = SetMfe;
    mgmConfig.pfnDeleteMfeCallback      = DeleteMfe;
    mgmConfig.pfnGetMfeCallback         = GetMfe;
    mgmConfig.pfnHasBoundaryCallback    = RmHasBoundary;

    dwResult = MgmInitialize(&mgmConfig,
                             &mgmCallbacks);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: Error %d initializing MGM\n",
               dwResult);

        TraceLeave("InitRouter");

        return dwResult;
    }

    //
    // Store callbacks into MGM
    //

    g_pfnMgmMfeDeleted      = mgmCallbacks.pfnMfeDeleteIndication;
    g_pfnMgmNewPacket       = mgmCallbacks.pfnNewPacketIndication;
    g_pfnMgmBlockGroups     = mgmCallbacks.pfnBlockGroups;
    g_pfnMgmUnBlockGroups   = mgmCallbacks.pfnUnBlockGroups;
    g_pfnMgmWrongIf         = mgmCallbacks.pfnWrongIfIndication;


    if(OpenIPDriver() isnot NO_ERROR)
    {
        Trace0(ERR,
               "InitRouter: Couldnt open IP driver");

        TraceLeave("InitRouter");

        return ERROR_OPEN_FAILED;
    }

    //
    // Do the multicast initialization
    //

    dwResult = OpenMulticastDriver();

    if(dwResult isnot NO_ERROR)
    {
        Trace0(ERR,
               "InitRoute: Could not open IP Multicast device");

        //
        // not an error, just continue;
        //
    }
    else
    {
        //
        // Find if we are in multicast mode
        //

        dwResult = StartMulticast();

        if(dwResult isnot NO_ERROR)
        {
            Trace0(ERR,
                   "InitRoute: Could not start multicast");
        }
    }

    if(!RouterRoleLanOnly)
    {
        if((dwResult = InitializeWanArp()) isnot NO_ERROR)
        {
            Trace0(ERR,
                   "InitRouter: Couldnt open WanArp driver");

            TraceLeave("InitRouter");

            return dwResult;
        }
    }

    SetPriorityInfo(pGlobalInfo);

    SetScopeInfo(pGlobalInfo);

    if((dwResult = InitializeMibHandler()) isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: InitializeMibHandler failed, returned %d",
               dwResult);

        TraceLeave("InitRouter");

        return dwResult;
    }

    //
    // Create Worker thread
    //

    hThread = CreateThread(NULL,
                           0,
                           (PVOID) WorkerThread,
                           pGlobalInfo,
                           0,
                           &dwTid) ;

    if(hThread is NULL)
    {
        dwResult = GetLastError () ;

        Trace1(ERR,
               "InitRouter: CreateThread failed %d",
               dwResult);

        TraceLeave("InitRouter");

        return dwResult ;
    }
    else
    {
        CloseHandle(hThread);
    }

#ifdef KSL_IPINIP
    dwResult = OpenIpIpKey();

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: Error %d opening ipinip key",
               dwResult);

        return ERROR_CAN_NOT_COMPLETE;
    }
#endif //KSL_IPINIP

    //
    // We load are routing protocols after all our own initialization,
    // since we dont know how they will interact with us
    //

    ENTER_WRITER(ICB_LIST);
    ENTER_WRITER(PROTOCOL_CB_LIST);

    LoadRoutingProtocols (pGlobalInfo);

    EXIT_LOCK(PROTOCOL_CB_LIST);
    EXIT_LOCK(ICB_LIST);

    TraceLeave("InitRouter");

    return NO_ERROR;
}


DWORD
LoadRoutingProtocols(
    PRTR_INFO_BLOCK_HEADER pGlobalInfo
    )

/*++

Routine Description:

    Loads and initializes all the routing protocols configured
    Called with ICBListLock and RoutingProcotoclCBListLock held

Arguments

    GlobalInfo passed in by DIM

Return Value:

    NO_ERROR or some error code

--*/

{
    DWORD               i, j, dwSize, dwNumProtoEntries, dwResult;
    PPROTO_CB  pNewProtocolCb;
    PWCHAR              pwszDllNames ; // array of dll names
    MPR_PROTOCOL_0      *pmpProtocolInfo;
    PVOID               pvInfo;
    BOOL                bFound;

    TraceEnter("LoadRoutingProtocols");

    dwResult = MprSetupProtocolEnum(PID_IP,
                                     (PBYTE *)(&pmpProtocolInfo),
                                     &dwNumProtoEntries);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "LoadRoutingProtocols: Error %d loading protocol info from registry",
               dwResult);

        TraceLeave("LoadRoutingProtocols");

        return dwResult;
    }

    for(i=0; i < pGlobalInfo->TocEntriesCount; i++)
    {
        ULONG   ulStructureVersion, ulStructureSize, ulStructureCount;
        DWORD   dwType;

        //
        // Read each TOC and see if it is PROTO_TYPE_UCAST/MCAST
        // If it does it is a loadable protocol and we get its info
        // from the registry
        //

        dwType = TYPE_FROM_PROTO_ID(pGlobalInfo->TocEntry[i].InfoType);
        if((dwType < PROTO_TYPE_MS1) and
           (pGlobalInfo->TocEntry[i].InfoSize > 0))
        {

            bFound = FALSE;

            for(j = 0; j < dwNumProtoEntries; j ++)
            {
                if(pmpProtocolInfo[j].dwProtocolId is pGlobalInfo->TocEntry[i].InfoType)
                {
                    //
                    // well great, we have found it
                    //

                    bFound = TRUE;

                    break;
                }
            }

            if(!bFound)
            {
                Trace1(ERR,
                       "LoadRoutingProtocols: Couldnt find information for protocol ID %d",
                       pGlobalInfo->TocEntry[i].InfoType);

                continue;
            }


            //
            // load library on the dll name provided
            //

            dwSize = (wcslen(pmpProtocolInfo[j].wszProtocol) +
                      wcslen(pmpProtocolInfo[j].wszDLLName) + 2) * sizeof(WCHAR) +
                      sizeof(PROTO_CB);

            pNewProtocolCb = HeapAlloc(IPRouterHeap,
                                       HEAP_ZERO_MEMORY,
                                       dwSize);

            if (pNewProtocolCb is NULL)
            {
                Trace2(ERR,
                       "LoadRoutingProtocols: Error allocating %d bytes for %S",
                       dwSize,
                       pmpProtocolInfo[j].wszProtocol);

                continue ;
            }

            pvInfo = GetInfoFromTocEntry(pGlobalInfo,
                                         &(pGlobalInfo->TocEntry[i]));

            //ulStructureVersion = pGlobalInfo->TocEntry[i].InfoVersion;
            ulStructureVersion = 0x500;
            ulStructureSize  = pGlobalInfo->TocEntry[i].InfoSize;
            ulStructureCount = pGlobalInfo->TocEntry[i].Count;

            dwResult = LoadProtocol(&(pmpProtocolInfo[j]),
                                     pNewProtocolCb,
                                     pvInfo,
                                     ulStructureVersion,
                                     ulStructureSize,
                                     ulStructureCount);

            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "LoadRoutingProtocols: %S failed to load: %d",
                       pmpProtocolInfo[j].wszProtocol,
                       dwResult);

                HeapFree (IPRouterHeap, 0, pNewProtocolCb) ;
            }
            else
            {
                pNewProtocolCb->posOpState = RTR_STATE_RUNNING ;

                //
                // Insert this routing protocol in the list of routing
                // protocols
                //

                InsertTailList(&g_leProtoCbList,
                               &pNewProtocolCb->leList) ;

                Trace1(GLOBAL,
                       "LoadRoutingProtocols: %S successfully initialized",
                       pmpProtocolInfo[j].wszProtocol) ;

                TotalRoutingProtocols++ ;
            }
        }
    }

    MprSetupProtocolFree(pmpProtocolInfo);

    TraceLeave("LoadRoutingProtocols");

    return NO_ERROR ;
}


DWORD
StartDriverAndOpenHandle(
    PCHAR   pszServiceName,
    PWCHAR  pwszDriverName,
    PHANDLE phDevice
    )

/*++

Routine Description:

    Creates a handle to the IP NAT service on the local machine
    Then tries to start the service. Loops till the service starts.
    Can potentially loop forever.

    Then creates a handle to the device.

Arguments

    None

Return Value:

    NO_ERROR or some error code

--*/

{
    NTSTATUS            status;
    UNICODE_STRING      nameString;
    IO_STATUS_BLOCK     ioStatusBlock;
    OBJECT_ATTRIBUTES   objectAttributes;
    SC_HANDLE           schSCManager, schService;
    DWORD               dwErr = NO_ERROR;
    SERVICE_STATUS      ssStatus;
    BOOL                bErr, bRet;
    ULONG               ulCount;

    TraceEnter("StartDriver");

    schSCManager = OpenSCManager(NULL,
                                 NULL,
                                 SC_MANAGER_ALL_ACCESS);


    if (schSCManager is NULL)
    {
        dwErr = GetLastError();

        Trace2(ERR,
               "StartDriver: Error %d opening svc controller for %s",
               dwErr,
               pszServiceName);

        TraceLeave("StartDriver");

        return ERROR_OPEN_FAILED;
    }

    schService = OpenService(schSCManager,
                             pszServiceName,
                             SERVICE_ALL_ACCESS);

    if(schService is NULL)
    {
        dwErr = GetLastError();

        Trace2(ERR,
               "StartDriver: Error %d opening %s",
               dwErr,
               pszServiceName);

        CloseServiceHandle(schSCManager);

        TraceLeave("StartDriver");

        return ERROR_OPEN_FAILED;
    }

    __try
    {
        bRet = FALSE;

        bErr = QueryServiceStatus(schService,
                                  &ssStatus);

        if(!bErr)
        {
            dwErr = GetLastError();

            Trace2(ERR,
                   "StartDriver: Error %d querying %s status to see if it is already running",
                   dwErr,
                   pszServiceName);

            __leave;
        }

        //
        // If the driver is running, we shut it down. This forces a
        // cleanup of all its internal data structures.
        //


        if(ssStatus.dwCurrentState isnot SERVICE_STOPPED)
        {
            if(!ControlService(schService,
                               SERVICE_CONTROL_STOP,
                               &ssStatus))
            {
                dwErr = GetLastError();

                Trace2(ERR,
                       "StartDriver: %s was running at init time. Attempts to stop it caused error %d",
                       pszServiceName,
                       dwErr);

            }
            else
            {
                Sleep(1000);

                //
                // Now loop for 10 seconds waiting for the service to stop
                //

                ulCount = 0;

                while(ulCount < 5)
                {

                    bErr = QueryServiceStatus(schService,
                                              &ssStatus);

                    if(!bErr)
                    {
                        dwErr = GetLastError();

                        break;
                    }
                    else
                    {
                        if (ssStatus.dwCurrentState is SERVICE_STOPPED)
                        {
                            break;
                        }
                        
                        ulCount++;

                        Sleep(2000);
                    }
                }

                if(ssStatus.dwCurrentState isnot SERVICE_STOPPED)
                {
                    if(ulCount is 5)
                    {
                        dwErr = ERROR_SERVICE_REQUEST_TIMEOUT;
                    }

                    Trace2(ERR,
                           "StartDriver: Error %d stopping %s which was running at init time",
                           dwErr,
                           pszServiceName);

                    __leave;
                }
            }
        }

        //
        // Query the service status one more time to see
        // if it is now stopped (because it was never running
        // or because it was started and we managed to stop
        // it successfully
        //

        bErr = QueryServiceStatus(schService,
                                  &ssStatus);

        if(!bErr)
        {
            dwErr = GetLastError();

            Trace2(ERR,
                   "StartDriver: Error %d querying %s status to see if it is stopped",
                   dwErr,
                   pszServiceName);

            __leave;
        }

        if(ssStatus.dwCurrentState is SERVICE_STOPPED)
        {
            //
            // Ok so at this time the service is stopped, lets start the
            // service
            //

            if(!StartService(schService, 0, NULL))
            {
                dwErr = GetLastError();

                Trace2(ERR,
                       "StartDriver: Error %d starting %s",
                       dwErr,
                       pszServiceName);

                __leave;
            }

            //
            // Sleep for 1 second to avoid loop
            //

            Sleep(1000);

            ulCount = 0;

            //
            // We will wait for 30 seconds for the driver to start
            //

            while(ulCount < 6)
            {
                bErr = QueryServiceStatus(schService,
                                          &ssStatus);

                if(!bErr)
                {
                    dwErr = GetLastError();

                    break;
                }
                else
                {
                    if (ssStatus.dwCurrentState is SERVICE_RUNNING)
                    {
                        break;
                    }
                    
                    ulCount++;

                    Sleep(5000);
                }
            }

            if(ssStatus.dwCurrentState isnot SERVICE_RUNNING)
            {
                if(ulCount is 6)
                {
                    dwErr = ERROR_SERVICE_REQUEST_TIMEOUT;
                }

                Trace2(ERR,
                       "StartDriver: Error %d starting %s",
                       dwErr,
                       pszServiceName);

                __leave;
            }
        }

        //
        // Now the service is definitely up and running
        //

        RtlInitUnicodeString(&nameString,
                             pwszDriverName);


        InitializeObjectAttributes(&objectAttributes,
                                   &nameString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        status = NtCreateFile(phDevice,
                              SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                              &objectAttributes,
                              &ioStatusBlock,
                              NULL,
                              FILE_ATTRIBUTE_NORMAL,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              FILE_OPEN_IF,
                              0,
                              NULL,
                              0);

        if(!NT_SUCCESS(status))
        {
            Trace2(ERR,
                   "StartDriver: NtStatus %x creating handle to %S",
                   status,
                   pwszDriverName);

            __leave;
        }

        bRet = TRUE;

    }
    __finally
    {
        CloseServiceHandle(schSCManager);
        CloseServiceHandle(schService);

        TraceLeave("StartDriver");

    }

    if(!bRet) {
        return ERROR_OPEN_FAILED;
    } else {
        return NO_ERROR;
    }
}



DWORD
OpenIPDriver(
    VOID
    )

/*++

Routine Description:

    Opens a handle to the IP Driver

Arguments

    None

Return Value:

    NO_ERROR or some error code

--*/

{
    NTSTATUS            status;
    UNICODE_STRING      nameString;
    IO_STATUS_BLOCK     ioStatusBlock;
    OBJECT_ATTRIBUTES   objectAttributes;
    DWORD               dwResult = NO_ERROR;


    TraceEnter("OpenIPDriver");

    do
    {
        RtlInitUnicodeString(&nameString, DD_IP_DEVICE_NAME);

        InitializeObjectAttributes(&objectAttributes, &nameString,
                                   OBJ_CASE_INSENSITIVE, NULL, NULL);

        status = NtCreateFile(&g_hIpDevice,
                              SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                              &objectAttributes,
                              &ioStatusBlock,
                              NULL,
                              FILE_ATTRIBUTE_NORMAL,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              FILE_OPEN_IF,
                              0,
                              NULL,
                              0);

        if(!NT_SUCCESS(status))
        {
            Trace1(ERR,
                   "OpenIPDriver: Couldnt create IP driver handle. NtStatus %x",
                   status);

            dwResult = ERROR_OPEN_FAILED;

            break;
        }


        //
        // Open change notification handle to TCPIP stack
        //

        ZeroMemory(&ioStatusBlock, sizeof(IO_STATUS_BLOCK));

#if 1        
        status = NtCreateFile(
                    &g_hIpRouteChangeDevice,
                    GENERIC_EXECUTE,
                    &objectAttributes,
                    &ioStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    0,
                    NULL,
                    0
                    );

#else
        g_hIpRouteChangeDevice = CreateFile(
                                    TEXT("\\\\.\\Ip"),
                                    GENERIC_EXECUTE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL | 
                                    FILE_ATTRIBUTE_OVERLAPPED,
                                    NULL
                                    );

        if (g_hIpRouteChangeDevice is NULL)
#endif

        if (!NT_SUCCESS(status))
        {
            Trace1(
                ERR,
                "OpenIPDriver: Couldnt create change notificatio handle."
                "NtStatus %x",
                status
                );

            dwResult = ERROR_OPEN_FAILED;

            CloseHandle( g_hIpDevice );
            g_hIpDevice = NULL;
        }

        g_IpNotifyData.Version = IPNotifySynchronization;
        g_IpNotifyData.Add = 0;
        
    } while( FALSE );
    
    TraceLeave("OpenIPDriver");

    return dwResult;
}



DWORD
OpenMulticastDriver(
    VOID
    )
{
    NTSTATUS            status;
    UNICODE_STRING      nameString;
    IO_STATUS_BLOCK     ioStatusBlock;
    OBJECT_ATTRIBUTES   objectAttributes;
    DWORD               i;

    TraceEnter("OpenMulticastDriver");


    RtlInitUnicodeString(&nameString,
                         DD_IPMCAST_DEVICE_NAME);

    InitializeObjectAttributes(&objectAttributes,
                               &nameString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&g_hMcastDevice,
                          SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                          &objectAttributes,
                          &ioStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN_IF,
                          0,
                          NULL,
                          0);

    if(status isnot STATUS_SUCCESS)
    {
        Trace2(MCAST,
               "OpenMulticastDriver: Device Name %S could not be opened -> error code %d\n",
               DD_IPMCAST_DEVICE_NAME,
               status);

        g_hMcastDevice = NULL;

        return ERROR_OPEN_FAILED;
    }

    TraceLeave("OpenMulticastDriver");

    return NO_ERROR;
}



DWORD
EnableNetbtBcastForwarding(
    DWORD   dwEnable
)


/*++

Routine description:

    Sets the NETBT proxy mode to enable NETBT broadcast forwarding.
    This enables RAS clients to resolve names (and consequently)
    access resources on the networks (LANs) connected to the RAS
    server without having WINS/DNS configured.

Arguements :


Return Value :

    NO_ERROR
--*/

{

    HKEY hkWanarpAdapter = NULL, hkNetbtParameters = NULL,
         hkNetbtInterface = NULL;
    DWORD dwSize = 0, dwResult, dwType = 0, dwMode = 0, dwFlags;
    PBYTE pbBuffer = NULL;
    PWCHAR pwcGuid;
    WCHAR wszNetbtInterface[256] = L"\0";
    
    
    TraceEnter("EnableNetbtBcastForwarding");

    do
    {
        //
        // Step I
        // Query appropriate WANARP regsitry keys to find GUID
        // corresponding to Internal (RAS server adapter)
        //

        dwResult = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Adapters\\NdisWanIP",
                        0,
                        KEY_READ,
                        &hkWanarpAdapter
                        );

        if (dwResult isnot NO_ERROR)
        {
            Trace1(
                ERR, 
                "EnableNetbtBcastForwarding : error %d opening"
                "NdisWanIP key\n",
                dwResult
                );

            break;
        }


        //
        // query size of buffer required.
        //
        
        dwResult = RegQueryValueExW(
                        hkWanarpAdapter,
                        L"IpConfig",
                        NULL,
                        &dwType,
                        (PBYTE)NULL,
                        &dwSize
                        );

        if (dwResult isnot NO_ERROR)
        {
            Trace1(
                ERR, 
                "EnableNetbtBcastForwarding : error %d querying"
                "IPConfig value\n",
                dwResult
                );

            break;
        }


        //
        // Allocate buffer for value
        //

        pbBuffer = (PBYTE) HeapAlloc(
                                GetProcessHeap(),
                                0,
                                dwSize
                                );

        if ( pbBuffer == NULL )
        {
            dwResult = GetLastError();
            
            Trace2(
                ERR,
                "EnableNetbtBcastForwarding : error %d allocating buffer of" 
                "size %d for IPConfig value",
                dwResult, dwSize
                );

            break;
        }
        

        //
        // query registry value of IPConfig
        //

        dwResult = RegQueryValueExW(
                        hkWanarpAdapter,
                        L"IpConfig",
                        NULL,
                        &dwType,
                        (PBYTE)pbBuffer,
                        &dwSize
                        );

        if ( (dwResult isnot NO_ERROR) || (dwType != REG_MULTI_SZ) )
        {
            Trace1(
                ERR, 
                "EnableNetbtBcastForwarding : error %d querying"
                "IPConfig value\n",
                dwResult
                );

            break;
        }


        //
        // Extract the GUID of the Internal (RAS Server) adapter
        //

        pwcGuid = wcschr( (PWCHAR)pbBuffer, '{' );

        Trace1(
            INIT, "Internal adapter GUID is %lS",
            pwcGuid
            );

            
        //
        // Step II
        //
        // Save the old setting for NETBT PROXY mode.  This will be restored
        // when the RRAS server is stopped. and set the new PROXY mode
        //

        //
        // open NETBT Key
        //
        
        dwResult = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        L"System\\CurrentControlSet\\Services\\Netbt\\Parameters",
                        0,
                        KEY_READ | KEY_WRITE,
                        &hkNetbtParameters
                        );


        if (dwResult isnot NO_ERROR)
        {
            Trace1(
                ERR, 
                "EnableNetbtBcastForwarding : error %d opening"
                "Netbt\\Parameters key\n",
                dwResult
                );

            break;
        }

        //
        // query EnableProxy mode
        //

        dwSize = sizeof( DWORD );
        dwMode = 0;
        dwResult = RegQueryValueExW(
                        hkNetbtParameters,
                        L"EnableProxy",
                        NULL,
                        &dwType,
                        (PBYTE)&dwMode,
                        &dwSize
                        );

        if (dwResult isnot NO_ERROR)
        {
            //
            // It is possible the key is not present esp. if this 
            // is the first time you are running RRAS or if the 
            // key has been manually deleted
            // In this case assume proxy is set to 0 (disabled)
            //

            g_dwOldNetbtProxyMode = 0;
        }

        else 
        {
            g_dwOldNetbtProxyMode = dwMode;

        }

        Trace1(
            INIT,
            "Netbt Proxy mode in registry is %d",
            dwMode
            );

        //
        // Set the NETBT proxy mode to enable/disable broadcast forwarding
        //

        //
        // if NETBT broadcast fwdg is disabled, make sure
        // the the EnableProxy setting matches that
        // 

        if ( dwEnable == 0 )
        {
            //
            // Netbt broadcast fwd'g is disabled
            //
            
            if ( dwMode == 2 )
            {
                //
                // But the registry setting does not reflect this
                //

                g_dwOldNetbtProxyMode = 0;

                dwMode = 0;
                
                Trace1(
                    INIT,
                    "Forcing Netbt Proxy mode to be %d",
                    g_dwOldNetbtProxyMode
                    );
            }
        }

        else
        {
            //
            // Note: Need a #define value for netbt proxy mode
            //
            
            dwMode = 2;
        }


        Trace2(
            INIT,
            "Old Netbt Proxy mode is %d, New Nebt Proxy Mode is %d",
            g_dwOldNetbtProxyMode, dwMode
            );
            
        dwResult = RegSetValueExW(
                        hkNetbtParameters,
                        L"EnableProxy",
                        0,
                        REG_DWORD,
                        (PBYTE) &dwMode,
                        dwSize
                        );

        if ( dwResult != NO_ERROR )
        {
            Trace1(
                ERR, 
                "EnableNetbtBcastForwarding : error %d setting"
                "EnableProxy value\n",
                dwResult
                );

            break;
        }

        
        //
        // Step III:
        //
        // Check for RASFlags under NETBT_TCPIP_{RAS_SERVER_GUID} key
        //

        //
        // Open interface key under NETBT
        //
        
        wcscpy(
            wszNetbtInterface,
            L"System\\CurrentControlSet\\Services\\Netbt\\Parameters\\Interfaces\\Tcpip_"
            );

        wcscat(
            wszNetbtInterface,
            pwcGuid
            );
            
        dwResult = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        wszNetbtInterface,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hkNetbtInterface
                        );

        if (dwResult isnot NO_ERROR)
        {
            Trace2(
                ERR, 
                "EnableNetbtBcastForwarding : error %d opening"
                "%ls key\n",
                dwResult, wszNetbtInterface
                );

            break;
        }

        //
        // query RASFlags value
        //
        // If present 
        //      leave as is.
        // else 
        //      create and set it to 0x00000001 to disable NETBT
        //      broadcasts on WAN.
        //

        dwFlags = 0;
        dwResult = RegQueryValueExW(
                        hkNetbtInterface,
                        L"RASFlags",
                        NULL,
                        &dwType,
                        (PBYTE)&dwFlags,
                        &dwSize
                        );

        if (dwResult isnot NO_ERROR)
        {
            //
            // It is possible the key is not present esp. if this 
            // is the first time you are running RRAS or if the 
            // key has been manually deleted
            // In this case set RASFlags to 1 (default behavior).
            //

            dwFlags = 1;

            dwResult = RegSetValueExW(
                            hkNetbtInterface,
                            L"RASFlags",
                            0,
                            REG_DWORD,
                            (PBYTE) &dwFlags,
                            sizeof( DWORD )
                            );
                            
            if ( dwResult != NO_ERROR )
            {
                Trace1(
                    ERR,
                    "error %d setting RASFlags",
                    dwResult
                    );
            }
        }
        
        else 
        {
            //
            // RASFlags value is already present. leave it as is.
            //

            Trace1(
                INIT,
                "RASFlags already present with value %d",
                dwFlags
                );
        }


        //
        // Close NETBT keys.  Doing so to avoid any contention issues
        // with the NETBT.SYS driver trying to read them in the following
        // function
        //

        RegCloseKey( hkNetbtParameters );

        hkNetbtParameters = NULL;

        RegCloseKey( hkNetbtInterface );

        hkNetbtInterface = NULL;

        dwResult = ForceNetbtRegistryRead();

    } while (FALSE);


    if ( hkWanarpAdapter )
    {
        RegCloseKey( hkWanarpAdapter );
    }
    
    if ( hkNetbtParameters )
    {
        RegCloseKey( hkNetbtParameters );
    }

    if ( hkNetbtInterface )
    {
        RegCloseKey( hkNetbtInterface );
    }

    if ( pbBuffer )
    {
        HeapFree( GetProcessHeap(), 0, pbBuffer );
    }

    TraceLeave("EnableNetbtBcastForwarding");

    return dwResult;
}


DWORD
RestoreNetbtBcastForwardingMode(
    VOID
)
/*++

Routine description:

    Return the NETBT proxy mode setting to its original setting

Arguements :


Return Value :


--*/
{
    DWORD dwResult, dwSize = 0;

    HKEY hkNetbtParameters = NULL;
    
    
    TraceEnter("RestoreNetbtBcastForwardingMode");

    do
    {
        //
        // open NETBT Key
        //
        
        dwResult = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        L"System\\CurrentControlSet\\Services\\Netbt\\Parameters",
                        0,
                        KEY_READ | KEY_WRITE,
                        &hkNetbtParameters
                        );


        if (dwResult isnot NO_ERROR)
        {
            Trace1(
                ERR, 
                "EnableNetbtBcastForwarding : error %d opening"
                "Netbt\\Parameters key\n",
                dwResult
                );

            break;
        }

        //
        // restore EnableProxy mode
        //

        dwSize = sizeof( DWORD );

        dwResult = RegSetValueExW(
                        hkNetbtParameters,
                        L"EnableProxy",
                        0,
                        REG_DWORD,
                        (PBYTE) &g_dwOldNetbtProxyMode,
                        dwSize
                        );

        if ( dwResult != NO_ERROR )
        {
            Trace1(
                ERR, 
                "EnableNetbtBcastForwarding : error %d setting"
                "EnableProxy value\n",
                dwResult
                );

            break;
        }


        dwResult = ForceNetbtRegistryRead();

    } while (FALSE);
    
    TraceLeave("RestoreNetbtBcastForwardingMode");

    return dwResult;
}


DWORD
ForceNetbtRegistryRead(
    VOID
)
/*++

Routine description:

    Issue IOCTL to NETBT to re-read its registry setting.

Arguements :


Return Value :


--*/
{
    DWORD               dwErr = NO_ERROR;
    NTSTATUS            status;
    UNICODE_STRING      nameString;
    IO_STATUS_BLOCK     ioStatusBlock;
    OBJECT_ATTRIBUTES   objectAttributes;
    HANDLE              hNetbtDevice = NULL;

    TraceEnter("ForceNetbtRegistryRead");

    do
    {
        //
        // Step I:
        //
        // Open NETBT driver
        //
        
        RtlInitUnicodeString(
            &nameString, 
            L"\\Device\\NetBt_Wins_Export"
            );

        InitializeObjectAttributes(
            &objectAttributes, 
            &nameString,
            OBJ_CASE_INSENSITIVE, 
            NULL, 
            NULL
            );

        status = NtCreateFile(
                    &hNetbtDevice,
                    SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                    &objectAttributes,
                    &ioStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    0,
                    NULL,
                    0
                    );

        if (!NT_SUCCESS(status))
        {
            Trace1(
                ERR,
                "ForceNetbtRegistryRead: Couldnt create NETBT driver handle. NtStatus %x",
                status
                );

            dwErr = ERROR_OPEN_FAILED;

            break;
        }


        //
        // Issue IOCTL to re-read registry
        //

        status = NtDeviceIoControlFile(
                    hNetbtDevice,
                    NULL,
                    NULL,
                    NULL,
                    &ioStatusBlock,
                    IOCTL_NETBT_REREAD_REGISTRY,
                    NULL,
                    0,
                    NULL,
                    0
                    );

        if (!NT_SUCCESS(status))
        {
            Trace1(
                ERR,
                "ForceNetbtRegistryRead: Failed IOCTL call to NETBT, status %x",
                status
                );

            dwErr = ERROR_UNKNOWN;

            break;
        }

    } while ( FALSE );


    //
    // Close NETBT driver
    //

    CloseHandle( hNetbtDevice );

    TraceLeave("ForceNetbtRegistryRead");

    return dwErr;
}


DWORD
InitializeMibHandler(
    VOID
    )

/*++

Routine Description:

    Initalizes the heaps and Locks needed by the MIB handling code

Arguments:

    None

Return Value:

    NO_ERROR or some error code

--*/

{
    DWORD i,dwResult, dwIpIfSize, dwMibSize;
    BOOL  fUpdate;

    TraceEnter("InitializeMibHandler");

    //
    // Assert the size of MIB to stack mappings for which direct copy is
    // being done
    //

    dwIpIfSize = IFE_FIXED_SIZE + MAX_IFDESCR_LEN;
    dwMibSize  = sizeof(MIB_IFROW) - FIELD_OFFSET(MIB_IFROW, dwIndex);

    IpRtAssert(dwIpIfSize is dwMibSize);
    IpRtAssert(sizeof(MIB_ICMP) is sizeof(ICMPSNMPInfo));
    IpRtAssert(sizeof(MIB_UDPSTATS) is sizeof(UDPStats));
    IpRtAssert(sizeof(MIB_UDPROW) is sizeof(UDPEntry));
    IpRtAssert(sizeof(MIB_TCPSTATS) is sizeof(TCPStats));
    IpRtAssert(sizeof(MIB_TCPROW) is sizeof(TCPConnTableEntry));
    IpRtAssert(sizeof(MIB_IPSTATS) is sizeof(IPSNMPInfo));
    IpRtAssert(sizeof(MIB_IPADDRROW) is sizeof(IPAddrEntry));
    IpRtAssert(sizeof(MIB_IPNETROW) is sizeof(IPNetToMediaEntry));

    g_dwStartTime = GetCurrentTime();

    __try
    {
        //
        // We dont initialize the locks since we do it in one shot at the
        // beginning of StartRouter
        //

        //
        // Now Create the heaps. Since only writers Alloc from the heap we
        // are already guaranteed serialization, so lets not ask for it again
        // Let all initial size be 1K, this doesnt really cost any thing
        // since the memory is not committed
        // We will just allocate a minimum size for the cache tables so
        // that the startup doesnt barf
        //

#define INIT_TABLE_SIZE 10

        g_hIfHeap = HeapCreate(HEAP_NO_SERIALIZE,1000,0);

        if(g_hIfHeap is NULL)
        {
            dwResult = GetLastError();

            Trace1(ERR,
                   "InitializeMibHandler: Couldnt allocate IF Heap. Error %d",
                   dwResult);

            __leave;
        }

        g_hUdpHeap = HeapCreate(HEAP_NO_SERIALIZE,1000,0);

        if(g_hUdpHeap is NULL)
        {
            dwResult = GetLastError();

            Trace1(ERR,
                   "InitializeMibHandler: Couldnt allocate UDP Heap. Error %d",
                   dwResult);

            __leave;
        }

        g_UdpInfo.pUdpTable = HeapAlloc(g_hUdpHeap,
                                        HEAP_NO_SERIALIZE,
                                        SIZEOF_UDPTABLE(INIT_TABLE_SIZE));

        if(g_UdpInfo.pUdpTable is NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;

            Trace0(ERR,
                   "InitializeMibHandler: Couldnt allocate UDP table");

            __leave;
        }

        g_UdpInfo.dwTotalEntries = INIT_TABLE_SIZE;

        g_hTcpHeap = HeapCreate(HEAP_NO_SERIALIZE,1000,0);

        if(g_hTcpHeap is NULL)
        {
            dwResult = GetLastError();

            Trace1(ERR,
                   "InitializeMibHandler: Couldnt allocate TCP Heap. Error %d",
                   dwResult);

            __leave;
        }

        g_TcpInfo.pTcpTable = HeapAlloc(g_hTcpHeap,
                                        HEAP_NO_SERIALIZE,
                                        SIZEOF_TCPTABLE(INIT_TABLE_SIZE));

        if(g_TcpInfo.pTcpTable is NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;

            Trace0(ERR,
                   "InitializeMibHandler: Couldnt allocate TCP table");

            __leave;
        }

        g_TcpInfo.dwTotalEntries = INIT_TABLE_SIZE;

        g_hIpAddrHeap = HeapCreate(HEAP_NO_SERIALIZE,1000,0);

        if(g_hIpAddrHeap is NULL)
        {
            dwResult = GetLastError();

            Trace1(ERR,
                   "InitializeMibHandler: Couldnt allocate IP Addr Heap. Error %d",
                   dwResult);

            __leave;
        }

        g_IpInfo.pAddrTable = HeapAlloc(g_hIpAddrHeap,
                                        HEAP_NO_SERIALIZE,
                                        SIZEOF_IPADDRTABLE(INIT_TABLE_SIZE));

        if(g_IpInfo.pAddrTable is NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;

            Trace0(ERR,
                   "InitializeMibHandler: Couldnt allocate IP Addr table.");

            __leave;
        }

        g_IpInfo.dwTotalAddrEntries = INIT_TABLE_SIZE;

        g_hIpForwardHeap = HeapCreate(HEAP_NO_SERIALIZE,1000,0);

        if(g_hIpForwardHeap is NULL)
        {
            dwResult = GetLastError();

            Trace1(ERR,
                   "InitializeMibHandler: Couldnt allocate IP Forward Heap. Error %d",
                   dwResult);

            __leave;
        }

        g_IpInfo.pForwardTable = HeapAlloc(g_hIpForwardHeap,
                                           HEAP_NO_SERIALIZE,
                                           SIZEOF_IPFORWARDTABLE(INIT_TABLE_SIZE));

        if(g_IpInfo.pForwardTable is NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;

            Trace0(ERR,
                   "InitializeMibHandler: Couldnt allocate IP Forward table");

            __leave;
        }

        g_IpInfo.dwTotalForwardEntries = INIT_TABLE_SIZE;

        g_hIpNetHeap = HeapCreate(HEAP_NO_SERIALIZE,1000,0);

        if(g_hIpNetHeap is NULL)
        {
            dwResult = GetLastError();

            Trace1(ERR,
                   "InitializeMibHandler: Couldnt allocate IP Net Heap. Error %d",
                   dwResult);

            __leave;
        }

        g_IpInfo.pNetTable = HeapAlloc(g_hIpNetHeap,
                                       HEAP_NO_SERIALIZE,
                                       SIZEOF_IPNETTABLE(INIT_TABLE_SIZE));


        if(g_IpInfo.pNetTable is NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;

            Trace0(ERR,
                   "InitializeMibHandler: Couldnt allocate IP Net table");

            __leave;
        }

        g_IpInfo.dwTotalNetEntries = INIT_TABLE_SIZE;

        //
        // Now set up the caches
        //

        for(i = 0; i < NUM_CACHE; i++)
        {
            g_LastUpdateTable[i] = 0;

            if(UpdateCache(i,&fUpdate) isnot NO_ERROR)
            {
                Trace1(ERR,
                       "InitializeMibHandler: Couldnt update %s Cache",
                       CacheToA(i));

                //__leave;
            }
        }

        dwResult = NO_ERROR;
    }
    __finally
    {
        TraceLeave("InitializeMibHandler");

    }

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\iprtrmgr.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\routing\ip\rtrmgr\iprtrmgr.c

Abstract:

    The interface to DIM/DDM

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/

#include "allinc.h"
#include "exdeclar.h"


BOOL
InitIPRtrMgrDLL(
    HANDLE  hInst,
    DWORD   dwCallReason,
    PVOID   pReserved
    )
{
    switch (dwCallReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            //
            // Init the state
            //

            InitializeCriticalSection(&RouterStateLock);
            InitializeCriticalSection(&g_csFwdState);

            RouterState.IRS_RefCount = 0;
            RouterState.IRS_State    = RTR_STATE_STOPPED;

            //
            // We are not interested in THREAD_XXX reasons
            //

            DisableThreadLibraryCalls(hInst);

            //
            // Setup our info routines
            //

            g_rgicInfoCb[0].pfnGetInterfaceInfo = NULL;
            g_rgicInfoCb[0].pfnSetInterfaceInfo = SetRouteInfo;
            g_rgicInfoCb[0].pfnBindInterface    = NULL;
            g_rgicInfoCb[0].pfnGetGlobalInfo    = NULL;
            g_rgicInfoCb[0].pszInfoName         = "Route";

            g_rgicInfoCb[1].pfnGetInterfaceInfo = NULL;
            g_rgicInfoCb[1].pfnSetInterfaceInfo = SetFilterInterfaceInfo;
            g_rgicInfoCb[1].pfnBindInterface    = BindFilterInterface;
            g_rgicInfoCb[1].pfnGetGlobalInfo    = NULL;
            g_rgicInfoCb[1].pszInfoName         = "Filter";

            g_rgicInfoCb[2].pfnGetInterfaceInfo = NULL;
            g_rgicInfoCb[2].pfnSetInterfaceInfo = SetDemandDialFilters;
            g_rgicInfoCb[2].pfnBindInterface    = NULL;
            g_rgicInfoCb[2].pfnGetGlobalInfo    = NULL;
            g_rgicInfoCb[2].pszInfoName         = "DemandFilter";

#ifdef KSL_IPINIP
            g_rgicInfoCb[3].pfnGetInterfaceInfo = NULL;
            g_rgicInfoCb[3].pfnSetInterfaceInfo = SetIpInIpInfo;
            g_rgicInfoCb[3].pfnBindInterface    = NULL;
            g_rgicInfoCb[3].pfnGetGlobalInfo    = NULL;
            g_rgicInfoCb[3].pszInfoName         = "IpIpInfo";

            g_rgicInfoCb[4].pfnGetInterfaceInfo = GetBoundaryInfo;
            g_rgicInfoCb[4].pfnSetInterfaceInfo = SetBoundaryInfo;
            g_rgicInfoCb[4].pfnBindInterface    = BindBoundaryInterface;
            g_rgicInfoCb[4].pfnGetGlobalInfo    = GetScopeInfo;
            g_rgicInfoCb[4].pszInfoName         = "MulticastBoundary";
            
            g_rgicInfoCb[5].pfnGetInterfaceInfo = GetMcastLimitInfo;
            g_rgicInfoCb[5].pfnSetInterfaceInfo = SetMcastLimitInfo;
            g_rgicInfoCb[5].pfnBindInterface    = NULL;
            g_rgicInfoCb[5].pfnGetGlobalInfo    = NULL;
            g_rgicInfoCb[5].pszInfoName         = "MulticastLimit";
#endif //KSL_IPINIP            

            g_rgicInfoCb[3].pfnGetInterfaceInfo = GetBoundaryInfo;
            g_rgicInfoCb[3].pfnSetInterfaceInfo = SetBoundaryInfo;
            g_rgicInfoCb[3].pfnBindInterface    = BindBoundaryInterface;
            g_rgicInfoCb[3].pfnGetGlobalInfo    = GetScopeInfo;
            g_rgicInfoCb[3].pszInfoName         = "MulticastBoundary";

            g_rgicInfoCb[4].pfnGetInterfaceInfo = GetMcastLimitInfo;
            g_rgicInfoCb[4].pfnSetInterfaceInfo = SetMcastLimitInfo;
            g_rgicInfoCb[4].pfnBindInterface    = NULL;
            g_rgicInfoCb[4].pfnGetGlobalInfo    = NULL;
            g_rgicInfoCb[4].pszInfoName         = "MulticastLimit";

            break ;
        }
        
        case DLL_PROCESS_DETACH:
        {
            DeleteCriticalSection(&RouterStateLock);
            DeleteCriticalSection(&g_csFwdState);
    
            break;
        }

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        {
            //
            // not of interest.
            //

            break;
        }
    }

    return TRUE;
}

const static WCHAR pszIpStackService[] = L"TcpIp";

DWORD 
VerifyOrStartIpStack(
    VOID
    ) 
/*++

Routine Description

    Verifies that the ip stack is started and attempts to start the stack
    if not.

Locks

    None - called at init time

Arguments

    None

Return Value

    NO_ERROR
    ERROR_CAN_NOT_COMPLETE

--*/
{
    SC_HANDLE hSC = NULL, hStack = NULL;
    SERVICE_STATUS Status;
    DWORD dwErr = NO_ERROR;

    TraceEnter("VerifyOrStartIpStack");

    __try 
    {

        //
        // Get a handle to the service controller
        //

        if ((hSC = OpenSCManager (NULL, NULL, GENERIC_READ | GENERIC_EXECUTE)) == NULL)
        {
            dwErr = GetLastError();
            __leave;
        }

        //
        // Get a handle to the ipx stack service
        //

        hStack = OpenServiceW (hSC,
                              pszIpStackService,
                              SERVICE_START | SERVICE_QUERY_STATUS);
        if (!hStack)
        {
            dwErr = GetLastError();
            __leave;
        }

        //
        // Find out if the service is running
        //

        if (QueryServiceStatus (hStack, &Status) == 0)
        {
            dwErr = GetLastError();
            __leave;
        }

        //
        // See if the service is running
        //

        if (Status.dwCurrentState != SERVICE_RUNNING) 
        {
            //
            // If it's stopped, start it
            //

            if (Status.dwCurrentState == SERVICE_STOPPED) 
            {
                if (StartService (hStack, 0, NULL) == 0)
                {
                    dwErr = GetLastError();
                    __leave;
                }

                //
                // Make sure that the service started.  StartService is not supposed
                // to return until the driver is started.
                //

                if (QueryServiceStatus (hStack, &Status) == 0)
                {
                    dwErr = GetLastError();
                    __leave;
                }

                if (Status.dwCurrentState != SERVICE_RUNNING)
                {
                    dwErr = ERROR_CAN_NOT_COMPLETE;
                    __leave;
                }
            }
            else
            {
                //
                // If it's not stopped, don't worry about it.
                //

                dwErr = NO_ERROR;
                __leave;
            }
        }
    }
    __finally 
    {
        if (hSC)
        {
            CloseServiceHandle (hSC);
        }

        if (hStack)
        {
            CloseServiceHandle (hStack);
        }
    }

    return dwErr;
}

DWORD
StartRouter(
    IN OUT  DIM_ROUTER_INTERFACE *pDimRouterIf,
    IN      BOOL                 bLanOnlyMode, 
    IN      PVOID                pvGlobalInfo
    )

/*++

Routine Description

    This function is called by DIM to at startup. WE initialize tracing
    and event logging.
    Call InitRouter() to do the main stuff and then pass pointers to 
    the rest of our functions back to DIM
    
Locks

    None - called at init time

Arguments

    pDimRouterIf    structure that holds all the function pointers
    bLanOnlyMode    True if not a WAN router
    pvGlobalInfo    Pointer to our global info

Return Value

    None    

--*/

{
    DWORD   dwResult, i;
    WORD    wVersion = MAKEWORD(2,0); //Winsock version 2.0 minimum
    WSADATA wsaData;

    OSVERSIONINFOEX VersionInfo;

    //
    // Initialize Trace and logging
    //
    
    TraceHandle     = TraceRegister("IPRouterManager");
    g_hLogHandle    = RouterLogRegister("IPRouterManager");

    TraceEnter("StartRouter") ;


    if(pvGlobalInfo is NULL)
    {
        //
        // Sometimes setup screws up
        //
        
        LogErr0(NO_GLOBAL_INFO,
                ERROR_NO_DATA);
        
        return ERROR_INVALID_PARAMETER;
    }

    //
    // We need to make sure that the stack is started before westart.
    //

    if ( VerifyOrStartIpStack() isnot NO_ERROR )
    {
        Trace0(ERR, "StartRouter: Unable to start ip stack." );

        return ERROR_SERVICE_DEPENDENCY_FAIL;
    }

    g_hOwnModule  = LoadLibraryEx("IPRTRMGR.DLL",
                                  NULL,
                                  0);

    if(g_hOwnModule is NULL)
    {
        dwResult = GetLastError();

        Trace1(ERR,
               "StartRouter: Unable to load itself. %d",
               dwResult);

        return dwResult;
    }


    RouterState.IRS_State = RTR_STATE_RUNNING ;

    g_bUninitServer = TRUE;

    g_dwNextICBSeqNumberCounter = INITIAL_SEQUENCE_NUMBER;

    if(WSAStartup(wVersion,&wsaData) isnot NO_ERROR)
    {
        Trace1(ERR,
               "StartRouter: WSAStartup failed. Error %d",
               WSAGetLastError());

        TraceDeregister(TraceHandle);

        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Read only variable, no locks protect this
    //

    RouterRoleLanOnly = bLanOnlyMode ;

    //
    // Do we have forwarding enabled?
    //

    EnterCriticalSection(&g_csFwdState);

    g_bEnableFwdRequest = TRUE;
    g_bFwdEnabled = FALSE;
    g_bSetRoutesToStack = TRUE;
    g_bEnableNetbtBcastFrowarding = FALSE;

    
    //
    // Are we running workstation?
    //

    ZeroMemory(&VersionInfo,
               sizeof(VersionInfo));

    VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);

    if(GetVersionEx((POSVERSIONINFO)&VersionInfo))
    {
        if(VersionInfo.wProductType is VER_NT_WORKSTATION)
        {
            g_bSetRoutesToStack = FALSE;
        }
    }
    else
    {
        Trace1(ERR,
               "StartRouter: GetVersionEx failed with %d\n",
               GetLastError());
    }

    Trace1(GLOBAL,
           "\n\nStartRouter: Machine will run as %s\n\n",
           g_bSetRoutesToStack?"router":"non-router");

    if(!RouterRoleLanOnly)
    {
        HKEY    hkIpcpParam;

        dwResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                 L"System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\Ip",
                                 0,
                                 KEY_READ | KEY_WRITE,
                                 &hkIpcpParam);


        if(dwResult is NO_ERROR)
        {
            DWORD   dwEnable, dwSize;

            dwSize = sizeof(dwEnable);

            dwResult = RegQueryValueExW(hkIpcpParam,
                                        L"AllowNetworkAccess",
                                        NULL,
                                        NULL,
                                        (PBYTE)&dwEnable,
                                        &dwSize);


            if(dwResult is NO_ERROR)
            {
                if(dwEnable is 0)
                {
                    g_bEnableFwdRequest = FALSE;
                }
            }


            //
            // NETBT broadcast forwarding was enabled as an option
            // to allow simple RAS server configurations to perform
            // name resolution in the absence of WINS/DNS server
            // configuration.
            // This in turn was necessiated by the removal of NBF from the
            // system (NT SERVER).  When NBF was present this functionality
            // was performed by the RAS Netbios gateway.
            //
            // NETBT broadcast forwarding is enabled only if
            //  1. Router is not in LanOnly Mode
            //  2. NETBT bcast fwd'g has been explicity turned on.
            //
            
            dwResult = RegQueryValueExW(hkIpcpParam,
                                        L"EnableNetbtBcastFwd",
                                        NULL,
                                        NULL,
                                        (PBYTE)&dwEnable,
                                        &dwSize);


            if(dwResult isnot NO_ERROR)
            {
                //
                // It is possible the value is not present
                // esp. if this is the first time RRAS is being
                // run or if the key was manually deleted
                //
                // Assume a default value of 1 (enabled) and set
                // the value in the registry
                //

                dwEnable = 1;

                dwResult = RegSetValueExW(
                                hkIpcpParam,
                                L"EnableNetbtBcastFwd",
                                0,
                                REG_DWORD,
                                (PBYTE) &dwEnable,
                                sizeof( DWORD )
                                );

                if(dwResult isnot NO_ERROR)
                {
                    Trace1(
                        ERR, 
                        "error %d setting EnableNetbtBcastFwd value",
                        dwResult
                        );
                }
            }

            Trace1(
                INIT, "Netbt Enable mode is %d", dwEnable
                );
                
            if(dwEnable isnot 0)
            {
                g_bEnableNetbtBcastFrowarding = TRUE;
            }
            
            EnableNetbtBcastForwarding(dwEnable);


            RegCloseKey(hkIpcpParam);
        }
    }

    LeaveCriticalSection(&g_csFwdState);

    //
    // Keep the entry points in a global structure. 
    // Saves the overhead of copying into a structure everytime a protocol
    // has to be loaded
    //
    
    g_sfnDimFunctions.DemandDialRequest = DemandDialRequest;
    g_sfnDimFunctions.SetInterfaceReceiveType = SetInterfaceReceiveType;
    g_sfnDimFunctions.ValidateRoute     = ValidateRouteForProtocolEx;
    g_sfnDimFunctions.MIBEntryGet       = RtrMgrMIBEntryGet;
    g_sfnDimFunctions.MIBEntryGetNext   = RtrMgrMIBEntryGetNext;
    g_sfnDimFunctions.MIBEntryGetFirst  = RtrMgrMIBEntryGetFirst;
    g_sfnDimFunctions.MIBEntrySet       = RtrMgrMIBEntrySet;
    g_sfnDimFunctions.MIBEntryCreate    = RtrMgrMIBEntryCreate;
    g_sfnDimFunctions.MIBEntryDelete    = RtrMgrMIBEntryDelete;
    g_sfnDimFunctions.GetRouterId       = GetRouterId;
    g_sfnDimFunctions.HasMulticastBoundary = RmHasBoundary;
    
    Trace1(GLOBAL,
           "StartRouter: LAN MODE = %d",
           RouterRoleLanOnly) ;
    
    //
    // Do all the necessary initializations for the router
    //
    
    if((dwResult = InitRouter(pvGlobalInfo)) isnot NO_ERROR) 
    {
        Trace1(ERR,
               "StartRouter: InitRouter failed %d", dwResult) ;
        
        RouterManagerCleanup();

        RouterState.IRS_State = RTR_STATE_STOPPED;

        return dwResult ;
    }
    
    //
    // fill in information required by DIM
    //
    
    pDimRouterIf->dwProtocolId = PID_IP;
    
    //
    // Set IP Router Manager entrypoints
    //
    
    pDimRouterIf->StopRouter            = StopRouter;
    pDimRouterIf->AddInterface          = AddInterface;
    pDimRouterIf->DeleteInterface       = DeleteInterface;
    pDimRouterIf->GetInterfaceInfo      = GetInterfaceInfo;
    pDimRouterIf->SetInterfaceInfo      = SetInterfaceInfo;
    pDimRouterIf->InterfaceNotReachable = InterfaceNotReachable;
    pDimRouterIf->InterfaceReachable    = InterfaceReachable;
    pDimRouterIf->InterfaceConnected    = InterfaceConnected;
    pDimRouterIf->UpdateRoutes          = UpdateRoutes;
    pDimRouterIf->GetUpdateRoutesResult = GetUpdateRoutesResult;
    pDimRouterIf->SetGlobalInfo         = SetGlobalInfo;
    pDimRouterIf->GetGlobalInfo         = GetGlobalInfo;
    pDimRouterIf->MIBEntryCreate        = RtrMgrMIBEntryCreate;
    pDimRouterIf->MIBEntryDelete        = RtrMgrMIBEntryDelete;
    pDimRouterIf->MIBEntryGet           = RtrMgrMIBEntryGet;
    pDimRouterIf->MIBEntryGetFirst      = RtrMgrMIBEntryGetFirst;
    pDimRouterIf->MIBEntryGetNext       = RtrMgrMIBEntryGetNext;
    pDimRouterIf->MIBEntrySet           = RtrMgrMIBEntrySet;
    pDimRouterIf->SetRasAdvEnable       = SetRasAdvEnable;
    pDimRouterIf->RouterBootComplete    = RouterBootComplete;


    //
    // Get DIM entrypoints
    //
    
    ConnectInterface        = pDimRouterIf->ConnectInterface ;
    DisconnectInterface     = pDimRouterIf->DisconnectInterface ;
    SaveInterfaceInfo       = pDimRouterIf->SaveInterfaceInfo ;
    RestoreInterfaceInfo    = pDimRouterIf->RestoreInterfaceInfo ;
    RouterStopped           = pDimRouterIf->RouterStopped ;
    SaveGlobalInfo          = pDimRouterIf->SaveGlobalInfo;
    EnableInterfaceWithDIM  = pDimRouterIf->InterfaceEnabled;

    LoadStringA(g_hOwnModule,
                LOOPBACK_STRID,
                g_rgcLoopbackString,
                sizeof(g_rgcLoopbackString));

    LoadStringA(g_hOwnModule,
                INTERNAL_STRID,
                g_rgcInternalString,
                sizeof(g_rgcInternalString));

    LoadStringA(g_hOwnModule,
                WAN_STRID,
                g_rgcWanString,
                sizeof(g_rgcWanString));

#ifdef KSL_IPINIP
    LoadStringA(g_hOwnModule,
                IPIP_STRID,
                g_rgcIpIpString,
                sizeof(g_rgcIpIpString));
#endif //KSL_IPINIP

    return NO_ERROR;
}

DWORD
RouterBootComplete( 
    VOID 
    )

/*++

Routine Description

    This function is called by DIM after all the interfaces in the registry
    have been loaded with the router manager.

Locks

    None - called at init time

Arguments

    None.

Return Value

    NO_ERROR

--*/
{
    DWORD   dwErr, dwSize, dwInfoSize, dwLastIndex;
    PVOID   pvBuffer;


    Trace0(ERR,
           "\n-----------------------------------------------------------\n\n");

    //
    // Call DIM to save the interface info
    //
  
    dwLastIndex = 0;
    dwInfoSize  = 0;
    pvBuffer    = NULL;
 
    ENTER_WRITER(ICB_LIST);

    // Tell all protocols that start is complete
    ENTER_READER(PROTOCOL_CB_LIST);
    {
        PLIST_ENTRY pleNode;
        PPROTO_CB   pProtocolCb;

        for(pleNode = g_leProtoCbList.Flink;
            pleNode != &g_leProtoCbList;
            pleNode = pleNode->Flink)
        {
            pProtocolCb = CONTAINING_RECORD(pleNode,
                                            PROTO_CB,
                                            leList) ;

            if (pProtocolCb->pfnStartComplete)
            {
                dwErr = (pProtocolCb->pfnStartComplete)();
            }
        }
    }
    EXIT_LOCK(PROTOCOL_CB_LIST);

    if(IsListEmpty(&ICBList))
    {
        EXIT_LOCK(ICB_LIST);

        return NO_ERROR;
    }

#if 0
    while(TRUE)
    {
        PICB        pIcb;
        PLIST_ENTRY pleNode;
        HANDLE  hDimHandle;

        //
        // Walk the list finding the first ICB that has an index larger than
        // the last index we processed
        //

        pIcb = NULL;

        for(pleNode  = ICBList.Flink;
            pleNode != &ICBList;
            pleNode  = pleNode->Flink)
        {
            PICB    pTempIcb;

            pTempIcb = CONTAINING_RECORD(pleNode,
                                         ICB,
                                         leIfLink);

            if((pTempIcb->ritType is ROUTER_IF_TYPE_CLIENT)  or
               (pTempIcb->ritType is ROUTER_IF_TYPE_DIALOUT) or
               (pTempIcb->dwAdminState isnot IF_ADMIN_STATUS_UP))
            {
                continue;
            }

            if(pTempIcb->dwIfIndex > dwLastIndex)
            {
                //
                // Found the next ICB to save
                //

                pIcb = pTempIcb;

                break;
            }
        }

        //
        // If none found, we are done
        //

        if(pIcb is NULL)
        {
            break;
        }

        dwLastIndex = pIcb->dwIfIndex;
        hDimHandle  = pIcb->hDIMHandle;

        //
        // Get the info for this ICB
        //

        dwSize = GetSizeOfInterfaceConfig(pIcb);

        //
        // If this will fit in the current buffer, use it
        //

        if(dwSize > dwInfoSize)
        {
            //
            // otherwise, allocate a new one
            //

            dwInfoSize = dwSize * 2;

            if(pvBuffer)
            {
                //
                // Free the old buffer
                //

                HeapFree(IPRouterHeap,
                         0,
                         pvBuffer);

                pvBuffer = NULL;
            }

            pvBuffer  = HeapAlloc(IPRouterHeap,
                                  HEAP_ZERO_MEMORY,
                                  dwInfoSize);

            if(pvBuffer is NULL)
            {
                dwInfoSize = 0;

                //
                // Go to the while(TRUE)
                //

                continue;
            }
        }

        dwErr = GetInterfaceConfiguration(pIcb,
                                          pvBuffer,
                                          dwInfoSize);

        
        if(dwErr is NO_ERROR)
        {
            //
            // Need to leave the lock for this
            //

            EXIT_LOCK(ICB_LIST);

            SaveInterfaceInfo(hDimHandle,
                              PID_IP,
                              pvBuffer,
                              dwSize);

            //
            // Reacquire it once we are done
            //

            ENTER_WRITER(ICB_LIST);
        }
        else
        {
            Trace1(ERR,
                   "RouterBootComplete: Error getting info for %S\n",
                   pIcb->pwszName);
        }
    }

#endif

    EXIT_LOCK(ICB_LIST);

    //
    // Now go in and start forwarding if we are not in lanonly mode
    // and IPCP is so configured
    //

    EnterCriticalSection(&g_csFwdState);

    Trace1(GLOBAL,
           "RouterBootComplete: Signalling worker to %s forwarding",
           g_bEnableFwdRequest ? "enable" : "disable");

    SetEvent(g_hSetForwardingEvent);

    LeaveCriticalSection(&g_csFwdState);

    return NO_ERROR;
}

DWORD
AddInterface(
    IN      PWSTR                   pwsInterfaceName,
    IN      PVOID                   pInterfaceInfo,
    IN      ROUTER_INTERFACE_TYPE   InterfaceType,
    IN      HANDLE                  hDIMInterface,
    IN OUT  HANDLE                  *phInterface
    )

/*++

Routine Description

    Called by DIM to add an interface. This could be one of our configured
    interfaces or a client dialling in

Locks

    Takes the ICB_LIST lock as WRITER

Arguments

    pwsInterfaceName
    pInterfaceInfo
    InterfaceType
    hDIMInterface
    phInterface

Return Value

    NO_ERROR
    ERROR_INVALID_PARAMETER

--*/

{
    PICB                    pNewInterfaceCb;
    DWORD                   dwResult, dwAdminState;
    PRTR_TOC_ENTRY          pTocEntry;
    PRTR_INFO_BLOCK_HEADER  pInfoHdr;
    PINTERFACE_STATUS_INFO  pInfo;
    BOOL                    bEnable;


    EnterRouterApi();
   
    TraceEnter("AddInterface");

    Trace1(IF,
           "AddInterface: Adding %S",
           pwsInterfaceName);
   

    pInfoHdr = (PRTR_INFO_BLOCK_HEADER)pInterfaceInfo;

#ifdef KSL_IPINIP
#if !defined( __IPINIP )

    //
    // In preparation for IPinIP interface removal
    //

    if(InterfaceType is ROUTER_IF_TYPE_TUNNEL1)
    {
        Trace1(ERR,
               "AddInterface: Interface type is TUNNEL (%d), which is no longer"
               "supported",
               InterfaceType);
        
        LogErr0(IF_TYPE_NOT_SUPPORTED, ERROR_INVALID_PARAMETER);
        
        TraceLeave("AddInterface");
        
        ExitRouterApi();

        return ERROR_INVALID_PARAMETER;
    }

#endif
#endif //KSL_IPINIP
    
    if(RouterRoleLanOnly and 
       (InterfaceType isnot ROUTER_IF_TYPE_DEDICATED) and
#ifdef KSL_IPINIP
       (InterfaceType isnot ROUTER_IF_TYPE_TUNNEL1) and
#endif //KSL_IPINIP
       (InterfaceType isnot ROUTER_IF_TYPE_LOOPBACK))
    {
        //
        // If we are in LAN only mode, we should not see CLIENT, INTERNAL
        // HOME_ROUTER or FULL_ROUTER
        //

        Trace1(ERR,
               "AddInterface: Interface is %d, but Router is in LanOnly Mode",
               InterfaceType);
        
        TraceLeave("AddInterface");
        
        ExitRouterApi();

        return ERROR_INVALID_PARAMETER;
    }
    
    ENTER_WRITER(ICB_LIST);

    EXIT_LOCK(ICB_LIST);

    //
    // Figure out the admin state (if any)
    // If there is no status info, we assume state to be UP
    //
    
    dwAdminState = IF_ADMIN_STATUS_UP;
    
    pTocEntry = GetPointerToTocEntry(IP_INTERFACE_STATUS_INFO,
                                     pInfoHdr);

    if(pTocEntry and (pTocEntry->InfoSize > 0) and (pTocEntry->Count > 0))
    {
        pInfo = (PINTERFACE_STATUS_INFO)GetInfoFromTocEntry(pInfoHdr,
                                                            pTocEntry);

        //
        // Set it only if it is a valid value. Ignore others
        //
        
        if((pInfo isnot NULL) and
           ((pInfo->dwAdminStatus is IF_ADMIN_STATUS_UP) or
            (pInfo->dwAdminStatus is IF_ADMIN_STATUS_DOWN)))
        {
            dwAdminState = pInfo->dwAdminStatus;
        }
    }

    //
    // Create an ICB
    //

    pNewInterfaceCb = CreateIcb(pwsInterfaceName,
                                hDIMInterface,
                                InterfaceType,
                                dwAdminState,
                                0);

    if(pNewInterfaceCb is NULL)
    {
        ExitRouterApi();
        
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    //
    // HEAP_ZERO_MEMORY so we dont need to set any of the rtrdisc fields to 0
    //
 
    InitializeRouterDiscoveryInfo(pNewInterfaceCb,
                                  pInfoHdr);
    
    
    // *** Exclusion Begin ***
    ENTER_WRITER(ICB_LIST);

    //
    // Insert pNewInterfaceCb in interface list and hash table
    // This increments the interface count and sets the seq number
    //
    
    InsertInterfaceInLists(pNewInterfaceCb);

    Trace2(IF, "ICB number for %S is %d\n\n",
           pwsInterfaceName, pNewInterfaceCb->dwSeqNumber);

    //
    // The interface have been added to wanarp, so now add the demand dial
    // filters
    //
    
    if((pNewInterfaceCb->ritType is ROUTER_IF_TYPE_FULL_ROUTER) or
       (pNewInterfaceCb->ritType is ROUTER_IF_TYPE_HOME_ROUTER))
    {
        dwResult = SetDemandDialFilters(pNewInterfaceCb,
                                        pInfoHdr);
            
        if(dwResult isnot NO_ERROR)
        {
            CHAR   Name[MAX_INTERFACE_NAME_LEN + 1];
            PCHAR  pszName;

            pszName = Name;

            WideCharToMultiByte(CP_ACP,
                                0,
                                pwsInterfaceName,
                                -1,
                                pszName,
                                MAX_INTERFACE_NAME_LEN,
                                NULL,
                                NULL);

            LogErr1(CANT_ADD_DD_FILTERS,
                    pszName,
                    dwResult);
        }
    }

    //
    // If this is the loopback interface, do that extra something to
    // initialize it
    //

    if(pNewInterfaceCb->ritType is ROUTER_IF_TYPE_LOOPBACK)
    {
        InitializeLoopbackInterface(pNewInterfaceCb);
    }

#ifdef KSL_IPINIP
    //
    // If this is an IP in IP tunnel, add the info if present
    //

    if(pNewInterfaceCb->ritType is ROUTER_IF_TYPE_TUNNEL1)
    {
        dwResult = SetIpInIpInfo(pNewInterfaceCb,
                                 pInfoHdr);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "AddInterface: Error %d adding %S to ipinip",
                   dwResult,
                   pwsInterfaceName);
        }
    }
#endif //KSL_IPINIP

    // 
    // Add multicast scope boundary info if present
    //
    
    dwResult = SetMcastLimitInfo(pNewInterfaceCb, 
                                 pInfoHdr);

    dwResult = SetBoundaryInfo(pNewInterfaceCb, 
                               pInfoHdr);
    if(dwResult isnot NO_ERROR)
    {
         Trace2(ERR,
                "AddInterface: Error %d adding boundary info for %S",
                dwResult,
                pwsInterfaceName);
    }
    
    //
    // Add Interfaces with the approp. routing protocols
    // FULL_ROUTER and HOME_ROUTER -> demand dial
    // DEDICATED, INTERNAL and CLIENT -> permanent
    //
    
    AddInterfaceToAllProtocols(pNewInterfaceCb,
                               pInfoHdr);

    //
    // Add filters and NAT info. We dont add the contexts to IP stack
    // over here, because that will happen when we bring the interface up
    //

    if((pNewInterfaceCb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
       (pNewInterfaceCb->ritType isnot ROUTER_IF_TYPE_LOOPBACK))
    {
        dwResult = SetFilterInterfaceInfo(pNewInterfaceCb,
                                          pInfoHdr);
        
        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "AddInterface: Couldnt set filters for %S",
                   pNewInterfaceCb->pwszName);
        }
    }


    if(pNewInterfaceCb->dwAdminState is IF_ADMIN_STATUS_UP)
    {   
        //
        // If the admin wants the interface up, well good for hir
        //

        switch(pNewInterfaceCb->ritType)
        {
            case ROUTER_IF_TYPE_HOME_ROUTER:
            case ROUTER_IF_TYPE_FULL_ROUTER:
            {
                dwResult = WanInterfaceDownToInactive(pNewInterfaceCb);

                if(dwResult isnot NO_ERROR)
                {
                    Trace2(ERR,
                           "AddInterface: Error %d down->inactive for %S",
                           dwResult,
                           pNewInterfaceCb->pwszName);
                }

                break;
            }
            
            case ROUTER_IF_TYPE_DEDICATED:
#ifdef KSL_IPINIP
            case ROUTER_IF_TYPE_TUNNEL1:
#endif //KSL_IPINIP
            {
#ifdef KSL_IPINIP
                if((pNewInterfaceCb->ritType is ROUTER_IF_TYPE_TUNNEL1) and
                   (pNewInterfaceCb->pIpIpInfo->dwLocalAddress is 0))
                {
                    //
                    // Means we added the interface, but dont have info to
                    // add it to IP in IP
                    //

                    break;
                }
#endif //KSL_IPINIP

                dwResult = LanEtcInterfaceDownToUp(pNewInterfaceCb,
                                                   TRUE);
                
                if(dwResult isnot NO_ERROR)
                {
                    Trace2(ERR,
                           "AddInterface: Error %d down->up for %S",
                           dwResult,
                           pNewInterfaceCb->pwszName);
                }

                break;
            }
        }
    }
    else
    {
        //
        // The problem with LAN and IP in IP interfaces is that the stack 
        // brings them up even before we start. So if the user wants the 
        // interface DOWN to begin with, we need to tell the stack to bring 
        // the i/f down
        //

        switch(pNewInterfaceCb->ritType)
        {
            case ROUTER_IF_TYPE_DEDICATED:
#ifdef KSL_IPINIP
            case ROUTER_IF_TYPE_TUNNEL1:
#endif //KSL_IPINIP
            {
                dwResult = LanEtcInterfaceInitToDown(pNewInterfaceCb);

                if(dwResult isnot NO_ERROR)
                {
                    Trace2(ERR,
                           "AddInterface: Interface %S could not be set to DOWN in the stack. Results are undefined. Error %d",
                           pNewInterfaceCb->pwszName,
                           dwResult);
                }

                break;
            }
        }
    }


    //
    // Add Static Routes
    //

    if(pNewInterfaceCb->dwAdminState is IF_ADMIN_STATUS_UP)
    {
        //
        // Only add routes if the i/f is up
        //

        //
        // Note that since init static routes is not being called for some 
        // interfaces the stack routes will not be picked up. But that 
        // may be OK since bringing the i/f down will delete the routes anyway
        //
       
        //
        // Can only be called when the pIcb has the correct
        // dwOperational State
        //
 
        InitializeStaticRoutes(pNewInterfaceCb,
                               pInfoHdr);
    }
    
    
    //
    // The handle we return to DIM is a pointer to our ICB
    //

    *phInterface = ULongToHandle(pNewInterfaceCb->dwSeqNumber);

    //
    // Check if we want to enable with DIM. Do this check while we still have
    // the LOCK
    //

    bEnable = (pNewInterfaceCb->dwAdminState is IF_ADMIN_STATUS_UP);
    
    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);

    //
    // We can not call upwards from a component while holding
    // a lock, so we first exit the lock and then call
    // enabled
    //

    if(bEnable)
    {
        EnableInterfaceWithAllProtocols(pNewInterfaceCb);

        EnableInterfaceWithDIM(hDIMInterface,
                               PID_IP,
                               TRUE);
    }

    
    Trace4(IF,
           "AddInterface: Added %S: Type- %d, Index- %d, ICB 0x%x",
           pwsInterfaceName, 
           InterfaceType, 
           pNewInterfaceCb->dwIfIndex,
           pNewInterfaceCb);

    
    TraceLeave("AddInterface");
    
    ExitRouterApi();

    return NO_ERROR;
}


DWORD
DeleteInterface(
    IN HANDLE hInterface
    )
    
/*++

Routine Description

    Called by DIM to delete an interface (or when a CLIENT disconnects)
    The main work is done by DeleteSingleInterface()
    
Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    PICB        pIcb;

    EnterRouterApi();

    TraceEnter("DeleteInterface");
    
    // *** Exclusion Begin ***
    ENTER_WRITER(ICB_LIST);

    pIcb = InterfaceLookupByICBSeqNumber(HandleToULong(hInterface));

    IpRtAssert(pIcb);

    if (pIcb isnot NULL)
    {
        Trace1(IF,
               "DeleteInterface: Deleting %S,",
               pIcb->pwszName);

        RemoveInterfaceFromLists(pIcb);

        DeleteSingleInterface(pIcb);

        if(pIcb is g_pInternalInterfaceCb)
        {
            g_pInternalInterfaceCb = NULL;
        }

        //
        // Free the memory
        //
        
        HeapFree(IPRouterHeap,
                 0,
                 pIcb);
    }
    else
    {
        Trace1(
            ANY, 
            "DeleteInterface: No interface for ICB number %d",
            HandleToULong(hInterface)
            );
    }
    
    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);

    TraceLeave("DeleteInterface");
    
    ExitRouterApi();

    return NO_ERROR;
}


DWORD
StopRouter(
    VOID
    )

/*++

Routine Description

    Called by DIM to shut us down. We set our state to STOPPING (which stops
    other APIs from being serviced) and set the event to let the worker
    thread clean up

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    TraceEnter("Stop Router") ;

    EnterCriticalSection(&RouterStateLock);

    RouterState.IRS_State   = RTR_STATE_STOPPING;

    LeaveCriticalSection(&RouterStateLock);

    //
    // Try and delete as many interfaces as you can. The ones that are
    // connected will be handled in worker thread
    //
    
    DeleteAllInterfaces();

    SetEvent(g_hStopRouterEvent) ; 

    TraceLeave("Stop Router");

    return PENDING;
}


DWORD
GetInterfaceInfo(
    IN     HANDLE   hInterface,
    OUT    PVOID    pvInterfaceInfo,
    IN OUT PDWORD   pdwInterfaceInfoSize
    )

/*++

Routine Description

    Called by DIM to get interface info. 

Locks

    Acquires the ICB_LIST lock as READER

Arguments

    hInterface           Our handle to the i/f (pIcb)
    pvInterfaceInfo      Buffer to store info
    pdwInterfaceInfoSize Size of Buffer. If the info is more than this, we
                         return the needed size
Return Value

    NO_ERROR
    ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD dwErr;
    DWORD dwInfoSize = 0;
    PICB  pIcb;
    
    EnterRouterApi();

    TraceEnter("GetInterfaceInfo");

    dwErr = NO_ERROR;


    // *** Exclusion Begin ***
    ENTER_READER(ICB_LIST);

    pIcb = InterfaceLookupByICBSeqNumber(HandleToULong(hInterface));
    
    IpRtAssert(pIcb);

    if (pIcb isnot NULL)
    {
        dwInfoSize = GetSizeOfInterfaceConfig(pIcb);
        
        
        if(dwInfoSize > *pdwInterfaceInfoSize)
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            dwErr = GetInterfaceConfiguration(pIcb,
                                              pvInterfaceInfo,
                                              *pdwInterfaceInfoSize);
            
            if(dwErr isnot NO_ERROR)
            {
                Trace1(ERR,
                       "GetInterfaceInfo: Error %d getting interface configuration",
                       dwErr);
                
                dwErr = ERROR_CAN_NOT_COMPLETE;
            }
        }
    }

    else
    {
        Trace1(
            ANY,
            "GetInterfaceInfo : No interface with ICB number %d",
            HandleToULong(hInterface)
            );

        dwErr = ERROR_INVALID_INDEX;
    }
    
    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);
    
    *pdwInterfaceInfoSize = dwInfoSize;
    
    TraceLeave("GetInterfaceInfo");
    
    ExitRouterApi();

    return dwErr;
}


DWORD
SetInterfaceInfo(
    IN HANDLE hInterface, 
    IN LPVOID pInterfaceInfo
    )

/*++

Routine Description

    Called by DIM when a users sets interface info. All our sets follow 
    OVERWRITE semantics, i.e. the new info overwrites the old info instead of
    being appended to the old info.

Locks

    ICB_LIST lock as WRITER

Arguments

    None

Return Value

    None    

--*/

{
    DWORD                   i, dwResult;
    PVOID                   *pInfo ;
    PPROTO_CB               pIfProt;
    PIF_PROTO               pProto;
    PICB                    pIcb;
    PLIST_ENTRY             pleProto,pleNode;
    PADAPTER_INFO           pBinding;
    IP_ADAPTER_BINDING_INFO *pBindInfo ;
    PRTR_INFO_BLOCK_HEADER  pInfoHdr;
    PRTR_TOC_ENTRY          pToc;
    PINTERFACE_STATUS_INFO  pStatusInfo;
    BOOL                    bStatusChanged, bUpdateDIM = FALSE, bEnable;
    HANDLE                  hDimInterface;
    
    EnterRouterApi();

    TraceEnter("SetInterfaceInfo");
    
    //
    // The set info is the standard Header+TOC
    //
    
    pInfoHdr = (PRTR_INFO_BLOCK_HEADER)pInterfaceInfo;
    
    // *** Exclusion Begin ***
    ENTER_WRITER(ICB_LIST);

    //
    // If the current AdminState is DOWN and we are being asked to
    // bring it up, we do so BEFORE setting any other info
    //

    pIcb = InterfaceLookupByICBSeqNumber(HandleToULong(hInterface));
    
    IpRtAssert(pIcb);

    if (pIcb isnot NULL)
    {
        Trace1(IF,
               "SetInterfaceInfo: Setting configuration for %S",
               pIcb->pwszName);

        bStatusChanged = FALSE;
        hDimInterface = pIcb->hDIMHandle;
        
        pToc = GetPointerToTocEntry(IP_INTERFACE_STATUS_INFO, pInfoHdr);

        if((pToc isnot NULL) and (pToc->InfoSize isnot 0))
        {
            pStatusInfo = (PINTERFACE_STATUS_INFO)GetInfoFromTocEntry(pInfoHdr,
                                                                      pToc);

            if((pStatusInfo isnot NULL) and 
               (pIcb->dwAdminState is IF_ADMIN_STATUS_DOWN) and
               (pStatusInfo->dwAdminStatus is IF_ADMIN_STATUS_UP))
            {
                dwResult = SetInterfaceAdminStatus(pIcb,
                                                   pStatusInfo->dwAdminStatus,
                                                   &bUpdateDIM);

                if(dwResult isnot NO_ERROR)
                {
                    Trace2(ERR,
                           "SetInterfaceInfo: Error %d setting Admin Status on %S",
                           dwResult,
                           pIcb->pwszName);

                    EXIT_LOCK(ICB_LIST);

                    TraceLeave("SetInterfaceInfo");
                    
                    ExitRouterApi();

                    return dwResult;
                }

                bStatusChanged = TRUE;
            }
        }

        if(pIcb->dwAdminState is IF_ADMIN_STATUS_DOWN)
        {
            //
            // If we are still down, we dont allow any SETS
            //

            Trace1(ERR,
                   "SetInterfaceInfo: Can not set info for %S since the the admin state is DOWN",
                   pIcb->pwszName);
            
            EXIT_LOCK(ICB_LIST);

            TraceLeave("SetInterfaceInfo");
            
            ExitRouterApi();

            return ERROR_INVALID_PARAMETER;
        }

        //
        // Set router discovery info
        //
        
        SetRouterDiscoveryInfo(pIcb,
                               pInfoHdr);

        //
        // Make a copy of the binding info
        // This may be needed to be passed to the protocols
        //
        
        pBindInfo   = NULL;

        CheckBindingConsistency(pIcb);
        
        if(pIcb->bBound)
        {
            pBindInfo = HeapAlloc(IPRouterHeap,
                                  0,
                                  SIZEOF_IP_BINDING(pIcb->dwNumAddresses));
            
            if(pBindInfo is NULL)
            {
                Trace1(ERR,
                       "SetInterfaceInfo: Error allocating %d bytes for binding",
                       SIZEOF_IP_BINDING(pIcb->dwNumAddresses));

                EXIT_LOCK(ICB_LIST);

                if (bUpdateDIM)
                {
                    EnableInterfaceWithDIM(hDimInterface,PID_IP,TRUE);
                }
                
                TraceLeave("SetInterfaceInfo");
                
                ExitRouterApi();

                return ERROR_NOT_ENOUGH_MEMORY;
            }

            pBindInfo->AddressCount  = pIcb->dwNumAddresses;
            pBindInfo->RemoteAddress = pIcb->dwRemoteAddress;

            pBindInfo->Mtu           = pIcb->ulMtu;
            pBindInfo->Speed         = pIcb->ullSpeed;
            
            for (i = 0; i < pIcb->dwNumAddresses; i++) 
            {
                pBindInfo->Address[i].Address = pIcb->pibBindings[i].dwAddress;
                pBindInfo->Address[i].Mask    = pIcb->pibBindings[i].dwMask;
            }
        }

        // *** Exclusion Begin ***
        ENTER_READER(PROTOCOL_CB_LIST);
        
        //
        // Walk all the protocols and see if we have info for that protocol
        //      If we do, we see if the interface is already added to the protocol.
        //          If it is, we just call the SetInfo callback.
        //          Otherwise we add the interface and then bind it.
        //      If we dont, we see if the interface had been added to the protocol
        //          If it had, we delete the interface from the protocol
        //
     
        for(pleProto =  g_leProtoCbList.Flink;
            pleProto isnot &g_leProtoCbList;
            pleProto = pleProto->Flink)
        {
            PPROTO_CB   pProtoCb;
            ULONG       ulStructureVersion, ulStructureSize, ulStructureCount;
            
            pProtoCb = CONTAINING_RECORD(pleProto,
                                         PROTO_CB,
                                         leList);
           
            Trace1(IF,
                   "SetInterfaceInfo: Checking for info for %S",
                   pProtoCb->pwszDisplayName);

            pToc = GetPointerToTocEntry(pProtoCb->dwProtocolId, 
                                        pInfoHdr);

            if(pToc is NULL)
            {
                //
                // Block absent means do not change anything
                //

                Trace1(IF,
                       "SetInterfaceInfo: No TOC for %S. No change",
                       pProtoCb->pwszDisplayName);

                continue;
            }
            else
            {
                pInfo = GetInfoFromTocEntry(pInfoHdr,
                                            pToc);
            }
           
            ulStructureVersion  = 0x500;
            ulStructureSize     = pToc->InfoSize;
            ulStructureCount    = pToc->Count; 

            if((pToc->InfoSize isnot 0) and (pInfo isnot NULL))
            {
                BOOL bFound;

                //
                // So we have protocol info
                //
                
                Trace1(IF,
                       "SetInterfaceInfo: TOC Found for %S",
                       pProtoCb->pwszDisplayName);

                //
                // See if this protocol exists on the active protocol list
                // for the interface
                //

                bFound = FALSE;
                
                for(pleNode = pIcb->leProtocolList.Flink;
                    pleNode isnot &(pIcb->leProtocolList);
                    pleNode = pleNode->Flink)
                {
                    pProto = CONTAINING_RECORD(pleNode,
                                               IF_PROTO,
                                               leIfProtoLink);
                    
                    if(pProto->pActiveProto->dwProtocolId is
                       pProtoCb->dwProtocolId)
                    {
                        //
                        // The interface has already been added to the interface
                        // Just set info
                        //
                        
                          
                        bFound = TRUE;
                       
                        Trace2(IF,
                               "SetInterfaceInfo: %S already on %S. Setting info",
                               pProtoCb->pwszDisplayName,
                               pIcb->pwszName);

                        dwResult = (pProto->pActiveProto->pfnSetInterfaceInfo)(
                                        pIcb->dwIfIndex,
                                        pInfo,
                                        ulStructureVersion,
                                        ulStructureSize,
                                        ulStructureCount);

                        //
                        // Set the promiscuous mode to false since this time we
                        // actually have info
                        //

                        pProto->bPromiscuous = FALSE;

                        break;
                    }
                }
                
                if(!bFound)
                {
                    //
                    // The interface is being added to the protocol for the
                    // first time
                    //
                   
                    Trace2(IF,
                           "SetInterfaceInfo: %S not running %S. Adding interface",
                           pProtoCb->pwszDisplayName,
                           pIcb->pwszName);

                    dwResult = AddInterfaceToProtocol(pIcb,
                                                      pProtoCb,
                                                      pInfo,
                                                      ulStructureVersion,
                                                      ulStructureSize,
                                                      ulStructureCount);
     
                    if(dwResult isnot NO_ERROR)
                    {
                        Trace3(ERR,
                               "SetInterfaceInfo: Error %d adding %S to %S",
                               dwResult,
                               pIcb->pwszName,
                               pProtoCb->pwszDisplayName);
                    }

                    dwResult = (pProtoCb->pfnInterfaceStatus)(
                                    pIcb->dwIfIndex,
                                    (pIcb->dwOperationalState >= CONNECTED),
                                    RIS_INTERFACE_ENABLED,
                                    NULL
                                    );

                    if(dwResult isnot NO_ERROR)
                    {
                        Trace3(ERR,
                               "SetInterfaceInfo: Error %d enabling %S with %S",
                               dwResult,
                               pIcb->pwszName,
                               pProtoCb->pwszDisplayName);
                    }
                    
                    //
                    // If the binding information is available, pass it to the
                    // protocol
                    //
               
                    if(pBindInfo)
                    {
                        Trace2(IF,
                               "SetInterfaceInfo: Binding %S in %S",
                               pIcb->pwszName,
                               pProtoCb->pwszDllName);

                        dwResult = BindInterfaceInProtocol(pIcb,
                                                           pProtoCb,
                                                           pBindInfo);
                        
                        if(dwResult isnot NO_ERROR)
                        {
                            Trace3(ERR, 
                                   "SetInterfaceInfo: Error %d binding %S to %S",
                                   dwResult,
                                   pIcb->pwszName,
                                   pProtoCb->pwszDllName);
                        }
                    }


                    //
                    // If this is the internal interface, also call connect client
                    // for connected clients
                    //

                    if((pIcb is g_pInternalInterfaceCb) and
                       (pProtoCb->pfnConnectClient))
                    {
                        PLIST_ENTRY         pleTempNode;
                        IP_LOCAL_BINDING    clientAddr;
                        PICB                pTempIf;

                        for(pleTempNode = &ICBList;
                            pleTempNode->Flink != &ICBList;
                            pleTempNode = pleTempNode->Flink)
                        {
                            pTempIf = CONTAINING_RECORD(pleTempNode->Flink,
                                                        ICB,
                                                        leIfLink);


                            if(pTempIf->ritType isnot ROUTER_IF_TYPE_CLIENT)
                            {
                                continue;
                            }

                            clientAddr.Address = pTempIf->pibBindings[0].dwAddress;
                            clientAddr.Mask    = pTempIf->pibBindings[0].dwMask;

                            pProtoCb->pfnConnectClient(g_pInternalInterfaceCb->dwIfIndex,
                                                       &clientAddr);
                        }
                    }
                }
            }
            else
            {
                //
                // A zero size TOC was found for this particular protocol. If
                // this protocol exists in the current ActiveProtocol list,
                // remove the interface from the protocol
                //
               
                Trace2(IF,
                       "SetInterfaceInfo: A zero size TOC was found for %S on %S",
                       pProtoCb->pwszDllName,
                       pIcb->pwszName);
     
                pleNode = pIcb->leProtocolList.Flink;
                
                while(pleNode isnot &(pIcb->leProtocolList))
                {
                    pProto = CONTAINING_RECORD(pleNode,
                                               IF_PROTO,
                                               leIfProtoLink);
                    
                    pleNode = pleNode->Flink;
                    
                    if(pProto->pActiveProto->dwProtocolId is pProtoCb->dwProtocolId)
                    {
                        IpRtAssert(pProto->pActiveProto is pProtoCb);

                        //
                        // Call the routing protocol's deleteinterface entrypoint
                        //
                      
                        Trace2(IF,
                               "SetInterfaceInfo: Deleting %S from %S",
                               pProtoCb->pwszDllName, 
                               pIcb->pwszName);

                        dwResult = (pProtoCb->pfnDeleteInterface)(pIcb->dwIfIndex);
                        
                        if(dwResult isnot NO_ERROR)
                        {
                            Trace3(ERR,
                                   "SetInterfaceInfo: Err %d deleting %S from %S",
                                   dwResult,
                                   pIcb->pwszName,
                                   pProtoCb->pwszDllName);
                        }
                        else
                        {
                            //
                            // Delete this protocol from the list of protocols
                            // in the Interface
                            //
                            
                            RemoveEntryList(&(pProto->leIfProtoLink));
                            
                            HeapFree(IPRouterHeap,
                                     0,
                                     pProto);
                        }
                    }
                }
            }
        }
        
        // *** Exclusion End ***
        EXIT_LOCK(PROTOCOL_CB_LIST);

        for(i = 0; i < NUM_INFO_CBS; i++)
        {
            dwResult = g_rgicInfoCb[i].pfnSetInterfaceInfo(pIcb,
                                                           pInfoHdr);

            if(dwResult isnot NO_ERROR)
            {
                Trace3(ERR,
                       "SetInterfaceInfo: Error %d setting %s info for %S",
                       dwResult,
                       g_rgicInfoCb[i].pszInfoName,
                       pIcb->pwszName);
            }
        }
        
        if(pBindInfo)
        {
            HeapFree(IPRouterHeap,
                     0,
                     pBindInfo);
        }


        //
        // If we have already changed the status dont do it again
        //

        if(!bStatusChanged)
        {
            dwResult = SetInterfaceStatusInfo(pIcb,
                                              pInfoHdr,
                                              &bUpdateDIM);
        
            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "SetInterfaceInfo: Error %d setting status info for %S",
                       dwResult,
                       pIcb->pwszName);
            }
        }

        bEnable = (pIcb->dwAdminState == IF_ADMIN_STATUS_UP) ? TRUE : FALSE;
    }

    else
    {
        Trace1(
            ANY,
            "SetInterfaceInfo : No interface with ICB number %d",
            HandleToULong(hInterface)
            );
    }
    
    
    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);
    
    if(bUpdateDIM)
    {
        EnableInterfaceWithDIM(
            hDimInterface,
            PID_IP,
            bEnable
            );
    }

    TraceLeave("SetInterfaceInfo");
    
    ExitRouterApi();

    return NO_ERROR;
}


DWORD
InterfaceNotReachable(
    IN HANDLE                hInterface, 
    IN UNREACHABILITY_REASON Reason
    )

/*++

Routine Description

    Called by DIM to tell us that an interface should be considered
    UNREACHABLE till further notice

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    PICB            pIcb;
    PADAPTER_INFO   pBinding;
    DWORD           dwErr;

    EnterRouterApi();

    TraceEnter("InterfaceNotReachable");

    ENTER_WRITER(ICB_LIST);
  
    //
    // If it is a CLIENT interface all this means is that the connection
    // failed
    //

    pIcb = InterfaceLookupByICBSeqNumber(HandleToULong(hInterface));

    IpRtAssert(pIcb);

    if (pIcb isnot NULL)
    {
        if(pIcb->ritType is ROUTER_IF_TYPE_CLIENT)
        {
            pIcb->dwOperationalState = UNREACHABLE;

            EXIT_LOCK(ICB_LIST);

            ExitRouterApi();

            return NO_ERROR;
        }
     
        Trace2(IF, 
               "InterfaceNotReachable: %S is not reachable for reason %d",
               pIcb->pwszName,
               Reason) ;

        if(pIcb->ritType is ROUTER_IF_TYPE_DEDICATED)
        {
            if(Reason == INTERFACE_NO_MEDIA_SENSE)
            {
                HandleMediaSenseEvent(pIcb,
                                      FALSE);
            }

            else
            {
                dwErr = LanEtcInterfaceUpToDown(pIcb, FALSE);

                if(dwErr isnot NO_ERROR)
                {
                    Trace1(ERR,
                           "InterfaceNotReachable: Failed to status for %S to down",
                           dwErr);
                }
            }
            
            EXIT_LOCK(ICB_LIST);

            ExitRouterApi();

            return NO_ERROR;
        }
        
#if STATIC_RT_DBG

        ENTER_WRITER(BINDING_LIST);

        pBinding = GetInterfaceBinding(pIcb->dwIfIndex);

        pBinding->bUnreach = TRUE;

        EXIT_LOCK(BINDING_LIST);

#endif


        //
        // If we were trying to connect on this - then inform WANARP to 
        // drain its queued up packets
        //
        
        if(pIcb->dwOperationalState is CONNECTING)
        {
            NTSTATUS           Status;

            Status = NotifyWanarpOfFailure(pIcb);

            if((Status isnot STATUS_PENDING) and
               (Status isnot STATUS_SUCCESS))
            {
                Trace1(ERR,
                       "InterfaceNotReachable: IOCTL_WANARP_CONNECT_FAILED failed. Status %x",
                       Status);
            }

            //
            // If it was connecting, then the stack has set the interface context
            // to something other than 0xffffffff. Hence he wont dial out on that 
            // route. We need to change the context in the stack back to invalid 
            // so that new packets cause the demand dial 
            //
                
            ChangeAdapterIndexForDodRoutes(pIcb->dwIfIndex);

            //
            // We are still in INACTIVE state so dont have to call any if the
            // WanInterface*To*() functions. But since we are in CONNECTING
            // WANARP must have called us with CONNECTION notification
            // so we undo what we did there
            //

            DeAllocateBindings(pIcb);

            ClearNotificationFlags(pIcb);
            
        }
        else
        {
            //
            // A connected interface must first be disconnected
            //
            
            if(pIcb->dwOperationalState is CONNECTED)
            {
                Trace1(IF,
                       "InterfaceNotReachable: %S is already connected",
                       pIcb->pwszName);

                EXIT_LOCK(ICB_LIST);

                ExitRouterApi();

                return ERROR_INVALID_HANDLE_STATE;
            }
        }

        //
        // This sets the state to UNREACHABLE
        //

        WanInterfaceInactiveToDown(pIcb,
                                   FALSE);
    }
    
    else
    {
        Trace1(
            ANY,
            "InterfaceNotReachable : No interface with ICB number %d",
            HandleToULong(hInterface)
            );
    }
    
    EXIT_LOCK(ICB_LIST);
    
    TraceLeave("InterfaceNotReachable");
    
    ExitRouterApi();

    return NO_ERROR;
}


DWORD
InterfaceReachable(
    IN HANDLE hInterface
    )

/*++

Routine Description

    Notification by DIM that the interface is REACHABLE again

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    DWORD   dwErr;

    PICB    pIcb;
    
    EnterRouterApi();

    TraceEnter("InterfaceReachable");

    // *** Exclusion Begin ***
    ENTER_WRITER(ICB_LIST);

    pIcb = InterfaceLookupByICBSeqNumber(HandleToULong(hInterface));

    IpRtAssert(pIcb);

    if (pIcb isnot NULL)
    {
        Trace1(IF, "InterfaceReachable: %S is now reachable",
               pIcb->pwszName);

        if((pIcb->dwOperationalState <= UNREACHABLE) and
           (pIcb->dwAdminState is IF_ADMIN_STATUS_UP))
        {
            //
            // only if it was unreachable before.
            //
           
            if(pIcb->ritType is ROUTER_IF_TYPE_DEDICATED)
            {
                dwErr = LanEtcInterfaceDownToUp(pIcb,
                                                FALSE);
            }
            else
            {
                dwErr = WanInterfaceDownToInactive(pIcb);
            }

            if(dwErr isnot NO_ERROR) 
            {
                Trace2(ERR,
                       "InterfaceReachable: Err %d bringing up %S",
                       dwErr,
                       pIcb->pwszName);
            }
        }
    }
    else
    {
        Trace1(
            ANY,
            "InterfaceReachable : No interface with ICB number %d",
            HandleToULong(hInterface)
            );
    }
    

    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);
  
    TraceLeave("InterfaceNotReachable");

    ExitRouterApi();

    return NO_ERROR;
}

DWORD
InterfaceConnected(
    IN   HANDLE  hInterface,
    IN   PVOID   pFilter,
    IN   PVOID   pPppProjectionResult
    )

/*++

Routine Description

    Notification by DIM that an interface has connected.

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    DWORD   dwResult, i;
    PICB    pIcb;

    INTERFACE_ROUTE_INFO rifRoute;

    EnterRouterApi(); 

    TraceEnter("InterfaceConnected");
    
    ENTER_WRITER(ICB_LIST);

    pIcb = InterfaceLookupByICBSeqNumber(HandleToULong(hInterface));

    IpRtAssert(pIcb);

    if (pIcb != NULL)
    {
        Trace2(IF,
               "InterfaceConnected: InterfaceConnected called for %S. State is %d",
               pIcb->pwszName,
               pIcb->dwOperationalState);

        if((pIcb->ritType is ROUTER_IF_TYPE_CLIENT) and
           (g_pInternalInterfaceCb is NULL))
        {
            EXIT_LOCK(ICB_LIST);

            ExitRouterApi();

            return ERROR_INVALID_HANDLE_STATE;
        }

        if((pIcb->ritType is ROUTER_IF_TYPE_CLIENT) and
           g_bUninitServer)
        {
            TryUpdateInternalInterface();
        }

        if(pIcb->dwOperationalState is UNREACHABLE)
        {
            //
            // going from unreachable to connecting. This can happen
            //

            WanInterfaceDownToInactive(pIcb);
        }
            
        if(pIcb->dwOperationalState isnot CONNECTING)
        {
            //
            // Wanarp has not called us as yet, so set the state to connecting
            //
            
            pIcb->dwOperationalState = CONNECTING;
        }

        SetDDMNotification(pIcb);

        if(HaveAllNotificationsBeenReceived(pIcb))
        {
            //
            // Wanarp has also called us
            //
          
            pIcb->dwOperationalState = CONNECTED ;
            
            if(pIcb->ritType isnot ROUTER_IF_TYPE_CLIENT)
            {
                WRITER_TO_READER(ICB_LIST);

                WanInterfaceInactiveToUp(pIcb);
            }
            else
            {
                IP_LOCAL_BINDING    clientAddr;
                PLIST_ENTRY         pleNode;
                PPP_IPCP_RESULT     *pProjInfo;

                pProjInfo = &(((PPP_PROJECTION_RESULT *)pPppProjectionResult)->ip);

                IpRtAssert(pIcb->pibBindings);

                pIcb->dwNumAddresses = 1;

                pIcb->bBound = TRUE;

                pIcb->pibBindings[0].dwAddress = pProjInfo->dwRemoteAddress;

                if(g_pInternalInterfaceCb->bBound)
                {
                    pIcb->pibBindings[0].dwMask = 
                        g_pInternalInterfaceCb->pibBindings[0].dwMask;
                }
                else
                {
                    pIcb->pibBindings[0].dwMask = 
                        GetClassMask(pProjInfo->dwRemoteAddress);
                }
     
                clientAddr.Address = pIcb->pibBindings[0].dwAddress;
                clientAddr.Mask    = pIcb->pibBindings[0].dwMask;


#if 0               
                //
                // Add a non-stack host route to the client
                //

                rifRoute.dwRtInfoMask      = HOST_ROUTE_MASK;
                rifRoute.dwRtInfoNextHop   = clientAddr.Address;
                rifRoute.dwRtInfoDest      = clientAddr.Address;
                rifRoute.dwRtInfoIfIndex   = g_pInternalInterfaceCb->dwIfIndex;
                rifRoute.dwRtInfoMetric1   = 1;
                rifRoute.dwRtInfoMetric2   = 0;
                rifRoute.dwRtInfoMetric3   = 0;
                rifRoute.dwRtInfoPreference= 
                    ComputeRouteMetric(MIB_IPPROTO_LOCAL);
                rifRoute.dwRtInfoViewSet   = RTM_VIEW_MASK_UCAST |
                                              RTM_VIEW_MASK_MCAST; // XXX config
                rifRoute.dwRtInfoType      = MIB_IPROUTE_TYPE_DIRECT;
                rifRoute.dwRtInfoProto     = MIB_IPPROTO_NETMGMT;
                rifRoute.dwRtInfoAge       = INFINITE;
                rifRoute.dwRtInfoNextHopAS = 0;
                rifRoute.dwRtInfoPolicy    = 0;

                dwResult = AddSingleRoute(g_pInternalInterfaceCb->dwIfIndex,
                                          &rifRoute,
                                          clientAddr.Mask,
                                          0,        // RTM_ROUTE_INFO::Flags
                                          TRUE,
                                          FALSE,
                                          FALSE,
                                          NULL);

#endif
                ENTER_READER(PROTOCOL_CB_LIST);

                //
                // Call ConnectClient for all the protocols configured
                // over the ServerInterface
                //

                for(pleNode = g_pInternalInterfaceCb->leProtocolList.Flink; 
                    pleNode isnot &(g_pInternalInterfaceCb->leProtocolList);
                    pleNode = pleNode->Flink)
                {
                    PIF_PROTO   pIfProto;

                    pIfProto = CONTAINING_RECORD(pleNode,
                                                 IF_PROTO,
                                                 leIfProtoLink);

                    if(pIfProto->pActiveProto->pfnConnectClient)
                    {
                        pIfProto->pActiveProto->pfnConnectClient(
                            g_pInternalInterfaceCb->dwIfIndex,
                            &clientAddr
                            );
                    }
                }

                EXIT_LOCK(PROTOCOL_CB_LIST);

                for (i=0; i<NUM_INFO_CBS; i++)
                {
                    if (!g_rgicInfoCb[i].pfnBindInterface)
                    {
                        continue;
                    }

                    dwResult = g_rgicInfoCb[i].pfnBindInterface(pIcb);

                    if(dwResult isnot NO_ERROR)
                    {
                        Trace3(IF,
                               "InterfaceConnected: Error %d binding %S for %s info",
                               dwResult,
                               pIcb->pwszName,
                               g_rgicInfoCb[i].pszInfoName);
                    }
                }
                    
                AddAllClientRoutes(pIcb,
                                   g_pInternalInterfaceCb->dwIfIndex);


            }
        }
    }

    else
    {
        Trace1(
            ANY,
            "InterfaceConnected : No interface with ICB number %d",
            HandleToULong(hInterface)
            );
    }
    
    
    EXIT_LOCK(ICB_LIST);

    TraceLeave("InterfaceConnected");
    
    ExitRouterApi();

    return NO_ERROR;
}


DWORD
SetGlobalInfo(
    IN LPVOID pGlobalInfo
    )
{
    DWORD                   dwSize, dwResult, i, j;
    PPROTO_CB               pProtocolCb;
    PLIST_ENTRY             pleNode ;
    BOOL                    bFoundProto, bFoundInfo;
    PRTR_INFO_BLOCK_HEADER  pInfoHdr;
    MPR_PROTOCOL_0          *pmpProtocolInfo;
    DWORD                   dwNumProtoEntries;
    PVOID                   pvInfo;
    PRTR_TOC_ENTRY          pToc;
    PGLOBAL_INFO            pRtrGlobalInfo;
    
    EnterRouterApi();
    
    TraceEnter("SetGlobalInfo");

    if(pGlobalInfo is NULL)
    {
        TraceLeave("SetGlobalInfo");
    
        ExitRouterApi();
        
        return NO_ERROR;
    }

    pInfoHdr = (PRTR_INFO_BLOCK_HEADER)pGlobalInfo;
    
    //
    // Set Routing Protocol Priority info. Priority information is in its
    // own DLL so no locks need to be taken
    //
    
    SetPriorityInfo(pInfoHdr);

    //
    // Set Multicast Scope info (no locks needed)
    //

    SetScopeInfo(pInfoHdr);

    //
    // Enforce the discipline of taking ICBListLock before Routing lock
    //
    
    
    ENTER_WRITER(ICB_LIST);
    
    ENTER_WRITER(PROTOCOL_CB_LIST);
    
    pToc = GetPointerToTocEntry(IP_GLOBAL_INFO,
                                pInfoHdr);

    if(pToc is NULL)
    {
        Trace0(GLOBAL,
               "SetGlobalInfo: No TOC found for Global Info");
    }
    else
    {
        if(pToc->InfoSize is 0)
        {
            g_dwLoggingLevel = IPRTR_LOGGING_NONE;

        }
        else
        {
            pRtrGlobalInfo   = (PGLOBAL_INFO)GetInfoFromTocEntry(pInfoHdr,
                                                                 pToc);
            g_dwLoggingLevel = (pRtrGlobalInfo isnot NULL) ? 
                                    pRtrGlobalInfo->dwLoggingLevel : 
                                    IPRTR_LOGGING_NONE;
        }
    }

    dwResult = MprSetupProtocolEnum(PID_IP,
                                    (PBYTE *)(&pmpProtocolInfo),
                                    &dwNumProtoEntries);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "SetGlobalInfo: Error %d loading protocol info from registry",
               dwResult);

                    
        EXIT_LOCK(PROTOCOL_CB_LIST);

        EXIT_LOCK(ICB_LIST);
    
        TraceLeave("SetGlobalInfo");

        ExitRouterApi();

        return ERROR_REGISTRY_CORRUPT;
    }
    

    //
    // Now go looking for protocols TOCs
    //
    
    for(i = 0; i < pInfoHdr->TocEntriesCount; i++)
    {
        ULONG       ulStructureVersion, ulStructureSize, ulStructureCount;
        DWORD       dwType;

        dwType = TYPE_FROM_PROTO_ID(pInfoHdr->TocEntry[i].InfoType);

        if(dwType == PROTO_TYPE_MS1)
        {
            continue;
        }
            
        //
        // Go through the loaded routing protocols and see if the protocol is
        // in the list
        // If it is, we just call SetGlobalInfo callback.
        // If not we load the protocol
        //
            
        pProtocolCb = NULL;
        bFoundProto = FALSE;
            
        for(pleNode = g_leProtoCbList.Flink; 
            pleNode != &g_leProtoCbList; 
            pleNode = pleNode->Flink) 
        {
            pProtocolCb = CONTAINING_RECORD(pleNode,
                                            PROTO_CB,
                                            leList) ;
                
            if(pProtocolCb->dwProtocolId is pInfoHdr->TocEntry[i].InfoType)
            {
                bFoundProto = TRUE;
                    
                break;
            }
        }
            
        if(bFoundProto)
        {
            //
            // Ok, so this protocol was already loaded.
            //
                
            if(pInfoHdr->TocEntry[i].InfoSize is 0)
            {
                //
                // 0 TOC size means delete
                //
                    
                if(pProtocolCb->posOpState is RTR_STATE_RUNNING) 
                {
                    //
                    // If its stopped or stopping, we dont tell it again
                    //

                    Trace1(GLOBAL,
                           "SetGlobalInfo: Removing %S since the TOC size was 0",
                           pProtocolCb->pwszDisplayName);
                    
                    dwResult = StopRoutingProtocol(pProtocolCb);
                    
                    if(dwResult is NO_ERROR)
                    {
                        //
                        // The routing protocol stopped synchronously and
                        // all references to it in the interfaces have
                        // been removed
                        //
                            
                        //
                        // At this point we need to hold the PROTOCOL_CB_LIST
                        // lock exclusively
                        //

                        //
                        // relenquish CPU to enable DLL threads to
                        // finish
                        //
                        
                        Sleep(0);
                        
                        FreeLibrary(pProtocolCb->hiHInstance);
                            
                        RemoveEntryList(&(pProtocolCb->leList));
                            
                        HeapFree(IPRouterHeap, 
                                 0, 
                                 pProtocolCb);
                    
                        TotalRoutingProtocols--;
                    }
                    else
                    {
                        if(dwResult isnot ERROR_PROTOCOL_STOP_PENDING)
                        {
                            Trace2(ERR,
                                   "SetGlobalInfo: Error %d stopping %S. Not removing from list",
                                   dwResult,
                                   pProtocolCb->pwszDisplayName);
                        }
                    }
                }
            }
            else
            {
                //
                // So we do have info with this protocol
                //
                    
                pvInfo = GetInfoFromTocEntry(pInfoHdr,
                                             &(pInfoHdr->TocEntry[i]));
           
                
                //ulStructureVersion = pInfoHdr->TocEntry[i].InfoVersion;
                ulStructureVersion = 0x500;
                ulStructureSize  = pInfoHdr->TocEntry[i].InfoSize;
                ulStructureCount = pInfoHdr->TocEntry[i].Count;
 
                dwResult = (pProtocolCb->pfnSetGlobalInfo)(pvInfo,
                                                           ulStructureVersion,
                                                           ulStructureSize,
                                                           ulStructureCount);

                if(dwResult isnot NO_ERROR)
                {
                    Trace2(ERR,
                           "SetGlobalInfo: Error %d setting info for %S",
                           dwResult,
                           pProtocolCb->pwszDisplayName);
                }
            }
        }
        else
        {
            //
            // Well the protocol was not found so, lets load it up
            // 

            //
            // Bad case when size == 0
            //

            if(pInfoHdr->TocEntry[i].InfoSize is 0)
            {
                continue;
            }

            bFoundInfo = FALSE;
                
            for(j = 0; j < dwNumProtoEntries; j ++)
            {
                if(pmpProtocolInfo[j].dwProtocolId is pInfoHdr->TocEntry[i].InfoType)
                {
                    bFoundInfo = TRUE;

                    break;
                }
            }

            if(!bFoundInfo)
            {
                Trace1(ERR,
                       "SetGlobalInfo: Couldnt find config information for %d",
                       pInfoHdr->TocEntry[i].InfoType);

                continue;
            }

            //
            // Load the library and make a cb for this protocol
            //

            
            dwSize =
                (wcslen(pmpProtocolInfo[j].wszProtocol) + wcslen(pmpProtocolInfo[j].wszDLLName) + 2) * sizeof(WCHAR) +
                sizeof(PROTO_CB);
            
            pProtocolCb = HeapAlloc(IPRouterHeap, 
                                    HEAP_ZERO_MEMORY, 
                                    dwSize);

            if(pProtocolCb is NULL) 
            {
                Trace2(ERR,
                       "SetGlobalInfo: Error allocating %d bytes for %S",
                       dwSize,
                       pmpProtocolInfo[j].wszProtocol);
                
                continue ;
            }

            pvInfo = GetInfoFromTocEntry(pInfoHdr,
                                         &(pInfoHdr->TocEntry[i]));

            //ulStructureVersion = pInfoHdr->TocEntry[i].InfoVersion;
            ulStructureVersion = 0x500;
            ulStructureSize  = pInfoHdr->TocEntry[i].InfoSize;
            ulStructureCount = pInfoHdr->TocEntry[i].Count;

            dwResult = LoadProtocol(&(pmpProtocolInfo[j]),
                                    pProtocolCb,
                                    pvInfo,
                                    ulStructureVersion,
                                    ulStructureSize,
                                    ulStructureCount);
       
            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "SetGlobalInfo: %S failed to load: %d",
                       pmpProtocolInfo[j].wszProtocol,
                       dwResult);
            
                HeapFree (IPRouterHeap,
                          0,
                          pProtocolCb) ;
            
            }
            else
            {
                pProtocolCb->posOpState = RTR_STATE_RUNNING ;
            
                //
                // Insert this routing protocol in the list of routing
                // protocols
                //
            
                InsertTailList (&g_leProtoCbList, &pProtocolCb->leList);
                
                Trace1(GLOBAL, 
                       "SetGlobalInfo: %S successfully initialized", 
                       pmpProtocolInfo[j].wszProtocol) ;
            
                TotalRoutingProtocols++;

                //
                // Lets see if it wants to be in promiscuous add mode.
                // If so, add all the current interfaces
                //

                if(pProtocolCb->fSupportedFunctionality & RF_ADD_ALL_INTERFACES)
                {
                    //
                    // First lets add the internal interface
                    //

                    if(g_pInternalInterfaceCb)
                    {
                        dwResult = AddInterfaceToProtocol(g_pInternalInterfaceCb,
                                                          pProtocolCb,
                                                          NULL,
                                                          0,
                                                          0,
                                                          0);

                        if(dwResult isnot NO_ERROR)
                        {
                            Trace3(ERR,
                                   "SetGlobalInfo: Error %d adding %S to %S promously",
                                   dwResult,
                                   g_pInternalInterfaceCb->pwszName,
                                   pProtocolCb->pwszDisplayName);
    
                        }
    
                        if(g_pInternalInterfaceCb->dwAdminState is IF_ADMIN_STATUS_UP)
                        {
                            EnableInterfaceWithAllProtocols(g_pInternalInterfaceCb);
                        }
    
                        if(g_pInternalInterfaceCb->bBound)
                        {
                            BindInterfaceInAllProtocols(g_pInternalInterfaceCb);
                        }
                    }

                    for(pleNode = &ICBList;
                        pleNode->Flink != &ICBList;
                        pleNode = pleNode->Flink)
                    {
                        PICB    pIcb;

                        pIcb = CONTAINING_RECORD(pleNode->Flink,
                                                 ICB,
                                                 leIfLink);


                        if(pIcb is g_pInternalInterfaceCb)
                        {
                            //
                            // Already added, continue;
                            //
                        
                            continue;
                        }

                        if(pIcb->ritType is ROUTER_IF_TYPE_DIALOUT)
                        {
                            //
                            // Skip dial out interfaces
                            //

                            continue;
                        }

                        if(pIcb->ritType is ROUTER_IF_TYPE_CLIENT)
                        {
                            IP_LOCAL_BINDING    clientAddr;

                            //
                            // Just call connect client for these
                            // We have to have internal interface
                            //

                            clientAddr.Address = pIcb->pibBindings[0].dwAddress;
                            clientAddr.Mask    = pIcb->pibBindings[0].dwMask;

                            if(pProtocolCb->pfnConnectClient)
                            {
                                pProtocolCb->pfnConnectClient(g_pInternalInterfaceCb->dwIfIndex,
                                                              &clientAddr);
                            }

                            continue;
                        }

                        //
                        // The rest we add
                        //

                        dwResult = AddInterfaceToProtocol(pIcb,
                                                          pProtocolCb,
                                                          NULL,
                                                          0,
                                                          0,
                                                          0);

                        if(dwResult isnot NO_ERROR)
                        {
                            Trace3(ERR,
                                   "SetGlobalInfo: Error %d adding %S to %S promiscuously",
                                   dwResult,
                                   pIcb->pwszName,
                                   pProtocolCb->pwszDisplayName);

                            continue;
                        }

                        if(pIcb->dwAdminState is IF_ADMIN_STATUS_UP)
                        {
                            EnableInterfaceWithAllProtocols(pIcb);
                        }

                        if(pIcb->bBound)
                        {
                            BindInterfaceInAllProtocols(pIcb);
                        }
                    }
                }
            }
        }
    }

    MprSetupProtocolFree(pmpProtocolInfo);

    EXIT_LOCK(PROTOCOL_CB_LIST);

    EXIT_LOCK(ICB_LIST);
    
    TraceLeave("SetGlobalInfo");

    ExitRouterApi();
    
    return NO_ERROR;
}

DWORD
GetGlobalInfo(
    OUT    LPVOID    pGlobalInfo,
    IN OUT LPDWORD   lpdwGlobalInfoSize
    )

/*++

Routine Description

    This function

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    DWORD dwSize;
    DWORD dwResult;

    EnterRouterApi();

    TraceEnter("GetGlobalInfo");
    
    ENTER_READER(ICB_LIST);
    ENTER_READER(PROTOCOL_CB_LIST);
    
    dwSize = GetSizeOfGlobalInfo();
    
    if(dwSize > *lpdwGlobalInfoSize)
    {
        *lpdwGlobalInfoSize = dwSize;
        
        EXIT_LOCK(PROTOCOL_CB_LIST);
        EXIT_LOCK(ICB_LIST);
        
        TraceLeave("GetGlobalInfo");
        
        ExitRouterApi();

        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    
    dwResult = GetGlobalConfiguration((PRTR_INFO_BLOCK_HEADER)pGlobalInfo,
                                      *lpdwGlobalInfoSize);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetGlobalInfo: Error %d getting global config",
               dwResult);
    }
    
    EXIT_LOCK(PROTOCOL_CB_LIST);
    EXIT_LOCK(ICB_LIST);


    TraceLeave("GetGlobalInfo");
    
    ExitRouterApi();

    return NO_ERROR;
}


DWORD
UpdateRoutes(
    IN HANDLE hInterface, 
    IN HANDLE hEvent
    )
{
    DWORD           i;
    DWORD           dwResult;
    PIF_PROTO       pProto;
    PICB            pIcb;
    PLIST_ENTRY     pleNode;
    
    EnterRouterApi();

    TraceEnter("UpdateRoutes");
    
    // *** Exclusion Begin ***
    ENTER_READER(ICB_LIST);

    pIcb = InterfaceLookupByICBSeqNumber(HandleToULong(hInterface));

    IpRtAssert(pIcb);

    if (pIcb != NULL)
    {
        Trace1(ROUTE,
               "UpdateRoutes: Updating routes over %S", pIcb->pwszName) ;
        
        if(pIcb->dwOperationalState < CONNECTED)
        {
            Trace1(ERR,
                   "UpdateRoutes: %S is not connected.",
                   pIcb->pwszName);

            EXIT_LOCK(ICB_LIST);

            TraceLeave("UpdateRoutes");

            ExitRouterApi();

            return ERROR_INVALID_PARAMETER;
        }

        //
        // We first delete all the routes over this interface. If we
        // fail the update routes, that means we have lost the autostatic
        // routes. But that is OK, since if we fail for some reason - that
        // is an error condition and we should be getting rid of the routes
        // anyway. Sure, we can fail for non protocol related reasons
        // (out of memory) but that is also an error.  Earlier we used to
        // let the routing protocol finish its update and then delete the
        // route. However if RIP did not have "Overwrite routes" stuff 
        // set, it would not write its routes to RTM. So now we first delete
        // the routes. This means that for some time (while the update is
        // going on) we have loss of reachability. 
        //

        dwResult = DeleteRtmRoutesOnInterface(g_hAutoStaticRoute,
                                              pIcb->dwIfIndex);

        if(//(dwResult isnot ERROR_NO_ROUTES) and
           (dwResult isnot NO_ERROR))
        {
            Trace1(ERR,
                   "UpdateRoutes: Error %d block deleting routes",
                   dwResult);

            EXIT_LOCK(ICB_LIST);

            TraceLeave("UpdateRoutes");
            
            ExitRouterApi();

            return dwResult ;
        }
            
        if(pIcb->hDIMNotificationEvent isnot NULL)
        {
            //
            // There is already an update routes for this interface in progress 
            //
            
            dwResult = ERROR_UPDATE_IN_PROGRESS;
        }
        else
        {
            dwResult = ERROR_FILE_NOT_FOUND;

            // *** Exclusion Begin ***
            ENTER_READER(PROTOCOL_CB_LIST);
                
            //
            // Find a protocol that supports update route operation. we
            // settle for the first one that does.
            //
            
            for(pleNode = pIcb->leProtocolList.Flink;
                pleNode isnot &(pIcb->leProtocolList);
                pleNode = pleNode->Flink)
            {
                pProto = CONTAINING_RECORD(pleNode,
                                           IF_PROTO,
                                           leIfProtoLink);
                
                if(pProto->pActiveProto->pfnUpdateRoutes isnot NULL)
                {
                    //
                    // found a routing protocol that supports updates
                    //
                    
                    dwResult = (pProto->pActiveProto->pfnUpdateRoutes)(
                                   pIcb->dwIfIndex
                                   );

                    if((dwResult isnot NO_ERROR) and (dwResult isnot PENDING))
                    {
                        //
                        // The protocol can return NO_ERROR, or PENDING all
                        // else is an error
                        //

                        Trace2(ERR,
                               "UpdateRoutes: %S returned %d while trying to update routes. Trying other protocols",
                               pProto->pActiveProto->pwszDisplayName,
                               dwResult);
                    }
                    else
                    {
                        //
                        // Even if the protocol returned NO_ERROR, this is
                        // an inherently
                        // asynchronous call, so we return PENDING
                        //

                        dwResult = PENDING;

                        pIcb->hDIMNotificationEvent = hEvent;

                        break;
                    }
                }
            }
                
            // *** Exclusion End ***
            EXIT_LOCK(PROTOCOL_CB_LIST);
        }
    }
    else
    {
        Trace1(
            ANY,
            "UpdateRoutes : No interface with ICB number %d",
            HandleToULong(hInterface)
            );

        dwResult = ERROR_INVALID_INDEX;
    }
    
    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);

    TraceLeave("UpdateRoutes");
    
    ExitRouterApi();

    return dwResult ;
}

DWORD
GetUpdateRoutesResult(
    IN  HANDLE  hInterface, 
    OUT PDWORD  pdwUpdateResult
    )
{
    DWORD               dwResult ;
    UpdateResultList    *pResult ;
    PLIST_ENTRY         pleNode ;
    PICB                pIcb;
    
    EnterRouterApi();
    
    TraceEnter("GetUpdateRoutesResult") ;
    
    // *** Exclusion Begin ***
    ENTER_WRITER(ICB_LIST);

    pIcb = InterfaceLookupByICBSeqNumber(HandleToULong(hInterface));

    IpRtAssert(pIcb);

    if (pIcb != NULL)
    {
        if (IsListEmpty (&pIcb->lePendingResultList))
        {
            dwResult = ERROR_CAN_NOT_COMPLETE ;
        }
        else
        {
            pleNode = RemoveHeadList (&pIcb->lePendingResultList) ;
            
            pResult = CONTAINING_RECORD(pleNode,
                                        UpdateResultList,
                                        URL_List) ;
            
            *pdwUpdateResult = pResult->URL_UpdateStatus;
            
            HeapFree(IPRouterHeap,
                     0,
                     pResult) ;
            
            dwResult = NO_ERROR ;
        }
    }
    else
    {
        Trace1(
            ANY,
            "GetInterfaceInfo : No interface with ICB number %d",
            HandleToULong(hInterface)
            );

        dwResult = ERROR_INVALID_INDEX;
    }
    
    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);

    TraceLeave("GetUpdateRoutesResult");
    
    ExitRouterApi();

    return dwResult;
}

DWORD
DemandDialRequest(
    IN DWORD dwProtocolId,
    IN DWORD dwInterfaceIndex
    )
{
    PICB    pIcb;
    DWORD   dwResult;
    HANDLE  hDim;

    EnterRouterApi();

    TraceEnter("DemandDialRequest");

    //
    // This doesnt follow the normal locking rules of not taking locks
    // when calling up
    //

    ENTER_READER(ICB_LIST);

    pIcb = InterfaceLookupByIfIndex(dwInterfaceIndex);

    if(pIcb is NULL)
    {
        EXIT_LOCK(ICB_LIST);

        return ERROR_INVALID_INDEX;
    }

    hDim = pIcb->hDIMHandle;

    EXIT_LOCK(ICB_LIST);

    dwResult = (ConnectInterface)(hDim,
                                  PID_IP);

    TraceLeave("DemandDialRequest");
    
    ExitRouterApi();

    return dwResult;
}

DWORD
RtrMgrMIBEntryCreate(
    IN DWORD   dwRoutingPid,
    IN DWORD   dwEntrySize,
    IN LPVOID  lpEntry
    )
{
    PMIB_OPAQUE_QUERY   pQuery;
    PMIB_OPAQUE_INFO    pInfo = (PMIB_OPAQUE_INFO)lpEntry;
    DWORD               dwInEntrySize,dwOutEntrySize, dwResult;
    BOOL                fCache;
    PPROTO_CB  pProtocolCb ;
    PLIST_ENTRY         pleNode ;
    DWORD               rgdwQuery[6];
    
    EnterRouterApi();;

    TraceEnter("RtrMgrMIBEntryCreate");
    
    pQuery = (PMIB_OPAQUE_QUERY)rgdwQuery;
    
    if(dwRoutingPid is IPRTRMGR_PID)
    {
        switch(pInfo->dwId)
        {
            case IP_FORWARDROW:
            {
                PMIB_IPFORWARDROW pRow = (PMIB_IPFORWARDROW)(pInfo->rgbyData);
                
                pQuery->dwVarId = IP_FORWARDROW;
                
                pQuery->rgdwVarIndex[0] = pRow->dwForwardDest;
                pQuery->rgdwVarIndex[1] = pRow->dwForwardProto;
                pQuery->rgdwVarIndex[2] = pRow->dwForwardPolicy;
                pQuery->rgdwVarIndex[3] = pRow->dwForwardNextHop;
                
                dwOutEntrySize  = dwEntrySize;
                dwInEntrySize   = sizeof(MIB_OPAQUE_QUERY) + 3 * sizeof(DWORD);
                
                dwResult = AccessIpForwardRow(ACCESS_CREATE_ENTRY,
                                              dwInEntrySize,
                                              pQuery,
                                              &dwOutEntrySize,
                                              pInfo,
                                              &fCache);
                

                break;
            }

            case ROUTE_MATCHING:
            {
                dwOutEntrySize = dwEntrySize;

                dwResult = AccessIpMatchingRoute(ACCESS_CREATE_ENTRY,
                                                 0, 
                                                 NULL,
                                                 &dwOutEntrySize,
                                                 pInfo,
                                                 &fCache);
                break;
            }
            
            case IP_NETROW:
            {
                PMIB_IPNETROW pRow = (PMIB_IPNETROW)(pInfo->rgbyData);
                
                pQuery->dwVarId = IP_NETROW;
                
                pQuery->rgdwVarIndex[0] = pRow->dwIndex;
                pQuery->rgdwVarIndex[1] = pRow->dwAddr;
                
                dwOutEntrySize = dwEntrySize;
                
                dwInEntrySize = sizeof(MIB_OPAQUE_QUERY) + sizeof(DWORD);
                
                dwResult = AccessIpNetRow(ACCESS_CREATE_ENTRY,
                                          dwInEntrySize,
                                          pQuery,
                                          &dwOutEntrySize,
                                          pInfo,
                                          &fCache);
                

                break;
            }

            case PROXY_ARP:
            {
                PMIB_PROXYARP pRow = (PMIB_PROXYARP)(pInfo->rgbyData);

                pQuery->dwVarId = IP_NETROW;

                pQuery->rgdwVarIndex[0] = pRow->dwAddress;
                pQuery->rgdwVarIndex[1] = pRow->dwMask;
                pQuery->rgdwVarIndex[2] = pRow->dwIfIndex;

                dwOutEntrySize = dwEntrySize;

                dwInEntrySize = sizeof(MIB_OPAQUE_QUERY) + (2 * sizeof(DWORD));

                dwResult = AccessProxyArp(ACCESS_CREATE_ENTRY,
                                          dwInEntrySize,
                                          pQuery,
                                          &dwOutEntrySize,
                                          pInfo,
                                          &fCache);


                break;
            }

            default:
            {
                dwResult = ERROR_INVALID_PARAMETER;
                
                break;
            }
        }
    }
    else
    {
        //
        // Send over to other pids
        //

        // *** Exclusion Begin ***
        ENTER_READER(PROTOCOL_CB_LIST);
        
        dwResult = ERROR_CAN_NOT_COMPLETE;

        for(pleNode = g_leProtoCbList.Flink; 
             pleNode != &g_leProtoCbList; 
             pleNode = pleNode->Flink) 
        {
            pProtocolCb = CONTAINING_RECORD(pleNode,
                                            PROTO_CB,
                                            leList);
            
            if (dwRoutingPid == pProtocolCb->dwProtocolId) 
            {
                dwResult = (pProtocolCb->pfnMibCreateEntry)(dwEntrySize,
                                                       lpEntry) ;
                break;
            }
        }

        // *** Exclusion End ***
        EXIT_LOCK(PROTOCOL_CB_LIST);

    }

    TraceLeave("RtrMgrMIBEntryCreate");
    
    ExitRouterApi();

    return dwResult;
}

DWORD
RtrMgrMIBEntryDelete(
    IN DWORD   dwRoutingPid,
    IN DWORD   dwEntrySize,
    IN LPVOID  lpEntry
    )
{
    DWORD               dwOutEntrySize = 0;
    PMIB_OPAQUE_QUERY   pQuery = (PMIB_OPAQUE_QUERY) lpEntry;
    DWORD               dwResult;
    BOOL                fCache;
    PPROTO_CB  pProtocolCb ;
    PLIST_ENTRY         pleNode ;

    
    EnterRouterApi();

    TraceEnter("RtrMgrMIBEntryDelete");

    if(dwRoutingPid is IPRTRMGR_PID)
    {
        switch(pQuery->dwVarId)
        {
            case IP_FORWARDROW:
            {
                dwResult = AccessIpForwardRow(ACCESS_DELETE_ENTRY,
                                              dwEntrySize,
                                              pQuery,
                                              &dwOutEntrySize,
                                              NULL,
                                              &fCache);
                break;
            }

            case ROUTE_MATCHING:
            {
                dwResult = AccessIpMatchingRoute(ACCESS_DELETE_ENTRY,
                                                 dwEntrySize,
                                                 pQuery,
                                                 &dwOutEntrySize,
                                                 NULL,
                                                 &fCache);
                break;
            }

            case IP_NETROW:
            {
                dwResult = AccessIpNetRow(ACCESS_DELETE_ENTRY,
                                          dwEntrySize,
                                          pQuery,
                                          &dwOutEntrySize,
                                          NULL,
                                          &fCache);
                break;
            }
            case PROXY_ARP:
            {
                dwResult = AccessProxyArp(ACCESS_DELETE_ENTRY,
                                          dwEntrySize,
                                          pQuery,
                                          &dwOutEntrySize,
                                          NULL,
                                          &fCache);
                break;
            }
            case IP_NETTABLE:
            {
                dwResult = AccessIpNetRow(ACCESS_DELETE_ENTRY,
                                          dwEntrySize,
                                          pQuery,
                                          &dwOutEntrySize,
                                          NULL,
                                          &fCache);
                break;
            }
            default:
            {
                dwResult = ERROR_INVALID_PARAMETER;
                break;
            }
        }
    }
    else
    {

        // *** Exclusion Begin ***
        ENTER_READER(PROTOCOL_CB_LIST);

        dwResult = ERROR_CAN_NOT_COMPLETE;

        for (pleNode = g_leProtoCbList.Flink; 
             pleNode != &g_leProtoCbList; 
             pleNode = pleNode->Flink) 
        {
            pProtocolCb = CONTAINING_RECORD(pleNode,
                                            PROTO_CB,
                                            leList);

            if(dwRoutingPid == pProtocolCb->dwProtocolId) 
            {
                dwResult = (pProtocolCb->pfnMibDeleteEntry)(dwEntrySize,
                                                       lpEntry);
                break ;
            }

        }

        // *** Exclusion End ***
        EXIT_LOCK(PROTOCOL_CB_LIST);

    }

    TraceLeave("RtrMgrMIBEntryDelete");
    
    ExitRouterApi();

    return dwResult;
    
}

DWORD
RtrMgrMIBEntrySet(
    IN DWORD  dwRoutingPid,
    IN DWORD  dwEntrySize,
    IN LPVOID lpEntry
    )
{
    PMIB_OPAQUE_QUERY   pQuery;
    PMIB_OPAQUE_INFO    pInfo = (PMIB_OPAQUE_INFO)lpEntry;
    DWORD               dwInEntrySize, dwOutEntrySize, dwResult=NO_ERROR;
    BOOL                fCache;
    PPROTO_CB  pProtocolCb ;
    PLIST_ENTRY         pleNode ;
    DWORD               rgdwQuery[6];
    
    EnterRouterApi();;

    TraceEnter("RtrMgrMIBEntrySet");

    pQuery = (PMIB_OPAQUE_QUERY)rgdwQuery;
    
    if(dwRoutingPid is IPRTRMGR_PID)
    {

        switch(pInfo->dwId)
        {
            case IF_ROW:
            {
                PMIB_IFROW  pRow = (PMIB_IFROW)(pInfo->rgbyData);
                
                pQuery->dwVarId = IF_ROW;
                
                pQuery->rgdwVarIndex[0] = pRow->dwIndex;
                
                dwOutEntrySize = dwEntrySize;
                
                dwInEntrySize  = sizeof(MIB_OPAQUE_QUERY);
                
                dwResult = AccessIfRow(ACCESS_SET,
                                       dwInEntrySize,
                                       pQuery,
                                       &dwOutEntrySize,
                                       pInfo,
                                       &fCache);
                

                break;
            }

            case TCP_ROW:
            {
                PMIB_TCPROW pRow = (PMIB_TCPROW)(pInfo->rgbyData);
                
                pQuery->dwVarId = TCP_ROW;
                
                pQuery->rgdwVarIndex[0] = pRow->dwLocalAddr;
                pQuery->rgdwVarIndex[1] = pRow->dwLocalPort;
                pQuery->rgdwVarIndex[2] = pRow->dwRemoteAddr;
                pQuery->rgdwVarIndex[3] = pRow->dwRemotePort;
                
                dwInEntrySize = sizeof(MIB_OPAQUE_QUERY) + (3 * sizeof(DWORD));
                
                dwOutEntrySize = dwEntrySize;
                
                dwResult = AccessTcpRow(ACCESS_SET,
                                        dwInEntrySize,
                                        pQuery,
                                        &dwOutEntrySize,
                                        pInfo,
                                        &fCache);
                
                break;
            }
            
            case IP_STATS:
            {
                PMIB_IPSTATS pStats = (PMIB_IPSTATS)(pInfo->rgbyData);
                
                pQuery->dwVarId = IP_STATS;
                
                dwInEntrySize = sizeof(MIB_OPAQUE_QUERY) - sizeof(DWORD);
                
                dwOutEntrySize = dwEntrySize;
                
                dwResult = AccessIpStats(ACCESS_SET,
                                         dwInEntrySize,
                                         pQuery,
                                         &dwOutEntrySize,
                                         pInfo,
                                         &fCache);
                
                break;
            }
              
            case IP_FORWARDROW:
            {
                PMIB_IPFORWARDROW pRow = (PMIB_IPFORWARDROW)(pInfo->rgbyData);
                
                pQuery->dwVarId = IP_FORWARDROW;
                
                pQuery->rgdwVarIndex[0] = pRow->dwForwardDest;
                pQuery->rgdwVarIndex[1] = pRow->dwForwardProto;
                pQuery->rgdwVarIndex[2] = pRow->dwForwardPolicy;
                pQuery->rgdwVarIndex[3] = pRow->dwForwardNextHop;

                dwOutEntrySize = dwEntrySize;
                
                dwInEntrySize = sizeof(MIB_OPAQUE_QUERY) + 3 * sizeof(DWORD);
                
                dwResult = AccessIpForwardRow(ACCESS_SET,
                                              dwInEntrySize,
                                              pQuery,
                                              &dwOutEntrySize,
                                              pInfo,
                                              &fCache);
                
                break;
            }

            case ROUTE_MATCHING:
            {
                dwOutEntrySize = dwEntrySize;

                dwResult = AccessIpMatchingRoute(ACCESS_SET,
                                                 0, 
                                                 NULL,
                                                 &dwOutEntrySize,
                                                 pInfo,
                                                 &fCache);
                break;
            }
            
            case IP_NETROW:
            {
                PMIB_IPNETROW pRow = (PMIB_IPNETROW)(pInfo->rgbyData);
                
                pQuery->dwVarId = IP_NETROW;
                
                pQuery->rgdwVarIndex[0] = pRow->dwIndex;
                pQuery->rgdwVarIndex[1] = pRow->dwAddr;
                
                dwOutEntrySize = dwEntrySize;
                
                dwInEntrySize = sizeof(MIB_OPAQUE_QUERY) + sizeof(DWORD);
                
                dwResult = AccessIpNetRow(ACCESS_SET,
                                          dwInEntrySize,
                                          pQuery,
                                          &dwOutEntrySize,
                                          pInfo,
                                          &fCache);
                
                break;
            }

            case MCAST_MFE:
            {
                dwResult = AccessMcastMfe(ACCESS_SET,
                                          0,
                                          NULL,
                                          &dwOutEntrySize,
                                          pInfo,
                                          &fCache); 

                break;
            }

            case MCAST_BOUNDARY:
            {
                dwResult = AccessMcastBoundary(ACCESS_SET,
                                          0,
                                          NULL,
                                          &dwOutEntrySize,
                                          pInfo,
                                          &fCache); 

                break;
            }

            case MCAST_SCOPE:
            {
                dwResult = AccessMcastScope(ACCESS_SET,
                                          0,
                                          NULL,
                                          &dwOutEntrySize,
                                          pInfo,
                                          &fCache); 

                break;
            }

            case PROXY_ARP:
            {
                 PMIB_PROXYARP pRow = (PMIB_PROXYARP)(pInfo->rgbyData);

                 pQuery->dwVarId = IP_NETROW;

                 pQuery->rgdwVarIndex[0] = pRow->dwAddress;
                 pQuery->rgdwVarIndex[1] = pRow->dwMask;
                 pQuery->rgdwVarIndex[2] = pRow->dwIfIndex;

                 dwOutEntrySize = dwEntrySize;

                 dwInEntrySize = sizeof(MIB_OPAQUE_QUERY) + (2 *  sizeof(DWORD));

                 dwResult = AccessProxyArp(ACCESS_CREATE_ENTRY,
                                           dwInEntrySize,
                                           pQuery,
                                           &dwOutEntrySize,
                                           pInfo,
                                           &fCache);
                 break;
            }
            
            default:
            {
                dwResult = ERROR_INVALID_PARAMETER;
                break;
            }
        }
    }
    else
    {
        // *** Exclusion Begin ***
        ENTER_READER(PROTOCOL_CB_LIST);

        dwResult = ERROR_CAN_NOT_COMPLETE;

        for (pleNode = g_leProtoCbList.Flink; 
             pleNode != &g_leProtoCbList; 
             pleNode = pleNode->Flink) 
        {
            pProtocolCb = CONTAINING_RECORD(pleNode,
                                            PROTO_CB,
                                            leList) ;

            if (dwRoutingPid == pProtocolCb->dwProtocolId) 
            {
                dwResult = (pProtocolCb->pfnMibSetEntry) (dwEntrySize, lpEntry) ;
                break ;
            }

        }

        // *** Exclusion End ***
        EXIT_LOCK(PROTOCOL_CB_LIST);

    }
    
    TraceLeave("RtrMgrMIBEntrySet");

    ExitRouterApi();

    return dwResult;
}

DWORD
RtrMgrMIBEntryGet(
    IN     DWORD      dwRoutingPid,
    IN     DWORD      dwInEntrySize,
    IN     LPVOID     lpInEntry,
    IN OUT LPDWORD    lpOutEntrySize,
    OUT    LPVOID     lpOutEntry
    )
{
    PMIB_OPAQUE_QUERY   pQuery = (PMIB_OPAQUE_QUERY)lpInEntry;
    PMIB_OPAQUE_INFO    pInfo = (PMIB_OPAQUE_INFO)lpOutEntry;
    BOOL                fCache;
    DWORD               dwResult;
    PPROTO_CB  pProtocolCb ;
    PLIST_ENTRY         pleNode ;

    EnterRouterApi();
    
    TraceEnter("RtrMgrMIBEntryGet");

    if(dwRoutingPid is IPRTRMGR_PID)
    {
        if(*lpOutEntrySize > 0)
        {
            ZeroMemory(lpOutEntry,
                       *lpOutEntrySize);
        }

        dwResult = (*g_AccessFunctionTable[pQuery->dwVarId])(ACCESS_GET,
                                                             dwInEntrySize,
                                                             pQuery,
                                                             lpOutEntrySize,
                                                             pInfo,
                                                             &fCache);
    }
    else
    {

        // *** Exclusion Begin ***
        ENTER_READER(PROTOCOL_CB_LIST);

        dwResult = ERROR_CAN_NOT_COMPLETE;

        for (pleNode = g_leProtoCbList.Flink; 
             pleNode != &g_leProtoCbList; 
             pleNode = pleNode->Flink) 
        {
            pProtocolCb = CONTAINING_RECORD(pleNode,
                                            PROTO_CB,
                                            leList);

            if (dwRoutingPid == pProtocolCb->dwProtocolId) 
            {
                dwResult = (pProtocolCb->pfnMibGetEntry) (dwInEntrySize,
                                                     lpInEntry, 
                                                     lpOutEntrySize,
                                                     lpOutEntry) ;
                break ;
            }
        }

        // *** Exclusion End ***
        EXIT_LOCK(PROTOCOL_CB_LIST);
    }
    
    TraceLeave("RtrMgrMIBEntryGet");
    
    ExitRouterApi();

    return dwResult;
}

DWORD
RtrMgrMIBEntryGetFirst(
    IN     DWORD     dwRoutingPid,
    IN     DWORD     dwInEntrySize,
    IN     LPVOID    lpInEntry,
    IN OUT LPDWORD   lpOutEntrySize,
    OUT    LPVOID    lpOutEntry
    )
{
    PMIB_OPAQUE_QUERY   pQuery = (PMIB_OPAQUE_QUERY)lpInEntry;
    PMIB_OPAQUE_INFO    pInfo = (PMIB_OPAQUE_INFO)lpOutEntry;
    DWORD               dwResult;
    BOOL                fCache;
    PPROTO_CB  pProtocolCb ;
    PLIST_ENTRY         pleNode ;

    EnterRouterApi();

    TraceEnter("RtrMgrMIBEntryGetFirst");

    if(dwRoutingPid is IPRTRMGR_PID)
    {
        if(*lpOutEntrySize > 0)
        {
            ZeroMemory(lpOutEntry,
                       *lpOutEntrySize);
        }

        dwResult = (*g_AccessFunctionTable[pQuery->dwVarId])(ACCESS_GET_FIRST,
                                                             dwInEntrySize,
                                                             pQuery,
                                                             lpOutEntrySize,
                                                             pInfo,
                                                             &fCache);
    }
    else
    {
        // *** Exclusion Begin ***
        ENTER_READER(PROTOCOL_CB_LIST);
        
        dwResult = ERROR_CAN_NOT_COMPLETE;

        for(pleNode = g_leProtoCbList.Flink; 
            pleNode != &g_leProtoCbList; 
            pleNode = pleNode->Flink) 
        {
            pProtocolCb = CONTAINING_RECORD(pleNode,
                                            PROTO_CB,
                                            leList) ;

            if (dwRoutingPid == pProtocolCb->dwProtocolId) 
            {
                dwResult = (pProtocolCb->pfnMibGetFirstEntry)(dwInEntrySize,
                                                              lpInEntry, 
                                                              lpOutEntrySize,
                                                              lpOutEntry);
                break;
            }
        }

        // *** Exclusion End ***
        EXIT_LOCK(PROTOCOL_CB_LIST);

    }

    TraceLeave("RtrMgrMIBEntryGetFirst");

    ExitRouterApi();

    return dwResult;
}

DWORD
RtrMgrMIBEntryGetNext(
    IN     DWORD      dwRoutingPid,
    IN     DWORD      dwInEntrySize,
    IN     LPVOID     lpInEntry,
    IN OUT LPDWORD    lpOutEntrySize,
    OUT    LPVOID     lpOutEntry
    )
{
    PMIB_OPAQUE_QUERY   pQuery = (PMIB_OPAQUE_QUERY)lpInEntry;
    PMIB_OPAQUE_INFO    pInfo = (PMIB_OPAQUE_INFO)lpOutEntry;
    DWORD               dwResult;
    BOOL                fCache;
    PPROTO_CB  pProtocolCb ;
    PLIST_ENTRY         pleNode ;

    EnterRouterApi();

    TraceEnter("RtrMgrMIBEntryGetNext");

    if(dwRoutingPid is IPRTRMGR_PID)
    {
        if(*lpOutEntrySize > 0)
        {
            ZeroMemory(lpOutEntry,
                       *lpOutEntrySize);
        }
    
        dwResult = (*g_AccessFunctionTable[pQuery->dwVarId])(ACCESS_GET_NEXT,
                                                             dwInEntrySize,
                                                             pQuery,
                                                             lpOutEntrySize,
                                                             pInfo,
                                                             &fCache);
    } 
    else
    {
        // *** Exclusion Begin ***
        ENTER_READER(PROTOCOL_CB_LIST);
        
        dwResult = ERROR_CAN_NOT_COMPLETE;
        
        for(pleNode = g_leProtoCbList.Flink; 
            pleNode != &g_leProtoCbList; 
            pleNode = pleNode->Flink) 
        { 
            pProtocolCb = CONTAINING_RECORD(pleNode,
                                            PROTO_CB,
                                            leList) ;
            
            if(dwRoutingPid == pProtocolCb->dwProtocolId) 
            {
                dwResult = (pProtocolCb->pfnMibGetNextEntry)(dwInEntrySize,
                                                             lpInEntry, 
                                                             lpOutEntrySize,
                                                             lpOutEntry);
                break;
            }
            
        }

        // *** Exclusion End ***
        EXIT_LOCK(PROTOCOL_CB_LIST);
    }

    TraceLeave("RtrMgrMIBEntryGetNext");

    ExitRouterApi();

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\iprtrmgr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\iprtrmgr.h

Abstract:

    Header for IP Router Manager

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/

#ifndef __RTRMGR_IPRTRMGR_H__
#define __RTRMGR_IPRTRMGR_H__


//
// Router State
//

typedef enum _RouterOperationalState 
{
    RTR_STATE_RUNNING,
    RTR_STATE_STOPPING,
    RTR_STATE_STOPPED
}RouterOperationalState, ProtocolOperationalState ;

typedef struct _IPRouterState 
{
    RouterOperationalState  IRS_State ;

    DWORD                   IRS_RefCount ;
}IPRouterState, *pIPRouterState ;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The following are the the operational states for WAN and LAN interfaces. //
// These are not the same as the MIB-II operational states.                 //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define NON_OPERATIONAL     IF_OPER_STATUS_NON_OPERATIONAL
#define UNREACHABLE         IF_OPER_STATUS_UNREACHABLE
#define DISCONNECTED        IF_OPER_STATUS_DISCONNECTED
#define CONNECTING          IF_OPER_STATUS_CONNECTING
#define CONNECTED           IF_OPER_STATUS_CONNECTED
#define OPERATIONAL         IF_OPER_STATUS_OPERATIONAL

//
// Control blocks for all Routing Protocols
//

#pragma warning(disable:4201)

typedef struct _PROTO_CB
{
    LIST_ENTRY                  leList;  
    ProtocolOperationalState    posOpState;     
    PWCHAR                      pwszDllName;     
    PWCHAR                      pwszDisplayName; 
    HINSTANCE                   hiHInstance;    
    MPR_ROUTING_CHARACTERISTICS;

}PROTO_CB, *PPROTO_CB;

#pragma warning(default:4201)

typedef struct _IF_PROTO
{
    LIST_ENTRY  leIfProtoLink;
    BOOL        bPromiscuous;
    PPROTO_CB   pActiveProto;
}IF_PROTO, *PIF_PROTO;

typedef struct _ICB_BINDING
{
    DWORD   dwAddress;
    DWORD   dwMask;
}ICB_BINDING, *PICB_BINDING;

typedef struct _GATEWAY_INFO
{
    DWORD   dwAddress;
    DWORD   dwIfIndex;
    DWORD   dwMetric;
}GATEWAY_INFO, *PGATEWAY_INFO;

#define MAX_DEFG    5

//
// Interface Control Block
//

typedef struct _ICB 
{
    //
    // Link into the doubly linked list of all interfaces
    //

    LIST_ENTRY              leIfLink;
    
    //
    // The interface index
    //

    DWORD                   dwIfIndex; 

    //
    // Link into the doubly linked list of interfaces hashed of the index
    //

    LIST_ENTRY              leHashLink;

    //
    // Link into doubly linked list of interfaces hashed on ICB seq. number
    //

    LIST_ENTRY              leICBHashLink;
    
    //
    // List of all the protocols on which the interface is added
    // (IF_PROTO structures)
    //

    LIST_ENTRY              leProtocolList;

    //
    // Pointer to interface name. The storage for the name is after the ICB
    //

    PWCHAR                  pwszName;

    //
    // Pointer to device name
    // Only used for internal interfaces
    //

    PWCHAR                  pwszDeviceName;

    DWORD                   dwSeqNumber;

    //
    // Handle from PfCreateInterface. Set to INVALID_HANDLE_VALUE if 
    // the interface was not/could not be created
    //

    INTERFACE_HANDLE        ihFilterInterface;
    INTERFACE_HANDLE        ihDemandFilterInterface;

    //
    // The filter info. We keep this here, because we dont have
    // a GET call from the filter driver
    //

    PFILTER_DESCRIPTOR      pInFilter;
    PFILTER_DESCRIPTOR      pOutFilter;
    PFILTER_DESCRIPTOR      pDemandFilter;

    BOOL                    bFragCheckEnable;

    //
    // Set to true when we are restoring routes
    //

    BOOL                    bRestoringRoutes;

    //
    // Type of the interface
    //

    ROUTER_INTERFACE_TYPE   ritType;
    NET_INTERFACE_TYPE      nitProtocolType;
    DWORD                   dwMediaType;
    WORD                    wAccessType;
    WORD                    wConnectionType;

    //
    // Operational and admin states
    //

    DWORD                   dwOperationalState;
    DWORD                   dwAdminState;

    //
    // Mcast state
    //

    BOOL                    bMcastEnabled;

    //
    // State of the connection
    //

    DWORD                   fConnectionFlags;

    //
    // DIM's handle for this interface
    //

    HANDLE                  hDIMHandle;

    //
    // Event to be signalled to inform DIM that an UpdateRoutes is completed.
    // A non NULL value => UpdateRoutes in progress
    //

    HANDLE                  hDIMNotificationEvent;

    //
    // The list of results
    //

    LIST_ENTRY              lePendingResultList;

    //
    // The router discovery information for this interface
    //

    ROUTER_DISC_CB          rdcRtrDiscInfo;

    //
    // Pointer to the advertisement. The memory for this is allocated from
    // the IPRouterHeap
    //

    PICMP_ROUTER_ADVT_MSG   pRtrDiscAdvt;
    WSABUF                  wsAdvtWSABuffer;
    DWORD                   dwRtrDiscAdvtSize;

#ifdef KSL_IPINIP
    //
    // IP in IP config
    //

    PIPINIP_CONFIG_INFO     pIpIpInfo;
#endif //KSL_IPINIP

    // 
    // The TTL scope for multicasts
    //

    DWORD                   dwMcastTtl;

    //
    // The rate limit for multicast traffic.
    //

    DWORD                   dwMcastRateLimit;

    //
    // The multicast heartbeat info
    //

    MCAST_HBEAT_CB          mhcHeartbeatInfo;

    //
    // For clients only
    //

    PINTERFACE_ROUTE_TABLE  pStoredRoutes;

    //
    // Stuff for IPAddressTable
    //

    //
    // Indicates whether the interface is bound or not
    //

    BOOL                    bBound;

    //
    // Set to true if we bumped up metric
    //

    BOOL                    bChangedMetrics;
    
    //
    // The rest of the fields are valid only if an interface is
    // bound
    //

    //DWORD                   dwAdapterId;
    DWORD                   dwBCastBit;
    DWORD                   dwReassemblySize;
    ULONG                   ulMtu;
    ULONGLONG               ullSpeed;

    DWORD                   dwGatewayCount;
   
    GATEWAY_INFO            Gateways[MAX_DEFG];

    //
    // dwNumAddresses may be 0 even if the interface is bound. This happens
    // when the interface is in unnumbered mode
    //

    DWORD                   dwNumAddresses;
    DWORD                   dwRemoteAddress;

    PICB_BINDING            pibBindings;

}ICB, *PICB;

//
// An adapter info is an alternate store for the binding info kept in 
// the ICB to avoid some deadlock conditions
// Even if this belongs to an unnumbered interface, we still have space
// for one ICB_BINDING, iow the minimum size is SIZEOF_ADAPTER_INFO(1)
// 

typedef struct _ADAPTER_INFO
{
    LIST_ENTRY              leHashLink;
    BOOL                    bBound;
    DWORD                   dwIfIndex;
    PICB                    pInterfaceCB;
    ROUTER_INTERFACE_TYPE   ritType;
    DWORD                   dwNumAddresses;
    DWORD                   dwRemoteAddress;
    DWORD                   dwBCastBit;
    DWORD                   dwReassemblySize;
    DWORD                   dwSeqNumber;
    
#if STATIC_RT_DBG
    BOOL        bUnreach;
#endif

    ICB_BINDING             rgibBinding[1];
}ADAPTER_INFO, *PADAPTER_INFO;

#define SIZEOF_ADAPTER_INFO(X)            \
    (FIELD_OFFSET(ADAPTER_INFO,rgibBinding[0]) + ((X) * sizeof(ICB_BINDING)))

#define NDISWAN_NOTIFICATION_RECEIVED   0x00000001
#define DDM_NOTIFICATION_RECEIVED       0x00000002
#define ALL_NOTIFICATIONS_RECEIVED      (NDISWAN_NOTIFICATION_RECEIVED | DDM_NOTIFICATION_RECEIVED)

#define INTERFACE_MARKED_FOR_DELETION   0x00000004

#define HasNdiswanNoticationBeenReceived(picb)  \
    ((picb)->fConnectionFlags & NDISWAN_NOTIFICATION_RECEIVED)

#define HasDDMNotificationBeenReceived(picb)    \
    ((picb)->fConnectionFlags & DDM_NOTIFICATION_RECEIVED)

#define IsInterfaceMarkedForDeletion(picb)      \
    ((picb)->fConnectionFlags & INTERFACE_MARKED_FOR_DELETION)

#define HaveAllNotificationsBeenReceived(picb)  \
    (((picb)->fConnectionFlags & ALL_NOTIFICATIONS_RECEIVED) == ALL_NOTIFICATIONS_RECEIVED)


#define ClearNotificationFlags(picb) ((picb)->fConnectionFlags = 0x00000000)

#define SetNdiswanNotification(picb)            \
    ((picb)->fConnectionFlags |= NDISWAN_NOTIFICATION_RECEIVED)

#define SetDDMNotification(picb)                \
    ((picb)->fConnectionFlags |= DDM_NOTIFICATION_RECEIVED)

#define MarkInterfaceForDeletion(picb)          \
    ((picb)->fConnectionFlags |= INTERFACE_MARKED_FOR_DELETION)

//
// List of NETMGMT routes that need to be restored to the stack
//

typedef struct _ROUTE_LIST_ENTRY
{
    LIST_ENTRY          leRouteList;
    MIB_IPFORWARDROW    mibRoute;
} ROUTE_LIST_ENTRY, *PROUTE_LIST_ENTRY;

//
// List of update route results
//

typedef struct _UpdateResultList 
{
    LIST_ENTRY      URL_List;
    DWORD           URL_UpdateStatus;
}UpdateResultList, *pUpdateResultList;

/*
typedef struct _ADAPTER_MAP
{
  LIST_ENTRY  leHashLink;
  DWORD       dwAdapterId;
  DWORD       dwIfIndex;
}ADAPTER_MAP, *PADAPTER_MAP;
*/

typedef struct _IP_CACHE
{
  PMIB_IPADDRTABLE      pAddrTable;
  PMIB_IPFORWARDTABLE   pForwardTable;
  PMIB_IPNETTABLE       pNetTable;
  DWORD                 dwTotalAddrEntries;
  DWORD                 dwTotalForwardEntries;
  DWORD                 dwTotalNetEntries;
}IP_CACHE, *PIP_CACHE;

typedef struct _TCP_CACHE
{
  PMIB_TCPTABLE         pTcpTable;
  DWORD                 dwTotalEntries;
}TCP_CACHE, *PTCP_CACHE;

typedef struct _UDP_CACHE
{
  PMIB_UDPTABLE         pUdpTable;
  DWORD                 dwTotalEntries;
}UDP_CACHE, *PUDP_CACHE;


DWORD
AddInterface(
    IN      LPWSTR lpwsInterfaceName,
    IN      LPVOID pInterfaceInfo,
    IN      ROUTER_INTERFACE_TYPE InterfaceType,
    IN      HANDLE hDIMInterface,
    IN OUT  HANDLE *phInterface
    );

DWORD
RouterBootComplete( 
    VOID
    );

DWORD
StopRouter(
    VOID
    );

DWORD
DeleteInterface(
    IN  HANDLE   hInterface
    );

DWORD
GetInterfaceInfo(
    IN      HANDLE  hInterface,
    OUT     LPVOID  pInterfaceInfo,
    IN OUT  LPDWORD lpdwInterfaceInfoSize
    );

DWORD
SetInterfaceInfo(
    IN  HANDLE  hInterface,
    IN  LPVOID  pInterfaceInfo
    );
                 
DWORD
InterfaceNotReachable(
    IN  HANDLE                  hInterface,
    IN  UNREACHABILITY_REASON   Reason
    );
                      
DWORD
InterfaceReachable(
    IN  HANDLE  hInterface
    );

DWORD
InterfaceConnected(
    IN   HANDLE  hInterface,
    IN   PVOID   pFilter,
    IN   PVOID   pPppProjectionResult
    );
                                         
DWORD 
UpdateRoutes(
    IN HANDLE hInterface, 
    IN HANDLE hEvent
    );

DWORD 
GetUpdateRoutesResult(
    IN HANDLE hInterface, 
    OUT LPDWORD pUpdateResult
    );

DWORD
SetGlobalInfo(
    IN  LPVOID  pGlobalInfo
    );
 
DWORD
GetGlobalInfo(
    OUT    LPVOID    pGlobalInfo,
    IN OUT LPDWORD   lpdwGlobalInfoSize
    );
             
DWORD
DemandDialRequest(
    IN DWORD dwProtocolId,
    IN DWORD dwInterfaceIndex
    );

DWORD 
RtrMgrMIBEntryCreate(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwEntrySize,
    IN      LPVOID          lpEntry
    );
                     

DWORD 
RtrMgrMIBEntryDelete(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwEntrySize,
    IN      LPVOID          lpEntry
    );
                     
DWORD 
RtrMgrMIBEntryGet(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwInEntrySize,
    IN      LPVOID          lpInEntry,
    IN OUT  LPDWORD         lpOutEntrySize,
    OUT     LPVOID          lpOutEntry
    );
                        
DWORD 
RtrMgrMIBEntryGetFirst(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwInEntrySize,
    IN      LPVOID          lpInEntry,
    IN OUT  LPDWORD         lpOutEntrySize,
    OUT     LPVOID          lpOutEntry
    );
                       
DWORD 
RtrMgrMIBEntryGetNext(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwInEntrySize,
    IN      LPVOID          lpInEntry,
    IN OUT  LPDWORD         lpOutEntrySize,
    OUT     LPVOID          lpOutEntry
    );

DWORD 
RtrMgrMIBEntrySet(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwEntrySize,
    IN      LPVOID          lpEntry
    );


#endif // __RTRMGR_IPRTRMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\load.c ===
/*++
Copyright (c) 1995  Microsoft Corporation


Module Name:

    routing\ip\load.c

Abstract:
    	
    The Load functions load the appropriate caches. They all follow a
    somewhat similar algorithm. They figure out how much space is needed
    for the cache. If there is a need to allocate memory, that is done.
    Then they read the tables from stack or RTM. They keep track of the
    space in the cache as the dwTotalEntries and the actual number of
    entries as the dwValidEntries

Revision History:

    Amritansh Raghav	      7/8/95  Created

--*/

#include "allinc.h"



int
__cdecl
CompareIpAddrRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    int iRes;

    PMIB_IPADDRROW  pRow1 = (PMIB_IPADDRROW)pvElem1;
    PMIB_IPADDRROW  pRow2 = (PMIB_IPADDRROW)pvElem2;

    InetCmp(pRow1->dwAddr,
            pRow2->dwAddr,
            iRes);

    return iRes;
}

int
__cdecl
CompareIpForwardRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    LONG lResult;

    PMIB_IPFORWARDROW   pRow1 = (PMIB_IPFORWARDROW)pvElem1;
    PMIB_IPFORWARDROW   pRow2 = (PMIB_IPFORWARDROW)pvElem2;

    if(InetCmp(pRow1->dwForwardDest,
               pRow2->dwForwardDest,
               lResult) isnot 0)
    {
        return lResult;
    }

    if(Cmp(pRow1->dwForwardProto,
           pRow2->dwForwardProto,
           lResult) isnot 0)
    {
        return lResult;
    }

    if(Cmp(pRow1->dwForwardPolicy,
           pRow2->dwForwardPolicy,
           lResult) isnot 0)
    {
        return lResult;
    }

    return InetCmp(pRow1->dwForwardNextHop,
                   pRow2->dwForwardNextHop,
                   lResult);
}

int
__cdecl
CompareIpNetRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    LONG lResult;

    PMIB_IPNETROW   pRow1 = (PMIB_IPNETROW)pvElem1;
    PMIB_IPNETROW   pRow2 = (PMIB_IPNETROW)pvElem2;

    if(Cmp(pRow1->dwIndex,
           pRow2->dwIndex,
           lResult) isnot 0)
    {
        return lResult;
    }
    else
    {
        return InetCmp(pRow1->dwAddr,
                       pRow2->dwAddr,
                       lResult);
    }
}

//
// Since all these are called from within UpdateCache, the appropriate
// lock is already being held as a writer so dont try and grab locks here
//

DWORD
LoadUdpTable(
    VOID
    )
/*++

Routine Description

    Loads the UDP cache from the stack

Locks

    UDP Cache lock must be taken as writer

Arguments

    None

Return Value
    NO_ERROR

--*/

{
    DWORD       dwResult;
    ULONG       ulRowsPresent,ulRowsNeeded;

    MIB_UDPSTATS    usInfo;

    dwResult = GetUdpStatsFromStack(&usInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "LoadUdpTable: Error %d trying to to determine table size",
               dwResult);

        TraceLeave("LoadUdpTable");

        return dwResult;
    }

    ulRowsNeeded  = usInfo.dwNumAddrs + SPILLOVER;
    ulRowsPresent = g_UdpInfo.dwTotalEntries;

    if((ulRowsNeeded > ulRowsPresent) or
       (ulRowsPresent - ulRowsNeeded > MAX_DIFF))
    {
        //
        // Need to allocate space
        //

        if(g_UdpInfo.pUdpTable)
        {
            HeapFree(g_hUdpHeap,
                     HEAP_NO_SERIALIZE,
                     g_UdpInfo.pUdpTable);
        }

        ulRowsPresent = ulRowsNeeded + MAX_DIFF;

        g_UdpInfo.pUdpTable = HeapAlloc(g_hUdpHeap,
                                        HEAP_NO_SERIALIZE,
                                        SIZEOF_UDPTABLE(ulRowsPresent));

        if(g_UdpInfo.pUdpTable is NULL)
        {
            Trace1(ERR,
                   "LoadUdpTable: Error allocating %d bytes for Udp table",
                   SIZEOF_UDPTABLE(ulRowsPresent));

            g_UdpInfo.dwTotalEntries = 0;

            TraceLeave("LoadUdpTable");

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        g_UdpInfo.dwTotalEntries = ulRowsPresent;
    }

    dwResult = GetUdpTableFromStack(g_UdpInfo.pUdpTable,
                                    SIZEOF_UDPTABLE(ulRowsPresent),
                                    TRUE);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "LoadUdpTable: NtStatus %x getting UdpTable from stack",
               dwResult);

        g_UdpInfo.pUdpTable->dwNumEntries = 0;
    }


    return dwResult;
}

DWORD
LoadTcpTable(
    VOID
    )
/*++

Routine Description

    Loads the TCP cache from the stack

Locks

    TCP Cache lock must be taken as writer

Arguments

    None

Return Value
    NO_ERROR

--*/

{
    DWORD       dwResult;
    ULONG       ulRowsPresent,ulRowsNeeded;

    MIB_TCPSTATS    tsInfo;

    dwResult = GetTcpStatsFromStack(&tsInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "LoadTcpTable: Error %d trying to determince table size",
                dwResult);

        TraceLeave("LoadTcpTable");

        return dwResult;
    }

    ulRowsNeeded    = tsInfo.dwNumConns + SPILLOVER;
    ulRowsPresent   = g_TcpInfo.dwTotalEntries;

    if((ulRowsNeeded > ulRowsPresent) or
       (ulRowsPresent - ulRowsNeeded > MAX_DIFF))
    {
        if(g_TcpInfo.pTcpTable)
        {	
            HeapFree(g_hTcpHeap,
                     HEAP_NO_SERIALIZE,
                     g_TcpInfo.pTcpTable);
        }

        ulRowsPresent       = ulRowsNeeded + MAX_DIFF;

        g_TcpInfo.pTcpTable = HeapAlloc(g_hTcpHeap,
                                        HEAP_NO_SERIALIZE,
                                        SIZEOF_TCPTABLE(ulRowsPresent));

        if(g_TcpInfo.pTcpTable is NULL)
        {
            Trace1(ERR,
                   "LoadTcpTable: Error allocating %d bytes for tcp table",
                   SIZEOF_TCPTABLE(ulRowsPresent));

            g_TcpInfo.dwTotalEntries = 0;

            TraceLeave("LoadTcpTable");

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        g_TcpInfo.dwTotalEntries = ulRowsPresent;
    }

    dwResult = GetTcpTableFromStack(g_TcpInfo.pTcpTable,
                                    SIZEOF_TCPTABLE(ulRowsPresent),
                                    TRUE);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "LoadTcpTable: NtStatus %x load TcpTable from stack",
               dwResult);

        g_TcpInfo.pTcpTable->dwNumEntries = 0;
    }


    return dwResult;
}

DWORD
LoadIpAddrTable(
    VOID
    )
/*++

Routine Description

    Loads the IPAddress cache. Unlike the other functions, this cache is
    loaded from the BINDING list kept in user mode. The binding list is
    however kept in a hash table (with no thread linking all the addresses
    in lexicographic order).  Thus we just copy out all the address and then
    run qsort() over them

Locks

    The IP Address Cache lock must be taken as writer

Arguments

    None

Return Value
    NO_ERROR

--*/

{
    ULONG       ulRowsPresent,ulRowsNeeded;
    DWORD       dwIndex, i, j;

    PLIST_ENTRY     pleNode;
    PADAPTER_INFO   pBind;


    ENTER_READER(BINDING_LIST);

    ulRowsNeeded  = g_ulNumBindings + SPILLOVER;
    ulRowsPresent = g_IpInfo.dwTotalAddrEntries;

    if((ulRowsNeeded > ulRowsPresent) or
       (ulRowsPresent - ulRowsNeeded > MAX_DIFF))
    {
        if(g_IpInfo.pAddrTable)
        {
            HeapFree(g_hIpAddrHeap,
                     HEAP_NO_SERIALIZE,
                     g_IpInfo.pAddrTable);
        }

        ulRowsPresent       = ulRowsNeeded + MAX_DIFF;

        g_IpInfo.pAddrTable = HeapAlloc(g_hIpAddrHeap,
                                        HEAP_NO_SERIALIZE,
                                        SIZEOF_IPADDRTABLE(ulRowsPresent));

        if(g_IpInfo.pAddrTable is NULL)
        {
            EXIT_LOCK(ICB_LIST);


            Trace1(ERR,
                   "LoadIpAddrTable: Error allocating %d bytes for table",
                   SIZEOF_IPADDRTABLE(ulRowsPresent));

            g_IpInfo.dwTotalAddrEntries = 0;

            TraceLeave("LoadIpAddrTable");

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        g_IpInfo.dwTotalAddrEntries = ulRowsPresent;
    }

    dwIndex = 0;

    for(i = 0;
        i < BINDING_HASH_TABLE_SIZE;
        i++)
    {
        for(pleNode = g_leBindingTable[i].Flink;
            pleNode isnot &g_leBindingTable[i];
            pleNode = pleNode->Flink)
        {
            pBind = CONTAINING_RECORD(pleNode,
                                      ADAPTER_INFO,
                                      leHashLink);

            if(!pBind->bBound)
            {
                continue;
            }

            //
            // If the nte is bound, but has no address, we still have
            // space for 1 address
            //

            for(j = 0;
                j < (pBind->dwNumAddresses? pBind->dwNumAddresses : 1);
                j++)
            {
                g_IpInfo.pAddrTable->table[dwIndex].dwIndex     =
                    pBind->dwIfIndex;

                g_IpInfo.pAddrTable->table[dwIndex].dwBCastAddr =
                    pBind->dwBCastBit;

                g_IpInfo.pAddrTable->table[dwIndex].dwReasmSize =
                    pBind->dwReassemblySize;

                g_IpInfo.pAddrTable->table[dwIndex].dwAddr      =
                    pBind->rgibBinding[j].dwAddress;

                g_IpInfo.pAddrTable->table[dwIndex].dwMask      =
                    pBind->rgibBinding[j].dwMask;

                g_IpInfo.pAddrTable->table[dwIndex].wType     = 1;

                dwIndex++;
            }
        }
    }

    g_IpInfo.pAddrTable->dwNumEntries = dwIndex;

    EXIT_LOCK(BINDING_LIST);

    if(g_IpInfo.pAddrTable->dwNumEntries > 0)
    {
        qsort(g_IpInfo.pAddrTable->table,
              dwIndex,
              sizeof(MIB_IPADDRROW),
              CompareIpAddrRow);
    }

    return NO_ERROR;
}

DWORD
LoadIpForwardTable(
    VOID
    )
/*++

Routine Description

    Loads the UDP cache from the stack

Locks

    UDP Cache lock must be taken as writer

Arguments

    None

Return Value
    NO_ERROR

--*/

{
    HANDLE            hRtmEnum;
    PHANDLE           hRoutes;
    PRTM_NET_ADDRESS  pDestAddr;
    PRTM_ROUTE_INFO   pRoute;
    RTM_NEXTHOP_INFO  nhiInfo;
    RTM_ENTITY_INFO   entityInfo;
    DWORD             dwCount;
    DWORD             dwResult;
    DWORD             dwRoutes;
    DWORD             i,j;
    IPSNMPInfo        ipsiInfo;
    ULONG             ulRowsPresent,ulRowsNeeded;
    ULONG             ulEntities;
    RTM_ADDRESS_FAMILY_INFO rtmAddrFamilyInfo;
    LPVOID            Tmp;
    
    //
    // Get the number of destinations in the RTM's table
    //

    dwResult = RtmGetAddressFamilyInfo(0, // routerId
                                       AF_INET,
                                       &rtmAddrFamilyInfo,
                                       &ulEntities,
                                       NULL);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "LoadIpForwardTable: Error %d getting number of destinations",
               dwResult);

        return dwResult;
    }

    //
    // Use an enumeration to retrieve routes from RTM
    //

    dwResult = RtmCreateRouteEnum(g_hLocalRoute,
                                  NULL,
                                  RTM_VIEW_MASK_UCAST,
                                  RTM_ENUM_ALL_ROUTES,
                                  NULL,
                                  0,
                                  NULL,
                                  0,
                                  &hRtmEnum);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "LoadIpForwardTable: Error %d creating RTM enumeration handle",
               dwResult);

        return dwResult;
    }

    ulRowsNeeded  = rtmAddrFamilyInfo.NumDests + SPILLOVER;
    ulRowsPresent = g_IpInfo.dwTotalForwardEntries;

    if((ulRowsNeeded > ulRowsPresent) or
       (ulRowsPresent - ulRowsNeeded > MAX_DIFF))
    {
        if(g_IpInfo.pForwardTable)
        {
            HeapFree(g_hIpForwardHeap,
                     HEAP_NO_SERIALIZE,
                     g_IpInfo.pForwardTable);
        }

        ulRowsPresent = ulRowsNeeded + MAX_DIFF;

        g_IpInfo.pForwardTable = HeapAlloc(g_hIpForwardHeap,
                                           HEAP_NO_SERIALIZE,
                                           SIZEOF_IPFORWARDTABLE(ulRowsPresent));

        if(g_IpInfo.pForwardTable is NULL)
        {
            Trace1(ERR,
                   "LoadIpForwardTable: Error allocating %d bytes for forward table",
                   SIZEOF_IPFORWARDTABLE(ulRowsPresent));

            g_IpInfo.dwTotalForwardEntries = 0;

            RtmDeleteEnumHandle(g_hLocalRoute, hRtmEnum);

            TraceLeave("LoadIpForwardTable");

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        g_IpInfo.dwTotalForwardEntries = ulRowsPresent;
    }

    //
    // Routes are enum'ed from the RTM route table
    //

    pRoute = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                );

    if (pRoute == NULL)
    {
        TraceLeave("LoadIpForwardTable");

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pDestAddr = HeapAlloc(
                IPRouterHeap,
                0,
                sizeof(RTM_NET_ADDRESS)
                );

    if (pDestAddr == NULL)
    {
        TraceLeave("LoadIpForwardTable");

        HeapFree(IPRouterHeap, 0, pRoute);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    hRoutes = HeapAlloc(
                IPRouterHeap,
                0,
                g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                );

    if (hRoutes == NULL)
    {
        TraceLeave("LoadIpForwardTable");

        HeapFree(IPRouterHeap, 0, pRoute);
        
        HeapFree(IPRouterHeap, 0, pDestAddr);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwCount = 0;

    do
    {
        // Get next set of routes in RTM table

        dwRoutes = g_rtmProfile.MaxHandlesInEnum;

        RtmGetEnumRoutes(g_hLocalRoute,
                         hRtmEnum,
                         &dwRoutes,
                         hRoutes);

        for (i = 0; i < dwRoutes; i++)
        {
            // Get the route info given the route handle

            dwResult = RtmGetRouteInfo(g_hLocalRoute,
                                       hRoutes[i],
                                       pRoute,
                                       pDestAddr);

            // Route would have got deleted meanwhile

            if (dwResult isnot NO_ERROR)
            {
                continue;
            }

            // Process info for the route from above

            // This route with multiple next hops
            // might end up as multiple ip routes
            if(dwCount + pRoute->NextHopsList.NumNextHops
                    > g_IpInfo.dwTotalForwardEntries)
            {
                //
                // Hmm - we accounted for spillover and still have extra routes
                // Lets double the route table
                //

                g_IpInfo.dwTotalForwardEntries =
                    (g_IpInfo.dwTotalForwardEntries)<<1;

                // Are we still short in terms of number of routes required ?
                if (g_IpInfo.dwTotalForwardEntries <
                        dwCount + pRoute->NextHopsList.NumNextHops)
                {
                    g_IpInfo.dwTotalForwardEntries =
                        dwCount + pRoute->NextHopsList.NumNextHops;
                }

                
                Tmp =  HeapReAlloc(g_hIpForwardHeap,
                                HEAP_NO_SERIALIZE,
                                g_IpInfo.pForwardTable,
                                SIZEOF_IPFORWARDTABLE(g_IpInfo.dwTotalForwardEntries));

                if( Tmp is NULL)
                {
                    Trace1(ERR,
                           "LoadIpForwardTable: Error reallocating %d bytes for forward table",
                           SIZEOF_IPFORWARDTABLE(g_IpInfo.dwTotalForwardEntries));

                    if (g_IpInfo.pForwardTable)
                    {
                        HeapFree(g_hIpForwardHeap,
                             HEAP_NO_SERIALIZE,
                             g_IpInfo.pForwardTable);
                    }

                    g_IpInfo.pForwardTable = NULL;
                    g_IpInfo.dwTotalForwardEntries = 0;

                    RtmReleaseRouteInfo(g_hLocalRoute, pRoute);

                    RtmReleaseRoutes(g_hLocalRoute, dwRoutes, hRoutes);

                    RtmDeleteEnumHandle(g_hLocalRoute, hRtmEnum);

                    HeapFree(IPRouterHeap, 0, pRoute);
                    
                    HeapFree(IPRouterHeap, 0, pDestAddr);

                    HeapFree(IPRouterHeap, 0, hRoutes);

                    TraceLeave("LoadIpForwardTable");

                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    g_IpInfo.pForwardTable = Tmp;
                }
            }

            if (RtmGetEntityInfo(g_hLocalRoute,
                                 pRoute->RouteOwner,
                                 &entityInfo) is NO_ERROR)
            {
                // Try getting the nexthop information from the route

                for (j = 0; j < pRoute->NextHopsList.NumNextHops; j++)
                {
                    if (RtmGetNextHopInfo(g_hLocalRoute,
                                          pRoute->NextHopsList.NextHops[j],
                                          &nhiInfo) is NO_ERROR)
                    {
                        ConvertRtmToRouteInfo(entityInfo.EntityId.EntityProtocolId,
                                                 pDestAddr,
                                                 pRoute,
                                                 &nhiInfo,
                                                 (PINTERFACE_ROUTE_INFO)&(g_IpInfo.pForwardTable->table[dwCount++]));

                        RtmReleaseNextHopInfo(g_hLocalRoute, &nhiInfo);
                    }
                }
            }

            RtmReleaseRouteInfo(g_hLocalRoute, pRoute);
        }

        RtmReleaseRoutes(g_hLocalRoute, dwRoutes, hRoutes);
    }
    while (dwRoutes != 0);

    RtmDeleteEnumHandle(g_hLocalRoute, hRtmEnum);

    g_IpInfo.pForwardTable->dwNumEntries = dwCount;

    if(dwCount > 0)
    {
        qsort(g_IpInfo.pForwardTable->table,
              dwCount,
              sizeof(MIB_IPFORWARDROW),
              CompareIpForwardRow);
    }

    HeapFree(IPRouterHeap, 0, pRoute);
    
    HeapFree(IPRouterHeap, 0, pDestAddr);

    HeapFree(IPRouterHeap, 0, hRoutes);

    return NO_ERROR;
}


DWORD
LoadIpNetTable(
    VOID
    )
/*++

Routine Description

    Loads the UDP cache from the stack

Locks

    UDP Cache lock must be taken as writer

Arguments

    None

Return Value
    NO_ERROR

--*/

{
    DWORD		dwResult, i;
    BOOL		fUpdate;

    //
    // Arp entries change so fast that we deallocate the table
    // every time
    //

    if(g_IpInfo.pNetTable isnot NULL)
    {
        HeapFree(g_hIpNetHeap,
                 HEAP_NO_SERIALIZE,
                 g_IpInfo.pNetTable);
    }

    dwResult = AllocateAndGetIpNetTableFromStack(&(g_IpInfo.pNetTable),
                                                 FALSE,
                                                 g_hIpNetHeap,
                                                 HEAP_NO_SERIALIZE,
                                                 FALSE);
    if(dwResult is NO_ERROR)
    {
        Trace0(MIB,
               "LoadIpNetTable: Succesfully loaded net table");
    }
    else
    {
        HeapFree(g_hIpNetHeap,
                 HEAP_NO_SERIALIZE,
                 g_IpInfo.pNetTable);

        g_IpInfo.pNetTable  = NULL;

        Trace1(ERR,
               "LoadIpNetTable: NtStatus %x loading IpNetTable from stack",
               dwResult);
    }

    if((g_IpInfo.pNetTable isnot NULL) and
       (g_IpInfo.pNetTable->dwNumEntries > 0))
    {
        qsort(g_IpInfo.pNetTable->table,
              g_IpInfo.pNetTable->dwNumEntries,
              sizeof(MIB_IPNETROW),
              CompareIpNetRow);
    }

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\locate.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\locate.h

Abstract:

    Header for locate.c

Revision History:

    Gurdeep Singh Pall          6/26/95  Created

--*/


DWORD
LocateIfRow(
    DWORD   dwQueryType,
    DWORD   dwNumIndices,
    PDWORD  pdwIndex,
    ICB     **ppicb,
    BOOL    bNoClient
    );

DWORD
LocateIpAddrRow(
    DWORD   dwQueryType,
    DWORD   dwNumIndices,
    PDWORD  pdwIndex,
    PDWORD  pdwRetIndex
    );

DWORD
LocateIpForwardRow(
    DWORD   dwQueryType,
    DWORD   dwNumIndices,
    PDWORD  pdwIndex,
    PDWORD  pdwRetIndex
    );

DWORD
LocateIpNetRow(
    DWORD dwQueryType,
    DWORD dwNumIndices,
    PDWORD  pdwIndex,
    PDWORD  pdwRetIndex
    );

DWORD
LocateUdpRow(
    DWORD   dwQueryType,
    DWORD   dwNumIndices,
    PDWORD  pdwIndex,
    PDWORD  pdwRetIndex
    );

DWORD
LocateTcpRow(
    DWORD   dwQueryType,
    DWORD   dwNumIndices,
    PDWORD  pdwIndex,
    PDWORD  pdwRetIndex
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\locate.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\locate.c

Abstract:

    The LocateXXXRow Functions are passed a variable sized array of 
    indices, a count of the number of indices passed and the type of search
    that needs to be executed. There are three types of searches:
    Locate the first item (ACCESS_GET_FIRST)
    Locate the next item  (ACCESS_GET_NEXT)
    Locate the exact item (ACCESS_GET, ACCESS_SET, ACCESS_CREATE_ENTRY
                           ACCESS_DELETE_ENTRY)

    The functions fill in the index of the corresponding row and return 

    NO_ERROR            if an item matching the indices and criterion was found
    ERROR_NO_DATA       if no item is found 
    ERROR_INVALID_INDEX
    ERROR_NO_MORE_ITEMS 

    The general search algorithm is this:

    If the table is empty
        return ERROR_NO_DATA
	
	If the query is a LOCATE_FIRST
	    return the first row
	
	Build the index as follows:

    Set the Index to all 0s
    From the number of indices passed  figure out how much of the index
    can be built keeping the rest 0.
    If the query is a LOCATE_EXACT then the complete index must be given.
    This check is, however, supposed to be done by the caller
    If the full index has not been given, the index is deemed to be
    modified (Again this can only happen in the LOCATE_NEXT case).
    Once the index is created, a search is done.
    We try for an exact match with the index. For all queries other than
    LOCATE_NEXT there is no problem.
    For LOCATE_NEXT there are two cases:

        If the complete index was given and we get an exact match, then we
        return the next entry.
        If we dont get an exact match we return the next higher entry
        If an incomplete index was given and we modified it by padding 0s, 
        and if an exact match is found, then we return the matching entry
        (Of course if an exact match is not found just return the next
        higher entry)

    ALL THESE FUNCTION ARE CALLED WITH THE LOCK OF THE RESPECTIVE CACHE
    HELD ATLEAST AS READER
    
Revision History:

    Amritansh Raghav          6/8/95  Created

--*/

#include "allinc.h"

#define LOCAL_ADDR  0
#define LOCAL_PORT  1
#define REM_ADDR    2
#define REM_PORT    3

	

DWORD  
LocateIfRow(
    DWORD   dwQueryType, 
    DWORD   dwNumIndices,
    PDWORD  pdwIndex, 
    ICB     **ppicb,
    BOOL    bNoClient 
    )
{
    PLIST_ENTRY currentList,startIndex,stopIndex ;
    DWORD       dwIndex = 0;
    BOOL        fNext, fModified;
    PICB        pIf;
    
    *ppicb = NULL;
    
    if(g_ulNumInterfaces is 0)
    {
        if(EXACT_MATCH(dwQueryType))
        {
            return ERROR_INVALID_INDEX;
        }

        if(dwQueryType is ACCESS_GET_FIRST)
        {
            return ERROR_NO_DATA;
        }

        return ERROR_NO_MORE_ITEMS;
    }

    
    if(dwQueryType is ACCESS_GET_FIRST)
    {
        
        if(bNoClient)
        {
            for(currentList  = ICBList.Flink;
                currentList isnot &ICBList;
                currentList  = currentList->Flink)
            {
                //
                // Find the first one which is not internal loopback
                // or client
                //

                pIf = CONTAINING_RECORD (currentList, ICB, leIfLink);
                
                if(pIf->ritType is ROUTER_IF_TYPE_CLIENT)
                {
                    continue;
                }

                *ppicb = pIf;

                break;
            }
        }
        else
        {
            *ppicb = CONTAINING_RECORD(ICBList.Flink,
                                       ICB,
                                       leIfLink);
        }

        if(*ppicb)
        {
            return NO_ERROR;
        }
        else
        {
            return ERROR_NO_DATA;
        }
    }

    fModified = TRUE;
    
    if(dwNumIndices > 0)
    {
        dwIndex = pdwIndex[0];
        
        fModified = FALSE;
    }

    //
    // Should we take the match or the next entry in case of an exact match?
    //
    
    fNext = (dwQueryType is ACCESS_GET_NEXT) and (fModified is FALSE);
    
    
    startIndex = ICBList.Flink;
    stopIndex  = &ICBList;
    
    for(currentList = startIndex;
        currentList isnot stopIndex;
        currentList = currentList->Flink)
    {
        *ppicb = CONTAINING_RECORD(currentList,
                                   ICB,
                                   leIfLink) ;

        if(bNoClient and
           ((*ppicb)->ritType is ROUTER_IF_TYPE_CLIENT))
        {
            //
            // Go to the next one
            //

            continue;
        }
        
        if((dwIndex is (*ppicb)->dwIfIndex) and !fNext)
        {
            //
            // Found it
            //

            return NO_ERROR;
        }
        
        if(dwIndex < (*ppicb)->dwIfIndex)
        {
            if(dwQueryType is ACCESS_GET_NEXT)
            {
                return NO_ERROR;
            }
            else
            {
                //
                // Since the list is ordered we wont find this index further on
                //

                *ppicb = NULL;
                
                return ERROR_INVALID_INDEX;
            }
        }
    }

    return ERROR_NO_MORE_ITEMS;
}

DWORD 
LocateIpAddrRow(
    DWORD   dwQueryType, 
    DWORD   dwNumIndices,
    PDWORD  pdwIndex, 
    PDWORD  pdwRetIndex
    )
{
    DWORD dwIpAddr;
    DWORD dwResult, startIndex, stopIndex;
    LONG  lCompare;
    DWORD i;
    BOOL  fNext, fModified;
    
    if((g_IpInfo.pAddrTable is NULL) or
       (g_IpInfo.pAddrTable->dwNumEntries is 0))
    {
        if(EXACT_MATCH(dwQueryType))
        {
            return ERROR_INVALID_INDEX;
        }
       
        if(dwQueryType is ACCESS_GET_FIRST)
        {
            return ERROR_NO_DATA;
        }

        return ERROR_NO_MORE_ITEMS;
    }
    
    if(dwQueryType is ACCESS_GET_FIRST)
    {
        *pdwRetIndex = 0;
        
        return NO_ERROR;
    }
    
    if(dwNumIndices > 0)
    {
        dwIpAddr = pdwIndex[0];
        
        fModified = FALSE;
    }
    else
    {
        dwIpAddr = 0;
        
        fModified = TRUE;
    }
    
    fNext = (dwQueryType is ACCESS_GET_NEXT) and (fModified is FALSE);
  
    startIndex = 0;
    stopIndex  = g_IpInfo.pAddrTable->dwNumEntries;
    
    for(i = startIndex; i < stopIndex; i++)
    {
        lCompare = InetCmp(dwIpAddr,
                           g_IpInfo.pAddrTable->table[i].dwAddr,
                           lCompare);
        
        if((lCompare is 0) and !fNext)
        {
            *pdwRetIndex = i;
            
            return NO_ERROR;
        }
        
        if(lCompare < 0)
        {
            if(dwQueryType is ACCESS_GET_NEXT)
            {
                *pdwRetIndex = i;
                
                return NO_ERROR;
            }
            else
            {
                return ERROR_INVALID_INDEX;
            }
        }
    }

    return ERROR_NO_MORE_ITEMS;
}

DWORD 
LocateIpForwardRow(
    DWORD   dwQueryType, 
    DWORD   dwNumIndices,
    PDWORD  pdwIndex, 
    PDWORD  pdwRetIndex
    )
{
    DWORD rgdwIpForwardIndex[4];
    DWORD dwResult,startIndex, stopIndex;
    LONG  lCompare;
    DWORD i;
    BOOL  fNext,fModified;
    
    if((g_IpInfo.pForwardTable is NULL) or
       (g_IpInfo.pForwardTable->dwNumEntries is 0))
    {
        if(EXACT_MATCH(dwQueryType))
        {
            return ERROR_INVALID_INDEX;
        }

        if(dwQueryType is ACCESS_GET_FIRST)
        {
            return ERROR_NO_DATA;
        }

        return ERROR_NO_MORE_ITEMS;
    }
    
    if(dwQueryType is ACCESS_GET_FIRST)
    {
        *pdwRetIndex = 0;
        
        return NO_ERROR;
    }
    
    // Quick way to copy the valid part of index
    // TBD: just might want to asssert the sizes
    
    ZeroMemory(rgdwIpForwardIndex,
               4*sizeof(DWORD));
    
    memcpy(rgdwIpForwardIndex,
           pdwIndex,
           dwNumIndices * sizeof(DWORD));

    //
    // We have modified it if the index is not the exact size
    //
    
    if(dwNumIndices isnot 4)
    {
        fModified = TRUE;
    }
    else
    {
        fModified = FALSE;
    }
    
    fNext = (dwQueryType is ACCESS_GET_NEXT) and (fModified is FALSE);
    
    startIndex = 0;
    stopIndex  = g_IpInfo.pForwardTable->dwNumEntries;
  
    for(i = startIndex; i < stopIndex; i++)
    {
        lCompare =
            IpForwardCmp(rgdwIpForwardIndex[0],
                         rgdwIpForwardIndex[1],
                         rgdwIpForwardIndex[2],
                         rgdwIpForwardIndex[3],
                         g_IpInfo.pForwardTable->table[i].dwForwardDest,
                         g_IpInfo.pForwardTable->table[i].dwForwardProto,
                         g_IpInfo.pForwardTable->table[i].dwForwardPolicy,
                         g_IpInfo.pForwardTable->table[i].dwForwardNextHop);
        
        if((lCompare is 0) and !fNext)
        {
            *pdwRetIndex = i;
            
            return NO_ERROR;
        }
        
        if(lCompare < 0)
        {
            if(dwQueryType is ACCESS_GET_NEXT)
            {
                *pdwRetIndex = i;
                
                return NO_ERROR;
            }
            else
            {
                return ERROR_INVALID_INDEX;
            }
        }
    }
    
    return ERROR_NO_MORE_ITEMS;
}

DWORD 
LocateIpNetRow(
    DWORD dwQueryType, 
    DWORD dwNumIndices,
    PDWORD  pdwIndex, 
    PDWORD  pdwRetIndex
    )
{
    DWORD dwResult,i;
    LONG  lCompare;
    DWORD dwIpNetIfIndex,dwIpNetIpAddr;
    BOOL  fNext, fModified;
    DWORD startIndex,stopIndex;
    
    if((g_IpInfo.pNetTable is NULL) or
       (g_IpInfo.pNetTable->dwNumEntries is 0))
    {
        if(EXACT_MATCH(dwQueryType))
        {
            return ERROR_INVALID_INDEX;
        }

        if(dwQueryType is ACCESS_GET_FIRST)
        {
            return ERROR_NO_DATA;
        }

        return ERROR_NO_MORE_ITEMS;
    }
    
    if(dwQueryType is ACCESS_GET_FIRST)
    {
        *pdwRetIndex = 0;
        
        return NO_ERROR;
    }
    
	

    switch(dwNumIndices)
    {
        case 0:
        {
            dwIpNetIfIndex = 0;
            dwIpNetIpAddr  = 0;
            
            fModified = TRUE;
            
            break;
        }
        
        case 1:
        {
            dwIpNetIfIndex = pdwIndex[0];
            
            dwIpNetIpAddr  = 0;
            
            fModified = TRUE;
            
            break;
        }
        
        case 2:
        {
            dwIpNetIfIndex = pdwIndex[0];
            
            dwIpNetIpAddr  = pdwIndex[1];
            
            fModified = FALSE;
            
            break;
        }
        
        default:
        {
            return ERROR_INVALID_INDEX;
        }
    }
    
    
    fNext = (dwQueryType is ACCESS_GET_NEXT) and (fModified is FALSE);
	
    startIndex  = 0;
    stopIndex   = g_IpInfo.pNetTable->dwNumEntries;
    
    for(i = startIndex; i < stopIndex; i++)
    {
        lCompare = IpNetCmp(dwIpNetIfIndex,
                            dwIpNetIpAddr, 
                            g_IpInfo.pNetTable->table[i].dwIndex,
                            g_IpInfo.pNetTable->table[i].dwAddr);
    
        if((lCompare is 0) and !fNext)
        {
            *pdwRetIndex = i;
            
            return NO_ERROR;
        }
        
        if(lCompare < 0)
        {
            if(dwQueryType is ACCESS_GET_NEXT)
            {
                *pdwRetIndex = i;
                
                return NO_ERROR;
            }
            else
            {
                return ERROR_INVALID_INDEX;
            }
        }
    }
    
    return ERROR_NO_MORE_ITEMS;
}

DWORD 
LocateUdpRow(
    DWORD   dwQueryType, 
    DWORD   dwNumIndices,
    PDWORD  pdwIndex,
    PDWORD  pdwRetIndex
    )
{
    DWORD   i;
    LONG    lCompare;
    DWORD   rgdwLocal[2];
    BOOL    fNext, fModified;
    DWORD   startIndex, stopIndex;
    
    if((g_UdpInfo.pUdpTable is NULL) or
       (g_UdpInfo.pUdpTable->dwNumEntries is 0))
    {
        if(EXACT_MATCH(dwQueryType))
        {
            return ERROR_INVALID_INDEX;
        }

        if(dwQueryType is ACCESS_GET_FIRST)
        {
            return ERROR_NO_DATA;
        }

        return ERROR_NO_MORE_ITEMS;
    }
    
    if(dwQueryType is ACCESS_GET_FIRST)
    {
        *pdwRetIndex = 0;
        
        return NO_ERROR;
    }
    
    rgdwLocal[0] = 0;
    rgdwLocal[1] = 0;
    
    fModified = TRUE;
    
    switch(dwNumIndices)
    {
        case 0:
        {
            break;
        }
        case 1:
        {
            rgdwLocal[LOCAL_ADDR] = pdwIndex[0];
            
            break;
        }
        case 2:
        {
            fModified = FALSE;
            
            rgdwLocal[LOCAL_ADDR] = pdwIndex[0];
            rgdwLocal[LOCAL_PORT] = pdwIndex[1];
            
            break;
        }
    }
  
    fNext = (dwQueryType is ACCESS_GET_NEXT) and (fModified is FALSE);
    
    startIndex  = 0;
    stopIndex   = g_UdpInfo.pUdpTable->dwNumEntries;
    
    for(i = startIndex; i < stopIndex; i++)
    {
        lCompare = UdpCmp(rgdwLocal[LOCAL_ADDR],
                          rgdwLocal[LOCAL_PORT],
                          g_UdpInfo.pUdpTable->table[i].dwLocalAddr,
                          g_UdpInfo.pUdpTable->table[i].dwLocalPort);
        
        if((lCompare is 0) and !fNext)
        {
            *pdwRetIndex = i;
            
            return NO_ERROR;
        }
        
        if(lCompare < 0)
        {
            if(dwQueryType is ACCESS_GET_NEXT)
            {
                *pdwRetIndex = i;
                
                return NO_ERROR;
            }
            else
            {
                return ERROR_INVALID_INDEX;
            }
        }
    } 
  
    return ERROR_NO_MORE_ITEMS;
}

DWORD 
LocateTcpRow(
    DWORD   dwQueryType, 
    DWORD   dwNumIndices,
    PDWORD  pdwIndex,
    PDWORD  pdwRetIndex
    )
{
    LONG    lCompare;
    DWORD   rgdwAddr[4];
    BOOL    fNext, fModified;
    DWORD   startIndex, stopIndex,i;
	
    if((g_TcpInfo.pTcpTable is NULL) or
       (g_TcpInfo.pTcpTable->dwNumEntries is 0))
    {
        if(EXACT_MATCH(dwQueryType))
        {
            return ERROR_INVALID_INDEX;
        }

        if(dwQueryType is ACCESS_GET_FIRST)
        {
            return ERROR_NO_DATA;
        }

        return ERROR_NO_MORE_ITEMS;
    }
    
    if(dwQueryType is ACCESS_GET_FIRST)
    {
        *pdwRetIndex = 0;
        
        return NO_ERROR;
    }
    
    //
    // Quick way to copy the valid part of index
    // BUG might want to asssert the sizes
    //
    
    ZeroMemory(rgdwAddr,
               4*sizeof(DWORD));
    
    memcpy(rgdwAddr,
           pdwIndex,
           dwNumIndices * sizeof(DWORD));

    //
    // We have modified it if the index is not the exact size
    //
    
    if(dwNumIndices isnot 4)
    {
        fModified = TRUE;
    }
    else
    {
        fModified = FALSE;
    }
    
    fNext = (dwQueryType is ACCESS_GET_NEXT) and (fModified is FALSE);
    
    startIndex  = 0;
    stopIndex   = g_TcpInfo.pTcpTable->dwNumEntries;
    
    for(i = startIndex; i < stopIndex; i++)
    {
        lCompare = TcpCmp(rgdwAddr[LOCAL_ADDR],
                          rgdwAddr[LOCAL_PORT],
                          rgdwAddr[REM_ADDR],
                          rgdwAddr[REM_PORT],
                          g_TcpInfo.pTcpTable->table[i].dwLocalAddr,
                          g_TcpInfo.pTcpTable->table[i].dwLocalPort,
                          g_TcpInfo.pTcpTable->table[i].dwRemoteAddr,
                          g_TcpInfo.pTcpTable->table[i].dwRemotePort);
        
        if((lCompare is 0) and !fNext)
        {
            *pdwRetIndex = i;
            
            return NO_ERROR;
        }
	
        if(lCompare < 0)
        {
            if(dwQueryType is ACCESS_GET_NEXT)
            {
                *pdwRetIndex = i;
                
                return NO_ERROR;
            }
            else
            {
                return ERROR_INVALID_INDEX;
            }
        }
    }
    
    return ERROR_NO_MORE_ITEMS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\map.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\map.c

Abstract:

    Header for map.c 

Revision History:

    Amritansh Raghav          10/6/95  Created

--*/

VOID
InitHashTables(
    VOID
    );

VOID
UnInitHashTables(
    VOID
    );

VOID
AddBinding(
    PICB picb
    );

VOID
RemoveBinding(
    PICB  picb
    );

PADAPTER_INFO
GetInterfaceBinding(
    DWORD   dwIfIndex
    );

#if DBG

VOID
CheckBindingConsistency(
    PICB    picb
    );

#else

#define CheckBindingConsistency(x)  NOTHING

#endif

/*
DWORD
StoreAdapterToInterfaceMap(
    DWORD dwAdapterId,
    DWORD dwIfIndex
    );

DWORD
DeleteAdapterToInterfaceMap(
    DWORD dwAdapterId
    );

DWORD
GetInterfaceFromAdapter(
    DWORD dwAdapterId
    );

PADAPTER_MAP
LookUpAdapterHash(
    DWORD dwAdapterId
    );

VOID
InsertAdapterHash(
    PADAPTER_MAP paiBlock
    );

DWORD
GetAdapterFromInterface(
    DWORD dwIfIndex
    );
*/

VOID
AddInterfaceLookup(
    PICB    picb
    );

VOID
RemoveInterfaceLookup(
    PICB    picb
    );

PICB
InterfaceLookupByIfIndex(
    DWORD           dwIfIndex
    );

PICB
InterfaceLookupByICBSeqNumber(
    DWORD           dwSeqNumber
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\map.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\routing\ip\rtrmgr\map.c

Abstract:

    Utility functions for various lookups and mappings

Revision History:

    Amritansh Raghav          10/6/95  Created

--*/

#include "allinc.h"

VOID 
InitHashTables(
    VOID
    )

/*++

Routine Description

    This function initializes the various mapping tables

Locks

    None. Called at init time

Arguments

    None

Return Value

    None

--*/

{
    DWORD i;

    TraceEnter("InitHashTables");

/*    
    for(i = 0; i < ADAPTER_HASH_TABLE_SIZE; i++)
    {
        InitializeListHead(&(g_rgleAdapterMapTable[i]));
    }
*/

    for(i = 0; i < BINDING_HASH_TABLE_SIZE; i++)
    {
        InitializeListHead(&g_leBindingTable[i]);
    }

    g_ulNumBindings = 0;
    
    TraceLeave("InitHashTables");
}

VOID
UnInitHashTables(
    VOID
    )

/*++

Routine Description

    Undo whatever was done in InitHasTables()

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    DWORD       i;
    PLIST_ENTRY pleHead;
    PLIST_ENTRY pleNode;
    
    TraceEnter("UnInitHashTables");

/*    
    for(i = 0; i < ADAPTER_HASH_TABLE_SIZE; i++)
    {
        pleHead = &g_rgleAdapterMapTable[i];
        
        while(!IsListEmpty(pleHead))
        {
            PADAPTER_MAP pAIBlock;
            
            pleNode = RemoveHeadList(pleHead);
            
            pAIBlock = CONTAINING_RECORD(pleNode,ADAPTER_MAP,leHashLink);
            
            HeapFree(GetProcessHeap(),0,pAIBlock);
        }
    }
*/

    for(i = 0; i < BINDING_HASH_TABLE_SIZE; i++)
    {
        pleHead = &g_leBindingTable[i];

        while(!IsListEmpty(pleHead))
        {
            PADAPTER_INFO   pBinding;

            pleNode = RemoveHeadList(pleHead);

            pBinding = CONTAINING_RECORD(pleNode, ADAPTER_INFO, leHashLink);

            Trace1(ERR,
                   "UnInitHashTables: Binding found for %d",
                   pBinding->dwIfIndex);

            HeapFree(IPRouterHeap,
                     0,
                     pBinding);
        }
    }

    g_ulNumBindings = 0;
    
    TraceLeave("UnInitHashTables");
}

VOID
AddBinding(
    PICB picb
    )

/*++

Routine Description

    Adds a binding info node to the hash table. Increments the
    g_ulNumBindings to track the number of addresses on the system
  
Locks 

    ICB lock as writer
    BINDING lock as writer
 
Arguments

    picb    The ICB of the interface whose bindings need to be added
            to the binding list.

Return Value

    None
    
--*/

{
    PADAPTER_INFO   pBinding;
    DWORD           i, dwNumAddr;

#if DBG

    PLIST_ENTRY     pleNode;

#endif

    IpRtAssert(picb->pibBindings isnot NULL);
    IpRtAssert(picb->bBound);

    //
    // adapter info always has space for one address/mask. This is needed
    // for the address table
    //

    dwNumAddr   = picb->dwNumAddresses ? picb->dwNumAddresses : 1;

    pBinding    = HeapAlloc(IPRouterHeap,
                            HEAP_ZERO_MEMORY,
                            SIZEOF_ADAPTER_INFO(picb->dwNumAddresses));

    if(pBinding is NULL)
    {
        Trace1(ERR,
               "AddBinding: Error %d allocating memory",
               GetLastError());
        
        IpRtAssert(FALSE);

        return;
    }

    pBinding->pInterfaceCB      = picb;
    pBinding->bBound            = picb->bBound;
    pBinding->dwIfIndex         = picb->dwIfIndex;
    pBinding->dwNumAddresses    = picb->dwNumAddresses;
    pBinding->dwRemoteAddress   = picb->dwRemoteAddress;

    pBinding->dwBCastBit        = picb->dwBCastBit;
    pBinding->dwReassemblySize  = picb->dwReassemblySize;

    pBinding->ritType           = picb->ritType;

    for(i = 0; i < picb->dwNumAddresses; i++)
    {
        //
        // structure assignment
        //
        
        pBinding->rgibBinding[i] = picb->pibBindings[i];
    }

#if DBG

    for(pleNode = g_leBindingTable[BIND_HASH(picb->dwIfIndex)].Flink;
        pleNode isnot &g_leBindingTable[BIND_HASH(picb->dwIfIndex)];
        pleNode = pleNode->Flink)
    {
        PADAPTER_INFO   pTempBind;

        pTempBind = CONTAINING_RECORD(pleNode,
                                      ADAPTER_INFO,
                                      leHashLink);

        IpRtAssert(pTempBind->dwIfIndex isnot picb->dwIfIndex);
    }

#endif

    InsertHeadList(&g_leBindingTable[BIND_HASH(picb->dwIfIndex)],
                   &(pBinding->leHashLink));

    g_ulNumBindings += (picb->dwNumAddresses ? picb->dwNumAddresses : 1);
    
    g_LastUpdateTable[IPADDRCACHE] = 0;
    
    return;
}

VOID
RemoveBinding(
    PICB  picb
    )

/*++

Routine Description

    Called to remove the bindings associated with an interface

Locks

    ICB lock held as WRITER
    BINDING list lock held as WRITER

Arguments

    picb    ICB of the interface whose bindings need to be removed

Return Value

    None

--*/

{
    PADAPTER_INFO   pBind;


    pBind = GetInterfaceBinding(picb->dwIfIndex);
    
    if(pBind isnot NULL)
    {
        RemoveEntryList(&(pBind->leHashLink));

        g_ulNumBindings -= (pBind->dwNumAddresses? pBind->dwNumAddresses : 1);
        
        HeapFree(IPRouterHeap,
                 0,
                 pBind);

        g_LastUpdateTable[IPADDRCACHE] = 0;

        return;
    }

    Trace0(ERR,
           "RemoveBinding: BINDING NOT FOUND");

    IpRtAssert(FALSE);
}

PADAPTER_INFO
GetInterfaceBinding(
    DWORD   dwIfIndex
    )

/*++

Routine Description

    Retrieves a pointer to the binding info from hash table

Locks

    BINDING lock held atleast as READER

Arguments

    dwIfIndex   Interface Index for the interface whose bindings need
                    to be looked up

Return Value

    Pointer to binding information if the binding was found
    NULL    if binding was not found
    
--*/

{
    PLIST_ENTRY     pleNode;
    PADAPTER_INFO   pBinding;

    for(pleNode = g_leBindingTable[BIND_HASH(dwIfIndex)].Flink;
        pleNode isnot &g_leBindingTable[BIND_HASH(dwIfIndex)];
        pleNode = pleNode->Flink)
    {
        pBinding = CONTAINING_RECORD(pleNode,ADAPTER_INFO,leHashLink);

        if(pBinding->dwIfIndex is dwIfIndex)
        {
            return pBinding;
        }
    }

    Trace0(ERR,
           "GetInterfaceBinding: BINDING NOT FOUND");

    return NULL;
}

#if DBG

VOID
CheckBindingConsistency(
    PICB    picb
    )

/*++

Routine Description

    This

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{

}

#endif


//
// The following are the set of various mapping functions
// They require that you already possess the dwLock before you call them
//

#if 0

DWORD 
StoreAdapterToInterfaceMap(
    DWORD dwAdapterId,
    DWORD dwIfIndex
    )
{
    PADAPTER_MAP pAIBlock;
    
    if((pAIBlock = LookUpAdapterHash(dwAdapterId)) isnot NULL)
    {
        pAIBlock->dwIfIndex = dwIfIndex;
        
        return NO_ERROR;
    }

    //
    // Wasnt found
    //
    
    if((pAIBlock = HeapAlloc(GetProcessHeap(),0,sizeof(ADAPTER_MAP))) is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pAIBlock->dwAdapterId      = dwAdapterId;
    pAIBlock->dwIfIndex = dwIfIndex;

    InsertAdapterHash(pAIBlock);
    return NO_ERROR;
}

DWORD 
DeleteAdapterToInterfaceMap(
    DWORD dwAdapterId
    )
{
    PADAPTER_MAP pAIBlock;

    if((pAIBlock = LookUpAdapterHash(dwAdapterId)) isnot NULL)
    {
        pAIBlock->dwIfIndex = INVALID_IF_INDEX;
        
        return NO_ERROR;
    }

    return INVALID_ADAPTER_ID;
}

DWORD 
GetInterfaceFromAdapter(
    DWORD dwAdapterId
    )
{
    PADAPTER_MAP pAIBlock;

    if((pAIBlock = LookUpAdapterHash(dwAdapterId)) isnot NULL)
    {
        return pAIBlock->dwIfIndex;
    }

    return INVALID_ADAPTER_ID;
}

PADAPTER_MAP 
LookUpAdapterHash(
    DWORD dwAdapterId
    )
{
    DWORD dwHashIndex;
    PADAPTER_MAP pAIBlock;
    PLIST_ENTRY pleCurrent;
    
    dwHashIndex = ADAPTER_HASH(dwAdapterId);

    //
    // The list is not ordered, travel the whole hash bucket
    //
    
    for(pleCurrent = g_rgleAdapterMapTable[dwHashIndex].Flink;
        pleCurrent isnot &g_rgleAdapterMapTable[dwHashIndex];
        pleCurrent = pleCurrent->Flink)
    {
        pAIBlock = CONTAINING_RECORD(pleCurrent,ADAPTER_MAP,leHashLink);

        if(pAIBlock->dwAdapterId is dwAdapterId)
        {
            return pAIBlock;
        }
    }

    return NULL;
}

VOID 
InsertAdapterHash(
    PADAPTER_MAP paiBlock
    )
{
    DWORD dwHashIndex;

    dwHashIndex = ADAPTER_HASH(paiBlock->dwAdapterId);
    
    InsertHeadList(&g_rgleAdapterMapTable[dwHashIndex],
                   &paiBlock->leHashLink);
}

DWORD 
GetAdapterFromInterface(
    DWORD dwIfIndex
    )
{
    PICB            picb;
    
    picb = InterfaceLookupByIfIndex(dwIfIndex);

    CheckBindingConsistency(picb);
    
    if(!picb)
    {
        Trace0(ERR,
               "GetAdapterFromInterface: Unable to map interface to adapter since the interface id was not found!");
        
        return INVALID_IF_INDEX;
    }
    
    if((picb->dwOperationalState is CONNECTED) or
       (picb->dwOperationalState is OPERATIONAL))
    {
        return picb->dwAdapterId;
    }
    
    Trace1(IF,
           "GetAdapterFromInterface: Unable to map interface to adapter since its operational state was %d",
           picb->dwOperationalState);
    
    return INVALID_IF_INDEX;
}

#endif

// AddInterfaceLookup()
//
// Function: Adds the given interface to the hash table used for quick look up given
//           an interface id.
//
// Returns: Nothing
//

VOID
AddInterfaceLookup(
    PICB    picb
    )
{
    PLIST_ENTRY ple;
    PICB pIcbHash;
    
    InsertHeadList(&ICBHashLookup[picb->dwIfIndex % ICB_HASH_TABLE_SIZE],
                   &picb->leHashLink);

    for (
        ple = ICBSeqNumLookup[picb->dwSeqNumber % ICB_HASH_TABLE_SIZE].Flink;
        ple != &ICBSeqNumLookup[picb->dwSeqNumber % ICB_HASH_TABLE_SIZE];
        ple = ple->Flink
        )
    {
        pIcbHash = CONTAINING_RECORD(ple, ICB, leICBHashLink );
        
        if (pIcbHash->dwSeqNumber > picb->dwSeqNumber)
        {
            break;
        }
    }
    
    InsertTailList(ple, &picb->leICBHashLink);
}


// RemoveInterfaceLookup()
//
// Function: Removes the given interface from the hash table used for quick look up given
//           an interface id.
//
// Returns: Nothing
//

VOID
RemoveInterfaceLookup(
    PICB    picb
    )
{
    RemoveEntryList(&picb->leHashLink);

    picb->leHashLink.Flink = NULL;
    picb->leHashLink.Blink = NULL;

    RemoveEntryList(&picb->leICBHashLink);

    InitializeListHead(&picb->leICBHashLink);
}


// InterfaceLookupByICBSeqNumber()
//
// Function: Returns a pointer to ICB given the sequence number
//
// Returns: PICB if found - NULL otherwise.
//

PICB
InterfaceLookupByICBSeqNumber(
    DWORD           dwSeqNumber
    )
{
    PICB        picb;
    PLIST_ENTRY pleNode;

    for(pleNode = ICBSeqNumLookup[dwSeqNumber % ICB_HASH_TABLE_SIZE].Flink;
        pleNode isnot &ICBSeqNumLookup[dwSeqNumber % ICB_HASH_TABLE_SIZE];
        pleNode = pleNode->Flink)
    {
        picb = CONTAINING_RECORD(pleNode, ICB, leICBHashLink);

        if (picb->dwSeqNumber < dwSeqNumber)
        {
            continue;
        }

        if (picb->dwSeqNumber == dwSeqNumber)
        {
            return picb;
        }

        else
        {
            break;
        }
    }

    return NULL;
}


//
// InterfaceLookupByIfIndex()
//
// Function: Returns a pointer to ICB given the interfaceid
//
// Returns: PICB if found - NULL otherwise.
//

PICB
InterfaceLookupByIfIndex(
    DWORD dwIfIndex
    )
{
    PICB        picb;
    PLIST_ENTRY pleNode;

    for(pleNode = ICBHashLookup[dwIfIndex % ICB_HASH_TABLE_SIZE].Flink;
        pleNode isnot &ICBHashLookup[dwIfIndex % ICB_HASH_TABLE_SIZE];
        pleNode = pleNode->Flink)
    {
        picb = CONTAINING_RECORD(pleNode, ICB, leHashLink);

        if (picb->dwIfIndex is dwIfIndex)
        {
            return picb;
        }
    }

    return NULL;
}

DWORD
MapInterfaceToAdapter(
    DWORD Index
    )
{
    return Index;

#if 0
    ENTER_READER(ICB_LIST);
    Index = GetAdapterFromInterface(Index);
    EXIT_LOCK(ICB_LIST);
    return Index;
#endif
}


DWORD
MapInterfaceToRouterIfType(
    DWORD Index
    )
{
    DWORD   dwIfType = ROUTER_IF_TYPE_INTERNAL;
    PICB    picb;
    ENTER_READER(ICB_LIST);
    picb = InterfaceLookupByIfIndex(Index);
    if (picb) { dwIfType = picb->ritType; }
    EXIT_LOCK(ICB_LIST);
    return dwIfType;
}


DWORD
MapAddressToAdapter(
    DWORD Address
    )
{
    DWORD dwAdapterId;
    DWORD dwBCastBit;
    DWORD dwReassemblySize;
    if (GetAdapterInfo(Address, &dwAdapterId, &dwBCastBit, &dwReassemblySize))
    {
        return INVALID_IF_INDEX;
    }
    return dwAdapterId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\mbound.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    mbound.c

Abstract:

    This module implements routines associated with administratively-
    scoped boundaries (i.e. group-prefix boundaries).  An IPv4 Local
    Scope boundary implicitly exists (no state needed) whenever any
    other boundary exists.  The IPv4 Local Scope implicitly exists
    whenever any other scope exists.

Author:

    dthaler@microsoft.com   4-20-98

Revision History:

--*/

#include "allinc.h"
#include "mbound.h"
#include <math.h>   // for floor()
#pragma hdrstop

#ifdef DEBUG
#define INLINE
#else
#define INLINE          __inline
#endif

#define MZAP_DEFAULT_BIT 0x80

#define MAX_SCOPES 10
SCOPE_ENTRY  g_scopeEntry[MAX_SCOPES];
SCOPE_ENTRY  g_LocalScope;

#define BOUNDARY_HASH_TABLE_SIZE 57
#define BOUNDARY_HASH(X)  ((X) % BOUNDARY_HASH_TABLE_SIZE)
BOUNDARY_BUCKET g_bbScopeTable[BOUNDARY_HASH_TABLE_SIZE];

#define ROWSTATUS_ACTIVE 1

#define MIN_SCOPE_ADDR         0xef000000
#define MAX_SCOPE_ADDR        (0xefff0000 - 1)

#define IPV4_LOCAL_SCOPE_LANG MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US)
#define IPV4_LOCAL_SCOPE_NAME SN_L"IPv4 Local Scope"
#define IPV4_LOCAL_SCOPE_ADDR htonl(0xefff0000)
#define IPV4_LOCAL_SCOPE_MASK htonl(0xffff0000)
#define IN_IPV4_LOCAL_SCOPE(x) \
    (((x) & IPV4_LOCAL_SCOPE_MASK) == IPV4_LOCAL_SCOPE_ADDR)

LIST_ENTRY g_MasterInterfaceList;
LIST_ENTRY g_MasterScopeList;

#define MALLOC(dwSize)       HeapAlloc(IPRouterHeap, 0, dwSize)
#define FREE(x)              HeapFree(IPRouterHeap, 0, x)
#define MIN(x,y)                 (((x)<(y))?(x):(y))

// Forward static declarations

DWORD
AssertBoundaryEntry(
    BOUNDARY_IF     *pBoundaryIf, 
    SCOPE_ENTRY     *pScope,
    PBOUNDARY_ENTRY *ppBoundary
    );

VOID
MzapInitScope(
    PSCOPE_ENTRY    pScope
    );

DWORD
MzapInitBIf(
    PBOUNDARY_IF    pBIf
    );

VOID
MzapUninitBIf(
    PBOUNDARY_IF    pBIf
    );

DWORD
MzapActivateBIf( 
    PBOUNDARY_IF    pBIf
    );

// 
// Functions to manipulate scopes
//

PSCOPE_ENTRY
NewScope()
{
    DWORD dwScopeIndex;

    // Find an unused scope index
    for (dwScopeIndex=0; dwScopeIndex<MAX_SCOPES; dwScopeIndex++) 
    {
        if ( !g_scopeEntry[dwScopeIndex].ipGroupAddress ) 
        {
            return &g_scopeEntry[ dwScopeIndex ];
        }
    }

    return NULL;
}

PSCOPE_ENTRY
FindScope(
    IN IPV4_ADDRESS  ipGroupAddress,
    IN IPV4_ADDRESS  ipGroupMask
    )
/*++
Called by: 
    AssertScope(), RmGetBoundary()
Locks:
    Assumes caller holds write lock on BOUNDARY_TABLE.
--*/
{
    PLIST_ENTRY  pleNode;

    for (pleNode = g_MasterScopeList.Flink;
         pleNode isnot &g_MasterScopeList;
         pleNode = pleNode->Flink) 
    {

        SCOPE_ENTRY *pScope = CONTAINING_RECORD(pleNode, SCOPE_ENTRY,
         leScopeLink);

        if (pScope->ipGroupAddress == ipGroupAddress
         && pScope->ipGroupMask    == ipGroupMask)
           return pScope;
    }

    return NULL;
}

PBYTE
GetLangName(
    IN LANGID  idLanguage
    )
{
    char b1[8], b2[8];
    static char buff[80];
    LCID lcid = MAKELCID(idLanguage, SORT_DEFAULT);

    GetLocaleInfo(lcid, LOCALE_SISO639LANGNAME, b1, sizeof(b1));

    GetLocaleInfo(lcid, LOCALE_SISO3166CTRYNAME, b2, sizeof(b2));

    if (_stricmp(b1, b2))
        sprintf(buff, "%s-%s", b1, b2);
    else
        strcpy(buff, b1);

    return buff;
}

PSCOPE_NAME_ENTRY
GetScopeNameByLangID(
    IN PSCOPE_ENTRY pScope, 
    IN LANGID       idLanguage
    )
/*++
Called by:
    AssertScopeName()
--*/
{
    PLIST_ENTRY       pleNode;
    PSCOPE_NAME_ENTRY pName;

    for (pleNode = pScope->leNameList.Flink;
         pleNode isnot &pScope->leNameList;
         pleNode = pleNode->Flink)
    {
        pName = CONTAINING_RECORD(pleNode, SCOPE_NAME_ENTRY, leNameLink);
        if (idLanguage == pName->idLanguage)
            return pName;
    }

    return NULL;
}

PSCOPE_NAME_ENTRY
GetScopeNameByLangName(
    IN PSCOPE_ENTRY pScope, 
    IN PBYTE        pLangName
    )
/*++
Called by:
    CheckForScopeNameMismatch()
--*/
{
    PLIST_ENTRY       pleNode;
    PSCOPE_NAME_ENTRY pName;

    for (pleNode = pScope->leNameList.Flink;
         pleNode isnot &pScope->leNameList;
         pleNode = pleNode->Flink)
    {
        pName = CONTAINING_RECORD(pleNode, SCOPE_NAME_ENTRY, leNameLink);
        if (!strcmp(pLangName, GetLangName(pName->idLanguage)))
            return pName;
    }

    return NULL;
}


VOID
MakePrefixStringW( 
    OUT PWCHAR       pwcPrefixStr,
    IN  IPV4_ADDRESS ipAddr, 
    IN  IPV4_ADDRESS ipMask
    )
{
    swprintf( pwcPrefixStr, 
              L"%d.%d.%d.%d/%d", 
              PRINT_IPADDR(ipAddr),  
              MaskToMaskLen(ipMask) );
}

// Global buffers used to create messages
WCHAR g_AddrBuf1[20];
WCHAR g_AddrBuf2[20];
WCHAR g_AddrBuf3[20];
WCHAR g_AddrBuf4[20];

VOID
MakeAddressStringW(
    OUT PWCHAR       pwcAddressStr,
    IN  IPV4_ADDRESS ipAddr
    )
{
    swprintf( pwcAddressStr,
              L"%d.%d.%d.%d",
              PRINT_IPADDR(ipAddr) );
}

SCOPE_NAME
GetDefaultName(
    IN PSCOPE_ENTRY pScope
    )
/*++
Called by:
    RmGetNextScope()
    Various other functions for use in Trace() calls
--*/
{
    PLIST_ENTRY       pleNode;
    PSCOPE_NAME_ENTRY pName;
    static SCOPE_NAME_BUFFER snScopeNameBuffer;
    SCOPE_NAME        pFirst = NULL;

    for (pleNode = pScope->leNameList.Flink;
         pleNode isnot &pScope->leNameList;
         pleNode = pleNode->Flink)
    {
        pName = CONTAINING_RECORD(pleNode, SCOPE_NAME_ENTRY, leNameLink);
        if (pName->bDefault)
            return pName->snScopeName;
        if (!pFirst)
            pFirst = pName->snScopeName;
    }

    // If any names were specified, just pick the first one.

    if (pFirst)
        return pFirst;

    MakePrefixStringW( snScopeNameBuffer, 
                       pScope->ipGroupAddress,
                       pScope->ipGroupMask );

    return snScopeNameBuffer;
}

VOID
DeleteScopeName(
    IN  PLIST_ENTRY   pleNode
    )
{
    PSCOPE_NAME_ENTRY pName = CONTAINING_RECORD( pleNode, 
                                                 SCOPE_NAME_ENTRY, 
                                                 leNameLink );

    RemoveEntryList(pleNode);

    if (pName->snScopeName)
        FREE(pName->snScopeName);

    FREE( pName );
}

DWORD
AssertScopeName(
    IN  PSCOPE_ENTRY  pScope,
    IN  LANGID        idLanguage,
    IN  SCOPE_NAME    snScopeName  // unicode string to duplicate
    )
/*++
Arguments:
    pScope - scope entry to modify
    idLanguage - language ID of new name
    snScopeName - new name to use
Called by:
    MzapInitLocalScope(), AddScope(), ParseScopeInfo(), SetScopeInfo(),
    SNMPSetScope()
--*/
{
    SCOPE_NAME_BUFFER snScopeNameBuffer;
    PSCOPE_NAME_ENTRY pName;

    pName = GetScopeNameByLangID(pScope, idLanguage);

    //
    // See if the name is already correct.
    //

    if (pName && snScopeName && !sn_strcmp( snScopeName, pName->snScopeName ))
    {
        return NO_ERROR;
    }

    //
    // Create a scope name if we weren't given one
    //

    if ( snScopeName is NULL 
      || snScopeName[0] is '\0' ) 
    {
        MakePrefixStringW( snScopeNameBuffer, 
                           pScope->ipGroupAddress,
                           pScope->ipGroupMask );

        snScopeName = snScopeNameBuffer;
    }

    // Add a name entry if needed

    if (!pName)
    {
        pName = (PSCOPE_NAME_ENTRY)MALLOC( sizeof(SCOPE_NAME_ENTRY) );
        if (!pName) 
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        pName->bDefault = FALSE;
        pName->snScopeName = NULL;
        pName->idLanguage = idLanguage;
        InsertTailList( &pScope->leNameList, &pName->leNameLink );
        pScope->ulNumNames++;
    }

    //
    // Free the old name and save the new one
    //

    if (pName->snScopeName) 
    {
        FREE( pName->snScopeName );
    }

    pName->snScopeName = (SCOPE_NAME)MALLOC( (sn_strlen(snScopeName)+1) 
                               * SNCHARSIZE );

    if (pName->snScopeName == NULL)
    {
        DWORD dwErr = GetLastError();
        
        Trace3(
            ANY,
            "Error %d allocating %d bytes for scope name %s",
            dwErr, sn_strlen(snScopeName)+1, snScopeName
            );

        return dwErr;
    }
    
    sn_strcpy(pName->snScopeName, snScopeName);

    Trace4(MCAST, "Updated scope name for \"%s\": %ls (%d.%d.%d.%d/%d)", 
     GetLangName(idLanguage),
     snScopeName,
     PRINT_IPADDR(pScope->ipGroupAddress),
     MaskToMaskLen(pScope->ipGroupMask) );

    return NO_ERROR;
}

VOID
MzapInitLocalScope()
/*++
Called by:
    ActivateMZAP()
--*/
{
    PSCOPE_ENTRY pScope = &g_LocalScope;

    pScope->ipGroupAddress = IPV4_LOCAL_SCOPE_ADDR;
    pScope->ipGroupMask    = IPV4_LOCAL_SCOPE_MASK;

    InitializeListHead( &pScope->leNameList );
    pScope->ulNumNames = 0;

    MzapInitScope(pScope);

    AssertScopeName( pScope, IPV4_LOCAL_SCOPE_LANG, IPV4_LOCAL_SCOPE_NAME );
}

DWORD
AddScope(
    IN  IPV4_ADDRESS  ipGroupAddress,
    IN  IPV4_ADDRESS  ipGroupMask,
    OUT PSCOPE_ENTRY *pScopeEntry
    )
/*++
Routine Description:
    Add a named scope.
Arguments:
    IN  ipGroupAddress - first address in the scope to add
    IN  ipGroupMask    - mask associated with the address
    OUT pScope         - scope entry added
Called by:
    AssertScope()
Locks:
    Assumes caller holds write lock on BOUNDARY_TABLE
Returns:
    NO_ERROR
    ERROR_NOT_ENOUGH_MEMORY
    ERROR_INVALID_PARAMETER
--*/
{
    SCOPE_ENTRY      *pScope;
    PLIST_ENTRY       pleNode;

    // See if any bits are set in the address but not the mask
    if (ipGroupAddress & ~ipGroupMask)
       return ERROR_INVALID_PARAMETER;

    // Make sure the address is a valid one
    if (ntohl(ipGroupAddress) < MIN_SCOPE_ADDR
     || ntohl(ipGroupAddress) > MAX_SCOPE_ADDR)
       return ERROR_INVALID_PARAMETER;

    // Make sure we have space for this entry
    if ((pScope = NewScope()) == NULL)
       return ERROR_NOT_ENOUGH_MEMORY;

    pScope->ipGroupAddress  = ipGroupAddress;
    pScope->ipGroupMask     = ipGroupMask;

    InitializeListHead( &pScope->leNameList );
    pScope->ulNumNames = 0;

#if 0
{
    SCOPE_NAME_BUFFER snScopeNameBuffer;

    // Create a scope name if we weren't given one
    if ( snScopeName is NULL 
      || snScopeName[0] is '\0' ) 
    {
        MakePrefixStringW( snScopeNameBuffer, 
                           pScope->ipGroupAddress,
                           pScope->ipGroupMask );

        snScopeName = snScopeNameBuffer;
    }

    AssertScopeName( pScope, idLanguage, snScopeName );
}
#endif

    MzapInitScope(pScope);

    //
    // Add it to the master scope list
    //

    // Search for entry after the new one
    for (pleNode = g_MasterScopeList.Flink;
         pleNode isnot &g_MasterScopeList;
         pleNode = pleNode->Flink) 
    {
       SCOPE_ENTRY *pPrevScope = CONTAINING_RECORD(pleNode, SCOPE_ENTRY,
        leScopeLink);
       IPV4_ADDRESS ipAddress = pPrevScope->ipGroupAddress;
       IPV4_ADDRESS ipMask    = pPrevScope->ipGroupMask;
       
       if (ipAddress > pScope->ipGroupAddress
        || (ipAddress==pScope->ipGroupAddress && ipMask>pScope->ipGroupMask))
          break;
    }

    InsertTailList( pleNode, &pScope->leScopeLink );
          
    *pScopeEntry = pScope;

#if 0
    Trace4(MCAST, "AddScope: added %s %ls (%d.%d.%d.%d/%d)", 
     GetLangName( idLanguage ),
     snScopeName,
     PRINT_IPADDR(ipGroupAddress),
     MaskToMaskLen(ipGroupMask) );
#endif
    Trace2(MCAST, "AddScope: added (%d.%d.%d.%d/%d)", 
     PRINT_IPADDR(ipGroupAddress),
     MaskToMaskLen(ipGroupMask) );
   
    return NO_ERROR;
}

DWORD
AssertScope(
    IN  IPV4_ADDRESS  ipGroupAddress,
    IN  IPV4_ADDRESS  ipGroupMask,
    OUT PSCOPE_ENTRY *ppScopeEntry
    )
/*++
Arguments:
    ipGroupAddress - address part of the scope prefix
    ipGroupMask    - mask part of the scope prefix
    ppScopeEntry   - scope entry to return to caller
Locks:
    Assumes caller holds write lock on BOUNDARY_TABLE.
Called by: 
    SetScopeInfo()
    SNMPAddBoundaryToInterface()
Returns:
    NO_ERROR - success
    whatever AddScope() returns
--*/
{
    DWORD dwResult = NO_ERROR;

    *ppScopeEntry = FindScope(ipGroupAddress, ipGroupMask);

    if (! *ppScopeEntry) 
    {
        dwResult = AddScope(ipGroupAddress, ipGroupMask, ppScopeEntry);
    } 

    return dwResult;
}


DWORD
DeleteScope(
    IN PSCOPE_ENTRY pScope
    )
/*++
Routine Description:
    Remove all information about a given boundary.
Called by:
    SetScopeInfo(), SNMPDeleteBoundaryFromInterface()
Locks:
    Assumes caller holds write lock on BOUNDARY_TABLE
Returns:
    NO_ERROR
--*/
{
   Trace2( MCAST, "ENTERED DeleteScope: %d.%d.%d.%d/%d", 
    PRINT_IPADDR(pScope->ipGroupAddress),
    MaskToMaskLen(pScope->ipGroupMask) );

   if (pScope->ipGroupAddress == 0) {

      Trace0( MCAST, "LEFT DeleteScope" );
      return NO_ERROR; // already deleted
   }

   if (pScope->ulNumInterfaces > 0) 
   {
      //
      // Walk all interfaces looking for references.  It doesn't matter
      // whether this is inefficient, since it occurs extremely rarely,
      // if ever, and we don't care whether it takes a couple of seconds
      // to do.
      //
      DWORD dwBucketIdx;
      PLIST_ENTRY pleNode, pleNext;

      for (dwBucketIdx = 0; 
           dwBucketIdx < BOUNDARY_HASH_TABLE_SIZE 
            && pScope->ulNumInterfaces > 0;
           dwBucketIdx++)
      {
         for (pleNode = g_bbScopeTable[dwBucketIdx].leInterfaceList.Flink;
              pleNode isnot & g_bbScopeTable[dwBucketIdx].leInterfaceList;
              pleNode = pleNext)
         {
            BOUNDARY_ENTRY *pBoundary = CONTAINING_RECORD(pleNode, 
             BOUNDARY_ENTRY, leBoundaryLink);
  
            // Save pointer to next node, since we may delete the current one
            pleNext = pleNode->Flink;
  
            if (pBoundary->pScope == pScope) {

               // Delete boundary 
               RemoveEntryList(&(pBoundary->leBoundaryLink));
               pScope->ulNumInterfaces--;
               FREE(pBoundary);
            }
         }
      }
   }

   // Do the actual scope deletion
   RemoveEntryList(&(pScope->leScopeLink));
   pScope->ipGroupAddress = 0;
   pScope->ipGroupMask    = 0xFFFFFFFF;

   while (! IsListEmpty(&pScope->leNameList) )
   {
      DeleteScopeName(pScope->leNameList.Flink);
      pScope->ulNumNames--;
   }

   Trace0( MCAST, "LEFT DeleteScope" );

   return NO_ERROR;
}

//
// Routines to manipulate BOUNDARY_IF structures
//

BOUNDARY_IF *
FindBIfEntry(
    IN DWORD dwIfIndex
    )
/*++
Locks: 
    Assumes caller holds at least a read lock on BOUNDARY_TABLE
Called by: 
    AssertBIfEntry(), RmHasBoundary(), BindBoundaryInterface()
Returns:
    pointer to BOUNDARY_IF entry, if found
    NULL, if not found
--*/
{
    PLIST_ENTRY pleNode;
    BOUNDARY_IF *pIf;
    DWORD dwBucketIdx = BOUNDARY_HASH(dwIfIndex);

    for (pleNode = g_bbScopeTable[dwBucketIdx].leInterfaceList.Flink;
         pleNode isnot & g_bbScopeTable[dwBucketIdx].leInterfaceList;
         pleNode = pleNode->Flink)
    {
         pIf = CONTAINING_RECORD(pleNode, BOUNDARY_IF, leBoundaryIfLink);
         if (pIf->dwIfIndex == dwIfIndex)
            return pIf;
    }

    return NULL;
}

BOUNDARY_IF *
FindBIfEntryBySocket(
    IN SOCKET sMzapSocket
    )
{
    register PLIST_ENTRY pleNode;
    register DWORD dwBucketIdx;
    BOUNDARY_IF *pIf;

    for (dwBucketIdx = 0;
         dwBucketIdx < BOUNDARY_HASH_TABLE_SIZE;
         dwBucketIdx++)
    {
        for (pleNode = g_bbScopeTable[dwBucketIdx].leInterfaceList.Flink;
             pleNode isnot & g_bbScopeTable[dwBucketIdx].leInterfaceList;
             pleNode = pleNode->Flink)
        {
             pIf = CONTAINING_RECORD(pleNode, BOUNDARY_IF, leBoundaryIfLink);

             if (pIf->sMzapSocket == sMzapSocket)
                return pIf;
        }
    }

    return NULL;
}



DWORD
AddBIfEntry(
    IN  DWORD         dwIfIndex,
    OUT PBOUNDARY_IF *ppBoundaryIf,
    IN  BOOL          bIsOperational
    )
/*++
Locks: 
    Assumes caller holds a write lock on BOUNDARY_TABLE
Called by: 
    AssertBIfEntry()
Returns:
    NO_ERROR on success
    ERROR_NOT_ENOUGH_MEMORY
--*/
{
    PLIST_ENTRY  pleNode;
    DWORD        dwBucketIdx, dwErr = NO_ERROR;
    BOUNDARY_IF *pBoundaryIf;

    Trace1(MCAST, "AddBIfEntry %x", dwIfIndex);

    dwBucketIdx = BOUNDARY_HASH(dwIfIndex);
    pBoundaryIf = MALLOC( sizeof(BOUNDARY_IF) );
    if (!pBoundaryIf)
       return ERROR_NOT_ENOUGH_MEMORY;

    pBoundaryIf->dwIfIndex = dwIfIndex;
    InitializeListHead(&pBoundaryIf->leBoundaryList);
    MzapInitBIf(pBoundaryIf);

    if (bIsOperational)
    {
        dwErr = MzapActivateBIf(pBoundaryIf);
    }

    // find entry in bucket's list to insert before
    for (pleNode =  g_bbScopeTable[dwBucketIdx].leInterfaceList.Flink;
         pleNode isnot &g_bbScopeTable[dwBucketIdx].leInterfaceList;
         pleNode = pleNode->Flink) {
       BOUNDARY_IF *pPrevIf = CONTAINING_RECORD(pleNode, BOUNDARY_IF,
        leBoundaryIfLink);
       
       if (pPrevIf->dwIfIndex > dwIfIndex)
          break;
    }

    InsertTailList( pleNode, &(pBoundaryIf->leBoundaryIfLink));

    // find entry in master list to insert before
    for (pleNode =  g_MasterInterfaceList.Flink;
         pleNode isnot &g_MasterInterfaceList;
         pleNode = pleNode->Flink) {
       BOUNDARY_IF *pPrevIf = CONTAINING_RECORD(pleNode, BOUNDARY_IF,
        leBoundaryIfLink);
       
       if (pPrevIf->dwIfIndex > dwIfIndex)
          break;
    }

    InsertTailList( pleNode, &(pBoundaryIf->leBoundaryIfMasterLink));

    *ppBoundaryIf = pBoundaryIf;

    return dwErr;
}


DWORD
AssertBIfEntry(
    IN DWORD          dwIfIndex,
    OUT PBOUNDARY_IF *ppBoundaryIf,
    IN  BOOL          bIsOperational
    )
/*++
Locks: 
    Assumes caller holds a write lock on BOUNDARY_TABLE
Called by: 
    SetBoundaryInfo(), SNMPAddBoundaryToInterface()
--*/
{
    if ((*ppBoundaryIf = FindBIfEntry(dwIfIndex)) != NULL)
       return NO_ERROR;

    return AddBIfEntry(dwIfIndex, ppBoundaryIf, bIsOperational);
}

//
// Routines to manipulate BOUNDARY_ENTRY structures
//

BOUNDARY_ENTRY *
FindBoundaryEntry(
    BOUNDARY_IF *pBoundaryIf, 
    SCOPE_ENTRY *pScope
    )
/*++
Locks: 
    Assumes caller already holds at least a read lock on BOUNDARY_TABLE
Called by: 
    AssertBoundaryEntry()
Returns:
    pointer to BOUNDARY_ENTRY, if found
    NULL, if not found
--*/
{
    PLIST_ENTRY pleNode;

    for (pleNode = pBoundaryIf->leBoundaryList.Flink;
         pleNode isnot &(pBoundaryIf->leBoundaryList);
         pleNode = pleNode->Flink)
    {
        BOUNDARY_ENTRY *pBoundary = CONTAINING_RECORD(pleNode, BOUNDARY_ENTRY,
         leBoundaryLink);
        if (pScope == &g_LocalScope || pScope == pBoundary->pScope)
           return pBoundary;
    }
    return NULL;
}

DWORD
AddBoundaryEntry(
    BOUNDARY_IF     *pBoundaryIf, 
    SCOPE_ENTRY     *pScope,
    PBOUNDARY_ENTRY *ppBoundary
    )
/*++
Called by: 
    AssertBoundaryEntry()
Locks:
    Assumes caller holds a write lock on BOUNDARY_TABLE
Returns:
    NO_ERROR on success
    ERROR_NOT_ENOUGH_MEMORY
--*/
{
    PLIST_ENTRY pleNode;

    Trace3(MCAST, "AddBoundaryEntry: If %x Scope %d.%d.%d.%d/%d", 
     pBoundaryIf->dwIfIndex,
     PRINT_IPADDR(pScope->ipGroupAddress),
     MaskToMaskLen(pScope->ipGroupMask) );

    if ((*ppBoundary = MALLOC( sizeof(BOUNDARY_ENTRY) )) == NULL)
       return ERROR_NOT_ENOUGH_MEMORY;

    (*ppBoundary)->pScope = pScope;

    // Search for entry after the new one
    for (pleNode = pBoundaryIf->leBoundaryList.Flink;
         pleNode isnot &pBoundaryIf->leBoundaryList;
         pleNode = pleNode->Flink) {
       BOUNDARY_ENTRY *pPrevRange = CONTAINING_RECORD(pleNode, BOUNDARY_ENTRY,
        leBoundaryLink);
       IPV4_ADDRESS ipAddress = pPrevRange->pScope->ipGroupAddress;
       IPV4_ADDRESS ipMask    = pPrevRange->pScope->ipGroupMask;
       
       if (ipAddress > pScope->ipGroupAddress
        || (ipAddress==pScope->ipGroupAddress && ipMask>pScope->ipGroupMask))
          break;
    }

    InsertTailList( pleNode, &((*ppBoundary)->leBoundaryLink));

    pScope->ulNumInterfaces++;

    return NO_ERROR;
}

DWORD
AssertBoundaryEntry(
    BOUNDARY_IF     *pBoundaryIf, 
    SCOPE_ENTRY     *pScope,
    PBOUNDARY_ENTRY *ppBoundary
    )
/*++
Called by: 
    SetBoundaryInfo()
Locks:
    Assumes caller holds a write lock on BOUNDARY_TABLE
Returns:
    NO_ERROR on success
    ERROR_NOT_ENOUGH_MEMORY
--*/
{
    if ((*ppBoundary = FindBoundaryEntry(pBoundaryIf, pScope)) != NULL)
       return NO_ERROR;

    return AddBoundaryEntry(pBoundaryIf, pScope, ppBoundary);
}

//
// Functions to manipulate boundaries
//

VOID
DeleteBoundaryFromInterface(pBoundary, pBoundaryIf)
    BOUNDARY_ENTRY *pBoundary;
    BOUNDARY_IF    *pBoundaryIf;
/*++
Called by:
    SetBoundaryInfo(), SNMPDeleteBoundaryFromInterface()
--*/
{
    Trace3(MCAST, "DeleteBoundaryFromInterface: If %x Scope %d.%d.%d.%d/%d", 
     pBoundaryIf->dwIfIndex,
     PRINT_IPADDR(pBoundary->pScope->ipGroupAddress),
     MaskToMaskLen(pBoundary->pScope->ipGroupMask) );

    RemoveEntryList(&(pBoundary->leBoundaryLink));
    pBoundary->pScope->ulNumInterfaces--;
    FREE(pBoundary);

    //
    // If there are no boundaries left, delete the pBoundaryIf.
    //
    if (IsListEmpty( &pBoundaryIf->leBoundaryList ))
    {
        // Remove the BoundaryIf
        MzapUninitBIf( pBoundaryIf );
        RemoveEntryList( &(pBoundaryIf->leBoundaryIfLink));
        RemoveEntryList( &(pBoundaryIf->leBoundaryIfMasterLink));
        FREE(pBoundaryIf);
    }
}

//
// Routines to process range information, which is what MGM deals with.
// It's much more efficient to pass range deltas to MGM than to pass
// prefixes, or original info, since overlapping boundaries might exist.
//

DWORD
AssertRange(
    IN OUT PLIST_ENTRY  pHead, 
    IN     IPV4_ADDRESS ipFirst,
    IN     IPV4_ADDRESS ipLast
    )
/*++
Called by:
    ConvertIfTableToRanges()
Locks:
    none
--*/
{
    PLIST_ENTRY  pleLast;
    RANGE_ENTRY *pRange;

    Trace2(MCAST, "AssertRange: (%d.%d.%d.%d - %d.%d.%d.%d)", 
     PRINT_IPADDR(ipFirst),
     PRINT_IPADDR(ipLast));

    //
    // Since we're calling this in <ipFirst,ipLast> order, the new
    // range may only overlap with the last range, if any.
    //

    pleLast = pHead->Blink;
    if (pleLast isnot pHead) 
    {
       RANGE_ENTRY *pPrevRange = CONTAINING_RECORD(pleLast, RANGE_ENTRY,
        leRangeLink);

       // See if it aggregates
       if (ntohl(ipFirst) <= ntohl(pPrevRange->ipLast) + 1) 
       { 
          if (ntohl(ipLast) > ntohl(pPrevRange->ipLast))
             pPrevRange->ipLast = ipLast;
          return NO_ERROR;
       }
    }

    //
    // Ok, no overlap, so add a new range
    //

    pRange = MALLOC( sizeof(RANGE_ENTRY) );
    if (pRange == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pRange->ipFirst = ipFirst;
    pRange->ipLast  = ipLast;
    InsertTailList(pHead, &pRange->leRangeLink);

    return NO_ERROR;
}

VOID
ConvertIfTableToRanges(
    IN  DWORD       dwIfIndex,
    OUT PLIST_ENTRY pHead
    )
/*++
Routine Description:
    Go through the list of boundaries on a given interface, and
    compose an ordered list of non-overlapping ranges.
Called by:
    ConvertTableToRanges()
    SetBoundaryInfo(), SNMPAddBoundaryToInterface(), 
    SNMPDeleteBoundaryFromInterface()
Locks:
    Assumes caller holds read lock on BOUNDARY_TABLE
--*/
{
    PLIST_ENTRY     pleNode;
    IPV4_ADDRESS    ipLastAddress;
    BOUNDARY_IF    *pBoundaryIf;
    BOUNDARY_ENTRY *pBoundary;

    Trace1( MCAST, "ENTERED ConvertIfTableToRanges: If=%x", dwIfIndex );

    InitializeListHead(pHead);

    pBoundaryIf = FindBIfEntry(dwIfIndex);
    if (pBoundaryIf) {
       for (pleNode = pBoundaryIf->leBoundaryList.Flink;
            pleNode isnot &pBoundaryIf->leBoundaryList;
            pleNode = pleNode->Flink) {
          pBoundary = CONTAINING_RECORD(pleNode, BOUNDARY_ENTRY,
           leBoundaryLink);

          ipLastAddress = pBoundary->pScope->ipGroupAddress | 
                         ~pBoundary->pScope->ipGroupMask;
          AssertRange(pHead, pBoundary->pScope->ipGroupAddress,
           ipLastAddress);
       }

       // Finally, we also have one for the IPv4 Local Scope
       if ( !IsListEmpty( &pBoundaryIf->leBoundaryList ) ) {
           AssertRange(pHead, IPV4_LOCAL_SCOPE_ADDR,
            IPV4_LOCAL_SCOPE_ADDR | ~IPV4_LOCAL_SCOPE_MASK);
       }
    }

    Trace0( MCAST, "LEFT ConvertIfTableToRanges" );
}


DWORD
ConvertTableToRanges(
    OUT PLIST_ENTRY pIfHead
    )
/*++
Routine description:
    Calculate the list of blocked ranges on all interfaces.
Locks:
    BOUNDARY_TABLE for reading
--*/
{
    DWORD       i, dwErr = NO_ERROR;
    PLIST_ENTRY pleNode;
    BOUNDARY_IF *pBoundaryIf, *pRangeIf;

    InitializeListHead(pIfHead);

    ENTER_READER(BOUNDARY_TABLE);
    {
       // For each interface with boundaries...
       for (i=0; i<BOUNDARY_HASH_TABLE_SIZE; i++) {
          for (pleNode = g_bbScopeTable[i].leInterfaceList.Flink;
               pleNode isnot &g_bbScopeTable[i].leInterfaceList;
               pleNode = pleNode->Flink) {
             pBoundaryIf = CONTAINING_RECORD(pleNode, BOUNDARY_IF,
              leBoundaryIfLink);
   
             // Add a node to the if range list 
             pRangeIf = MALLOC( sizeof(BOUNDARY_IF) );
             if (pRangeIf is NULL)
             {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
             }

             pRangeIf->dwIfIndex = pBoundaryIf->dwIfIndex;
             InsertTailList(pIfHead, &pRangeIf->leBoundaryIfLink);
      
             // Compose the range list for this interface
             ConvertIfTableToRanges(pBoundaryIf->dwIfIndex, 
              &pRangeIf->leBoundaryList);
          }
       }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    return dwErr;
}

VOID
GetRange(
    IN PLIST_ENTRY    pleNode, 
    IN PLIST_ENTRY    pHead,
    OUT PRANGE_ENTRY *ppRange, 
    OUT IPV4_ADDRESS *phipFirst, 
    OUT IPV4_ADDRESS *phipLast
    )
{
    if (pleNode isnot pHead) 
    {
       (*ppRange) = CONTAINING_RECORD(pleNode, RANGE_ENTRY, leRangeLink);
       *phipFirst = ntohl((*ppRange)->ipFirst);
       *phipLast  = ntohl((*ppRange)->ipLast);
    } 
    else 
    {
       (*ppRange) = NULL;
       *phipFirst = *phipLast = 0xFFFFFFFF;
    }
}

VOID
GetRangeIf(
    IN  PLIST_ENTRY   pleNode, 
    IN  PLIST_ENTRY   pHead,
    OUT PBOUNDARY_IF *ppRangeIf, 
    OUT ULONG        *pulIfIndex
    )
{
    if (pleNode isnot pHead) 
    {
       (*ppRangeIf) = CONTAINING_RECORD(pleNode, BOUNDARY_IF, leBoundaryIfLink);
       *pulIfIndex = (*ppRangeIf)->dwIfIndex;
    } 
    else 
    {
       (*ppRangeIf) = NULL;
       *pulIfIndex = 0xFFFFFFFF;
    }
}

VOID
FreeRangeList(
    IN PLIST_ENTRY pHead
    )
/*++
Routine description:
    Free up space from a range list
Called by:
    ProcessIfRangeDeltas()
Locks:
    none
--*/
{
    RANGE_ENTRY *pRange;
    PLIST_ENTRY  pleNode;

    for (pleNode = pHead->Flink;
         pleNode isnot pHead;
         pleNode = pHead->Flink) 
    {
       pRange = CONTAINING_RECORD(pleNode, RANGE_ENTRY, leRangeLink);
       RemoveEntryList(&pRange->leRangeLink);
       FREE(pRange);
    }
}

VOID
FreeIfRangeLists(
    IN PLIST_ENTRY pHead
    )
/*++
Routine description:
    Free all entries in the list, as well as the list of ranges off each entry.
Called by:
    ProcessRangeDeltas()
Locks:
    none
--*/
{
    BOUNDARY_IF *pRangeIf;
    PLIST_ENTRY  pleNode;

    for (pleNode = pHead->Flink;
         pleNode isnot pHead;
         pleNode = pHead->Flink) 
    {
       pRangeIf = CONTAINING_RECORD(pleNode, BOUNDARY_IF, leBoundaryIfLink);
       RemoveEntryList(&pRangeIf->leBoundaryIfLink);
       FreeRangeList(&pRangeIf->leBoundaryList);
       FREE(pRangeIf);
    }
}

//
//   Check if the interface
//   is the RAS Server Interface in which case, the 
//   callback should be invoked for all clients connected
//   and the NEXT HOP address should be set to the client
//   address.  Otherwise zero should be fine as NHOP
//
VOID
BlockGroups(
    IN IPV4_ADDRESS ipFirst, 
    IN IPV4_ADDRESS ipLast, 
    IN DWORD        dwIfIndex
    )
{
    IPV4_ADDRESS ipNextHop;
    PICB         picb;
    PLIST_ENTRY  pleNode;

    ENTER_READER(ICB_LIST);
    do {

        // Look up the type of this interface

        picb = InterfaceLookupByIfIndex(dwIfIndex);

        if (picb==NULL)
            break;


        // If interface is not an NBMA interface, just block on the interface
        // Currently, the only NBMA-like interface is the "internal" interface

        if (picb->ritType isnot ROUTER_IF_TYPE_INTERNAL)
        {
            Trace3( MCAST, 
                    "Blocking [%d.%d.%d.%d-%d.%d.%d.%d] on if %x",
                    PRINT_IPADDR(ipFirst),
                    PRINT_IPADDR(ipLast),
                    dwIfIndex );

            g_pfnMgmBlockGroups(ipFirst, ipLast, dwIfIndex, 0);

            break;
        }
    
        // For NBMA interfaces, need to block on each next hop
    
        //    to enumerate all next hops on the internal interface, 
        //    we have to walk the PICB list looking for entries with
        //    an ifIndex of -1.
    
        for (pleNode = ICBList.Flink;
             pleNode isnot &ICBList;
             pleNode = pleNode->Flink)
        {
            picb = CONTAINING_RECORD(pleNode, ICB, leIfLink);
    
            if (picb->ritType isnot ROUTER_IF_TYPE_CLIENT)
                continue;

            Trace4( MCAST, 
                    "Blocking [%d.%d.%d.%d-%d.%d.%d.%d] on if %x nh %d.%d.%d.%d",
                    PRINT_IPADDR(ipFirst),
                    PRINT_IPADDR(ipLast),
                    dwIfIndex,
                    PRINT_IPADDR(picb->dwRemoteAddress) );

            g_pfnMgmBlockGroups( ipFirst, 
                                 ipLast, 
                                 dwIfIndex, 
                                 picb->dwRemoteAddress );
        }
    } while(0);
    EXIT_LOCK(ICB_LIST);
}

//
//   Check if the interface
//   is the RAS Server Interface in which case, the 
//   callback should be invoked for all clients connected
//   and the NEXT HOP address should be set to the client
//   address.  Otherwise zero should be fine as NHOP
//
VOID
UnblockGroups(
    IN IPV4_ADDRESS ipFirst, 
    IN IPV4_ADDRESS ipLast, 
    IN DWORD        dwIfIndex
    )
{
    IPV4_ADDRESS ipNextHop;
    PICB         picb;
    PLIST_ENTRY  pleNode;

    ENTER_READER(ICB_LIST);
    do {

        // Look up the type of this interface

        picb = InterfaceLookupByIfIndex(dwIfIndex);

        if (picb == NULL ) 
            break;
        
        // If interface is not an NBMA interface, just block on the interface
        // Currently, the only NBMA-like interface is the "internal" interface

        if (picb->ritType isnot ROUTER_IF_TYPE_INTERNAL)
        {
            Trace3( MCAST, 
                    "Unblocking [%d.%d.%d.%d-%d.%d.%d.%d] on if %x",
                    PRINT_IPADDR(ipFirst),
                    PRINT_IPADDR(ipLast),
                    dwIfIndex );

            g_pfnMgmUnBlockGroups(ipFirst, ipLast, dwIfIndex, 0);

            break;
        }
    
        // For NBMA interfaces, need to block on each next hop
    
        //    to enumerate all next hops on the internal interface, 
        //    we have to walk the PICB list looking for entries with
        //    an ifIndex of -1.
    
        for (pleNode = ICBList.Flink;
             pleNode isnot &ICBList;
             pleNode = pleNode->Flink)
        {
            picb = CONTAINING_RECORD(pleNode, ICB, leIfLink);
    
            if (picb->ritType isnot ROUTER_IF_TYPE_CLIENT)
                continue;

            Trace4( MCAST, 
                    "Unblocking [%d.%d.%d.%d-%d.%d.%d.%d] on if %x nh %d.%d.%d.%d",
                    PRINT_IPADDR(ipFirst),
                    PRINT_IPADDR(ipLast),
                    dwIfIndex,
                    PRINT_IPADDR(picb->dwRemoteAddress) );

            g_pfnMgmUnBlockGroups( ipFirst, 
                                   ipLast, 
                                   dwIfIndex, 
                                   picb->dwRemoteAddress );
        }
    } while(0);
    EXIT_LOCK(ICB_LIST);
}

VOID
ProcessIfRangeDeltas(
    IN DWORD       dwIfIndex,
    IN PLIST_ENTRY pOldHead,
    IN PLIST_ENTRY pNewHead
    )
/*++
Routine Description:
    Go through the previous and current lists of ranges, and inform
    MGM of any differences found.
Called by:
    SetBoundaryInfo(), SNMPAddBoundaryToInterface(),
    SNMPDeleteBoundaryFromInterface()
Locks:
    none
--*/
{
    PLIST_ENTRY pleOld = pOldHead->Flink,
                pleNew = pNewHead->Flink;
    RANGE_ENTRY *pOld, *pNew;
    IPV4_ADDRESS hipOldFirst, hipOldLast, hipNewFirst, hipNewLast;
    IPV4_ADDRESS hipLast;

    // Get ranges in host order fields
    GetRange(pleOld, pOldHead, &pOld, &hipOldFirst, &hipOldLast);
    GetRange(pleNew, pNewHead, &pNew, &hipNewFirst, &hipNewLast);

    // Loop until we hit the end of both lists
    while (pOld || pNew) 
    {

       // See if there's a new range to block
       if (pNew && hipNewFirst < hipOldFirst) 
       {
          hipLast = MIN(hipNewLast, hipOldFirst-1);
          BlockGroups(pNew->ipFirst, htonl(hipLast), dwIfIndex);
          hipNewFirst   = hipOldFirst;
          pNew->ipFirst = htonl(hipNewFirst);
          if (hipNewFirst > hipNewLast) 
          {
             // advance new
             pleNew = pleNew->Flink;
             GetRange(pleNew, pNewHead, &pNew, &hipNewFirst, &hipNewLast);
          }
       }

       // See if there's an old range to unblock
       if (pOld && hipOldFirst < hipNewFirst) 
       {
          hipLast = MIN(hipOldLast, hipNewFirst-1);
          UnblockGroups(pOld->ipFirst, htonl(hipLast), dwIfIndex);
          hipOldFirst   = hipNewFirst;
          pOld->ipFirst = htonl(hipOldFirst);
          if (hipOldFirst > hipOldLast) 
          {
             // advance old
             pleOld = pleOld->Flink;
             GetRange(pleOld, pOldHead, &pOld, &hipOldFirst, &hipOldLast);
          }
       }

       // See if there's an unchanged range to skip
       if (pOld && pNew && hipOldFirst == hipNewFirst) 
       {
          hipLast = MIN(hipOldLast, hipNewLast);
          hipOldFirst   = hipLast+1;
          pOld->ipFirst = htonl(hipOldFirst);
          if (hipOldFirst > hipOldLast) 
          {
             // advance old
             pleOld = pleOld->Flink;
             GetRange(pleOld, pOldHead, &pOld, &hipOldFirst, &hipOldLast);
          }
          hipNewFirst   = hipLast+1;
          pNew->ipFirst = htonl(hipNewFirst);
          if (hipNewFirst > hipNewLast) 
          {
             // advance new
             pleNew = pleNew->Flink;
             GetRange(pleNew, pNewHead, &pNew, &hipNewFirst, &hipNewLast);
          }
       }
    }
    
    FreeRangeList(pOldHead);
    FreeRangeList(pNewHead);
}

VOID
ProcessRangeDeltas(
    IN PLIST_ENTRY pOldIfHead,
    IN PLIST_ENTRY pNewIfHead
    )
{
    PLIST_ENTRY pleOldIf = pOldIfHead->Flink,
                pleNewIf = pNewIfHead->Flink;
    BOUNDARY_IF *pOldIf, *pNewIf;
    ULONG       ulOldIfIndex, ulNewIfIndex;
    LIST_ENTRY  emptyList;

    GetRangeIf(pleOldIf, pOldIfHead, &pOldIf, &ulOldIfIndex);
    GetRangeIf(pleNewIf, pNewIfHead, &pNewIf, &ulNewIfIndex);

    InitializeListHead(&emptyList);

    // Loop until we hit the end of both lists
    while (pOldIf || pNewIf) 
    {

       // See if there's a new interface without old boundaries
       if (pNewIf && ulNewIfIndex < ulOldIfIndex) 
       {
          // process it
          ProcessIfRangeDeltas(ulNewIfIndex, &emptyList,
           &pNewIf->leBoundaryList);

          // advance new
          pleNewIf = pleNewIf->Flink;
          GetRangeIf(pleNewIf, pNewIfHead, &pNewIf, &ulNewIfIndex);
       }

       // See if there's an old interface without new boundaries 
       if (pOldIf && ulOldIfIndex < ulNewIfIndex) 
       {
          // process it
          ProcessIfRangeDeltas(ulOldIfIndex, &pOldIf->leBoundaryList, 
           &emptyList);

          // advance old
          pleOldIf = pleOldIf->Flink;
          GetRangeIf(pleOldIf, pOldIfHead, &pOldIf, &ulOldIfIndex);
       }

       // See if there's an ifindex to change
       if (pOldIf && pNewIf && ulOldIfIndex == ulNewIfIndex) 
       {
          // process it
          ProcessIfRangeDeltas(ulOldIfIndex, &pOldIf->leBoundaryList, 
           &pNewIf->leBoundaryList);

          // advance old
          pleOldIf = pleOldIf->Flink;
          GetRangeIf(pleOldIf, pOldIfHead, &pOldIf, &ulOldIfIndex);
          
          // advance new
          pleNewIf = pleNewIf->Flink;
          GetRangeIf(pleNewIf, pNewIfHead, &pNewIf, &ulNewIfIndex);
       }
    }
    
    FreeIfRangeLists(pOldIfHead);
    FreeIfRangeLists(pNewIfHead);
}

VOID
ParseScopeInfo(
    IN  PBYTE                  pBuffer,
    IN  ULONG                  ulNumScopes,
    OUT PSCOPE_ENTRY          *ppScopes
    )
/*++
Description:
   Routines to parse registry info into a pre-allocated array.
   Space for names will be dynamically allocated by this function,
   and it is the caller's responsibility to free them.
Called by:
    SetScopeInfo()
--*/
{
    DWORD             i, j, dwLen, dwNumNames, dwLanguage, dwFlags;
    SCOPE_NAME_BUFFER pScopeName;
    PSCOPE_ENTRY      pScopes;

    *ppScopes = pScopes = MALLOC( ulNumScopes * sizeof(SCOPE_ENTRY) );

    for (i=0; i<ulNumScopes; i++) 
    {
        // Copy group address, and mask
        dwLen = 2 * sizeof(IPV4_ADDRESS);
        CopyMemory(&pScopes[i].ipGroupAddress, pBuffer, dwLen);
        pBuffer += dwLen;

        // Get flags
        CopyMemory(&dwFlags, pBuffer, sizeof(DWORD));
        pBuffer += sizeof(DWORD);
        pScopes[i].bDivisible = dwFlags;
 
        CopyMemory(&dwNumNames, pBuffer, sizeof(DWORD));
        pBuffer += sizeof(DWORD);
 
        pScopes[i].ulNumInterfaces = 0; // this value is ignored
        pScopes[i].ulNumNames = 0;
        InitializeListHead( &pScopes[i].leNameList );
 
        for (j=0; j<dwNumNames; j++) 
        {
            // Set language name
            CopyMemory(&dwLanguage, pBuffer, sizeof(dwLanguage));
            pBuffer += sizeof(dwLanguage);

            // Get scope name length
            CopyMemory(&dwLen, pBuffer, sizeof(DWORD));
            pBuffer += sizeof(DWORD);
            if (dwLen > MAX_SCOPE_NAME_LEN)
            {
                Trace2(MCAST, 
                       "ERROR %d-char scope name in registry, truncated to %d",
                       dwLen, MAX_SCOPE_NAME_LEN);
                dwLen = MAX_SCOPE_NAME_LEN;
            }
     
            // Set scope name
            wcsncpy(pScopeName, (SCOPE_NAME)pBuffer, dwLen);
            pScopeName[ dwLen ] = '\0';
            pBuffer += dwLen * SNCHARSIZE;
    
            AssertScopeName( &pScopes[i], (LANGID)dwLanguage, pScopeName );
        }
    }
}

VOID
FreeScopeInfo(
    PSCOPE_ENTRY pScopes,
    DWORD        dwNumScopes
    )
{
    PLIST_ENTRY pleNode;
    DWORD       i;

    for (i=0; i<dwNumScopes; i++)
    {
        while (!IsListEmpty(&pScopes[i].leNameList)) 
        {
            DeleteScopeName( pScopes[i].leNameList.Flink );
        }
    }

    FREE(pScopes);
}

DWORD
SetScopeInfo(
    PRTR_INFO_BLOCK_HEADER pInfoHdr
    )
/*++
Routine Description:
    Sets the scope info associated with the router.
    First we add the scopes present in the scope info.  Then we
    enumerate the scopes and delete those that we don't find in the
    scope info.
Locks:
    BOUNDARY_TABLE for writing
Called by:
    InitRouter() in init.c
    SetGlobalInfo() in iprtrmgr.c
--*/
{
    DWORD             dwResult = NO_ERROR;
    DWORD             dwNumScopes, i, j;
    PRTR_TOC_ENTRY    pToc;
    SCOPE_ENTRY      *pScopes;
    BOOL              bFound;
    SCOPE_ENTRY      *pScope;
    BYTE             *pBuffer;
    LIST_ENTRY        leOldIfRanges, leNewIfRanges;
    PSCOPE_NAME_ENTRY pName;
    PLIST_ENTRY       pleNode;

    Trace0( MCAST, "ENTERED SetScopeInfo" );

    pToc = GetPointerToTocEntry(IP_MCAST_BOUNDARY_INFO, pInfoHdr);
    if (pToc is NULL) {
       // No TOC means no change
       Trace0( MCAST, "LEFT SetScopeInfo" );
       return NO_ERROR;
    }

    //
    // This call wouldn't be needed if we saved this info in the
    // BOUNDARY_IF structure, but since it should rarely, if ever,
    // change, we won't worry about it for now.
    //
    dwResult = ConvertTableToRanges(&leOldIfRanges);
    if (dwResult isnot NO_ERROR) {
       return dwResult;
    }

    if (pToc->InfoSize is 0) 
    {
       StopMZAP();

       // delete all scopes
       ENTER_WRITER(BOUNDARY_TABLE);
       {
          for (i=0; i<MAX_SCOPES; i++)
             DeleteScope(&g_scopeEntry[i]);
       }
       EXIT_LOCK(BOUNDARY_TABLE);

       // Inform MGM of deltas
       dwResult = ConvertTableToRanges(&leNewIfRanges);
       if (dwResult isnot NO_ERROR) 
       {
          return dwResult;
       }

       ProcessRangeDeltas(&leOldIfRanges, &leNewIfRanges);

       Trace0( MCAST, "LEFT SetScopeInfo" );
       return NO_ERROR;
    }

    pBuffer = (PBYTE)GetInfoFromTocEntry(pInfoHdr, pToc);
    if (pBuffer is NULL)
    {
       return ERROR_INSUFFICIENT_BUFFER;
    }

    // Scope count is stored in first DWORD
    dwNumScopes = *((PDWORD) pBuffer);
    pBuffer += sizeof(DWORD);

    ParseScopeInfo(pBuffer, dwNumScopes, &pScopes);

    ENTER_WRITER(BOUNDARY_TABLE);
    {
       //
       // Add all the new scopes
       //

       for (i=0; i<dwNumScopes; i++) 
       {
          dwResult = AssertScope( pScopes[i].ipGroupAddress, 
                                  pScopes[i].ipGroupMask, 
                                  &pScope );

          if (!pScope)
          {
              Trace2( MCAST, 
                      "Bad scope prefix %d.%d.%d.%d/%d.%d.%d.%d",
                      PRINT_IPADDR(pScopes[i].ipGroupAddress),
                      PRINT_IPADDR(pScopes[i].ipGroupMask) );

              continue;
          }

          pScope->bDivisible = pScopes[i].bDivisible;

          for (pleNode = pScopes[i].leNameList.Flink;
               pleNode isnot &pScopes[i].leNameList;
               pleNode = pleNode->Flink)
          {
              pName = CONTAINING_RECORD(pleNode, SCOPE_NAME_ENTRY, leNameLink);

              AssertScopeName( pScope, pName->idLanguage, pName->snScopeName );
          }
       }

       //
       // Now enumerate the scopes, deleting the scopes that are not in the
       // new list.
       //
       for (i=0; i<MAX_SCOPES; i++) 
       {
          pScope = &g_scopeEntry[i];

          if (pScope->ipGroupAddress == 0)
             continue; // not active

          bFound = FALSE;
          for (j=0; j<dwNumScopes; j++) 
          {
             if (pScopes[j].ipGroupAddress == pScope->ipGroupAddress
              && pScopes[j].ipGroupMask    == pScope->ipGroupMask ) 
             {
                bFound = TRUE;
                break;
             }
          }
   
          if (!bFound)
             DeleteScope(pScope);
       }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    // Free scopes and names
    FreeScopeInfo(pScopes, dwNumScopes);

    dwResult = ConvertTableToRanges(&leNewIfRanges);
    if (dwResult isnot NO_ERROR) {
       return dwResult;
    }

    ProcessRangeDeltas(&leOldIfRanges, &leNewIfRanges);

    Trace0( MCAST, "LEFT SetScopeInfo" );

    return NO_ERROR;
}

DWORD
GetScopeInfo(
    IN OUT PRTR_TOC_ENTRY         pToc,
    IN OUT PDWORD                 pdwTocIndex,
    IN OUT PBYTE                  pBuffer,
    IN     PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwBufferSize
    )
/*++
Routine Description:
    Called to get a copy of the scope information to write into the
    registry.
Locks:
    BOUNDARY_TABLE for reading
Arguments:
    pToc            Space to fill in the TOC entry (may be NULL)
    pdwTocIndex     Pointer to TOC index to be incremented if TOC written
    pBuffer         Pointer to buffer into which info is to be written
    pInfoHdr        Pointer to info block header for offset computation
    pdwBufferSize   [IN]  Size of the buffer pointed to by pBuffer
                    [OUT] Size of data copied out, or size of buffer needed
Called by:
    GetGlobalConfiguration() in info.c
Return Value:
    NO_ERROR                    Buffer of size *pdwBufferSize was copied out
    ERROR_INSUFFICIENT_BUFFER   The buffer was too small to copy out the info
                                The size of buffer needed is in *pdwBufferSize
--*/
{
    DWORD             i, dwSizeReqd, dwNumScopes, dwLen, dwNumNames,
                      dwLanguage, dwFlags;
    PLIST_ENTRY       pleNode, pleNode2;
    PSCOPE_ENTRY      pScope;
    PSCOPE_NAME_ENTRY pName;

    dwSizeReqd = sizeof(DWORD);
    dwNumScopes = 0;

    ENTER_READER(BOUNDARY_TABLE);
    {
        //
        // Calculate size required
        //

        for (pleNode = g_MasterScopeList.Flink;
             pleNode isnot &g_MasterScopeList;
             pleNode = pleNode->Flink) 
        {
           pScope = CONTAINING_RECORD(pleNode, SCOPE_ENTRY, leScopeLink);

           if ( !pScope->ipGroupAddress )
              continue; // not active

           dwSizeReqd += 2*sizeof(IPV4_ADDRESS) + 2*sizeof(DWORD);

           for (pleNode2 = pScope->leNameList.Flink;
                pleNode2 isnot &pScope->leNameList;
                pleNode2 = pleNode2->Flink)
           {
               pName = CONTAINING_RECORD( pleNode2, 
                                          SCOPE_NAME_ENTRY, 
                                          leNameLink );

               dwSizeReqd += (DWORD)(2 * sizeof(DWORD)
                             + sn_strlen(pName->snScopeName) * SNCHARSIZE);
           }

           dwNumScopes++;
        }
        if (dwNumScopes) {
           dwSizeReqd += sizeof(DWORD); // space for scope count
        }
 
        // 
        // Increment TOC index by number of TOC entries needed
        // 
        
        if (pdwTocIndex && dwSizeReqd>0)
           (*pdwTocIndex)++;
 
        if (dwSizeReqd > *pdwBufferSize) 
        {
           *pdwBufferSize = dwSizeReqd;
           EXIT_LOCK(BOUNDARY_TABLE);
           return ERROR_INSUFFICIENT_BUFFER;
        }
 
        *pdwBufferSize = dwSizeReqd;
 
        if (pToc) 
        {
            //pToc->InfoVersion = IP_MCAST_BOUNDARY_INFO;
            pToc->InfoType = IP_MCAST_BOUNDARY_INFO;
            pToc->Count    = 1; // single variable-sized opaque block
            pToc->InfoSize = dwSizeReqd;
            pToc->Offset   = (ULONG)(pBuffer - (PBYTE) pInfoHdr);
        }
 
        if (pBuffer)
        {

            //
            // Add scope count
            //

            CopyMemory(pBuffer, &dwNumScopes, sizeof(DWORD));
            pBuffer += sizeof(DWORD);

            //
            // Go through and get each scope
            //
    
            for (pleNode = g_MasterScopeList.Flink;
                 pleNode isnot &g_MasterScopeList;
                 pleNode = pleNode->Flink) 
            {
                pScope = CONTAINING_RECORD(pleNode, SCOPE_ENTRY, leScopeLink);

                if ( !pScope->ipGroupAddress )
                   continue; // not active
      
                // Copy scope address, and mask
                dwLen = 2 * sizeof(IPV4_ADDRESS);
                CopyMemory(pBuffer, &pScope->ipGroupAddress, dwLen);
                pBuffer += dwLen;

                // Copy flags
                dwFlags = pScope->bDivisible;
                CopyMemory(pBuffer, &dwFlags, sizeof(dwFlags));
                pBuffer += sizeof(dwFlags);

                // Copy # of names
                CopyMemory(pBuffer, &pScope->ulNumNames, sizeof(DWORD));
                pBuffer += sizeof(DWORD);
     
                for (pleNode2 = pScope->leNameList.Flink;
                     pleNode2 isnot &pScope->leNameList;
                     pleNode2 = pleNode2->Flink)
                {
                    pName = CONTAINING_RECORD( pleNode2, 
                                               SCOPE_NAME_ENTRY, 
                                               leNameLink );

                    // Save language
                    dwLanguage = pName->idLanguage;
                    CopyMemory(pBuffer, &dwLanguage, sizeof(dwLanguage));
                    pBuffer += sizeof(dwLanguage);
    
                    // Copy scope name (save length in words)
                    dwLen = sn_strlen(pName->snScopeName);
                    CopyMemory(pBuffer, &dwLen, sizeof(DWORD));
                    pBuffer += sizeof(DWORD);
                    dwLen *= SNCHARSIZE;
                    CopyMemory(pBuffer, pName->snScopeName, dwLen);
                    pBuffer += dwLen;
                }
            }
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    return NO_ERROR;
}

DWORD
SetBoundaryInfo(
    PICB                   picb,
    PRTR_INFO_BLOCK_HEADER pInfoHdr
    )
/*++
Routine Description:
    Sets the boundary info associated with an interface.
    First we add the boundaries present in the boundary info.  Then we
    enumerate the boundaries and delete those that we don't find in the
    boundary info.
Arguments:
    picb        The ICB of the interface
Called by:
    AddInterface() in iprtrmgr.c
    SetInterfaceInfo() in iprtrmgr.c
Locks:
    BOUNDARY_TABLE for writing
--*/
{
    DWORD            dwResult = NO_ERROR,
                     dwNumBoundaries, i, j;

    PRTR_TOC_ENTRY   pToc;

    PMIB_BOUNDARYROW pBoundaries;

    BOOL             bFound;

    BOUNDARY_ENTRY  *pBoundary;

    SCOPE_ENTRY     *pScope;

    LIST_ENTRY       leOldRanges, 
                     leNewRanges,
                    *pleNode, 
                    *pleNext;

    BOUNDARY_IF     *pBoundaryIf;

    Trace1( MCAST, "ENTERED SetBoundaryInfo for If %x", picb->dwIfIndex );

    pToc = GetPointerToTocEntry(IP_MCAST_BOUNDARY_INFO, pInfoHdr);

    if (pToc is NULL) 
    {
       // No TOC means no change
       Trace0( MCAST, "LEFT SetBoundaryInfo" );
       return NO_ERROR;
    }

    dwNumBoundaries = pToc->Count;

    ENTER_WRITER(BOUNDARY_TABLE);
    {

    //
    // This call wouldn't be needed if we saved this info in the
    // BOUNDARY_IF structure, but since it should rarely, if ever,
    // change, we won't worry about it for now.
    //
        ConvertIfTableToRanges(picb->dwIfIndex, &leOldRanges);

        if (pToc->InfoSize is 0) 
        {
            // Delete all boundaries on this interface
            pBoundaryIf = FindBIfEntry(picb->dwIfIndex);

            if (pBoundaryIf) 
            {
                for (pleNode = pBoundaryIf->leBoundaryList.Flink;
                     pleNode isnot &pBoundaryIf->leBoundaryList;
                     pleNode = pBoundaryIf->leBoundaryList.Flink) 
                {
                   pBoundary = CONTAINING_RECORD(pleNode, BOUNDARY_ENTRY,
                    leBoundaryLink);

                   DeleteBoundaryFromInterface(pBoundary, pBoundaryIf);
                }
             }
        } 
        else 
        {
            pBoundaries = (PMIB_BOUNDARYROW)GetInfoFromTocEntry(pInfoHdr, pToc);

            dwResult = AssertBIfEntry(picb->dwIfIndex, &pBoundaryIf,
                (picb->dwOperationalState is IF_OPER_STATUS_OPERATIONAL));

            // Add all the new boundaries
            for (i=0; i<dwNumBoundaries; i++) 
            {
                dwResult = AssertScope( pBoundaries[i].dwGroupAddress,
                                        pBoundaries[i].dwGroupMask,
                                        &pScope );
                if (pScope)
                {
                   dwResult = AssertBoundaryEntry( pBoundaryIf, 
                                                   pScope, 
                                                   &pBoundary);
                }
            }

            //
            // Now enumerate the boundaries, deleting the boundaries that are 
            // not in the new list.
            //
   
            for (pleNode = pBoundaryIf->leBoundaryList.Flink;
                 pleNode isnot &pBoundaryIf->leBoundaryList;
                 pleNode = pleNext) 
            {
               pleNext = pleNode->Flink;
               pBoundary = CONTAINING_RECORD(pleNode, BOUNDARY_ENTRY,
                leBoundaryLink);
               pScope = pBoundary->pScope;
               bFound = FALSE;
               for (j=0; j<dwNumBoundaries; j++) 
               {
                  if (pBoundaries[j].dwGroupAddress == pScope->ipGroupAddress
                   && pBoundaries[j].dwGroupMask    == pScope->ipGroupMask ) 
                  {
                     bFound = TRUE;
                     break;
                  }
               }
        
               if (!bFound)
                  DeleteBoundaryFromInterface(pBoundary, pBoundaryIf);
            }
        }
     
        ConvertIfTableToRanges(picb->dwIfIndex, &leNewRanges);
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    // Inform MGM of deltas 
    ProcessIfRangeDeltas(picb->dwIfIndex, &leOldRanges, &leNewRanges);

    StartMZAP();

    Trace0( MCAST, "LEFT SetBoundaryInfo" );

    return NO_ERROR;
}

DWORD
GetMcastLimitInfo(
    IN     PICB                   picb,
    OUT    PRTR_TOC_ENTRY         pToc,
    IN OUT PDWORD                 pdwTocIndex,
    OUT    PBYTE                  pBuffer,
    IN     PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwBufferSize
    )
/*++
Routine Description:
    Called to get a copy of the limit information to write into the
    registry.
Arguments:
    picb            Interface entry
    pToc            Space to fill in the TOC entry (may be NULL)
    pdwTocIndex     Pointer to TOC index to be incremented if TOC written
    pBuffer         Pointer to buffer into which info is to be written
    pInfoHdr        Pointer to info block header for offset computation
    pdwBufferSize   [IN]  Size of the buffer pointed to by pBuffer
                    [OUT] Size of data copied out, or size of buffer needed
Called by:
    GetInterfaceConfiguration() in info.c
Return Value:
    NO_ERROR                    Buffer of size *pdwBufferSize was copied out
    ERROR_INSUFFICIENT_BUFFER   The buffer was too small to copy out the info
                                The size of buffer needed is in *pdwBufferSize
--*/
{
    DWORD           i, dwLen, dwSizeReqd, dwNumBoundaries;
    PLIST_ENTRY     pleNode;
    PMIB_MCAST_LIMIT_ROW pLimit;

    dwSizeReqd = 0;
    dwNumBoundaries = 0;

    if (picb->dwMcastTtl < 2 and picb->dwMcastRateLimit is 0)
    {
        // No block needed, since values are default
        *pdwBufferSize = 0;
        return NO_ERROR;        
    }

    if (pdwTocIndex)
       (*pdwTocIndex)++;

    if (*pdwBufferSize < sizeof (MIB_MCAST_LIMIT_ROW))
    {
        *pdwBufferSize = sizeof(MIB_MCAST_LIMIT_ROW);
        return ERROR_INSUFFICIENT_BUFFER;
    }

    if (pToc)
    {
        //pToc->InfoVersion = IP_MCAST_BOUNDARY_INFO;
        pToc->InfoSize = sizeof(MIB_MCAST_LIMIT_ROW);
        pToc->InfoType = IP_MCAST_LIMIT_INFO;
        pToc->Count    = 1;
        pToc->Offset   = (DWORD)(pBuffer - (PBYTE) pInfoHdr);
    }

    *pdwBufferSize = sizeof(MIB_MCAST_LIMIT_ROW);

    pLimit              = (PMIB_MCAST_LIMIT_ROW)pBuffer;
    pLimit->dwTtl       = picb->dwMcastTtl;
    pLimit->dwRateLimit = picb->dwMcastRateLimit;

    return NO_ERROR;
}

DWORD
GetBoundaryInfo(
    IN     PICB                   picb,
    OUT    PRTR_TOC_ENTRY         pToc,
    IN OUT PDWORD                 pdwTocIndex,
    OUT    PBYTE                  pBuffer,
    IN     PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwBufferSize
    )
/*++
Routine Description:
    Called to get a copy of the boundary information to write into the
    registry.
Locks:
    BOUNDARY_TABLE for reading
Arguments:
    picb            Interface entry
    pToc            Space to fill in the TOC entry (may be NULL)
    pdwTocIndex     Pointer to TOC index to be incremented if TOC written
    pBuffer         Pointer to buffer into which info is to be written
    pInfoHdr        Pointer to info block header for offset computation
    pdwBufferSize   [IN]  Size of the buffer pointed to by pBuffer
                    [OUT] Size of data copied out, or size of buffer needed
Called by:
    GetInterfaceConfiguration() in info.c
Return Value:
    NO_ERROR                    Buffer of size *pdwBufferSize was copied out
    ERROR_INSUFFICIENT_BUFFER   The buffer was too small to copy out the info
                                The size of buffer needed is in *pdwBufferSize
--*/

{
    DWORD           i, dwLen, dwSizeReqd, dwNumBoundaries;
    PLIST_ENTRY     pleNode;
    BOUNDARY_ENTRY *pBoundary;
    MIB_BOUNDARYROW BoundaryRow;
    BOUNDARY_IF    *pIf;

    dwSizeReqd = 0;
    dwNumBoundaries = 0;

    ENTER_READER(BOUNDARY_TABLE);
    {
       pIf = FindBIfEntry(picb->dwIfIndex);
       if (!pIf) 
       {
          *pdwBufferSize = 0;
          EXIT_LOCK(BOUNDARY_TABLE);
          return NO_ERROR;
       }

       //
       // Calculate size required.  We could have stored the count
       // in the boundary entry, but we expect a pretty small number
       // of boundaries (1 or 2) so use brute force for now.
       //

       for (pleNode = pIf->leBoundaryList.Flink;
            pleNode isnot &pIf->leBoundaryList;
            pleNode = pleNode->Flink) 
       {
          dwNumBoundaries++;
       }

       dwSizeReqd += dwNumBoundaries * sizeof(MIB_BOUNDARYROW);

       //
       // Increment TOC index by number of TOC entries needed
       //

       if (pdwTocIndex && dwSizeReqd>0)
          (*pdwTocIndex)++;

       if (dwSizeReqd > *pdwBufferSize) 
       {
          *pdwBufferSize = dwSizeReqd;
          EXIT_LOCK(BOUNDARY_TABLE);
          return ERROR_INSUFFICIENT_BUFFER;
       }

       *pdwBufferSize = dwSizeReqd;

       if (pToc)
       {
           //pToc->InfoVersion = sizeof(MIB_BOUNDARYROW);
           pToc->InfoSize = sizeof(MIB_BOUNDARYROW);
           pToc->InfoType = IP_MCAST_BOUNDARY_INFO;
           pToc->Count    = dwNumBoundaries;
           pToc->Offset   = (DWORD)(pBuffer - (PBYTE) pInfoHdr);
       }

       // Go through and copy each boundary
       for (pleNode = pIf->leBoundaryList.Flink;
            pleNode isnot &pIf->leBoundaryList;
            pleNode = pleNode->Flink) 
       {
          pBoundary = CONTAINING_RECORD(pleNode, BOUNDARY_ENTRY,
              leBoundaryLink);

          BoundaryRow.dwGroupAddress = pBoundary->pScope->ipGroupAddress;
          BoundaryRow.dwGroupMask    = pBoundary->pScope->ipGroupMask;

          CopyMemory(pBuffer, &BoundaryRow, sizeof(MIB_BOUNDARYROW));
          pBuffer += sizeof(MIB_BOUNDARYROW);
       }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    return NO_ERROR;
}




//
// Functions used by SNMP
//

DWORD
SNMPDeleteScope(
    IN  IPV4_ADDRESS  ipGroupAddress,
    IN  IPV4_ADDRESS  ipGroupMask
    )
/*++
Called by: 
Locks: 
    BOUNDARY_TABLE for writing.
    ICB_LIST and then PROTOCOL_CB_LIST for writing (for saving to registry).
Returns:
    ERROR_INVALID_PARAMETER if trying to delete the local scope
    whatever DeleteScope() returns
    whatever ProcessSaveGlobalConfigInfo() returns
--*/
{
    DWORD        dwErr = NO_ERROR;
    PSCOPE_ENTRY pScope;
    BOOL         bChanged = FALSE;

    if ( IN_IPV4_LOCAL_SCOPE(ipGroupAddress) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    ENTER_WRITER(BOUNDARY_TABLE);
    {
        pScope = FindScope( ipGroupAddress, ipGroupMask );

        if (pScope)
        {
            dwErr = DeleteScope( pScope );
            bChanged = TRUE;
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    // Resave the scopes to the registry
    if (dwErr is NO_ERROR && bChanged) 
    {
       // ProcessSaveGlobalConfigInfo() requires us to have both the 
       // ICB_LIST and the PROTOCOL_CB_LIST locked.
       ENTER_WRITER(ICB_LIST);
       ENTER_WRITER(PROTOCOL_CB_LIST);

       dwErr = ProcessSaveGlobalConfigInfo();

       EXIT_LOCK(PROTOCOL_CB_LIST);
       EXIT_LOCK(ICB_LIST);
    }

    return dwErr;
}

DWORD
SNMPSetScope(
    IN  IPV4_ADDRESS  ipGroupAddress,
    IN  IPV4_ADDRESS  ipGroupMask,
    IN  SCOPE_NAME    snScopeName
    )
/*++
Called by: 
    AccessMcastScope() in access.c
Locks: 
    Locks BOUNDARY_TABLE for writing
    Locks ICB_LIST then PROTOCOL_CB_LIST for writing (for saving to registry)
Returns:
    whatever ProcessSaveGlobalConfigInfo() returns
--*/
{
    DWORD        dwErr;
    PSCOPE_ENTRY pScope;
    LANGID       idLanguage = MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT);

    ENTER_WRITER(BOUNDARY_TABLE);
    {
        pScope = FindScope( ipGroupAddress, ipGroupMask );

        if ( ! pScope ) 
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            dwErr = AssertScopeName( pScope, idLanguage, snScopeName );
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    // Save the scope to the registry
    if (dwErr is NO_ERROR) 
    {
       // ProcessSaveGlobalConfigInfo() requires us to have both the 
       // ICB_LIST and the PROTOCOL_CB_LIST locked.
       ENTER_WRITER(ICB_LIST);
       ENTER_WRITER(PROTOCOL_CB_LIST);

       dwErr = ProcessSaveGlobalConfigInfo();

       EXIT_LOCK(PROTOCOL_CB_LIST);
       EXIT_LOCK(ICB_LIST);
    }

    return dwErr;
}

DWORD
SNMPAddScope(
    IN  IPV4_ADDRESS  ipGroupAddress,
    IN  IPV4_ADDRESS  ipGroupMask,
    IN  SCOPE_NAME    snScopeName,
    OUT PSCOPE_ENTRY *ppScope
    )
/*++
Called by: 
    AccessMcastScope() in access.c
Locks: 
    Locks BOUNDARY_TABLE for writing
    Locks ICB_LIST then PROTOCOL_CB_LIST for writing (for saving to registry)
Returns:
    ERROR_INVALID_PARAMATER if already exists
    whatever AddScope() returns
    whatever ProcessSaveGlobalConfigInfo() returns
--*/
{
    DWORD             dwErr;
    PSCOPE_ENTRY      pScope;
    LANGID       idLanguage = MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT);

    ENTER_WRITER(BOUNDARY_TABLE);
    {
        pScope = FindScope( ipGroupAddress, ipGroupMask );

        if ( pScope ) 
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            dwErr = AddScope( ipGroupAddress, 
                              ipGroupMask, 
                              ppScope );

            if (dwErr is NO_ERROR)
                dwErr = AssertScopeName( *ppScope, idLanguage, snScopeName );
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    // Save the scope to the registry
    if (dwErr is NO_ERROR) 
    {
       // ProcessSaveGlobalConfigInfo() requires us to have both the 
       // ICB_LIST and the PROTOCOL_CB_LIST locked.
       ENTER_WRITER(ICB_LIST);
       ENTER_WRITER(PROTOCOL_CB_LIST);

       dwErr = ProcessSaveGlobalConfigInfo();

       EXIT_LOCK(PROTOCOL_CB_LIST);
       EXIT_LOCK(ICB_LIST);
    }

    return dwErr;
}

DWORD
SNMPAssertScope(
    IN  IPV4_ADDRESS  ipGroupAddress,
    IN  IPV4_ADDRESS  ipGroupMask,
    IN  PBYTE         pScopeName, // string to duplicate
    OUT PSCOPE_ENTRY *ppScopeEntry,
    OUT PBOOL         pbSaveGlobal
    )
/*++
Locks:
    Assumes caller holds write lock on BOUNDARY_TABLE.
Called by: 
    SNMPAddBoundaryToInterface()
Returns:
    NO_ERROR - success
    whatever AddScope() returns
--*/
{
    DWORD             dwErr = NO_ERROR;
    SCOPE_NAME_BUFFER snScopeNameBuffer;
    LANGID            idLanguage;

    if (pScopeName)
    {
        idLanguage = MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT );

        MultiByteToWideChar( CP_UTF8,
                             0,
                             pScopeName,
                             strlen(pScopeName),
                             snScopeNameBuffer,
                             MAX_SCOPE_NAME_LEN+1 );
    }

    *ppScopeEntry = FindScope(ipGroupAddress, ipGroupMask);

    if (! *ppScopeEntry) 
    {
        dwErr = AddScope( ipGroupAddress, 
                             ipGroupMask, 
                             ppScopeEntry);

        if (pScopeName and (dwErr is NO_ERROR))
        {
            dwErr = AssertScopeName( *ppScopeEntry, 
                                      idLanguage, 
                                      snScopeNameBuffer );
        }

        *pbSaveGlobal = TRUE;
    }

    return dwErr;
}

DWORD
SNMPAddBoundaryToInterface(
    IN DWORD         dwIfIndex,
    IN IPV4_ADDRESS  ipGroupAddress,
    IN IPV4_ADDRESS  ipGroupMask
    )
/*++
Routine Description:
    Create a boundary if necessary, and add it to a given interface
    and to the registry.
Called by:
    AccessMcastBoundary() in access.c
Locks:
    BOUNDARY_TABLE for writing
    ICB_LIST and then PROTOCOL_CB_LIST for writing
Returns:
    NO_ERROR
    whatever AssertScope() returns
    whatever AssertBifEntry() returns
    whatever ProcessSaveInterfaceConfigInfo()
--*/
{
    DWORD           dwResult;

    LIST_ENTRY      leOldRanges, 
                    leNewRanges;

    BOOL            bSaveGlobal = FALSE,
                    bIsOperational = TRUE;

    BOUNDARY_ENTRY *pBoundary;

    BOUNDARY_IF    *pBIf;

    SCOPE_ENTRY    *pScope;

    //
    // bIsOperational should really be set to TRUE only if
    // picb->dwOperationalState is IF_OPER_STATUS_OPERATIONAL
    //

    // Add the boundary
    ENTER_WRITER(BOUNDARY_TABLE);
    {
        Trace0( MCAST, "SNMPAddBoundaryToInterface: converting old ranges" );
        ConvertIfTableToRanges(dwIfIndex, &leOldRanges);
 
        dwResult = SNMPAssertScope(ipGroupAddress, ipGroupMask, NULL, &pScope,
                                   &bSaveGlobal);

        if (dwResult == NO_ERROR) 
        {
            dwResult = AssertBIfEntry(dwIfIndex, &pBIf, bIsOperational);
            if (dwResult is NO_ERROR)
            {
                AssertBoundaryEntry(pBIf, pScope, &pBoundary);
            }
        }

        if (dwResult isnot NO_ERROR) 
        {
            EXIT_LOCK(BOUNDARY_TABLE);
            return dwResult;
        }

        Trace0( MCAST, "SNMPAddBoundaryToInterface: converting new ranges" );
        ConvertIfTableToRanges(dwIfIndex, &leNewRanges);
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    // Inform MGM of deltas
    ProcessIfRangeDeltas(dwIfIndex, &leOldRanges, &leNewRanges);

    // Save the boundary to the registry
    {
        // ProcessSaveInterfaceConfigInfo() requires us to have both the 
        // ICB_LIST and the PROTOCOL_CB_LIST locked.
        ENTER_WRITER(ICB_LIST);
        ENTER_WRITER(PROTOCOL_CB_LIST);

        if (bSaveGlobal)
            dwResult = ProcessSaveGlobalConfigInfo();
 
        dwResult = ProcessSaveInterfaceConfigInfo(dwIfIndex);
 
        EXIT_LOCK(PROTOCOL_CB_LIST);
        EXIT_LOCK(ICB_LIST);
    }
 
    return dwResult;
}

DWORD
SNMPDeleteBoundaryFromInterface(
    IN DWORD         dwIfIndex,
    IN IPV4_ADDRESS  ipGroupAddress,
    IN IPV4_ADDRESS  ipGroupMask
    )
/*++
Routine Description:
    Remove a boundary from a given interface, and delete the scope
    entry if it's unnamed and no interfaces remain.
Called by:
    AccessMcastBoundary() in access.c
Locks:
    BOUNDARY_TABLE for writing
Returns:
    NO_ERROR
--*/
{
    LIST_ENTRY      leOldRanges, 
                    leNewRanges,
                   *pleNode, 
                   *pleNext;

    DWORD           dwResult = NO_ERROR;

    BOOL            bSaveGlobal = FALSE;

    BOUNDARY_IF    *pBIf;

    BOUNDARY_ENTRY *pBoundary;

    SCOPE_ENTRY    *pScope;

    ENTER_WRITER(BOUNDARY_TABLE);
    {
       Trace0( MCAST, 
              "SNMPDeleteBoundaryFromInterface: converting old ranges" );
       ConvertIfTableToRanges(dwIfIndex, &leOldRanges);

       //
       // We have to do a little more work than just calling 
       // DeleteBoundaryFromInterface(), since we first have to
       // look up which boundary matches.
       //
       pBIf = FindBIfEntry(dwIfIndex);
       if (pBIf is NULL)
       {
          // nothing to do
          FreeRangeList(&leOldRanges);
          EXIT_LOCK(BOUNDARY_TABLE);
          return NO_ERROR;
       }

       for (pleNode = pBIf->leBoundaryList.Flink;
            pleNode isnot &pBIf->leBoundaryList;
            pleNode = pleNext) 
       {
          // Save ptr to next node, since we may delete this one
          pleNext = pleNode->Flink;

          pBoundary = CONTAINING_RECORD(pleNode, BOUNDARY_ENTRY,
           leBoundaryLink);

          pScope = pBoundary->pScope;

          if (pScope->ipGroupAddress == ipGroupAddress
           && pScope->ipGroupMask    == ipGroupMask) 
          {

             // Delete boundary from interface
             DeleteBoundaryFromInterface(pBoundary, pBIf);

             if (!pScope->ulNumInterfaces && IsListEmpty(&pScope->leNameList)) 
             {
                 DeleteScope(pScope);
                 bSaveGlobal = TRUE;
             }
          }
       }

       Trace0( MCAST, 
               "SNMPDeleteBoundaryFromInterface: converting new ranges" );
       ConvertIfTableToRanges(dwIfIndex, &leNewRanges);
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    // Inform MGM of deltas
    ProcessIfRangeDeltas(dwIfIndex, &leOldRanges, &leNewRanges);

    // Resave boundaries to registry
    {
        // ProcessSaveInterfaceConfigInfo() requires us to have both the 
        // ICB_LIST and the PROTOCOL_CB_LIST locked.
        ENTER_WRITER(ICB_LIST);
        ENTER_WRITER(PROTOCOL_CB_LIST);

        if (bSaveGlobal)
            dwResult = ProcessSaveGlobalConfigInfo();
 
        dwResult = ProcessSaveInterfaceConfigInfo(dwIfIndex);

        EXIT_LOCK(PROTOCOL_CB_LIST);
        EXIT_LOCK(ICB_LIST);
    }
 
    return dwResult;
}

//
// Functions which can be called from MGM and Routing Protocols
//

BOOL
WINAPI
RmHasBoundary(
    IN DWORD        dwIfIndex,
    IN IPV4_ADDRESS ipGroupAddress
    )
/*++
Routine Description:
    Test to see whether a boundary for the given group exists on the
    indicated interface.
Called by:
    (MGM, Routing Protocols)
Locks:
    BOUNDARY_TABLE for reading
Returns:
    TRUE, if a boundary exists
    FALSE, if not
--*/
{
    BOUNDARY_IF *pIf;
    BOUNDARY_ENTRY *pBoundary;
    PLIST_ENTRY pleNode;
    BOOL bFound = FALSE;

    ENTER_READER(BOUNDARY_TABLE);
    {
       pIf = FindBIfEntry(dwIfIndex);
       if (pIf) 
       {
          
          // An address in the IPv4 Local Scope has a boundary if
          // ANY boundary exists.
          if ( !IsListEmpty( &pIf->leBoundaryList )
            && IN_IPV4_LOCAL_SCOPE(ipGroupAddress) )
             bFound = TRUE;

          for (pleNode = pIf->leBoundaryList.Flink;
               !bFound && pleNode isnot &pIf->leBoundaryList;
               pleNode = pleNode->Flink) 
          {
             pBoundary = CONTAINING_RECORD(pleNode, BOUNDARY_ENTRY,
              leBoundaryLink);
             if ((ipGroupAddress & pBoundary->pScope->ipGroupMask)
              == pBoundary->pScope->ipGroupAddress)
                bFound = TRUE;
          }
       }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    return bFound;
}

//----------------------------------------------------------------------------
// Boundary enumeration API.
//
//----------------------------------------------------------------------------

DWORD
RmGetBoundary(
    IN       PMIB_IPMCAST_BOUNDARY pimm,
    IN  OUT  PDWORD                pdwBufferSize,
    IN  OUT  PBYTE                 pbBuffer
)
/*++
Called by:
    AccessMcastBoundary() in access.c
Returns:
    SNMP error code
--*/
{
    DWORD                  dwErr = NO_ERROR;
    BOUNDARY_IF           *pBIf;
    BOUNDARY_ENTRY        *pBoundary;
    SCOPE_ENTRY           *pScope;
    PMIB_IPMCAST_BOUNDARY *pOut;

    Trace1( ENTER, "ENTERED RmGetBoundary: %d", *pdwBufferSize );

    if (*pdwBufferSize < sizeof(MIB_IPMCAST_BOUNDARY)) {
       *pdwBufferSize = sizeof(MIB_IPMCAST_BOUNDARY);
       return ERROR_INSUFFICIENT_BUFFER;
    }

    do {
       ENTER_READER(BOUNDARY_TABLE);

       if ((pBIf = FindBIfEntry(pimm->dwIfIndex)) == NULL) 
       {
          dwErr = ERROR_NOT_FOUND;
          break;
       }

       if ( IN_IPV4_LOCAL_SCOPE(pimm->dwGroupAddress) )
       {
          dwErr = ERROR_NOT_FOUND;
          break;
       }
       else
       {
          pScope = FindScope(pimm->dwGroupAddress, pimm->dwGroupMask);
          if (pScope == NULL) 
          {
             dwErr = ERROR_NOT_FOUND;
             break;
          }

          if ((pBoundary = FindBoundaryEntry(pBIf, pScope)) == NULL) 
          {
             dwErr = ERROR_NOT_FOUND;
             break;
          }
       }

       // Ok, we found it.
       pimm->dwStatus = ROWSTATUS_ACTIVE;
       CopyMemory(pbBuffer, pimm, sizeof(MIB_IPMCAST_BOUNDARY));
        
    } while(0);
    EXIT_LOCK(BOUNDARY_TABLE);

    Trace1( ENTER, "LEAVING RmGetBoundary %x\n", dwErr );

    return dwErr;
}

//----------------------------------------------------------------------------
// SCOPE enumeration API.
//
//----------------------------------------------------------------------------

DWORD
AddNextScope(
    IN     IPV4_ADDRESS         ipAddr, 
    IN     IPV4_ADDRESS         ipMask, 
    IN     SCOPE_NAME           snScopeName,
    IN     PMIB_IPMCAST_SCOPE   pimmStart,
    IN OUT PDWORD               pdwNumEntries,
    IN OUT PDWORD               pdwBufferSize,
    IN OUT PBYTE               *ppbBuffer)
/*++
Arguments:
    pdwBufferSize:  [IN] size of buffer
                    [OUT] extra space left, if NO_ERROR is returned
                          total size needed, if ERROR_INSUFFICIENT_BUFFER
--*/
{

    //
    // See whether this scope fits the requested criteria
    //

    if (ntohl(ipAddr) > ntohl(pimmStart->dwGroupAddress)
     || (      ipAddr  ==       pimmStart->dwGroupAddress
      && ntohl(ipMask) >= ntohl(pimmStart->dwGroupMask)))
    {
        MIB_IPMCAST_SCOPE imm;

        //
        // Make sure enough space is left in the buffer
        //

        if (*pdwBufferSize < sizeof(MIB_IPMCAST_SCOPE)) 
        {
           if (*pdwNumEntries == 0)
              *pdwBufferSize = sizeof(MIB_IPMCAST_SCOPE);
           return ERROR_INSUFFICIENT_BUFFER;
        }

        //
        // Copy scope into buffer
        //

        imm.dwGroupAddress = ipAddr;
        imm.dwGroupMask    = ipMask;
        sn_strcpy(imm.snNameBuffer, snScopeName);
        imm.dwStatus       = ROWSTATUS_ACTIVE;
        CopyMemory(*ppbBuffer, &imm, sizeof(MIB_IPMCAST_SCOPE));
        (*ppbBuffer)     += sizeof(MIB_IPMCAST_SCOPE);
        (*pdwBufferSize) -= sizeof(MIB_IPMCAST_SCOPE);
        (*pdwNumEntries)++;
    }

    return NO_ERROR;
}

DWORD
RmGetNextScope(
    IN              PMIB_IPMCAST_SCOPE   pimmStart,
    IN  OUT         PDWORD               pdwBufferSize,
    IN  OUT         PBYTE                pbBuffer,
    IN  OUT         PDWORD               pdwNumEntries
)
/*++
Locks: 
    BOUNDARY_TABLE for reading
Called by:
    RmGetFirstScope(), 
    AccessMcastScope() in access.c
--*/
{
    DWORD             dwErr = NO_ERROR;
    DWORD             dwNumEntries=0, dwBufferSize = *pdwBufferSize;
    SCOPE_ENTRY      *pScope, local;
    DWORD             dwInd;
    BOOL              bHaveScopes = FALSE;
    PLIST_ENTRY       pleNode;

    Trace1( MCAST, "ENTERED RmGetNextScope: %d", dwBufferSize);

    // Bump index by 1
    pimmStart->dwGroupMask = htonl( ntohl(pimmStart->dwGroupMask) + 1);
    if (!pimmStart->dwGroupMask) 
    {
       pimmStart->dwGroupAddress = htonl( ntohl(pimmStart->dwGroupAddress) + 1);
    }

    ENTER_READER(BOUNDARY_TABLE);
    {

        // Walk master scope list
        for (pleNode = g_MasterScopeList.Flink;
             dwNumEntries < *pdwNumEntries && pleNode isnot &g_MasterScopeList;
             pleNode = pleNode->Flink) {

            pScope = CONTAINING_RECORD(pleNode, SCOPE_ENTRY, leScopeLink);

            if ( !pScope->ipGroupAddress )
                continue;

            bHaveScopes = TRUE;

            dwErr = AddNextScope(pScope->ipGroupAddress,
                                 pScope->ipGroupMask, 
                                 GetDefaultName( pScope ),
                                 pimmStart,
                                 &dwNumEntries,
                                 &dwBufferSize,
                                 &pbBuffer);

            if (dwErr == ERROR_INSUFFICIENT_BUFFER) 
            {
                *pdwBufferSize = dwBufferSize;
                return dwErr;
            }
        }
        
        //
        // Finally, if we have scopes, then we can also count
        // one for the IPv4 Local Scope.
        //

        if ( dwNumEntries > 0 && dwNumEntries < *pdwNumEntries && bHaveScopes )
        {
            dwErr = AddNextScope( IPV4_LOCAL_SCOPE_ADDR,
                                  IPV4_LOCAL_SCOPE_MASK, 
                                  IPV4_LOCAL_SCOPE_NAME,
                                  pimmStart,
                                  &dwNumEntries,
                                  &dwBufferSize,
                                  &pbBuffer );
        }
        if (!dwNumEntries && dwErr==NO_ERROR)
           dwErr = ERROR_NO_MORE_ITEMS;
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    *pdwBufferSize -= dwBufferSize;
    *pdwNumEntries  = dwNumEntries;

    Trace1( MCAST, "LEAVING RmGetNextScope %x", dwErr );

    return dwErr;
}

DWORD
RmGetScope(
    IN       PMIB_IPMCAST_SCOPE pimm,
    IN  OUT  PDWORD             pdwBufferSize,
    IN  OUT  PBYTE              pbBuffer
)
/*++
Called by:
    AccessMcastScope() in access.c
Returns:
    SNMP error code
--*/
{
    DWORD                  dwErr = NO_ERROR;
    SCOPE_ENTRY           *pScope;
    PMIB_IPMCAST_SCOPE    *pOut;

    Trace1( ENTER, "ENTERED RmGetScope: %d", *pdwBufferSize );

    if (*pdwBufferSize < sizeof(MIB_IPMCAST_SCOPE)) {
       *pdwBufferSize = sizeof(MIB_IPMCAST_SCOPE);
       return ERROR_INSUFFICIENT_BUFFER;
    }

    pimm->dwStatus = ROWSTATUS_ACTIVE;


    ENTER_READER(BOUNDARY_TABLE);
    do {

       if ( pimm->dwGroupAddress == IPV4_LOCAL_SCOPE_ADDR
         && pimm->dwGroupMask    == IPV4_LOCAL_SCOPE_MASK )
       {
          sn_strcpy( pimm->snNameBuffer, IPV4_LOCAL_SCOPE_NAME );
          CopyMemory(pbBuffer, pimm, sizeof(MIB_IPMCAST_SCOPE));
       }
       else
       {
          pScope = FindScope(pimm->dwGroupAddress, pimm->dwGroupMask);
          if (pScope == NULL) 
          {
             dwErr = ERROR_NOT_FOUND;
             break;
          }

          // Ok, we found it.
          CopyMemory(pbBuffer, pimm, sizeof(MIB_IPMCAST_SCOPE));
       }
        
    } while(0);
    EXIT_LOCK(BOUNDARY_TABLE);

    Trace1( ENTER, "LEAVING RmGetScope %x\n", dwErr );

    return dwErr;
}

DWORD
RmGetFirstScope(
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
)
/*++
Routine description:
    Get the first scope in lexicographic order.  Since Addr=0
    is not used, a GetFirst is equivalent to a GetNext with Addr=0.
Called by:
    AccessMcastScope() in access.c
--*/
{
    MIB_IPMCAST_SCOPE imm;
    imm.dwGroupAddress = imm.dwGroupMask = 0;
    return RmGetNextScope(&imm, pdwBufferSize, pbBuffer, pdwNumEntries);
}

//----------------------------------------------------------------------------
// BOUNDARY enumeration API.
//
//----------------------------------------------------------------------------

DWORD
AddNextBoundary(
    IN     DWORD                   dwIfIndex, 
    IN     IPV4_ADDRESS            ipAddr, 
    IN     IPV4_ADDRESS            ipMask, 
    IN     PMIB_IPMCAST_BOUNDARY   pimmStart,
    IN OUT PDWORD                  pdwNumEntries,
    IN OUT PDWORD                  pdwBufferSize,
    IN OUT PBYTE                  *ppbBuffer)
/*++
Arguments:
    pdwBufferSize:  [IN] size of buffer
                    [OUT] extra space left, if NO_ERROR is returned
                          total size needed, if ERROR_INSUFFICIENT_BUFFER
--*/
{

    //
    // See whether this boundary fits the requested criteria
    //

    if (ntohl(ipAddr) > ntohl(pimmStart->dwGroupAddress)
     || (      ipAddr  ==       pimmStart->dwGroupAddress
      && ntohl(ipMask) >= ntohl(pimmStart->dwGroupMask)))
    {
        MIB_IPMCAST_BOUNDARY imm;

        //
        // Make sure enough space is left in the buffer
        //

        if (*pdwBufferSize < sizeof(MIB_IPMCAST_BOUNDARY)) 
        {
           if (*pdwNumEntries == 0)
              *pdwBufferSize = sizeof(MIB_IPMCAST_BOUNDARY);
           return ERROR_INSUFFICIENT_BUFFER;
        }

        //
        // Copy boundary into buffer
        //

        imm.dwIfIndex      = dwIfIndex;
        imm.dwGroupAddress = ipAddr;
        imm.dwGroupMask    = ipMask;
        imm.dwStatus       = ROWSTATUS_ACTIVE;
        CopyMemory(*ppbBuffer, &imm, sizeof(MIB_IPMCAST_BOUNDARY));
        (*ppbBuffer)     += sizeof(MIB_IPMCAST_BOUNDARY);
        (*pdwBufferSize) -= sizeof(MIB_IPMCAST_BOUNDARY);
        (*pdwNumEntries)++;
    }

    return NO_ERROR;
}

DWORD
RmGetNextBoundary(
    IN              PMIB_IPMCAST_BOUNDARY   pimmStart,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
)
/*++
Locks: 
    BOUNDARY_TABLE for reading
Called by:
    RmGetFirstBoundary(), 
    AccessMcastBoundary() in access.c
--*/
{
    DWORD                dwErr = NO_ERROR;
    PLIST_ENTRY          pleIf, pleBound;
    DWORD                dwNumEntries=0, dwBufferSize = *pdwBufferSize;
    BOUNDARY_ENTRY      *pBound, local;

    Trace1( MCAST, "ENTERED RmGetNextBoundary: %d", dwBufferSize);

    // Bump index by 1
    pimmStart->dwGroupMask = htonl( ntohl(pimmStart->dwGroupMask) + 1);
    if (!pimmStart->dwGroupMask) 
    {
       pimmStart->dwGroupAddress = htonl( ntohl(pimmStart->dwGroupAddress) + 1);
       if (!pimmStart->dwGroupAddress)
          pimmStart->dwIfIndex++;
    }

    ENTER_READER(BOUNDARY_TABLE);
    {

       // Walk master BOUNDARY_IF list
       for (pleIf =  g_MasterInterfaceList.Flink;
            dwErr == NO_ERROR && dwNumEntries < *pdwNumEntries 
             && pleIf isnot &g_MasterInterfaceList;
            pleIf = pleIf->Flink) 
       {
          BOUNDARY_IF *pBIf = CONTAINING_RECORD(pleIf, BOUNDARY_IF,
           leBoundaryIfMasterLink);
          
          if (pBIf->dwIfIndex >= pimmStart->dwIfIndex) 
          {

             // Walk BOUNDARY list
             for (pleBound = pBIf->leBoundaryList.Flink;
                  dwErr == NO_ERROR && dwNumEntries < *pdwNumEntries
                  && pleBound isnot &pBIf->leBoundaryList;
                  pleBound = pleBound->Flink) 
             {
                 pBound = CONTAINING_RECORD(pleBound, 
                  BOUNDARY_ENTRY, leBoundaryLink);

                 dwErr = AddNextBoundary(pBIf->dwIfIndex, 
                                         pBound->pScope->ipGroupAddress,
                                         pBound->pScope->ipGroupMask, 
                                         pimmStart,
                                         &dwNumEntries,
                                         &dwBufferSize,
                                         &pbBuffer);
             }

             //
             // Finally, if we have boundaries, then we can also count
             // one for the IPv4 Local Scope.
             //

             if (dwErr == NO_ERROR && dwNumEntries < *pdwNumEntries
                 && !IsListEmpty( &pBIf->leBoundaryList ) )
             {
                 dwErr = AddNextBoundary(pBIf->dwIfIndex, 
                                         IPV4_LOCAL_SCOPE_ADDR,
                                         IPV4_LOCAL_SCOPE_MASK, 
                                         pimmStart,
                                         &dwNumEntries,
                                         &dwBufferSize,
                                         &pbBuffer);
             }

             if (dwErr == ERROR_INSUFFICIENT_BUFFER) 
             {
                 *pdwBufferSize = dwBufferSize;
                 return dwErr;
             }
          }
       }
       if (!dwNumEntries && dwErr==NO_ERROR)
          dwErr = ERROR_NO_MORE_ITEMS;

    }
    EXIT_LOCK(BOUNDARY_TABLE);

    *pdwBufferSize -= dwBufferSize;
    *pdwNumEntries  = dwNumEntries;

    Trace1( MCAST, "LEAVING RmGetNextBoundary %x\n", dwErr );

    return dwErr;
}

DWORD
RmGetFirstBoundary(
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
)
/*++
Routine description:
    Get the first boundary in lexicographic order.  Since IfIndex=0
    is not used, a GetFirst is equivalent to a GetNext with IfIndex=0.
Called by:
    AccessMcastBoundary() in access.c
--*/
{
    MIB_IPMCAST_BOUNDARY imm;
    imm.dwIfIndex = imm.dwGroupAddress = imm.dwGroupMask = 0;
    return RmGetNextBoundary(&imm, pdwBufferSize, pbBuffer, pdwNumEntries);
}

void
InitializeBoundaryTable()
/*++
Locks:
    BOUNDARY_TABLE for writing
--*/
{
    register int i;

    ENTER_WRITER(BOUNDARY_TABLE);
    {

       for (i=0; i<BOUNDARY_HASH_TABLE_SIZE; i++) 
           InitializeListHead(&g_bbScopeTable[i].leInterfaceList);

       InitializeListHead(&g_MasterInterfaceList);
       InitializeListHead(&g_MasterScopeList);

       ZeroMemory( g_scopeEntry, MAX_SCOPES * sizeof(SCOPE_ENTRY) );
    }
    EXIT_LOCK(BOUNDARY_TABLE);
}

//////////////////////////////////////////////////////////////////////////////
// START OF MZAP ROUTINES
//////////////////////////////////////////////////////////////////////////////
// Notes on MZAP write lock dependencies:
//    ZAM_CACHE  - no dependencies
//    MZAP_TIMER - no dependencies
//    ZBR_LIST   - lock BOUNDARY_ENTRY and MZAP_TIMER before ZBR_LIST
//    ZLE_LIST   - lock MZAP_TIMER before ZLE_LIST

#define TOP_OF_SCOPE(pScope) \
                        ((pScope)->ipGroupAddress | ~(pScope)->ipGroupMask)

// Convert number of seconds to number of 100ns intervals
#define TM_SECONDS(x)  ((x)*10000000)

//
// Define this if/when authentication of MZAP messages is provided
//

#undef SECURE_MZAP

//
// Address used as Message Origin for locally-originated messages
//

IPV4_ADDRESS  g_ipMyAddress = INADDR_ANY;
IPV4_ADDRESS  g_ipMyLocalZoneID = INADDR_ANY;
SOCKET        g_mzapLocalSocket = INVALID_SOCKET;
LIST_ENTRY    g_zbrTimerList;
LIST_ENTRY    g_zleTimerList;
BOOL          g_bMzapStarted = FALSE;
HANDLE        g_hMzapSocketEvent = NULL;

// For now, originate all ZAMs and ZCMs at the same time.
LARGE_INTEGER g_liZamExpiryTime;


DWORD
UpdateMzapTimer();

#include <packon.h>
typedef struct _IPV4_MZAP_HEADER {
    BYTE         byVersion;
    BYTE         byBPType;
    BYTE         byAddressFamily;
    BYTE         byNameCount;
    IPV4_ADDRESS ipMessageOrigin;
    IPV4_ADDRESS ipScopeZoneID;
    IPV4_ADDRESS ipScopeStart;
    IPV4_ADDRESS ipScopeEnd;
    BYTE         pScopeNameBlock[0];
} IPV4_MZAP_HEADER, *PIPV4_MZAP_HEADER;

typedef struct _IPV4_ZAM_HEADER {
    BYTE             bZT;
    BYTE             bZTL;
    WORD             wHoldTime;
    IPV4_ADDRESS     ipAddress[1]; 
} IPV4_ZAM_HEADER, *PIPV4_ZAM_HEADER;

typedef struct _IPV4_ZCM_HEADER {
    BYTE         bZNUM;
    BYTE         bReserved;
    WORD         wHoldTime;
    IPV4_ADDRESS ipZBR[0];
} IPV4_ZCM_HEADER, *PIPV4_ZCM_HEADER;
#include <packoff.h>


//////////////////////////////////////////////////////////////////////////////
// Functions for ZBR neighbor list and Zone ID maintenance
//////////////////////////////////////////////////////////////////////////////

ZBR_ENTRY *
FindZBR(
    IN PSCOPE_ENTRY pScope, 
    IN IPV4_ADDRESS ipAddress
    )
/*++
Description:
    Finds a given ZBR in a list.
Arguments:
    IN pscope    - scope to find a ZBR associated with
    IN ipAddress - address of ZBR to find
Returns:
    Pointer to ZBR entry, or NULL if not found
Called by:
    AssertZBR()
Locks:
    Assumes caller holds read lock on BOUNDARY_ENTRY and ZBR_LIST
--*/
{
    PZBR_ENTRY  pZbr;
    PLIST_ENTRY pleNode;

    for (pleNode = pScope->leZBRList.Flink;
         pleNode isnot &pScope->leZBRList;
         pleNode = pleNode->Flink)
    {
        pZbr = CONTAINING_RECORD(pleNode, ZBR_ENTRY, leZBRLink);

        if (pZbr->ipAddress == ipAddress)
        {
            return pZbr;
        }
    }

    return NULL;
}

IPV4_ADDRESS
MyScopeZoneID(
    IN PSCOPE_ENTRY  pScope
    )
/*++
Description:
    Get the Zone ID which we're inside for a given scope
Arguments:
    IN pScope - scope to get the zone ID for
Returns:
    scope zone address
Called by:
    AddMZAPHeader(), HandleZAM()
Locks:
    Assumes caller holds read lock on BOUNDARY_TABLE
    so that pScope won't go away.
--*/
{
    PLIST_ENTRY  pleNode;
    IPV4_ADDRESS ipScopeZoneID = g_ipMyAddress;

    // If first ZBR has a lower IP address than us, use that.
    pleNode = pScope->leZBRList.Flink;

    if (pleNode isnot &pScope->leZBRList)
    {
        ZBR_ENTRY *pZbr = CONTAINING_RECORD(pleNode, ZBR_ENTRY, leZBRLink);
        
        if (ntohl(pZbr->ipAddress) < ntohl(ipScopeZoneID))
            ipScopeZoneID = pZbr->ipAddress;
    }

    return ipScopeZoneID;
}

VOID
SetZbrExpiryTime( 
    PZBR_ENTRY    pZbr, 
    LARGE_INTEGER liExpiryTime 
    )
{
    PLIST_ENTRY pleNode;

    pZbr->liExpiryTime = liExpiryTime;

    for (pleNode = g_zbrTimerList.Flink;
         pleNode isnot &g_zbrTimerList;
         pleNode = pleNode->Flink)
    {
        ZBR_ENTRY *pPrev = CONTAINING_RECORD(pleNode, ZBR_ENTRY, leTimerLink);

        if (RtlLargeIntegerGreaterThan(pPrev->liExpiryTime, liExpiryTime))
            break;
    }

    InsertTailList( pleNode, &pZbr->leTimerLink );
}

ZBR_ENTRY *
AddZBR(
    IN PSCOPE_ENTRY  pScope, 
    IN IPV4_ADDRESS  ipAddress, 
    IN LARGE_INTEGER liExpiryTime
    )
/*++
Description:
    Adds ZBR to scope's list.  Initializes timer, and updates Zone ID.
Arguments:
    IN pScope       - scope to add a boundary router of
    IN ipAddress    - address of the boundary router to add
    IN liExpiryTime - time at which to expire the boundary router entry
Returns:
    Pointer to new boundary router entry, or NULL on memory alloc error
Called by:
    AssertZBR()
Locks:
    Assumes caller holds write lock on BOUNDARY_ENTRY, MZAP_TIMER, and ZBR_LIST
--*/
{
    PZBR_ENTRY  pZbr;
    PLIST_ENTRY pleNode;

    // Initialize new ZBR entry
    pZbr = MALLOC( sizeof(ZBR_ENTRY) );
    if (!pZbr)
    {
        return NULL;
    }

    pZbr->ipAddress    = ipAddress;

    // Add ZBR to list in order of lowest IP address

    for (pleNode = pScope->leZBRList.Flink;
         pleNode isnot &pScope->leZBRList;
         pleNode = pleNode->Flink)
    {
        ZBR_ENTRY *pPrev = CONTAINING_RECORD(pleNode, ZBR_ENTRY, leZBRLink);

        if (ntohl(pPrev->ipAddress) > ntohl(ipAddress))
        {
            break;
        }
    }

    InsertTailList( pleNode, &pZbr->leZBRLink );

    // We don't need to update Zone ID since it's recalculated
    // whenever we need it.

    // Add ZBR to timer list in order of expiry time
    SetZbrExpiryTime( pZbr, liExpiryTime );

    UpdateMzapTimer();

    return pZbr;
}


ZBR_ENTRY *
AssertZBR(
    IN PSCOPE_ENTRY pScope, 
    IN IPV4_ADDRESS ipAddress, 
    IN WORD         wHoldTime
    )
/*++
Description:
    Finds ZBR in list, adding it if needed.  Resets timer for ZBR.
Arguments:
    IN pScope    - scope to find/add a boundary router of
    IN ipAddress - address of boundary router to find/add
    IN wHoldTime - hold time in seconds remaining to reset timer to
Returns:
    Pointer to boundary router entry
Called by:
    HandleZAM(), HandleZCM()
Locks:
    Assumes caller holds read lock on BOUNDARY_ENTRY
    Locks MZAP_TIMER and then ZBR_LIST for writing
--*/
{
    LARGE_INTEGER liCurrentTime, liExpiryTime;
    ZBR_ENTRY    *pZbr;

    NtQuerySystemTime( &liCurrentTime );

    liExpiryTime = RtlLargeIntegerAdd(liCurrentTime, 
      RtlConvertUlongToLargeInteger(TM_SECONDS((ULONG)wHoldTime)));

    ENTER_WRITER(MZAP_TIMER);
    ENTER_WRITER(ZBR_LIST);
    {
        pZbr = FindZBR( pScope, ipAddress );
    
        if (!pZbr) 
        {
            pZbr = AddZBR( pScope, ipAddress, liExpiryTime );
        }
        else
        {
            RemoveEntryList( &pZbr->leTimerLink );

            SetZbrExpiryTime( pZbr, liExpiryTime );
        }
    }
    EXIT_LOCK(ZBR_LIST);
    EXIT_LOCK(MZAP_TIMER);

    return pZbr;
}

VOID
DeleteZBR(
    IN PZBR_ENTRY pZbr
    )
/*++
Arguments:
    IN pZbr - Pointer to boundary router entry to delete
Called by:
    HandleMzapTimer()
Locks:
    Assumes caller has write lock on ZBR_LIST
--*/
{
    // Remove from timer list
    RemoveEntryList( &pZbr->leTimerLink );

    // Remove from ZBR list for the scope
    RemoveEntryList( &pZbr->leZBRLink );

    // We don't need to update the Zone ID, since it's recalculated
    // whenever we need it
}


//////////////////////////////////////////////////////////////////////////////
// Functions for pending ZLE store manipulation
//////////////////////////////////////////////////////////////////////////////

typedef struct _ZLE_PENDING {
    LIST_ENTRY    leTimerLink;
    PBYTE         pBuffer;
    ULONG         ulBuffLen;
    LARGE_INTEGER liExpiryTime;
} ZLE_PENDING, *PZLE_PENDING;

LIST_ENTRY g_leZleList;

PZLE_PENDING
AddPendingZLE(
    IN PBYTE         pBuffer, 
    IN ULONG         ulBuffLen,
    IN LARGE_INTEGER liExpiryTime
    )
/*++
Arguments:
    IN pBuffer      - buffer holding ZLE message
    IN ulBuffLen    - size in bytes of buffer passed in
    IN liExpiryTime - time at which to expire ZLE entry
Returns:
    Pointer to ZLE entry added, or NULL on memory alloc error
Called by:
    HandleZAM()
Locks:
    Assumes caller holds write lock on ZLE_LIST
--*/
{
    PLIST_ENTRY  pleNode;
    PZLE_PENDING pZle;

    pZle = MALLOC( sizeof(ZLE_PENDING) );
    if (!pZle)
    {
        return NULL;
    }

    pZle->pBuffer      = pBuffer;
    pZle->ulBuffLen    = ulBuffLen;
    pZle->liExpiryTime = liExpiryTime;

    // Search for entry after the new one
    for (pleNode = g_leZleList.Flink;
         pleNode isnot &g_leZleList;
         pleNode = pleNode->Flink)
    {
        PZLE_PENDING pPrev = CONTAINING_RECORD(pleNode,ZLE_PENDING,leTimerLink);

        if (RtlLargeIntegerGreaterThan(pPrev->liExpiryTime, 
                                       pZle->liExpiryTime))
        {
            break;
        }
    }

    // Insert into cache
    InsertTailList( pleNode, &pZle->leTimerLink );

    return pZle;
}

VOID
DeletePendingZLE(
    IN PZLE_PENDING zle
    )
/*++
Description:
    Remove all state related to a pending ZLE
Arguments:
    IN zle - pointer to ZLE entry to delete
Called by:
    HandleZLE(), SendZLE()
Locks:
    Assumes caller holds write lock on ZLE_LIST
--*/
{
    RemoveEntryList( &zle->leTimerLink );

    // Free up space 
    FREE(zle->pBuffer);
    FREE(zle);
}

PZLE_PENDING
FindPendingZLE(
    IN IPV4_MZAP_HEADER *mh
    )
/*++
Description:
    Find an entry for a pending ZLE which matches a given MZAP message header
Arguments:
    IN mh - pointer to MZAP message header to locate a matching ZLE entry for
Returns:
    Pointer to matching ZLE entry, if any
Called by:
    HandleZAM(), HandleZLE()
Locks:
    Assumes caller holds read lock on ZLE_LIST
--*/
{
    PLIST_ENTRY       pleNode;
    IPV4_MZAP_HEADER *mh2;

    for (pleNode = g_leZleList.Flink;
         pleNode isnot &g_leZleList;
         pleNode = pleNode->Flink)
    {
        PZLE_PENDING zle = CONTAINING_RECORD(pleNode, ZLE_PENDING, leTimerLink);

        mh2 = (PIPV4_MZAP_HEADER)zle->pBuffer;

        if (mh->ipScopeZoneID == mh2->ipScopeZoneID 
         && mh->ipScopeStart  == mh2->ipScopeStart)
        {
            return zle;
        }
    }
    
    return NULL;
}


//////////////////////////////////////////////////////////////////////////////
// Functions for ZAM cache manipulation
//////////////////////////////////////////////////////////////////////////////

typedef struct _ZAM_ENTRY {
    LIST_ENTRY    leCacheLink;
    IPV4_ADDRESS  ipScopeZoneID;
    IPV4_ADDRESS  ipStartAddress;
    LARGE_INTEGER liExpiryTime;
} ZAM_ENTRY, *PZAM_ENTRY;

LIST_ENTRY g_leZamCache;

void
UpdateZamCache(
    IN LARGE_INTEGER liCurrentTime
    )
/*++
Description:
    Throw any expired entries out of the ZAM cache.
Arguments:
    IN liCurrentTime - current time, to compare vs expiry times of entries
Called by:
    AssertInZamCache()
Locks:
    Assumes caller has write lock on ZAM_CACHE
--*/
{
    PLIST_ENTRY pleNode;
    PZAM_ENTRY  pZam;

    // Throw out old cache entries
    while (g_leZamCache.Flink isnot &g_leZamCache) 
    {
        pleNode = g_leZamCache.Flink;

        pZam = CONTAINING_RECORD(pleNode, ZAM_ENTRY, leCacheLink);

        if ( RtlLargeIntegerLessThanOrEqualTo( pZam->liExpiryTime, 
                                               liCurrentTime )
         ||  RtlLargeIntegerEqualToZero( liCurrentTime ))
        {
            Trace6(MCAST,
                   "Evicting %d.%d.%d.%d/%d.%d.%d.%d from ZAM cache with current time %x.%x exp %x.%x",
                   PRINT_IPADDR(pZam->ipScopeZoneID),
                   PRINT_IPADDR(pZam->ipStartAddress),
                   liCurrentTime.HighPart, liCurrentTime.LowPart,
                   pZam->liExpiryTime.HighPart,  pZam->liExpiryTime.LowPart);
    
            RemoveEntryList( &pZam->leCacheLink );

            FREE( pZam );

            continue;
        }

        // Ok, we've reached one that stays, so we're done

        break;
    }
}

PZAM_ENTRY
AddToZamCache(
    IN IPV4_ADDRESS  ipScopeZoneID,
    IN IPV4_ADDRESS  ipStartAddress,
    IN LARGE_INTEGER liExpiryTime
    )
/*++
Description:
    This function takes a ZAM identifier and timeout, and adds it to the
    ZAM cache.
Arguments:
    IN ipScopeZoneID  - scope zone ID to cache
    IN ipStartAddress - scope start address to cache
    IN liExpiryTime   - time at which to expire the cache entry
Returns:
    Pointer to cache entry, or NULL on memory error
Called by:
    AssertInZamCache()
Locks:
    Assumes caller holds write lock on ZAM_CACHE
--*/
{
    PLIST_ENTRY pleNode;
    PZAM_ENTRY  pZam;

    // Add entry to cache
    pZam = MALLOC( sizeof(ZAM_ENTRY) );
    if (!pZam)
    {
        return NULL;
    }

    pZam->ipScopeZoneID  = ipScopeZoneID;
    pZam->ipStartAddress = ipStartAddress;
    pZam->liExpiryTime   = liExpiryTime;

    // Search for entry after the new one
    for (pleNode = g_leZamCache.Flink;
         pleNode isnot &g_leZamCache;
         pleNode = pleNode->Flink)
    {
        PZAM_ENTRY pPrevC = CONTAINING_RECORD(pleNode, ZAM_ENTRY, leCacheLink);

        if (RtlLargeIntegerGreaterThan(pPrevC->liExpiryTime, 
                                       pZam->liExpiryTime))
        {
            break;
        }
    }

    // Insert into cache
    InsertTailList( pleNode, &pZam->leCacheLink );

    return pZam;
}

PZAM_ENTRY
FindInZamCache(
    IN IPV4_ADDRESS ipScopeZoneID,
    IN IPV4_ADDRESS ipStartAddress
    )
/*++
Description:
    See if a given ZAM spec is in the cache.
Arguments:
    IN ipScopeZoneID  - scope zone ID to match
    IN ipStartAddress - scope start address to match
Return:
    Pointer to cache entry, or NULL if not found.
Called by:
    AssertInZamCache()
Locks:
    Assumes caller has read lock on ZAM_CACHE
--*/
{
    PLIST_ENTRY pleNode;

    // Search for cache entry
    for (pleNode = g_leZamCache.Flink;
         pleNode isnot &g_leZamCache;
         pleNode = pleNode->Flink)
    {
        ZAM_ENTRY *pZam = CONTAINING_RECORD(pleNode, ZAM_ENTRY, leCacheLink);

        if ( ipScopeZoneID is pZam->ipScopeZoneID
          && ipStartAddress is pZam->ipStartAddress)
        {
            return pZam;
        }
    }

    return NULL;
}

PZAM_ENTRY
AssertInZamCache(
    IN  IPV4_ADDRESS ipScopeZoneID,
    IN  IPV4_ADDRESS ipStartAddress,
    OUT BOOL        *pbFound
    )
/*++
Description:
    Locate a ZAM spec in the cache, adding it if not already present.
Arguments:
    IN  ipScopeZoneID  - scope zone ID to match/cache
    IN  ipStartAddress - scope start address to match/cache
    OUT pbFound        - TRUE if found, FALSE if newly cached
Called by:
    HandleZAM()
Locks:
    ZAM_CACHE for writing
--*/
{
    PZAM_ENTRY    pZam;
    LARGE_INTEGER liCurrentTime, liExpiryTime;

    // Get current time
    NtQuerySystemTime(&liCurrentTime);

    ENTER_WRITER(ZAM_CACHE);
    {
        UpdateZamCache(liCurrentTime);

        pZam = FindInZamCache( ipScopeZoneID, ipStartAddress);

        if (!pZam)
        {
            liExpiryTime = RtlLargeIntegerAdd(liCurrentTime, 
              RtlConvertUlongToLargeInteger(TM_SECONDS(ZAM_DUP_TIME)));
    
            AddToZamCache( ipScopeZoneID, ipStartAddress, liExpiryTime );

            Trace6(MCAST,
                   "Added %d.%d.%d.%d/%d.%d.%d.%d to ZAM cache with current time %x/%x exp %x/%x",
                   PRINT_IPADDR(ipScopeZoneID),
                   PRINT_IPADDR(ipStartAddress),
                   liCurrentTime.HighPart, liCurrentTime.LowPart,
                   liExpiryTime.HighPart,  liExpiryTime.LowPart);
    
            *pbFound = FALSE;
        }
        else
        {
            *pbFound = TRUE;
        }
    }
    EXIT_LOCK(ZAM_CACHE);

    return pZam;
}



//////////////////////////////////////////////////////////////////////////////
// Functions for message sending
//////////////////////////////////////////////////////////////////////////////

DWORD
SendMZAPMessageByIndex(
    IN PBYTE        pBuffer, 
    IN ULONG        ulBuffLen,
    IN IPV4_ADDRESS ipGroup,
    IN DWORD        dwIfIndex   
    )
{
    SOCKADDR_IN    sinAddr;
    DWORD          dwErr = NO_ERROR, dwLen;

    dwErr = McSetMulticastIfByIndex( g_mzapLocalSocket, SOCK_DGRAM, dwIfIndex );

    if (dwErr is SOCKET_ERROR)
    {
        dwErr = WSAGetLastError();

        Trace2( ERR, 
                "SendMZAPMessage: error %d setting oif to IF %x", 
                dwErr, 
                dwIfIndex );
    }

    sinAddr.sin_family      = AF_INET;
    sinAddr.sin_addr.s_addr = ipGroup;
    sinAddr.sin_port        = htons(MZAP_PORT);

#ifdef DEBUG_MZAP
    Trace2( ERR, "SendMZAPMessageByIndex: sending %d bytes on IF %d", 
            ulBuffLen, dwIfIndex );
#endif

    dwLen = sendto( g_mzapLocalSocket, 
                pBuffer, 
                ulBuffLen, 
                0, 
                (struct sockaddr*)&sinAddr,
                sizeof(sinAddr));

#ifdef DEBUG_MZAP
    Trace1( ERR, "SendMZAPMessageByIndex: sent %d bytes", dwLen);
#endif

    if (dwLen is SOCKET_ERROR )
    {
        dwErr = WSAGetLastError();

        Trace1( ERR, 
                "SendMZAPMessage: error %d sending message",
                dwErr );
    }

    return dwErr;
}

DWORD
SendMZAPMessage( 
    IN PBYTE        pBuffer, 
    IN ULONG        ulBuffLen,
    IN IPV4_ADDRESS ipGroup,
    IN IPV4_ADDRESS ipInterface
    )
/*++
Called by:
    HandleZAM()
Arguments:
    IN pBuffer     - buffer containing message to send
    IN ulBuffLen   - length of buffer in bytes
    IN ipGroup     - destination address to send message to
    IN ipInterface - interface to send message out
Returns:
    whatever WSAGetLastError() returns
Locks:
    None
--*/
{
    SOCKADDR_IN    sinAddr;
    DWORD          dwErr = NO_ERROR, dwLen;

    dwErr = McSetMulticastIf( g_mzapLocalSocket, ipInterface );

    if (dwErr is SOCKET_ERROR)
    {
        dwErr = WSAGetLastError();

        Trace2( ERR, 
                "SendMZAPMessage: error %d setting oif to %d.%d.%d.%d", 
                dwErr, 
                PRINT_IPADDR(ipInterface) );
    }

    sinAddr.sin_family      = AF_INET;
    sinAddr.sin_addr.s_addr = ipGroup;
    sinAddr.sin_port        = htons(MZAP_PORT);

#ifdef DEBUG_MZAP
    Trace2( ERR, "SendMZAPMessage: sending %d bytes on %d.%d.%d.%d", ulBuffLen,
            PRINT_IPADDR(ipInterface));
#endif

    dwLen = sendto( g_mzapLocalSocket, 
                pBuffer, 
                ulBuffLen, 
                0, 
                (struct sockaddr*)&sinAddr,
                sizeof(sinAddr));

#ifdef DEBUG_MZAP
    Trace1( ERR, "SendMZAPMessage: sent %d bytes", dwLen);
#endif

    if (dwLen is SOCKET_ERROR )
    {
        dwErr = WSAGetLastError();

        Trace1( ERR, 
                "SendMZAPMessage: error %d sending message",
                dwErr );
    }

    return dwErr;
}

void
AddMZAPHeader(
    IN OUT PBYTE       *ppb,     // IN: pointer into buffer 
    IN     BYTE         byPType, // IN: message type
    IN     PSCOPE_ENTRY pScope   // IN: scope
    )
/*++
Description:
    Compose an MZAP message header in a buffer.
Arguments:
    IN/OUT ppb     - buffer to add an MZAP header to
    IN     byPType - message type to fill into header
    IN     pScope  - scope to fill into header
Called by:
    SendZAM(), SendZCM()
Locks:
    Assumes caller holds read lock on BOUNDARY_TABLE so pScope won't go away
--*/
{
    PBYTE             pb;
    IPV4_MZAP_HEADER *mh = (PIPV4_MZAP_HEADER)*ppb;
    BYTE              pConfName[257];
    ULONG             ulConfNameLen, ulConfLangLen;
    PSCOPE_NAME_ENTRY pName;
    int               iDefault;
    PLIST_ENTRY       pleNode;
    PBYTE             pLangName;

    // Make sure packing is correct
    ASSERT((((PBYTE)&mh->ipMessageOrigin) - ((PBYTE)mh)) is 4);
    
    mh->byVersion       = MZAP_VERSION;
    mh->byBPType        = byPType;
    if (pScope->bDivisible) 
    {
        mh->byBPType |= MZAP_BIG_BIT;
    }
    mh->byAddressFamily = ADDRFAMILY_IPV4;
    mh->byNameCount     = 0;
    mh->ipMessageOrigin = g_ipMyAddress;
    mh->ipScopeZoneID   = MyScopeZoneID(pScope);
    mh->ipScopeStart    = pScope->ipGroupAddress;
    mh->ipScopeEnd      = TOP_OF_SCOPE( pScope );

    // Append scope name blocks

    pb = *ppb + sizeof(IPV4_MZAP_HEADER);

    for (pleNode = pScope->leNameList.Flink;
         pleNode isnot &pScope->leNameList;
         pleNode = pleNode->Flink)
    {
        pName = CONTAINING_RECORD(pleNode, SCOPE_NAME_ENTRY, leNameLink);
        iDefault = (pName->bDefault)? MZAP_DEFAULT_BIT : 0;

        pLangName = GetLangName(pName->idLanguage);
        ulConfLangLen = strlen(pLangName);

        ulConfNameLen = WideCharToMultiByte( CP_UTF8,
                             0,
                             pName->snScopeName,
                             sn_strlen( pName->snScopeName ),
                             pConfName,
                             sizeof(pConfName),
                             NULL,
                             NULL );

        *pb++ = (BYTE)iDefault;
        *pb++ = (BYTE)ulConfLangLen;
        strncpy( pb, pLangName, ulConfLangLen );
        pb += ulConfLangLen;

        *pb++ = (BYTE)ulConfNameLen;
        strncpy( pb, pConfName, ulConfNameLen );
        pb += ulConfNameLen;

        mh->byNameCount++;
    }
    
    // Pad to a 4-byte boundary
    // Note that casting to a ULONG is 64-bit safe, since we only care about
    // the low-order bits anyway.

    while (((ULONG_PTR)pb) & 3)
    {
        *pb++ = '\0';
    }

    *ppb = pb;
}

INLINE
IPV4_ADDRESS
MzapRelativeGroup(
    IN PSCOPE_ENTRY pScope
    )
/*++
Description:
    Returns the Scope-relative group address for MZAP within a given scope.
Arguments:
    IN pScope - scope to find the MZAP group in
Returns:
    Address of the MZAP group in the scope
Locks:
    Assumes caller holds read lock on BOUNDARY_TABLE so pScope doesn't go away
--*/
{
    return htonl(ntohl(TOP_OF_SCOPE(pScope)) - MZAP_RELATIVE_GROUP);
}

ULONG
GetMZAPHeaderSize(
    IN PSCOPE_ENTRY pScope
    )
{
    PLIST_ENTRY       pleNode;
    ULONG             ulLen = sizeof(IPV4_MZAP_HEADER);
    BYTE              pConfName[257];
    PSCOPE_NAME_ENTRY pName;
    PBYTE             pLangName;
    ULONG             ulConfLangLen, ulConfNameLen;

    // For each scope name, add size needed to store it
    for (pleNode = pScope->leNameList.Flink;
         pleNode isnot &pScope->leNameList;
         pleNode = pleNode->Flink)
    {
        pName = CONTAINING_RECORD(pleNode, SCOPE_NAME_ENTRY, leNameLink);
        pLangName = GetLangName(pName->idLanguage);
        ulConfLangLen = strlen(pLangName);

        WideCharToMultiByte( CP_UTF8,
                             0,
                             pName->snScopeName,
                             sn_strlen( pName->snScopeName ),
                             pConfName,
                             sizeof(pConfName),
                             NULL,
                             NULL );

        ulConfNameLen = strlen( pConfName );

        ulLen += 3; // flags, langlen, and namelen
        ulLen += ulConfLangLen;
        ulLen += ulConfNameLen;
    }

    // Round up to multiple of 4
    ulLen =  4 * ((ulLen + 3) / 4);

    return ulLen;
}

ULONG
GetZAMBuffSize(
    IN PSCOPE_ENTRY pScope
    )
{
    ULONG ulLen = GetMZAPHeaderSize(pScope) + sizeof(IPV4_ZAM_HEADER);

#ifdef SECURE_MZAP
    // Add size of Authentication Block
    // XXX
#endif

    // return 512; // an unsigned IPv4 ZAM message is at most 284 bytes
    return ulLen;
}

DWORD
SendZAM(
    IN PSCOPE_ENTRY pScope
    )
/*++
Description:
    Send a ZAM message within a given scope.
Locks:
    Assumes caller holds lock on BOUNDARY_TABLE so pScope doesn't go away
--*/
{
    DWORD            dwErr;
    PBYTE            pBuffer, pb;
    PIPV4_ZAM_HEADER zam;
    ULONG            ulBuffLen;

    ulBuffLen = GetZAMBuffSize( pScope );

    pb = pBuffer = MALLOC( ulBuffLen );
    if (!pb)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Fill in MZAP header
    AddMZAPHeader(&pb, PTYPE_ZAM, pScope);

    zam = (PIPV4_ZAM_HEADER)pb;
    zam->bZT          = 0;
    zam->bZTL         = pScope->bZTL;
    zam->wHoldTime    = htons(ZAM_HOLDTIME);
    zam->ipAddress[0] = g_ipMyLocalZoneID;
    pb += sizeof(IPV4_ZAM_HEADER);

#ifdef SECURE_MZAP
    // Add optional authentication block here 
#endif

#ifdef DEBUG_MZAP
    Trace0(ERR, "Originate ZAM inside...");
#endif

    // Send on an interface which does not have a boundary for the given scope.
    dwErr = SendMZAPMessage( pBuffer, 
                             (DWORD)(pb-pBuffer), 
                             MZAP_LOCAL_GROUP, 
                             g_ipMyAddress );

    FREE( pBuffer );
    
    return dwErr;
}

ULONG
GetZCMBuffSize(
    IN PSCOPE_ENTRY pScope
    )
{
    PLIST_ENTRY pleNode;
    ULONG       ulLen = GetMZAPHeaderSize(pScope) + sizeof(IPV4_ZCM_HEADER);

    for (pleNode = pScope->leZBRList.Flink;
         pleNode isnot &pScope->leZBRList;
         pleNode = pleNode->Flink)
    {
        ulLen += sizeof(IPV4_ADDRESS);
    }

    return ulLen;
}

DWORD
SendZCM(
    IN PSCOPE_ENTRY pScope
    )
/*++
Description:
    Sends a Zone Convexity Message for a given scope.
Locks:
    Assumes caller has read lock on BOUNDARY_TABLE so pScope won't go away.
    Locks ZBR_LIST for reading.
--*/
{
    PBYTE             pb;
    PIPV4_ZCM_HEADER  zcm;
    PLIST_ENTRY       pleNode;
    PZBR_ENTRY        pZbr;
    WSABUF            wsaZcmBuf;
    DWORD             dwSize, dwErr;

    ENTER_READER(ZBR_LIST);
    {
        dwSize = GetZCMBuffSize(pScope);

        wsaZcmBuf.len = dwSize;
        wsaZcmBuf.buf = MALLOC( dwSize );
    
        pb = wsaZcmBuf.buf;
        if (!pb)
        {
            EXIT_LOCK(ZBR_LIST);

            return GetLastError();
        }
    
        // Fill in MZAP header
        AddMZAPHeader(&pb, PTYPE_ZCM, pScope);
    
        zcm = (PIPV4_ZCM_HEADER)pb;
        zcm->bZNUM      = 0;
        zcm->bReserved  = 0;
        zcm->wHoldTime  = htons(ZCM_HOLDTIME);
    
        // Add all known neighbors
        for (pleNode = pScope->leZBRList.Flink;
             pleNode isnot &pScope->leZBRList;
             pleNode = pleNode->Flink)
        {
            pZbr = CONTAINING_RECORD(pleNode, ZBR_ENTRY, leZBRLink);
    
            zcm->ipZBR[ zcm->bZNUM++ ] = pZbr->ipAddress;
        }
    }
    EXIT_LOCK(ZBR_LIST);

    pb += sizeof(IPV4_ZCM_HEADER) + zcm->bZNUM * sizeof(IPV4_ADDRESS);

#ifdef DEBUG_MZAP
    Trace0(ERR, "Sending ZCM...");
#endif

    dwErr = SendMZAPMessage( wsaZcmBuf.buf, 
                             (DWORD)(pb-wsaZcmBuf.buf), 
                             MzapRelativeGroup(pScope), 
                             g_ipMyAddress );

    // Free the buffer

    FREE( wsaZcmBuf.buf );
    
    return dwErr;
}

DWORD
SendZLE(
    IN PZLE_PENDING zle
    )
/*++
Description:
    Given a buffer holding a ZAM, immediately send a ZLE to the origin.
Locks:
    Assumes caller holds write lock on ZLE_LIST
--*/
{
    DWORD             dwErr;
    PBYTE             pBuffer    = zle->pBuffer;
    ULONG             ulBuffLen  = zle->ulBuffLen;
    IPV4_MZAP_HEADER *mh         = (PIPV4_MZAP_HEADER)pBuffer;
    IPV4_ADDRESS      ipDestAddr = mh->ipScopeEnd - MZAP_RELATIVE_GROUP;

    // Change PType to ZLE
    mh->byBPType = (mh->byBPType & MZAP_BIG_BIT) | PTYPE_ZLE;

#ifdef DEBUG_MZAP
    Trace0(ERR, "Sending ZLE...");
#endif
    
    // Return to sender
    dwErr = SendMZAPMessage( pBuffer, 
                             ulBuffLen, 
                             ipDestAddr, 
                             g_ipMyAddress );

    // Free up space
    DeletePendingZLE(zle);
    
    return dwErr;
}

double
UniformRandom01()
{
    return ((double)rand()) / RAND_MAX;
}

VOID
SendAllZamsAndZcms()
/*++
Locks:
    BOUNDARY_TABLE for reading
--*/
{
    PLIST_ENTRY  pleNode;
    PSCOPE_ENTRY pScope;
    double       t,x;
    ULONG        Tmin,Trange;
    BOOL         bSent = FALSE;

    ENTER_READER(BOUNDARY_TABLE);
    {
        for (pleNode = g_MasterScopeList.Flink;
             pleNode isnot &g_MasterScopeList;
             pleNode = pleNode->Flink)
        {
            pScope = CONTAINING_RECORD(pleNode, SCOPE_ENTRY, leScopeLink);

            // Send ZAM inside
            SendZAM( pScope );

            // Send ZCM inside
            SendZCM( pScope );

            bSent = TRUE;
        }

        if (bSent)
        {
            SendZCM( &g_LocalScope );
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    // Schedule the next time to send them
    Tmin   = ZAM_INTERVAL/2;
    Trange = ZAM_INTERVAL;
    x = UniformRandom01();
    t = Tmin + x*Trange;

    g_liZamExpiryTime = RtlLargeIntegerAdd( g_liZamExpiryTime,
          RtlConvertUlongToLargeInteger(TM_SECONDS((ULONG)floor(t+0.5))));
}


//////////////////////////////////////////////////////////////////////////////
// Functions for message processing
//////////////////////////////////////////////////////////////////////////////


VOID
CheckForScopeNameMismatch(
    IN PSCOPE_ENTRY      pScope, 
    IN IPV4_MZAP_HEADER *mh
    )
/*++
Locks:
    Assumes caller holds read lock on BOUNDARY_TABLE so pScope won't go away
--*/
{
    DWORD i, dwMsgNameLen, dwMsgLangLen, dwConfNameLen = 0, dwConfLangLen;
    DWORD dwMsgNameWLen;
    BYTE pMsgLang[257], *pb, *pConfLang;
    SCOPE_NAME        snConfName = NULL;
    SCOPE_NAME_BUFFER snMsgName;
    PLIST_ENTRY       pleNode;
    PSCOPE_NAME_ENTRY pName;

    // For each language in the message
    //    If we know that language
    //       If the names are different
    //           Signal a conflict

    pb = mh->pScopeNameBlock;

    for (i=0; i<mh->byNameCount; i++)
    {
        pb++; // skip flags
        dwMsgLangLen = *pb++;
        strncpy(pMsgLang, pb, dwMsgLangLen);
        pMsgLang[ dwMsgLangLen ] = '\0';
        pb += dwMsgLangLen;

        dwMsgNameLen = *pb++;
        
        dwMsgNameWLen = MultiByteToWideChar( CP_UTF8,
                             0,
                             pb,
                             dwMsgNameLen,
                             snMsgName,
                             MAX_SCOPE_NAME_LEN+1 );

        snMsgName[dwMsgNameWLen] = L'\0';

        pb += dwMsgNameLen;

        pName = GetScopeNameByLangName( pScope, pMsgLang );
        if (!pName)
            continue;

        snConfName    = pName->snScopeName;
        dwConfNameLen = sn_strlen(snConfName);

        // Check for a name conflict

        if (dwConfNameLen != dwMsgNameWLen
         || sn_strncmp(snConfName, snMsgName, dwMsgNameWLen))
        {
            // Display origin and both scope names

            MakeAddressStringW(g_AddrBuf1, mh->ipMessageOrigin);

            Trace1( ERR,
                    "ERROR: Scope name conflict with %ls",
                    g_AddrBuf1 );

            Trace1( ERR, "ERROR: Our name = %ls", snConfName );

            Trace1( ERR, "ERROR: His name = %ls", snMsgName );

            RouterLogEventExW( LOGHANDLE,
                               EVENTLOG_ERROR_TYPE,
                               0,
                               ROUTERLOG_IP_SCOPE_NAME_CONFLICT,
                               L"%S%S%S",
                               g_AddrBuf1,
                               snConfName,
                               snMsgName );
        }
    }
}

VOID
ReportLeakyScope(
    IN PSCOPE_ENTRY      pScope,
    IN IPV4_MZAP_HEADER *mh,
    IN IPV4_ZAM_HEADER  *zam
    )
/*++
Called by:
    HandleZAM(), HandleZLE()
Locks:
    Assumes caller has read lock on BOUNDARY_TABLE so pScope won't go away
--*/
{
    ULONG  ulIdx;
    PWCHAR pwszBuffer, pb;

    Trace1( ERR,
            "ERROR: Leak detected in '%ls' scope!  One of the following routers is misconfigured:", 
            GetDefaultName( pScope ) );

    pb = pwszBuffer = MALLOC( zam->bZT * 20 + 1 );
    if (pwszBuffer is NULL)
    {
        Trace0( ERR, "ERROR: Couldn't allocate space for rest of message");
        return;
    }

    // Add origin.
    swprintf(pb, L"   %d.%d.%d.%d", PRINT_IPADDR(mh->ipMessageOrigin ));
    pb += wcslen(pb);
    
    Trace1( ERR, 
            "   %d.%d.%d.%d", 
            PRINT_IPADDR(mh->ipMessageOrigin ));

    // Display addresses of routers in the path list.
    for (ulIdx=0; ulIdx < zam->bZT; ulIdx++)
    {
        swprintf(pb,L"   %d.%d.%d.%d", PRINT_IPADDR(zam->ipAddress[ulIdx*2+1]));
        pb += wcslen(pb);

        Trace1( ERR, 
                "   %d.%d.%d.%d", 
                PRINT_IPADDR(zam->ipAddress[ulIdx*2+1] ));
    }

    // write to event log

    RouterLogEventExW( LOGHANDLE,
                       EVENTLOG_ERROR_TYPE,
                       0,
                       ROUTERLOG_IP_LEAKY_SCOPE,
                       L"%S%S",
                       GetDefaultName(pScope),
                       pwszBuffer );

    FREE( pwszBuffer );
}

VOID
CheckForScopeRangeMismatch(
    IN IPV4_MZAP_HEADER *mh
    )
/*++
Called by:
    HandleZAM(), HandleZCM()
Locks:
    Assumes caller has read lock on BOUNDARY_TABLE
--*/
{
    PLIST_ENTRY  pleNode;
    PSCOPE_ENTRY pScope;

    for (pleNode = g_MasterScopeList.Flink;
         pleNode isnot &g_MasterScopeList;
         pleNode = pleNode->Flink)
    {
        pScope = CONTAINING_RECORD(pleNode, SCOPE_ENTRY, leScopeLink);

        if (mh->ipScopeStart > TOP_OF_SCOPE(pScope)
         || mh->ipScopeEnd   < pScope->ipGroupAddress)
            continue;
            
        MakeAddressStringW(g_AddrBuf1, mh->ipScopeStart);
        MakeAddressStringW(g_AddrBuf2, mh->ipScopeEnd);
        MakeAddressStringW(g_AddrBuf3, pScope->ipGroupAddress);
        MakeAddressStringW(g_AddrBuf4, TOP_OF_SCOPE(pScope) );

        Trace1( ERR,
                "ERROR: ZAM scope conflicts with configured scope '%ls'!",
                GetDefaultName(pScope) );

        Trace2( ERR,
                "ERROR: ZAM has: (%ls-%ls)",
                g_AddrBuf1,
                g_AddrBuf2 );

        Trace2( ERR,
                "ERROR: Scope is (%ls-%ls)",
                g_AddrBuf3,
                g_AddrBuf4 );

        RouterLogEventExW( LOGHANDLE,
                           EVENTLOG_ERROR_TYPE,
                           0,
                           ROUTERLOG_IP_SCOPE_ADDR_CONFLICT,
                           L"%S%S%S%S%S",
                           GetDefaultName(pScope),
                           g_AddrBuf1,
                           g_AddrBuf2,
                           g_AddrBuf3,
                           g_AddrBuf4 );

        break;
    }
}

BOOL
ZamIncludesZoneID(
    IPV4_ZAM_HEADER *zam,
    IPV4_ADDRESS     ipZoneID
    )
{
    ULONG ulIdx;

    for (ulIdx=0; ulIdx <= ((ULONG)zam->bZT)*2; ulIdx+=2)
    {
        if (zam->ipAddress[ulIdx] == ipZoneID)
        {
            return TRUE;
        }
    }

    return FALSE;
}

void
HandleZAM(
    IN PBYTE        pBuffer,    // IN: Buffer holding ZAM received
    IN ULONG        ulBuffLen,  // IN: Length of ZAM message
    IN PBOUNDARY_IF pInBIf      // IN: BIf on which ZAM arrived, or NULL
                                //     if it came from "inside"
    )
/*++
Called by:
    HandleMZAPSocket()
Locks:
    Assumes caller holds read lock on BOUNDARY_TABLE
    Locks ZLE_LIST for writing
--*/
{
    PBYTE             pb;
    IPV4_MZAP_HEADER *mh;
    IPV4_ZAM_HEADER  *zam;
    BOOL              bFound, bFromInside = FALSE;
    PSCOPE_ENTRY      pScope, pOverlap;
    BOUNDARY_ENTRY   *pBoundary = NULL;
    ULONG             ulIdx;
    PBOUNDARY_IF      pBIf;

    mh = (PIPV4_MZAP_HEADER)pBuffer;

    // Set pb to end of MZAP header

    pb = pBuffer + sizeof(IPV4_MZAP_HEADER); 
    for (ulIdx=0; ulIdx < mh->byNameCount; ulIdx++)
    {
        // skip flags
        pb ++;

        // skip language tag len and str
        pb += (1 + *pb);

        // skip scope name len and str
        pb += (1 + *pb);
    }

    // Note that casting to a ULONG is safe, since we only care about
    // the low-order bits anyway.

    while (((ULONG_PTR)pb) & 3)
        *pb++ = '\0';

    zam = (PIPV4_ZAM_HEADER)pb;

    {
        // Find matching scope entry
        pScope = FindScope( mh->ipScopeStart, 
                            ~(mh->ipScopeEnd - mh->ipScopeStart) );
        if (pScope) {
    
            pBoundary = (pInBIf)? FindBoundaryEntry(pInBIf, pScope) : NULL;
    
            if (pBoundary)
            {
                // ZAM arrived from "outside"
    
                //
                // If ZAM is for a scope we're inside, but was received over a
                // boundary, signal a leaky scope warning.
                //
    
                if (mh->ipScopeZoneID == MyScopeZoneID(pScope))
                {
                    ReportLeakyScope(pScope, mh, zam);
                }
    
                // If the previous Local Zone ID was given, update our 
                // local copy.
                if ( zam->ipAddress[ zam->bZT * 2 ] ) 
                {
                    pInBIf->ipOtherLocalZoneID = zam->ipAddress[ zam->bZT * 2 ];
                }
    
                //
                // If ZAM was received on an interface with a boundary for the
                // given scope, drop it.
                //
    
                return;
            }
            else
            {
                // ZAM arrived from "inside"
                bFromInside = TRUE;
    
                // Make sure we know about the origin as a neighbor
                AssertZBR(pScope, mh->ipMessageOrigin, zam->wHoldTime);
    
                //
                // If a ZAM was received from within the zone, then the
                // Zone ID should match.  Persistent mismatches are evidence
                // of a leaky Local Scope.
                //
    
                if (mh->ipScopeZoneID != MyScopeZoneID(pScope))
                {
                    //
                    // Display origin and scope info, warn about
                    // possible leaky local scope.
                    //

                    MakeAddressStringW(g_AddrBuf1, mh->ipMessageOrigin);

                    MakeAddressStringW(g_AddrBuf2, mh->ipScopeStart);
    
                    Trace2( ERR,
                            "WARNING: Possible leaky Local Scope detected between this machine and %ls, boundary exists for %ls.",
                            g_AddrBuf1,
                            g_AddrBuf2 );

                    RouterLogEventExW( LOGHANDLE,
                                       EVENTLOG_WARNING_TYPE,
                                       0,
                                       ROUTERLOG_IP_POSSIBLE_LEAKY_SCOPE,
                                       L"%S%S",
                                       g_AddrBuf1,
                                       g_AddrBuf2 );
                }
    
                // See if scope names don't match
                CheckForScopeNameMismatch(pScope, mh);
            }
    
            // If last local zone ID is 0, but we know a zone ID, fill it in.
            if ( ! zam->ipAddress[ zam->bZT * 2 ] ) 
            {
               if (pBoundary)
                  zam->ipAddress[ zam->bZT*2 ] = pInBIf->ipOtherLocalZoneID;
               else
                  zam->ipAddress[ zam->bZT*2 ] = MyScopeZoneID(pScope);
            }
    
        }
        else 
        {
            //
            // Check for conflicting address ranges.  A scope conflicts
            // if any locally-configured scope's range overlaps that in the ZAM.
            //
    
            CheckForScopeRangeMismatch(mh);
        }
    }

    // Check ZAM cache.  If found, drop new ZAM.
    AssertInZamCache(mh->ipScopeZoneID, mh->ipScopeStart, &bFound);
    Trace3(MCAST, "ZAM Cache check for %d.%d.%d.%d, %d.%d.%d.%d is %d",
                  PRINT_IPADDR(mh->ipScopeZoneID),
                  PRINT_IPADDR( mh->ipScopeStart),
                  bFound);
    if (bFound)
    {
#ifdef SECURE_MZAP
        // If cached ZAM wasn't authenticated, and this one is, 
        // then go ahead and forward it. XXX
#endif
        return;
    }

    // If it's from outside, see if our Local Zone ID is already in 
    // the path list. If so, drop it.
    if (!bFromInside)
    {
        if (ZamIncludesZoneID(zam, g_ipMyLocalZoneID))
            return;
    }

    // Update Zones travelled, and drop if we've reached the limit
    zam->bZT++;
    if (zam->bZT >= zam->bZTL)
    {
        PBYTE  pBufferDup;
        ZLE_PENDING *zle;
        LARGE_INTEGER liCurrentTime, liExpiryTime;
        double x,c,t;

        ENTER_WRITER(MZAP_TIMER);
        ENTER_WRITER(ZLE_LIST);
        {
            // See if one is already scheduled
            if (FindPendingZLE(mh))
            {
                EXIT_LOCK(ZLE_LIST);
                EXIT_LOCK(MZAP_TIMER);
                return;
            }

            // Schedule a ZLE message
            x = UniformRandom01();
            c = 256.0;
            t = ZLE_SUPPRESSION_INTERVAL * log(c*x+1) / log(c);

            // Duplicate the message
            pBufferDup = MALLOC( ulBuffLen );
            if (!pBufferDup)
            {
                EXIT_LOCK(ZLE_LIST);
                EXIT_LOCK(MZAP_TIMER);
                return;
            }

            memcpy(pBufferDup, pBuffer, ulBuffLen);

            NtQuerySystemTime(&liCurrentTime);

            liExpiryTime = RtlLargeIntegerAdd(liCurrentTime, 
              RtlConvertUlongToLargeInteger(TM_SECONDS((ULONG)floor(t+0.5))));

            zle = AddPendingZLE(pBufferDup, ulBuffLen, liExpiryTime);
        }
        EXIT_LOCK(ZLE_LIST);

        UpdateMzapTimer();

        EXIT_LOCK(MZAP_TIMER);

        return;
    }

    // Add our address
    ulBuffLen += 2*sizeof(IPV4_ADDRESS);
    zam->ipAddress[ zam->bZT*2 - 1 ] = g_ipMyAddress;

    // If from outside, inject inside
    if ( !bFromInside )
    {
        zam->ipAddress[ zam->bZT*2 ] = g_ipMyLocalZoneID;

#ifdef DEBUG_MZAP
        Trace0(ERR, "Relaying ZAM inside...");
#endif

        SendMZAPMessage( pBuffer, 
                         ulBuffLen,
                         MZAP_LOCAL_GROUP, 
                         g_ipMyAddress );
    }

    //
    // Re-originate on all interfaces with boundaries
    // (skipping the arrival interface, if it has a boundary)
    // We don't need to hold the lock on the BOUNDARY_TABLE from
    // the first pass above, since it doesn't matter whether the
    // boundaries change in between.
    //
    ENTER_READER(BOUNDARY_TABLE);
    {
        PLIST_ENTRY       pleNode;
        DWORD             dwBucketIdx;

        for (dwBucketIdx = 0;
             dwBucketIdx < BOUNDARY_HASH_TABLE_SIZE;
             dwBucketIdx++)
        {
            for (pleNode = g_bbScopeTable[dwBucketIdx].leInterfaceList.Flink;
                 pleNode isnot & g_bbScopeTable[dwBucketIdx].leInterfaceList;
                 pleNode = pleNode->Flink)
            {
                pBIf = CONTAINING_RECORD( pleNode, 
                                          BOUNDARY_IF, 
                                          leBoundaryIfLink );
        
                if ( pBIf == pInBIf )
                    continue;

                if (FindBoundaryEntry(pBIf, pScope))
                {
#ifdef DEBUG_MZAP
                    Trace1(ERR, "NOT relaying ZAM on IF %d due to boundary",
                                 pBIf->dwIfIndex );
#endif
                    continue;
                }

                // If other local zone ID is already in the path,
                // skip it.

                if (pBIf->ipOtherLocalZoneID
                 && ZamIncludesZoneID(zam, pBIf->ipOtherLocalZoneID))
                    continue;

                zam->ipAddress[ zam->bZT*2 ] = pBIf->ipOtherLocalZoneID;

#ifdef DEBUG_MZAP
                Trace0(ERR, "Relaying ZAM outside by index...");
#endif

                SendMZAPMessageByIndex( pBuffer, 
                                        ulBuffLen, 
                                        MZAP_LOCAL_GROUP, 
                                        pBIf->dwIfIndex );
            }
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);
}

void
HandleZCM(
    IN PBYTE        pBuffer,    // IN: Buffer holding ZAM received
    IN ULONG        ulBuffLen,  // IN: Length of ZAM message
    IN PBOUNDARY_IF pInBIf      // IN: Interface on which the message arrived,
                                //     or NULL if from "inside"
    )
/*++
Called by:
    HandleMZAPSocket()
Locks:
    BOUNDARY_TABLE for reading
--*/
{
    PBYTE             pb;
    IPV4_MZAP_HEADER *mh = (PIPV4_MZAP_HEADER)pBuffer;
    IPV4_ZCM_HEADER  *zcm;
    PSCOPE_ENTRY      pScope;
    ULONG             i;
    BOOL              bRouteFound;

    // Set pb to end of MZAP header

    pb = pBuffer + sizeof(IPV4_MZAP_HEADER); 
    for (i=0; i < mh->byNameCount; i++)
    {
        // skip flags
        pb ++;

        // skip language tag len and str
        pb += (1 + *pb);

        // skip scope name len and str
        pb += (1 + *pb);
    }

    //
    // Note that casting to a ULONG is safe, since we only care about
    // the low-order bits anyway.
    //

    while (((ULONG_PTR)pb) & 3)
        *pb++ = '\0';

    zcm = (PIPV4_ZCM_HEADER)pb;

    ENTER_READER(BOUNDARY_TABLE);
    {
        // Find matching scope entry

        if (mh->ipScopeStart == IPV4_LOCAL_SCOPE_ADDR
         &&  ~(mh->ipScopeEnd - mh->ipScopeStart) == IPV4_LOCAL_SCOPE_MASK)
        {
            pScope = &g_LocalScope;
        }
        else
        {
            pScope = FindScope( mh->ipScopeStart, 
                            ~(mh->ipScopeEnd - mh->ipScopeStart) );
        }

        if (pScope) {
            PBOUNDARY_IF    pBIf;
            PBOUNDARY_ENTRY pBoundary;

            pBoundary = (pInBIf)? FindBoundaryEntry(pInBIf, pScope) : NULL;

            if (pBoundary)
            {
                // ZCM arrived from "outside"
    
                //
                // If ZCM was received on an interface with a boundary for the
                // given scope, drop it.
                //
    
                EXIT_LOCK(BOUNDARY_TABLE);

                return;
            }
            else
            {
                // ZCM arrived from "inside"

#ifdef HAVE_RTMV2
                RTM_NET_ADDRESS  naZBR;
                RTM_DEST_INFO    rdi;
                PRTM_ROUTE_INFO  pri;
                RTM_NEXTHOP_INFO nhi;
                ULONG            ulIdx;
#endif
    
                // Make sure we know about the origin as a neighbor
                AssertZBR(pScope, mh->ipMessageOrigin, zcm->wHoldTime);
    
#ifdef HAVE_RTMV2
                //
                // If multicast RIB route to any router address included
                // is over a boundary for the given scope, signal 
                // non-convexity warning.
                //

                pri = HeapAlloc(
                            IPRouterHeap,
                            0,
                            RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                            );

                if (pri == NULL)
                {
                    EXIT_LOCK(BOUNDARY_TABLE);

                    return;
                }
                
                for (i = 0; i < zcm->bZNUM; i++)
                {
                    RTM_IPV4_MAKE_NET_ADDRESS(&naZBR, zcm->ipZBR[i], 32);

                    // Look up route in multicast RIB
                    if ( RtmGetMostSpecificDestination( g_hLocalRoute,
                                                        &naZBR,
                                                        RTM_BEST_PROTOCOL,
                                                        RTM_VIEW_MASK_MCAST,
                                                        &rdi ) isnot NO_ERROR )
                    {
                        continue;
                    }
    
                    //
                    // See if next hop interface has a boundary for the 
                    // ZCM group
                    //

                    ASSERT(rdi.ViewInfo[0].ViewId == RTM_VIEW_ID_MCAST);

                    if ( RtmGetRouteInfo( g_hLocalRoute, 
                                          rdi.ViewInfo[0].Route,
                                          pri,
                                          NULL ) is NO_ERROR )
                    {
                        for (ulIdx = 0;
                             ulIdx < pri->NextHopsList.NumNextHops;
                             ulIdx++)
                        {
                            if ( RtmGetNextHopInfo( g_hLocalRoute,
                                                    pri->NextHopsList.NextHops[ulIdx],
                                                    &nhi ) is NO_ERROR )
                            {
                                if ( RmHasBoundary( nhi.InterfaceIndex,
                                                    MzapRelativeGroup(pScope) ))
                                {
                                    MakeAddressStringW(g_AddrBuf1, 
                                                       mh->ipMessageOrigin);
                                    Trace2( ERR,
                                            "ERROR: non-convex scope zone for '%ls', router %ls",
                                            GetDefaultName(pScope),
                                            g_AddrBuf1 );

                                    RouterLogEventExW( LOGHANDLE,
                                                       EVENTLOG_ERROR_TYPE,
                                                       0,
                                                 ROUTERLOG_NONCONVEX_SCOPE_ZONE,
                                                       L"%S%S",
                                                       GetDefaultName(pScope),
                                                       g_AddrBuf1
                                                     );
                                }

                                RtmReleaseNextHopInfo( g_hLocalRoute, &nhi);
                            }
                        }

                        RtmReleaseRouteInfo( g_hLocalRoute, pri );
                    }

                    RtmReleaseDestInfo(g_hLocalRoute, &rdi);
                }

                HeapFree(IPRouterHeap, 0, pri);
                
#endif /* HAVE_RTMV2 */

                // See if scope names don't match
                CheckForScopeNameMismatch(pScope, mh);
            }
        }
        else 
        {
            //
            // Check for conflicting address ranges.  A scope conflicts
            // if any locally-configured scope's range overlaps that in the ZAM.
            //
            CheckForScopeRangeMismatch(mh);
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);
}

void
HandleZLE(
    IN PBYTE pBuffer,
    IN ULONG ulBuffLen    
    )
/*++
Called by:
    HandleMZAPSocket()
Locks:
    BOUNDARY_TABLE for reading
    ZLE_LIST for writing
--*/
{
    PBYTE             pb;
    IPV4_MZAP_HEADER *mh;
    IPV4_ZAM_HEADER  *zam;
    PSCOPE_ENTRY      pScope;
    ZLE_PENDING      *zle;
    ULONG             ulIdx;

    mh = (PIPV4_MZAP_HEADER)pBuffer;

    // Set pb to end of MZAP header

    pb = pBuffer + sizeof(IPV4_MZAP_HEADER); 
    for (ulIdx=0; ulIdx < mh->byNameCount; ulIdx++)
    {
        // skip flags
        pb ++;

        // skip language tag len and str
        pb += (1 + *pb);

        // skip scope name len and ptr
        pb += (1 + *pb);
    }

    //
    // Note that casting to a ULONG is safe, since we only care about
    // the low-order bits anyway.
    //

    while (((ULONG_PTR)pb) & 3)
        *pb++ = '\0';

    zam = (PIPV4_ZAM_HEADER)pb;

    ENTER_READER(BOUNDARY_TABLE);
    {
        // Find matching scope entry
        pScope = FindScope( mh->ipScopeStart, 
                            ~(mh->ipScopeEnd - mh->ipScopeStart) );

        //
        // ZLE's are multicast.  If we are the "Message Origin", signal a
        // leaky scope warning.  Display addresses of routers in the path list.
        //
    
        if (mh->ipMessageOrigin == g_ipMyAddress)
        {
            ReportLeakyScope(pScope, mh, zam);

            EXIT_LOCK(BOUNDARY_TABLE);
    
            return;
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    // Otherwise, abort any pending ZLE which matches the one received
    ENTER_WRITER(ZLE_LIST);
    {
        if ((zle = FindPendingZLE(mh)) isnot NULL)
        {
            DeletePendingZLE(zle);
        }
    }
    EXIT_LOCK(ZLE_LIST);
}

VOID
HandleMZAPSocket(
    PBOUNDARY_IF pBIf,
    SOCKET       s
    )
/*++
Description:
    Receive an MZAP message on a socket s, and dispatch it to the 
    appropriate function.
Called by:
    HandleMZAPMessages()
Locks:
    Assumes caller holds read lock on BOUNDARY_TABLE if pBIf is non-NULL
--*/
{
    IPV4_MZAP_HEADER *mh;
    DWORD             dwErr, dwNumBytes, dwFlags, dwAddrLen, dwSizeOfHeader;
    DWORD             dwDataLen;
    SOCKADDR_IN       sinFrom;
    WSANETWORKEVENTS  wsaNetworkEvents;

    if (s is INVALID_SOCKET)
        return;

    if (WSAEnumNetworkEvents( s,
                              NULL,
                              &wsaNetworkEvents) is SOCKET_ERROR)
    {
        dwErr = GetLastError();

        Trace1(ERR,
               "HandleMZAPMessages: WSAEnumNetworkEvents() returned %d",
               dwErr);

        return;
    }

    if (!(wsaNetworkEvents.lNetworkEvents & FD_READ))
    {
        return;
    }

    if (wsaNetworkEvents.iErrorCode[FD_READ_BIT] isnot NO_ERROR)
    {
        Trace1( ERR,
                "HandleMZAPMessages: Error %d on FD_READ",
                wsaNetworkEvents.iErrorCode[FD_READ_BIT] );

        return;
    }

    //
    // read the incoming packet.  If the buffer isn't big enough,
    // WSAEMSGSIZE will be returned, and we'll ignore the message.
    // We don't currently expect this will ever happen.
    //

    dwAddrLen  = sizeof(sinFrom);
    dwFlags    = 0;

    dwErr = WSARecvFrom( s,
                         &g_wsaMcRcvBuf,
                         1,
                         &dwNumBytes,
                         &dwFlags,
                         (SOCKADDR FAR *)&sinFrom,
                         &dwAddrLen,
                         NULL,
                         NULL );

    //
    // check if any error in reading packet
    //

    if ((dwErr!=0) || (dwNumBytes==0))
    {
        dwErr = WSAGetLastError();

        Trace1( MCAST,
                "HandleMZAPSocket: Error %d receiving MZAP message",
                dwErr);

        // LogErr1(RECVFROM_FAILED, lpszAddr, dwErr);

        return;
    }

    mh = (PIPV4_MZAP_HEADER)g_wsaMcRcvBuf.buf;

    if (mh->byVersion isnot MZAP_VERSION)
        return;

#ifdef DEBUG_MZAP
    Trace4( MCAST,
            "HandleMZAPSocket: received type %x len %d IF %x from %d.%d.%d.%d",
            mh->byBPType,
            dwNumBytes,
            ((pBIf)? pBIf->dwIfIndex : 0),
            PRINT_IPADDR(mh->ipMessageOrigin) );
#endif

    switch(mh->byBPType & ~MZAP_BIG_BIT) {
    case PTYPE_ZAM: 
        HandleZAM(g_wsaMcRcvBuf.buf, dwNumBytes, pBIf); 
        break;
    case PTYPE_ZLE: 
        HandleZLE(g_wsaMcRcvBuf.buf, dwNumBytes);            
        break;
    case PTYPE_ZCM: 
        HandleZCM(g_wsaMcRcvBuf.buf, dwNumBytes, pBIf); 
        break;
    }

    return;
}

VOID
HandleMZAPMessages()
/*++
Called by:
    WorkerThread() in worker.c
Locks:
    BOUNDARY_TABLE for reading
--*/
{
    DWORD            dwBucketIdx;
    PLIST_ENTRY      pleNode;

    TraceEnter("HandleMZAPMessages");

    ENTER_READER(BOUNDARY_TABLE);
    {
        // Check local socket
        HandleMZAPSocket(NULL, g_mzapLocalSocket);

        // Loop through all BIf entries...
        for (dwBucketIdx = 0;
             dwBucketIdx < BOUNDARY_HASH_TABLE_SIZE;
             dwBucketIdx++)
        {
            for (pleNode = g_bbScopeTable[dwBucketIdx].leInterfaceList.Flink;
                 pleNode isnot & g_bbScopeTable[dwBucketIdx].leInterfaceList;
                 pleNode = pleNode->Flink)
            {
                PBOUNDARY_IF pBIf = CONTAINING_RECORD( pleNode, 
                                                       BOUNDARY_IF,
                                                       leBoundaryIfLink );

                HandleMZAPSocket(pBIf, pBIf->sMzapSocket);
            }
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    TraceLeave("HandleMZAPMessages");
}


//////////////////////////////////////////////////////////////////////////////
// Functions for timer events
//////////////////////////////////////////////////////////////////////////////

DWORD
UpdateMzapTimer()
/*++
Called by:
    AddZBR(), HandleZAM(), HandleMzapTimer()
Locks:
    Assumes caller has write lock on MZAP_TIMER
--*/
{
    DWORD         dwErr = NO_ERROR;
    LARGE_INTEGER liExpiryTime;
    PLIST_ENTRY   pleNode;

    TraceEnter("UpdateMzapTimer");

    //
    // Expiry time of next ZAM/ZCM advertisement is already in
    // g_liZamExpiryTime
    //

    liExpiryTime = g_liZamExpiryTime;

    //
    // Get expiry time of first ZBR
    //

    if (!IsListEmpty( &g_zbrTimerList ))
    {
        ZBR_ENTRY    *pZbr;

        pleNode = g_zbrTimerList.Flink;

        pZbr = CONTAINING_RECORD(pleNode, ZBR_ENTRY, leTimerLink);

        if (RtlLargeIntegerLessThan(pZbr->liExpiryTime, liExpiryTime))
        {
            liExpiryTime = pZbr->liExpiryTime;
        }
    }

    //
    // Get expiry time of first ZLE
    //

    if (!IsListEmpty( &g_zleTimerList ))
    {
        ZLE_PENDING  *zle;

        pleNode = g_zleTimerList.Flink;
        
        zle = CONTAINING_RECORD(pleNode, ZLE_PENDING, leTimerLink);

        if (RtlLargeIntegerLessThan(zle->liExpiryTime, liExpiryTime))
        {
            liExpiryTime = zle->liExpiryTime;
        }
    }

    //
    // Reset the event timer
    //

    if (!SetWaitableTimer( g_hMzapTimer,
                           &liExpiryTime,
                           0,
                           NULL,
                           NULL,
                           FALSE ))
    {
        dwErr = GetLastError();

        Trace1( ERR,
                "UpdateMzapTimer: Error %d setting timer",
                dwErr );

    }

    TraceLeave("UpdateMzapTimer");

    return dwErr;
}

VOID
HandleMzapTimer(
    VOID
    )
/*++
Description:
    Process all events which are now due
Locks:
    MZAP_TIMER and then ZBR_LIST for writing
--*/
{
    LARGE_INTEGER liCurrentTime;
    PLIST_ENTRY   pleNode;
    BOOL          bDidSomething;

    TraceEnter("HandleMzapTimer");

    ENTER_WRITER(MZAP_TIMER);

    do 
    {
        bDidSomething = FALSE;

        NtQuerySystemTime(&liCurrentTime);

        //
        // Process timing out ZBRs if due
        //

        ENTER_WRITER(ZBR_LIST);
        {
            for ( pleNode = g_zbrTimerList.Flink;
                  pleNode isnot &g_zbrTimerList;
                  pleNode = g_zbrTimerList.Flink)
            {
                ZBR_ENTRY *pZbr;
    
                pZbr = CONTAINING_RECORD(pleNode, ZBR_ENTRY, leTimerLink);
    
                if (RtlLargeIntegerLessThan(liCurrentTime, pZbr->liExpiryTime))
                    break;

                DeleteZBR(pZbr);

                bDidSomething = TRUE;
            }
        }
        EXIT_LOCK(ZBR_LIST);

        //
        // Process sending ZAM/ZCMs if due
        //

        if (RtlLargeIntegerGreaterThanOrEqualTo(liCurrentTime, 
                                                g_liZamExpiryTime))
        {
            SendAllZamsAndZcms();

            bDidSomething = TRUE;
        }

        //
        // Process sending ZLEs if due
        //

        ENTER_WRITER(ZLE_LIST);
        {
            for ( pleNode = g_zleTimerList.Flink;
                  pleNode isnot &g_zleTimerList;
                  pleNode = g_zleTimerList.Flink)
            {
                ZLE_PENDING *zle;

                zle = CONTAINING_RECORD(pleNode, ZLE_PENDING, leTimerLink);

                if (RtlLargeIntegerLessThan(liCurrentTime, zle->liExpiryTime))
                    break;

                SendZLE( zle );

                bDidSomething = TRUE;
            }
        }
        EXIT_LOCK(ZLE_LIST);

    } while (bDidSomething);

    // Reset the timer

    UpdateMzapTimer();

    EXIT_LOCK(MZAP_TIMER);

    TraceLeave("HandleMzapTimer");
}

//////////////////////////////////////////////////////////////////////////////


DWORD
ActivateMZAP()
/*++
Called by:
    StartMZAP(), BindBoundaryInterface()
--*/
{
    DWORD        dwErr = NO_ERROR;
    DWORD        dwBucketIdx;
    PLIST_ENTRY  pleNode;
    BOOL         bOption;
    SOCKADDR_IN  sinAddr;

    TraceEnter("ActivateMZAP");

    g_ipMyLocalZoneID = g_ipMyAddress;

    MzapInitLocalScope();

    // Start listening for MZAP messages

    g_mzapLocalSocket = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );
    if (g_mzapLocalSocket is INVALID_SOCKET)
    {
        dwErr = WSAGetLastError();
        Trace1(ERR, "ActivateMZAP: error %d creating socket", dwErr);
        TraceLeave("ActivateMZAP");
        return dwErr;
    }

    if (WSAEventSelect( g_mzapLocalSocket,
                        g_hMzapSocketEvent,
                        FD_READ) is SOCKET_ERROR)
    {
        dwErr = WSAGetLastError();
        Trace1(ERR,
               "ActivateMZAP: WSAEventSelect failed for local socket, Err=%d",
               dwErr);

        closesocket( g_mzapLocalSocket );

        g_mzapLocalSocket = INVALID_SOCKET;

        TraceLeave("ActivateMZAP");

        return dwErr;
    }

    bOption = TRUE;

    if(setsockopt(g_mzapLocalSocket,
                  SOL_SOCKET,
                  SO_REUSEADDR,
                  (const char FAR*)&bOption,
                  sizeof(BOOL)) is SOCKET_ERROR)
    {
        Trace1(ERR,
               "ActivateMZAP: Couldn't set reuse option - continuing. Error %d",
               WSAGetLastError());
    }

    // Bind to INADDR_ANY/MZAP_PORT to get ZLEs
    sinAddr.sin_family = AF_INET;
    sinAddr.sin_addr.s_addr = INADDR_ANY;
    sinAddr.sin_port = htons(MZAP_PORT);
    if (bind(g_mzapLocalSocket, (struct sockaddr*)&sinAddr, sizeof(sinAddr))
        is SOCKET_ERROR)
    {
        dwErr = WSAGetLastError();
        Trace2(ERR, "ActivateMZAP: error %d binding to port %d", dwErr, MZAP_PORT);
        TraceLeave("ActivateMZAP");
        return dwErr;
    }
                              
    // Set TTL to 255
    if (McSetMulticastTtl( g_mzapLocalSocket, 255 ) is SOCKET_ERROR)
    {
        Trace1(ERR,
               "ActivateMZAP: Couldn't set TTL. Error %d",
               WSAGetLastError());
    }

    ENTER_READER(BOUNDARY_TABLE);
    {
        //
        // Join MZAP_RELATIVE_GROUPs locally, to get ZCMs
        //

        for (pleNode = g_MasterScopeList.Flink;
             pleNode isnot &g_MasterScopeList;
             pleNode = pleNode->Flink) 
        {
            SCOPE_ENTRY *pScope = CONTAINING_RECORD(pleNode, SCOPE_ENTRY,
             leScopeLink);
    
            if (McJoinGroup( g_mzapLocalSocket, 
                             MzapRelativeGroup(pScope), 
                             g_ipMyAddress ) is SOCKET_ERROR)
            {
                dwErr = WSAGetLastError();

                Trace3( ERR,
                        "Error %d joining %d.%d.%d.%d on %d.%d.%d.%d",
                        dwErr,
                        PRINT_IPADDR(MzapRelativeGroup(pScope)),
                        PRINT_IPADDR(g_ipMyAddress) );

                EXIT_LOCK(BOUNDARY_TABLE);

                TraceLeave("ActivateMZAP");

                return dwErr;
            }
        }
    
        //
        // Join MZAP_LOCAL_GROUP in each local zone we connect to, to get ZAMs
        //

        if (McJoinGroup( g_mzapLocalSocket, 
                         MZAP_LOCAL_GROUP, 
                         g_ipMyAddress ) is SOCKET_ERROR)
        {
            dwErr = WSAGetLastError();

            Trace3( ERR,
                    "Error %d joining %d.%d.%d.%d on %d.%d.%d.%d",
                    dwErr,
                    PRINT_IPADDR(MZAP_LOCAL_GROUP),
                    PRINT_IPADDR(g_ipMyAddress) );

            EXIT_LOCK(BOUNDARY_TABLE);

            TraceLeave("ActivateMZAP");

            return dwErr;
        }

        for (dwBucketIdx = 0;
             dwBucketIdx < BOUNDARY_HASH_TABLE_SIZE;
             dwBucketIdx++)
        {
            for (pleNode = g_bbScopeTable[dwBucketIdx].leInterfaceList.Flink;
                 pleNode isnot & g_bbScopeTable[dwBucketIdx].leInterfaceList;
                 pleNode = pleNode->Flink)
            {
                PBOUNDARY_IF pBIf = CONTAINING_RECORD( pleNode, 
                                                       BOUNDARY_IF,
                                                       leBoundaryIfLink );
                if ( pBIf->sMzapSocket is INVALID_SOCKET )
                {
                    // Interface is not yet active.  The join will be
                    // done at the time BindBoundaryInterface() is called

                    continue;
                }
    
                if (McJoinGroupByIndex( pBIf->sMzapSocket,
                                        SOCK_DGRAM,
                                        MZAP_LOCAL_GROUP, 
                                        pBIf->dwIfIndex ) is SOCKET_ERROR)
                {
                    dwErr = WSAGetLastError();

                    Trace3( ERR,
                            "Error %d joining %d.%d.%d.%d on IF %x",
                            dwErr,
                            PRINT_IPADDR(MZAP_LOCAL_GROUP),
                            pBIf->dwIfIndex );

                    EXIT_LOCK(BOUNDARY_TABLE);

                    TraceLeave("ActivateMZAP");

                    return dwErr;
                }
            }
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    //
    // Initialize timer used for sending messages
    //

    ENTER_WRITER(MZAP_TIMER);
    {
        LARGE_INTEGER liCurrentTime, liExpiryTime;

        NtQuerySystemTime( &liCurrentTime );

        g_liZamExpiryTime = RtlLargeIntegerAdd( liCurrentTime,
         RtlConvertUlongToLargeInteger(TM_SECONDS(ZAM_STARTUP_DELAY)) );

        UpdateMzapTimer();
    }
    EXIT_LOCK(MZAP_TIMER);

    TraceLeave("ActivateMZAP");

    return dwErr;
}

VOID
UpdateLowestAddress(
    PIPV4_ADDRESS pIpAddr, 
    PICB          picb
    )
{
    ULONG ulIdx;

    for (ulIdx=0; ulIdx<picb->dwNumAddresses; ulIdx++)
    {
         if (IS_ROUTABLE(picb->pibBindings[ulIdx].dwAddress)
             && (!*pIpAddr ||
                ntohl(picb->pibBindings[ulIdx].dwAddress)
              < ntohl(*pIpAddr)))
         {
                *pIpAddr = picb->pibBindings[ulIdx].dwAddress;
         }
    }
}

DWORD
MzapActivateBIf( 
    PBOUNDARY_IF pBIf
    )
/*++
Called by:
    AddBIfEntry(), BindBoundaryInterface()
Locks:
    Assumes caller holds at least a read lock on BOUNDARY_TABLE
--*/
{
    BOOL  bOption;
    DWORD dwErr = NO_ERROR;

    pBIf->sMzapSocket = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );

    if ( pBIf->sMzapSocket is INVALID_SOCKET )
    {
        dwErr = WSAGetLastError();

        Trace1(ERR, "StartMZAP: error %d creating socket", dwErr);

        return dwErr;
    }

    if (setsockopt( pBIf->sMzapSocket,
                    SOL_SOCKET,
                    SO_REUSEADDR,
                    (const char FAR*)&bOption,
                    sizeof(BOOL)) is SOCKET_ERROR)
    {
        Trace1(ERR,
               "MzapInitBIf: Couldn't set reuse option - continuing. Error %d",
               WSAGetLastError());
    }

#if 1
{
    struct sockaddr_in sinAddr;

    //
    // WORKAROUND FOR BUG #222214: must bind before set TTL will work
    //

    sinAddr.sin_family = AF_INET;
    sinAddr.sin_addr.s_addr = INADDR_ANY;
    sinAddr.sin_port = htons(MZAP_PORT);

    if (bind( pBIf->sMzapSocket, 
              (struct sockaddr*)&sinAddr, 
              sizeof(sinAddr) ) is SOCKET_ERROR)
    {
        dwErr = WSAGetLastError();

        Trace2( ERR, 
                "StartMZAP: error %d binding boundary socket to port %d", 
                dwErr, 
                MZAP_PORT);

        return dwErr;
    }
}
#endif                              

    // Set TTL to 255
    if (McSetMulticastTtl( pBIf->sMzapSocket, 255) is SOCKET_ERROR)
    {
        Trace1(ERR,
               "StartMZAP: Couldn't set TTL. Error %d",
               WSAGetLastError());
    }

    if (WSAEventSelect( pBIf->sMzapSocket,
                        g_hMzapSocketEvent,
                        FD_READ) is SOCKET_ERROR)
    {
        dwErr = WSAGetLastError();

        Trace1(ERR,
               "StartMZAP: WSAEventSelect failed for local socket, Err=%d",
               dwErr);

        closesocket( pBIf->sMzapSocket );

        pBIf->sMzapSocket = INVALID_SOCKET;

        return dwErr;
    }

    if (g_bMzapStarted)
    {
        if (McJoinGroupByIndex( pBIf->sMzapSocket,
                                SOCK_DGRAM,
                                MZAP_LOCAL_GROUP, 
                                pBIf->dwIfIndex ) is SOCKET_ERROR)
        {
            dwErr = WSAGetLastError();

            Trace3( ERR,
                    "Error %d joining %d.%d.%d.%d on IF %x",
                    dwErr,
                    PRINT_IPADDR(MZAP_LOCAL_GROUP),
                    pBIf->dwIfIndex );
        }
    }

    return dwErr;
}

DWORD
BindBoundaryInterface(
    PICB picb
    )
{
    DWORD        dwErr = NO_ERROR;
    ULONG        ulIdx;
    BOUNDARY_IF *pBif;

    TraceEnter("BindBoundaryInterface");

    if (!g_bMzapStarted)
        return NO_ERROR;

    ENTER_READER(BOUNDARY_TABLE);
    {
        pBif = FindBIfEntry(picb->dwIfIndex);

        if ( ! g_ipMyAddress && ! pBif )
        {
            UpdateLowestAddress(&g_ipMyAddress, picb);
    
            if (g_ipMyAddress)
                dwErr = ActivateMZAP();
        }
    
        if ( pBif && (pBif->sMzapSocket is INVALID_SOCKET))
        {
            dwErr = MzapActivateBIf(pBif );
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    TraceLeave("BindBoundaryInterface");

    return dwErr;
}

DWORD
StartMZAP()
/*++
Description:
    Initialize state and start running MZAP()
Called by:
    SetScopeInfo()
Locks:
    ICB_LIST for reading
    BOUNDARY_TABLE for reading
--*/
{
    DWORD        dwErr = NO_ERROR,
                 dwBucketIdx;
    SOCKADDR_IN  sinAddr;
    ULONG        ulIdx;
    PLIST_ENTRY  pleNode;
    PSCOPE_ENTRY pScope;
    BOOL         bOption;

    if (g_bMzapStarted)
        return NO_ERROR;

    g_bMzapStarted = TRUE;

    // Initialize local data structures
    InitializeListHead( &g_leZamCache );
    InitializeListHead( &g_leZleList );
    InitializeListHead( &g_zbrTimerList );
    InitializeListHead( &g_zleTimerList );

    //
    // Set address to lowest routable IP address which has no boundary 
    // configured on it.
    //

    ENTER_READER(ICB_LIST);
    {
        PICB picb;

        for (pleNode = ICBList.Flink;
             pleNode isnot &ICBList;
             pleNode = pleNode->Flink)
        {
            picb = CONTAINING_RECORD(pleNode, ICB, leIfLink);
    
            if (FindBIfEntry(picb->dwIfIndex))
                continue;
    
            UpdateLowestAddress(&g_ipMyAddress, picb);

        }
    }
    EXIT_LOCK(ICB_LIST);

    if (!g_ipMyAddress)
    {
        Trace0(ERR, "StartMZAP: no IP address found in local scope");

        return ERROR_NOT_SUPPORTED;
    }

    dwErr = ActivateMZAP();

    return dwErr;
}

void
StopMZAP()
/*++
Called by:
    SetScopeInfo()
--*/
{
    if (!g_bMzapStarted)
        return;

    g_bMzapStarted = FALSE;

    // Stop timer used for sending messages
    ENTER_WRITER(MZAP_TIMER);
    {
        CancelWaitableTimer(g_hMzapTimer);
    }
    EXIT_LOCK(MZAP_TIMER);

    // Stop listening for MZAP messages
    if (g_mzapLocalSocket isnot INVALID_SOCKET)
    {
        closesocket(g_mzapLocalSocket);
        g_mzapLocalSocket = INVALID_SOCKET;
    }

    //
    // Free up local data stores
    //    Empty ZAM cache
    //

    ENTER_WRITER(ZAM_CACHE);
    UpdateZamCache(RtlConvertUlongToLargeInteger(0));
    EXIT_LOCK(ZAM_CACHE);
}

VOID
MzapInitScope(
    PSCOPE_ENTRY pScope
    )
/*++
Description:
    Initialize MZAP fields of a scope
--*/
{
    pScope->ipMyZoneID      = g_ipMyLocalZoneID;    
    InitializeListHead(&pScope->leZBRList);
    pScope->bZTL            = MZAP_DEFAULT_ZTL;
    pScope->ulNumInterfaces = 0;
    pScope->bDivisible      = FALSE;
}



DWORD
MzapInitBIf(
    PBOUNDARY_IF pBIf
    )
/*++
Description:
    Called when the first boundary is added to an interface, and we
    need to start up MZAP on it.  MZAP may (if we add a boundary
    while the router is running) or may not (startup time) already be 
    running at this point.
Called by:
    AddBIfEntry()
Locks:
    Assumes caller holds a write lock on BOUNDARY_TABLE
--*/
{
    BOOL  bOption;
    DWORD dwErr = NO_ERROR;

    pBIf->ipOtherLocalZoneID = 0;
    
    pBIf->sMzapSocket = INVALID_SOCKET;

    return dwErr;
}

VOID
MzapUninitBIf(
    PBOUNDARY_IF pBIf
    )
/*++
Called by:
--*/
{
    if ( pBIf->sMzapSocket isnot INVALID_SOCKET )
    {
        closesocket( pBIf->sMzapSocket );

        pBIf->sMzapSocket = INVALID_SOCKET;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\logtrdef.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routign\ip\rtrmgr\logtrdefs.c

Abstract:

    IP Router Manager defines for tracing and logging

Revision History:

    Gurdeep Singh Pall          6/16/95  Created

--*/

#ifndef __LOGTRDEF_H__
#define __LOGTRDEF_H__

//
// constants and macros used for tracing
//

#define IPRTRMGR_TRACE_ANY              ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_ERR              ((DWORD)0x00010000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_ENTER            ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_IF               ((DWORD)0x00040000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_ROUTE            ((DWORD)0x00080000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_MIB              ((DWORD)0x00100000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_GLOBAL           ((DWORD)0x00200000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_DEMAND           ((DWORD)0x00400000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_RTRDISC          ((DWORD)0x00800000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_LOCK             ((DWORD)0x01000000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_MCAST            ((DWORD)0x02000000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_MZAP             ((DWORD)0x04000000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_INIT             ((DWORD)0x08000000 | TRACE_USE_MASK)


#define TRACEID         TraceHandle


#define Trace0(l,a)             \
            TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ ## l, a)
#define Trace1(l,a,b)           \
            TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ ## l, a, b)
#define Trace2(l,a,b,c)         \
            TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ ## l, a, b, c)
#define Trace3(l,a,b,c,d)       \
            TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ ## l, a, b, c, d)
#define Trace4(l,a,b,c,d,e)     \
            TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ ## l, a, b, c, d, e)
#define Trace5(l,a,b,c,d,e,f)   \
            TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ ## l, a, b, c, d, e, f)
#define Trace6(l,a,b,c,d,e,f,g) \
            TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ ## l, a, b, c, d, e, f, g)
#define Trace7(l,a,b,c,d,e,f,g,h) \
            TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ ## l, a, b, c, d, e, f, g, h)

#if TRACE_DBG

#define TraceEnter(X)   TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ENTER, "Entered: "X)
#define TraceLeave(X)   TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ENTER, "Leaving: "X"\n")

#define TraceRoute0     Trace0
#define TraceRoute1     Trace1
#define TraceRoute2     Trace2
#define TraceRoute3     Trace3
#define TraceRoute4     Trace4
#define TraceRoute5     Trace5

#else   // TRACE_DBG

#define TraceEnter(X)
#define TraceLeave(X)

#define TraceRoute0(l,a)
#define TraceRoute1(l,a,b)
#define TraceRoute2(l,a,b,c)
#define TraceRoute3(l,a,b,c,d)
#define TraceRoute4(l,a,b,c,d,e)
#define TraceRoute5(l,a,b,c,d,e,f)

#endif // TRACE_DBG


//
// Event logging macros
//

#define LOGLEVEL        g_dwLoggingLevel
#define LOGHANDLE       g_hLogHandle

#define LOGERR          RouterLogError
#define LOGERRW         RouterLogErrorW
#define LOGERRDATA      RouterLogErrorData
#define LOGWARN         RouterLogWarning
#define LOGWARNDATA     RouterLogWarningData
#define LOGINFO         RouterLogInformation
#define LOGINFODATA     RouterLogInformationData

//
// Error logging
//

//
//  VOID
//  Log{Err|Warn|Info}{NumArgs}(
//      DWORD    dwLogMsgId,
//      PSTR     pszInsertString1,
//      ....
//      PSTR     pszInsertString{NumArgs},
//      DWORD    dwErrorCode
//      );
//
//  VOID
//  Log{Err|Warn|Info}Data{NumArgs}(
//      DWORD    dwLogMsgId,
//      PSTR     pszInsertString1,
//      ....
//      PSTR     pszInsertString{NumArgs},
//      DWORD    dwDataSize,
//      PBYTE    pbData 
//      );
//


#define LogErr0(msg,err)                                    \
if (LOGLEVEL >= IPRTR_LOGGING_ERROR)                    \
            LOGERR(LOGHANDLE,ROUTERLOG_IP_ ## msg,0,NULL,(err))
#define LogErr1(msg,a,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,ROUTERLOG_IP_ ## msg,1,&(a),(err))
#define LogErr2(msg,a,b,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_ERROR) { \
            LPTSTR _asz[2] = { (a), (b) }; \
            LOGERR(LOGHANDLE,ROUTERLOG_IP_ ## msg,2,_asz,(err)); \
        }
#define LogErr3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_ERROR) { \
            LPTSTR _asz[3] = { (a), (b), (c) }; \
            LOGERR(LOGHANDLE,ROUTERLOG_IP_ ## msg,3,_asz,(err)); \
        }
#define LogErr4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_ERROR) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGERR(LOGHANDLE,ROUTERLOG_IP_ ## msg,4,_asz,(err)); \
        }
#define LogErr5(msg,a,b,c,d,e,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_ERROR) { \
            LPSTR _asz[5] = { (a), (b), (c), (d), (e) }; \
            LOGERR(LOGHANDLE,ROUTERLOG_IP_ ## msg,5,_asz,(err)); \
        }

#define LogErrW3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_ERROR) { \
            LPTSTR _asz[3] = { (a), (b), (c) }; \
            LOGERRW(LOGHANDLE,ROUTERLOG_IP_ ## msg,3,_asz,(err)); \
        }


// Warning logging

#define LogWarn0(msg,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,ROUTERLOG_IP_ ## msg,0,NULL,(err))
#define LogWarn1(msg,a,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,ROUTERLOG_IP_ ## msg,1,&(a),(err))
#define LogWarn2(msg,a,b,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_WARN) { \
            LPTSTR _asz[2] = { (a), (b) }; \
            LOGWARN(LOGHANDLE,ROUTERLOG_IP_ ## msg,2,_asz,(err)); \
        }
#define LogWarn3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_WARN) { \
            LPTSTR _asz[3] = { (a), (b), (c) }; \
            LOGWARN(LOGHANDLE,ROUTERLOG_IP_ ## msg,3,_asz,(err)); \
        }
#define LogWarn4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_WARN) { \
            LPTSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGWARN(LOGHANDLE,ROUTERLOG_IP_ ## msg,4,_asz,(err)); \
        }

#define LogWarnData2(msg,a,b,dw,buf) \
        if (LOGLEVEL >= IPRTR_LOGGING_WARN) { \
            LPTSTR _asz[2] = { (a), (b) }; \
            LOGWARNDATA(LOGHANDLE,ROUTERLOG_IP_ ## msg,2,_asz,(dw),(buf)); \
        }

#define LogWarnData5(msg,a,b,c,d,e,dw,buf) \
        if (LOGLEVEL >= IPRTR_LOGGING_WARN) { \
            LPTSTR _asz[5] = { (a), (b), (c), (d), (e)}; \
            LOGWARNDATA(LOGHANDLE,ROUTERLOG_IP_ ## msg,5,_asz,(dw),(buf)); \
        }


// Information logging

#define LogInfo0(msg,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,ROUTERLOG_IP_ ## msg,0,NULL,(err))
#define LogInfo1(msg,a,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,ROUTERLOG_IP_ ## msg,1,&(a),(err))
#define LogInfo2(msg,a,b,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_INFO) { \
            LPTSTR _asz[2] = { (a), (b) }; \
            LOGINFO(LOGHANDLE,ROUTERLOG_IP_ ## msg,2,_asz,(err)); \
        }
#define LogInfo3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_INFO) { \
            LPTSTR _asz[3] = { (a), (b), (c) }; \
            LOGINFO(LOGHANDLE,ROUTERLOG_IP_ ## msg,3,_asz,(err)); \
        }
#define LogInfo4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_INFO) { \
            LPTSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGINFO(LOGHANDLE,ROUTERLOG_IP_ ## msg,4,_asz,(err)); \
        }


#endif // __LOGTRDEF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\mbound.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\mbound.h

Abstract:

    Header file for admin-scoped boundaries

Revision History:

    Dave Thaler       20th Apr 1998      Created

--*/

#ifndef __MBOUND_H__
#define __MBOUND_H__

// Definitions for manipulating scope names

#ifdef SN_UNICODE
# define  sn_strlen  wcslen
# define  sn_strcpy  wcscpy
# define  sn_strncpy wcsncpy
# define  sn_strcmp  wcscmp
# define  sn_strncmp wcsncmp
# define  sn_sprintf wsprintf
# define  SN_L       L
#else
# define  sn_strlen  strlen
# define  sn_strcpy  strcpy
# define  sn_strncpy strncpy
# define  sn_strcmp  strcmp
# define  sn_strncmp strncmp
# define  sn_sprintf sprintf
# define  SN_L       
#endif

#define   SNCHARSIZE sizeof(SN_CHAR)

typedef struct _SCOPE_NAME_ENTRY {
    LIST_ENTRY   leNameLink;
    LANGID       idLanguage;
    SCOPE_NAME   snScopeName; // in unicode
    BOOL         bDefault;
} SCOPE_NAME_ENTRY, *PSCOPE_NAME_ENTRY;

typedef struct _SCOPE_ENTRY {
    LIST_ENTRY   leScopeLink;
    IPV4_ADDRESS ipGroupAddress;
    IPV4_ADDRESS ipGroupMask;
    ULONG        ulNumInterfaces;

    ULONG        ulNumNames;
    LIST_ENTRY   leNameList;

    // fields used by MZAP
    BOOL         bDivisible;
    IPV4_ADDRESS ipMyZoneID;
    LIST_ENTRY   leZBRList;
    BYTE         bZTL;
} SCOPE_ENTRY, *PSCOPE_ENTRY;

typedef struct _ZBR_ENTRY {
    LIST_ENTRY    leZBRLink;
    LIST_ENTRY    leTimerLink;
    IPV4_ADDRESS  ipAddress;
    LARGE_INTEGER liExpiryTime;
} ZBR_ENTRY, *PZBR_ENTRY;

typedef struct _BOUNDARY_BUCKET {
    LIST_ENTRY   leInterfaceList;
} BOUNDARY_BUCKET;

typedef struct _BOUNDARY_IF {
    LIST_ENTRY   leBoundaryIfLink;       // entry in list per bucket
    LIST_ENTRY   leBoundaryIfMasterLink; // entry in master list
    DWORD        dwIfIndex;
    LIST_ENTRY   leBoundaryList;

    // fields used by MZAP
    SOCKET       sMzapSocket;
    IPV4_ADDRESS ipOtherLocalZoneID;
} BOUNDARY_IF, *PBOUNDARY_IF;

typedef struct _BOUNDARY_ENTRY {
    LIST_ENTRY   leBoundaryLink;
    PSCOPE_ENTRY pScope;
} BOUNDARY_ENTRY, *PBOUNDARY_ENTRY;

typedef struct _RANGE_ENTRY {
    LIST_ENTRY   leRangeLink;
    IPV4_ADDRESS ipFirst;
    IPV4_ADDRESS ipLast;
} RANGE_ENTRY, *PRANGE_ENTRY;

// should this be moved into some snmp header file?
#define ROWSTATUS_ACTIVE        1
#define ROWSTATUS_NOTINSERVICE  2
#define ROWSTATUS_NOTREADY      3
#define ROWSTATUS_CREATEANDGO   4
#define ROWSTATUS_CREATEANDWAIT 5
#define ROWSTATUS_DESTROY       6

//
// Function prototypes
//

DWORD
SetMcastLimitInfo(
    IN PICB                   picb,
    IN PRTR_INFO_BLOCK_HEADER pInfoHdr
    );                                

DWORD
GetMcastLimitInfo(
    IN     PICB                   picb,
    IN OUT PRTR_TOC_ENTRY         pToc,
    IN OUT PDWORD                 pdwTocIndex,
    IN OUT PBYTE                  pBuffer,
    IN     PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwBufferSize
    );

void
InitializeBoundaryTable();

BOOL
RmHasBoundary(
    IN DWORD        dwIfIndex,
    IN IPV4_ADDRESS ipGroupAddress
    );

DWORD
SetBoundaryInfo(
    IN PICB                   picb,
    IN PRTR_INFO_BLOCK_HEADER pInfoHdr
    );                                

DWORD
GetBoundaryInfo(
    IN     PICB                   picb,
    IN OUT PRTR_TOC_ENTRY         pToc,
    IN OUT PDWORD                 pdwTocIndex,
    IN OUT PBYTE                  pBuffer,
    IN     PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwBufferSize
    );

DWORD
SetScopeInfo(
    IN PRTR_INFO_BLOCK_HEADER pInfoHdr
    );

DWORD
GetScopeInfo(
    IN OUT PRTR_TOC_ENTRY         pToc,
    IN OUT PDWORD                 pdwTocIndex,
    IN OUT PBYTE                  pBuffer,
    IN     PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwBufferSize
    );

DWORD
SNMPSetScope(
    IN  IPV4_ADDRESS  ipGroupAddress,
    IN  IPV4_ADDRESS  ipGroupMask,
    IN  SCOPE_NAME    snScopeName
    );

DWORD
SNMPAddScope(
    IN  IPV4_ADDRESS  ipGroupAddress,
    IN  IPV4_ADDRESS  ipGroupMask,
    IN  SCOPE_NAME    snScopeName,
    OUT PSCOPE_ENTRY *ppScope
    );

DWORD
SNMPDeleteScope(
    IN IPV4_ADDRESS  ipGroupAddress,
    IN IPV4_ADDRESS  ipGroupMask
    );                                    

DWORD
SNMPAddBoundaryToInterface(
    IN DWORD         dwIfIndex,
    IN IPV4_ADDRESS  ipGroupAddress,
    IN IPV4_ADDRESS  ipGroupMask
    );

DWORD
SNMPDeleteBoundaryFromInterface(
    IN DWORD         dwIfIndex,
    IN IPV4_ADDRESS  ipGroupAddress,
    IN IPV4_ADDRESS  ipGroupMask
    );                                    

//----------------------------------------------------------------------------
// BOUNDARY enumeration API
//----------------------------------------------------------------------------

DWORD
RmGetBoundary(
    IN              PMIB_IPMCAST_BOUNDARY   pimm,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer
);

DWORD
RmGetFirstBoundary(
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
);


DWORD
RmGetNextBoundary(
    IN              PMIB_IPMCAST_BOUNDARY   pimmStart,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
);

//----------------------------------------------------------------------------
// SCOPE enumeration API
//----------------------------------------------------------------------------

DWORD
RmGetScope(
    IN              PMIB_IPMCAST_SCOPE      pimm,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer
);

DWORD
RmGetFirstScope(
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
);


DWORD
RmGetNextScope(
    IN              PMIB_IPMCAST_SCOPE      pimmStart,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
);

#endif


// Constants used by MZAP

#define MZAP_VERSION               0
#define MZAP_LOCAL_GROUP ((DWORD)0xFcFFFFeF) // 239.255.255.252
#define MZAP_RELATIVE_GROUP        3 // TOP-3
#define MZAP_PORT               2106
#define MZAP_DEFAULT_ZTL          32
#if 0 
 // values used for testing
#define DEBUG_MZAP
#define ZAM_INTERVAL               5 // 5 seconds
#define ZAM_HOLDTIME              17 // 17 seconds
#define ZAM_DUP_TIME              15 // 15 seconds
#define ZAM_STARTUP_DELAY          0 // 0 seconds
#define ZCM_INTERVAL               5 // 5 seconds
#define ZCM_HOLDTIME              17 // 17 mins
#define ZLE_SUPPRESSION_INTERVAL   5 // 5 seconds
#define ZLE_MIN_INTERVAL           5 // 5 seconds
#else
#define ZAM_INTERVAL             600 // 10 mins
#define ZAM_HOLDTIME            1860 // 31 mins
#define ZAM_DUP_TIME              30 // 30 seconds
#define ZAM_STARTUP_DELAY          0 // 0 seconds
#define ZCM_INTERVAL             600 // 10 mins
#define ZCM_HOLDTIME            1860 // 31 mins
#define ZLE_SUPPRESSION_INTERVAL 300 // 5 mins
#define ZLE_MIN_INTERVAL         300 // 5 mins
#endif

#define MZAP_BIG_BIT            0x80

#define ADDRFAMILY_IPV4            1
#define ADDRFAMILY_IPV6            2

#define PTYPE_ZAM                  0
#define PTYPE_ZLE                  1
#define PTYPE_ZCM                  2
#define PTYPE_NIM                  3

DWORD
StartMZAP();

void
StopMZAP();

VOID
HandleMZAPMessages();

VOID
HandleMzapTimer();

DWORD
BindBoundaryInterface(
    PICB  picb
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\mcastif.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:


Abstract:

Revision History:



--*/


#include "allinc.h"

PCHAR   g_pszMsg[] = {
    "Packet Received",
    "MFE Deleted",
    "Wrong I/f Upcall"
};

DWORD
QueueAsyncFunction(
    WORKERFUNCTION   pfnFunction,
    PVOID            pvContext,
    BOOL             bAlertable
    );

DWORD
ValidateMfe(
    IN OUT  PIPMCAST_MFE    pMfe
    );


VOID
HandleRcvPkt(
    PVOID   pvContext
    )

/*++

Routine Description:


Locks:


Arguments:


Return Value:

    NO_ERROR

--*/

{
    PIP_HEADER   pHdr;
    DWORD        dwResult, dwOldIf;
    ULONG        ulIndex;

    PIPMCAST_PKT_MSG        pPktInfo;
    PIPMCAST_NOTIFICATION   pMsg;

    ulIndex  = PtrToUlong(pvContext);

    pMsg     = &(g_rginMcastMsg[ulIndex].msg);
    pPktInfo = &(pMsg->ipmPkt);

    pHdr     = (PIP_HEADER)(pPktInfo->rgbyData);

    Trace3(MCAST,
           "HandleRcvPkt: Rcvd pkt from %d.%d.%d.%d to %d.%d.%d.%d on %d",
           PRINT_IPADDR(pHdr->dwSrc),
           PRINT_IPADDR(pHdr->dwDest),
           pPktInfo->dwInIfIndex);

    dwResult = g_pfnMgmNewPacket(pHdr->dwSrc,
                                 pHdr->dwDest,
                                 pPktInfo->dwInIfIndex,
                                 pPktInfo->dwInNextHopAddress,
                                 pPktInfo->cbyDataLen,
                                 pPktInfo->rgbyData);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(MCAST,
               "HandleRcvPkt: MGM returned error %d\n", dwResult);
    }

    PostNotificationForMcastEvents(&(g_rginMcastMsg[ulIndex]),
                                   g_hMcastEvents[ulIndex]);

    ExitRouterApi();
}

VOID
HandleDeleteMfe(
    PVOID   pvContext
    )

/*++

Routine Description:


Locks:


Arguments:


Return Value:

    NO_ERROR

--*/

{
    DWORD        dwResult;
    ULONG        ulIndex, i;

    PIPMCAST_MFE_MSG        pMfeInfo;
    PIPMCAST_NOTIFICATION   pMsg;

    ulIndex  = PtrToUlong(pvContext);

    pMsg     = &(g_rginMcastMsg[ulIndex].msg);
    pMfeInfo = &(pMsg->immMfe);

    Trace1(MCAST,
           "HandleDeleteMfe: Kernel deleted %d MFEs\n",
           pMfeInfo->ulNumMfes);

    for(i = 0; i < pMfeInfo->ulNumMfes; i++)
    {
        Trace3(MCAST,
               "HandleDeleteMfe: Group %d.%d.%d.%d Source %d.%d.%d.%d/%d.%d.%d.%d\n",
               PRINT_IPADDR(pMsg->immMfe.idmMfe[i].dwGroup),
               PRINT_IPADDR(pMsg->immMfe.idmMfe[i].dwSource),
               PRINT_IPADDR(pMsg->immMfe.idmMfe[i].dwSrcMask));
    }

    dwResult = g_pfnMgmMfeDeleted(pMfeInfo->ulNumMfes,
                                  pMfeInfo->idmMfe);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(MCAST,
               "HandleDeleteMfe: MGM returned error %d\n", dwResult);
    }

    PostNotificationForMcastEvents(&(g_rginMcastMsg[ulIndex]),
                                   g_hMcastEvents[ulIndex]);

    ExitRouterApi();
}

VOID
HandleWrongIfUpcall(
    PVOID   pvContext
    )

/*++

Routine Description:


Locks:


Arguments:


Return Value:

    NO_ERROR

--*/

{
    PIP_HEADER   pHdr;
    DWORD        dwResult, dwOldIf;
    ULONG        ulIndex;

    PIPMCAST_PKT_MSG        pPktInfo;
    PIPMCAST_NOTIFICATION   pMsg;

    ulIndex  = PtrToUlong(pvContext);

    pMsg     = &(g_rginMcastMsg[ulIndex].msg);
    pPktInfo = &(pMsg->ipmPkt);

    pHdr     = (PIP_HEADER)(pPktInfo->rgbyData);

    Trace3(MCAST,
           "HandleWrongIfUpcall: Pkt from %d.%d.%d.%d to %d.%d.%d.%d on %d is wrong",
           PRINT_IPADDR(pHdr->dwSrc),
           PRINT_IPADDR(pHdr->dwDest),
           pPktInfo->dwInIfIndex);

    dwResult = g_pfnMgmWrongIf(pHdr->dwSrc,
                               pHdr->dwDest,
                               pPktInfo->dwInIfIndex,
                               pPktInfo->dwInNextHopAddress,
                               pPktInfo->cbyDataLen,
                               pPktInfo->rgbyData);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(MCAST,
               "HandleWrongIfUpcall: MGM returned error %d\n", dwResult);
    }
        
    PostNotificationForMcastEvents(&(g_rginMcastMsg[ulIndex]),
                                   g_hMcastEvents[ulIndex]);

    ExitRouterApi();
}

VOID
HandleMcastNotification(
    DWORD   dwIndex
    )

/*++

Routine Description:


Locks:


Arguments:


Return Value:

    NO_ERROR

--*/

{
    DWORD   dwResult;
    ULONG   i;
    
    PIPMCAST_NOTIFICATION   pMsg;
    

    pMsg = &(g_rginMcastMsg[dwIndex].msg);
    
    
    //
    // read the notification
    //


    Trace1(MCAST,
           "HandleMcastNotification: Notification received for %s\n",
           g_pszMsg[pMsg->dwEvent]);
                
    switch(pMsg->dwEvent)
    {
        case IPMCAST_RCV_PKT_MSG:
        {
            QueueAsyncFunction(HandleRcvPkt,
                               (PVOID)(ULONG_PTR)dwIndex,
                               FALSE);
            
            break;
        }
        
        case IPMCAST_DELETE_MFE_MSG:
        {
            QueueAsyncFunction(HandleDeleteMfe,
                               (PVOID)(ULONG_PTR)dwIndex,
                               FALSE);
            
            break;
        }

        case IPMCAST_WRONG_IF_MSG:
        {
            QueueAsyncFunction(HandleWrongIfUpcall,
                               (PVOID)(ULONG_PTR)dwIndex,
                               FALSE);

            break;
        }
        
        default:
        {
            Trace1(MCAST,
                   "HandleMcastNotification: Bad event code %d\n",
                   pMsg->dwEvent);        
            
            PostNotificationForMcastEvents(&(g_rginMcastMsg[dwIndex]),
                                           g_hMcastEvents[dwIndex]);

            break;
        }
    }
        
}


VOID
PostNotificationForMcastEvents(
    PMCAST_OVERLAPPED   pOverlapped,
    HANDLE              hEvent
    )

/*++

Routine Description:


Locks:


Arguments:


Return Value:

    NO_ERROR

--*/

{
    NTSTATUS    nsStatus;

    nsStatus = SendIoctlToMcastDevice(IOCTL_IPMCAST_POST_NOTIFICATION,
                                      hEvent,
                                      &pOverlapped->ioStatus,
                                      &pOverlapped->msg,
                                      sizeof(IPMCAST_NOTIFICATION),
                                      &pOverlapped->msg,
                                      sizeof(IPMCAST_NOTIFICATION));
    
    if((nsStatus isnot STATUS_SUCCESS) and
       (nsStatus isnot STATUS_PENDING))
    {
        Trace1(ERR,
               "PostNotificationForMcastEvents: Error %X",
               nsStatus);
    }
}   


DWORD
SendIoctlToMcastDevice(
    DWORD               dwIoctl,
    HANDLE              hEvent,
    PIO_STATUS_BLOCK    pIoStatus,
    PVOID               pvInBuffer,
    DWORD               dwInBufLen,
    PVOID               pvOutBuffer,
    DWORD               dwOutBufLen
    )
{
    NTSTATUS                        ntStatus;

    ntStatus = NtDeviceIoControlFile(g_hMcastDevice,
                                     hEvent,
                                     NULL,
                                     NULL,
                                     pIoStatus,
                                     dwIoctl,
                                     pvInBuffer,
                                     dwInBufLen,
                                     pvOutBuffer,
                                     dwOutBufLen);

    return ntStatus;
}

DWORD
SetMfe(
    PIPMCAST_MFE    pMfe
    )

/*++

Routine Description:


Locks:


Arguments:


Return Value:

    NO_ERROR

--*/

{
    DWORD           dwResult;
    IO_STATUS_BLOCK ioStatus; 
    
    dwResult = ValidateMfe(pMfe);
    
    if(dwResult isnot NO_ERROR)
    {
        //
        // Something bad happened while validating the MFE
        //

        Trace1(ERR,
               "SetMfe: Error %d validating MFE",
               dwResult);

        return dwResult;
    }

    dwResult = SendIoctlToMcastDevice(IOCTL_IPMCAST_SET_MFE,
                                      NULL,
                                      &ioStatus,
                                      pMfe,
                                      SIZEOF_MFE(pMfe->ulNumOutIf),
                                      NULL,
                                      0);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(MCAST,
               "SetMfe: NtStatus %x while setting MFE",
               dwResult);
    }

    return dwResult;
}

DWORD
GetMfe(
    PIPMCAST_MFE_STATS  pMfeStats
    )
{
    DWORD           dwResult;
    IO_STATUS_BLOCK ioStatus;

    dwResult = SendIoctlToMcastDevice(IOCTL_IPMCAST_GET_MFE,
                                      NULL,
                                      &ioStatus,
                                      pMfeStats,
                                      SIZEOF_MFE_STATS(pMfeStats->ulNumOutIf),
                                      pMfeStats,
                                      SIZEOF_MFE_STATS(pMfeStats->ulNumOutIf));

    if(dwResult isnot NO_ERROR)
    {
        Trace1(MCAST,
               "GetMfe: NtStatus %x while getting MFE",
               dwResult);
    }

    return dwResult;
}


DWORD
DeleteMfe(
    PIPMCAST_DELETE_MFE pDelMfe
    )
{
    DWORD           dwResult;
    IO_STATUS_BLOCK ioStatus;
    
    dwResult = SendIoctlToMcastDevice(IOCTL_IPMCAST_DELETE_MFE,
                                      NULL,
                                      &ioStatus,
                                      pDelMfe,
                                      sizeof(IPMCAST_DELETE_MFE),
                                      NULL,
                                      0);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(MCAST,
               "DeleteMfe: NtStatus %x while deleting MFE",
               dwResult);
    }

    return dwResult;
}

DWORD
ActivateMcastLimits(
    PICB    picb
    )
{
    DWORD           dwResult;
    IO_STATUS_BLOCK ioStatus; 
    IPMCAST_IF_TTL  iitTtl;
    DWORD           dwTtl = picb->dwMcastTtl;

    // Set the TTL threshold

    iitTtl.dwIfIndex = picb->dwIfIndex;
    iitTtl.byTtl     = LOBYTE(LOWORD(dwTtl));
    
    dwResult = SendIoctlToMcastDevice(IOCTL_IPMCAST_SET_TTL,
                                      NULL,
                                      &ioStatus,
                                      &iitTtl,
                                      sizeof(IPMCAST_IF_TTL),
                                      NULL,
                                      0);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "SetMcastTtl: NtStatus %x from SendIoctl when setting TTL for %S",
               dwResult,
               picb->pwszName);

        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Set the rate limit for multicast traffic on an interface.
    // Currently, the kernel does not support rate limiting.
    //

    return NO_ERROR;
}

DWORD
SetMcastLimits(
    PICB   picb,
    DWORD  dwTtl,
    DWORD  dwRateLimit
    )
{
    if (dwTtl > 255)
    {
        Trace2(ERR,
               "SetMcastTtl: TTL for %S is %d which is invalid",
               picb->pwszName,
               dwTtl);

        return ERROR_INVALID_DATA;
    }

    picb->dwMcastTtl = dwTtl;

    //
    // Set the rate limit for multicast traffic on an interface.
    // Currently, the kernel does not support rate limiting, so
    // the only valid value is 0 (=none).
    //

    if (dwRateLimit != 0)
    {
        Trace2(ERR,
               "SetMcastRateLimit: RateLimit for %S is %d which is invalid",
               picb->pwszName,
               dwRateLimit);

        return ERROR_INVALID_DATA;
    }

    picb->dwMcastRateLimit = dwRateLimit;

    if ( picb->dwOperationalState is IF_OPER_STATUS_OPERATIONAL )
    {
        return ActivateMcastLimits(picb);
    }

    return NO_ERROR;
}

DWORD
SetMcastLimitInfo(
    PICB                   picb,
    PRTR_INFO_BLOCK_HEADER pInfoHdr
    )
/*++
Routine Description:
    Sets the TTL and rate limit info associated with an interface.
Arguments:
    picb    The ICB of the interface
Called by:
    AddInterface() in iprtrmgr.c
    SetInterfaceInfo() in iprtrmgr.c
Locks:
    BOUNDARY_TABLE for writing
--*/
{
    DWORD            dwResult = NO_ERROR,
                     i, j;

    PRTR_TOC_ENTRY   pToc;

    PMIB_MCAST_LIMIT_ROW pLimit;

    BOOL             bFound;

    Trace1( MCAST, "ENTERED SetMcastLimitInfo for If %x", picb->dwIfIndex );

    pToc = GetPointerToTocEntry(IP_MCAST_LIMIT_INFO, pInfoHdr);

    if (pToc is NULL) 
    {
       // No TOC means no change
       Trace0( MCAST, "LEFT SetMcastLimitInfo" );
       return NO_ERROR;
    }

    pLimit = (PMIB_MCAST_LIMIT_ROW)GetInfoFromTocEntry(pInfoHdr, pToc);

    if (pLimit is NULL)
    {
        Trace0( MCAST, "LEFT SetMcastLimitInfo" );

        return NO_ERROR;
    }

    dwResult = SetMcastLimits( picb, pLimit->dwTtl, pLimit->dwRateLimit );

    Trace0( MCAST, "LEFT SetMcastLimitInfo" );

    return dwResult;
}

DWORD
SetMcastOnIf(
    PICB    picb,
    BOOL    bActivate
    )
{
    DWORD                       dwResult;
    IO_STATUS_BLOCK             ioStatus;
    IPMCAST_IF_STATE            iisState;

    iisState.dwIfIndex = picb->dwIfIndex;
    iisState.byState   = bActivate?1:0;

    dwResult = SendIoctlToMcastDevice(IOCTL_IPMCAST_SET_IF_STATE,
                                      NULL,
                                      &ioStatus,
                                      &iisState,
                                      sizeof(IPMCAST_IF_STATE),
                                      NULL,
                                      0);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "SetMcastOnIf: NtStatus %x from SendIoctl for %S",
               dwResult,
               picb->pwszName);

        return ERROR_CAN_NOT_COMPLETE;
    }

    return NO_ERROR;
}

DWORD
StartMulticast(
    VOID
    )

/*++

Routine Description:


Locks:


Arguments:


Return Value:

    NO_ERROR

--*/

{
    DWORD           i, dwStart;
    NTSTATUS        nStatus;
    IO_STATUS_BLOCK ioStatus;

    dwStart  = 1;

    nStatus  = SendIoctlToMcastDevice(IOCTL_IPMCAST_START_STOP,
                                      NULL,
                                      &ioStatus,
                                      &dwStart,
                                      sizeof(DWORD),
                                      NULL,
                                      0);

    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace1(MCAST, "StartMulticast: Error %x starting driver",
               nStatus);

        return ERROR_OPEN_FAILED;
    }

    for(i = 0; i < NUM_MCAST_IRPS; i++)
    {
        PostNotificationForMcastEvents(&(g_rginMcastMsg[i]),
                                       g_hMcastEvents[i]);
    }

    // Start up mrinfo and mtrace services
    StartMcMisc();

    return NO_ERROR;
}




DWORD
ValidateMfe(
    IN OUT PIPMCAST_MFE    pMfe
    )

/*++

Routine Description:


Locks:


Arguments:


Return Value:

    NO_ERROR

--*/

{
    PADAPTER_INFO   pBinding;
    ULONG           i;
    
    
    ENTER_READER(BINDING_LIST);

    //
    // First find the interface index for incoming i/f
    // If there are no outgoing interfaces, then this is a NEGATIVE
    // MFE and the incoming interface index must be 0 (and need not
    // be mapped)
    //

#if DBG
    
    if(pMfe->ulNumOutIf is 0)
    {
        IpRtAssert(pMfe->dwInIfIndex is 0);

        pMfe->dwInIfIndex = 0;
    }

#endif

    
    for(i = 0; i < pMfe->ulNumOutIf; i++)
    {
        pBinding = GetInterfaceBinding(pMfe->rgioOutInfo[i].dwOutIfIndex);

        if(!pBinding)
        {
            Trace1(ERR,
                   "ValidateMfe: Unable to find binding for outgoing i/f %d",
                   pMfe->rgioOutInfo[i].dwOutIfIndex);
            
            EXIT_LOCK(BINDING_LIST);

            return ERROR_INVALID_INDEX;
        }
        

        if(pBinding->bBound)
        {
            //
            // valid index
            //

            pMfe->rgioOutInfo[i].dwOutIfIndex = pBinding->dwIfIndex;
        }
        else
        {
            //
            // Demand dial interface
            //

            pMfe->rgioOutInfo[i].dwOutIfIndex = INVALID_IF_INDEX;
            
            pMfe->rgioOutInfo[i].dwDialContext = pBinding->dwSeqNumber;
            
        }
    }

    EXIT_LOCK(BINDING_LIST);
    
    return NO_ERROR;
}

DWORD
GetInterfaceMcastCounters(
    IN   PICB                   picb, 
    OUT  PIP_MCAST_COUNTER_INFO pOutBuffer
    )
{
    DWORD                 dwAdapterId,dwResult;
    PPROTO_CB             pcbOwner;
    IO_STATUS_BLOCK       ioStatus;
    ULONG                 Request = picb->dwIfIndex;
    HANDLE                hEvent;

    dwResult = NO_ERROR;
    
    hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);

    if(hEvent is NULL)
    {
        dwResult = GetLastError();

        Trace1(ERR,
               "GetInterfaceMcastCounters: Error %d creating event",
               dwResult);

        return dwResult;
    }

    dwResult = NtDeviceIoControlFile(g_hIpDevice,
                                     hEvent,
                                     NULL,
                                     NULL,
                                     &ioStatus,
                                     IOCTL_IP_GET_MCAST_COUNTERS,
                                     &Request,
                                     sizeof(Request),
                                     pOutBuffer,
                                     sizeof(IP_MCAST_COUNTER_INFO));

    if(dwResult is STATUS_PENDING)
    {
        Trace0(ERR,
               "GetInterfaceMcastCounters: Pending from ioctl");

        dwResult = WaitForSingleObject(hEvent,
                                       INFINITE);

        if(dwResult isnot WAIT_OBJECT_0) // 0
        {
            Trace1(ERR,
                   "GetInterfaceMcastCounters: Error %d from wait",
                   dwResult);

            dwResult = GetLastError();
        }
        else
        {
            dwResult = STATUS_SUCCESS;
        }
    }

    return dwResult;
}

DWORD 
GetInterfaceMcastStatistics(
    IN   PICB                  picb, 
    OUT  PMIB_IPMCAST_IF_ENTRY pOutBuffer
    )
{
    DWORD                 dwAdapterId,dwResult;
    PPROTO_CB             pcbOwner;
    IO_STATUS_BLOCK       ioStatus;
    IP_MCAST_COUNTER_INFO ifStats;

    dwResult = NO_ERROR;
    
    TraceEnter("GetInterfaceMcastStatistics");

    pOutBuffer->dwIfIndex       = picb->dwIfIndex;
    pOutBuffer->dwTtl           = picb->dwMcastTtl;
    pOutBuffer->dwRateLimit     = 0; // XXX change when we have rate limiting

    dwResult = GetInterfaceMcastCounters(picb, &ifStats);
    if (dwResult isnot STATUS_SUCCESS)
    {
        return dwResult;
    }

    pOutBuffer->ulOutMcastOctets = (ULONG)ifStats.OutMcastOctets; 
    pOutBuffer->ulInMcastOctets  = (ULONG)ifStats.InMcastOctets; 
    pOutBuffer->dwProtocol   = 2; // "local" (static only) is default

    dwResult = MulticastOwner(picb, &pcbOwner, NULL);
    if (dwResult == NO_ERROR && pcbOwner != NULL) {
       switch(pcbOwner->dwProtocolId) {
#ifdef MS_IP_DVMRP
       case MS_IP_DVMRP:  pOutBuffer->dwProtocol = 4; break;
#endif
#ifdef MS_IP_MOSPF
       case MS_IP_MOSPF:  pOutBuffer->dwProtocol = 5; break;
#endif
#ifdef MS_IP_CBT
       case MS_IP_CBT  :  pOutBuffer->dwProtocol = 7; break;
#endif
#ifdef MS_IP_PIMSM
       case MS_IP_PIMSM:  pOutBuffer->dwProtocol = 8; break;
#endif
#ifdef MS_IP_PIMDM
       case MS_IP_PIMDM:  pOutBuffer->dwProtocol = 9; break;
#endif
       case MS_IP_IGMP :  pOutBuffer->dwProtocol = 10; break;
       }
    } 

    TraceLeave("GetInterfaceMcastStatistics");
    return dwResult;
}


DWORD 
SetInterfaceMcastStatistics(
    IN PICB                  picb, 
    IN PMIB_IPMCAST_IF_ENTRY lpInBuffer
    )
{
    DWORD dwResult = NO_ERROR;

    TraceEnter("SetInterfaceMcastStatistics");

    dwResult = SetMcastLimits(picb, lpInBuffer->dwTtl, lpInBuffer->dwRateLimit);

    if(dwResult isnot NO_ERROR) {
        Trace2(ERR,
               "SetInterfaceStatistics: Error %d setting %S",
               dwResult,
               picb->pwszName);
    }

    TraceLeave("SetInterfaceMcastStatistics");
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\mcastif.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\mcastif.h

Abstract:

    Header for mcastif.c

Revision History:

    Gurdeep Singh Pall          6/26/95  Created

--*/

//
// This is the size of buffer used for MGM queries
//

#define MIB_MFE_BUFFER_SIZE     (1 * 1024)

//
// This is the size of buffer used for boundary queries
//

#define MIB_BOUNDARY_BUFFER_SIZE  (1 * 1024)
#define MIB_SCOPE_BUFFER_SIZE     (1 * 1024)

typedef struct MCAST_OVERLAPPED
{
    IO_STATUS_BLOCK         ioStatus;
    IPMCAST_NOTIFICATION    msg;
}MCAST_OVERLAPPED, *PMCAST_OVERLAPPED;

VOID
HandleMcastNotification(
    DWORD   dwIndex
    );

DWORD
SendIoctlToMcastDevice(
    DWORD               dwIoctl,
    HANDLE              hEvent,
    PIO_STATUS_BLOCK    pIoStatus,
    PVOID               pvInBuffer,
    DWORD               dwInBufLen,
    PVOID               pvOutBuffer,
    DWORD               dwOutBufLen
    );

VOID
HandleRcvPkt(
    PVOID   pvContext
    );

VOID
PostNotificationForMcastEvents(
    PMCAST_OVERLAPPED       pOverlapped,
    HANDLE                  hEvent
    );

DWORD
SetMfe(
    PIPMCAST_MFE    pMfe
    );

DWORD
DeleteMfe(
    PIPMCAST_DELETE_MFE pDelMfe
    );

DWORD
GetMfe(
    PIPMCAST_MFE_STATS  pMfeStats
    );

DWORD
ActivateMcastLimits(
    PICB    picb
    );

DWORD
StartMulticast(
    VOID
    );

DWORD
SetMcastOnIf(
    PICB    picb,
    BOOL    bActivate
    );

DWORD
GetInterfaceMcastStatistics(
    PICB                  picb,
    PMIB_IPMCAST_IF_ENTRY pOutBuffer
    );

DWORD
GetInterfaceMcastCounters(
    PICB                   picb,
    PIP_MCAST_COUNTER_INFO pOutBuffer
    );

DWORD
SetInterfaceMcastStatistics(
    PICB                  picb,
    PMIB_IPMCAST_IF_ENTRY lpInBuffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\mcmisc.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\mcmisc.h

Abstract:

    Header file for mrinfo and mtrace-related stuff

Revision History:

    Dave Thaler       20th Apr 1998      Created

--*/

#ifndef __MCMISC_H__
#define __MCMISC_H__

#include <pshpack1.h>

//
// Identify all address variables by IPV4_ADDRESS to make it
// easier to port to IPv6.
//

typedef DWORD IPV4_ADDRESS, *PIPV4_ADDRESS;

typedef struct _IGMP_HEADER
{
    BYTE      byType;
    BYTE      byCode;
    WORD      wXSum;
    DWORD     dwReserved;
} IGMP_HEADER, *PIGMP_HEADER;


#define MIN_IGMP_PACKET_SIZE     sizeof(IGMP_HEADER)

//
// Format of an mrinfo message
//

typedef struct _MRINFO_HEADER
{
    BYTE	byType;
    BYTE	byCode;
    WORD	wChecksum;
    BYTE	byReserved;
    BYTE	byCapabilities;
    BYTE	byMinor;
    BYTE	byMajor;
}MRINFO_HEADER, *PMRINFO_HEADER;

//
// Format of an mtrace header
//

typedef struct _MTRACE_HEADER
{
    BYTE            byType;
    BYTE            byHops;
    WORD            wChecksum;
    IPV4_ADDRESS    dwGroupAddress;
    IPV4_ADDRESS    dwSourceAddress;
    IPV4_ADDRESS    dwDestAddress;
    IPV4_ADDRESS    dwResponseAddress;
    BYTE            byRespTtl;
    BYTE            byQueryID1;
    WORD            wQueryID2;
    
}MTRACE_HEADER, *PMTRACE_HEADER;

//
// Format of a response block inside an mtrace message
//

typedef struct _MTRACE_RESPONSE_BLOCK
{
    DWORD           dwQueryArrivalTime;
    IPV4_ADDRESS    dwIifAddr;
    IPV4_ADDRESS    dwOifAddr;
    IPV4_ADDRESS    dwPrevHopAddr;
    DWORD           dwIifPacketCount;
    DWORD           dwOifPacketCount;
    DWORD           dwSGPacketCount;
    BYTE            byIifProtocol;
    BYTE            byOifThreshold;
    BYTE            bySrcMaskLength;
    BYTE            byStatusCode;
    
}MTRACE_RESPONSE_BLOCK, *PMTRACE_RESPONSE_BLOCK;

#include <poppack.h>

//
// igmp type field
//

#define IGMP_DVMRP           0x13
#define IGMP_MTRACE_RESPONSE 0x1e
#define IGMP_MTRACE_REQUEST  0x1f

//
// dvmrp code field
//

#define DVMRP_ASK_NEIGHBORS2 0x05
#define DVMRP_NEIGHBORS2     0x06

// 
// mrinfo flags field
//

#define MRINFO_TUNNEL_FLAG   0x01
#define MRINFO_DOWN_FLAG     0x10
#define MRINFO_DISABLED_FLAG 0x20
#define MRINFO_QUERIER_FLAG  0x40
#define MRINFO_LEAF_FLAG     0x80

// 
// mrinfo capabilities field
//

#define MRINFO_CAP_LEAF     0x01
#define MRINFO_CAP_PRUNE    0x02
#define MRINFO_CAP_GENID    0x04
#define MRINFO_CAP_MTRACE   0x08
#define MRINFO_CAP_SNMP     0x10


//
// Function prototypes
//

DWORD
McSetMulticastTtl(
    SOCKET s,
    DWORD  dwTtl
    );

DWORD
McSetMulticastIfByIndex(
    SOCKET       s,
    DWORD        dwSockType,
    DWORD        dwIfIndex
    );

DWORD
McSetMulticastIf(
    SOCKET       s,
    IPV4_ADDRESS ipAddr
    );

DWORD
McJoinGroupByIndex(
    SOCKET       s,
    DWORD        dwSockType,
    IPV4_ADDRESS ipGroup,
    DWORD        dwIfIndex  
    );

DWORD
McJoinGroup(
    SOCKET       s,
    IPV4_ADDRESS ipGroup,
    IPV4_ADDRESS ipInterface
    );

DWORD
StartMcMisc(
    VOID
    );

VOID
StopMcMisc(
    VOID
    );

VOID
HandleMrinfoRequest(
    IPV4_ADDRESS dwLocalAddr,
    SOCKADDR_IN *sinDestAddr
    );

VOID
HandleMtraceRequest(
    WSABUF      *pWsabuf
    );

VOID
HandleMcMiscMessages(
    VOID
    );

DWORD
MulticastOwner(
    PICB         picb,      // IN: interface config block
    PPROTO_CB   *pcbOwner,  // OUT: owner
    PPROTO_CB   *pcbQuerier // OUT: IGMP
    );

BYTE
MaskToMaskLen(
    IPV4_ADDRESS dwMask
    );

IPV4_ADDRESS
defaultSourceAddress(
    PICB picb
    );

//
// RAS Server Advertisement constants
//

#define RASADV_GROUP  "239.255.2.2"
#define RASADV_PORT            9753
#define RASADV_PERIOD       3600000  // 1 hour (in milliseconds)
#define RASADV_STARTUP_DELAY      0  // immediately
#define RASADV_TTL               15

DWORD
SetRasAdvEnable(
    BOOL bEnabled
    );

VOID
HandleRasAdvTimer(
    VOID
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\mcmisc.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    mcmisc.c

Abstract:

    This module implements routines associated with mrinfo and mtrace
    functionality.  

Author:

    dthaler@microsoft.com   2-9-98

Revision History:

--*/

#include "allinc.h"
#include <iptypes.h>
#include <dsrole.h>
#pragma hdrstop

//
// Undefine this if we can't bind/set oif by IfIndex.
// This can be turned on if Bug #208359 gets fixed.
//

#define RAW_UNNUMBERED_SUPPORT

#undef UDP_UNNUMBERED_SUPPORT

// Miscellaneous IGMP socket used for mrinfo, mtrace, etc.

SOCKET McMiscSocket = INVALID_SOCKET;

// Miscellaneous UDP socket used for RAS advertisements, etc.
// Note that no event is currently associated with this socket,
// since it's currently only used for sending.

SOCKET g_UDPMiscSocket = INVALID_SOCKET;

//
// Set this to >0 to generate extra logging information
//

DWORD g_mcastDebugLevel = 0;

//
// This is an array mapping an error code in priority order
// (MFE_...) to the actual value which goes in a packet.
//


//
// MFE_NO_ERROR         0x00
// MFE_REACHED_CORE     0x08
// MFE_NOT_FORWARDING   0x07
// MFE_WRONG_IF         0x01
// MFE_PRUNED_UPSTREAM  0x02
// MFE_OIF_PRUNED       0x03
// MFE_BOUNDARY_REACHED 0x04
// MFE_NO_MULTICAST     0x0A
// MFE_IIF              0x09
// MFE_NO_ROUTE         0x05 - set by rtrmgr
// MFE_NOT_LAST_HOP     0x06 - set by rtrmgr
// MFE_OLD_ROUTER       0x82
// MFE_PROHIBITED       0x83
// MFE_NO_SPACE         0x81
//

static int mtraceErrCode[MFE_NO_SPACE+1] =
{
    0x00,
    0x08,
    0x07,
    0x01,
    0x02,
    0x03,
    0x04,
    0x0A,
    0x09,
    0x05,
    0x06,
    0x82,
    0x83,
    0x81
};

DWORD
MulticastOwner(
    PICB         picb,
    PPROTO_CB   *pcbOwner,
    PPROTO_CB   *pcbQuerier
    )


/*++

Routine Description:

    Looks up which protocol instance "owns" a given interface, and which
    is the IGMP querying instance.   

Locks:

    Assumes caller holds read lock on ICB list

Arguments:

    

Return Value:


--*/

{
    PLIST_ENTRY pleNode;
    PPROTO_CB pOwner = NULL,
        pQuerier = NULL;

    if (g_mcastDebugLevel > 0) {
        
        Trace1(MCAST, "MulticastOwner: Looking for owner of %x", picb);
        
        if ( picb->leProtocolList.Flink == &(picb->leProtocolList))
        {
            Trace0(MCAST, "MulticastOwner: Protocol list is empty.");
        }
    }

    for (pleNode = picb->leProtocolList.Flink;
         pleNode isnot &(picb->leProtocolList); 
         pleNode = pleNode->Flink) 
    { 
        PIF_PROTO  pProto;
        
        pProto = CONTAINING_RECORD(pleNode,
                                   IF_PROTO,
                                   leIfProtoLink);
        
        if (!(pProto->pActiveProto->fSupportedFunctionality & RF_MULTICAST)
            //|| pProto->bPromiscuous
            || !(pProto->pActiveProto->pfnGetNeighbors))
        {
            continue;
        }

        if (!pOwner || pOwner->dwProtocolId==MS_IP_IGMP)
        {
            pOwner = pProto->pActiveProto;
        }

        if (pProto->pActiveProto->dwProtocolId==MS_IP_IGMP)
        {
            pQuerier = pProto->pActiveProto;
        }
    }
    
    if (pcbOwner)
    {
        (*pcbOwner) = pOwner;
    }
    
    if (pcbQuerier)
    {
        (*pcbQuerier) = pQuerier;
    }
    
    return NO_ERROR;
}

IPV4_ADDRESS
defaultSourceAddress(
    PICB picb
    )

/*++

Routine Description:

    Look up the default source address for an interface
    For now, we need to special case IP-in-IP since at least
    the local address is available SOMEWHERE, unlike other 
    unnumbered interfaces!

Locks:

    

Arguments:

    

Return Value:


--*/

{
    if (picb->dwNumAddresses > 0)
    {
        //
        // report 1st binding
        //
        
        return picb->pibBindings[0].dwAddress;
    }
    else
    {
#ifdef KSL_IPINIP
        if ((picb->ritType is ROUTER_IF_TYPE_TUNNEL1) && 
            (picb->pIpIpInfo->dwLocalAddress != 0))
        {
            return picb->pIpIpInfo->dwLocalAddress;
        }
        else
        {
            // XXX fill in 0.0.0.0 until this is fixed
            
            return 0;
        }
#endif //KSL_IPINIP
        // XXX fill in 0.0.0.0 until this is fixed
            
        return 0;
    }
}

BOOL
McIsMyAddress(
    IPV4_ADDRESS dwAddr
    )
{
    // XXX test whether dwAddr is bound to any interface.
    // If we return FALSE, then an mtrace with this destination address
    // will be reinjected to be forwarded.

    return FALSE;
}

DWORD
McSetRouterAlert(
    SOCKET       s, 
    BOOL         bEnabled
    )
{
    DWORD   dwErr = NO_ERROR;
    int     StartSnooping = bEnabled;
    int     cbReturnedBytes;
    
    if ( WSAIoctl( s,
                   SIO_ABSORB_RTRALERT,
                   (char *)&StartSnooping, 
                   sizeof(StartSnooping),
                   NULL,
                   0,
                   &cbReturnedBytes,
                   NULL,
                   NULL) ) 
    {
        dwErr = WSAGetLastError();
    }

    return dwErr;
}

DWORD 
StartMcMisc(
    VOID
    )
{
    DWORD           dwErr = NO_ERROR, dwRetval;
    SOCKADDR_IN     saLocalIf;

    Trace1(MCAST,
           "StartMcMisc() initiated with filever=%d",
           VER_PRODUCTBUILD);

    InitializeBoundaryTable();

    do
    {
        //
        // create input socket 
        //
        
        McMiscSocket = WSASocket(AF_INET,
                                 SOCK_RAW,
                                 IPPROTO_IGMP,
                                 NULL,
                                 0,
                                 0);

        if (McMiscSocket == INVALID_SOCKET)
        {
            dwErr = WSAGetLastError();
            
            Trace1(MCAST,
                   "error %d creating mrinfo/mtrace socket",
                   dwErr);
            
            // LogErr1(CREATE_SOCKET_FAILED_2, lpszAddr, dwErr);
            
            break;
        }

        //
        // bind socket to any interface and port 0 (0 => doesnt matter)
        //
        
        saLocalIf.sin_family        = PF_INET;
        saLocalIf.sin_addr.s_addr   = INADDR_ANY;
        saLocalIf.sin_port          = 0;

        //
        // bind the input socket
        //
        
        dwErr = bind(McMiscSocket,
                     (SOCKADDR FAR *)&saLocalIf,
                     sizeof(SOCKADDR));
        
        if (dwErr == SOCKET_ERROR)
        {
            dwErr = WSAGetLastError();
            
            Trace1(MCAST,
                   "error %d binding on mrinfo/mtrace socket",
                   dwErr);
            
            // LogErr1(BIND_FAILED, lpszAddr, dwErr);
            
            break;
        }

        Trace0(MCAST, "StartMcMisc: bind succeeded");

        //
        // to respond to mrinfo, and unicast mtraces, we don't need the 
        // following.
        // To respond to mtrace queries which are multicast
        // (to the group being traced, to ALL-<proto>-ROUTERS, or
        // to ALL-ROUTERS), we do need this.
        //
        

#if 0
#ifdef SIO_RCVALL_HOST
        {
            //
            // put the socket in promiscuous igmp mode.
            // (no need to specify which protocol we want, as it's taken
            //  from the protocol we used in the WSASocket() call above)
            //
            {
                DWORD   dwEnable = 1;
                DWORD   dwNum;
                
                dwRetval = WSAIoctl(McMiscSocket, SIO_RCVALL_HOST, 
                                    (char *)&dwEnable, sizeof(dwEnable), NULL, 0, &dwNum, 
                                    NULL, NULL);
                                    
                if (dwRetval !=0) {
                    // LPSTR lpszAddr = "ANY";
                    dwRetval = WSAGetLastError();
                    Trace1(MCAST, 
                           "error %d setting mrinfo/mtrace socket as host-promiscuous IGMP",
                           dwRetval);
                    // LogErr1(SET_MCAST_IF_FAILED, lpszAddr, dwRetval);

                    // Don't set dwErr in this case, since we can still
                    // respond to unicast queries.
                    break;
                } else { 
                    Trace0(MCAST, "host-promiscuous IGMP enabled on mrinfo/mtrace socket");
                }
            }
        }
#endif
#endif

        // Tell the kernel to hand us IGMP packets with the RouterAlert 
        // option, even if they're not destined to us

        McSetRouterAlert( McMiscSocket, TRUE );

        //
        // Associate an event with the socket
        //
        
        if (WSAEventSelect(McMiscSocket,
                           g_hMcMiscSocketEvent,
                           FD_READ | FD_ADDRESS_LIST_CHANGE) == SOCKET_ERROR)
        {
            Trace1(MCAST, 
                   "StartMcMisc: WSAEventSelect() failed. Error %d",
                   WSAGetLastError());
            
            closesocket(McMiscSocket);
            
            McMiscSocket = INVALID_SOCKET;
            
            continue;
        }
        
    } while(0);

    if (dwErr!=NO_ERROR)
    {
        StopMcMisc();
    }

    return dwErr;
}

VOID 
StopMcMisc(
    VOID
    )
{
    Trace0(MCAST,
           "StopMcMisc() initiated");

    //
    // close input socket
    //
    
    if (McMiscSocket!=INVALID_SOCKET)
    {
        if (closesocket(McMiscSocket) == SOCKET_ERROR) {
            
            Trace1(MCAST,
                   "error %d closing socket",
                   WSAGetLastError());
        }

        McMiscSocket = INVALID_SOCKET;
    }

    Trace0(MCAST, "StopMcMisc() complete");
    
    return;
}

VOID
HandleMcMiscMessages(
    VOID
    )

/*++

Routine Description:

    Accepts mrinfo and mtrace messages and hands them off to the appropriate
    routine.
    Also called to handle address change notification

Locks:

    Acquires the ICB lock as reader if processing Mc messages    

Arguments:

    None 

Return Value:

    None

--*/

{
    DWORD            dwErr, dwNumBytes, dwFlags, dwAddrLen, dwSizeOfHeader;
    DWORD           dwDataLen;
    SOCKADDR_IN        sinFrom;
    PIGMP_HEADER    pIgmpMsg;
    PIP_HEADER      pIpHeader;
    BOOL            bSetIoctl, bUnlock;

    WSANETWORKEVENTS    NetworkEvents;

    bSetIoctl = FALSE;
    bUnlock = FALSE;

    do
    {
        //
        // Figure out if its an address change or read
        //

        dwErr = WSAEnumNetworkEvents(McMiscSocket,
                                     g_hMcMiscSocketEvent,
                                     &NetworkEvents);

        if(dwErr isnot NO_ERROR)
        {
            bSetIoctl = TRUE;

            Trace1(ERR,
                   "HandleMcMiscMessages: Error %d from WSAEnumNetworkEvents",
                   WSAGetLastError());

            break;
        }

        if(NetworkEvents.lNetworkEvents & FD_ADDRESS_LIST_CHANGE)
        {
            bSetIoctl = TRUE;

            dwErr = NetworkEvents.iErrorCode[FD_ADDRESS_LIST_CHANGE_BIT];

           Trace0(GLOBAL,
                  "HandleMcMiscMessages: Received Address change notification");

            if(dwErr isnot NO_ERROR)
            {
                Trace1(ERR,
                       "HandleMcMiscMessages: ErrorCode %d",
                       dwErr);

                break;
            }

            //
            // All's good, handle the binding change
            //

            HandleAddressChangeNotification();

            break;
        }

        ENTER_READER(ICB_LIST);

        bUnlock = TRUE;

        //
        // read the incoming packet
        //
       
        dwAddrLen  = sizeof(sinFrom);
        dwFlags    = 0;

        dwErr = WSARecvFrom(McMiscSocket,
                        &g_wsaMcRcvBuf,
                        1,
                        &dwNumBytes, 
                        &dwFlags,
                        (SOCKADDR FAR *)&sinFrom,
                        &dwAddrLen,
                        NULL,
                        NULL);

        //
        // check if any error in reading packet
        //
        
        if ((dwErr!=0) || (dwNumBytes==0))
        {
            // LPSTR lpszAddr = "ANY";

            dwErr = WSAGetLastError();

            Trace1(MCAST, 
               "HandleMcMiscMessages: Error %d receiving IGMP packet",
               dwErr);

            // LogErr1(RECVFROM_FAILED, lpszAddr, dwErr);

            break;
        }
   
        pIpHeader = (PIP_HEADER)g_wsaMcRcvBuf.buf;
        dwSizeOfHeader = ((pIpHeader->byVerLen)&0x0f)<<2;
        
        pIgmpMsg = (PIGMP_HEADER)(((PBYTE)pIpHeader) + dwSizeOfHeader);
   
        dwDataLen = ntohs(pIpHeader->wLength) - dwSizeOfHeader;
        
        if (g_mcastDebugLevel > 0)
        {
               Trace4(MCAST,
                   "HandleMcMiscMessages: Type is %d (0x%x), code %d (0x%x).",
                   (DWORD)pIgmpMsg->byType,
                   (DWORD)pIgmpMsg->byType,
                   (DWORD)pIgmpMsg->byCode,
                   (DWORD)pIgmpMsg->byCode);
            
               Trace2(MCAST,
                   "HandleMcMiscMessages: IP Length is %d. Header Length  %d",
                   ntohs(pIpHeader->wLength),
                   dwSizeOfHeader);
            
               Trace2(MCAST,
                   "HandleMcMiscMessages: Src: %d.%d.%d.%d dest: %d.%d.%d.%d",
                   PRINT_IPADDR(pIpHeader->dwSrc),
                   PRINT_IPADDR(pIpHeader->dwDest));

            TraceDump(TRACEID,(PBYTE)pIpHeader,dwNumBytes,2,FALSE,NULL);
        }

        //
        // Verify minimum length
        //
        
        if (dwNumBytes < MIN_IGMP_PACKET_SIZE)
        {
            Trace2(MCAST,
               "%d-byte packet from %d.%d.%d.%d is too small",
               dwNumBytes,
               PRINT_IPADDR(pIpHeader->dwSrc));

            break;
        }


        //
        // Check for mal-formed packets that might report bad lengths
        //

        if (dwDataLen > (dwNumBytes - dwSizeOfHeader))
        {
            Trace3(MCAST,
                "%d-byte packet from %d.%d.%d.%d is smaller than "
                "indicated length %d", dwNumBytes, 
                PRINT_IPADDR(pIpHeader->dwSrc),
                dwDataLen);

            break;
        }

        
        //
        // Verify IGMP checksum
        //
        
        if (Compute16BitXSum((PVOID)pIgmpMsg, dwDataLen) != 0)
        {
               Trace4( MCAST,
                    "Wrong IGMP checksum %d-byte packet received from %d.%d.%d.%d, type %d.%d",
                    dwDataLen,
                    PRINT_IPADDR(pIpHeader->dwSrc),
                    pIgmpMsg->byType, pIgmpMsg->byCode );
            
               break;
        }
   
        if (pIgmpMsg->byType is IGMP_DVMRP
            && pIgmpMsg->byCode is DVMRP_ASK_NEIGHBORS2)
        {
               SOCKADDR_IN sinDestAddr;
            
            sinDestAddr.sin_family      = PF_INET;
            sinDestAddr.sin_addr.s_addr = pIpHeader->dwSrc;
            sinDestAddr.sin_port        = 0;
            
               HandleMrinfoRequest((IPV4_ADDRESS)pIpHeader->dwDest, 
                                &sinDestAddr
                               );
            
        }
        else
        {
            if (pIgmpMsg->byType is IGMP_MTRACE_REQUEST)
            {
                HandleMtraceRequest(&g_wsaMcRcvBuf);
            }
        }
        
    } while (FALSE);

    if(bSetIoctl)
    {
        dwErr = WSAIoctl(McMiscSocket,
                         SIO_ADDRESS_LIST_CHANGE,
                         NULL,
                         0,
                         NULL,
                         0,
                         &dwNumBytes,
                         NULL,
                         NULL);

        if(dwErr is SOCKET_ERROR)
        {
            dwErr = WSAGetLastError();

            if((dwErr isnot WSAEWOULDBLOCK) and
               (dwErr isnot WSA_IO_PENDING) and
               (dwErr isnot NO_ERROR))
            {
                Trace1(ERR,
                       "HandleMcMiscMessages: Error %d from SIO_ADDRESS_LIST_CHANGE",
                       dwErr);
            }
        }
    }

    if(bUnlock)
    {
        EXIT_LOCK(ICB_LIST);
    }
}



DWORD
FindBindingWithLocalAddress(
    OUT PICB         *ppicb,
    OUT PIPV4_ADDRESS pdwIfAddress,
    IN  IPV4_ADDRESS  dwAddress
    )
{
    BOOL         bFound = FALSE;
    PLIST_ENTRY  pleNode;
    IPV4_ADDRESS ipFoundMask;
    
    //
    // Lock the ICBList for reading
    //
    
    ENTER_READER(ICB_LIST);

    for (pleNode = ICBList.Flink;
         pleNode isnot &ICBList && !bFound;
         pleNode = pleNode->Flink) 
    {
        DWORD dwIndex;
        PICB  picb;
        
        picb = CONTAINING_RECORD(pleNode,
                                 ICB,
                                 leIfLink);

        for (dwIndex=0;
             dwIndex<picb->dwNumAddresses && !bFound;
             dwIndex++)
        { 
            PICB_BINDING pb = &picb->pibBindings[dwIndex];
            
            if (dwAddress == pb->dwAddress)
            {
                *pdwIfAddress = pb->dwAddress;

                *ppicb = picb;
                
                bFound = TRUE;
            }
        }
    }

    EXIT_LOCK(ICB_LIST);
    
    if (bFound)
    {
        return NO_ERROR;
    }
    
    *ppicb = NULL;
    
    return ERROR_INVALID_PARAMETER;
}

BOOL
IsConnectedTo(
    IN  PICB          picb,
    IN  IPV4_ADDRESS  ipAddress,
    OUT PIPV4_ADDRESS pipLocalAddress   OPTIONAL,
    OUT PIPV4_ADDRESS pipMask           OPTIONAL
    )
{
    DWORD        dwIndex;
    BOOL         bFound = FALSE;
    IPV4_ADDRESS ipFoundMask = 0;

    if (picb->dwRemoteAddress is ipAddress)
    {
        if (pipLocalAddress)
        {
            *pipLocalAddress = defaultSourceAddress(picb);
        }
        if (pipMask)
        {
            *pipMask = ALL_ONES_MASK;
        }
        return TRUE;
    }

    // Find interface with longest match 

    for (dwIndex=0;
         dwIndex<picb->dwNumAddresses && !bFound;
         dwIndex++)
    {
        PICB_BINDING pb = &picb->pibBindings[dwIndex];

        if (((ipAddress & pb->dwMask) is (pb->dwAddress & pb->dwMask))
            && (!bFound || (pb->dwMask > ipFoundMask)))
        {
            if (pipLocalAddress) 
            {
                *pipLocalAddress = pb->dwAddress;
            }

            bFound = TRUE;

            ipFoundMask = pb->dwMask;
        }
    }

    if (pipMask)
    {
        *pipMask = ipFoundMask;
    }

    return bFound;
}

DWORD
FindBindingWithRemoteAddress(
    OUT PICB         *ppicb,
    OUT PIPV4_ADDRESS pdwIfAddress,
    IN  IPV4_ADDRESS  dwAddress
    )
{
    BOOL        bFound = FALSE;
    PLIST_ENTRY pleNode;
    IPV4_ADDRESS ipFoundMask, ipMask, ipLocalAddress;
    
    //
    // Lock the ICBList for reading
    //
    
    ENTER_READER(ICB_LIST);

    for (pleNode = ICBList.Flink;
         pleNode isnot &ICBList;
         pleNode = pleNode->Flink) 
    {
        DWORD dwIndex;
        PICB  picb;
        
        picb = CONTAINING_RECORD(pleNode,
                                 ICB,
                                 leIfLink);

        if (IsConnectedTo(picb, dwAddress, &ipLocalAddress, &ipMask)
         && (!bFound || (ipMask > ipFoundMask)))
        {
            *pdwIfAddress = ipLocalAddress;
            *ppicb        = picb;
            bFound        = TRUE;
            ipFoundMask   = ipMask;
        }
    }

    EXIT_LOCK(ICB_LIST);
    
    if (bFound)
    {
        return NO_ERROR;
    }
    
    *ppicb = NULL;
    
    return ERROR_INVALID_PARAMETER;
}

DWORD
FindBindingForPacket(
    IN  PIP_HEADER    pIpHeader,
    OUT PICB         *ppicb, 
    OUT IPV4_ADDRESS *pdwIfAddr
    )
{
    DWORD dwResult;
    
    dwResult = FindBindingWithRemoteAddress(ppicb,
                                            pdwIfAddr,
                                            pIpHeader->dwSrc);
    
    if (dwResult == NO_ERROR)
    {
        return dwResult;
    }
    
    dwResult = FindBindingWithRemoteAddress(ppicb,
                                            pdwIfAddr,
                                            pIpHeader->dwDest);
    
    return dwResult;
}

VOID
HandleMrinfoRequest(
    IPV4_ADDRESS dwLocalAddr,
    SOCKADDR_IN    *sinDestAddr
    )

/*++

Routine Description:

    Accepts an mrinfo request and sends a reply.    

Locks:

    

Arguments:

    

Return Value:


--*/

{
    DWORD          dwNumBytesSent, dwResult, dwSize = sizeof(MRINFO_HEADER);
    WSABUF         wsMrinfoBuffer;
    MRINFO_HEADER *mriHeader;
    DWORD          dwBufSize;
    IPV4_ADDRESS   dwIfAddr;
    PLIST_ENTRY    pleNode, pleNode2;
    PICB           picb;
    PBYTE          pb;
    BYTE           byIfFlags;
    BOOL           bForMe;

    //
    // If the query was not destined to me, drop it.
    //

    dwResult = FindBindingWithLocalAddress(&picb,
                                           &dwIfAddr, 
                                            dwLocalAddr);

    if (dwResult != NO_ERROR)
    {
        return;
    }

    //
    // Lock the ICBList for reading
    //
    
    ENTER_READER(ICB_LIST);
    
    do 
    {

        //
        // Calculate required size of response packet
        //
        
        for (pleNode = ICBList.Flink;
             pleNode isnot &ICBList; 
             pleNode = pleNode->Flink) 
        {
            PPROTO_CB pOwner, pQuerier;

            picb = CONTAINING_RECORD(pleNode,
                                     ICB,
                                     leIfLink);
            
            dwResult = MulticastOwner(picb,
                                      &pOwner,
                                      &pQuerier);

            //
            // If we didn't find an owner, then we can skip this
            // interface, since we're not doing multicast routing on it.
            //
            
            if (!pOwner)
            {
                continue;
            }
            
            if (picb->dwNumAddresses > 0)
            {
                //
                // add iface size per address
                //
                
                dwSize += 8+4*picb->dwNumAddresses;
            }
            else
            {
                //
                // add single address size for unnumbered iface
                //
                
                dwSize += 12;
            }
  
            //
            // Call the owner's GetNeighbors() entrypoint
            // with a NULL buffer. This will cause it to tell us the size of
            // its neighbor set
            //
            
            dwBufSize = 0;
            byIfFlags = 0;

            //
            // mrouted doesn't report multiple subnets,
            // so neither do we.  Just group all neighbors
            // together on an interface.
            //
            
            dwResult = (pOwner->pfnGetNeighbors)(picb->dwIfIndex,
                                                 NULL,
                                                 &dwBufSize,
                                                 &byIfFlags);

            if ((dwResult isnot NO_ERROR) and
                (dwResult isnot ERROR_INSUFFICIENT_BUFFER))
            {
                //
                // The only errors which will tell us the size needed are
                // NO_ERROR and ERROR_INSUFFICIENT_BUFFER. Anything else
                // means we didn't get the right size
                //
                
                Trace2(MCAST, 
                       "HandleMrinfoRequest: Error %d in GetNeighbours for %S",
                       dwResult,
                       pOwner->pwszDisplayName);
                
                continue;
            }
            
            dwSize += dwBufSize;
        }

        //
        // We can now malloc a buffer and fill in the info
        //
        
        wsMrinfoBuffer.len = dwSize;
        
        wsMrinfoBuffer.buf = HeapAlloc(IPRouterHeap,
                                       0,
                                       dwSize);

        if(wsMrinfoBuffer.buf is NULL)
        {
            EXIT_LOCK(ICB_LIST);

            return;
        }
        
        mriHeader = (PMRINFO_HEADER)wsMrinfoBuffer.buf;
        
        mriHeader->byType         = IGMP_DVMRP;
        mriHeader->byCode         = DVMRP_NEIGHBORS2;
        mriHeader->wChecksum      = 0;
        mriHeader->byReserved     = 0;

        //
        // MRINFO_CAP_MTRACE - set if mtrace handler is available
        // MRINFO_CAP_SNMP   - set if public IP Multicast MIB is available
        // MRINFO_CAP_GENID  - set if DVMRP 3.255 is available
        // MRINFO_CAP_PRUNE  - set if DVMRP 3.255 is available
        //
        
        mriHeader->byCapabilities = MRINFO_CAP_MTRACE | MRINFO_CAP_SNMP;
        mriHeader->byMinor        = VER_PRODUCTBUILD % 100;
        mriHeader->byMajor        = VER_PRODUCTBUILD / 100;

        //
        // Need to get a list of interfaces, and a list of neighbors
        // (and their info) per interface, updating dwSize as we go.
        //
        
        pb = ((PBYTE) wsMrinfoBuffer.buf) + sizeof(MRINFO_HEADER);
        
        for (pleNode = ICBList.Flink;
             pleNode isnot &ICBList; 
             pleNode = pleNode->Flink) 
        {
            PBYTE pbNbrCount, pfIfFlags;
            PPROTO_CB pOwner, pQuerier;

            picb = CONTAINING_RECORD(pleNode,
                                     ICB,
                                     leIfLink);
            
            dwResult = MulticastOwner(picb,
                                      &pOwner,
                                      &pQuerier);

            //
            // If we didn't find an owner, then we can skip this
            // interface, since we're not doing multicast routing on it.
            //
            
            if (!pOwner)
            {
                continue;
            }

            //
            // Fill in interface info
            //
            
            *(PIPV4_ADDRESS)pb = defaultSourceAddress(picb);

            pb += 4;
            *pb++ = 1;                      // currently metric must be 1
            *pb++ = (BYTE)picb->dwMcastTtl; // threshold
            *pb = 0;
#ifdef KSL_IPINIP
            //
            // Right now, we only report IP-in-IP tunnels with the tunnel flag
            // In the future, a tunnel should have its own MIB-II ifType
            // value, which should be stored in the ICB structure so we can
            // get at it.
            //
            
            if (picb->ritType is ROUTER_IF_TYPE_TUNNEL1)
            {
                //
                // neighbor reached via tunnel
                //
                
                *pb |= MRINFO_TUNNEL_FLAG;
            }
#endif //KSL_IPINIP            
            
            if (picb->dwOperationalState < IF_OPER_STATUS_CONNECTED)
            {
                //
                // operational status down
                //
                
                *pb |= MRINFO_DOWN_FLAG;
            }
            
            if (picb->dwAdminState is IF_ADMIN_STATUS_DOWN)
            {
                //
                // administrative status down
                //
                
                *pb |= MRINFO_DISABLED_FLAG;
            }

            pfIfFlags  = pb++; // save pointer for later updating
            pbNbrCount = pb++; // save pointer to neighbor count location
            *pbNbrCount = 0;

            //
            // Call the routing protocol's GetNeighbors() entrypoint
            // with a pointer into the middle of the current packet buffer.
            //
            
            dwBufSize = dwSize - (DWORD)(pb-(PBYTE)wsMrinfoBuffer.buf);
            
            byIfFlags = 0;
            
            dwResult = (pOwner->pfnGetNeighbors)(picb->dwIfIndex,
                                                 (PDWORD)pb,
                                                 &dwBufSize,
                                                 &byIfFlags);
            
            if (dwBufSize>0)
            {
                pb += dwBufSize;
                (*pbNbrCount)+= (BYTE)(dwBufSize / sizeof(DWORD));
                
            }
            else
            {
                //
                // If the protocol has no neighbors, we fill in 0.0.0.0
                // because the mrinfo client most people use
                // won't display the flags, metric, and threshold
                // unless the neighbors count is non-zero.  0.0.0.0
                // is legal according to the spec.
                //
                
                *(PDWORD)pb = 0;
                
                pb += sizeof(DWORD);
                
                (*pbNbrCount)++;
            }

            //
            // set pim/querier/whatever bits
            //
            
            *pfIfFlags |= byIfFlags;

            //
            // Get querier flag
            //
            
            if (pQuerier isnot NULL && pQuerier isnot pOwner)
            {
                byIfFlags = 0;
                dwBufSize = 0;
                
                dwResult = (pQuerier->pfnGetNeighbors)(picb->dwIfIndex,
                                                       NULL,
                                                       &dwBufSize, 
                                                       &byIfFlags);
                
                *pfIfFlags |= byIfFlags;
            }
        }
        
    } while (FALSE);
    
    EXIT_LOCK(ICB_LIST);

    //
    // Fill in Checksum
    //

    mriHeader->wChecksum = Compute16BitXSum(wsMrinfoBuffer.buf,
                                            dwSize);

    if (g_mcastDebugLevel > 0)
    {
        Trace2(MCAST,
               "HandleMrinfoRequest: sending reply to %d.%d.%d.%d. Len %d", 
               PRINT_IPADDR(sinDestAddr->sin_addr.s_addr),
               wsMrinfoBuffer.len);
    }

    //
    // Send it off
    //
    
    if(WSASendTo(McMiscSocket,
                 &wsMrinfoBuffer,
                 1,
                 &dwNumBytesSent,
                 0,
                 (const struct sockaddr *)sinDestAddr,
                 sizeof(SOCKADDR_IN),
                 NULL,
                 NULL) == SOCKET_ERROR) 
    {
        dwResult = WSAGetLastError();
        
        Trace2(MCAST, 
               "HandleMrinfoRequest: Err %d sending reply to %d.%d.%d.%d",
               dwResult,
               PRINT_IPADDR(sinDestAddr->sin_addr.s_addr));
    }

    //
    // Free the buffer
    //
    
    HeapFree(IPRouterHeap,
             0,
             wsMrinfoBuffer.buf);
}



//
// This function is derived from NTTimeToNTPTime() in 
// src\sockets\tcpcmd\iphlpapi\mscapis.cxx
//

DWORD
GetCurrentNTP32Time(
    VOID
    )


/*++

Routine Description:

   Get current 32-bit NTP timestamp.  The 32-bit form of an NTP timestamp
   consists of the middle 32 bits of the full 64-bit form; that is, the low
   16 bits of the integer part and the high 16 bits of the fractional part.    

Locks:

    

Arguments:

    

Return Value:


--*/

{
    static LARGE_INTEGER li1900 = {0xfde04000, 0x14f373b};
    LARGE_INTEGER liTime;
    DWORD  dwMs;
    ULONG  hi, lo;

    GetSystemTimeAsFileTime((LPFILETIME)&liTime);

    //
    // Seconds is simply the time difference
    //
    
    hi = htonl((ULONG)((liTime.QuadPart - li1900.QuadPart) / 10000000));

    //
    // Ms is the residue from the seconds calculation.
    //
    
    dwMs = (DWORD)(((liTime.QuadPart - li1900.QuadPart) % 10000000) / 10000);

    //
    // time base in the beginning of the year 1900
    //
    
    lo = htonl((unsigned long)(.5+0xFFFFFFFF*(double)(dwMs/1000.0)));

    return (hi << 16) | (lo >> 16);
}

IPV4_ADDRESS
IfIndexToIpAddress(
    DWORD dwIfIndex
    )
{
    // Locate picb
    PICB picb = InterfaceLookupByIfIndex(dwIfIndex);

    return (picb)? defaultSourceAddress(picb) : 0;
}

DWORD
McSetMulticastIfByIndex(
    SOCKET       s, 
    DWORD        dwSockType,
    DWORD        dwIfIndex
    )
{
    DWORD        dwNum, dwErr;
    IPV4_ADDRESS ipAddr;

#ifdef RAW_UNNUMBERED_SUPPORT
    if ((dwSockType is SOCK_RAW)
#ifdef UDP_UNNUMBERED_SUPPORT
     || (dwSockType is SOCK_DGRAM)
#endif 
       )
    {
        dwErr = WSAIoctl( s,
                          SIO_INDEX_MCASTIF,
                          (char*)&dwIfIndex,
                          sizeof(dwIfIndex),
                          NULL,
                          0,
                          &dwNum,
                          NULL,
                          NULL );
    
        return dwErr;
    }
#endif

    //
    // If we can't set oif to an ifIndex yet, then we
    // attempt to map it to some IP address
    //

    ipAddr = IfIndexToIpAddress(dwIfIndex);

    if (!ipAddr)
        return ERROR_INVALID_PARAMETER;

    return McSetMulticastIf( s, ipAddr );
}



DWORD
McSetMulticastIf( 
    SOCKET       s, 
    IPV4_ADDRESS ipAddr
    )
{
    SOCKADDR_IN saSrcAddr;

    saSrcAddr.sin_family      = AF_INET;
    saSrcAddr.sin_port        = 0;
    saSrcAddr.sin_addr.s_addr = ipAddr;
    
    return setsockopt( s,
                       IPPROTO_IP,
                       IP_MULTICAST_IF,
                       (char *)&saSrcAddr.sin_addr,
                       sizeof(IN_ADDR) );
}

DWORD
McSetMulticastTtl( 
    SOCKET  s, 
    DWORD   dwTtl 
    )
{
    return setsockopt( s,
                       IPPROTO_IP,
                       IP_MULTICAST_TTL,
                       (char *)&dwTtl,
                       sizeof(dwTtl) );
}

DWORD
McJoinGroupByIndex(
    IN SOCKET       s,
    IN DWORD        dwSockType,
    IN IPV4_ADDRESS ipGroup, 
    IN DWORD        dwIfIndex  
    )
{
    struct ip_mreq imOption;
    IPV4_ADDRESS   ipInterface;

#ifdef RAW_UNNUMBERED_SUPPORT
    if ((dwSockType is SOCK_RAW)
#ifdef UDP_UNNUMBERED_SUPPORT
     || (dwSockType is SOCK_DGRAM)
#endif
       )
    {
        DWORD dwNum, dwErr;

        imOption.imr_multiaddr.s_addr = ipGroup;
        imOption.imr_interface.s_addr = dwIfIndex;
    
        dwErr = WSAIoctl( s,
                          SIO_INDEX_ADD_MCAST,
                          (char*)&imOption,
                          sizeof(imOption),
                          NULL,
                          0,
                          &dwNum,
                          NULL,
                          NULL );
    
        return dwErr;
    }
#endif

    ipInterface = IfIndexToIpAddress(ntohl(dwIfIndex));

    if (!ipInterface)
    {
        Trace1(MCAST, "McJoinGroup: bad IfIndex 0x%x", ntohl(ipInterface));

        return ERROR_INVALID_PARAMETER;
    }

    return McJoinGroup( s, ipGroup, ipInterface );
}

DWORD
McJoinGroup(
    IN SOCKET       s,
    IN IPV4_ADDRESS ipGroup, 
    IN IPV4_ADDRESS ipInterface
    )
/*++
Description:
    Joins a group on a given interface.
Called by:
Locks:
    None
--*/
{
    struct ip_mreq imOption;

    imOption.imr_multiaddr.s_addr = ipGroup;
    imOption.imr_interface.s_addr = ipInterface;

    return setsockopt( s, 
                       IPPROTO_IP, 
                       IP_ADD_MEMBERSHIP, 
                       (PBYTE)&imOption, 
                       sizeof(imOption));
}

DWORD
McSendPacketTo( 
    SOCKET                      s,
    WSABUF                     *pWsabuf,
    IPV4_ADDRESS                dest
    )
{
    DWORD       dwSent, dwRet;
    int         iSetIp = 1;
    SOCKADDR_IN to;

    // Set header include

    setsockopt( s,
                IPPROTO_IP,
                IP_HDRINCL,
                (char *) &iSetIp,
                sizeof(int) );

    // Send the packet

    to.sin_family      = AF_INET;
    to.sin_port        = 0;
    to.sin_addr.s_addr = dest;

    dwRet = WSASendTo( s, 
                       pWsabuf, 
                       1, 
                       &dwSent, 
                       0, 
                       (const struct sockaddr FAR *)&to, 
                       sizeof(to), 
                       NULL, NULL );

    // Clear header include

    iSetIp = 0;
    setsockopt( s,
                IPPROTO_IP,
                IP_HDRINCL,
                (char *) &iSetIp,
                sizeof(int) );

    return dwRet;
}

DWORD
ForwardMtraceRequest(
    IPV4_ADDRESS   dwForwardDest,
    IPV4_ADDRESS   dwForwardSrc,
    PMTRACE_HEADER pMtraceMsg,
    DWORD          dwMessageLength
    )

/*++

Routine Description:

    Pass an mtrace request to the next router upstream

Locks:

    

Arguments:

    

Return Value:


--*/

{
    SOCKADDR_IN saDestAddr;
    INT         iLength;
    DWORD       dwErr = NO_ERROR;

    //
    // Recalculate Checksum
    //
    
    pMtraceMsg->wChecksum = 0;
    
    pMtraceMsg->wChecksum = Compute16BitXSum((PVOID)pMtraceMsg,
                                             dwMessageLength);

    if (dwForwardSrc && IN_MULTICAST(ntohl(dwForwardDest)))
    {
        dwErr = McSetMulticastIf( McMiscSocket, dwForwardSrc );

    }

    //
    // Send it off
    //
    
    saDestAddr.sin_family      = AF_INET;
    saDestAddr.sin_port        = 0;
    saDestAddr.sin_addr.s_addr = dwForwardDest;
    
    iLength = sendto(McMiscSocket,
                     (PBYTE)pMtraceMsg,
                     dwMessageLength,
                     0,
                     (PSOCKADDR) &saDestAddr,
                     sizeof(SOCKADDR_IN));

    return dwErr;
}

VOID
SendMtraceResponse(
    IPV4_ADDRESS   dwForwardDest,
    IPV4_ADDRESS   dwForwardSrc,
    PMTRACE_HEADER pMtraceMsg,
    DWORD          dwMessageLength
    )

/*++

Routine Description:

    Send a reply to the response address

Locks:

    

Arguments:

    

Return Value:


--*/

{
    SOCKADDR_IN saDestAddr;
    INT         iLength;

    //
    // Source Address can be any of our addresses, but should
    // be one which is in the multicast routing table if that
    // can be determined.
    // XXX
    //

    //
    // If the response address is multicast, use the TTL supplied in the header
    //
    
    if (IN_MULTICAST(ntohl(dwForwardDest)))
    {
        DWORD dwTtl, dwErr;
        
        //
        // Copy Response TTL from traceroute header into IP header
        //

        dwErr = McSetMulticastTtl( McMiscSocket, (DWORD)pMtraceMsg->byRespTtl );
    }

    //
    // Change message type to response
    //
    
    pMtraceMsg->byType = IGMP_MTRACE_RESPONSE;

    ForwardMtraceRequest(dwForwardDest,
                         dwForwardSrc,
                         pMtraceMsg,
                         dwMessageLength);
}

BYTE
MaskToMaskLen(
    IPV4_ADDRESS dwMask
    )
{
    register int i;

    dwMask = ntohl(dwMask);
    
    for (i=0; i<32 && !(dwMask & (1<<i)); i++);
    
    return 32-i;
}

//
// Test whether an interface is a p2p interface.
//

DWORD
IsPointToPoint(
    PICB  picb
    )
{
#ifdef KSL_IPINIP
    // all tunnels are p2p
    if (picb->ritType == ROUTER_IF_TYPE_TUNNEL1)
        return 1;
#endif //KSL_IPINIP

    // all unnumbered interfaces are p2p
    if (! picb->dwNumAddresses)
        return 1;

    // a numbered interface with a /32 mask is p2p
    if (picb->pibBindings[0].dwMask == 0xFFFFFFFF)
        return 1;

    // everything else isn't
    return 0;
}

//
// Look up route to S or G ***in the M-RIB*** 
// XXX We actually need to query the MGM to get the right route
// from the routing protocol.  Since the MGM doesn't let us do
// this yet, we'll make a good guess for now.  This will work for 
// BGMP but not for PIM-SM (*,G) or CBT.
//
BOOL
McLookupRoute( 
    IN  IPV4_ADDRESS  ipAddress,
    IN  BOOL          bSkipFirst,
    OUT PBYTE         pbySrcMaskLength,
    OUT PIPV4_ADDRESS pipNextHopAddress, 
    OUT PDWORD        pdwNextHopIfIndex,
    OUT PDWORD        pdwNextHopProtocol 
    )
#ifdef HAVE_RTMV2
{
    RTM_DEST_INFO       rdi, rdi2;
    PRTM_ROUTE_INFO     pri;
    RTM_NEXTHOP_INFO    nhi;
    RTM_ENTITY_INFO     rei;
    RTM_NET_ADDRESS     naAddress;
    BOOL                bRouteFound = FALSE;
    DWORD               dwErr;

    pri = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                );

    if (pri == NULL)
    {
        return FALSE;
    }
            
    RTM_IPV4_MAKE_NET_ADDRESS(&naAddress, ipAddress, 32);

    dwErr = RtmGetMostSpecificDestination( g_hLocalRoute,
                                           &naAddress,
                                           RTM_BEST_PROTOCOL,
                                           RTM_VIEW_MASK_MCAST,
                                           &rdi );

    if (bSkipFirst)
    {
        dwErr = RtmGetLessSpecificDestination( g_hLocalRoute,
                                               rdi.DestHandle,
                                               RTM_BEST_PROTOCOL,
                                               RTM_VIEW_MASK_MCAST,
                                               &rdi2 );

        RtmReleaseDestInfo( g_hLocalRoute, &rdi);

        memcpy(&rdi, &rdi2, sizeof(rdi));
    }

    if (dwErr is NO_ERROR)
    {
        ASSERT( rdi.ViewInfo[0].ViewId is RTM_VIEW_ID_MCAST);

        dwErr = RtmGetRouteInfo( g_hLocalRoute,
                                 rdi.ViewInfo[0].Route,
                                 pri,
                                 NULL );

        if (dwErr is NO_ERROR)
        {
            ULONG ulNHopIdx;
            ULONG ulDummyLen;

            bRouteFound = TRUE;

            RtmGetEntityInfo( g_hLocalRoute,
                              pri->RouteOwner,
                              &rei );

            // XXX Use 1st next hop for now.  Should query MGM.
            ulNHopIdx = 0;
            
            if (RtmGetNextHopInfo( g_hLocalRoute,
                                   pri->NextHopsList.NextHops[ulNHopIdx],
                                   &nhi ) is NO_ERROR )
            {
                RTM_IPV4_GET_ADDR_AND_LEN( *pipNextHopAddress, 
                                           ulDummyLen, 
                                           &nhi.NextHopAddress );
                *pbySrcMaskLength  = (BYTE)rdi.DestAddress.NumBits;
                *pdwNextHopIfIndex = nhi.InterfaceIndex;
                *pdwNextHopProtocol= PROTO_FROM_PROTO_ID( 
                                      rei.EntityId.EntityProtocolId );

                RtmReleaseNextHopInfo( g_hLocalRoute, &nhi );
            }

            RtmReleaseRouteInfo( g_hLocalRoute, pri );
        }
            
        if (g_mcastDebugLevel > 0)
        {
            Trace6(MCAST,
                   "%d.%d.%d.%d matched %d.%d.%d.%d/%x", 
                   PRINT_IPADDR(ipAddress),
                   rdi.DestAddress.AddrBits[0],
                   rdi.DestAddress.AddrBits[1],
                   rdi.DestAddress.AddrBits[2],
                   rdi.DestAddress.AddrBits[3],
                   rdi.DestAddress.NumBits);

            // XXX Get and show next hop
        }

        RtmReleaseDestInfo( g_hLocalRoute, &rdi);
    }

    HeapFree(IPRouterHeap, 0, pri);
    
    return bRouteFound;
}
#else 
{
    // RTMV1 has no multicast RIB, and the unicast RIB may be wrong.

    return FALSE;
}
#endif

VOID
HandleMtraceRequest(
    WSABUF    *pWsabuf
    )
/*++
Locks:
    Assumes caller holds read lock on ICB list
--*/
{
    DWORD   dwSizeOfHeader, dwBlocks, dwOutBufferSize, dwSize;
    DWORD   dwProtocolGroup, dwResult, dwErr;
    IPV4_ADDRESS dwForwardDest = 0;
    BYTE    byStatusCode = MFE_NO_ERROR;
    BYTE    byProtoStatusCode = MFE_NO_ERROR;
    BYTE    byProtocol;
    PICB    picbIif, picbOif;
    IPV4_ADDRESS dwIifAddr, dwOifAddr;
    WSABUF  wsMtraceBuffer;
    BOOL    bRouteFound;

    MIB_IPMCAST_MFE     mimInMfe;
    PPROTO_CB           pOifOwner, pIifOwner;

    PMTRACE_HEADER              pMtraceMsg;
    PMTRACE_RESPONSE_BLOCK      pBlock;
    PMIB_IPMCAST_MFE_STATS      mfeStats;

    PIP_HEADER pIpHeader = (PIP_HEADER)pWsabuf->buf;

    //
    // Route fields independent of which version of RTM we're using
    //

    BYTE         bySrcMaskLength  = 0;
    IPV4_ADDRESS ipNextHopAddress = 0;
    DWORD        dwNextHopIfIndex = 0;
    DWORD        dwNextHopProtocol= 0;

    dwSizeOfHeader = ((pIpHeader->byVerLen)&0x0f)<<2;
    
    pMtraceMsg = (PMTRACE_HEADER)(((PBYTE)pIpHeader) + dwSizeOfHeader);
    
    dwBlocks = (ntohs(pIpHeader->wLength) - dwSizeOfHeader 
                - sizeof(MTRACE_HEADER)) / sizeof(MTRACE_RESPONSE_BLOCK);

    //
    // If Query (no response blocks) received via routeralert and we're 
    // not lasthop router, then silently drop it.
    //
    
    if (!dwBlocks)
    {
        BOOL isLastHop;

        //
        // Check whether we're the last-hop router by seeing if we
        // have a multicast-capable interface on the same subnet as
        // the destination address, and we are the router that would
        // forward traffic from the given source onto the oif.
        //
        
        dwResult = FindBindingWithRemoteAddress(&picbOif,
                                                &dwOifAddr, 
                                                pMtraceMsg->dwDestAddress);
        
        isLastHop = (dwResult == NO_ERROR);

        if (!isLastHop)
        {
            // If multicast, or if unicast but not to us, reinject

            if (IN_MULTICAST(ntohl(pIpHeader->dwDest))
             || !McIsMyAddress(pMtraceMsg->dwDestAddress))
            {
                Trace1(MCAST, "Mtrace: reinjecting packet to %d.%d.%d.%d",
                       PRINT_IPADDR(pIpHeader->dwDest));

                McSendPacketTo( McMiscSocket,
                                pWsabuf,
                                pMtraceMsg->dwDestAddress);

                return;
            }

            //
            // Ok, this was received via unicast to us, and we want to
            // trace starting from this router, but we don't
            // know what oif would be used, so we need to put
            // 0 in the message.
            //
            
            picbOif   = NULL;
            dwOifAddr = 0;

            //
            // note error code of 0x06
            //
            
            byStatusCode = MFE_NOT_LAST_HOP;
        }
    }
    else
    {
        //
        // If Request (response blocks exist) received via non-link-local 
        // multicast, drop it.
        //
        
        if (IN_MULTICAST(ntohl(pIpHeader->dwDest)) &&
            ((pIpHeader->dwDest & LOCAL_NET_MULTICAST_MASK) != LOCAL_NET_MULTICAST))
        {
            return;
        }
        
        //
        // Match interface on which request arrived
        //
        
        dwResult = FindBindingForPacket(pIpHeader,
                                        &picbOif,
                                        &dwOifAddr);
        
        if(dwResult != NO_ERROR)
        {
            //
            // Drop it if we couldn't find the interface.
            // Since it was received via link-local multicast,
            // this should never happen.
            //
            
            if (g_mcastDebugLevel > 0)
            {
                Trace0(MCAST, "Mtrace: no matching interface");
            }
            
            return; 
        }
    }

    //
    // 1) Insert a new response block into the packet and fill in the
    //    Query Arrival Time, Outgoing Interface Address, Output
    //    Packet Count, and FwdTTL.
    // if (XXX can insert)
    //
    
    {
        dwSize = sizeof(MTRACE_HEADER) + dwBlocks*sizeof(MTRACE_RESPONSE_BLOCK);
        wsMtraceBuffer.len = dwSize + sizeof(MTRACE_RESPONSE_BLOCK);
        wsMtraceBuffer.buf = HeapAlloc(IPRouterHeap, 0, wsMtraceBuffer.len);

        if (wsMtraceBuffer.buf == NULL)
        {
            Trace0( MCAST, "Couldn't allocate memory for mtrace response" );
            return;
        }

        CopyMemory(wsMtraceBuffer.buf, pMtraceMsg, dwSize);
        pBlock = (PMTRACE_RESPONSE_BLOCK)(((PBYTE)wsMtraceBuffer.buf) + dwSize);
        dwBlocks++;
        ZeroMemory(pBlock, sizeof(MTRACE_RESPONSE_BLOCK));

        pBlock->dwQueryArrivalTime = GetCurrentNTP32Time();
        pBlock->dwOifAddr          = dwOifAddr;
        if (picbOif) {
            IP_MCAST_COUNTER_INFO oifStats;
            GetInterfaceMcastCounters(picbOif, &oifStats);
            pBlock->dwOifPacketCount = htonl((ULONG)oifStats.OutMcastPkts);

            if (g_mcastDebugLevel > 0)
                Trace1(MCAST, "dwOifPacketCount = %d", oifStats.OutMcastPkts);

            pBlock->byOifThreshold   = (BYTE)picbOif->dwMcastTtl;
        } else {
            pBlock->dwOifPacketCount = 0;
            pBlock->byOifThreshold   = 0;
        }
    }
    // else {
    //    byStatusCode = MFE_NO_SPACE;
    // }

    //
    // 2) Attempt to determine the forwarding information for the
    //    source and group specified, using the same mechanisms as
    //    would be used when a packet is received from the source
    //    destined for the group.  (State need not be initiated.)
    //
    
    ZeroMemory( &mimInMfe, sizeof(mimInMfe) );
    
    mimInMfe.dwGroup   = pMtraceMsg->dwGroupAddress;
    mimInMfe.dwSource  = pMtraceMsg->dwSourceAddress;
    mimInMfe.dwSrcMask = 0xFFFFFFFF;
    
    dwOutBufferSize = 0;
    
    dwResult = MgmGetMfeStats(
                    &mimInMfe, &dwOutBufferSize, (PBYTE)NULL, 
                    MGM_MFE_STATS_0
                    );

    if (dwResult isnot NO_ERROR)
    {
        mfeStats = NULL; 
    }
    else
    {
        mfeStats = HeapAlloc(IPRouterHeap,
                             0,
                             dwOutBufferSize);
        
        dwResult = MgmGetMfeStats(
                        &mimInMfe,
                        &dwOutBufferSize,
                        (PBYTE)mfeStats,
                        MGM_MFE_STATS_0
                        );
    
        if (dwResult isnot NO_ERROR)
        {
            HeapFree(IPRouterHeap,
                     0,
                     mfeStats);

            mfeStats = NULL;
        }
    }
    
    if (mfeStats)
    {
        //
        // MFE was found...
        //

        dwNextHopProtocol  = mfeStats->dwRouteProtocol;
        dwNextHopIfIndex   = mfeStats->dwInIfIndex;
        ipNextHopAddress   = mfeStats->dwUpStrmNgbr;
        bySrcMaskLength    = MaskToMaskLen(mfeStats->dwRouteMask);

        bRouteFound = TRUE;
    }
    else
    {
        bRouteFound = FALSE;

        if (pMtraceMsg->dwSourceAddress == 0xFFFFFFFF)
        {
            //
            // G route
            //
            
            bRouteFound = McLookupRoute( pMtraceMsg->dwGroupAddress,
                                         FALSE,
                                         & bySrcMaskLength,
                                         & ipNextHopAddress, 
                                         & dwNextHopIfIndex,
                                         & dwNextHopProtocol );
    
            if (ipNextHopAddress is IP_LOOPBACK_ADDRESS)
            {
                // It's one of our addresses, so switch to the interface
                // route instead of the loopback one.

                bRouteFound = McLookupRoute( pMtraceMsg->dwGroupAddress,
                                             TRUE,
                                             & bySrcMaskLength,
                                             & ipNextHopAddress, 
                                             & dwNextHopIfIndex,
                                             & dwNextHopProtocol );
            }

            bySrcMaskLength = 0; // force source mask length to 0
        }
        else
        {
            //
            // S route
            //
            
            bRouteFound = McLookupRoute( pMtraceMsg->dwSourceAddress,
                                         FALSE,
                                         & bySrcMaskLength,
                                         & ipNextHopAddress, 
                                         & dwNextHopIfIndex,
                                         & dwNextHopProtocol );

            if (ipNextHopAddress is IP_LOOPBACK_ADDRESS)
            {
                // It's one of our addresses, so switch to the interface
                // route instead of the loopback one.
    
                bRouteFound = McLookupRoute( pMtraceMsg->dwSourceAddress,
                                             TRUE,
                                             & bySrcMaskLength,
                                             & ipNextHopAddress, 
                                             & dwNextHopIfIndex,
                                             & dwNextHopProtocol );
            }
        }
    }

    picbIif   = (dwNextHopIfIndex)? InterfaceLookupByIfIndex(dwNextHopIfIndex) : 0;
    dwIifAddr = (picbIif)? defaultSourceAddress(picbIif) : 0;

    // If the source is directly-connected, make sure the next hop
    // address is equal to the source.  Later on below, we'll set the 
    // forward destination to the response address

    if (picbIif 
     && (pMtraceMsg->dwSourceAddress isnot 0xFFFFFFFF)
     && IsConnectedTo(picbIif, pMtraceMsg->dwSourceAddress, NULL, NULL))
    {
        ipNextHopAddress = pMtraceMsg->dwSourceAddress;
    }

    // 
    // New Rule: if received via link-local multicast, then silently
    // drop requests if we know we're not the forwarder
    //

    if ((pIpHeader->dwDest & LOCAL_NET_MULTICAST_MASK) == LOCAL_NET_MULTICAST)

    {
        // If we don't have a route to another iface, we're not forwarder
        if (!picbIif || picbIif==picbOif)
        {
            return;
        }
    }

    //
    // Special case: if we matched a host route pointing back to us,
    // then we've actually reached the source.
    //
    
    if (dwIifAddr == IP_LOOPBACK_ADDRESS)
    {
        dwIifAddr = pMtraceMsg->dwSourceAddress;
    }

    //
    // Initialize all fields
    // spec doesn't say what value to use as "other"
    //
    
    byProtocol      = 0; 
    dwProtocolGroup = ALL_ROUTERS_MULTICAST_GROUP;

    //
    // 3) If no forwarding information can be determined, set error
    //    to MFE_NO_ROUTE, zero remaining fields, and forward to
    //    requester.
    //
    
    if (!picbIif)
    {
        if (byStatusCode < MFE_NO_ROUTE)
        {
            byStatusCode = MFE_NO_ROUTE;
        }
        
        dwForwardDest = pMtraceMsg->dwResponseAddress;
        
        pIifOwner = NULL;
        
    }
    else
    {
        //
        // Calculate Mtrace protocol ID and next hop group address
        // (Yes, the protocol ID field in the spec really is one big
        // hairy mess)
        //
        
        dwResult = MulticastOwner(picbIif,
                                  &pIifOwner,
                                  NULL);
        
        if(pIifOwner)
        {
            switch(PROTO_FROM_PROTO_ID(pIifOwner->dwProtocolId))
            {
                //
                // Fill this in for every new protocol added.
                //
                // We'll be nice and fill in code for protocols which aren't
                // implemented yet.
                //

#if defined(PROTO_IP_DVMRP) && defined(ALL_DVMRP_ROUTERS_MULTICAST_GROUP)
                case PROTO_IP_DVMRP:
                {
                    if (rir.RR_RoutingProtocol is PROTO_IP_LOCAL)
                    {
                        //
                        // Static route
                        //
                        
                        byProtocol   = 7;
                    }
                    else
                    {
                        //
                        // Non-static route
                        //
                        
                        byProtocol   = 1;
                    }
                    
                    dwProtocolGroup = ALL_DVMRP_ROUTERS_MULTICAST_GROUP;
                    
                    break;
                }
#endif
#if defined(PROTO_IP_MOSPF) && defined(ALL_MOSPF_ROUTERS_MULTICAST_GROUP)
                case PROTO_IP_MOSPF:
                {
                    byProtocol      = 2;
                    
                    dwProtocolGroup = ALL_MOSPF_ROUTERS_MULTICAST_GROUP;
                    
                    break;
                }
#endif
#if defined(PROTO_IP_PIM) && defined(ALL_PIM_ROUTERS_MULTICAST_GROUP)
                case PROTO_IP_PIM:
                {
                    if (rir.RR_RoutingProtocol is PROTO_IP_LOCAL)
                    {
                        //
                        // Static route
                        //
                        
                        byProtocol   = 6;
                    }
                    else
                    {
                        if (0)
                        {
                            //
                            // XXX Non-static, M-RIB route!=U-RIB route
                            //
                            
                            byProtocol   = 5;
                        }
                        else
                        {
                            //
                            // Non-static, PIM over M-RIB==U-RIB
                            //
                            
                            byProtocol   = 3;
                        }
                    }
                    
                    dwProtocolGroup = ALL_PIM_ROUTERS_MULTICAST_GROUP;
                    
                    break;
                }
#endif
#if defined(PROTO_IP_CBT) && defined(ALL_CBT_ROUTERS_MULTICAST_GROUP)
                case PROTO_IP_CBT:
                {
                    byProtocol      = 4;
                    
                    dwProtocolGroup = ALL_CBT_ROUTERS_MULTICAST_GROUP;
                    
                    break;
                }
#endif
                    
            }
        }

        //
        // 4) Fill in more information
        //

        //
        // Incoming Interface Address
        //
        
        pBlock->dwIifAddr = dwIifAddr;
        
        if (mfeStats)
        {
            //
            // Figure out Previous-Hop Router Address
            //
            
            dwForwardDest = mfeStats->dwUpStrmNgbr;
        }
        else
        {
            if ( IsPointToPoint(picbIif) && picbIif->dwRemoteAddress )
            {
                dwForwardDest = picbIif->dwRemoteAddress;
            }
            else if (bRouteFound && ipNextHopAddress)
            {
                dwForwardDest = ipNextHopAddress;
            }
            else
            {
                dwForwardDest = 0;
            }
        }
        
        pBlock->dwPrevHopAddr = dwForwardDest;

        // Okay, if the previous hop address is the source,
        // set the forward destination to the response address 

        if (dwForwardDest is pMtraceMsg->dwSourceAddress)
        {
            ipNextHopAddress = 0;
            dwForwardDest    = pMtraceMsg->dwResponseAddress;
        }
         
        if (picbIif)
        {
            IP_MCAST_COUNTER_INFO iifStats;
            
            GetInterfaceMcastCounters(picbIif, &iifStats); 
            
            pBlock->dwIifPacketCount = htonl((ULONG)iifStats.InMcastPkts);
        }
        else
        {
            pBlock->dwIifPacketCount = 0;
        }

        //
        // Total Number of Packets
        //
        
        pBlock->dwSGPacketCount  = (mfeStats)? htonl(mfeStats->ulInPkts) : 0; 
        pBlock->byIifProtocol    = byProtocol; // Routing Protocol

        //
        // length of source mask for S route
        //

        if (bRouteFound)
        {
            pBlock->bySrcMaskLength = bySrcMaskLength;
        }
        else
        {
            pBlock->bySrcMaskLength = 0;
        }

#if 0
        if (XXX starG or better forwarding state)
        {
            pBlock->bySrcMaskLength = 63; // Smask from forwarding info
        }

        //
        // Set S bit (64) if packet counts aren't (S,G)-specific
        //
        
        if (XXX)
        {
            pBlock->bySrcMaskLength |= 64;
        }
        
#endif

    }

    //
    // 5) Check if traceroute is administratively prohibited, or if
    //    previous hop router doesn't understand traceroute.  If so,
    //    forward to requester.
    //
    
#if 0
    if (XXX) {
        
        if (byStatusCode < MFE_PROHIBITED)
        {
            byStatusCode = MFE_PROHIBITED;
        }
        
        dwForwardDest = pMtraceMsg->dwResponseAddress;
    }
    
#endif

    //
    //    Check for MFE_OLD_ROUTER - set by routing protocol
    //
    // 6) If reception iface is non-multicast or iif, set appropriate error.
    //
    
    if (picbOif)
    {
        dwResult = MulticastOwner(picbOif,
                                  &pOifOwner,
                                  NULL);
        
        if (pOifOwner == NULL)
        {
            if (byStatusCode < MFE_NO_MULTICAST)
            {
                byStatusCode = MFE_NO_MULTICAST;
            }
            
        }
        else
        {
            if (picbOif == picbIif)
            {
                if (byStatusCode < MFE_IIF)
                {
                    byStatusCode = MFE_IIF;
                }
            }
        }
    }
    else
    {
        pOifOwner = NULL;
    }

    //
    // Check for MFE_WRONG_IF - set by routing protocol
    //
    // 7) Check for admin scoping on either iif or oif.
    //
    
    if ((picbIif 
         && RmHasBoundary(picbIif->dwIfIndex, pMtraceMsg->dwGroupAddress)) 
     || (picbOif 
         && RmHasBoundary(picbOif->dwIfIndex, pMtraceMsg->dwGroupAddress)))
    {
        if (byStatusCode < MFE_BOUNDARY_REACHED)
        {
            byStatusCode = MFE_BOUNDARY_REACHED;
        }
        
    }

    //
    // 8) Check for MFE_REACHED_CORE - set by routing protocol
    // 9) Check for MFE_PRUNED_UPSTREAM - set by routing protocol
    //    Check for MFE_OIF_PRUNED - set by routing protocol
    //    Check for MFE_NOT_FORWARDING:
    //       Search for picbOif->(index) and picbOifAddr in oiflist
    //
    
    if (mfeStats && picbOif)
    {
        DWORD oifIndex;
        
        for (oifIndex=0;
             oifIndex < mfeStats->ulNumOutIf;
             oifIndex++)
        {
            if (picbOif->dwIfIndex==mfeStats->rgmiosOutStats[oifIndex].dwOutIfIndex 
                && dwOifAddr == mfeStats->rgmiosOutStats[oifIndex].dwNextHopAddr)
            {
                break;
            }
        }
        
        if (oifIndex >= mfeStats->ulNumOutIf)
        {
            if (byStatusCode < MFE_NOT_FORWARDING)
            {
                byStatusCode = MFE_NOT_FORWARDING;
            }
        }
    }
    
    //
    // status code to add is highest value of what iif owner, oif owner,
    // and rtrmgr say.
    //
    
    if (pOifOwner && pOifOwner->pfnGetMfeStatus)
    {
        dwResult = (pOifOwner->pfnGetMfeStatus)(picbOif->dwIfIndex,
                                                pMtraceMsg->dwGroupAddress,
                                                pMtraceMsg->dwSourceAddress,
                                                &byProtoStatusCode);
        
        if (byStatusCode < byProtoStatusCode)
        {
            byStatusCode = byProtoStatusCode;
        }
    }
    
    if (pIifOwner && pIifOwner->pfnGetMfeStatus)
    {
        dwResult = (pIifOwner->pfnGetMfeStatus)(picbIif->dwIfIndex,
                                                pMtraceMsg->dwGroupAddress,
                                                pMtraceMsg->dwSourceAddress,
                                                &byProtoStatusCode);
        
        if (byStatusCode < byProtoStatusCode)
        {
            byStatusCode = byProtoStatusCode;
        }
    }
    
    pBlock->byStatusCode = (char)mtraceErrCode[byStatusCode];

    Trace5( MCAST,
            "Mtrace: err %d blks %d maxhops %d iif %d prevhop %d.%d.%d.%d",
            pBlock->byStatusCode,
            dwBlocks,
            pMtraceMsg->byHops,
            ((picbIif)? picbIif->dwIfIndex : 0),
            PRINT_IPADDR(pBlock->dwPrevHopAddr));

    //
    // 10) Send packet on to previous hop or to requester.
    //     If prev hop is not known, but iif is known, use a multicast group.
    //
    
    if (dwBlocks == pMtraceMsg->byHops)
    {
        dwForwardDest = pMtraceMsg->dwResponseAddress;
        
    }
    else
    {
        if (!dwForwardDest)
        {
            if (picbIif)
            {
                pBlock->dwPrevHopAddr = dwForwardDest = dwProtocolGroup;
                
            }
            else
            {
                dwForwardDest = pMtraceMsg->dwResponseAddress;
            }
        }   
    }

    if (g_mcastDebugLevel > 0) {
        Trace1(MCAST, " QueryArrivalTime = %08x", pBlock->dwQueryArrivalTime);
        Trace2(MCAST, " IifAddr          = %08x (%d.%d.%d.%d)", pBlock->dwIifAddr,
         PRINT_IPADDR(pBlock->dwIifAddr));
        Trace2(MCAST, " OifAddr          = %08x (%d.%d.%d.%d)", pBlock->dwOifAddr,
         PRINT_IPADDR(pBlock->dwOifAddr));
        Trace2(MCAST, " PrevHopAddr      = %08x (%d.%d.%d.%d)", pBlock->dwPrevHopAddr,
         PRINT_IPADDR(pBlock->dwPrevHopAddr));
        Trace1(MCAST, " IifPacketCount   = %08x", pBlock->dwIifPacketCount  );
        Trace1(MCAST, " OifPacketCount   = %08x", pBlock->dwOifPacketCount  );
        Trace1(MCAST, " SGPacketCount    = %08x", pBlock->dwSGPacketCount  );
        Trace1(MCAST, " IifProtocol      = %02x", pBlock->byIifProtocol  );
        Trace1(MCAST, " OifThreshold     = %02x", pBlock->byOifThreshold );
        Trace1(MCAST, " SrcMaskLength    = %02x", pBlock->bySrcMaskLength );
        Trace1(MCAST, " StatusCode       = %02x", pBlock->byStatusCode    );
    }
    
    if (dwForwardDest is pMtraceMsg->dwResponseAddress)
    {
        Trace2(MCAST,
               "Sending mtrace response to %d.%d.%d.%d from %d.%d.%d.%d",
               PRINT_IPADDR(dwForwardDest),
               PRINT_IPADDR(dwOifAddr));

        SendMtraceResponse(dwForwardDest,
                           dwOifAddr,
                           (PMTRACE_HEADER)wsMtraceBuffer.buf, 
                           dwSize + sizeof(MTRACE_RESPONSE_BLOCK));
        
    }
    else
    {
        Trace2(MCAST,
               "Forwarding mtrace request to %d.%d.%d.%d from %d.%d.%d.%d",
               PRINT_IPADDR(dwForwardDest),
               PRINT_IPADDR(dwIifAddr));

        ForwardMtraceRequest(dwForwardDest,
                             dwIifAddr,
                             (PMTRACE_HEADER)wsMtraceBuffer.buf,
                             dwSize + sizeof(MTRACE_RESPONSE_BLOCK));
    }

    //
    // Free the buffers
    //
    
    if (mfeStats)
    {
        HeapFree(IPRouterHeap,
                 0,
                 mfeStats);
    }
    
    HeapFree(IPRouterHeap,
             0,
             wsMtraceBuffer.buf);
}


///////////////////////////////////////////////////////////////////////////////
// Functions to deal with RAS Server advertisements
///////////////////////////////////////////////////////////////////////////////

static BOOL g_bRasAdvEnabled = FALSE;

DWORD
SetRasAdvEnable(
    BOOL bEnabled
    )
{
    LARGE_INTEGER liExpiryTime;
    DWORD         dwErr = NO_ERROR;

    if (bEnabled == g_bRasAdvEnabled)
        return dwErr;

    g_bRasAdvEnabled = bEnabled;

    if (bEnabled) 
    {
        //
        // create input socket 
        //
            
        g_UDPMiscSocket = WSASocket(AF_INET,
                                    SOCK_DGRAM,
                                    0,
                                    NULL,
                                    0,
                                    0);

        // Start timer
        liExpiryTime = RtlConvertUlongToLargeInteger(RASADV_STARTUP_DELAY);
        if (!SetWaitableTimer( g_hRasAdvTimer,
                               &liExpiryTime,
                               RASADV_PERIOD,
                               NULL,
                               NULL,
                               FALSE))
        {
            dwErr = GetLastError();

            Trace1(ERR,
                   "SetRasAdvEnable: Error %d setting waitable timer",
                   dwErr);
        }
    }
    else
    {
        // Stop timer
        dwErr = CancelWaitableTimer( g_hRasAdvTimer );
    }

    return dwErr;
}

VOID
HandleRasAdvTimer()
{
    BYTE        bHostName[MAX_HOSTNAME_LEN];
    BYTE        bMessage[MAX_HOSTNAME_LEN + (DNS_MAX_NAME_LENGTH + 2) + 128]; 
    //
    // bMessage is required to hold hostname, the DomanNameDns, and the extra 
    // 128 bytes are kept to store the other misc text that is copied to the 
    // message
    //
    BYTE        *p;
    SOCKADDR_IN sinAddr, srcAddr;
    PICB        picb = NULL;
    PLIST_ENTRY pleNode;
    DWORD       dwErr;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pGlobalDomainInfo = NULL;

    if (!g_bRasAdvEnabled)
        return;

    // Compose message
    gethostname(bHostName, sizeof(bHostName));
    sprintf(bMessage, "Hostname=%s\n", bHostName);
    p = bMessage + strlen(bMessage);

    // Get the name of the domain this machine is a member of
    dwErr = DsRoleGetPrimaryDomainInformation( 
                NULL,
                DsRolePrimaryDomainInfoBasic,
                (LPBYTE *) &pGlobalDomainInfo );

    if ((dwErr is NO_ERROR) and 
        (pGlobalDomainInfo->DomainNameDns isnot NULL))
    {
        int rc;
        char *pType;
        char buff[DNS_MAX_NAME_LENGTH+2];

        rc = WideCharToMultiByte( CP_ACP,
                             0,
                             pGlobalDomainInfo->DomainNameDns,
                             wcslen(pGlobalDomainInfo->DomainNameDns)+1,
                             buff,
                             sizeof(buff),
                             NULL,
                             NULL );

        if (pGlobalDomainInfo->MachineRole is DsRole_RoleStandaloneWorkstation
         or pGlobalDomainInfo->MachineRole is DsRole_RoleStandaloneServer)
            pType = "Workgroup";
        else
            pType = "Domain";
 
        if ( rc ) {
            sprintf(p, "%s=%s\n", pType, buff);
        }
        
        // Trace1(MCAST, "Sending !%s!", bMessage);
    }
        
    sinAddr.sin_family      = AF_INET;
    sinAddr.sin_port        = htons(RASADV_PORT);
    sinAddr.sin_addr.s_addr = inet_addr(RASADV_GROUP);

    dwErr = McSetMulticastTtl( g_UDPMiscSocket, RASADV_TTL );

    // Find a dedicated interface (if any)
    ENTER_READER(ICB_LIST);
    {
        for (pleNode = ICBList.Flink;
             pleNode isnot &ICBList;
             pleNode = pleNode->Flink) 
        {
            DWORD dwIndex;
            
            picb = CONTAINING_RECORD(pleNode,
                                     ICB,
                                     leIfLink);

            if (! picb->bBound)
                continue;
    
            if (picb->ritType == ROUTER_IF_TYPE_DEDICATED)
            {
                dwErr = McSetMulticastIfByIndex( g_UDPMiscSocket,
                                                 SOCK_DGRAM,
                                                 picb->dwIfIndex );

                // Send a Ras Adv message
        
                sendto(g_UDPMiscSocket, bMessage, strlen(bMessage)+1, 0,
                 (struct sockaddr *)&sinAddr, sizeof(sinAddr));

                // If multicast forwarding is enabled, then
                // a single send will get forwarded out all
                // interfaces, so we can stop after the first send

                if (McMiscSocket != INVALID_SOCKET)
                    break;
            }
        }
    }
    EXIT_LOCK(ICB_LIST);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\mhrtbt.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    net\routing\ip\rtrmgr\mhrtbt.c

Abstract:

    Multicast heartbeat

Revision History:

    Amritansh Raghav  

--*/

#include "allinc.h"

HANDLE g_hMHbeatSocketEvent;

DWORD
SetMHeartbeatInfo(
    IN PICB                      picb,
    IN PRTR_INFO_BLOCK_HEADER    pInfoHdr
    )

/*++

Routine Description

    Sets multicast heartbeat information passed to the ICB. 

Locks

    Must be called with ICB_LIST lock held as WRITER

Arguments

    picb        The ICB of the interface for whom the multicast hearbeat
                related variables have to be set
    pInfoHdr    Interface Info header

Return Value

    None

--*/

{
    PMCAST_HBEAT_INFO   pInfo;
    PRTR_TOC_ENTRY      pToc;
    DWORD               dwResult;
    PMCAST_HBEAT_CB     pHbeatCb;    
    
    TraceEnter("SetMHeartbeatInfo");
    
    pHbeatCb = &picb->mhcHeartbeatInfo;

    pToc = GetPointerToTocEntry(IP_MCAST_HEARBEAT_INFO,
                                pInfoHdr);
        
    if(!pToc)
    {
        //
        // Leave things as they are
        //

        TraceLeave("SetMHeartbeatInfo");
        
        return NO_ERROR;
    }

    pInfo = (PMCAST_HBEAT_INFO)GetInfoFromTocEntry(pInfoHdr,
                                                   pToc);

        
    if((pToc->InfoSize is 0) or (pInfo is NULL))
    {
        //
        // If the size is zero, stop detecting
        //
        
        DeActivateMHeartbeat(picb);

        //
        // Also, blow away any old info
        //

        ZeroMemory(pHbeatCb,
                   sizeof(MCAST_HBEAT_CB));

        //
        // Set the socket to invalid
        //
        
        pHbeatCb->sHbeatSocket = INVALID_SOCKET;
        
        return NO_ERROR;
    }

    //
    // Set the info present. We dont care if resolution is in progress
    // because it will find that the name has changed or that detection has
    // been deactivated and will not do anything
    //
    
    //
    // If the address protocol or port changes deactivate the heartbeat
    //
    
    if((pInfo->bActive is FALSE) or
       (wcsncmp(pInfo->pwszGroup,
                pHbeatCb->pwszGroup,
                MAX_GROUP_LEN) isnot 0) or
       (pInfo->byProtocol isnot pHbeatCb->byProtocol) or
       (pInfo->wPort isnot pHbeatCb->wPort))
    {
        DeActivateMHeartbeat(picb);
    }

    //
    // Copy out the info
    //

    wcsncpy(pHbeatCb->pwszGroup,
            pInfo->pwszGroup,
            MAX_GROUP_LEN);

    pHbeatCb->pwszGroup[MAX_GROUP_LEN - 1] = UNICODE_NULL;

    pHbeatCb->wPort           = pInfo->wPort;
    pHbeatCb->byProtocol      = pInfo->byProtocol;
    pHbeatCb->ullDeadInterval = 
        (ULONGLONG)(60 * SYS_UNITS_IN_1_SEC * pInfo->ulDeadInterval);
    
    //
    // Leave the group and socket as they are
    //

    //
    // If the info says that detection should be on, but the i/f is not
    // detecting, either it is being switched on or it was deactivated due
    // to a info change and needs to be on
    //

    dwResult = NO_ERROR;
    
    if((pHbeatCb->bActive is FALSE) and
       (pInfo->bActive is TRUE))                              
    {
        pHbeatCb->bActive = TRUE;
        
        dwResult = ActivateMHeartbeat(picb);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "SetMHeartbeatInfo: Error %d activating hbeat for  %S",
                   GetLastError(),
                   picb->pwszName);
        
            ZeroMemory(pHbeatCb,
                       sizeof(MCAST_HBEAT_CB));
        }
    }

    TraceLeave("SetMHeartbeatInfo");

    return dwResult;
}

DWORD
GetMHeartbeatInfo(
    PICB                    picb,
    PRTR_TOC_ENTRY          pToc,
    PBYTE                   pbDataPtr,
    PRTR_INFO_BLOCK_HEADER  pInfoHdr,
    PDWORD                  pdwSize
    )

/*++

Routine Description

    Gets the multicast hearbeat info related to the interface

Locks

    Called with ICB_LIST lock held as READER

Arguments

    picb        The ICB of the interface whose multicast heartbeat information
                is being retrieved
    pToc        Pointer to TOC for router discovery info
    pbDataPtr   Pointer to start of data buffer
    pInfoHdr    Pointer to the header of the whole info
    pdwSize     [IN]  Size of data buffer
                [OUT] Size of buffer consumed

Return Value
  
--*/

{
    PMCAST_HBEAT_INFO   pInfo;
    PMCAST_HBEAT_CB     pHbeatCb;
    
    TraceEnter("GetMHeartbeatInfo");
    
    if(*pdwSize < sizeof(MCAST_HBEAT_INFO))
    {
        *pdwSize = sizeof(MCAST_HBEAT_INFO);

        TraceLeave("GetMHeartbeatInfo");
    
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    *pdwSize = pToc->InfoSize = sizeof(MCAST_HBEAT_INFO);

    //pToc->InfoVersion IP_MCAST_HEARBEAT_INFO;
    pToc->InfoType  = IP_MCAST_HEARBEAT_INFO;
    pToc->Count     = 1;
    pToc->Offset    = (ULONG)(pbDataPtr - (PBYTE) pInfoHdr);
    
    pInfo = (PMCAST_HBEAT_INFO)pbDataPtr;

    pHbeatCb = &picb->mhcHeartbeatInfo;
    
    wcsncpy(pHbeatCb->pwszGroup,
            pInfo->pwszGroup,
            MAX_GROUP_LEN);

    pHbeatCb->pwszGroup[MAX_GROUP_LEN - 1] = UNICODE_NULL;

    
    pInfo->bActive          = pHbeatCb->bActive;
    pInfo->byProtocol       = pHbeatCb->byProtocol;
    pInfo->wPort            = pHbeatCb->wPort;
    pInfo->ulDeadInterval   = 
        (ULONG)(pHbeatCb->ullDeadInterval/(60 * SYS_UNITS_IN_1_SEC));

    
    TraceLeave("GetMHeartbeatInfo");
    
    return NO_ERROR;
}
    
    
DWORD
ActivateMHeartbeat(
    PICB    picb
    )

/*++

Routine Description

    Function to activate heartbeat detection. If there is no info or the
    detection is configured to be inactive, we quit. We try to get the
    group address. If a name is given we queue a worker to resolve the
    group name, otherwise we start detection

Locks

    ICB_LIST lock held as WRITER

Arguments

    picb    ICB of the interface to activate

Return Value


--*/

{
    PMCAST_HBEAT_CB     pHbeatCb;    
    CHAR                pszGroup[MAX_GROUP_LEN];
    PHEARTBEAT_CONTEXT  pContext;
    DWORD               dwResult;


    TraceEnter("ActivateMHeartbeat");
    
    pHbeatCb = &picb->mhcHeartbeatInfo;

    if((pHbeatCb->bActive is FALSE) or
       (pHbeatCb->bResolutionInProgress is TRUE))
    {
        return NO_ERROR;
    }
    
    //
    // Convert to ansi
    //
    
    WideCharToMultiByte(CP_ACP,
                        0,
                        pHbeatCb->pwszGroup,
                        -1,
                        pszGroup,
                        MAX_GROUP_LEN,
                        NULL,
                        NULL);
    
    pHbeatCb->dwGroup = inet_addr((CONST CHAR *)pszGroup);

    if(pHbeatCb->dwGroup is INADDR_NONE)
    {
        //
        // we need to resolve the name. This will be done in a
        // worker function. Create a context for the function and
        // queue it
        //

        pContext = HeapAlloc(IPRouterHeap,
                             0,
                             sizeof(HEARTBEAT_CONTEXT));

        if(pContext is NULL)
        {
            Trace2(ERR,
                   "SetMHeartbeatInfo: Error %d allocating context for %S",
                   GetLastError(),
                   picb->pwszName);
            

            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        pContext->dwIfIndex = picb->dwIfIndex;
        pContext->picb      = picb;

        
        CopyMemory(&pContext->pwszGroup,
                   pHbeatCb->pwszGroup,
                   sizeof(MAX_GROUP_LEN));
        
        dwResult = QueueAsyncFunction(ResolveHbeatName,
                                      pContext,
                                      FALSE);
        
        if(dwResult isnot NO_ERROR)
        {
            HeapFree(IPRouterHeap,
                     0,
                     pContext);
            
            Trace2(ERR,
                   "SetMHeartbeatInfo: Error %d queuing worker for %S",
                   GetLastError(),
                   picb->pwszName);

            return dwResult;
        }
            
        pHbeatCb->bResolutionInProgress = TRUE;

        return NO_ERROR;
    }
    
    //
    // No need to do name resultion. Just start
    //

    dwResult = StartMHeartbeat(picb);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "SetMHeartbeatInfo: Error %d starting hbeat for %S",
               dwResult,
               picb->pwszName);

    }

    return dwResult;
}

DWORD
StartMHeartbeat(    
    IN PICB  picb
    )

/*++

Routine Description

    Activates router discovery messages on an interface. The interface must 
    already be bound. 

Locks

    Called with the ICB_LIST lock held as WRITER
     
Arguments

    picb          The ICB of the interface to activate

Return Value

    NO_ERROR or some error code 

--*/

{    
    PMCAST_HBEAT_CB    pHbeatCb;
    DWORD              dwResult;

    TraceEnter("ActivateMHeartbeat");

    if((picb->dwAdminState isnot IF_ADMIN_STATUS_UP) or
       (picb->dwOperationalState < IF_OPER_STATUS_CONNECTING))
    {
        TraceLeave("ActivateMHeartbeat");
    
        return NO_ERROR;
    }
    
    pHbeatCb = &picb->mhcHeartbeatInfo;
    
    dwResult = CreateHbeatSocket(picb);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "ActivateMHeartbeat: Couldnt create socket for %S. Error %d",
               picb->pwszName,
               dwResult);

        TraceLeave("ActivateMHeartbeat");
    
        return dwResult;
    }

    //
    // Yes we are active
    //

    pHbeatCb->bActive = TRUE;

    TraceLeave("ActivateMHeartbeat");
    
    return NO_ERROR;
}



DWORD
CreateHbeatSocket(
    IN PICB picb
    )

/*++

Routine Description

    Creates a socket to listen to multicast hearbeat messages

Locks

    ICB_LIST lock must be held as WRITER

Arguments

    picb    The ICB of the interface for which the socket has to be created

Return Value

    NO_ERROR or some error code 

--*/

{
    PMCAST_HBEAT_CB  pHbeatCb;
    DWORD            i, dwResult, dwBytesReturned;
    struct linger    lingerOption;
    BOOL             bOption, bLoopback;
    SOCKADDR_IN      sinSockAddr;
    struct ip_mreq   imOption;
    
    TraceEnter("CreateHbeatSocket");
    
    if(picb->bBound)
    {
        Trace1(ERR,
               "CreateHbeatSocket: Can not activate heartbeat on %S as it is not bound",
               picb->pwszName);

        TraceLeave("CreateHbeatSocket");
        
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    //
    // Create the sockets for the interface
    //
    
    pHbeatCb = &(picb->mhcHeartbeatInfo);
    
    
    pHbeatCb->sHbeatSocket = INVALID_SOCKET;


    if(pHbeatCb->byProtocol is IPPROTO_RAW)
    {
        //
        // If we are raw proto, then the port number contains protocol
        //
        
        pHbeatCb->sHbeatSocket = WSASocket(AF_INET,
                                           SOCK_RAW,
                                           LOBYTE(pHbeatCb->wPort),
                                           NULL,
                                           0,
                                           MHBEAT_SOCKET_FLAGS);
    }
    else
    {
        IpRtAssert(pHbeatCb->byProtocol is IPPROTO_UDP);

        pHbeatCb->sHbeatSocket = WSASocket(AF_INET,
                                           SOCK_DGRAM,
                                           IPPROTO_UDP,
                                           NULL,
                                           0,
                                           MHBEAT_SOCKET_FLAGS);
        
    }
    
    if(pHbeatCb->sHbeatSocket is INVALID_SOCKET)
    {
        dwResult = WSAGetLastError();
        
        Trace2(ERR,
               "CreateHbeatSocket: Couldnt create socket on %S. Error %d",
               picb->pwszName,
               dwResult);
        
        TraceLeave("CreateHbeatSocket");
        
        return dwResult;
    }

#if 0
    
    //
    // Set to SO_DONTLINGER
    //
    
    bOption = TRUE;
    
    if(setsockopt(pHbeatCb->sHbeatSocket,
                  SOL_SOCKET,
                  SO_DONTLINGER,   
                  (const char FAR*)&bOption,
                  sizeof(BOOL)) is SOCKET_ERROR)
    {
        Trace1(ERR,
               "CreateHbeatSocket: Couldnt set linger option - continuing. Error %d",
               WSAGetLastError());
    }
    
#endif
        
    //
    // Set to SO_REUSEADDR
    //
    
    bOption = TRUE;
    
    if(setsockopt(pHbeatCb->sHbeatSocket,
                  SOL_SOCKET,
                  SO_REUSEADDR,
                  (const char FAR*)&bOption,
                  sizeof(BOOL)) is SOCKET_ERROR)
    {
        Trace1(ERR,
               "CreateHbeatSocket: Couldnt set reuse option - continuing. Error %d",
               WSAGetLastError());
    }

    //
    // we are interested in READ events only and want the event to be set
    // for those
    //
    
    if(WSAEventSelect(pHbeatCb->sHbeatSocket,
                      g_hMHbeatSocketEvent,
                      FD_READ) is SOCKET_ERROR)
    {
        dwResult = WSAGetLastError();
        
        Trace2(ERR,
               "CreateHbeatSocket: WSAEventSelect() failed for socket on %S.Error %d",
               picb->pwszName,
               dwResult);
        
        closesocket(pHbeatCb->sHbeatSocket);
        
        pHbeatCb->sHbeatSocket = INVALID_SOCKET;
        
        return dwResult;
    }
            

    //
    // Bind to one of the addresses on the interface. We just bind to the
    // first address (and the port if specified)
    //
    
    sinSockAddr.sin_family      = AF_INET;
    sinSockAddr.sin_addr.s_addr = picb->pibBindings[0].dwAddress;

    if(pHbeatCb->byProtocol is IPPROTO_UDP)
    {
        sinSockAddr.sin_port = pHbeatCb->wPort;
    }
    else
    {
        sinSockAddr.sin_port = 0;
    }
    
    if(bind(pHbeatCb->sHbeatSocket,
            (const struct sockaddr FAR*)&sinSockAddr,
            sizeof(SOCKADDR_IN)) is SOCKET_ERROR)
    {   
        dwResult = WSAGetLastError();
        
        Trace3(ERR,
               "CreateHbeatSocket: Couldnt bind to %s on interface %S. Error %d",
               inet_ntoa(*(PIN_ADDR)&(picb->pibBindings[0].dwAddress)),
               picb->pwszName,
               dwResult);
            
        closesocket(pHbeatCb->sHbeatSocket);
        
        pHbeatCb->sHbeatSocket = INVALID_SOCKET;
        
        return dwResult;
        
    }


#if 0
        
    //
    // Join the multicast session 
    //
    
    sinSockAddr.sin_family      = AF_INET;
    sinSockAddr.sin_addr.s_addr = pHbeatCb->dwGroup;
    sinSockAddr.sin_port        = 0;

    if(WSAJoinLeaf(pHbeatCb->sHbeatSocket,
                   (const struct sockaddr FAR*)&sinSockAddr,
                   sizeof(SOCKADDR_IN),
                   NULL,
                   NULL,
                   NULL,
                   NULL,
                   JL_BOTH) is INVALID_SOCKET)
    {
        dwResult = WSAGetLastError();
        
        Trace2(ERR,
               "CreateHbeatSocket: Couldnt join multicast group over %s on %S",
               inet_ntoa(*(PIN_ADDR)&(picb->pibBindings[i].dwAddress)),
               picb->pwszName);
            
        closesocket(pHbeatCb->sHbeatSocket);
        
        pHbeatCb->sHbeatSocket = INVALID_SOCKET;
        
        return dwResult;
    }

#else
    
    sinSockAddr.sin_addr.s_addr = picb->pibBindings[0].dwAddress;
    
    if(setsockopt(pHbeatCb->sHbeatSocket,
                  IPPROTO_IP, 
                  IP_MULTICAST_IF,
                  (PBYTE)&sinSockAddr.sin_addr, 
                  sizeof(IN_ADDR)) is SOCKET_ERROR)
    {
        dwResult = WSAGetLastError();
        
        Trace2(ERR,
               "CreateHbeatSocket: Couldnt enable mcast over %s on %S",
               inet_ntoa(*(PIN_ADDR)&(picb->pibBindings[0].dwAddress)),
               picb->pwszName);
            
        closesocket(pHbeatCb->sHbeatSocket);
        
        pHbeatCb->sHbeatSocket = INVALID_SOCKET;
        
        return dwResult;
    }

    imOption.imr_multiaddr.s_addr = pHbeatCb->dwGroup;
    imOption.imr_interface.s_addr = picb->pibBindings[0].dwAddress;

    if(setsockopt(pHbeatCb->sHbeatSocket,
                  IPPROTO_IP,
                  IP_ADD_MEMBERSHIP,
                  (PBYTE)&imOption,
                  sizeof(imOption)) is SOCKET_ERROR)
    {
        dwResult = WSAGetLastError();
        
        Trace3(ERR,
               "CreateHbeatSocket: Couldnt join %d.%d.%d.%d on socket over %s on %S",
               PRINT_IPADDR(pHbeatCb->dwGroup),
               inet_ntoa(*(PIN_ADDR)&(picb->pibBindings[0].dwAddress)),
               picb->pwszName);
        
        closesocket(pHbeatCb->sHbeatSocket);
        
        pHbeatCb->sHbeatSocket = INVALID_SOCKET;
        
        return dwResult;
    }

#endif
    
    TraceLeave("CreateHbeatSocket");
        
    return NO_ERROR;
}

VOID
DeleteHbeatSocket(
    IN PICB picb
    )

/*++

Routine Description

    Deletes the sockets (if any) created for running Router Discovery

Locks


Arguments
    
    picb   The interface whose sockets need to be deleted

Return Value

--*/

{
    PMCAST_HBEAT_CB     pHbeatCb;
    DWORD               i;

    
    pHbeatCb = &(picb->mhcHeartbeatInfo);

    if(pHbeatCb->sHbeatSocket isnot INVALID_SOCKET)
    {
        closesocket(pHbeatCb->sHbeatSocket);
    }

    pHbeatCb->sHbeatSocket = INVALID_SOCKET;
}



DWORD
DeActivateMHeartbeat(    
    IN PICB  picb
    )
{
    PMCAST_HBEAT_CB     pHbeatCb;

    
    TraceEnter("DeActivateMHeartbeat");
    
    pHbeatCb = &(picb->mhcHeartbeatInfo);

    if(!pHbeatCb->bActive)
    {
        return NO_ERROR;
    }

    DeleteHbeatSocket(picb);
    
    pHbeatCb->bActive = FALSE;
    
    TraceLeave("DeActivateMHeartbeat");
    
    return NO_ERROR;
}

VOID
HandleMHeartbeatMessages(
    VOID
    )

/*++

Routine Description
  

Locks


Arguments
      

Return Value
      
--*/

{
    PLIST_ENTRY         pleNode;
    PICB                picb;
    DWORD               i, dwResult, dwRcvAddrLen, dwSizeOfHeader;
    DWORD               dwBytesRead, dwFlags;
    WSANETWORKEVENTS    wsaNetworkEvents;
    SOCKADDR_IN         sinFrom;
    WSABUF              wsaRcvBuf;
    SYSTEMTIME          stSysTime;
    ULARGE_INTEGER      uliTime;
    
    wsaRcvBuf.len = 0;
    wsaRcvBuf.buf = NULL;

    GetSystemTime(&stSysTime);

    SystemTimeToFileTime(&stSysTime,
                         (PFILETIME)&uliTime);
    
    TraceEnter("HandleMHeartbeatMessages");
    
    for(pleNode = ICBList.Flink;
        pleNode isnot &ICBList;
        pleNode = pleNode->Flink)
    {
        picb = CONTAINING_RECORD(pleNode, ICB, leIfLink);
        
        //
        // If the interface has no bindings, or isnot involved in
        // multicast heartbeat detection, we wouldnt have
        // opened a socket on it so the FD_READ notification cant be for it
        //
        
        if((picb->bBound is FALSE) or
           (picb->mhcHeartbeatInfo.bActive is FALSE))
        {
            continue;
        }
        
        if(picb->mhcHeartbeatInfo.sHbeatSocket is INVALID_SOCKET)
        {
            continue;
        }
            
        if(WSAEnumNetworkEvents(picb->mhcHeartbeatInfo.sHbeatSocket,
                                NULL,
                                &wsaNetworkEvents) is SOCKET_ERROR)
        {
            dwResult = GetLastError();
            
            Trace1(ERR,
                   "HandleMHeartbeatMessages: WSAEnumNetworkEvents() returned %d",
                   dwResult);
                
            continue;
        }
            
        if(!(wsaNetworkEvents.lNetworkEvents & FD_READ))
        {
            //
            // Read bit isnot set and we arent interested in anything else
            //
            
            continue;
        }
            
        if(wsaNetworkEvents.iErrorCode[FD_READ_BIT] isnot NO_ERROR)
        {
            Trace2(ERR,
                   "HandleMHeartbeatMessages: Error %d associated with socket on %S for FD_READ",
                   wsaNetworkEvents.iErrorCode[FD_READ_BIT],
                   picb->pwszName);
                
            continue;
        }
            
        dwRcvAddrLen = sizeof(SOCKADDR_IN);
        dwFlags      = 0;

        //
        // We dont want the data, we just want to clear out the read
        // notification
        //

        dwResult = WSARecvFrom(picb->mhcHeartbeatInfo.sHbeatSocket,
                               &wsaRcvBuf,
                               1,
                               &dwBytesRead,
                               &dwFlags,
                               (struct sockaddr FAR*)&sinFrom,
                               &dwRcvAddrLen,
                               NULL,
                               NULL);

        if(dwResult is SOCKET_ERROR)
        {
            dwResult = WSAGetLastError();

            if(dwResult isnot WSAEMSGSIZE)
            {
                Trace3(ERR,
                       "HandleMHeartbeatMessages: Error %d in WSARecvFrom on %S. Bytes read %d",
                       dwResult,
                       picb->pwszName,
                       dwBytesRead);
            
                continue;
            }
        }
            
        //
        // If the message is on the group we need to hear from
        // then update the last heard time
        //

        picb->mhcHeartbeatInfo.ullLastHeard = uliTime.QuadPart;
        
    }

    TraceLeave("HandleMHeartbeatMessages");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\nat.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\nat.h

Abstract:

    Header for nat.c

Revision History:

    Gurdeep Singh Pall          6/26/95  Created

--*/

DWORD
StartNat(
    PIP_NAT_GLOBAL_INFO     pNatGlobalInfo
    );

DWORD
StopNat(
    VOID
    );

DWORD
SetGlobalNatInfo(
    PRTR_INFO_BLOCK_HEADER   pRtrGlobalInfo
    );

DWORD
AddInterfaceToNat(
    PICB picb
    );

DWORD
SetNatInterfaceInfo(
    PICB                     picb,
    PRTR_INFO_BLOCK_HEADER   pInterfaceInfo
    );

DWORD
BindNatInterface(
    PICB  picb
    );

DWORD
UnbindNatInterface(
    PICB    picb
    );

DWORD
DeleteInterfaceFromNat(
    PICB picb
    );

DWORD
SetNatContextToIpStack(
    PICB    picb
    );

DWORD
DeleteNatContextFromIpStack(
    PICB    picb
    );

DWORD
GetInterfaceNatInfo(
    PICB                    picb,
    PRTR_TOC_ENTRY          pToc,
    PBYTE                   pbDataPtr,
    PRTR_INFO_BLOCK_HEADER  pInfoHdrAndBuffer,
    PDWORD                  pdwSize
    );

DWORD
GetNatMappings(
    PICB                                picb,
    PIP_NAT_ENUMERATE_SESSION_MAPPINGS  pBuffer,
    DWORD                               dwSize
    );

DWORD
GetNumNatMappings(
    PICB    picb,
    PULONG  pulNatMappings
    );

DWORD
GetNatStatistics(
    PICB                            picb,
    PIP_NAT_INTERFACE_STATISTICS    pBuffer
    );
VOID
SetNatRangeForProxyArp(
    PICB    picb
    );
VOID
DeleteNatRangeFromProxyArp(
    PICB    picb
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\nat.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\rtrmgr\nat.c

Abstract:

    Based on filter.c
    Abstracts out the NAT functionality

Revision History:



--*/

#include "allinc.h"

DWORD
StartNat(
    PIP_NAT_GLOBAL_INFO     pNatGlobalInfo
    )
{
#if 1
return 0;
#else
    PLIST_ENTRY             pleNode;
    PICB                    picb;
    DWORD                   dwResult;
    NTSTATUS                ntStatus;
    IO_STATUS_BLOCK         IoStatusBlock;

    TraceEnter("StartNat");

    if(!g_bNatRunning)
    {
        if(StartDriverAndOpenHandle(IP_NAT_SERVICE_NAME,
                                    DD_IP_NAT_DEVICE_NAME,
                                    &g_hNatDevice) isnot NO_ERROR)
        {
            Trace0(ERR,
                   "StartNat: Couldnt open driver");

            TraceLeave("StartNat");

            return ERROR_OPEN_FAILED;
        }
       
        //
        // At this point NAT is running
        //

        ntStatus = NtDeviceIoControlFile(g_hNatDevice,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &IoStatusBlock,
                                         IOCTL_IP_NAT_SET_GLOBAL_INFO,
                                         (PVOID)pNatGlobalInfo,
                                         sizeof(IP_NAT_GLOBAL_INFO),
                                         NULL,
                                         0);

        if(ntStatus isnot STATUS_SUCCESS)
        {
            Trace1(ERR,
                   "StartNat: Status %X setting global info",
                   ntStatus);

            StopDriverAndCloseHandle(IP_NAT_SERVICE_NAME,
                                     g_hNatDevice);
            
            g_hNatDevice = NULL;

            TraceLeave("StartNat");

            return ERROR_OPEN_FAILED;
        }
 
        g_bNatRunning = TRUE;

        //
        // Just queue a worker to add the nat info and contexts
        //

        dwResult = QueueAsyncFunction(RestoreNatInfo,
                                      NULL,
                                      FALSE);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "StartNat: Error %d firing worker function to set nat info",
                   dwResult);
            
        }
    }
    
    TraceLeave("StartNat");

    return NO_ERROR;
#endif
}

DWORD
StopNat(
    VOID
    )
{
#if 1
return 0;
#else
    PLIST_ENTRY pleNode;
    PICB        picb;
    DWORD       dwResult;
 
    TraceEnter("StopNat");

    if(g_bNatRunning)
    {
        g_bNatRunning = FALSE;

        //
        // Set the NAT context in the ICBs to INVALID
        //
 
        for (pleNode = ICBList.Flink;
             pleNode != &ICBList;
             pleNode = pleNode->Flink)
        {
            picb = CONTAINING_RECORD (pleNode, ICB, leIfLink);
            
            if((picb->ritType is ROUTER_IF_TYPE_INTERNAL) or
               (picb->ritType is ROUTER_IF_TYPE_LOOPBACK) or
               (picb->ritType is ROUTER_IF_TYPE_CLIENT))
            {
                //
                // The above types are not added to the NAT
                // or to the IP stack
                //
                
                continue;
            }
            
            if(picb->dwOperationalState >= MIB_IF_OPER_STATUS_CONNECTED)
            {
                IpRtAssert(picb->bBound);

                UnbindNatInterface(picb);
            }

            dwResult = DeleteInterfaceFromNat(picb);

            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "StopNat: NtStatus %x deleting %S from NAT",
                       dwResult,
                       picb->pwszName);
            }
        }

        StopDriverAndCloseHandle(IP_NAT_SERVICE_NAME,
                                 g_hNatDevice);
    }

    TraceLeave("StopNat");

    return NO_ERROR;
#endif
}


DWORD
SetGlobalNatInfo(
    PRTR_INFO_BLOCK_HEADER   pRtrGlobalInfo
    )
{
#if 1
return 0;
#else
    PRTR_TOC_ENTRY          pToc;
    PIP_NAT_GLOBAL_INFO     pNatGlobalInfo;
    NTSTATUS                ntStatus;
    IO_STATUS_BLOCK         IoStatusBlock;
    DWORD                   dwResult;


    TraceEnter("SetGlobalNatInfo");
    
    pNatGlobalInfo = NULL;
    
    pToc = GetPointerToTocEntry(IP_NAT_INFO,
                                pRtrGlobalInfo);

   
    if(pToc)
    {
        pNatGlobalInfo = GetInfoFromTocEntry(pRtrGlobalInfo,
                                             pToc);
        if((pToc->InfoSize is 0) or (pNatGlobalInfo is NULL))
        {
            //
            // Means remove NAT
            //

            dwResult = StopNat();

            if(dwResult isnot NO_ERROR)
            {
                Trace1(ERR,
                       "SetGlobalNatInfo: Error %d stopping NAT (no info)",
                       dwResult);
            }

            TraceLeave("SetGlobalNatInfo");

            return dwResult;
        }
    }
    else
    {    
        Trace0(IF,
               "SetGlobalNatInfo: No NAT info, so leaving");

        TraceLeave("SetGlobalNatInfo");
        
        return NO_ERROR;
    }

    EnterCriticalSection(&g_csNatInfo);

    if(g_pNatGlobalInfo is NULL)
    {
        g_pNatGlobalInfo = HeapAlloc(IPRouterHeap,
                                     0,
                                     sizeof(IP_NAT_GLOBAL_INFO));

        if(g_pNatGlobalInfo is NULL)
        {
            Trace1(ERR,
                   "SetGlobalNatInfo: Error %d allocating memory for NAT info",
                   GetLastError());

            LeaveCriticalSection(&g_csNatInfo);

            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // Save a copy
    //

    CopyMemory(g_pNatGlobalInfo,
               pNatGlobalInfo,
               sizeof(IP_NAT_GLOBAL_INFO));

    if(g_bNatRunning)
    {
        //
        // NAT is running, if the user is asking us to stop it,
        // do so now an return
        //

        if(pNatGlobalInfo->NATEnabled is FALSE)
        {
            dwResult = StopNat();
            
            LeaveCriticalSection(&g_csNatInfo);

            if(dwResult isnot NO_ERROR)
            {
                Trace1(ERR,
                       "SetGlobalNatInfo: Error %d stopping NAT",
                       dwResult);
            }

            TraceLeave("SetGlobalNatInfo");
        
            return dwResult;
        }
    }
    else
    {
        if(pNatGlobalInfo->NATEnabled is TRUE)
        {
            dwResult = StartNat(pNatGlobalInfo);

            LeaveCriticalSection(&g_csNatInfo);

            if(dwResult isnot NO_ERROR)
            {
                Trace1(ERR,
                       "SetGlobalNatInfo: Error %d starting NAT",
                       dwResult);
            }
            
            TraceLeave("SetGlobalNatInfo");
       
            //
            // Starting NAT causes us to also set the global info
            // so we can return from here
            //
 
            return dwResult;
        }
    }

    //
    // This is the case where NAT is already started and only its info is
    // being changed
    //

    ntStatus = NtDeviceIoControlFile(g_hNatDevice,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_IP_NAT_SET_GLOBAL_INFO,
                                     (PVOID)pNatGlobalInfo,
                                     sizeof(IP_NAT_GLOBAL_INFO),
                                     NULL,
                                     0);
    if (!NT_SUCCESS(ntStatus))
    {
        Trace1(ERR,
               "SetGlobalNatInfo: NtStatus %x setting NAT info",
               ntStatus);

        TraceLeave("SetGlobalNatInfo");
    
        LeaveCriticalSection(&g_csNatInfo);

        return ERROR_CAN_NOT_COMPLETE;
    }

    LeaveCriticalSection(&g_csNatInfo);

    TraceLeave("SetGlobalNatInfo");
    
    return NO_ERROR;
#endif
}
        
        
DWORD
AddInterfaceToNat(
    PICB picb
    )

/*++
  
Routine Description

    Adds an interface to the nat driver and stores the context returned by
    the driver
    Can only be called if NAT is running

Locks

    
Arguments

    picb
          
Return Value

--*/

{
#if 1
return 0;
#else
    NTSTATUS                        ntStatus;
    IO_STATUS_BLOCK                 IoStatusBlock;
    IP_NAT_CREATE_INTERFACE         inBuffer;
    DWORD                           dwInBufLen;

    TraceEnter("AddInterfaceToNat");

    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK) and
               (picb->ritType isnot ROUTER_IF_TYPE_CLIENT));

    inBuffer.RtrMgrIndex         = picb->dwIfIndex;
    inBuffer.RtrMgrContext       = picb;
    inBuffer.NatInterfaceContext = NULL;
    
    dwInBufLen = sizeof(IP_NAT_CREATE_INTERFACE);

    picb->pvNatContext = NULL;
    
    ntStatus = NtDeviceIoControlFile(g_hNatDevice,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_IP_NAT_CREATE_INTERFACE,
                                     (PVOID)&inBuffer,
                                     dwInBufLen,
                                     (PVOID)&inBuffer,
                                     dwInBufLen);
    
    if(!NT_SUCCESS(ntStatus))
    {
        Trace2(ERR,
               "AddInterfaceToNat: NtStatus %x adding %S to NAT",
               ntStatus,
               picb->pwszName);

        TraceLeave("AddInterfaceToNat");
    
        return ntStatus;
    }
    
    picb->pvNatContext = inBuffer.NatInterfaceContext;

    TraceLeave("AddInterfaceToNat");
    
    return NO_ERROR;    
#endif
}

DWORD
SetNatInterfaceInfo(
    PICB                     picb, 
    PRTR_INFO_BLOCK_HEADER   pInterfaceInfo
    )
{
#if 1
return 0;
#else
    NTSTATUS                    ntStatus;
    IO_STATUS_BLOCK             IoStatusBlock;
    DWORD                       i,dwInBufLen,dwResult;
    PRTR_TOC_ENTRY              pToc;
    PIP_NAT_INTERFACE_INFO      pNatInfo;
 
    if((picb->ritType is ROUTER_IF_TYPE_INTERNAL) or
       (picb->ritType is ROUTER_IF_TYPE_LOOPBACK) or
       (picb->ritType is ROUTER_IF_TYPE_CLIENT))
    {
        return NO_ERROR;
    }

    if(!g_bNatRunning)
    {
        return NO_ERROR;
    }

    TraceEnter("SetNatInterfaceInfo");

    pToc  = GetPointerToTocEntry(IP_NAT_INFO,
                                 pInterfaceInfo);

    if(pToc is NULL)
    {
        //
        // NULL means we dont need to change anything
        //
        
        Trace1(IF,
               "SetNatInterfaceInfo: Nat info is  NULL for %S, so leaving",
               picb->pwszName);
       
        TraceLeave("SetNatInterfaceInfo");

        return NO_ERROR;
    }

    if(pToc->InfoSize is 0)
    {
        //
        // TOC present, but no info
        // This means, delete the interface
        //

        dwResult = UnbindNatInterface(picb);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "SetNatInterfaceInfo: Error %d unbinding %S",
                   dwResult,
                   picb->pwszName);
        }
   
        dwResult = DeleteInterfaceFromNat(picb);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "SetNatInterfaceInfo: Error %d deleting interface %S",
                   dwResult,
                   picb->pwszName);
        }
   
        TraceLeave("SetNatInterfaceInfo");
     
        return dwResult;
    }
   
    //
    // So we have NAT info
    //
 
    if(picb->pvNatContext is NULL)
    {
        //
        // Looks like this interface does not have NAT
        //

        Trace1(IF,
               "SetNatInterfaceInfo: No context, assuming interface %S not added to NAT",
               picb->pwszName);

        //
        // Add the interface to NAT
        //

        dwResult = AddInterfaceToNat(picb);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "SetNatInterfaceInfo: Error %d adding interface %S",
                   dwResult,
                   picb->pwszName);

            TraceLeave("SetNatInterfaceInfo");

            return dwResult;
        }
    }

    if(picb->pvNatInfo)
    {
        //
        // If we are LAN and UP, then this info has been added for
        // proxy ARP. Remove it
        // An optimization would be to only remove those addresses that will
        // be going away by this set, and then only set those addresses
        // that will be coming new due to this set.
        // But like I said, that is an _optimization_
        //
        
        DeleteNatRangeFromProxyArp(picb);

        IpRtAssert(picb->ulNatInfoSize isnot 0);

        HeapFree(IPRouterHeap,
                 0,
                 picb->pvNatInfo);
    }

    picb->ulNatInfoSize = 0;
    
    dwInBufLen  = pToc->InfoSize;

    pNatInfo = (PIP_NAT_INTERFACE_INFO)GetInfoFromTocEntry(pInterfaceInfo,
                                                           pToc);

    //
    // Allocate space for nat info
    //

    picb->pvNatInfo = HeapAlloc(IPRouterHeap,
                                0,
                                dwInBufLen);

    if(picb->pvNatInfo is NULL)
    {
        Trace2(ERR,
               "SetNatInterfaceInfo: Error %d allocating memory for %S",
               GetLastError(),
               picb->pwszName);

        TraceLeave("SetNatInterfaceInfo");

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Save a copy of the info
    //

    CopyMemory(picb->pvNatInfo,
               pNatInfo,
               dwInBufLen);

    picb->ulNatInfoSize = dwInBufLen;
    
    //
    // Fill in the context since that will not be in the info that is
    // passed to us
    //

    pNatInfo->NatInterfaceContext = picb->pvNatContext;

    ntStatus = NtDeviceIoControlFile(g_hNatDevice,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_IP_NAT_SET_INTERFACE_INFO,
                                     (PVOID)pNatInfo,
                                     dwInBufLen,
                                     NULL,
                                     0);
    
    if (!NT_SUCCESS(ntStatus))
    {
        Trace2(ERR,
               "SetNatInterfaceInfo: NtStatus %x adding NAT info for %S",
               ntStatus,
               picb->pwszName);

        TraceLeave("SetNatInterfaceInfo");

        return ERROR_CAN_NOT_COMPLETE;
    }

 
    TraceLeave("SetNatInterfaceInfo");
        
    return NO_ERROR;
#endif
}

DWORD
GetInterfaceNatInfo(
    PICB                    picb,
    PRTR_TOC_ENTRY          pToc,
    PBYTE                   pbDataPtr,
    PRTR_INFO_BLOCK_HEADER  pInfoHdrAndBuffer,
    PDWORD                  pdwSize
    )

/*++

Routine Description

    This function copies out the saved NAT info to the buffer
    Can only be called if NAT is running
    
Locks

    ICB_LIST lock held as READER

Arguments

    picb
    pToc
    pbDataPtr
    pInfoHdrAndBuffer
    pdwSize

Return Value

    None    

--*/

{
#if 1
return 0;
#else
    TraceEnter("GetInterfaceNatInfo");

    if(*pdwSize < picb->ulNatInfoSize)
    {
        *pdwSize = picb->ulNatInfoSize;

        TraceLeave("GetInterfaceNatInfo");
        
        return ERROR_INSUFFICIENT_BUFFER;
    }

    if(picb->pvNatInfo is NULL)
    {
        IpRtAssert(picb->ulNatInfoSize is 0);

        //
        // No data
        //

        *pdwSize = 0;

        TraceLeave("GetInterfaceNatInfo");
        
        return ERROR_NO_DATA;
    }

    IpRtAssert(picb->pvNatContext);

    pToc->InfoType  = IP_NAT_INFO;
    pToc->Count     = 1;
    pToc->InfoSize  = picb->ulNatInfoSize;
    pToc->Offset    = pbDataPtr - (PBYTE)pInfoHdrAndBuffer;

    CopyMemory(pbDataPtr,
               picb->pvNatInfo,
               picb->ulNatInfoSize);

    *pdwSize = picb->ulNatInfoSize;

    TraceLeave("GetInterfaceNatInfo");
    
    return NO_ERROR;
#endif
}


DWORD
BindNatInterface(
    PICB  picb
    )
{
#if 1
return 0;
#else
    PIP_NAT_BIND_INTERFACE      pnbiBindInfo;
    NTSTATUS                    ntStatus;
    IO_STATUS_BLOCK             IoStatusBlock;
    DWORD                       i, dwInBufLen, dwResult;
    PIP_ADAPTER_BINDING_INFO    pBinding;


    if((picb->ritType is ROUTER_IF_TYPE_INTERNAL) or
       (picb->ritType is ROUTER_IF_TYPE_LOOPBACK) or
       (picb->ritType is ROUTER_IF_TYPE_CLIENT))
    {
        return NO_ERROR;
    }

    if(!g_bNatRunning)
    {
        return NO_ERROR;
    }

    TraceEnter("BindNatInterface");

    if(picb->pvNatContext is NULL)
    {
        Trace1(IF,
               "BindNatInterface: No context, assuming interface %S not added to NAT",
               picb->pwszName);

        TraceLeave("SetAddressFromNat");

        return NO_ERROR;
    }

    //
    // Try and set the address to NAT
    //

    if(picb->dwNumAddresses > 0)
    {
        dwInBufLen = FIELD_OFFSET(IP_NAT_BIND_INTERFACE, BindingInfo[0]) + 
                     SIZEOF_IP_BINDING(picb->dwNumAddresses);

        pnbiBindInfo = HeapAlloc(IPRouterHeap,
                                 HEAP_ZERO_MEMORY,
                                 dwInBufLen);
       
        if(pnbiBindInfo is NULL)
        {
            dwResult = GetLastError();

            Trace2(ERR,
                   "BindNatInterface: Unable to allocate memory for binding for %S",
                   dwResult,
                   picb->pwszName);

            TraceLeave("BindNatInterface");

            return dwResult;
        }

        pnbiBindInfo->NatInterfaceContext = picb->pvNatContext;

        pBinding = (PIP_ADAPTER_BINDING_INFO)pnbiBindInfo->BindingInfo;

        pBinding->NumAddresses  = picb->dwNumAddresses;
        pBinding->RemoteAddress = picb->dwRemoteAddress;
    
        for(i = 0; i < picb->dwNumAddresses; i++)
        {
            pBinding->Address[i].IPAddress = picb->pibBindings[i].dwAddress;
            pBinding->Address[i].Mask      = picb->pibBindings[i].dwMask;
        }
    
        ntStatus = NtDeviceIoControlFile(g_hNatDevice,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &IoStatusBlock,
                                         IOCTL_IP_NAT_BIND_INTERFACE,
                                         (PVOID)pnbiBindInfo,
                                         dwInBufLen,
                                         NULL,
                                         0);

        if(!NT_SUCCESS(ntStatus))
        {
            Trace2(ERR,
                   "BindNatInterface: NtStatus %x setting binding  for %S",
                   ntStatus,
                   picb->pwszName);
        }
    }

    //
    // Set the proxy arp range
    // This requires that the NAT info already be part of the ICB
    //
    

    SetNatRangeForProxyArp(picb);
    
    //
    // Set the context to IP stack
    //

    dwResult = SetNatContextToIpStack(picb);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "BindNatInterface: Error %d setting context for %S",
               dwResult,
               picb->pwszName);
    }
    
    TraceLeave("BindNatInterface");

    return ntStatus;
#endif
}

DWORD
UnbindNatInterface(
    PICB    picb
    )

/*++

Routine Description


Locks


Arguments


Return Value

    NO_ERROR

--*/

{
#if 1
return 0;
#else
    IP_NAT_UNBIND_INTERFACE     ubiUnbindInfo;
    NTSTATUS                    ntStatus;
    IO_STATUS_BLOCK             IoStatusBlock;
    DWORD                       dwResult;
    

    if((picb->ritType is ROUTER_IF_TYPE_INTERNAL) and
       (picb->ritType is ROUTER_IF_TYPE_LOOPBACK) and
       (picb->ritType is ROUTER_IF_TYPE_CLIENT))
    {
        return NO_ERROR;
    }

    if(!g_bNatRunning)
    {
        return NO_ERROR;
    }

    TraceEnter("UnbindNatInterface");
    
    if(picb->pvNatContext is NULL)
    {
        Trace1(IF,
               "ClearAddressToNat: No context, assuming interface %S not added to NAT",
               picb->pwszName);

        TraceLeave("UnbindNatInterface");

        return NO_ERROR;
    }

    ubiUnbindInfo.NatInterfaceContext = picb->pvNatContext;

    ntStatus = NtDeviceIoControlFile(g_hNatDevice,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_IP_NAT_UNBIND_INTERFACE,
                                     (PVOID)&ubiUnbindInfo,
                                     sizeof(IP_NAT_UNBIND_INTERFACE),
                                     NULL,
                                     0);

    if(!NT_SUCCESS(ntStatus))
    {
        Trace2(ERR,
               "UnbindNatInterface: NtStatus %x setting binding  for %S",
               ntStatus,
               picb->pwszName);
    }

    //
    // Blow away the proxy arp stuff
    //

    DeleteNatRangeFromProxyArp(picb);

    dwResult = DeleteNatContextFromIpStack(picb);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "UnbindNatInterface: Error %d removing context for %S",
               dwResult,
               picb->pwszName);
    }
    
    TraceLeave("UnbindNatInterface");

    return ntStatus;
#endif
}
    
     
DWORD
DeleteInterfaceFromNat(
    PICB picb
    )
{
#if 1
return 0;
#else
    IP_NAT_DELETE_INTERFACE     DeleteInfo;
    NTSTATUS                    ntStatus;
    IO_STATUS_BLOCK             IoStatusBlock;
    DWORD                       dwResult;

    TraceEnter("DeleteInterfaceFromNat");

    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK) and
               (picb->ritType isnot ROUTER_IF_TYPE_CLIENT));


    if(picb->pvNatContext is NULL)
    {
        Trace1(IF,
               "DeleteInterfaceFromNat: No context, assuming interface %S not added to NAT",
               picb->pwszName);

        TraceLeave("DeleteInterfaceFromNat");

        return NO_ERROR;
    }

    //
    // Non NULL pvContext means NAT must be running
    //

    IpRtAssert(g_bNatRunning);
    IpRtAssert(g_hNatDevice);

    //
    // Blow away any saved info
    //

    if(picb->pvNatInfo)
    {
        IpRtAssert(picb->ulNatInfoSize isnot 0);

        HeapFree(IPRouterHeap,
                 0,
                 picb->pvNatInfo);

        picb->pvNatInfo = NULL;
    }

    picb->ulNatInfoSize = 0;
    
    DeleteInfo.NatInterfaceContext = picb->pvNatContext;

    dwResult = NO_ERROR;

    ntStatus = NtDeviceIoControlFile(g_hNatDevice,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_IP_NAT_DELETE_INTERFACE,
                                     (PVOID)&DeleteInfo,
                                     sizeof(IP_NAT_DELETE_INTERFACE),
                                     NULL,
                                     0);

    if(!NT_SUCCESS(ntStatus))
    {
        Trace2(ERR,
               "DeleteInterfaceFromNat: NtStatus %x deleting %S",
               ntStatus,
               picb->pwszName);

        dwResult = ERROR_CAN_NOT_COMPLETE;
    }

    picb->pvNatContext = NULL;

    TraceLeave("DeleteInterfaceFromNat");

    return dwResult;
#endif
}

DWORD
SetNatContextToIpStack(
    PICB    picb
    )

/*++

Routine Description
   
    Sets the NAT context as the FIREWALL context in IP 
    Can only be called if NAT is running
    
Locks

    The ICB list should be held atleast as READER

Arguments

    picb    ICB for the interface

Return Value

    NO_ERROR

--*/

{
#if 1
return 0;
#else
    NTSTATUS           ntStatus;
    IO_STATUS_BLOCK    IoStatusBlock;
    DWORD              dwResult;
    IP_SET_IF_CONTEXT_INFO info;

    TraceEnter("SetNatContextToIpStack");

    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK) and
               (picb->ritType isnot ROUTER_IF_TYPE_CLIENT));

    if(picb->pvNatContext is NULL)
    {
        Trace1(IF,
               "SetNatContextToIpStack: No context, assuming interface %S not added to NAT",
               picb->pwszName);

        return NO_ERROR;
    }

    if(picb->bBound is FALSE)
    {
        Trace1(IF,
               "SetNatContextToIpStack: Not setting context for %S since it is not bound",
               picb->pwszName);


        TraceLeave("SetNatContextToIpStack");

        return NO_ERROR;
    }

    info.Index   = picb->dwAdapterId;
    info.Context = picb->pvNatContext;

    ntStatus = NtDeviceIoControlFile(g_hIpDevice,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_IP_SET_FIREWALL_IF,
                                     (PVOID)&info,
                                     sizeof(IP_SET_IF_CONTEXT_INFO),
                                     NULL,
                                     0);
    if(!NT_SUCCESS(ntStatus))
    {
        Trace2(ERR,
               "SetNatContextToIpStack: NtStatus %x while setting context for %S",
               ntStatus,
               picb->pwszName);

        TraceLeave("SetNatContextToIpStack");

        return ntStatus;
    }

    TraceLeave("SetNatContextToIpStack");

    return NO_ERROR;
#endif
}

DWORD
DeleteNatContextFromIpStack(
    PICB    picb
    )

/*++
Routine Description

    Deletes the the NAT context as the FIREWALL context in IP by setting it 
    to NULL
    Can only be called if NAT is running
    
Locks

    The ICB list should be held as WRITER

Arguments

    picb    ICB for the interface

Return Value

    NO_ERROR

--*/

{
#if 1
return 0;
#else
    NTSTATUS           ntStatus;
    IO_STATUS_BLOCK    IoStatusBlock;
    DWORD              dwResult;
    IP_SET_IF_CONTEXT_INFO info;

    TraceEnter("DeleteNatContextFromIpStack");

    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK) and
               (picb->ritType isnot ROUTER_IF_TYPE_CLIENT));

    if(picb->pvNatContext is NULL)
    {
        Trace1(IF,
               "DeleteNatContextFromIpStack: No context, assuming interface %S not added to NAT",
               picb->pwszName);

        return NO_ERROR;
    }

    if(picb->bBound is FALSE)
    {
        Trace1(IF,
               "DeleteNatContextFromIpStack: Not deleting context for %S since it is not bound",
               picb->pwszName);

        TraceLeave("DeleteNatContextFromIpStack");

        return NO_ERROR;
    }

    info.Index   = picb->dwAdapterId;
    info.Context = NULL;

    ntStatus = NtDeviceIoControlFile(g_hIpDevice,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_IP_SET_FIREWALL_IF,
                                     (PVOID)&info,
                                     sizeof(IP_SET_IF_CONTEXT_INFO),
                                     NULL,
                                     0);
    if(!NT_SUCCESS(ntStatus))
    {
        Trace2(ERR,
               "DeleteNatContextFromIpStack: NtStatus %x while deleting context for %S",
               ntStatus,
               picb->pwszName);

        TraceLeave("DeleteNatContextFromIpStack");

        return ntStatus;
    }

    TraceLeave("DeleteNatContextFromIpStack");

    return NO_ERROR;
#endif
}

VOID
SetNatRangeForProxyArp(
    PICB    picb
    )

/*++

Routine Description

    This functions adds any address ranges in the NAT info as Proxy Arp
    addresses

Locks

    ICB_LIST locked as writer

Arguments

    picb    ICB of the interface whose nat info is being added

Return Value

    NONE    we log the errors, there isnt much to do with an error code

--*/

{
#if 1
return;
#else
    DWORD   dwResult, dwAddr, dwStartAddr, dwEndAddr, i;
   
    PIP_NAT_INTERFACE_INFO  pNatInfo; 
    PIP_NAT_ADDRESS_RANGE   pRange;

    
    //
    // Only do this if we have a valid adapter index and this is a LAN
    // interface
    //

    if((picb->dwOperationalState < MIB_IF_OPER_STATUS_CONNECTED) or
       (picb->ritType isnot ROUTER_IF_TYPE_DEDICATED))
    {
        return;
    }

    IpRtAssert(picb->bBound);
    IpRtAssert(picb->dwAdapterId isnot INVALID_ADAPTER_ID);

    pNatInfo = picb->pvNatInfo;

    //
    // Now, if we have ranges, we need to set the proxy arp addresses on them
    //

    for(i = 0; i < pNatInfo->Header.TocEntriesCount; i++)
    {
        if(pNatInfo->Header.TocEntry[i].InfoType isnot IP_NAT_ADDRESS_RANGE_TYPE)
        {
            continue;
        }

        if(pNatInfo->Header.TocEntry[i].InfoSize is 0)
        {
            continue;
        }

        //
        // Here we are adding potentially duplicate PARP entries.
        // Hopefully, IP knows how to handle it
        //
      
        pRange = GetInfoFromTocEntry(&(pNatInfo->Header),
                                     &(pNatInfo->Header.TocEntry[i]));

        //
        // Convert to little endian
        //

        dwStartAddr = ntohl(pRange->StartAddress);
        dwEndAddr   = ntohl(pRange->EndAddress);

        for(dwAddr = dwStartAddr;
            dwAddr <= dwEndAddr;
            dwAddr++)
        {
            DWORD   dwNetAddr, dwClassMask;

            dwNetAddr = htonl(dwAddr);

            //
            // Throw away useless addresses and then set proxy arp entries
            //

            dwClassMask = GetClassMask(dwNetAddr);

            if(((dwNetAddr & ~pRange->SubnetMask) is 0) or
               (dwNetAddr is (dwNetAddr & ~pRange->SubnetMask)) or
               ((dwNetAddr & ~dwClassMask) is 0) or
               (dwNetAddr is (dwNetAddr & ~dwClassMask)))
            {
                continue;
            }

            dwResult = SetProxyArpEntryToStack(dwNetAddr,
                                               0xFFFFFFFF,
                                               picb->dwAdapterId,
                                               TRUE,
                                               FALSE);

            if(dwResult isnot NO_ERROR)
            {
                Trace4(ERR,
                       "SetProxy: Error %x setting %d.%d.%d.%d over adapter %d (%S)",
                       dwResult,
                       PRINT_IPADDR(dwNetAddr),
                       picb->dwAdapterId,
                       picb->pwszName);
            }
        }
    }
#endif
}

VOID
DeleteNatRangeFromProxyArp(
    PICB    picb
    )

/*++

Routine Description

    This removes the previously added proxy arp addresses    

Locks

    ICB_LIST lock taken as writer

Arguments

    picb    The icb of the interface whose addr range info needs to be removed

Return Value

    NONE
    
--*/

{
#if 1
return;
#else
    DWORD   dwResult, dwAddr, dwStartAddr, dwEndAddr, i;
   
    PIP_NAT_INTERFACE_INFO  pNatInfo; 
    PIP_NAT_ADDRESS_RANGE   pRange;

    
    //
    // Only do this if we have a valid adapter index and this is a LAN
    // interface
    //

    if((picb->dwOperationalState < MIB_IF_OPER_STATUS_CONNECTED) or
       (picb->ritType isnot ROUTER_IF_TYPE_DEDICATED))
    {
        return;
    }

    IpRtAssert(picb->bBound);

    pNatInfo = picb->pvNatInfo;

    for(i = 0; i < pNatInfo->Header.TocEntriesCount; i++)
    {
        if(pNatInfo->Header.TocEntry[i].InfoType isnot IP_NAT_ADDRESS_RANGE_TYPE)
        {
            continue;
        }

        if(pNatInfo->Header.TocEntry[i].InfoSize is 0)
        {
            continue;
        }

        //
        // Here we are adding potentially duplicate PARP entries.
        // Hopefully, IP knows how to handle it
        //
      
        pRange = GetInfoFromTocEntry(&(pNatInfo->Header),
                                     &(pNatInfo->Header.TocEntry[i]));

        dwStartAddr = ntohl(pRange->StartAddress);
        dwEndAddr   = ntohl(pRange->EndAddress);

        for(dwAddr = dwStartAddr; 
            dwAddr <= dwEndAddr; 
            dwAddr++)
        {
            DWORD   dwNetAddr, dwClassMask;

            dwNetAddr = htonl(dwAddr);

            //
            // Throw away useless addresses and then set proxy arp entries
            //

            dwClassMask = GetClassMask(dwNetAddr);

            if(((dwNetAddr & ~pRange->SubnetMask) is 0) or
               (dwNetAddr is (dwNetAddr & ~pRange->SubnetMask)) or
               ((dwNetAddr & ~dwClassMask) is 0) or
               (dwNetAddr is (dwNetAddr & ~dwClassMask)))
            {
                continue;
            }

            dwResult = SetProxyArpEntryToStack(dwNetAddr,
                                               0xFFFFFFFF,
                                               picb->dwAdapterId,
                                               FALSE,
                                               FALSE);

            if(dwResult isnot NO_ERROR)
            {
                Trace4(ERR,
                       "DeleteProxy: Error %x removing %d.%d.%d.%d over adapter %d (%S)",
                       dwResult,
                       PRINT_IPADDR(dwNetAddr),
                       picb->dwAdapterId,
                       picb->pwszName);
            }
        }
    }
#endif
}

    
DWORD
GetNumNatMappings(
    PICB    picb,
    PULONG  pulNatMappings
    )

/*++

Routine Description

    This function queries the NAT with a minimum sized buffer to figure out
    the number of mappings
    Can only be called if NAT is running
    
Locks

    ICB_LIST lock held as READER

Arguments

    picb,           ICB of interface whose map count needs to be queried
    pulNatMappings  Number of mappings

Return Value

    NO_ERROR

--*/

{
#if 1
return 0;
#else
    DWORD       dwResult;

    IP_NAT_INTERFACE_STATISTICS stats;

    *pulNatMappings = 0;
    
    dwResult = GetNatStatistics(picb,
                                &stats);
    
    if(dwResult is NO_ERROR)
    {
        *pulNatMappings = stats.TotalMappings;
    }

    return dwResult;
#endif
}

DWORD
GetNatMappings(
    PICB                                picb,
    PIP_NAT_ENUMERATE_SESSION_MAPPINGS  pBuffer,
    DWORD                               dwSize
    )

/*++

Routine Description

    This function gets the mappings on the interface
    Can only be called if NAT is running

Locks

    ICB_LIST held as READER

Arguments

    picb
    pBuffer
    pdwSize

Return Value

    None    

--*/

{
#if 1
return 0;
#else
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS        nStatus;

    if(picb->pvNatContext is NULL)
    {
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    IpRtAssert(dwSize >= sizeof(IP_NAT_ENUMERATE_SESSION_MAPPINGS));
    
    //
    // Zero out the context and stuff
    //
    
    ZeroMemory(pBuffer,
               sizeof(IP_NAT_ENUMERATE_SESSION_MAPPINGS));

    pBuffer->NatInterfaceContext = picb->pvNatContext;

    nStatus = NtDeviceIoControlFile(g_hNatDevice,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    IOCTL_IP_NAT_ENUMERATE_SESSION_MAPPINGS,
                                    (PVOID)pBuffer,
                                    dwSize,
                                    (PVOID)pBuffer,
                                    dwSize);
    
    if(!NT_SUCCESS(nStatus))
    {
        Trace1(ERR,
               "GetNumNatMappings: NtStatus %x",
               nStatus);

        return ERROR_CAN_NOT_COMPLETE;
    }

    return NO_ERROR;
#endif
}

DWORD
GetNatStatistics(
    PICB                            picb,
    PIP_NAT_INTERFACE_STATISTICS    pBuffer
    )

/*++

Routine Description

    This function retrieves the nat interface statistics into the supplied
    buffer

Locks

    ICB_LIST lock held as READER

Arguments

    picb
    pBuffer

Return Value

    None    

--*/

{
#if 1
return 0;
#else
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS        nStatus;

    if(picb->pvNatContext is NULL)
    {
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    pBuffer->NatInterfaceContext = picb->pvNatContext;
    
    nStatus = NtDeviceIoControlFile(g_hNatDevice,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    IOCTL_IP_NAT_GET_INTERFACE_STATISTICS,
                                    (PVOID)pBuffer,
                                    sizeof(IP_NAT_INTERFACE_STATISTICS),
                                    (PVOID)pBuffer,
                                    sizeof(IP_NAT_INTERFACE_STATISTICS));
   
    if(!NT_SUCCESS(nStatus))
    {
        Trace1(ERR,
               "GetNatStatistics: NtStatus %x",
               nStatus);

        return ERROR_CAN_NOT_COMPLETE;
    }

    return NO_ERROR;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\mhrtbt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\mhrtbt.h

Abstract:

    Header for multicast heartbeat

Revision History:

    Amritansh Raghav  26th Dec 1997     Created

--*/


#define MHBEAT_SOCKET_FLAGS     \
    (WSA_FLAG_MULTIPOINT_C_LEAF|WSA_FLAG_MULTIPOINT_D_LEAF)

typedef struct _MCAST_HBEAT_CB
{
    BOOL        bActive;

    //
    // The name/address of group
    //

    WCHAR       pwszGroup[MAX_GROUP_LEN];

    //
    // The resolved address
    //

    DWORD       dwGroup;

    //
    // Port or protocol
    //

    WORD        wPort;
    
    //
    // Protocol or RAW
    //

    BYTE        byProtocol;

    //
    // Set to TRUE if a gethostbyname is in progress
    //

    BOOL        bResolutionInProgress;

    //
    // The socket for the interface
    //

    SOCKET      sHbeatSocket;

    //
    // The dead interval in system ticks
    //

    ULONGLONG   ullDeadInterval;

    ULONGLONG   ullLastHeard;

}MCAST_HBEAT_CB, *PMCAST_HBEAT_CB;


//
// Structure used to pass to worker function
//

typedef struct _HEARTBEAT_CONTEXT
{
    DWORD   dwIfIndex;
    PICB    picb;
    WCHAR   pwszGroup[MAX_GROUP_LEN];
}HEARTBEAT_CONTEXT, *PHEARTBEAT_CONTEXT;

//
// Forward function declarations
//

DWORD
SetMHeartbeatInfo(
    IN PICB                      picb,
    IN PRTR_INFO_BLOCK_HEADER    pInfoHdr
    );

DWORD
GetMHeartbeatInfo(
    PICB                    picb,
    PRTR_TOC_ENTRY          pToc,
    PBYTE                   pbDataPtr,
    PRTR_INFO_BLOCK_HEADER  pInfoHdr,
    PDWORD                  pdwSize
    );

DWORD
ActivateMHeartbeat(
    IN PICB  picb
    );

DWORD
StartMHeartbeat(
    IN PICB  picb
    );

DWORD
CreateHbeatSocket(
    IN PICB picb
    );

VOID
DeleteHbeatSocket(
    IN PICB picb
    );

DWORD
DeActivateMHeartbeat(
    IN PICB  picb
    );

VOID
HandleMHeartbeatMessages(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\route.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\route.h

Abstract:

    Header for route.c

Revision History:


--*/


#ifndef __RTRMGR_ROUTE_H__
#define __RTRMGR_ROUTE_H__

typedef struct _RTM_HANDLE_INFO
{
    DWORD   dwProtoId;
    BOOL    bStatic;
    HANDLE  hRouteHandle;
}RTM_HANDLE_INFO, *PRTM_HANDLE_INFO;

RTM_HANDLE_INFO g_rgRtmHandles[5];

typedef struct _ROUTE_CHANGE_INFO
{
    IO_STATUS_BLOCK         ioStatus;
    IPRouteNotifyOutput     ipNotifyOutput;
} ROUTE_CHANGE_INFO, *PROUTE_CHANGE_INFO;

DWORD
InitializeStaticRoutes(
    PICB                     picb,
    PRTR_INFO_BLOCK_HEADER   pInfoHdr
    );

DWORD
CopyOutClientRoutes(
    PICB                     picb,
    PRTR_INFO_BLOCK_HEADER   pInfoHdr
    );

DWORD
AddSingleRoute(
    DWORD                   dwInterfaceIndex,
    PINTERFACE_ROUTE_INFO   pRoute,
    DWORD                   dwNextHopMask,
    WORD                    wRtmFlags,
    BOOL                    bValid,
    BOOL                    bAddToStack,
    BOOL                    bP2P,
    HANDLE                  *phRtmRoute OPTIONAL
    );

DWORD
DeleteSingleRoute(
    DWORD   dwInterfaceId,
    DWORD   dwDestAddr,
    DWORD   dwDestMask,
    DWORD   dwNexthop,
    DWORD   dwProtoId,
    BOOL    bP2P
    );

DWORD
DeleteAllRoutes(
    IN  DWORD   dwIfIndex,
    IN  BOOL    bStaticOnly
    );

VOID
DeleteAllClientRoutes(
    PICB    pIcb,
    DWORD   dwServerIfIndex
    );

VOID
AddAllClientRoutes(
    PICB    pIcb,
    DWORD   dwServerIfIndex
    );

DWORD
GetNumStaticRoutes(
    PICB picb
    );

DWORD
GetInterfaceRouteInfo(
    IN     PICB                   picb,
    IN     PRTR_TOC_ENTRY         pToc,
    IN     PBYTE                  pbDataPtr,
    IN OUT PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwInfoSize
    );

DWORD
ReadAllStaticRoutesIntoBuffer(
    PICB                 picb,
    PINTERFACE_ROUTE_INFO   pRoutes,
    DWORD                dwMaxRoutes
    );

DWORD
SetRouteInfo(
    PICB                    picb,
    PRTR_INFO_BLOCK_HEADER  pInfoHdr
    );

DWORD
ConvertRoutesToAutoStatic(
    DWORD dwProtocolId,
    DWORD dwIfIndex
    );

VOID
ChangeAdapterIndexForDodRoutes (
    DWORD    dwInterfaceIndex
    );

VOID
AddAutomaticRoutes(
    PICB    picb,
    DWORD   dwAddress,
    DWORD   dwMask
    );

VOID
DeleteAutomaticRoutes(
    PICB    picb,
    DWORD   dwAddress,
    DWORD   dwMask
    );

VOID
ChangeDefaultRouteMetrics(
    IN  BOOL    bIncrement
    );

VOID
AddAllStackRoutes(
    PICB    pIcb
    );

VOID
UpdateDefaultRoutes(
    VOID
    );

NTSTATUS
PostIoctlForRouteChangeNotification(
    ULONG
    );

DWORD
HandleRouteChangeNotification(
    ULONG
    );

VOID
AddLoopbackRoute(
    DWORD       dwIfAddress,
    DWORD       dwIfMask
    );

VOID
UpdateStackRoutesToRestoreList(
    IN  PMIB_IPFORWARDROW   pirf,
    IN  DWORD               dwFlags
    );

BOOL
LookupStackRoutesToRestoreList(
    IN  PMIB_IPFORWARDROW   pmibRoute,
    OUT PROUTE_LIST_ENTRY   *pRoute
    );

#endif // __RTRMGR_ROUTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\proto.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\proto.h

Abstract:

    IP Router Manager code prototypes

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/


#ifndef __PROTO_H__
#define __PROTO_H__

//* INIT.C
//
DWORD InitRouter(PRTR_INFO_BLOCK_HEADER pGlobalHdr);
DWORD LoadRoutingProtocols (PRTR_INFO_BLOCK_HEADER pGlobalHdr);
DWORD InitializeMibHandler();
DWORD OpenIPDriver();
DWORD StartDriverAndOpenHandle(PCHAR pszName, PWCHAR  pwszDriverName, PHANDLE phDevice);
DWORD OpenFilterDriver();
DWORD OpenMulticastDriver(VOID);
DWORD EnableNetbtBcastForwarding( DWORD dwEnable );
DWORD RestoreNetbtBcastForwardingMode();
DWORD ForceNetbtRegistryRead();

//
// CLOSE.C
//

VOID  RouterManagerCleanup();
VOID  UnloadRoutingProtocols() ;
VOID  CloseIPDriver();
DWORD 
StopDriverAndCloseHandle(
    PCHAR   pszServiceName,
    HANDLE  hDevice
    );
VOID  CloseMcastDriver();
DWORD CloseFilterDriver();
VOID  MIBCleanup();


//* WORKER.C
//
DWORD WorkerThread (LPVOID pGlobalInfo) ;
DWORD ProcessSaveGlobalConfigInfo() ;
DWORD ProcessSaveInterfaceConfigInfo() ;
DWORD ProcessUpdateComplete (PPROTO_CB proutprot, UPDATE_COMPLETE_MESSAGE *updateresult) ;
DWORD ProcessRouterStopped() ;
VOID  WaitForAPIsToExitBeforeStopping() ;
DWORD QueueUpdateEvent (DWORD interfaceindex, DWORD result) ;


// PROTODLL.C
//
DWORD HandleRoutingProtocolNotification () ;
VOID  NotifyRoutingProtocolsToStop() ;
BOOL  AllRoutingProtocolsStopped() ;

DWORD
LoadProtocol(
    IN MPR_PROTOCOL_0  *pmpProtocolInfo,
    IN PPROTO_CB       pProtocolCb,
    IN PVOID           pvInfo,
    IN ULONG           ulGlobalInfoVersion,
    IN ULONG           ulGlobalInfoSize,
    IN ULONG           ulGlobalInfoCount
    );

VOID  RemoveProtocolFromAllInterfaces(PPROTO_CB  pProtocolCB);
DWORD  StopRoutingProtocol(PPROTO_CB  pProtocolCB);

//* RTMOPS.C
//

DWORD
RtmEventCallback (
     IN     RTM_ENTITY_HANDLE               hRtmHandle,
     IN     RTM_EVENT_TYPE                  retEvent,
     IN     PVOID                           pContext1,
     IN     PVOID                           pContext2
     );

DWORD
WINAPI
ProcessDefaultRouteChanges(
    IN      HANDLE                          hNotifyHandle
    );

DWORD
WINAPI
AddNetmgmtDefaultRoutesToForwarder(
    PRTM_DEST_INFO                          pDestInfo
    );

DWORD
WINAPI
ProcessChanges (
    IN     HANDLE                           hNotifyHandle
    );

DWORD 
AddRtmRoute (
    IN      HANDLE                          hRtmHandle,
    IN      PINTERFACE_ROUTE_INFO           pIpForw,
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwNextHopMask,
    IN      DWORD                           dwTimeToLive,
    OUT     HANDLE                         *phRtmRoute
    );

DWORD 
DeleteRtmRoute (
    IN      HANDLE                          hRtmHandle,
    IN      PINTERFACE_ROUTE_INFO           pIpForw
    );

DWORD
ConvertRouteInfoToRtm (
    IN      HANDLE                          hRtmHandle,
    IN      PINTERFACE_ROUTE_INFO           pIpForw, 
    IN      HANDLE                          hNextHopHandle,
    IN      DWORD                           dwRouteFlags,
    OUT     PRTM_NET_ADDRESS                pDestAddr,
    OUT     PRTM_ROUTE_INFO                 pRouteInfo
    );

VOID
ConvertRtmToRouteInfo (
    IN      DWORD                           ownerProtocol,
    IN      PRTM_NET_ADDRESS                pDestAddr,
    IN      PRTM_ROUTE_INFO                 pRoute,
    IN      PRTM_NEXTHOP_INFO               pNextHop,
    OUT     PINTERFACE_ROUTE_INFO           pIpForw
    );

PINTERFACE_ROUTE_INFO
ConvertMibRouteToRouteInfo(
    IN  PMIB_IPFORWARDROW pMibRow
    );

//#define ConvertRouteInfoToMibRoute(x) ((PMIB_IPFORWARDROW)(x))
PMIB_IPFORWARDROW
ConvertRouteInfoToMibRoute(
    IN  PINTERFACE_ROUTE_INFO pRouteInfo
    );

VOID
ConvertRouteNotifyOutputToRouteInfo(
    IN      PIPRouteNotifyOutput            pirno,
    OUT     PINTERFACE_ROUTE_INFO           pRtInfo
    );
    

DWORD
BlockConvertRoutesToStatic (
    IN      HANDLE                          hRtmHandle,
    IN      DWORD                           dwIfIndex,
    IN      DWORD                           dwProtocolId
    );


DWORD
DeleteRtmRoutes (
    IN      HANDLE                          ClientHandle,
    IN      DWORD                           dwIfIndex,
    IN      BOOL                            fDeleteAll
    );

#define DeleteRtmRoutesOnInterface(h, i)    DeleteRtmRoutes(h, i, FALSE)


DWORD
DeleteRtmNexthops (
    IN      HANDLE                          hRtmHandle,
    IN      DWORD                           dwIfIndex,
    IN      BOOL                            fDeleteAll
    );

#define DeleteRtmNexthopsOnInterface(h, i)  DeleteRtmNexthops(h, i, FALSE)

//* RTMIF.C
//
VOID IPRouteChange (DWORD Flags, PVOID CurBestRoute, PVOID PrevBestRoute) ;
INT  IPHash (PVOID Net) ;
BOOL IPCompareFamilySpecificData (PVOID Route1, PVOID Route2) ;
INT  IPCompareNextHopAddress (PVOID Route1, PVOID Route2) ;
INT  IPCompareNetworks (PVOID Net1, PVOID Net2) ;
INT  IPCompareMetrics(PVOID Route1, PVOID Route2);
DWORD IPValidateRoute(PVOID Route);

DWORD 
ChangeRouteWithForwarder(
    IN      PRTM_NET_ADDRESS                pDestAddr,
    IN      PRTM_ROUTE_INFO                 pRoute, 
    IN      BOOL                            bAddRoute,
    IN      BOOL                            bDelOld
    );

DWORD
WINAPI
ValidateRouteForProtocol(
    IN      DWORD                           dwProtoId,
    IN      PVOID                           pRouteInfo,
    IN      PVOID                           pDestAddr  OPTIONAL
    );
    
DWORD
WINAPI
ValidateRouteForProtocolEx(
    IN      DWORD                           dwProtoId,
    IN      PVOID                           pRouteInfo,
    IN      PVOID                           pDestAddr  OPTIONAL
    );

// Load.c Functions that load the caches from the stack or elsewhere

DWORD LoadIpAddrTable(VOID);
DWORD LoadIpForwardTable(VOID);
DWORD LoadIpNetTable(VOID);
DWORD LoadTcpTable(VOID);
DWORD LoadUdpTable(VOID);
DWORD LoadArpEntTable(VOID);


LONG  UdpCmp(DWORD dwAddr1, DWORD dwPort1, DWORD dwAddr2, DWORD dwPort2);
LONG  TcpCmp(DWORD dwLocalAddr1, DWORD dwLocalPort1, DWORD dwRemAddr1, DWORD dwRemPort1,
             DWORD dwLocalAddr2, DWORD dwLocalPort2, DWORD dwRemAddr2, DWORD dwRemPort2);
LONG  IpForwardCmp(DWORD dwIpDest1, DWORD dwProto1, DWORD dwPolicy1, 
                   DWORD dwIpNextHop1, DWORD dwIpDest2, DWORD dwProto2, 
                   DWORD dwPolicy2, DWORD dwIpNextHop2);
LONG  IpNetCmp(DWORD dwIfIndex1, DWORD dwAddr1, DWORD dwIfIndex2, DWORD dwAddr2);

PSZ   CacheToA(DWORD dwCache);
DWORD UpdateCache(DWORD dwCache,BOOL *fUpdate);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\protodll.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\routing\ip\rtrmgr\protodll.c

Abstract:
    Routines for managing protocol DLLs

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/

#include "allinc.h"


DWORD
LoadProtocol(
    IN MPR_PROTOCOL_0  *pmpProtocolInfo,
    IN PPROTO_CB       pProtocolCb,
    IN PVOID           pvInfo,
    IN ULONG           ulStructureVersion,
    IN ULONG           ulStructureSize,
    IN ULONG           ulStructureCount
    )

/*++

Routine Description:

    Loads the DLL for a routing protocol. Initializes the entry points in 
    the CB

Locks:

      
Arguments:

    pszDllName      Name of DLL of the routing protocol
    pProtocolCb     Pointer to CB to hold info for this protocol
    pGlobalInfo     GlobalInfo (from which the info for this protocol is 
                    extracted)
      
Return Value:

    NO_ERROR or some error code

--*/

{
    DWORD           dwResult,dwNumStructs, dwSupport;
    PVOID           pInfo;
    HINSTANCE       hModule;
    PRTR_TOC_ENTRY  pToc;

    PREGISTER_PROTOCOL          pfnRegisterProtocol;
    MPR_ROUTING_CHARACTERISTICS mrcRouting;
    MPR_SERVICE_CHARACTERISTICS mscService;

    TraceEnter("LoadProtocol");
    
    Trace1(GLOBAL,
           "LoadProtocol: Loading %S",
           pmpProtocolInfo->wszProtocol); 

#if IA64
    if ( pmpProtocolInfo-> dwProtocolId == PROTO_IP_OSPF )
    {
        Trace1(
            ERR,
            "Protocol %S not supported on 64 bit",
            pmpProtocolInfo-> wszProtocol
            );

        return ERROR_NOT_SUPPORTED;
    }

#endif 


    //
    // Loading all entrypoints
    //
    
    hModule = LoadLibraryW(pmpProtocolInfo->wszDLLName);
    
    if(hModule is NULL) 
    {
        dwResult = GetLastError();

        Trace2(ERR, "LoadProtocol: %S failed to load: %d\n", 
               pmpProtocolInfo->wszDLLName,
               dwResult);

        return dwResult;
    }
        
    pProtocolCb->hiHInstance  = hModule;
    pProtocolCb->dwProtocolId = pmpProtocolInfo->dwProtocolId;

    pfnRegisterProtocol = NULL;

    pfnRegisterProtocol =
        (PREGISTER_PROTOCOL)GetProcAddress(hModule,
                                           REGISTER_PROTOCOL_ENTRY_POINT_STRING);

    if(pfnRegisterProtocol is NULL)
    {
        //
        // Could not find the RegisterProtocol entry point
        // Nothing we can do - bail out
        //

        Sleep(0);
        
        FreeLibrary(hModule);

        Trace1(ERR, "LoadProtocol: Could not find RegisterProtocol for %S", 
               pmpProtocolInfo->wszDLLName);

        return ERROR_INVALID_FUNCTION;
    }
        
    //
    // Give a chance for the protocol to register itself
    //

    //
    // Zero out the memory so that protocols with older versions
    // still work
    //

    ZeroMemory(&mrcRouting,
               sizeof(MPR_ROUTING_CHARACTERISTICS));

    mrcRouting.dwVersion                = MS_ROUTER_VERSION;
    mrcRouting.dwProtocolId             = pmpProtocolInfo->dwProtocolId;

#define __CURRENT_FUNCTIONALITY         \
            RF_ROUTING |                \
            RF_DEMAND_UPDATE_ROUTES |   \
            RF_ADD_ALL_INTERFACES |     \
            RF_MULTICAST |              \
            RF_POWER

    mrcRouting.fSupportedFunctionality  = (__CURRENT_FUNCTIONALITY);

    //
    // We dont support any service related stuff
    //

    mscService.dwVersion                = MS_ROUTER_VERSION;
    mscService.dwProtocolId             = pmpProtocolInfo->dwProtocolId;
    mscService.fSupportedFunctionality  = 0;

    dwResult = pfnRegisterProtocol(&mrcRouting,
                                   &mscService);

    if(dwResult isnot NO_ERROR)
    {
        Sleep(0);
        
        FreeLibrary(hModule);

        pProtocolCb->hiHInstance = NULL;
        
        Trace2(ERR, "LoadProtocol: %S returned error %d while registering", 
               pmpProtocolInfo->wszDLLName,
               dwResult);

        return dwResult;
    }

    if(mrcRouting.dwVersion > MS_ROUTER_VERSION)
    {
        Trace3(ERR,
               "LoadProtocol: %S registered with version 0x%x. Our version is 0x%x\n", 
               pmpProtocolInfo->wszProtocol,
               mrcRouting.dwVersion,
               MS_ROUTER_VERSION);

        //
        // relenquish CPU to enable DLL threads to finish
        //

        Sleep(0);

        FreeLibrary(hModule);

        return ERROR_CAN_NOT_COMPLETE;
    }
    
    if(mrcRouting.dwProtocolId isnot pmpProtocolInfo->dwProtocolId)
    {
        //
        // protocol tried to change IDs on us
        //

        Trace3(ERR,
               "LoadProtocol: %S returned ID of %x when it should be %x",
               pmpProtocolInfo->wszProtocol,
               mrcRouting.dwProtocolId,
               pmpProtocolInfo->dwProtocolId);

        Sleep(0);

        FreeLibrary(hModule);

        return ERROR_CAN_NOT_COMPLETE;
    }


    if(mrcRouting.fSupportedFunctionality & ~(__CURRENT_FUNCTIONALITY))
    {
        //
        // Hmm, some functionality that we dont understand
        //

        Trace3(ERR,
               "LoadProtocol: %S wanted functionalitf %x when we have %x",
               pmpProtocolInfo->wszProtocol,
               mrcRouting.fSupportedFunctionality,
               (__CURRENT_FUNCTIONALITY));

        Sleep(0);

        FreeLibrary(hModule);

        return ERROR_CAN_NOT_COMPLETE;
    }

#undef __CURRENT_FUNCTIONALITY

    if(!(mrcRouting.fSupportedFunctionality & RF_ROUTING))
    {
        Trace1(ERR, 
               "LoadProtocol: %S doesnt support routing", 
               pmpProtocolInfo->wszProtocol);

        //
        // relenquish CPU to enable DLL threads to finish
        //
        
        Sleep(0);
        
        FreeLibrary(hModule);

        return ERROR_CAN_NOT_COMPLETE;
    }

    pProtocolCb->fSupportedFunctionality = mrcRouting.fSupportedFunctionality;

    pProtocolCb->pfnStartProtocol   = mrcRouting.pfnStartProtocol;
    pProtocolCb->pfnStartComplete   = mrcRouting.pfnStartComplete;
    pProtocolCb->pfnStopProtocol    = mrcRouting.pfnStopProtocol;
    pProtocolCb->pfnGetGlobalInfo   = mrcRouting.pfnGetGlobalInfo;
    pProtocolCb->pfnSetGlobalInfo   = mrcRouting.pfnSetGlobalInfo;
    pProtocolCb->pfnQueryPower      = mrcRouting.pfnQueryPower;
    pProtocolCb->pfnSetPower        = mrcRouting.pfnSetPower;

    pProtocolCb->pfnAddInterface      = mrcRouting.pfnAddInterface;
    pProtocolCb->pfnDeleteInterface   = mrcRouting.pfnDeleteInterface;
    pProtocolCb->pfnInterfaceStatus   = mrcRouting.pfnInterfaceStatus;
    pProtocolCb->pfnGetInterfaceInfo  = mrcRouting.pfnGetInterfaceInfo;
    pProtocolCb->pfnSetInterfaceInfo  = mrcRouting.pfnSetInterfaceInfo;

    pProtocolCb->pfnGetEventMessage   = mrcRouting.pfnGetEventMessage;

    pProtocolCb->pfnUpdateRoutes      = mrcRouting.pfnUpdateRoutes;

    pProtocolCb->pfnConnectClient     = mrcRouting.pfnConnectClient;
    pProtocolCb->pfnDisconnectClient  = mrcRouting.pfnDisconnectClient;

    pProtocolCb->pfnGetNeighbors      = mrcRouting.pfnGetNeighbors;
    pProtocolCb->pfnGetMfeStatus      = mrcRouting.pfnGetMfeStatus;

    pProtocolCb->pfnMibCreateEntry    = mrcRouting.pfnMibCreateEntry;
    pProtocolCb->pfnMibDeleteEntry    = mrcRouting.pfnMibDeleteEntry;
    pProtocolCb->pfnMibGetEntry       = mrcRouting.pfnMibGetEntry;
    pProtocolCb->pfnMibSetEntry       = mrcRouting.pfnMibSetEntry;
    pProtocolCb->pfnMibGetFirstEntry  = mrcRouting.pfnMibGetFirstEntry;
    pProtocolCb->pfnMibGetNextEntry   = mrcRouting.pfnMibGetNextEntry;



    if(!(pProtocolCb->pfnStartProtocol) or
       !(pProtocolCb->pfnStartComplete) or
       !(pProtocolCb->pfnStopProtocol) or
       !(pProtocolCb->pfnGetGlobalInfo) or
       !(pProtocolCb->pfnSetGlobalInfo) or
    //   !(pProtocolCb->pfnQueryPower) or
    //   !(pProtocolCb->pfnSetPower) or
       !(pProtocolCb->pfnAddInterface) or
       !(pProtocolCb->pfnDeleteInterface) or
       !(pProtocolCb->pfnInterfaceStatus) or
       !(pProtocolCb->pfnGetInterfaceInfo) or
       !(pProtocolCb->pfnSetInterfaceInfo) or
       !(pProtocolCb->pfnGetEventMessage) or
    //   !(pProtocolCb->pfnConnectClient) or
    //   !(pProtocolCb->pfnDisconnectClient) or
    //   !(pProtocolCb->pfnGetNeighbors) or
    //   !(pProtocolCb->pfnGetMfeStatus) or
       !(pProtocolCb->pfnMibCreateEntry) or
       !(pProtocolCb->pfnMibDeleteEntry) or
       !(pProtocolCb->pfnMibGetEntry) or
       !(pProtocolCb->pfnMibSetEntry) or
       !(pProtocolCb->pfnMibGetFirstEntry) or
       !(pProtocolCb->pfnMibGetNextEntry))
    {
        Trace1(ERR, 
               "LoadProtocol: %S failed to provide atleast one entrypoint\n", 
               pmpProtocolInfo->wszProtocol);

        //
        // relenquish CPU to enable DLL threads to finish
        //
        
        Sleep(0);
        
        FreeLibrary(hModule);

        pProtocolCb->hiHInstance = NULL;
        
        return ERROR_CAN_NOT_COMPLETE;
    }

    if(mrcRouting.fSupportedFunctionality & RF_DEMAND_UPDATE_ROUTES)
    {
        if(!pProtocolCb->pfnUpdateRoutes)
        {
            Trace1(ERR, 
                   "LoadProtocol: %S supports DEMAND but has no entry point", 
                   pmpProtocolInfo->wszProtocol);

            //
            // relenquish CPU to enable DLL threads to finish
            //
        
            Sleep(0);
        
            FreeLibrary(hModule);

            pProtocolCb->hiHInstance = NULL;
        
            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    if(mrcRouting.fSupportedFunctionality & RF_MULTICAST)
    {
        DWORD   dwType;

        //
        // Make sure it has a good ID
        //

        dwType = TYPE_FROM_PROTO_ID(mrcRouting.dwProtocolId);

        if(dwType isnot PROTO_TYPE_MCAST)
        {
           Trace2(ERR,
                  "LoadProtocol: %S supports MCAST but has an id of %x",
                  pmpProtocolInfo->wszProtocol,
                  mrcRouting.dwProtocolId);

           //
           // relenquish CPU to enable DLL threads to finish
           //

           Sleep(0);

           FreeLibrary(hModule);

           pProtocolCb->hiHInstance = NULL;

           return ERROR_CAN_NOT_COMPLETE;
        }
    }

    pProtocolCb->pwszDllName = (PWCHAR)((PBYTE)pProtocolCb + sizeof(PROTO_CB));
                
    CopyMemory(pProtocolCb->pwszDllName,
               pmpProtocolInfo->wszDLLName,
               (wcslen(pmpProtocolInfo->wszDLLName) * sizeof(WCHAR))) ;

    pProtocolCb->pwszDllName[wcslen(pmpProtocolInfo->wszDLLName)] = 
        UNICODE_NULL;
    
    //
    // The memory for display name starts after the DLL name storage
    //
    
    pProtocolCb->pwszDisplayName = 
        &(pProtocolCb->pwszDllName[wcslen(pmpProtocolInfo->wszDLLName) + 1]);
                
    CopyMemory(pProtocolCb->pwszDisplayName,
               pmpProtocolInfo->wszProtocol,
               (wcslen(pmpProtocolInfo->wszProtocol) * sizeof(WCHAR))) ;
    
    pProtocolCb->pwszDisplayName[wcslen(pmpProtocolInfo->wszProtocol)] = 
        UNICODE_NULL;


    dwResult = (pProtocolCb->pfnStartProtocol)(g_hRoutingProtocolEvent, 
                                               &g_sfnDimFunctions,
                                               pvInfo,
                                               ulStructureVersion,
                                               ulStructureSize,
                                               ulStructureCount);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR, 
               "LoadProtocol: %S failed to start: %d\n", 
               pmpProtocolInfo->wszProtocol,
               dwResult);

        //
        // relenquish CPU to enable DLL threads to finish
        //
        
        Sleep(0);
        
        FreeLibrary(hModule);

        return dwResult;
    } 

    Trace1(GLOBAL,
           "LoadProtocol: Loaded %S successfully",
           pmpProtocolInfo->wszProtocol);
    
    return NO_ERROR;
}

DWORD
HandleRoutingProtocolNotification(
    VOID
    )

/*++

Routine Description:     

    For all routing protocol initiated events - this routine calls the
    routing protocol to service the event.

Locks:


Arguments:

    None

Return Value:

    NO_ERROR or some error code

--*/

{
    ROUTING_PROTOCOL_EVENTS               routprotevent ;
    MESSAGE             result ;
    PPROTO_CB  protptr ;
    PLIST_ENTRY         currentlist ;

    TraceEnter("HandleRoutingProtocolNotification");

    //
    // We take the ICBListLock because we want to enforce the discipline of 
    // taking the ICB lock before the RoutingProtocol lock if both need to 
    // be taken. 
    // This is to avoid deadlocks.
    //
    
    //
    // TBD: Avoid calling out from our DLL while holding the locks exclusively
    //
    
    // *** Exclusion Begin ***
    ENTER_WRITER(ICB_LIST);

    // *** Exclusion Begin ***
    ENTER_WRITER(PROTOCOL_CB_LIST);
    
    currentlist = g_leProtoCbList.Flink;
    
    while(currentlist != &g_leProtoCbList)
    {
        protptr = CONTAINING_RECORD (currentlist, PROTO_CB, leList) ;
	
        //
        // drain all messages for this protocol
        //
        
        while ((protptr->pfnGetEventMessage) (&routprotevent, &result) == NO_ERROR) 
        {
            switch (routprotevent)  
            {
                case SAVE_GLOBAL_CONFIG_INFO:

                    ProcessSaveGlobalConfigInfo() ;
                    break ;
                
                case SAVE_INTERFACE_CONFIG_INFO:
                
                    ProcessSaveInterfaceConfigInfo (result.InterfaceIndex) ;
                    break ;
                
                case UPDATE_COMPLETE:
                
                    ProcessUpdateComplete(protptr, 
                                          &result.UpdateCompleteMessage) ;
                    break ;
                
                case ROUTER_STOPPED:
                
                    protptr->posOpState = RTR_STATE_STOPPED ;
                    break ;
                
                default:

                    // no event raised for this protocol.
                    break;
            }
        }
        
        //
        // Move to the next item before freeing this one. The most common 
        // error in the book
        //
        
        currentlist = currentlist->Flink;
        
        if(protptr->posOpState is RTR_STATE_STOPPED)
        {
            //
            // Something happened that caused the stopping of the protocol
            //
            
            RemoveProtocolFromAllInterfaces(protptr);
                
            //
            // relenquish CPU to enable DLL threads to finish
            //
        
            Sleep(0);
        
            FreeLibrary(protptr->hiHInstance);
            
            //
            // Move to the next entry before freeing this entry
            //
            
            RemoveEntryList(&(protptr->leList));
            
            HeapFree(IPRouterHeap, 
                     0, 
                     protptr);
            
            TotalRoutingProtocols--;
        }
    }

    // *** Exclusion End ***
    EXIT_LOCK(PROTOCOL_CB_LIST);

    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);

    return NO_ERROR;
}

VOID
NotifyRoutingProtocolsToStop(
    VOID
    )

/*++

Routine Description:

    Notifies routing protocols to stop

Locks:

    Must be called with the ICB_LIST lock held as READER and PROTOCOL_CB_LIST
    held as WRITER
      
Arguments:

    None

Return Value:

    None

--*/

{
    PLIST_ENTRY currentlist ;
    PPROTO_CB  protptr ;
    DWORD       dwResult;
    
    TraceEnter("NotifyRoutingProtocolsToStop");

    //
    // Go thru the routing protocol list and call stopprotocol() for each 
    // of them
    //
    
    currentlist = g_leProtoCbList.Flink; 
    
    while(currentlist isnot &g_leProtoCbList)
    {
        protptr = CONTAINING_RECORD (currentlist, PROTO_CB, leList) ;
        
        if((protptr->posOpState is RTR_STATE_STOPPING) or
           (protptr->posOpState is RTR_STATE_STOPPED))
        {
            //
            // If its stopped or stopping, we dont tell it again
            //
            
            continue;
        }
        
        dwResult = StopRoutingProtocol(protptr);
        
        currentlist = currentlist->Flink;
        
        if(dwResult is NO_ERROR)
        {
            //
            // The routing protocol stopped synchronously and all references
            // to it in the interfaces have been removed
            //
            
            //
            // relenquish CPU to enable DLL threads to finish
            //
        
            Sleep(0);
        
            FreeLibrary(protptr->hiHInstance);
            
            RemoveEntryList(&(protptr->leList));
            
            HeapFree(IPRouterHeap, 
                     0, 
                     protptr);
            
            TotalRoutingProtocols--;
        }
    }
}

DWORD
StopRoutingProtocol(
    PPROTO_CB  pProtocolCB
    )

/*++

Routine Description:

    Stops a routing protocol

Arguments:

    pProtocolCB      The CB of the routing protocol to stop

Locks:



Return Value:

    NO_ERROR                     If the routing protocol stopped synchronously
    ERROR_PROTOCOL_STOP_PENDING  If the protocol is stopping asynchronously
    other WIN32 code

--*/ 

{
    DWORD dwResult;

    TraceEnter("StopRoutingProtocol");
    
    Trace1(GLOBAL,
           "StopRoutingProtocol: Stopping %S",
           pProtocolCB->pwszDllName);

    RemoveProtocolFromAllInterfaces(pProtocolCB);
    
    dwResult = (pProtocolCB->pfnStopProtocol)();
        
    if(dwResult is ERROR_PROTOCOL_STOP_PENDING)
    {
        //
        // If the protocol stops asynchronously then we dont do any clean up
        // right now. We it signals us that it has stopped, we will do the
        // necessary clean up
        //
        
        Trace1(GLOBAL,
               "StopRoutingProtocol: %S will stop asynchronously",
               pProtocolCB->pwszDllName);
        
        pProtocolCB->posOpState = RTR_STATE_STOPPING;
    }
    else
    {
        if(dwResult is NO_ERROR)
        {
            //
            // Great. So it stopped synchronously.
            //
            
            Trace1(GLOBAL,
                   "StopRoutingProtocol: %S stopped synchronously",
                   pProtocolCB->pwszDllName);
    
            pProtocolCB->posOpState = RTR_STATE_STOPPED ;
        }
        else
        {
            //
            // This is not good. Routing Protocol couldnt stop
            //
            
            Trace2(ERR,
                   "StopRoutingProtocol: %S returned error %d on calling StopProtocol().",
                   pProtocolCB->pwszDllName,
                   dwResult);
        }
    }

    return dwResult;
}

VOID
RemoveProtocolFromAllInterfaces(
    PPROTO_CB  pProtocolCB
    )

/*++

Routine Description:

    Each interface keeps a list of the protocols that are running on it. 
    This removes the given protocol from all the interfaces list

Locks:


Arguments:

    pProtocolCB      The CB of the routing protocol to remove

Return Value:

    None

--*/

{
    
    PLIST_ENTRY pleIfNode,pleProtoNode;
    PICB        pIcb;
    PIF_PROTO   pProto;

    TraceEnter("RemoveProtocolFromAllInterfaces");
    
    Trace1(GLOBAL,
           "RemoveProtocolFromAllInterfaces: Removing %S from all interfaces",
           pProtocolCB->pwszDllName);
    
    //
    // For each interface, we go through the list of protocols it is active
    // over. If the interface had been active over this protocol, we remove the
    // entry from the i/f's list
    //
    
    for(pleIfNode = ICBList.Flink;
        pleIfNode isnot &ICBList;
        pleIfNode = pleIfNode->Flink)
    {
        pIcb = CONTAINING_RECORD(pleIfNode, ICB, leIfLink);
        
        pleProtoNode = pIcb->leProtocolList.Flink;
        
        while(pleProtoNode isnot &(pIcb->leProtocolList))
        {
            pProto = CONTAINING_RECORD(pleProtoNode,IF_PROTO,leIfProtoLink);
            
            pleProtoNode = pleProtoNode->Flink;

            if(pProto->pActiveProto is pProtocolCB)
            {
                Trace2(GLOBAL,
                       "RemoveProtocolFromAllInterfaces: Removing %S from %S",
                       pProtocolCB->pwszDllName,
                       pIcb->pwszName);
               
                //
                // call the delete interface entry point
                //

                (pProto->pActiveProto->pfnDeleteInterface) (pIcb->dwIfIndex);
 
                RemoveEntryList(&(pProto->leIfProtoLink));
                
                break;
            }
        }
    }

}


BOOL
AllRoutingProtocolsStopped(
    VOID
    )

/*++

Routine Description:

    Walks thru all routing protocols to see if all have operational state 
    of STOPPED.

Locks:



Arguments:

    None

Return Value:

    TRUE if all stopped, otherwise FALSE

--*/

{
    DWORD       routprotevent ;
    PPROTO_CB  protptr ;
    PLIST_ENTRY  currentlist ;

    TraceEnter("AllRoutingProtocolsStopped");

    for (currentlist = g_leProtoCbList.Flink; 
         currentlist != &g_leProtoCbList; 
         currentlist = currentlist->Flink) 
    {
        
        protptr = CONTAINING_RECORD (currentlist, PROTO_CB, leList) ;

        if (protptr->posOpState != RTR_STATE_STOPPED)
        {
            Trace1(GLOBAL,
                   "AllRoutingProtocolsStopped: %S has not stopped as yet",
                   protptr->pwszDllName);
            
            return FALSE;
        }
    }

    return TRUE ;
}

DWORD
ProcessUpdateComplete (
    PPROTO_CB       proutprot, 
    UPDATE_COMPLETE_MESSAGE  *updateresult
    )
{
    PLIST_ENTRY  currentlist ;
    LPHANDLE     hDIMEventToSignal = NULL;
    PICB pIcb ;
    UpdateResultList *pupdateresultlist ;
    
    TraceEnter("ProcessUpdateComplete");
    
    //
    // If update is successful convert the protocol's routes to static routes.
    //
    
    if (updateresult->UpdateStatus == NO_ERROR)
    {
        ConvertRoutesToAutoStatic(proutprot->dwProtocolId, 
                                  updateresult->InterfaceIndex);

    }
    
    //
    // Figure out which event to signal and where to queue the event
    //
    
    for (currentlist = ICBList.Flink;
         currentlist != &ICBList; 
         currentlist = currentlist->Flink) 
    {
        pIcb = CONTAINING_RECORD (currentlist, ICB, leIfLink);
      
        if (pIcb->dwIfIndex is updateresult->InterfaceIndex)
        {
            hDIMEventToSignal = pIcb->hDIMNotificationEvent;
            
            pIcb->hDIMNotificationEvent = NULL;

            if(hDIMEventToSignal is NULL)
            {
                Trace0(ERR, "ProcessUpdateComplete: No DIM event found in ICB - ERROR");

                return ERROR_CAN_NOT_COMPLETE;
            }
            
            //
            // Queue the update event
            //
            
            pupdateresultlist = HeapAlloc(IPRouterHeap, 
                                          HEAP_ZERO_MEMORY, 
                                          sizeof(UpdateResultList));
           
            if(pupdateresultlist is NULL)
            {
                Trace1(ERR,
                       "ProcessUpdateComplete: Error allocating %d bytes",
                       sizeof(UpdateResultList));

                SetEvent(hDIMEventToSignal);

                CloseHandle(hDIMEventToSignal);

                return ERROR_NOT_ENOUGH_MEMORY;
            }
 
            pupdateresultlist->URL_UpdateStatus = updateresult->UpdateStatus;
            
            InsertTailList(&pIcb->lePendingResultList, 
                           &pupdateresultlist->URL_List) ;
            
            //
            // Save the routes in the registry
            //
           
            ProcessSaveInterfaceConfigInfo(pIcb->dwIfIndex);

            Trace0(GLOBAL, 
                   "ProcessUpdateComplete: Notifying DIM of update route completion");
            
            if(!SetEvent(hDIMEventToSignal))
            {
                Trace2(ERR,
                       "ProcessUpdateComplete: Error %d setting event for notifying completion of update routes for %S",
                       proutprot->pwszDllName,  
                       GetLastError());

                CloseHandle(hDIMEventToSignal);
 
                return ERROR_CAN_NOT_COMPLETE;
            }

            CloseHandle(hDIMEventToSignal);

            return NO_ERROR;
        }

    }
    
    //
    // If you reach till here you didnt find the ICB
    //
    
    Trace1(ERR,
           "ProcessUpdateComplete: Couldnt find the ICB for interface %d",
           updateresult->InterfaceIndex);

    return ERROR_INVALID_PARAMETER;
}

DWORD
ProcessSaveInterfaceConfigInfo(
    DWORD dwInterfaceindex
    )
{
    PICB            pIcb ;
    DWORD           infosize;
    PVOID           pinfobuffer ;
    PLIST_ENTRY     currentlist ;
    BOOL            bFound = FALSE;
    DWORD           dwNumInFilters, dwNumOutFilters;
    
    TraceEnter("ProcessSaveInterfaceConfigInfo");

    //
    // find the if.
    //
    
    for (currentlist = ICBList.Flink;
         currentlist != &ICBList;
         currentlist = currentlist->Flink)
    {

        pIcb = CONTAINING_RECORD (currentlist, ICB, leIfLink);

        if (pIcb->dwIfIndex is dwInterfaceindex)
        {
            bFound = TRUE;
            
            break;
        }
    }

    if(!bFound)
    {
        Trace1(ERR,
               "ProcessSaveInterfaceConfigInfo: Couldnt find ICB for interface %d",
               dwInterfaceindex);

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Interface info
    //
    
    infosize = GetSizeOfInterfaceConfig(pIcb);

    pinfobuffer  = HeapAlloc(IPRouterHeap, 
                             HEAP_ZERO_MEMORY, 
                             infosize);

    if(pinfobuffer is NULL)
    {
        Trace0(
            ERR, "ProcessSaveInterfaceConfigInfo: failed to allocate buffer");

        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    GetInterfaceConfiguration(pIcb, 
                              pinfobuffer, 
                              infosize);


    EXIT_LOCK(PROTOCOL_CB_LIST);
    EXIT_LOCK(ICB_LIST);

    SaveInterfaceInfo(pIcb->hDIMHandle,
                      PID_IP,
                      pinfobuffer,
                      infosize );

    ENTER_WRITER(ICB_LIST);
    ENTER_WRITER(PROTOCOL_CB_LIST);

    HeapFree (IPRouterHeap, 0, pinfobuffer) ;

    return NO_ERROR;
}

DWORD
ProcessSaveGlobalConfigInfo(
    VOID
    )
{
    PRTR_INFO_BLOCK_HEADER  pInfoHdrAndBuffer;
    DWORD                   dwSize,dwResult;

    TraceEnter("ProcessSaveGlobalConfigInfo");
    
    dwSize = GetSizeOfGlobalInfo();  

    pInfoHdrAndBuffer = HeapAlloc(IPRouterHeap,
                                  HEAP_ZERO_MEMORY,
                                  dwSize);

    if(pInfoHdrAndBuffer is NULL) 
    {
        Trace1(ERR,
               "ProcessSaveGlobalConfigInfo: Error allocating %d bytes",
               dwSize);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    dwResult = GetGlobalConfiguration(pInfoHdrAndBuffer,
                                      dwSize);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "ProcessSaveGlobalConfigInfo: Error %d getting global configuration",
               dwResult);
    }
    else
    {

        EXIT_LOCK(PROTOCOL_CB_LIST);
        EXIT_LOCK(ICB_LIST);

        dwResult = SaveGlobalInfo(PID_IP,
                                  (PVOID)pInfoHdrAndBuffer,
                                  dwSize);

        ENTER_WRITER(ICB_LIST);
        ENTER_WRITER(PROTOCOL_CB_LIST);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "ProcessSaveGlobalConfigInfo: Error %d saving global information",
                   dwResult);
        }
    }
    
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\route.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\route.c

Abstract:
    All routes related code lives here.

Revision History:

    Gurdeep Singh Pall          6/15/95  Created

--*/

#include "allinc.h"

DWORD
WINAPI
GetBestRoute(
    IN  DWORD               dwDestAddr,
    IN  DWORD               dwSourceAddr, OPTIONAL
    OUT PMIB_IPFORWARDROW   pBestRoute
    );
    

DWORD
InitializeStaticRoutes(
    PICB                     pIcb, 
    PRTR_INFO_BLOCK_HEADER   pInfoHdr
    )

/*++

Routine Description:

    Adds static routes with RTM

Arguments:

    pIcb          The ICB of the interface for whom the routes are
    pInfoHdr      Pointer to info block containing IP_ROUTE_INFO

Return Value:

    NO_ERROR 

--*/

{
    DWORD               dwNumRoutes, dwResult;
    DWORD               i, j;
    PRTR_TOC_ENTRY      pToc;
    PINTERFACE_ROUTE_INFO   pRoutes;
    BOOL                bP2P;

    TraceEnter("IntializeStaticRoutes");
   
    //
    // If this is a client, only do the special client processing
    //

    if(pIcb->ritType is ROUTER_IF_TYPE_CLIENT)
    {
        CopyOutClientRoutes(pIcb,
                            pInfoHdr);
    
        return NO_ERROR;
    }
 
    //
    // We first go through the init route table and add any route going
    // over that interface that is
    //      (i)   not a local net route
    //      (ii)  not a subnet/net broadcast route
    //      (iii) not a Loopback route,
    //      (iv)  not a CLASS D or E route and not a 255.255.255.255 destination
    //      (vi)       a PROTO_IP_LOCAL or PROTO_IP_NETMGMT route
    //

    CheckBindingConsistency(pIcb);
   
    bP2P = IsIfP2P(pIcb->ritType);
 
    pToc = GetPointerToTocEntry(IP_ROUTE_INFO, 
                                pInfoHdr);
   
    if((pToc is NULL) or
       (pToc->InfoSize is 0))
    {
        Trace0(ROUTE,"IntializeStaticRoutes: No Routes found");
        
        TraceLeave("IntializeStaticRoutes");

        return NO_ERROR;
    }

    pRoutes = GetInfoFromTocEntry(pInfoHdr,
                                  pToc);

    if(pRoutes is NULL)
    {
        Trace0(ROUTE,"IntializeStaticRoutes: No Routes found");
        
        TraceLeave("IntializeStaticRoutes");

        return NO_ERROR;
    }

    dwNumRoutes = pToc->Count;
    
    for (i=0; i< dwNumRoutes; i++) 
    {
        DWORD dwMask;

        dwMask   = GetBestNextHopMaskGivenICB(pIcb,
                                              pRoutes[i].dwRtInfoNextHop);

        dwResult = AddSingleRoute(pIcb->dwIfIndex,
                                  (&pRoutes[i]),
                                  dwMask,
                                  0,     // RTM_ROUTE_INFO::Flags
                                  TRUE,  // Valid route
                                  TRUE,
                                  bP2P,
                                  NULL); // Add the route to stack, if need be

        if(dwResult isnot NO_ERROR)
        {
            Trace3(ERR,
                   "IntializeStaticRoutes: Error %d adding config route to %x over %S",
                   dwResult,
                   pRoutes[i].dwRtInfoDest,
                   pIcb->pwszName);
        }

    }
              
    TraceLeave("IntializeStaticRoutes");

    return NO_ERROR;
}

DWORD
CopyOutClientRoutes(
    PICB                     pIcb,
    PRTR_INFO_BLOCK_HEADER   pInfoHdr
    )

/*++

Routine Description:

    Stores a copy of the client static routes

Arguments:

    pIcb          The ICB of the interface for whom the routes are
    pInfoHdr      Pointer to info block containing IP_ROUTE_INFO

Return Value:

    NO_ERROR

--*/

{
    PINTERFACE_ROUTE_INFO   pRoutes;
    PINTERFACE_ROUTE_TABLE pStore;
    DWORD               i, dwNumRoutes;
    PRTR_TOC_ENTRY      pToc;

    pToc = GetPointerToTocEntry(IP_ROUTE_INFO,
                                pInfoHdr);

    if((pToc is NULL) or
       (pToc->InfoSize is 0))
    {
        return NO_ERROR;
    }

    pRoutes = GetInfoFromTocEntry(pInfoHdr,
                                  pToc);

    if (pRoutes is NULL)
    {
        return NO_ERROR;
    }
    
    dwNumRoutes = pToc->Count;

    if(dwNumRoutes is 0)
    {
        return NO_ERROR;
    }

    pStore = HeapAlloc(IPRouterHeap,
                       HEAP_ZERO_MEMORY,
                       SIZEOF_IPFORWARDTABLE(dwNumRoutes));

    if(pStore is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pStore->dwNumEntries = dwNumRoutes;

    for(i = 0; i < dwNumRoutes; i++)
    {
        pStore->table[i] = pRoutes[i];
    }

    pIcb->pStoredRoutes = pStore;

    return NO_ERROR;
}

    
DWORD
AddSingleRoute(
    DWORD                   dwIfIndex,
    PINTERFACE_ROUTE_INFO   pRtInfo,
    DWORD                   dwNextHopMask,
    WORD                    wRtmFlags,
    BOOL                    bValid,
    BOOL                    bAddToStack,
    BOOL                    bP2P,
    HANDLE                  *phRtmRoute OPTIONAL
    )

/*++

Routine Description

    Adds a route with RTM

Arguments

    pIcb          The ICB of the interface for whom the route is
    pIpForw       The route
    mask          Mask for destination

Return Value

    NO_ERROR or some code from RTM

--*/

{
    DWORD            i, dwResult, dwRouteFlags;
    HANDLE           hRtmHandle;
    DWORD            dwOldIfIndex;

    TraceEnter("AddSingleRoute");
   
    TraceRoute2(ROUTE,
            "route to %d.%d.%d.%d/%d.%d.%d.%d",
               PRINT_IPADDR(pRtInfo->dwRtInfoDest),
               PRINT_IPADDR(pRtInfo->dwRtInfoMask));

    TraceRoute4(ROUTE,
            "Flags 0x%x Valid %d Stack %d P2P %d",
            wRtmFlags, bValid, bAddToStack, bP2P
            );
            
    hRtmHandle = NULL;

    for(i = 0; 
        i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
        i++)
    {
        if(pRtInfo->dwRtInfoProto is g_rgRtmHandles[i].dwProtoId)
        {
            hRtmHandle = g_rgRtmHandles[i].hRouteHandle;

            break;
        }
    }

    if(hRtmHandle is NULL)
    {    
        Trace1(ERR,
               "AddSingleRoute: Protocol %d not valid",
               pRtInfo->dwRtInfoProto);

        return ERROR_INVALID_PARAMETER;
    }

    if((pRtInfo->dwRtInfoDest & pRtInfo->dwRtInfoMask) isnot pRtInfo->dwRtInfoDest)
    {
        Trace2(ERR,
               "AddSingleRoute: Dest %d.%d.%d.%d and Mask %d.%d.%d.%d wrong",
               PRINT_IPADDR(pRtInfo->dwRtInfoDest),
               PRINT_IPADDR(pRtInfo->dwRtInfoMask));

        TraceLeave("AddSingleRoute");

        return ERROR_INVALID_PARAMETER;
    }

    if((((DWORD)(pRtInfo->dwRtInfoDest & 0x000000FF)) >= (DWORD)0x000000E0) and
       (pRtInfo->dwRtInfoDest isnot ALL_ONES_BROADCAST) and
       (pRtInfo->dwRtInfoDest isnot LOCAL_NET_MULTICAST))
    {
        //
        // This will catch the CLASS D/E
        //

        Trace1(ERR,
               "AddSingleRoute: Dest %d.%d.%d.%d is invalid",
               PRINT_IPADDR(pRtInfo->dwRtInfoDest));

        TraceLeave("AddSingleRoute");

        return ERROR_INVALID_PARAMETER;
    }

    // Special case to deal with weird utilities (legacy UI, etc):

    if (pRtInfo->dwRtInfoViewSet is 0)
    {
        pRtInfo->dwRtInfoViewSet = RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST;
    }

#if 0
    // Removed this check since a metric of 0 is legal, for example for
    // routes to the loopback interface.

    if(pRtInfo->dwRtInfoMetric1 is 0)
    {
        Trace0(ERR,
               "AddSingleRoute: Metric1 cant be 0");

        TraceLeave("AddSingleRoute");

        return ERROR_INVALID_PARAMETER;
    }
#endif

    if(bP2P)
    {
        dwNextHopMask = ALL_ONES_MASK;

        //pRtInfo->dwRtInfoNextHop = 0;
    }

    //
    // The route might not have the right index since config routes dont know
    // their interface id
    //

    dwOldIfIndex = pRtInfo->dwRtInfoIfIndex;
    
    pRtInfo->dwRtInfoIfIndex = dwIfIndex;
    
    //
    // Set the appropritate route flags
    //
    
    dwRouteFlags = 0;
   
    if(bValid)
    {
        dwRouteFlags |= IP_VALID_ROUTE;
    }
 
    if(bAddToStack)
    {
        dwRouteFlags |= IP_STACK_ROUTE;
    }

    if(bP2P)
    {
        dwRouteFlags |= IP_P2P_ROUTE;
    }

    // these flags correspond to RTM_ROUTE_INFO::Flags
    dwRouteFlags |= (wRtmFlags << 16);
    
    //
    // Add the forward route with RTM
    //

    dwResult = AddRtmRoute(hRtmHandle,
                           pRtInfo,
                           dwRouteFlags,
                           dwNextHopMask,
                           INFINITE,
                           phRtmRoute);

    if (dwResult isnot NO_ERROR)
    {
        Trace1(ERR, "AddSingleRoute: Could not add route to: %x",
               pRtInfo->dwRtInfoDest) ;
    }

    pRtInfo->dwRtInfoIfIndex = dwOldIfIndex;

    TraceLeave("AddSingleRoute");
    
    return dwResult;
}

DWORD 
DeleteSingleRoute(
    DWORD   dwIfIndex,
    DWORD   dwDestAddr,
    DWORD   dwDestMask,
    DWORD   dwNexthop,
    DWORD   dwProtoId,
    BOOL    bP2P
    )

/*++

Routine Description:

    Deletes a single route from RTM

Arguments:

    InterfaceID   Index of the interface
    dest          Destination address
    nexthop       Next hop address

Return Value:

    NO_ERROR or some code from RTM

--*/

{
    DWORD            i, dwResult;
    HANDLE           hRtmHandle;
    INTERFACE_ROUTE_INFO RtInfo;

    TraceEnter("DeleteSingleRoute");
    
    TraceRoute2(
        ROUTE, "DeleteSingleRoute: %d.%d.%d.%d/%d.%d.%d.%d",
        PRINT_IPADDR( dwDestAddr ),
        PRINT_IPADDR( dwDestMask )
        );

    hRtmHandle = NULL;

    for(i = 0;
        i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
        i++)
    {
        if(dwProtoId is g_rgRtmHandles[i].dwProtoId)
        {
            hRtmHandle = g_rgRtmHandles[i].hRouteHandle;

            break;
        }
    }

    if(hRtmHandle is NULL)
    {
        Trace1(ERR,
               "DeleteSingleRoute: Protocol %d not valid",
               dwProtoId);

        return ERROR_INVALID_PARAMETER;
    }


    RtInfo.dwRtInfoNextHop = dwNexthop;

    /*
    if(bP2P)
    {
        RtInfo.dwRtInfoNextHop = 0;
    }
    else
    {
        RtInfo.dwRtInfoNextHop = dwNexthop;
    }
    */
    
    RtInfo.dwRtInfoDest     = dwDestAddr;
    RtInfo.dwRtInfoMask     = dwDestMask;
    RtInfo.dwRtInfoIfIndex  = dwIfIndex;
    RtInfo.dwRtInfoProto    = dwProtoId;

    //
    // Delete this forward route from RTM
    //

    dwResult = DeleteRtmRoute(hRtmHandle,
                              &RtInfo);
  
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "DeleteSingleRoute: Error %d deleting route in RTM.",
               dwResult);
    }

    TraceLeave("DeleteSingleRoute");
    
    return dwResult;
}

DWORD
DeleteAllRoutes(
    IN  DWORD   dwIfIndex,
    IN  BOOL    bStaticOnly
    )

/*++
  
Routine Description

    Deletes all the routes (owned by IP Router Manager) on the interface

Arguments

    dwIfIndex
    bStaticOnly

Return Value
  
    Error returned from RTM
    
--*/

{
    DWORD           i, dwResult = NO_ERROR;

    TraceEnter("DeleteAllRoutes");

    for(i = 0;
        i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
        i++)
    {
        if(bStaticOnly && !g_rgRtmHandles[i].bStatic)
        {
            continue;
        }

        dwResult = DeleteRtmRoutesOnInterface(g_rgRtmHandles[i].hRouteHandle,
                                              dwIfIndex);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "DeleteAllRoutes: BlockDeleteRoutes returned %d for %d",
                   dwResult,
                   g_rgRtmHandles[i].dwProtoId);

            continue;
        }

        dwResult = DeleteRtmNexthopsOnInterface(g_rgRtmHandles[i].hRouteHandle,
                                                dwIfIndex);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "DeleteAllRoutes: BlockDeleteNextHops returned %d for %d",
                   dwResult,
                   g_rgRtmHandles[i].dwProtoId);

            continue;
        }
    }

    TraceLeave("DeleteAllRoutes");

    return dwResult;
}

VOID
DeleteAllClientRoutes(
    PICB    pIcb,
    DWORD   dwServerIfIndex
    )

/*++

Routine Description

    Deletes all routes going to a client. Only needed for removal from
    RTM, stack removes them since the link has been deleted

Arguments

    pIcb
    dwServerIfIndex - ServerInterface's ifIndex

Return Value


--*/

{
    ULONG   i;

    TraceEnter("DeleteAllClientRoutes");

    IpRtAssert(pIcb->ritType is ROUTER_IF_TYPE_CLIENT);

    if((pIcb->pStoredRoutes is NULL) or
       (pIcb->pibBindings is NULL))
    {
        return; 
    }

    for(i = 0 ; i < pIcb->pStoredRoutes->dwNumEntries; i++)
    {
        DeleteSingleRoute(dwServerIfIndex,
                          pIcb->pStoredRoutes->table[i].dwRtInfoDest,
                          pIcb->pStoredRoutes->table[i].dwRtInfoMask,
                          pIcb->pibBindings[0].dwAddress,
                          PROTO_IP_NT_STATIC_NON_DOD,
                          FALSE);
    }
}

VOID
AddAllClientRoutes(
    PICB    pIcb,
    DWORD   dwServerIfIndex
    )

/*++

Routine Description

    Adds the stored routes over the server interface

Arguments

    pIcb
    dwServerIfIndex - ServerInterface's ifIndex

Return Value


--*/

{
    ULONG   i;

    TraceEnter("AddAllClientRoutes");

    IpRtAssert(pIcb->ritType is ROUTER_IF_TYPE_CLIENT);

    if((pIcb->pStoredRoutes is NULL) or
       (pIcb->pibBindings is NULL))
    {
        return;
    }

    for(i = 0; i < pIcb->pStoredRoutes->dwNumEntries; i++)
    {
        //
        // Fix the next hop since that is not known
        // Also fix someother fields which we know are not being set
        // correctly for client routes
        //

        pIcb->pStoredRoutes->table[i].dwRtInfoNextHop = 
            pIcb->pibBindings[0].dwAddress;

        pIcb->pStoredRoutes->table[i].dwRtInfoProto   = 
            PROTO_IP_NT_STATIC_NON_DOD;

        pIcb->pStoredRoutes->table[i].dwRtInfoMetric2 = 0;
        pIcb->pStoredRoutes->table[i].dwRtInfoMetric3 = 0;

        pIcb->pStoredRoutes->table[i].dwRtInfoPreference = 
                ComputeRouteMetric(MIB_IPPROTO_LOCAL);

        pIcb->pStoredRoutes->table[i].dwRtInfoViewSet    = 
                RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST;

        AddSingleRoute(dwServerIfIndex,
                       &(pIcb->pStoredRoutes->table[i]),
                       pIcb->pibBindings[0].dwMask,
                       0,       // RTM_ROUTE_INFO::Flags
                       TRUE,
                       TRUE,
                       FALSE,
                       NULL);
    }
}

DWORD
GetNumStaticRoutes(
    PICB pIcb
    )

/*++
  
Routine Description

    Figure out the number of static routes associated with an interface

Arguments

    pIcb          The ICB of the interface whose route count is needed

Return Value

    Number of routes associated with an interface
  
--*/

{
    HANDLE           hRtmHandle;
    HANDLE           hRtmEnum;
    PHANDLE          hRoutes;
    DWORD            dwHandles;
    DWORD            dwNumRoutes;
    DWORD            i, j;
    DWORD            dwResult;
    
    hRoutes = HeapAlloc(
                IPRouterHeap,
                0,
                g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                );

    if (hRoutes == NULL)
    {
        Trace1(ERR,
               "GetNumStaticRoutes: Error allocating %d bytes for "
               "handles\n",
               g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
               );

        return 0;
    }
    
    dwNumRoutes = 0;

    for(i = 0;
        i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
        i++)
    {
        if(!g_rgRtmHandles[i].bStatic)
        {
            continue;
        }

        hRtmHandle = g_rgRtmHandles[i].hRouteHandle;
        
        dwResult = RtmCreateRouteEnum(hRtmHandle,
                                      NULL,
                                      RTM_VIEW_MASK_UCAST|RTM_VIEW_MASK_MCAST,
                                      RTM_ENUM_OWN_ROUTES,
                                      NULL,
                                      RTM_MATCH_INTERFACE,
                                      NULL,
                                      pIcb->dwIfIndex,
                                      &hRtmEnum);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "GetNumStaticRoutes: Error %d creating handle for %d\n",
                   dwResult,
                   g_rgRtmHandles[i].dwProtoId);
            
            continue;
        }

        do
        {
            dwHandles = g_rtmProfile.MaxHandlesInEnum;
            
            dwResult = RtmGetEnumRoutes(hRtmHandle,
                                        hRtmEnum,
                                        &dwHandles,
                                        hRoutes);

            dwNumRoutes += dwHandles;

            RtmReleaseRoutes(hRtmHandle, dwHandles, hRoutes);
        }
        while (dwResult is NO_ERROR);

        RtmDeleteEnumHandle(hRtmHandle, hRtmEnum);
    }

    HeapFree(IPRouterHeap, 0, hRoutes);
    
    return dwNumRoutes;
}


DWORD
GetInterfaceRouteInfo(
    IN     PICB                   pIcb, 
    IN     PRTR_TOC_ENTRY         pToc, 
    IN     PBYTE                  pbDataPtr, 
    IN OUT PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwInfoSize
    )
/*++
  
Routine Description

    Gets the route info (static routes) associated with an interface

Arguments

    pIcb          The ICB of the interface for whom the info is requested
    pToc          Pointer to TOC for the total inforamtion
    pbDataPtr     Pointer to free space where info can be written
    pInfoHdr      Pointer to Info Hdr 
    pdwInfoSize   Size of free space

Return Value

    NO_ERROR or some code from RTM
    
--*/

{
    DWORD               dwNumRoutes;
    PINTERFACE_ROUTE_INFO  pRoutes = (PINTERFACE_ROUTE_INFO) pbDataPtr ;
    DWORD               dwMaxRoutes;

    TraceEnter("GetInterfaceRouteInfo");
    
    dwNumRoutes = GetNumStaticRoutes(pIcb);
   
    dwMaxRoutes = MAX_ROUTES_IN_BUFFER(*pdwInfoSize);
 
    if(dwNumRoutes > dwMaxRoutes)
    {
        *pdwInfoSize = SIZEOF_ROUTEINFO(dwNumRoutes);
        
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    dwNumRoutes     = ReadAllStaticRoutesIntoBuffer(pIcb,
                                                    pRoutes,
                                                    dwMaxRoutes);
    
    *pdwInfoSize    = SIZEOF_ROUTEINFO(dwNumRoutes);

    //pToc->InfoVersion  = sizeof(INTERFACE_ROUTE_INFO);
    pToc->InfoSize  = sizeof(INTERFACE_ROUTE_INFO);
    pToc->InfoType  = IP_ROUTE_INFO ;
    pToc->Count     = dwNumRoutes;
    pToc->Offset    = (ULONG)(pbDataPtr - (PBYTE) pInfoHdr) ;

    TraceLeave("GetInterfaceRouteInfo");
    
    return NO_ERROR;
}

DWORD
ReadAllStaticRoutesIntoBuffer(
    PICB                 pIcb, 
    PINTERFACE_ROUTE_INFO   pRoutes,
    DWORD                dwMaxRoutes
    )

/*++
  
Routine Description

    Reads out static routes from RTM

Arguments

    pIcb          The ICB of the interface for whom the route is
    routptr       Pointer to where info has to be written out
    dwMaxRoutes   Max routes the buffer can hold

Return Value

    Count of routes written out
    
--*/

{
    HANDLE           hRtmHandle;
    HANDLE           hRtmEnum;
    PHANDLE          hRoutes;
    PRTM_NET_ADDRESS pDestAddr;
    PRTM_ROUTE_INFO  pRoute;
    RTM_NEXTHOP_INFO nhiInfo;
    RTM_ENTITY_INFO  entityInfo;
    DWORD            dwNumRoutes;
    DWORD            dwHandles;
    DWORD            i, j;
    DWORD            dwResult;

    pRoute = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                );

    if (pRoute == NULL)
    {
        return 0;
    }
    
    hRoutes = HeapAlloc(
                IPRouterHeap,
                0,
                g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                );

    if (hRoutes == NULL)
    {
        HeapFree(IPRouterHeap, 0, pRoute);
        
        return 0;
    }

    pDestAddr = HeapAlloc(
                IPRouterHeap,
                0,
                sizeof(RTM_NET_ADDRESS)
                );

    if (pDestAddr == NULL)
    {
        HeapFree(IPRouterHeap, 0, pRoute);
        
        HeapFree(IPRouterHeap, 0, hRoutes);
        
        return 0;
    }

    dwNumRoutes = 0;

    for(i = 0;
        (i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO)) and
        (dwNumRoutes < dwMaxRoutes);
        i++)
    {
        if(!g_rgRtmHandles[i].bStatic)
        {
            continue;
        }

        hRtmHandle = g_rgRtmHandles[i].hRouteHandle;
        
        dwResult = RtmCreateRouteEnum(hRtmHandle,
                                      NULL,
                                      RTM_VIEW_MASK_UCAST|RTM_VIEW_MASK_MCAST,
                                      RTM_ENUM_OWN_ROUTES,
                                      NULL,
                                      RTM_MATCH_INTERFACE,
                                      NULL,
                                      pIcb->dwIfIndex,
                                      &hRtmEnum);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "ReadAllStaticRoutesIntoBuffer: Error %d creating handle for %d\n",
                   dwResult,
                   g_rgRtmHandles[i].dwProtoId);
            
            continue;
        }
        
        do
        {
            dwHandles = g_rtmProfile.MaxHandlesInEnum;
            
            dwResult = RtmGetEnumRoutes(hRtmHandle,
                                        hRtmEnum,
                                        &dwHandles,
                                        hRoutes);
                                        
            //
            // We pick up all that we can in the buffer. If things
            // change between the time the size of the buffer was
            // calculated and now,we discard the additional routes
            //
            // TBD: * Log an event if the buffer was too small *
            //

            for (j = 0; (j < dwHandles) && (dwNumRoutes < dwMaxRoutes); j++)
            {
                // Get the route info corr. to this handle
                
                if (RtmGetRouteInfo(hRtmHandle,
                                    hRoutes[j],
                                    pRoute,
                                    pDestAddr) is NO_ERROR)
                {
                    if (RtmGetEntityInfo(hRtmHandle,
                                         pRoute->RouteOwner,
                                         &entityInfo) is NO_ERROR)
                    {
                        if (RtmGetNextHopInfo(hRtmHandle,
                                              pRoute->NextHopsList.NextHops[0],
                                              &nhiInfo) is NO_ERROR)
                        {
                            // We assume that static routes have only 1 nexthop
                        
                            ConvertRtmToRouteInfo(entityInfo.EntityId.EntityProtocolId,
                                                     pDestAddr,
                                                     pRoute,
                                                     &nhiInfo,
                                                     &(pRoutes[dwNumRoutes++]));

                            RtmReleaseNextHopInfo(hRtmHandle, &nhiInfo);
                        }
                    }

                    RtmReleaseRouteInfo(hRtmHandle, pRoute);
                }
            }

            RtmReleaseRoutes(hRtmHandle, dwHandles, hRoutes);
        }
        while ((dwResult is NO_ERROR) && (dwNumRoutes < dwMaxRoutes));

        RtmDeleteEnumHandle(hRtmHandle, hRtmEnum);
    }
    
    HeapFree(IPRouterHeap, 0, pRoute);
    
    HeapFree(IPRouterHeap, 0, hRoutes);

    HeapFree(IPRouterHeap, 0, pDestAddr);

    return dwNumRoutes;
}


DWORD
SetRouteInfo(
    PICB                    pIcb,
    PRTR_INFO_BLOCK_HEADER  pInfoHdr
    )

/*++
  
Routine Description

    Sets the route info associated with an interface
    First we add the routes present in the route info. Then we enumerate
    the routes and delete those that we dont find in the route info
      
Arguments

    pIcb          The ICB of the interface for whom the route info is

Return Value

    NO_ERROR
    
--*/

{
    PINTERFACE_ROUTE_INFO   pRoutes;
    PRTR_TOC_ENTRY      pToc;
    BOOL                bP2P;
    HANDLE              hRtmHandle;
    HANDLE              hRtmEnum;
    PHANDLE             hAddedRoutes;
    DWORD               dwNumRoutes;
    PHANDLE             hRoutes;
    DWORD               dwHandles;
    DWORD               i, j, k;
    DWORD               dwFlags, dwResult;

    TraceEnter("SetRouteInfo");
   
    if(pIcb->dwOperationalState is UNREACHABLE)
    {
        Trace1(ROUTE,
               "SetRouteInfo: %S is unreachable, not setting routes",
               pIcb->pwszName);

        return NO_ERROR;
    }

    pToc = GetPointerToTocEntry(IP_ROUTE_INFO, pInfoHdr);

    if(pToc is NULL)
    {
        //
        // No TOC means no change
        //

        TraceLeave("SetRouteInfo");
        
        return NO_ERROR;
    }


    pRoutes = (PINTERFACE_ROUTE_INFO)GetInfoFromTocEntry(pInfoHdr,
                                                         pToc);
    
    if((pToc->InfoSize is 0) or (pRoutes is NULL))
    {
        //
        // Delete all the static routes
        //

        DeleteAllRoutes(pIcb->dwIfIndex,
                        TRUE);
        
        TraceLeave("SetRouteInfo");
        
        return NO_ERROR;
    }
    
    dwResult = NO_ERROR;
    
    dwNumRoutes  = pToc->Count;

    // Handles to routes added are stored here
    hAddedRoutes = HeapAlloc(
                    IPRouterHeap,
                    0,
                    dwNumRoutes * sizeof(HANDLE)
                    );

    if (hAddedRoutes == NULL)
    {
        Trace1(ERR,
               "SetRouteInfo: Error allocating %d bytes for addded "
               "route handles",
               dwNumRoutes * sizeof(HANDLE));
        
        TraceLeave("SetRouteInfo");

        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    hRoutes = HeapAlloc(
                IPRouterHeap,
                0,
                g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                );

    if (hRoutes == NULL)
    {
        Trace1(ERR,
               "SetRouteInfo: Error allocating %d bytes for route "
               "handles",
               dwNumRoutes * sizeof(HANDLE));
        
        HeapFree(IPRouterHeap, 0, hAddedRoutes);
        
        TraceLeave("SetRouteInfo");

        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    //
    // The route info is set in two phases. First, all the routes specified
    // are added, and then, the ones present, but not in the info are deleted
    //
   
    bP2P = IsIfP2P(pIcb->ritType);
 
    for(i = j = 0; i < dwNumRoutes; i++)
    {
        DWORD dwMask;
      
        if((pIcb->dwOperationalState is DISCONNECTED) and
           (pRoutes[i].dwRtInfoProto is PROTO_IP_NT_STATIC_NON_DOD))
        {
            continue;
        }
 
        //
        // If this will be a point to point interface,
        // ignore the next hop
        //

        if(bP2P)
        {
            pRoutes[i].dwRtInfoNextHop = pIcb->dwRemoteAddress;
            dwMask = ALL_ONES_MASK;
        }
        else
        {
            dwMask = GetBestNextHopMaskGivenIndex(pIcb->dwIfIndex,
                                                  pRoutes[i].dwRtInfoNextHop);
        }

        if (AddSingleRoute(pIcb->dwIfIndex,
                           &(pRoutes[i]),
                           dwMask,
                           0,       // RTM_ROUTE_INFO::Flags
                           TRUE,    // Valid route
                           TRUE,
                           bP2P,
                           &hAddedRoutes[j]) is NO_ERROR)
        {
            j++;
        }
    }

    dwNumRoutes = j;

    //
    // Now enumerate the static routes, deleting the routes that are
    // not in the new list.
    //

    for(i = 0;
        i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
        i++)
    {
        if(!g_rgRtmHandles[i].bStatic)
        {
            continue;
        }

        hRtmHandle = g_rgRtmHandles[i].hRouteHandle;
        
        dwResult = RtmCreateRouteEnum(hRtmHandle,
                                      NULL,
                                      RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST,
                                      RTM_ENUM_OWN_ROUTES,
                                      NULL,
                                      RTM_MATCH_INTERFACE,
                                      NULL,
                                      pIcb->dwIfIndex,
                                      &hRtmEnum);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "SetRouteInfo: Error %d creating enum handle for %d",
                   dwResult,
                   g_rgRtmHandles[i].dwProtoId);
            
            continue;
        }

        do
        {
            dwHandles = g_rtmProfile.MaxHandlesInEnum;
            
            dwResult = RtmGetEnumRoutes(hRtmHandle,
                                        hRtmEnum,
                                        &dwHandles,
                                        hRoutes);

            for (j = 0; j < dwHandles; j++)
            {
                BOOL  bFound = FALSE;
                
                for (k = 0; k < dwNumRoutes; k++) 
                {
                    if (hRoutes[j] == hAddedRoutes[k])
                    {
                        bFound = TRUE;
                        break;
                    }
                }
                
                if(!bFound)
                {
                    if (RtmDeleteRouteToDest(g_rgRtmHandles[i].hRouteHandle,
                                             hRoutes[j],
                                             &dwFlags) is NO_ERROR)
                    {
                        continue;
                    }
                }

                RtmReleaseRoutes(g_rgRtmHandles[i].hRouteHandle,
                                 1,
                                 &hRoutes[j]);
            }
        }
        while (dwResult is NO_ERROR);
        
        RtmDeleteEnumHandle(hRtmHandle, hRtmEnum);
    }

    // Release the array of handles for routes added

    RtmReleaseRoutes(g_hLocalRoute, dwNumRoutes, hAddedRoutes);
    
    HeapFree(IPRouterHeap, 0, hAddedRoutes);

    HeapFree(IPRouterHeap, 0, hRoutes);

    TraceLeave("SetRouteInfo");
    
    return NO_ERROR;
}

#if 0

DWORD
EnableAllStaticRoutes (
    DWORD    dwInterfaceIndex,
    BOOL     fenable
    )

/*++
  
Routine Description

    Enables or disables Static Routes for an interface

Locks

    Called with ICB_LIST lock held as READER

Arguments

    pIcb          The ICB of the interface
    fenable       TRUE if enable 

Return Value

    NO_ERROR
    
--*/

{
    RTM_IP_ROUTE route ;

    TraceEnter("EnableAllStaticRoutes");
    
    Trace1(ROUTE, "EnableAllStaticRoutes entered with fenable = %d\n",
           fenable) ;

    route.RR_InterfaceID        = dwInterfaceIndex;
    route.RR_RoutingProtocol    = PROTO_IP_LOCAL;
    
    RtmBlockSetRouteEnable(g_hRtmHandle,
                           RTM_ONLY_THIS_INTERFACE | RTM_ONLY_THIS_PROTOCOL,
                           &route,
                           fenable);

    route.RR_InterfaceID        = dwInterfaceIndex;
    route.RR_RoutingProtocol    = PROTO_IP_NT_AUTOSTATIC;

    RtmBlockSetRouteEnable(g_hAutoStaticHandle,
                           RTM_ONLY_THIS_INTERFACE | RTM_ONLY_THIS_PROTOCOL,
                           &route,
                           fenable);


    TraceLeave("EnableAllStaticRoutes");
    
    return NO_ERROR;
}

#endif

DWORD
ConvertRoutesToAutoStatic(
    DWORD dwProtocolId, 
    DWORD dwIfIndex
    )

/*++

Routine Description

    Called to convert routes from a protocol's ownership (IP_RIP) to static 
    (PROTO_IP_NT_AUTOSTATIC)
    Used for autostatic updates etc.

Arguments

    protocolid       Id of protocol whose routes are to be converted
    interfaceindex   Index of the interface whose routes are to be converted
      
Return Value

--*/

{
    DWORD           dwResult, dwFlags;
    
    TraceEnter("ConvertRoutesToAutoStatic");

#if 0

    //
    // We now do the delete before calling the protocols update
    // route
    //

    dwResult = DeleteRtmRoutesOnInterface(g_hAutoStaticHandle,
                                             dwIfIndex);
        
    if((dwResult isnot ERROR_NO_ROUTES) and
       (dwResult isnot NO_ERROR)) 
    {
        Trace1(ERR,
               "ConvertRoutesToAutoStatic: Error %d block deleting routes",
               dwResult);
    }

#endif

    if(((dwResult = BlockConvertRoutesToStatic(g_hAutoStaticRoute,
                                  dwIfIndex, 
                                  dwProtocolId)) isnot NO_ERROR))
    {
        dwResult = GetLastError();
        
        Trace1(ROUTE, 
               "ConvertRoutesToAutoStatic: Rtm returned error: %d", 
               dwResult);
    }

    TraceLeave("ConvertRoutesToAutoStatic");
    
    return dwResult;
}


VOID
ChangeAdapterIndexForDodRoutes (
    DWORD    dwInterfaceIndex
    )

/*++
  
Routine Description

    Changes the adapter index for static routes associated with an
    interface.  The adapter index can go from being valid (the index of a
    net card known to the stack) to INVALID_INDEX. This happens when an
    interface gets unmapped (say on disconnection).  The stack special
    cases the routes with index = 0xffffffff (invalid_index) and does demand
    dial call out for packets destined on such adapters.

    We only enumerate best routes, because this function short circuits
    the normal metric comparison of RTM. If we ran this on all the routes,
    we would be adding some routes to stack which were not meant to be there.
      
Arguments
  
    pIcb  The ICB of the interface 

Return Value

    None
    
--*/

{
    HANDLE           hRtmHandles[2];
    HANDLE           hRtmHandle;
    HANDLE           hRtmEnum;
    PHANDLE          hRoutes;
    PRTM_NET_ADDRESS pDestAddr;
    PRTM_ROUTE_INFO  pRoute;
    RTM_VIEW_SET     fBestInViews;
    DWORD            dwHandles;
    DWORD            i, j;
    DWORD            dwResult;

    pRoute = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                );

    if (pRoute == NULL)
    {
        Trace1(
            ERR, "ChangeAdapterIndexForDodRoutes : Error allocating %d "
            " bytes for route info",
            RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
            );
            
        return;
    }

    hRoutes = HeapAlloc(
                IPRouterHeap,
                0,
                g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                );

    if (hRoutes == NULL)
    {
        Trace1(
            ERR, "ChangeAdapterIndexForDodRoutes : Error allocating %d "
            " bytes for route handles",
            g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
            );
            
        HeapFree(IPRouterHeap, 0, pRoute);
        
        return;
    }
    
    pDestAddr = HeapAlloc(
                    IPRouterHeap,
                    0,
                    sizeof(RTM_NET_ADDRESS)
                    );

    if (pDestAddr == NULL)
    {
        Trace1(
            ERR, "ChangeAdapterIndexForDodRoutes : Error allocating %d "
            " bytes for dest. address",
            sizeof(RTM_NET_ADDRESS)
            );
            
        HeapFree(IPRouterHeap, 0, pRoute);
        
        HeapFree(IPRouterHeap, 0, hRoutes);
        
        return;
    }
    

    hRtmHandles[0] = g_hStaticRoute;        // For all static (dod) routes..
    hRtmHandles[1] = g_hAutoStaticRoute;    // For all autostatic routes....

    for (i = 0; i < 2; i++)
    {
        hRtmHandle = hRtmHandles[i];
        
        dwResult = RtmCreateRouteEnum(hRtmHandle,
                                      NULL,
                                      RTM_VIEW_MASK_UCAST,
                                      RTM_ENUM_OWN_ROUTES,
                                      NULL,
                                      RTM_MATCH_INTERFACE,
                                      NULL,
                                      dwInterfaceIndex,
                                      &hRtmEnum);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "ChangeAdapterIndexForDodRoutes: Error %d creating enum handle for %s routes",
                   dwResult,
                   (i == 0) ? "static" : "autostatic");
        }
        else
        {        
            do
            {
                dwHandles = g_rtmProfile.MaxHandlesInEnum;
                
                dwResult = RtmGetEnumRoutes(hRtmHandle,
                                            hRtmEnum,
                                            &dwHandles,
                                            hRoutes);

                for (j = 0; j < dwHandles; j++)
                {
                    // Is this the best route in unicast view
                    
                    dwResult = RtmIsBestRoute(hRtmHandle,
                                              hRoutes[j],
                                              &fBestInViews);

                    if ((dwResult isnot NO_ERROR) or
                        (!(fBestInViews & RTM_VIEW_MASK_UCAST)))
                    {
                        continue;
                    }
                    
                    // Get the route info corr. to this handle
                    
                    if (RtmGetRouteInfo(hRtmHandle,
                                        hRoutes[j],
                                        pRoute,
                                        pDestAddr) is NO_ERROR)
                    {                    
                        //
                        // This call adds the same route with the forwarder - with
                        // the current adapter index
                        //
            /*       
                        pRoute->RR_FamilySpecificData.FSD_Metric += 
                            g_ulDisconnectedMetricIncrement;

                        RtmAddRoute(g_hStaticRoute,
                                    pRoute,
                                    INFINITE,
                                    &fFlags,
                                    NULL,
                                    NULL); 
            */

                        ChangeRouteWithForwarder(pDestAddr, 
                                                 pRoute, 
                                                 TRUE,
                                                 TRUE);

                        RtmReleaseRouteInfo(hRtmHandle, pRoute);
                    }
                }

                RtmReleaseRoutes(hRtmHandle, dwHandles, hRoutes);
            }
            while (dwResult is NO_ERROR);

            RtmDeleteEnumHandle(hRtmHandle, hRtmEnum);
        }
    }
    
    HeapFree(IPRouterHeap, 0, pRoute);
    HeapFree(IPRouterHeap, 0, hRoutes);
    HeapFree(IPRouterHeap, 0, pDestAddr);
    
    return;
}

#if 0
DWORD
GetMaskForClientSubnet(
    DWORD    dwInternalAddress
    )
/*++
  Routine Description

  Arguments

  Return Value
--*/
{
    HANDLE          hEnum;
    RTM_IP_ROUTE    route;

    TraceEnter("IsRoutePresent");

    route.RR_RoutingProtocol    = PROTO_IP_LOCAL;

    hEnum = RtmCreateEnumerationHandle(RTM_PROTOCOL_FAMILY_IP,
                                       RTM_ONLY_THIS_PROTOCOL,
                                       &route);

    if(hEnum is NULL)
    {
        return GetClassMask(dwInternalAddress);
    }


    while(RtmEnumerateGetNextRoute(hEnum, &route) isnot ERROR_NO_MORE_ROUTES)
    {
        if(route.RR_Network.N_NetMask is 0x00000000)
        {
            //
            // Dont match default route
            //

            continue;
        }

        if((dwInternalAddress & route.RR_Network.N_NetMask) is route.RR_Network.N_NetNumber)
        {
            RtmCloseEnumerationHandle(hEnum);

            TraceLeave("IsRoutePresent");

            return route.RR_Network.N_NetMask;
        }
    }

    RtmCloseEnumerationHandle(hEnum);

    TraceLeave("IsRoutePresent");

    return GetClassMask(dwInternalAddress);
}

#endif

VOID
AddAutomaticRoutes(
    PICB    pIcb,
    DWORD   dwAddress,
    DWORD   dwMask
    )

/*++

Routine Description

    This function adds the routes that are otherwise generated by the
    stack. This is mainly done for consistency between RTM and kernel tables
    
    The routes added are:
        (i)   local loopback
        (ii)  local multicast
        (iii) local subnet -> if the dwMask is not 255.255.255.255
        (iv)  all subnets broadcast -> if the ClassMask and Mask are different
        (v)   all 1's broadcast
        
    Since some of the routes are added to the stack the interface to adapter
    index map must already be set before this function is called
    
    VERY IMPORTANT:
    
    One MUST add the local route before binding the interface because this
    route is not going to be added to stack. However it has higher
    priority than say an OSPF route. Now if we first bind the interface
    to OSPF, it will add a network route for this interface (which will
    get added to the stack since only Router Manager can add non
    stack routes). Now when we add the local route to RTM, we will find
    our route better because we are higher priority. So RTM will tell
    us to delete the OSPF route (which we will since its a stack route).
    Then he will tell us to add our route to the stack.  But we wont
    do this since its a non stack route. So we basically end up deleting
    network route from the routing table

Locks

    

Arguments

    

Return Value


--*/

{
    DWORD               dwClassMask, dwResult;
    INTERFACE_ROUTE_INFO    RtInfo;
    BOOL                bP2P;

    IpRtAssert(pIcb->bBound);
    IpRtAssert(dwAddress isnot INVALID_IP_ADDRESS);

    return;
    
    bP2P = IsIfP2P(pIcb->ritType);
 
    if(dwMask isnot ALL_ONES_MASK)
    {
        BOOL            bStack, bDontAdd;
        RTM_NET_ADDRESS DestAddr;
        PRTM_DEST_INFO  pDestInfo;
        DWORD           dwLen;

        //
        // We now add the subnet route to stack so that if race condition
        // had deleted the route on stopping, the restarting
        // fixes the problem
        //

        //
        // NOTE: For the RAS Server Interface we need to add the route to the
        // routing table only if such a route doesnt exist. We need to add it
        // because we want the pool advertised by the routing protocols
        // However, adding to the stack will fail since we dont have a valid
        // next hop (which is needed for p2mp)
        //

        bDontAdd = FALSE;

        if(pIcb->ritType is ROUTER_IF_TYPE_INTERNAL)
        {
            //
            // If a route to this virtual net exists, dont add it
            //

            __try
            {
                pDestInfo = 
                    _alloca(RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews));
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                IpRtAssert(FALSE);
            }

            RTM_IPV4_LEN_FROM_MASK(dwLen, dwMask);

            RTM_IPV4_MAKE_NET_ADDRESS(&DestAddr,  (dwAddress & dwMask), dwLen);

            if (RtmGetExactMatchDestination(g_hLocalRoute,
                                            &DestAddr,
                                            RTM_BEST_PROTOCOL,
                                            RTM_VIEW_MASK_UCAST,
                                            pDestInfo) is NO_ERROR)
            {
                RtmReleaseDestInfo(g_hLocalRoute, pDestInfo);

                Trace1(IF,
                       "AddAutomaticRoutes: Route to virtual LAN %d.%d.%d.%d already exists",
                       PRINT_IPADDR(dwAddress));

                bDontAdd = TRUE;
            }
        }

        if(!bDontAdd)
        {
            //
            // Add the network route
            //
        
            RtInfo.dwRtInfoDest          = (dwAddress & dwMask);
            RtInfo.dwRtInfoMask          = dwMask;
            RtInfo.dwRtInfoNextHop       = dwAddress;
            RtInfo.dwRtInfoIfIndex       = pIcb->dwIfIndex;
            RtInfo.dwRtInfoMetric1       = 1;
            RtInfo.dwRtInfoMetric2       = 1;
            RtInfo.dwRtInfoMetric3       = 1;
            RtInfo.dwRtInfoPreference    = ComputeRouteMetric(MIB_IPPROTO_LOCAL);
            RtInfo.dwRtInfoViewSet       = RTM_VIEW_MASK_UCAST |
                                              RTM_VIEW_MASK_MCAST; // XXX config
            RtInfo.dwRtInfoType          = MIB_IPROUTE_TYPE_DIRECT;
            RtInfo.dwRtInfoProto         = MIB_IPPROTO_LOCAL;
            RtInfo.dwRtInfoAge           = INFINITE;
            RtInfo.dwRtInfoNextHopAS     = 0;
            RtInfo.dwRtInfoPolicy        = 0;
        
            bStack = TRUE;
       
            IpRtAssert(bP2P is FALSE);
 
            dwResult = AddSingleRoute(pIcb->dwIfIndex,
                                      &RtInfo,
                                      dwMask,
                                      // RTM_ROUTE_INFO::Flags
                                      RTM_ROUTE_FLAGS_LOCAL,
                                      TRUE,     // Valid route
                                      bStack,
                                      bP2P,
                                      NULL);
        
            if(dwResult isnot NO_ERROR)
            {
                Trace1(ERR,
                       "AddAutoRoutes: Can't add subnet route for %d.%d.%d.%d",
                       PRINT_IPADDR(dwAddress));
            }
        }
    }
    
    if(g_pLoopbackInterfaceCb)
    {
        RtInfo.dwRtInfoDest      = dwAddress;
        RtInfo.dwRtInfoMask      = HOST_ROUTE_MASK;
        RtInfo.dwRtInfoNextHop   = IP_LOOPBACK_ADDRESS;
        RtInfo.dwRtInfoIfIndex   = g_pLoopbackInterfaceCb->dwIfIndex;
        RtInfo.dwRtInfoMetric1   = 1;
        RtInfo.dwRtInfoMetric2   = 1;
        RtInfo.dwRtInfoMetric3   = 1;
        RtInfo.dwRtInfoPreference= ComputeRouteMetric(MIB_IPPROTO_LOCAL);
        RtInfo.dwRtInfoViewSet   = RTM_VIEW_MASK_UCAST |
                                      RTM_VIEW_MASK_MCAST;
        RtInfo.dwRtInfoType      = MIB_IPROUTE_TYPE_DIRECT;
        RtInfo.dwRtInfoProto     = MIB_IPPROTO_LOCAL;
        RtInfo.dwRtInfoAge       = INFINITE;
        RtInfo.dwRtInfoNextHopAS = 0;
        RtInfo.dwRtInfoPolicy    = 0;

        dwResult = AddSingleRoute(g_pLoopbackInterfaceCb->dwIfIndex,
                                  &RtInfo,
                                  dwMask,
                                  // RTM_ROUTE_INFO::Flags
                                  RTM_ROUTE_FLAGS_MYSELF,
                                  TRUE,
                                  FALSE,
                                  FALSE,
                                  NULL);
            
        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "AddAutoRoutes: Cant add 127.0.0.1 route for %d.%d.%d.%d",
                   PRINT_IPADDR(dwAddress));
        }
    }
    
    RtInfo.dwRtInfoDest          = LOCAL_NET_MULTICAST;
    RtInfo.dwRtInfoMask          = LOCAL_NET_MULTICAST_MASK;
    RtInfo.dwRtInfoNextHop       = dwAddress;
    RtInfo.dwRtInfoIfIndex       = pIcb->dwIfIndex;
    RtInfo.dwRtInfoMetric1       = 1;
    RtInfo.dwRtInfoMetric2       = 1;
    RtInfo.dwRtInfoMetric3       = 1;
    RtInfo.dwRtInfoPreference    = ComputeRouteMetric(MIB_IPPROTO_LOCAL);
    RtInfo.dwRtInfoViewSet       = RTM_VIEW_MASK_UCAST;
    RtInfo.dwRtInfoType          = MIB_IPROUTE_TYPE_DIRECT;
    RtInfo.dwRtInfoProto         = MIB_IPPROTO_LOCAL;
    RtInfo.dwRtInfoAge           = INFINITE;
    RtInfo.dwRtInfoNextHopAS     = 0;
    RtInfo.dwRtInfoPolicy        = 0;

    dwResult = AddSingleRoute(pIcb->dwIfIndex,
                              &RtInfo,
                              dwMask,
                              0,        // RTM_ROUTE_INFO::Flags
                              FALSE,    // Protocols dont like a mcast route
                              FALSE,    // No need to add to stack
                              bP2P,
                              NULL);
        
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AddAutoRoutes: Couldnt add 224.0.0.0 route for %d.%d.%d.%d",
               PRINT_IPADDR(dwAddress));
    }
        
    //
    // We add the All 1's Bcast route to all interfaces. This is
    // actually a BUG since we should see if the medium allows
    // broadcast (X.25 would be an example of one that didnt)
    //
    
    RtInfo.dwRtInfoDest          = ALL_ONES_BROADCAST;
    RtInfo.dwRtInfoMask          = HOST_ROUTE_MASK;
    RtInfo.dwRtInfoNextHop       = dwAddress;
    RtInfo.dwRtInfoIfIndex       = pIcb->dwIfIndex;
    RtInfo.dwRtInfoMetric1       = 1;
    RtInfo.dwRtInfoMetric2       = 1;
    RtInfo.dwRtInfoMetric3       = 1;
    RtInfo.dwRtInfoPreference    = ComputeRouteMetric(MIB_IPPROTO_LOCAL);
    RtInfo.dwRtInfoViewSet       = RTM_VIEW_MASK_UCAST;
    RtInfo.dwRtInfoType          = MIB_IPROUTE_TYPE_DIRECT;
    RtInfo.dwRtInfoProto         = MIB_IPPROTO_LOCAL;
    RtInfo.dwRtInfoAge           = INFINITE;
    RtInfo.dwRtInfoNextHopAS     = 0;
    RtInfo.dwRtInfoPolicy        = 0;
        
    dwResult = AddSingleRoute(pIcb->dwIfIndex,
                              &RtInfo,
                              dwMask,
                              0,        // RTM_ROUTE_INFO::Flags
                              FALSE,    // Protocols dont like a bcast route
                              FALSE,    // No need to add to stack
                              bP2P,
                              NULL);                         
        
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AddAutRoutes: Couldnt add all 1's bcast route for %d.%d.%d.%d",
               PRINT_IPADDR(dwAddress));
    }       
        
    //
    // We add the All Subnets Broadcast route if the class mask is different
    // from the subnet mask
    //

    dwClassMask = GetClassMask(dwAddress);

    if(dwClassMask isnot dwMask)
    {
        RtInfo.dwRtInfoDest      = (dwAddress | ~dwClassMask);
        RtInfo.dwRtInfoMask      = HOST_ROUTE_MASK;
        RtInfo.dwRtInfoNextHop   = dwAddress;
        RtInfo.dwRtInfoIfIndex   = pIcb->dwIfIndex;
        RtInfo.dwRtInfoMetric1   = 1;
        RtInfo.dwRtInfoMetric2   = 1;
        RtInfo.dwRtInfoMetric3   = 1;
        RtInfo.dwRtInfoPreference= ComputeRouteMetric(MIB_IPPROTO_LOCAL);
        RtInfo.dwRtInfoViewSet   = RTM_VIEW_MASK_UCAST |
                                      RTM_VIEW_MASK_MCAST; // XXX configurable
        RtInfo.dwRtInfoType      = MIB_IPROUTE_TYPE_DIRECT;
        RtInfo.dwRtInfoProto     = MIB_IPPROTO_LOCAL;
        RtInfo.dwRtInfoAge       = INFINITE;
        RtInfo.dwRtInfoNextHopAS = 0;
        RtInfo.dwRtInfoPolicy    = 0;
        
        dwResult = AddSingleRoute(pIcb->dwIfIndex,
                                  &RtInfo,
                                  dwMask,
                                  0,     // RTM_ROUTE_INFO::Flags
                                  FALSE, // Protocols dont like a bcast route
                                  FALSE, // No need to add to stack
                                  bP2P,
                                  NULL);
                       
        
        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "AddAutoRoutes: Couldnt add all nets bcast route for %d.%d.%d.%d",
                   PRINT_IPADDR(dwAddress));
        }
    }
}


VOID
DeleteAutomaticRoutes(
    PICB    pIcb,
    DWORD   dwAddress,
    DWORD   dwMask
    )

/*++

Routine Description

    

Locks

    

Arguments

    

Return Value


--*/

{
    DWORD   dwClassMask, dwResult;
    BOOL    bP2P;

    
    if(dwAddress is INVALID_IP_ADDRESS)
    {
        IpRtAssert(FALSE);
    }

    return;
    
    bP2P = IsIfP2P(pIcb->ritType);
 
    //
    // Delete the loopback route we added
    //
    
    if(g_pLoopbackInterfaceCb)
    { 
        dwResult = DeleteSingleRoute(g_pLoopbackInterfaceCb->dwIfIndex, 
                                     dwAddress,
                                     HOST_ROUTE_MASK,    
                                     IP_LOOPBACK_ADDRESS,
                                     PROTO_IP_LOCAL,
                                     FALSE);
            
        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "DeleteAutoRoutes: Error %d deleting loopback route on %d.%d.%d.%d",
                   dwResult,
                   PRINT_IPADDR(dwAddress));
        }
    }

    //
    // Delete the multicast route
    //
    
    dwResult = DeleteSingleRoute(pIcb->dwIfIndex,
                                 LOCAL_NET_MULTICAST,
                                 LOCAL_NET_MULTICAST_MASK,
                                 dwAddress,
                                 PROTO_IP_LOCAL,
                                 bP2P);
            
    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "DeleteAutoRoutes: Error %d deleting 224.0.0.0 route on %d.%d.%d.%d",
               dwResult,
               PRINT_IPADDR(dwAddress));
    }

    if(dwMask isnot ALL_ONES_MASK)
    {
        //
        // Delete the network route we added
        //
           
        IpRtAssert(bP2P is FALSE);
 
        dwResult = DeleteSingleRoute(pIcb->dwIfIndex,
                                     (dwAddress & dwMask),
                                     dwMask,
                                     dwAddress,
                                     PROTO_IP_LOCAL,
                                     bP2P);
            
        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "DeleteAutoRoutes: Error %d deleting subnet route for %d.%d.%d.%d",
                   dwResult,
                   PRINT_IPADDR(dwAddress));
        }
    }
    
    //
    // Delete the all nets bcast route
    //
    
    dwClassMask = GetClassMask(dwAddress);

    if(dwClassMask isnot dwMask)
    {
        dwResult = DeleteSingleRoute(pIcb->dwIfIndex,
                                     (dwAddress | ~dwClassMask),
                                     HOST_ROUTE_MASK,
                                     dwAddress,
                                     PROTO_IP_LOCAL,
                                     bP2P);
            
        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "DeleteAutoRoutes: Error %d deleting subnet bcast route on %x",
                   dwResult,
                   dwAddress);
        }

        //
        // Delete the all 1's bcast route
        //
    }

    dwResult = DeleteSingleRoute(pIcb->dwIfIndex,
                                 ALL_ONES_BROADCAST,
                                 HOST_ROUTE_MASK,
                                 dwAddress,
                                 PROTO_IP_LOCAL,
                                 bP2P);
            
    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "DeleteAutoRoutes: Error %d deleting all 1's bcast route on %d.%d.%d.%d",
               dwResult,    
               PRINT_IPADDR(dwAddress));
    }
}

VOID
ChangeDefaultRouteMetrics(
    IN  BOOL    bIncrement
    )


/*++

Routine Description

    Increments or decrements the default route(s) metrics.
    For increment, it should be called BEFORE the default route for the
    dial out interface is added, and for decrement it should be called AFTER
    the dial out interface has been deleted

Locks

    Called with the ICB lock held. This ensures that two such operations
    are not being executed simultaneously (which would do the nasties to our
    route table)

Arguments

    bIncrement  TRUE if we need to increment the metric

Return Value

    None

--*/

{
    ULONG   i;
    DWORD   dwErr;

    RTM_NET_ADDRESS     NetAddress;
    PRTM_ROUTE_HANDLE   phRoutes;
    PRTM_ROUTE_INFO     pRouteInfo;
    RTM_DEST_INFO       DestInfo;
    RTM_ENUM_HANDLE     hEnum;

    ZeroMemory(&NetAddress,
               sizeof(NetAddress));

    __try
    {
        phRoutes   = 
            _alloca(sizeof(RTM_ROUTE_HANDLE) * g_rtmProfile.MaxHandlesInEnum);

        pRouteInfo = 
            _alloca(RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return;
    }
 
    //
    // Use any handle
    //

    dwErr = RtmGetExactMatchDestination(g_hLocalRoute,
                                        &NetAddress,
                                        RTM_BEST_PROTOCOL, // rather any
                                        RTM_VIEW_ID_UCAST,
                                        &DestInfo);

    if(dwErr isnot NO_ERROR)
    {
        return;
    }

    hEnum = NULL;

    dwErr =  RtmCreateRouteEnum(g_hLocalRoute,
                                DestInfo.DestHandle,
                                RTM_VIEW_ID_UCAST,
                                RTM_ENUM_ALL_ROUTES,
                                NULL,
                                RTM_MATCH_NONE,
                                NULL,
                                0,
                                &hEnum);

    if(dwErr isnot NO_ERROR)
    {
        RtmReleaseDestInfo(g_hLocalRoute,
                           &DestInfo);

        return;
    }

    do
    {
        RTM_ENTITY_HANDLE   hRtmHandle;
        ULONG               j, ulCount;

        ulCount = g_rtmProfile.MaxHandlesInEnum;

        dwErr = RtmGetEnumRoutes(g_hLocalRoute,
                                 hEnum,
                                 &ulCount,
                                 phRoutes);

        if(ulCount < 1)
        {
            break;
        }

        for(i = 0 ; i < ulCount; i++)
        {
            PRTM_ROUTE_INFO pRtmRoute;
            DWORD           dwFlags;
 
            dwErr = RtmGetRouteInfo(g_hLocalRoute,
                                    phRoutes[i],
                                    pRouteInfo,
                                    NULL);

            if(dwErr isnot NO_ERROR)
            {
                continue;
            }

            //
            // See if we are the owner of this route
            //

            hRtmHandle = NULL;

            for(j = 0; 
                j <  sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
                j++)
            {
                if(pRouteInfo->RouteOwner is g_rgRtmHandles[j].hRouteHandle)
                {
                    hRtmHandle = g_rgRtmHandles[j].hRouteHandle;

                    break;
                }
            }

            RtmReleaseRouteInfo(g_hLocalRoute,
                                pRouteInfo);

            if(hRtmHandle is NULL)
            {
                continue;
            }

            //
            // Lock the route (and re-read the info)
            //

            dwErr = RtmLockRoute(hRtmHandle,
                                 phRoutes[i],
                                 TRUE,
                                 TRUE,
                                 &pRtmRoute);

            if(dwErr isnot NO_ERROR)
            {
                continue;
            }
            
            //
            // If we have to decrease the metric and it is already 1,
            // let it be
            //

            if(!bIncrement)
            {
                if(pRtmRoute->PrefInfo.Metric <= 1)
                {
                    RtmLockRoute(hRtmHandle,
                                 phRoutes[i],
                                 TRUE,
                                 FALSE,
                                 NULL);
                    continue;
                }
            }

            //
            // Now update the route
            //

            if(bIncrement)
            {
                pRtmRoute->PrefInfo.Metric++;
            }
            else
            {
                pRtmRoute->PrefInfo.Metric--;
            }

            dwFlags = 0;

            dwErr = RtmUpdateAndUnlockRoute(hRtmHandle,
                                            phRoutes[i],
                                            INFINITE,
                                            NULL,
                                            0,
                                            NULL,
                                            &dwFlags);

            if(dwErr isnot NO_ERROR)
            {
                RtmLockRoute(hRtmHandle,
                             phRoutes[i],
                             TRUE,
                             FALSE,
                             NULL);
            }
        }

        RtmReleaseRoutes(g_hLocalRoute,
                         ulCount,
                         phRoutes);

    }while(TRUE);

    RtmDeleteEnumHandle(g_hLocalRoute,
                        hEnum);

    RtmReleaseDestInfo(g_hLocalRoute,
                       &DestInfo);

    return;
}

VOID
AddAllStackRoutes(
    PICB    pIcb
    )
    
/*++

Routine Description:

    This function picks up the default gateway and persistent routes
    that the stack may have added under the covers for this interface
    and adds them to RTM

Locks:

    ICB_LIST lock must be held as WRITER

Arguments:

    dwIfIndex   Interface index

Return Value:

    none

--*/

{
    DWORD   dwErr, dwMask, i;
    BOOL    bStack;
    
    PMIB_IPFORWARDTABLE pRouteTable;


    TraceEnter("AddAllStackRoutes");
    
    IpRtAssert(!IsIfP2P(pIcb->ritType));
    
    dwErr = AllocateAndGetIpForwardTableFromStack(&pRouteTable,
                                                  FALSE,
                                                  IPRouterHeap,
                                                  0);

    if(dwErr isnot NO_ERROR)
    {
        Trace1(ERR,
               "AddAllStackRoutes: Couldnt get initial routes. Error %d",
               dwErr);

        return;
    }

    for(i = 0; i < pRouteTable->dwNumEntries; i++)
    {

        TraceRoute4(ROUTE,
                "route to %d.%d.%d.%d/%d.%d.%d.%d, If Index %d, proto %d",
                   PRINT_IPADDR(pRouteTable->table[i].dwForwardDest),
                   PRINT_IPADDR(pRouteTable->table[i].dwForwardMask),
                   pRouteTable->table[i].dwForwardIfIndex,
                   pRouteTable->table[i].dwForwardProto);

        if(pRouteTable->table[i].dwForwardIfIndex isnot pIcb->dwIfIndex)
        {
            //
            // Not going out over this interface
            //
            
            continue;
        }

#if 1

        //
        // Pick up only PROTO_IP_LOCAL and PROTO_IP_NETMGMT routes
        // from the IP stack
        //

        if((pRouteTable->table[i].dwForwardProto isnot PROTO_IP_LOCAL) and
           (pRouteTable->table[i].dwForwardProto isnot PROTO_IP_NETMGMT))
        {
            continue;
        }
        
#else
        if((pRouteTable->table[i].dwForwardProto isnot PROTO_IP_NT_STATIC_NON_DOD) and
           (pRouteTable->table[i].dwForwardDest isnot 0))
        {
            //
            // Only pick up default gateways and persistent routes
            //
            
            continue;
        }
#endif
        dwMask = GetBestNextHopMaskGivenICB(pIcb,
                                            pRouteTable->table[i].dwForwardDest);


        //
        // Routes learned from the stack should be added back to the stack if
        // required.  This can happen as follows:
        //
        //  1. Route R1 from stack is currently best route for destination D1.
        //  2. Subsequently it is superseeded by route R2 as the best route for 
        //      destination D1.
        //      R2 is added to the stack, deleting R1 as a side effect.
        //  3. Eventually R2 is deleted and R1 is again the best route to D1
        //  4. R1 now needs to be added back to the stack and can only be done
        //      if its stack bit is set.
        //
        
        bStack = TRUE;
        
        //if((pRouteTable->table[i].dwForwardProto is PROTO_IP_NETMGMT) &&
        //   (pRouteTable->table[i].dwForwardMask is HOST_ROUTE_MASK))
        //{
        //    bStack = FALSE;
        //}

        if(pRouteTable->table[i].dwForwardProto is PROTO_IP_LOCAL)
        {
            //
            // PROTO_IP_LOCAL routes as a rule need not be added back
            //  as they are entirely managed by the stack.
            //
            // The one exception as routes to the local subnet.
            //  These need to added back to the stack so that any
            //  routes to the local subnet learned over other interfaces
            //  are deleted as a side effect.
            //  
            // This is required as follows:
            //  1. Interface I1 connected to network N1 is disabled.
            //  2. Route R1 to network N1 is learnt over interface
            //      I2 connected to network N2 from a neighboring 
            //      router running RIP.
            //  3. So the best route to N1 is the RIP route R1.
            //  4. Interface I1 is now enabled.
            //  5. PROTO_IP_LOCAL route R2 to N1 is added by the stack.
            //      But the stack does not delete R1 automatically.
            //  6. In RTMv2 in user-mode R2 is added as the best route.
            //  7. If R2 does not have its stack bit set, it is not
            //      added back to the stack, allowing both R2 and R1 to
            //      remain in the stack.
            //  8. Route R1 is deleted by RIP.  Since it is not the
            //      best route in RTMv2 no changes are propagated to the
            //      stack even though R1 is present in the stack.
            //

            //
            // As per above disable stack bit for PROTO_IP_LOCAL routes
            //  except route to the local subnet.
            //
            
            if(
                //
                // Do not add the loopback route back to the stack.
                // PROTO_IP_LOCAL host route check catches the loopback route
                //
                
                (pRouteTable->table[i].dwForwardMask is HOST_ROUTE_MASK) or

                //
                // Do not add the multicast and all 1's broadcast route
                //
                
                ((pRouteTable->table[i].dwForwardDest &
                    ((DWORD) 0x000000FF)) >= ((DWORD) 0x000000E0)) or

                //
                // Do not add subnet broadcast route 
                //
                
                (pRouteTable->table[i].dwForwardDest == 
                    (pRouteTable->table[i].dwForwardDest | 
                     ~pRouteTable->table[i].dwForwardMask)))
            {
                bStack = FALSE;
            }

            //
            // This should leave only the subnet route with its stack bit set
            //
        }
                    
        dwErr = AddSingleRoute(pIcb->dwIfIndex,
                               ConvertMibRouteToRouteInfo(&(pRouteTable->table[i])),
                               dwMask,
                               0,       // RTM_ROUTE_INFO::Flags
                               TRUE,    // Valid route
                               bStack,   // Do not add back to stack
                               FALSE,   // Only called for non P2P i/fs
                               NULL);
    }

    TraceLeave("AddAllStackRoutes");
    
    return;
}

VOID
UpdateDefaultRoutes(
    VOID
    )
{
    DWORD   dwErr, dwMask, i, j;
    BOOL    bFound;
    
    PMIB_IPFORWARDTABLE  pRouteTable;

    PINTERFACE_ROUTE_INFO pRtInfo;

    TraceEnter("UpdateDefaultRoutes");
    
    //
    // Get the routes in an ordered table
    //
    
    dwErr = AllocateAndGetIpForwardTableFromStack(&pRouteTable,
                                                  TRUE,
                                                  IPRouterHeap,
                                                  0);

    if(dwErr isnot NO_ERROR)
    {
        Trace1(ERR,
               "UpdateDefaultRoutes: Couldnt get routes. Error %d",
               dwErr);

        return;
    }

            
    //
    // Now add the dgs not already present
    //

    for(i = 0; i < pRouteTable->dwNumEntries; i++)
    {
        PICB    pIcb;

        TraceRoute2(
            ROUTE, "%d.%d.%d.%d/%d.%d.%d.%d",
            PRINT_IPADDR( pRouteTable-> table[i].dwForwardDest ),
            PRINT_IPADDR( pRouteTable-> table[i].dwForwardMask )
            );
        //
        // Once we get past the default routes, we are done
        //
        
        if(pRouteTable->table[i].dwForwardDest isnot 0)
        {
#if TRACE_DBG
            continue;
#else
            break;
#endif
        }

        if(pRouteTable->table[i].dwForwardIfIndex is INVALID_IF_INDEX)
        {
            continue;
        }

        if(pRouteTable->table[i].dwForwardProto isnot PROTO_IP_NETMGMT)
        {
            continue;
        }

        pIcb = InterfaceLookupByIfIndex(pRouteTable->table[i].dwForwardIfIndex);

        if(pIcb is NULL)
        {
            Trace1(ERR,
                   "UpdateDefaultRoutes: Couldnt get icb for %x",
                   pRouteTable->table[i].dwForwardIfIndex);

            continue;
        }

        //
        // Dont need to do this for p2p interfaces
        //

        if(IsIfP2P(pIcb->ritType))
        {
            continue;
        }

        dwMask = GetBestNextHopMaskGivenICB(pIcb,
                                            pRouteTable->table[i].dwForwardDest);
        Trace1(ROUTE,
               "UpdateDefaultRoutes: Adding default route over %S",
               pIcb->pwszName);

        dwErr = AddSingleRoute(pIcb->dwIfIndex,
                               ConvertMibRouteToRouteInfo(&(pRouteTable->table[i])),
                               dwMask,
                               0,       // RTM_ROUTE_INFO::Flags
                               TRUE,    // Valid route
                               TRUE,    // Add the route to stack
                               FALSE,   // Only called for non P2P i/fs
                               NULL);

        if(dwErr isnot NO_ERROR)
        {
            Trace3(ERR,
                   "UpdateDefaultRoutes: Error %d adding dg to %d.%d.%d.%d over %x",
                   dwErr,
                   PRINT_IPADDR(pRouteTable->table[i].dwForwardNextHop),
                   pRouteTable->table[i].dwForwardIfIndex);
        }
#if 0
        else
        {
            if(g_ulGatewayCount < g_ulGatewayMaxCount)
            {
                g_pGateways[g_ulGatewayCount].dwAddress =
                    pRouteTable->table[i].dwForwardNextHop;

                g_pGateways[g_ulGatewayCount].dwMetric =
                    pRouteTable->table[i].dwForwardMetric1;

                g_pGateways[g_ulGatewayCount].dwIfIndex =
                    pRouteTable->table[i].dwForwardIfIndex;

                g_ulGatewayCount++;
            }
            else
            {
                PGATEWAY_INFO   pNewGw;

                IpRtAssert(g_ulGatewayCount == g_ulGatewayMaxCount);

                pNewGw = HeapAlloc(IPRouterHeap,
                                   HEAP_ZERO_MEMORY,
                                   (g_ulGatewayMaxCount + 5) * sizeof(GATEWAY_INFO));

                if(pNewGw isnot NULL)
                {
                    g_ulGatewayMaxCount = g_ulGatewayMaxCount + 5;

                    for(j = 0; j < g_ulGatewayCount; j++)
                    {
                        pNewGw[j] = g_pGateways[j];
                    }

                    if(g_pGateways isnot NULL)
                    {
                        HeapFree(IPRouterHeap,
                                 0,
                                 g_pGateways);
                    }

                    g_pGateways = pNewGw;

                    g_pGateways[g_ulGatewayCount].dwAddress =
                        pRouteTable->table[i].dwForwardNextHop;

                    g_pGateways[g_ulGatewayCount].dwMetric =
                        pRouteTable->table[i].dwForwardMetric1;

                    g_pGateways[g_ulGatewayCount].dwIfIndex =
                        pRouteTable->table[i].dwForwardIfIndex;

                    g_ulGatewayCount++;
                }
            }
        }
#endif
    }

    HeapFree(IPRouterHeap,
             0,
             pRouteTable);

    TraceLeave("UpdateDefaultRoutes");
    
    return;
}


NTSTATUS
PostIoctlForRouteChangeNotification(
    DWORD   ulIndex
    )

/*++

Routine Description:

    This routine posts an IOCTL with the TCP/IP driver for route change
    notifications caused by addition of routes to the stack by entities
    other than Router Manager

Arguments:

    ulIndex -   Index into array of notifications indicating which one
                needs to be posted

Return Value

    STATUS_SUCCESS  -   Success

    NTSTATUS code   -   Otherwise

Environment:

--*/
{

    NTSTATUS    status;
    

    status = NtDeviceIoControlFile(
                g_hIpRouteChangeDevice,
                g_hRouteChangeEvents[ulIndex],
                NULL,
                NULL,
                &g_rgIpRouteNotifyOutput[ulIndex].ioStatus,
                IOCTL_IP_RTCHANGE_NOTIFY_REQUEST_EX,
                &g_IpNotifyData,
                sizeof(IPNotifyData),
                &g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput,
                sizeof(IPRouteNotifyOutput)
                );
                
    if ((status isnot STATUS_SUCCESS) and
        (status isnot STATUS_PENDING))
    {
        Trace2(
            ERR,
            "Error 0x%x posting route change notification[%d]",
            status, ulIndex
            );
    }

    return status;
}


DWORD
HandleRouteChangeNotification(
    ULONG   ulIndex
    )
/*++

--*/
{
    DWORD   dwResult = NO_ERROR, dwFlags, dwClassMask;
    BOOL    bValid, bStack = FALSE;
    WORD    wRouteFlags = 0;
    INTERFACE_ROUTE_INFO RtInfo;
    PICB    pIcb;
    

    TraceEnter("HandleRouteChangeNotification");

    TraceRoute2(
        ROUTE, "Change for route to %d.%d.%d.%d/%d.%d.%d.%d",
        PRINT_IPADDR(g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_dest),
        PRINT_IPADDR(g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_mask)
        );        
        
    TraceRoute3(
        ROUTE, "Proto : %d, via i/f 0x%x, nexthop %d.%d.%d.%d",
        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_proto,
        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_ifindex,
        PRINT_IPADDR(g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_nexthop)
        );

    TraceRoute2(
        ROUTE, "Metric : %d, Change : 0x%x",
        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_metric,
        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_flags
        );

    //
    // Update RTM route table as per route change indication
    //

    ENTER_READER(ICB_LIST);

    do
    {
        pIcb = InterfaceLookupByIfIndex(
                g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_ifindex
                );

        if (pIcb == NULL)
        {
            //
            // if there is no interface with the specified index in 
            // router manager, skip this route
            //
            
            Trace3(
                ERR,
                "Failed to add route to %d.%d.%d.%d/%d.%d.%d.%d."
                "Interface index %d not present with router manager",
                PRINT_IPADDR(g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_dest),
                PRINT_IPADDR(g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_mask),
                g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_ifindex
                );

            break;
        }


        //
        // if route had been added to stack, add it to RTM
        //

        dwFlags = 
            g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_flags;

            
        ConvertRouteNotifyOutputToRouteInfo(
            &g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput,
            &RtInfo
            );

        if ((dwFlags is 0) or (dwFlags & IRNO_FLAG_ADD))
        {
            bValid = TRUE;
            
            if (RtInfo.dwRtInfoProto == PROTO_IP_LOCAL)
            {
                //
                // Set appropriate RTM flags for local routes
                //
                
                if (RtInfo.dwRtInfoNextHop == IP_LOOPBACK_ADDRESS)
                {
                    //
                    // Route over loopback.  Set MYSELF flag
                    //
                    
                    wRouteFlags = RTM_ROUTE_FLAGS_MYSELF;
                }

                else if ((RtInfo.dwRtInfoMask != HOST_ROUTE_MASK ) &&
                         ((RtInfo.dwRtInfoDest & RtInfo.dwRtInfoMask) < 
                            ((DWORD) 0x000000E0)))
                {
                    //
                    // RTM_ROUTE_FLAGS_LOCAL is set only for subnet 
                    // routes.  Not sure why this is so.  I am only
                    // preserving the semantics from AddAutomaticRoutes
                    // Either way the consequences are not drastic since
                    // this does not affect the IP forwarding table in 
                    // the stack.
                    //      - VRaman
                    //

                    //
                    // We arrive at the fact that this is a subnet route
                    // in a roundabout fashion by eliminating 
                    // PROTO_IP_LOCAL routes that are host routes and
                    // by eliminating any broadcast routes
                    //
                    // Since the host route check eliminates all routes
                    // with an all 1's mask, subnet/net broadcast routes
                    // are also eliminated.
                    //
                    
                    wRouteFlags = RTM_ROUTE_FLAGS_LOCAL;
                }


                //
                // mark mcast/bcast route as invalid so the protocols
                // do not advertize them
                //

                dwClassMask = GetClassMask(RtInfo.dwRtInfoDest);
                
                if ((RtInfo.dwRtInfoDest & (DWORD) 0x000000FF) >= 
                        ((DWORD) 0x000000E0) ||
                    (RtInfo.dwRtInfoDest == 
                        (RtInfo.dwRtInfoDest | ~dwClassMask)))
                {
                    bValid = FALSE;
                }

                else
                {
                    //
                    // For PROTO_IP_LOCAL we do not add them back to
                    // the stack since these are managed by the stack
                    // We add them to RTM only to keep the user mode 
                    // route table synchronized with the stack
                    //
                    //  On second thoughts, we do need to add them
                    //  back to the stack.  More accurately, we need to 
                    //  try and add them back to the stack.  This 
                    //  operation should fail, but as a side effect of 
                    //  this existing non PROTO_IP_LOCAL in the stack 
                    //  will be deleted.
                    //  This is required in case of local subnet 
                    //  routes.  It is possible that before an 
                    //  interface is enabled with IP, a route to the 
                    //  connected subnet may have been learnt over 
                    //  another interface via a routing protocol and
                    //  added to the stack.  When an interface is
                    //  enabled all previously added routes to the 
                    //  local subnet should be deleted if the 
                    //  PROTO_IP_LOCAL route is the best route (which
                    //  it should be unless you have a really wierd set 
                    //  of protocol preferences).  
                    //  Otherwise we run the risk of having non-best 
                    //  routes in the IP stack that are never deleted
                    //  when the user mode route corresponding to it is 
                    //  deleted since you do not get a route change 
                    //  notification for non-best routes.  The result is
                    //  that you end up with state routes in the stack
                    //

                    if (RtInfo.dwRtInfoMask != HOST_ROUTE_MASK)
                    {
                        bStack = TRUE;
                    }
                }
            }

            //
            // Routes learn't from the stack are normally not
            // added back to the stack.  Hence the bStack is
            // initialized to FALSE.
            //
            // PROTO_IP_NETMGT are not managed by the stack.  They
            // can be added/deleted/updated by user mode processes.
            // As consequence a NETMGT route learned from the stack
            // may be superseded by a route with a different protocol
            // ID e.g. static.  When the superseding route is deleted
            // the NETMGMT routes need to be restored to the stack.
            // Hence for NETMGMT routes we set bStack = true.
            //
            //  An exception the processing of NETMGMT routes are HOST routes 
            //  It is assumed by host routes added directly to the 
            //  stack are managed by the process adding/deleting them 
            //  e.g.RASIPCP
            //  They are added to RTM for sync. with the stack route table
            //  only.  So for these we set bStack = FALSE
            //
            //
            
            if ((RtInfo.dwRtInfoProto is PROTO_IP_NETMGMT) &&
                (RtInfo.dwRtInfoMask isnot HOST_ROUTE_MASK))
            {
                bStack = TRUE;
            }

            TraceRoute5(
                ROUTE, "NHOP mask %d.%d.%d.%d, Flag 0x%x, Valid %d, "
                "Stack %d, P2P %d", 
                PRINT_IPADDR(GetBestNextHopMaskGivenICB( 
                    pIcb, RtInfo.dwRtInfoNextHop)), 
                wRouteFlags,
                bValid,
                bStack,
                IsIfP2P(pIcb->ritType)
                );

            dwResult = AddSingleRoute(
                            RtInfo.dwRtInfoIfIndex,
                            &RtInfo,
                            GetBestNextHopMaskGivenICB(
                                pIcb, RtInfo.dwRtInfoNextHop
                                ),
                            wRouteFlags,
                            bValid,
                            bStack,
                            IsIfP2P(pIcb->ritType),
                            NULL
                            );
                            
            if (dwResult != NO_ERROR)
            {
                Trace2(
                    ERR, "HandleRouteChangeNotification: Failed to add "
                    "route %d.%d.%d.%d, error %d",
                    PRINT_IPADDR(RtInfo.dwRtInfoDest),
                    dwResult
                    );

                break;
            }
        }

        else if (dwFlags & IRNO_FLAG_DELETE)
        {
            dwResult = DeleteSingleRoute(
                        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_ifindex,
                        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_dest,
                        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_mask,
                        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_nexthop,
                        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_proto,
                        IsIfP2P(pIcb->ritType)
                        );
            
            if (dwResult != NO_ERROR)
            {
                Trace2(
                    ERR, "HandleRouteChangeNotification: Failed to" 
                    "delete route %d.%d.%d.%d, error %d",
                    PRINT_IPADDR(
                        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_dest),
                    dwResult
                    );
                    
                break;
            }
        }

        else
        {
            Trace1(
                ERR, "HandleRouteChangeNotification: Invalid flags "
                "0x%x",
                g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_flags
                );
                
            break;
        }
        
        if (RtInfo.dwRtInfoProto is PROTO_IP_NETMGMT)
        {
            UpdateStackRoutesToRestoreList( 
                ConvertRouteInfoToMibRoute( &RtInfo ),
                dwFlags 
                );
        }

    } while (FALSE);

    EXIT_LOCK(ICB_LIST);
    
    PostIoctlForRouteChangeNotification(ulIndex);
    
    TraceLeave("HandleRouteChangeNotification");

    return dwResult;
}


VOID
AddLoopbackRoute(
    DWORD       dwIfAddress,
    DWORD       dwIfMask
    )
{
    DWORD dwResult;
    INTERFACE_ROUTE_INFO rifRoute;
    MIB_IPFORWARDROW mibRoute;

    if(g_pLoopbackInterfaceCb is NULL)
    {
        Trace0(ERR, "AddLoopbackRoute: No loopback interface");

        return;
    }
    
    rifRoute.dwRtInfoMask       = HOST_ROUTE_MASK;
    rifRoute.dwRtInfoNextHop    = IP_LOOPBACK_ADDRESS;
    rifRoute.dwRtInfoDest       = dwIfAddress;
    rifRoute.dwRtInfoIfIndex    = g_pLoopbackInterfaceCb->dwIfIndex;
    rifRoute.dwRtInfoMetric2    = 0;
    rifRoute.dwRtInfoMetric3    = 0;
    rifRoute.dwRtInfoPreference = ComputeRouteMetric(MIB_IPPROTO_LOCAL);
    rifRoute.dwRtInfoViewSet    = RTM_VIEW_MASK_UCAST |
                                  RTM_VIEW_MASK_MCAST; // XXX config
    rifRoute.dwRtInfoType       = MIB_IPROUTE_TYPE_DIRECT;
    rifRoute.dwRtInfoProto      = MIB_IPPROTO_LOCAL;
    rifRoute.dwRtInfoAge        = 0;
    rifRoute.dwRtInfoNextHopAS  = 0;
    rifRoute.dwRtInfoPolicy     = 0;

    //
    // Query IP stack to verify for loopback route
    // corresponding to this binding
    //

    dwResult = GetBestRoute(
                    dwIfAddress,
                    0,
                    &mibRoute
                    );

    if(dwResult isnot NO_ERROR)
    {
        Trace2(
            ERR,
            "AddLoopbackRoute: Stack query for loopback route" 
            " associated with %d.%d.%d.%d failed, error %d",
            PRINT_IPADDR(dwIfAddress),
            dwResult
            );

        return;
    }


    if (mibRoute.dwForwardIfIndex != 
            g_pLoopbackInterfaceCb->dwIfIndex)
    {
        //
        // There appears to be no loopback address 
        // very strange
        //
        
        Trace1(
            ERR,
            "AddLoopbackRoute: No loopback route for %d.%d.%d.%d" 
            "in stack",
            PRINT_IPADDR(dwIfAddress)
            );

        return;
    }

    //
    // Use metric returned from stack.
    //
    
    rifRoute.dwRtInfoMetric1   = mibRoute.dwForwardMetric1;

    dwResult = AddSingleRoute(g_pLoopbackInterfaceCb->dwIfIndex,
                              &rifRoute,
                              dwIfMask,
                              0,    // RTM_ROUTE_INFO::Flags
                              TRUE,
                              FALSE,
                              FALSE,
                              NULL);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AddLoopbackRoute: Couldnt add 127.0.0.1 route associated with %x",
               dwIfAddress);
    }

    return;
}


VOID
UpdateStackRoutesToRestoreList(
    IN  PMIB_IPFORWARDROW   pmibRoute,
    IN  DWORD               dwFlags
    )
/*++

Routine Description:
    This routine adds/deletes PROTO_IP_NETMGMT routes to/from the global 
    list g_leStackRoutesToRestore.  This list is used by IP router 
    manager to restore routes these routes to the TCP/IP stack when it 
    is shutting down

Parameters
    pirf    - Route to be added or deleted
    dwFlags - Specifies whether the operation is add or delete

Return Value
    None

Context:
    Invoked from 
        HandleRouteChangeNotification 
        [Set/Delete]IpForwardRow
    
--*/
{
    BOOL                bFound;
    PROUTE_LIST_ENTRY   prl, prlNew;

    
    TraceEnter("UpdateStackRoutes");
    
    TraceRoute5(
        ROUTE,
        "UpdateStackRoutes : Route "
        "%d.%d.%d.%d/%d.%d.%d.%d via i/f 0x%x "
        "nexthop %d.%d.%d.%d is being 0x%x "
        "user mode",
        PRINT_IPADDR(pmibRoute->dwForwardDest),
        PRINT_IPADDR(pmibRoute->dwForwardMask),
        pmibRoute->dwForwardIfIndex,
        PRINT_IPADDR(pmibRoute->dwForwardNextHop),
        dwFlags
        );

    ENTER_WRITER(STACK_ROUTE_LIST);
    
    //
    // Locate route in list
    //

    bFound = LookupStackRoutesToRestoreList(
                pmibRoute,
                &prl
                );

    do
    {
        //
        // Is this a route update or add
        //
        
        if ((dwFlags is 0) or (dwFlags & IRNO_FLAG_ADD))
        {
            //
            //  if route is not found, add it
            //

            if (!bFound)
            {
                if (dwFlags is 0)
                {
                    //
                    // Strange that route is not around in
                    // user mode though it is present in the
                    // stack (update case).
                    //
                    // Print a trace to note this and add it
                    // anyway
                    //

                    Trace4(
                        ERR,
                        "UpdateStackRoutes : Route "
                        "%d.%d.%d.%d/%d.%d.%d.%d via i/f 0x%x "
                        "nexthop %d.%d.%d.%d not found in "
                        "user mode",
                        PRINT_IPADDR(pmibRoute->dwForwardDest),
                        PRINT_IPADDR(pmibRoute->dwForwardMask),
                        pmibRoute->dwForwardIfIndex,
                        PRINT_IPADDR(pmibRoute->dwForwardNextHop)
                        );
                }
                
                //
                // Allocate and store route in a linked list
                //

                prlNew = HeapAlloc(
                            IPRouterHeap, HEAP_ZERO_MEMORY, 
                            sizeof(ROUTE_LIST_ENTRY)
                            );

                if (prlNew is NULL)
                {
                    Trace2(
                        ERR, 
                        "UpdateStackRoutes : error %d allocating %d"
                        " bytes for stack route entry",
                        ERROR_NOT_ENOUGH_MEMORY,
                        sizeof(ROUTE_LIST_ENTRY)
                        );

                    break;
                }

                InitializeListHead( &prlNew->leRouteList );

                prlNew->mibRoute = *pmibRoute;

                InsertTailList( 
                    (prl is NULL) ? 
                        &g_leStackRoutesToRestore :
                        &prl->leRouteList, 
                    &prlNew->leRouteList 
                    );
                    
                break;
            }
            
            //
            // route is found, update it
            //

            prl->mibRoute = *pmibRoute;

            break;
        }


        //
        // Is this a route delete
        //

        if (dwFlags & IRNO_FLAG_DELETE)
        {
            if (bFound)
            {
                RemoveEntryList( &prl->leRouteList );
                HeapFree(IPRouterHeap, 0, prl);
            }
        }
        
    } while( FALSE );
    
    EXIT_LOCK(STACK_ROUTE_LIST);

    TraceLeave("UpdateStackRoutes");
}



BOOL
LookupStackRoutesToRestoreList(
    IN  PMIB_IPFORWARDROW   pmibRoute,
    OUT PROUTE_LIST_ENTRY   *pRoute
    )
/*++

Routine Description:
    This routine searches g_leStackRoutesToRestore to determine if the 
    route specified by pmibRoute is present.  If it is it returns TRUE 
    and a pointer to the specified route in pRoute.  If is not present 
    FALSE is returned along with a pointer to the next route in list.  
    If there are no routes, pRoute is NULL

Parameters
    pmibRoute   - Route to locate in g_leStackRoutesToRestore
    pRoute      - Pointer to the route entry if present
                - Pointer to the next route entry if not present
                  (save additional lookups in case of route entry 
                   additions)
                - NULL if list is empty

Return Value:
    TRUE    - if route found
    FALSE   - otherwise


Context:
    Should be called with the lock for g_leStackRoutesToRestore
--*/
{
    INT iCmp;
    BOOL bFound = FALSE;
    PLIST_ENTRY ple;
    PROUTE_LIST_ENTRY prl;

    *pRoute = NULL;
    
    if (IsListEmpty(&g_leStackRoutesToRestore))
    {
        return bFound;
    }
    
    for (ple = g_leStackRoutesToRestore.Flink;
         ple != &g_leStackRoutesToRestore;
         ple = ple->Flink)
    {
        prl = CONTAINING_RECORD( 
                ple, ROUTE_LIST_ENTRY, leRouteList
                );

        if (INET_CMP(
                prl->mibRoute.dwForwardDest &
                prl->mibRoute.dwForwardMask,
                pmibRoute->dwForwardDest &
                pmibRoute->dwForwardMask,
                iCmp
                ) < 0 )
        {
            continue;
        }

        else if (iCmp > 0)
        {
            //
            // we have gone past the possible location
            // of the specified route
            //

            break;
        }

        //
        // found a matching dest, check if the i/f is
        // the same.
        //

        if ((prl->mibRoute.dwForwardIfIndex is 
                pmibRoute->dwForwardIfIndex ) and
            (prl->mibRoute.dwForwardNextHop is
                pmibRoute->dwForwardNextHop))
        {
            bFound = TRUE;
            break;
        }
    }

    if (ple == &g_leStackRoutesToRestore)
    {
        *pRoute = (PROUTE_LIST_ENTRY)NULL;
    }

    else
    {
        *pRoute = prl;
    }
    
    return bFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\rtmops.c ===
#include "allinc.h"

DWORD
RtmEventCallback (
     IN     RTM_ENTITY_HANDLE               hRtmHandle,
     IN     RTM_EVENT_TYPE                  retEvent,
     IN     PVOID                           pContext1,
     IN     PVOID                           pContext2
     )

/*++

Routine Description:

    This callback is given by RTM when we have changed dests
    to process. We just queue a work item to process changed
    destinations.

Arguments:

    hRtmHandle      -   Handle that we got during registration
    
    retEvent        -   Event type - we only handle events of
                        type "more changes available" for now
    
    pContext1       -   Notification handle on which changes
                        are available

    pContext2       -   Context supplied during notification
                        registration time
    
Return Value:

    Status of the operation.
    
--*/

{
    DWORD   dwResult;
    
    // Only "change notifications available" is supported
    
    if (retEvent != RTM_CHANGE_NOTIFICATION)
    {
        return ERROR_NOT_SUPPORTED;
    }

    return ((HANDLE) pContext1) == g_hNotification ?
            ProcessChanges(g_hNotification) :
            ProcessDefaultRouteChanges( g_hDefaultRouteNotification );
}


DWORD
WINAPI
ProcessChanges (
    IN      HANDLE                          hNotifyHandle
    )

/*++

Routine Description:

    Upon learning that  we have changed destinations to 
    process, this function gets called. We retrieve all
    destinations to process and take appropriate action.

Arguments:

    hRtmHandle      - RTM registration handle
    
    hNotifyHandle   - Handle correponding to the change notification 
                      that is being signalled
    
Return Value:

    Status of the operation.
    
--*/

{
    PRTM_DEST_INFO  pDestInfo;
    PRTM_ROUTE_INFO pRouteInfo;
    DWORD           dwDests;
    DWORD           dwResult;
    BOOL            bMark = FALSE;


    TraceEnter("ProcessChanges");

    pRouteInfo = HeapAlloc(
                    IPRouterHeap,
                    0,
                    RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                    );

    if (pRouteInfo == NULL)
    {
        Trace1(
            ERR, "ProcessChanges : error allocating %d bytes for "
            "route info",
            RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
            );

        TraceLeave("ProcessChanges");

        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    pDestInfo = HeapAlloc(
                    IPRouterHeap,
                    0,
                    RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
                    );

    if (pDestInfo == NULL)
    {
        Trace1(
            ERR, "ProcessChanges : error allocating %d bytes for "
            "dest. info",
            RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
            );

        HeapFree(IPRouterHeap, 0, pRouteInfo);
        
        TraceLeave("ProcessChanges");

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwDests = 1;
    
    // Get each changed dest from the table

    do
    {
        RtmGetChangedDests(g_hLocalRoute,
                           hNotifyHandle,
                           &dwDests,
                           pDestInfo);
        if (dwDests < 1)
        {
            break;
        }

        //
        // For default routes, mark the route so that future changes
        // are managed by ProcessDefaultRouteChanges.
        //
        // We need to do this here so that default routes added by
        // routing protocols RIP/OSPF are marked for change notification
        // These default routes are added by entities other than 
        // RouterManager.  Default routes added by RM i.e STATIC, 
        // AUTO-STATIC and NETMGMT default routes are already marked for
        // change notification when they are added by RM.
        //
        // By marking routing protocol default routes here we make sure
        // that all default routes are subsequently handled by marked changed 
        // mechanism (ProcessDefaultRouteChanges).
        //
        
        if (pDestInfo->DestAddress.NumBits is 0)
        {
            TraceRoute2(
                ROUTE, "Checking dest %d.%d.%d.%d/%d is marked", 
                PRINT_IPADDR(*(ULONG *)pDestInfo->DestAddress.AddrBits),
                PRINT_IPADDR(pDestInfo->DestAddress.NumBits)
                );

            dwResult = RtmIsMarkedForChangeNotification(
                        g_hNetMgmtRoute,
                        g_hDefaultRouteNotification,
                        pDestInfo->DestHandle,
                        &bMark
                        );

            if (dwResult is NO_ERROR)
            {
                if (bMark)
                {
                    //
                    // default route is already marked, nothing further
                    // to do here.  This default route change will be
                    // handled by ProcessDefaultRouteChanges
                    //

                    TraceRoute0( 
                        ROUTE, 
                        "ProcessChanges : Route 0/0 is already marked"
                        );

                    RtmReleaseChangedDests(g_hLocalRoute,
                                           hNotifyHandle,
                                           dwDests,
                                           pDestInfo);

                    continue;
                }

                //
                // Default route is not marked, mark it
                //

                dwResult = RtmMarkDestForChangeNotification(
                            g_hNetMgmtRoute,
                            g_hDefaultRouteNotification,
                            pDestInfo->DestHandle,
                            TRUE
                            );

                if (dwResult isnot NO_ERROR)
                {
                    //
                    // Failed to mark 0/0 route.  The consequence is that
                    // only best route changes are processed.  We will
                    // have to live with the fact that we cannot 
                    // install multiple NETMGMT default routes since 
                    // this is performed by the mark dest. change 
                    // processing (in ProcessDefaultRouteChanges)
                    //
                    
                    Trace1(
                        ERR, 
                        "ProcessChanges: error %d marking default route",
                        dwResult
                        );
                }
            }

            else
            {
                //
                // Failed to check is 0/0 destination has been
                // marked for change notification
                // - Refer previous comment
                //
                
                Trace1(
                    ERR, 
                    "ProcessChanges: error %d checking if default route "
                    "marked",
                    dwResult
                    );
            }
        }

        
        // Check if we have a route in Unicast view
        
        if (pDestInfo->BelongsToViews & RTM_VIEW_MASK_UCAST)
        {
            // This is either a new or update route

            // Update the same route in KM Frwder

            ASSERT(pDestInfo->ViewInfo[0].ViewId is RTM_VIEW_ID_UCAST);

            dwResult = RtmGetRouteInfo(g_hLocalRoute,
                                       pDestInfo->ViewInfo[0].Route,
                                       pRouteInfo,
                                       NULL);

            // An error mean route just got deleted
            // Ignore this change as it is obsolete

            if (dwResult is NO_ERROR)
            {
                ChangeRouteWithForwarder(&pDestInfo->DestAddress,
                                         pRouteInfo,
                                         TRUE,
                                         TRUE);

                RtmReleaseRouteInfo(g_hLocalRoute,
                                    pRouteInfo);
            }            
        }
        else
        {
            // The last UCAST route has been deleted

            // Delete the same route from KM Frwder

            //
            // Check to make sure that the route was added to
            //  the forwarder.  If not there is no need to 
            //  ChangeRouteWithForwarder.
            //
            // This rather kludgy fix was done for 446075
            //  The problem here is really a fallout of
            //  of RTMv2 behavior and how IPRTRMGR uses
            //  RTM.
            //
            // Routes added to RTM and not to the TCP/IP
            //  stack are marked as such in the Flags1 field
            //  of the RTM_ROUTE_INFO struture.  (they have
            //  the IP_STACK_ROUTE bit turned off).
            //
            //  The problem arises when a particular destination
            //  is no longer reachable i.e. all routes to it have
            //  been deleted.  When a change notification for this
            //  is processed by IPRTRMGR, it no longer has access
            //  to the RTM_ROUTE_INFO STUCTURE for the last route
            //  to the destination and consequently no access to
            //  the flags field mentioned above.  Hence routes
            //  were being deleted from the the TCP/IP stack that
            //  had not been added by IPRTRMGR.
            //
            //  In the normal case this is not a problem.  However
            //  for host routes added by PPTP directly to TCP/IP stack 
            //  a problem arises as follows:
            //
            //  1. Host route to VPN server Route added by PPTP to TCP
            //  2. IPRTRMGR notified of route by TCP.
            //  3. IPRTRMGR added route to RTM with stack bit cleared
            //      as we do not want to readd this route to stack.
            //  4. RTM notifies IPRTRMGR to new best route.
            //  5. IPRTRMGR skips adding this route to the stack as
            //      its stack bit is cleared.
            //
            //  6. Host route to VPN server Route deleted by PPTP to TCP
            //  7. IPRTRMGR notified of route deletion by TCP
            //  8. IPRTRMGR deleted route from RTM
            //  9. RTM notified IPRTRMGR of route/dest deletion
            //  10. IPRTRMGR having no idea if this was added to TCP
            //      deletes this route from TCP.
            //  
            //  Somewhere between steps 7 and 10, PPTP adds the route
            //  to TCP again.  Step 10 deleted the new route in TCP in
            //  response to the old route being deleted thereby 
            //  disabling the new PPTP connection.
            //
            //  To get around this problem we set state in the 
            //  destination RTM_DEST_INFO to flag this condition. This
            //  is not a complete fix, allows IPRTRMGR to not delete 
            //  routes from TCP that were added by it in the first
            //  place.
            //
            //  Refer AddRtmRoute to figure out for which routes this
            //  state is set.
            //
            
            TraceRoute2(
                ROUTE, "Route delete notification for "
                "%d.%d.%d.%d/%d",
                PRINT_IPADDR(*(ULONG *)pDestInfo->DestAddress.AddrBits),
                pDestInfo->DestAddress.NumBits
                );

            //
            // if this is a host route
            //
            
            if(pDestInfo->DestAddress.NumBits is HOST_MASK_LENGTH)
            {
                PBYTE pbOpaque;
                
                do
                {
                    //
                    //  1. Get the opaque pointer for NETMGMT
                    //

                    dwResult = RtmGetOpaqueInformationPointer(
                                g_hNetMgmtRoute,
                                pDestInfo->DestHandle,
                                &pbOpaque
                                );
                                
                    if(dwResult isnot NO_ERROR)
                    {
                        Trace1(
                            ERR,
                            "AddRtmRoute : error %d retrieving opaque "
                            "info",
                            dwResult
                            );

                        break;
                    }

                    //
                    //  2. Check if this route was set to stack
                    //

                    if(*((PDWORD) pbOpaque) isnot RTM_NOT_STACK_ROUTE)
                    {
                        TraceRoute1(
                            ROUTE, "Host route with Stack bit 0x%x",
                            *((PDWORD) pbOpaque)
                            );

                        //
                        //  3.1 If so delete it.
                        //

                        ChangeRouteWithForwarder(
                            &pDestInfo->DestAddress,
                            NULL,
                            FALSE,
                            TRUE
                            );
                    }

                    else
                    {
                        //
                        // 3.2 Otherwise move on.
                        //
                        
                        TraceRoute1(
                            ROUTE, "Stack bit not set on host "
                            "route, Skipping deleting 0x%x",
                            *((PDWORD) pbOpaque)
                            );
                    }
                    
                }while( FALSE );                                
            }
            
            else 
            {
                TraceRoute0(ROUTE, "Deleting a subnet route" );
                
                ChangeRouteWithForwarder(&pDestInfo->DestAddress,
                                         NULL,
                                         FALSE,
                                         TRUE);
            }
        }

        RtmReleaseChangedDests(g_hLocalRoute,
                               hNotifyHandle,
                               dwDests,
                               pDestInfo);
    }
    while (TRUE);

    HeapFree(IPRouterHeap, 0, pRouteInfo);

    HeapFree(IPRouterHeap, 0, pDestInfo);
    
    TraceLeave("ProcessChanges");

    return NO_ERROR;
}



DWORD
WINAPI
ProcessDefaultRouteChanges(
    IN      HANDLE                          hNotifyHandle
    )

/*++

Routine Description:

    This function is invoked in response to changes to
    the default route.  If the best default route is owned
    by protocol PROTO_IP_NETMGMT enumerate all PROTO_IP_NETMGMT
    routes for default route 0/0 and set them as one
    multihop route to the forwarder
    
Arguments:

    hRtmHandle      - RTM registration handle
    
    hNotifyHandle   - Handle correponding to the change notification 
                      that is being signalled
    

Return Value:

    NO_ERROR    - Success

    System error code - Otherwise
    
--*/
{
    PRTM_DEST_INFO  pDestInfo;
    PRTM_ROUTE_INFO pRouteInfo;
    DWORD           dwDests;
    DWORD           dwResult;


    TraceEnter("ProcessDefaultRouteChanges");
    
    pRouteInfo = HeapAlloc( 
                    IPRouterHeap,
                    0,
                    RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                    );
                    
    if (pRouteInfo == NULL)
    {
        Trace1(
            ERR, "ProcessDefaultRouteChanges : error allocating %d bytes for "
            "route info",
            RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
            );

        TraceLeave("ProcessDefaultRouteChanges");

        return ERROR_NOT_ENOUGH_MEMORY;
    }
                
    pDestInfo = HeapAlloc(
                    IPRouterHeap,
                    0,
                    RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
                    );

    if (pDestInfo == NULL)
    {
        Trace1(
            ERR, "ProcessDefaultRouteChanges : error allocating %d bytes for "
            "dest. info",
            RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
            );

        HeapFree(IPRouterHeap, 0, pRouteInfo);
        
        TraceLeave("ProcessDefaultRouteChanges");

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do
    {
        //
        // retreive changed dests
        //

        dwDests = 1;

        dwResult = RtmGetChangedDests(
                    g_hNetMgmtRoute,
                    hNotifyHandle,
                    &dwDests,
                    pDestInfo
                    );

        if ((dwResult isnot NO_ERROR) and 
            (dwResult isnot ERROR_NO_MORE_ITEMS))
        {
            Trace1(
                ERR, 
                "ProcessDefaultRouteChanges: error %d retrieving changed dests",
                dwResult
                );

            break;
        }

        if (dwDests < 1)
        {
            //
            // no more dests to enumerate
            //

            break;
        }


        do
        {
            //
            // Make sure this the default route 0/0.  This functions
            // only processes default route changes.
            //

            if ((pDestInfo->DestAddress.NumBits isnot 0) or
                (*((ULONG *)pDestInfo->DestAddress.AddrBits) isnot 0))
            {
                Trace2(
                    ERR,
                    "ProcessDefaultRouteChanges: Not default route %d.%d.%d.%d/%d",
                    PRINT_IPADDR(*((ULONG *)pDestInfo->DestAddress.AddrBits)),
                    pDestInfo->DestAddress.NumBits
                    );

                break;
            }

            //
            // If all routes to 0/0 have been deleted,
            // delete it from the forwarder too.
            //

            if (!(pDestInfo->BelongsToViews & RTM_VIEW_MASK_UCAST))
            {
                dwResult = ChangeRouteWithForwarder(
                                &(pDestInfo->DestAddress),
                                NULL,
                                FALSE,
                                TRUE
                                );

                break;
            }

            //
            // A route to 0/0 was added/updated
            //

            if (pDestInfo->ViewInfo[0].Owner isnot g_hNetMgmtRoute)
            {
                //
                // Default route is not owned by PROTO_IP_NETMGT
                // Add only the best route to forwarder
                //
                
                TraceRoute1(
                    ROUTE,
                    "ProcessDefaultRouteChanges: Adding non-NetMgmt"
                    " route to forwarder, owner RTM handle 0x%x",
                    pDestInfo->ViewInfo[0].Owner
                    );

                dwResult = RtmGetRouteInfo(
                            g_hNetMgmtRoute,
                            pDestInfo->ViewInfo[0].Route,
                            pRouteInfo,
                            NULL
                            );

                if (dwResult is NO_ERROR)
                {
                    ChangeRouteWithForwarder(
                        &pDestInfo->DestAddress,
                        pRouteInfo,
                        TRUE,
                        TRUE
                        );

                    dwResult = RtmReleaseRouteInfo(
                                g_hNetMgmtRoute,
                                pRouteInfo
                                );
                                
                    if (dwResult isnot NO_ERROR)
                    {
                        Trace1(
                            ERR, 
                            "ProcessDefaultRouteChanges: Failed "
                            "to release route info",
                            dwResult
                            );
                    }
                }
                
                break;
            }
            
            //
            // Default route owned by PROTO_IP_NETMGMT
            //

            //
            // First delete existing 0/0 from the TCP/IP forwarder
            //

            dwResult = ChangeRouteWithForwarder(
                            &(pDestInfo->DestAddress),
                            NULL,
                            FALSE,
                            TRUE
                            );

            if (dwResult isnot NO_ERROR)
            {
                Trace1(
                    ERR,
                    "ProcessDefaultRouteChanges: error %d deleting "
                    "old NetMgmt default routes from forwarder",
                    dwResult
                    );
                    
                // break;
            }

            //
            // Second add all NETMGMT 0/0 to the TCP/IP forwarder
            //
            
            AddNetmgmtDefaultRoutesToForwarder(pDestInfo);
                
        } while( FALSE );


        //
        // release handles to changed destinations
        //
        
        dwResult = RtmReleaseChangedDests(
                    g_hNetMgmtRoute,
                    hNotifyHandle,
                    dwDests,
                    pDestInfo
                    );

        if (dwResult isnot NO_ERROR)
        {
            Trace1(
                ERR,
                "ProcessDefaultRouteChanges: error %d releasing dests ",
                dwResult
                );
        }

    } while ( TRUE );

    HeapFree(IPRouterHeap, 0, pRouteInfo);

    HeapFree(IPRouterHeap, 0, pDestInfo);
    
    TraceLeave("ProcessDefaultRouteChanges");

    return dwResult;
}


DWORD
WINAPI
AddNetmgmtDefaultRoutesToForwarder(
    PRTM_DEST_INFO                          pDestInfo
    )
/*++

Routine Description:

    This routine enumerates the routes to 0/0 added by protocol
    PROTO_IP_NETMGT and adds them to the forwarder.  This routine
    is invoked in response to any change to the default route
    If the best default route is owned by PROTO_IP_NETMGMT, all
    PROTO_IP_NETMGMT default routes are added to the TCP/IP
    forwarder.  

    This is required since the TCP/IP stack does dead gateway
    detection and that required multiple default routes if
    present to be installed in the stack.

    An implicit assumption here is that PROTO_IP_NETMGMT routes
    alone merit this treatment.  In case of static or other
    protocol generated 0/0 routes, only the best route is
    added to the stack.  It is assumed that in the later case(s)
    the administrator (for static routes) or the protocol has
    a better idea of routing and so the dead gateway detection
    is suppressed in the stack by the addition of the best route
    to 0/0 alone.

Arguments:

    pDestInfo - RTM destination info structure of 0/0 route


Return Value :

    NO_ERROR -  Sucess

    Win32 error code - Otherwise

--*/
{
    DWORD               dwResult, dwNumHandles = 0, i;
    BOOL                bRelEnum = FALSE, bRelRoutes = FALSE;
    PRTM_ROUTE_INFO     pRouteInfo;
    PRTM_ROUTE_HANDLE   pHandles;
    RTM_ENUM_HANDLE     hRouteEnum;


    dwNumHandles = pDestInfo->ViewInfo[0].NumRoutes;
    
    pHandles = HeapAlloc(
                IPRouterHeap,
                0,
                dwNumHandles * sizeof(RTM_ROUTE_HANDLE)
                );

    if (pHandles == NULL)
    {
        Trace1(
            ERR,
            "AddNetmgmtDefaultRoutesToForwarder: error allocating %d bytes"
            "for route handles",
            dwNumHandles * sizeof(RTM_ROUTE_HANDLE)
            );
            
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pRouteInfo = HeapAlloc( 
                    IPRouterHeap,
                    0,
                    RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                    );
                    
    if (pRouteInfo == NULL)
    {
        Trace1(
            ERR,
            "AddNetmgmtDefaultRoutesToForwarder: error allocating %d bytes"
            "for route info",
            RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
            );
            
        HeapFree(IPRouterHeap, 0, pHandles);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    do
    {
        //
        // Enumerate and add all NETMGMT routes to the forwarder
        //

        dwResult = RtmCreateRouteEnum(
                    g_hNetMgmtRoute,
                    pDestInfo->DestHandle,
                    RTM_VIEW_MASK_UCAST,
                    RTM_ENUM_OWN_ROUTES,
                    NULL,
                    0,
                    NULL,
                    0,
                    &hRouteEnum
                    );

        if (dwResult isnot NO_ERROR)
        {
            Trace1(
                ERR,
                "AddNetmgmtDefaultRoutesToForwarder: error %d creating route "
                "enumeration",
                dwResult
                );

            break;
        }

        bRelEnum = TRUE;
        
        dwResult = RtmGetEnumRoutes(
                    g_hNetMgmtRoute,
                    hRouteEnum,
                    &dwNumHandles,
                    pHandles
                    );

        if (dwResult isnot NO_ERROR)
        {
            Trace1(
                ERR,
                "ProcessDefaultRouteChanges:error %d enumerating "
                "routes",
                dwResult
                );

            break;
        }

        bRelRoutes = TRUE;

        //
        // Change route with the forwarder
        //

        for (i = 0; i < dwNumHandles; i++)
        {
            dwResult = RtmGetRouteInfo(
                        g_hNetMgmtRoute,
                        pHandles[i],
                        pRouteInfo,
                        NULL
                        );

            if (dwResult is NO_ERROR)
            {
                ChangeRouteWithForwarder(
                    &(pDestInfo->DestAddress),
                    pRouteInfo,
                    TRUE,
                    FALSE
                    );

                dwResult = RtmReleaseRouteInfo(
                            g_hNetMgmtRoute,
                            pRouteInfo
                            );

                if (dwResult isnot NO_ERROR)
                {
                    Trace1(
                        ERR,
                        "ProcessDefaultRouteChanges: error %d releasing "
                        "route info ",
                        dwResult
                        );
                }
            }
            else
            {
                Trace2(
                    ERR,
                    "ProcessDefaultRouteChanges: error %d getting route "
                    "info for route %d",
                    dwResult, i
                    );
            }
        }
        
    } while( FALSE );

    //
    // Release handles
    //

    if (bRelRoutes)
    {
        Trace0(ROUTE, "Releasing routes to 0/0");

        dwResult = RtmReleaseRoutes(
                    g_hNetMgmtRoute,
                    dwNumHandles,
                    pHandles
                    );

        if (dwResult isnot NO_ERROR)
        {
            Trace1(
                ERR,
                "ProcessDefaultRouteChanges: error %d deleting enum "
                "handle",
                dwResult
                );
        }
    }

    if (bRelEnum)
    {
        Trace0(ROUTE, "Releasing route enum for 0/0");
        
        dwResult = RtmDeleteEnumHandle(
                    g_hNetMgmtRoute,
                    hRouteEnum
                    );

        if (dwResult isnot NO_ERROR)
        {
            Trace1(
                ERR,
                "ProcessDefaultRouteChanges: error %d deleting enum "
                "handle",
                dwResult
                );
        }
    }

    HeapFree(IPRouterHeap, 0, pHandles);
    HeapFree(IPRouterHeap, 0, pRouteInfo);

    return dwResult;
}


DWORD 
AddRtmRoute (
    IN      HANDLE                          hRtmHandle,
    IN      PINTERFACE_ROUTE_INFO           pRtInfo,
    IN      DWORD                           dwRouteFlags,
    IN      DWORD                           dwNextHopMask,
    IN      DWORD                           dwTimeToLive,
    OUT     HANDLE                         *phRtmRoute
    )

/*++

Routine Description:

    Adds a route to RTM with the specified route information.

Arguments:

    hRtmHandle    - RTM registration handle used in RTM calls

    pRtInfo       - 

    dwNextHopMask - 

    dwTimeToLive  - Time for which the route is kept in RTM
                    before being deleted (value is seconds).

Return Value:

    Status of the operation.

--*/

{
    PRTM_NET_ADDRESS  pDestAddr;
    PRTM_ROUTE_INFO   pRouteInfo;
    RTM_NEXTHOP_INFO  rniInfo;
    DWORD             dwFlags;
    DWORD             dwResult;
    HANDLE            hNextHopHandle;
    PADAPTER_INFO     pBinding;

    // Initialize output before caling ops
    
    if (ARGUMENT_PRESENT(phRtmRoute))
    {
        *phRtmRoute = NULL;
    }
    
    pDestAddr = HeapAlloc(
                    IPRouterHeap,
                    0,
                    sizeof(RTM_NET_ADDRESS)
                    );

    if (pDestAddr == NULL)
    {
        Trace1(
            ERR,
            "AddRtmRoute : error allocating %d bytes"
            "for dest. address",
            RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
            );
            
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pRouteInfo = HeapAlloc(
                    IPRouterHeap,
                    0,
                    RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                    );

    if (pRouteInfo == NULL)
    {
        Trace1(
            ERR,
            "AddRtmRoute : error allocating %d bytes"
            "for route info",
            RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
            );
            
        HeapFree(IPRouterHeap, 0, pDestAddr);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Add a next hop if not already present
    //

    RTM_IPV4_MAKE_NET_ADDRESS(&rniInfo.NextHopAddress,
                              pRtInfo->dwRtInfoNextHop,
                              32);
                              
    rniInfo.InterfaceIndex = pRtInfo->dwRtInfoIfIndex;
    rniInfo.EntitySpecificInfo = (PVOID) (ULONG_PTR)dwNextHopMask;
    rniInfo.Flags = 0;
    rniInfo.RemoteNextHop = NULL;

    hNextHopHandle = NULL;
    
    dwResult = RtmAddNextHop(hRtmHandle,
                             &rniInfo,
                             &hNextHopHandle,
                             &dwFlags);

    if (dwResult is NO_ERROR)
    {
        TraceRoute2(
            ROUTE, "Route to %d.%d.%d.%d/%d.%d.%d.%d",
            PRINT_IPADDR(pRtInfo->dwRtInfoDest),
            PRINT_IPADDR(pRtInfo->dwRtInfoMask)
            );
            
        TraceRoute4(
            ROUTE, "Next Hop %d.%d.%d.%d/%d.%d.%d.%d, If 0x%x, handle is 0x%x", 
            PRINT_IPADDR(pRtInfo->dwRtInfoNextHop),
            PRINT_IPADDR(dwNextHopMask),
            pRtInfo->dwRtInfoIfIndex,
            hNextHopHandle
            );

        dwResult = ConvertRouteInfoToRtm(hRtmHandle,
                                         pRtInfo,
                                         hNextHopHandle,
                                         dwRouteFlags,
                                         pDestAddr,
                                         pRouteInfo);
        if (dwResult is NO_ERROR)
        {
            //
            // If we are adding a non-dod route we should
            // adjust the state of the route to match
            // that of the interface it is being added on
            //

            if ((hRtmHandle == g_hNonDodRoute)  ||
                (hRtmHandle == g_hNetMgmtRoute))
            {
                //
                // Find the binding given the interface id
                //

                ENTER_READER(BINDING_LIST);

                pBinding = GetInterfaceBinding(pRtInfo->dwRtInfoIfIndex);

                if ((!pBinding) || (!pBinding->bBound))
                {
                    // Interface has been deleted meanwhile
                    // or is not bound at this point - quit
                    EXIT_LOCK(BINDING_LIST);
                    
                    return ERROR_INVALID_PARAMETER;
                }
            }
            
            //
            // Convert TimeToLive from secs to millisecs
            //

            if (dwTimeToLive != INFINITE)
            {
                if (dwTimeToLive < (INFINITE / 1000))
                {
                    dwTimeToLive *= 1000;
                }
                else
                {
                    dwTimeToLive = INFINITE;
                }
            }

            dwFlags = 0;

            //
            // Add the new route using the RTMv2 API call
            //
                
            dwResult = RtmAddRouteToDest(hRtmHandle,
                                         phRtmRoute,
                                         pDestAddr,
                                         pRouteInfo,
                                         dwTimeToLive,
                                         NULL,
                                         0,
                                         NULL,
                                         &dwFlags);

            if ((hRtmHandle == g_hNonDodRoute)  ||
                (hRtmHandle == g_hNetMgmtRoute))
            {
                EXIT_LOCK(BINDING_LIST);
            }


            //
            // check if route is 0/0 and route protocol is
            //  PROTO_IP_NETMGMT.  If so mark for change notification
            //

            if ((pRtInfo->dwRtInfoDest is 0) and
                (pRtInfo->dwRtInfoMask is 0))
            {
                RTM_DEST_INFO rdi;
                BOOL bMark;
                BOOL bRelDest = FALSE;
                
                do
                {
                    TraceRoute2(
                        ROUTE, "Checking dest %d.%d.%d.%d/%d for mark", 
                        PRINT_IPADDR(*(ULONG *)pDestAddr->AddrBits),
                        PRINT_IPADDR(pDestAddr->NumBits)
                        );

                    dwResult = RtmGetExactMatchDestination(
                                g_hNetMgmtRoute,
                                pDestAddr,
                                RTM_THIS_PROTOCOL,
                                RTM_VIEW_MASK_UCAST,
                                &rdi
                                );

                    if (dwResult isnot NO_ERROR)
                    {
                        Trace1(
                            ERR,
                            "AddRtmRoute: error %d failed to get "
                            "destination 0/0 for change notification",
                            dwResult
                            );

                        break;
                    }

                    bRelDest = TRUE;

                    dwResult = RtmIsMarkedForChangeNotification(
                                g_hNetMgmtRoute,
                                g_hDefaultRouteNotification,
                                rdi.DestHandle,
                                &bMark
                                );

                    if (dwResult isnot NO_ERROR)
                    {
                        Trace1(
                            ERR,
                            "AddRtmRoute: error %d failed to check "
                            "destination 0/0 for change notification",
                            dwResult
                            );

                        break;
                    }

                    if (!bMark)
                    {
                        dwResult = RtmMarkDestForChangeNotification(
                                    g_hNetMgmtRoute,
                                    g_hDefaultRouteNotification,
                                    rdi.DestHandle,
                                    TRUE
                                    );
                                    
                        if (dwResult isnot NO_ERROR)
                        {
                            Trace1(
                                ERR,
                                "AddRtmRoute: error %d failed to nark "
                                "destination 0/0 for change notification",
                                dwResult
                                );
                                
                             break;
                        }
                        
                        //
                        // Add route once more, to force marked dest
                        // change notifications to be issued for this 
                        // change
                        //

                        dwFlags  = 0;
                        
                        dwResult = RtmAddRouteToDest(
                                        hRtmHandle,
                                        phRtmRoute,
                                        pDestAddr,
                                        pRouteInfo,
                                        dwTimeToLive,
                                        NULL,
                                        0,
                                        NULL,
                                        &dwFlags
                                        );

                        if (dwResult isnot NO_ERROR)
                        {
                            Trace1(
                                ERR,
                                "AddRtmRoute: error %d added route after "
                                "marking destination",
                                dwResult
                                );

                            break;
                        }

                        TraceRoute2(
                            ROUTE, "Marked dest %d.%d.%d.%d/%d and added", 
                            PRINT_IPADDR(*(ULONG *)pDestAddr->AddrBits),
                            pDestAddr->NumBits
                            );

                    }
                    
                } while (FALSE);

                if (bRelDest)
                {
                    RtmReleaseDestInfo(
                        g_hNetMgmtRoute,
                        &rdi
                        );
                }
            }

            //
            // for host routes, added by NETMGMT
            //  if they are not added to the stack
            //
            
            if((pRtInfo->dwRtInfoMask is HOST_ROUTE_MASK) and
               (pRtInfo->dwRtInfoProto is PROTO_IP_NETMGMT) and
               (!(dwRouteFlags & IP_STACK_ROUTE)))
            {
                RTM_DEST_INFO rdi;
                BOOL bRelDest = FALSE;
                PBYTE pbOpaque = NULL;

                TraceRoute2(
                    ROUTE, 
                    "Non-stack Netmgmt host route "
                    "%d.%d.%d.%d/%d",
                    PRINT_IPADDR(*(ULONG *)pDestAddr->AddrBits),
                    pDestAddr->NumBits
                    );
                    
                do
                {
                    //
                    // Retrieve destination
                    //

                    dwResult = RtmGetExactMatchDestination(
                                g_hNetMgmtRoute,
                                pDestAddr,
                                RTM_THIS_PROTOCOL,
                                RTM_VIEW_MASK_UCAST,
                                &rdi
                                );
                                
                    if (dwResult isnot NO_ERROR)
                    {
                        Trace1(
                            ERR,
                            "AddRtmRoute : error %d retriveing host route "
                            "destination",
                            dwResult
                            );

                        break;
                    }

                    bRelDest = TRUE;

                    //
                    // get opaque info ptr.
                    //

                    dwResult = RtmLockDestination(
                                g_hNetMgmtRoute,
                                rdi.DestHandle,
                                TRUE,
                                TRUE
                                );
                                
                    if (dwResult isnot NO_ERROR)
                    {
                        Trace1(
                            ERR,
                            "AddRtmRoute : error %d locking host route "
                            "destination",
                            dwResult
                            );

                        break;
                    }

                    dwResult = RtmGetOpaqueInformationPointer(
                                g_hNetMgmtRoute,
                                rdi.DestHandle,
                                &pbOpaque
                                );

                    if(dwResult isnot NO_ERROR)
                    {
                        Trace1(
                            ERR,
                            "AddRtmRoute : error %d retrieving opaque "
                            "info",
                            dwResult
                            );

                        break;
                    }

                    *((PDWORD) pbOpaque) = RTM_NOT_STACK_ROUTE;
                    
                    dwResult = RtmLockDestination(
                                g_hNetMgmtRoute,
                                rdi.DestHandle,
                                TRUE,
                                FALSE
                                );

                    if (dwResult isnot NO_ERROR)
                    {
                        Trace1(
                            ERR,
                            "AddRtmRoute : error %d unlocking dest",
                            dwResult
                            );

                        break;
                    }
                    
                }while( FALSE );

                if (bRelDest)
                {
                    RtmReleaseDestInfo(
                        g_hNetMgmtRoute,
                        &rdi
                        );
                }
                
                TraceRoute3(
                    ROUTE, 
                    "Non-stack Netmgmt host route "
                    "%d.%d.%d.%d/%d opaq info set, res == %d",
                    PRINT_IPADDR(*(ULONG *)pDestAddr->AddrBits),
                    pDestAddr->NumBits,
                    dwResult
                    );
            }
        }
        
        // Release the next hop handle obtained above
        
        RtmReleaseNextHops(hRtmHandle, 
                           1, 
                           &hNextHopHandle);
    }

    HeapFree(IPRouterHeap, 0, pDestAddr);
    HeapFree(IPRouterHeap, 0, pRouteInfo);
        
    return dwResult;
}


DWORD 
DeleteRtmRoute (
    IN      HANDLE                          hRtmHandle,
    IN      PINTERFACE_ROUTE_INFO           pRtInfo
    )

/*++

Routine Description:

    Deletes an  RTM route with the specified route information.

Arguments:

    hRtmHandle    - RTM registration handle used in RTM calls

    pRtInfo       - 

Return Value:

    Status of the operation.

--*/

{
    PRTM_NET_ADDRESS pDestAddr;
    PRTM_ROUTE_INFO  pRouteInfo;
    RTM_NEXTHOP_INFO rniInfo;
    DWORD            dwFlags;
    DWORD            dwResult;
    HANDLE           hRouteHandle;
    HANDLE           hNextHopHandle;
    
    pRouteInfo = HeapAlloc(
                    IPRouterHeap,
                    0,
                    RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                    );

    if (pRouteInfo == NULL)
    {
        Trace1(
            ERR,
            "DeleteRtmRoute : error allocating %d bytes"
            "for route info",
            RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
            );
            
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pDestAddr = HeapAlloc(
                    IPRouterHeap,
                    0,
                    sizeof(RTM_NET_ADDRESS)
                    );

    if (pDestAddr == NULL)
    {
        Trace1(
            ERR,
            "AddRtmRoute : error allocating %d bytes"
            "for dest. address",
            RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
            );
            
        HeapFree(IPRouterHeap, 0, pRouteInfo);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    //
    // Obtain a handle to the next hop in the route
    //

    RTM_IPV4_MAKE_NET_ADDRESS(&rniInfo.NextHopAddress,
                              pRtInfo->dwRtInfoNextHop,
                              32);
                              
    rniInfo.InterfaceIndex = pRtInfo->dwRtInfoIfIndex;

    rniInfo.NextHopOwner = hRtmHandle;
    
    dwResult = RtmFindNextHop(hRtmHandle,
                              &rniInfo,
                              &hNextHopHandle,
                              NULL);

    if (dwResult isnot NO_ERROR)
    {
        HeapFree(IPRouterHeap, 0, pDestAddr);
        HeapFree(IPRouterHeap, 0, pRouteInfo);
        return dwResult;
    }

    //
    // We can get this route by matching the route's
    // net addr, its owner and neighbour learnt from
    //

    ConvertRouteInfoToRtm(hRtmHandle,
                             pRtInfo,
                             hNextHopHandle,
                             0,
                             pDestAddr,
                             pRouteInfo);

    dwResult = RtmGetExactMatchRoute(hRtmHandle,
                                     pDestAddr,
                                     RTM_MATCH_OWNER | RTM_MATCH_NEIGHBOUR,
                                     pRouteInfo,
                                     0,
                                     0,
                                     &hRouteHandle);
    if (dwResult is NO_ERROR)
    {
        //
        // Delete the route found above using the handle
        //
        
        dwResult = RtmDeleteRouteToDest(hRtmHandle,
                                        hRouteHandle,
                                        &dwFlags);

        if (dwResult isnot NO_ERROR)
        {
            // If delete successful, deref is automatic

            RtmReleaseRoutes(hRtmHandle, 
                             1, 
                             &hRouteHandle);
        }

        // Release the route information obtained above

        RtmReleaseRouteInfo(hRtmHandle,
                            pRouteInfo);
    }

    // Release the next hop handle obtained above

    RtmReleaseNextHops(hRtmHandle, 
                       1, 
                       &hNextHopHandle);
    
    HeapFree(IPRouterHeap, 0, pDestAddr);
    HeapFree(IPRouterHeap, 0, pRouteInfo);

    return dwResult;
}


DWORD
ConvertRouteInfoToRtm(
    IN      HANDLE                          hRtmHandle,
    IN      PINTERFACE_ROUTE_INFO           pRtInfo,
    IN      HANDLE                          hNextHopHandle,
    IN      DWORD                           dwRouteFlags,
    OUT     PRTM_NET_ADDRESS                pDestAddr,
    OUT     PRTM_ROUTE_INFO                 pRouteInfo
    )
{
    DWORD         dwAddrLen;
    
    // Fill the destination addr structure

    RTM_IPV4_LEN_FROM_MASK(dwAddrLen, pRtInfo->dwRtInfoMask);

    RTM_IPV4_MAKE_NET_ADDRESS(pDestAddr, 
                              pRtInfo->dwRtInfoDest,
                              dwAddrLen);

    // Fill in the route information now

    ZeroMemory(pRouteInfo, sizeof(RTM_ROUTE_INFO));

    pRouteInfo->RouteOwner  = hRtmHandle;
    pRouteInfo->Neighbour   = hNextHopHandle;
    
    pRouteInfo->PrefInfo.Metric     = pRtInfo->dwRtInfoMetric1;
    pRouteInfo->PrefInfo.Preference = pRtInfo->dwRtInfoPreference;
    pRouteInfo->BelongsToViews      = pRtInfo->dwRtInfoViewSet;

    //
    // BUG BUG BUG BUG :
    //  This is broken for future references
    //

    if(g_pLoopbackInterfaceCb && 
       pRtInfo->dwRtInfoIfIndex is g_pLoopbackInterfaceCb->dwIfIndex)
    {
        pRouteInfo->BelongsToViews &= ~RTM_VIEW_MASK_MCAST;
    }

    pRouteInfo->NextHopsList.NumNextHops = 1;
    pRouteInfo->NextHopsList.NextHops[0] = hNextHopHandle;

    // an unsigned integer is converted to a shorter
    // unsigned integer by truncating the high-order bits!
    pRouteInfo->Flags1  = (UCHAR) dwRouteFlags;
    pRouteInfo->Flags   = (USHORT) (dwRouteFlags >> 16);
            
    // Get the preference for this route 
    
    return ValidateRouteForProtocol(pRtInfo->dwRtInfoProto, 
                                    pRouteInfo,
                                    pDestAddr);

    // The following information is lost
    //
    //  dwForwardMetric2,3
    //  dwForwardPolicy
    //  dwForwardType
    //  dwForwardAge
    //  dwForwardNextHopAS
}

VOID
ConvertRtmToRouteInfo (
    IN      DWORD                           ownerProtocol,
    IN      PRTM_NET_ADDRESS                pDestAddr,
    IN      PRTM_ROUTE_INFO                 pRouteInfo,
    IN      PRTM_NEXTHOP_INFO               pNextHop,
    OUT     PINTERFACE_ROUTE_INFO           pRtInfo
    )
{
    pRtInfo->dwRtInfoDest    = *(ULONG *)pDestAddr->AddrBits;
    pRtInfo->dwRtInfoMask    = RTM_IPV4_MASK_FROM_LEN(pDestAddr->NumBits);

    pRtInfo->dwRtInfoIfIndex = pNextHop->InterfaceIndex;
    pRtInfo->dwRtInfoNextHop = *(ULONG *)pNextHop->NextHopAddress.AddrBits;

    pRtInfo->dwRtInfoProto   = ownerProtocol;

    pRtInfo->dwRtInfoMetric1 =
    pRtInfo->dwRtInfoMetric2 =
    pRtInfo->dwRtInfoMetric3 = pRouteInfo->PrefInfo.Metric;
    pRtInfo->dwRtInfoPreference = pRouteInfo->PrefInfo.Preference;
    pRtInfo->dwRtInfoViewSet    = pRouteInfo->BelongsToViews;
    
    pRtInfo->dwRtInfoPolicy  = 0;
    pRtInfo->dwRtInfoType    = 0;
    pRtInfo->dwRtInfoAge     = 0;
    pRtInfo->dwRtInfoNextHopAS = 0;

    return;
}

PINTERFACE_ROUTE_INFO
ConvertMibRouteToRouteInfo(
    IN  PMIB_IPFORWARDROW pMibRow
    )
{
    PINTERFACE_ROUTE_INFO pRouteInfo = (PINTERFACE_ROUTE_INFO)pMibRow;

    pMibRow->dwForwardMetric2 = 0;
    pMibRow->dwForwardMetric3 = 0;
    pMibRow->dwForwardMetric4 = 0;
    pMibRow->dwForwardMetric5 = 0;

    // Make sure Metric1 isn't 0

    if (pRouteInfo->dwRtInfoMetric1 is 0)
    {
        pRouteInfo->dwRtInfoMetric1 = 1;
    }

    // By default put it in both views
    pRouteInfo->dwRtInfoViewSet = RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST;

    return pRouteInfo;
}


PMIB_IPFORWARDROW
ConvertRouteInfoToMibRoute(
    IN  PINTERFACE_ROUTE_INFO pRouteInfo
    )
{
    PMIB_IPFORWARDROW pMibRoute = (PMIB_IPFORWARDROW) pRouteInfo;

    pMibRoute->dwForwardMetric2 =
    pMibRoute->dwForwardMetric3 =
    pMibRoute->dwForwardMetric4 =
    pMibRoute->dwForwardMetric5 = IRE_METRIC_UNUSED;

    pMibRoute->dwForwardAge = INFINITE;
    pMibRoute->dwForwardPolicy = 0;
    pMibRoute->dwForwardNextHopAS = 0;
    
    pMibRoute->dwForwardType = IRE_TYPE_INDIRECT;

    return pMibRoute;
}


VOID
ConvertRouteNotifyOutputToRouteInfo(
    IN      PIPRouteNotifyOutput            pirno,
    OUT     PINTERFACE_ROUTE_INFO           pRtInfo
    )
{

    ZeroMemory(pRtInfo, sizeof(INTERFACE_ROUTE_INFO));

    pRtInfo->dwRtInfoDest       = pirno->irno_dest;
    pRtInfo->dwRtInfoMask       = pirno->irno_mask;
    pRtInfo->dwRtInfoIfIndex    = pirno->irno_ifindex;
    pRtInfo->dwRtInfoNextHop    = pirno->irno_nexthop;

    pRtInfo->dwRtInfoProto      = pirno->irno_proto;

    pRtInfo->dwRtInfoMetric1    = 
    pRtInfo->dwRtInfoMetric2    =
    pRtInfo->dwRtInfoMetric3    = pirno->irno_metric;

    pRtInfo->dwRtInfoPreference = ComputeRouteMetric(pirno->irno_proto);

    pRtInfo->dwRtInfoViewSet    = RTM_VIEW_MASK_UCAST | 
                                  RTM_VIEW_MASK_MCAST;

    pRtInfo->dwRtInfoType       = (pirno->irno_proto == PROTO_IP_LOCAL) ?
                                  MIB_IPROUTE_TYPE_DIRECT : MIB_IPROUTE_TYPE_OTHER;

    pRtInfo->dwRtInfoAge        = INFINITE;
    pRtInfo->dwRtInfoNextHopAS  = 0;
    pRtInfo->dwRtInfoPolicy     = 0;


    return;
}


DWORD
BlockConvertRoutesToStatic (
    IN      HANDLE                          hRtmHandle,
    IN      DWORD                           dwIfIndex,
    IN      DWORD                           dwProtocolId
    )
{
    HANDLE             hRtmEnum;
    RTM_ENTITY_INFO    reiInfo;
    RTM_NET_ADDRESS    rnaDest;
    PRTM_ROUTE_INFO    pRouteInfo1;
    PRTM_ROUTE_INFO    pRouteInfo2;
    RTM_NEXTHOP_INFO   nhiInfo;
    RTM_NEXTHOP_HANDLE hNextHop;
    PHANDLE            hRoutes;
    DWORD              dwHandles;
    DWORD              dwFlags;
    DWORD              dwNumBytes;
    DWORD              i, j, k;
    BOOL               fDeleted;
    DWORD              dwResult;

    hRoutes = HeapAlloc(
                IPRouterHeap,
                0,
                g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                );

    if (hRoutes == NULL)
    {
        Trace1(
            ERR,
            "BlockConvertRoutesToStatic : error allocating %d bytes"
            "for route handes",
            g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
            );
            
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    dwNumBytes = RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute);
    
    pRouteInfo1 = HeapAlloc(
                    IPRouterHeap,
                    0,
                    dwNumBytes
                    );

    if (pRouteInfo1 == NULL)
    {
        Trace1(
            ERR,
            "BlockConvertRoutesToStatic : error allocating %d bytes"
            "for route info",
            dwNumBytes
            );
            
        HeapFree(IPRouterHeap, 0, hRoutes);
        
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pRouteInfo2 = HeapAlloc(
                    IPRouterHeap,
                    0,
                    dwNumBytes
                    );

    if (pRouteInfo2 == NULL)
    {
        Trace1(
            ERR,
            "BlockConvertRoutesToStatic : error allocating %d bytes"
            "for route info",
            dwNumBytes
            );
            
        HeapFree(IPRouterHeap, 0, hRoutes);
        
        HeapFree(IPRouterHeap, 0, pRouteInfo1);
        
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);

        return ERROR_NOT_ENOUGH_MEMORY;
    }
    

    //
    // Enum all routes on the interface that we need
    //

    dwResult = RtmCreateRouteEnum(hRtmHandle,
                                  NULL,
                                  RTM_VIEW_MASK_ANY,
                                  RTM_ENUM_ALL_ROUTES,
                                  NULL,
                                  RTM_MATCH_INTERFACE,
                                  NULL,
                                  dwIfIndex,
                                  &hRtmEnum);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "BlockConvertRoutesToStatic: Error %d creating handle for %d\n",
               dwResult,
               hRtmHandle);
        
        HeapFree(IPRouterHeap, 0, hRoutes);
        
        HeapFree(IPRouterHeap, 0, pRouteInfo1);

        HeapFree(IPRouterHeap, 0, pRouteInfo2);

        return dwResult;
    }

    do
    {
        dwHandles = g_rtmProfile.MaxHandlesInEnum;
        
        dwResult = RtmGetEnumRoutes(hRtmHandle,
                                    hRtmEnum,
                                    &dwHandles,
                                    hRoutes);

        for (i = 0; i < dwHandles; i++)
        {
            fDeleted = FALSE;
            
            // Get the route info from the handle

            if (RtmGetRouteInfo(hRtmHandle,
                                hRoutes[i],
                                pRouteInfo1,
                                &rnaDest) is NO_ERROR)
            {
                // Does this match the routing protocol we want ?
                
                if ((RtmGetEntityInfo(hRtmHandle,
                                      pRouteInfo1->RouteOwner,
                                      &reiInfo) is NO_ERROR) &&
                    (reiInfo.EntityId.EntityProtocolId is dwProtocolId))
                {
                    //
                    // Add new static route with same information
                    // 

                    CopyMemory(pRouteInfo2,
                               pRouteInfo1,
                               sizeof(RTM_ROUTE_INFO));

                    // Adjust the preference to confirm to protocol
                    pRouteInfo2->PrefInfo.Preference = 
                        ComputeRouteMetric(PROTO_IP_NT_AUTOSTATIC);

                    // Adjust the neighbour to corr to new protocol

                    if (pRouteInfo1->Neighbour)
                    {
                        // In case we cant get convert the neighbour
                        pRouteInfo2->Neighbour = NULL;
                        
                        if (RtmGetNextHopInfo(hRtmHandle,
                                              pRouteInfo1->Neighbour,
                                              &nhiInfo) is NO_ERROR)
                        {
                            // Add the same neigbour using new protocol

                            hNextHop = NULL;

                            if (RtmAddNextHop(hRtmHandle,
                                              &nhiInfo,
                                              &hNextHop,
                                              &dwFlags) is NO_ERROR)
                            {
                                pRouteInfo2->Neighbour = hNextHop;
                            }

                            RtmReleaseNextHopInfo(hRtmHandle, &nhiInfo);
                        }
                    }

                    // Adjust the next hops to corr to new protocol

                    for (j = k = 0;
                         j < pRouteInfo1->NextHopsList.NumNextHops;
                         j++)
                    {
                        if (RtmGetNextHopInfo(hRtmHandle,
                                              pRouteInfo1->NextHopsList.NextHops[j],
                                              &nhiInfo) is NO_ERROR)
                        {
                            // Add the same nexthop using new protocol

                            hNextHop = NULL;

                            if (RtmAddNextHop(hRtmHandle,
                                              &nhiInfo,
                                              &hNextHop,
                                              &dwFlags) is NO_ERROR)
                            {
                                pRouteInfo2->NextHopsList.NextHops[k++] = hNextHop;
                            }

                            RtmReleaseNextHopInfo(hRtmHandle, &nhiInfo);
                        }
                    }

                    pRouteInfo2->NextHopsList.NumNextHops = (USHORT) k;

                    // Add the new route with the next hop information

                    if (k > 0)
                    {
                        dwFlags = 0;
                        
                        if (RtmAddRouteToDest(hRtmHandle,
                                              NULL,
                                              &rnaDest,
                                              pRouteInfo2,
                                              INFINITE,
                                              NULL,
                                              0,
                                              NULL,
                                              &dwFlags) is NO_ERROR)
                        {
                            // Route add is successful - delete old route

                            if (RtmDeleteRouteToDest(pRouteInfo1->RouteOwner,
                                                     hRoutes[i],
                                                     &dwFlags) is NO_ERROR)
                            {
                                fDeleted = TRUE;
                            }
                        }

                        RtmReleaseNextHops(hRtmHandle,
                                           k,
                                           pRouteInfo2->NextHopsList.NextHops);
                    }
                }

                RtmReleaseRouteInfo(hRtmHandle, pRouteInfo1);
            }

            if (!fDeleted)
            {
                RtmReleaseRoutes(hRtmHandle, 1, &hRoutes[i]);
            }
        }
    }
    while (dwResult is NO_ERROR);

    RtmDeleteEnumHandle(hRtmHandle, hRtmEnum);

    HeapFree(IPRouterHeap, 0, hRoutes);
    
    HeapFree(IPRouterHeap, 0, pRouteInfo1);

    HeapFree(IPRouterHeap, 0, pRouteInfo2);

    return NO_ERROR;
}


DWORD
DeleteRtmRoutes (
    IN      HANDLE                          hRtmHandle,
    IN      DWORD                           dwIfIndex,
    IN      BOOL                            fDeleteAll
    )
{
    HANDLE           hRtmEnum;
    PHANDLE          hRoutes;
    DWORD            dwHandles;
    DWORD            dwFlags;
    DWORD            i;
    DWORD            dwResult;

    hRoutes = HeapAlloc(
                IPRouterHeap,
                0,
                g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                );

    if (hRoutes == NULL)
    {
        Trace1(ERR,
               "DeleteRtmRoutes: Error allocating %d bytes",
               g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE));
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwFlags = fDeleteAll ? 0: RTM_MATCH_INTERFACE;
    
    dwResult = RtmCreateRouteEnum(hRtmHandle,
                                  NULL,
                                  RTM_VIEW_MASK_ANY,
                                  RTM_ENUM_OWN_ROUTES,
                                  NULL,
                                  dwFlags,
                                  NULL,
                                  dwIfIndex,
                                  &hRtmEnum);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "DeleteRtmRoutes: Error %d creating handle for %d\n",
               dwResult,
               hRtmHandle);
        
        HeapFree(IPRouterHeap, 0, hRoutes);
        
        return dwResult;
    }

    do
    {
        dwHandles = g_rtmProfile.MaxHandlesInEnum;
        
        dwResult = RtmGetEnumRoutes(hRtmHandle,
                                    hRtmEnum,
                                    &dwHandles,
                                    hRoutes);

        for (i = 0; i < dwHandles; i++)
        {
            if (RtmDeleteRouteToDest(hRtmHandle,
                                     hRoutes[i],
                                     &dwFlags) isnot NO_ERROR)
            {
                // If delete is successful, this is automatic
                RtmReleaseRoutes(hRtmHandle, 1, &hRoutes[i]);
            }
        }
    }
    while (dwResult is NO_ERROR);

    RtmDeleteEnumHandle(hRtmHandle, hRtmEnum);

    HeapFree(IPRouterHeap, 0, hRoutes);
    
    return NO_ERROR;
}


DWORD
DeleteRtmNexthops (
    IN      HANDLE                          hRtmHandle,
    IN      DWORD                           dwIfIndex,
    IN      BOOL                            fDeleteAll
    )
{
    PRTM_NEXTHOP_INFO pNexthop;
    PHANDLE           hNexthops;
    HANDLE            hRtmEnum;
    DWORD             dwHandles;
    DWORD             i;
    DWORD             dwResult;

    hNexthops = HeapAlloc(
                IPRouterHeap,
                0,
                g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                );

    if (hNexthops == NULL)
    {
        Trace1(ERR,
               "DeleteRtmNextHops: Error allocating %d bytes",
               g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE));
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwResult = RtmCreateNextHopEnum(hRtmHandle,
                                    0,
                                    NULL,
                                    &hRtmEnum);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "DeleteAllNexthops: Error %d creating handle for %d\n",
               dwResult,
               hRtmHandle);
        
        HeapFree(IPRouterHeap, 0, hNexthops);
        
        return dwResult;
    }

    do
    {
        dwHandles = g_rtmProfile.MaxHandlesInEnum;
        
        dwResult = RtmGetEnumNextHops(hRtmHandle,
                                      hRtmEnum,
                                      &dwHandles,
                                      hNexthops);

        for (i = 0; i < dwHandles; i++)
        {
            if (!fDeleteAll)
            {
                //
                // Make sure that the interface matches
                //
                
                if ((RtmGetNextHopPointer(hRtmHandle,
                                          hNexthops[i],
                                          &pNexthop) isnot NO_ERROR) ||
                    (pNexthop->InterfaceIndex != dwIfIndex))
                {
                    RtmReleaseNextHops(hRtmHandle, 1, &hNexthops[i]);
                    continue;
                }
            }

            // We need to delete this next hop here
            
            if (RtmDeleteNextHop(hRtmHandle,
                                 hNexthops[i],
                                 NULL) isnot NO_ERROR)
            {
                // If delete is successful, this is automatic
                RtmReleaseNextHops(hRtmHandle, 1, &hNexthops[i]);
            }
        }
    }
    while (dwResult is NO_ERROR);

    RtmDeleteEnumHandle(hRtmHandle, hRtmEnum);

    HeapFree(IPRouterHeap, 0, hNexthops);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\rtrdisc.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\routing\ip\rtrmgr\rtrdisc.c

Abstract:
    Router Discover code

Revision History:

    Amritansh Raghav  20th March 1996     Created

--*/

#include "allinc.h"

VOID
DeleteSockets(
    IN PICB picb
    );


VOID
InitializeRouterDiscoveryInfo(
    IN PICB                   picb,
    IN PRTR_INFO_BLOCK_HEADER pInfoHdr
    )

/*++

Routine Description

    Sets router discovery information passed in the ICB. If none is passed,
    sets to RFC 1256 defaults

Locks

    Must be called with ICB_LIST lock held as WRITER

Arguments

    picb        The ICB of the interface for whom the router discovery
                related variables have to be set

Return Value

    None

--*/

{
    PROUTER_DISC_CB pDiscCb;
    PRTR_DISC_INFO  pInfo = NULL;
    PRTR_TOC_ENTRY  pToc;
    LONG            lMilliSec;

    TraceEnter("InitializeRouterDiscovery");

    pToc = GetPointerToTocEntry(IP_ROUTER_DISC_INFO,
                                pInfoHdr);

    if(!pToc)
    {
        //
        // Leave things as they are
        //

        TraceLeave("InitializeRouterDiscoveryInfo");

        return;
    }

    pDiscCb = &picb->rdcRtrDiscInfo;

    //
    // First set everything to defaults, then if any info is valid, reset
    // those fields
    //

    pDiscCb->wMaxAdvtInterval = DEFAULT_MAX_ADVT_INTERVAL;

    pDiscCb->lPrefLevel       = DEFAULT_PREF_LEVEL;
    pDiscCb->dwNumAdvtsSent   = pDiscCb->dwNumSolicitationsSeen = 0;

    pDiscCb->liMaxMinDiff.HighPart   =
        pDiscCb->liMaxMinDiff.LowPart    = 0;

    pDiscCb->liMinAdvtIntervalInSysUnits.HighPart =
        pDiscCb->liMinAdvtIntervalInSysUnits.LowPart  = 0;

    pDiscCb->pRtrDiscSockets = NULL;

    //
    // RFC 1256 says default should be true, so there will be traffic on the
    // net if the user does not explicitly set this to false. We diverge from
    // the RFC and default to FALSE
    //

    pDiscCb->bAdvertise = FALSE;
    pDiscCb->bActive    = FALSE;

    if(pToc and (pToc->InfoSize > 0) and (pToc->Count > 0))
    {
        pInfo = (PRTR_DISC_INFO) GetInfoFromTocEntry(pInfoHdr,pToc);

        if(pInfo isnot NULL)
        {
            //
            // Ok, so we were passed some info
            //

            if((pInfo->wMaxAdvtInterval >= MIN_MAX_ADVT_INTERVAL) and
               (pInfo->wMaxAdvtInterval <= MAX_MAX_ADVT_INTERVAL))
            {
                pDiscCb->wMaxAdvtInterval = pInfo->wMaxAdvtInterval;
            }

            if((pInfo->wMinAdvtInterval >= MIN_MIN_ADVT_INTERVAL) and
               (pInfo->wMinAdvtInterval <= pDiscCb->wMaxAdvtInterval))
            {
                pDiscCb->liMinAdvtIntervalInSysUnits = SecsToSysUnits(pInfo->wMinAdvtInterval);
            }
            else
            {
                lMilliSec = (LONG)(DEFAULT_MIN_ADVT_INTERVAL_RATIO * pDiscCb->wMaxAdvtInterval * 1000);

                pDiscCb->liMinAdvtIntervalInSysUnits = RtlEnlargedIntegerMultiply(lMilliSec,10000);
            }

            if((pInfo->wAdvtLifetime >= pDiscCb->wMaxAdvtInterval) and
               (pInfo->wAdvtLifetime <= MAX_ADVT_LIFETIME))
            {
                pDiscCb->wAdvtLifetime = pInfo->wAdvtLifetime;
            }
            else
            {
                pDiscCb->wAdvtLifetime = DEFAULT_ADVT_LIFETIME_RATIO * pDiscCb->wMaxAdvtInterval;
            }

            pDiscCb->bAdvertise = pInfo->bAdvertise;

            pDiscCb->lPrefLevel = pInfo->lPrefLevel;
        }
    }

    if(pInfo is NULL)
    {
        //
        // default case, in case no router disc. info. is specified.
        //
        
        lMilliSec = (LONG)(DEFAULT_MIN_ADVT_INTERVAL_RATIO * pDiscCb->wMaxAdvtInterval * 1000);

        pDiscCb->liMinAdvtIntervalInSysUnits = RtlEnlargedIntegerMultiply(lMilliSec,10000);

        pDiscCb->wAdvtLifetime     = DEFAULT_ADVT_LIFETIME_RATIO * pDiscCb->wMaxAdvtInterval;
    }

    pDiscCb->liMaxMinDiff = RtlLargeIntegerSubtract(SecsToSysUnits(pDiscCb->wMaxAdvtInterval),
                                                    pDiscCb->liMinAdvtIntervalInSysUnits);

    TraceLeave("InitializeRouterDiscovery");
}

VOID
SetRouterDiscoveryInfo(
    IN PICB                      picb,
    IN PRTR_INFO_BLOCK_HEADER    pInfoHdr
    )

/*++

Routine Description

    Sets router discovery information passed in the ICB. If none is passed,
    sets to RFC 1256 defaults

Locks

    Must be called with ICB_LIST lock held as WRITER

Arguments

    picb        The ICB of the interface for whom the router discovery related
                variables have to be set
    pInfoHdr    Interface Info header

Return Value

    None

--*/

{
    PROUTER_DISC_CB  pDiscCb;
    PRTR_DISC_INFO   pInfo;
    PRTR_TOC_ENTRY   pToc;
    LONG             lMilliSec;
    BOOL             bOriginalStatus;

    TraceEnter("SetRouterDiscoveryInfo");

    pDiscCb = &picb->rdcRtrDiscInfo;

    pToc = GetPointerToTocEntry(IP_ROUTER_DISC_INFO,
                                pInfoHdr);

    if(!pToc)
    {
        //
        // Leave things as they are
        //

        TraceLeave("SetRouterDiscoveryInfo");

        return;
    }

    pInfo = (PRTR_DISC_INFO) GetInfoFromTocEntry(pInfoHdr,pToc);

    bOriginalStatus = pDiscCb->bAdvertise;

    if((pToc->InfoSize is 0) or (pInfo is NULL))
    {
        //
        // If the size is zero, stop advertising
        //

        DeActivateRouterDiscovery(picb);

        //
        // Instead of returning, we go through and set defaults so that the info
        // looks good when someone does a get info
        //
    }


    //
    // First set everything to defaults, then if any info is valid, reset
    // those fields
    //

    pDiscCb->wMaxAdvtInterval = DEFAULT_MAX_ADVT_INTERVAL;

    pDiscCb->lPrefLevel       = DEFAULT_PREF_LEVEL;

    //
    // We reset the counters
    //

    pDiscCb->dwNumAdvtsSent   = pDiscCb->dwNumSolicitationsSeen = 0;

    pDiscCb->liMaxMinDiff.HighPart  =
        pDiscCb->liMaxMinDiff.LowPart   = 0;

    pDiscCb->liMinAdvtIntervalInSysUnits.HighPart =
        pDiscCb->liMinAdvtIntervalInSysUnits.LowPart  = 0;

    //
    // We DONT mess with the sockets
    //


    if((pToc->InfoSize) and (pInfo isnot NULL))
    {
        if(!pInfo->bAdvertise)
        {
            DeActivateRouterDiscovery(picb);
        }

        if((pInfo->wMaxAdvtInterval > MIN_MAX_ADVT_INTERVAL) and
           (pInfo->wMaxAdvtInterval < MAX_MAX_ADVT_INTERVAL))
        {
            pDiscCb->wMaxAdvtInterval = pInfo->wMaxAdvtInterval;
        }

        if((pInfo->wMinAdvtInterval > MIN_MIN_ADVT_INTERVAL) and
           (pInfo->wMinAdvtInterval < pDiscCb->wMaxAdvtInterval))
        {
            pDiscCb->liMinAdvtIntervalInSysUnits =
                SecsToSysUnits(pInfo->wMinAdvtInterval);
        }
        else
        {
            lMilliSec = (LONG)(DEFAULT_MIN_ADVT_INTERVAL_RATIO * pDiscCb->wMaxAdvtInterval * 1000);

            pDiscCb->liMinAdvtIntervalInSysUnits =
                RtlEnlargedIntegerMultiply(lMilliSec,10000);
        }

        if((pInfo->wAdvtLifetime > pDiscCb->wMaxAdvtInterval) and
           (pInfo->wAdvtLifetime < MAX_ADVT_LIFETIME))
        {
            pDiscCb->wAdvtLifetime = pInfo->wAdvtLifetime;
        }
        else
        {
            pDiscCb->wAdvtLifetime =
                DEFAULT_ADVT_LIFETIME_RATIO * pDiscCb->wMaxAdvtInterval;
        }

        pDiscCb->bAdvertise = pInfo->bAdvertise;

        pDiscCb->lPrefLevel = pInfo->lPrefLevel;
    }
    else
    {
        lMilliSec = (LONG)(DEFAULT_MIN_ADVT_INTERVAL_RATIO * pDiscCb->wMaxAdvtInterval * 1000);

        pDiscCb->liMinAdvtIntervalInSysUnits =
            RtlEnlargedIntegerMultiply(lMilliSec,10000);

        pDiscCb->wAdvtLifetime =
            DEFAULT_ADVT_LIFETIME_RATIO * pDiscCb->wMaxAdvtInterval;
    }

    if(pDiscCb->bAdvertise is TRUE)
    {
        if(bOriginalStatus is FALSE)
        {
            //
            // If we were originally not advertising but are advertising now,
            // then start router discovery
            //

            ActivateRouterDiscovery(picb);
        }
        else
        {
            //
            // Else just update the fields in the advertisement
            //

            UpdateAdvertisement(picb);
        }
    }

    TraceLeave("SetRouterDiscoveryInfo");
}

DWORD
GetInterfaceRouterDiscoveryInfo(
    PICB                    picb,
    PRTR_TOC_ENTRY          pToc,
    PBYTE                   pbDataPtr,
    PRTR_INFO_BLOCK_HEADER  pInfoHdr,
    PDWORD                  pdwSize
    )

/*++

Routine Description

    Gets router discovery information related to an interface

Locks

    Called with ICB_LIST lock held as READER

Arguments

    picb        The ICB of the interface whose router discovery information is
                being retrieved
    pToc        Pointer to TOC for router discovery info
    pbDataPtr   Pointer to start of data buffer
    pInfoHdr    Pointer to the header of the whole info
    pdwSize     [IN]  Size of data buffer
                [OUT] Size of buffer consumed

Return Value

--*/

{
    PRTR_DISC_INFO  pInfo;
    DWORD           dwRem;
    LARGE_INTEGER   liQuotient;

    TraceEnter("GetInterfaceRouterDiscoveryInfo");

    if(*pdwSize < sizeof(RTR_DISC_INFO))
    {
        *pdwSize = sizeof(RTR_DISC_INFO);

        TraceLeave("GetInterfaceRouterDiscoveryInfo");

        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pdwSize = pToc->InfoSize = sizeof(RTR_DISC_INFO);

    //pToc->InfoVersion  = IP_ROUTER_DISC_INFO;
    pToc->InfoType  = IP_ROUTER_DISC_INFO;
    pToc->Count     = 1;
    pToc->Offset    = (ULONG)(pbDataPtr - (PBYTE) pInfoHdr);

    pInfo = (PRTR_DISC_INFO)pbDataPtr;

    pInfo->wMaxAdvtInterval = picb->rdcRtrDiscInfo.wMaxAdvtInterval;

    liQuotient = RtlExtendedLargeIntegerDivide(picb->rdcRtrDiscInfo.liMinAdvtIntervalInSysUnits,
                                               SYS_UNITS_IN_1_SEC,
                                               &dwRem);

    pInfo->wMinAdvtInterval = LOWORD(liQuotient.LowPart);
    pInfo->wAdvtLifetime    = picb->rdcRtrDiscInfo.wAdvtLifetime;
    pInfo->bAdvertise       = picb->rdcRtrDiscInfo.bAdvertise;
    pInfo->lPrefLevel       = picb->rdcRtrDiscInfo.lPrefLevel;

    TraceLeave("GetInterfaceRouterDiscoveryInfo");

    return NO_ERROR;
}



DWORD
ActivateRouterDiscovery(
    IN PICB  picb
    )

/*++

Routine Description

    Activates router discovery messages on an interface. The interface must
    already be bound.

Locks

    Called with the ICB_LIST lock held as WRITER

Arguments

    picb          The ICB of the interface to activate

Return Value

    NO_ERROR or some error code

--*/

{
    PROUTER_DISC_CB    pDiscCb;
    PROUTER_DISC_CB    pDiscCb2;
    DWORD              dwResult,i,dwNumAddrs,dwNumOldAddrs,dwSize;
    LARGE_INTEGER      liTimer;
    PTIMER_QUEUE_ITEM  pTimer;
    BOOL               bReset;

    TraceEnter("ActivateRouterDiscovery");

    //
    // The SetInterfaceInfo call takes into account whether our
    // admin state is UP or down. Here we only check if our oper
    // state allows us to come up
    //

    if(picb->dwOperationalState < IF_OPER_STATUS_CONNECTING)
    {
        TraceLeave("ActivateRouterDiscovery");

        return NO_ERROR;
    }

    pDiscCb = &picb->rdcRtrDiscInfo;

    if(!pDiscCb->bAdvertise)
    {
        //
        // Since we dont have to advertise on this interface, we are done
        //

        TraceLeave("ActivateRouterDiscovery");

        return NO_ERROR;
    }

    dwResult = CreateSockets(picb);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "ActivateRouterDiscovery: Couldnt create sockets for interface %S. Error %d",
               picb->pwszName,
               dwResult);

        TraceLeave("ActivateRouterDiscovery");

        return dwResult;
    }

    dwResult    = UpdateAdvertisement(picb);

    if(dwResult isnot NO_ERROR)
    {
        DeleteSockets(picb);

        Trace1(ERR,
               "ActivateRouterDiscovery: Couldnt update Icmp Advt. Error %d",
               dwResult);

        TraceLeave("ActivateRouterDiscovery");

        return dwResult;
    }

    //
    // Ok so we have a valid CB and we have the sockets all set up.
    //

    bReset = SetFiringTimeForAdvt(picb);

    if(bReset)
    {
        if(!SetWaitableTimer(g_hRtrDiscTimer,
                             &(pDiscCb->tqiTimer.liFiringTime),
                             0,
                             NULL,
                             NULL,
                             FALSE))
        {
            dwResult = GetLastError();

            Trace1(ERR,
                   "ActivateRouterDiscovery: Error %d setting timer",
                   dwResult);

            DeleteSockets(picb);

            TraceLeave("ActivateRouterDiscovery");

            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    //
    // Yes we are active
    //

    pDiscCb->bActive = TRUE;

    TraceLeave("ActivateRouterDiscovery");

    return NO_ERROR;
}

DWORD
UpdateAdvertisement(
    IN PICB    picb
    )

/*++

Routine Description

    Updates the Router discovery advertisement. If none exists, creates one

Locks

    ICB lock as writer

Arguments

    picb      ICB to update

Return Value

    NO_ERROR

--*/

{
    DWORD               dwResult,i;
    PROUTER_DISC_CB     pDiscCb;


    TraceEnter("UpdateAdvertisement");

    pDiscCb = &picb->rdcRtrDiscInfo;

    if(picb->pRtrDiscAdvt)
    {
        //
        // If we have an old advertisement
        //

        if(picb->dwRtrDiscAdvtSize < SIZEOF_RTRDISC_ADVT(picb->dwNumAddresses))
        {
            //
            // Too small, cannot reuse the old advert
            //

            HeapFree(IPRouterHeap,
                     0,
                     picb->pRtrDiscAdvt);

            picb->pRtrDiscAdvt = NULL;

            picb->dwRtrDiscAdvtSize   = 0;
        }
    }

    if(!picb->pRtrDiscAdvt)
    {
        picb->pRtrDiscAdvt = HeapAlloc(IPRouterHeap,
                                       HEAP_ZERO_MEMORY,
                                       SIZEOF_RTRDISC_ADVT(picb->dwNumAddresses));

        if(picb->pRtrDiscAdvt is NULL)
        {
            //
            // Set advertise to FALSE so that no one uses the
            // NULL pointer by mistake
            //

            pDiscCb->bAdvertise         = FALSE;
            picb->dwRtrDiscAdvtSize   = 0;

            Trace1(ERR,
                   "UpdateAdvertisement: Cant allocate %d bytes for Icmp Msg",
                   SIZEOF_RTRDISC_ADVT(picb->dwNumAddresses));

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        picb->dwRtrDiscAdvtSize   = SIZEOF_RTRDISC_ADVT(picb->dwNumAddresses);
    }

    picb->pRtrDiscAdvt->byType           = ICMP_ROUTER_DISCOVERY_TYPE;
    picb->pRtrDiscAdvt->byCode           = ICMP_ROUTER_DISCOVERY_CODE;
    picb->pRtrDiscAdvt->wLifeTime        = htons(pDiscCb->wAdvtLifetime);
    picb->pRtrDiscAdvt->byAddrEntrySize  = ICMP_ROUTER_DISCOVERY_ADDR_SIZE;
    picb->pRtrDiscAdvt->wXSum            = 0;

    //
    // Add the interface's addresses to the advertisement.
    //

    picb->wsAdvtWSABuffer.buf = (PBYTE)picb->pRtrDiscAdvt;
    picb->wsAdvtWSABuffer.len = SIZEOF_RTRDISC_ADVT(picb->dwNumAddresses);

    picb->pRtrDiscAdvt->byNumAddrs = LOBYTE(LOWORD(picb->dwNumAddresses));

    for(i = 0; i < picb->dwNumAddresses; i++)
    {
        picb->pRtrDiscAdvt->iaAdvt[i].dwRtrIpAddr = picb->pibBindings[i].dwAddress;
        picb->pRtrDiscAdvt->iaAdvt[i].lPrefLevel  =
            htonl(picb->rdcRtrDiscInfo.lPrefLevel);
    }

    picb->pRtrDiscAdvt->wXSum    = Compute16BitXSum((PVOID)picb->pRtrDiscAdvt,
                                                    SIZEOF_RTRDISC_ADVT(picb->dwNumAddresses));

    //
    // Note: TBD: If the advertising times have changed we should
    // change the timer queue. However we let the timer fire and the
    // next time we set the timer we will pick up the correct
    // time
    //

    TraceLeave("UpdateAdvertisement");

    return NO_ERROR;
}



BOOL
SetFiringTimeForAdvt(
    IN PICB   picb
    )

/*++

Routine Description



Locks

    ICB_LIST lock must be held as WRITER

Arguments

    picb    The ICB of the interface to activate

Return Value

    TRUE if calling the function caused the timer to be reset

--*/

{
    PROUTER_DISC_CB    pDiscCb;
    DWORD              dwResult;
    LARGE_INTEGER      liCurrentTime, liRandomTime;
    INT                iRand;
    ULONG              ulRem;
    PLIST_ENTRY        pleNode;
    PTIMER_QUEUE_ITEM  pOldTime;

    TraceEnter("SetFiringTimeForAdvt");

    //
    // Figure out the next time this interface should advertise
    //

    iRand = rand();

    pDiscCb = &picb->rdcRtrDiscInfo;

    liRandomTime = RtlExtendedLargeIntegerDivide(RtlExtendedIntegerMultiply(pDiscCb->liMaxMinDiff,
                                                                            iRand),
                                                 RAND_MAX,
                                                 &ulRem);

    liRandomTime = RtlLargeIntegerAdd(liRandomTime,
                                      pDiscCb->liMinAdvtIntervalInSysUnits);

    if((pDiscCb->dwNumAdvtsSent <= MAX_INITIAL_ADVTS) and
       RtlLargeIntegerGreaterThan(liRandomTime,SecsToSysUnits(MAX_INITIAL_ADVT_TIME)))
    {
        liRandomTime = SecsToSysUnits(MAX_INITIAL_ADVT_TIME);
    }

    NtQuerySystemTime(&liCurrentTime);

    picb->rdcRtrDiscInfo.tqiTimer.liFiringTime = RtlLargeIntegerAdd(liCurrentTime,liRandomTime);

    //
    // Insert into sorted list
    //

    for(pleNode = g_leTimerQueueHead.Flink;
        pleNode isnot &g_leTimerQueueHead;
        pleNode = pleNode->Flink)
    {
        pOldTime = CONTAINING_RECORD(pleNode,TIMER_QUEUE_ITEM,leTimerLink);

        if(RtlLargeIntegerGreaterThan(pOldTime->liFiringTime,
                                      picb->rdcRtrDiscInfo.tqiTimer.liFiringTime))
        {
            break;
        }
    }

    //
    // Now pleNode points to first Node whose time is greater than ours, so
    // we insert ourselves before pleNode. Since RTL doesnt supply us with
    // an InsertAfter function, we go back on and use the previous node as a
    // list head and call InsertHeadList
    //

    pleNode = pleNode->Blink;

    InsertHeadList(pleNode,
                   &(picb->rdcRtrDiscInfo.tqiTimer.leTimerLink));

    if(pleNode is &g_leTimerQueueHead)
    {
        //
        // We inserted ourselves at the head of the queue
        //

        TraceLeave("SetFiringTimeForAdvt");

        return TRUE;
    }

    TraceLeave("SetFiringTimeForAdvt");

    return FALSE;

}


DWORD
CreateSockets(
    IN PICB picb
    )

/*++

Routine Description

    Activates router discovery messages on an interface. The interface must
    already be bound

Locks

    ICB_LIST lock must be held as WRITER

Arguments

    picb    The ICB of the interface for which the sockets have to be created

Return Value

    NO_ERROR or some error code

--*/

{
    PROUTER_DISC_CB  pDiscCb;
    DWORD            i, dwResult, dwBytesReturned;
    struct linger    lingerOption;
    BOOL             bOption, bLoopback;
    SOCKADDR_IN      sinSockAddr;
    struct ip_mreq   imOption;
    INT              iScope;

    TraceEnter("CreateSockets");

    dwResult = NO_ERROR;

    if(picb->dwNumAddresses is 0)
    {
        Trace1(ERR,
               "CreateSockets: Can not activate router discovery on %S as it has no addresses",
               picb->pwszName);

        TraceLeave("CreateSockets");

        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Create the sockets for the interface
    //

    pDiscCb = &(picb->rdcRtrDiscInfo);

    pDiscCb->pRtrDiscSockets = HeapAlloc(IPRouterHeap,
                                         0,
                                         (picb->dwNumAddresses) * sizeof(SOCKET));

    if(pDiscCb->pRtrDiscSockets is NULL)
    {
        Trace1(ERR,
               "CreateSockets: Error allocating %d bytes for sockets",
               (picb->dwNumAddresses) * sizeof(SOCKET));

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for(i = 0; i < picb->dwNumAddresses; i++)
    {
        pDiscCb->pRtrDiscSockets[i] = INVALID_SOCKET;
    }

    for(i = 0; i < picb->dwNumAddresses; i++)
    {
        pDiscCb->pRtrDiscSockets[i] = WSASocket(AF_INET,
                                                SOCK_RAW,
                                                IPPROTO_ICMP,
                                                NULL,
                                                0,
                                                RTR_DISC_SOCKET_FLAGS);

        if(pDiscCb->pRtrDiscSockets[i] is INVALID_SOCKET)
        {
            dwResult = WSAGetLastError();

            Trace3(ERR,
                   "CreateSockets: Couldnt create socket number %d on %S. Error %d",
                   i,
                   picb->pwszName,
                   dwResult);

            continue;
        }

#if 0
        //
        // Set to SO_DONTLINGER
        //

        bOption = TRUE;

        if(setsockopt(pDiscCb->pRtrDiscSockets[i],
                      SOL_SOCKET,
                      SO_DONTLINGER,
                      (const char FAR*)&bOption,
                      sizeof(BOOL)) is SOCKET_ERROR)
        {
            Trace1(ERR,
                   "CreateSockets: Couldnt set linger option - continuing. Error %d",
                   WSAGetLastError());
        }
#endif

        //
        // Set to SO_REUSEADDR
        //

        bOption = TRUE;

        if(setsockopt(pDiscCb->pRtrDiscSockets[i],
                      SOL_SOCKET,
                      SO_REUSEADDR,
                      (const char FAR*)&bOption,
                      sizeof(BOOL)) is SOCKET_ERROR)
        {
            Trace1(ERR,
                   "CreateSockets: Couldnt set reuse option - continuing. Error %d",
                   WSAGetLastError());
        }

        if(WSAEventSelect(pDiscCb->pRtrDiscSockets[i],
                          g_hRtrDiscSocketEvent,
                          FD_READ) is SOCKET_ERROR)
        {
            Trace2(ERR,
                   "CreateSockets: WSAEventSelect() failed for socket on %S.Error %d",
                   picb->pwszName,
                   WSAGetLastError());

            closesocket(pDiscCb->pRtrDiscSockets[i]);

            pDiscCb->pRtrDiscSockets[i] = INVALID_SOCKET;

            continue;
        }

        //
        // TBD: Set scope/TTL to 1 since we always multicast the responses
        // Also set Loopback to ignore self generated packets
        //

        //
        // Bind to the addresses on the interface
        //

        sinSockAddr.sin_family      = AF_INET;
        sinSockAddr.sin_addr.s_addr = picb->pibBindings[i].dwAddress;
        sinSockAddr.sin_port        = 0;

        if(bind(pDiscCb->pRtrDiscSockets[i],
                (const struct sockaddr FAR*)&sinSockAddr,
        sizeof(SOCKADDR_IN)) is SOCKET_ERROR)
        {
            dwResult = WSAGetLastError();

            Trace3(ERR,
                   "CreateSockets: Couldnt bind to %d.%d.%d.%d on interface %S. Error %d",
                   PRINT_IPADDR(picb->pibBindings[i].dwAddress),
                   picb->pwszName,
                   dwResult);

            closesocket(pDiscCb->pRtrDiscSockets[i]);

            pDiscCb->pRtrDiscSockets[i] = INVALID_SOCKET;

            continue;
        }

        bLoopback   = FALSE;

        dwResult = WSAIoctl(pDiscCb->pRtrDiscSockets[i],
                            SIO_MULTIPOINT_LOOPBACK,
                            (PVOID)&bLoopback,
                            sizeof(BOOL),
                            NULL,
                            0,
                            &dwBytesReturned,
                            NULL,
                            NULL);

        if(dwResult is SOCKET_ERROR)
        {
            Trace1(ERR,
                   "CreateSockets: Error %d setting loopback to FALSE",
                   WSAGetLastError());
        }

        iScope  = 1;

        dwResult = WSAIoctl(pDiscCb->pRtrDiscSockets[i],
                            SIO_MULTICAST_SCOPE,
                            (PVOID)&iScope,
                            sizeof(INT),
                            NULL,
                            0,
                            &dwBytesReturned,
                            NULL,
                            NULL);

        if(dwResult is SOCKET_ERROR)
        {
            Trace1(ERR,
                   "CreateSockets: Error %d setting multicast scope to 1",
                   WSAGetLastError());
        }


#if 0

        //
        // Join the multicast session on ALL_ROUTERS_MULTICAST
        //

        sinSockAddr.sin_family      = AF_INET;
        sinSockAddr.sin_addr.s_addr = ALL_ROUTERS_MULTICAST_GROUP;
        sinSockAddr.sin_port        = 0;

        if(WSAJoinLeaf(pDiscCb->pRtrDiscSockets[i],
                       (const struct sockaddr FAR*)&sinSockAddr,
                       sizeof(SOCKADDR_IN),
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       JL_BOTH) is INVALID_SOCKET)
        {
            dwResult = WSAGetLastError();

            Trace2(ERR,
                   "CreateSockets: Couldnt join multicast group on socket for %d.%d.%d.%d on %S",
                   PRINT_IPADDR(picb->pibBindings[i].dwAddress)),
                   picb->pwszName);

            closesocket(pDiscCb->pRtrDiscSockets[i]);

            pDiscCb->pRtrDiscSockets[i] = INVALID_SOCKET;

            continue;
        }

        //
        // Join the multicast session on ALL_SYSTEMS_MULTICAST
        //

        sinSockAddr.sin_family      = AF_INET;
        sinSockAddr.sin_addr.s_addr = ALL_SYSTEMS_MULTICAST_GROUP;
        sinSockAddr.sin_port        = 0;

        if(WSAJoinLeaf(pDiscCb->pRtrDiscSockets[i],
                       (const struct sockaddr FAR*)&sinSockAddr,
                       sizeof(SOCKADDR_IN),
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       JL_BOTH) is INVALID_SOCKET)
        {
            dwResult = WSAGetLastError();

            Trace2(ERR,
                   "CreateSockets: Couldnt join all systems multicast group on socket for %d.%d.%d.%d on %S",
                   PRINT_IPADDR(picb->pibBindings[i].dwAddress),
                   picb->pwszName);
        }

#endif

        sinSockAddr.sin_addr.s_addr = picb->pibBindings[i].dwAddress;

        if(setsockopt(pDiscCb->pRtrDiscSockets[i],
                      IPPROTO_IP,
                      IP_MULTICAST_IF,
                      (PBYTE)&sinSockAddr.sin_addr,
                      sizeof(IN_ADDR)) is SOCKET_ERROR)
        {
            dwResult = WSAGetLastError();

            Trace2(ERR,
                   "CreateSockets: Couldnt join multicast group on socket for %d.%d.%d.%d on %S",
                   PRINT_IPADDR(picb->pibBindings[i].dwAddress),
                   picb->pwszName);

            closesocket(pDiscCb->pRtrDiscSockets[i]);

            pDiscCb->pRtrDiscSockets[i] = INVALID_SOCKET;

            continue;
        }

        Trace2(RTRDISC,
               "CreateSockets: Joining ALL_ROUTERS on %d.%d.%d.%d over %S",
               PRINT_IPADDR(picb->pibBindings[i].dwAddress),
               picb->pwszName);

        imOption.imr_multiaddr.s_addr = ALL_ROUTERS_MULTICAST_GROUP;
        imOption.imr_interface.s_addr = picb->pibBindings[i].dwAddress;

        if(setsockopt(pDiscCb->pRtrDiscSockets[i],
                      IPPROTO_IP,
                      IP_ADD_MEMBERSHIP,
                      (PBYTE)&imOption,
                      sizeof(imOption)) is SOCKET_ERROR)
        {
            dwResult = WSAGetLastError();

            Trace2(ERR,
                   "CreateSockets: Couldnt join multicast group on socket for %d.%d.%d.%d on %S",
                   PRINT_IPADDR(picb->pibBindings[i].dwAddress),
                   picb->pwszName);

            closesocket(pDiscCb->pRtrDiscSockets[i]);

            pDiscCb->pRtrDiscSockets[i] = INVALID_SOCKET;

            continue;
        }


    }

    TraceLeave("CreateSockets");

    return dwResult;
}

VOID
DeleteSockets(
    IN PICB picb
    )

/*++

Routine Description

    Deletes the sockets (if any) created for running Router Discovery

Locks


Arguments

    picb   The interface whose sockets need to be deleted

Return Value

--*/

{
    PROUTER_DISC_CB     pDiscCb;
    DWORD               i;

    //
    // Cloese the sockets, free the memory
    //

    pDiscCb = &(picb->rdcRtrDiscInfo);

    for(i = 0; i < picb->dwNumAddresses; i++)
    {
        if(pDiscCb->pRtrDiscSockets[i] isnot INVALID_SOCKET)
        {
            closesocket(pDiscCb->pRtrDiscSockets[i]);
        }
    }

    HeapFree(IPRouterHeap,
             0,
             pDiscCb->pRtrDiscSockets);

    pDiscCb->pRtrDiscSockets = NULL;

}

VOID
HandleRtrDiscTimer(
    VOID
    )

/*++

Routine Description

    Processes the firing of the Router Discovery Timer for an interface

Locks

    Called with ICB_LIST held as WRITER. This is needed because ICB_LIST
    protects timer queue, etc. This may seem inefficient, but the Timer will
    go off once in 5 minutes or so, so its worth reducing Kernel Mode footprint
    by reusing the lock

Arguments

    None

Return Value

    None

--*/

{
    LARGE_INTEGER       liCurrentTime;
    PICB                picb;
    PLIST_ENTRY         pleNode;
    PTIMER_QUEUE_ITEM   pTimer;
    BOOL                bReset;
    DWORD               dwResult;
    PROUTER_DISC_CB     pInfo;

    TraceEnter("HandleRtrDiscTimer");

    while(!IsListEmpty(&g_leTimerQueueHead))
    {
        pleNode = g_leTimerQueueHead.Flink;

        pTimer = CONTAINING_RECORD(pleNode, TIMER_QUEUE_ITEM, leTimerLink);

        NtQuerySystemTime(&liCurrentTime);

        if(RtlLargeIntegerGreaterThan(pTimer->liFiringTime,liCurrentTime))
        {
            break;
        }

        RemoveHeadList(&g_leTimerQueueHead);

        //
        // We have the pointer to the timer element. From that
        // we get the pointer to the  Router Discovery Info container
        //

        pInfo   = CONTAINING_RECORD(pTimer, ROUTER_DISC_CB, tqiTimer);

        //
        // From the rtrdisc info we get to the ICB which contains it
        //

        picb    = CONTAINING_RECORD(pInfo, ICB, rdcRtrDiscInfo);

        //
        // Send advt for this interface
        //

        if((picb->rdcRtrDiscInfo.bAdvertise is FALSE) or
           (picb->dwAdminState is IF_ADMIN_STATUS_DOWN) or
           (picb->dwOperationalState < CONNECTED))
        {
            Trace3(ERR,
                   "HandleRtrDiscTimer: Router Discovery went off for interface %S, but current state (%d/%d) doesnt allow tx",
                   picb->pwszName,
                   picb->dwAdminState,
                   picb->dwOperationalState);

            continue;
        }

        IpRtAssert(picb->pRtrDiscAdvt);

        AdvertiseInterface(picb);

        //
        // Insert the next time this interface needs to advt into the queue.
        // Reset the timer
        //

        SetFiringTimeForAdvt(picb);

    }

    //
    // We have to reset the timer
    //

    if(!IsListEmpty(&g_leTimerQueueHead))
    {
        pleNode = g_leTimerQueueHead.Flink;

        pTimer = CONTAINING_RECORD(pleNode, TIMER_QUEUE_ITEM, leTimerLink);

        if(!SetWaitableTimer(g_hRtrDiscTimer,
                             &pTimer->liFiringTime,
                             0,
                             NULL,
                             NULL,
                             FALSE))
        {
            dwResult = GetLastError();

            Trace1(ERR,
                   "HandleRtrDiscTimer: Couldnt set waitable timer",
                   dwResult);
        }
    }

    TraceLeave("HandleRtrDiscTimer");
}

VOID
AdvertiseInterface(
    IN PICB picb
    )

/*++

Routine Description


Locks



Arguments

    picb    ICB of the interface on which to send out the advertisement


Return Value

    None

--*/

{
    DWORD i,dwResult,dwNumBytesSent;

    TraceEnter("AdvertiseInterface");

    //
    // If any replies were pending, they are deemed to be sent even if
    // the send fails
    //

    picb->rdcRtrDiscInfo.bReplyPending = FALSE;

    for(i = 0; i < picb->dwNumAddresses; i++)
    {

#if DBG

        Trace2(RTRDISC,
               "Advertising from %d.%d.%d.%d on %S",
               PRINT_IPADDR(picb->pibBindings[i].dwAddress),
               picb->pwszName);

        TraceDumpEx(TraceHandle,
                    IPRTRMGR_TRACE_RTRDISC,
                    picb->wsAdvtWSABuffer.buf,
                    picb->wsAdvtWSABuffer.len,
                    4,
                    FALSE,
                    "ICMP Advt");
#endif

        if(WSASendTo(picb->rdcRtrDiscInfo.pRtrDiscSockets[i],
                     &picb->wsAdvtWSABuffer,
                     1,
                     &dwNumBytesSent,
                     MSG_DONTROUTE,
                     (const struct sockaddr FAR*)&g_sinAllSystemsAddr,
                     sizeof(SOCKADDR_IN),
                     NULL,
                     NULL
            ) is SOCKET_ERROR)
        {
            dwResult = WSAGetLastError();

            Trace3(ERR,
                   "AdvertiseInterface: Couldnt send from %d.%d.%d.%d on %S. Error %d",
                   PRINT_IPADDR(picb->pibBindings[i].dwAddress),
                   picb->pwszName,
                   dwResult);
        }
        else
        {
            picb->rdcRtrDiscInfo.dwNumAdvtsSent++;
        }
    }

    TraceLeave("AdvertiseInterface");
}

DWORD
DeActivateRouterDiscovery(
    IN PICB  picb
    )
{
    PROUTER_DISC_CB     pDiscCb;
    DWORD               i;
    PTIMER_QUEUE_ITEM   pTimer;
    PLIST_ENTRY         pleNode;


    TraceEnter("DeActivateRouterDiscovery");

    pDiscCb = &(picb->rdcRtrDiscInfo);

    if(!pDiscCb->bActive)
    {
        return NO_ERROR;
    }

    DeleteSockets(picb);

    //
    // Check to see if our advertisement is in the front of the queue
    //

    if(&(pDiscCb->tqiTimer.leTimerLink) is &g_leTimerQueueHead)
    {
        RemoveHeadList(&g_leTimerQueueHead);

        if(!IsListEmpty(&g_leTimerQueueHead))
        {
            pleNode = g_leTimerQueueHead.Flink;

            pTimer = CONTAINING_RECORD(pleNode, TIMER_QUEUE_ITEM, leTimerLink);

            if(!SetWaitableTimer(g_hRtrDiscTimer,
                                 &pTimer->liFiringTime,
                                 0,
                                 NULL,
                                 NULL,
                                 FALSE))
            {
                Trace1(ERR,
                       "DeActivateRouterDiscovery: Couldnt set waitable timer",
                       GetLastError());
            }
        }
    }
    else
    {
        //
        // Just remove the timer element from the queue
        //

        RemoveEntryList(&(pDiscCb->tqiTimer.leTimerLink));
    }

    pDiscCb->bActive = FALSE;

    TraceLeave("DeActivateRouterDiscovery");

    return NO_ERROR;
}

VOID
HandleSolicitations(
    VOID
    )

/*++

Routine Description


Locks


Arguments


Return Value

--*/

{
    PLIST_ENTRY           pleNode;
    PICB                  picb;
    DWORD                 i, dwResult, dwRcvAddrLen, dwSizeOfHeader, dwBytesRead, dwFlags;
    WSANETWORKEVENTS      wsaNetworkEvents;
    SOCKADDR_IN           sinFrom;
    PICMP_ROUTER_SOL_MSG  pIcmpMsg;

    TraceEnter("HandleSolicitations");

    for(pleNode = ICBList.Flink;
        pleNode isnot &ICBList;
        pleNode = pleNode->Flink)
    {
        picb = CONTAINING_RECORD(pleNode, ICB, leIfLink);

        //
        // If the interface has no bindings, or isnot involved in Router Discovery, we wouldnt have
        // opened a socket on it so the FD_READ notification cant be for it
        //

        if((picb->dwNumAddresses is 0) or
           (picb->rdcRtrDiscInfo.bActive is FALSE))
        {
            continue;
        }

        for(i = 0; i < picb->dwNumAddresses; i++)
        {
            if(picb->rdcRtrDiscInfo.pRtrDiscSockets[i] is INVALID_SOCKET)
            {
                continue;
            }

            if(WSAEnumNetworkEvents(picb->rdcRtrDiscInfo.pRtrDiscSockets[i],
                                    NULL,
                                    &wsaNetworkEvents) is SOCKET_ERROR)
            {
                dwResult = GetLastError();

                Trace1(ERR,
                       "HandleSolicitations: WSAEnumNetworkEvents() returned %d",
                       dwResult);

                continue;
            }

            if(!(wsaNetworkEvents.lNetworkEvents & FD_READ))
            {
                //
                // Read bit isnot set and we arent interested in anything else
                //

                continue;
            }

            if(wsaNetworkEvents.iErrorCode[FD_READ_BIT] isnot NO_ERROR)
            {
                Trace3(ERR,
                       "HandleSolicitations: Error %d associated with socket %s on %S for FD_READ",
                       wsaNetworkEvents.iErrorCode[FD_READ_BIT],
                       PRINT_IPADDR(picb->pibBindings[i].dwAddress),
                       picb->pwszName);

                continue;
            }

            dwRcvAddrLen = sizeof(SOCKADDR_IN);
            dwFlags = 0;

            dwResult = WSARecvFrom(picb->rdcRtrDiscInfo.pRtrDiscSockets[i],
                                   &g_wsaIpRcvBuf,
                                   1,
                                   &dwBytesRead,
                                   &dwFlags,
                                   (struct sockaddr FAR*)&sinFrom,
                                   &dwRcvAddrLen,
                                   NULL,
                                   NULL);

            if(dwResult is SOCKET_ERROR)
            {
                dwResult = WSAGetLastError();

                Trace4(ERR,
                       "HandleSolicitations: Error %d in WSARecvFrom on  socket %d.%d.%d.%d over %S. Bytes read %d",
                       dwResult,
                       PRINT_IPADDR(picb->pibBindings[i].dwAddress),
                       picb->pwszName,
                       dwBytesRead);

                continue;
            }

            Trace2(RTRDISC,
                   "HandleSolicitations: Received %d bytes on %d.%d.%d.%d",
                   dwBytesRead,
                   PRINT_IPADDR(picb->pibBindings[i].dwAddress));

            if(picb->rdcRtrDiscInfo.bReplyPending)
            {
                //
                // Well the reply is pending so we dont need to do anything other than go
                // through the sockets for this interface and do a recvfrom to clear out the
                // FD_READ bit
                //

                continue;
            }

            dwSizeOfHeader = ((g_pIpHeader->byVerLen)&0x0f)<<2;

            pIcmpMsg = (PICMP_ROUTER_SOL_MSG)(((PBYTE)g_pIpHeader) + dwSizeOfHeader);

#if DBG

            Trace6(RTRDISC,
                   "HandleSolicitations: Type is %d, code %d. IP Length is %d. \n\t\tHeader Length is %d Src is %d.%d.%d.%d dest is %d.%d.%d.%d",
                   (DWORD)pIcmpMsg->byType,
                   (DWORD)pIcmpMsg->byCode,
                   ntohs(g_pIpHeader->wLength),
                   (DWORD)dwSizeOfHeader,
                   PRINT_IPADDR(g_pIpHeader->dwSrc),
                   PRINT_IPADDR(g_pIpHeader->dwDest));
#endif

            if((pIcmpMsg->byType isnot 0xA) or
               (pIcmpMsg->byCode isnot 0x0))
            {
                //
                // Can not be a valid ICMP Router Solicitation packet
                //

                continue;
            }

            if((ntohs(g_pIpHeader->wLength) - dwSizeOfHeader) < 8)
            {
                Trace0(RTRDISC,
                       "HandleSolicitations: Received ICMP packet of length less than 8, discarding");

                continue;
            }

            if(Compute16BitXSum((PVOID)pIcmpMsg,
                                8) isnot 0x0000)
            {
                Trace0(ERR,
                       "HandleSolicitations: ICMP packet checksum wrong");

                continue;
            }

            //
            // Check for valid neighbour
            //

            if((g_pIpHeader->dwSrc isnot 0) and
               ((g_pIpHeader->dwSrc & picb->pibBindings[i].dwMask) isnot
                (picb->pibBindings[i].dwAddress & picb->pibBindings[i].dwMask)))
            {
                Trace1(ERR,
                       "HandleSolicitations: Received ICMP solicitation from invalid neigbour %d.%d.%d.%d",
                       PRINT_IPADDR(g_pIpHeader->dwDest));

                continue;
            }

            //
            // Since we always Multicast, if the destination addresses was a
            // broadcast, log an error
            //

            if((g_pIpHeader->dwDest is 0xFFFFFFFF) or
               (g_pIpHeader->dwDest is (picb->pibBindings[i].dwMask | ~picb->pibBindings[i].dwMask)))
            {
                Trace0(ERR,
                       "HandleSolicitations: Received a broadcast ICMP solicitation");
            }

            //
            // So insert a reply for this interface. We multicast the replies
            // too.
            //

            picb->rdcRtrDiscInfo.bReplyPending = TRUE;

            SetFiringTimeForReply(picb);
        }
    }

    TraceLeave("HandleSolicitations");
}


VOID
SetFiringTimeForReply(
    IN PICB picb
    )

/*++

Routine Description


Locks


Arguments


Return Value


--*/

{
    LARGE_INTEGER       liCurrentTime, liRandomTime;
    INT                 iRand;
    ULONG               ulRem;
    PLIST_ENTRY         pleNode;
    PTIMER_QUEUE_ITEM   pOldTime;
    BOOL                bReset = FALSE;
    DWORD               dwResult;

    TraceEnter("SetFiringTimeForReply");

    //
    // We remove the timer the interface has queued up
    //

    if(g_leTimerQueueHead.Flink is &(picb->rdcRtrDiscInfo.tqiTimer.leTimerLink))
    {
        //
        // Since this timer was the first one, it determined the firing time of the timer.
        //

        bReset = TRUE;
    }

    RemoveEntryList(&(picb->rdcRtrDiscInfo.tqiTimer.leTimerLink));

    iRand = rand();

    liRandomTime = RtlExtendedLargeIntegerDivide(SecsToSysUnits(RESPONSE_DELAY_INTERVAL * iRand),
                                                 RAND_MAX,
                                                 &ulRem);

    liRandomTime = RtlLargeIntegerAdd(liRandomTime,SecsToSysUnits(MIN_RESPONSE_DELAY));

    NtQuerySystemTime(&liCurrentTime);

    picb->rdcRtrDiscInfo.tqiTimer.liFiringTime = RtlLargeIntegerAdd(liCurrentTime,liRandomTime);

    //
    // Insert into sorted list
    //

    for(pleNode = g_leTimerQueueHead.Flink;
        pleNode isnot &g_leTimerQueueHead;
        pleNode = pleNode->Flink)
    {
        pOldTime = CONTAINING_RECORD(pleNode,TIMER_QUEUE_ITEM,leTimerLink);

        if(RtlLargeIntegerGreaterThan(pOldTime->liFiringTime,
                                      picb->rdcRtrDiscInfo.tqiTimer.liFiringTime))
        {
            break;
        }
    }

    pleNode = pleNode->Blink;

    InsertHeadList(pleNode,
                   &(picb->rdcRtrDiscInfo.tqiTimer.leTimerLink));

    if((pleNode is &g_leTimerQueueHead) or bReset)
    {
        //
        // We inserted ourselves at the head of the queue, or took the timer off the front of the
        // queue
        //

        pOldTime = CONTAINING_RECORD(g_leTimerQueueHead.Flink,TIMER_QUEUE_ITEM,leTimerLink);

        if(!SetWaitableTimer(g_hRtrDiscTimer,
                             &pOldTime->liFiringTime,
                             0,
                             NULL,
                             NULL,
                             FALSE))
        {
            dwResult = GetLastError();

            Trace1(ERR,
                   "SetFiringTimeForReply: Error %d setting waitable timer",
                   dwResult);
        }

    }
}

WORD
Compute16BitXSum(
    IN VOID UNALIGNED *pvData,
    IN DWORD dwNumBytes
    )

/*++

Routine Description


Locks


Arguments


Return Value

    16 Bit one's complement of the one's complement sum of dwNumBytes starting
    at pData

--*/

{
    REGISTER WORD  UNALIGNED *pwStart;
    REGISTER DWORD  dwNumWords,i;
    REGISTER DWORD  dwSum = 0;

    pwStart = (PWORD)pvData;

    //
    // If there are odd numbered bytes, that has to be handled differently
    // However we can never have odd numbered bytes in our case so we optimize.
    //


    dwNumWords = dwNumBytes/2;

    for(i = 0; i < dwNumWords; i++)
    {
        dwSum += pwStart[i];
    }

    //
    // Add any carry
    //

    dwSum = (dwSum & 0x0000FFFF) + (dwSum >> 16);
    dwSum = dwSum + (dwSum >> 16);

    return LOWORD((~(DWORD_PTR)dwSum));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\rtmif.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\init.c

Abstract:

    IP Router Manager code

Revision History:

    Gurdeep Singh Pall          6/14/95  Created

--*/

#include "allinc.h"


// ChangeRouteWithForwarder()
//
//  Function: If addroute is TRUE this function adds an IP route. If addroute is FALSE
//            this function deletes the given route with the forwarder.
//
//  Returns:  Nothing
//
//

DWORD
ChangeRouteWithForwarder(
    PRTM_NET_ADDRESS pDestAddr,
    PRTM_ROUTE_INFO  pRoute,
    BOOL             bAddRoute,
    BOOL             bDelOld
    )
{
    IPMultihopRouteEntry           *pMultiRouteEntry;
    IPRouteEntry                   *pRouteEntry;
    IPRouteNextHopEntry            *pNexthopEntry;
    RTM_ENTITY_INFO                 entityInfo;
    RTM_NEXTHOP_INFO                nhiInfo;
    PADAPTER_INFO                   pBinding;
    UINT                            numnexthops, i;
    ULONG                           numbytes;
    DWORD                           dwAddr, dwMask;
    UINT                            dwLen;
    ULONG                           ifindex, nexthop, type;
    BOOL                            bValidNHop;
    DWORD                           context;
    DWORD                           dwLocalNet, dwLocalMask;
    DWORD                           dwResult;

    TraceEnter("ChangeRouteWithForwarder");

    if(!g_bSetRoutesToStack)
    {
        Trace0(ROUTE,
               "ChangeRouteWithForwarder: SetRoutesToStack is FALSE");

        TraceLeave("ChangeRouteWithForwarder");
        
        return NO_ERROR;
    }


    if (bAddRoute)
    {
        //
        // Ensure that the stack bit is set
        //

        if (!pRoute || !IsRouteStack(pRoute))
        {
            if (!pRoute )
            {
                Trace0(ROUTE,
                    "Error adding route, route == NULL"
                    );
            }
            
            else 
            {
                Trace1(ROUTE,
                    "Error adding route, Stack bit == %d",
                    IsRouteStack(pRoute)
                    );
            }

            TraceLeave("ChangeRouteWithForwarder");
            
            return ERROR_INVALID_PARAMETER;
        }


        // We should have atleast one nexthop
        numnexthops = pRoute->NextHopsList.NumNextHops;
        if (numnexthops == 0)
        {
            Trace0(ROUTE,
                "Error adding route, no nexthops");

            TraceLeave("ChangeRouteWithForwarder");
            
            return ERROR_INVALID_PARAMETER;
        }

        numbytes = sizeof(IPMultihopRouteEntry) + 
                    (numnexthops - 1) * 
                    sizeof(IPRouteNextHopEntry);
    }
    else
    {
        //
        // for routes to be deleted, they should be stack
        // routes
        //

        // We do not have any next hops here
        numbytes = sizeof(IPMultihopRouteEntry);
    }

    __try
    {    
        pMultiRouteEntry = _alloca(numbytes);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pRouteEntry = &pMultiRouteEntry->imre_routeinfo;

    //
    // Fill the dest and mask for the current route
    //

    RTM_IPV4_GET_ADDR_AND_LEN(pRouteEntry->ire_dest,
                              dwLen,
                              pDestAddr);
    
    pRouteEntry->ire_mask = RTM_IPV4_MASK_FROM_LEN(dwLen);

    TraceRoute2(ROUTE,
           "route to %d.%d.%d.%d/%d.%d.%d.%d",
               PRINT_IPADDR(pRouteEntry->ire_dest),
               PRINT_IPADDR(pRouteEntry->ire_mask));

    if (!bAddRoute)
    {    
        //
        // Prepare to delete old information on dest
        //
    
        pRouteEntry->ire_type = IRE_TYPE_INVALID;

        pMultiRouteEntry->imre_numnexthops = 0;

        Trace2(ROUTE,
               "ChangeRouteWithForwarder: Deleting all " \
               "routes to %d.%d.%d.%d/%d.%d.%d.%d",
               PRINT_IPADDR(pRouteEntry->ire_dest),
               PRINT_IPADDR(pRouteEntry->ire_mask));

        dwResult = SetIpMultihopRouteEntryToStack(pMultiRouteEntry);

        TraceLeave("ChangeRouteWithForwarder");
            
        return dwResult;
    }


    //
    // Get the routing protocol of the route's owner
    //
    
    dwResult = RtmGetEntityInfo(g_hLocalRoute,
                                pRoute->RouteOwner,
                                &entityInfo);

    if (dwResult isnot NO_ERROR)
    {
        Trace1(ROUTE,
               "Error %d retrieving entity info from RTM",
               dwResult);
               
        TraceLeave("ChangeRouteWithForwarder");
        
        return dwResult;
    }

    //
    // Prepare to add a multihop route on this dest
    //

    // Prepare information common to all nexthops

    pRouteEntry->ire_proto = entityInfo.EntityId.EntityProtocolId;
    pRouteEntry->ire_metric1 = pRoute->PrefInfo.Metric;
    pRouteEntry->ire_metric2 = IRE_METRIC_UNUSED;
    pRouteEntry->ire_metric3 = IRE_METRIC_UNUSED;
    pRouteEntry->ire_metric4 = IRE_METRIC_UNUSED;
    pRouteEntry->ire_metric5 = IRE_METRIC_UNUSED;
    pRouteEntry->ire_age = 0;

    numnexthops = 0;
    
    for (i = 0; i < pRoute->NextHopsList.NumNextHops; i++)
    {
        // Get and release next hop info as we got a copy
    
        dwResult = RtmGetNextHopInfo(g_hLocalRoute,
                                     pRoute->NextHopsList.NextHops[i],
                                     &nhiInfo);

        if (dwResult isnot NO_ERROR)
        {
            Trace1(ROUTE,
                   "Error %d retrieving next hop info from RTM",
                    dwResult);
                    
            continue;
        }
        
        RtmReleaseNextHopInfo(g_hLocalRoute, &nhiInfo);

        // Get the next hop address from the nexthop info

        RTM_IPV4_GET_ADDR_AND_LEN(nexthop,
                                  dwLen,
                                  &nhiInfo.NextHopAddress);

        TraceRoute3(
            ROUTE, "Next Hop %d.%d.%d.%d, If 0x%x, handle is 0x%x", 
            PRINT_IPADDR(nexthop),
            nhiInfo.InterfaceIndex,
            pRoute->NextHopsList.NextHops[i]
            );
    
        ENTER_READER(BINDING_LIST);
    
        //
        // find the binding given the interface id
        //
    
        pBinding = GetInterfaceBinding(nhiInfo.InterfaceIndex);
    
        if(!(pBinding))
        {
            //
            // The interface was deleted so lets just get out
            //
        
            EXIT_LOCK(BINDING_LIST);
        
            TraceRoute2(ERR,
               "**Warning** tried to %s route with interface %d which "
               "is no longer present",
               bAddRoute?"add":"delete",
               nhiInfo.InterfaceIndex);

            continue;
        }

        //
        // set adapter index - this is 0xffffffff
        // if the nexthop interface is not MAPPED
        //

        ifindex = pBinding->bBound ? pBinding->dwIfIndex : INVALID_IF_INDEX;
       
        if(((pRouteEntry->ire_proto is PROTO_IP_NT_STATIC) or
            (pRouteEntry->ire_proto is PROTO_IP_NT_AUTOSTATIC)) and
           (pBinding->ritType is ROUTER_IF_TYPE_FULL_ROUTER))
        {
            context = pBinding->dwSeqNumber;

            TraceRoute1(ROUTE,
                   "route context : ICB == %d\n\n",
                   pBinding->dwSeqNumber);
        }
        else
        {
            context = 0;

            if(ifindex is INVALID_IF_INDEX)
            {
                Trace3(ERR,
                       "**Error** Tried to %s route to %d.%d.%d.%d over %d as DOD\n",
                        bAddRoute?"add":"delete",
                        PRINT_IPADDR(pRouteEntry->ire_dest),
                        pBinding->dwIfIndex);

                EXIT_LOCK(BINDING_LIST);

                continue;
            }
        }

        //
        // First we figure out the correct nexthop for p2p links
        // For all other links, we take the whatever is given to us
        //

        if(IsIfP2P(pBinding->ritType))
        {
            if(pBinding->bBound)
            {
                TraceRoute2(
                    ROUTE, "Next Hop %d.%d.%d.%d, remote address %d.%d.%d.%d, "
                    "bound p2p",
                    PRINT_IPADDR(nexthop),
                    PRINT_IPADDR(pBinding->dwRemoteAddress)
                    );
                    
                if (nexthop is 0)
                {
                    nexthop = pBinding->dwRemoteAddress;
                }
            }
            else
            {
                nexthop = 0;
            }
        }

        //
        // Now we figure out if the route is a direct route or indirect routes
        // Routes over unconnected demand dial routes are marked OTHER
        //

        //
        // For connected WAN interfaces (P2P with mask of 255.255.255.255) we 
        // do two checks:
        // The next hop should be local address or remote address.
        //      AR: We used to do the above check but removed it because when 
        //          we set a route over a disconnected interface, we dont
        //          know the address of the remote endpoint
        // If the dest is remote address, then the MASK must be all ONES
        // We mark all valid routes as DIRECT
        //
        
        //
        // For LAN interfaces and WAN with non all ones mask, we check the 
        // following:
        // A direct route to a host must have the Destination as the NextHop
        // A direct route to a network must have the the NextHop as one of the 
        // local interfaces
        // The next hop must be on the same subnet as one of the bindings
        //

        type = IRE_TYPE_OTHER;

        if(pBinding->bBound)
        {
            if((pBinding->dwNumAddresses is 1) and
               (pBinding->rgibBinding[0].dwMask is ALL_ONES_MASK))
            {
                //
                // route over P2P link or P2MP link, possibly unnumbered.
                //
         
                if(
                    //
                    // if this is a route to the remote end of the P2P 
                    // connection
                    //
                    ((pBinding->dwRemoteAddress isnot 0) and
                     (pRouteEntry->ire_dest is pBinding->dwRemoteAddress)) or

                    //
                    // OR
                    // if the destination of the connection is the nexthop
                    //
                    (pRouteEntry->ire_dest is nexthop) or

                    //
                    // OR
                    // if the nexthop is the local address of the P2P connection
                    // 
                    (pBinding->rgibBinding[0].dwAddress is nexthop)
                  )
                {
                    //
                    // This is a direct route as per the TCP/IP stack
                    //
                    type = IRE_TYPE_DIRECT;
                }
                else
                {
                    type = IRE_TYPE_INDIRECT;
                }
            }
            else
            {
                //
                // A route over a non P2P link or a bay style p2p link which
                // has a /30 mask
                //

                bValidNHop = FALSE;
            
                type = IRE_TYPE_INDIRECT;

                for(i = 0; i < pBinding->dwNumAddresses; i++)
                {
                    dwLocalMask = pBinding->rgibBinding[i].dwMask;
                    
                    dwLocalNet = pBinding->rgibBinding[i].dwAddress & dwLocalMask;

                    if((dwLocalNet is (pRouteEntry->ire_dest & dwLocalMask)) or
                       (nexthop is IP_LOOPBACK_ADDRESS) or
                       (nexthop is pBinding->rgibBinding[i].dwAddress))
                    {
                        //
                        // Route to local net or over loopback
                        //
                    
                        type = IRE_TYPE_DIRECT;
                    }

                    if(((nexthop & dwLocalMask) is dwLocalNet) or
                       ((nexthop is IP_LOOPBACK_ADDRESS)))
                    {
                        //
                        // Next hop is on local net or loopback
                        // That is good
                        //

                        bValidNHop = TRUE;

                        break;                
                    }
                }
            
                if(!bValidNHop and 
                   (pBinding->dwNumAddresses isnot 0) and
                   (pBinding->ritType isnot ROUTER_IF_TYPE_INTERNAL))
                {
                    Trace0(ERR,
                       "ERROR - Nexthop not on same network");
                
                    for(i = 0; i < pBinding->dwNumAddresses; i ++)
                    {
                        Trace3(ROUTE,"AdapterId: %d, %d.%d.%d.%d/%d.%d.%d.%d",
                               pBinding->dwIfIndex,
                               PRINT_IPADDR(pBinding->rgibBinding[i].dwAddress),
                               PRINT_IPADDR(pBinding->rgibBinding[i].dwMask));
                    }

                    EXIT_LOCK(BINDING_LIST);
                

                    // PrintRoute(ERR, ipRoute);

                    continue;
                }
            }
        }

        EXIT_LOCK(BINDING_LIST);

#if 0
        // DGT workaround for bug where stack won't accept
        // nexthop of 0.0.0.0.  Until Chait fixes this, we'll
        // set nexthop to the ifindex.

        if (!nexthop) 
        {
            nexthop = ifindex;
        }
#endif

        //
        // Fill the current nexthop info into the route
        //
        
        if (numnexthops)
        {
            // Copy to the next posn in the route
            pNexthopEntry = 
                &pMultiRouteEntry->imre_morenexthops[numnexthops - 1];

            pNexthopEntry->ine_iretype = type;
            pNexthopEntry->ine_ifindex = ifindex;
            pNexthopEntry->ine_nexthop = nexthop;
            pNexthopEntry->ine_context = context;
        }
        else
        {
            // Copy to the first posn in the route
            pRouteEntry->ire_type    = type;
            pRouteEntry->ire_index   = ifindex;
            pRouteEntry->ire_nexthop = nexthop;
            pRouteEntry->ire_context = context;
        }

        numnexthops++;
    }

    pMultiRouteEntry->imre_numnexthops = numnexthops;
    pMultiRouteEntry->imre_flags = bDelOld ? IMRE_FLAG_DELETE_DEST : 0;
    
    if (numnexthops > 0)
    {
        dwResult = SetIpMultihopRouteEntryToStack(pMultiRouteEntry);

        if(dwResult isnot NO_ERROR) 
        {
            if(pRouteEntry->ire_nexthop != IP_LOOPBACK_ADDRESS)
            {
                Trace1(ERR, 
                       "Route addition failed with %x for", dwResult); 

                PrintRoute(ERR, pMultiRouteEntry);
            }

            Trace1(ERR, 
                   "Route addition failed with %x for local route", dwResult); 

            TraceLeave("ChangeRouteWithForwarder");

            return dwResult;
        }
        else
        {
            Trace0(ROUTE,
                   "Route addition succeeded for");

            PrintRoute(ROUTE, pMultiRouteEntry);
        }
    }

    else
    {
        Trace0(ERR, "Route not added since there are no next hops" );

        PrintRoute(ROUTE, pMultiRouteEntry);
    }

    TraceLeave("ChangeRouteWithForwarder");
    
    return NO_ERROR;
}


DWORD
WINAPI
ValidateRouteForProtocol(
    IN  DWORD   dwProtoId,
    IN  PVOID   pRouteInfo,
    IN  PVOID   pDestAddr  OPTIONAL
    )

/*++

Routine Description:

    This function is called by the router Manger (and indirectly by routing 
    protocols) to validate the route info. We set the preference and the 
    type of the route

Locks:

    Acquires the binding lock
    This function CAN NOT acquire the ICB lock

Arguments:

    dwProtoId   Protocols Id
    pRoute

Return Value:

    NO_ERROR
    RtmError code

--*/

{
    RTM_DEST_INFO    destInfo;
    PRTM_ROUTE_INFO  pRoute;
    RTM_NEXTHOP_INFO nextHop;
    PADAPTER_INFO    pBinding;
    HANDLE           hNextHop;
    BOOL             bValidNHop;
    DWORD            dwIfIndex;
    DWORD            dwLocalNet;
    DWORD            dwLocalMask;
    DWORD            destAddr;
    DWORD            destMask;
    DWORD            nexthop;
    DWORD            nhopMask;
    DWORD            dwType;
    DWORD            dwResult;
    UINT             i, j;

    pRoute = (PRTM_ROUTE_INFO)pRouteInfo;

    if (pRoute->PrefInfo.Preference is 0)
    {
        //
        // Map the metric weight based on the weight assigned by admin
        //
    
        pRoute->PrefInfo.Preference = ComputeRouteMetric(dwProtoId);
    }

    //
    // This validation applies to the unicast routes only.
    // [ This does not apply to INACTIVE routes and such ]
    //

    if (!(pRoute->BelongsToViews & RTM_VIEW_MASK_UCAST))
    {
        return NO_ERROR;
    }

    //
    // Get the destination address if it is not specified
    //
    
    if (!ARGUMENT_PRESENT(pDestAddr))
    {
        //
        // Get the destination information from the route
        //
    
        dwResult = RtmGetDestInfo(g_hLocalRoute,
                                  pRoute->DestHandle,
                                  RTM_BEST_PROTOCOL,
                                  RTM_VIEW_MASK_UCAST,
                                  &destInfo);

        if (dwResult != NO_ERROR)
        {
            Trace0(ERR,
                   "**ERROR:ValidateRoute: Invalid destination");
                   
            return dwResult;
        }

        pDestAddr = &destInfo.DestAddress;

        RtmReleaseDestInfo(g_hLocalRoute, &destInfo);
    }

    RTM_IPV4_GET_ADDR_AND_MASK(destAddr, 
                               destMask, 
                               (PRTM_NET_ADDRESS)pDestAddr);

    //
    // If the dest&Mask != dest then the stack will not set this route
    // Hence lets do the check here
    //

    if((destAddr & destMask) isnot destAddr)
    {

        TraceRoute2(ROUTE,
               "**ERROR:ValidateRoute: called with Dest %d.%d.%d.%d and "
               "Mask %d.%d.%d.%d - This will fail**",
               PRINT_IPADDR(destAddr),
               PRINT_IPADDR(destMask));

        return ERROR_INVALID_PARAMETER;
    }
   
    if((((DWORD)(destAddr & 0x000000FF)) >= (DWORD)0x000000E0) and 
       (destAddr isnot ALL_ONES_BROADCAST) and
       (destAddr isnot LOCAL_NET_MULTICAST))
    {
        //
        // This will catch the CLASS D/E but allow all 1's bcast
        //

        Trace1(ERR,
               "**ERROR:ValidateRoute: Dest %d.%d.%d.%d is invalid",
               PRINT_IPADDR(destAddr));

        return ERROR_INVALID_PARAMETER;
    } 

    if (pRoute->NextHopsList.NumNextHops == 0)
    {
        Trace0(ERR,
               "**ERROR:ValidateRoute: Zero next hops");

        return ERROR_INVALID_PARAMETER;
    }

    // Make sure each next hop on the route is a valid one

    for (i = 0; i < pRoute->NextHopsList.NumNextHops; i++)
    {
        hNextHop = pRoute->NextHopsList.NextHops[i];

        dwResult = RtmGetNextHopInfo(g_hLocalRoute,
                                     hNextHop,
                                     &nextHop);

        if (dwResult != NO_ERROR)
        {
            Trace0(ERR,
                   "**ERROR:ValidateRoute: Invalid next hop");
                   
            return dwResult;
        }

        dwIfIndex = nextHop.InterfaceIndex;

        RTM_IPV4_GET_ADDR_AND_MASK(nexthop, 
                                   nhopMask, 
                                   (PRTM_NET_ADDRESS)&nextHop.NextHopAddress);

        RtmReleaseNextHopInfo(g_hLocalRoute, &nextHop);
        
        // *** Exclusion Begin ***
        ENTER_READER(BINDING_LIST);
        
        //
        // find the interface given the interface id
        //
        
        pBinding = GetInterfaceBinding(dwIfIndex);
        
        if(!pBinding)
        {
            EXIT_LOCK(BINDING_LIST);

            Trace0(ERR,
                   "**ERROR:ValidateRoute: Binding doesnt exist for "
                   "interface");

            return ERROR_INVALID_PARAMETER;
        }

        //
        // Set whether the route is P2P
        //

        if(IsIfP2P(pBinding->ritType))
        {
            // Note that in the multihop case, we just overwrite value
            SetRouteP2P(pRoute);
        }

        //
        // Now we figure out if the route is a direct route or indirect routes
        // Routes over unconnected demand dial routes are marked OTHER
        //

        //
        // For connected WAN interfaces (P2P with mask of 255.255.255.255) we 
        // do two checks:
        // The next hop should be local address or remote address.
        //      AR: We used to do the above check but removed it because when 
        //          we set a route over a disconnected interface, we dont
        //          know the address of the remote endpoint
        // If the dest is remote address, then the MASK must be all ONES
        // We mark all valid routes as DIRECT
        //
        
        //
        // For LAN interfaces and WAN with non all ones mask, we check the 
        // following:
        // A direct route to a host to must have the Destination as the NextHop
        // A direct route to a network to must have the the NextHop as one of the 
        // local interfaces
        // The next hop must be on the same subnet as one of the bindings
        //

        dwType = IRE_TYPE_OTHER;
        
        if(pBinding->bBound and IsRouteValid(pRoute))
        {
            if((pBinding->dwNumAddresses is 1) and
               (pBinding->rgibBinding[0].dwMask is ALL_ONES_MASK))
            {
                //
                // route over P2P link. 
                // Set it to indirect and mark it as a P2P route
                //
               
                dwType = IRE_TYPE_DIRECT;

                //IpRtAssert(IsRouteP2P(pRoute));
            }
            else
            {
                //
                // A route over a non P2P link possibly unnumbered
                //

                bValidNHop = FALSE;
                
                dwType = IRE_TYPE_INDIRECT;

                for(j = 0; j < pBinding->dwNumAddresses; j++)
                {
                    dwLocalMask = pBinding->rgibBinding[j].dwMask;

                    dwLocalNet = pBinding->rgibBinding[j].dwAddress & dwLocalMask;

                    if((dwLocalNet is (destAddr & dwLocalMask)) or
                       (nexthop is IP_LOOPBACK_ADDRESS) or
                       //(nexthop is dwLocalNet) or
                       (nexthop is pBinding->rgibBinding[i].dwAddress))
                    {
                        //
                        // Route to local net or over loopback
                        //
                    
                        dwType = IRE_TYPE_DIRECT;
                    }

                    if(((nexthop & dwLocalMask) is dwLocalNet) or
                       ((nexthop is IP_LOOPBACK_ADDRESS)))
                    {
                        //
                        // Next hop is on local net or loopback
                        // That is good
                        //

                        bValidNHop = TRUE;

                        break;
                        
                    }
                }
                
                if(!bValidNHop and 
                   pBinding->dwNumAddresses and
                   (pBinding->ritType isnot ROUTER_IF_TYPE_INTERNAL))
                {
                    Trace1(ERR,
                           "ValidateRoute: Nexthop %d.%d.%d.%d not on network",
                           PRINT_IPADDR(nexthop));
                    
                    for(j = 0; j < pBinding->dwNumAddresses; j++)
                    {
                        Trace3(ROUTE,"AdapterId: %d, %d.%d.%d.%d/%d.%d.%d.%d",
                               pBinding->dwIfIndex,
                               PRINT_IPADDR(pBinding->rgibBinding[j].dwAddress),
                               PRINT_IPADDR(pBinding->rgibBinding[j].dwMask));
                    }

                    EXIT_LOCK(BINDING_LIST);
                    
                    return ERROR_INVALID_PARAMETER;
                }
            }
        }

        // *** Exclusion End ***
        EXIT_LOCK(BINDING_LIST);
    }

    //
    // Set the appropriate route flags in the route - stack flag etc.
    //

    g_LastUpdateTable[IPFORWARDCACHE] = 0;

    return NO_ERROR;
}


DWORD
WINAPI
ValidateRouteForProtocolEx(
    IN  DWORD   dwProtoId,
    IN  PVOID   pRouteInfo,
    IN  PVOID   pDestAddr  OPTIONAL
    )
    
/*++

Routine Description:

    This function is called by the router Manger (and indirectly by routing 
    protocols) to validate the route info. We set the preference and the 
    type of the route

Locks:

    Acquires the binding lock
    This function CAN NOT acquire the ICB lock

Arguments:

    dwProtoId   Protocols Id
    pRoute

Return Value:

    NO_ERROR
    RtmError code

--*/
{
    DWORD dwResult;

    dwResult = ValidateRouteForProtocol(
                    dwProtoId,
                    pRouteInfo,
                    pDestAddr
                    );

    if (dwResult is NO_ERROR)
    {
        ((PRTM_ROUTE_INFO)pRouteInfo)->Flags1 |= IP_STACK_ROUTE;
    }

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\rtrdisc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\rtrdisc.h

Abstract:

    Header file for router discover related stuff

Revision History:

    Amritansh Raghav  20th Mar 1996      Created

--*/

#ifndef __RTRDISC_H__
#define __RTRDISC_H__


typedef struct _ICB ICB, *PICB;

typedef struct _TIMER_QUEUE_ITEM
{
    LIST_ENTRY       leTimerLink;
    LARGE_INTEGER    liFiringTime;
}TIMER_QUEUE_ITEM, *PTIMER_QUEUE_ITEM;

typedef struct _ROUTER_DISC_CB
{
    WORD               wMaxAdvtInterval;
    WORD               wAdvtLifetime;
    BOOL               bAdvertise;
    BOOL               bActive;
    LONG               lPrefLevel;
    DWORD              dwNumAdvtsSent;
    DWORD              dwNumSolicitationsSeen;
    TIMER_QUEUE_ITEM   tqiTimer;
    BOOL               bReplyPending;
    LARGE_INTEGER      liMaxMinDiff;
    LARGE_INTEGER      liMinAdvtIntervalInSysUnits;
    SOCKET             *pRtrDiscSockets;
}ROUTER_DISC_CB, *PROUTER_DISC_CB;

//
// Blocking mode socket with IP Multicast capability
//

#define RTR_DISC_SOCKET_FLAGS (WSA_FLAG_MULTIPOINT_C_LEAF|WSA_FLAG_MULTIPOINT_D_LEAF)

#define ALL_ROUTERS_MULTICAST_GROUP     ((DWORD)0x020000E0) //inet_addr("224.0.0.2")

#define ALL_SYSTEMS_MULTICAST_GROUP     ((DWORD)0x010000E0) //inet_addr("224.0.0.1")

//#define ALL_SYSTEMS_MULTICAST_GROUP   ((DWORD)0xFFFFFFFF) //inet_addr("224.0.0.1")

#define ICMP_ROUTER_DISCOVERY_TYPE      ((BYTE) 0x9)

#define ICMP_ROUTER_DISCOVERY_CODE      ((BYTE) 0x0)

#define ICMP_ROUTER_DISCOVERY_ADDR_SIZE ((BYTE) 0x2)

#include <packon.h>

typedef struct _ICMP_ROUTER_SOL_MSG
{
    BYTE      byType;
    BYTE      byCode;
    WORD      wXSum;
    DWORD     dwReserved;
}ICMP_ROUTER_SOL_MSG, *PICMP_ROUTER_SOL_MSG;

typedef struct _ICMP_ADVT
{
    DWORD     dwRtrIpAddr;
    LONG      lPrefLevel;
}ICMP_ADVT, *PICMP_ADVT;

typedef struct _ICMP_ROUTER_ADVT_MSG
{
    BYTE       byType;
    BYTE       byCode;
    WORD       wXSum;
    BYTE       byNumAddrs;
    BYTE       byAddrEntrySize;
    WORD       wLifeTime;
    ICMP_ADVT  iaAdvt[1];
}ICMP_ROUTER_ADVT_MSG, *PICMP_ROUTER_ADVT_MSG;

#define SIZEOF_RTRDISC_ADVT(X)  \
    (FIELD_OFFSET(ICMP_ROUTER_ADVT_MSG, iaAdvt[0])   +      \
     ((X) * sizeof(ICMP_ADVT)))
 
typedef struct _IP_HEADER 
{
    BYTE      byVerLen;         // Version and length.
    BYTE      byTos;            // Type of service.
    WORD      wLength;          // Total length of datagram.
    WORD      wId;              // Identification.
    WORD      wFlagOff;         // Flags and fragment offset.
    BYTE      byTtl;            // Time to live.
    BYTE      byProtocol;       // Protocol.
    WORD      wXSum;            // Header checksum.
    DWORD     dwSrc;            // Source address.
    DWORD     dwDest;           // Destination address.
}IP_HEADER, *PIP_HEADER;

//
// Max size of the IP Header in DWORDs
//

#include <packoff.h>

#define MAX_LEN_HDR          15

//
// Take the largest ICMP packet that can be received to avoid getting 
// too many buffer size errors
//

#define ICMP_RCV_BUFFER_LEN  ((2*MAX_LEN_HDR) + 2 +2)

//
// Function prototypes
//

VOID  
SetRouterDiscoveryInfo(
    IN PICB picb,
    IN PRTR_INFO_BLOCK_HEADER pInfoHdr
    );

VOID  
InitializeRouterDiscoveryInfo(
    IN PICB picb,
    IN PRTR_INFO_BLOCK_HEADER pInfoHdr
    );

DWORD
GetInterfaceRouterDiscoveryInfo(
    PICB picb,
    PRTR_TOC_ENTRY pToc,
    PBYTE dataptr,
    PRTR_INFO_BLOCK_HEADER pInfoHdr,
    PDWORD pdwSize
    );

DWORD 
ActivateRouterDiscovery(
    IN PICB  picb
    );

BOOL  
SetFiringTimeForAdvt(
    IN PICB picb
    );

DWORD 
CreateSockets(
    IN PICB picb
    );

DWORD 
UpdateAdvertisement(
    IN PICB picb
    );

VOID 
HandleRtrDiscTimer(
    VOID    
    );

VOID  
HandleSolicitations(
    VOID 
    );

VOID  
AdvertiseInterface(
    IN PICB picb
    );

WORD  
Compute16BitXSum(
    IN PVOID pvData,
    IN DWORD dwNumBytes
    );

DWORD 
DeActivateRouterDiscovery(
    IN PICB  picb
    );

VOID  
SetFiringTimeForReply(
    IN PICB picb
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\configentry.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\configurationentry.h

Abstract:

    The file contains definitions for the configuration entry.

--*/

#ifndef _CONFIGURATIONENTRY_H_
#define _CONFIGURATIONENTRY_H_

//
// type:    EVENT_ENTRY
//
// stores events for the ip router manager
//
// protected by the read-write lock CONFIGURATION_ENTRY::rwlLock
//

typedef struct _EVENT_ENTRY 
{
    QUEUE_ENTRY             qeEventQueueLink;
    ROUTING_PROTOCOL_EVENTS rpeEvent;
    MESSAGE                 mMessage;
} EVENT_ENTRY, *PEVENT_ENTRY;



DWORD
EE_Create (
    IN  ROUTING_PROTOCOL_EVENTS rpeEvent,
    IN  MESSAGE                 mMessage,
    OUT PEVENT_ENTRY            *ppeeEventEntry);

DWORD
EE_Destroy (
    IN  PEVENT_ENTRY            peeEventEntry);

#ifdef DEBUG
DWORD
EE_Display (
    IN  PEVENT_ENTRY            peeEventEntry);
#else
#define EE_Display(peeEventEntry)
#endif // DEBUG

DWORD
EnqueueEvent(
    IN  ROUTING_PROTOCOL_EVENTS rpeEvent,
    IN  MESSAGE                 mMessage);

DWORD
DequeueEvent(
    OUT ROUTING_PROTOCOL_EVENTS  *prpeEvent,
    OUT MESSAGE                  *pmMessage);



//
// various codes describing states of IPSAMPLE.
//

typedef enum _IPSAMPLE_STATUS_CODE
{
    IPSAMPLE_STATUS_RUNNING     = 101,
    IPSAMPLE_STATUS_STOPPING    = 102,
    IPSAMPLE_STATUS_STOPPED     = 103
} IPSAMPLE_STATUS_CODE, *PIPSAMPLE_STATUS_CODE;


//
// type:    CONFIGURATION_ENTRY
//
// stores global state.
//
// igsStats is protected through interlocked increments or decrements
// lqEventQueue is protected by its own lock
// rest protected by the read-write lock CONFIGURATION_ENTRY::rwlLock
// 


typedef struct _CONFIGURATION_ENTRY
{
    // 
    // Following are PERSISTENT, across Start and Stop Protocol
    //
    
    // Lock
    READ_WRITE_LOCK         rwlLock;

    // Global Heap
    HANDLE                  hGlobalHeap;
    
    // Clean Stop (Protocol)
    ULONG                   ulActivityCount;
    HANDLE                  hActivitySemaphore;

    // Logging & Tracing Information
    DWORD 				    dwLogLevel;
    HANDLE 				    hLogHandle;
    DWORD					dwTraceID;

    // Event Queue
    LOCKED_QUEUE            lqEventQueue;

    // Protocol State
    IPSAMPLE_STATUS_CODE    iscStatus;


    
    // 
    // Following are INITIALIZE'd and CLEANUP'd every Start & Stop Protocol
    //

    // Store of Dynamic Locks
    DYNAMIC_LOCKS_STORE     dlsDynamicLocksStore;
    
    // Timer Entry
    HANDLE                  hTimerQueue;
    
    // Router Manager Information 
    HANDLE				    hMgrNotificationEvent;
    SUPPORT_FUNCTIONS       sfSupportFunctions;

    // RTMv2 Information
    RTM_ENTITY_INFO			reiRtmEntity;
    RTM_REGN_PROFILE  		rrpRtmProfile;
    HANDLE				    hRtmHandle;
    HANDLE				    hRtmNotificationHandle;

    // MGM Information
    HANDLE				    hMgmHandle;

    // Network Entry
    PNETWORK_ENTRY          pneNetworkEntry;

    // Global Statistics
    IPSAMPLE_GLOBAL_STATS   igsStats;

} CONFIGURATION_ENTRY, *PCONFIGURATION_ENTRY;



// create all fields on DLL_PROCESS_ATTACH
DWORD
CE_Create (
    IN  PCONFIGURATION_ENTRY    pce);

// destroy all fields on DLL_PROCESS_DEATTACH
DWORD
CE_Destroy (
    IN  PCONFIGURATION_ENTRY    pce);

// initialize non persistent fields on StartProtocol
DWORD
CE_Initialize (
    IN  PCONFIGURATION_ENTRY    pce,
    IN  HANDLE                  hMgrNotificationEvent,
    IN  PSUPPORT_FUNCTIONS      psfSupportFunctions,
    IN  PIPSAMPLE_GLOBAL_CONFIG pigc);

// cleanup non persistent fields on StopProtocol
DWORD
CE_Cleanup (
    IN  PCONFIGURATION_ENTRY    pce,
    IN  BOOL                    bCleanupWinsock);

#ifdef DEBUG
DWORD
CE_Display (
    IN  PCONFIGURATION_ENTRY    pce);
#else
#define CE_Display(pce)
#endif // DEBUG

#endif // _CONFIGURATIONENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\configmgr.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\configurationmanager.c

Abstract:

    The file contains global configuration related functions,
    implementing the configuration manager.

--*/

#include "pchsample.h"
#pragma hdrstop

// global variables...

CONFIGURATION_ENTRY g_ce;



// functions...

BOOL
ValidateGlobalConfig (
    IN  PIPSAMPLE_GLOBAL_CONFIG pigc)
/*++

Routine Description
    Checks to see if the global configuration is OK. It is good practice to
    do this because a corrupt registry can change configuration causing all
    sorts of debugging headaches if it is not found early

Locks
    None

Arguments
    pigc                pointer to ip sample's global configuration

Return Value
    TRUE                if the configuration is good
    FALSE               o/w

--*/
{
    DWORD dwErr = NO_ERROR;
    
    do                          // breakout loop
    {
        if (pigc is NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            TRACE0(CONFIGURATION, "Error null global config");

            break;
        }

        // 
        // check range of each field
        // 

        // ensure that the logging level is within bounds
        if((pigc->dwLoggingLevel < IPSAMPLE_LOGGING_NONE) or
           (pigc->dwLoggingLevel > IPSAMPLE_LOGGING_INFO))
        {   
            dwErr = ERROR_INVALID_PARAMETER;
            TRACE0(CONFIGURATION, "Error log level out of range");

            break;
        }

        // add more here...
        
    } while (FALSE);

    if (!(dwErr is NO_ERROR))
    {
        TRACE0(CONFIGURATION, "Error corrupt global config");
        LOGERR0(CORRUPT_GLOBAL_CONFIG, dwErr);
        
        return FALSE;
    }

    return TRUE;
}



////////////////////////////////////////
// WORKERFUNCTIONS
////////////////////////////////////////

VOID
CM_WorkerFinishStopProtocol (
    IN      PVOID   pvContext)
/*++

Routine Description
    WORKERFUNCTION.  Queued by CM_StopProtocol.
    Waits for all active and queued threads to exit and cleans up
    configuration entry.

Locks
    Acquires exclusively g_ce.rwlLock
    Releases             g_ce.rwlLock

Arguments
    pvContext           ulActivityCount

Return Value
    None

--*/
{
    DWORD           dwErr = NO_ERROR;
    MESSAGE         mMessage;
    
    ULONG           ulThreadCount = 0;
    
    ulThreadCount = (ULONG)pvContext;

    TRACE1(ENTER, "Entering WorkerFinishStopProtocol: active threads %u",
           ulThreadCount);
    
    // NOTE: since this is called while the router is stopping, there is no
    // need for it to use ENTER_SAMPLE_WORKER()/LEAVE_SAMPLE_WORKER()

    // waits for all threads to stop
    while (ulThreadCount-- > 0)
        WaitForSingleObject(g_ce.hActivitySemaphore, INFINITE);

    
   // acquire the lock and release it, just to be sure that all threads
   // have quit their calls to LeaveSampleWorker()

    ACQUIRE_WRITE_LOCK(&(g_ce.rwlLock));
    RELEASE_WRITE_LOCK(&(g_ce.rwlLock));

    // NOTE: there is no need to acquire g_ce.rwlLock for the call to
    // CE_Cleanup since there are no threads competing for access to the
    // fields being cleaned up.  new competing threads aren't created till
    // CE_Cleanup sets the protocol state to IPSAMPLE_STATUS_STOPPED, which
    // is the last thing it does.

    CE_Cleanup(&g_ce, TRUE);

    LOGINFO0(SAMPLE_STOPPED, NO_ERROR);
    
    // inform router manager that we are done
    ZeroMemory(&mMessage, sizeof(MESSAGE));
    if (EnqueueEvent(ROUTER_STOPPED, mMessage) is NO_ERROR)
        SetEvent(g_ce.hMgrNotificationEvent);

    TRACE0(LEAVE, "Leaving  WorkerFinishStopProtocol");
}



////////////////////////////////////////
// APIFUNCTIONS
////////////////////////////////////////

DWORD
CM_StartProtocol (
    IN  HANDLE                  hMgrNotificationEvent,
    IN  PSUPPORT_FUNCTIONS      psfSupportFunctions,
    IN  PVOID                   pvGlobalInfo)
/*++

Routine Description
    Called by StartProtocol.  Initializes configuration entry.

Locks
    Acquires exclusively g_ce.rwlLock
    Releases             g_ce.rwlLock

Arguments
    hMgrNotificationEvent   event used to notify ip router manager
    psfSupportFunctions     functions exported by ip router manager
    pvGlobalInfo            global configuration set in registry

Return Value
    NO_ERROR            if successfully initiailzed
    Failure code        o/w

--*/
{
    DWORD dwErr = NO_ERROR;
    
    // NOTE: since this is called when SAMPLE is stopped, there is no need
    // for it to use ENTER_SAMPLE_API()/LEAVE_SAMPLE_API()

    ACQUIRE_WRITE_LOCK(&(g_ce.rwlLock));

    do                          // breakout loop
    {
        if (g_ce.iscStatus != IPSAMPLE_STATUS_STOPPED)
        {
            TRACE0(CONFIGURATION, "Error ip sample already installed");
            LOGWARN0(SAMPLE_ALREADY_STARTED, NO_ERROR);
            dwErr = ERROR_CAN_NOT_COMPLETE;
            
            break;
        }

        if (!ValidateGlobalConfig((PIPSAMPLE_GLOBAL_CONFIG) pvGlobalInfo))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        dwErr = CE_Initialize(&g_ce,
                              hMgrNotificationEvent,
                              psfSupportFunctions,
                              (PIPSAMPLE_GLOBAL_CONFIG) pvGlobalInfo);
    } while (FALSE);
    
    RELEASE_WRITE_LOCK(&(g_ce.rwlLock));

    if (dwErr is NO_ERROR)
    {
        TRACE0(CONFIGURATION, "ip sample has successfully started");
        LOGINFO0(SAMPLE_STARTED, dwErr);
    }
    else
    {
        TRACE1(CONFIGURATION, "Error ip sample failed to start", dwErr);
        LOGERR0(SAMPLE_START_FAILED, dwErr);
    }

    return dwErr;
}



DWORD
CM_StopProtocol (
    )
/*++

Routine Description
    Called by StopProtocol.  It queues a WORKERFUNCTION which waits for all
    active threads to exit and then cleans up the configuration entry.

Locks
    Acquires exclusively g_ce.rwlLock
    Releases             g_ce.rwlLock

Arguments
    None

Return Value
    ERROR_PROTOCOL_STOP_PENDING     if successfully queued
    Failure code                    o/w

--*/
{
    DWORD dwErr         = NO_ERROR;
    BOOL  bSuccess      = FALSE;
    ULONG ulThreadCount = 0;
    
    // NOTE: no need to use ENTER_SAMPLE_API()/LEAVE_SAMPLE_API()
    // Does not use QueueSampleWorker
    
    ACQUIRE_WRITE_LOCK(&(g_ce.rwlLock));

    do                          // breakout loop
    {
        // cannot stop if already stopped
        if (g_ce.iscStatus != IPSAMPLE_STATUS_RUNNING)
        {
            TRACE0(CONFIGURATION, "Error ip sample already stopped");
            LOGWARN0(SAMPLE_ALREADY_STOPPED, NO_ERROR);
            dwErr = ERROR_CAN_NOT_COMPLETE;
        
            break;
        }
    

        // set IPSAMPLE's status to STOPPING; this prevents any more
        // work-items from being queued, and it prevents the ones already
        // queued from executing
        g_ce.iscStatus = IPSAMPLE_STATUS_STOPPING;
        

        // find out how many threads are either queued or active in SAMPLE;
        // we will have to wait for this many threads to exit before we
        // clean up SAMPLE's resources
        ulThreadCount = g_ce.ulActivityCount;
        TRACE1(CONFIGURATION,
               "%u threads are active in SAMPLE", ulThreadCount);
    } while (FALSE);

    RELEASE_WRITE_LOCK(&(g_ce.rwlLock));


    if (dwErr is NO_ERROR)
    {
        bSuccess = QueueUserWorkItem(
            (LPTHREAD_START_ROUTINE)CM_WorkerFinishStopProtocol,
            (PVOID) ulThreadCount,
            0); // no flags

        dwErr = (bSuccess) ? ERROR_PROTOCOL_STOP_PENDING : GetLastError();
    }

    return dwErr;
}



DWORD
CM_GetGlobalInfo (
    IN      PVOID 	            pvGlobalInfo,
    IN OUT  PULONG              pulBufferSize,
    OUT     PULONG	            pulStructureVersion,
    OUT     PULONG              pulStructureSize,
    OUT     PULONG              pulStructureCount)
/*++

Routine Description
    See if there's space enough to return ip sample global config. If yes,
    we return it, otherwise return the size needed.

Locks
    Acquires shared g_ce.rwlLock
    Releases        g_ce.rwlLock
    
Arguments
    pvGlobalInfo        pointer to allocated buffer to store our config
    pulBufferSize       IN  size of buffer received
                        OUT size of our global config

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    DWORD                   dwErr = NO_ERROR;
    PIPSAMPLE_GLOBAL_CONFIG pigc;
    ULONG                   ulSize = sizeof(IPSAMPLE_GLOBAL_CONFIG);

    if (!ENTER_SAMPLE_API()) { return ERROR_CAN_NOT_COMPLETE; }

    do                          // breakout loop
    {
        if((*pulBufferSize < ulSize) or (pvGlobalInfo is NULL))
        {
            // either the size was too small or there was no storage
            dwErr = ERROR_INSUFFICIENT_BUFFER;
            TRACE1(CONFIGURATION,
                   "CM_GetGlobalInfo: *ulBufferSize %u",
                   *pulBufferSize);

            *pulBufferSize = ulSize;

            break;
        }

        *pulBufferSize = ulSize;

        if (pulStructureVersion)    *pulStructureVersion    = 1;
        if (pulStructureSize)       *pulStructureSize       = ulSize;
        if (pulStructureCount)      *pulStructureCount      = 1;
        

        // so we have a good buffer to write our info into...
        pigc = (PIPSAMPLE_GLOBAL_CONFIG) pvGlobalInfo;

        // copy out the global configuration
        ACQUIRE_READ_LOCK(&(g_ce.rwlLock));

        pigc->dwLoggingLevel = g_ce.dwLogLevel;

        RELEASE_READ_LOCK(&(g_ce.rwlLock));
    } while (FALSE);
    
    LEAVE_SAMPLE_API();

    return dwErr;
}



DWORD
CM_SetGlobalInfo (
    IN      PVOID 	            pvGlobalInfo)
/*++

Routine Description
    Set ip sample's global configuration.

Locks
    Acquires exclusively g_ce.rwlLock
    Releases             g_ce.rwlLock
    
Arguments
    pvGlobalInfo        buffer with new global configuration

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    DWORD                   dwErr = NO_ERROR;
    PIPSAMPLE_GLOBAL_CONFIG pigc;

    if (!ENTER_SAMPLE_API()) { return ERROR_CAN_NOT_COMPLETE; }

    do                          // breakout loop
    {
        pigc = (PIPSAMPLE_GLOBAL_CONFIG) pvGlobalInfo;
        
        if (!ValidateGlobalConfig(pigc)) 
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        // copy in the global configuration
        ACQUIRE_WRITE_LOCK(&(g_ce.rwlLock));

        g_ce.dwLogLevel = pigc->dwLoggingLevel;

        RELEASE_WRITE_LOCK(&(g_ce.rwlLock));
    } while (FALSE);
    
    LEAVE_SAMPLE_API();

    return dwErr;
}



DWORD
CM_GetEventMessage (
    OUT ROUTING_PROTOCOL_EVENTS *prpeEvent,
    OUT MESSAGE                 *pmMessage)
/*++

Routine Description
    Get the next event in queue for the ip router manager.

Locks
    None
    
Arguments
    prpeEvent           routing protocol event type
    pmMessage           message associated with the event

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    DWORD           dwErr       = NO_ERROR;
    
    // NOTE: this can be called after the protocol is stopped, as in when
    // the ip router manager is retrieving the ROUTER_STOPPED message, so
    // we do not call ENTER_SAMPLE_API()/LEAVE_SAMPLE_API()

    dwErr = DequeueEvent(prpeEvent, pmMessage);
    
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\worker.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\rtrmgr\worker.c

Abstract:
    IP Router Manager worker thread code

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/

#include "allinc.h"

extern SOCKET McMiscSocket;

//
// From iphlpapi.h
//

DWORD
NotifyRouteChangeEx(
    PHANDLE      pHandle,
    LPOVERLAPPED pOverLapped,
    BOOL         bExQueue
    );

DWORD
WINAPI
EnableRouter(
    HANDLE* pHandle,
    OVERLAPPED* pOverlapped
    );

DWORD
WINAPI
UnenableRouter(
    OVERLAPPED* pOverlapped,
    LPDWORD lpdwEnableCount OPTIONAL
    );

DWORD
WorkerThread (
    PVOID pGlobalInfo
    )
{
    DWORD       eventindex ;            // index of event notified
    HANDLE      workereventarray [NUMBER_OF_EVENTS] ;  // event array
    PPROTO_CB   protptr ;
    DWORD       dwTimeOut, dwResult, dwByteCount, dwEnableCount;
    OVERLAPPED  RouteChangeOverlapped, SetForwardingOverlapped;
    HANDLE      hTemp;

    TraceEnter("WorkerThread");

    //
    // Prepare list of events that WaitForMultipleObjects will wait on
    //

    workereventarray[EVENT_DEMANDDIAL]        = g_hDemandDialEvent;
#ifdef KSL_IPINIP
    workereventarray[EVENT_IPINIP]            = g_hIpInIpEvent;
#endif //KSL_IPINIP
    workereventarray[EVENT_STOP_ROUTER]       = g_hStopRouterEvent;
    workereventarray[EVENT_SET_FORWARDING]    = g_hSetForwardingEvent;
    workereventarray[EVENT_FORWARDING_CHANGE] = g_hForwardingChangeEvent;
    workereventarray[EVENT_STACK_CHANGE]      = g_hStackChangeEvent;
    workereventarray[EVENT_ROUTINGPROTOCOL]   = g_hRoutingProtocolEvent ;
    workereventarray[EVENT_RTRDISCTIMER]      = g_hRtrDiscTimer;
    workereventarray[EVENT_RTRDISCSOCKET]     = g_hRtrDiscSocketEvent;
    workereventarray[EVENT_MCMISCSOCKET]      = g_hMcMiscSocketEvent;
    workereventarray[EVENT_MZAPTIMER]         = g_hMzapTimer;
    workereventarray[EVENT_MZAPSOCKET]        = g_hMzapSocketEvent;
    workereventarray[EVENT_RASADVTIMER]       = g_hRasAdvTimer;
    workereventarray[EVENT_MHBEAT]            = g_hMHbeatSocketEvent;
    workereventarray[EVENT_MCAST_0]           = g_hMcastEvents[0];
    workereventarray[EVENT_MCAST_1]           = g_hMcastEvents[1];
    workereventarray[EVENT_MCAST_2]           = g_hMcastEvents[2];
    workereventarray[EVENT_ROUTE_CHANGE_0]    = g_hRouteChangeEvents[0];
    workereventarray[EVENT_ROUTE_CHANGE_1]    = g_hRouteChangeEvents[1];
    workereventarray[EVENT_ROUTE_CHANGE_2]    = g_hRouteChangeEvents[2];


    dwTimeOut = INFINITE;

    //
    // Do a setsockopt to listen for address changes.
    // This must be done in the thread that will wait for the notifications
    //

    dwResult = WSAIoctl(McMiscSocket,
                        SIO_ADDRESS_LIST_CHANGE,
                        NULL,
                        0,
                        NULL,
                        0,
                        &dwByteCount,
                        NULL,
                        NULL);

    if(dwResult is SOCKET_ERROR)
    {
        dwResult = WSAGetLastError();

        if((dwResult isnot WSAEWOULDBLOCK) and
           (dwResult isnot WSA_IO_PENDING) and
           (dwResult isnot NO_ERROR))
        {

            Trace1(ERR,
                   "WorkerThread: Error %d from SIO_ADDRESS_LIST_CHANGE",
                   dwResult);
        }
    }


    ZeroMemory(&SetForwardingOverlapped,
               sizeof(SetForwardingOverlapped));

#if 1

    for (
        eventindex = 0; 
        eventindex < NUM_ROUTE_CHANGE_IRPS; 
        eventindex++
        )
    {
        PostIoctlForRouteChangeNotification(eventindex);
    }

#else
    ZeroMemory(&RouteChangeOverlapped,
               sizeof(RouteChangeOverlapped));

    RouteChangeOverlapped.hEvent = g_hStackChangeEvent;

    hTemp = NULL;

    dwResult = NotifyRouteChangeEx(&hTemp,
                                   &RouteChangeOverlapped,
                                   TRUE);

    if((dwResult isnot NO_ERROR) and
       (dwResult isnot ERROR_IO_PENDING))
    {
        Trace1(ERR,
               "WorkerThread: Error %d from NotifyRouteChange",
               dwResult);
    }
#endif

    __try
    {
        while(TRUE)
        {
            eventindex = WaitForMultipleObjectsEx(NUMBER_OF_EVENTS,
                                                  workereventarray, 
                                                  FALSE,
                                                  dwTimeOut,
                                                  TRUE);
        
            switch(eventindex) 
            {
                case WAIT_IO_COMPLETION:
                {
                    continue ;                  // handle alertable wait case
                }

                case EVENT_DEMANDDIAL:
                {
                    Trace0(DEMAND,
                           "WorkerThread: Demand Dial event received");
                    
                    HandleDemandDialEvent();
                    
                    break ;
                }

#ifdef KSL_IPINIP
                case EVENT_IPINIP:
                {
                    Trace0(DEMAND,
                           "WorkerThread: IpInIp event received");

                    HandleIpInIpEvent();

                    break ;
                }
#endif //KSL_IPINIP

                case EVENT_STOP_ROUTER:
                case WAIT_TIMEOUT:
                {
                    Trace0(GLOBAL,
                           "WorkerThread: Stop router event received");
                    
                    // *** Exclusion Begin ***
                    ENTER_READER(ICB_LIST);

                    // *** Exclusion Begin ***
                    ENTER_WRITER(PROTOCOL_CB_LIST);

                    //
                    // If all interfaces havent been deleted we switch to 
                    // polling mode where we get up every 
                    // INTERFACE_DELETE_POLL_TIME and check
                    //
                    
                    if(!IsListEmpty(&ICBList))
                    {
                        //
                        // Now wakeup every two second to check
                        //
                        
                        dwTimeOut = INTERFACE_DELETE_POLL_TIME;
                        
                        EXIT_LOCK(PROTOCOL_CB_LIST);
                    
                        EXIT_LOCK(ICB_LIST);
                    
                        break ;
                    }
                    else
                    {
                        //
                        // Get out of polling mode
                        //

                        dwTimeOut = INFINITE;
                    }

                    //
                    // Since all interfaces are now gone, we can delete the 
                    // internal interface
                    //

                    if(g_pInternalInterfaceCb)
                    {
                        DeleteInternalInterface();
                    }

                    NotifyRoutingProtocolsToStop() ;    // tells routing protocols to stop.
                    //
                    // Well interfaces have been deleted, so what about 
                    // protocols?
                    //
                    
                    WaitForAPIsToExitBeforeStopping() ;     // returns when it is safe to stop router

                    if (AllRoutingProtocolsStopped())
                    {
                        //
                        // This check is done here since all routing protocols 
                        // may have stopped synchronously, in which case 
                        // we can safely stop
                        //

                        EXIT_LOCK(PROTOCOL_CB_LIST);

                        EXIT_LOCK(ICB_LIST);
                       
                        __leave;
                    }

                    //
                    // All interfaces have been deleted but some protocol is
                    // still running. We will get a EVENT_ROUTINGPROTOCOL
                    // notification
                    //
                    
                    EXIT_LOCK(PROTOCOL_CB_LIST);
                    
                    EXIT_LOCK(ICB_LIST);

                    // make sure mrinfo/mtrace service is stopped
                    StopMcMisc();

                    if ( g_bEnableNetbtBcastFrowarding )
                    {
                        RestoreNetbtBcastForwardingMode();
                        g_bEnableNetbtBcastFrowarding = FALSE;
                    }
                    
                    break ;
                }

                case EVENT_SET_FORWARDING:
                {
                    hTemp = NULL;

                    EnterCriticalSection(&g_csFwdState);

                    //
                    // If our current state matches the user's request
                    // just free the message and move on
                    //

                    if(g_bEnableFwdRequest is g_bFwdEnabled)
                    {
                        LeaveCriticalSection(&g_csFwdState);

                        break;
                    }

                    SetForwardingOverlapped.hEvent = g_hForwardingChangeEvent;

                    if(g_bEnableFwdRequest)
                    {
                        Trace0(GLOBAL,
                               "WorkerThread: **--Enabling forwarding--**\n\n");

                        dwResult = EnableRouter(&hTemp,
                                                &SetForwardingOverlapped);

                        g_bFwdEnabled = TRUE;
                    }
                    else
                    {
                        Trace0(GLOBAL,
                               "WorkerThread: **--Disabling forwarding--**\n\n");

                        dwResult = UnenableRouter(&SetForwardingOverlapped,
                                                  &dwEnableCount);

                        g_bFwdEnabled = FALSE;
                    }

                    if((dwResult isnot NO_ERROR) and
                       (dwResult isnot ERROR_IO_PENDING))
                    {
                        Trace1(ERR,
                               "WorkerThread: Error %d from call",
                               dwResult);
                    }

                    LeaveCriticalSection(&g_csFwdState);

                    break;
                }

                case EVENT_FORWARDING_CHANGE:
                {
                    Trace0(GLOBAL,
                           "WorkerThread: **--Forwarding change event--**\n\n");

                    break;
                }

                case EVENT_STACK_CHANGE:
                {
                    Trace0(GLOBAL,
                           "WorkerThread: Stack Change event received");


                    UpdateDefaultRoutes();

                    dwResult = NotifyRouteChangeEx(&hTemp,
                                                   &RouteChangeOverlapped,
                                                   TRUE);
                    
                    if((dwResult isnot NO_ERROR) and
                       (dwResult isnot ERROR_IO_PENDING))
                    {
                        Trace1(ERR,
                               "WorkerThread: Error %d from NotifyRouteChangeEx",
                               dwResult);

                        //
                        // If there was an error, try again
                        //

                        NotifyRouteChangeEx(&hTemp,
                                            &RouteChangeOverlapped,
                                            TRUE);
                    }

                    break;
                }
            
                case EVENT_ROUTINGPROTOCOL:
                {
                    Trace0(GLOBAL,
                           "WorkerThread: Routing protocol notification received");

                    HandleRoutingProtocolNotification() ;
                    
                    if((RouterState.IRS_State is RTR_STATE_STOPPING) and
                       IsListEmpty(&ICBList) and 
                       AllRoutingProtocolsStopped())
                    {
                        __leave;
                    }
                    
                    break ;
                }

                case EVENT_RASADVTIMER:
                {
                    EnterCriticalSection(&RouterStateLock);

                    if(RouterState.IRS_State isnot RTR_STATE_RUNNING)
                    {
                        Trace0(IF,
                               "WorkerThread: Router discovery timer fired while shutting down. Ignoring");
                    
                        LeaveCriticalSection(&RouterStateLock);

                        break;
                    }

                    LeaveCriticalSection(&RouterStateLock);
 
                    Trace0(MCAST,
                           "WorkerThread: RasAdv Timer event received");
                    
                    HandleRasAdvTimer();
                    
                    break;
                }

                case EVENT_RTRDISCTIMER:
                {
                    PLIST_ENTRY      pleTimerNode;
                    PROUTER_DISC_CB  pDiscCb;

                                       
                    EnterCriticalSection(&RouterStateLock);

                    if(RouterState.IRS_State isnot RTR_STATE_RUNNING)
                    {
                        Trace0(IF,
                               "WorkerThread: Router discovery timer fired while shutting down. Ignoring");
                    
                        LeaveCriticalSection(&RouterStateLock);

                        break;
                    }

                    LeaveCriticalSection(&RouterStateLock);
 

                    ENTER_WRITER(ICB_LIST);
                    
                    Trace0(RTRDISC,
                           "WorkerThread: Router Discovery Timer event received");
                    
                    if(IsListEmpty(&g_leTimerQueueHead))
                    {
                        //
                        // Someone removed the timer item from under us 
                        // and happened to empty the timer queue. Since we 
                        // are a non-periodic timer, we will not 
                        // fire again so no problem
                        //
                        
                        Trace0(RTRDISC,
                               "WorkerThread: Router Discovery Timer went off but no timer items");
                        
                        EXIT_LOCK(ICB_LIST);
                        
                        break;
                    }
                    
                    HandleRtrDiscTimer();
                    
                    EXIT_LOCK(ICB_LIST);
                    
                    break;
                }

                case EVENT_RTRDISCSOCKET:
                {
                    EnterCriticalSection(&RouterStateLock);

                    if(RouterState.IRS_State isnot RTR_STATE_RUNNING)
                    {
                        Trace0(IF,
                               "WorkerThread: FD_READ while shutting down. Ignoring");
                    
                        LeaveCriticalSection(&RouterStateLock);

                        break;
                    }

                    LeaveCriticalSection(&RouterStateLock);
 

                    ENTER_WRITER(ICB_LIST);
                    
                    HandleSolicitations();
                    
                    EXIT_LOCK(ICB_LIST);
                    
                    break;
                }

                case EVENT_MCMISCSOCKET:
                {
                    EnterCriticalSection(&RouterStateLock);

                    if(RouterState.IRS_State isnot RTR_STATE_RUNNING)
                    {
                       Trace0(IF,
                        "WorkerThread: FD_READ while shutting down. Ignoring");

                       LeaveCriticalSection(&RouterStateLock);

                       break;
                    }

                    LeaveCriticalSection(&RouterStateLock);


                    HandleMcMiscMessages();

                    break;
                }

                case EVENT_MZAPTIMER:
                {
                    EnterCriticalSection(&RouterStateLock);

                    if(RouterState.IRS_State isnot RTR_STATE_RUNNING)
                    {
                        Trace0(IF,
                               "WorkerThread: Router discovery timer fired while shutting down. Ignoring");
                    
                        LeaveCriticalSection(&RouterStateLock);

                        break;
                    }

                    LeaveCriticalSection(&RouterStateLock);

                    HandleMzapTimer();
                    
                    break;
                }

                case EVENT_MZAPSOCKET:
                {
                    EnterCriticalSection(&RouterStateLock);

                    if(RouterState.IRS_State isnot RTR_STATE_RUNNING)
                    {
                       Trace0(IF,
                        "WorkerThread: FD_READ while shutting down. Ignoring");

                       LeaveCriticalSection(&RouterStateLock);

                       break;
                    }

                    LeaveCriticalSection(&RouterStateLock);

                    HandleMZAPMessages();

                    break;
                }

                case EVENT_MCAST_0:
                case EVENT_MCAST_1:
                case EVENT_MCAST_2:
                {
                    HandleMcastNotification(eventindex - EVENT_MCAST_0);

                    break;
                }

                case EVENT_ROUTE_CHANGE_0:
                case EVENT_ROUTE_CHANGE_1:
                case EVENT_ROUTE_CHANGE_2:
                {
                    HandleRouteChangeNotification(
                        eventindex - EVENT_ROUTE_CHANGE_0
                        );

                    break;
                }
                
                default:
                {
                    Trace1(ERR,
                           "WorkerThread: Wait failed with following error %d", 
                           GetLastError());
                    
                    break;
                }
            }
        }
    }
    __finally
    {
        Trace0(GLOBAL,
               "WorkerThread: Worker thread stopping");
        
        RouterManagerCleanup();

        RouterState.IRS_State = RTR_STATE_STOPPED;

        (RouterStopped) (PID_IP, 0);
    }

    FreeLibraryAndExitThread(g_hOwnModule,
                             NO_ERROR);

    return NO_ERROR;
}

VOID
WaitForAPIsToExitBeforeStopping(
    VOID
    )
{
    DWORD sleepcount = 0 ;

    TraceEnter("WaitForAPIsToExitBeforeStopping");
    
    //
    // Wait for refcount to trickle down to zero: this indicates that no
    // threads are in the router now
    //
    
    while(RouterState.IRS_RefCount != 0) 
    {
        if (sleepcount++ > 20)
        {
            Trace0(ERR,
                   "WaitForAPIsToExitBeforeStopping: RouterState.IRS_Refcount not decreasing");
        }
        
        Sleep (200L);
    }

    TraceLeave("WaitForAPIsToExitBeforeStopping");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\defs.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\defs.h

Abstract:

    The file contains various...
    . constants
    . definitions
    . macros
      - memory-allocation
      - logging
      - tracing

--*/

#ifndef _DEFS_H_
#define _DEFS_H_


// constants

#define INTERFACE_TABLE_BUCKETS     29 // # buckets in the interface hash table

#define NOW                         0
#define INFINITE_INTERVAL           0x7fffffff    
#define PERIODIC_INTERVAL           5   // # seconds

#define MAX_PACKET_LENGTH           512
    


// definitions

#define is                          ==
#define and                         &&
#define or                          ||

#define GLOBAL_HEAP                 g_ce.hGlobalHeap
#define TRACEID                     g_ce.dwTraceID
#define LOGLEVEL                    g_ce.dwLogLevel
#define LOGHANDLE                   g_ce.hLogHandle
#define LOCKSTORE                   g_ce.dlsDynamicLocksStore

// invoked when entering API or worker functions
#define ENTER_SAMPLE_API()          EnterSampleAPI()
#define ENTER_SAMPLE_WORKER()       EnterSampleWorker()

// invoked when leaving API or worker functions
#define LEAVE_SAMPLE_API()          LeaveSampleWorker()
#define LEAVE_SAMPLE_WORKER()       LeaveSampleWorker()

// dynamic locks
#define ACQUIRE_READ_DLOCK(pLock)                                   \
    AcquireDynamicReadwriteLock(&pLock, READ_MODE, LOCKSTORE)
#define RELEASE_READ_DLOCK(pLock)                                   \
    ReleaseDynamicReadwriteLock(pLock, READ_MODE, LOCKSTORE)
#define ACQUIRE_WRITE_DLOCK(pLock)                                  \
    AcquireDynamicReadwriteLock(&pLock, WRITE_MODE, LOCKSTORE)
#define RELEASE_WRITE_DLOCK(pLock)                                  \
    ReleaseDynamicReadwriteLock(pLock, WRITE_MODE, LOCKSTORE)



// macros

#define SECTOMILLISEC(x)            ((x) * 1000)
#define MAX(a, b)                   (((a) >= (b)) ? (a) : (b))
#define MIN(a, b)                   (((a) <= (b)) ? (a) : (b))



// IP ADDRESS

// type
typedef DWORD   IPADDRESS, *PIPADDRESS;


// definitions
#define IP_LOWEST                   0x00000000
#define IP_HIGHEST                  0xffffffff
#define STAR                        0x00000000


// macros

// compare a and b
#define IP_COMPARE(a, b)            (((a) < (b)) ? -1       \
                                                 : (((a) is (b)) ? 0 : 1)) 

// assign b to a 
#define IP_ASSIGN(pip, ip)          *(pip) = (ip)

// verify whether an ip address is valid
#define IP_VALID(ip)                (IP_COMPARE(ip, IP_HIGHEST) is -1)

// returns the string representation of an ip address in a static buffer
#define INET_NTOA(x)                (inet_ntoa(*(struct in_addr*)&(x)))
    


// TIMER

// macros

#define CREATE_TIMER(phHandle, pfnCallback, pvContext, ulWhen, pdwErr)      \
{                                                                           \
    if (CreateTimerQueueTimer((phHandle),                                   \
                              g_ce.hTimerQueue,                             \
                              (pfnCallback),                                \
                              (pvContext),                                  \
                              SECTOMILLISEC(ulWhen),                        \
                              INFINITE_INTERVAL,                            \
                              0))                                           \
    {                                                                       \
        *(pdwErr) = NO_ERROR;                                               \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        *(pdwErr) = GetLastError();                                         \
        TRACE1(ANY, "Error %u creating timer", *(pdwErr));                  \
        LOGERR0(CREATE_TIMER_FAILED, *(pdwErr));                            \
    }                                                                       \
}

// it is safe to hold locks while making this call since
// it is non blocking (NULL for hCompletionEvent).
#define DELETE_TIMER(hHandle, pdwErr)                                       \
{                                                                           \
    if (DeleteTimerQueueTimer(g_ce.hTimerQueue,                             \
                              (hHandle),                                    \
                              NULL))                                        \
    {                                                                       \
        *(pdwErr) = NO_ERROR;                                               \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        *(pdwErr) = GetLastError();                                         \
        TRACE1(ANY, "Error %u deleting timer, continuing...", *(pdwErr));   \
    }                                                                       \
}

#define RESTART_TIMER(hHandle, ulWhen, pdwErr)                              \
{                                                                           \
    if (ChangeTimerQueueTimer(g_ce.hTimerQueue,                             \
                              (hHandle),                                    \
                              SECTOMILLISEC(ulWhen),                        \
                              INFINITE_INTERVAL))                           \
    {                                                                       \
        *(pdwErr) = NO_ERROR;                                               \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        *(pdwErr) = GetLastError();                                         \
        TRACE1(ANY, "Error %u restarting timer, continuing...", *(pdwErr)); \
    }                                                                       \
}



// MEMORY ALLOCATION

// macros
#define MALLOC(ppPointer, ulSize, pdwErr)                                   \
{                                                                           \
    if (*(ppPointer) = HeapAlloc(GLOBAL_HEAP, HEAP_ZERO_MEMORY, (ulSize)))  \
    {                                                                       \
        *(pdwErr) = NO_ERROR;                                               \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        *(pdwErr) = ERROR_NOT_ENOUGH_MEMORY;                                \
        TRACE1(ANY, "Error allocating %u bytes", (ulSize));                 \
        LOGERR0(HEAP_ALLOC_FAILED, *(pdwErr));                              \
    }                                                                       \
}
#define REALLOC(ptr, size)          HeapReAlloc(GLOBAL_HEAP, 0, ptr, size)
#define FREE(ptr)                                           \
{                                                           \
     HeapFree(GLOBAL_HEAP, 0, (ptr));                       \
     (ptr) = NULL;                                          \
}
         
#define FREE_NOT_NULL(ptr)                                  \
{                                                           \
     if (!(ptr)) HeapFree(GLOBAL_HEAP, 0, (ptr));           \
     (ptr) = NULL;                                          \
}



// TRACING

// definitions...
#define IPSAMPLE_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define IPSAMPLE_TRACE_ENTER           ((DWORD)0x00010000 | TRACE_USE_MASK)
#define IPSAMPLE_TRACE_LEAVE           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IPSAMPLE_TRACE_DEBUG           ((DWORD)0x00040000 | TRACE_USE_MASK)
#define IPSAMPLE_TRACE_CONFIGURATION   ((DWORD)0x00100000 | TRACE_USE_MASK)
#define IPSAMPLE_TRACE_NETWORK         ((DWORD)0x00200000 | TRACE_USE_MASK)
#define IPSAMPLE_TRACE_PACKET          ((DWORD)0x00400000 | TRACE_USE_MASK)
#define IPSAMPLE_TRACE_TIMER           ((DWORD)0x00800000 | TRACE_USE_MASK)
#define IPSAMPLE_TRACE_MIB             ((DWORD)0x01000000 | TRACE_USE_MASK)


// macros...
#define TRACE0(l,a)                                                     \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfEx(TRACEID, IPSAMPLE_TRACE_ ## l, a)
#define TRACE1(l,a,b)                                                   \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfEx(TRACEID, IPSAMPLE_TRACE_ ## l, a, b)
#define TRACE2(l,a,b,c)                                                 \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfEx(TRACEID, IPSAMPLE_TRACE_ ## l, a, b, c)
#define TRACE3(l,a,b,c,d)                                               \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfEx(TRACEID, IPSAMPLE_TRACE_ ## l, a, b, c, d)
#define TRACE4(l,a,b,c,d,e)                                             \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfEx(TRACEID, IPSAMPLE_TRACE_ ## l, a, b, c, d, e)
#define TRACE5(l,a,b,c,d,e,f)                                           \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfEx(TRACEID, IPSAMPLE_TRACE_ ## l, a, b, c, d, e, f)

        

// EVENT LOGGING

// definitions...
#define LOGERR              RouterLogError
#define LOGWARN             RouterLogWarning
#define LOGINFO             RouterLogInformation
#define LOGWARNDATA         RouterLogWarningData


// macros...

//      ERRORS
#define LOGERR0(msg,err)                                                \
        if (LOGLEVEL >= IPSAMPLE_LOGGING_ERROR)                         \
            LOGERR(LOGHANDLE,IPSAMPLELOG_ ## msg,0,NULL,(err))
#define LOGERR1(msg,a,err)                                              \
        if (LOGLEVEL >= IPSAMPLE_LOGGING_ERROR)                         \
            LOGERR(LOGHANDLE,IPSAMPLELOG_ ## msg,1,&(a),(err))
#define LOGERR2(msg,a,b,err)                                            \
        if (LOGLEVEL >= IPSAMPLE_LOGGING_ERROR) {                       \
            LPSTR _asz[2] = { (a), (b) };                               \
            LOGERR(LOGHANDLE,IPSAMPLELOG_ ## msg,2,_asz,(err));         \
        }
#define LOGERR3(msg,a,b,c,err)                                          \
        if (LOGLEVEL >= IPSAMPLE_LOGGING_ERROR) {                       \
            LPSTR _asz[3] = { (a), (b), (c) };                          \
            LOGERR(LOGHANDLE,IPSAMPLELOG_ ## msg,3,_asz,(err));         \
        }
#define LOGERR4(msg,a,b,c,d,err)                                        \
        if (LOGLEVEL >= IPSAMPLE_LOGGING_ERROR) {                       \
            LPSTR _asz[4] = { (a), (b), (c), (d) };                     \
            LOGERR(LOGHANDLE,IPSAMPLELOG_ ## msg,4,_asz,(err));         \
        }

//      WARNINGS
#define LOGWARN0(msg,err)                                               \
        if (LOGLEVEL >= IPSAMPLE_LOGGING_WARN)                          \
            LOGWARN(LOGHANDLE,IPSAMPLELOG_ ## msg,0,NULL,(err))
#define LOGWARN1(msg,a,err)                                             \
        if (LOGLEVEL >= IPSAMPLE_LOGGING_WARN)                          \
            LOGWARN(LOGHANDLE,IPSAMPLELOG_ ## msg,1,&(a),(err))
#define LOGWARN2(msg,a,b,err)                                           \
        if (LOGLEVEL >= IPSAMPLE_LOGGING_WARN) {                        \
            LPSTR _asz[2] = { (a), (b) };                               \
            LOGWARN(LOGHANDLE,IPSAMPLELOG_ ## msg,2,_asz,(err));        \
        }
#define LOGWARN3(msg,a,b,c,err)                                         \
        if (LOGLEVEL >= IPSAMPLE_LOGGING_WARN) {                        \
            LPSTR _asz[3] = { (a), (b), (c) };                          \
            LOGWARN(LOGHANDLE,IPSAMPLELOG_ ## msg,3,_asz,(err));        \
        }
#define LOGWARN4(msg,a,b,c,d,err)                                       \
        if (LOGLEVEL >= IPSAMPLE_LOGGING_WARN) {                        \
            LPSTR _asz[4] = { (a), (b), (c), (d) };                     \
            LOGWARN(LOGHANDLE,IPSAMPLELOG_ ## msg,4,_asz,(err));        \
        }

#define LOGWARNDATA2(msg,a,b,dw,buf)                                    \
        if (LOGLEVEL >= IPSAMPLE_LOGGING_WARN) {                        \
            LPSTR _asz[2] = { (a), (b) };                               \
            LOGWARNDATA(LOGHANDLE,IPSAMPLELOG_ ## msg,2,_asz,(dw),(buf)); \
        }

//      INFORMATION
#define LOGINFO0(msg,err)                                               \
        if (LOGLEVEL >= IPSAMPLE_LOGGING_INFO)                          \
            LOGINFO(LOGHANDLE,IPSAMPLELOG_ ## msg,0,NULL,(err))
#define LOGINFO1(msg,a,err)                                             \
        if (LOGLEVEL >= IPSAMPLE_LOGGING_INFO)                          \
            LOGINFO(LOGHANDLE,IPSAMPLELOG_ ## msg,1,&(a),(err))
#define LOGINFO2(msg,a,b,err)                                           \
        if (LOGLEVEL >= IPSAMPLE_LOGGING_INFO) {                        \
            LPSTR _asz[2] = { (a), (b) };                               \
            LOGINFO(LOGHANDLE,IPSAMPLELOG_ ## msg,2,_asz,(err));        \
        }
#define LOGINFO3(msg,a,b,c,err)                                         \
        if (LOGLEVEL >= IPSAMPLE_LOGGING_INFO) {                        \
            LPSTR _asz[3] = { (a), (b), (c) };                          \
            LOGINFO(LOGHANDLE,IPSAMPLELOG_ ## msg,3,_asz,(err));        \
        }
#define LOGINFO4(msg,a,b,c,d,err)                                       \
        if (LOGLEVEL >= IPSAMPLE_LOGGING_INFO) {                        \
            LPSTR _asz[4] = { (a), (b), (c), (d) };                     \
            LOGINFO(LOGHANDLE,IPSAMPLELOG_ ## msg,4,_asz,(err));        \
        }

#endif // _DEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\stack.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:


Abstract:

Revision History:

    Amritansh Raghav

--*/
#include "allinc.h"
//
// Definitions
//

//*****************************************************************************
//
// Name:        GetIpAddrTableFromStack
//
// Description:
//
// Parameters:  IPAddrEntry *lpipaeTable, LPDWORD lpdwNumEntries, BOOL bOrder
//
// Returns:     DWORD: NO_ERROR or some error code.
//
// History:
//
//*****************************************************************************

DWORD 
GetIpAddrTableFromStack(IPAddrEntry *lpipaeTable, LPDWORD lpdwNumEntries, 
                        BOOL bOrder, BOOL bMap)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    DWORD                              i,j;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                       *ID;
    BYTE                             *Context;
    
    TraceEnter("GetIpAddrTableFromStack");
    
    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    
    dwOutBufLen = (*lpdwNumEntries) * sizeof( IPAddrEntry );
    
    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );
    
    dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (LPVOID)lpipaeTable,
                                     &dwOutBufLen );
    
    if (dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetIpAddrTableFromStack: NtStatus %x querying IpAddrTable from stack",
               dwResult);

        TraceLeave("GetIpAddrTableFromStack");
    
        return dwResult;
    }
    
    *lpdwNumEntries =(dwOutBufLen / sizeof(IPAddrEntry));
    
    //
    // Now sort the address table.  Key is IP address.
    //
    
    if(*lpdwNumEntries > 0)
    { 
        if(bMap)
        {
            for (i = 0; i < (*lpdwNumEntries); i++ )
            {
                lpipaeTable[i].iae_index = GetInterfaceFromAdapter(lpipaeTable[i].iae_index);
            }
        }
        
        if(bOrder)
        {
            for (i = 0; i < (*lpdwNumEntries) - 1; i++ )
            {
                IPAddrEntry tempEntry;
                DWORD min;
                LONG  lCompare; 
                min = i;
                
                for (j = i + 1; j < *lpdwNumEntries; j++ )
                {
                    if(InetCmp(lpipaeTable[min].iae_addr,lpipaeTable[j].iae_addr,lCompare) > 0)
                    {
                        min = j;
                    }
                }
                if(min isnot i)
                {
                    tempEntry = lpipaeTable[min];
                    lpipaeTable[min] = lpipaeTable[i];
                    lpipaeTable[i] = tempEntry;
                }
            }
        }
    }

    TraceLeave("GetIpAddrTableFromStack");
    
    return NO_ERROR;
}


//*****************************************************************************
//
// Name:        GetTcpConnTableFromStack
//
// Description: Reads and sorts the route table from the stack.
//
// Parameters:  TCPConnTableEntry *lptcteTable, LPDWORD lpdwNumEntries, BOOL bOrder
//
// Returns:     DWORD: NO_ERROR or some error code.
//
// History:
//
//*****************************************************************************

DWORD 
GetTcpTableFromStack(TCPConnTableEntry *lptcteTable, LPDWORD lpdwNumEntries, BOOL bOrder)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    DWORD                              i,j;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                       *ID;
    BYTE                              *Context;
    TCPStats                           TcpInfo;
    DWORD                              NumConn;
    DWORD                              *IndTab;
    LONG                               CmpResult;
    
    
    TraceEnter("GetTcpTableFromStack");
    
    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = (*lpdwNumEntries) * sizeof(TCPConnTableEntry);
    
    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = CO_TL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = TCP_MIB_TABLE_ID;
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );
    
    dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (LPVOID)lptcteTable,
                                     &dwOutBufLen);
    
    if (dwResult isnot NO_ERROR )
    {
        Trace1(ERR,
               "GetTcpTableFromStack: NtStatus %x querying TcpConnTable from stack",
               dwResult);

        TraceLeave("GetTcpTableFromStack");
    
        return dwResult;
    }
    
    *lpdwNumEntries = (dwOutBufLen/sizeof(TCPConnTableEntry));

    //
    // Now sort the TCP connection table.  Keys are: local address, local
    // port, remote address, and remote port.
    //

    if((*lpdwNumEntries > 0) and bOrder)
    {
        for ( i = 0; i < (*lpdwNumEntries) - 1 ; i++ )
        {
            TCPConnTableEntry tempEntry;
            DWORD min;
            min = i;
            
            for ( j = i+1; j < *lpdwNumEntries ; j++ )
            {
                if(TcpCmp(lptcteTable[min].tct_localaddr,lptcteTable[min].tct_localport,
                          lptcteTable[min].tct_remoteaddr,lptcteTable[min].tct_remoteport,
                          lptcteTable[j].tct_localaddr,lptcteTable[j].tct_localport,
                          lptcteTable[j].tct_remoteaddr,lptcteTable[j].tct_remoteport) > 0)
                {
                    min = j;
                }
            }
            if(min isnot i)
            {
                tempEntry      = lptcteTable[min];
                lptcteTable[min] = lptcteTable[i];
                lptcteTable[i]   = tempEntry;
            }
        }
    }

    TraceLeave("GetTcpTableFromStack");
    
    return NO_ERROR;
}

DWORD 
SetTcpRowToStack(TCPConnTableEntry *tcpRow)
{
    TCP_REQUEST_SET_INFORMATION_EX    *lptrsiInBuf;
    TDIObjectID                       *ID;
    UCHAR                             *Context;
    TCPConnTableEntry                 *copyInfo;
    DWORD                             dwInBufLen,dwOutBufLen,dwResult;

    TraceEnter("SetTcpRowToStack");

    dwInBufLen = sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(TCPConnTableEntry) - 1;
    
    lptrsiInBuf = HeapAlloc(GetProcessHeap(),0,dwInBufLen);
    
    if(lptrsiInBuf is NULL)
    {
        dwResult = GetLastError();
        
        Trace1(ERR,
               "SetTcpRowToStack: Error %d allocating memory",
               dwResult);

        TraceLeave("SetTcpRowToStack");

        return dwResult;
    }
    
    ID = &lptrsiInBuf->ID;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_entity.tei_entity = CO_TL_ENTITY;
    ID->toi_id = TCP_MIB_TABLE_ID;
    ID->toi_entity.tei_instance = 0;
   
    lptrsiInBuf->BufferSize = sizeof(TCPConnTableEntry);
 
    copyInfo = (TCPConnTableEntry*)lptrsiInBuf->Buffer;
    *copyInfo = *tcpRow;
    
    dwResult = TCPSetInformationEx(g_hTcpDevice,
                                   (LPVOID)lptrsiInBuf,
                                   &dwInBufLen,
                                   NULL,
                                   &dwOutBufLen);
    
    HeapFree(GetProcessHeap(),0,lptrsiInBuf);

    TraceLeave("SetTcpRowToStack");

    return dwResult;
}


//*****************************************************************************
//
// Name:        GetUdpConnTableFromStack
//
// Description: Reads and sorts the route table from the stack.
//
// Parameters:  UDPEntry *lpueTable, LPDWORD lpdwNumEntries, BOOL bOrder
//
// Returns:     DWORD: NO_ERROR or some error code.
//
// History:
//
//*****************************************************************************

DWORD 
GetUdpTableFromStack(UDPEntry *lpueTable, LPDWORD lpdwNumEntries, BOOL bOrder)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    DWORD                              i,j;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    BYTE                               *Context;

    TraceEnter("GetUdpTableFromStack");

    //
    // Determine number of connections via the UDPStats structure
    //
    dwInBufLen = sizeof( TCP_REQUEST_QUERY_INFORMATION_EX );
    dwOutBufLen = (*lpdwNumEntries) * sizeof(UDPEntry);
    
    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = CL_TL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = UDP_MIB_TABLE_ID;
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );
    
    dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (LPVOID)lpueTable,
                                     &dwOutBufLen );
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetUdpTableFromStack: NtStatus %x querying UdpTable from stack",
               dwResult);

        TraceLeave("GetUdpTableFromStack");
        
        return dwResult;
    }
    
    *lpdwNumEntries =(dwOutBufLen / sizeof(UDPEntry));

    //
    // Now sort the UDP connection table.  Keys are: local address, and local
    // port.
    //

    if((*lpdwNumEntries > 0) and bOrder)
    {
        for ( i = 0; i < (*lpdwNumEntries) - 1; i++ )
        {
            UDPEntry tempEntry;
            DWORD    min;
            min = i;
            
            for ( j = i + 1; j < (*lpdwNumEntries) ; j++ )
            {
                if(UdpCmp(lpueTable[min].ue_localaddr,
                          lpueTable[min].ue_localport,
                          lpueTable[j].ue_localaddr,
                          lpueTable[j].ue_localport) > 0)
                {
                    min = j;
                }
            }
            if(min isnot i)
            {
                tempEntry = lpueTable[min];
                lpueTable[min] = lpueTable[i];
                lpueTable[i] = tempEntry;
            }
        }
    }

    TraceLeave("GetUdpTableFromStack");
        
    return NO_ERROR;
}



//*****************************************************************************
//
// Name:        GetIpStatsFromStack
//
// Description: Read the IPSNMPInfo structure from the stack.
//
// Parameters:  IPSNMPInfo *IPSnmpInfo
//
// Returns:     DWORD: NO_ERROR or some error code.
//
// History:
//
//*****************************************************************************

DWORD 
GetIpStatsFromStack(IPSNMPInfo *IPSnmpInfo)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                       *ID;
    BYTE                             *Context;

    TraceEnter("GetIpStatsFromStack");
    
    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = sizeof(IPSNMPInfo);
    
    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = IP_MIB_STATS_ID;
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory(Context, CONTEXT_SIZE);
    
    dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     IPSnmpInfo,
                                     &dwOutBufLen);
    
    if (dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetIpStatsFromStack: NtStatus %x querying IpStats from stack",
               dwResult);

        TraceLeave("GetIpStatsFromStack");

        return dwResult;
    }

    TraceLeave("GetIpStatsFromStack");

    return NO_ERROR;
}

DWORD 
SetIpInfoToStack(IPSNMPInfo *ipsiInfo)
{
    TCP_REQUEST_SET_INFORMATION_EX    *lptrsiInBuf;
    TDIObjectID                       *ID;
    UCHAR                             *Context;
    IPSNMPInfo                        *copyInfo;
    DWORD                             dwInBufLen,dwOutBufLen,dwResult;

    TraceEnter("SetIpInfoToStack");
    
    dwInBufLen = sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(IPSNMPInfo) - 1;
    
    lptrsiInBuf = HeapAlloc(GetProcessHeap(),0,dwInBufLen);
    
    if(lptrsiInBuf is NULL)
    {
        dwResult = GetLastError();
        
        Trace1(ERR,
               "SetIpInfoToStack: Error %d allocating memory",
               dwResult);

        TraceLeave("SetIpInfoToStack");

        return dwResult;
    }
  
    ID = &lptrsiInBuf->ID;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_entity.tei_entity = CL_NL_ENTITY;
    ID->toi_id = IP_MIB_STATS_ID;
    ID->toi_entity.tei_instance = 0;
    
    copyInfo = (IPSNMPInfo*)lptrsiInBuf->Buffer;
    *copyInfo = *ipsiInfo;
    
    dwResult = TCPSetInformationEx(g_hTcpDevice,
                                   (LPVOID)lptrsiInBuf,
                                   &dwInBufLen,
                                   NULL,
                                   &dwOutBufLen);

    TraceLeave("SetIpInfoToStack");

    return dwResult;
}

//*****************************************************************************
//
// Name:        GetIcmpStatsFromStack
//
// Description: Read the ICMPSNMPInfo structure from the stack.
//
// Parameters:  ICMPSNMPInfo *ICMPSnmpInfo 
//
// Returns:     DWORD: NO_ERROR or some error code.
//
// History:
//
//*****************************************************************************

DWORD 
GetIcmpStatsFromStack( ICMPSNMPInfo *ICMPSnmpInfo )
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    BYTE                               *Context;

    TraceEnter("GetIcmpStatsFromStack");
    
    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = sizeof(ICMPSNMPInfo);
    
    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = ER_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = ICMP_MIB_STATS_ID;
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory(Context,CONTEXT_SIZE);
    
    dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     ICMPSnmpInfo,
                                     &dwOutBufLen );

    if (dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetIcmpStatsFromStack: NtStatus %x querying IcmpStats from stack",
               dwResult);

        TraceLeave("GetIcmpStatsFromStack");
        
        return dwResult;
    }

    TraceLeave("GetIcmpStatsFromStack");
        
    return NO_ERROR;
}


//*****************************************************************************
//
// Name:        GetUdpStatsFromStack
//
// Description: Read the UDPStats structure from the stack.
//
// Parameters:  UDPStats *UdpInfo
//
// Returns:     DWORD: NO_ERROR or some error code.
//
// History:
//
//*****************************************************************************

DWORD 
GetUdpStatsFromStack(UDPStats *UdpInfo)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    BYTE                              *Context;

    TraceEnter("GetUdpStatsFromStack");
    
    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = sizeof(UDPStats);
    
    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = CL_TL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = UDP_MIB_STAT_ID;
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );
    
    dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     UdpInfo,
                                     &dwOutBufLen );

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetUdpStatsFromStack: NtStatus %x querying UdpStats from stack",
               dwResult);

        TraceLeave("GetUdpStatsFromStack");
    
        return dwResult;
    }

    TraceLeave("GetUdpStatsFromStack");
    
    return NO_ERROR;
}


//*****************************************************************************
//
// Name:        GetTCPStats
//
// Description: Read the TCPStats structure from the stack.
//
// Parameters:
//
// Returns:     DWORD: NO_ERROR or some error code.
//
// History:
//
//*****************************************************************************

DWORD 
GetTcpStatsFromStack(TCPStats *TcpInfo)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    BYTE                               *Context;

    TraceEnter("GetTcpStatsFromStack");
    
    dwInBufLen = sizeof( TCP_REQUEST_QUERY_INFORMATION_EX );
    dwOutBufLen = sizeof( TCPStats );
    
    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = CO_TL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = TCP_MIB_STAT_ID;
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory(Context,CONTEXT_SIZE);
    
    dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     TcpInfo,
                                     &dwOutBufLen );
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetTcpStatsFromStack: NtStatus %x querying TcpStats from stack",
               dwResult);

        TraceLeave("GetTcpStatsFromStack");
    
        return dwResult;
    }

    TraceLeave("GetTcpStatsFromStack");
    
    return NO_ERROR;
}

//*****************************************************************************
//
// Name:        GetRouteTableFromStack
//
// Description: Reads all the routes from the stack. This is needed because the ICMP redirect
//                routes are only kept in the stack and cant be queried from RTM
//
// Parameters:
//
// Returns:     DWORD: NO_ERROR or some error code.
//
// History:
//
//*****************************************************************************



DWORD 
GetIpRouteTableFromStack(IPRouteEntry *lpireTable,LPDWORD lpdwNumEntries, BOOL bOrder)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    UCHAR                              *Context;
    TDIObjectID                        *ID;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    IPSNMPInfo                         ipsiInfo;

    TraceEnter("GetIpRouteTableFromStack");
    
    dwInBufLen = sizeof( TCP_REQUEST_QUERY_INFORMATION_EX );
    dwOutBufLen = *lpdwNumEntries * sizeof(IPRouteEntry);
    
    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = IP_MIB_RTTABLE_ENTRY_ID;
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );
    
    dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (LPVOID)lpireTable,
                                     &dwOutBufLen );
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetIpRouteTableFromStack: NtStatus %x querying IpRouteTable from stack",
               dwResult);
        
        TraceLeave("GetIpRouteTableFromStack");
    
        return dwResult;
    }
    
    *lpdwNumEntries = (dwOutBufLen / sizeof( IPRouteEntry ));
    
    if((*lpdwNumEntries > 0) and bOrder)
    {
        DWORD i,j;
        for (i = 0; i < (*lpdwNumEntries) - 1; i++ )
        {
            IPRouteEntry tempEntry;
            DWORD min;
            LONG lCompare;
            min = i;
            
            for (j = i + 1; j < *lpdwNumEntries; j++ )
            {
                if(InetCmp(lpireTable[min].ire_dest,lpireTable[j].ire_dest,lCompare) > 0)
                {
                    min = j;
                }
            }
            if(min isnot i)
            {
                tempEntry = lpireTable[min];
                lpireTable[min] = lpireTable[i];
                lpireTable[i] = tempEntry;
            }
        }
    }

    TraceLeave("GetIpRouteTableFromStack");
    
    return NO_ERROR;
}

//*****************************************************************************
//
// Name:        GetARPEntityTable
//
// Description: Builds a list of AT entities. that support ARP. Keeps it in the global
//                 entity table
//
// Parameters:
//
// Returns:     DWORD: NO_ERROR or some error code.
//
// History:
//
//*****************************************************************************

DWORD 
GetArpEntTableFromStack(DWORD **lpArpEntTable,
                        LPDWORD lpdwSize, 
                        LPDWORD lpdwValid,
                        HANDLE hHeap)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    DWORD                              dwATType;
    UCHAR                              *Context;
    TDIObjectID                        *ID;
    LPVOID                             lpOutBuf;
    TDIEntityID                        *lpEntTable;
    DWORD                              dwNumEntities;
    DWORD                              i,dwCount ;

    TraceEnter("GetArpEntTableFromStack");
    
    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = MAX_TDI_ENTITIES * sizeof(TDIEntityID);
    
    lpOutBuf = HeapAlloc(GetProcessHeap(),0,dwOutBufLen);

    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = GENERIC_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_GENERIC;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = ENTITY_LIST_ID;
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory(Context, CONTEXT_SIZE);
    
    if(lpOutBuf is NULL)
    {
        dwResult = GetLastError();
        
        Trace1(ERR,"GetArpEntTableFromStack: Error %d allocating memory",
               dwResult);
        
        TraceLeave("GetArpEntTableFromStack");
    
        return dwResult;
    }
    
    dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     lpOutBuf,
                                     &dwOutBufLen);
    
    if ( dwResult != NO_ERROR )
    {
        Trace1(ERR,
               "GetArpEntTableFromStack: NtStatus %x querying TDI Entities from stack",
               dwResult);
        
        HeapFree(GetProcessHeap(),0,lpOutBuf);
        
        TraceLeave("GetArpEntTableFromStack");
    
        return dwResult;
    }

    //
    // Now we have all the entities
    //
    
    dwNumEntities = dwOutBufLen / sizeof( TDIEntityID );
    
    dwCount = 0;
    lpEntTable = (TDIEntityID*)lpOutBuf;
    
    for(i = 0; i < dwNumEntities; i++)
    {
        //
        // See which ones are AT
        //
        
        if(lpEntTable[i].tei_entity is AT_ENTITY)
        {
            //
            // Query the entity to see if it supports ARP
            //
            
            ID->toi_entity.tei_entity = AT_ENTITY;
            ID->toi_class = INFO_CLASS_GENERIC;
            ID->toi_type = INFO_TYPE_PROVIDER;
            ID->toi_id = ENTITY_TYPE_ID;
            ID->toi_entity.tei_instance = lpEntTable[i].tei_instance;
            dwOutBufLen = sizeof(dwATType);
            
            ZeroMemory(Context,CONTEXT_SIZE);

            dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                             &trqiInBuf,
                                             &dwInBufLen,
                                             (LPVOID)&dwATType,
                                             &dwOutBufLen );
            
            if(dwResult is STATUS_INVALID_DEVICE_REQUEST)
            {
                continue;
            }
            if(dwResult isnot NO_ERROR)
            {
                HeapFree(GetProcessHeap(),0,lpOutBuf);
                return dwResult;
            }
            
            if(dwATType is AT_ARP)
            {
                
                if(dwCount is *lpdwSize)
                {
                    //
                    // Realloc more memory
                    //

                    *lpArpEntTable = (LPDWORD)HeapReAlloc(hHeap,
                                                          0,
                                                          (LPVOID)*lpArpEntTable,
                                                          ((*lpdwSize)<<1)*sizeof(DWORD));
                    if(*lpArpEntTable is NULL)
                    {
                        dwResult = GetLastError();
                        
                        Trace1(ERR,
                               "GetArpEntTableFromStack: Error %d reallocating memory",
                               dwResult);
                        
                        TraceLeave("GetArpEntTableFromStack");
    
                        return dwResult;
                    }
                    
                    *lpdwSize = (*lpdwSize)<<1;
                }
                
                (*lpArpEntTable)[dwCount++] = lpEntTable[i].tei_instance;
            }
        }
    }
    
    *lpdwValid = dwCount;
    
    HeapFree(GetProcessHeap(),0,lpOutBuf);
    
    TraceLeave("GetArpEntTableFromStack");
    
    return NO_ERROR;
}

// Called only if you are a IPNET reader

DWORD 
UpdateAdapterToATInstanceMap()
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              i;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                       *ID;
    UCHAR                             *Context;
    DWORD                              dwSize;
    AddrXlatInfo                       AXI;

    TraceEnter("UpdateAdapterToATInstanceMap");
    
    dwInBufLen = sizeof( TCP_REQUEST_QUERY_INFORMATION_EX );
    
    Context = &(trqiInBuf.Context[0]);
    ID = &(trqiInBuf.ID);

    //
    // Maybe we should first clear out all the mappings
    //
    
    for (i = 0; i < g_IpInfo.dwValidArpEntEntries; i++ )
    {
        
        ID->toi_entity.tei_entity = AT_ENTITY;
        ID->toi_type = INFO_TYPE_PROVIDER;
        ID->toi_class = INFO_CLASS_PROTOCOL;
        ID->toi_id = AT_MIB_ADDRXLAT_INFO_ID;
        ID->toi_entity.tei_instance = g_IpInfo.arpEntTable[i];
        
        dwSize = sizeof(AXI);
        ZeroMemory(Context, CONTEXT_SIZE);
        
        dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                         &trqiInBuf,
                                         &dwInBufLen,
                                         &AXI,
                                         &dwSize );
        
        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "UpdateAdapterToATInstanceMap: NtStatus %x querying ArpInfo from stack",
                   dwResult);

            TraceLeave("UpdateAdapterToATInstanceMap");
    
            return dwResult;
        }
        
        StoreAdapterToATInstanceMap(AXI.axi_index,g_IpInfo.arpEntTable[i]);
    }

    TraceLeave("UpdateAdapterToATInstanceMap");
    
    return NO_ERROR;
}

DWORD 
GetIpNetTableFromStackEx(LPDWORD arpEntTable,
                         DWORD dwValidArpEntEntries,
                         IPNetToMediaEntry **lpNetTable,
                         LPDWORD lpdwTotalEntries,
                         LPDWORD lpdwValidEntries,
                         BOOL bOrder,
                         HANDLE hHeap)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    DWORD                              i,j;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                       *ID;
    UCHAR                             *Context;
    DWORD                              dwNetEntryCount,dwNumAdded,dwValidNetEntries;
    DWORD                              dwSize,dwNeed;
    AddrXlatInfo                       AXI;
    IPNetToMediaEntry                  *lpOutBuf,tempEntry;
    
    dwInBufLen = sizeof( TCP_REQUEST_QUERY_INFORMATION_EX );
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );
    
    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = AT_ENTITY;
    ID->toi_type = INFO_TYPE_PROVIDER;
    
    dwNetEntryCount = 0;
    
    for (i = 0; i < dwValidArpEntEntries; i++ )
    {
        // First add up the AXI counts
        ID->toi_class = INFO_CLASS_PROTOCOL;
        ID->toi_id = AT_MIB_ADDRXLAT_INFO_ID;
        ID->toi_entity.tei_instance = arpEntTable[i];
        dwSize = sizeof(AXI);
        ZeroMemory(Context, CONTEXT_SIZE);
        
        dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                         &trqiInBuf,
                                         &dwInBufLen,
                                         &AXI,
                                         &dwSize );
        
        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "GetIpNetTableFromStackEx: NtStatus %x querying information from stack",
                   dwResult);

            TraceLeave("GetIpNetTableFromStackEx");
            
            return dwResult;
        }

        //
        // At this point map the index to the instance - the index is the adapter 
        // index though the instance is not the same as IFInstance
        //
        
        StoreAdapterToATInstanceMap(AXI.axi_index,arpEntTable[i]);

        dwNetEntryCount += AXI.axi_count;
    }

    //
    // This is generally a memory hog
    //
    
    dwNeed = dwNetEntryCount + (dwValidArpEntEntries) * SPILLOVER;
    
    if(dwNeed > *lpdwTotalEntries) 
    {
        if(*lpdwTotalEntries)
        {
            HeapFree(hHeap,0,*lpNetTable);
        }
        
        dwNeed += MAX_DIFF;

        //
        // Serialize the heap ???
        //
        
        *lpNetTable = (IPNetToMediaEntry*)HeapAlloc(hHeap,0,
                                                    dwNeed*sizeof(IPNetToMediaEntry));
        if(*lpNetTable is NULL)
        {
            dwResult = GetLastError();
            
            Trace1(ERR,
                   "GetIpNetTableFromStackEx: Error %d allocating memory for IpNetTable",
                   dwResult);

            
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        *lpdwTotalEntries = dwNeed;
    }
    else
    {
        dwNeed = *lpdwTotalEntries;
    }
    
    
    lpOutBuf = *lpNetTable;
    dwOutBufLen = dwNeed * sizeof(IPNetToMediaEntry);
    
    dwValidNetEntries = 0;
  
    for(i = 0; i < dwValidArpEntEntries; i++ )
    {
        ID->toi_class = INFO_CLASS_PROTOCOL;
        ID->toi_id = AT_MIB_ADDRXLAT_ENTRY_ID;
        ID->toi_entity.tei_instance = arpEntTable[i];
        ZeroMemory( Context, CONTEXT_SIZE );
        
        dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                         &trqiInBuf,
                                         &dwInBufLen,
                                         (LPVOID)lpOutBuf,
                                         &dwOutBufLen);
        
        if ( dwResult isnot NO_ERROR )
        {
            Trace1(ERR,
                   "GetIpNetTableFromStackEx: Error %x getting AT Entry",
                   dwResult);
 
            continue;
        }
        
        dwNumAdded = dwOutBufLen/(sizeof(IPNetToMediaEntry));
        lpOutBuf += dwNumAdded;
        dwValidNetEntries += dwNumAdded;
        dwOutBufLen = (dwNeed - dwValidNetEntries) * sizeof(IPNetToMediaEntry);
    }
   
    dwResult = NO_ERROR;
 
    *lpdwValidEntries = dwValidNetEntries;

    //
    // Now sort the net table
    //
    
    if(dwValidNetEntries > 0)
    {
        for(i = 0; i < dwValidNetEntries; i++)
        {
            (*lpNetTable)[i].inme_index = GetInterfaceFromAdapter((*lpNetTable)[i].inme_index);
        }
        
        if(bOrder)
        {
            for(i = 0; i < dwValidNetEntries - 1; i++)
            {
                DWORD min = i;
                
                for(j =  i + 1; j < dwValidNetEntries; j++)
                {
                    if(IpNetCmp((*lpNetTable)[min].inme_index,(*lpNetTable)[min].inme_addr,
                                (*lpNetTable)[j].inme_index,(*lpNetTable)[j].inme_addr) > 0)
                    {
                        min = j;
                    }
                }
                if(min isnot i)
                {
                    tempEntry = (*lpNetTable)[min];
                    (*lpNetTable)[min] = (*lpNetTable)[i];
                    (*lpNetTable)[i] = tempEntry;
                }
            }
        }
    }

    TraceLeave("GetIpNetTableFromStackEx");
    
    return dwResult;
}

DWORD 
SetIpNetEntryToStack(IPNetToMediaEntry *inmeEntry, DWORD dwInstance)
{
    TCP_REQUEST_SET_INFORMATION_EX    *lptrsiInBuf;
    TDIObjectID                       *ID;
    UCHAR                             *Context;
    IPNetToMediaEntry                 *copyInfo;
    DWORD                             dwInBufLen,dwOutBufLen,dwResult;

    TraceEnter("SetIpNetEntryToStack");
    
    dwInBufLen = sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(IPNetToMediaEntry) - 1;
    
    lptrsiInBuf = HeapAlloc(GetProcessHeap(),0,dwInBufLen);
    
    if(lptrsiInBuf is NULL)
    {
        dwResult = GetLastError();
        
        Trace1(ERR,
               "SetIpNetEntryToStack: Error %d allocating memory",
               dwResult);
        
        return dwResult;
    }
    
    ID                          = &lptrsiInBuf->ID;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_entity.tei_entity   = AT_ENTITY;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = AT_MIB_ADDRXLAT_ENTRY_ID;
    ID->toi_entity.tei_instance = dwInstance;

    //
    // Since IPNetToMediaEntry is a fixed size structure
    //
    
    copyInfo = (IPNetToMediaEntry*)lptrsiInBuf->Buffer;
    *copyInfo = *inmeEntry;
    
    dwResult = TCPSetInformationEx(g_hTcpDevice,
                                   (LPVOID)lptrsiInBuf,
                                   &dwInBufLen,
                                   NULL,
                                   &dwOutBufLen);

    TraceLeave("SetIpNetEntryToStack");
    
    return dwResult;
}

DWORD 
UpdateAdapterToIFInstanceMap()
{
    IPSNMPInfo                         ipsiInfo;
    DWORD                              dwResult;
    DWORD                              dwOutBufLen;
    DWORD                              dwInBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    IFEntry                            *maxIfEntry;
    BYTE                               *Context;
    DWORD                              dwCount,i;

    TraceEnter("UpdateAdapterToIFInstanceMap");
    
    dwResult = GetIpStatsFromStack(&ipsiInfo);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "UpdateAdapterToIFInstanceMap: NtStatus %x querying IpSnmpInfo from stack to determine number if interface",
               dwResult);

        TraceLeave("UpdateAdapterToIFInstanceMap");
        
        return dwResult;
    }
    
    
    dwOutBufLen = sizeof(MIB_IFROW) - FIELD_OFFSET(MIB_IFROW, dwIndex);

    if((maxIfEntry = (IFEntry*)HeapAlloc(GetProcessHeap(),
                                         0,
                                         dwOutBufLen)) is NULL)
    {
        dwResult = GetLastError();
        
        Trace1(ERR,
               "UpdateAdapterToIFInstanceMap: Error %d allocating memory",
               dwResult);

        TraceLeave("UpdateAdapterToIFInstanceMap");
        
        return ERROR_NOT_ENOUGH_MEMORY; 
    }




    dwInBufLen                  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    ID                          = &(trqiInBuf.ID);
    Context                     = &(trqiInBuf.Context[0]);
    ID->toi_entity.tei_entity   = IF_ENTITY;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = IF_MIB_STATS_ID;

    //
    // Read the interface entry items
    //

    for ( i = 0; i < ipsiInfo.ipsi_numif ; i++ )
    {
        dwOutBufLen = sizeof(MIB_IFROW) - FIELD_OFFSET(MIB_IFROW, dwIndex);

        ID->toi_entity.tei_instance = i;
        
        ZeroMemory(Context,CONTEXT_SIZE);

        dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                         &trqiInBuf,
                                         &dwInBufLen,
                                         (LPVOID)maxIfEntry,
                                         &dwOutBufLen);
        if (dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "UpdateAdapterToIFInstanceMap: NtStatus %x getting IFRow from stack",
                   dwResult);
            
            continue;
        }
        
        StoreAdapterToIFInstanceMap(maxIfEntry->if_index,i);
    }
    
    HeapFree(GetProcessHeap(),0,maxIfEntry);

    TraceLeave("UpdateAdapterToIFInstanceMap");
        
    return NO_ERROR;
}


//* TCPQueryInformationEx
//
// Description: Get information from the stack.
//
// Parameters:  HANDLE hHandle: handle to the stack.
//              TDIObjectID *ID: pointer to TDIObjectID info.
//              void *Buffer: buffer to receive data from the stack.
//              ulong *Bufferlen: IN: tells stack size of available buffer,
//                                OUT: tells us how much data is available.
//              CONTEXT *Context: allows queries spanning more than one call.
//
// Returns:     int:
//
//*
int
TCPQueryInformationEx( HANDLE hHandle,
                       void *InBuf,
                       ulong *InBufLen,
                       void *OutBuf,
                       ulong *OutBufLen )
{
    NTSTATUS           Status;
    IO_STATUS_BLOCK    IoStatusBlock;

    TraceEnter("TCPQueryInformationEx");
    
    Status = NtDeviceIoControlFile( hHandle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_TCP_QUERY_INFORMATION_EX,
                                   InBuf,
                                   *InBufLen,
                                   OutBuf,
                                   *OutBufLen );
    
    if ( Status == STATUS_PENDING )
    {
        Status = NtWaitForSingleObject( hHandle, FALSE, NULL );
        Status = IoStatusBlock.Status;
    }
    
    if ( !NT_SUCCESS( Status ) )
    {
        Trace1(ERR,
               "TCPQueryInformationEx: NtStatus %x from NtDeviceIoControlFile",
               Status);
        
        *OutBufLen = 0;

        TraceLeave("TCPQueryInformationEx");
        
        return Status;
    }

    //
    // Tell caller how much was written
    //
    
    *OutBufLen = IoStatusBlock.Information;

    TraceLeave("TCPQueryInformationEx");
    
    return NO_ERROR;
    
}


//* TCPSetInformationEx()
//
// Description: Send information to the stack
//
// Parameters:  HANDLE hHandle: handle to the stack.
//              TDIObjectID *ID: pointer to TDIObjectID info.
//              void *Buffer: buffer to receive data from the stack.
//              ulong Bufferlen: tells stack size of available buffer,
//
// Returns:     int:
//
//*
int 
TCPSetInformationEx(HANDLE  hHandle,
                    void    *InBuf,
                    ULONG   *InBufLen,
                    void    *OutBuf,
                    ULONG   *OutBufLen )
{
    NTSTATUS           Status;
    IO_STATUS_BLOCK    IoStatusBlock;

    TraceEnter("TCPSetInformationEx");
    
    Status = NtDeviceIoControlFile(hHandle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_TCP_SET_INFORMATION_EX,
                                   InBuf,
                                   *InBufLen,
                                   OutBuf,
                                   *OutBufLen );
    
    
    if ( Status == STATUS_PENDING )
    {
        Status = NtWaitForSingleObject(hHandle, FALSE, NULL );
        Status = IoStatusBlock.Status;
    }
    
    if ( !NT_SUCCESS( Status ) )
    {
        Trace1(ERR,
               "TCPSetInformationEx: NtStatus %x from NtDeviceIoControlFile",
               Status);

        TraceLeave("TCPSetInformationEx");
        
        return Status;
    }

    TraceLeave("TCPSetInformationEx");
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\hashtable.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\hashtable.c

Abstract:

    The file contains a hash table implementation.

--*/

#include "pchsample.h"
#pragma hdrstop


DWORD
HT_Create(
    IN  HANDLE              hHeap,
    IN  ULONG               ulNumBuckets,
    IN  PDISPLAY_FUNCTION   pfnDisplay  OPTIONAL,
    IN  PFREE_FUNCTION      pfnFree,
    IN  PHASH_FUNCTION      pfnHash,
    IN  PCOMPARE_FUNCTION   pfnCompare,
    OUT PHASH_TABLE         *pphtHashTable)
/*++

Routine Description
    Creates a hash table.

Locks
    None

Arguments
    hHeap               heap to use for allocation
    ulNumBuckets        # buckets in the hash table
    pfnDisplay          function used to display a hash table entry
    pfnFree             function used to free a hash table entry
    pfnHash             function used to compute the hash of an entry
    pfnCompare          function used to compare two hash table entries
    pphtHashTable       pointer to the hash table address

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    DWORD       dwErr = NO_ERROR;
    ULONG       i = 0, ulSize = 0; 
    PHASH_TABLE phtTable;
    
    // validate parameters
    if (!hHeap or
        !ulNumBuckets or
        !pfnFree or
        !pfnHash or
        !pfnCompare or
        !pphtHashTable)
        return ERROR_INVALID_PARAMETER;

    *pphtHashTable = NULL;
    
    do                          // breakout loop
    {
        // allocate the hash table structure
        ulSize = sizeof(HASH_TABLE);
        phtTable = HeapAlloc(hHeap, 0, ulSize);
        if (phtTable is NULL)
        {
            dwErr = GetLastError();
            break;
        }

        // allocate the buckets
        ulSize = ulNumBuckets * sizeof(LIST_ENTRY);
        phtTable->pleBuckets = HeapAlloc(hHeap, 0, ulSize);
        if (phtTable->pleBuckets is NULL)
        {
            HeapFree(hHeap, 0, phtTable); // undo allocation
            dwErr = GetLastError();
            break;
        }

        // initialize the buckets
        for (i = 0; i < ulNumBuckets; i++)
            InitializeListHead(phtTable->pleBuckets + i);

        // initialize the hash table structure's members
        phtTable->ulNumBuckets  = ulNumBuckets;
        phtTable->ulNumEntries  = 0;
        phtTable->pfnDisplay    = pfnDisplay;
        phtTable->pfnFree       = pfnFree;
        phtTable->pfnHash       = pfnHash;
        phtTable->pfnCompare    = pfnCompare;

        *pphtHashTable = phtTable;
    } while (FALSE);
    
    return dwErr;
}



DWORD
HT_Destroy(
    IN  HANDLE              hHeap,
    IN  PHASH_TABLE         phtHashTable)
/*++

Routine Description
    Destroys a hash table.
    Frees up memory allocated for hash table entries.

Locks
    Assumes the hash table is locked for writing.
    
Arguments
    hHeap               heap to use for deallocation
    phtHashTable        pointer to the hash table to be destroyed

Return Value
    NO_ERROR            always

--*/
{
    ULONG i;
    PLIST_ENTRY pleList = NULL;
    
    // validate parameters
    if (!hHeap or
        !phtHashTable)
        return NO_ERROR;

    // deallocate the entries
    for (i = 0; i < phtHashTable->ulNumBuckets; i++)
    {
        pleList = phtHashTable->pleBuckets + i;
        FreeList(pleList, phtHashTable->pfnFree);
    }

    // deallocate the buckets
    HeapFree(hHeap, 0, phtHashTable->pleBuckets);

    // deallocate the hash table structure
    HeapFree(hHeap, 0, phtHashTable);

    return NO_ERROR;
}



DWORD
HT_Cleanup(
    IN  PHASH_TABLE         phtHashTable)
/*++

Routine Description
    Cleans up all hash table entries.

Locks
    Assumes the hash table is locked for writing.

Arguments
    phtHashTable        pointer to the hash table to be cleaned up

Return Value
    NO_ERROR            always

--*/
{
    ULONG i;
    PLIST_ENTRY pleList = NULL;

    // validate parameters
    if (!phtHashTable)
        return NO_ERROR;

    // deallocate the entries
    for (i = 0; i < phtHashTable->ulNumBuckets; i++)
    {
        pleList = phtHashTable->pleBuckets + i;
        FreeList(pleList, phtHashTable->pfnFree);
    }

    phtHashTable->ulNumEntries  = 0;
    
    return NO_ERROR;
}



DWORD
HT_InsertEntry(
    IN  PHASH_TABLE         phtHashTable,
    IN  PLIST_ENTRY         pleEntry)
/*++

Routine Description
    Inserts the specified entry in the hash table.
    Memory for the entry should already have been allocated.

Locks
    Assumes the hash table is locked for writing.

Arguments
    phtHashTable        pointer to the hash table to be modified
    pleEntry            entry to be inserted

Return Value
    NO_ERROR            if success
    Error code          o/w (entry exists)

--*/
{
    DWORD dwErr = NO_ERROR;
    PLIST_ENTRY pleList = NULL;

    // validate parameters
    if (!phtHashTable or !pleEntry)
        return ERROR_INVALID_PARAMETER;

    do                          // breakout loop
    {
        // entry exists, fail
        if (HT_IsPresentEntry(phtHashTable, pleEntry))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        // insert the entry in the hash table
        pleList = phtHashTable->pleBuckets +
            (*phtHashTable->pfnHash)(pleEntry);
        InsertHeadList(pleList, pleEntry);
        phtHashTable->ulNumEntries++;
    } while (FALSE);

    return dwErr;
}
    


DWORD
HT_GetEntry(
    IN  PHASH_TABLE         phtHashTable,
    IN  PLIST_ENTRY         pleKey,
    OUT PLIST_ENTRY         *ppleEntry)
/*++

Routine Description
    Gets the hash table entry with the given key.

Locks
    Assumes the hash table is locked for reading.

Arguments
    phtHashTable        pointer to the hash table to be searched
    pleKey              key to be searched for
    ppleEntry           pointer to matching entry's address

Return Value
    NO_ERROR                entry exisits
    ERROR_INVALID_PARAMETER o/w (entry does not exist)

--*/
{
    DWORD dwErr = NO_ERROR;
    PLIST_ENTRY pleList = NULL;

    // validate parameters
    if (!phtHashTable or !pleKey or !ppleEntry)
        return ERROR_INVALID_PARAMETER;
    
    pleList = phtHashTable->pleBuckets +
        (*phtHashTable->pfnHash)(pleKey);

    FindList(pleList, pleKey, ppleEntry, phtHashTable->pfnCompare);
    
    // entry not found, fail
    if (*ppleEntry is NULL)
        dwErr = ERROR_INVALID_PARAMETER;

    return dwErr;
}


DWORD
HT_DeleteEntry(
    IN  PHASH_TABLE         phtHashTable,
    IN  PLIST_ENTRY         pleKey,
    OUT PLIST_ENTRY         *ppleEntry)
/*++

Routine Description
    Deletes the entry with the given key from the hash table.
    Memory for the entry is not deleted.

Locks
    Assumes the hash table is locked for writing.

Arguments
    phtHashTable        pointer to the hash table to be searched
    pleKey              key to be deleted
    ppleEntry           pointer to matching entry's address

Return Value
    NO_ERROR                entry exisits
    ERROR_INVALID_PARAMETER o/w (entry does not exist)

--*/
{
    DWORD dwErr = NO_ERROR;

    // validate parameters
    if (!phtHashTable or !pleKey or !ppleEntry)
        return ERROR_INVALID_PARAMETER;

    do                          // breakout loop
    {
        dwErr = HT_GetEntry(phtHashTable, pleKey, ppleEntry);

        // entry not found, fail
        if (dwErr != NO_ERROR)
            break;

        // entry found, delete from hash table and reset pointers
        RemoveEntryList(*ppleEntry);
        phtHashTable->ulNumEntries--;
    } while (FALSE);

    return dwErr;
}



BOOL
HT_IsPresentEntry(
    IN  PHASH_TABLE         phtHashTable,
    IN  PLIST_ENTRY         pleKey)
/*++

Routine Description
    Is key present in the hash table?

Locks
    Assumes the hash table is locked for reading.

Arguments
    phtHashTable        pointer to the hash table to be searched
    pleKey              key to be deleted

Return Value
    TRUE                entry exisits
    FALSE               o/w

--*/
{
    DWORD       dwErr;
    PLIST_ENTRY pleEntry = NULL;

    // validate parameters
    if (!phtHashTable or !pleKey)
        return FALSE;
    
    dwErr = HT_GetEntry(phtHashTable, pleKey, &pleEntry);

    // entry not found, fail
    if (dwErr != NO_ERROR)
        return FALSE;
        
    // entry found, delete from hash table
    return TRUE;
}



DWORD
HT_MapCar(
    IN  PHASH_TABLE         phtHashTable,
    IN  PVOID_FUNCTION      pfnVoidFunction
    )
/*++

Routine Description
    Applies the specified function to all entries in a hash table.

Locks
    Assumes the hash table is locked for reading.

Arguments
    phtHashTable        pointer to the hash table to be mapcar'ed
    pfnVoidFunction     pointer to function to apply to all entries
    
Return Value
    NO_ERROR            always

--*/
{
    ULONG i;
    PLIST_ENTRY pleList = NULL;

    // validate parameters
    if (!phtHashTable or !pfnVoidFunction)
        return NO_ERROR;

    for (i = 0; i < phtHashTable->ulNumBuckets; i++)
    {
        pleList = phtHashTable->pleBuckets + i;
        MapCarList(pleList, pfnVoidFunction);
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\configentry.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\configurationentry.c

Abstract:

    The file contains functions to deal with the configuration entry.

--*/

#include "pchsample.h"
#pragma hdrstop

static
VOID
DisplayEventEntry (
    IN  PQUEUE_ENTRY        pqeEntry)
/*++

Routine Description
    Displays an EVENT_ENTRY object.

Locks
    None

Arguments

    pqeEntry            address of the 'leEventQueueLink' field

Return Value
    None

--*/
{
    EE_Display(CONTAINING_RECORD(pqeEntry, EVENT_ENTRY, qeEventQueueLink));
}
               


static
VOID
FreeEventEntry (
    IN  PQUEUE_ENTRY        pqeEntry)
/*++

Routine Description
    Frees an EVENT_ENTRY object.

Locks
    None

Arguments

    pqeEntry            address of the 'leEventQueueLink' field

Return Value
    None

--*/
{
    EE_Destroy(CONTAINING_RECORD(pqeEntry, EVENT_ENTRY, qeEventQueueLink));
}
               


DWORD
EE_Create (
    IN  ROUTING_PROTOCOL_EVENTS rpeEvent,
    IN  MESSAGE                 mMessage,
    OUT PEVENT_ENTRY            *ppeeEventEntry)
/*++

Routine Description
    Creates an event entry.

Locks
    None

Arguments
    rpeEvent
    mMessage
    ppEventEntry        pointer to the event entry address

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    DWORD               dwErr = NO_ERROR;
    PEVENT_ENTRY        peeEntry; // scratch

    // validate parameters
    if (!ppeeEventEntry)
        return ERROR_INVALID_PARAMETER;

    *ppeeEventEntry = NULL;

    // allocate the interface entry structure
    MALLOC(&peeEntry, sizeof(EVENT_ENTRY), &dwErr);
    if (dwErr != NO_ERROR)
        return dwErr;

    // initialize various fields
    InitializeQueueHead(&(peeEntry->qeEventQueueLink));
    
    peeEntry->rpeEvent = rpeEvent;
    peeEntry->mMessage = mMessage;

    *ppeeEventEntry = peeEntry;
    return dwErr;
}



DWORD
EE_Destroy (
    IN  PEVENT_ENTRY            peeEventEntry)
/*++

Routine Description
    Destroys an event entry.

Locks
    None.

Arguments
    peeEventEntry       pointer to the event entry

Return Value
    NO_ERROR            always

--*/
{
    if (!peeEventEntry)
        return NO_ERROR;

    FREE(peeEventEntry);
    
    return NO_ERROR;
}



#ifdef DEBUG
DWORD
EE_Display (
    IN  PEVENT_ENTRY            peeEventEntry)
/*++

Routine Description
    Displays an event entry.

Locks
    None.

Arguments
    peeEventEntry       pointer to the event entry

Return Value
    NO_ERROR            always

--*/
{
    if (!peeEventEntry)
        return NO_ERROR;

    TRACE1(CONFIGURATION,
           "Event %u",
           peeEventEntry->rpeEvent);

    if (peeEventEntry->rpeEvent is SAVE_INTERFACE_CONFIG_INFO)
        TRACE1(CONFIGURATION,
               "Index %u",
               (peeEventEntry->mMessage).InterfaceIndex);

    return NO_ERROR;
}
#endif // DEBUG



DWORD
EnqueueEvent(
    IN  ROUTING_PROTOCOL_EVENTS rpeEvent,
    IN  MESSAGE                 mMessage)
/*++

Routine Description
    Queues an event entry in g_ce.lqEventQueue.

Locks
    Locks and unlocks the locked queue g_ce.lqEventQueue.

Arguments
    rpeEvent
    mMessage

Return Value
    NO_ERROR            success
    Error Code          o/w

--*/    
{
    DWORD           dwErr = NO_ERROR;
    PEVENT_ENTRY    peeEntry = NULL;

    dwErr = EE_Create(rpeEvent, mMessage, &peeEntry); 
    // destroyed in EE_DequeueEvent
    
    if (dwErr is NO_ERROR)
    {
        ACQUIRE_QUEUE_LOCK(&(g_ce.lqEventQueue));
        
        Enqueue(&(g_ce.lqEventQueue.head), &(peeEntry->qeEventQueueLink));

        RELEASE_QUEUE_LOCK(&(g_ce.lqEventQueue));
    }
    
    return dwErr;
}


     
DWORD
DequeueEvent(
    OUT ROUTING_PROTOCOL_EVENTS  *prpeEvent,
    OUT MESSAGE                  *pmMessage)
/*++

Routine Description
    Dequeues an event entry from g_ce.lqEventQueue.

Locks
    Locks and unlocks the locked queue g_ce.lqEventQueue.

Arguments
    prpeEvent
    pmMessage

Return Value
    NO_ERROR            success
    ERROR_NO_MORE_ITEMS o/w

--*/  
{
    DWORD           dwErr   = NO_ERROR;
    PQUEUE_ENTRY    pqe     = NULL;
    PEVENT_ENTRY    pee     = NULL;

    ACQUIRE_QUEUE_LOCK(&(g_ce.lqEventQueue));

    do                          // breakout loop
    {
        if (IsQueueEmpty(&(g_ce.lqEventQueue.head)))
        {
            dwErr = ERROR_NO_MORE_ITEMS;
            TRACE0(CONFIGURATION, "Error no events in the queue");
            LOGWARN0(EVENT_QUEUE_EMPTY, dwErr);
            break;
        }

        pqe = Dequeue(&(g_ce.lqEventQueue.head));

        pee = CONTAINING_RECORD(pqe, EVENT_ENTRY, qeEventQueueLink);
        *(prpeEvent) = pee->rpeEvent;
        *(pmMessage) = pee->mMessage;

        // created in EE_EnqueueEvent
        EE_Destroy(pee);
        pee = NULL;
    } while (FALSE);

    RELEASE_QUEUE_LOCK(&(g_ce.lqEventQueue));
        
    return dwErr;
}   



DWORD
CE_Create (
    IN  PCONFIGURATION_ENTRY    pce)
/*++

Routine Description
    Creates a configuration entry on DLL_PROCESS_ATTACH.

Locks
    None

Arguments
    pce                 pointer to the configuration entry

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    DWORD dwErr = NO_ERROR;

    // initialize to default values
    ZeroMemory(pce, sizeof(CONFIGURATION_ENTRY));
    pce->dwTraceID = INVALID_TRACEID;
    
    do                          // breakout loop
    {
        // initialize the read-write lock
        CREATE_READ_WRITE_LOCK(&(pce->rwlLock));
        if (!READ_WRITE_LOCK_CREATED(&(pce->rwlLock)))
        {
            dwErr = GetLastError();
            
            TRACE1(CONFIGURATION, "Error %u creating read-write-lock", dwErr);
            LOGERR0(CREATE_RWL_FAILED, dwErr);

            break;
        }

        // initialize the global heap
        pce->hGlobalHeap = HeapCreate(0, 0, 0);
        if (pce->hGlobalHeap is NULL)
        {
            dwErr = GetLastError();
            TRACE1(CONFIGURATION, "Error %u creating global heap", dwErr);
            LOGERR0(HEAP_CREATE_FAILED, dwErr);

            break;
        }

        //
        // initialize the count of threads that are active in IPSAMPLE
        // create the semaphore released by each thread when it is done
        // required for clean stop to the protocol
        // 
        pce->ulActivityCount = 0;
        pce->hActivitySemaphore = CreateSemaphore(NULL, 0, 0xfffffff, NULL);
        if (pce->hActivitySemaphore is NULL)
        {
            dwErr = GetLastError();
            TRACE1(CONFIGURATION, "Error %u creating semaphore", dwErr);
            LOGERR0(CREATE_SEMAPHORE_FAILED, dwErr);
            break;
        }

        // Logging & Tracing Information
        pce->dwLogLevel = IPSAMPLE_LOGGING_INFO;
        pce->hLogHandle = RouterLogRegister("IPSAMPLE");
        pce->dwTraceID  = TraceRegister("IPSAMPLE");

        // Event Queue
        INITIALIZE_LOCKED_QUEUE(&(pce->lqEventQueue));
        if (!LOCKED_QUEUE_INITIALIZED(&(pce->lqEventQueue)))
        {
            dwErr = GetLastError();
            TRACE1(CONFIGURATION, "Error %u initializing locked queue", dwErr);
            LOGERR0(INIT_CRITSEC_FAILED, dwErr);
            break;
        }

        // Protocol State
        pce->iscStatus = IPSAMPLE_STATUS_STOPPED;
        

        // Store of Dynamic Locks
        // pce->dlsDynamicLocksStore    zero'ed out

        // Timer Entry
        // pce->hTimerQueue             = NULL;

        // Router Manager Information (later)
        // pce->hMgrNotificationEvent   = NULL
        // pce->sfSupportFunctions      zero'ed out

        // RTMv2 Information
        // pce->reiRtmEntity            zero'ed out
        // pce->rrpRtmProfile           zero'ed out
        // pce->hRtmHandle              = NULL
        // pce->hRtmNotificationHandle  = NULL

        // MGM Information
        // pce->hMgmHandle              = NULL

        // Network Entry
        // pce->pneNetworkEntry         = NULL;

        // Global Statistics
        // pce->igsStats                zero'ed out

    } while (FALSE);

    if (dwErr != NO_ERROR)
    {
        // something went wrong, so cleanup.
        TRACE0(CONFIGURATION, "Failed to create configuration entry");
        CE_Destroy(pce);
    }
    
    return dwErr;
}



DWORD
CE_Destroy (
    IN  PCONFIGURATION_ENTRY    pce)
/*++

Routine Description
    Destroys a configuration entry on DLL_PROCESS_DEATTACH

Locks
    Assumes exclusive access to rwlLock with no waiting thread.

Arguments
    pce                 pointer to the configuration entry

Return Value
    NO_ERROR            always

--*/
{
    // Network Entry
    
    // MGM Information
    
    // RTMv2 Information
    
    // Router Manager Information

    // Timer Entry

    // Store of Dynamic Locks
    
    // protocol state should be such...
    RTASSERT(pce->iscStatus is IPSAMPLE_STATUS_STOPPED);

    // Event Queue
    if (LOCKED_QUEUE_INITIALIZED(&(pce->lqEventQueue)))
        DELETE_LOCKED_QUEUE((&(pce->lqEventQueue)), FreeEventEntry);
    
    // Logging & Tracing Information
    if (pce->dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(pce->dwTraceID);
        pce->dwTraceID = INVALID_TRACEID;
    }
    if (pce->hLogHandle != NULL)
    {
        RouterLogDeregister(pce->hLogHandle);
        pce->hLogHandle = NULL;
    }

    // destroy the semaphore released by each thread when it is done
    if (pce->hActivitySemaphore != NULL)
    {
        CloseHandle(pce->hActivitySemaphore);
        pce->hActivitySemaphore = NULL;
    }

    if (pce->hGlobalHeap != NULL)
    {
        HeapDestroy(pce->hGlobalHeap);
        pce->hGlobalHeap = NULL;
    }

    // delete the read-write lock
    if (READ_WRITE_LOCK_CREATED(&(pce->rwlLock)))
        DELETE_READ_WRITE_LOCK(&(pce->rwlLock));

    return NO_ERROR;
}



DWORD
CE_Initialize (
    IN  PCONFIGURATION_ENTRY    pce,
    IN  HANDLE                  hMgrNotificationEvent,
    IN  PSUPPORT_FUNCTIONS      psfSupportFunctions,
    IN  PIPSAMPLE_GLOBAL_CONFIG pigc)
/*++

Routine Description
    Initializes a configuration entry on StartProtocol.

Locks
    Assumes exclusive access to pce->rwlLock

Arguments
    pce                     pointer to the configuration entry
    hMgrNotificationEvent   event used to notify ip router manager
    psfSupportFunctions     functions exported by ip router manager
    pigc                    global configuration set in registry
    
Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    WORD    wVersionRequested   = MAKEWORD(1,1);
    WSADATA wsaData;
    BOOL    bCleanupWinsock     = FALSE;
    
    DWORD   dwErr               = NO_ERROR;

    // validate environment
    RTASSERT(pce->ulActivityCount is 0);
    RTASSERT(pce->iscStatus is IPSAMPLE_STATUS_STOPPED);
    
    do                          // breakout loop
    {
        pce->ulActivityCount    = 0;
        pce->dwLogLevel         = pigc->dwLoggingLevel;


        dwErr = (DWORD) WSAStartup(wVersionRequested, &wsaData);
        if (dwErr != 0)
        {
            TRACE1(CONFIGURATION, "Error %u starting windows sockets", dwErr);
            LOGERR0(WSASTARTUP_FAILED, dwErr);
            break;
        }
        bCleanupWinsock = TRUE;

        // Store of Dynamic Locks
        dwErr = InitializeDynamicLocksStore(&(pce->dlsDynamicLocksStore),
                                            GLOBAL_HEAP);
        if (dwErr != NO_ERROR)
        {
            TRACE1(CONFIGURATION, "Error %u initializing locks store", dwErr);
            LOGERR0(INIT_CRITSEC_FAILED, dwErr);
            break;
        }

        // Timer Entry
        pce->hTimerQueue = CreateTimerQueue();
        if (!pce->hTimerQueue)
        {
            dwErr = GetLastError();
            TRACE1(CONFIGURATION, "Error %u registering timer queue", dwErr);
            LOGERR0(CREATE_TIMER_QUEUE_FAILED, dwErr);
            break;
        }

        
        // Router Manager Information
        pce->hMgrNotificationEvent   = hMgrNotificationEvent;
        if (psfSupportFunctions)
            pce->sfSupportFunctions      = *psfSupportFunctions;

        
        // RTMv2 Information
        pce->reiRtmEntity.RtmInstanceId = 0;
        pce->reiRtmEntity.AddressFamily = AF_INET;
        pce->reiRtmEntity.EntityId.EntityProtocolId = PROTO_IP_SAMPLE;
        pce->reiRtmEntity.EntityId.EntityInstanceId = 0;

        dwErr = RTM_RegisterEntity(
            &pce->reiRtmEntity,     // IN   my RTM_ENTITY_INFO
            NULL,                   // IN   my exported methods
            RTM_CallbackEvent,      // IN   my callback function 
            TRUE,                   // IN   reserve opaque pointer?
            &pce->rrpRtmProfile,    // OUT  my RTM_REGN_PROFILE
            &pce->hRtmHandle);      // OUT  my RTMv2 handle 
        if (dwErr != NO_ERROR)
        {
            TRACE1(CONFIGURATION, "Error %u registering with RTM", dwErr);
            LOGERR0(RTM_REGISTER_FAILED, dwErr);
            break;
        }

        dwErr = RTM_RegisterForChangeNotification(
            pce->hRtmHandle,        // IN   my RTMv2 handle 
            RTM_VIEW_MASK_MCAST,    // IN   route table views relevant to moi 
            RTM_CHANGE_TYPE_BEST,   // IN   change types interesting to moi
            NULL,                   // IN   context in callback function
            &pce->hRtmNotificationHandle); // OUT   my notification handle
        if (dwErr != NO_ERROR)
        {
            TRACE1(CONFIGURATION,
                   "Error %u registering for change with RTM", dwErr);
            LOGERR0(RTM_REGISTER_FAILED, dwErr);
            break;
        }


        // MGM Information
        // pce->hMgmHandle (later)


        // Network Entry
        dwErr = NE_Create(&(pce->pneNetworkEntry));
        if (dwErr != NO_ERROR)
            break;        


        // Global Statistics
        ZeroMemory(&(pce->igsStats), sizeof(IPSAMPLE_GLOBAL_STATS));
        

        pce->iscStatus = IPSAMPLE_STATUS_RUNNING;
    } while (FALSE);

    // something went wrong, cleanup
    if (dwErr != NO_ERROR)
        CE_Cleanup(pce, bCleanupWinsock);

    return dwErr;
}



DWORD
CE_Cleanup (
    IN  PCONFIGURATION_ENTRY    pce,
    IN  BOOL                    bCleanupWinsock)
/*++

Routine Description
    Cleans up a configuration entry on StopProtocol.

Locks
    Exclusive access to pce->rwlLock by virtue of no competing threads.

    NOTE: However, pce->rwlLock should NOT actually be held!  The call to
    DeleteTimerQueueEx blocks till all queued callbacks finish execution.
    These callbacks may acquire pce->rwlLock, causing deadlock.
    
Arguments
    pce                 pointer to the configuration entry
    bCleanupWinsock     
Return Value
    NO_ERROR            always

--*/
{
    DWORD dwErr = NO_ERROR;

    
    // Network Entry
    NE_Destroy(pce->pneNetworkEntry);
    pce->pneNetworkEntry        = NULL;
     

    // MGM Information (later)
    pce->hMgmHandle = NULL;
    

    // RTMv2 Information
    if (pce->hRtmNotificationHandle)
    {
        dwErr = RTM_DeregisterFromChangeNotification(
            pce->hRtmHandle,
            pce->hRtmNotificationHandle);

        if (dwErr != NO_ERROR)
            TRACE1(CONFIGURATION,
                   "Error %u deregistering for change from RTM", dwErr);
    }
    pce->hRtmNotificationHandle = NULL;

    if (pce->hRtmHandle)
    {
        dwErr = RTM_DeregisterEntity(pce->hRtmHandle);

        if (dwErr != NO_ERROR)
            TRACE1(CONFIGURATION,
                   "Error %u deregistering from RTM", dwErr);
    }
    pce->hRtmHandle             = NULL;

    
    // Router Manager Information
    // valid till overwritten, needed to signal the ip router manager
    //     pce->hMgrNotificationEvent
    //     pce->sfSupportFunctions
    

    // Timer Entry
    if (pce->hTimerQueue)
        DeleteTimerQueueEx(pce->hTimerQueue, INVALID_HANDLE_VALUE);
    pce->hTimerQueue            = NULL;
    

    // Store of Dynamic Locks
    if (DYNAMIC_LOCKS_STORE_INITIALIZED(&(pce->dlsDynamicLocksStore)))
    {
        dwErr = DeInitializeDynamicLocksStore(&(pce->dlsDynamicLocksStore));

        // all dynamic locks should have been free
        RTASSERT(dwErr is NO_ERROR);
    }

    if (bCleanupWinsock)
        WSACleanup();
    
    // protocol state
    pce->iscStatus = IPSAMPLE_STATUS_STOPPED;

    return NO_ERROR;
}



#ifdef DEBUG
DWORD
CE_Display (
    IN  PCONFIGURATION_ENTRY    pce)
/*++

Routine Description
    Displays a configuration entry.

Locks
    Acquires shared pce->rwlLock
    Releases        pce->rwlLock

Arguments
    pce                 pointer to the configuration entry to be displayed

Return Value
    NO_ERROR            always

--*/
{
    if (!pce)
        return NO_ERROR;

    
    ACQUIRE_READ_LOCK(&(pce->rwlLock));
    
    TRACE0(CONFIGURATION, "Configuration Entry...");

    TRACE3(CONFIGURATION,
           "ActivityCount %u, LogLevel %u, NumInterfaces %u",
           pce->ulActivityCount,
           pce->dwLogLevel,
           pce->igsStats.ulNumInterfaces);

    NE_Display(pce->pneNetworkEntry);

    RELEASE_READ_LOCK(&(pce->rwlLock));

    TRACE0(CONFIGURATION, "EventQueue...");
    ACQUIRE_QUEUE_LOCK(&(pce->lqEventQueue));
    MapCarQueue(&((pce->lqEventQueue).head), DisplayEventEntry);
    RELEASE_QUEUE_LOCK(&(pce->lqEventQueue));


    return NO_ERROR;
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\configmgr.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\configurationemanager.h

Abstract:

    The file contains the interface to the configuration manager.

--*/

#ifndef _CONFIGURATION_MANAGER_H_
#define _CONFIGURATION_MANAGER_H_

// globals...

extern CONFIGURATION_ENTRY      g_ce;



// functions...

DWORD
CM_StartProtocol (
    IN  HANDLE                  hMgrNotificationEvent,
    IN  PSUPPORT_FUNCTIONS      psfSupportFunctions,
    IN  PVOID                   pvGlobalInfo);

DWORD
CM_StopProtocol (
    );

DWORD
CM_GetGlobalInfo (
    IN      PVOID 	            pvGlobalInfo,
    IN OUT  PULONG              pulBufferSize,
    OUT     PULONG	            pulStructureVersion,
    OUT     PULONG              pulStructureSize,
    OUT     PULONG              pulStructureCount);

DWORD
CM_SetGlobalInfo (
    IN      PVOID 	            pvGlobalInfo);

DWORD
CM_GetEventMessage (
    OUT ROUTING_PROTOCOL_EVENTS *prpeEvent,
    OUT MESSAGE                 *pmMessage);

#endif // _CONFIGURATION_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\ipsample.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\ipsample.h

Abstract:

    The file contains the header for ipsample.c.

--*/

#ifndef _IPSAMPLE_H_
#define _IPSAMPLE_H_

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus
    
#ifndef SAMPLEAPI
#define SAMPLEAPI __declspec(dllimport)
#endif // SAMPLEAPI

SAMPLEAPI
VOID
WINAPI    
TestProtocol(VOID);  

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _IPSAMPLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\ipsample.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\ipsample.c

Abstract:

    The file contains the entry point to the ip sample protocol's dll.

--*/

#include "pchsample.h"
#pragma hdrstop

#define SAMPLEAPI __declspec(dllexport)
#include "ipsample.h"

BOOL
WINAPI
DllMain(
    IN  HINSTANCE hInstance,
    IN  DWORD dwReason,
    IN  PVOID pvImpLoad
    )

/*++

Routine Description
    DLL entry and exit point handler.
    It calls CE_Initialize to initialize the configuration entry...
    It calls CD_Cleanup to cleanup the configuration entry...

Locks
    None

Arguments
    hInstance   Instance handle of DLL
    dwReason    Reason function called
    pvImpLoad   Implicitly loaded DLL?

Return Value
    TRUE        Successfully loaded DLL

--*/
    
{
    BOOL bError = TRUE;

    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(pvImpLoad);
    
    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hInstance);
            bError = (CE_Create(&g_ce) is NO_ERROR) ? TRUE : FALSE;
                
            break;
            
        case DLL_PROCESS_DETACH:
            CE_Destroy(&g_ce);
            
            break;

        default:

            break;
    }   

    return bError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\makefile.inc ===
ipsamplemsg.mc:   .\log.h
    mapmsg NET IPSAMPLELOG_BASE .\log.h > ipsamplemsg.mc

ipsamplemsg.h msg00001.bin:   ipsamplemsg.mc
    mc -v ipsamplemsg.mc

ipsample.rc:   msg00001.bin

clean::
    -del ipsamplemsg.mc ipsamplemsg.h ipsamplemsg.rc msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\list.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\list.h

Abstract:

    The file contains a list implementation.

--*/

#ifndef _LIST_H_
#define _LIST_H_

/*++

The Following are already defined

(public\sdk\inc\winnt.h)

//
// Calculate the byte offset of a 'field' in a structure of type 'type'.
//
// #define FIELD_OFFSET(type, field)                                    \
//     ((LONG)(LONG_PTR)&(((type *)0)->field))
//

//
// Calculate the address of the base of the structure given its 'type',
// and an 'address' of a 'field' within the structure.
//
// #define CONTAINING_RECORD(address, type, field)                      \
//     ((type *)((PCHAR)(address) - (ULONG_PTR)(&((type *)0)->field)))
//

//  Doubly linked list structure.
//
// typedef struct _LIST_ENTRY
// {
//     struct _LIST_ENTRY *Flink;
//     struct _LIST_ENTRY *Blink;
// } LIST_ENTRY, *PLIST_ENTRY;
//

--*/

//
//  Doubly-linked list manipulation routines.  Implemented as macros but
//  logically these are procedures.
//



//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead)                            \
    ((ListHead)->Flink = (ListHead)->Blink = (ListHead))


    
//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead)                                   \
    ((ListHead)->Flink == (ListHead))


    
//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead)                                \
    (ListHead)->Flink;                                          \
    {RemoveEntryList((ListHead)->Flink)}



//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead)                                \
    (ListHead)->Blink;                                          \
    {RemoveEntryList((ListHead)->Blink)}



//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry)                                  \
{                                                               \
    PLIST_ENTRY _EX_Blink;                                      \
    PLIST_ENTRY _EX_Flink;                                      \
    _EX_Flink = (Entry)->Flink;                                 \
    _EX_Blink = (Entry)->Blink;                                 \
    _EX_Blink->Flink = _EX_Flink;                               \
    _EX_Flink->Blink = _EX_Blink;                               \
}



//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry)                          \
{                                                               \
    PLIST_ENTRY _EX_Blink;                                      \
    PLIST_ENTRY _EX_ListHead;                                   \
    _EX_ListHead = (ListHead);                                  \
    _EX_Blink = _EX_ListHead->Blink;                            \
    (Entry)->Flink = _EX_ListHead;                              \
    (Entry)->Blink = _EX_Blink;                                 \
    _EX_Blink->Flink = (Entry);                                 \
    _EX_ListHead->Blink = (Entry);                              \
}



//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry)                          \
{                                                               \
    PLIST_ENTRY _EX_Flink;                                      \
    PLIST_ENTRY _EX_ListHead;                                   \
    _EX_ListHead = (ListHead);                                  \
    _EX_Flink = _EX_ListHead->Flink;                            \
    (Entry)->Flink = _EX_Flink;                                 \
    (Entry)->Blink = _EX_ListHead;                              \
    _EX_Flink->Blink = (Entry);                                 \
    _EX_ListHead->Flink = (Entry);                              \
}



//
//  VOID
//  InsertSortedList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry,
//      LONG(*CompareFunction)(PLIST_ENTRY, PLIST_ENTRY)
//      );
//

#define InsertSortedList(ListHead, Entry, CompareFunction)      \
{                                                               \
    PLIST_ENTRY _EX_Entry;                                      \
    PLIST_ENTRY _EX_Blink;                                      \
    for (_EX_Entry = (ListHead)->Flink;                         \
         _EX_Entry != (ListHead);                               \
         _EX_Entry = _EX_Entry->Flink)                          \
        if ((*(CompareFunction))((Entry), _EX_Entry) <= 0)      \
            break;                                              \
    _EX_Blink = _EX_Entry->Blink;                               \
    _EX_Blink->Flink = (Entry);                                 \
    _EX_Entry->Blink = (Entry);                                 \
    (Entry)->Flink     = _EX_Entry;                             \
    (Entry)->Blink     = _EX_Blink;                             \
}



//
// Finds an 'Entry' equal to 'Key' in a 'List'
// 
//  VOID
//  FindList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Key,
//      PLIST_ENTRY *Entry,
//      LONG (*CompareFunction)(PLIST_ENTRY, PLIST_ENTRY)
//      );
//

#define FindList(ListHead, Key, Entry, CompareFunction)         \
{                                                               \
    PLIST_ENTRY _EX_Entry;                                      \
    *(Entry) = NULL;                                            \
    for (_EX_Entry = (ListHead)->Flink;                         \
         _EX_Entry != (ListHead);                               \
         _EX_Entry = _EX_Entry->Flink)                          \
        if ((*(CompareFunction))((Key), _EX_Entry) is 0)        \
        {                                                       \
            *(Entry) = _EX_Entry;                               \
            break;                                              \
        }                                                       \
}



//
// Finds an 'Entry' equal to or greater than 'Key' in a sorted 'List'
// 
//  VOID
//  FindSortedList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Key,
//      PLIST_ENTRY *Entry,
//      LONG (*CompareFunction)(PLIST_ENTRY, PLIST_ENTRY)
//      );
//

#define FindSortedList(ListHead, Key, Entry, CompareFunction)   \
{                                                               \
    PLIST_ENTRY _EX_Entry;                                      \
    *(Entry) = NULL;                                            \
    for (_EX_Entry = (ListHead)->Flink;                         \
         _EX_Entry != (ListHead);                               \
         _EX_Entry = _EX_Entry->Flink)                          \
        if ((*(CompareFunction))((Key), _EX_Entry) <= 0)        \
        {                                                       \
            *(Entry) = _EX_Entry;                               \
            break;                                              \
        }                                                       \
}



//
// Applies a 'Function' to all entries in a list.
// 
//  VOID
//  MapCarList(
//      PLIST_ENTRY ListHead,
//      VOID(*VoidFunction)(PLIST_ENTRY)
//      );
//

#define MapCarList(ListHead, VoidFunction)                      \
{                                                               \
    PLIST_ENTRY _EX_Entry;                                      \
    for (_EX_Entry = (ListHead)->Flink;                         \
         _EX_Entry != (ListHead);                               \
         _EX_Entry = _EX_Entry->Flink)                          \
        (*(VoidFunction))(_EX_Entry);                           \
}



//
// Frees a list.
// 
//  VOID
//  FreeList(
//      PLIST_ENTRY ListHead,
//      VOID(*FreeFunction)(PLIST_ENTRY)
//      );
//

#define FreeList(ListHead, FreeFunction)                        \
{                                                               \
    PLIST_ENTRY _EX_Head;                                       \
    while (!IsListEmpty(ListHead))                              \
    {                                                           \
        _EX_Head = RemoveHeadList(ListHead);                    \
        (*(FreeFunction))(_EX_Head);                            \
    }                                                           \
}
    


#define QUEUE_ENTRY                     LIST_ENTRY
#define PQUEUE_ENTRY                    PLIST_ENTRY

//
//  VOID
//  InitializeQueueHead(
//      PQUEUE_ENTRY QueueHead
//      );
//

#define InitializeQueueHead(QueueHead)  InitializeListHead(QueueHead)

//
//  BOOLEAN
//  IsQueueEmpty(
//      PQUEUE_ENTRY QueueHead
//      );
//

#define IsQueueEmpty(QueueHead)         IsListEmpty(QueueHead)

//
//  VOID
//  Enqueue(
//      PQUEUE_ENTRY QueueHead,
//      PQUEUE_ENTRY Entry
//      );
//

#define Enqueue(QueueHead, Entry)       InsertTailList(QueueHead, Entry)

//
//  PQUEUE_ENTRY
//  Dequeue(
//      PQUEUE_ENTRY QueueHead,
//      );
//

#define Dequeue(QueueHead)              RemoveHeadList(QueueHead)

// 
//  VOID
//  FreeQueue(
//      PQUEUE_ENTRY QueueHead,
//      VOID(*FreeFunction)(PQUEUE_ENTRY)
//      );
//

#define FreeQueue(QueueHead, FreeFunction)                      \
    FreeList(QueueHead, FreeFunction)

//
//  VOID
//  MapCarQueue(
//      PQUEUE_ENTRY QueueHead,
//      VOID(*VoidFunction)(PQUEUE_ENTRY)
//      );
//

#define MapCarQueue(QueueHead, VoidFunction)                    \
    MapCarList(QueueHead, VoidFunction)



#define STACK_ENTRY                     LIST_ENTRY
#define PSTACK_ENTRY                    PLIST_ENTRY

//
//  VOID
//  InitializeStackHead(
//      PSTACK_ENTRY StackHead
//      );
//

#define InitializeStackHead(StackHead)  InitializeListHead(StackHead)

//
//  BOOLEAN
//  IsStackEmpty(
//      PSTACK_ENTRY StackHead
//      );
//

#define IsStackEmpty(StackHead)         IsListEmpty(StackHead)

//
//  VOID
//  Push(
//      PSTACK_ENTRY StackHead,
//      PSTACK_ENTRY Entry
//      );
//

#define Push(StackHead, Entry)          InsertHeadList(StackHead, Entry)

//
//  PSTACK_ENTRY
//  Pop(
//      PSTACK_ENTRY StackHead,
//      );
//

#define Pop(StackHead)                  RemoveHeadList(StackHead)

// 
//  VOID
//  FreeStack(
//      PSTACK_ENTRY StackHead,
//      VOID(*FreeFunction)(PSTACK_ENTRY)
//      );
//

#define FreeStack(StackHead, FreeFunction)                      \
    FreeList(StackHead, FreeFunction)

//
//  VOID
//  MapCarStack(
//      PSTACK_ENTRY StackHead,
//      VOID(*VoidFunction)(PSTACK_ENTRY)
//      );
//

#define MapCarStack(StackHead, VoidFunction)                    \
    MapCarList(StackHead, VoidFunction)

#endif // _LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\ipsamplerm.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    ipsamplerm.h

Abstract:

    The file contains type definitions and declarations for SAMPLE, the
    sample ip protocol, used by the IP Router Manager.

--*/

#ifndef _IPSAMPLERM_H_
#define _IPSAMPLERM_H_


// useful for variable sized structs
#undef  ANY_SIZE
#define ANY_SIZE 0



//----------------------------------------------------------------------------
// CONSTANT AND MACRO DECLARATIONS
//----------------------------------------------------------------------------

#define PROTO_IP_SAMPLE 200
#define MS_IP_SAMPLE    \
PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS0, PROTO_IP_SAMPLE)

#define SAMPLE_PROTOCOL_MULTICAST_GROUP ((DWORD)0x640000E0) // 224.0.0.100
    
    
//----------------------------------------------------------------------------
// constants identifying IPSAMPLE's MIB tables
//----------------------------------------------------------------------------

#define IPSAMPLE_GLOBAL_STATS_ID        0
#define IPSAMPLE_GLOBAL_CONFIG_ID       1
#define IPSAMPLE_IF_STATS_ID            2
#define IPSAMPLE_IF_CONFIG_ID           3
#define IPSAMPLE_IF_BINDING_ID          4


//----------------------------------------------------------------------------
// constants used for the field IPSAMPLE_GLOBAL_CONFIG::dwLoggingLevel
//----------------------------------------------------------------------------

#define IPSAMPLE_LOGGING_NONE           0
#define IPSAMPLE_LOGGING_ERROR          1
#define IPSAMPLE_LOGGING_WARN           2
#define IPSAMPLE_LOGGING_INFO           3



//----------------------------------------------------------------------------
// constants used for the field IPSAMPLE_IF_CONFIG::ulMetric
//----------------------------------------------------------------------------

#define IPSAMPLE_METRIC_INFINITE        16

    
    
//----------------------------------------------------------------------------
// constants used to construct the field IPSAMPLE_IF_BINDING::dwState
//----------------------------------------------------------------------------
    
#define IPSAMPLE_STATE_ACTIVE           0x00000001
#define IPSAMPLE_STATE_BOUND            0x00000002
    


//----------------------------------------------------------------------------
// STRUCTURE DEFINITIONS
//----------------------------------------------------------------------------



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_GLOBAL_STATS
//
// This MIB entry stores global statistics for IPSAMPLE;
// There is only one instance, so this entry has no index.
//
// This structure is read-only.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_GLOBAL_STATS
{
    ULONG       ulNumInterfaces; // # interfaces added
} IPSAMPLE_GLOBAL_STATS, *PIPSAMPLE_GLOBAL_STATS;



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_GLOBAL_CONFIG
//
// This MIB entry stores global configuration for IPSAMPLE
// There is only one instance, so this entry has no index.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_GLOBAL_CONFIG
{
    DWORD       dwLoggingLevel;
} IPSAMPLE_GLOBAL_CONFIG, *PIPSAMPLE_GLOBAL_CONFIG;



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_IF_STATS
//
// This MIB entry stores per-interface statistics for IPSAMPLE.
//
// This structure is read-only.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_IF_STATS
{
    ULONG       ulNumPackets;   // # packets sent out this interface
} IPSAMPLE_IF_STATS, *PIPSAMPLE_IF_STATS;



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_IF_CONFIG
//
// This MIB entry describes per-interface configuration.
// All IP address fields must be in network order.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_IF_CONFIG
{
    ULONG       ulMetric;
} IPSAMPLE_IF_CONFIG, *PIPSAMPLE_IF_CONFIG;



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_IF_BINDING
//
// This MIB entry contains the table of IP addresses to which each
// interface is bound.  All IP addresses are in network order.
//
// THIS STRUCTURE IS VARIABLE LENGTH:
//
//  The base structure contains of the field ulCount, which gives the
//  number of IP addresses to which the indexed interface is bound.  The
//  IP addresses themselves follow the base structure, and are given as
//  IPSAMPLE_IP_ADDRESS structures.
//
// This MIB entry is read-only.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_IF_BINDING
{
    DWORD       dwState;
    ULONG       ulCount;
} IPSAMPLE_IF_BINDING, *PIPSAMPLE_IF_BINDING;




//----------------------------------------------------------------------------
// struct:      IPSAMPLE_IP_ADDRESS
//
// This structure is used for storing interface bindings.  A series of
// structures of this type follows the IPSAMPLE_IF_BINDING structure
// (described above).
//
// Both fields are IP address fields in network-order.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_IP_ADDRESS
{
    DWORD       dwAddress;
    DWORD       dwMask;
} IPSAMPLE_IP_ADDRESS, *PIPSAMPLE_IP_ADDRESS;



//----------------------------------------------------------------------------
// macros for manipulating the variable-length IPSAMPLE_IF_BINDING structure
//
// IPSAMPLE_IF_BINDING_SIZE computes the size of a binding structure.
//
// IPSAMPLE_IF_ADDRESS_TABLE computes the starting address in a binding
//      struct of the series of IPSAMPLE_IP_ADDRESS structures which are
//      the bindings for the interface in question.
//
// e.g.
//      PIPSAMPLE_IF_BINDING piibSource, piibDest;
//
//      piibDest = malloc(IPSAMPLE_IF_BINDING_SIZE(piibSource));
//      memcpy(piibDest, piibSource, IPSAMPLE_IF_BINDING_SIZE(piibSource));
//
// e.g.
//      ULONG                   i;
//      PIPSAMPLE_IF_BINDING    piib;
//      PIPSAMPLE_IP_ADDRESS    *piia;
//
//      piia = IPSAMPLE_IF_ADDRESS_TABLE(piib);
//      for (i = 0; i < piib->ulCount; i++)
//      {
//          printf("%s-", inet_ntoa(*(struct in_addr *)&piia->dwAddress));
//          printf("%s\n", inet_ntoa(*(struct in_addr *)&piia->dwMask));
//      }
//----------------------------------------------------------------------------

#define IPSAMPLE_IF_BINDING_SIZE(bind)                          \
    (sizeof(IPSAMPLE_IF_BINDING) +                              \
     (bind)->ulCount * sizeof(IPSAMPLE_IP_ADDRESS))

#define IPSAMPLE_IF_ADDRESS_TABLE(bind)                         \
    ((PIPSAMPLE_IP_ADDRESS)((bind) + 1))

        

//----------------------------------------------------------------------------
// The following structures are used to query the MIB and get back a
// response.  The TypeID field is one of the IDs #defined above.  The
// IfIndex is used to reference an interface table entry .  For sample
// it corresponds to an ip address, and hence is a single DWORD for now.
// In general the index could be a variable size array of DWORDs.
//----------------------------------------------------------------------------

        

//----------------------------------------------------------------------------
// struct:      IPSAMPLE_MIB_SET_INPUT_DATA
//
// This is passed as input data for MibSet.
// Note that only global config and interface config can be set.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_MIB_SET_INPUT_DATA
{
    DWORD       IMSID_TypeID;
    DWORD       IMSID_IfIndex;
    DWORD       IMSID_BufferSize;
    BYTE        IMSID_Buffer[ANY_SIZE];
} IPSAMPLE_MIB_SET_INPUT_DATA, *PIPSAMPLE_MIB_SET_INPUT_DATA;



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_MIB_GET_INPUT_DATA
//
// This is passed as input data for MibGet, MibGetFirst, MibGetNext.  All
// tables are readable.  All IP addresses must be in network order.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_MIB_GET_INPUT_DATA
{
    DWORD   IMGID_TypeID;
    DWORD   IMGID_IfIndex;
} IPSAMPLE_MIB_GET_INPUT_DATA, *PIPSAMPLE_MIB_GET_INPUT_DATA;



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_MIB_GET_OUTPUT_DATA
//
// This is written into the output data by MibGet, MibGetFirst, MibGetNext.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_MIB_GET_OUTPUT_DATA
{
    DWORD   IMGOD_TypeID;
    DWORD   IMGOD_IfIndex;

    BYTE    IMGOD_Buffer[ANY_SIZE];
} IPSAMPLE_MIB_GET_OUTPUT_DATA, *PIPSAMPLE_MIB_GET_OUTPUT_DATA;

#endif // _IPSAMPLERM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\log.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\log.h

Abstract:

    This file is processed by mapmsg to produce a .mc file,
    then the .mc file is compiled by the message compiler,
    and the resulting binary is included in IPSAMPLE's resource file.

    Don't change the comments following the manifest constants
    without understanding how mapmsg works.

--*/

#define IPSAMPLELOG_BASE                        43000

#define IPSAMPLELOG_INIT_CRITSEC_FAILED         (IPSAMPLELOG_BASE + 1)
/*
 * SAMPLE was unable to initialize a critical section.
 * The data is the exception code.
 */

#define IPSAMPLELOG_CREATE_SEMAPHORE_FAILED     (IPSAMPLELOG_BASE + 2)
/*
 * SAMPLE was unable to create a semaphore.
 * The data is the error code.
 */

#define IPSAMPLELOG_CREATE_EVENT_FAILED         (IPSAMPLELOG_BASE + 3)
/*
 * SAMPLE was unable to create an event.
 * The data is the error code.
 */

#define IPSAMPLELOG_CREATE_RWL_FAILED           (IPSAMPLELOG_BASE + 4)
/*
 * SAMPLE was unable to create a synchronization object.
 * The data is the error code.
 */

#define IPSAMPLELOG_REGISTER_WAIT_FAILED        (IPSAMPLELOG_BASE + 5)
/*
 * IPSAMPLE could not register an event wait.
 * The data is the error code.
 */

#define IPSAMPLELOG_HEAP_CREATE_FAILED          (IPSAMPLELOG_BASE + 6)
/*
 * SAMPLE was unable to create a heap.
 * The data is the error code.
 */

#define IPSAMPLELOG_HEAP_ALLOC_FAILED           (IPSAMPLELOG_BASE + 7)
/*
 * SAMPLE was unable to allocate memory from its heap.
 * The data is the error code.
 */

#define IPSAMPLELOG_CREATE_HASHTABLE_FAILED     (IPSAMPLELOG_BASE + 8)
/*
 * SAMPLE was unable to create a hash table.
 * The data is the error code.
 */

#define IPSAMPLELOG_WSASTARTUP_FAILED           (IPSAMPLELOG_BASE + 9)
/*
 * SAMPLE was unable to start Windows Sockets.
 * The data is the error code.
 */

#define IPSAMPLELOG_CREATE_SOCKET_FAILED        (IPSAMPLELOG_BASE + 10)
/*
 * SAMPLE was unable to create a socket for the IP address %1.
 * The data is the error code.
 */

#define IPSAMPLELOG_DESTROY_SOCKET_FAILED       (IPSAMPLELOG_BASE + 11)
/*
 * SAMPLE was unable to close a socket.
 * The data is the error code.
 */

#define IPSAMPLELOG_EVENTSELECT_FAILED          (IPSAMPLELOG_BASE + 12)
/*
 * SAMPLE was unable to request notification of events on a socket.
 * The data is the error code.
 */

#define IPSAMPLELOG_BIND_IF_FAILED              (IPSAMPLELOG_BASE + 13)
/*
 * SAMPLE could not bind to the IP address %1.
 * Please make sure TCP/IP is installed and configured correctly.
 * The data is the error code.
 */

#define IPSAMPLELOG_RECVFROM_FAILED             (IPSAMPLELOG_BASE + 14)
/*
 * SAMPLE was unable to receive an incoming message on an interface.
 * The data is the error code.
 */

#define IPSAMPLELOG_SENDTO_FAILED               (IPSAMPLELOG_BASE + 15)
/*
 * SAMPLE was unable to send a packet on an interface.
 * The data is the error code.
 */

#define IPSAMPLELOG_SET_MCAST_IF_FAILED         (IPSAMPLELOG_BASE + 16)
/*
 * SAMPLE could not request multicasting
 * for the local interface with IP address %1.  
 * The data is the error code.
 */

#define IPSAMPLELOG_JOIN_GROUP_FAILED           (IPSAMPLELOG_BASE + 17)
/*
 * SAMPLE could not join the multicast group 224.0.0.100
 * on the local interface with IP address %1.
 * The data is the error code.
 */

#define IPSAMPLELOG_ENUM_NETWORK_EVENTS_FAILED  (IPSAMPLELOG_BASE + 18)
/*
 * IPSAMPLE was unable to enumerate network events on a local interface.
 * The data is the error code.
 */

#define IPSAMPLELOG_INPUT_RECORD_ERROR          (IPSAMPLELOG_BASE + 19)
/*
 * IPSAMPLE detected an error on a local interface.
 * The error occurred while the interface was receiving packets.
 * The data is the error code.
 */

#define IPSAMPLELOG_SAMPLE_STARTED              (IPSAMPLELOG_BASE + 20)
/*
 * SAMPLE has started successfully.
 */

#define IPSAMPLELOG_SAMPLE_ALREADY_STARTED      (IPSAMPLELOG_BASE + 21)
/*
 * SAMPLE received a start request when it was already running.
 */

#define IPSAMPLELOG_SAMPLE_START_FAILED         (IPSAMPLELOG_BASE + 22)
/*
 * SAMPLE failed to start
 */

#define IPSAMPLELOG_SAMPLE_STOPPED              (IPSAMPLELOG_BASE + 23)
/*
 * SAMPLE has stopped.
 */

#define IPSAMPLELOG_SAMPLE_ALREADY_STOPPED      (IPSAMPLELOG_BASE + 24)
/*
 * SAMPLE received a stop request when it was not running.
 */

#define IPSAMPLELOG_SAMPLE_STOP_FAILED          (IPSAMPLELOG_BASE + 25)
/*
 * SAMPLE failed to stop
 */

#define IPSAMPLELOG_CORRUPT_GLOBAL_CONFIG       (IPSAMPLELOG_BASE + 26)
/*
 * SAMPLE global configuration is corrupted.
 * The data is the error code.
 */

#define IPSAMPLELOG_RTM_REGISTER_FAILED         (IPSAMPLELOG_BASE + 27)
/*
 * SAMPLE was unable to register with the Routing Table Manager.
 * The data is the error code.
 */

#define IPSAMPLELOG_EVENT_QUEUE_EMPTY           (IPSAMPLELOG_BASE + 28)
/*
 * SAMPLE event queue is empty.
 * The data is the error code.
 */

#define IPSAMPLELOG_CREATE_TIMER_QUEUE_FAILED   (IPSAMPLELOG_BASE + 29)
/*
 * SAMPLE was unable to create the timer queue.
 * The data is the error code.
 */

#define IPSAMPLELOG_NETWORK_MODULE_ERROR        (IPSAMPLELOG_BASE + 30)
/*
 * SAMPLE encountered a problem in the Network Module.
 * The data is the error code.
 */

#define IPSAMPLELOG_CORRUPT_INTERFACE_CONFIG    (IPSAMPLELOG_BASE + 31)
/*
 * SAMPLE interface configuration is corrupted.
 */

#define IPSAMPLELOG_INTERFACE_PRESENT           (IPSAMPLELOG_BASE + 32)
/*
 * SAMPLE interface already exists.
 */

#define IPSAMPLELOG_INTERFACE_ABSENT            (IPSAMPLELOG_BASE + 33)
/*
 * SAMPLE interface does not exist.
 */

#define IPSAMPLELOG_PACKET_TOO_SMALL            (IPSAMPLELOG_BASE + 34)
/* SAMPLE received a packet which was smaller than the minimum size allowed
 * for SAMPLE packets. The packet has been discarded.  It was received on
 * the local interface with IP address %1, and it came from the neighboring
 * router with IP address %2.
 */

#define IPSAMPLELOG_PACKET_HEADER_CORRUPT       (IPSAMPLELOG_BASE + 35)
/*
 * SAMPLE received a packet with an invalid header. The packet has been
 * discarded. It was received on the local interface with IP address %1,
 * and it came from the neighboring router with IP address %2.
 */

#define IPSAMPLELOG_PACKET_VERSION_INVALID      (IPSAMPLELOG_BASE + 36)
/*
 * SAMPLE received a packet with an invalid version in its header.
 * The packet has been discarded. It was received on the local interface
 * with IP address %1, and it came from the neighboring router
 * with IP address %2.
 */ 

#define IPSAMPLELOG_TIMER_MODULE_ERROR          (IPSAMPLELOG_BASE + 37)
/*
 * SAMPLE encountered a problem in the Timer Module.
 * The data is the error code.
 */

#define IPSAMPLELOG_CREATE_TIMER_FAILED         (IPSAMPLELOG_BASE + 38)
/*
 * IPSAMPLE could not create a timer.
 * The data is the error code.
 */

#define IPSAMPLELOG_PROTOCOL_MODULE_ERROR       (IPSAMPLELOG_BASE + 39)
/*
 * SAMPLE encountered a problem in the Protocol Module.
 * The data is the error code.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\hashtable.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\hashtable.h

Abstract:

    The file contains the header for hashtable.c.

--*/

#ifndef _HASH_TABLE_H_
#define _HASH_TABLE_H_


typedef VOID (*PVOID_FUNCTION)
    (PLIST_ENTRY    pleEntry);

typedef PVOID_FUNCTION PDISPLAY_FUNCTION;

typedef PVOID_FUNCTION PFREE_FUNCTION;

typedef ULONG (*PHASH_FUNCTION) 
    (PLIST_ENTRY    pleEntry);

// < 0 KeyEntry less than TableEntry
//   0 KeyEntry identical TableEntry
// > 0 KeyEntry more than TableEntry
typedef LONG  (*PCOMPARE_FUNCTION)
    (PLIST_ENTRY    pleTableEntry,
     PLIST_ENTRY    pleKeyEntry);

typedef struct _HASH_TABLE
{
    ULONG               ulNumBuckets;   // # buckets in hash table
    ULONG               ulNumEntries;   // # entries in hash table

    PDISPLAY_FUNCTION   pfnDisplay;     // display an entry (optional) 
    PFREE_FUNCTION      pfnFree;        // free an entry
    PHASH_FUNCTION      pfnHash;        // hash an entry 
    PCOMPARE_FUNCTION   pfnCompare;     // compare two entries
    
    PLIST_ENTRY         pleBuckets;     // the buckets 
} HASH_TABLE, *PHASH_TABLE;



// Create the hash table
DWORD
HT_Create(
    IN  HANDLE              hHeap,
    IN  ULONG               ulNumBuckets,
    IN  PDISPLAY_FUNCTION   pfnDisplay  OPTIONAL,
    IN  PFREE_FUNCTION      pfnFree,
    IN  PHASH_FUNCTION      pfnHash,
    IN  PCOMPARE_FUNCTION   pfnCompare,
    OUT PHASH_TABLE         *pphtHashTable);

// Destroy the hash table
DWORD
HT_Destroy(
    IN  HANDLE              hHeap,
    IN  PHASH_TABLE         phtTable);

// Clean hash table by destroying all entries
DWORD
HT_Cleanup(
    IN  PHASH_TABLE         phtHashTable);

// Display all entries in the hash table
#define HT_Display(phtHashTable)                                    \
{                                                                   \
    if (phtHashTable)                                               \
        HT_MapCar(phtHashTable, phtHashTable->pfnDisplay);          \
}
    
// # entries in the hash table
#define HT_Size(phtHashTable)                           \
(                                                       \
    phtHashTable->ulNumEntries                          \
)

// Is hash table empty?
#define HT_IsEmpty(phtHashTable)                        \
(                                                       \
    HT_Size(phtHashTable) is 0                          \
)                                                        

// Inserts an entry in the hash table
DWORD
HT_InsertEntry(
    IN  PHASH_TABLE         phtHashTable,
    IN  PLIST_ENTRY         pleEntry);

// Gets the hash table entry with the given key
DWORD
HT_GetEntry(
    IN  PHASH_TABLE         phtHashTable,
    IN  PLIST_ENTRY         pleKey,
    OUT PLIST_ENTRY         *ppleEntry);

// Delete an entry from the hash table
DWORD
HT_DeleteEntry(
    IN  PHASH_TABLE         phtHashTable,
    IN  PLIST_ENTRY         pleKey,
    OUT PLIST_ENTRY         *ppleEntry);

// Remove this entry from the hash table
#define HT_RemoveEntry(phtHashTable, pleEntry)          \
(                                                       \
    RemoveEntryList(pleEntry)                           \
    phtHashTable->ulNumEntries--;                       \
)
    
DWORD
HT_DeleteEntry(
    IN  PHASH_TABLE         phtHashTable,
    IN  PLIST_ENTRY         pleKey,
    OUT PLIST_ENTRY         *ppleEntry);

// Is key present in the hash table?
BOOL
HT_IsPresentEntry(
    IN  PHASH_TABLE         phtHashTable,
    IN  PLIST_ENTRY         pleKey);

// Apply the specified function to all entries in the hash table
DWORD
HT_MapCar(
    IN  PHASH_TABLE         phtHashTable,
    IN  PVOID_FUNCTION      pfnVoidFunction);

#endif // _HASH_TABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\mibmgr.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\mibmanager.h

Abstract:

    The file contains the header for mib.c

Revision History:

    MohitT      June-15-1999    Created

--*/

#ifndef _MIBMANAGER_H_
#define _MIBMANAGER_H_

DWORD
WINAPI
MM_MibSet (
    IN      PIPSAMPLE_MIB_SET_INPUT_DATA    pimsid);

DWORD
WINAPI
MM_MibGet (
    IN      PIPSAMPLE_MIB_GET_INPUT_DATA    pimgid,
    OUT     PIPSAMPLE_MIB_GET_OUTPUT_DATA   pimgod,
    IN OUT  PULONG	                        pulOutputSize,
    IN      MODE                            mMode);

#endif // _MIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\networkentry.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\networkentry.h

Abstract:

    The file contains definitions for the network entry and associated data
    structures.

--*/

#ifndef _NETWORKENTRY_H_
#define _NETWORKENTRY_H_


//
// TYPE DEFINITIONS FOR INTERFACE MANAGEMENT
//

//
// struct:  BINDING_ENTRY
//
// stores interface bindings, ip addresses to which an interface is bound.
// all ip addresses are in network byte order.
//
// protected by the read-write lock NETWORK_ENTRY::rwlLock.
//

typedef struct _BINDING_ENTRY
{
    IPADDRESS               ipAddress;
    IPADDRESS               ipMask;
} BINDING_ENTRY, *PBINDING_ENTRY;

DWORD
BE_CreateTable (
    IN  PIP_ADAPTER_BINDING_INFO    pBinding,
    OUT PBINDING_ENTRY              *ppbeBindingTable,
    OUT PIPADDRESS                  pipLowestAddress);

DWORD
BE_DestroyTable (
    IN  PBINDING_ENTRY              pbeBindingTable);

#ifdef DEBUG
DWORD
BE_DisplayTable (
    IN  PBINDING_ENTRY              pbeBindingTable,
    IN  ULONG                       ulNumBindings);
#else
#define BE_Display(pbe)
#endif // DEBUG

//
// VOID
// BE_FindTable (
//     IN  PBINDING_ENTRY      pbeBindingTable,
//     IN  ULONG               ulNumBindings,
//     IN  IPADDRESS           ipAddress,
//     IN  IPADDRESS           ipMask,
//     OUT PULONG              pulIndex
//     );
//

#define BE_FindTable(table, num, address, mask, pindex)                 \
{                                                                       \
    for (*(pindex) = 0; *(pindex) < (num); (*(pindex))++)               \
        if (!IP_COMPARE((table)[*(pindex)].ipAddress, (address)) and    \
            !IP_COMPARE((table)[*(pindex)].ipMask, (mask)))             \
            break;                                                      \
}



//
// struct:  INTERFACE_ENTRY
//
// stores per-interface information.
// 
// protected by the read-write lock NETWORK_ENTRY::rwlLock.
//

// mib get modes

typedef enum { GET_EXACT, GET_FIRST, GET_NEXT } MODE;


typedef struct _INTERFACE_ENTRY
{
    // Hash Table Link (primary access structure)
    LIST_ENTRY              leInterfaceTableLink;

    // Index Sorted List Link (secondary access structure)
    LIST_ENTRY              leIndexSortedListLink;
    
    // Interface Name (logging)
    PWCHAR                  pwszIfName;
    
    // Interface Index
    DWORD                   dwIfIndex;

    // Interface Address Bindings
    ULONG                   ulNumBindings;
    PBINDING_ENTRY          pbeBindingTable;
    
    // Interface Flags ENABLED, BOUND, ACTIVE, MULTIACCESS
    DWORD                   dwFlags; 

    // Interface Address (lowest binding ip address for now) & Socket
    IPADDRESS               ipAddress;
    SOCKET                  sRawSocket;

    // Receive Event and Registered Wait
    HANDLE                  hReceiveEvent;
    HANDLE                  hReceiveWait;

    // Periodic Timer
    HANDLE                  hPeriodicTimer;
    
    // Interface Configuration
    DWORD                   ulMetric;

    // Interface Statistics
    IPSAMPLE_IF_STATS       iisStats;
} INTERFACE_ENTRY, *PINTERFACE_ENTRY;

#define IEFLAG_ACTIVE           0x00000001
#define IEFLAG_BOUND            0x00000002
#define IEFLAG_MULTIACCESS      0x00000004



#define INTERFACE_IS_ACTIVE(i)                              \
    ((i)->dwFlags & IEFLAG_ACTIVE) 

#define INTERFACE_IS_INACTIVE(i)                            \
    !INTERFACE_IS_ACTIVE(i)
        
#define INTERFACE_IS_BOUND(i)                               \
    ((i)->dwFlags & IEFLAG_BOUND) 

#define INTERFACE_IS_UNBOUND(i)                             \
    !INTERFACE_IS_BOUND(i)

#define INTERFACE_IS_MULTIACCESS(i)                         \
    ((i)->dwFlags & IEFLAG_MULTIACCESS) 

#define INTERFACE_IS_POINTTOPOINT(i)                        \
    !INTERFACE_IS_MULTIACCESS(i)


        
DWORD
IE_Create (
    IN  PWCHAR                      pwszIfName,
    IN  DWORD                       dwIfIndex,
    IN  WORD                        wAccessType,
    OUT PINTERFACE_ENTRY            *ppieInterfaceEntry);

DWORD
IE_Destroy (
    IN  PINTERFACE_ENTRY            pieInterfaceEntry);

#ifdef DEBUG
DWORD
IE_Display (
    IN  PINTERFACE_ENTRY            pieInterfaceEntry);
#else
#define IE_Display(pieInterfaceEntry)
#endif // DEBUG

DWORD
IE_Insert (
    IN  PINTERFACE_ENTRY            pieIfEntry);

DWORD
IE_Delete (
    IN  DWORD                       dwIfIndex,
    OUT PINTERFACE_ENTRY            *ppieIfEntry);

BOOL
IE_IsPresent (
    IN  DWORD                       dwIfIndex);

DWORD
IE_Get (
    IN  DWORD                       dwIfIndex,
    OUT PINTERFACE_ENTRY            *ppieIfEntry);

DWORD
IE_GetIndex (
    IN  DWORD                       dwIfIndex,
    IN  MODE                        mMode,
    OUT PINTERFACE_ENTRY            *ppieIfEntry);

DWORD
IE_BindInterface (
    IN  PINTERFACE_ENTRY            pie,
    IN  PIP_ADAPTER_BINDING_INFO    pBinding);

DWORD
IE_UnBindInterface (
    IN  PINTERFACE_ENTRY            pie);

DWORD
IE_ActivateInterface (
    IN  PINTERFACE_ENTRY            pie);

DWORD
IE_DeactivateInterface (
    IN  PINTERFACE_ENTRY            pie);




//
// struct:  NETWORK_ENTRY
//
// stores interface table and other network related information.
// the interface table is a hashed on the interface index.
//
// protected by the read-write lock NETWORK_ENTRY::rwlLock.
//
// must be acquired exclusively when entries are being added or deleted
// from the table, and when the states of entries are being changed.
//
// must be acquired non-exclusively on all other acceses.
//

typedef struct _NETWORK_ENTRY
{
    // Lock
    READ_WRITE_LOCK         rwlLock;
    
    PHASH_TABLE             phtInterfaceTable; // primary access structure
    LIST_ENTRY              leIndexSortedList; // secondary access structure
} NETWORK_ENTRY, *PNETWORK_ENTRY;



DWORD
NE_Create (
    OUT PNETWORK_ENTRY              *ppneNetworkEntry);

DWORD
NE_Destroy (
    IN  PNETWORK_ENTRY              pneNetworkEntry);

#ifdef DEBUG
DWORD
NE_Display (
    IN  PNETWORK_ENTRY              pneNetworkEntry);
#else
#define NE_Display(pneNetworkEntry)
#endif // DEBUG

#endif // _NETWORKENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\mibmgr.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\mibmanager.c

Abstract:

    The file contains IP Sample's MIB implementation.

Revision History:

    MohitT      June-15-1999    Created

--*/

#include "pchsample.h"
#pragma hdrstop


DWORD
WINAPI
MM_MibSet (
    IN      PIPSAMPLE_MIB_SET_INPUT_DATA    pimsid)
/*++

Routine Description
    Set IPSAMPLE's global or interface configuration.

Locks
    Acquires shared      (g_ce.pneNetworkEntry)->rwlLock
    Releases             (g_ce.pneNetworkEntry)->rwlLock

Arguments
    pimsid              input data, contains global/interface configuration
    
Return Value
    NO_ERROR            success
    Error Code          o/w
    
--*/
{
    DWORD                   dwErr = NO_ERROR;
    ROUTING_PROTOCOL_EVENTS rpeEvent;
    MESSAGE                 mMessage = {0, 0, 0};
    PINTERFACE_ENTRY        pie;

    if (!ENTER_SAMPLE_API()) { return ERROR_CAN_NOT_COMPLETE; }

    do                          // breakout loop
    {
        // set global configuration
        if (pimsid->IMSID_TypeID is IPSAMPLE_GLOBAL_CONFIG_ID)
        {
            if (pimsid->IMSID_BufferSize < sizeof(IPSAMPLE_GLOBAL_CONFIG))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            dwErr = CM_SetGlobalInfo((PVOID) pimsid->IMSID_Buffer);
            if (dwErr != NO_ERROR)
                break;

            rpeEvent = SAVE_GLOBAL_CONFIG_INFO;
        }
        // set interface configuration
        else if (pimsid->IMSID_TypeID is IPSAMPLE_IF_CONFIG_ID)
        {
            if (pimsid->IMSID_BufferSize < sizeof(IPSAMPLE_IF_CONFIG))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            dwErr = NM_SetInterfaceInfo(pimsid->IMSID_IfIndex,
                                        (PVOID) pimsid->IMSID_Buffer);
            if (dwErr != NO_ERROR)
                break;            

            rpeEvent                = SAVE_INTERFACE_CONFIG_INFO;
            mMessage.InterfaceIndex = pimsid->IMSID_IfIndex;
        }
        // error, unexpected type
        else
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        // notify router manager
        if (EnqueueEvent(rpeEvent, mMessage) is NO_ERROR)
            SetEvent(g_ce.hMgrNotificationEvent);

    } while(FALSE);


    LEAVE_SAMPLE_API();

    return dwErr;
}



DWORD
WINAPI
MM_MibGet (
    IN      PIPSAMPLE_MIB_GET_INPUT_DATA    pimgid,
    OUT     PIPSAMPLE_MIB_GET_OUTPUT_DATA   pimgod,
    IN OUT  PULONG	                        pulOutputSize,
    IN      MODE                            mMode)
/*++

Routine Description
    Handles the structure accesses required to read MIB data.  Supports
    three modes of querying: EXACT, FIRST, and NEXT, which correspond to
    MibGet(), MibGetFirst(), and MibGetNext() respectively.

Locks
    Acquires shared      (g_ce.pneNetworkEntry)->rwlLock
    Releases             (g_ce.pneNetworkEntry)->rwlLock

Arguments
    pimgid              input data
    pimgod              output buffer
    pulOutputSize       IN  size of output buffer given
                        OUT size of output buffer needed
    mMode               query type
    
Return Value
    NO_ERROR            success
    Error Code          o/w
    
--*/
{
    DWORD               dwErr           = NO_ERROR;
    ULONG               ulSizeGiven     = 0;
    ULONG               ulSizeNeeded    = 0;
    PINTERFACE_ENTRY    pie;

    
    if (!ENTER_SAMPLE_API()) { return ERROR_CAN_NOT_COMPLETE; }

    // compute the size of the buffer available for storing
    // returned structures (the size of IMGOD_Buffer)
    if (*pulOutputSize < sizeof(IPSAMPLE_MIB_GET_OUTPUT_DATA))
        ulSizeGiven = 0;
    else
        ulSizeGiven = *pulOutputSize - sizeof(IPSAMPLE_MIB_GET_OUTPUT_DATA);

    switch (pimgid->IMGID_TypeID)
    {
        // the global statistics struct is fixed-length.
        // there is a single instance.
        case IPSAMPLE_GLOBAL_STATS_ID:
        {
            PIPSAMPLE_GLOBAL_STATS pigsdst, pigssrc;
    
            // only GET_EXACT and GET_FIRST are valid for the
            // global stats object since there is only one entry
            if (mMode is GET_NEXT)
            {
                dwErr = ERROR_NO_MORE_ITEMS;
                break;
            }

            // set the output size required for this entry
            ulSizeNeeded = sizeof(IPSAMPLE_GLOBAL_STATS);

            // check that the output buffer is big enough
            if (ulSizeGiven < ulSizeNeeded)
            {
                dwErr = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            pimgod->IMGOD_TypeID = IPSAMPLE_GLOBAL_STATS_ID;

            // since access to this structure is synchronized through
            // locked increments/decrements, we must copy it field by field
            pigssrc = &(g_ce.igsStats);
            pigsdst = (PIPSAMPLE_GLOBAL_STATS) pimgod->IMGOD_Buffer;

            pigsdst->ulNumInterfaces = pigssrc->ulNumInterfaces;

            break;
        }

        // the global configuration structure may be of variable size.
        // there is a single instance.
        case IPSAMPLE_GLOBAL_CONFIG_ID:
        {
            // only GET_EXACT and GET_FIRST are valid for the
            // global configuration object since there is only one entry
            if (mMode is GET_NEXT)
            {
                dwErr = ERROR_NO_MORE_ITEMS;
                break;
            }

            // CM_GetGlobalInfo() decides whether the buffer size is
            // sufficient.  if so, it retrieves the global configuration.
            // either case it sets the required output buffer size.
            dwErr = CM_GetGlobalInfo ((PVOID) pimgod->IMGOD_Buffer,
                                      &ulSizeGiven,
                                      NULL,
                                      NULL,
                                      NULL);
            ulSizeNeeded = ulSizeGiven;

            // check that the output buffer was big enough
            if (dwErr != NO_ERROR)
                break;

            pimgod->IMGOD_TypeID = IPSAMPLE_GLOBAL_CONFIG_ID;
            
            break;
        }

        // the interface statistics struct is fixed-length.
        // there may be multiple instances.
        case IPSAMPLE_IF_STATS_ID:
        {
            PIPSAMPLE_IF_STATS  piisdst, piissrc;

            ACQUIRE_READ_LOCK(&(g_ce.pneNetworkEntry)->rwlLock);

            do                  // breakout loop
            {
                // retrieve the interface whose stats are to be read
                dwErr = IE_GetIndex(pimgid->IMGID_IfIndex,
                                    mMode,
                                    &pie);
                if (dwErr != NO_ERROR)
                    break;
                
                // set the output size required for this entry
                ulSizeNeeded = sizeof(IPSAMPLE_IF_STATS);

                // check that the output buffer is big enough
                if (ulSizeGiven < ulSizeNeeded)
                {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }

                pimgod->IMGOD_TypeID = IPSAMPLE_IF_STATS_ID;
                pimgod->IMGOD_IfIndex = pie->dwIfIndex;

                // access to this structure is synchronized through locked
                // increments/decrements, so we copy it field by field
                piissrc = &(pie->iisStats);
                piisdst = (PIPSAMPLE_IF_STATS) pimgod->IMGOD_Buffer;

                piisdst->ulNumPackets = piissrc->ulNumPackets;
            } while (FALSE);

            RELEASE_READ_LOCK(&(g_ce.pneNetworkEntry)->rwlLock);

            break;
        }

        // the interface configuration structure may be of variable size.
        // there may be multiple instances.
        case IPSAMPLE_IF_CONFIG_ID:
        {
            // get the queried interface's index
            ACQUIRE_READ_LOCK(&(g_ce.pneNetworkEntry)->rwlLock);

            do                  // breakout loop
            {
                dwErr = IE_GetIndex(pimgid->IMGID_IfIndex,
                                    mMode,
                                    &pie);
                if (dwErr != NO_ERROR)
                    break;

                // read lock acuired again, which is fine :)
                dwErr = NM_GetInterfaceInfo(pie->dwIfIndex,
                                            (PVOID) pimgod->IMGOD_Buffer,
                                            &ulSizeGiven,
                                            NULL,
                                            NULL,
                                            NULL);
                ulSizeNeeded = ulSizeGiven;

                // check that the output buffer was big enough
                if (dwErr != NO_ERROR)
                    break;
                
                pimgod->IMGOD_TypeID    = IPSAMPLE_IF_CONFIG_ID;
                pimgod->IMGOD_IfIndex   = pie->dwIfIndex;
            } while (FALSE);

            RELEASE_READ_LOCK(&(g_ce.pneNetworkEntry)->rwlLock);

            break;
        }

        // the interface binding structure is of variable size.
        // there may be multiple instances.
        case IPSAMPLE_IF_BINDING_ID:
        {
            PIPSAMPLE_IF_BINDING    piib;
            PIPSAMPLE_IP_ADDRESS    piia;

            ACQUIRE_READ_LOCK(&(g_ce.pneNetworkEntry)->rwlLock);

            do                  // breakout loop
            {
                // retrieve the interface whose stats are to be read
                dwErr = IE_GetIndex(pimgid->IMGID_IfIndex,
                                    mMode,
                                    &pie);
                if (dwErr != NO_ERROR)
                    break;
                
                // set the output size required for this entry
                ulSizeNeeded = sizeof(IPSAMPLE_IF_BINDING) +
                    pie->ulNumBindings * sizeof(IPSAMPLE_IP_ADDRESS);

                // check that the output buffer is big enough
                if (ulSizeGiven < ulSizeNeeded)
                {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }

                pimgod->IMGOD_TypeID    = IPSAMPLE_IF_BINDING_ID;
                pimgod->IMGOD_IfIndex   = pie->dwIfIndex;

                piib = (PIPSAMPLE_IF_BINDING) pimgod->IMGOD_Buffer;
                piia = IPSAMPLE_IF_ADDRESS_TABLE(piib);            

                if (INTERFACE_IS_ACTIVE(pie))
                    piib->dwState |= IPSAMPLE_STATE_ACTIVE;

                if (INTERFACE_IS_BOUND(pie))
                    piib->dwState |= IPSAMPLE_STATE_BOUND;

                piib->ulCount = pie->ulNumBindings;
                CopyMemory((PVOID) piia, // address,mask pairs
                           (PVOID) pie->pbeBindingTable, // ditto
                           pie->ulNumBindings * sizeof(IPSAMPLE_IP_ADDRESS));
            } while (FALSE);

            RELEASE_READ_LOCK(&(g_ce.pneNetworkEntry)->rwlLock);

            break;
        }

        default:
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
    }

    *pulOutputSize = sizeof(IPSAMPLE_MIB_GET_OUTPUT_DATA) + ulSizeNeeded;

    LEAVE_SAMPLE_API();

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\networkentry.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\networkentry.c

Abstract:

    The file contains functions to deal with the network entry and its
    associated data structures.

--*/

#include "pchsample.h"
#pragma hdrstop


DWORD
BE_CreateTable (
    IN  PIP_ADAPTER_BINDING_INFO    pBinding,
    OUT PBINDING_ENTRY              *ppbeBindingTable,
    OUT PIPADDRESS                  pipLowestAddress)
/*++

Routine Description
    Creates a table of binding entries and returns the binding with the
    lowest ip address.  Ensures that there is atleast one binding. 

Locks
    None

Arguments
    pBinding            structure containing info about addresses bindings 
    ppbeBindingTable    pointer to the binding table address
    pipLowestAddress    pointer to the lowest ip address in the binding
    
Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    ULONG               i;
    DWORD               dwErr = NO_ERROR;
    PBINDING_ENTRY      pbe; // scratch

    // validate parameters
    if (!pBinding or !ppbeBindingTable or !pipLowestAddress)
        return ERROR_INVALID_PARAMETER;

    // a binding already exists
    if (*ppbeBindingTable != NULL)
        return ERROR_INVALID_PARAMETER;

    IP_ASSIGN(pipLowestAddress, IP_HIGHEST);
    
    do                          // breakout loop
    {
        if (pBinding->AddressCount is 0)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            TRACE0(NETWORK, "Error, no bindings specified");
            break;
        }

        for (i = 0; i < pBinding->AddressCount; i++)
            if (!IP_VALID((pBinding->Address)[i].Address))
                break;
        if (i != pBinding->AddressCount)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            TRACE0(NETWORK, "Error, an invalid binding specified");
            break;
        }

        // allocate the binding table
        MALLOC(&pbe, pBinding->AddressCount * sizeof(BINDING_ENTRY), &dwErr);
        if (dwErr != NO_ERROR)
            break;

        for (i = 0; i < pBinding->AddressCount; i++)
        {
            // initialize fields
            IP_ASSIGN(&(pbe[i].ipAddress), (pBinding->Address)[i].Address);
            IP_ASSIGN(&(pbe[i].ipMask), pBinding->Address[i].Mask);

            // update lowest ip address
            if (IP_COMPARE(pbe[i].ipAddress, *pipLowestAddress) is -1)
                IP_ASSIGN(pipLowestAddress,pbe[i].ipAddress);
        }
        
        *ppbeBindingTable = pbe;

    } while (FALSE);

    return dwErr;
}



DWORD
BE_DestroyTable (
    IN  PBINDING_ENTRY              pbeBindingTable)
/*++

Routine Description
    Destroys a binding table.

Locks
    None.

Arguments
    pbeBindingTable     pointer to the table of binding entries
    
Return Value
    NO_ERROR            always

--*/
{
    if (!pbeBindingTable)
        return NO_ERROR;

    FREE(pbeBindingTable);

    return NO_ERROR;
}



#ifdef DEBUG
DWORD
BE_DisplayTable (
    IN  PBINDING_ENTRY              pbeBindingTable,
    IN  ULONG                       ulNumBindings)
/*++

Routine Description
    Displays a binding entry.

Locks
    None.

Arguments
    pbeBindingTable     pointer to the table of binding entries
    ulNumBindings       # binding entries in the table

Return Value
    NO_ERROR            always

--*/
{
    ULONG i;

    if (!pbeBindingTable)
        return NO_ERROR;
    
    for (i = 0; i < ulNumBindings; i++)
    {
        TRACE1(NETWORK, "ipAddress %s",
               INET_NTOA(pbeBindingTable[i].ipAddress));
        TRACE1(NETWORK, "ipMask %s",
               INET_NTOA(pbeBindingTable[i].ipMask));
    }

    return NO_ERROR;
}
#endif // DEBUG



#ifdef DEBUG
static
VOID
DisplayInterfaceEntry (
    IN  PLIST_ENTRY                 pleEntry)
/*++

Routine Description
    Displays an INTERFACE_ENTRY object.

Locks
    None

Arguments
    pleEntry            address of the 'leInterfaceTableLink' field

Return Value
    None

--*/
{
    IE_Display(CONTAINING_RECORD(pleEntry,
                                 INTERFACE_ENTRY,
                                 leInterfaceTableLink));
}
#else
#define DisplayInterfaceEntry       NULL
#endif // DEBUG                          
    


static
VOID
FreeInterfaceEntry (
    IN  PLIST_ENTRY                 pleEntry)
/*++

Routine Description
    Called by HT_Destroy, the destructor of the primary access structure.
    Removes an INTERFACE_ENTRY object from all secondary access structures.
    
Locks
    None

Arguments
    pleEntry            address of the 'leInterfaceTableLink' field

Return Value
    None

--*/
{
    PINTERFACE_ENTRY pie = NULL;

    pie = CONTAINING_RECORD(pleEntry, INTERFACE_ENTRY, leInterfaceTableLink);

    // remove from all secondary access structures.
    RemoveEntryList(&(pie->leIndexSortedListLink));

    // initialize pointers to indicate that the entry has been deleted
    InitializeListHead(&(pie->leInterfaceTableLink));
    InitializeListHead(&(pie->leIndexSortedListLink));

    IE_Destroy(pie);
}
    


static
ULONG
HashInterfaceEntry (
    IN  PLIST_ENTRY                 pleEntry)
/*++

Routine Description
    Computes the hash value of an INTERFACE_ENTRY object.

Locks
    None

Arguments
    pleEntry            address of the 'leInterfaceTableLink' field

Return Value
    None

--*/
{
    PINTERFACE_ENTRY pie = CONTAINING_RECORD(pleEntry,
                                             INTERFACE_ENTRY,
                                             leInterfaceTableLink);

    return (pie->dwIfIndex % INTERFACE_TABLE_BUCKETS);
}



static
LONG
CompareInterfaceEntry (
    IN  PLIST_ENTRY                 pleKeyEntry,
    IN  PLIST_ENTRY                 pleTableEntry)
/*++

Routine Description
    Compares the interface indices of two INTERFACE_ENTRY objects.

Locks
    None

Arguments
    pleTableEntry       address of the 'leInterfaceTableLink' fields   
    pleKeyEntry             within the two objects

Return Value
    None

--*/
{
    PINTERFACE_ENTRY pieA, pieB;
    pieA = CONTAINING_RECORD(pleKeyEntry,
                             INTERFACE_ENTRY,
                             leInterfaceTableLink);
    pieB = CONTAINING_RECORD(pleTableEntry,
                             INTERFACE_ENTRY,
                             leInterfaceTableLink);

    if (pieA->dwIfIndex < pieB->dwIfIndex)
        return -1;
    else if (pieA->dwIfIndex is pieB->dwIfIndex)
        return 0;
    else
        return 1;
}



#ifdef DEBUG
static
VOID
DisplayIndexInterfaceEntry (
    IN  PLIST_ENTRY                 pleEntry)
/*++

Routine Description
    Displays an INTERFACE_ENTRY object.

Locks
    None

Arguments
    pleEntry            address of the 'leIndexSortedListLink' field

Return Value
    None

--*/
{
    IE_Display(CONTAINING_RECORD(pleEntry,
                                 INTERFACE_ENTRY,
                                 leIndexSortedListLink));
}
#else
#define DisplayIndexInterfaceEntry  NULL
#endif // DEBUG



static
LONG
CompareIndexInterfaceEntry (
    IN  PLIST_ENTRY                 pleKeyEntry,
    IN  PLIST_ENTRY                 pleTableEntry)
/*++

Routine Description
    Compares the interface indices of two INTERFACE_ENTRY objects.

Locks
    None

Arguments
    pleTableEntry       address of the 'leIndexSortedListLink' fields   
    pleKeyEntry             within the two objects

Return Value
    None

--*/
{
    PINTERFACE_ENTRY pieA, pieB;
    pieA = CONTAINING_RECORD(pleKeyEntry,
                             INTERFACE_ENTRY,
                             leIndexSortedListLink);
    pieB = CONTAINING_RECORD(pleTableEntry,
                             INTERFACE_ENTRY,
                             leIndexSortedListLink);

    if (pieA->dwIfIndex < pieB->dwIfIndex)
        return -1;
    else if (pieA->dwIfIndex is pieB->dwIfIndex)
        return 0;
    else
        return 1;
}



DWORD
IE_Create (
    IN  PWCHAR                      pwszIfName,
    IN  DWORD                       dwIfIndex,
    IN  WORD                        wAccessType,
    OUT PINTERFACE_ENTRY            *ppieInterfaceEntry)
/*++

Routine Description
    Creates an interface entry.

Locks
    None

Arguments
    ppieInterfaceEntry  pointer to the interface entry address

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    DWORD               dwErr = NO_ERROR;
    ULONG               ulNameLength;
    PINTERFACE_ENTRY    pieEntry; // scratch
    
    // validate parameters
    if (!ppieInterfaceEntry)
        return ERROR_INVALID_PARAMETER;

    *ppieInterfaceEntry = NULL;
    
    do                          // breakout loop
    {
        // allocate and zero out the interface entry structure
        MALLOC(&pieEntry, sizeof(INTERFACE_ENTRY), &dwErr);
        if (dwErr != NO_ERROR)
            break;


        // initialize fields with default values
        
        InitializeListHead(&(pieEntry->leInterfaceTableLink));
        InitializeListHead(&(pieEntry->leIndexSortedListLink));

        // pieEntry->pwszIfName         = NULL;

        pieEntry->dwIfIndex             = dwIfIndex;

        // pieEntry->ulNumBindings      = 0;
        // pieEntry->pbeBindingTable    = NULL;
        

        // pieEntry->dwFlags            = 0; // disabled unbound pointtopoint
        if (wAccessType is IF_ACCESS_BROADCAST)
            pieEntry->dwFlags           |= IEFLAG_MULTIACCESS;
        
        IP_ASSIGN(&(pieEntry->ipAddress), IP_LOWEST);
        pieEntry->sRawSocket            = INVALID_SOCKET;

        // pieEntry->hReceiveEvent      = NULL;
        // pieEntry->hReceiveWait       = NULL;
        
        // pieEntry->hPeriodicTimer     = NULL;
        
        // pieEntry->ulMetric           = 0;
        
        // pieEntry->iisStats           zero'ed out


        // initialize name
        ulNameLength = wcslen(pwszIfName) + 1;
        MALLOC(&(pieEntry->pwszIfName), ulNameLength * sizeof(WCHAR), &dwErr);
        if(dwErr != NO_ERROR)
            break;
        wcscpy(pieEntry->pwszIfName, pwszIfName);


        // initialize   ReceiveEvent (signalled when input arrives).
        // Auto-Reset Event: state automatically reset to nonsignaled after
        // a single waiting thread is released.  Initially non signalled
        pieEntry->hReceiveEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (pieEntry->hReceiveEvent is NULL)
        {
            dwErr = GetLastError();
            TRACE1(NETWORK, "Error %u creating Receive Event", dwErr);
            LOGERR0(CREATE_EVENT_FAILED, dwErr);

            break;
        }


        // register     ReceiveWait for this interface
        if (!RegisterWaitForSingleObject(&(pieEntry->hReceiveWait),
                                         pieEntry->hReceiveEvent,
                                         NM_CallbackNetworkEvent,
                                         (PVOID) dwIfIndex,
                                         INFINITE,
                                         WT_EXECUTEONLYONCE))
        {
            dwErr = GetLastError();
            TRACE1(NETWORK, "Error %u registering ReceiveWait", dwErr);
            LOGERR0(REGISTER_WAIT_FAILED, dwErr);

            break;
        }

        
        *ppieInterfaceEntry = pieEntry; // all's well :)
    } while (FALSE);

    if (dwErr != NO_ERROR)
    {
        // something went wrong, so cleanup.
        TRACE2(NETWORK, "Failed to create interface entry for %S (%u)",
               pwszIfName, dwIfIndex);
        IE_Destroy(pieEntry);
    }

    return dwErr;
}



DWORD
IE_Destroy (
    IN  PINTERFACE_ENTRY            pieInterfaceEntry)
/*++

Routine Description
    Destroys an interface entry.

Locks
    Assumes exclusive access to the entry by virute of it having been
    removed from all access data structures (lists, tables, ...)
    
    NOTE: Should NOT be called with g_ce.neNetworkEntry.rwlLock held!  The
    call to UnregisterWaitEx blocks till all queued callbacks for
    pieInterfaceEntry->hReceiveEvent finish execution.  These callbacks may
    acquire g_ce.neNetworkEntry.rwlLock, causing deadlock.

Arguments
    pieInterfaceEntry   pointer to the interface entry

Return Value
    NO_ERROR            always

--*/
{
    if (!pieInterfaceEntry)
        return NO_ERROR;

    if (INTERFACE_IS_BOUND(pieInterfaceEntry))
        IE_UnBindInterface(pieInterfaceEntry);

    if (INTERFACE_IS_ACTIVE(pieInterfaceEntry))
        IE_DeactivateInterface(pieInterfaceEntry);


    // PeriodicTimer should have been destroyed
    RTASSERT(pieInterfaceEntry->hPeriodicTimer is NULL);
    
    // deregister   ReceiveWait
    if (pieInterfaceEntry->hReceiveWait)
        UnregisterWaitEx(pieInterfaceEntry->hReceiveWait,
                         INVALID_HANDLE_VALUE);
    
    // delete       ReceiveEvent
    if (pieInterfaceEntry->hReceiveEvent)
        CloseHandle(pieInterfaceEntry->hReceiveEvent);
    
    // BindingTable and RawSocket should have been destroyed
    RTASSERT(pieInterfaceEntry->pbeBindingTable is NULL);
    RTASSERT(pieInterfaceEntry->sRawSocket is INVALID_SOCKET);
             
    // delete       IfName
    FREE(pieInterfaceEntry->pwszIfName);

    // Entry should have been removed from all access structures
    RTASSERT(IsListEmpty(&(pieInterfaceEntry->leInterfaceTableLink)));
    RTASSERT(IsListEmpty(&(pieInterfaceEntry->leIndexSortedListLink)));
    
    // deallocate the interface entry structure
    FREE(pieInterfaceEntry);
    
    return NO_ERROR;
}



#ifdef DEBUG
DWORD
IE_Display (
    IN  PINTERFACE_ENTRY            pieInterfaceEntry)
/*++

Routine Description
    Displays an interface entry.

Locks
    Assumes the interface entry is locked for reading.

Arguments
    pieInterfaceEntry   pointer to the interface entry to be displayed

Return Value
    NO_ERROR            always

--*/
{
    if (!pieInterfaceEntry)
        return NO_ERROR;

    TRACE3(NETWORK,
           "IfName %S, IfIndex %u, AccessType %u",
           pieInterfaceEntry->pwszIfName,
           pieInterfaceEntry->dwIfIndex,
           INTERFACE_IS_MULTIACCESS(pieInterfaceEntry));

    TRACE1(NETWORK, "NumBindings %u", pieInterfaceEntry->ulNumBindings);
    BE_DisplayTable(pieInterfaceEntry->pbeBindingTable,
                    pieInterfaceEntry->ulNumBindings);

    TRACE2(NETWORK,
           "IfAddress %s Flags %u",
           INET_NTOA(pieInterfaceEntry->ipAddress),
           pieInterfaceEntry->dwFlags);

    TRACE2(NETWORK,
           "Metric %u, NumPackets %u",
           pieInterfaceEntry->ulMetric,
           pieInterfaceEntry->iisStats.ulNumPackets);
    
    return NO_ERROR;
}
#endif // DEBUG



DWORD
IE_Insert (
    IN  PINTERFACE_ENTRY            pieIfEntry)
/*++

Routine Description
    Inserts an interface entry in all access structures,
    primary and secondary.

Locks
    Assumes exclusive access to the interface table and index sorted list
    i.e. (g_ce.pneNetworkEntry)->rwlLock held in write mode.

Arguments
    pieIfEntry              pointer to the interface entry

Return Value
    NO_ERROR                success
    ERROR_INVALID_PARAMETER o/w (interface entry already exists)

--*/
{
    DWORD dwErr = NO_ERROR;

    do                          // breakout loop
    {
        dwErr = HT_InsertEntry((g_ce.pneNetworkEntry)->phtInterfaceTable,
                               &(pieIfEntry->leInterfaceTableLink));
        if (dwErr != NO_ERROR)
        {
            TRACE2(NETWORK, "Error interface %S (%u) already exists",
                   pieIfEntry->pwszIfName, pieIfEntry->dwIfIndex);
            LOGERR0(INTERFACE_PRESENT, dwErr);
            break;
        }
        
        // insert in all tables, lists...
        InsertSortedList(&((g_ce.pneNetworkEntry)->leIndexSortedList),
                         &(pieIfEntry->leIndexSortedListLink),
                         CompareIndexInterfaceEntry);
    } while (FALSE);
    
    return dwErr;
}



DWORD
IE_Delete (
    IN  DWORD                       dwIfIndex,
    OUT PINTERFACE_ENTRY            *ppieIfEntry)
/*++

Routine Description
    Deletes an interface entry from all access structures,
    primary and secondary.

Locks
    Assumes exclusive access to the interface table and index sorted list
    i.e. (g_ce.pneNetworkEntry)->rwlLock held in write mode.

Arguments
    dwIfIndex       the positive integer used to identify the interface.
    ppieIfEntry     address of the pointer to the interface entry

Return Value
    NO_ERROR                success
    ERROR_INVALID_PARAMETER o/w (interface entry does not exist)

--*/
{
    DWORD           dwErr           = NO_ERROR;
    INTERFACE_ENTRY ieKey;
    PLIST_ENTRY     pleListEntry    = NULL;

    *ppieIfEntry = NULL;
    
    do                          // breakout loop
    {
        // remove from interface table (primary)
        ZeroMemory(&ieKey, sizeof(INTERFACE_ENTRY));
        ieKey.dwIfIndex = dwIfIndex;

        dwErr = HT_DeleteEntry((g_ce.pneNetworkEntry)->phtInterfaceTable,
                               &(ieKey.leInterfaceTableLink),
                               &pleListEntry);
        if (dwErr != NO_ERROR)
        {
            TRACE1(NETWORK, "Error interface %u has vanished", dwIfIndex);
            LOGWARN0(INTERFACE_ABSENT, dwErr);
            break;
        }

        *ppieIfEntry = CONTAINING_RECORD(pleListEntry,
                                         INTERFACE_ENTRY,
                                         leInterfaceTableLink);

        // remove from all other tables, lists... (secondary)
        RemoveEntryList(&((*ppieIfEntry)->leIndexSortedListLink));

        // initialize pointers to indicate that the entry has been deleted
        InitializeListHead(&((*ppieIfEntry)->leInterfaceTableLink));
        InitializeListHead(&((*ppieIfEntry)->leIndexSortedListLink));
    } while (FALSE);
    
    return dwErr;
}



BOOL
IE_IsPresent (
    IN  DWORD                       dwIfIndex)
/*++

Routine Description
    Is interface entry present in interface table?

Locks
    Assumes shared access to the interface table
    i.e. (g_ce.pneNetworkEntry)->rwlLock held in read mode.

Arguments
    dwIfIndex       the positive integer used to identify the interface.

Return Value
    TRUE            entry present
    FALSE           o/w

--*/
{
    DWORD           dwErr = NO_ERROR;
    INTERFACE_ENTRY ieKey;

    ZeroMemory(&ieKey, sizeof(INTERFACE_ENTRY));
    ieKey.dwIfIndex = dwIfIndex;
    
    return HT_IsPresentEntry((g_ce.pneNetworkEntry)->phtInterfaceTable,
                             &(ieKey.leInterfaceTableLink));
}



DWORD
IE_Get (
    IN  DWORD                       dwIfIndex,
    OUT PINTERFACE_ENTRY            *ppieIfEntry)
/*++

Routine Description
    Retrieves an interface entry from the interface table,
    the primary address strucutre.

Locks
    Assumes shared access to the interface table
    i.e. (g_ce.pneNetworkEntry)->rwlLock held in read mode.

Arguments
    dwIfIndex       the positive integer used to identify the interface.
    ppieIfEntry     address of the pointer to the interface entry

Return Value
    NO_ERROR                success
    ERROR_INVALID_PARAMETER o/w (interface entry does not exist)

--*/
{
    DWORD           dwErr           = NO_ERROR;
    INTERFACE_ENTRY ieKey;
    PLIST_ENTRY     pleListEntry    = NULL;

    *ppieIfEntry = NULL;
    
    do                          // breakout loop
    {
        ZeroMemory(&ieKey, sizeof(INTERFACE_ENTRY));
        ieKey.dwIfIndex = dwIfIndex;

        dwErr = HT_GetEntry((g_ce.pneNetworkEntry)->phtInterfaceTable,
                            &(ieKey.leInterfaceTableLink),
                            &pleListEntry);

        if (dwErr != NO_ERROR)
        {
            TRACE1(NETWORK, "Error interface %u has vanished", dwIfIndex);
            LOGWARN0(INTERFACE_ABSENT, dwErr);
            break;
        }

        *ppieIfEntry = CONTAINING_RECORD(pleListEntry,
                                         INTERFACE_ENTRY,
                                         leInterfaceTableLink);
    } while (FALSE);
    
    return dwErr;
}



DWORD
IE_GetIndex (
    IN  DWORD                       dwIfIndex,
    IN  MODE                        mMode,
    OUT PINTERFACE_ENTRY            *ppieIfEntry)
/*++

Routine Description
    Retrieves an interface entry from the index sorted list,
    the secondary address strucutre.

Locks
    Assumes shared access to the index sorted list
    i.e. (g_ce.pneNetworkEntry)->rwlLock held in read mode.

Arguments
    dwIfIndex       the positive integer used to identify the interface.
    mMode           mode of access (GET_EXACT, GET_FIRST, GET_NEXT)
    ppieIfEntry     address of the pointer to the interface entry

Return Value
    NO_ERROR                success
    ERROR_NO_MORE_ITEMS     o/w 

--*/
{
    INTERFACE_ENTRY ieKey;
    PLIST_ENTRY     pleHead = NULL, pleEntry = NULL;

    *ppieIfEntry = NULL;

    pleHead = &((g_ce.pneNetworkEntry)->leIndexSortedList);
    
    if (IsListEmpty(pleHead))
        return ERROR_NO_MORE_ITEMS;

    ZeroMemory(&ieKey, sizeof(INTERFACE_ENTRY));
    ieKey.dwIfIndex = (mMode is GET_FIRST) ? 0 : dwIfIndex;

    // this either gets the exact match or the next entry
    FindSortedList(pleHead,
                   &(ieKey.leIndexSortedListLink),
                   &pleEntry,
                   CompareIndexInterfaceEntry);

    // reached end of list
    if (pleEntry is NULL)
    {
        RTASSERT(mMode != GET_FIRST); // should have got the first entry
        return ERROR_NO_MORE_ITEMS;
    }

    *ppieIfEntry = CONTAINING_RECORD(pleEntry,
                                     INTERFACE_ENTRY,
                                     leIndexSortedListLink);

    switch (mMode)
    {
        case GET_FIRST:
            return NO_ERROR;
            
        case GET_EXACT:
            // found an exact match
            if ((*ppieIfEntry)->dwIfIndex is dwIfIndex)
                return NO_ERROR;
            else
            {
                *ppieIfEntry = NULL;
                return ERROR_NO_MORE_ITEMS;
            }

        case GET_NEXT:
            // found an exact match
            if ((*ppieIfEntry)->dwIfIndex is dwIfIndex)
            {
                pleEntry = pleEntry->Flink; // get next entry
                if (pleEntry is pleHead)    // end of list
                {
                    *ppieIfEntry = NULL;
                    return ERROR_NO_MORE_ITEMS;
                }

                *ppieIfEntry = CONTAINING_RECORD(pleEntry,
                                                 INTERFACE_ENTRY,
                                                 leIndexSortedListLink);
            }

            return NO_ERROR;

        default:
            RTASSERT(FALSE);    // never reached
    }
}



DWORD
IE_BindInterface (
    IN  PINTERFACE_ENTRY            pie,
    IN  PIP_ADAPTER_BINDING_INFO    pBinding)
/*++

Routine Description
    Binds an interface.
    
Locks
    Assumes the interface entry is locked for writing.
    
Arguments
    pie                 pointer to the interface entry
    pBinding            info about the addresses on the interface

Return Value
    NO_ERROR            success
    Error Code          o/w

--*/
{
    DWORD   dwErr = NO_ERROR;
    ULONG   i, j;
    
    do                          // breakout loop
    {
        // fail if the interface is already bound
        if (INTERFACE_IS_BOUND(pie))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            TRACE2(NETWORK, "Error interface %S (%u) is already bound",
                   pie->pwszIfName, pie->dwIfIndex);
            break;
        }


        dwErr = BE_CreateTable (pBinding,
                                &(pie->pbeBindingTable),
                                &(pie->ipAddress));
        if (dwErr != NO_ERROR)
            break;

        pie->ulNumBindings = pBinding->AddressCount;

        // set the "bound" flag
        pie->dwFlags |= IEFLAG_BOUND;
    } while (FALSE);
    
    return dwErr;
}



DWORD
IE_UnBindInterface (
    IN  PINTERFACE_ENTRY            pie)
/*++

Routine Description
    UnBinds an interface.
    
Locks
    Assumes the interface entry is locked for writing.
    
Arguments
    pie                 pointer to the interface entry

Return Value
    NO_ERROR            success
    Error Code          o/w

--*/
{
    DWORD   dwErr = NO_ERROR;
    
    do                          // breakout loop
    {
        // fail if the interface is already unbound
        if (INTERFACE_IS_UNBOUND(pie))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            TRACE2(NETWORK, "interface %S (%u) already unbound",
                   pie->pwszIfName, pie->dwIfIndex);
            break;
        }

        // clear the "bound" flag
        pie->dwFlags &= ~IEFLAG_BOUND;        

        IP_ASSIGN(&(pie->ipAddress), IP_LOWEST);
        
        BE_DestroyTable(pie->pbeBindingTable);
        pie->pbeBindingTable    = NULL;
        pie->ulNumBindings      = 0;
    } while (FALSE);

    return dwErr;
}



DWORD
IE_ActivateInterface (
    IN  PINTERFACE_ENTRY            pie)
/*++

Routine Description
    Activates an interface by creating a socket and starting a timer.
    The socket is bound to the interface address.
    Interface is assumed to have atleast one binding.

Locks
    Assumes the interface entry is locked for writing.
    
Arguments
    pie                 pointer to the interface entry

Return Value
    NO_ERROR            success
    Error Code          o/w

--*/
{
    DWORD   dwErr = NO_ERROR;
    
    do                          // breakout loop
    {
        // fail if the interface is already active
        if (INTERFACE_IS_ACTIVE(pie))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            TRACE0(NETWORK, "Interface already active");
            break;
        }

        // set the "active" flag
        pie->dwFlags |= IEFLAG_ACTIVE;                
        
        // create a socket for the interface
        dwErr = SocketCreate(pie->ipAddress,
                             pie->hReceiveEvent,
                             &(pie->sRawSocket));
        if (dwErr != NO_ERROR)
        {
            TRACE1(NETWORK, "Error creating socket for %s",
                   INET_NTOA(pie->ipAddress));
            break;
        }
        
        // start timer for sending protocol packets
        CREATE_TIMER(&pie->hPeriodicTimer ,
                     NM_CallbackPeriodicTimer,
                     (PVOID) pie->dwIfIndex,
                     PERIODIC_INTERVAL,
                     &dwErr);
        if (dwErr != NO_ERROR)
            break;
    } while (FALSE);

    if (dwErr != NO_ERROR)
    {
        TRACE3(NETWORK, "Error %u activating interface %S (%u)",
               dwErr, pie->pwszIfName, pie->dwIfIndex);
        IE_DeactivateInterface(pie);
    }
 
    return dwErr;
}



DWORD
IE_DeactivateInterface (
    IN  PINTERFACE_ENTRY            pie)
/*++

Routine Description
    Deactivates an interface by stopping the timer and destroying the socket.
    
Locks
    Assumes the interface entry is locked for writing.
    
Arguments
    pie                 pointer to the interface entry

Return Value
    NO_ERROR            success
    Error Code          o/w

--*/
{
    DWORD   dwErr = NO_ERROR;
    
    do                          // breakout loop
    {
        // fail if the interface is already inactive
        if (INTERFACE_IS_INACTIVE(pie))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            TRACE2(NETWORK, "interface %S (%u) already inactive",
                   pie->pwszIfName, pie->dwIfIndex);
            break;
        }

        // stop the timer 
        if (pie->hPeriodicTimer)
            DELETE_TIMER(pie->hPeriodicTimer, &dwErr);
        pie->hPeriodicTimer = NULL;

        // destroy the socket for the interface
        dwErr = SocketDestroy(pie->sRawSocket);
        pie->sRawSocket     = INVALID_SOCKET;

        // clear the "active" flag
        pie->dwFlags &= ~IEFLAG_ACTIVE;        
    } while (FALSE);

    return dwErr;
}



DWORD
NE_Create (
    OUT PNETWORK_ENTRY              *ppneNetworkEntry)
/*++

Routine Description
    Creates a network entry.

Locks
    None

Arguments
    ppneNetworkEntry    pointer to the network entry address

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    DWORD           dwErr = NO_ERROR;
    PNETWORK_ENTRY  pneEntry;   // scratch
    
    // validate parameters
    if (!ppneNetworkEntry)
        return ERROR_INVALID_PARAMETER;

    *ppneNetworkEntry = NULL;
    
    do                          // breakout loop
    {
        // allocate and zero out the network entry structure
        MALLOC(&pneEntry, sizeof(NETWORK_ENTRY), &dwErr);
        if (dwErr != NO_ERROR)
            break;


        // initialize fields with default values

        // pneEntry->rwlLock                zero'ed out
        
        // pneEntry->phtInterfaceTable      = NULL;

        InitializeListHead(&(pneEntry->leIndexSortedList));
        
        
        // initialize the read-write lock
        dwErr = CREATE_READ_WRITE_LOCK(&(pneEntry->rwlLock));
        if (dwErr != NO_ERROR)
        {
            TRACE1(NETWORK, "Error %u creating read-write-lock", dwErr);
            LOGERR0(CREATE_RWL_FAILED, dwErr);
            
            break;
        }


        // allocate the interface table
        dwErr = HT_Create(GLOBAL_HEAP,
                          INTERFACE_TABLE_BUCKETS,
                          DisplayInterfaceEntry,
                          FreeInterfaceEntry,
                          HashInterfaceEntry,
                          CompareInterfaceEntry,
                          &(pneEntry->phtInterfaceTable));
        if (dwErr != NO_ERROR)
        {
            TRACE1(NETWORK, "Error %u creating hash-table", dwErr);
            LOGERR0(CREATE_HASHTABLE_FAILED, dwErr);
            
            break;
        }


        *ppneNetworkEntry = pneEntry;
    } while (FALSE);

    if (dwErr != NO_ERROR)
    {
        // something went wrong, so cleanup.
        TRACE0(NETWORK, "Failed to create nework entry");
        NE_Destroy(pneEntry);
        pneEntry = NULL;
    }

    return dwErr;
}



DWORD
NE_Destroy (
    IN  PNETWORK_ENTRY              pneNetworkEntry)
/*++

Routine Description
    Destroys a network entry.

Locks
    Assumes exclusive access to rwlLock by virtue of of no competing threads.

Arguments
    pneNetworkEntry     pointer to the network entry

Return Value
    NO_ERROR            always

--*/
{
    if (!pneNetworkEntry)
        return NO_ERROR;

    // deallocate the interface table...
    // this removes the interface entries from all secondary access
    // structures (IndexSortedList, ...) as well since all of them
    // share interface entries by containing pointers to the same object.
    HT_Destroy(GLOBAL_HEAP, pneNetworkEntry->phtInterfaceTable);
    pneNetworkEntry->phtInterfaceTable = NULL;

    RTASSERT(IsListEmpty(&(pneNetworkEntry->leIndexSortedList)));
    
    // delete read-write-lock
    if (READ_WRITE_LOCK_CREATED(&(pneNetworkEntry->rwlLock)))
        DELETE_READ_WRITE_LOCK(&(pneNetworkEntry->rwlLock));

    // deallocate the network entry structure
    FREE(pneNetworkEntry);
    
    return NO_ERROR;
}



#ifdef DEBUG
DWORD
NE_Display (
    IN  PNETWORK_ENTRY              pneNetworkEntry)
/*++

Routine Description
    Displays a network entry.

Locks
    Acquires shared pneNetworkEntry->rwlLock
    Releases        pneNetworkEntry->rwlLock

Arguments
    pne                 pointer to the network entry to be displayed

Return Value
    NO_ERROR            always

--*/
{
    if (!pneNetworkEntry)
        return NO_ERROR;


    ACQUIRE_READ_LOCK(&(pneNetworkEntry->rwlLock));

    TRACE0(NETWORK, "Network Entry...");

    TRACE1(NETWORK,
           "Interface Table Size %u",
           HT_Size(pneNetworkEntry->phtInterfaceTable));

    TRACE0(NETWORK, "Interface Table...");
    HT_Display(pneNetworkEntry->phtInterfaceTable);

    TRACE0(NETWORK, "Index Sorted List...");
    MapCarList(&(pneNetworkEntry->leIndexSortedList),
               DisplayIndexInterfaceEntry);
    
    RELEASE_READ_LOCK(&(pneNetworkEntry->rwlLock));

        
    return NO_ERROR;
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\networkmgr.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\networkmanager.h

Abstract:

    The file contains the interface to the network manager.

--*/

#ifndef _NETWORK_MANAGER_H_
#define _NETWORK_MANAGER_H_


VOID
WINAPI
NM_CallbackNetworkEvent (
    IN  PVOID                   pvContext,
    IN  BOOLEAN                 bTimerOrWaitFired);

VOID
WINAPI
NM_CallbackPeriodicTimer (
    IN  PVOID                   pvContext,
    IN  BOOLEAN                 bTimerOrWaitFired);



DWORD
NM_AddInterface (
    IN  LPWSTR                  pwszInterfaceName,
    IN  DWORD	                dwInterfaceIndex,
    IN  WORD                    wAccessType,
    IN  PVOID	                pvInterfaceInfo);

DWORD
NM_DeleteInterface (
    IN  DWORD                   dwInterfaceIndex);

DWORD
NM_InterfaceStatus (
    IN DWORD                    dwInterfaceIndex,
    IN BOOL                     bInterfaceActive,
    IN DWORD                    dwStatusType,
    IN PVOID                    pvStatusInfo);

DWORD
NM_GetInterfaceInfo (
    IN      DWORD               dwInterfaceIndex,
    IN      PVOID               pvInterfaceInfo,
    IN  OUT PULONG              pulBufferSize,
    OUT     PULONG	            pulStructureVersion,
    OUT     PULONG	            pulStructureSize,
    OUT     PULONG	            pulStructureCount);

DWORD
NM_SetInterfaceInfo (
    IN      DWORD               dwInterfaceIndex,
    IN      PVOID               pvInterfaceInfo);



DWORD
NM_DoUpdateRoutes (
    IN      DWORD               dwInterfaceIndex
    );



DWORD
NM_ProcessRouteChange (
    VOID);

#endif // _NETWORK_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\networkmgr.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\networkmanager.c

Abstract:

    The file contains network configuration related functions,
    implementing the network manager.

    NOTE: The network manager should never take the configuration entry
          lock (g_ce.rwlLock).
    . the protocol manager never modifies any g_ce field protected by it
    . the network manager never modifies any g_ce field protected by it
    . the configuration manager never cleans up any g_ce field as long as
      there are active threads

--*/

#include "pchsample.h"
#pragma hdrstop


BOOL
ValidateInterfaceConfig (
    IN  PIPSAMPLE_IF_CONFIG piic)
/*++

Routine Description
    Checks to see if the interface configuration is OK. It is good practice
    to do this because a corrupt registry can change configuration causing
    all sorts of debugging headaches if it is not found early

Locks
    None

Arguments
    piic                pointer to ip sample interface's configuration

Return Value
    TRUE                if the configuration is good
    FALSE               o/w

--*/
{
    DWORD dwErr = NO_ERROR;

    do                          // breakout loop
    {
        if (piic is NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            TRACE0(NETWORK, "Error null interface config");

            break;
        }

        //
        // check range of each field
        //

        // ensure that the metric is within bounds

        if (piic->ulMetric > IPSAMPLE_METRIC_INFINITE)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            TRACE0(NETWORK, "Error metric out of range");

            break;
        }

        // ensure that protocol flags are fine, for now they'll always be
        
        
        // add more here...

    } while (FALSE);

    if (!(dwErr is NO_ERROR))
    {
        TRACE0(NETWORK, "Error corrupt interface config");
        LOGERR0(CORRUPT_INTERFACE_CONFIG, dwErr);

        return FALSE;
    }

    return TRUE;
}


////////////////////////////////////////
// CALLBACKFUNCTIONS
////////////////////////////////////////

VOID
WINAPI
NM_CallbackNetworkEvent (
    IN  PVOID                   pvContext,
    IN  BOOLEAN                 bTimerOrWaitFired)
/*++

Routine Description
    Processes a network event on the specified interface.
    NOTE: The interface might have been deleted.

Locks
    Acquires shared      (g_ce.pneNetworkEntry)->rwlLock
    Releases             (g_ce.pneNetworkEntry)->rwlLock

Arguments
    pvContext           dwIfIndex

Return Value
   None

--*/
{
    DWORD               dwErr               = NO_ERROR;
    DWORD               dwIfIndex           = 0;
    PINTERFACE_ENTRY    pieInterfaceEntry   = NULL;
    PACKET              Packet;

    dwIfIndex = (DWORD) pvContext;
    
    TRACE1(ENTER, "Entering NM_CallbackNetworkEvent: %u", dwIfIndex);

    if (!ENTER_SAMPLE_API()) { return; } // cannot return anything


    ACQUIRE_READ_LOCK(&((g_ce.pneNetworkEntry)->rwlLock));

    do                          // breakout loop
    {
        // fail if the interface does not exist
        dwErr = IE_Get(dwIfIndex, &pieInterfaceEntry);
        if (dwErr != NO_ERROR)
            break;

        // fail if interface is inactive
        if (!INTERFACE_IS_ACTIVE(pieInterfaceEntry))
        {
            TRACE1(NETWORK, "Error interface %u is inactive", dwIfIndex);
            break;
        }

        RTASSERT(pieInterfaceEntry->sRawSocket != INVALID_SOCKET);
        
        if (SocketReceiveEvent(pieInterfaceEntry->sRawSocket))
        {
            if (SocketReceive(pieInterfaceEntry->sRawSocket,
                              &Packet) is NO_ERROR)
                PacketDisplay(&Packet);
        }
        else
        {
            TRACE1(NETWORK, "Error interface %u false alarm", dwIfIndex);
            break;
        }

    } while (FALSE);

    // reregister ReceiveWait if the interface exists
    if (pieInterfaceEntry)
    {
        if (!RegisterWaitForSingleObject(&pieInterfaceEntry->hReceiveWait,
                                         pieInterfaceEntry->hReceiveEvent,
                                         NM_CallbackNetworkEvent,
                                         (PVOID) pieInterfaceEntry->dwIfIndex,
                                         INFINITE,
                                         WT_EXECUTEONLYONCE))
        {
            dwErr = GetLastError();
            TRACE2(NETWORK, "Error %u registering wait for %u, continuing",
                   dwErr, pieInterfaceEntry->dwIfIndex);
            LOGERR0(REGISTER_WAIT_FAILED, dwErr);
        }
    }

    RELEASE_READ_LOCK(&((g_ce.pneNetworkEntry)->rwlLock));


    LEAVE_SAMPLE_API();

    TRACE0(LEAVE, "Leaving  NM_CallbackNetworkEvent");
}



VOID
WINAPI
NM_CallbackPeriodicTimer (
    IN  PVOID                   pvContext,
    IN  BOOLEAN                 bTimerOrWaitFired)
/*++

Routine Description
    Processes a periodic timeout event on the specified interface.
    NOTE: The interface might have been deleted.

Locks
    Acquires shared      (g_ce.pneNetworkEntry)->rwlLock
    Releases             (g_ce.pneNetworkEntry)->rwlLock

Arguments
    pvContext           dwIfIndex

Return Value
   None

--*/
{
    DWORD               dwErr               = NO_ERROR;
    DWORD               dwIfIndex           = 0;
    PINTERFACE_ENTRY    pieInterfaceEntry   = NULL;
    PPACKET             pPacket;
    
    dwIfIndex = (DWORD) pvContext;
    
    TRACE1(ENTER, "Entering NM_CallbackPeriodicTimer: %u", dwIfIndex);

    if (!ENTER_SAMPLE_API()) { return; } // cannot return anything


    ACQUIRE_READ_LOCK(&((g_ce.pneNetworkEntry)->rwlLock));

    do                          // breakout loop
    {
        // fail if the interface does not exist
        dwErr = IE_Get(dwIfIndex, &pieInterfaceEntry);
        if (dwErr != NO_ERROR)
            break;

        // fail if interface is inactive
        if (!INTERFACE_IS_ACTIVE(pieInterfaceEntry))
            break;

        RTASSERT(pieInterfaceEntry->sRawSocket != INVALID_SOCKET);

        // fail if packet cannot be created
        if (PacketCreate(&pPacket) != NO_ERROR)
            break;
        

        PacketDisplay(pPacket);
        dwErr = SocketSend(pieInterfaceEntry->sRawSocket,
                           SAMPLE_PROTOCOL_MULTICAST_GROUP,
                           pPacket);
        if (dwErr != NO_ERROR)
        {
            PacketDestroy(pPacket);
            break;
        }
        

        // update interface statistics
        InterlockedIncrement(&(pieInterfaceEntry->iisStats.ulNumPackets)); 
    } while (FALSE);

    // restart timer if the interface exists and is active
    if ((pieInterfaceEntry) and INTERFACE_IS_ACTIVE(pieInterfaceEntry))
    {
        RESTART_TIMER(pieInterfaceEntry->hPeriodicTimer,
                      PERIODIC_INTERVAL,
                      &dwErr);
    }
        

    RELEASE_READ_LOCK(&((g_ce.pneNetworkEntry)->rwlLock));

    
    LEAVE_SAMPLE_API();

    TRACE0(LEAVE, "Leaving  NM_CallbackPeriodicTimer");
}



////////////////////////////////////////
// APIFUNCTIONS
////////////////////////////////////////


DWORD
NM_AddInterface (
    IN  LPWSTR                  pwszInterfaceName,
    IN  DWORD	                dwInterfaceIndex,
    IN  WORD                    wAccessType,
    IN  PVOID	                pvInterfaceInfo)
/*++

Routine Description
    Add an interface with the given configuration to IPSAMPLE.  Interface
    is created UNBOUND and DISABLED.

Locks
    Acquires exclusively (g_ce.pneNetworkEntry)->rwlLock
    Releases             (g_ce.pneNetworkEntry)->rwlLock

Arguments
    pwszInterfaceName   the name of the interface, used for logging.
    dwInterfaceIndex    the positive integer used to refer to this interface.
    wAccessType         access type... MULTIACCESS or POINTTOPOINT
    pvInterfaceInfo     our config for this interface

Return Value
    NO_ERROR            if successfully initiailzed
    Failure code        o/w

--*/
{
    DWORD               dwErr   = NO_ERROR;
    PIPSAMPLE_IF_CONFIG piic    = NULL;
    PINTERFACE_ENTRY    pieEntry = NULL;
    
    
    if (!ENTER_SAMPLE_API()) { return ERROR_CAN_NOT_COMPLETE; }

    ACQUIRE_WRITE_LOCK(&((g_ce.pneNetworkEntry)->rwlLock));
    
    do                          // breakout loop
    {
        piic = (PIPSAMPLE_IF_CONFIG) pvInterfaceInfo;

        
        // validate the configuration parameters
        if (!ValidateInterfaceConfig(piic))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        
        // fail if the interface exists
        if (IE_IsPresent(dwInterfaceIndex))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            TRACE2(NETWORK, "Error interface %S (%u) already exists",
                   pwszInterfaceName, dwInterfaceIndex);
            LOGERR0(INTERFACE_PRESENT, dwErr);

            break;
        }

        
        // create an interface entry
        dwErr = IE_Create(pwszInterfaceName,
                          dwInterfaceIndex,
                          wAccessType,
                          &pieEntry);
        if (dwErr != NO_ERROR)
            break;

        
        // initialize interface configuration fields
        pieEntry->ulMetric          = piic->ulMetric;

        
        // insert the interface in all access structures
        dwErr = IE_Insert(pieEntry);
        RTASSERT(dwErr is NO_ERROR); // no reason to fail!

        
        // update global statistics
        InterlockedIncrement(&(g_ce.igsStats.ulNumInterfaces));
    } while (FALSE);
    
    RELEASE_WRITE_LOCK(&((g_ce.pneNetworkEntry)->rwlLock));

    LEAVE_SAMPLE_API();

    return dwErr;
}



DWORD
NM_DeleteInterface (
    IN  DWORD	                dwInterfaceIndex)
/*++

Routine Description
    Remove an interface with the given index, deactivating it if required.

Locks
    Acquires exclusively (g_ce.pneNetworkEntry)->rwlLock
    Releases             (g_ce.pneNetworkEntry)->rwlLock

Arguments
    dwInterfaceIndex    the positive integer used to identify the interface.

Return Value
    NO_ERROR            if successfully initiailzed
    Failure code        o/w

--*/
{
    DWORD               dwErr               = NO_ERROR;
    PINTERFACE_ENTRY    pieInterfaceEntry   = NULL;


    if (!ENTER_SAMPLE_API()) { return ERROR_CAN_NOT_COMPLETE; }

    do                          // breakout loop
    {
        // remove from all tables, lists...
        ACQUIRE_WRITE_LOCK(&((g_ce.pneNetworkEntry)->rwlLock));

        dwErr = IE_Delete(dwInterfaceIndex, &pieInterfaceEntry);

        RELEASE_WRITE_LOCK(&((g_ce.pneNetworkEntry)->rwlLock));


        // fail if the interface does not exist
        if (dwErr != NO_ERROR)
        {
            TRACE1(NETWORK, "Error interface %u does not exist",
                   dwInterfaceIndex);
            break;
        }


        // destroy the interface entry, deregisters ReceiveWait
        // hence best not to hold any locks to prevent deadlocks.
        IE_Destroy(pieInterfaceEntry);


        // update global statistics
        InterlockedDecrement(&(g_ce.igsStats.ulNumInterfaces));
    } while (FALSE);

    LEAVE_SAMPLE_API();

    return dwErr;
}



DWORD
NM_InterfaceStatus (
    IN DWORD                    dwInterfaceIndex,
    IN BOOL                     bInterfaceActive,
    IN DWORD                    dwStatusType,
    IN PVOID                    pvStatusInfo)
/*++

Routine Description

Locks
    Acquires exclusively (g_ce.pneNetworkEntry)->rwlLock
    Releases             (g_ce.pneNetworkEntry)->rwlLock

Arguments
    dwInterfaceIndex    The index of the interface in question
    bInterfaceActive    Whether the interface can send and receive data
    dwStatusType        RIS_INTERFACE_[ADDRESS_CHANGED|ENABLED|DISABLED]
    pvStatusInfo        Pointer to IP_ADAPTER_BINDING_INFO containing info
                            about the addresses on the interface

Return Value
    NO_ERROR            if successfully initiailzed
    Failure code        o/w
    
--*/
{
    DWORD                       dwErr               = NO_ERROR;
    PINTERFACE_ENTRY            pieInterfaceEntry   = NULL;
    PIP_ADAPTER_BINDING_INFO    pBinding            = NULL;
    BOOL                        bBindingChanged     = FALSE;
    

    if (!ENTER_SAMPLE_API()) { return ERROR_CAN_NOT_COMPLETE; }


    ACQUIRE_WRITE_LOCK(&((g_ce.pneNetworkEntry)->rwlLock));

    do                          // breakout loop
    {
        // fail if the interface does not exist
        dwErr = IE_Get(dwInterfaceIndex, &pieInterfaceEntry);
        if (dwErr != NO_ERROR)
            break;


        // the only status we care about is a change in interface binding
        if (dwStatusType is RIS_INTERFACE_ADDRESS_CHANGE)
        {
            // destroy existing binding
            if (INTERFACE_IS_BOUND(pieInterfaceEntry))
            {
                bBindingChanged = TRUE;
                dwErr = IE_UnBindInterface(pieInterfaceEntry);
                RTASSERT(dwErr is NO_ERROR);
            }

            // create new binding
            pBinding = (PIP_ADAPTER_BINDING_INFO) pvStatusInfo;
            if(pBinding->AddressCount)
            {
                bBindingChanged = TRUE;
                dwErr = IE_BindInterface(pieInterfaceEntry, pBinding);
                if (dwErr != NO_ERROR)
                    break;
            }
        }


        // interface needs to be deactivated even when the binding changes!
        // this restriction is due to the fact that the socket is bound to 
        // the interface address and not the interface index...
        if (INTERFACE_IS_ACTIVE(pieInterfaceEntry) and
            (bBindingChanged or !bInterfaceActive))
        {
            dwErr = IE_DeactivateInterface(pieInterfaceEntry);    
            if (dwErr != NO_ERROR)
                break;
        }

        // activate interface only when a binding exists!
        // i.e. we do not support unnumbered interfaces for now...
        if (INTERFACE_IS_INACTIVE(pieInterfaceEntry) and
            INTERFACE_IS_BOUND(pieInterfaceEntry) and
            bInterfaceActive)
        {
            dwErr = IE_ActivateInterface(pieInterfaceEntry);    
            if (dwErr != NO_ERROR)
                break;
        }
    } while (FALSE);
    
    RELEASE_WRITE_LOCK(&((g_ce.pneNetworkEntry)->rwlLock));


    LEAVE_SAMPLE_API();

    return dwErr;    
}



DWORD
NM_GetInterfaceInfo (
    IN      DWORD               dwInterfaceIndex,
    IN      PVOID               pvInterfaceInfo,
    IN  OUT PULONG              pulBufferSize,
    OUT     PULONG	            pulStructureVersion,
    OUT     PULONG	            pulStructureSize,
    OUT     PULONG	            pulStructureCount)
/*++

Routine Description
    See if there's space enough to return ip sample interface config. If
    yes, we return it, otherwise return the size needed.

Locks
    Acquires shared     (g_ce.pneNetworkEntry)->rwlLock
    Releases            (g_ce.pneNetworkEntry)->rwlLock

Arguments
    dwInterfaceIndex    the interface whose configuration is needed
    pvInterfaceInfo     pointer to allocated buffer to store our config
    pulBufferSize       IN  size of buffer received
                        OUT size of our interface config

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    DWORD               dwErr               = NO_ERROR;
    PIPSAMPLE_IF_CONFIG piic;
    ULONG               ulSize              = sizeof(IPSAMPLE_IF_CONFIG);
    PINTERFACE_ENTRY    pieInterfaceEntry   = NULL;

    if (!ENTER_SAMPLE_API()) { return ERROR_CAN_NOT_COMPLETE; }


    ACQUIRE_READ_LOCK(&((g_ce.pneNetworkEntry)->rwlLock));

    do                          // breakout loop
    {
        // fail if the interface does not exist
        dwErr = IE_Get(dwInterfaceIndex, &pieInterfaceEntry);
        if (dwErr != NO_ERROR)
            break;

        // fail if the size was too small or there was no storage
        if((*pulBufferSize < ulSize) or (pvInterfaceInfo is NULL))
        {
            TRACE1(NETWORK, "NM_GetInterfaceInfo: *ulBufferSize %u",
                   *pulBufferSize);

            *pulBufferSize = ulSize;
            dwErr = ERROR_INSUFFICIENT_BUFFER;
            break;
        }


        // set the OUT parameters
        *pulBufferSize = ulSize;
        if (pulStructureVersion)    *pulStructureVersion    = 1;
        if (pulStructureSize)       *pulStructureSize       = ulSize;
        if (pulStructureCount)      *pulStructureCount      = 1;


        // copy out the interface configuration
        piic = (PIPSAMPLE_IF_CONFIG) pvInterfaceInfo;
        piic->ulMetric = pieInterfaceEntry->ulMetric;
    } while (FALSE);

    RELEASE_READ_LOCK(&((g_ce.pneNetworkEntry)->rwlLock));

    
    LEAVE_SAMPLE_API();

    return dwErr;
}



DWORD
NM_SetInterfaceInfo (
    IN      DWORD           dwInterfaceIndex,
    IN      PVOID           pvInterfaceInfo)
/*++

Routine Description
    Set ip sample interface's configuration.

Locks
    Acquires exclusively (g_ce.pneNetworkEntry)->rwlLock
    Releases             (g_ce.pneNetworkEntry)->rwlLock

Arguments
    dwInterfaceIndex    the interface whose configuration is to be set
    pvInterfaceInfo     buffer with new interface config

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    DWORD               dwErr               = NO_ERROR;
    PIPSAMPLE_IF_CONFIG piic;
    PINTERFACE_ENTRY    pieInterfaceEntry   = NULL;

    if (!ENTER_SAMPLE_API()) { return ERROR_CAN_NOT_COMPLETE; }


    ACQUIRE_WRITE_LOCK(&((g_ce.pneNetworkEntry)->rwlLock));

    do                          // breakout loop
    {
        // fail if the interface does not exist
        dwErr = IE_Get(dwInterfaceIndex, &pieInterfaceEntry);
        if (dwErr != NO_ERROR)
            break;

        // fail if the configuration is invalid
        piic = (PIPSAMPLE_IF_CONFIG) pvInterfaceInfo;
        if(!ValidateInterfaceConfig(piic))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        
        // update our configuration
        pieInterfaceEntry->ulMetric         = piic->ulMetric;

        // might need additional processing depending on the state change
        // caused by the updated interface configuration and the protocol
        // behavior.  for instance, sockets may need to be created/shutdown

    } while (FALSE);

    RELEASE_WRITE_LOCK(&((g_ce.pneNetworkEntry)->rwlLock));

    
    LEAVE_SAMPLE_API();

    return dwErr;
}



DWORD
NM_DoUpdateRoutes (
    IN      DWORD               dwInterfaceIndex
    )
/*++

Routine Description
    Updates routes over a demand dial interface.

Locks
    Acquires exclusively (g_ce.pneNetworkEntry)->rwlLock
    Releases             (g_ce.pneNetworkEntry)->rwlLock

Arguments
    dwInterfaceIndex    the relevant interface index

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    DWORD               dwErr               = NO_ERROR;
    PINTERFACE_ENTRY    pieInterfaceEntry   = NULL;
    MESSAGE             mMessage;
    
    if (!ENTER_SAMPLE_API()) { return ERROR_CAN_NOT_COMPLETE; }


    ACQUIRE_READ_LOCK(&((g_ce.pneNetworkEntry)->rwlLock));

    do                          // breakout loop
    {
        // fail if the interface does not exist
        dwErr = IE_Get(dwInterfaceIndex, &pieInterfaceEntry);
        if (dwErr != NO_ERROR)
            break;

        // ensure interface is active
        if (INTERFACE_IS_INACTIVE(pieInterfaceEntry))
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            TRACE1(NETWORK, "Error, interface %u inactive", dwInterfaceIndex);
            break;
        }

        // here we do protocol specific processing,
        // for sample nothing :)

    } while (FALSE);

    RELEASE_READ_LOCK(&((g_ce.pneNetworkEntry)->rwlLock));

    mMessage.UpdateCompleteMessage.InterfaceIndex   = dwInterfaceIndex;
    mMessage.UpdateCompleteMessage.UpdateType       = RF_DEMAND_UPDATE_ROUTES;
    mMessage.UpdateCompleteMessage.UpdateStatus     = dwErr;
    if (EnqueueEvent(UPDATE_COMPLETE, mMessage) is NO_ERROR)
        SetEvent(g_ce.hMgrNotificationEvent);
    
    LEAVE_SAMPLE_API();

    return dwErr;
}



DWORD
NM_ProcessRouteChange (
    VOID)
/*++

Routine Description
   Handle messages from RTM about route changes.

Locks
   None
   
Arguments
   None
   
Return Value
   NO_ERROR                 success
   Error Code               o/w
   
--*/    
{
    DWORD           dwErr           = NO_ERROR;
    RTM_DEST_INFO   rdiDestination;             // 1 view registered for change
    BOOL            bDone           = FALSE;
    UINT            uiNumDests;
    
    if (!ENTER_SAMPLE_API()) { return ERROR_CAN_NOT_COMPLETE; }

    // loop dequeueing messages until RTM says there are no more left
    while (!bDone)
    {
        // retrieve route changes
        uiNumDests = 1;
        dwErr = RTM_GetChangedDests(
            g_ce.hRtmHandle,                    // my RTMv2 handle 
            g_ce.hRtmNotificationHandle,        // my notification handle 
            &uiNumDests,                        // IN   # dest info's required
                                                // OUT  # dest info's supplied
            &rdiDestination);                   // OUT  buffer for dest info's

        switch (dwErr)
        {
            case ERROR_NO_MORE_ITEMS:
                bDone = TRUE;
                dwErr = NO_ERROR;
                if (uiNumDests < 1)
                    break;
                // else continue below to process the last destination

            case NO_ERROR:
                RTASSERT(uiNumDests is 1);
                RTM_DisplayDestInfo(&rdiDestination);
                
                // release the destination info
                if (RTM_ReleaseChangedDests(
                    g_ce.hRtmHandle,            // my RTMv2 handle 
                    g_ce.hRtmNotificationHandle,// my notif handle 
                    uiNumDests,                 // 1
                    &rdiDestination             // released dest info
                    ) != NO_ERROR)
                    TRACE0(NETWORK, "Error releasing changed dests");

                break;

            default:
                bDone = TRUE;
                TRACE1(NETWORK, "Error %u RtmGetChangedDests", dwErr);
                break;
        }
    } // while 
    
    LEAVE_SAMPLE_API();

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\packet.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\packet.h

Abstract:

    The file contains the header for packet.c

--*/

#ifndef _PACKET_H_
#define _PACKET_H_

//
// struct: PACKET
//
// stores a packet's fields and the buffer
//

typedef struct _PACKET
{
    IPADDRESS   ipSource;
    WSABUF      wsaBuffer;
    BYTE        rgbyBuffer[MAX_PACKET_LENGTH];

    OVERLAPPED  oOverlapped;
} PACKET, *PPACKET;

DWORD
PacketCreate (
    OUT PPACKET                 *ppPacket);

DWORD
PacketDestroy (
    IN  PPACKET                 pPacket);

#ifdef DEBUG
DWORD
PacketDisplay (
    IN  PPACKET                 pPacket);
#else
#define PacketDisplay(pPacket)
#endif // DEBUG

#endif // _PACKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\packet.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\packet.c

Abstract:

    The file contains functions to deal with an ip sample packet.

--*/

#include "pchsample.h"
#pragma hdrstop

DWORD
PacketCreate (
    OUT PPACKET         *ppPacket)
/*++

Routine Description
    Creates a packet.

Locks
    None

Arguments
    ppPacket            pointer to the packet address

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    DWORD   dwErr   = NO_ERROR;
    
    // validate parameters
    if (!ppPacket)
        return ERROR_INVALID_PARAMETER;

    do                          // breakout loop
    {
        // allocate and zero out the packet structure
        MALLOC(ppPacket, sizeof(PACKET), &dwErr);
        if (dwErr != NO_ERROR)
            break;
        
        // initialize fields
        
        // ((*ppPacket)->ipSource  zero'ed out
        
        sprintf((*ppPacket)->rgbyBuffer, "hello world!"); // for now :)

        (*ppPacket)->wsaBuffer.buf = (*ppPacket)->rgbyBuffer;
        (*ppPacket)->wsaBuffer.len = strlen((*ppPacket)->rgbyBuffer);

    } while (FALSE);

    return dwErr;
}



DWORD
PacketDestroy (
    IN  PPACKET                 pPacket)
/*++

Routine Description
    Destroys a packet.

Locks
    None

Arguments
    pPacket             packet to destroy

Return Value
    NO_ERROR            always

--*/
{
    // validate parameters
    if (!pPacket)
        return NO_ERROR;
    
    FREE(pPacket);

    return NO_ERROR;
}



#ifdef DEBUG
DWORD
PacketDisplay (
    IN  PPACKET                 pPacket)
/*++

Routine Description
    Displays a packet, it's fields and the buffer.

Locks
    None

Arguments
    pPacket             packet to destroy

Return Value
    NO_ERROR            always

--*/
{
    ULONG   i;
    CHAR    szBuffer[2 * MAX_PACKET_LENGTH + 1]; // buffer in hex

    for (i = 0; i < pPacket->wsaBuffer.len; i++)
        sprintf(szBuffer + i*2, "%02x", pPacket->rgbyBuffer[i]);

    TRACE3(NETWORK, "Packet... Source %s, Length %d, Buffer %s",
           INET_NTOA(pPacket->ipSource), pPacket->wsaBuffer.len, szBuffer);

    return NO_ERROR;
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\pchsample.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\pchsample.h

Abstract:

    The file contains precompiled header for PIM-SM

--*/

#ifndef _PCHSAMPLE_H_
#define _PCHSAMPLE_H_

// DO NOT CHANGE ORDER UNLESS YOU KNOW WHAT YOU ARE DOING

#include <windows.h>            // Include file for Windows applications

#undef FD_SETSIZE
#define FD_SETSIZE  256         // Max sockets a WinSock application can use
#include <winsock2.h>           // Interface to WinSock 2 API
#include <ws2tcpip.h>           // WinSock 2 Extension for TCP/IP protocols

#include <routprot.h>           // Interface to Router Manager
#include <rtmv2.h>              // Interface to Routing Table Manager v2
#include <iprtrmib.h>           // MIB variables handled by Router Manager
#include <mgm.h>                // Interface to Multicast Group Manager

#include <mprerror.h>           // Router specific error codes
#include <rtutils.h>            // Utility functions (Log, Trace, ...)

#include <stdio.h>
#include <wchar.h>

#include "ipsamplerm.h"

#include "list.h"               // List Implementation
#include "hashtable.h"          // HashTable Implementation
#include "sync.h"               // ReadWriteLock, LockedList Implementation

#include "log.h"                // Localizable log messages
#include "defs.h"               // IPADDRESS, Memory, Trace, Log
#include "utils.h"              // Utilities

#include "packet.h"             // Packet implementation
#include "socket.h"             // Socket Functions
#include "networkentry.h"
#include "networkmgr.h"
#include "configentry.h"
#include "configmgr.h"
#include "mibmgr.h"

#include "rtmapi.h"
#include "rtmapi.h"

#endif // _PCHSAMPLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\rmapi.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\rmapi.h

Abstract:

    The file contains the header for rmapi.c.

--*/

#ifndef _RMAPI_H_
#define _RMAPI_H_

//
// function declarations for router manager interface:
//

DWORD
APIENTRY
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    );

#endif // _RMAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\rtmapi.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\rtmapi.c

Abstract:

    The file contains RTMv2 API implementations.

--*/

#include "pchsample.h"
#pragma hdrstop


#ifdef DEBUG
DWORD
RTM_DisplayDestInfo(
    IN  PRTM_DEST_INFO          prdi)
/*++

Routine Description
    Displays an RTM_DEST_INFO object.

Locks
    None

Arguments
    prdi                buffer containing the rtm dest info

Return Value
    NO_ERROR            always

--*/
{
    IPADDRESS   ip;

    if (!prdi)
        return NO_ERROR;

    RTM_GetAddress(&ip, &(prdi->DestAddress));
    TRACE2(NETWORK, "RtmDestInfo Destination %s/%u",
           INET_NTOA(ip), (prdi->DestAddress).NumBits);

    return NO_ERROR;    
}
#else
#define DisplayRtmDestInfo(prdi)
#endif // DEBUG



DWORD
RTM_NextHop (
    IN  PRTM_DEST_INFO              prdiDestination,
    OUT PDWORD                      pdwIfIndex,
    OUT PIPADDRESS                  pipNeighbor)
/*++

Routine Description
    Obtain the next hop for a destination (typically a data source or an RP).

Locks
    None

Arguments
    prdiDestination     destination information obtained from rtm
    dwIfIndex           next hop interface index
    pipNeighbor         ip address of next hop neighbor
    
Return Value
    NO_ERROR            success
    Error Code          o/w
    
--*/
{
    DWORD               dwErr = NO_ERROR;
    PRTM_ROUTE_INFO     prriRoute;
    RTM_NEXTHOP_INFO    rniNextHop;
    BOOL                bRoute, bNextHop;

    // flags indicating handles held
    bRoute = bNextHop = FALSE;
    
    do                          // breakout loop
    {
        // allocate route info structure
        MALLOC(&prriRoute,
               RTM_SIZE_OF_ROUTE_INFO(g_ce.rrpRtmProfile.MaxNextHopsInRoute),
               &dwErr);
        if (dwErr != NO_ERROR)
            break;

        // get route info (best route in mcast view)
        dwErr = RtmGetRouteInfo (
            g_ce.hRtmHandle,
            prdiDestination->ViewInfo[0].Route,
            prriRoute,
            NULL);
        if (dwErr != NO_ERROR)
        {
            TRACE1(ANY, "Error %u getting route", dwErr);
            break;
        }
        bRoute = TRUE;

        // get nexthop info (first next hop for now...)
        dwErr = RtmGetNextHopInfo(
            g_ce.hRtmHandle,
            prriRoute->NextHopsList.NextHops[0],
            &rniNextHop);
        if (dwErr != NO_ERROR)
        {
            TRACE1(ANY, "Error %u getting next hop", dwErr);
            break;
        }
        bNextHop = TRUE;

        // finally!!! THIS SHOULD NOT BE A REMOTE NEXT HOP!!!
        *(pdwIfIndex) = rniNextHop.InterfaceIndex;
        RTM_GetAddress(pipNeighbor,
                       &(rniNextHop.NextHopAddress));
    } while (FALSE);

    if (dwErr != NO_ERROR)
        TRACE1(ANY, "Error %u obtaining next hop", dwErr);
    
    // release the handle to the next hop
    if (bNextHop)
    {
        if (RtmReleaseNextHopInfo(g_ce.hRtmHandle, &rniNextHop) != NO_ERROR)
            TRACE0(ANY, "Error releasing next hop, continuing...");
    }

    // release the handle to the route
    if (bRoute)
    {
        if (RtmReleaseRouteInfo(g_ce.hRtmHandle, prriRoute) != NO_ERROR)
            TRACE0(ANY, "Error releasing route, continuing...");
    }

    // deallocate route info structure
    if (prriRoute)
        FREE(prriRoute);

    return dwErr;
}


    
////////////////////////////////////////
// CALLBACKFUNCTIONS
////////////////////////////////////////

DWORD
APIENTRY
RTM_CallbackEvent (
    IN  RTM_ENTITY_HANDLE   hRtmHandle, // registration handle
    IN  RTM_EVENT_TYPE      retEvent,
    IN  PVOID               pvContext1,
    IN  PVOID               pvContext2)
/*++

Routine Description
    Processes an RTMv2 event.  Used to inform entities of new entities
    registering, entities deregistering, route expiration, route changes.

Locks
   None (for now)
   
Arguments
   retEvent                 rtmv2 event type
   
Return Value
   NO_ERROR                 success
   Error Code               o/w
   
--*/
{
    DWORD dwErr = NO_ERROR;

    TRACE1(ENTER, "Entering RTM_CallbackEvent: %u", retEvent);

    do                          // breakout loop
    {
        UNREFERENCED_PARAMETER(hRtmHandle);
        UNREFERENCED_PARAMETER(pvContext1);
        UNREFERENCED_PARAMETER(pvContext2);

        // only route change notifications are processed
        if (retEvent != RTM_CHANGE_NOTIFICATION)
        {
            dwErr = ERROR_NOT_SUPPORTED;
            break;
        }

        dwErr = NM_ProcessRouteChange();
    } while (FALSE);

    TRACE0(LEAVE, "Leaving  RTM_CallbackEvent");

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\sampletest.cxx ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\sampletest.cxx

Abstract:

    The file contains code for the test program

--*/

#include "sampletest.h"

int _cdecl
main()
{
    TestProtocol();
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\sampletest.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\sampletest.h

Abstract:

    The file contains declarations for the test program

--*/

#ifndef _SAMPLETEST_H_
#define _SAMPLETEST_H_

#include <windows.h>

#include "ipsample.h"

#endif // _SAMPLETEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\rtmapi.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\rtmapi.h

Abstract:

    The file contains the header for rtmapi.c...

--*/

#ifndef _RTMAPI_H_
#define _RTMAPI_H_

//
// this indirection would be useful if i ever write a protocol emulator
//

#define RTM_RegisterEntity(preiEntity,                              \
                           preemMethods,                            \
                           recCallback,                             \
                           bReserve,                                \
                           rrpProfile,                              \
                           phHandle)                                \
RtmRegisterEntity(preiEntity,                                       \
                  preemMethods,                                     \
                  recCallback,                                      \
                  bReserve,                                         \
                  rrpProfile,                                       \
                  phHandle)


#define RTM_DeregisterEntity(hHandle)                               \
RtmDeregisterEntity(hHandle)
    

    
#define RTM_RegisterForChangeNotification(hHandle,                  \
                                          rvsViews,                 \
                                          rnfFlags,                 \
                                          pvContext,                \
                                          phNotificationHandle)     \
RtmRegisterForChangeNotification(hHandle,                           \
                                 rvsViews,                          \
                                 rnfFlags,                          \
                                 pvContext,                         \
                                 phNotificationHandle)

    
#define RTM_DeregisterFromChangeNotification(hHandle,               \
                                             hNotificationHandle)   \
RtmDeregisterFromChangeNotification(hHandle,                        \
                                    hNotificationHandle)

    
                           
#define RTM_GetChangedDests(hRtmHandle,                             \
                            hNotificationHandle,                    \
                            puiNumDests,                            \
                            pRtmDestInfo)                           \
RtmGetChangedDests(hRtmHandle,                                      \
                   hNotificationHandle,                             \
                   puiNumDests,                                     \
                   pRtmDestInfo)

                            
#define RTM_ReleaseChangedDests(hRtmHandle,                         \
                                hNotificationHandle,                \
                                uiNumDests,                         \
                                pRtmDestInfo)                       \
RtmReleaseChangedDests(hRtmHandle,                                  \
                      hNotificationHandle,                          \
                      uiNumDests,                                   \
                      pRtmDestInfo)


#define RTM_SetAddress(prnaAddress,                                 \
                       ipAddress)                                   \
RTM_IPV4_SET_ADDR_AND_LEN(prnaAddress,                              \
                          ipAddress,                                \
                          sizeof(IPADDRESS))

#define RTM_GetAddress(pipAddress,                                  \
                       prnaAddress)                                 \
(                                                                   \
    IP_ASSIGN((pipAddress), (* (ULONG *)  (prnaAddress)->AddrBits)) \
)
    
#define RTM_GetMostSpecificDestination (RtmRegHandle,               \
                                        DestAddress,                \
                                        ProtocolId,                 \
                                        TargetView,                 \
                                        DestInfo)                   \
RtmGetMostSpecificDestination (RtmRegHandle,                        \
                               DestAddress,                         \
                               ProtocolId,                          \
                               TargetView,                          \
                               DestInfo)

#define RTM_ReleaseDestInfo (RtmRegHandle,                          \
                             DestInfo)                              \
RtmReleaseDestInfo (RtmRegHandle,                                   \
                    DestInfo)

#define RTM_MarkDestForChangeNotification (RtmRegHandle,            \
                                           NotifyHandle,            \
                                           DestHandle,              \
                                           MarkDest)                \
RtmMarkDestForChangeNotification (RtmRegHandle,                     \
                                  NotifyHandle,                     \
                                  DestHandle,                       \
                                  MarkDest)

#define RTM_IsMarkedForChangeNotification (RtmRegHandle,            \
                                           NotifyHandle,            \
                                           DestHandle,              \
                                           DestMarked)              \
RtmIsMarkedForChangeNotification (RtmRegHandle,                     \
                                  NotifyHandle,                     \
                                  DestHandle,                       \
                                  DestMarked)

#define RTM_GetOpaqueInformationPointer (RtmRegHandle,              \
                                         DestHandle,                \
                                         OpaqueInfoPointer)         \
RtmGetOpaqueInformationPointer (RtmRegHandle,                       \
                                DestHandle,                         \
                                OpaqueInfoPointer)


    
//    
// function declarations for rtmv2 interface
//

#ifdef DEBUG
DWORD
RTM_DisplayDestInfo(
    IN  PRTM_DEST_INFO          prdi);
#else
#define RTM_DisplayDestInfo(prdi)
#endif // DEBUG



DWORD
RTM_NextHop (
    IN  PRTM_DEST_INFO              prdiDestination,
    OUT PDWORD                      pdwIfIndex,
    OUT PIPADDRESS                  pipNeighbor);



DWORD
APIENTRY
RTM_CallbackEvent (
    IN  RTM_ENTITY_HANDLE   hRtmHandle,
    IN  RTM_EVENT_TYPE      retEvent,
    IN  PVOID               pvContext1,
    IN  PVOID               pvContext2);

#endif // _RTMAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\rmapi.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\rmapi.c

Abstract:

    The file contains IP router manager API implementations.

--*/

#include "pchsample.h"
#pragma hdrstop


DWORD
WINAPI
StartProtocol (
    IN HANDLE 	            NotificationEvent,
    IN PSUPPORT_FUNCTIONS   SupportFunctions,
    IN LPVOID               GlobalInfo,
    IN ULONG                StructureVersion,
    IN ULONG                StructureSize,
    IN ULONG                StructureCount
    )
/*++

Routine Description
    After the protocol has been registered, the IP Router Manager calls
    this function to tell the protocol to start.  Most of the startup code
    is executed here.

Arguments
    NotificationEvent   Event to Set if the IP Router Manager needs to
                            be notified to take any action on our behalf
    SupportFunctions    Some functions exported by IP Router Manager
    GlobalInfo          Our global configuration which was setup by our
                            setup/admin DLL

Return Value
    NO_ERROR            Success
    Error Code          o/w

--*/    
{
    DWORD dwErr = NO_ERROR;

    TRACE3(ENTER, "Entering StartProtocol 0x%08x 0x%08x 0x%08x",
           NotificationEvent, SupportFunctions, GlobalInfo);

    do                          // breakout loop
    {
        // validate parameters
        if (!NotificationEvent or
            !SupportFunctions  or
            !GlobalInfo)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
        
        dwErr = CM_StartProtocol(NotificationEvent,
                                 SupportFunctions,
                                 GlobalInfo);
    } while(FALSE);
    
    TRACE1(LEAVE, "Leaving  StartProtocol: %u", dwErr);

    return dwErr;
}

DWORD
WINAPI
StartComplete (
    VOID
    )
{
    TRACE0(ENTER, "Entering StartComplete");
    TRACE0(LEAVE, "Leaving  StartComplete");

    return NO_ERROR;
}


DWORD
WINAPI
StopProtocol (
    VOID
    )
/*++

Routine Description
    This function is called by the IP Router Manager to tell the protocol
    to stop.  We set the protocol state to IPSAMPLE_STATUS_STOPPING to
    prevent us from servicing any more requests and wait for all pending
    threads to finish.  Meanwhile we return PENDING to the IP Router
    Manager.

Arguments
    None

Return Value
   ERROR_PROTOCOL_STOP_PENDING      Success
   Error Code                       o/w

--*/    
{
    DWORD dwErr = NO_ERROR;
    
    TRACE0(ENTER, "Entering StopProtocol");

    dwErr = CM_StopProtocol();
    
    TRACE1(LEAVE, "Leaving  StopProtocol: %u", dwErr);

    return dwErr;
}



DWORD
WINAPI
GetGlobalInfo (
    IN     PVOID 	GlobalInfo,
    IN OUT PULONG   BufferSize,
    OUT    PULONG	StructureVersion,
    OUT    PULONG   StructureSize,
    OUT    PULONG   StructureCount
    )
/*++

Routine Description
    The function is called by the IP Router Manager, usually because of a
    query by the admin utility.  We see if we have space enough to return
    our global config. If we do, we return it, otherwise we return the size
    needed.

Arguments
    GlobalInfo      Pointer to allocated buffer to store our config
    BufferSize      Size of config.

Return Value
    NO_ERROR                    Success
    ERROR_INSUFFICIENT_BUFFER   If the size of the buffer is too small
    Error Code                  o/w

--*/    
{
    DWORD dwErr = NO_ERROR;
    
    TRACE2(ENTER, "Entering GetGlobalInfo: 0x%08x 0x%08x",
           GlobalInfo, BufferSize);

    do                          // breakout loop
    {
        // validate parameters
        if (!BufferSize)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
        
        dwErr = CM_GetGlobalInfo(GlobalInfo,
                                 BufferSize,
                                 StructureVersion,
                                 StructureSize,
                                 StructureCount);
    } while(FALSE);
    
    TRACE1(LEAVE, "Leaving  GetGlobalInfo: %u", dwErr);

    return dwErr;
}



DWORD
WINAPI
SetGlobalInfo (
    IN  PVOID 	GlobalInfo,
    IN  ULONG	StructureVersion,
    IN  ULONG   StructureSize,
    IN  ULONG   StructureCount
    )
/*++

Routine Description
    Called by the IP Router Manager usually in response to an admin utility
    changing the global config.  We verify the info and set it.

Arguments
    GlobalInfo                  Our globals configuration

Return Value
    NO_ERROR                    Success
    Error Code                  o/w

--*/
{
    DWORD dwErr = NO_ERROR;

    TRACE1(ENTER, "Entering SetGlobalInfo: 0x%08x", GlobalInfo);

    do                          // breakout loop
    {
        // validate parameters
        if (!GlobalInfo)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
        
        dwErr = CM_SetGlobalInfo(GlobalInfo);

    } while(FALSE);
    
    TRACE1(LEAVE, "Leaving  SetGlobalInfo: %u", dwErr);

    return NO_ERROR;
}






DWORD
WINAPI
AddInterface (
    IN LPWSTR               InterfaceName,
    IN ULONG	            InterfaceIndex,
    IN NET_INTERFACE_TYPE   InterfaceType,
    IN DWORD                MediaType,
    IN WORD                 AccessType,
    IN WORD                 ConnectionType,
    IN PVOID	            InterfaceInfo,
    IN ULONG                StructureVersion,
    IN ULONG                StructureSize,
    IN ULONG                StructureCount
    )
/*++

Routine Description
    Called by the ip router manager to add an interface when it finds our
    information block within the interface's configuration.  We verify the
    information and create an entry for the interface in our interface
    table.  Then we see all the configured addresses for the interface and
    create a binding structure for each address The interface comes up as
    UNBOUND-DISABLED (INACTIVE).

Arguments
    InterfaceName   The name of the interface, used for logging.
    InterfaceIndex  The positive integer used to refer to this interface.
    AccessType      Access type of the interface
    InterfaceInfo   Our config for this interface

Return Value
    NO_ERROR        Success
    Error Code      o/w

--*/
{
    DWORD dwErr = NO_ERROR;

    TRACE4(ENTER, "Entering AddInterface: %S %u %u 0x%08x",
           InterfaceName, InterfaceIndex, AccessType, InterfaceInfo);

    // interface properties unused for now
    UNREFERENCED_PARAMETER(InterfaceType);
    UNREFERENCED_PARAMETER(MediaType);
    UNREFERENCED_PARAMETER(ConnectionType);

    if (AccessType != IF_ACCESS_POINTTOPOINT)
        AccessType = IF_ACCESS_BROADCAST;
    
    do                          // breakout loop
    {
        // validate parameters
        if ((wcslen(InterfaceName) is 0) or
            !((AccessType is IF_ACCESS_BROADCAST) or
              (AccessType is IF_ACCESS_POINTTOPOINT)) or
            !InterfaceInfo)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
        
        dwErr = NM_AddInterface(InterfaceName,
                                InterfaceIndex,
                                AccessType,
                                InterfaceInfo);
    } while(FALSE);
    
    TRACE1(LEAVE, "Leaving  AddInterface: %u", dwErr);

    return dwErr;
}



DWORD
WINAPI
DeleteInterface (
    IN ULONG	InterfaceIndex
    )
/*++

Routine Description
    Called by the ip router manager to delete an interface and free its
    resources. If the interface is ACTIVE we shut it down.

Arguments
    InterfaceIndex  The index of the interface to be deleted

Return Value
    NO_ERROR        Success
    Error Code      o/w

--*/
{
    DWORD dwErr = NO_ERROR;

    TRACE1(ENTER, "Entering DeleteInterface: %u", InterfaceIndex);

    dwErr = NM_DeleteInterface(InterfaceIndex);
            
    TRACE1(LEAVE, "Leaving  DeleteInterface: %u", dwErr);

    return dwErr;
}



DWORD
WINAPI
InterfaceStatus (
    IN ULONG	InterfaceIndex,
    IN BOOL     InterfaceActive,
    IN DWORD    StatusType,
    IN PVOID	StatusInfo
    )
/*++

Routine Description

    Called by ip router manager to bind/unbind/activate/deactivate interfaces.

    BIND      (
               (StatusType is RIS_INTERFACE_ADDRESS_CHANGE) and
               (((PIP_ADAPTER_BINDING_INFO) StatusInfo)->AddressCount > 0)
              )

    Called by the ip router manager once it learns the address(es) on an
    interface.  This may happen as soon as the router starts (after the
    interface is added, of course) when the interface has a static address
    or may happen when an interface acquires a DHCP address or may happen
    when IPCP acquires the address for a dial up link.  The binding may
    consist of one or more addresses.
    
    UNBIND    (
               (StatusType is RIS_INTERFACE_ADDRESS_CHANGE) and
               (((PIP_ADAPTER_BINDING_INFO) StatusInfo)->AddressCount is 0)
              )

    Called when the interface loses its ip Address(es). This may happen
    when the interface is shutting down. It may be because an admin
    disabled IP on the interface (as opposed to just disabling the protocol
    on the interface). It can happen when the admin releases a DHCP
    acquired interface or when a dial up link disconnects.

    ENABLED   (RIS_INTERFACE_ENABLED)

    Called to enable the interface after it has been added or when the
    interface is being reenabled after being disabled by the admin.  The
    bindings on an interface are kept across Enable-Disable.

    DISABLED  (RIS_INTERFACE_DISABLED)

    Called to disable an interface.  This is usually in response to an
    admin setting the AdminStatus in IP to DOWN.  This is different from an
    admin trying to disable an interface by setting a flag in our interface
    config because that is opaque to IP. That is a routing protocol
    specific disable and is conveyed to us via SetInterfaceConfig() calls.
    THIS IS AN IMPORTANT DISTINCTION. A ROUTING PROTOCOL NEEDS TO MANTAIN
    TWO STATES - AN NT STATE AND A PROTOCOL SPECIFIC STATE.

    INTERFACE ACTIVE
    
    This flag is used to activate the protocol over the interface
    independent of whether the interface has been bound or enabled.
    An unnumbered interface will not have a binding even when activated.

Arguments
    InterfaceIndex  The index of the interface in question
    InterfaceActive Whether the interface can send and receive data
    StatusType      RIS_INTERFACE_[ADDRESS_CHANGED|ENABLED|DISABLED]
    SattusInfo      Pointer to IP_ADAPTER_BINDING_INFO containing info
                    about the addresses on the interface

Return Value
    NO_ERROR        Success
    Error Code      o/w

--*/
{
    DWORD dwErr = NO_ERROR;

    TRACE4(ENTER, "Entering InterfaceStatus: %u %u %u 0x%08x",
           InterfaceIndex, InterfaceActive, StatusType, StatusInfo);
    
    do                          // breakout loop
    {
        dwErr = NM_InterfaceStatus(InterfaceIndex,
                                   InterfaceActive,
                                   StatusType,
                                   StatusInfo);
    } while(FALSE);
    
    TRACE1(LEAVE, "Leaving  InterfaceStatus: %u", dwErr);

    return dwErr;
}



DWORD
WINAPI
GetInterfaceConfigInfo (
    IN      ULONG	InterfaceIndex,
    IN      PVOID   InterfaceInfo,
    IN  OUT PULONG  BufferSize,
    OUT     PULONG	StructureVersion,
    OUT     PULONG	StructureSize,
    OUT     PULONG	StructureCount
    )
/*++

Routine Description
    Called by the IP Router Manager to retrieve an interface's
    configuration.  Usually this is because an admin utility is displaying
    this information.  The Router Manager calls us with a NULL config and
    ZERO size. We return the required size to it.  It then allocates the
    needed memory and calls us a second time with a valid buffer.  We
    validate parameters each time and copy out our config if we can.

Arguments
    InterfaceIndex      Index of the interface being queried
    InterfaceInfo       Pointer to buffer to store the config
    BufferSize          Size of the buffer

Return Value
    NO_ERROR        Success
    Error Code      o/w

--*/
{
    DWORD dwErr = NO_ERROR;

    TRACE3(ENTER, "Entering GetInterfaceConfigInfo: %u 0x%08x 0x%08x",
           InterfaceIndex, InterfaceInfo, BufferSize);

    do                          // breakout loop
    {
        // validate parameters
        if(BufferSize is NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        dwErr = NM_GetInterfaceInfo(InterfaceIndex,
                                    InterfaceInfo,
                                    BufferSize,
                                    StructureVersion,
                                    StructureSize,
                                    StructureCount);
    } while(FALSE);

    TRACE1(LEAVE, "Leaving  GetInterfaceConfigInfo: %u",
           dwErr);

    return dwErr;
}



DWORD
WINAPI
SetInterfaceConfigInfo (
    IN ULONG	InterfaceIndex,
    IN PVOID	InterfaceInfo,
    IN ULONG    StructureVersion,
    IN ULONG    StructureSize,
    IN ULONG    StructureCount
    )
/*++

Routine Description
    Called by the IP Router Manager to set an interface's configuration.
    Usually this is because an admin utility modified this information.
    After validating parameters we update our config if we can.

Arguments
    InterfaceIndex      Index of the interface being updated
    InterfaceInfo       Buffer with our updated configuration

Return Value
    NO_ERROR        Success
    Error Code      o/w

--*/
{
    DWORD dwErr = NO_ERROR;

    TRACE2(ENTER, "Entering SetInterfaceConfigInfo: %u 0x%08x",
           InterfaceIndex, InterfaceInfo);

    do                          // breakout loop
    {
        // validate parameters
        if(InterfaceInfo is NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        dwErr = NM_SetInterfaceInfo(InterfaceIndex, InterfaceInfo);
    } while(FALSE);
    
    TRACE1(LEAVE, "Leaving  SetInterfaceConfigInfo: %u", dwErr);

    return dwErr;
}






DWORD
WINAPI
GetEventMessage (
    OUT ROUTING_PROTOCOL_EVENTS  *Event,
    OUT MESSAGE                  *Result
    )
/*++

Routine Description
    This is called by the IP Router Manager if we indicate that we have a
    message in our queue to be delivered to it (by setting the
    g_ce.hMgrNotificationEvent)

Arguments
    Event               Routing Protocol Event Type
    Result              Message associated with the event

Return Value
    NO_ERROR            Success
    Error Code          o/w

--*/    
{
    DWORD dwErr = NO_ERROR;

    TRACE2(ENTER, "Entering GetEventMessage: 0x%08x 0x%08x",
           Event, Result);

    do                          // breakout loop
    {
        // validate parameters
        if (!Event or !Result)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
        
        dwErr = CM_GetEventMessage(Event, Result);

    } while(FALSE);
    
    TRACE1(LEAVE, "Leaving  GetEventMessage: %u", dwErr);

    return dwErr;
}



DWORD
WINAPI
DoUpdateRoutes (
    IN ULONG	InterfaceIndex
    )
/*++

Routine Description
    This function is called by the IP Router Manger to ask us to update
    routes over a Demand Dial link.  The link has already been brought up
    so should be in ENABLED-BOUND state.  After we are done we need to set
    the g_ce.hMgrNotificationEvent to inform the Router Manager that we
    have a message in our queue to be delivered to it.  The Router Manager
    will call our GetEventMessage() function in which we will inform it
    that we are done with update routes (and the routes have been stored in
    RTMv2). The Router Manager will "freeze" these routes by converting
    them to AUTOSTATIC.

Arguments
    InterfaceIndex      Interface index on which to do the update

Return Value
    NO_ERROR            Success
    Error Code          o/w
    
--*/    
{
    DWORD dwErr = NO_ERROR;

    TRACE1(ENTER, "Entering DoUpdateRoutes: %u", InterfaceIndex);

    dwErr = NM_DoUpdateRoutes(InterfaceIndex);
    
    TRACE1(LEAVE, "Leaving  DoUpdateRoutes: %u", dwErr);

    return dwErr;
}






DWORD
WINAPI
MibCreate (
    IN ULONG 	InputDataSize,
    IN PVOID 	InputData
    )
/*++

Routine Description
    This function does nothing, since IPSAMPLE does not support creation of
    interface objects via SNMP.  However, this could be implemented as a
    sequence of calls to NM_AddInterface(), IE_BindInterface() and
    IE_EnableInterface.  The input data would then have to contain the
    interface's index, configuration, and binding.

Arguments
    InputData           Relevant input, some struct defined in ipsamplerm.h
    InputDataSize       Size of the input
    
Return Value
    ERROR_CAN_NOT_COMPLETE      for now
    
--*/    
{
    DWORD dwErr = ERROR_CAN_NOT_COMPLETE;

    TRACE2(ENTER, "Entering MibCreate: %u 0x%08x",
           InputDataSize, InputData);

    TRACE1(LEAVE, "Leaving  MibCreate: %u", dwErr);

    return dwErr;
}



DWORD
WINAPI
MibDelete (
    IN ULONG 	InputDataSize,
    IN PVOID 	InputData
    )
/*++

Routine Description
    This function does nothing, since IPSAMPLE does not support deletion of
    interface objects via SNMP.  However, this could be implemented as a
    call to NM_DeleteInterface().  The input data would then have to
    contain the interface's index.

Arguments
    InputData           Relevant input, some struct defined in ipsamplerm.h
    InputDataSize       Size of the input
    
Return Value
    ERROR_CAN_NOT_COMPLETE      for now
    
--*/    
{
    DWORD dwErr = ERROR_CAN_NOT_COMPLETE;

    TRACE2(ENTER, "Entering MibDelete: %u 0x%08x",
           InputDataSize, InputData);

    TRACE1(LEAVE, "Leaving  MibDelete: %u", dwErr);

    return dwErr;
}



DWORD
WINAPI
MibSet (
    IN ULONG 	InputDataSize,
    IN PVOID	InputData
    )
/*++

Routine Description
    This function sets IPSAMPLE's global or interface configuration.

Arguments
    InputData           Relevant input, struct IPSAMPLE_MIB_SET_INPUT_DATA
    InputDataSize       Size of the input
    
Return Value
    NO_ERROR            success
    Error Code          o/w
    
--*/    
{
    DWORD dwErr = NO_ERROR;

    TRACE2(ENTER, "Entering MibSet: %u 0x%08x",
           InputDataSize, InputData);

    do                          // breakout loop
    {
        // validate parameters
        if ((!InputData) or
            (InputDataSize < sizeof(IPSAMPLE_MIB_SET_INPUT_DATA)))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        dwErr = MM_MibSet((PIPSAMPLE_MIB_SET_INPUT_DATA) InputData);

    } while(FALSE);
    
    TRACE1(LEAVE, "Leaving  MibSet: %u", dwErr);

    return dwErr;
}



DWORD
WINAPI
MibGet (
    IN      ULONG	InputDataSize,
    IN      PVOID	InputData,
    IN OUT  PULONG	OutputDataSize,
    OUT     PVOID	OutputData
    )
/*++

Routine Description
    This function retrieves one of...
    . global configuration
    . interface configuration
    . global stats
    . interface stats
    . interface binding

    Called by an admin (SNMP) utility.  It actually passes through the IP
    Router Manager, but all that does is demux the call to the desired
    routing protocol.

Arguments
    InputData           Relevant input, struct IPSAMPLE_MIB_GET_INPUT_DATA
    InputDataSize       Size of the input
    OutputData          Buffer for struct IPSAMPLE_MIB_GET_OUTPUT_DATA
    OutputDataSize      IN  size of output buffer received
                        OUT size of output buffer required
                        
Return Value
    NO_ERROR            success
    Error Code          o/w
    
--*/    
{
    DWORD dwErr = NO_ERROR;

    TRACE4(ENTER, "Entering MibGet: %u 0x%08x 0x%08x 0x%08x",
           InputDataSize, InputData, OutputDataSize, OutputData);

    do                          // breakout loop
    {
        // validate parameters
        if ((!InputData) or
            (InputDataSize < sizeof(IPSAMPLE_MIB_GET_INPUT_DATA)) or
            (!OutputDataSize))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        dwErr = MM_MibGet((PIPSAMPLE_MIB_GET_INPUT_DATA) InputData,
                          (PIPSAMPLE_MIB_GET_OUTPUT_DATA) OutputData,
                          OutputDataSize,
                          GET_EXACT);
        
    } while(FALSE);

    TRACE1(LEAVE, "Leaving  MibGet: %u", dwErr);

    return dwErr;
}



DWORD
WINAPI
MibGetFirst (
    IN      ULONG	InputDataSize,
    IN      PVOID	InputData,
    IN OUT  PULONG  OutputDataSize,
    OUT     PVOID   OutputData
    )
/*++

Routine Description
    This function retrieves one of...
    . global configuration
    . interface configuration
    . global stats
    . interface stats
    . interface binding

    It differs from MibGet() in that it always returns the FIRST entry in
    whichever table is being queried.  There is only one entry in the
    global configuration and global stats tables, but the interface
    configuration, interface stats, and interface binding tables are sorted
    by IP address; this function returns the first entry from these.

Arguments
    InputData           Relevant input, struct IPSAMPLE_MIB_GET_INPUT_DATA
    InputDataSize       Size of the input
    OutputData          Buffer for struct IPSAMPLE_MIB_GET_OUTPUT_DATA
    OutputDataSize      IN  size of output buffer received
                        OUT size of output buffer required
                        
Return Value
    NO_ERROR            success
    Error Code          o/w
    
--*/    
{
    DWORD dwErr = NO_ERROR;

    TRACE4(ENTER, "Entering MibGetFirst: %u 0x%08x 0x%08x 0x%08x",
           InputDataSize, InputData, OutputDataSize, OutputData);

    do                          // breakout loop
    {
        // validate parameters
        if ((!InputData) or
            (InputDataSize < sizeof(IPSAMPLE_MIB_GET_INPUT_DATA)) or
            (!OutputDataSize))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        dwErr = MM_MibGet((PIPSAMPLE_MIB_GET_INPUT_DATA) InputData,
                          (PIPSAMPLE_MIB_GET_OUTPUT_DATA) OutputData,
                          OutputDataSize,
                          GET_FIRST);
        
    } while(FALSE);

    TRACE1(LEAVE, "Leaving  MibGetFirst: %u", dwErr);

    return dwErr;
}



DWORD
WINAPI
MibGetNext (
    IN      ULONG   InputDataSize,
    IN      PVOID	InputData,
    IN OUT  PULONG  OutputDataSize,
    OUT     PVOID	OutputData
    )
/*++

Routine Description
    This function retrieves one of...
    . global configuration
    . interface configuration
    . global stats
    . interface stats
    . interface binding

    It differs from both MibGet() and MibGetFirst() in that it returns the
    entry AFTER the one specified in the indicated table.  Thus, in the
    interface configuration, interface stats, and interface binding tables,
    this function supplies the entry after the one with the input address.

    If there are no more entries in the table being queried we return
    ERROR_NO_MORE_ITEMS.  Unlike SNMP we don't walk to the next table.
    This does not take away any functionality since the NT SNMP agent
    will try the next variable (having ID one greater than the ID passed
    in) automatically on getting this error.

Arguments
    InputData           Relevant input, struct IPSAMPLE_MIB_GET_INPUT_DATA
    InputDataSize       Size of the input
    OutputData          Buffer for struct IPSAMPLE_MIB_GET_OUTPUT_DATA
    OutputDataSize      IN  size of output buffer received
                        OUT size of output buffer required
                        
Return Value
    NO_ERROR            success
    Error Code          o/w
    
--*/    
{
    DWORD                           dwErr   = NO_ERROR;

    TRACE4(ENTER, "Entering MibGetFirst: %u 0x%08x 0x%08x 0x%08x",
           InputDataSize, InputData, OutputDataSize, OutputData);

    do                          // breakout loop
    {
        // validate parameters
        if ((!InputData) or
            (InputDataSize < sizeof(IPSAMPLE_MIB_GET_INPUT_DATA)) or
            (!OutputDataSize))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        dwErr = MM_MibGet((PIPSAMPLE_MIB_GET_INPUT_DATA) InputData,
                          (PIPSAMPLE_MIB_GET_OUTPUT_DATA) OutputData,
                          OutputDataSize,
                          GET_NEXT);

    } while(FALSE);

    TRACE1(LEAVE, "Leaving  MibGetNext: %u", dwErr);

    return dwErr;
}



DWORD
WINAPI
MibSetTrapInfo (
    IN  HANDLE  Event,
    IN  ULONG   InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG	OutputDataSize,
    OUT PVOID	OutputData
    )
/*++

Routine Description
    This function does nothing at the moment...
    
Return Value
    ERROR_CAN_NOT_COMPLETE      for now
    
--*/    
{
    DWORD dwErr = ERROR_CAN_NOT_COMPLETE;

    TRACE0(ENTER, "Entering MibSetTrapInfo");
    TRACE1(LEAVE, "Leaving  MibSetTrapInfo: %u", dwErr);

    return dwErr;
}



DWORD
WINAPI
MibGetTrapInfo (
    IN  ULONG	InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG  OutputDataSize,
    OUT PVOID	OutputData
    )
/*++

Routine Description
    This function does nothing at the moment...
    
Return Value
    ERROR_CAN_NOT_COMPLETE      for now
    
--*/    
{
    DWORD dwErr = ERROR_CAN_NOT_COMPLETE;

    TRACE0(ENTER, "Entering MibGetTrapInfo");
    TRACE1(LEAVE, "Leaving  MibGetTrapInfo: %u", dwErr);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    RegisterProtocol
//
// Returns protocol ID and functionality for IPRIP
//----------------------------------------------------------------------------

DWORD
APIENTRY
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    )
/*++

Routine Description
    This is the first function called by the IP Router Manager.  The Router
    Manager tells the routing protocol its version and capabilities.  It
    also tells our DLL, the ID of the protocol it expects us to register.
    This allows one DLL to support multiple routing protocols.  We return
    the functionality we support and a pointer to our functions.

Arguments
    pRoutingChar    The routing characteristics
    pServiceChar    The service characteristics (IPX 'thingy')

Return Value
    NO_ERROR                success
    ERROR_NOT_SUPPORTED     o/w

--*/    
{
    DWORD   dwErr = NO_ERROR;
    
    TRACE0(ENTER, "Entering RegisterProtocol");

    do                          // breakout loop
    {
        if(pRoutingChar->dwProtocolId != MS_IP_SAMPLE)
        {
            dwErr = ERROR_NOT_SUPPORTED;
            break;
        }

        if  ((pRoutingChar->fSupportedFunctionality
              & (RF_ROUTING|RF_DEMAND_UPDATE_ROUTES)) !=
             (RF_ROUTING|RF_DEMAND_UPDATE_ROUTES))
        {
            dwErr = ERROR_NOT_SUPPORTED;
            break;
        }
    
        pRoutingChar->fSupportedFunctionality =
            (RF_ROUTING | RF_DEMAND_UPDATE_ROUTES);

        // Since we are not a service advertiser (and IPX thing)
        pServiceChar->fSupportedFunctionality = 0;

        pRoutingChar->pfnStartProtocol      = StartProtocol;
        pRoutingChar->pfnStartComplete      = StartComplete;
        pRoutingChar->pfnStopProtocol       = StopProtocol;
        pRoutingChar->pfnGetGlobalInfo      = GetGlobalInfo;
        pRoutingChar->pfnSetGlobalInfo      = SetGlobalInfo;
        pRoutingChar->pfnQueryPower         = NULL;
        pRoutingChar->pfnSetPower           = NULL;

        pRoutingChar->pfnAddInterface       = AddInterface;
        pRoutingChar->pfnDeleteInterface    = DeleteInterface;
        pRoutingChar->pfnInterfaceStatus    = InterfaceStatus;
        pRoutingChar->pfnGetInterfaceInfo   = GetInterfaceConfigInfo;
        pRoutingChar->pfnSetInterfaceInfo   = SetInterfaceConfigInfo;

        pRoutingChar->pfnGetEventMessage    = GetEventMessage;

        pRoutingChar->pfnUpdateRoutes       = DoUpdateRoutes;

        pRoutingChar->pfnConnectClient      = NULL;
        pRoutingChar->pfnDisconnectClient   = NULL;

        pRoutingChar->pfnGetNeighbors       = NULL;
        pRoutingChar->pfnGetMfeStatus       = NULL;

        pRoutingChar->pfnMibCreateEntry     = MibCreate;
        pRoutingChar->pfnMibDeleteEntry     = MibDelete;
        pRoutingChar->pfnMibGetEntry        = MibGet;
        pRoutingChar->pfnMibSetEntry        = MibSet;
        pRoutingChar->pfnMibGetFirstEntry   = MibGetFirst;
        pRoutingChar->pfnMibGetNextEntry    = MibGetNext;
        pRoutingChar->pfnMibSetTrapInfo     = MibSetTrapInfo;
        pRoutingChar->pfnMibGetTrapInfo     = MibGetTrapInfo;
    } while (FALSE);

    TRACE1(LEAVE, "Leaving RegisterProtocol: %u", dwErr);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\socket.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\socket.c
    Assumes an IPv4 IPADDRESS for now...

Abstract:

    The file contains functions to deal with sockets.
    Assumes an IPv4 IPADDRESS for now...

--*/

#include "pchsample.h"
#pragma hdrstop


#define START_SAMPLE_IO()       ENTER_SAMPLE_API()

#define FINISH_SAMPLE_IO()      LEAVE_SAMPLE_API()



////////////////////////////////////////
// CALLBACKFUNCTIONS
////////////////////////////////////////

VOID
WINAPI
SocketCallbackSendCompletion (
    IN  DWORD                   dwErr,
    IN  DWORD                   dwNumSent,
    IN  LPOVERLAPPED            lpOverlapped
    )
/*++

Routine Description
    This routine is invoked by the I/O system upon completion of an
    operation.  Runs in the context of an RTUTILS.DLL worker thread.

Locks
    None.
    
Arguments:
    dwErr                   system-supplied error code
    dwNumSent               system-supplied byte-count
    lpOverlapped            caller-supplied context area

Return Value:
    None.

--*/
{
    PPACKET pPacket = CONTAINING_RECORD(lpOverlapped, PACKET, oOverlapped);

    TRACE3(ENTER, "Entering SocketCallbackSendCompletion: %u %u 0x%08x",
           dwErr, dwNumSent, lpOverlapped);
    PacketDisplay(pPacket);
    

    if ((dwErr != NO_ERROR) or                      // operation aborted
        (dwNumSent != pPacket->wsaBuffer.len))      // data not sent entirely
    {
        TRACE1(NETWORK, "Error %u sending packet", dwErr);
        LOGERR0(SENDTO_FAILED, dwErr);
        
    }

    PacketDestroy(pPacket);     // destroy the packet structure


    TRACE0(LEAVE, "Leaving  SocketCallbackSendCompletion");

    FINISH_SAMPLE_IO();
}



////////////////////////////////////////
// APIFUNCTIONS
////////////////////////////////////////


DWORD
SocketCreate (
    IN  IPADDRESS               ipAddress,
    IN  HANDLE                  hEvent,
    OUT SOCKET                  *psSocket)
/*++

Routine Description
    Creates a socket.

Locks
    None
    
Arguments
    ipAddress           ip address to bind the socket to
    hEvent              the event to set when a packet arrives
    psSocket            address of the socket to create

Return Value
    NO_ERROR            success
    Error Code          o/w

--*/
{
    DWORD           dwErr = NO_ERROR;
    PCHAR           pszBuffer;
    SOCKADDR_IN     sinSockAddr;
    BOOL            bDontLinger, bReuse, bLoopback;
    struct linger   lLinger = { 0, 0 };
    UCHAR           ucTTL;
    struct ip_mreq  imMulticast;

    
    // validate parameters
    if ((!psSocket or (*psSocket != INVALID_SOCKET)) or
        !IP_VALID(ipAddress) or
        (hEvent is INVALID_HANDLE_VALUE))
        return ERROR_INVALID_PARAMETER;

    // default return value
    *psSocket = INVALID_SOCKET;

    
    pszBuffer = INET_NTOA(ipAddress);

    do                          // breakout loop
    {
        // create socket
        *psSocket = WSASocket(AF_INET,            // address family
                              SOCK_RAW,           // type
                              PROTO_IP_SAMPLE,    // protocol
                              NULL,
                              0,
                              WSA_FLAG_OVERLAPPED);
        if(*psSocket is INVALID_SOCKET)
        {
            dwErr = WSAGetLastError();
            TRACE0(NETWORK, "Could not create socket");
            break;
        }

        // associate the socket with our I/O completion port.  the callback
        // function is invoked when an overlapped I/O operation completes.
        // this would be the send operation!
        dwErr = SetIoCompletionProc((HANDLE) *psSocket,
                                    SocketCallbackSendCompletion);
        if (dwErr != NO_ERROR)
        {
            TRACE0(NETWORK, "Could not associate callback function");
            break;
        }


        // set SO_LINGER to off
        // do not linger on close waiting for unsent data to be sent
        bDontLinger = TRUE;
        if (setsockopt(*psSocket,
                       SOL_SOCKET,
                       SO_DONTLINGER,   
                       (const char *) &bDontLinger,
                       sizeof(BOOL)) is SOCKET_ERROR)
        {
            TRACE2(NETWORK,
                   "Error %u setting linger option on %s, continuing...",
                   WSAGetLastError(), pszBuffer);
        }

        // set to SO_REUSEADDR
        // allow socket to be bound to an address that is already in use 
        bReuse = TRUE;
        if (setsockopt(*psSocket,
                       SOL_SOCKET,
                       SO_REUSEADDR,
                       (const char *) &bReuse,
                       sizeof(BOOL)) is SOCKET_ERROR)
        {
            TRACE2(NETWORK,
                   "Error %u seting reuse option on %s, continuing...",
                   WSAGetLastError(), pszBuffer);
        }

        // bind to the specified IPv4 addresses
        ZeroMemory(&sinSockAddr, sizeof(SOCKADDR_IN));
        sinSockAddr.sin_family      = AF_INET;
        sinSockAddr.sin_addr.s_addr = ipAddress;
        sinSockAddr.sin_port        = 0;
        if (bind(*psSocket, (LPSOCKADDR) &sinSockAddr, sizeof(SOCKADDR_IN))
            is SOCKET_ERROR)
        {
            dwErr = WSAGetLastError();
            TRACE0(NETWORK, "Could not bind socket");
            LOGERR1(BIND_IF_FAILED, pszBuffer, dwErr);
            break;
        }


        // allow multicast traffic to be sent out this interface
        if (setsockopt(*psSocket,
                       IPPROTO_IP,
                       IP_MULTICAST_IF,
                       (const char *) &sinSockAddr.sin_addr,
                       sizeof(IN_ADDR)) is SOCKET_ERROR)
        {
            dwErr = WSAGetLastError();
            TRACE2(NETWORK,
                   "Error %u setting interface %s as multicast...",
                   dwErr, pszBuffer);
            LOGERR1(SET_MCAST_IF_FAILED, pszBuffer, dwErr);
            break;
        }
        
        // set loopback to ignore self generated packets.
        bLoopback   = FALSE;
        if (setsockopt(*psSocket,
                       IPPROTO_IP,
                       IP_MULTICAST_LOOP,
                       (const char *) &bLoopback,
                       sizeof(BOOL)) is SOCKET_ERROR)
        {
            TRACE2(NETWORK,
                   "Error %u setting loopback to FALSE on %s, continuing...",
                   WSAGetLastError(), pszBuffer);
        }
        
        // set TTL to 1 to restrict packet to within subnet (default anyway)
        ucTTL  = 1;
        if (setsockopt(*psSocket,
                       IPPROTO_IP,
                       IP_MULTICAST_TTL,
                       (const char *) &ucTTL,
                       sizeof(UCHAR)) is SOCKET_ERROR)
        {
            TRACE2(NETWORK,
                   "Error %u setting mcast ttl to 1 on %s, continuing...",
                   WSAGetLastError(), pszBuffer);
        }
        
        // join the multicast session on SAMPLE_PROTOCOL_MULTICAST_GROUP.
        imMulticast.imr_multiaddr.s_addr = SAMPLE_PROTOCOL_MULTICAST_GROUP;
        imMulticast.imr_interface.s_addr = ipAddress;
        if (setsockopt(*psSocket,
                       IPPROTO_IP,
                       IP_ADD_MEMBERSHIP,
                       (const char *) &imMulticast,
                       sizeof(struct ip_mreq)) is SOCKET_ERROR)
        {
            dwErr = WSAGetLastError();
            TRACE0(NETWORK, "Could not join multicast group on socket");
            LOGERR1(JOIN_GROUP_FAILED, pszBuffer, dwErr);
            break;
        }


        // associate hReceiveEvent with the receive network event
        if (WSAEventSelect(*psSocket, (WSAEVENT) hEvent, FD_READ)
            is SOCKET_ERROR)
        {
            dwErr = WSAGetLastError();
            TRACE1(NETWORK, "Error %u calling WSAEventSelect()", dwErr);
            LOGERR0(EVENTSELECT_FAILED, dwErr);
            break;
        }
    } while(FALSE);

    if (dwErr != NO_ERROR)
    {
        TRACE2(NETWORK, "Error %u creating socket for %s", dwErr, pszBuffer);
        LOGERR0(CREATE_SOCKET_FAILED, dwErr);
        SocketDestroy(*psSocket);
        *psSocket = INVALID_SOCKET;
    }

    return dwErr;
}


    
DWORD
SocketDestroy (
    IN  SOCKET                  sSocket)
/*++

Routine Description
    Closes a socket.

Locks
    None
    
Arguments
    sSocket             the socket to close

Return Value
    NO_ERROR            success
    Error Code          o/w

--*/
{
    DWORD dwErr = NO_ERROR;
    
    if (sSocket is INVALID_SOCKET)
        return NO_ERROR;

    /*
    // closing a socket with closesocket also cancels the association and
    // selection of network events specified in WSAEventSelect.  redundant!
    if (WSAEventSelect(sSocket, (WSAEVENT) NULL, 0) is SOCKET_ERROR)
    {
        dwErr = WSAGetLastError();
        TRACE1(NETWORK, "Error %u clearing socket-event association", dwErr);
        LOGERR0(EVENTSELECT_FAILED, dwErr);
    }
    */
    
    // close the socket
    if (closesocket(sSocket) != NO_ERROR)
    {
        dwErr = WSAGetLastError();
        TRACE1(NETWORK, "Error %u closing socket", dwErr);
        LOGERR0(DESTROY_SOCKET_FAILED, dwErr);
    }
    
    return dwErr;
}



DWORD
SocketSend (
    IN  SOCKET                  sSocket,
    IN  IPADDRESS               ipDestination,
    IN  PPACKET                 pPacket)
/*++

Routine Description
    Send a packet to its destination and destroy it.
    Asynchronous.
    
Locks
    None
    
Arguments
    sSocket             the socket to send the packet over
    ipDestination       the packet's destination
    pPacket             the packet to send out
    
Return Value
    NO_ERROR            success
    Error Code          o/w

--*/
{
    DWORD           dwErr = NO_ERROR;
    SOCKADDR_IN     sinDestination;
    DWORD           dwScratch;
    
    if (!START_SAMPLE_IO()) { return ERROR_CAN_NOT_COMPLETE; }
    

    // validate parameters
    if ((sSocket is INVALID_SOCKET) or !pPacket)
        return ERROR_INVALID_PARAMETER;


    ZeroMemory(&sinDestination, sizeof(SOCKADDR_IN));
    sinDestination.sin_family      = AF_INET;
    sinDestination.sin_addr.s_addr = ipDestination;
    sinDestination.sin_port        = 0;
    dwErr = WSASendTo(sSocket,
                      &(pPacket->wsaBuffer),        // buffer and length 
                      1,                            // only one wsabuf exists
                      &dwScratch,                   // unused
                      0,                            // no flags
                      (PSOCKADDR) &sinDestination,  
                      sizeof(SOCKADDR_IN),
                      &pPacket->oOverlapped,        // context upon completion 
                      NULL);                        // no completion routine

    // completion routine (SocketCallbackSendCompletion) queued
    if (((dwErr is SOCKET_ERROR) and (WSAGetLastError() is WSA_IO_PENDING)) or
        (dwErr is NO_ERROR))
    {
        return NO_ERROR;
    }

    // completion routine (SocketCallbackSendCompletion) not queued
    dwErr = WSAGetLastError();
    TRACE1(NETWORK, "Error %u sending packet", dwErr);
    LOGERR0(SENDTO_FAILED, dwErr);

    FINISH_SAMPLE_IO();

    return dwErr;
}



DWORD
SocketReceive (
    IN  SOCKET                  sSocket,
    IN  PPACKET                 pPacket)
/*++

Routine Description
    Receive a packet on a socket.
    
    This routine is written so that it could dynamically allocate a buffer,
    not knowing a priori the maximum size of the protocol's packet.  It is
    synchronous, treating sSocket as a non overlapped socket.

Locks
    None
    
Arguments
    sSocket             the socket to send the packet over
    pPacket             the packet to send out
    
Return Value
    NO_ERROR            success
    Error Code          o/w

--*/
#define IPv4_PREVIEW_SIZE               4
#define IPv4_LENGTH_OFFSET              2
{
    DWORD       dwErr = NO_ERROR;
    BYTE        rgbyPreview[IPv4_PREVIEW_SIZE];
    DWORD       dwNumReceived, dwFlags;
    INT         iSourceLength;
    SOCKADDR_IN sinSource;
    DWORD       dwPacketLength;
    
    // validate parameters
    if ((sSocket is INVALID_SOCKET) or !pPacket)
        return ERROR_INVALID_PARAMETER;

    do                          // breakout loop
    {
        // read enuf to figure length
        pPacket->wsaBuffer.buf  = rgbyPreview;
        pPacket->wsaBuffer.len  = IPv4_PREVIEW_SIZE;
        dwFlags                 = MSG_PEEK;
        iSourceLength = sizeof(SOCKADDR_IN);
  
        dwErr = WSARecvFrom(sSocket,
                            &(pPacket->wsaBuffer),  // buffer and length 
                            1,                      // only one wsabuf exists
                            &dwNumReceived,         // # bytes received
                            &dwFlags,               // flags
                            (PSOCKADDR) &sinSource,
                            &iSourceLength,
                            NULL,                   // no context
                            NULL);                  // no completion routine
        if (dwErr != SOCKET_ERROR)  // there should have been an error
            break;
        dwErr = WSAGetLastError();
        if (dwErr != WSAEMSGSIZE)   // of this kind 
            break;
        if (dwNumReceived != pPacket->wsaBuffer.len)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        
        // calculate the packet length
        dwPacketLength = ntohs(*((PUSHORT)(rgbyPreview + IPv4_LENGTH_OFFSET)));
        if (dwPacketLength > MAX_PACKET_LENGTH)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        
        // read the entire packet, the buffer could be dynamically allocated
        pPacket->wsaBuffer.buf  = pPacket->rgbyBuffer;
        pPacket->wsaBuffer.len  = dwPacketLength;
        dwFlags                 = 0;
        iSourceLength = sizeof(SOCKADDR_IN);
  
        dwErr = WSARecvFrom(sSocket,
                            &(pPacket->wsaBuffer),  // buffer and length 
                            1,                      // only one wsabuf exists
                            &dwNumReceived,         // # bytes received
                            &dwFlags,               // flags
                            (PSOCKADDR) &sinSource,
                            &iSourceLength,
                            NULL,                   // no context
                            NULL);                  // no completion routine
        if (dwErr is SOCKET_ERROR)
        {
            dwErr = WSAGetLastError();
            break;
        }
        if (dwPacketLength != dwNumReceived)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        
        pPacket->ipSource       = sinSource.sin_addr.s_addr;
        pPacket->wsaBuffer.len  = dwNumReceived;

        dwErr = NO_ERROR;
    } while (FALSE);

    if (dwErr != NO_ERROR)
    {
        TRACE1(NETWORK, "Error %u receiving packet", dwErr);
        LOGERR0(RECVFROM_FAILED, dwErr);
    }

    return dwErr;
}



BOOL
SocketReceiveEvent (
    IN  SOCKET                  sSocket)
/*++

Routine Description
    Indicates whether a receive event occured on a socket.  The recording
    of network events commences when WSAEventSelect is called with a
    nonzero lNetworkEvents parameter (i.e. the socket is activated) and
    remains in effect until another call is made to WSAEventSelect with the
    lNetworkEvents parameter set to zero (i.e. the socket is deactivated).

Locks
    None
    
Arguments
    sSocket             the socket to check for packet reception
    
Return Value
    TRUE                receive event did occur
    FALSE               o/w

--*/
{
    DWORD               dwErr = NO_ERROR;
    WSANETWORKEVENTS    wsaEvent;

    // validate parameters
    if (sSocket is INVALID_SOCKET)
        return ERROR_INVALID_PARAMETER;

    do                          // breakout loop
    {
        // enumerate network events to see if any packets have arrived on
        dwErr = WSAEnumNetworkEvents(sSocket, NULL, &wsaEvent);
        if (dwErr != NO_ERROR)
        {
            TRACE1(NETWORK, "Error %u enumerating network events", dwErr);
            LOGERR0(ENUM_NETWORK_EVENTS_FAILED, dwErr);
            break;
        }

        // see if the input bit is set
        if (!(wsaEvent.lNetworkEvents & FD_READ))
        {
            dwErr = SOCKET_ERROR;
            break;
        }
        
        // the input bit is set, now see if there was an error
        dwErr = wsaEvent.iErrorCode[FD_READ_BIT];
        if (dwErr != NO_ERROR)
        {
            TRACE1(NETWORK, "Error %u in input record", dwErr);
            LOGERR0(INPUT_RECORD_ERROR, dwErr);
            break;
        }
    } while (FALSE);
    
    if (dwErr is NO_ERROR)
        return TRUE;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\socket.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\socket.h

Abstract:

    The file contains the header for socket.c

--*/

#ifndef _SOCKET_H_
#define _SOCKET_H_

DWORD
SocketCreate (
    IN  IPADDRESS               ipAddress,
    IN  HANDLE                  hEvent,
    OUT SOCKET                  *psSocket);

DWORD
SocketDestroy (
    IN  SOCKET                  sSocket);

DWORD
SocketSend (
    IN  SOCKET                  sSocket,
    IN  IPADDRESS               ipDestination,
    IN  PPACKET                 pPacket);

DWORD
SocketReceive (
    IN  SOCKET                  sSocket,
    IN  PPACKET                 pPacket);

BOOL
SocketReceiveEvent (
    IN  SOCKET                  sSocket);

#endif // _SOCKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\sync.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\sync.h

Abstract:

    The file contains the READ_WRITE_LOCK definition which allows
    multiple-reader/single-writer.

--*/

#ifndef _SYNC_H_
#define _SYNC_H_

//
// type definition for READ_WRITE_LOCK
//

typedef struct _READ_WRITE_LOCK
{
    CRITICAL_SECTION    RWL_ReadWriteBlock;
    LONG                RWL_ReaderCount;
    HANDLE              RWL_ReaderDoneEvent;
} READ_WRITE_LOCK, *PREAD_WRITE_LOCK;



DWORD
CreateReadWriteLock(
    PREAD_WRITE_LOCK pRWL);

VOID
DeleteReadWriteLock(
    PREAD_WRITE_LOCK pRWL);

VOID
AcquireReadLock(
    PREAD_WRITE_LOCK pRWL);

VOID
ReleaseReadLock(
    PREAD_WRITE_LOCK pRWL);

VOID
AcquireWriteLock(
    PREAD_WRITE_LOCK pRWL);

VOID
ReleaseWriteLock(
    PREAD_WRITE_LOCK pRWL);



//
// macro functions for manipulating a read-write lock
//

#define CREATE_READ_WRITE_LOCK(pRWL)                                \
    CreateReadWriteLock(pRWL)
#define DELETE_READ_WRITE_LOCK(pRWL)                                \
    DeleteReadWriteLock(pRWL)
#define READ_WRITE_LOCK_CREATED(pRWL)                               \
    ((pRWL)->RWL_ReaderDoneEvent != NULL)

#define ACQUIRE_READ_LOCK(pRWL)                                     \
    AcquireReadLock(pRWL)
#define RELEASE_READ_LOCK(pRWL)                                     \
    ReleaseReadLock(pRWL)
#define ACQUIRE_WRITE_LOCK(pRWL)                                    \
    AcquireWriteLock(pRWL)
#define RELEASE_WRITE_LOCK(pRWL)                                    \
    ReleaseWriteLock(pRWL)

// atomic.  works since a critical section can be entered recursively.        
#define WRITE_LOCK_TO_READ_LOCK(pRWL)                               \
{                                                                   \
    ACQUIRE_READ_LOCK(pRWL);                                        \
    RELEASE_WRITE_LOCK(pRWL);                                       \
}
                
                
//
// type definition for generic locked list
// access is sychronized with a critical section
//

typedef struct _LOCKED_LIST
{
    CRITICAL_SECTION    lock;
    LIST_ENTRY          head;
    DWORD               created;
} LOCKED_LIST, *PLOCKED_LIST;

//
//  VOID
//  INITIALIZE_LOCKED_LIST (
//      PLOCKED_LIST   pLL
//      );
//
#define INITIALIZE_LOCKED_LIST(pLL)                                 \
{                                                                   \
    do                                                              \
    {                                                               \
        __try {                                                     \
            InitializeCriticalSection(&((pLL)->lock));              \
        }                                                           \
        __except (EXCEPTION_EXECUTE_HANDLER) {                      \
            break;                                                  \
        }                                                           \
        InitializeListHead(&((pLL)->head));                         \
        (pLL)->created = 0x12345678;                                \
    } while (FALSE);                                                \
}

//
//  BOOL
//  LOCKED_LIST_INITIALIZED (
//      PLOCKED_LIST    pLL
//      );
//
#define LOCKED_LIST_INITIALIZED(pLL)                                \
     ((pLL)->created == 0x12345678)

//
//  VOID
//  DELETE_LOCKED_LIST (
//      PLOCKED_LIST    pLL,
//      VOID(*FreeFunction)(PLIST_ENTRY)         
//      );
//
#define DELETE_LOCKED_LIST(pLL, FreeFunction)                       \
{                                                                   \
     (pLL)->created = 0;                                            \
     FreeList(&((pLL)->head), FreeFunction);                        \
     DeleteCriticalSection(&(pLL)->lock);                           \
}

#define ACQUIRE_LIST_LOCK(pLL)                                      \
     EnterCriticalSection(&(pLL)->lock)

#define RELEASE_LIST_LOCK(pLL)                                      \
     LeaveCriticalSection(&(pLL)->lock)


         
#define LOCKED_QUEUE    LOCKED_LIST
#define PLOCKED_QUEUE   PLOCKED_LIST

         
#define INITIALIZE_LOCKED_QUEUE(pLQ)                                \
     INITIALIZE_LOCKED_LIST(pLQ)
#define LOCKED_QUEUE_INITIALIZED(pLQ)                               \
     LOCKED_LIST_INITIALIZED(pLQ)
#define DELETE_LOCKED_QUEUE(pLQ, FreeFunction)                      \
     DELETE_LOCKED_LIST(pLQ, FreeFunction)
#define ACQUIRE_QUEUE_LOCK(pLQ)                                     \
     ACQUIRE_LIST_LOCK(pLQ)
#define RELEASE_QUEUE_LOCK(pLQ)                                     \
     RELEASE_LIST_LOCK(pLQ)



//
// type definition for DYNAMIC_READWRITE_LOCK
//
typedef struct _DYNAMIC_READWRITE_LOCK {
    READ_WRITE_LOCK     rwlLock;
    union
    {
        ULONG           ulCount;    // number of waiting threads
        LIST_ENTRY      leLink;     // link in list of free locks
    };
} DYNAMIC_READWRITE_LOCK, *PDYNAMIC_READWRITE_LOCK;

//
// type definition of DYNAMIC_LOCKS_STORE
// store of free dynamic locks that can be allocated as required.
//
typedef struct _DYNAMIC_LOCKS_STORE {
    HANDLE              hHeap;
    
    LOCKED_LIST         llFreeLocksList;

    ULONG               ulCountAllocated;
    ULONG               ulCountFree;
} DYNAMIC_LOCKS_STORE, *PDYNAMIC_LOCKS_STORE;



// if more than DYNAMIC_LOCKS_HIGH_THRESHOLD locks are
// allocated then any locks that are freed are destroyed
#define DYNAMIC_LOCKS_HIGH_THRESHOLD 7

#define DYNAMIC_LOCKS_STORE_INITIALIZED(pStore)                     \
    (LOCKED_LIST_INITIALIZED(&(pStore)->llFreeLocksList))

typedef enum { READ_MODE, WRITE_MODE } LOCK_MODE;

DWORD
InitializeDynamicLocksStore (
    PDYNAMIC_LOCKS_STORE    pStore,
    HANDLE                  hHeap
    );

DWORD
DeInitializeDynamicLocksStore (
    PDYNAMIC_LOCKS_STORE    pStore
    );

DWORD
AcquireDynamicReadwriteLock (
    PDYNAMIC_READWRITE_LOCK *ppLock,
    LOCK_MODE               lmMode,
    PDYNAMIC_LOCKS_STORE    pStore
    );

VOID
ReleaseDynamicReadwriteLock (
    PDYNAMIC_READWRITE_LOCK *ppLock,
    LOCK_MODE               lmMode,
    PDYNAMIC_LOCKS_STORE    pStore
    );

#endif // _SYNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\test.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\test.c

Abstract:

    The file contains test utilities.

--*/

#include "pchsample.h"
#pragma hdrstop

#ifdef TEST

#define TEST_NUM_IE         230
#define TEST_NUM_INTERFACE  2
#define TEST_SLEEP_TIME     3*PERIODIC_INTERVAL
#define TEST_NUM_START_STOP 2


VOID
ErrorCodes()
{
    TRACE1(DEBUG, "ERROR_CAN_NOT_COMPLETE: %u",
           ERROR_CAN_NOT_COMPLETE);
    TRACE1(DEBUG, "ERROR_INSUFFICIENT_BUFFER: %u",
           ERROR_INSUFFICIENT_BUFFER);
    TRACE1(DEBUG, "ERROR_NO_MORE_ITEMS: %u",
           ERROR_NO_MORE_ITEMS);
    TRACE1(DEBUG, "ERROR_INVALID_PARAMETER: %u",
           ERROR_INVALID_PARAMETER);
}



VOID
HT_Test()
{
    ULONG               i, ulNumDeleted = 0, ulNumGotten = 0;
    DWORD               dwErr;
    PNETWORK_ENTRY      pneNetworkEntry;
    PINTERFACE_ENTRY    pieInterfaceEntry;
    INTERFACE_ENTRY     ieKey;
    PLIST_ENTRY         plePtr;
    WCHAR               pwszIfName[20];
    
    do                          // breakout loop
    {
        dwErr = NE_Create(&pneNetworkEntry);
        if (dwErr != NO_ERROR)
        {
            TRACE0(DEBUG, "HT_Test: Could not create NetworkEntry");
            break;
        }
    
        for (i = 0; i < TEST_NUM_IE; i++)
        {
            swprintf(pwszIfName, L"if%u", i);
            dwErr = IE_Create(pwszIfName,
                              i,
                              IEFLAG_MULTIACCESS,
                              &pieInterfaceEntry);
            if (dwErr != NO_ERROR)
            {
                TRACE1(DEBUG, "HT_Test: Could not Create %u", i);
                break;
            }

            dwErr = HT_InsertEntry(pneNetworkEntry->phtInterfaceTable,
                                   &(pieInterfaceEntry->leInterfaceTableLink));
            if (dwErr != NO_ERROR)
            {
                TRACE1(DEBUG, "HT_Test: Could not Insert %u", i);
                break;  
            }
        }   

        TRACE1(DEBUG, "Hash Table Size %u",
               HT_Size(pneNetworkEntry->phtInterfaceTable));
    
        for (i = 0; i < TEST_NUM_IE; i += 2)
        {
            ieKey.dwIfIndex = i;
        
            dwErr = HT_DeleteEntry(pneNetworkEntry->phtInterfaceTable,
                                   &(ieKey.leInterfaceTableLink),
                                   &plePtr);
            if (dwErr != NO_ERROR)
            {
                TRACE1(DEBUG, "HT_Test: Could not Delete %u", i);
                break;
            }

            // indicate deletion
            InitializeListHead(plePtr);
            IE_Destroy(CONTAINING_RECORD(plePtr,
                                         INTERFACE_ENTRY,
                                         leInterfaceTableLink));
            ulNumDeleted++;
        }   

        TRACE2(DEBUG, "NumDeleted %u Hash Table Size %u",
               ulNumDeleted, HT_Size(pneNetworkEntry->phtInterfaceTable));

        for (i = 0; i < TEST_NUM_IE; i++)
        {
            ieKey.dwIfIndex = i;
        
            if (HT_IsPresentEntry(pneNetworkEntry->phtInterfaceTable,
                                  &(ieKey.leInterfaceTableLink)))
            {   
                dwErr = HT_GetEntry(pneNetworkEntry->phtInterfaceTable,
                                    &(ieKey.leInterfaceTableLink),
                                    &plePtr);

                if (dwErr != NO_ERROR)
                {
                    TRACE1(DEBUG, "HT_Test: Could not Get %u", i);
                    break;
                }

                ulNumGotten++;
            }   
        }

        TRACE1(DEBUG, "NumGotten %u", ulNumGotten);
    } while (FALSE);
    
    NE_Destroy(pneNetworkEntry);
}



VOID
MM_Test(HANDLE  hEvent)
{
    ROUTING_PROTOCOL_EVENTS         rpeEvent;
    MESSAGE                         mMessage;
    ULONG                           ulSize;
    BYTE                            byBuffer[100];
    PIPSAMPLE_GLOBAL_CONFIG         pigc;
    PIPSAMPLE_IP_ADDRESS            piia;
    PIPSAMPLE_IF_BINDING            piib;
    PIPSAMPLE_IF_CONFIG             piic;
    
    IPSAMPLE_MIB_GET_INPUT_DATA     imgid;
    PIPSAMPLE_MIB_SET_INPUT_DATA    pimsid = 
        (PIPSAMPLE_MIB_SET_INPUT_DATA) byBuffer;
    PIPSAMPLE_MIB_GET_OUTPUT_DATA   pimgod =
        (PIPSAMPLE_MIB_GET_OUTPUT_DATA) byBuffer;
    
    
    // mib set global configuration
    pimsid->IMSID_TypeID        = IPSAMPLE_GLOBAL_CONFIG_ID;
    pimsid->IMSID_BufferSize    = sizeof(IPSAMPLE_GLOBAL_CONFIG);
    pigc = (PIPSAMPLE_GLOBAL_CONFIG) pimsid->IMSID_Buffer;
    pigc->dwLoggingLevel = IPSAMPLE_LOGGING_ERROR;
    MM_MibSet(pimsid);
    TRACE2(MIB, "MIB SET: %u %u", pimsid->IMSID_TypeID, pigc->dwLoggingLevel);

    WaitForSingleObject(hEvent, INFINITE);
    CM_GetEventMessage(&rpeEvent, &mMessage);
    TRACE1(DEBUG, "SetMib %u", rpeEvent);
    

    // mib get global configuration
    ulSize = 0;
    imgid.IMGID_TypeID = IPSAMPLE_GLOBAL_CONFIG_ID;
    pigc = (PIPSAMPLE_GLOBAL_CONFIG) pimgod->IMGOD_Buffer;

    MM_MibGet(&imgid, pimgod, &ulSize, GET_EXACT);
    TRACE3(MIB, "MIB GET: %u %u %u",
           ulSize, pimgod->IMGOD_TypeID, pigc->dwLoggingLevel);
    
    MM_MibGet(&imgid, pimgod, &ulSize, GET_EXACT);
    TRACE3(MIB, "MIB GET: %u %u %u",
           ulSize, pimgod->IMGOD_TypeID, pigc->dwLoggingLevel);
    

    // mib get first interface binding
    ulSize = 0;
    imgid.IMGID_TypeID  = IPSAMPLE_IF_BINDING_ID;
    imgid.IMGID_IfIndex = 0;
    piib = (PIPSAMPLE_IF_BINDING) pimgod->IMGOD_Buffer;
    piia = IPSAMPLE_IF_ADDRESS_TABLE(piib);
    
    MM_MibGet(&imgid, pimgod, &ulSize, GET_FIRST);
    TRACE4(MIB, "MIB GET: %u %u %u %u",
           ulSize, pimgod->IMGOD_TypeID, piib->dwState, piib->ulCount);

    MM_MibGet(&imgid, pimgod, &ulSize, GET_FIRST);
    TRACE5(MIB, "MIB GET: %u %u %u %u %u",
           ulSize, pimgod->IMGOD_TypeID, piib->dwState, piib->ulCount,
           piia->dwAddress);


    // mib get next interface binding
    ulSize = 0;    
    MM_MibGet(&imgid, pimgod, &ulSize, GET_NEXT);
    TRACE4(MIB, "MIB GET: %u %u %u %u",
           ulSize, pimgod->IMGOD_TypeID, piib->dwState, piib->ulCount);

    MM_MibGet(&imgid, pimgod, &ulSize, GET_NEXT);
    TRACE5(MIB, "MIB GET: %u %u %u %u %u",
           ulSize, pimgod->IMGOD_TypeID, piib->dwState, piib->ulCount,
           piia->dwAddress);


    // mib set interface configuration
    pimsid->IMSID_TypeID        = IPSAMPLE_IF_CONFIG_ID;
    pimsid->IMSID_IfIndex       = 0;
    pimsid->IMSID_BufferSize    = sizeof(IPSAMPLE_IF_CONFIG);
    piic = (PIPSAMPLE_IF_CONFIG) pimsid->IMSID_Buffer;
    piic->ulMetric              = 0;
    MM_MibSet(pimsid);
    TRACE1(MIB, "MIB SET: %u", pimsid->IMSID_TypeID);

    WaitForSingleObject(hEvent, INFINITE);
    CM_GetEventMessage(&rpeEvent, &mMessage);
    TRACE1(DEBUG, "SetMib %u", rpeEvent);


    // mib get interface configuration
    ulSize = 0;
    imgid.IMGID_TypeID  = IPSAMPLE_IF_CONFIG_ID;
    imgid.IMGID_IfIndex = 0;
    piic = (PIPSAMPLE_IF_CONFIG) pimgod->IMGOD_Buffer;
    
    MM_MibGet(&imgid, pimgod, &ulSize, GET_EXACT);
    TRACE3(MIB, "MIB GET: %u %u %u",
           ulSize, pimgod->IMGOD_TypeID, piic->ulMetric);
    

    MM_MibGet(&imgid, pimgod, &ulSize, GET_EXACT);
    TRACE3(MIB, "MIB GET: %u %u %u",
           ulSize, pimgod->IMGOD_TypeID, piic->ulMetric);
}



VOID
NM_Test(HANDLE  hEvent)
{
    DWORD                       dwErr = NO_ERROR;
    ULONG                       i;
    WCHAR                       pwszIfName[20];
    ROUTING_PROTOCOL_EVENTS     rpeEvent;
    MESSAGE                     mMessage;
    IPSAMPLE_IF_CONFIG          iic = { 1 };
    PIP_ADAPTER_BINDING_INFO    pBinding;

    MALLOC(&pBinding,
           (sizeof(IP_ADAPTER_BINDING_INFO) + 3 * sizeof(IP_LOCAL_BINDING)),
           &dwErr);
    pBinding->AddressCount = 3;
    pBinding->Address[0].Address    = 0xfffffffd;
    pBinding->Address[0].Mask       = 0xffffffff;
    pBinding->Address[1].Address    = INADDR_ANY;
    pBinding->Address[1].Mask       = 0xffffffff;
    pBinding->Address[2].Address    = 0xfffffffe;
    pBinding->Address[2].Mask       = 0xffffffff;
    

    // add interfaces
    for (i = 0; i < TEST_NUM_INTERFACE; i++)
    {
        swprintf(pwszIfName, L"if%u", i);
        dwErr = NM_AddInterface(pwszIfName,
                                i,
                                PERMANENT,
                                &iic);
        if (dwErr != NO_ERROR)
        {
            TRACE1(DEBUG, "NM_Test: Could not Add Interface %u", i);
            break;
        }
    }
    TRACE1(DEBUG, "...AddInterface %u", dwErr);
    CE_Display(&g_ce);


    // bind interfaces
    for (i = 0; i < TEST_NUM_INTERFACE; i++)
    {
        pBinding->Address[0].Address    = i;
    
        dwErr = NM_InterfaceStatus(i,
                                   FALSE,
                                   RIS_INTERFACE_ADDRESS_CHANGE,
                                   (PVOID) pBinding);
        if (dwErr != NO_ERROR)
        {
            TRACE1(DEBUG, "NM_Test: Could not Bind Interface %u", i);
            break;
        }
    }
    TRACE1(DEBUG, "...BindInterface %u", dwErr);
    CE_Display(&g_ce);

    // activate interfaces
    for (i = 0; i < TEST_NUM_INTERFACE; i++)
    {
        dwErr = NM_InterfaceStatus(i,
                                   TRUE,
                                   RIS_INTERFACE_ENABLED,
                                   NULL);
        if (dwErr != NO_ERROR)
        {
            TRACE1(DEBUG, "NM_Test: Could not Activate Interface %u", i);
            break;
        }
    }
    TRACE1(DEBUG, "...ActivateInterface %u", dwErr);
    CE_Display(&g_ce);

    for (i = 0; i < TEST_NUM_INTERFACE; i++)
    {
        dwErr = NM_DoUpdateRoutes(i);
        if (dwErr != NO_ERROR)
        {
            TRACE1(DEBUG, "NM_Test: Couldn't UpdateRoutes on Interface %u", i);
            break;
        }
        
        dwErr = WaitForSingleObject(hEvent, INFINITE);
        dwErr = CM_GetEventMessage(&rpeEvent, &mMessage);
        TRACE2(DEBUG, "DidUpdateRoutes %u %u", rpeEvent, dwErr);
    }
    TRACE1(DEBUG, "...DoUpdateRoutes %u", dwErr);
    CE_Display(&g_ce);


    // interface is active (enabled and bound)
    TRACE1(DEBUG, "Sleeping...", dwErr);
    Sleep(SECTOMILLISEC(TEST_SLEEP_TIME));
    TRACE1(DEBUG, "...Awake", dwErr);


    // mib manager test
    MM_Test(hEvent);
    TRACE0(DEBUG, "...MM_Test");
    

    // deactivate interfaces
    for (i = 0; i < TEST_NUM_INTERFACE; i++)
    {
        dwErr = NM_InterfaceStatus(i,
                                   FALSE,
                                   RIS_INTERFACE_DISABLED,
                                   NULL);
        if (dwErr != NO_ERROR)
        {
            TRACE1(DEBUG, "NM_Test: Could not Deactivate Interface %u", i);
            break;
        }
    }
    TRACE1(DEBUG, "...DeactivateInterface %u", dwErr);
    CE_Display(&g_ce);
    
    
    // unbind interfaces
    pBinding->AddressCount = 0;
    for (i = 0; i < TEST_NUM_INTERFACE; i++)
    {
        dwErr = NM_InterfaceStatus(i,
                                   FALSE,
                                   RIS_INTERFACE_ADDRESS_CHANGE,
                                   (PVOID) pBinding);
        if (dwErr != NO_ERROR)
        {
            TRACE1(DEBUG, "NM_Test: Could not Unbind Interface %u", i);
            break;
        }
    }
    TRACE1(DEBUG, "...UnbindInterface %u", dwErr);
    CE_Display(&g_ce);


    // delete interfaces
    for (i = 0; i < TEST_NUM_INTERFACE; i++)
    {
        dwErr = NM_DeleteInterface(i);
        if (dwErr != NO_ERROR)
        {
            TRACE1(DEBUG, "CM_Test: Could not Delete Interface %u", i);
            break;
        }
    }
    TRACE1(DEBUG, "...DeleteInterface %u", dwErr);
    CE_Display(&g_ce);
}



VOID
CM_Test()
{
    DWORD                   dwErr = NO_ERROR;
    IPSAMPLE_GLOBAL_CONFIG  igc = { IPSAMPLE_LOGGING_INFO };
    ROUTING_PROTOCOL_EVENTS rpeEvent;
    MESSAGE                 mMessage;
    HANDLE                  hEvent;

    hEvent = CreateEvent(NULL, FALSE, FALSE, "RouterManagerEvent");


    // start protocol
    dwErr = CM_StartProtocol(hEvent, NULL, (PVOID) (&igc));
    TRACE1(DEBUG, "StartProtocol %u", dwErr);
    CE_Display(&g_ce);

    
    // network manager test
    NM_Test(hEvent);
    TRACE0(DEBUG, "...NM_Test");


    // stop protocol
    dwErr = CM_StopProtocol();
    TRACE1(DEBUG, "StopProtocol %u", dwErr);
    CE_Display(&g_ce);


    // wait for stop event
    dwErr = WaitForSingleObject(hEvent, INFINITE);
    dwErr = CM_GetEventMessage(&rpeEvent, &mMessage);
    TRACE2(DEBUG, "Stopped %u %u", rpeEvent, dwErr);
    CE_Display(&g_ce);

    CloseHandle(hEvent);
}



VOID
WINAPI
TestProtocol(VOID)
{
    ULONG   i;

    TRACE0(DEBUG, "Hello World!!!");

    for (i = 0; i < TEST_NUM_START_STOP; i++)
    {
        CM_Test();
        TRACE1(DEBUG, "...CM_Test (%u)", i);
    }

    HT_Test();
    TRACE0(DEBUG, "...HT_Test");

    ErrorCodes();
    TRACE0(DEBUG, "...ErrorCodes");
}

#else   // TEST

VOID
WINAPI
TestProtocol(VOID)
{
    TRACE0(ANY, "Hello World!");
}

#endif  // TEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\sync.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\sync.h

Abstract:

    The file contains the READ_WRITE_LOCK definition which allows
    multiple-reader/single-writer.  This implementation DOES NOT
    starve a thread trying to acquire write accesss if there are
    a large number of threads interested in acquiring read access.

--*/

#include "pchsample.h"
#pragma hdrstop

//----------------------------------------------------------------------------
// Function: CreateReadWriteLock
//
// Initializes a multiple-reader/single-writer lock object
//----------------------------------------------------------------------------

DWORD
CreateReadWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    pRWL->RWL_ReaderCount = 0;

    __try {
        InitializeCriticalSection(&(pRWL)->RWL_ReadWriteBlock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        return GetLastError();
    }

    pRWL->RWL_ReaderDoneEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    if (pRWL->RWL_ReaderDoneEvent != NULL) {
        return GetLastError();
    }

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    DeleteReadWriteLock
//
// Frees resources used by a multiple-reader/single-writer lock object
//----------------------------------------------------------------------------

VOID
DeleteReadWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    CloseHandle(pRWL->RWL_ReaderDoneEvent);
    pRWL->RWL_ReaderDoneEvent = NULL;
    DeleteCriticalSection(&pRWL->RWL_ReadWriteBlock);
    pRWL->RWL_ReaderCount = 0;
}



//----------------------------------------------------------------------------
// Function:    AcquireReadLock
//
// Secures shared ownership of the lock object for the caller.
//
// readers enter the read-write critical section, increment the count,
// and leave the critical section
//----------------------------------------------------------------------------

VOID
AcquireReadLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    EnterCriticalSection(&pRWL->RWL_ReadWriteBlock); 
    InterlockedIncrement(&pRWL->RWL_ReaderCount);
    LeaveCriticalSection(&pRWL->RWL_ReadWriteBlock);
}



//----------------------------------------------------------------------------
// Function:    ReleaseReadLock
//
// Relinquishes shared ownership of the lock object.
//
// the last reader sets the event to wake any waiting writers
//----------------------------------------------------------------------------

VOID
ReleaseReadLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    if (InterlockedDecrement(&pRWL->RWL_ReaderCount) < 0) {
        SetEvent(pRWL->RWL_ReaderDoneEvent); 
    }
}



//----------------------------------------------------------------------------
// Function:    AcquireWriteLock
//
// Secures exclusive ownership of the lock object.
//
// the writer blocks other threads by entering the ReadWriteBlock section,
// and then waits for any thread(s) owning the lock to finish
//----------------------------------------------------------------------------

VOID
AcquireWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    EnterCriticalSection(&pRWL->RWL_ReadWriteBlock);
    if (InterlockedDecrement(&pRWL->RWL_ReaderCount) >= 0) { 
        WaitForSingleObject(pRWL->RWL_ReaderDoneEvent, INFINITE);
    }
}



//----------------------------------------------------------------------------
// Function:    ReleaseWriteLock
//
// Relinquishes exclusive ownership of the lock object.
//
// the writer releases the lock by setting the count to zero
// and then leaving the ReadWriteBlock critical section
//----------------------------------------------------------------------------

VOID
ReleaseWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    InterlockedIncrement(&pRWL->RWL_ReaderCount);
    LeaveCriticalSection(&(pRWL)->RWL_ReadWriteBlock);
}



//----------------------------------------------------------------------------
// InitializeDynamicLocksStore
//
// Initialize the structure from which dynamic readwrite locks are allocated.
//----------------------------------------------------------------------------

DWORD
InitializeDynamicLocksStore (
    PDYNAMIC_LOCKS_STORE    pStore,
    HANDLE                  hHeap
    ) {

    // initialize the heap from where dynamic locks are allocated
    pStore->hHeap = hHeap;
    
    INITIALIZE_LOCKED_LIST(&pStore->llFreeLocksList);
    if (!LOCKED_LIST_INITIALIZED(&pStore->llFreeLocksList))
        return GetLastError();

    // initialize the count of the number of free and allocated locks
    pStore->ulCountAllocated = pStore->ulCountFree = 0;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// DeInitializeDynamicLocksStore
//
// Fail if any allocated locks have not been freed.
// Delete the free locks and the FreeLocksList.
//----------------------------------------------------------------------------

DWORD
DeInitializeDynamicLocksStore (
    PDYNAMIC_LOCKS_STORE    pStore
    ) {
    
    PDYNAMIC_READWRITE_LOCK pLock;
    PLIST_ENTRY             pleHead, ple;
    
    if (pStore->ulCountFree)
        return ERROR_CAN_NOT_COMPLETE;

    // deinitialize the count of the number of free and allocated locks
    pStore->ulCountAllocated = pStore->ulCountFree = 0;

    // deinitialize the FreeLocksList
    pStore->llFreeLocksList.created = 0;

    // delete all dynamic readwrite locks and free the memory.
    pleHead = &(pStore->llFreeLocksList.head);
    for (ple = pleHead->Flink; ple != pleHead; ple = ple->Flink)
    {
        pLock = CONTAINING_RECORD(ple, DYNAMIC_READWRITE_LOCK, leLink);
        DELETE_READ_WRITE_LOCK(&pLock->rwlLock);
        HeapFree(pStore->hHeap, 0, pLock);
    }

    DeleteCriticalSection(&(pStore->llFreeLocksList.lock));

    // deinitialize the heap from where dynamic locks are allocated
    pStore->hHeap = NULL;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// GetDynamicReadwriteLock
//
// Return a free dynamic readwrite lock, if one is available.
// Else allocate a new dynamic readwrite lock.
// Assumes pStore->llFreeLocksList is locked.
//----------------------------------------------------------------------------

PDYNAMIC_READWRITE_LOCK
GetDynamicReadwriteLock (
    PDYNAMIC_LOCKS_STORE    pStore
    ) {

    PDYNAMIC_READWRITE_LOCK pLock;
    PLIST_ENTRY             pleHead, ple;


    // a free dynamic lock is available. Return it
    pleHead = &(pStore->llFreeLocksList.head);
    if (!IsListEmpty(pleHead))
    {
        pStore->ulCountFree--;
        ple = RemoveHeadList(pleHead);
        pLock = CONTAINING_RECORD(ple, DYNAMIC_READWRITE_LOCK, leLink);
        return pLock;
    }
    
    // allocate memory for a new dynamic lock
    pLock = HeapAlloc(pStore->hHeap, 0, sizeof(DYNAMIC_READWRITE_LOCK));
    if (pLock ==  NULL)
        return NULL;

    // initialize the fields
    CREATE_READ_WRITE_LOCK(&(pLock->rwlLock));
    if (!READ_WRITE_LOCK_CREATED(&(pLock->rwlLock)))
    {
        HeapFree(pStore->hHeap, 0, pLock);
        return NULL;
    }
    pLock->ulCount = 0;

    pStore->ulCountAllocated++;

    return pLock;
}
    

    
//----------------------------------------------------------------------------
// FreeDynamicReadwriteLock
//
// Accepts a released dynamic readwrite lock.
// Frees it if there are too many dynamic readwrite locks.
// Assumes pStore->llFreeLocksList is locked.
//----------------------------------------------------------------------------

VOID
FreeDynamicReadwriteLock (
    PDYNAMIC_READWRITE_LOCK pLock,
    PDYNAMIC_LOCKS_STORE    pStore
    ) {

    PLIST_ENTRY             pleHead;


    // decrement count of allocated locks
    pStore->ulCountAllocated--;

    // if there are too many dynamic readwrite locks, then free this lock
    if ((pStore->ulCountAllocated + pStore->ulCountFree + 1) >
        DYNAMIC_LOCKS_HIGH_THRESHOLD)
    {
        DELETE_READ_WRITE_LOCK(&pLock->rwlLock);
        HeapFree(pStore->hHeap, 0, pLock);    
    }
    else                        // insert into the list of free locks
    {
        pleHead = &(pStore->llFreeLocksList.head);
        InsertHeadList(pleHead, &pLock->leLink);
        pStore->ulCountFree++;
    }

    return;
}



//----------------------------------------------------------------------------
// AcquireDynamicLock
//
// Locks the FreeLocksList.
// Allocates a new dynamic lock if required.
// Increments the count.
// Unlocks the FreeLocksList.
// Acquires the dynamic lock.
//----------------------------------------------------------------------------

DWORD
AcquireDynamicReadwriteLock (
    PDYNAMIC_READWRITE_LOCK *ppLock,
    LOCK_MODE               lmMode,
    PDYNAMIC_LOCKS_STORE    pStore
    ) {

    // acquire the lock for the free locks list
    ACQUIRE_LIST_LOCK(&pStore->llFreeLocksList);
    
    // if it is does not already exist, allocate a new dynamic lock
    if (*ppLock == NULL)
    {
        *ppLock = GetDynamicReadwriteLock(pStore);

        // if could not get a lock we are in serious trouble
        if (*ppLock == NULL)
        {
            RELEASE_LIST_LOCK(&pStore->llFreeLocksList);
            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    // increment count in the dynamic lock
    (*ppLock)->ulCount++;

    // release the lock for the free locks list
    RELEASE_LIST_LOCK(&pStore->llFreeLocksList);    

    // acquire dynamic lock
    if (lmMode == READ_MODE)
        ACQUIRE_READ_LOCK(&(*ppLock)->rwlLock);
    else
        ACQUIRE_WRITE_LOCK(&(*ppLock)->rwlLock);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// ReleaseDynamicReadwriteLock
//
// Locks the FreeLocksList.
// Releases the dynamic lock.
// Decrements the count.
//  Free the dynamic lock if count becomes 0.
// Unlocks the FreeLocksList.
//----------------------------------------------------------------------------

VOID
ReleaseDynamicReadwriteLock (
    PDYNAMIC_READWRITE_LOCK *ppLock,
    LOCK_MODE               lmMode,
    PDYNAMIC_LOCKS_STORE    pStore
    ) {

    // acquire the lock for the free locks list
    ACQUIRE_LIST_LOCK(&pStore->llFreeLocksList);

    // release the dynamic readwrite lock
    if (lmMode == READ_MODE)
        RELEASE_READ_LOCK(&(*ppLock)->rwlLock);
    else 
        RELEASE_WRITE_LOCK(&(*ppLock)->rwlLock);

    // decrement count in the dynamic lock, free it if count becomes 0
    if (!(*ppLock)->ulCount--)
    {
        FreeDynamicReadwriteLock(*ppLock, pStore);
        *ppLock = NULL;         // so it is known that it doesn't exist 
    }

    // release the lock for the free locks list
    RELEASE_LIST_LOCK(&pStore->llFreeLocksList);    

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\utility\ipkern\addr.h ===
#ifndef __IPKERN_ADDR_H__
#define __IPKERN_ADDR_H__

VOID
HandleAddress(
    LONG    lNumArgs,
    WCHAR   **ppwszArgs
    );

#endif // __IPKERN_ADDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\utils.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\utils.h

Abstract:

    The file contains miscellaneous utilities.

--*/

#ifndef _UTILS_H_
#define _UTILS_H_


// Worker Function Processing

// functions

DWORD
QueueSampleWorker(
    IN  WORKERFUNCTION  pfnFunction,
    IN  PVOID           pvContext
    );

BOOL
EnterSampleAPI(
    );

BOOL
EnterSampleWorker(
    );

VOID
LeaveSampleWorker(
    );

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\utility\ipkern\addr.c ===
#include "inc.h"

VOID
HandleAddress(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    )
{
    DWORD       dwResult, i;

    PMIB_IPADDRTABLE   pTable;

    
    //
    // Get the address table
    //

    dwResult = AllocateAndGetIpAddrTableFromStack(&pTable,
                                                  TRUE,
                                                  GetProcessHeap(),
                                                  HEAP_NO_SERIALIZE);

    if(dwResult isnot NO_ERROR)
    {
        PWCHAR pwszEntry;

        pwszEntry = MakeString(STR_ADDRTABLE);

        if(pwszEntry)
        {
            DisplayMessage(EMSG_RETRIEVAL_ERROR1,
                           dwResult,
                           pwszEntry);

            FreeString(pwszEntry);
        }
        else
        {
            DisplayMessage(EMSG_RETRIEVAL_ERROR2,
                           dwResult);
        }

        return;
    }

    if(pTable->dwNumEntries is 0)
    {
        PWCHAR  pwszEntryType;

        pwszEntryType = MakeString(TOKEN_ADDRESS);

        if(pwszEntryType)
        {
            DisplayMessage(EMSG_NO_ENTRIES1,
                           pwszEntryType);

            FreeString(pwszEntryType);
        }
        else
        {
            DisplayMessage(EMSG_NO_ENTRIES2);
        }

        HeapFree(GetProcessHeap(),
                 HEAP_NO_SERIALIZE,
                 pTable);

        return;
    }

    DisplayMessage(MSG_ADDRTABLE_HDR);

    for(i = 0; i < pTable->dwNumEntries; i++)
    {
        ADDR_STRING rgwcAddr, rgwcMask;
        PWCHAR      pwszBCast;

        NetworkToUnicode(pTable->table[i].dwAddr,
                         rgwcAddr);

        NetworkToUnicode(pTable->table[i].dwMask,
                         rgwcMask);

        pwszBCast = (pTable->table[i].dwBCastAddr)?L"255.255.255.255":L"0.0.0.0";

        wprintf(L"%-15s\t%-15s\t%-15s\t\t%-4d\t%d\n",
                rgwcAddr,
                rgwcMask,
                pwszBCast,
                pTable->table[i].dwIndex,
                pTable->table[i].dwReasmSize);
    }

    HeapFree(GetProcessHeap(),
             HEAP_NO_SERIALIZE,
             pTable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\utility\ipkern\arp.h ===
#ifndef __IPKERN_ARP_H__
#define __IPKERN_ARP_H__


VOID
HandleArp(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    );

VOID
PrintArp(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    );

VOID
FlushArp(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    );

#endif // __IPKERN_ARP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\sample\utils.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\utils.c

Abstract:

    The file contains miscellaneous utilities.

--*/


#include "pchsample.h"
#pragma hdrstop

DWORD
QueueSampleWorker(
    IN  WORKERFUNCTION  pfnFunction,
    IN  PVOID           pvContext
    )
/*++

Routine Description
    This function is called to queue a worker function in a safe fashion;
    if cleanup is in progress or if SAMPLE has stopped, this function
    discards the work-item.

Locks
    Acquires exclusively g_ce.rwlLock
    Releases             g_ce.rwlLock

Arguments
    pfnFunction         function to be called
    pvContext           opaque ptr used in callback

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    DWORD   dwErr       = NO_ERROR;
    BOOL    bSuccess    = FALSE;
    
    ACQUIRE_WRITE_LOCK(&(g_ce.rwlLock));

    do                          // breakout loop
    {
        // cannot queue a work function when SAMPLE has quit or is quitting
        if (g_ce.iscStatus != IPSAMPLE_STATUS_RUNNING)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        
        bSuccess = QueueUserWorkItem((LPTHREAD_START_ROUTINE)pfnFunction,
                                     pvContext,
                                     0); // no flags
        if (bSuccess)
            g_ce.ulActivityCount++;
        else
            dwErr = GetLastError();
    } while (FALSE);

    RELEASE_WRITE_LOCK(&(g_ce.rwlLock));

    return dwErr;
}



BOOL
EnterSampleAPI(
    )
/*++

Routine Description
    This function is called when entering a SAMPLE api, as well as when
    entering the input thread and timer thread.  It checks to see if SAMPLE
    has stopped, and if so it quits; otherwise it increments the count of
    active threads.

Locks
    Acquires exclusively g_ce.rwlLock
    Releases             g_ce.rwlLock

Arguments
    None

Return Value
    TRUE                if entered successfully
    FALSE               o/w

--*/
{
    BOOL    bEntered    = FALSE;

    ACQUIRE_WRITE_LOCK(&(g_ce.rwlLock));

    if (g_ce.iscStatus is IPSAMPLE_STATUS_RUNNING)
    {
        // SAMPLE is running, so continue
        g_ce.ulActivityCount++;
        bEntered = TRUE;
    }
    
    RELEASE_WRITE_LOCK(&(g_ce.rwlLock));

    return bEntered;
}



BOOL
EnterSampleWorker(
    )
/*++

Routine Description
    This function is called when entering a SAMPLE worker-function.  Since
    there is a lapse between the time a worker-function is queued and the
    time the function is actually invoked by a worker thread, this function
    must check to see if SAMPLE has stopped or is stopping; if this is the
    case, then it decrements the activity count, releases the activity
    semaphore, and quits.

Locks
    Acquires exclusively g_ce.rwlLock
    Releases             g_ce.rwlLock

Arguments
    None

Return Value
    TRUE                if entered successfully
    FALSE               o/w

--*/
{
    BOOL    bEntered    = FALSE;

    ACQUIRE_WRITE_LOCK(&(g_ce.rwlLock));

    do                          // breakout loop
    {
        // SAMPLE is running, so the function may continue
        if (g_ce.iscStatus is IPSAMPLE_STATUS_RUNNING)
        {
            bEntered = TRUE;
            break;
        }

        // SAMPLE is not running, but it was, so the function must stop
        if (g_ce.iscStatus is IPSAMPLE_STATUS_STOPPING)
        {
            g_ce.ulActivityCount--;
            ReleaseSemaphore(g_ce.hActivitySemaphore, 1, NULL);
            break;
        }

        // SAMPLE probably never started. quit
    } while (FALSE);
    
    RELEASE_WRITE_LOCK(&(g_ce.rwlLock));

    return bEntered;
}



VOID
LeaveSampleWorker(
    )
/*++

Routine Description
    This function is called when leaving a SAMPLE api or worker function.
    It decrements the activity count, and if it detects that SAMPLE has
    stopped or is stopping, it releases the activity semaphore.

Locks
    Acquires exclusively g_ce.rwlLock
    Releases             g_ce.rwlLock

Arguments
    None

Return Value
    TRUE                if entered successfully
    FALSE               o/w

--*/
{
    ACQUIRE_WRITE_LOCK(&(g_ce.rwlLock));

    g_ce.ulActivityCount--;

    if (g_ce.iscStatus is IPSAMPLE_STATUS_STOPPING)
        ReleaseSemaphore(g_ce.hActivitySemaphore, 1, NULL);

    RELEASE_WRITE_LOCK(&(g_ce.rwlLock));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\utility\ipkern\if.c ===
#include "inc.h"

#define GUID_FORMAT_W   L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"

DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

CMD_ENTRY   g_rgIfCmdTable[] = {
    {TOKEN_STATS, PrintStats},
    {TOKEN_INFO, PrintInfo},
    {TOKEN_NAME, PrintName},
    {TOKEN_GUID, PrintGuid},
};

int
__cdecl
ScanHexFormat(
    IN const WCHAR* pwszBuffer,
    IN ULONG        ulCharCount,
    IN const WCHAR* pwszFormat,
    ...
    )

/*++

Routine Description:

    Scans a source Buffer and places values from that buffer into the parameters
    as specified by Format.

Arguments:

    pwszBuffer  Source buffer which is to be scanned.

    ulCharCount Maximum length in characters for which Buffer is searched.
                This implies that Buffer need not be UNICODE_NULL terminated.

    Format      Format string which defines both the acceptable string form as
                contained in pwszBuffer


Return Value:

    Returns the number of parameters filled if the end of the Buffer is reached,
    else -1 on an error.

--*/
{
    va_list ArgList;
    int     iFormatItems;

    va_start(ArgList, pwszFormat);

    //
    // Count of number of parameters filled
    //

    iFormatItems = 0;

    while(TRUE)
    {
        switch (*pwszFormat) 
        {
            case UNICODE_NULL:
            {
                //
                // end of string
                //

                return (*pwszBuffer && ulCharCount) ? -1 : iFormatItems;
            }

            case L'%':
            {
                //
                // Format specifier
                //

                pwszFormat++;

                if (*pwszFormat != L'%') 
                {
                    ULONG   ulNumber;
                    int     iWidth;
                    int     iLong;
                    PVOID   pvPointer;

                    //
                    // So it isnt a %%
                    //

                    iLong = 0;
                    iWidth = 0;

                    while(TRUE)
                    {
                        if((*pwszFormat >= L'0') && 
                           (*pwszFormat <= L'9')) 
                        {
                            iWidth = iWidth * 10 + *pwszFormat - '0';
                        } 
                        else
                        {
                            if(*pwszFormat == L'l') 
                            {
                                iLong++;
                            } 
                            else 
                            {
                                if((*pwszFormat == L'X') || 
                                   (*pwszFormat == L'x')) 
                                {
                                    break;
                                }
                            }
                        }
                       
                        //
                        // Move to the next specifier
                        //
 
                        pwszFormat++;
                    }

                    pwszFormat++;

                    for(ulNumber = 0; iWidth--; pwszBuffer++, ulCharCount--) 
                    {
                        if(!ulCharCount)
                        {
                            return -1;
                        }

                        ulNumber *= 16;

                        if((*pwszBuffer >= L'0') && 
                           (*pwszBuffer <= L'9')) 
                        {
                            ulNumber += (*pwszBuffer - L'0');
                        } 
                        else
                        {
                            if((*pwszBuffer >= L'a') && 
                               (*pwszBuffer <= L'f')) 
                            {
                                ulNumber += (*pwszBuffer - L'a' + 10);
                            }
                            else
                            {
                                if((*pwszBuffer >= L'A') && 
                                   (*pwszBuffer <= L'F')) 
                                {
                                    ulNumber += (*pwszBuffer - L'A' + 10);
                                } 
                                else 
                                {
                                    return -1;
                                }
                            }
                        }
                    }

                    pvPointer = va_arg(ArgList, PVOID);

                    if(iLong) 
                    {
                        *(PULONG)pvPointer = ulNumber;
                    } 
                    else 
                    {
                        *(PUSHORT)pvPointer = (USHORT)ulNumber;
                    }

                    iFormatItems++;

                    break;
                }
           
                //
                // NO BREAK
                // 

            }

            default:
            {
                if (!ulCharCount || (*pwszBuffer != *pwszFormat))
                {
                    return -1;
                }

                pwszBuffer++;

                ulCharCount--;

                pwszFormat++;

                break;
            }
        }
    }
}

DWORD
ConvertGuidToString(
    IN  GUID    *pGuid,
    OUT PWCHAR  pwszBuffer
    )

/*++

Routine Description:

    Constructs the standard string version of a GUID, in the form:
    "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    pGuid       Contains the GUID to translate.

    pwszBuffer  Space for storing the string. Must be >= 39 * sizeof(WCHAR)

Return Value:


--*/

{
    return swprintf(pwszBuffer, 
                    GUID_FORMAT_W, 
                    pGuid->Data1, 
                    pGuid->Data2, 
                    pGuid->Data3, 
                    pGuid->Data4[0], 
                    pGuid->Data4[1], 
                    pGuid->Data4[2], 
                    pGuid->Data4[3], 
                    pGuid->Data4[4], 
                    pGuid->Data4[5], 
                    pGuid->Data4[6], 
                    pGuid->Data4[7]);
}

DWORD
ConvertStringToGuid(
    IN  PWCHAR  pwszGuid,
    IN  ULONG   ulStringLen,
    OUT GUID    *pGuid
    )

/*++

Routine Description:

    Retrieves a the binary format of a textual GUID presented in the standard
    string version of a GUID: "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    GuidString -
        Place from which to retrieve the textual form of the GUID.

    Guid -
        Place in which to put the binary form of the GUID.

Return Value:

    Returns STATUS_SUCCESS if the buffer contained a valid GUID, else
    STATUS_INVALID_PARAMETER if the string was invalid.

--*/

{
    USHORT    Data4[8];
    int       Count;

    if (ScanHexFormat(pwszGuid,
                      ulStringLen/sizeof(WCHAR),
                      GUID_FORMAT_W,
                      &pGuid->Data1, 
                      &pGuid->Data2, 
                      &pGuid->Data3, 
                      &Data4[0], 
                      &Data4[1], 
                      &Data4[2], 
                      &Data4[3], 
                      &Data4[4], 
                      &Data4[5], 
                      &Data4[6], 
                      &Data4[7]) == -1) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    for(Count = 0; Count < sizeof(Data4)/sizeof(Data4[0]); Count++) 
    {
        pGuid->Data4[Count] = (UCHAR)Data4[Count];
    }

    return NO_ERROR;
}

VOID
HandleInterface(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    )
{
    LONG    lIndex;

    if(lNumArgs < 2)
    {
        DisplayMessage(HMSG_IF_USAGE);

        return;
    }

    lIndex = ParseCommand(g_rgIfCmdTable,
                          sizeof(g_rgIfCmdTable)/sizeof(CMD_ENTRY),
                          rgpwszArgs[1]);

    if(lIndex is -1)
    {
        DisplayMessage(HMSG_IF_USAGE);

        return;
    }

    g_rgIfCmdTable[lIndex].pfnHandler(lNumArgs - 1,
                                      &rgpwszArgs[1]);


    return;
}

VOID
PrintStats(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    )
{
    DWORD           dwResult, i, j;
    PMIB_IFTABLE    pTable;

    dwResult = AllocateAndGetIfTableFromStack(&pTable,
                                              TRUE,
                                              GetProcessHeap(),
                                              HEAP_NO_SERIALIZE,
                                              FALSE);

    if(dwResult isnot NO_ERROR)
    {
        PWCHAR pwszEntry;

        pwszEntry = MakeString(STR_IFTABLE);

        if(pwszEntry)
        {
            DisplayMessage(EMSG_RETRIEVAL_ERROR1,
                           dwResult,
                           pwszEntry);

            FreeString(pwszEntry);
        }
        else
        {
            DisplayMessage(EMSG_RETRIEVAL_ERROR2,
                           dwResult);
        }

        return;
    }

    if(pTable->dwNumEntries is 0)
    {
        PWCHAR  pwszEntryType;

        pwszEntryType = MakeString(TOKEN_INTERFACE);

        if(pwszEntryType)
        {
            DisplayMessage(EMSG_NO_ENTRIES1,
                           pwszEntryType);

            FreeString(pwszEntryType);
        }
        else
        {
            DisplayMessage(EMSG_NO_ENTRIES2);
        }

        HeapFree(GetProcessHeap(),
                 HEAP_NO_SERIALIZE,
                 pTable);

        return;
    }

    for(i = 0; i < pTable->dwNumEntries; i++)
    {
        PWCHAR  pwszIfType, pwszAdmin, pwszOper;
        WCHAR   rgwcDescr[MAXLEN_IFDESCR + 1];
        WCHAR   rgwcPhysAddr[3*MAXLEN_PHYSADDR + 8];


        switch(pTable->table[i].dwType)
        {
            case IF_TYPE_OTHER:
            {
                pwszIfType = MakeString(STR_OTHER);
                break;
            }
            case IF_TYPE_ETHERNET_CSMACD:
            {
                pwszIfType = MakeString(STR_ETHERNET);
                break;
            }
            case IF_TYPE_ISO88025_TOKENRING:
            {
                pwszIfType = MakeString(STR_TOKENRING);
                break;
            }
            case IF_TYPE_FDDI:
            {
                pwszIfType = MakeString(STR_FDDI);
                break;
            }
            case IF_TYPE_PPP:
            {
                pwszIfType = MakeString(STR_PPP);
                break;
            }
            case IF_TYPE_SOFTWARE_LOOPBACK:
            {
                pwszIfType = MakeString(STR_LOOPBACK);
                break;
            }
            case IF_TYPE_SLIP:
            {
                pwszIfType = MakeString(STR_SLIP);
                break;
            }
        }

        switch(pTable->table[i].dwAdminStatus)
        {
            case IF_ADMIN_STATUS_UP:
            {
                pwszAdmin = MakeString(STR_UP);
                break;
            }
            case IF_ADMIN_STATUS_DOWN:
            {
                pwszAdmin = MakeString(STR_DOWN);
                break;
            }
            case IF_ADMIN_STATUS_TESTING:
            {
                pwszAdmin = MakeString(STR_TESTING);
                break;
            }
        }

        switch(pTable->table[i].dwOperStatus)
        {
            case IF_OPER_STATUS_NON_OPERATIONAL:
            {
                pwszOper = MakeString(STR_NON_OPERATIONAL);
                break;
            }
            case IF_OPER_STATUS_UNREACHABLE:
            {
                pwszOper = MakeString(STR_UNREACHABLE);
                break;
            }
            case IF_OPER_STATUS_DISCONNECTED:
            {
                pwszOper = MakeString(STR_DISCONNECTED);
                break;
            }
            case IF_OPER_STATUS_CONNECTING:
            {
                pwszOper = MakeString(STR_CONNECTING);
                break;
            }
            case IF_OPER_STATUS_CONNECTED:
            {
                pwszOper = MakeString(STR_CONNECTED);
                break;
            }
            case IF_OPER_STATUS_OPERATIONAL:
            {
                pwszOper = MakeString(STR_OPERATIONAL);
                break;
            }
       }

        MultiByteToWideChar(CP_ACP,
                            0,
                            pTable->table[i].bDescr,
                            -1,
                            rgwcDescr,
                            MAXLEN_IFDESCR);

        rgwcDescr[MAXLEN_IFDESCR] = UNICODE_NULL;

        PhysAddrToUnicode(rgwcPhysAddr,
                          pTable->table[i].bPhysAddr,
                          pTable->table[i].dwPhysAddrLen);

        DisplayMessage(MSG_IF_INFO,
                       pTable->table[i].wszName,
                       pTable->table[i].dwIndex,
                       pwszIfType,
                       pTable->table[i].dwMtu,
                       pTable->table[i].dwSpeed,
                       rgwcPhysAddr,
                       pwszAdmin,
                       pwszOper,
                       pTable->table[i].dwLastChange,
                       pTable->table[i].dwInOctets,
                       pTable->table[i].dwInUcastPkts,
                       pTable->table[i].dwInNUcastPkts,
                       pTable->table[i].dwInDiscards,
                       pTable->table[i].dwInErrors,
                       pTable->table[i].dwInUnknownProtos,
                       pTable->table[i].dwOutOctets,
                       pTable->table[i].dwOutUcastPkts,
                       pTable->table[i].dwOutNUcastPkts,
                       pTable->table[i].dwOutDiscards,
                       pTable->table[i].dwOutErrors,
                       pTable->table[i].dwOutQLen,
                       rgwcDescr);

        FreeString(pwszIfType);
        FreeString(pwszAdmin);
        FreeString(pwszOper);
    }


}

VOID
PrintInfo(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    )
{
    DWORD   dwResult, i, dwCount;

    PIP_INTERFACE_NAME_INFO pTable;

    dwResult = NhpAllocateAndGetInterfaceInfoFromStack(&pTable,
                                                       &dwCount,
                                                       TRUE,
                                                       GetProcessHeap(),
                                                       HEAP_NO_SERIALIZE);

    if(dwResult isnot NO_ERROR)
    {
        PWCHAR pwszEntry;

        pwszEntry = MakeString(STR_IFTABLE);

        if(pwszEntry)
        {
            DisplayMessage(EMSG_RETRIEVAL_ERROR1,
                           dwResult,
                           pwszEntry);

            FreeString(pwszEntry);
        }
        else
        {
            DisplayMessage(EMSG_RETRIEVAL_ERROR2,
                           dwResult);
        }

        return;
    }

    if(dwCount is 0)
    {
        PWCHAR  pwszEntryType;

        pwszEntryType = MakeString(TOKEN_INTERFACE);

        if(pwszEntryType)
        {
            DisplayMessage(EMSG_NO_ENTRIES1,
                           pwszEntryType);

            FreeString(pwszEntryType);
        }
        else
        {
            DisplayMessage(EMSG_NO_ENTRIES2);
        }

        HeapFree(GetProcessHeap(),
                 HEAP_NO_SERIALIZE,
                 pTable);

        return;
    }

    for(i = 0; i < dwCount; i++)
    {
        WCHAR   pwszDeviceGuid[40], pwszIfGuid[40];
        WCHAR   pwszName[300];
        GUID    *pGuid;
        DWORD   dwSize;

        ConvertGuidToString(&(pTable[i].DeviceGuid),
                            pwszDeviceGuid);

        ConvertGuidToString(&(pTable[i].InterfaceGuid),
                            pwszIfGuid);

        if(IsEqualGUID(&(pTable[i].InterfaceGuid),
                       &(GUID_NULL)))
        {
            pGuid = &(pTable[i].DeviceGuid);
        }
        else
        {
            pGuid = &(pTable[i].InterfaceGuid);
        }

        dwSize = sizeof(pwszName);

        dwResult = NhGetInterfaceNameFromGuid(pGuid,
                                              pwszName,
                                              &dwSize,
                                              FALSE,
                                              TRUE);

        ASSERT(dwResult == NO_ERROR);
                        
        wprintf(L"%d %s %s %s\n",
                pTable[i].Index,
                pwszDeviceGuid,
                pwszIfGuid,
                pwszName);
    }

}               

VOID
PrintName(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    )

{
    ULONG   ulSize;
    GUID    Guid;
    WCHAR   rgwcIfName[MAX_INTERFACE_NAME_LEN + 2];

    //
    // The command line at this point should read:
    // NAME {Guid}
    //

    if(lNumArgs != 2)
    {
        DisplayMessage(HMSG_IF_NAME_USAGE);

        return;
    }

    if(ConvertStringToGuid(rgpwszArgs[1],
                           wcslen(rgpwszArgs[1]) * sizeof(WCHAR),
                           &Guid) isnot NO_ERROR)
    {
        DisplayMessage(HMSG_IF_NAME_USAGE);

        return;
    }

    ulSize = sizeof(rgwcIfName);

    if(NhGetInterfaceNameFromGuid(&Guid,
                                  rgwcIfName,
                                  &ulSize,
                                  FALSE,
                                  TRUE) isnot NO_ERROR)
    {
        DisplayMessage(EMSG_NO_SUCH_IF);
    
        return;
    }

    wprintf(L"%s\n", rgwcIfName);
}

VOID
PrintGuid(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    )

{
    GUID    Guid;
    WCHAR   rgwcString[40];

    //
    // The command line at this point should read:
    // GUID "Name"
    //

    if(lNumArgs != 2)
    {
        DisplayMessage(HMSG_IF_GUID_USAGE);

        return;
    }

    if(NhGetGuidFromInterfaceName(rgpwszArgs[1],
                                  &Guid,
                                  FALSE,
                                  TRUE) isnot NO_ERROR)
    {
        DisplayMessage(EMSG_NO_SUCH_IF);

        return;
    }

    ConvertGuidToString(&Guid,
                        rgwcString);

    wprintf(L"%s\n", rgwcString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\utility\ipkern\if.h ===
#ifndef __IPKERN_IP_H__
#define __IPKERN_IP_H__

VOID
HandleInterface(
    LONG    lNumArgs,
    WCHAR   **ppwszArgs
    );

VOID
PrintStats(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    );

VOID
PrintInfo(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    );

VOID
PrintName(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    );

VOID
PrintGuid(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    );

#endif // __IPKERN_IP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\utility\ipkern\arp.c ===
#include "inc.h"

CMD_ENTRY   g_rgArpCmdTable[] = {
    {TOKEN_PRINT, PrintArp},
    {TOKEN_FLUSH, FlushArp},
};

VOID
HandleArp(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    )
{
    LONG    lIndex;

    if(lNumArgs < 2)
    {
        DisplayMessage(HMSG_ARP_USAGE);

        return;
    }

    lIndex = ParseCommand(g_rgArpCmdTable,
                          sizeof(g_rgArpCmdTable)/sizeof(CMD_ENTRY),
                          rgpwszArgs[1]);

    if(lIndex is -1)
    {
        DisplayMessage(HMSG_ARP_USAGE);

        return;
    }

    g_rgArpCmdTable[lIndex].pfnHandler(lNumArgs - 1,
                                       &rgpwszArgs[1]);


    return;
}

VOID
PrintArp(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    )
{
    DWORD   dwResult, i;

    PMIB_IPNETTABLE pTable;

    dwResult = AllocateAndGetIpNetTableFromStack(&pTable,
                                                 TRUE,
                                                 GetProcessHeap(),
                                                 HEAP_NO_SERIALIZE,
                                                 FALSE);

    if(dwResult isnot NO_ERROR)
    {
        PWCHAR pwszEntry;

        pwszEntry = MakeString(STR_ARPTABLE);

        if(pwszEntry)
        {
            DisplayMessage(EMSG_RETRIEVAL_ERROR1,
                           dwResult,
                           pwszEntry);

            FreeString(pwszEntry);
        }
        else
        {
            DisplayMessage(EMSG_RETRIEVAL_ERROR2,
                           dwResult);
        }

        return;
    }

    if(pTable->dwNumEntries is 0)
    {
        PWCHAR  pwszEntryType;

        pwszEntryType = MakeString(TOKEN_ARP);

        if(pwszEntryType)
        {
            DisplayMessage(EMSG_NO_ENTRIES1,
                           pwszEntryType);

            FreeString(pwszEntryType);
        }
        else
        {
            DisplayMessage(EMSG_NO_ENTRIES2);
        }

        HeapFree(GetProcessHeap(),
                 HEAP_NO_SERIALIZE,
                 pTable);

        return;
    }

    DisplayMessage(MSG_ARPTABLE_HDR);

    for(i = 0; i < pTable->dwNumEntries; i++)
    {
        ADDR_STRING rgwcAddr;
        PWCHAR      pwszType;
        WCHAR       rgwcPhysAddr[3*MAXLEN_PHYSADDR + 8];

        NetworkToUnicode(pTable->table[i].dwAddr,
                         rgwcAddr);

        switch(pTable->table[i].dwType)
        {
            case MIB_IPNET_TYPE_OTHER:
            {
                pwszType = MakeString(STR_OTHER);
                break;
            }
            case MIB_IPNET_TYPE_INVALID:
            {
                pwszType = MakeString(STR_INVALID);
                break;
            }
            case MIB_IPNET_TYPE_DYNAMIC:
            {
                pwszType = MakeString(STR_DYNAMIC);
                break;
            }
            case MIB_IPNET_TYPE_STATIC:
            {
                pwszType = MakeString(STR_STATIC);
                break;
            }
        }

        PhysAddrToUnicode(rgwcPhysAddr,
                          pTable->table[i].bPhysAddr,
                          pTable->table[i].dwPhysAddrLen);

        wprintf(L"%-15s\t\t%-24s\t%-4d\t\t%s\n",
                rgwcAddr,
                rgwcPhysAddr,
                pTable->table[i].dwIndex,
                pwszType);

        FreeString(pwszType);
    }

    HeapFree(GetProcessHeap(),
             HEAP_NO_SERIALIZE,
             pTable);
}



VOID
FlushArp(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    )
{
    DWORD   i, dwIfIndex, dwResult;
    BOOL    bFound;

    PMIB_IPADDRTABLE   pTable;

    //
    // Parse the rest of the arguments
    // The command line at this point should read:
    // FLUSH <ifIndex>
    //

    if(lNumArgs < 2)
    {
        DisplayMessage(HMSG_ARP_FLUSH_USAGE);

        return;
    }

    dwIfIndex = wcstoul(rgpwszArgs[1],
                        NULL,
                        10);

    //
    // Get the route table and see if such a route exists
    //

    dwResult = AllocateAndGetIpAddrTableFromStack(&pTable,
                                                  TRUE,
                                                  GetProcessHeap(),
                                                  HEAP_NO_SERIALIZE);

    if(dwResult isnot NO_ERROR)
    {
        PWCHAR pwszEntry;

        pwszEntry = MakeString(STR_ADDRTABLE);

        if(pwszEntry)
        {
            DisplayMessage(EMSG_RETRIEVAL_ERROR1,
                           dwResult,
                           pwszEntry);

            FreeString(pwszEntry);
        }
        else
        {
            DisplayMessage(EMSG_RETRIEVAL_ERROR2,
                           dwResult);
        }

        return;
    }

    for(bFound = FALSE, i = 0;
        i < pTable->dwNumEntries;
        i++)
    {
        if(pTable->table[i].dwIndex is dwIfIndex)
        {
            bFound = TRUE;

            break;
        }
    }
    
    HeapFree(GetProcessHeap(),
             HEAP_NO_SERIALIZE,
             pTable);

    if(!bFound)
    {
        DisplayMessage(EMSG_ARP_NO_SUCH_IF,
                       dwIfIndex);

        return;
    }

    dwResult = FlushIpNetTableFromStack(dwIfIndex);

    if(dwResult isnot NO_ERROR)
    {
        DisplayMessage(EMSG_UNABLE_TO_FLUSH_ARP,
                       dwIfIndex,
                       dwResult);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\utility\ipkern\ipkern.c ===
#include "inc.h"

CMD_ENTRY g_rgMainCmdTable[] = 
{
    {TOKEN_ROUTE, HandleRoute},
    {TOKEN_ADDRESS, HandleAddress},
    {TOKEN_INTERFACE, HandleInterface},
    {TOKEN_ARP, HandleArp},
};

HMODULE g_hModule;

DWORD
_cdecl 
wmain(
    int     argc,
    wchar_t *argv[]
    )

/*++

Routine Description
      
  
Locks 


Arguments
      

Return Value


--*/

{
    LONG lIndex;

    setlocale(LC_ALL,
              "");

    if(argc < 2)
    {
        DisplayMessage(HMSG_IPKERN_USAGE);        

        return ERROR;
    }

    g_hModule = GetModuleHandle(NULL);

    if(g_hModule is NULL)
    {
        return GetLastError();
    }

    lIndex = ParseCommand(g_rgMainCmdTable,
                          sizeof(g_rgMainCmdTable)/sizeof(CMD_ENTRY),
                          argv[1]);
     
    if(lIndex is -1)
    {
        DisplayMessage(HMSG_IPKERN_USAGE);

        return ERROR_INVALID_PARAMETER;
    }

    g_rgMainCmdTable[lIndex].pfnHandler(argc - 1,
                                        &argv[1]);


    return NO_ERROR;
}

BOOL
MatchToken(
    IN  PWCHAR  pwszToken,
    IN  DWORD   dwTokenId
    )
{
    WCHAR   pwszTemp[MAX_TOKEN_LENGTH] = L"\0";

    if(!LoadStringW(g_hModule,
                    dwTokenId,
                    pwszTemp,
                    MAX_TOKEN_LENGTH))
    {
        return FALSE;
    }

    if(!_wcsicmp(pwszToken, pwszTemp))
    {
        return TRUE;
    }

    return FALSE;
}

LONG
ParseCommand(
    PCMD_ENTRY  pCmdTable,
    LONG        lNumEntries,
    PWCHAR      pwszFirstArg
    )
{
    LONG   i;

    for(i = 0; i < lNumEntries; i++)
    {
        if(MatchToken(pwszFirstArg,
                      pCmdTable[i].dwTokenId))
        {
            return i;
        }
    }

    return -1;
}

DWORD
DisplayMessage(
    DWORD    dwMsgId,
    ...
    )
{
    DWORD       dwMsglen = 0;
    PWCHAR      pwszOutput;
    va_list     arglist;
    WCHAR       rgwcInput[MAX_MSG_LENGTH];

    pwszOutput = NULL;

    do
    {
        va_start(arglist, dwMsgId);

        if(!LoadStringW(g_hModule,
                        dwMsgId,
                        rgwcInput,
                        MAX_MSG_LENGTH))
        {
            break;
        }

        dwMsglen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                                  rgwcInput,
                                  0,
                                  0L,
                                  (PWCHAR)&pwszOutput,
                                  0,
                                  &arglist);

        if(dwMsglen is 0)
        {
            break;
        }

        wprintf( L"%s", pwszOutput );

    }while(FALSE);


    if(pwszOutput) 
    { 
        LocalFree(pwszOutput); 
    }

    return dwMsglen;
}

PWCHAR
MakeString( 
    DWORD dwMsgId,
    ...
    )
{
    DWORD       dwMsglen;
    PWCHAR      pwszOutput;
    va_list     arglist;
    WCHAR       rgwcInput[MAX_MSG_LENGTH];

    pwszOutput = NULL;

    do
    {
        va_start(arglist, 
                 dwMsgId);

        if(!LoadStringW(g_hModule,
                        dwMsgId,
                        rgwcInput,
                        MAX_MSG_LENGTH))
        {
            break;
        }

        FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                       rgwcInput,
                       0,
                       0L,         // Default country ID.
                       (PWCHAR)&pwszOutput,
                       0,
                       &arglist);

    }while(FALSE);

    return pwszOutput;
}


VOID
FreeString(
    PWCHAR  pwszString
    )
{
    LocalFree(pwszString);
}


//
// This preinitialized array defines the strings to be used.
// The index of each row corresponds to the value for a byte
// in an IP address.  The first three bytes of each row are the
// char/string value for the byte, and the fourth byte in each row is
// the length of the string required for the byte.  This approach
// allows a fast implementation with no jumps.
//

static const WCHAR NToUWCharStrings[][4] =
{
    L'0', L'x', L'x', 1,
    L'1', L'x', L'x', 1,
    L'2', L'x', L'x', 1,
    L'3', L'x', L'x', 1,
    L'4', L'x', L'x', 1,
    L'5', L'x', L'x', 1,
    L'6', L'x', L'x', 1,
    L'7', L'x', L'x', 1,
    L'8', L'x', L'x', 1,
    L'9', L'x', L'x', 1,
    L'1', L'0', L'x', 2,
    L'1', L'1', L'x', 2,
    L'1', L'2', L'x', 2,
    L'1', L'3', L'x', 2,
    L'1', L'4', L'x', 2,
    L'1', L'5', L'x', 2,
    L'1', L'6', L'x', 2,
    L'1', L'7', L'x', 2,
    L'1', L'8', L'x', 2,
    L'1', L'9', L'x', 2,
    L'2', L'0', L'x', 2,
    L'2', L'1', L'x', 2,
    L'2', L'2', L'x', 2,
    L'2', L'3', L'x', 2,
    L'2', L'4', L'x', 2,
    L'2', L'5', L'x', 2,
    L'2', L'6', L'x', 2,
    L'2', L'7', L'x', 2,
    L'2', L'8', L'x', 2,
    L'2', L'9', L'x', 2,
    L'3', L'0', L'x', 2,
    L'3', L'1', L'x', 2,
    L'3', L'2', L'x', 2,
    L'3', L'3', L'x', 2,
    L'3', L'4', L'x', 2,
    L'3', L'5', L'x', 2,
    L'3', L'6', L'x', 2,
    L'3', L'7', L'x', 2,
    L'3', L'8', L'x', 2,
    L'3', L'9', L'x', 2,
    L'4', L'0', L'x', 2,
    L'4', L'1', L'x', 2,
    L'4', L'2', L'x', 2,
    L'4', L'3', L'x', 2,
    L'4', L'4', L'x', 2,
    L'4', L'5', L'x', 2,
    L'4', L'6', L'x', 2,
    L'4', L'7', L'x', 2,
    L'4', L'8', L'x', 2,
    L'4', L'9', L'x', 2,
    L'5', L'0', L'x', 2,
    L'5', L'1', L'x', 2,
    L'5', L'2', L'x', 2,
    L'5', L'3', L'x', 2,
    L'5', L'4', L'x', 2,
    L'5', L'5', L'x', 2,
    L'5', L'6', L'x', 2,
    L'5', L'7', L'x', 2,
    L'5', L'8', L'x', 2,
    L'5', L'9', L'x', 2,
    L'6', L'0', L'x', 2,
    L'6', L'1', L'x', 2,
    L'6', L'2', L'x', 2,
    L'6', L'3', L'x', 2,
    L'6', L'4', L'x', 2,
    L'6', L'5', L'x', 2,
    L'6', L'6', L'x', 2,
    L'6', L'7', L'x', 2,
    L'6', L'8', L'x', 2,
    L'6', L'9', L'x', 2,
    L'7', L'0', L'x', 2,
    L'7', L'1', L'x', 2,
    L'7', L'2', L'x', 2,
    L'7', L'3', L'x', 2,
    L'7', L'4', L'x', 2,
    L'7', L'5', L'x', 2,
    L'7', L'6', L'x', 2,
    L'7', L'7', L'x', 2,
    L'7', L'8', L'x', 2,
    L'7', L'9', L'x', 2,
    L'8', L'0', L'x', 2,
    L'8', L'1', L'x', 2,
    L'8', L'2', L'x', 2,
    L'8', L'3', L'x', 2,
    L'8', L'4', L'x', 2,
    L'8', L'5', L'x', 2,
    L'8', L'6', L'x', 2,
    L'8', L'7', L'x', 2,
    L'8', L'8', L'x', 2,
    L'8', L'9', L'x', 2,
    L'9', L'0', L'x', 2,
    L'9', L'1', L'x', 2,
    L'9', L'2', L'x', 2,
    L'9', L'3', L'x', 2,
    L'9', L'4', L'x', 2,
    L'9', L'5', L'x', 2,
    L'9', L'6', L'x', 2,
    L'9', L'7', L'x', 2,
    L'9', L'8', L'x', 2,
    L'9', L'9', L'x', 2,
    L'1', L'0', L'0', 3,
    L'1', L'0', L'1', 3,
    L'1', L'0', L'2', 3,
    L'1', L'0', L'3', 3,
    L'1', L'0', L'4', 3,
    L'1', L'0', L'5', 3,
    L'1', L'0', L'6', 3,
    L'1', L'0', L'7', 3,
    L'1', L'0', L'8', 3,
    L'1', L'0', L'9', 3,
    L'1', L'1', L'0', 3,
    L'1', L'1', L'1', 3,
    L'1', L'1', L'2', 3,
    L'1', L'1', L'3', 3,
    L'1', L'1', L'4', 3,
    L'1', L'1', L'5', 3,
    L'1', L'1', L'6', 3,
    L'1', L'1', L'7', 3,
    L'1', L'1', L'8', 3,
    L'1', L'1', L'9', 3,
    L'1', L'2', L'0', 3,
    L'1', L'2', L'1', 3,
    L'1', L'2', L'2', 3,
    L'1', L'2', L'3', 3,
    L'1', L'2', L'4', 3,
    L'1', L'2', L'5', 3,
    L'1', L'2', L'6', 3,
    L'1', L'2', L'7', 3,
    L'1', L'2', L'8', 3,
    L'1', L'2', L'9', 3,
    L'1', L'3', L'0', 3,
    L'1', L'3', L'1', 3,
    L'1', L'3', L'2', 3,
    L'1', L'3', L'3', 3,
    L'1', L'3', L'4', 3,
    L'1', L'3', L'5', 3,
    L'1', L'3', L'6', 3,
    L'1', L'3', L'7', 3,
    L'1', L'3', L'8', 3,
    L'1', L'3', L'9', 3,
    L'1', L'4', L'0', 3,
    L'1', L'4', L'1', 3,
    L'1', L'4', L'2', 3,
    L'1', L'4', L'3', 3,
    L'1', L'4', L'4', 3,
    L'1', L'4', L'5', 3,
    L'1', L'4', L'6', 3,
    L'1', L'4', L'7', 3,
    L'1', L'4', L'8', 3,
    L'1', L'4', L'9', 3,
    L'1', L'5', L'0', 3,
    L'1', L'5', L'1', 3,
    L'1', L'5', L'2', 3,
    L'1', L'5', L'3', 3,
    L'1', L'5', L'4', 3,
    L'1', L'5', L'5', 3,
    L'1', L'5', L'6', 3,
    L'1', L'5', L'7', 3,
    L'1', L'5', L'8', 3,
    L'1', L'5', L'9', 3,
    L'1', L'6', L'0', 3,
    L'1', L'6', L'1', 3,
    L'1', L'6', L'2', 3,
    L'1', L'6', L'3', 3,
    L'1', L'6', L'4', 3,
    L'1', L'6', L'5', 3,
    L'1', L'6', L'6', 3,
    L'1', L'6', L'7', 3,
    L'1', L'6', L'8', 3,
    L'1', L'6', L'9', 3,
    L'1', L'7', L'0', 3,
    L'1', L'7', L'1', 3,
    L'1', L'7', L'2', 3,
    L'1', L'7', L'3', 3,
    L'1', L'7', L'4', 3,
    L'1', L'7', L'5', 3,
    L'1', L'7', L'6', 3,
    L'1', L'7', L'7', 3,
    L'1', L'7', L'8', 3,
    L'1', L'7', L'9', 3,
    L'1', L'8', L'0', 3,
    L'1', L'8', L'1', 3,
    L'1', L'8', L'2', 3,
    L'1', L'8', L'3', 3,
    L'1', L'8', L'4', 3,
    L'1', L'8', L'5', 3,
    L'1', L'8', L'6', 3,
    L'1', L'8', L'7', 3,
    L'1', L'8', L'8', 3,
    L'1', L'8', L'9', 3,
    L'1', L'9', L'0', 3,
    L'1', L'9', L'1', 3,
    L'1', L'9', L'2', 3,
    L'1', L'9', L'3', 3,
    L'1', L'9', L'4', 3,
    L'1', L'9', L'5', 3,
    L'1', L'9', L'6', 3,
    L'1', L'9', L'7', 3,
    L'1', L'9', L'8', 3,
    L'1', L'9', L'9', 3,
    L'2', L'0', L'0', 3,
    L'2', L'0', L'1', 3,
    L'2', L'0', L'2', 3,
    L'2', L'0', L'3', 3,
    L'2', L'0', L'4', 3,
    L'2', L'0', L'5', 3,
    L'2', L'0', L'6', 3,
    L'2', L'0', L'7', 3,
    L'2', L'0', L'8', 3,
    L'2', L'0', L'9', 3,
    L'2', L'1', L'0', 3,
    L'2', L'1', L'1', 3,
    L'2', L'1', L'2', 3,
    L'2', L'1', L'3', 3,
    L'2', L'1', L'4', 3,
    L'2', L'1', L'5', 3,
    L'2', L'1', L'6', 3,
    L'2', L'1', L'7', 3,
    L'2', L'1', L'8', 3,
    L'2', L'1', L'9', 3,
    L'2', L'2', L'0', 3,
    L'2', L'2', L'1', 3,
    L'2', L'2', L'2', 3,
    L'2', L'2', L'3', 3,
    L'2', L'2', L'4', 3,
    L'2', L'2', L'5', 3,
    L'2', L'2', L'6', 3,
    L'2', L'2', L'7', 3,
    L'2', L'2', L'8', 3,
    L'2', L'2', L'9', 3,
    L'2', L'3', L'0', 3,
    L'2', L'3', L'1', 3,
    L'2', L'3', L'2', 3,
    L'2', L'3', L'3', 3,
    L'2', L'3', L'4', 3,
    L'2', L'3', L'5', 3,
    L'2', L'3', L'6', 3,
    L'2', L'3', L'7', 3,
    L'2', L'3', L'8', 3,
    L'2', L'3', L'9', 3,
    L'2', L'4', L'0', 3,
    L'2', L'4', L'1', 3,
    L'2', L'4', L'2', 3,
    L'2', L'4', L'3', 3,
    L'2', L'4', L'4', 3,
    L'2', L'4', L'5', 3,
    L'2', L'4', L'6', 3,
    L'2', L'4', L'7', 3,
    L'2', L'4', L'8', 3,
    L'2', L'4', L'9', 3,
    L'2', L'5', L'0', 3,
    L'2', L'5', L'1', 3,
    L'2', L'5', L'2', 3,
    L'2', L'5', L'3', 3,
    L'2', L'5', L'4', 3,
    L'2', L'5', L'5', 3
};

VOID 
NetworkToUnicode(
    IN  DWORD   dwAddress,
    OUT PWCHAR  pwszBuffer
    )

/*++

Routine Description:

    This function takes an Internet address structure specified by the
    in parameter.  It returns an UNICODE string representing the address
    in ".'' notation as "a.b.c.d".  Note that unlike inet_ntoa, this requires
    the user to supply a buffer. This is good because all of the TLS crap
    now can be thrown out - and the function is leaner and meaner. Ofcourse
    this does make it incompatible with inet_ntoa since the parameters are
    different. And it makes it less safe since bad buffers will cause an
    a.v.

Arguments:

    iaAddress   A structure which represents an Internet host address.
    pwszBufer   User supplied buffer to ATLEAST WCHAR[16]. Since there is
                no try/except - you will crash if you dont supply a "good"
                buffer. The formatted address is returned in this buffer
Return Value:

    None

--*/
{
    PBYTE  p;
    PWCHAR b;

    
    b = pwszBuffer;

    //
    // In an unrolled loop, calculate the string value for each of the four
    // bytes in an IP address.  Note that for values less than 100 we will
    // do one or two extra assignments, but we save a test/jump with this
    // algorithm.
    //

    p = (PBYTE)&dwAddress;

    *b      = NToUWCharStrings[*p][0];
    *(b+1)  = NToUWCharStrings[*p][1];
    *(b+2)  = NToUWCharStrings[*p][2];
    b      += NToUWCharStrings[*p][3];
    *b++    = L'.';

    p++;
    *b      = NToUWCharStrings[*p][0];
    *(b+1)  = NToUWCharStrings[*p][1];
    *(b+2)  = NToUWCharStrings[*p][2];
    b      += NToUWCharStrings[*p][3];
    *b++    = L'.';

    p++;
    *b      = NToUWCharStrings[*p][0];
    *(b+1)  = NToUWCharStrings[*p][1];
    *(b+2)  = NToUWCharStrings[*p][2];
    b      += NToUWCharStrings[*p][3];
    *b++    = L'.';

    p++;
    *b      = NToUWCharStrings[*p][0];
    *(b+1)  = NToUWCharStrings[*p][1];
    *(b+2)  = NToUWCharStrings[*p][2];
    b      += NToUWCharStrings[*p][3];
    *b      = UNICODE_NULL;
}

DWORD
UnicodeToNetwork(
    PWCHAR  pwszAddr
    )
{
    CHAR    szAddr[MAX_TOKEN_LENGTH + 1];
    INT     iCount;

    iCount = WideCharToMultiByte(CP_ACP,
                                 0,
                                 pwszAddr,
                                 wcslen(pwszAddr),
                                 szAddr,
                                 MAX_TOKEN_LENGTH,
                                 NULL,
                                 NULL);

    szAddr[iCount] = '\0';

    return inet_addr(szAddr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\utility\ipkern\ipkern.h ===
#ifndef __IPKERN_IPKERN_H__
#define __IPKERN_IPKERN_H__

typedef
VOID
(*PCMD_HANDLER)(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    );
    
typedef struct _CMD_ENTRY
{
    DWORD           dwTokenId;

    PCMD_HANDLER    pfnHandler;

}CMD_ENTRY, *PCMD_ENTRY;

#define PhysAddrToUnicode(pwszUnicode,pszAddr,dwLen)            \
{                                                               \
    CHAR __szTemp[3*MAXLEN_PHYSADDR + 8];                       \
    DWORD __i,__dwTempLen;                                      \
    __dwTempLen = (((dwLen) <= MAXLEN_PHYSADDR) ? (dwLen) : MAXLEN_PHYSADDR); \
    for(__i = 0; __i < __dwTempLen; __i++)                      \
    {                                                           \
        sprintf(&(__szTemp[3*__i]),"%02X-",pszAddr[__i]);       \
    }                                                           \
    MultiByteToWideChar(CP_ACP,                                 \
                        0,                                      \
                        (__szTemp),                             \
                        -1,                                     \
                        (pwszUnicode),                          \
                        3*__i);                                 \
    pwszUnicode[(3*__i) - 1] = TEXT('\0');                      \
}

BOOL
MatchToken(
    IN  PWCHAR  pwszToken,
    IN  DWORD   dwTokenId
    );

LONG
ParseCommand(
    PCMD_ENTRY  pCmdTable,
    LONG        lNumEntries,
    PWCHAR      pwszFirstArg
    );

VOID
NetworkToUnicode(
    IN  DWORD   dwAddress,
    OUT PWCHAR  pwszBuffer
    );

DWORD
DisplayMessage(
    DWORD    dwMsgId,
    ...
    );

PWCHAR
MakeString(
    DWORD dwMsgId,
    ...
    );

VOID
FreeString(
    PWCHAR  pwszString
    );

DWORD
UnicodeToNetwork(
    PWCHAR  pwszAddr
    );

#endif // __IPKERN_IPKERN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\utility\ipkern\inc.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <crt\stddef.h>
#include <crt\locale.h>
#include <winsock.h>
#include <objbase.h>
#include <initguid.h>

#include <mprapi.h>
#include <iprtrmib.h>

#include <ndispnp.h>
#include <ntddip.h>

#include <iphlpapi.h>
#include <ipinfo.h>
#include <iphlpstk.h>
#include <nhapi.h>

#include "strdefs.h"
#include "route.h"
#include "if.h"
#include "addr.h"
#include "arp.h"
#include "ipkern.h"

#define is      ==
#define isnot   !=
#define and     &&
#define or      ||

#define MAX_MSG_LENGTH              5120 //5K
#define MAX_TOKEN_LENGTH            64

typedef WCHAR ADDR_STRING[16];

extern HMODULE g_hModule;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\bpdummy.c ===
#include "..\..\inc\bpool.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\dbgdummy.c ===
#include "..\..\inc\debug.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\utility\ipkern\strdefs.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:


Abstract:



Author:


Revision History:


--*/

#ifndef __IPKERN_STRDEFS_H__
#define __IPKERN_STRDEFS_H__

#define TOKEN_ROUTE                     1001
#define TOKEN_ADDRESS                   1002
#define TOKEN_INTERFACE                 1003
#define TOKEN_ARP                       1004
#define TOKEN_IFINFO                    1005

#define TOKEN_ADD                       2001
#define TOKEN_DELETE                    2002
#define TOKEN_PRINT                     2003
#define TOKEN_MATCH                     2004
#define TOKEN_FLUSH                     2005
#define TOKEN_ENABLE                    2006

#define TOKEN_MASK                      3001
#define TOKEN_METRIC                    3002
#define TOKEN_SRC                       3003

#define TOKEN_STATS                     4001
#define TOKEN_INFO                      4002
#define TOKEN_NAME                      4003
#define TOKEN_GUID                      4004

#define MSG_RTTABLE_HDR                 9001
#define MSG_ADDRTABLE_HDR               9002
#define MSG_ARPTABLE_HDR                9003
#define MSG_IF_INFO                     9004

//
// Usage and help messages
//

#define HMSG_IPKERN_USAGE               10001
#define HMSG_ROUTE_USAGE                10002
#define HMSG_ROUTE_ADD_USAGE            10003
#define HMSG_ROUTE_DELETE_USAGE         10004
#define HMSG_ROUTE_MATCH_USAGE          10005
#define HMSG_ARP_USAGE                  10006
#define HMSG_ARP_FLUSH_USAGE            10007
#define HMSG_IF_USAGE                   10008
#define HMSG_IF_NAME_USAGE              10009
#define HMSG_IF_GUID_USAGE              10010

//
// Error messages and strings
//

#define EMSG_NO_ENTRIES1                20001
#define EMSG_NO_ENTRIES2                20002
#define EMSG_RETRIEVAL_ERROR1           20003
#define EMSG_RETRIEVAL_ERROR2           20004
#define EMSG_UNIQUE_ROUTE_ABSENT        20005
#define EMSG_SET_ERROR1                 20006
#define EMSG_SET_ERROR2                 20007
#define EMSG_RT_BAD_DEST                20008
#define EMSG_RT_BAD_NHOP                20009
#define EMSG_RT_BAD_MASK                20010
#define EMSG_RT_ZERO_IF_METRIC          20011
#define EMSG_RT_BAD_IF_NHOP             20012
#define EMSG_ARP_NO_SUCH_IF             20013
#define EMSG_UNABLE_TO_FLUSH_ARP        20014
#define EMSG_ROUTE_ENABLE               20015
#define EMSG_NO_SUCH_IF                 20016

#define STR_RTTABLE                     30001
#define STR_ADDRTABLE                   30002
#define STR_RTENTRY                     30003
#define STR_ARPTABLE                    30004
#define STR_IFTABLE                     30005
#define STR_OTHER                       30006
#define STR_INVALID                     30007
#define STR_DYNAMIC                     30008
#define STR_STATIC                      30009
#define STR_ETHERNET                    30011
#define STR_TOKENRING                   30012
#define STR_FDDI                        30013
#define STR_PPP                         30014
#define STR_LOOPBACK                    30015
#define STR_SLIP                        30016
#define STR_UP                          30017
#define STR_DOWN                        30018
#define STR_TESTING                     30019
#define STR_NON_OPERATIONAL             30020
#define STR_UNREACHABLE                 30021
#define STR_DISCONNECTED                30022
#define STR_CONNECTING                  30023
#define STR_CONNECTED                   30024
#define STR_OPERATIONAL                 30025

#endif // __IPKERN_STRDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\utility\ipkern\route.h ===
#ifndef __IPKERN_ROUTE_H__
#define __IPKERN_ROUTE_H__

VOID
HandleRoute(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    );

VOID
PrintRoute(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    );

VOID
AddRoute(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    );

VOID
DeleteRoute(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    );

VOID
MatchRoute(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    );

VOID
EnableRoute(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    );

#endif // __IPKERN_ROUTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\adapter.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    wanarp\adapter.h

Abstract:

    Header for adapter.c

Revision History:

    AmritanR

--*/

#ifndef __WANARP_ADAPTER_H__
#define __WANARP_ADAPTER_H__


//
// Reader writer locks to protect the lists of interfaces and adapters
//

RW_LOCK     g_rwlIfLock;
RW_LOCK     g_rwlAdapterLock;

//
// List of interfaces. Protected by g_rwlIfLock
//

LIST_ENTRY  g_leIfList;


//
// List of adapters that are bound to wanarp but not added to IP. 
// Protected by g_rwlAdapterLock. Adapters are put on this list when
// they are created (with a state of AS_FREE) and again when on an APC they
// are deleted from IP.
//

LIST_ENTRY  g_leFreeAdapterList;
ULONG       g_ulNumFreeAdapters;

//
// List of adapters added to IP but not mapped. Protected by g_rwlAdapterLock.
// Adapters are put on this list when they are unmapped
// Adapters are removed from this list by the CloseAdapter callback which
// is invoked when we delete the adapter from  IP on an APC
// Adapters on this list have a state of AS_ADDED
//

LIST_ENTRY  g_leAddedAdapterList;
ULONG       g_ulNumAddedAdapters;

//
// List of adapters added to IP and mapped to an interface. Protected 
// by g_rwlAdapterLock. 
// Adapters are put on this list when they are mapped to an interface. 
// This happens for DU_CALLOUT on LinkUp in which case they can be moved
// directly from the free list when there are no added adapters present.
// For DU_ROUTER this can happen on LinkUp or on DemandDialRequest. 
// Since DemandDialRequest can occur at DPC, we can only map added 
// adapters in that call.
// Adapters are removed when they are unmapped (on LinkDown or 
// ProcessConnectionFailure). An adapter on this list can not be deleted
// Adapters on this list have a state of AS_MAPPED or AS_MAPPING
//

LIST_ENTRY  g_leMappedAdapterList;
ULONG       g_ulNumMappedAdapters;
ULONG       g_ulNumDialOutInterfaces;

//
// List of adapters whose state is changing. Protected by g_rwlAdapterLock.
// 

LIST_ENTRY  g_leChangeAdapterList;

//
// The total number of adapters. Only changed via Interlocked operations.
//

ULONG   g_ulNumAdapters;

//
// Stuff needed to maintain state. Only modified via InterlockedXxx
//

LONG    g_lBindRcvd;

//
// NdisWan binding related info. All are read-only after initialization
//

UNICODE_STRING  g_usNdiswanBindName;

#if DBG

ANSI_STRING     g_asNdiswanDebugBindName;

#endif

NDIS_STRING     g_nsSystemSpecific1;

NDIS_HANDLE     g_nhNdiswanBinding;

//
// The description string for our interfaces
//

#define VENDOR_DESCRIPTION_STRING       "WAN (PPP/SLIP) Interface"
#define VENDOR_DESCRIPTION_STRING_LEN   (strlen(VENDOR_DESCRIPTION_STRING))

INT
WanIpBindAdapter(
    IN  PNDIS_STATUS  pnsRetStatus,
    IN  NDIS_HANDLE   nhBindContext,
    IN  PNDIS_STRING  pnsAdapterName,
    IN  PVOID         pvSS1,
    IN  PVOID         pvSS2
    );

NDIS_STATUS
WanpOpenNdisWan(
    PNDIS_STRING    pnsAdapterName,
    PNDIS_STRING    pnsSystemSpecific1
    );

VOID
WanNdisOpenAdapterComplete(
    NDIS_HANDLE nhHandle,
    NDIS_STATUS nsStatus,
    NDIS_STATUS nsErrorStatus
    );

VOID
WanpSetProtocolTypeComplete(
    NDIS_HANDLE                         nhHandle,
    struct _WANARP_NDIS_REQUEST_CONTEXT *pRequestContext,
    NDIS_STATUS                         nsStatus
    );

VOID
WanpSetLookaheadComplete(
    NDIS_HANDLE                         nhHandle,
    struct _WANARP_NDIS_REQUEST_CONTEXT *pRequestContext,
    NDIS_STATUS                         nsStatus
    );

VOID
WanpSetPacketFilterComplete(
    NDIS_HANDLE                         nhHandle,
    struct _WANARP_NDIS_REQUEST_CONTEXT *pRequestContext,
    NDIS_STATUS                         nsStatus
    );

VOID
WanpLastOidComplete(
    NDIS_HANDLE                         nhHandle,
    struct _WANARP_NDIS_REQUEST_CONTEXT *pRequestContext,
    NDIS_STATUS                         nsStatus
    );

NTSTATUS
WanpInitializeAdapters(
    PVOID   pvContext
    );

NTSTATUS
WanpCreateAdapter(
    IN  GUID                *pAdapterGuid,
    IN  PUNICODE_STRING     pusConfigName,
    IN  PUNICODE_STRING     pusDeviceName,
    OUT ADAPTER             **ppNewAdapter
    );

PADAPTER
WanpFindAdapterToMap(
    IN  DIAL_USAGE      duUsage,
    OUT PKIRQL          pkiIrql,
    IN  DWORD           dwAdapterIndex, OPTIONAL
    IN  PUNICODE_STRING pusNewIfName OPTIONAL
    );

NTSTATUS
WanpAddAdapterToIp(
    IN  PADAPTER        pAdapter,
    IN  BOOLEAN         bServerAdapter,
    IN  DWORD           dwAdapterIndex, OPTIONAL
    IN  PUNICODE_STRING pusNewIfName, OPTIONAL
    IN  DWORD           dwMediaType,
    IN  BYTE            byAccessType,
    IN  BYTE            byConnectionType
    );

VOID
WanpUnmapAdapter(
    PADAPTER    pAdapter
    );

VOID
WanIpOpenAdapter(
    IN  PVOID pvContext
    );

VOID
WanIpCloseAdapter(
    IN  PVOID pvContext
    );

VOID
WanNdisCloseAdapterComplete(
    NDIS_HANDLE nhBindHandle,
    NDIS_STATUS nsStatus
    );

VOID
WanpFreeBindResourcesAndReleaseLock(
    VOID
    );

INT
WanIpDynamicRegister(
    IN  PNDIS_STRING            InterfaceName,
    IN  PVOID                   pvIpInterfaceContext,
    IN  struct _IP_HANDLERS *   IpHandlers,
    IN  struct LLIPBindInfo *   ARPBindInfo,
    IN  UINT                    uiInterfaceNumber
    );

NDIS_STATUS
WanpDoNdisRequest(
    IN  NDIS_REQUEST_TYPE                       RequestType,
    IN  NDIS_OID                                Oid,
    IN  PVOID                                   pvInfo,
    IN  UINT                                    uiInBufferLen,
    IN  PWANARP_NDIS_REQUEST_CONTEXT            pRequestContext,
    IN  PFNWANARP_REQUEST_COMPLETION_HANDLER    pfnCompletionHandler OPTIONAL
    );

VOID
WanNdisRequestComplete(
    IN  NDIS_HANDLE     nhHandle,
    IN  PNDIS_REQUEST   pRequest,
    IN  NDIS_STATUS     nsStatus
    );


PUMODE_INTERFACE
WanpFindInterfaceGivenIndex(
    DWORD  dwIfIndex
    );

VOID
WanpRemoveSomeAddedAdaptersFromIp(
    PVOID   pvContext
    );

VOID
WanpRemoveAllAdaptersFromIp(
    VOID
    );

VOID
WanpRemoveAllAdapters(
    VOID
    );

VOID
WanpDeleteAdapter(
    IN PADAPTER pAdapter
    );

NDIS_STATUS
WanNdisPnPEvent(
    NDIS_HANDLE     nhProtocolBindingContext,
    PNET_PNP_EVENT  pNetPnPEvent
    );

VOID
WanNdisResetComplete(
    NDIS_HANDLE nhHandle,
    NDIS_STATUS nsStatus
    );

VOID
WanNdisBindAdapter(
    PNDIS_STATUS    pnsRetStatus,
    NDIS_HANDLE     nhBindContext,
    PNDIS_STRING    nsAdapterName,
    PVOID           pvSystemSpecific1,
    PVOID           pvSystemSpecific2
    );

VOID
WanNdisUnbindAdapter(
    PNDIS_STATUS    pnsRetStatus,
    NDIS_HANDLE     nhProtocolContext,
    NDIS_HANDLE     nhUnbindContext
    );

VOID
WanpCloseNdisWan(
    PVOID           pvContext
    );


#endif // __WANARP_ADAPTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\utility\ipkern\route.c ===
#include "inc.h"

CMD_ENTRY   g_rgRouteCmdTable[] = {
    {TOKEN_ADD, AddRoute},
    {TOKEN_DELETE, DeleteRoute},
    {TOKEN_PRINT, PrintRoute},
    {TOKEN_MATCH, MatchRoute},
    {TOKEN_ENABLE, EnableRoute},
};

VOID
HandleRoute(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    )
{
    LONG    lIndex;

    if(lNumArgs < 2)
    {
        DisplayMessage(HMSG_ROUTE_USAGE);

        return;
    }

    lIndex = ParseCommand(g_rgRouteCmdTable,
                          sizeof(g_rgRouteCmdTable)/sizeof(CMD_ENTRY),
                          rgpwszArgs[1]);

    if(lIndex is -1)
    {
        DisplayMessage(HMSG_ROUTE_USAGE);

        return;
    }

    g_rgRouteCmdTable[lIndex].pfnHandler(lNumArgs - 1,
                                         &rgpwszArgs[1]);


    return;
}

VOID
PrintRoute(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    )
{
    DWORD               dwResult;
    PMIB_IPFORWARDTABLE pTable;
    ULONG               i;

    dwResult = AllocateAndGetIpForwardTableFromStack(&pTable,
                                                     TRUE,
                                                     GetProcessHeap(),
                                                     HEAP_NO_SERIALIZE);

    if(dwResult isnot NO_ERROR)
    {
        PWCHAR pwszEntry;

        pwszEntry = MakeString(STR_RTTABLE);

        if(pwszEntry)
        {
            DisplayMessage(EMSG_RETRIEVAL_ERROR1,
                           dwResult,
                           pwszEntry);

            FreeString(pwszEntry);
        }
        else
        {
            DisplayMessage(EMSG_RETRIEVAL_ERROR2,
                           dwResult);
        }

        return;
    }

    if(pTable->dwNumEntries is 0)
    {
        PWCHAR  pwszEntryType;

        pwszEntryType = MakeString(TOKEN_ROUTE);

        if(pwszEntryType)
        {
            DisplayMessage(EMSG_NO_ENTRIES1,
                           pwszEntryType); 
            
            FreeString(pwszEntryType);
        }
        else
        {
            DisplayMessage(EMSG_NO_ENTRIES2);
        }

        HeapFree(GetProcessHeap(),
                 HEAP_NO_SERIALIZE,
                 pTable);

        return;
    }
    
    DisplayMessage(MSG_RTTABLE_HDR);

    for(i = 0; i < pTable->dwNumEntries; i++)
    {
        ADDR_STRING rgwcDest, rgwcMask, rgwcNHop;

        NetworkToUnicode(pTable->table[i].dwForwardDest,
                         rgwcDest);

        NetworkToUnicode(pTable->table[i].dwForwardMask,
                         rgwcMask);

        NetworkToUnicode(pTable->table[i].dwForwardNextHop,
                         rgwcNHop);

        wprintf(L"%-15s\t%-15s\t%-15s\t%8d\t%4d\t%4d\n", 
                rgwcDest,
                rgwcMask,
                rgwcNHop,
                pTable->table[i].dwForwardIfIndex,
                pTable->table[i].dwForwardMetric1,
                pTable->table[i].dwForwardProto);
    }
        
    HeapFree(GetProcessHeap(),
             HEAP_NO_SERIALIZE,
             pTable);
}

VOID
AddRoute(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    )
{
    DWORD   dwResult, dwMask, dwDest, dwNHop, dwMetric, dwIfIndex;
    BOOL    bValid;
    ULONG   i;

    PMIB_IPADDRTABLE   pTable;
    MIB_IPFORWARDROW   Route;

    //
    // Parse the rest of the arguments
    // The command line at this point should read:
    // ADD <dest> MASK <mask> <nhop> [IF <ifIndex>] [METRIC <metric>]
    //

    if(lNumArgs < 5)
    {
        DisplayMessage(HMSG_ROUTE_ADD_USAGE);

        return;
    }

    if(!MatchToken(rgpwszArgs[2],
                   TOKEN_MASK))
    {
        DisplayMessage(HMSG_ROUTE_ADD_USAGE);
 
        return;
    }
 
    dwDest = UnicodeToNetwork(rgpwszArgs[1]);
    dwMask = UnicodeToNetwork(rgpwszArgs[3]);
    dwNHop = UnicodeToNetwork(rgpwszArgs[4]);

    do
    {
        DWORD   dwTestMask, dwNMask;

        dwTestMask = 0;

        if(dwMask is 0)
        {
            bValid = TRUE;

            break;
        }

        bValid = FALSE;

        for(i = 0; bValid or (i < 32); i++)
        {
            dwTestMask = 0x80000000 | (dwTestMask >> 1);

            dwNMask = RtlUlongByteSwap(dwTestMask);

            if(dwMask is dwNMask)
            {
                bValid = TRUE;

                break;
            }
        }

    }while(FALSE);


    if(dwDest is INADDR_NONE)
    {
        DisplayMessage(EMSG_RT_BAD_DEST);

        return;
    }

    if(dwNHop is INADDR_NONE)
    {
        DisplayMessage(EMSG_RT_BAD_NHOP);

        return;
    }

    if(bValid isnot TRUE)
    {
        DisplayMessage(EMSG_RT_BAD_MASK);

        return;
    }

    if((dwDest & dwMask) isnot dwDest)
    {
        DisplayMessage(EMSG_RT_BAD_DEST);

        return;
    }

    //
    // See if we have an index or metric
    //

    dwIfIndex = (DWORD)-1;
    dwMetric  = 1;
 
    if(lNumArgs > 5)
    {
        if((lNumArgs isnot 7) and
           (lNumArgs isnot 9))
        {
            DisplayMessage(HMSG_ROUTE_ADD_USAGE);

            return;
        }

        if(!MatchToken(rgpwszArgs[5],
                       TOKEN_INTERFACE))
        {
            DisplayMessage(HMSG_ROUTE_ADD_USAGE);

            return;
        }

        dwIfIndex = wcstoul(rgpwszArgs[6],
                            NULL,
                            10);


        if(lNumArgs is 9)
        {
            if(!MatchToken(rgpwszArgs[7],
                           TOKEN_METRIC))
            {
                DisplayMessage(HMSG_ROUTE_ADD_USAGE);

                return;
            }

            dwMetric = wcstoul(rgpwszArgs[8],
                               NULL,
                               10);
        }

        if((dwIfIndex && dwMetric) is 0)
        {
            DisplayMessage(EMSG_RT_ZERO_IF_METRIC);

            return;
        }
    }
        

    //
    // Get the address table
    //

    
    dwResult = AllocateAndGetIpAddrTableFromStack(&pTable,
                                                  FALSE,
                                                  GetProcessHeap(),
                                                  HEAP_NO_SERIALIZE);


    if(dwResult isnot NO_ERROR)
    {
        PWCHAR pwszEntry;

        pwszEntry = MakeString(STR_ADDRTABLE);

        if(pwszEntry)
        {
            DisplayMessage(EMSG_RETRIEVAL_ERROR1,
                           dwResult,
                           pwszEntry);

            FreeString(pwszEntry);
        }
        else
        {
            DisplayMessage(EMSG_RETRIEVAL_ERROR2,
                           dwResult);
        }

        return;
    }

    bValid = FALSE;

    for(i = 0; i < pTable->dwNumEntries; i++)
    {
        DWORD   dwNet;

        if((pTable->table[i].dwAddr is 0) or
           (pTable->table[i].dwMask is 0))
        {
            continue;
        }

        if(dwIfIndex isnot (DWORD)-1)
        {
            if(pTable->table[i].dwIndex is dwIfIndex)
            {
                if(pTable->table[i].dwMask is 0xFFFFFFFF)
                {
                    //
                    // cant do a next hop check
                    //
        
                    bValid = TRUE;

                    break;
                }

                dwNet = pTable->table[i].dwAddr & pTable->table[i].dwMask;

                if((dwNHop & pTable->table[i].dwMask) is dwNet)
                {
                    bValid = TRUE;

                    break;
                }
            }
        }
        else
        {
            //
            // Dont have an interface index
            // See if we can find an network on which the next hop lies
            //

            dwNet = pTable->table[i].dwAddr & pTable->table[i].dwMask;

            if((dwNHop & pTable->table[i].dwMask) is dwNet)
            {
                bValid = TRUE;

                dwIfIndex = pTable->table[i].dwIndex;

                break;
            }
        }
    }

    if(!bValid)
    {
        DisplayMessage(EMSG_RT_BAD_IF_NHOP);

        return;
    }

           
    ZeroMemory(&Route,
               sizeof(MIB_IPFORWARDROW));

    Route.dwForwardDest     = dwDest;
    Route.dwForwardMask     = dwMask;
    Route.dwForwardNextHop  = dwNHop;
    Route.dwForwardIfIndex  = dwIfIndex;
    Route.dwForwardMetric1  = dwMetric;
    Route.dwForwardProto    = MIB_IPPROTO_LOCAL;

    if((dwDest is pTable->table[i].dwAddr) or
       (dwDest is dwNHop))
    {
        Route.dwForwardType = MIB_IPROUTE_TYPE_DIRECT;
    }
    else
    {
        Route.dwForwardType = MIB_IPROUTE_TYPE_INDIRECT;
    }


    dwResult = SetIpForwardEntryToStack(&Route);

    if(dwResult isnot NO_ERROR)
    {
        PWCHAR pwszEntry;

        pwszEntry = MakeString(STR_RTENTRY);

        if(pwszEntry)
        {
            DisplayMessage(EMSG_SET_ERROR1,
                           dwResult,
                           pwszEntry);

            FreeString(pwszEntry);
        }
        else
        {
            DisplayMessage(EMSG_SET_ERROR2,
                           dwResult);
        }
    }
 
    HeapFree(GetProcessHeap(),
             HEAP_NO_SERIALIZE,
             pTable);
}

VOID
DeleteRoute(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    )
{
    DWORD   dwResult, dwMask, dwDest, dwNHop, dwIfIndex;
    BOOL    bAny;
    ULONG   i;

    PMIB_IPFORWARDTABLE pTable;
    PMIB_IPFORWARDROW   pRoute;

    //
    // Parse the rest of the arguments
    // The command line at this point should read:
    // DELETE <dest> [MASK <mask>] [<nhop>] [IF <ifIndex>]
    //

    if(lNumArgs < 2)
    {
        DisplayMessage(HMSG_ROUTE_DELETE_USAGE);

        return;
    }

    dwDest = UnicodeToNetwork(rgpwszArgs[1]);

    if((lNumArgs > 2) and
       (lNumArgs isnot 7))
    {
        DisplayMessage(HMSG_ROUTE_DELETE_USAGE);

        return;
    }

    bAny = TRUE;

    if(lNumArgs is 7)
    {
        if(!MatchToken(rgpwszArgs[2],
                       TOKEN_MASK))
        {
            DisplayMessage(HMSG_ROUTE_DELETE_USAGE);

            return;
        }

        if(!MatchToken(rgpwszArgs[5],
                       TOKEN_INTERFACE))
        {
            DisplayMessage(HMSG_ROUTE_DELETE_USAGE);

            return;
        }

        dwMask    = UnicodeToNetwork(rgpwszArgs[3]);
        dwNHop    = UnicodeToNetwork(rgpwszArgs[4]);
        dwIfIndex = wcstoul(rgpwszArgs[6],
                            NULL,
                            10);

        if((dwNHop is INADDR_NONE) or
           (dwIfIndex is 0))
        {
            DisplayMessage(HMSG_ROUTE_DELETE_USAGE);

            return;
        }

        bAny = FALSE;
    }

    //
    // Get the route table and see if such a route exists
    //

    dwResult = AllocateAndGetIpForwardTableFromStack(&pTable,
                                                     TRUE,
                                                     GetProcessHeap(),
                                                     HEAP_NO_SERIALIZE);

    if(dwResult isnot NO_ERROR)
    {
        PWCHAR pwszEntry;

        pwszEntry = MakeString(STR_RTTABLE);

        if(pwszEntry)
        {
            DisplayMessage(EMSG_RETRIEVAL_ERROR1,
                           dwResult,
                           pwszEntry);

            FreeString(pwszEntry);
        }
        else
        {
            DisplayMessage(EMSG_RETRIEVAL_ERROR2,
                           dwResult);
        }

        return;
    }

    if(pTable->dwNumEntries is 0)
    {
        PWCHAR  pwszEntryType;

        pwszEntryType = MakeString(TOKEN_ROUTE);

        if(pwszEntryType)
        {
            DisplayMessage(EMSG_NO_ENTRIES1,
                           pwszEntryType);

            FreeString(pwszEntryType);
        }
        else
        {
            DisplayMessage(EMSG_NO_ENTRIES2);
        }

        HeapFree(GetProcessHeap(),
                 HEAP_NO_SERIALIZE,
                 pTable);

        return;
    }

    pRoute = NULL;

    for(i = 0; i < pTable->dwNumEntries; i++)
    {
        if(pTable->table[i].dwForwardDest is dwDest)
        {
            if(bAny)
            {
                if((i is (pTable->dwNumEntries - 1)) or
                   (pTable->table[i + 1].dwForwardDest isnot dwDest))
                {
                    //
                    // Unique entry
                    //

                    pRoute = &(pTable->table[i]);
                }

                break;       
            }
            else
            {
                //
                // Do an exact match
                //

                if((pTable->table[i].dwForwardMask is dwMask) and
                   (pTable->table[i].dwForwardNextHop is dwNHop) and
                   (pTable->table[i].dwForwardIfIndex is dwIfIndex))
                {
                    pRoute = &(pTable->table[i]);

                    break;
                }
            }
        }
    }

    if(pRoute is NULL)
    {
        DisplayMessage(EMSG_UNIQUE_ROUTE_ABSENT);

        HeapFree(GetProcessHeap(),
                 HEAP_NO_SERIALIZE,
                 pTable); 

        return;
    }

    pRoute->dwForwardType = MIB_IPROUTE_TYPE_INVALID;

    dwResult = SetIpForwardEntryToStack(pRoute);

    if(dwResult isnot NO_ERROR)
    {
        PWCHAR pwszEntry;

        pwszEntry = MakeString(STR_RTENTRY);

        if(pwszEntry)
        {
            DisplayMessage(EMSG_SET_ERROR1,
                           dwResult,
                           pwszEntry);

            FreeString(pwszEntry);
        }
        else
        {
            DisplayMessage(EMSG_SET_ERROR2,
                           dwResult);
        }
    }

    HeapFree(GetProcessHeap(),
             HEAP_NO_SERIALIZE,
             pTable); 

}

VOID
MatchRoute(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    )
{
    DWORD   dwResult, dwDest, dwSrc;

    ADDR_STRING      rgwcDest, rgwcMask, rgwcNHop;
    MIB_IPFORWARDROW Route;

    //
    // Command line should be MATCH <dest> [SRC <srcAddr>]
    //

    if(lNumArgs < 2)
    {
        DisplayMessage(HMSG_ROUTE_MATCH_USAGE);

        return;
    }

    dwSrc = 0;

    if(lNumArgs > 2)
    {
        if(lNumArgs isnot 4)
        {
            DisplayMessage(HMSG_ROUTE_MATCH_USAGE);

            return;
        }

        if(!MatchToken(rgpwszArgs[2],
                       TOKEN_SRC))
        {
            DisplayMessage(HMSG_ROUTE_MATCH_USAGE);

            return;
        }

        dwSrc = UnicodeToNetwork(rgpwszArgs[3]);
    }

    dwDest = UnicodeToNetwork(rgpwszArgs[1]);

    dwResult = GetBestRouteFromStack(dwDest,
                                     dwSrc,
                                     &Route);

    if(dwResult isnot NO_ERROR)
    {
        PWCHAR pwszEntry;

        pwszEntry = MakeString(STR_RTENTRY);

        if(pwszEntry)
        {
            DisplayMessage(EMSG_RETRIEVAL_ERROR1,
                           dwResult,
                           pwszEntry);

            FreeString(pwszEntry);
        }
        else
        {
            DisplayMessage(EMSG_RETRIEVAL_ERROR2,
                           dwResult);
        }

        return;
    }

    NetworkToUnicode(Route.dwForwardDest,
                     rgwcDest);

    NetworkToUnicode(Route.dwForwardMask,
                     rgwcMask);

    NetworkToUnicode(Route.dwForwardNextHop,
                     rgwcNHop);

    DisplayMessage(MSG_RTTABLE_HDR);

    wprintf(L"%-15s\t%-15s\t%-15s\t%-4d\t%d\t%4d\n",
            rgwcDest,
            rgwcMask,
            rgwcNHop,
            Route.dwForwardIfIndex,
            Route.dwForwardMetric1,
            Route.dwForwardProto);
    
}

VOID
EnableRoute(
    LONG    lNumArgs,
    PWCHAR  rgpwszArgs[]
    )
{
    const WCHAR Empty[] = L"";
    UNICODE_STRING BindList;
    HKEY Key;
    UNICODE_STRING LowerComponent;
    IP_PNP_RECONFIG_REQUEST Request;
    UINT status;
    const WCHAR Tcpip[] = L"Tcpip";
    const TCHAR TcpipParameters[] =
        TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters");
    UNICODE_STRING UpperComponent;
    RtlInitUnicodeString(&BindList, Empty);
    RtlInitUnicodeString(&LowerComponent, Empty);
    RtlInitUnicodeString(&UpperComponent, Tcpip);
    Request.version = IP_PNP_RECONFIG_VERSION;
    Request.NextEntryOffset = 0;
    Request.arpConfigOffset = 0;
    Request.IPEnableRouter = TRUE;
    Request.Flags = IP_PNP_FLAG_IP_ENABLE_ROUTER;
    status = NdisHandlePnPEvent(NDIS,
                                RECONFIGURE,
                                &LowerComponent,
                                &UpperComponent,
                                &BindList,
                                &Request,
                                sizeof(Request)
                                );
    if (!status)
    {
        DisplayMessage(EMSG_ROUTE_ENABLE, GetLastError());
    }

    if (RegOpenKey(HKEY_LOCAL_MACHINE, TcpipParameters, &Key) == NO_ERROR)
    {
        status = TRUE;
        RegSetValueEx(Key,
                      TEXT("IPEnableRouter"),
                      0,
                      REG_DWORD,
                      (PBYTE)&status,
                      sizeof(status)
                      );
        RegCloseKey(Key);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\adapter.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    wanarp\adapter.c

Abstract:


    The file contains the section interface of WANARP to the TCP/IP stack
    that is involved with Binding Notification and Querying/Setting
    information for interfaces

Revision History:

    AmritanR

--*/

#define __FILE_SIG__    ADAPTER_SIG

#include "inc.h"
#pragma  hdrstop


NDIS_HANDLE g_nhUnbindContext;
NDIS_HANDLE g_nhBindContext;
NDIS_STATUS g_nsStatus = 0;
NDIS_STATUS g_nsError = 0;

BOOLEAN         g_bRemovalInProgress;
WORK_QUEUE_ITEM g_wqiWorkItem;
WORK_QUEUE_ITEM g_wqiNdisWorkItem;

const GUID      ServerInterfaceGuid = {0x6e06f030, 0x7526, 0x11d2, {0xba, 0xf4, 0x00, 0x60, 0x08, 0x15, 0xa4, 0xbd}};

extern 
VOID
IPDelayedNdisReEnumerateBindings(
    CTEEvent        *Event,
    PVOID           Context
    );

BOOLEAN
IsBindingPresent(
    IN  GUID    *pGuid
    );

VOID
WanNdisBindAdapter(
    PNDIS_STATUS  pnsRetStatus,
    NDIS_HANDLE   nhBindContext,
    PNDIS_STRING  nsAdapterName,
    PVOID         pvSystemSpecific1,
    PVOID         pvSystemSpecific2
    )
{
    RtAssert(FALSE);
}

INT
WanIpBindAdapter(
    IN  PNDIS_STATUS  pnsRetStatus,
    IN  NDIS_HANDLE   nhBindContext,
    IN  PNDIS_STRING  pnsAdapterName,
    IN  PVOID         pvSS1,
    IN  PVOID         pvSS2
    )

/*++

Routine Description:

    Called by IP to bind an adapter. We open the binding and then do
    all the other work in complete handler

Locks:

    The routine acquires the global adapter list lock, so it is not
    PAGEABLE.

Arguments:


Return Value:


--*/

{
    NDIS_STATUS     nsStatus;
    KIRQL           kiIrql;
    LONG            lResult;

#if DBG

    ANSI_STRING     asTempAnsiString;

#endif

    TraceEnter(ADPT, "WanIpBindAdapter");

    //
    // Serialize Bind, Unbind code
    //

    WanpAcquireResource(&g_wrBindMutex);

    RtAcquireSpinLock(&g_rlStateLock,
                      &kiIrql);

    //
    // See if we have already received a BIND call or are in the process
    // of servicing a bind
    //

    if(g_lBindRcvd isnot 0)
    {
        //
        // We have already received a bind call
        //

        RtAssert(g_lBindRcvd is 1);

        RtReleaseSpinLock(&g_rlStateLock,
                          kiIrql);

        WanpReleaseResource(&g_wrBindMutex);

        Trace(ADPT,ERROR,
              ("WanIpBindAdapter: Duplicate bind call\n"));

        *pnsRetStatus = NDIS_STATUS_SUCCESS;

        TraceLeave(ADPT, "WanIpBindAdapter");

        return FALSE;
    }

    //
    // Set BindRcvd to 1 so that we dont service any binds till we
    // get done
    //

    g_lBindRcvd = 1;

    RtReleaseSpinLock(&g_rlStateLock,
                      kiIrql);

    Trace(ADPT, INFO,
          ("WanIpBindAdapter: IP called to bind to adapter %S\n",
           pnsAdapterName->Buffer));

    //
    // We need to open this adapter as our NDISWAN binding
    //

    g_nhBindContext = nhBindContext;

    nsStatus = WanpOpenNdisWan(pnsAdapterName,
                               (PNDIS_STRING)pvSS1);


    if((nsStatus isnot NDIS_STATUS_SUCCESS) and
       (nsStatus isnot NDIS_STATUS_PENDING))
    {
        RtAcquireSpinLock(&g_rlStateLock,
                          &kiIrql);

        g_lBindRcvd = 0;

        RtReleaseSpinLock(&g_rlStateLock,
                          kiIrql);

        Trace(ADPT, ERROR,
              ("WanIpBindAdapter: Error %x opening NDISWAN on %S\n",
              nsStatus,
              pnsAdapterName->Buffer));

    }

    *pnsRetStatus = nsStatus;

    //
    // At this point we are done. If the operation finished synchronously
    // then our OpenAdapterComplete handler has already been called
    // Otherwise stuff will happen later
    //

    TraceLeave(ADPT, "WanIpBindAdapter");

    return TRUE;
}

#pragma alloc_text(PAGE, WanpOpenNdisWan)


NDIS_STATUS
WanpOpenNdisWan(
    PNDIS_STRING    pnsAdapterName,
    PNDIS_STRING    pnsSystemSpecific1
    )

/*++

Routine Description:

    This routine opens the ndiswan adapter. It also stores the SS1 string
    in a global for use by the completion routine

Locks:

    Called with the g_wrBindMutex held exclusively

Arguments:

    pusBindName         Name of the bindings
    pnsSystemSpecific1  The SS1 passed in the bind call from IP

Return Value:


--*/

{
    NDIS_STATUS     nsStatus, nsError;
    UINT            i;
    NDIS_MEDIUM     MediaArray[] = {NdisMediumWan};
    PWCHAR          pwcNameBuffer, pwcStringBuffer;
    PBYTE           pbyBuffer;


    PAGED_CODE();

    TraceEnter(ADPT,"OpenNdiswan");

    //
    // Save a copy of the NDIS binding name
    // Increase the length by 1 so that we can NULL terminate it for
    // easy printing
    //

    pnsAdapterName->Length += sizeof(WCHAR);

    g_usNdiswanBindName.Buffer = RtAllocate(NonPagedPool,
                                            pnsAdapterName->Length,
                                            WAN_STRING_TAG);

    if(g_usNdiswanBindName.Buffer is NULL)
    {
        Trace(GLOBAL, ERROR,
              ("OpenNdiswan: Unable to allocate %d bytes\n",
               pnsAdapterName->Length));

        g_nhBindContext = NULL;               
        WanpReleaseResource(&g_wrBindMutex);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_usNdiswanBindName.MaximumLength = pnsAdapterName->Length;

    RtlUpcaseUnicodeString(&g_usNdiswanBindName,
                           pnsAdapterName,
                           FALSE);

    pnsAdapterName->Length     -= sizeof(WCHAR);
    g_usNdiswanBindName.Length -= sizeof(WCHAR);

    //
    // NULL terminate
    //
    
    g_usNdiswanBindName.Buffer[g_usNdiswanBindName.MaximumLength/sizeof(WCHAR) - 1] = UNICODE_NULL;

    //
    // Save a copy of SS1
    //

    pwcStringBuffer = RtAllocate(NonPagedPool,
                                 pnsSystemSpecific1->MaximumLength,
                                 WAN_STRING_TAG);


    if(pwcStringBuffer is NULL)
    {
        RtFree(g_usNdiswanBindName.Buffer);

        g_usNdiswanBindName.Buffer        = NULL;
        g_usNdiswanBindName.MaximumLength = 0;
        g_usNdiswanBindName.Length        = 0;

        g_nhBindContext = NULL;
        WanpReleaseResource(&g_wrBindMutex);
        return NDIS_STATUS_RESOURCES;
    }

    RtlZeroMemory(pwcStringBuffer,
                  pnsSystemSpecific1->MaximumLength);

    //
    // Save a copy of the SS1 string
    //

    g_nsSystemSpecific1.MaximumLength   = pnsSystemSpecific1->MaximumLength;
    g_nsSystemSpecific1.Length          = pnsSystemSpecific1->Length;
    g_nsSystemSpecific1.Buffer          = pwcStringBuffer;

    RtlCopyMemory(g_nsSystemSpecific1.Buffer,
                  pnsSystemSpecific1->Buffer,
                  pnsSystemSpecific1->Length);

    //
    // Open the NDIS adapter.
    //

    Trace(ADPT, INFO,
          ("OpenNdiswan: Opening %S\n", g_usNdiswanBindName.Buffer));

    //
    // Medium index
    //

    i = 0;

#define MAX_MEDIA               1

    NdisOpenAdapter(&nsStatus,
                    &nsError,
                    &g_nhNdiswanBinding,
                    &i,
                    MediaArray,
                    MAX_MEDIA,
                    g_nhWanarpProtoHandle,
                    (NDIS_HANDLE)0x0CABB1E5,
                    pnsAdapterName, 
                    0,
                    NULL);


#undef MAX_MEDIA

    if(nsStatus isnot NDIS_STATUS_PENDING)
    {
        //
        // we always return PENDING to NDIS because we need to
        // do a switch to system thread when we are done setting OIDS to
        // NDISWAN. So call out completion routine here
        //

        WanNdisOpenAdapterComplete((NDIS_HANDLE)0x0CABB1E5,
                                   nsStatus,
                                   nsError);

        nsStatus = NDIS_STATUS_PENDING;
    }

    TraceLeave(ADPT, "OpenNdiswan");

    return nsStatus;
}

#pragma alloc_text (PAGE, WanNdisOpenAdapterComplete)


VOID
WanNdisOpenAdapterComplete(
    NDIS_HANDLE nhHandle,
    NDIS_STATUS nsStatus,
    NDIS_STATUS nsError
    )

/*++

Routine Description:

    Completion routine called by NDIS when it is done opening the NDISWAN
    binding
    If the open was successful, we start the train of requests

Locks:

    Called either synchronously or off a worker thread with the g_wrBindMutex
    This routine needs to release the resource and set g_lBindRcvd

Arguments:

    nhHandle
    nsStatus
    nsError

Return Value:

    None

--*/

{
    NDIS_STATUS nsResult;
    BYTE        rgbyProtocolId[ARP_802_ADDR_LENGTH] = {0x80,
                                                       0x00,
                                                       0x00,
                                                       0x00,
                                                       0x08,
                                                       0x00};

    PWANARP_NDIS_REQUEST_CONTEXT    pRequestContext;

    TraceEnter(ADPT,"NdisOpenAdapterComplete");

    PAGED_CODE();

    RtAssert(nhHandle is (NDIS_HANDLE)0x0CABB1E5);

    //
    // If we couldnt open the NDIS wan binding, free all the resources
    // and return
    //

    if(nsStatus isnot NDIS_STATUS_SUCCESS)
    {
        Trace(ADPT, ERROR,
              ("OpenAdapterComplete: Status %x\n", nsStatus));

        RtAssert(g_nhBindContext isnot NULL);

        NdisCompleteBindAdapter(g_nhBindContext,
                                nsStatus,
                                nsError);

        g_nhBindContext = NULL;

        WanpFreeBindResourcesAndReleaseLock();

        return;
    }

    //
    // From here on, the NDISWAN adapter is opened, so to cleanup resources
    // we must call CloseNdisWan()
    //

    pRequestContext = RtAllocate(NonPagedPool,
                                 sizeof(WANARP_NDIS_REQUEST_CONTEXT),
                                 WAN_REQUEST_TAG);

    if(pRequestContext is NULL)
    {
        RtAssert(g_nhBindContext isnot NULL);
#if 0        

        NdisCompleteBindAdapter(g_nhBindContext,
                                nsStatus,
                                nsError);
                                

        g_nhBindContext = NULL;
#endif

        g_nsStatus = g_nsError = NDIS_STATUS_RESOURCES;

        ExInitializeWorkItem(&g_wqiNdisWorkItem,
                             WanpCloseNdisWan,
                             NULL);

        ExQueueWorkItem(&g_wqiNdisWorkItem,
                        DelayedWorkQueue);

        // WanpCloseNdisWan(NULL);

        Trace(ADPT, ERROR,
              ("NdisOpenAdapterComplete: Couldnt allocate memory for request context\n"));

        return;
    }

    //
    // Set protocol type
    //

    RtlCopyMemory(pRequestContext->rgbyProtocolId,
                  rgbyProtocolId,
                  sizeof(rgbyProtocolId));

    nsResult = WanpDoNdisRequest(NdisRequestSetInformation,
                                 OID_WAN_PROTOCOL_TYPE,
                                 pRequestContext->rgbyProtocolId,
                                 sizeof(pRequestContext->rgbyProtocolId),
                                 pRequestContext,
                                 WanpSetProtocolTypeComplete);

    if(nsResult isnot NDIS_STATUS_PENDING)
    {
        //
        // No need to call the completion routine, since DoNdisRequest
        // always calls it
        //

        Trace(ADPT, ERROR,
              ("NdisOpenAdapterComplete: %x from OID_WAN_PROTOCOL_TYPE\n",
               nsResult));
    }


    TraceLeave(ADPT,"NdisOpenAdapterComplete");
}


VOID
WanpSetProtocolTypeComplete(
    NDIS_HANDLE                         nhHandle,
    struct _WANARP_NDIS_REQUEST_CONTEXT *pRequestContext,
    NDIS_STATUS                         nsStatus
    )

/*++

Routine Description:

    Completion handler called when we are done with setting
    OID_WAN_PROTOCOL_TYPE

Locks:

    None

Arguments:

    nhHandle            Binding for the adapter to which the request was sent
    pRequestContext     Pointer to the request context
    nsStatus            Result of the request

Return Value:

    None

--*/

{
    NDIS_STATUS nsResult;

    TraceEnter(ADPT,"SetProtocolTypeComplete");

    if(nsStatus isnot NDIS_STATUS_SUCCESS)
    {
        Trace(ADPT, ERROR,
              ("SetProtocolTypeComplete: Status %x\n", nsStatus));

        WanpLastOidComplete(nhHandle,
                            pRequestContext,
                            nsStatus);

        return;
    }

    //
    // Set lookahead size
    //

    pRequestContext->ulLookahead = WANARP_LOOKAHEAD_SIZE;

    nsResult = WanpDoNdisRequest(NdisRequestSetInformation,
                                 OID_GEN_CURRENT_LOOKAHEAD,
                                 &(pRequestContext->ulLookahead),
                                 sizeof(pRequestContext->ulLookahead),
                                 pRequestContext,
                                 WanpSetLookaheadComplete);

    if(nsResult isnot NDIS_STATUS_PENDING)
    {
        Trace(ADPT, ERROR,
              ("SetProtocolTypeComplete: %x from OID_GEN_CURRENT_LOOKAHEAD\n",
               nsResult));
    }

    TraceLeave(ADPT,"SetProtocolTypeComplete");
}

VOID
WanpSetLookaheadComplete(
    NDIS_HANDLE                         nhHandle,
    struct _WANARP_NDIS_REQUEST_CONTEXT *pRequestContext,
    NDIS_STATUS                         nsStatus
    )

/*++

Routine Description:

    Completion handler called when we are done with setting
    OID_GEN_CURRENT_LOOKAHEAD

Locks:

    None

Arguments:

    nhHandle            Binding for the adapter to which the request was sent
    pRequestContext     Pointer to the request context
    nsStatus            Result of the request

Return Value:

    None

--*/

{
    NDIS_STATUS nsResult;

    TraceEnter(ADPT,"SetLookaheadComplete");

    if(nsStatus isnot NDIS_STATUS_SUCCESS)
    {
        Trace(ADPT, ERROR,
              ("SetLookaheadComplete: Status %x\n", nsStatus));

        WanpLastOidComplete(nhHandle,
                            pRequestContext,
                            nsStatus);

        return;
    }

    //
    // Set packet filters
    //

    pRequestContext->ulPacketFilter = 
        NDIS_PACKET_TYPE_BROADCAST | NDIS_PACKET_TYPE_DIRECTED;

    nsResult = WanpDoNdisRequest(NdisRequestSetInformation,
                                 OID_GEN_CURRENT_PACKET_FILTER,
                                 &(pRequestContext->ulPacketFilter),
                                 sizeof(pRequestContext->ulPacketFilter),
                                 pRequestContext,
                                 WanpSetPacketFilterComplete);

    if(nsResult isnot NDIS_STATUS_PENDING)
    {
        Trace(ADPT, ERROR,
              ("SetLookaheadComplete: %x from OID_GEN_CURRENT_PACKET_FILTER\n",
               nsResult));

    }

    TraceLeave(ADPT,"SetLookaheadComplete");
}

VOID
WanpSetPacketFilterComplete(
    NDIS_HANDLE                         nhHandle,
    struct _WANARP_NDIS_REQUEST_CONTEXT *pRequestContext,
    NDIS_STATUS                         nsStatus
    )

/*++

Routine Description:

    Completion handler called when we are done with setting
    OID_GEN_CURRENT_PACKET_FILTER

Locks:

    None

Arguments:

    nhHandle            Binding for the adapter to which the request was sent
    pRequestContext     Pointer to the request context
    nsStatus            Result of the request

Return Value:

    None

--*/

{
    NDIS_STATUS nsResult;
    BYTE        byHeaderSize;

    TraceEnter(ADPT,"SetPacketFilterComplete");

    if(nsStatus isnot NDIS_STATUS_SUCCESS)
    {
        Trace(ADPT, ERROR,
              ("SetPacketFilterComplete: Status %x\n", nsStatus));

        WanpLastOidComplete(nhHandle,
                            pRequestContext,
                            nsStatus);

        return;
    }

    //
    // Set packet filters
    //

    pRequestContext->TransportHeaderOffset.ProtocolType = 
        NDIS_PROTOCOL_ID_TCP_IP;

    pRequestContext->TransportHeaderOffset.HeaderOffset = 
        (USHORT)sizeof(ETH_HEADER);
    
    nsResult = WanpDoNdisRequest(NdisRequestSetInformation,
                                 OID_GEN_TRANSPORT_HEADER_OFFSET,
                                 &(pRequestContext->TransportHeaderOffset),
                                 sizeof(pRequestContext->TransportHeaderOffset),
                                 pRequestContext,
                                 WanpLastOidComplete);

    if(nsResult isnot NDIS_STATUS_PENDING)
    {
        Trace(ADPT, ERROR,
              ("SetPacketFilterComplete: %x from OID_GEN_TRANSPORT_HEADER_OFFSET\n",
               nsResult));

    }

    TraceLeave(ADPT,"SetPacketFilterComplete");
}

VOID
WanpLastOidComplete(
    NDIS_HANDLE                         nhHandle,
    struct _WANARP_NDIS_REQUEST_CONTEXT *pRequestContext,
    NDIS_STATUS                         nsStatus
    )

/*++

Routine Description:

    Completion handler called when we are done with setting the last OID
    Currently that is OID_GEN_TRANSPORT_HEADER_OFFSET,
    If everything went, well we initialize our adapters

Locks:

    None

Arguments:

    nhHandle            Binding for the adapter to which the request was sent
    pRequestContext     Pointer to the request context
    nsStatus            Result of the request

Return Value:

    None

--*/

{
    NDIS_STATUS nsResult;

    TraceEnter(ADPT,"LastOidComplete");

    RtFree(pRequestContext);

    RtAssert(g_wrBindMutex.lWaitCount >= 1);

    if(nsStatus isnot STATUS_SUCCESS)
    {
        RtAssert(g_nhBindContext isnot NULL);

#if 0
        //
        // BindContext being NON-NULL means we are being called
        // asynchronously, hence call NdisCompleteBindAdapter
        //

        NdisCompleteBindAdapter(g_nhBindContext,
                                nsStatus,
                                nsStatus);
        g_nhBindContext = NULL;

#endif                                

        Trace(ADPT, ERROR,
              ("LastOidComplete: Status %x\n", nsStatus));

        g_nsStatus = g_nsError = nsStatus;

        ExInitializeWorkItem(&g_wqiNdisWorkItem,
                             WanpCloseNdisWan,
                             NULL);

        ExQueueWorkItem(&g_wqiNdisWorkItem,
                        DelayedWorkQueue);

        // WanpCloseNdisWan(NULL);

        return;
    }

    //
    // This needs to be put in when the multiple adapters stuff is done
    //

    //
    // The OpenNdiswan call would have setup the system specific
    // Since the WanpInitializeAdapters must be called at PASSIVE, we
    // fire of a work item here to call the function.
    //

    ExInitializeWorkItem(&g_wqiWorkItem,
                         WanpInitializeAdapters,
                         NULL);

    ExQueueWorkItem(&g_wqiWorkItem,
                    DelayedWorkQueue);

    //
    // Dont release the mutex here
    //

    TraceLeave(ADPT,"LastOidComplete");
}

//
// When this is used, remember NOT to use NdisUnbindAdapter as a clean
// up routine because of the way the resource is held
//

#pragma alloc_text(PAGE, WanpInitializeAdapters)

NTSTATUS
WanpInitializeAdapters(
    PVOID pvContext
    )

/*++

Routine Description:

    This routine uses the stored SS1 and opens the IP config for the
    binding. It then loops through the multi_sz and creates one adapter
    for every sz.

Locks:

    Called with the bind mutex held.
    This function releases the mutex

Arguments:

    None

Return Value:


--*/

{
    NDIS_STRING     IPConfigName = NDIS_STRING_CONST("IPConfig");
    NDIS_STATUS     nsStatus;
    NDIS_HANDLE     nhConfigHandle;
    USHORT          i;
    PADAPTER        pNewAdapter;
    NTSTATUS        nStatus, nReturnStatus;
    PWCHAR          pwszDeviceBuffer;

    PNDIS_CONFIGURATION_PARAMETER   pParam;

    TraceEnter(ADPT, "InitializeAdapters");

    PAGED_CODE();
    
    UNREFERENCED_PARAMETER(pvContext);

    RtAssert(g_nhBindContext isnot NULL);

    do
    {
        //
        // Open the key for this "adapter"
        //

        NdisOpenProtocolConfiguration(&nsStatus,
                                      &nhConfigHandle,
                                      &g_nsSystemSpecific1);

        if(nsStatus isnot NDIS_STATUS_SUCCESS)
        {
            Trace(ADPT, ERROR,
                  ("InitializeAdapters: Unable to Open Protocol Config %x\n",
                   nsStatus));

            break;
        }

        //
        //  Read in the IPConfig string. If this is not present,
        //  fail this call.
        //

        NdisReadConfiguration(&nsStatus,
                              &pParam,
                              nhConfigHandle,
                              &IPConfigName,
                              NdisParameterMultiString);

        if((nsStatus isnot NDIS_STATUS_SUCCESS) or
           (pParam->ParameterType isnot NdisParameterMultiString))
        {
            Trace(ADPT, ERROR,
                  ("InitializeAdapters: Unable to read IPConfig. Status %x \n",
                   nsStatus));

            NdisCloseConfiguration(nhConfigHandle);

            nsStatus = STATUS_UNSUCCESSFUL;

            break;
        }


        //
        // Allocate memory for the max length device name - used later
        //

        pwszDeviceBuffer = 
            RtAllocate(NonPagedPool,
                       (WANARP_MAX_DEVICE_NAME_LEN + 1) * sizeof(WCHAR),
                       WAN_STRING_TAG);

        if(pwszDeviceBuffer is NULL)
        {
            NdisCloseConfiguration(nhConfigHandle);

            Trace(ADPT, ERROR,
                  ("InitializeAdapters: Couldnt alloc %d bytes for dev name\n",
                   (WANARP_MAX_DEVICE_NAME_LEN + 1) * sizeof(WCHAR)));


            nsStatus = STATUS_INSUFFICIENT_RESOURCES;

            break;
        }

    }while(FALSE);

    if(nsStatus isnot STATUS_SUCCESS)
    {
        //
        // Tell NDIS that the bind is done but it failed
        //

        g_nsStatus = g_nsError = nsStatus;

#if 0
        NdisCompleteBindAdapter(g_nhBindContext,
                                nsStatus,
                                nsStatus);

        g_nhBindContext = NULL;

#endif        

        WanpCloseNdisWan(NULL);
        TraceLeave(ADPT, "InitializeAdapters");

        return nsStatus;
    }

    //
    // Now walk through the each of the string
    // Since the string must end with two \0's we only walk Len/2 - 1
    //

    i = 0;

    nReturnStatus = STATUS_UNSUCCESSFUL;

    RtAssert((pParam->ParameterData.StringData.Length % sizeof(WCHAR)) is 0);

    //
    // The IPConfigString is a MULTI_SZ with each SZ being the relative key
    // for an interfaces IP configuration. It is thus something like
    // TCPIP\PARAMETERS\INTERFACES\<device_name>
    // Being a MULTI_SZ it is terminated by 2 NULL characters. So we 
    // walk till the last but one character while parsing out the SZ from
    // the multi_sz
    //

    while(i < (pParam->ParameterData.StringData.Length/sizeof(WCHAR)) - 1)
    {
        USHORT          j, usConfigLen, usDevLen;
        UNICODE_STRING  usTempString, usUpcaseString, usDevString;
        GUID            Guid;

        if(pParam->ParameterData.StringData.Buffer[i] is UNICODE_NULL)
        {
            if(pParam->ParameterData.StringData.Buffer[i + 1] is UNICODE_NULL)
            {
                //
                // Two nulls - end of string
                //

                break;
            }

            //
            // only one null, just move on to the next character
            //

            i++;

            continue;
        }

        RtAssert(pParam->ParameterData.StringData.Buffer[i] isnot UNICODE_NULL);

        //
        // Now i points to the start of an SZ. Figure out the length of this
        //

        usConfigLen = 
            (USHORT)wcslen(&(pParam->ParameterData.StringData.Buffer[i]));

    
        //
        // Make usTempString point to this config. Also increase
        // the size by one so one can print this nicely
        //

        usTempString.MaximumLength  = (usConfigLen + 1) * sizeof(WCHAR);
        usTempString.Length         = (usConfigLen + 1) * sizeof(WCHAR);

        usTempString.Buffer = &(pParam->ParameterData.StringData.Buffer[i]);


        usUpcaseString.Buffer = RtAllocate(NonPagedPool,
                                           usTempString.MaximumLength,
                                           WAN_STRING_TAG);

        if(usUpcaseString.Buffer is NULL)
        {
            Trace(ADPT, ERROR,
                  ("InitializeAdapters: Unable to allocate %d bytes\n",
                   usTempString.MaximumLength));

            usUpcaseString.MaximumLength = 0;
            usUpcaseString.Length        = 0;

            i += usConfigLen;

            continue;
        }

        usUpcaseString.MaximumLength = usTempString.MaximumLength;

        RtlUpcaseUnicodeString(&usUpcaseString,
                               &usTempString,
                               FALSE);

        //
        // Set the last wchar to null
        //

        usUpcaseString.Buffer[usConfigLen] = UNICODE_NULL;

        //
        // Set the length back to what it was
        //

        usUpcaseString.Length -= sizeof(WCHAR);

        RtAssert((usUpcaseString.Length % sizeof(WCHAR)) is 0);

        //
        // The device name is the last thing in the '\' separated path.
        // So walk the SZ backwards looking for '\'
        // NOTE one could use wcsrchr, but it would be inefficient since
        // it doesnt know the end of the buffer
        //

        for(j = usUpcaseString.Length/sizeof(WCHAR) - 1; 
            j >= 0;
            j--)
        {
            if(usUpcaseString.Buffer[j] is L'\\')
            {
                break;
            }
        }

        //
        // So at this point j is the index to the last '\'
        //

        //
        // First off, make this a GUID
        //

        nStatus = ConvertStringToGuid(&(usUpcaseString.Buffer[j + 1]),
                                      wcslen(&(usUpcaseString.Buffer[j + 1])) * sizeof(WCHAR),
                                      &Guid);

        if(nStatus isnot STATUS_SUCCESS)
        {
            //
            // Hmm - not a GUID?
            //

            Trace(ADPT, ERROR,
                  ("InitializeAdapters: String %S is not a GUID\n",
                   &(usUpcaseString.Buffer[j + 1])));

            //
            // Free the upcase string and move to the next SZ in IPConfig
            //

            RtFree(usUpcaseString.Buffer);

            usUpcaseString.Buffer        = NULL;
            usUpcaseString.MaximumLength = 0;
            usUpcaseString.Length        = 0;

            i += usConfigLen;

            continue;
        }

        //
        // Make sure this binding is not present
        //

        if(IsBindingPresent(&Guid))
        {
            Trace(ADPT, WARN,
                  ("InitializeAdapters: %S already present\n",
                   &(usUpcaseString.Buffer[j + 1])));

            //
            // Free the upcase string and move to the next SZ in IPConfig
            //

            RtFree(usUpcaseString.Buffer);

            usUpcaseString.Buffer        = NULL;
            usUpcaseString.MaximumLength = 0;
            usUpcaseString.Length        = 0;

            i += usConfigLen;

            continue;
        }


        // 
        // We need to tack on a \DEVICE in front of  Guid string
        //

        usDevLen = wcslen(TCPIP_IF_PREFIX) +
                   wcslen(&(usUpcaseString.Buffer[j]));

        //
        // make sure we can fit in the space we have allocated
        //

        RtAssert(usDevLen <= WANARP_MAX_DEVICE_NAME_LEN);

        pwszDeviceBuffer[usDevLen] = UNICODE_NULL;

        usDevString.MaximumLength  = usDevLen * sizeof(WCHAR);
        usDevString.Length         = usDevLen * sizeof(WCHAR);
        usDevString.Buffer         = pwszDeviceBuffer;

        //
        // Copy over the \Device part
        //

        RtlCopyMemory(pwszDeviceBuffer,
                      TCPIP_IF_PREFIX,
                      wcslen(TCPIP_IF_PREFIX) * sizeof(WCHAR));

        //
        // Cat the \<Name> part
        //

        RtlCopyMemory(&(pwszDeviceBuffer[wcslen(TCPIP_IF_PREFIX)]),
                      &usUpcaseString.Buffer[j],
                      wcslen(&(usUpcaseString.Buffer[j])) * sizeof(WCHAR));


        //
        // Create an adapter with this name and config
        //

        pNewAdapter = NULL;

        Trace(ADPT, INFO,
              ("InitializeAdapters: Calling create adapter for %S %S\n",
               usUpcaseString.Buffer,
               usDevString.Buffer));

        nStatus = WanpCreateAdapter(&Guid,
                                    &usUpcaseString,
                                    &usDevString,
                                    &pNewAdapter);

        if(nStatus isnot STATUS_SUCCESS)
        {
            Trace(ADPT, ERROR,
                  ("InitializeAdapters: Err %x creating adapter for %S (%S)\n",
                   nStatus,
                   usUpcaseString.Buffer,
                   pwszDeviceBuffer));

        }
        else
        {
            //
            // If even one succeeds, we return success
            //

            nReturnStatus = STATUS_SUCCESS;
        }

        //
        // Done with the upcased string
        //

        RtFree(usUpcaseString.Buffer);

        usUpcaseString.Buffer        = NULL;
        usUpcaseString.MaximumLength = 0;
        usUpcaseString.Length        = 0;

        //
        // Go to the next SZ in the MULTI_SZ
        //

        i += usConfigLen;
    }

    NdisCloseConfiguration(nhConfigHandle);

    RtFree(pwszDeviceBuffer);

    NdisCompleteBindAdapter(g_nhBindContext,
                            nReturnStatus,
                            nReturnStatus);

    g_nhBindContext = NULL;

    if(nReturnStatus isnot STATUS_SUCCESS)
    {
        WanpCloseNdisWan(NULL);
    }
    else
    {
        g_lBindRcvd = 1;

        WanpReleaseResource(&g_wrBindMutex);
    }


    TraceLeave(ADPT, "InitializeAdapters");

    return nReturnStatus;
}

NTSTATUS
WanpCreateAdapter(
    IN  GUID                *pAdapterGuid,
    IN  PUNICODE_STRING     pusConfigName,
    IN  PUNICODE_STRING     pusDeviceName,
    OUT ADAPTER             **ppNewAdapter
    )

/*++

Routine Description:

    Creates and initializes an ADAPTER structure
    If this is the first adapter, it is used as the server adapter.
    For that case, it also creates and initializes the server interface.
    The server adapter is added to IP

Locks:

    Called at passive, however it acquires the adapter list lock since it
    sets g_pServerAdapter/Interface

Arguments:

    pusConfigName   Name of config key
    pusDeviceName   The device name for the adapter
    ppNewAdapter    Pointer to storage for the pointer to newly created adapter

Return Value:

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES

--*/

{
    ULONG       ulSize;
    PVOID       pvBuffer;
    PADAPTER    pAdapter;
    USHORT      i;
    NTSTATUS    nStatus;
    KIRQL       kiIrql;

    PASSIVE_ENTRY();

    TraceEnter(ADPT, "CreateAdapter");

    Trace(ADPT, TRACE,
          ("CreateAdapter: \n\t%S\n\t%S\n",
           pusConfigName->Buffer,
           pusDeviceName->Buffer));

    *ppNewAdapter = NULL;

    //
    // The size that one needs is the size of the adapter + the length of the
    // name. Add a WCHAR to get a easily printtable string. 
    // Align everything on a 4 byte boundary
    //

    ulSize = ALIGN_UP(sizeof(ADAPTER), ULONG) + 
             ALIGN_UP((pusConfigName->Length + sizeof(WCHAR)), ULONG) + 
             ALIGN_UP((pusDeviceName->Length + sizeof(WCHAR)), ULONG);
             

#if DBG

    //
    // For debug code we also store the adapter name in ANSI
    // We use 2 * sizeof(CHAR) because RtlUnicodeToAnsiString needs
    // MaximumLength + 1
    //

    ulSize += pusDeviceName->Length/sizeof(WCHAR) + (2 * sizeof(CHAR));

#endif

    pAdapter = RtAllocate(NonPagedPool,
                          ulSize,
                          WAN_ADAPTER_TAG);

    if(pAdapter is NULL)
    {
        Trace(ADPT, ERROR,
              ("CreateAdapter: Failed to allocate memory\n"));

        TraceLeave(ADPT, "CreateAdapter");

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Clear all the fields out
    //

    RtlZeroMemory(pAdapter,
                  ulSize);

    //
    // The config name buffer starts at the end of the adapter structure.
    //

    pvBuffer   = (PVOID)((ULONG_PTR)pAdapter + sizeof(ADAPTER));

    //
    // We DWORD align it for better compare/copy
    //

    pvBuffer   = ALIGN_UP_POINTER(pvBuffer, ULONG);

    pAdapter->usConfigKey.Length        = pusConfigName->Length;
    pAdapter->usConfigKey.MaximumLength = pusConfigName->Length;
    pAdapter->usConfigKey.Buffer        = (PWCHAR)pvBuffer;

    RtlCopyMemory(pAdapter->usConfigKey.Buffer,
                  pusConfigName->Buffer,
                  pusConfigName->Length);

    //
    // The device name comes after this
    //


    pvBuffer = (PVOID)((ULONG_PTR)pvBuffer   + 
                       pusConfigName->Length + 
                       sizeof(WCHAR));

    pvBuffer = ALIGN_UP_POINTER(pvBuffer, ULONG);

    pAdapter->usDeviceNameW.Length        = pusDeviceName->Length;
    pAdapter->usDeviceNameW.MaximumLength = pusDeviceName->Length;
    pAdapter->usDeviceNameW.Buffer        = (PWCHAR)pvBuffer;

    RtlCopyMemory(pAdapter->usDeviceNameW.Buffer,
                  pusDeviceName->Buffer,
                  pusDeviceName->Length);

#if DBG

    //
    // The debug string comes after the UNICODE device name buffer
    //

    pvBuffer = (PVOID)((ULONG_PTR)pvBuffer   + 
                       pusDeviceName->Length + 
                       sizeof(WCHAR));

    pvBuffer = ALIGN_UP_POINTER(pvBuffer, ULONG);

    pAdapter->asDeviceNameA.Buffer = (PCHAR)pvBuffer;

    //
    // Apparently, the unicode to ansi function wants length + 1
    //

    pAdapter->asDeviceNameA.MaximumLength = pusDeviceName->Length/sizeof(WCHAR) + 1;

    RtlUnicodeStringToAnsiString(&pAdapter->asDeviceNameA,
                                 &pAdapter->usDeviceNameW,
                                 FALSE);

#endif // DBG

    //
    // Structure copy
    //

    pAdapter->Guid = *pAdapterGuid;

    //
    // Must be set to INVALID so that GetEntityList can work
    //

    pAdapter->dwATInstance = INVALID_ENTITY_INSTANCE;
    pAdapter->dwIfInstance = INVALID_ENTITY_INSTANCE;

    //
    // Set the state
    //

    pAdapter->byState = AS_FREE;

    //
    // This hardware index is needed to generate the Unique ID that
    // DHCP uses.
    // NOTE - we dont have an index so all hardware addrs will be the same
    //

    BuildHardwareAddrFromIndex(pAdapter->rgbyHardwareAddr,
                               pAdapter->dwAdapterIndex);

    //
    // Initialize the lock for the adapter
    //

    RtInitializeSpinLock(&(pAdapter->rlLock));

    InitializeListHead(&(pAdapter->lePendingPktList));
    InitializeListHead(&(pAdapter->lePendingHdrList));
    InitializeListHead(&(pAdapter->leEventList));

    //
    // Set the Refcount to 1 because it will either lie on some list
    // or be pointed to by g_pServerAdapter
    //

    InitAdapterRefCount(pAdapter);

    if(g_pServerAdapter is NULL)
    {
        PUMODE_INTERFACE    pInterface;

        //
        // We use the first adapter adapter as the server adapter
        // We also create the server interface right here
        //

        RtAssert(g_pServerInterface is NULL);

        pInterface = RtAllocate(NonPagedPool,
                                sizeof(UMODE_INTERFACE),
                                WAN_INTERFACE_TAG);


        if(pInterface is NULL)
        {
            Trace(ADPT, ERROR,
                  ("CreateAdapter: Couldnt allocate %d bytes for server i/f\n",
                   sizeof(UMODE_INTERFACE)));

            RtFree(pAdapter);

            *ppNewAdapter = NULL;

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(pInterface,
                      sizeof(UMODE_INTERFACE));

        //
        // Get an index from IP
        // If this fails, it sets the value to INVALID_IF_INDEX
        //

        nStatus = WanpGetNewIndex(&(pInterface->dwRsvdAdapterIndex));

        if(nStatus isnot STATUS_SUCCESS)
        {
            Trace(ADPT, ERROR,
                  ("CreateAdapter: Couldnt get index for server interface\n"));

            RtFree(pAdapter);

            RtFree(pInterface);

            *ppNewAdapter = NULL;

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        Trace(ADPT, TRACE,
              ("CreateAdapter: Server Index is %d\n",
               pInterface->dwRsvdAdapterIndex));

        RtInitializeSpinLock(&(pInterface->rlLock));
        InitInterfaceRefCount(pInterface);

        pInterface->dwIfIndex    = INVALID_IF_INDEX;
        pInterface->dwAdminState = IF_ADMIN_STATUS_UP;
        pInterface->duUsage      = DU_CALLIN;

        //
        // Structure copy
        //

        pInterface->Guid = ServerInterfaceGuid;

        EnterWriter(&g_rwlAdapterLock,
                    &kiIrql);

        pAdapter->byState        = AS_FREE;
        pInterface->dwOperState  = IF_OPER_STATUS_DISCONNECTED;
        pInterface->dwLastChange = GetTimeTicks();

        //
        // We dont cross ref the structures here. That is done
        // we have added the server interface to IP.
        //

        g_pServerAdapter   = pAdapter;
        g_pServerInterface = pInterface;

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

        Trace(ADPT, INFO,
              ("CreateAdapter: %S is server adapter\n",
               pAdapter->usDeviceNameW.Buffer));

    }
    else
    {

        EnterWriter(&g_rwlAdapterLock,
                    &kiIrql);

        InsertHeadList(&g_leFreeAdapterList,
                       &(pAdapter->leAdapterLink));

        g_ulNumFreeAdapters++;

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

    }

    InterlockedIncrement(&g_ulNumAdapters);

    *ppNewAdapter = pAdapter;

    TraceLeave(ADPT, "CreateAdapter");

    return STATUS_SUCCESS;
}

#pragma alloc_text(PAGE, WanNdisUnbindAdapter)


VOID
WanNdisUnbindAdapter(
    PNDIS_STATUS    pnsRetStatus,
    NDIS_HANDLE     nhProtocolContext,
    NDIS_HANDLE     nhUnbindContext
    )

/*++

Routine Description:

    Called by NDIS to unbind an open adapter. Since we only open one adapter
    we get this only once.

Locks:

    The function acquires the g_wrBindMutex. This is released in 
    WanpFreeBindResourcesAndReleaseLock

Arguments:

    pnsRetStatus
    nhProtocolContext
    nhUnbindContext

Return Value:

    NDIS_STATUS_PENDING

--*/

{
    NDIS_STATUS nsStatus;

    TraceEnter(ADPT,"NdisUnbindAdapter");

    PAGED_CODE();

    RtAssert(nhProtocolContext is (NDIS_HANDLE)0x0CABB1E5);

    //
    // Get into the critical section
    //

    WanpAcquireResource(&g_wrBindMutex);


    //
    // Mark all the adapters as down so that we dont process anything
    // from IP on them
    //

    //
    // Close the adapter if we havent already done so. 
    // This will stop us getting stuff from NDISWAN
    //

    if(g_nhNdiswanBinding isnot NULL)
    {
        g_nhUnbindContext = nhUnbindContext;
        WanpCloseNdisWan(NULL);
   
        //
        // If we call CloseNdisWan then we DONT release the resource here. 
        // It is released by CloseAdapterComplete
        //
 
        *pnsRetStatus = NDIS_STATUS_PENDING;
    }
    else
    {
        WanpReleaseResource(&g_wrBindMutex);

        *pnsRetStatus = NDIS_STATUS_SUCCESS;
    }

    TraceLeave(ADPT, "NdisUnbindAdapter");

}

VOID
WanpCloseNdisWan(
    PVOID           pvContext
    )

/*++

Routine Description:

    This function cleans all the resources of an open adapter

Locks:

    The function is called with the g_wrBindMutex held.

Arguments:

    None

Return Value:

    None

--*/

{
    NDIS_STATUS nsStatus;

    TraceEnter(ADPT, "WanpCloseNdisWan");

    RtAssert(g_nhNdiswanBinding isnot NULL);

    RtAssert(g_wrBindMutex.lWaitCount >= 1);

    NdisCloseAdapter(&nsStatus,
                     g_nhNdiswanBinding);

    g_nhNdiswanBinding = NULL;

    //
    // If our completion routine will not be called, do it here
    //

    if(nsStatus isnot NDIS_STATUS_PENDING)
    {
        WanNdisCloseAdapterComplete((NDIS_HANDLE)0x0CABB1E5,
                                    nsStatus);
    }

    //
    // We DONT release the resource here. It is released by 
    // CloseAdapterComplete
    //

    TraceLeave(ADPT, "WanpCloseNdisWan");
    
    return;
}


#pragma alloc_text(PAGE, WanNdisCloseAdapterComplete)

VOID
WanNdisCloseAdapterComplete(
    NDIS_HANDLE nhBindHandle,
    NDIS_STATUS nsStatus
    )

/*++

Routine Description:

    Called by NDIS when it is done closing the NDISWAN adapter
    The close adapter can be done either because we failed somewhere (after
    successfully opening our adapter) and in the process of cleanup are 
    closing our adapter (in which case the unbind context will be null) or 
    because we got an unbind and were cleaning up all adapter related stuff

Locks:

    Called the g_wrBindMutex held. 
    The resource was acquired either in the Unbind handler or was acquired
    before the failure code was called

Arguments:

    nhBindHandle
    nsStatus

Return Value:

    None

--*/

{
    KIRQL       kiIrql;
    NDIS_HANDLE nhUnbind;
    NDIS_HANDLE nhBind;
    NDIS_STATUS tnsStatus, tnsError;

    TraceEnter(ADPT, "NdisCloseAdapterComplete");

    PAGED_CODE();

    nhUnbind = g_nhUnbindContext;
    nhBind = g_nhBindContext;
    tnsStatus = g_nsStatus;
    tnsError = g_nsError;

    RtAssert(g_wrBindMutex.lWaitCount >= 1);

    g_nhUnbindContext = NULL;
    g_nhBindContext = NULL;

    WanpFreeBindResourcesAndReleaseLock();

    if(nhBind isnot NULL)
    {
        RtAssert(nhUnbind == NULL);
        
        //
        // Tell NDIS that the bind is done but it failed
        //
        NdisCompleteBindAdapter(nhBind,
                                tnsStatus,
                                tnsError);
    }

    //
    // If this is being triggered from an unbind..
    //
    if(nhUnbind isnot NULL)
    {
        RtAssert(nhBind == NULL);                
        NdisCompleteUnbindAdapter(nhUnbind,
                                  NDIS_STATUS_SUCCESS);
    }

}

VOID
WanpFreeBindResourcesAndReleaseLock(
    VOID
    )
{
    RtAssert(g_wrBindMutex.lWaitCount >= 1);

    RtFree(g_usNdiswanBindName.Buffer);

    g_usNdiswanBindName.Buffer = NULL;

    RtFree(g_nsSystemSpecific1.Buffer);

    g_nsSystemSpecific1.Buffer = NULL;

    WanpRemoveAllAdapters();

    //
    // There could be turds in the connection table if this was not
    // a clean shutdown
    //

    WanpRemoveAllConnections();

    //
    // Done, set the global event
    //

    KeSetEvent(&g_keCloseEvent,
               0,
               FALSE);


    //
    // Finally done, set g_lBindRcvd and release the resource
    //

    g_lBindRcvd = 0;

    WanpReleaseResource(&g_wrBindMutex);

    PASSIVE_EXIT();
}


PADAPTER
WanpFindAdapterToMap(
    IN  DIAL_USAGE      duUsage,
    OUT PKIRQL          pkiIrql,
    IN  DWORD           dwAdapterIndex,
    IN  PUNICODE_STRING pusNewIfName
    )

/*++

Routine Description:

    Finds a free adapter to map to an interface.
    The adapter, if found is locked and referenced. Its state is set to
    AS_MAPPING and it is put on the mapped list.

Locks:

    Must be called at PASSIVE
    Acquires g_rwlAdapterLock as WRITER
    If it returns a mapped adapter, then the function returns at DPC and
    the original IRQL is in pkiIrql

Arguments:

    duUsage     The usage for which the adapter needs to be found
    pkiIrql
    dwAdapterIndex
    pusNewIfName

Return Value:

    Pointer to adapter if successful

--*/

{
    PADAPTER    pAdapter;
    KIRQL       kiIrql;
    PLIST_ENTRY pleNode;
    NTSTATUS    nStatus;
    KEVENT      keChangeEvent;

    WAN_EVENT_NODE TempEvent;

    //
    // Find a free adapter
    //

    EnterWriter(&g_rwlAdapterLock,
                &kiIrql);

    if(duUsage is DU_CALLIN)
    {
        if(g_pServerAdapter is NULL)
        {
            Trace(CONN, ERROR,
                  ("FindAdapterToMap: No server adapter\n"));

            ExitWriter(&g_rwlAdapterLock,
                       kiIrql);

            return NULL;
        }

        RtAssert(g_pServerInterface);

        //
        // Lock out the adapter
        //

        RtAcquireSpinLockAtDpcLevel(&(g_pServerAdapter->rlLock));

        //
        // Reference it because we are going to return it. Also we need the 
        // reference when we let go of the lock if we need to wait
        //

        ReferenceAdapter(g_pServerAdapter);

        //
        // See if the adapter has been added to IP
        // rasiphlp has to call us to map the server adapter before
        // doing a line up
        //

        if(g_pServerAdapter->byState isnot AS_MAPPED)
        {
            RtAssert(g_pServerAdapter->byState is AS_ADDING);
            
            if(g_pServerAdapter->byState is AS_ADDING)
            {
                KeInitializeEvent(&(TempEvent.keEvent),
                                  SynchronizationEvent,
                                  FALSE);

                InsertTailList(&(g_pServerAdapter->leEventList),
                               &(TempEvent.leEventLink));

                //
                // Let go of the lock and wait on the event
                //

                RtReleaseSpinLockFromDpcLevel(&(g_pServerAdapter->rlLock));

                ExitWriter(&g_rwlAdapterLock,
                           kiIrql);

                nStatus = KeWaitForSingleObject(&(TempEvent.keEvent),
                                                Executive,
                                                KernelMode,
                                                FALSE,
                                                NULL);

                RtAssert(nStatus is STATUS_SUCCESS);

                EnterWriter(&g_rwlAdapterLock,
                            &kiIrql);

                RtAcquireSpinLockAtDpcLevel(&(g_pServerAdapter->rlLock));

                RemoveEntryList(&(TempEvent.leEventLink));
            }
        }

        if(g_pServerAdapter->byState isnot AS_MAPPED)
        {
            PADAPTER    pTempAdapter;

            //
            // Couldnt add the adapter because of some reason, 
            //
     
            pTempAdapter = g_pServerAdapter;
 
            Trace(CONN, ERROR,
                  ("FindAdapterToMap: Unable to get mapped server adapter\n"));

            RtReleaseSpinLockFromDpcLevel(&(g_pServerAdapter->rlLock));

            ExitWriter(&g_rwlAdapterLock,
                       kiIrql);

            DereferenceAdapter(pTempAdapter);

            return NULL;
        }

        RtAssert(g_pServerAdapter->byState is AS_MAPPED);

        ExitWriterFromDpcLevel(&g_rwlAdapterLock);

        *pkiIrql = kiIrql;

        return g_pServerAdapter;
    }

    //
    // Non dial in case. First try and see if there is an adapter with the
    // index we want already added to IP
    //

    pAdapter = NULL;

    for(pleNode = g_leAddedAdapterList.Flink;
        pleNode isnot &g_leAddedAdapterList;
        pleNode = pleNode->Flink)
    {
        PADAPTER    pTempAdapter;

        pTempAdapter = CONTAINING_RECORD(pleNode,
                                         ADAPTER,
                                         leAdapterLink);

        RtAssert(pTempAdapter->byState is AS_ADDED);

        if(pTempAdapter->dwAdapterIndex is dwAdapterIndex)
        {
            RemoveEntryList(&(pTempAdapter->leAdapterLink));

            g_ulNumAddedAdapters--;

            pAdapter = pTempAdapter;

            break;
        }
    }

    if(pAdapter isnot NULL)
    {
        //
        // So we found an added adapter (it has been removed from the
        // added adapter list). Add it to the mapped list
        //

        InsertTailList(&g_leMappedAdapterList,
                       &(pAdapter->leAdapterLink));

        g_ulNumMappedAdapters++;

        RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

        ExitWriterFromDpcLevel(&g_rwlAdapterLock);

        ReferenceAdapter(pAdapter);

        pAdapter->byState = AS_MAPPING;

        *pkiIrql = kiIrql;

#if DBG

        Trace(CONN, INFO,
              ("FindAdapterToMap: Found %s already added\n",
               pAdapter->asDeviceNameA.Buffer));

#endif

        return pAdapter;
    }

    //
    // Didnt find an added adapter
    // See if the adapter is on the change list. We want to wait for this
    // because IP doesnt like to have to interfaces with the same index, even
    // if one is in the process of being removed
    //

    for(pleNode = g_leChangeAdapterList.Flink;
        pleNode isnot &g_leChangeAdapterList;
        pleNode = pleNode->Flink)
    {
        PADAPTER    pTempAdapter;

        pTempAdapter = CONTAINING_RECORD(pleNode,
                                         ADAPTER,
                                         leAdapterLink);

        if(pTempAdapter->dwAdapterIndex is dwAdapterIndex)
        {
            //
            // Wait for the change to complete
            //

            KeInitializeEvent(&(TempEvent.keEvent),
                              SynchronizationEvent,
                              FALSE);

            RtAcquireSpinLockAtDpcLevel(&(pTempAdapter->rlLock));

            InsertTailList(&(pTempAdapter->leEventList),
                           &(TempEvent.leEventLink));

            //
            // Reference the adapter, let go of the lock and wait on the event
            //

            ReferenceAdapter(pTempAdapter);

            RtReleaseSpinLockFromDpcLevel(&(pTempAdapter->rlLock));

            ExitWriter(&g_rwlAdapterLock,
                       kiIrql);

            nStatus = KeWaitForSingleObject(&(TempEvent.keEvent),
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            NULL);

            RtAssert(nStatus is STATUS_SUCCESS);

            EnterWriter(&g_rwlAdapterLock,
                        &kiIrql);

            RtAcquireSpinLockAtDpcLevel(&(pTempAdapter->rlLock));

            RemoveEntryList(&(TempEvent.leEventLink));

            RtReleaseSpinLockFromDpcLevel(&(pTempAdapter->rlLock));

            DereferenceAdapter(pTempAdapter);

            break;
        }
    }

    if(!IsListEmpty(&g_leFreeAdapterList))
    {
        pleNode = RemoveHeadList(&g_leFreeAdapterList);

        pAdapter = CONTAINING_RECORD(pleNode,
                                     ADAPTER,
                                     leAdapterLink);

        g_ulNumFreeAdapters--;

#if DBG

        Trace(CONN, INFO,
              ("FindAdapterToMap: Found free adapter %s\n",
               pAdapter->asDeviceNameA.Buffer));

#endif // DBG

    }
    else
    {
        //
        // Couldnt find an adapter. That is bad
        // TODO - if the added adapter list is not empty, we could call
        // RemoveSomeAddedAdapter... at this point
        //

        Trace(ADPT, ERROR,
              ("FindAdapterToMap: Couldnt find free adapter\n"));

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

        return NULL;
    }

    //
    // Lock and refcount the adapter.
    //

    RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

    ReferenceAdapter(pAdapter);

    //
    // The adapter better not be mapped
    //

    RtAssert(pAdapter->pInterface is NULL);
    RtAssert(pAdapter->byState is AS_FREE);

    //
    // Set the state to ADDING
    //

    pAdapter->byState = AS_ADDING;

    //
    // Since we are changing the state, no one else should be also
    // changing the state
    //

    RtAssert(pAdapter->pkeChangeEvent is NULL);

    KeInitializeEvent(&keChangeEvent,
                      SynchronizationEvent,
                      FALSE);

    pAdapter->pkeChangeEvent = &keChangeEvent;

    //
    // Insert into the change list
    //

    InsertTailList(&g_leChangeAdapterList,
                   &(pAdapter->leAdapterLink));


    RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));

    ExitWriter(&g_rwlAdapterLock,
               kiIrql);

    //
    // Add the adapter to IP
    //

    nStatus = WanpAddAdapterToIp(pAdapter,
                                 FALSE,
                                 dwAdapterIndex,
                                 pusNewIfName,
                                 IF_TYPE_PPP,
                                 IF_ACCESS_POINTTOPOINT,
                                 IF_CONNECTION_DEMAND);

    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(ADPT, ERROR,
              ("FindAdapterToMap: %x adding %x to IP\n",
               nStatus, pAdapter));

        EnterWriter(&g_rwlAdapterLock,
                    &kiIrql);

        RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

#if DBG

        RtAssert(IsEntryOnList(&g_leChangeAdapterList,
                               &(pAdapter->leAdapterLink)));

#endif

        pAdapter->pkeChangeEvent = NULL;

        RemoveEntryList(&(pAdapter->leAdapterLink));

        pAdapter->byState = AS_FREE;

        InsertTailList(&g_leFreeAdapterList,
                       &(pAdapter->leAdapterLink));

        g_ulNumFreeAdapters++;

        //
        // If anyone is waiting on a state change, notify them
        //

        for(pleNode = pAdapter->leEventList.Flink;
            pleNode isnot &(pAdapter->leEventList);
            pleNode = pleNode->Flink)
        {
            PWAN_EVENT_NODE pTempEvent;

            pTempEvent = CONTAINING_RECORD(pleNode,
                                           WAN_EVENT_NODE,
                                           leEventLink);

            KeSetEvent(&(pTempEvent->keEvent),
                       0,
                       FALSE);
        }

        RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

        DereferenceAdapter(pAdapter);

        return NULL;
    }

    //
    // Wait till the OpenAdapter is called
    //

    nStatus = KeWaitForSingleObject(&keChangeEvent,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL);

    RtAssert(nStatus is STATUS_SUCCESS);

    Trace(ADPT, TRACE,
          ("FindAdapterToMap: IPAddInterface succeeded for adapter %w\n",
           pAdapter->usDeviceNameW.Buffer));

    //
    // Lock the adapter, insert into the added list
    //

    EnterWriter(&g_rwlAdapterLock,
                &kiIrql);

    RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

#if DBG

    RtAssert(IsEntryOnList(&g_leChangeAdapterList,
                           &(pAdapter->leAdapterLink)));

#endif

    RemoveEntryList(&(pAdapter->leAdapterLink));

    pAdapter->pkeChangeEvent = NULL;

    InsertHeadList(&g_leMappedAdapterList,
                   &(pAdapter->leAdapterLink));

    g_ulNumMappedAdapters++;

    //
    // If anyone is waiting on a state change, notify them
    //

    for(pleNode = pAdapter->leEventList.Flink;
        pleNode isnot &(pAdapter->leEventList);
        pleNode = pleNode->Flink)
    {
        PWAN_EVENT_NODE pTempEvent;

        pTempEvent = CONTAINING_RECORD(pleNode,
                                       WAN_EVENT_NODE,
                                       leEventLink);

        KeSetEvent(&(pTempEvent->keEvent),
                   0,
                   FALSE);
    }

    ExitWriterFromDpcLevel(&g_rwlAdapterLock);

    *pkiIrql = kiIrql;

    return pAdapter;
}


NTSTATUS
WanpAddAdapterToIp(
    IN  PADAPTER        pAdapter,
    IN  BOOLEAN         bServerAdapter,
    IN  DWORD           dwAdapterIndex, OPTIONAL
    IN  PUNICODE_STRING pusNewIfName, OPTIONAL
    IN  DWORD           dwMediaType,
    IN  BYTE            byAccessType,
    IN  BYTE            byConnectionType
    )

/*++

Routine Description:

    This routine adds the interface to IP

Locks:

    MUST BE CALLED AT PASSIVE, but acquires a spinlock so cant be paged out

Arguments:

    pAdapter        The adapter to add
    bServerAdapter  Set to TRUE if this is a server adapter
    dwAdapterIndex  
    pusNewIfName

Return Value:

    STATUS_SUCCESS

--*/

{
    LLIPBindInfo    BindInfo;
    IP_STATUS       IPStatus;
    UNICODE_STRING  usName;
    NTSTATUS        nStatus;
    KIRQL           kiIrql;

    PASSIVE_ENTRY();

    TraceEnter(ADPT, "AddAdapterToIp");

    RtlZeroMemory(&BindInfo, sizeof(LLIPBindInfo));

    BindInfo.lip_context    = pAdapter;
    BindInfo.lip_mss        = WANARP_DEFAULT_MTU;
    BindInfo.lip_speed      = WANARP_DEFAULT_SPEED;
    BindInfo.lip_txspace    = sizeof(ETH_HEADER);

    BindInfo.lip_transmit   = WanIpTransmit;
    BindInfo.lip_transfer   = WanIpTransferData;
    BindInfo.lip_returnPkt  = WanIpReturnPacket;
    BindInfo.lip_close      = WanIpCloseAdapter;
    BindInfo.lip_addaddr    = WanIpAddAddress;
    BindInfo.lip_deladdr    = WanIpDeleteAddress;
    BindInfo.lip_invalidate = WanIpInvalidateRce;
    BindInfo.lip_open       = WanIpOpenAdapter;
    BindInfo.lip_qinfo      = WanIpQueryInfo;
    BindInfo.lip_setinfo    = WanIpSetInfo;
    BindInfo.lip_getelist   = WanIpGetEntityList;
    BindInfo.lip_flags      = LIP_COPY_FLAG;

    if(bServerAdapter)
    {
        BindInfo.lip_flags |= (LIP_P2MP_FLAG | LIP_NOLINKBCST_FLAG);

        BindInfo.lip_closelink = WanIpCloseLink;
    }
    else
    {
        BindInfo.lip_flags |= (LIP_P2P_FLAG | LIP_NOIPADDR_FLAG);
    }

    BindInfo.lip_addrlen    = ARP_802_ADDR_LENGTH;
    BindInfo.lip_addr       = pAdapter->rgbyHardwareAddr;

    BindInfo.lip_OffloadFlags   = 0;
    BindInfo.lip_dowakeupptrn   = NULL;
    BindInfo.lip_pnpcomplete    = NULL;
    BindInfo.lip_arpflushate    = NULL;
    BindInfo.lip_arpflushallate = NULL;

    BindInfo.lip_setndisrequest = WanIpSetRequest;

    RtlInitUnicodeString(&usName,
                         pAdapter->usConfigKey.Buffer);

#if DBG

    //
    // Only set while adding or deleting the interface, which is serialized
    //

    pAdapter->dwRequestedIndex = dwAdapterIndex;

#endif

    IPStatus = g_pfnIpAddInterface(&(pAdapter->usDeviceNameW),
                                   pusNewIfName,
                                   &(pAdapter->usConfigKey),
                                   NULL,
                                   pAdapter,
                                   WanIpDynamicRegister,
                                   &BindInfo,
                                   dwAdapterIndex,
                                   dwMediaType,
                                   byAccessType,
                                   byConnectionType);
    

    if(IPStatus isnot IP_SUCCESS)
    {
        Trace(ADPT, ERROR,
              ("AddAdapterToIp: IPAddInterface failed for adapter %w\n",
               pAdapter->usDeviceNameW.Buffer));

        TraceLeave(ADPT, "AddAdapterToIp");

        return STATUS_UNSUCCESSFUL;
    }

    TraceLeave(ADPT, "AddAdapterToIp");

    return STATUS_SUCCESS;
}

VOID
WanIpOpenAdapter(
    IN  PVOID pvContext
    )

/*++

Routine Description:

    Called by IP when the adapter from its IPAddInterface() call

Locks:


Arguments:

    pvContext   Pointer to the ADAPTER structure

Return Value:

    None

--*/

{
    PADAPTER    pAdapter;
    KIRQL       kiIrql;
    PLIST_ENTRY pleNode;

    TraceEnter(ADPT, "WanOpenAdapter");

    pAdapter = (PADAPTER)pvContext;

    RtAcquireSpinLock(&(pAdapter->rlLock),
                      &kiIrql);

    //
    // Set the state to added
    //

    pAdapter->byState = AS_ADDED;

    //
    // One reference for the fact that we added the adapter to IP
    //

    ReferenceAdapter(pAdapter);

    //
    // Wake up the thread that caused this
    //

    RtAssert(pAdapter->pkeChangeEvent);

    KeSetEvent(pAdapter->pkeChangeEvent,
               0,
               FALSE);


    RtReleaseSpinLock(&(pAdapter->rlLock),
                      kiIrql);

    TraceLeave(ADPT, "WanOpenAdapter");
}

VOID
WanpUnmapAdapter(
    PADAPTER    pAdapter
    )

/*++

Routine Description:

    This function moves an adapter from the mapped list and puts it on
    the free list

Locks:

    Called with no locks held, but not necessarily at PASSIVE.
    The adapter and adapter list locks are acquired

Arguments:

    pAdapter

Return Value:

    None

--*/

{
    KIRQL   kiIrql;

    EnterWriter(&g_rwlAdapterLock,
                &kiIrql);

#if DBG

    //
    // Make sure the adapter is on the mapped list
    //

    RtAssert(IsEntryOnList(&g_leMappedAdapterList,
                           &(pAdapter->leAdapterLink)));

#endif


    RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

    RemoveEntryList(&(pAdapter->leAdapterLink));

    g_ulNumMappedAdapters--;

    InsertHeadList(&g_leAddedAdapterList,
                   &(pAdapter->leAdapterLink));

    g_ulNumAddedAdapters++;

    pAdapter->byState    = AS_ADDED;
    pAdapter->pInterface = NULL;

    RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));

    //
    // Queue a work item if there is none queued, and we are not
    // shutting down
    //

    RtAcquireSpinLockAtDpcLevel(&g_rlStateLock);

    if((g_bRemovalInProgress isnot TRUE) and
       (g_dwDriverState is DRIVER_STARTED))
    {
        g_bRemovalInProgress = TRUE;

        ExInitializeWorkItem(&g_wqiWorkItem,
                             WanpRemoveSomeAddedAdaptersFromIp,
                             (PVOID)FALSE);

        ExQueueWorkItem(&g_wqiWorkItem,
                        DelayedWorkQueue);
    }

    RtReleaseSpinLockFromDpcLevel(&g_rlStateLock);

    ExitWriter(&g_rwlAdapterLock,
               kiIrql);

    return;
}


VOID
WanpRemoveSomeAddedAdaptersFromIp(
    PVOID   pvContext
    )

/*++

Routine Description:

    We queue this function to a work item to delete adapter(s) from IP when
    the connection is torn down. Unlike the next function, this
    (i) only removes added (but unmapped) adapters and
    (ii) removes the adapters one at a time.
    This allows another connection to move an adapter from the added list
    to the free list while we are deleting another adapter from IP

Locks:

    Must be called at passive
    Acquires the adapter list lock as WRITER and the lock for each adapter
    
Arguments:

    pvContext

Return Value:

    None

--*/

{
    PADAPTER    pAdapter;
    KIRQL       kiIrql;
    PLIST_ENTRY pleNode;
    NTSTATUS    nStatus;
    KEVENT      keChangeEvent;

    PASSIVE_ENTRY();

    UNREFERENCED_PARAMETER(pvContext);
    
    KeInitializeEvent(&keChangeEvent,
                      SynchronizationEvent,
                      FALSE);
    
    EnterWriter(&g_rwlAdapterLock,
                &kiIrql);

    while(!IsListEmpty(&g_leAddedAdapterList))
    {
        pleNode = RemoveHeadList(&g_leAddedAdapterList);
       
        g_ulNumAddedAdapters--;
 
        pAdapter = CONTAINING_RECORD(pleNode,
                                     ADAPTER,
                                     leAdapterLink);

        RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

        pAdapter->byState = AS_REMOVING;

        //
        // Since we are changing the state, no one else should be also
        // changing the state
        //

        RtAssert(pAdapter->pkeChangeEvent is NULL);

        pAdapter->pkeChangeEvent = &keChangeEvent;

        //
        // Insert it into the change list
        //

        InsertHeadList(&g_leChangeAdapterList,
                       &(pAdapter->leAdapterLink));

        RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

        //
        // Delete from IP but dont clear the index
        //

        g_pfnIpDeleteInterface(pAdapter->pvIpContext,
                               FALSE);

        //
        // Wait till the CloseAdapter completes
        //

        nStatus = KeWaitForSingleObject(&keChangeEvent,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

        RtAssert(nStatus is STATUS_SUCCESS);

        Trace(ADPT, INFO,
              ("RemoveSomeAddedAdaptersFromIp: Removed %S from Ip\n",
               pAdapter->usDeviceNameW.Buffer));

        //
        // Remove from the change list and put on the free list
        //

        EnterWriter(&g_rwlAdapterLock,
                    &kiIrql);

        RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

#if DBG

        RtAssert(IsEntryOnList(&g_leChangeAdapterList,
                               &(pAdapter->leAdapterLink)));

#endif

        RemoveEntryList(&(pAdapter->leAdapterLink));

        pAdapter->byState  = AS_FREE;

        pAdapter->pkeChangeEvent = NULL;

        InsertHeadList(&g_leFreeAdapterList,
                       &(pAdapter->leAdapterLink));

        g_ulNumFreeAdapters++;

        //
        // If anyone is waiting on a state change, notify them
        //

        for(pleNode = pAdapter->leEventList.Flink;
            pleNode isnot &(pAdapter->leEventList);
            pleNode = pleNode->Flink)
        {
            PWAN_EVENT_NODE pTempEvent;

            pTempEvent = CONTAINING_RECORD(pleNode,
                                           WAN_EVENT_NODE,
                                           leEventLink);

            KeSetEvent(&(pTempEvent->keEvent),
                       0,
                       FALSE);
        }

        RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));

    }

    //
    // We are done with the APC
    //

    g_bRemovalInProgress = FALSE;

    ExitWriter(&g_rwlAdapterLock,
               kiIrql);

    return;
}

VOID
WanpRemoveAllAdaptersFromIp(
    VOID
    )

/*++

Routine Description:

    This is a cleanup function called to remove all adapters (added and
    mapped) from IP. 

Locks:

    Acquired the g_rwlAdapterLock as WRITER
    Also acquire each adapter's lock when changing state

Arguments:

    None

Return Value:

    None

--*/

{
    PADAPTER    pAdapter;
    KIRQL       kiIrql;
    LIST_ENTRY  leTempHead, *pleNode;
    NTSTATUS    nStatus;
    KEVENT      keChangeEvent;

    WAN_EVENT_NODE  TempEvent;

    PASSIVE_ENTRY();
    
    KeInitializeEvent(&keChangeEvent,
                      SynchronizationEvent,
                      FALSE);

    KeInitializeEvent(&(TempEvent.keEvent),
                      SynchronizationEvent,
                      FALSE);

    InitializeListHead(&leTempHead);

    EnterWriter(&g_rwlAdapterLock,
                &kiIrql);

    //
    // First wait on any adapter in the change list to get out
    // of the change state. Once that is done it is either added to ip
    // or not, and we can deal with those two cases.  This is to handle
    // the case where we get an unbind in the middle of a status indication
    //

    while(!IsListEmpty(&g_leChangeAdapterList))
    {
        pleNode  = g_leChangeAdapterList.Flink;

        pAdapter = CONTAINING_RECORD(pleNode,
                                     ADAPTER,
                                     leAdapterLink);

        RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

        InsertTailList(&(pAdapter->leEventList),
                       &(TempEvent.leEventLink));

        ReferenceAdapter(pAdapter);

        RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

        nStatus = KeWaitForSingleObject(&(TempEvent.keEvent),
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

        RtAssert(nStatus is STATUS_SUCCESS);

        EnterWriter(&g_rwlAdapterLock,
                    &kiIrql);

#if DBG

        RtAssert(!IsEntryOnList(&g_leChangeAdapterList,
                                &(pAdapter->leAdapterLink)));

#endif

        RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

        RemoveEntryList(&(TempEvent.leEventLink));

        DereferenceAdapter(pAdapter);

        RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));
    }

    //
    // Set the state of all the adapters to removing...
    //

    while(!IsListEmpty(&g_leMappedAdapterList))
    {
        pleNode  = RemoveHeadList(&g_leMappedAdapterList);

        g_ulNumMappedAdapters--;

        pAdapter = CONTAINING_RECORD(pleNode,
                                     ADAPTER,
                                     leAdapterLink);
        
        RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));
        
        pAdapter->byState  = AS_REMOVING;

        InsertHeadList(&leTempHead,
                       pleNode);

        RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));
    }
    
    RtAssert(IsListEmpty(&g_leMappedAdapterList));

    while(!IsListEmpty(&g_leAddedAdapterList))
    {
        pleNode = RemoveHeadList(&g_leAddedAdapterList);

        g_ulNumAddedAdapters--;

        pAdapter = CONTAINING_RECORD(pleNode,
                                     ADAPTER,
                                     leAdapterLink);

        RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

        pAdapter->byState  = AS_REMOVING;

        InsertHeadList(&leTempHead,
                       pleNode);

        RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));

    }

    RtAssert(IsListEmpty(&g_leAddedAdapterList));

    ExitWriter(&g_rwlAdapterLock,
               kiIrql);

    //
    // No go through the list of adapters to remove from IP
    //

    while(!IsListEmpty(&leTempHead))
    {
        pleNode = RemoveHeadList(&leTempHead);

        pAdapter = CONTAINING_RECORD(pleNode,
                                     ADAPTER,
                                     leAdapterLink);


        EnterWriter(&g_rwlAdapterLock,
                    &kiIrql);

        RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

        //
        // Since we are changing the state, no one else should be also
        // changing the state
        //

        RtAssert(pAdapter->pkeChangeEvent is NULL);

        pAdapter->pkeChangeEvent = &keChangeEvent;

        //
        // Insert it into the change list
        //

        InsertHeadList(&g_leChangeAdapterList,
                       &(pAdapter->leAdapterLink));

        RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);
        
        //
        // Delete from IP but dont clear the index
        //

        g_pfnIpDeleteInterface(pAdapter->pvIpContext,
                               FALSE);

        //
        // Wait till the CloseAdapter completes
        //

        nStatus = KeWaitForSingleObject(&keChangeEvent,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

        RtAssert(nStatus is STATUS_SUCCESS);

        Trace(ADPT, INFO,
              ("RemoveAllAdaptersFromIp: Removed %S from Ip\n",
               pAdapter->usDeviceNameW.Buffer));

        //
        // Remove from the change list and put on the free list
        //

        EnterWriter(&g_rwlAdapterLock,
                    &kiIrql);

#if DBG

        RtAssert(IsEntryOnList(&g_leChangeAdapterList,
                               &(pAdapter->leAdapterLink)));

#endif

        RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

        RemoveEntryList(&(pAdapter->leAdapterLink));

        pAdapter->byState  = AS_FREE;

        pAdapter->pkeChangeEvent = NULL;

        InsertHeadList(&g_leFreeAdapterList,
                       &(pAdapter->leAdapterLink));

        g_ulNumFreeAdapters++;

        //
        // If anyone is waiting on a state change, notify them
        //

        for(pleNode = pAdapter->leEventList.Flink;
            pleNode isnot &(pAdapter->leEventList);
            pleNode = pleNode->Flink)
        {
            PWAN_EVENT_NODE pTempEvent;

            pTempEvent = CONTAINING_RECORD(pleNode,
                                           WAN_EVENT_NODE,
                                           leEventLink);

            KeSetEvent(&(pTempEvent->keEvent),
                       0,
                       FALSE);
        }

        RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

    }

    //
    // The write is atomic so we dont need to
    // acquire a lock
    //

    g_bRemovalInProgress = FALSE;

    return;
}



VOID
WanIpCloseAdapter(
    IN  PVOID pvContext
    )

/*++

Routine Description:

    Called by IP when it wants to close an adapter. Currently this is done
    from CloseNets() and IPDelInterface().

Locks:

    Acquires the adapter lock

Arguments:

    pvContext   Pointer to the ADAPTER

Return Value:

    None

--*/

{
    PADAPTER    pAdapter;
    KIRQL       kiIrql;
    PLIST_ENTRY pleNode;

    TraceEnter(ADPT, "IpCloseAdapter");

    pAdapter = (PADAPTER)pvContext;

    RtAcquireSpinLock(&(pAdapter->rlLock),
                      &kiIrql);

    pAdapter->pvIpContext = NULL;

    //
    // Wake up the thread that caused this
    //

    RtAssert(pAdapter->pkeChangeEvent);

    KeSetEvent(pAdapter->pkeChangeEvent,
               0,
               FALSE);

    RtReleaseSpinLock(&(pAdapter->rlLock),
                      kiIrql);

    DereferenceAdapter(pAdapter);

    TraceLeave(ADPT, "IpCloseAdapter");
}

VOID
WanpRemoveAllAdapters(
    VOID
    )

/*++

Routine Description:



Locks:



Arguments:



Return Value:


--*/

{
    LIST_ENTRY  leTempHead, *pleNode;
    KIRQL       kiIrql;
    NTSTATUS    nStatus;

    TraceEnter(ADPT, "RemoveAllAdapters");

    //
    // We can have mapped adapters.
    //

    //RtAssert(IsListEmpty(&g_leMappedAdapterList));

    //
    // Just call RemoveAllAdaptersFromIp()
    //

    WanpRemoveAllAdaptersFromIp();

    //
    // At this point the movement from one list to another is frozen
    // because we dont accept LinkUp's from Ndiswan
    //

    RtAssert(IsListEmpty(&g_leAddedAdapterList));
    //RtAssert(IsListEmpty(&g_leMappedAdapterList));
    //RtAssert(IsListEmpty(&g_leChangeAdapterList));

    EnterWriter(&g_rwlAdapterLock,
                &kiIrql);

    //
    // First clean out the free adapters
    //

    while(!IsListEmpty(&g_leFreeAdapterList))
    {
        PADAPTER    pAdapterTmp;

        pleNode = RemoveHeadList(&g_leFreeAdapterList);

        g_ulNumFreeAdapters--;

        pAdapterTmp = CONTAINING_RECORD(pleNode,
                                     ADAPTER,
                                     leAdapterLink);

        RtAcquireSpinLockAtDpcLevel(&(pAdapterTmp->rlLock));

        RtAssert(pAdapterTmp->byState is AS_FREE);

        pAdapterTmp->byState  = 0xFF;

        RtReleaseSpinLockFromDpcLevel(&(pAdapterTmp->rlLock));

        DereferenceAdapter(pAdapterTmp);
    }

    //
    // At the end of this, also remove the server adapter
    //

    if(g_pServerAdapter)
    {
        PADAPTER            pAdapter;
        PUMODE_INTERFACE    pInterface;
        BOOLEAN             bCrossRefed;

        RtAcquireSpinLockAtDpcLevel(&(g_pServerAdapter->rlLock));
        RtAcquireSpinLockAtDpcLevel(&(g_pServerInterface->rlLock));

        pAdapter   = g_pServerAdapter;
        pInterface = g_pServerInterface;

        if(g_pServerAdapter->byState is AS_MAPPED)
        {
            RtAssert(g_pServerAdapter->pInterface is g_pServerInterface);
            RtAssert(g_pServerInterface->pAdapter is g_pServerAdapter);

            bCrossRefed = TRUE;

        }
        else
        {
            RtAssert(g_pServerAdapter->pInterface is NULL);
            RtAssert(g_pServerInterface->pAdapter is NULL);

            RtAssert(g_pServerAdapter->byState is AS_FREE);

            bCrossRefed = FALSE;
        }

        //
        // Remove the global pointers
        //

        g_pServerInterface = NULL;
        g_pServerAdapter   = NULL;

        //
        // Remove the mapping from interface
        //

        pInterface->pAdapter = NULL;
        pAdapter->pInterface = NULL;
        pAdapter->byState    = AS_REMOVING;

        RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));

        if(bCrossRefed)
        {
            //
            // Deref because the cross mapping is removed
            //

            DereferenceAdapter(pAdapter);
            DereferenceInterface(pInterface);
        }

        if(pAdapter->pvIpContext)
        {
            KEVENT  keChangeEvent;

            KeInitializeEvent(&keChangeEvent,
                              SynchronizationEvent,
                              FALSE);

            //
            // Since we are changing the state, no one else should be also
            // changing the state
            //

            RtAssert(pAdapter->pkeChangeEvent is NULL);

            pAdapter->pkeChangeEvent = &keChangeEvent;

            RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));

            ExitWriter(&g_rwlAdapterLock,
                       kiIrql);

            //
            // Delete from IP, but dont clear the index
            //

            g_pfnIpDeleteInterface(pAdapter->pvIpContext,
                                   FALSE);

            nStatus = KeWaitForSingleObject(&keChangeEvent,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            NULL);


            RtAssert(nStatus is STATUS_SUCCESS);

            Trace(ADPT, INFO,
                  ("RemoveAllAdapters: Removed %S (server adapter) from Ip\n",
                   pAdapter->usDeviceNameW.Buffer));

            EnterWriter(&g_rwlAdapterLock,
                        &kiIrql);

            RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

            pAdapter->byState  = AS_FREE;

            pAdapter->pkeChangeEvent = NULL;

            //
            // If anyone is waiting on a state change, notify them
            //

            for(pleNode = pAdapter->leEventList.Flink;
                pleNode isnot &(pAdapter->leEventList);
                pleNode = pleNode->Flink)
            {
                PWAN_EVENT_NODE pTempEvent;

                pTempEvent = CONTAINING_RECORD(pleNode,
                                               WAN_EVENT_NODE,
                                               leEventLink);

                KeSetEvent(&(pTempEvent->keEvent),
                           0,
                           FALSE);
            }

            RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));
        } else {

            RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));
        }

        //
        // Deref because the global pointers are null
        //

        DereferenceAdapter(pAdapter);
        DereferenceInterface(pInterface);
    }

    ExitWriter(&g_rwlAdapterLock,
               kiIrql);

    TraceLeave(ADPT, "RemoveAllAdapters");
}


INT
WanIpDynamicRegister(
    IN  PNDIS_STRING            InterfaceName,
    IN  PVOID                   pvIpInterfaceContext,
    IN  struct _IP_HANDLERS *   IpHandlers,
    IN  struct LLIPBindInfo *   ARPBindInfo,
    IN  UINT                    uiInterfaceNumber
    )
{
    PADAPTER    pAdapter;
    KIRQL       irql;


    TraceEnter(ADPT, "IpDynamicRegister");


    pAdapter = (PADAPTER)(ARPBindInfo->lip_context);

    RtAcquireSpinLock(&(pAdapter->rlLock),
                      &irql);

#if DBG

    Trace(ADPT, INFO,
          ("IpDynamicRegister: IP called out to dynamically register %s\n",
           pAdapter->asDeviceNameA.Buffer));

#endif

    pAdapter->pvIpContext       = pvIpInterfaceContext;
    pAdapter->dwAdapterIndex    = uiInterfaceNumber;

#if DBG

    RtAssert(pAdapter->dwAdapterIndex is pAdapter->dwRequestedIndex);

#endif

    if(g_pfnIpRcv is NULL)
    {
        g_pfnIpRcv          = IpHandlers->IpRcvHandler;
        g_pfnIpRcvComplete  = IpHandlers->IpRcvCompleteHandler;
        g_pfnIpSendComplete = IpHandlers->IpTxCompleteHandler;
        g_pfnIpTDComplete   = IpHandlers->IpTransferCompleteHandler;
        g_pfnIpStatus       = IpHandlers->IpStatusHandler;
        g_pfnIpRcvPkt       = IpHandlers->IpRcvPktHandler;
        g_pfnIpPnp          = IpHandlers->IpPnPHandler;
    }

    RtReleaseSpinLock(&(pAdapter->rlLock),
                      irql);

    TraceLeave(ADPT, "IpDynamicRegister");

    return TRUE;
}


NDIS_STATUS
WanpDoNdisRequest(
    IN  NDIS_REQUEST_TYPE                       RequestType,
    IN  NDIS_OID                                Oid,
    IN  PVOID                                   pvInfo,
    IN  UINT                                    uiInBufferLen,
    IN  PWANARP_NDIS_REQUEST_CONTEXT            pRequestContext,
    IN  PFNWANARP_REQUEST_COMPLETION_HANDLER    pfnCompletionHandler OPTIONAL
    )

/*++

Routine Description:

    Wrapper for the NdisRequest call. We create a request context and submit
    the call to NDIS. If it returns synchronously, we fake asynchronous
    behaviour by call the completion routine.

Locks:

    None. The ndiswan binding must be valid for the duration of the call

Arguments:

    RequestType             Type of NDIS request
    Oid                     Ndis OID to set or get
    pvInfo                  Opaque OID specific info
    pRequestContext         A context for this request
    pfnCompletionHandler    Completion handler for this request

Return Value:

    STATUS_INVALID_PARAMETER
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_PENDING

    other error

--*/

{
    PNDIS_REQUEST                   pRequest;
    NDIS_STATUS                     nsStatus;

    if((RequestType isnot NdisRequestSetInformation) and
       (RequestType isnot NdisRequestQueryInformation))
    {
        return STATUS_INVALID_PARAMETER;
    }


    pRequestContext->pfnCompletionRoutine = pfnCompletionHandler;

    pRequest = &(pRequestContext->NdisRequest);

    pRequest->RequestType = RequestType;

    if(RequestType is NdisRequestSetInformation)
    {
        pRequest->DATA.SET_INFORMATION.Oid                     = Oid;
        pRequest->DATA.SET_INFORMATION.InformationBuffer       = pvInfo;
        pRequest->DATA.SET_INFORMATION.InformationBufferLength = uiInBufferLen;
    }
    else
    {
        pRequest->DATA.QUERY_INFORMATION.Oid                     = Oid;
        pRequest->DATA.QUERY_INFORMATION.InformationBuffer       = pvInfo;
        pRequest->DATA.QUERY_INFORMATION.InformationBufferLength = uiInBufferLen;
    }

    //
    // Submit the request.
    //

    NdisRequest(&nsStatus,
                g_nhNdiswanBinding,
                pRequest);


    if(nsStatus isnot NDIS_STATUS_PENDING)
    {
        //
        // If it finished synchronously, call the handler
        //

        if(pfnCompletionHandler)
        {
            (pfnCompletionHandler)(g_nhNdiswanBinding,
                                   pRequestContext,
                                   nsStatus);
        }


        if(nsStatus is NDIS_STATUS_SUCCESS)
        {
            //
            // Always make this look asynchronous
            //

            nsStatus = NDIS_STATUS_PENDING;
        }
    }

    return nsStatus;
}

VOID
WanNdisRequestComplete(
    IN  NDIS_HANDLE     nhHandle,
    IN  PNDIS_REQUEST   pRequest,
    IN  NDIS_STATUS     nsStatus
    )

/*++

Routine Description:

    Handler called by NDIS when it is done processing our request

Locks:

    None

Arguments:

    nhHandle    NdisHandle of the adapter to which the request was submitted
    pRequest    The original request
    nsStatus    The status returned by the adapter

Return Value:

    None

--*/

{
    PWANARP_NDIS_REQUEST_CONTEXT    pRequestContext;

    //
    // Get a pointer to the context
    //

    pRequestContext = CONTAINING_RECORD(pRequest,
                                        WANARP_NDIS_REQUEST_CONTEXT,
                                        NdisRequest);

    if(pRequestContext->pfnCompletionRoutine is NULL)
    {
        //
        // No more handlers to call, we are done
        //

        RtFree(pRequestContext);

        return;
    }

    //
    // If the request is OID_GEN_TRANSPORT_HEADER_OFFSET, ignore the error
    //

    RtAssert(pRequest is &(pRequestContext->NdisRequest));

    if((pRequest->RequestType is NdisRequestSetInformation) and
       (pRequest->DATA.SET_INFORMATION.Oid is OID_GEN_TRANSPORT_HEADER_OFFSET))
    {
        nsStatus = NDIS_STATUS_SUCCESS;
    }

    //
    // Call the request complete handler
    //

    (pRequestContext->pfnCompletionRoutine)(nhHandle,
                                            pRequestContext,
                                            nsStatus);

}

PUMODE_INTERFACE
WanpFindInterfaceGivenIndex(
    DWORD   dwIfIndex
    )
{
    PLIST_ENTRY         pleNode;
    PUMODE_INTERFACE    pIf;

    for(pleNode = g_leIfList.Flink;
        pleNode isnot &g_leIfList;
        pleNode = pleNode->Flink)
    {
        pIf = CONTAINING_RECORD(pleNode,
                                UMODE_INTERFACE,
                                leIfLink);

        if(pIf->dwIfIndex is dwIfIndex)
        {
            RtAcquireSpinLockAtDpcLevel(&(pIf->rlLock));

            ReferenceInterface(pIf);

            return pIf;
        }
    }

    return NULL;
}

VOID
WanpDeleteAdapter(
    IN PADAPTER pAdapter
    )
{

#if DBG

    Trace(ADPT, TRACE,
          ("DeleteAdapter: Deleting %x %s\n",
           pAdapter, pAdapter->asDeviceNameA.Buffer));

#else

    Trace(ADPT, TRACE,
          ("DeleteAdapter: Deleting %x\n",
           pAdapter));

#endif

    InterlockedDecrement(&g_ulNumAdapters);

    RtFree(pAdapter);
}

NDIS_STATUS
WanNdisIpPnPEventHandler(
    IN  PNET_PNP_EVENT  pNetPnPEvent
    )

{
    PWANARP_RECONFIGURE_INFO pInfo;
    NTSTATUS nStatus = NDIS_STATUS_FAILURE;

    RtAssert(pNetPnPEvent->NetEvent is NetEventReconfigure);

    pInfo = (PWANARP_RECONFIGURE_INFO) pNetPnPEvent->Buffer;

    switch (pInfo->wrcOperation)
    {
        case WRC_TCP_WINDOW_SIZE_UPDATE:
        {
            PLIST_ENTRY         pleNode;
            KIRQL               kirql;
            PADAPTER           pAdapter=NULL;

            RtAssert(pInfo->ulNumInterfaces is 1);

            if(pInfo->ulNumInterfaces isnot 1)
            {
                break;
            }

            EnterReader(&g_rwlAdapterLock, &kirql);

            for(pleNode  = g_leMappedAdapterList.Flink;
                pleNode != &g_leMappedAdapterList;
                pleNode  = pleNode->Flink)
            {
                pAdapter = CONTAINING_RECORD(pleNode, ADAPTER, leAdapterLink);

                if(IsEqualGUID(&(pAdapter->Guid),
                               &pInfo->rgInterfaces[0]))
                {
                    break;
                }
            }

            if ((pleNode is &g_leMappedAdapterList) || pAdapter==NULL)
            {
                ExitReader(&g_rwlAdapterLock, kirql);
                break;
            }
            
            if(     (pAdapter->byState is AS_MAPPED)
                && (pAdapter->pInterface)
                && (pAdapter->pInterface->duUsage is DU_CALLOUT))
            {
                NET_PNP_EVENT pnpEvent;
                IP_PNP_RECONFIG_REQUEST Request;

                RtlZeroMemory(&pnpEvent, sizeof(pnpEvent));
                RtlZeroMemory(&Request, sizeof(Request));
                Request.version = IP_PNP_RECONFIG_VERSION;
                Request.Flags = IP_PNP_FLAG_INTERFACE_TCP_PARAMETER_UPDATE;
                pnpEvent.NetEvent = NetEventReconfigure;
                pnpEvent.Buffer = &Request;
                pnpEvent.BufferLength = sizeof(Request);
                ReferenceAdapter(pAdapter);
                
                ExitReader(&g_rwlAdapterLock, kirql);

                nStatus = g_pfnIpPnp(pAdapter->pvIpContext,
                                    &pnpEvent);

                DereferenceAdapter(pAdapter);                                    
            }
            else
            {
                ExitReader(&g_rwlAdapterLock, kirql);
            }
            
            break;
        }

        default:
        {
            RtAssert(FALSE);
            nStatus = NDIS_STATUS_NOT_RECOGNIZED;
            break;
        }
    }

    return nStatus;
}

//
// Misc ndis interface functions
//

NDIS_STATUS
WanNdisPnPEvent(
    IN  NDIS_HANDLE     nhProtocolBindingContext,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    )
{
    ULONG       ulNumGuids, i;
    NTSTATUS    nStatus, nRetStatus;

    PWANARP_RECONFIGURE_INFO    pInfo;

    TraceEnter(ADPT, "NdisPnPEvent");

    if(nhProtocolBindingContext isnot (NDIS_HANDLE)0x0CABB1E5)
    {
        return NDIS_STATUS_NOT_RECOGNIZED;
    }

    if(pNetPnPEvent->NetEvent isnot NetEventReconfigure)
    {
        return NDIS_STATUS_SUCCESS;
    }

    pInfo = (PWANARP_RECONFIGURE_INFO)(pNetPnPEvent->Buffer);

    if(pNetPnPEvent->BufferLength < FIELD_OFFSET(WANARP_RECONFIGURE_INFO, rgInterfaces))
    {
        return NDIS_STATUS_BUFFER_TOO_SHORT;
    }

    pInfo = (PWANARP_RECONFIGURE_INFO)(pNetPnPEvent->Buffer);

    if(pInfo->wrcOperation isnot WRC_ADD_INTERFACES)
    {
        nStatus = WanNdisIpPnPEventHandler(pNetPnPEvent);
        return nStatus;
    }

    //
    // Make sure the length and matches with whats in the info
    //

    ulNumGuids = pNetPnPEvent->BufferLength - 
                 FIELD_OFFSET(WANARP_RECONFIGURE_INFO, rgInterfaces);

    ulNumGuids /= sizeof(GUID);

    if(ulNumGuids < pInfo->ulNumInterfaces)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Now go through each guid, and if it isnt present, add it
    // If we get a list of only duplicates, return SUCCESS (334575)
    //
  
    nRetStatus = STATUS_SUCCESS;
 
    for(i = 0; i < pInfo->ulNumInterfaces; i++)
    {
        WCHAR   rgwcDeviceBuffer[GUID_STR_LEN + 7 + 2];
        WCHAR   rgwcConfigBuffer[GUID_STR_LEN + 29 + 2];

        PADAPTER        pNewAdapter;
        UNICODE_STRING  usDevice;
        UNICODE_STRING  usConfig;

                    
        if(IsBindingPresent(&(pInfo->rgInterfaces[i])))
        {
            continue;
        }

        RtlZeroMemory(rgwcDeviceBuffer,
                      sizeof(rgwcDeviceBuffer));

        RtlZeroMemory(rgwcConfigBuffer,
                      sizeof(rgwcConfigBuffer));

        //
        // Make sure no problems with people changing the string
        //

        RtAssert(((wcslen(TCPIP_IF_PREFIX) + 1 + GUID_STR_LEN) * sizeof(WCHAR)) < sizeof(rgwcDeviceBuffer));

        RtAssert(((wcslen(TCPIP_REG_PREFIX) + 1 + GUID_STR_LEN) * sizeof(WCHAR)) < sizeof(rgwcConfigBuffer));

                 
        //
        // Copy over the \Device part
        //

        RtlCopyMemory(rgwcDeviceBuffer,
                      TCPIP_IF_PREFIX,
                      wcslen(TCPIP_IF_PREFIX) * sizeof(WCHAR));

        //
        // Tack on a '\'
        //

        rgwcDeviceBuffer[wcslen(TCPIP_IF_PREFIX)] = L'\\';

        //
        // Convert the guid to a string. Just pass the buffer starting
        // after the '\' we just catted. The conversion function returns
        // an upcase string - so thats good.
        //

        ConvertGuidToString(&(pInfo->rgInterfaces[i]),
                            &(rgwcDeviceBuffer[wcslen(TCPIP_IF_PREFIX) + 1]));

        //
        // Create the config
        //

        RtlCopyMemory(rgwcConfigBuffer,
                      TCPIP_REG_PREFIX,
                      wcslen(TCPIP_REG_PREFIX) * sizeof(WCHAR));

        //
        // Put the device guid at the end
        //

        ConvertGuidToString(&(pInfo->rgInterfaces[i]),
                            &(rgwcConfigBuffer[wcslen(TCPIP_REG_PREFIX)]));

        //
        // Set up the strings
        //

        usDevice.Length         = wcslen(rgwcDeviceBuffer) * sizeof(WCHAR);
        usDevice.MaximumLength  = usDevice.Length;
        usDevice.Buffer         = rgwcDeviceBuffer;

        usConfig.Length         = wcslen(rgwcConfigBuffer) * sizeof(WCHAR);
        usConfig.MaximumLength  = usConfig.Length;
        usConfig.Buffer         = rgwcConfigBuffer;

        //
        // Create an adapter with this name and config
        //

        pNewAdapter = NULL;

        Trace(ADPT, INFO,
              ("NdisPnPEvent: Calling create adapter for %S %S\n",
               usConfig.Buffer,
               usDevice.Buffer));

        nStatus = WanpCreateAdapter(&(pInfo->rgInterfaces[i]),
                                    &usConfig,
                                    &usDevice,
                                    &pNewAdapter);

        if(nStatus isnot STATUS_SUCCESS)
        {
            Trace(ADPT, ERROR,
                  ("NdisPnPEvent: Err %x creating adapter for %S (%S)\n",
                   nStatus,
                   usConfig.Buffer,
                   usDevice.Buffer));

        }
        else
        {
            //
            // If even one succeeds, we return success
            //

            nRetStatus = STATUS_SUCCESS;
        }

    }

    return nRetStatus;
}

VOID
WanNdisResetComplete(
    NDIS_HANDLE Handle,
    NDIS_STATUS Status
    )
{
    // We dont do anything here.
}



BOOLEAN
IsBindingPresent(
    IN  GUID    *pGuid
    )

/*++

Routine Description:

    Code to catch duplicate bind notifications

Locks:

    acquires adapter list lock

Arguments:

    pGuid   Guid of the adapter

Return Value:

    NO_ERROR

--*/

{
    BOOLEAN     bFound;
    PADAPTER    pAdapter;
    PLIST_ENTRY pleNode;
    KIRQL       kiIrql;


    EnterReader(&g_rwlAdapterLock, &kiIrql);
                    
    for(pleNode  = g_leAddedAdapterList.Flink;
        pleNode != &g_leAddedAdapterList;
        pleNode  = pleNode->Flink)
    {
        pAdapter = CONTAINING_RECORD(pleNode, ADAPTER, leAdapterLink);

        if(IsEqualGUID(&(pAdapter->Guid),
                       pGuid))
        {
            ExitReader(&g_rwlAdapterLock, kiIrql);
            return TRUE;

        }
    }

    for(pleNode  = g_leMappedAdapterList.Flink;
        pleNode != &g_leMappedAdapterList;
        pleNode  = pleNode->Flink)
    {
        pAdapter = CONTAINING_RECORD(pleNode, ADAPTER, leAdapterLink);

        if(IsEqualGUID(&(pAdapter->Guid),
                       pGuid))
        {
            ExitReader(&g_rwlAdapterLock, kiIrql);
            return TRUE;

        }
    }

    for(pleNode  = g_leFreeAdapterList.Flink;
        pleNode != &g_leFreeAdapterList;
        pleNode  = pleNode->Flink)
    {
        pAdapter = CONTAINING_RECORD(pleNode, ADAPTER, leAdapterLink);

        if(IsEqualGUID(&(pAdapter->Guid),
                       pGuid))
        {
            ExitReader(&g_rwlAdapterLock, kiIrql);
            return TRUE;

        }
    }

    for(pleNode  = g_leChangeAdapterList.Flink;
        pleNode != &g_leChangeAdapterList;
        pleNode  = pleNode->Flink)
    {
        pAdapter = CONTAINING_RECORD(pleNode, ADAPTER, leAdapterLink);

        if(IsEqualGUID(&(pAdapter->Guid),
                       pGuid))
        {
            ExitReader(&g_rwlAdapterLock, kiIrql);
            return TRUE;

        }
    }

    if(g_pServerAdapter)
    {
        if(IsEqualGUID(&(g_pServerAdapter->Guid),
                       pGuid))
        {
            ExitReader(&g_rwlAdapterLock, kiIrql);
            return TRUE;
        }
    }


    ExitReader(&g_rwlAdapterLock, kiIrql);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\conn.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\wanarp\conn.h

Abstract:

    Header for conn.c

Revision History:

    AmritanR

--*/


//
// Pointer to the connection table. Protected by g_rlConnTableLock
//

PULONG_PTR   g_puipConnTable;

//
// The current size of the connection table. Protected by g_rlConnTableLock
//

ULONG       g_ulConnTableSize;

//
// Current count of various connections. Also protected by the g_rlConnTableLock
//

ULONG       g_rgulConns[DU_ROUTER + 1];

//
// Initial size of the connection table
//

#define WAN_INIT_CONN_TABLE_SIZE            16

#define WAN_CONN_TABLE_INCREMENT            32

#define WANARP_CONN_LOOKASIDE_DEPTH         16 

//
// Hint to the next free slot. Protected by g_rlConnTableLock
//

ULONG       g_ulNextConnIndex;

//
// The lock protecting all the above
//

RT_LOCK     g_rlConnTableLock;

//
// The dial in interface and adapter. The server adapter is the first
// adapter we find in the TCP/IP Parameters. The pointer is initialized
// at bind time and then is unchanged. The g_pServerInterface is protected
// by the g_rwlIfListLock
//

PUMODE_INTERFACE    g_pServerInterface;
PADAPTER            g_pServerAdapter;


#include <packon.h>

//
// To remove the contexts, we will cast the Ethernet header to the following
// structure
//

typedef struct _ENET_CONTEXT_HALF_HDR
{
    BYTE    bUnused[2];

    ULONG   ulSlot;

}ENET_CONTEXT_HALF_HDR, *PENET_CONTEXT_HALF_HDR;

#include <packoff.h>

//++
//
//  VOID
//  InsertConnIndexInAddr(
//      PBYTE   pbyAddr,
//      ULONG   ulIndex
//      )
//
//  Inserts the index into the given ethernet address field
//
//--

#define InsertConnIndexInAddr(a,i)                  \
    ((PENET_CONTEXT_HALF_HDR)(a))->ulSlot = (i)

//++
//
//  ULONG
//  GetConnIndexFromAddr(
//      PBYTE   pbyAddr
//      )
//
//  Retrieves the index from the given ethernet address field
//
//--

#define GetConnIndexFromAddr(a)                     \
    ((PENET_CONTEXT_HALF_HDR)(a))->ulSlot


//++
//
//  PCONN_ENTRY
//  GetConnEntryGivenIndex(
//      ULONG   ulIndex 
//      )
//
//  Retrieves the connection entry given the connection index
//  The connection table must be locked for this call
//  If an entry is found for the index, it is referenced and also 
//  locked (if it is a DU_CALLIN connection)
//
//--

#define GetConnEntryGivenIndex(i)                               \
    (PCONN_ENTRY)(g_puipConnTable[(i)]);                        \
    {                                                           \
        PCONN_ENTRY __pTemp;                                    \
        __pTemp = (PCONN_ENTRY)g_puipConnTable[(i)];            \
        if(__pTemp != NULL)                                     \
        {                                                       \
            ReferenceConnEntry(__pTemp);                        \
        }                                                       \
    }

//
// The lookaside list for connection entries
//

extern NPAGED_LOOKASIDE_LIST       g_llConnBlocks;

//++
//
//  PCONN_ENTRY
//  AllocateConnection(
//      VOID
//      )
//
//  Allocate a connection entry from g_llConnBlocks
//
//--

#define AllocateConnection()                        \
            ExAllocateFromNPagedLookasideList(&g_llConnBlocks)

//++
//
//  VOID
//  FreeConnection(
//      PCONN_ENTRY pEntry
//      )
//
//  Free a connection entry to g_llConnBlocks
//
//--

#define FreeConnection(n)                           \
            ExFreeToNPagedLookasideList(&g_llConnBlocks, (n))



VOID
WanNdisStatus(
    NDIS_HANDLE nhHandle,
    NDIS_STATUS nsNdisStatus,
    PVOID       pvStatusInfo,
    UINT        uiStatusInfoSize
    );

VOID
WanNdisStatusComplete(
    NDIS_HANDLE nhHandle
    );

NDIS_STATUS
WanpLinkUpIndication(
    PNDIS_WAN_LINE_UP pInfoBuffer
    );

NDIS_STATUS
WanpLinkDownIndication(
    PNDIS_WAN_LINE_DOWN buffer
    );

UINT
WanDemandDialRequest(
    ROUTE_CONTEXT   Context,
    IPAddr          dwDest,
    IPAddr          dwSource,
    BYTE            byProtocol,
    PBYTE           pbyBuffer,
    UINT            uiLength,
    IPAddr          dwHdrSrc
    );

PCONN_ENTRY
WanpCreateConnEntry(
    DIAL_USAGE      duUsage
    );

VOID
WanIpCloseLink(
    PVOID   pvAdapterContext,
    PVOID   pvLinkContext
    );

VOID
WanpDeleteConnEntry(
    PCONN_ENTRY pConnEntry
    );

VOID
WanpNotifyRouterManager(
    PPENDING_NOTIFICATION   pMsg,
    PUMODE_INTERFACE        pInterface,
    PADAPTER                pAdapter,
    PCONN_ENTRY             pConnEntry,
    BOOLEAN                 bConnected
    );

VOID
WanpFreePacketAndBuffers(
    PNDIS_PACKET    pnpPacket
    );

PCONN_ENTRY
WanpGetConnEntryGivenAddress(
    DWORD   dwAddress
    );

ULONG
WanpRemoveAllConnections(
    VOID
    );

BOOLEAN
WanpIsConnectionTableEmpty(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\debug.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debug macros for the ARP module

Revision History:


Notes:

--*/

#ifndef __RT_DEBUG_H__
#define __RT_DEBUG_H__

VOID
RtInitializeDebug();

//
// Tags for Pools
//


#define WAN_ADAPTER_TAG         'aprW'
#define WAN_INTERFACE_TAG       'iprW'
#define WAN_REQUEST_TAG         'rprW'
#define WAN_STRING_TAG          'sprW'
#define WAN_CONN_TAG            'cprW'
#define WAN_PACKET_TAG          'wPDN'
#define FREE_TAG                'fprW'
#define WAN_DATA_TAG            'dprW'
#define WAN_HEADER_TAG          'hprW'
#define WAN_NOTIFICATION_TAG    'nprW'


//
// File signatures for everyone
//

#define DEBUG_SIG       'gbed'
#define DRIVER_SIG      'rvrd'
#define BPOOL_SIG       'lopb'
#define PPOOL_SIG       'lopp'
#define ADAPTER_SIG     'tpdA'
#define IOCTL_SIG       'tcoi'
#define CONN_SIG        'nnoc'
#define INFO_SIG        'ofni'
#define RCV_SIG         'vcer'
#define SEND_SIG        'dnes'
#define GUID_SIG        'diug'


//
// We use the RT_XXX_DEBUG flags so that we can force to
// different debug modes on free builds by changing sources.
// On a checked build, all debugging is on
//

#if DBG

#ifndef RT_TRACE_DEBUG
#define RT_TRACE_DEBUG  1
#endif

#ifndef RT_LOCK_DEBUG
#define RT_LOCK_DEBUG   1
#endif

#ifndef RT_ASSERT_ON
#define RT_ASSERT_ON    1
#endif

#ifndef RT_MEM_DEBUG
#define RT_MEM_DEBUG    1
#endif

#else // DBG

#ifndef RT_TRACE_DEBUG
#define RT_TRACE_DEBUG  0
#endif

#ifndef RT_LOCK_DEBUG
#define RT_LOCK_DEBUG   0
#endif

#ifndef RT_ASSERT_ON
#define RT_ASSERT_ON    0
#endif

#ifndef RT_MEM_DEBUG
#define RT_MEM_DEBUG    0
#endif

#endif // DBG


#if RT_ASSERT_ON

#define RtAssert(X)                                             \
{                                                               \
    if(!(X))                                                    \
    {                                                           \
        DbgPrint("[WANARP] Assertion failed in %s at line %d\n",\
                 __FILE__,__LINE__);                            \
        DbgPrint("WANARP: Assertion " #X "\n");                 \
        DbgBreakPoint();                                        \
    }                                                           \
}

#else   // RT_ASSERT_ON

#define RtAssert(X)

#endif


#if RT_TRACE_DEBUG

BYTE    g_byDebugLevel;
DWORD   g_fDebugComp;


#define WANARP_STREAM_GLOBAL        0x00000001
#define WANARP_STREAM_MEMORY        0x00000002
#define WANARP_STREAM_ADPT          0x00000004
#define WANARP_STREAM_CONN          0x00000008
#define WANARP_STREAM_SEND          0x00000010
#define WANARP_STREAM_RCV           0x00000020
#define WANARP_STREAM_UTIL          0x00000040

#define RT_DBG_LEVEL_NONE           0xFF
#define RT_DBG_LEVEL_FATAL          0xF0
#define RT_DBG_LEVEL_ERROR          0xE0
#define RT_DBG_LEVEL_WARN           0xD0
#define RT_DBG_LEVEL_INFO           0xC0
#define RT_DBG_LEVEL_TRACE          0xB0

#define Trace(Stream, Level, Str)                   \
{                                                   \
    if ((RT_DBG_LEVEL_##Level >= g_byDebugLevel) &&                    \
         ((g_fDebugComp & WANARP_STREAM_##Stream) == WANARP_STREAM_##Stream))\
    {                                               \
        DbgPrint("[WANARP] ");                      \
        DbgPrint Str;                               \
    }                                               \
}

#define TraceEnter(Stream, Str) Trace(Stream, TRACE, ("Entering "Str"\n"))
#define TraceLeave(Stream, Str) Trace(Stream, TRACE, ("Leaving "Str"\n"))

#else   // RT_TRACE_DEBUG

#define Trace(Stream, Level, Str)

#define TraceEnter(Stream, Str)
#define TraceLeave(Stream, Str)

#endif // RT_TRACE_DEBUG



#if RT_LOCK_DEBUG

extern KSPIN_LOCK  g_ksLockLock;

#ifndef __FILE_SIG__
#error File signature not defined
#endif

typedef struct _RT_LOCK
{
	ULONG		ulLockSig;
	BOOLEAN     bAcquired;
	PKTHREAD    pktLastThread;
	ULONG       ulFileSig;
	ULONG		ulLineNumber;
	KSPIN_LOCK  kslLock;
}RT_LOCK, *PRT_LOCK;


VOID
RtpInitializeSpinLock(
    IN  PRT_LOCK    pLock,
    IN  ULONG       ulFileSig,
    IN  ULONG       ulLineNumber
    );

VOID
RtpAcquireSpinLock(
    IN  PRT_LOCK    pLock,
    OUT PKIRQL      pkiIrql,
    IN  ULONG       ulFileSig,
    IN  ULONG       ulLineNumber,
    IN  BOOLEAN     bAtDpc
    );

VOID
RtpReleaseSpinLock(
    IN  PRT_LOCK    pLock,
    IN  KIRQL       kiIrql,
    IN  ULONG       ulFileSig,
    IN  ULONG       ulLineNumber,
    IN  BOOLEAN     bFromDpc
    );

#define RT_LOCK_SIG	'KCOL'


#define RtInitializeSpinLock(X)        RtpInitializeSpinLock((X), __FILE_SIG__, __LINE__)

#define RtAcquireSpinLock(X, Y)        RtpAcquireSpinLock((X), (Y), __FILE_SIG__, __LINE__, FALSE)

#define RtAcquireSpinLockAtDpcLevel(X) RtpAcquireSpinLock((X), NULL, __FILE_SIG__, __LINE__, TRUE)

#define RtReleaseSpinLock(X, Y)        RtpReleaseSpinLock((X), (Y), __FILE_SIG__, __LINE__, FALSE)

#define RtReleaseSpinLockFromDpcLevel(X) RtpReleaseSpinLock((X), 0, __FILE_SIG__, __LINE__, TRUE)


#else   // RT_LOCK_DEBUG


typedef KSPIN_LOCK  RT_LOCK, *PRT_LOCK;

#define RtInitializeSpinLock          KeInitializeSpinLock
#define RtAcquireSpinLock             KeAcquireSpinLock
#define RtAcquireSpinLockAtDpcLevel   KeAcquireSpinLockAtDpcLevel
#define RtReleaseSpinLock             KeReleaseSpinLock
#define RtReleaseSpinLockFromDpcLevel KeReleaseSpinLockFromDpcLevel


#endif	// RT_LOCK_DEBUG





#if RT_MEM_DEBUG


#ifndef __FILE_SIG__
#error File signature not defined
#endif

//
// Memory Allocation/Freeing Audit:
//

//
// The RT_ALLOCATION structure stores all info about one allocation
//

typedef struct _RT_ALLOCATION
{
    LIST_ENTRY  leLink;
    ULONG       ulMemSig;
    ULONG       ulFileSig;
    ULONG       ulLineNumber;
    ULONG       ulSize;
    UCHAR		pucData[1];
}RT_ALLOCATION, *PRT_ALLOCATION;

//
// The RT_FREE structure stores info about an allocation
// that was freed. Later if the memory is touched, the
// free list can be scanned to see where the allocation was
// freed
//

typedef struct _RT_FREE
{
    LIST_ENTRY  leLink;
    UINT_PTR    pStartAddr;
    ULONG       ulSize;
    ULONG       ulMemSig;
    ULONG       ulAllocFileSig;
    ULONG       ulAllocLineNumber;
    ULONG       ulFreeFileSig;
    ULONG       ulFreeLineNumber;
}RT_FREE, *PRT_FREE;


#define RT_MEMORY_SIG     'YRMM'
#define RT_FREE_SIG       'EERF'

PVOID
RtpAllocate(
    IN POOL_TYPE    ptPool,
	IN ULONG	    ulSize,
    IN ULONG        ulTag,
	IN ULONG	    ulFileSig,
	IN ULONG	    ulLineNumber
    );

VOID
RtpFree(
	PVOID	pvPointer,
    IN ULONG	    ulFileSig,
	IN ULONG	    ulLineNumber
    );

VOID
RtAuditMemory();

#define RtAllocate(X, Y, Z)   RtpAllocate((X), (Y), (Z), __FILE_SIG__, __LINE__)
#define RtFree(X)             RtpFree((X), __FILE_SIG__, __LINE__)



#else // RT_MEM_DEBUG



#define RtAllocate    ExAllocatePoolWithTag
#define RtFree        ExFreePool

#define RtAuditMemory()



#endif // RT_MEM_DEBUG




#endif // __RT_DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\conn.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    wanarp\conn.c

Abstract:

    The file contains the code needed for connection management

Revision History:

    AmritanR

--*/


#define __FILE_SIG__    CONN_SIG

#include "inc.h"

#if DBG
DWORD g_dwSendsOnDeletedLink = 0;
#endif

VOID
WanNdisStatus(
    NDIS_HANDLE nhHandle,
    NDIS_STATUS nsNdisStatus,
    PVOID       pvStatusInfo,
    UINT        uiStatusInfoSize
    )

/*++

Routine Description:

    Status handler for NDIS. we simply pass the buffer on to our private
    handlers

Locks:

    None needed

Arguments:

    nhHandle
    nsNdisStatus
    pvStatusInfo
    uiSatusInfoSize

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER(uiStatusInfoSize);
    UNREFERENCED_PARAMETER(nhHandle);

    switch(nsNdisStatus)
    {
        case NDIS_STATUS_WAN_LINE_UP:
        {
            PNDIS_WAN_LINE_UP   pLineUp;

            pLineUp = (PNDIS_WAN_LINE_UP)pvStatusInfo;

            WanpLinkUpIndication(pLineUp);

            break;
        }

        case NDIS_STATUS_WAN_LINE_DOWN:
        {
            PNDIS_WAN_LINE_DOWN pLineDown;

            pLineDown = (PNDIS_WAN_LINE_DOWN)pvStatusInfo;

            WanpLinkDownIndication(pLineDown);

            break;
        }

        case NDIS_STATUS_WAN_FRAGMENT:
        default:
        {
            //
            // Ignore all other indications
            //

            break;
        }
    }
}


VOID
WanNdisStatusComplete(
    NDIS_HANDLE nhHandle
    )

/*++

Routine Description:

    Called after the driver is done indicating a set of status
    indications
    We dont do anything

Locks:

    None

Arguments:

    nhHandle

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER(nhHandle);

    return;
}


NDIS_STATUS
WanpLinkUpIndication(
    PNDIS_WAN_LINE_UP pInfoBuffer
    )

/*++

Routine Description:

    The routine that handles a new connection. We also get this when a
    link in a multi-linked bundle comes up or goes down.
    If this is a new connection, we allocate a CONN_ENTRY for this.
    Then, if this is a dial in connection, we lock and ref the server
    adapter and interface. If this is a router connection, we see if
    we already have a mapped adapter. If we do, we lock the adapter
    otherwise, we find a free adapter to map for the linkup.
    If this is a dial out connection, we create an interface and find a
    free adapter to map for the connection.
    We set up the needed cross mappings between the conn entry, adapter
    and interface and initialize the conn entry
    If this is a router connection, we drain all packets, and complete
    an IRP to tell router manager about it.
    For non dial in connections we indicate a Status change to IP, while
    for dial in, we add a link to IP for the client.


Locks:

    MUST be called at PASSIVE because we call IPAddInterface.
    We acquire the g_rlConnTableLock, g_rwlAdapterLock, g_rwlIfLock
    in addition to locking down the adapter and the interface

Arguments:



Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_ADAPTER_NOT_READY
    STATUS_INVALID_PARAMETER
    NDIS_STATUS_RESOURCES
    STATUS_OBJECT_NAME_NOT_FOUND
    STATUS_INVALID_DEVICE_STATE

--*/

{
    PADAPTER        pAdapter;
    PCONN_ENTRY     pConnEntry;
    ULONG           ulConnIndex;
    KIRQL           kiIrql;
    LLIPMTUChange   mtuChangeInfo;
    LLIPSpeedChange speedChangeInfo;
    IP_STATUS       isStatus;
    ULONG           ulIndex;
    UNICODE_STRING  usTempName;
    WCHAR           rgwcGuid[GUID_STR_LEN + 1];

    PUMODE_INTERFACE        pInterface;
    PIP_WAN_LINKUP_INFO     pLinkInfo;
    PPENDING_NOTIFICATION   pMsg;

    //
    // This must be at PASSIVE (because we may need to drive a
    // IPAddInterface from here)
    //

    TraceEnter(CONN, "LinkUpIndication");

    pLinkInfo = (PIP_WAN_LINKUP_INFO)pInfoBuffer->ProtocolBuffer;

    Trace(CONN, INFO,
          ("HandleLinkUpIndication: %d.%d.%d.%d/%d.%d.%d.%d - %d.%d.%d.%d\n",
           PRINT_IPADDR(pLinkInfo->dwLocalAddr),
           PRINT_IPADDR(pLinkInfo->dwLocalMask),
           PRINT_IPADDR(pLinkInfo->dwRemoteAddr)));

    if(!EnterDriverCode())
    {
        return NDIS_STATUS_ADAPTER_NOT_READY;
    }


    ulConnIndex = GetConnIndexFromAddr(pInfoBuffer->LocalAddress);

    if(ulConnIndex isnot 0)
    {
        PVOID pvLinkContext;

        //
        // This is not the first lineup for this entry
        // We should find the entry (if it is on this interface)
        // and update speed and mtu info
        //

        RtAcquireSpinLock(&g_rlConnTableLock,
                          &kiIrql);

        pConnEntry = GetConnEntryGivenIndex(ulConnIndex);

        if((pConnEntry is NULL) or
           (pConnEntry->byState isnot CS_CONNECTED))
        {
            RtAssert(FALSE);

            RtReleaseSpinLock(&g_rlConnTableLock,
                              kiIrql);
        
            ExitDriverCode();

            return NDIS_STATUS_SUCCESS;
        }

        RtAssert(pConnEntry->pAdapter);

        //
        // Lock the conn entry or the adapter
        //

        RtAcquireSpinLockAtDpcLevel(pConnEntry->prlLock);

       
        RtReleaseSpinLockFromDpcLevel(&g_rlConnTableLock);

        if(pInfoBuffer->MaximumTotalSize isnot pConnEntry->ulMtu)
        {
            pConnEntry->ulMtu     = pInfoBuffer->MaximumTotalSize;
            mtuChangeInfo.lmc_mtu = pConnEntry->ulMtu; 
        }
        else
        {
            mtuChangeInfo.lmc_mtu = 0;
        }
        
        if((pInfoBuffer->LinkSpeed * 100L) isnot pConnEntry->ulSpeed)
        {    
            pConnEntry->ulSpeed         = pInfoBuffer->LinkSpeed * 100L;
            speedChangeInfo.lsc_speed   = pConnEntry->ulSpeed;
        }
        else
        {
            speedChangeInfo.lsc_speed   = 0;
        }

        RtReleaseSpinLock(pConnEntry->prlLock,
                          kiIrql);

        if(mtuChangeInfo.lmc_mtu isnot 0)
        {
            g_pfnIpStatus(pConnEntry->pAdapter->pvIpContext,
                          LLIP_STATUS_MTU_CHANGE,
                          &mtuChangeInfo,
                          sizeof(LLIPMTUChange),
                          pConnEntry->pvIpLinkContext);
        }

        if(speedChangeInfo.lsc_speed isnot 0)
        {
            g_pfnIpStatus(pConnEntry->pAdapter->pvIpContext,
                          LLIP_STATUS_SPEED_CHANGE,
                          &speedChangeInfo,
                          sizeof(LLIPSpeedChange),
                          pConnEntry->pvIpLinkContext);
        }

        DereferenceConnEntry(pConnEntry);
    
        TraceLeave(CONN, "LinkUpIndication");

        ExitDriverCode();

        return NDIS_STATUS_SUCCESS;
    }

    PASSIVE_ENTRY();

    if((pLinkInfo->duUsage isnot DU_CALLIN) and
       (pLinkInfo->duUsage isnot DU_CALLOUT) and
       (pLinkInfo->duUsage isnot DU_ROUTER))
    {
        RtAssert(FALSE);

        Trace(CONN,ERROR,
              ("LinkUpIndication: Invalid usage %d\n", pLinkInfo->duUsage));

        TraceLeave(CONN, "LinkUpIndication");

        ExitDriverCode();

        return STATUS_INVALID_PARAMETER;
    }

    RtlZeroMemory(pInfoBuffer->LocalAddress,
                  ARP_802_ADDR_LENGTH);

    //
    // Get a connection entry for this connection
    // This function finds a free slot in the connection table and puts
    // the conn entry into the slot. It sets the ulSlot field in the
    // conn entry to be the index of the slot
    //

    RtAcquireSpinLock(&g_rlConnTableLock,
                      &kiIrql);

    pConnEntry = WanpCreateConnEntry(pLinkInfo->duUsage);

    if(pConnEntry is NULL)
    {
        RtReleaseSpinLock(&g_rlConnTableLock,
                          kiIrql);

        Trace(CONN,ERROR,
              ("LinkUpIndication: Couldnt allocate conn entry\n"));

        TraceLeave(CONN, "LinkUpIndication");

        ExitDriverCode();

        return NDIS_STATUS_RESOURCES;
    }

    RtReleaseSpinLock(&g_rlConnTableLock,
                      kiIrql);

    //
    // Create a GUID from a name
    //

    usTempName.MaximumLength = (GUID_STR_LEN + 1) * sizeof(WCHAR);
    usTempName.Length        = GUID_STR_LEN * sizeof(WCHAR);
    usTempName.Buffer        = rgwcGuid;

    ConvertGuidToString((GUID *)(pInfoBuffer->DeviceName.Buffer),
                        rgwcGuid);

    rgwcGuid[GUID_STR_LEN] = UNICODE_NULL;

    pAdapter = NULL;

    //
    // Do this usage specific thing. At the end of this switch statement
    // we have a locked and referenced Adapter and Interface for the
    // connection
    //

    switch(pLinkInfo->duUsage)
    {
        case DU_CALLIN:
        {
            //
            // Just get the server adapter and interface
            //

            Trace(CONN, INFO,
                  ("LinkUpIndication: Linkup Usage is CALLIN\n"));

            //
            // Just use 0 as adapter index, since it is not really needed
            // for the CALLIN case
            //

            pAdapter = WanpFindAdapterToMap(DU_CALLIN,
                                            &kiIrql,
                                            0,
                                            NULL);

            if(pAdapter is NULL)
            {
                WanpDeleteConnEntry(pConnEntry);

                ExitDriverCode();

                return NDIS_STATUS_RESOURCES;
            }

            RtAssert(pAdapter is g_pServerAdapter);

            //
            // clients lock the connection entry
            //

            RtInitializeSpinLock(&(pConnEntry->rlLock));

            pConnEntry->prlLock = &(pConnEntry->rlLock);


            RtAssert(pAdapter->pInterface is g_pServerInterface);
            RtAssert(pAdapter->byState is AS_MAPPED);

            //
            // Lock the server interface. We have to have a server interface.
            //

            pInterface = g_pServerInterface;

            //
            // Lock and reference the interface
            //

            RtAcquireSpinLockAtDpcLevel(&(pInterface->rlLock));

            ReferenceInterface(pInterface);

            break;
        }

        case DU_CALLOUT:
        {
            Trace(CONN, INFO,
                  ("LinkUpIndication: Linkup Usage is CALLOUT\n"));

            //
            // Allocate a notification for informing the router manager
            // of this connection
            //

            pMsg = AllocateNotification();

            if(pMsg is NULL)
            {
                Trace(CONN, ERROR,
                      ("LinkUpIndication: Couldnt allocate msg\n"));

                TraceLeave(CONN, "LinkUpIndication");

                WanpDeleteConnEntry(pConnEntry);

                ExitDriverCode();

                return NDIS_STATUS_RESOURCES;
            }

            //
            // For dial out, we dynamically create an interface
            //

            pInterface = RtAllocate(NonPagedPool,
                                    sizeof(UMODE_INTERFACE),
                                    WAN_INTERFACE_TAG);

            if(pInterface is NULL)
            {
                Trace(CONN, ERROR,
                      ("LinkUpIndication: Couldnt allocate I/f\n"));

                TraceLeave(CONN, "LinkUpIndication");

                WanpDeleteConnEntry(pConnEntry);

                FreeNotification(pMsg);

                ExitDriverCode();

                return NDIS_STATUS_RESOURCES;
            }

            RtlZeroMemory(pInterface,
                          sizeof(UMODE_INTERFACE));

            //
            // Get a new index from IP for this
            // This sets the value to INVALID_IF_INDEX if it fails
            //

            isStatus = WanpGetNewIndex(&(pInterface->dwRsvdAdapterIndex));

            if(isStatus isnot STATUS_SUCCESS)
            {
                RtFree(pInterface);

                Trace(CONN, ERROR,
                      ("LinkUpIndication: Couldnt get index for I/f\n"));

                TraceLeave(CONN, "LinkUpIndication");

                WanpDeleteConnEntry(pConnEntry);

                FreeNotification(pMsg);

                ExitDriverCode();

                return NDIS_STATUS_RESOURCES;
            }

            Trace(CONN, INFO,
                  ("LinkUpIndication: DialOut name is %S %d\n",
                   rgwcGuid, pInterface->dwRsvdAdapterIndex));

            //
            // Find an adapter
            //

            pAdapter = WanpFindAdapterToMap(DU_CALLOUT,
                                            &kiIrql,
                                            pInterface->dwRsvdAdapterIndex,
                                            &usTempName);

            if(pAdapter is NULL)
            {
                WanpFreeIndex(pInterface->dwRsvdAdapterIndex);

                RtFree(pInterface);

                WanpDeleteConnEntry(pConnEntry);

                FreeNotification(pMsg);

                ExitDriverCode();

                return NDIS_STATUS_RESOURCES;
            }

            //
            // Initialize the interface block
            //

            RtInitializeSpinLock(&(pInterface->rlLock));

            //
            // Structure copy
            //

            pInterface->Guid  = *((GUID *)(pInfoBuffer->DeviceName.Buffer));

            pInterface->dwAdminState    = IF_ADMIN_STATUS_UP;
            pInterface->dwOperState     = IF_OPER_STATUS_CONNECTING;
            pInterface->dwLastChange    = GetTimeTicks();
            pInterface->dwIfIndex       = INVALID_IF_INDEX;
        
            pInterface->duUsage         = DU_CALLOUT;

            InitInterfaceRefCount(pInterface);

            //
            // Reference and lock the interface because the code after
            // the switch statement expects pInterface to be locked and
            // ref'ed
            //

            ReferenceInterface(pInterface);

            RtAcquireSpinLockAtDpcLevel(&(pInterface->rlLock));

            EnterWriterAtDpcLevel(&g_rwlIfLock);

            InsertHeadList(&g_leIfList,
                           &(pInterface->leIfLink));

            //
            // No need to insert this in the quick lookup table since
            // this interface is never accessed by the index
            //

            InterlockedIncrement(&g_ulNumDialOutInterfaces);

            ExitWriterFromDpcLevel(&g_rwlIfLock);

            //
            // Initialize the message
            //

            pMsg->wnMsg.ddeEvent        = DDE_CALLOUT_LINKUP;
            pMsg->wnMsg.dwUserIfIndex   = INVALID_IF_INDEX;
            pMsg->wnMsg.dwAdapterIndex  = pInterface->dwRsvdAdapterIndex;
            pMsg->wnMsg.dwLocalMask     = pLinkInfo->dwLocalMask;
            pMsg->wnMsg.dwLocalAddr     = pLinkInfo->dwLocalAddr;
            pMsg->wnMsg.dwRemoteAddr    = pLinkInfo->dwRemoteAddr;
            pMsg->wnMsg.fDefaultRoute   = pLinkInfo->fDefaultRoute;

            RtAssert(pInfoBuffer->DeviceName.Length <= WANARP_MAX_DEVICE_NAME_LEN);
            RtAssert((pInfoBuffer->DeviceName.Length % sizeof(WCHAR)) is 0)

            RtlCopyMemory(pMsg->wnMsg.rgwcName,
                          usTempName.Buffer,
                          usTempName.Length);

            pMsg->wnMsg.rgwcName[usTempName.Length/sizeof(WCHAR)] = UNICODE_NULL;

            break;
        }

        case DU_ROUTER:
        {
            pMsg = AllocateNotification();

            if(pMsg is NULL)
            {
                Trace(CONN, ERROR,
                      ("LinkUpIndication: Couldnt allocate msg\n"));

                TraceLeave(CONN, "LinkUpIndication");

                WanpDeleteConnEntry(pConnEntry);

                ExitDriverCode();

                return NDIS_STATUS_RESOURCES;
            }

            //
            // Get the interface
            //

            EnterReader(&g_rwlIfLock,
                        &kiIrql);

            pInterface = WanpFindInterfaceGivenIndex(
                            pLinkInfo->dwUserIfIndex
                            );

            if(pInterface is NULL)
            {
                ExitReader(&g_rwlIfLock,
                           kiIrql);

                Trace(CONN, ERROR,
                      ("LinkUpIndication: No interface %d\n",
                       pLinkInfo->dwUserIfIndex));

                WanpDeleteConnEntry(pConnEntry);

                FreeNotification(pMsg);

                TraceLeave(CONN, "LinkUpIndication");

                ExitDriverCode();

                return STATUS_OBJECT_NAME_NOT_FOUND;
            }

            ExitReaderFromDpcLevel(&g_rwlIfLock);

            if((pInterface->dwOperState isnot IF_OPER_STATUS_CONNECTING) and
               (pInterface->dwOperState isnot IF_OPER_STATUS_DISCONNECTED))
            {
                Trace(CONN, ERROR,
                      ("LinkUpIndication: Interface %p is in state %d\n",
                       pInterface,
                       pInterface->dwOperState));

                RtReleaseSpinLock(&(pInterface->rlLock),
                                  kiIrql);

                WanpDeleteConnEntry(pConnEntry);

                FreeNotification(pMsg);

                TraceLeave(CONN, "LinkUpIndication");

                ExitDriverCode();

                return STATUS_INVALID_DEVICE_STATE;
            }

            pInterface->Guid  = *((GUID *)(pInfoBuffer->DeviceName.Buffer));

            Trace(CONN, TRACE,
                  ("LinkUpIndication: For interface %p\n",
                   pInterface));

            //
            // See if the interface is mapped to an adapter. This happens
            // if this connection is being brought up due to a DODCallout
            //

            pAdapter = pInterface->pAdapter;

            if(pAdapter isnot NULL)
            {
                //
                // We have an adapter and we need to lock it. However
                // we cant lock it till we unlock the interface
                // So we let go of the interface lock, but dont deref
                //

                RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));

                //
                // Acquire the adapter lock
                //

                RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

                //
                // This adapter better be mapped to the above interface
                // because the only way to unmap an adapter is to delete it
                // or to get a LinkDown or a ConnFailure. All these cases are
                // mutually exclusive with LinkUp
                //

                RtAssert(pAdapter->pInterface is pInterface);
                RtAssert(pAdapter->byState is AS_MAPPED);

                ReferenceAdapter(pAdapter);

                //
                // Go back and lock the interface
                //

                RtAcquireSpinLockAtDpcLevel(&(pInterface->rlLock));

                RtAssert(pInterface->dwOperState is IF_OPER_STATUS_CONNECTING);
            }
            else
            {
                //
                // So we dont have an adapter...
                // This function MUST be called at PASSIVE
                //

                RtReleaseSpinLock(&(pInterface->rlLock),
                                  kiIrql);

                pAdapter = WanpFindAdapterToMap(DU_ROUTER,
                                                &kiIrql,
                                                pInterface->dwRsvdAdapterIndex,
                                                &usTempName);

                if(pAdapter is NULL)
                {
                    DereferenceInterface(pInterface);

                    WanpDeleteConnEntry(pConnEntry);

                    FreeNotification(pMsg);

                    ExitDriverCode();

                    return NDIS_STATUS_RESOURCES;
                }

                //
                // Got the adapter, lock the interface. We are at
                // DPC since the adapter is locked
                //

                RtAcquireSpinLockAtDpcLevel(&(pInterface->rlLock));
            }

            //
            // Interface and adapter refcounted and locked
            //

            pMsg->wnMsg.ddeEvent        = DDE_INTERFACE_CONNECTED;
            pMsg->wnMsg.dwUserIfIndex   = pInterface->dwIfIndex;
            pMsg->wnMsg.dwAdapterIndex  = pInterface->dwRsvdAdapterIndex;
            pMsg->wnMsg.dwLocalMask     = pLinkInfo->dwLocalMask;
            pMsg->wnMsg.dwLocalAddr     = pLinkInfo->dwLocalAddr;
            pMsg->wnMsg.dwRemoteAddr    = pLinkInfo->dwRemoteAddr;
            pMsg->wnMsg.fDefaultRoute   = pLinkInfo->fDefaultRoute;

            break;
        }

        default:
        {
            RtAssert(FALSE);

            WanpDeleteConnEntry(pConnEntry);

            ExitDriverCode();

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // At this point we have a locked and refcounted adapter
    // The adapter has been moved to the MAPPED adapter list
    // We also have a locked and recfounted interface
    // pConnEntry points to a CONN_ENTRY which is in the table but
    // is neither locked nor refcounted
    //

    Trace(CONN, INFO,
          ("LinkUpIndication: Found adapter %x to map to i/f %x %d\n",
           pAdapter, pInterface, pInterface->dwIfIndex));

#if DBG

    Trace(CONN, INFO,
          ("LinkUpIndication: Adapter Name is %s\n",
           pAdapter->asDeviceNameA.Buffer));
#endif


    if(pLinkInfo->duUsage isnot DU_CALLIN)
    {
        //
        // Set the cross mappings between the interface and the adapter
        //

        pAdapter->pInterface = pInterface;
        pInterface->pAdapter = pAdapter;

        pAdapter->byState       = AS_MAPPED;
        pInterface->dwOperState = IF_OPER_STATUS_CONNECTED;
        pInterface->dwLastChange= GetTimeTicks();

        //
        // Put a refcount on both the adapter and the interface
        // because the mapping stored pointers to them
        //

        ReferenceAdapter(pAdapter);
        ReferenceInterface(pInterface);

        //
        // Set the lock in the conn entry
        //

        pConnEntry->prlLock  = &(pAdapter->rlLock);

        //
        // Non Client adapters store a pointer to the connection entry
        // However we dont ref the conn entry for that
        //

        pAdapter->pConnEntry = pConnEntry;

    }
    else
    {
        //
        // For callin, the mappings are already set up
        //

        RtAssert(pAdapter->pInterface is pInterface);
        RtAssert(pInterface->pAdapter is pAdapter);
        RtAssert(pInterface->dwOperState is IF_OPER_STATUS_CONNECTED);
    }

    RtlZeroMemory(pInfoBuffer->DeviceName.Buffer,
                  pInfoBuffer->DeviceName.MaximumLength);

    //
    // Copy the adapter(device) name into the buffer.
    //

    RtAssert(pAdapter->usDeviceNameW.Length <= pInfoBuffer->DeviceName.MaximumLength);

    pInfoBuffer->DeviceName.Length = pAdapter->usDeviceNameW.Length;

    RtlCopyMemory(pInfoBuffer->DeviceName.Buffer,
                  pAdapter->usDeviceNameW.Buffer,
                  pAdapter->usDeviceNameW.Length);

    //
    // Copy out the connection index for this connection into NDISWAN's
    // LocalAddress - this will then be put in the DestAddr field by
    // NDISWAN in all the receive indications, and in the linkdown
    //

    InsertConnIndexInAddr(pInfoBuffer->LocalAddress,
                          pConnEntry->ulSlotIndex);


    //
    // Set up the connection entry
    //

    pConnEntry->dwLocalMask         = pLinkInfo->dwLocalMask;
    pConnEntry->dwLocalAddr         = pLinkInfo->dwLocalAddr;
    pConnEntry->dwRemoteAddr        = pLinkInfo->dwRemoteAddr;
    pConnEntry->ulMtu               = pInfoBuffer->MaximumTotalSize;
    pConnEntry->ulSpeed             = pInfoBuffer->LinkSpeed * 100L;
    pConnEntry->bFilterNetBios      = (pLinkInfo->fFilterNetBios == 1);
    pConnEntry->byState             = CS_CONNECTED;
    RtAssert(pConnEntry->duUsage is pLinkInfo->duUsage);
    pConnEntry->pvIpLinkContext     = NULL;

    //
    // Map the entry to the adapter
    // Because of the stored pointer, refcount the adapter
    //

    pConnEntry->pAdapter = pAdapter;

    ReferenceAdapter(pAdapter);

    //
    // Initialize the prebuilt ethernet header
    // First zero out the source address in the ethernet header
    //

    RtlZeroMemory(pConnEntry->ehHeader.rgbySourceAddr,
                  ARP_802_ADDR_LENGTH);

    //
    // Put our context in the right place in the ethernet source
    // address
    //

    InsertConnIndexInAddr(pConnEntry->ehHeader.rgbySourceAddr,
                          pConnEntry->ulSlotIndex);

    //
    // Refcount the connentry because it lies in the connection table,
    // NDISWAN has a "pointer" to it and because pAdapter->pConnEntry
    // may have a pointer to it.
    // NOTE: since we keep only one ref for all these conditions, all the
    // pointer must be cleared in the same function with the connection
    // locked
    //

    ReferenceConnEntry(pConnEntry);

    pConnEntry->ehHeader.wType  = RtlUshortByteSwap(ARP_ETYPE_IP);

    //
    // A send is from WANARP -> NDISWAN so put the NDISWAN context in
    // the DEST address of our prebuilt ethernet header
    //

    RtlCopyMemory(pConnEntry->ehHeader.rgbyDestAddr,
                  pInfoBuffer->RemoteAddress,
                  ARP_802_ADDR_LENGTH);

    //
    // For a router connection, tell router manager about it
    //

    if(pLinkInfo->duUsage is DU_ROUTER)
    {
        //
        // If there are packets queued to the interface, drain them now
        //

        WanpTransmitQueuedPackets(pAdapter,
                                  pInterface,
                                  pConnEntry,
                                  kiIrql);

        //
        // Let Router Manager know of a new connection
        //

        WanpCompleteIrp(pMsg);
    }
    else
    {

        //
        // Done with the interfaces. We can unlock them now
        // Router interfaces are unlocked in WanpSendPackets which
        // is called from WanpTransmitQueuedPackets
        //

        RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));
        RtReleaseSpinLock(&(pAdapter->rlLock),
                          kiIrql);
    
        if(pLinkInfo->duUsage is DU_CALLOUT)
        {
            //
            // Complete the IRP to the router manager (or queue if no IRPs
            // are pending)
            //

            WanpCompleteIrp(pMsg);
        }
    }


    //
    // Need to make this call without holding locks.
    // We can let go of the locks since we wont get any NDIS layer
    // calls for this connection till this function completes and
    // the IP and IOCTL interface functions can be handled with no
    // consistency problems
    //

    if(pLinkInfo->duUsage isnot DU_CALLIN)
    {

        //
        // Notify upper layer of mtu change
        //

        mtuChangeInfo.lmc_mtu       = pConnEntry->ulMtu;
        speedChangeInfo.lsc_speed   = pConnEntry->ulSpeed;


        g_pfnIpStatus(pAdapter->pvIpContext,
                      LLIP_STATUS_MTU_CHANGE,
                      &mtuChangeInfo,
                      sizeof(LLIPMTUChange),
                      NULL);

        g_pfnIpStatus(pConnEntry->pAdapter->pvIpContext,
                      LLIP_STATUS_SPEED_CHANGE,
                      &speedChangeInfo,
                      sizeof(LLIPSpeedChange),
                      pConnEntry->pvIpLinkContext);
    }
    else
    {
        isStatus = g_pfnIpAddLink(pAdapter->pvIpContext,
                                  pConnEntry->dwRemoteAddr,
                                  pConnEntry,
                                  &(pConnEntry->pvIpLinkContext),
                                  pConnEntry->ulMtu);

        if(isStatus isnot IP_SUCCESS)
        {
            Trace(CONN, ERROR,
                  ("LinkUpIndication: IpAddLink returned %x\n",
                   isStatus));

            RtlZeroMemory(pInfoBuffer->DeviceName.Buffer,
                          pInfoBuffer->DeviceName.MaximumLength);

            pInfoBuffer->DeviceName.Length = 0;

            RtlZeroMemory(pInfoBuffer->LocalAddress,
                          ARP_802_ADDR_LENGTH);

            //
            // Just deref the connection entry
            // This will clear up everything
            //

            DereferenceConnEntry(pConnEntry);
        }
        else
        {
            //
            // Reference it once for the fact that we now have this entry
            // with IP
            //

            ReferenceConnEntry(pConnEntry);
        }
    }

    //
    // Done with the interface and adapter. Dereference them now because
    // the Find..() functions put a reference on them
    //


    DereferenceAdapter(pAdapter);
    DereferenceInterface(pInterface);

    ExitDriverCode();

    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
WanpLinkDownIndication(
    PNDIS_WAN_LINE_DOWN pInfoBuffer
    )

/*++

Routine Description:



Locks:



Arguments:



Return Value:


--*/

{
    PADAPTER            pAdapter;
    PUMODE_INTERFACE    pInterface;
    KIRQL               kiIrql;
    PCONN_ENTRY         pConnEntry;
    ULONG               ulIndex;

    PPENDING_NOTIFICATION   pMsg;

    TraceEnter(CONN, "LinkDownIndication");

    ulIndex = GetConnIndexFromAddr(pInfoBuffer->LocalAddress);

    Trace(CONN, INFO,
          ("WanpLinkDowIndication: index %d\n", ulIndex));

    //
    // Lock out the connection entry
    //

    RtAcquireSpinLock(&g_rlConnTableLock,
                      &kiIrql);

    pConnEntry = GetConnEntryGivenIndex(ulIndex);

    if(pConnEntry is NULL)
    {
        Trace(CONN, ERROR,
              ("LinkDownIndication: No entry in slot %d\n",
               ulIndex));

        RtReleaseSpinLock(&g_rlConnTableLock,
                          kiIrql);

        return NDIS_STATUS_SUCCESS;
    }

    //
    // Lock the connection entry or adapter
    //

    RtAcquireSpinLockAtDpcLevel(pConnEntry->prlLock);

    //
    // Done with the connection table
    //

    RtReleaseSpinLockFromDpcLevel(&g_rlConnTableLock);

    //
    // Mark this connection/adapter as disconnecting
    // We can reference these field of the CONN_ENTRY since they cant
    // change during its lifetime
    //

    pAdapter = pConnEntry->pAdapter;

    RtAssert(pAdapter);
    RtAssert(pAdapter->byState is AS_MAPPED);

    pInterface = pAdapter->pInterface;
    pMsg       = NULL;

    if(pInterface->duUsage is DU_CALLIN)
    {
        IP_STATUS   isStatus;

        //
        // Client connection. This means we have the connection entry
        // locked, but the adapter is unlocked
        //

        pConnEntry->byState = CS_DISCONNECTING;

        RtReleaseSpinLock(pConnEntry->prlLock,
                          kiIrql);

        isStatus = g_pfnIpDeleteLink(g_pServerAdapter->pvIpContext,
                                     pConnEntry->pvIpLinkContext);

        if(isStatus isnot IP_SUCCESS)
        {
            Trace(CONN, ERROR,
                  ("LinkDownIndication: IpDeleteLink returned %x\n",
                   isStatus));

            //
            // This is really bad
            //

            RtAssert(FALSE);
        }
    }
    else
    {
        //
        // Here we have the adapter locked
        // The connection entry is protected by the same lock
        //

        pConnEntry->byState = CS_DISCONNECTING;

        //
        // Free the interface mapping
        //

        pAdapter->pInterface = NULL;
        pAdapter->byState    = AS_UNMAPPING;

        //
        // Lock the interface list and the interface
        // The interface has to be present since it is ref counted
        //

        EnterWriterAtDpcLevel(&g_rwlIfLock);

        RtAcquireSpinLockAtDpcLevel(&(pInterface->rlLock));

        //
        // Clear out the adapter field.
        //

        pInterface->pAdapter    = NULL;

        pInterface->dwOperState = IF_OPER_STATUS_DISCONNECTED;
        pInterface->dwLastChange= GetTimeTicks();

        pMsg = AllocateNotification();

        if(pMsg is NULL)
        {
            Trace(CONN, ERROR,
                  ("LinkDownIndication: Couldnt allocate msg\n"));

            //
            // Really no failure path here
            //

            RtAssert(FALSE);
        }

        if(pInterface->duUsage is DU_CALLOUT)
        {
            if(pMsg)
            {
                //
                // Setup the message
                //

                pMsg->wnMsg.ddeEvent        = DDE_CALLOUT_LINKDOWN;
                pMsg->wnMsg.dwAdapterIndex  = pInterface->dwRsvdAdapterIndex;
                pMsg->wnMsg.dwUserIfIndex   = INVALID_IF_INDEX;
                pMsg->wnMsg.dwAdapterIndex  = pAdapter->dwAdapterIndex;
                pMsg->wnMsg.dwLocalAddr     = pConnEntry->dwLocalAddr;
                pMsg->wnMsg.dwLocalMask     = pConnEntry->dwLocalMask;
                pMsg->wnMsg.dwRemoteAddr    = pConnEntry->dwRemoteAddr;
            }

            //
            // Remove from list and dereference the interface
            //

            RemoveEntryList(&(pInterface->leIfLink));

            InterlockedDecrement(&g_ulNumDialOutInterfaces);

            //
            // Done with the interface list
            //

            ExitWriterFromDpcLevel(&g_rwlIfLock);

            //
            // One ref kept for being on list
            // The final deletion will free the index
            //

            DereferenceInterface(pInterface);
        }
        else
        {
            //
            // Dont need the interface list lock
            //

            ExitWriterFromDpcLevel(&g_rwlIfLock);

            Trace(CONN, TRACE,
                  ("LinkDownIndication: For interface %p\n",
                   pInterface));

            //
            // For ROUTER interfaces notify user mode of the connection
            // going down
            //

            if(pMsg)
            {
                //
                // Setup the message
                //

                pMsg->wnMsg.ddeEvent        = DDE_INTERFACE_DISCONNECTED;
                pMsg->wnMsg.dwAdapterIndex  = pInterface->dwRsvdAdapterIndex;
                pMsg->wnMsg.dwUserIfIndex   = pInterface->dwIfIndex;
                pMsg->wnMsg.dwAdapterIndex  = pAdapter->dwAdapterIndex;
                pMsg->wnMsg.dwLocalAddr     = pConnEntry->dwLocalAddr;
                pMsg->wnMsg.dwLocalMask     = pConnEntry->dwLocalMask;
                pMsg->wnMsg.dwRemoteAddr    = pConnEntry->dwRemoteAddr;
            }
        }

        //
        // Done with the interface and adapter
        //

        RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));

        RtReleaseSpinLock(&(pAdapter->rlLock),
                          kiIrql);

        //
        // Deref the adapter because it was mapped to the interface
        //

        DereferenceAdapter(pAdapter);

        //
        // Deref the interface because it was mapped to the adapter
        //

        DereferenceInterface(pInterface);
    }

    //
    // Dereference the connection entry twice. Once because NDISWAN is
    // removing the connection, and again because GetConnEntry put a
    // reference on it
    //

    DereferenceConnEntry(pConnEntry);
    DereferenceConnEntry(pConnEntry);

    if(pMsg)
    {
        //
        // Will be non null only for callout where allocation succeeded
        //

        WanpCompleteIrp(pMsg);
    }

    return NDIS_STATUS_SUCCESS;
}

UINT
WanDemandDialRequest(
    ROUTE_CONTEXT   Context,
    IPAddr          dwDest,
    IPAddr          dwSource,
    BYTE            byProtocol,
    PBYTE           pbyBuffer,
    UINT            uiLength,
    IPAddr          dwHdrSrc
    )

/*++

Routine Description:

    This function services the request by IP to dial out an interface.
    IP passes us the context stored within the route. This context is
    nothing but the index of the interface to dial.
    We first find the interface. If found, we see if the interface is
    already mapped. This can happen in some window of time. In such a case
    we simply return the adapter mapped to the interface. Otherwise, we
    find a free adapter. We map this adapter to the interface and
    complete an IRP to the router manager to ask it to connect the interface.
    We set the state on the interface and the adapter to reflect the fact
    that they are mapped and awaiting connection. 
    If we dont find a free adapter, we nevertheless ask the router manager
    to dial out the interface, but we fail the demand dial request to IP.
    We return the adapter (IP) index of the adapter that was mapped.

Locks:

    Acquires the g_rwlIfLock as READER to lock out the interface
    The release the g_rwlIfLock and acquires the g_rwlAdapterlock to
    lock out a free adapter. (NOTE: DOES NOT FOLLOW adapter->interface
    hierarchy)

Arguments:

    Context
    dwDest
    dwSource
    byProtocol
    pbyBuffer
    uiLength

Return Value:

    The adapter of the index mapped
    INVALID_IF_INDEX on failure

--*/

{
    PADAPTER                pAdapter;
    PPENDING_NOTIFICATION   pMsg;
    PUMODE_INTERFACE        pInterface;
    KIRQL                   kiIrql;
    DWORD                   dwAdapterIndex;
    PLIST_ENTRY             pleNode;

    TraceEnter(CONN, "DemandDialRequest");

    EnterWriter(&g_rwlAdapterLock,
                &kiIrql);

    EnterReaderAtDpcLevel(&g_rwlIfLock);

    pInterface = WanpFindInterfaceGivenIndex(Context);

    if(pInterface is NULL)
    {
        ExitReaderFromDpcLevel(&g_rwlIfLock);

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

        Trace(CONN, ERROR,
              ("DemandDialRequest: Couldnt find interface %d\n",
               Context));

        TraceLeave(CONN, "DemandDialRequest");

        return INVALID_IF_INDEX;
    }

    ExitReaderFromDpcLevel(&g_rwlIfLock);

    Trace(CONN, TRACE,
          ("DemandDialRequest: For interface %p\n",
           pInterface));

    //
    // If the interface is already connected, this is just race condition
    //

    if(pInterface->dwOperState >= IF_OPER_STATUS_CONNECTING)
    {
        Trace(CONN, WARN,
              ("DemandDialRequest: I/f state %d, returning old adapter %p\n",
               pInterface->dwOperState,
               pInterface->pAdapter));


        if(pInterface->pAdapter)
        {
            //
            // We can get the adapter index without the holding the adapter
            // lock , because it is a read-only field once the adapter has
            // been added to IP, and can not change while the adapter is
            // is mapped to the interface
            //

            RtAssert(pInterface->pAdapter->dwAdapterIndex is pInterface->dwRsvdAdapterIndex);

            dwAdapterIndex = pInterface->dwRsvdAdapterIndex;
        }
        else
        {
            dwAdapterIndex = INVALID_IF_INDEX;
        }

        RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

        DereferenceInterface(pInterface);

        TraceLeave(CONN, "DemandDialRequest");

        return dwAdapterIndex;
    }

    //
    // We will need to connect this. If we cant get the memory
    // needed for the connection message, bail out
    //

    pMsg = AllocateNotification();

    if(pMsg is NULL)
    {
        Trace(CONN, ERROR,
              ("DemandDialRequest: Couldnt allocate notification\n"));

        RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

        DereferenceInterface(pInterface);

        TraceLeave(CONN, "DemandDialRequest");

        return INVALID_IF_INDEX;
    }

    pInterface->dwOperState = IF_OPER_STATUS_CONNECTING;
    pInterface->dwLastChange= GetTimeTicks();

    //
    // So we dont have an adapter mapped to the interface. Try and find one
    // We dont call FindAdapterToMap because that needs to be at passive
    //

    if(IsListEmpty(&g_leAddedAdapterList))
    {
        Trace(CONN, INFO,
              ("DemandDialRequest: Couldnt find an adapter already added to IP\n"));

        ExitWriterFromDpcLevel(&g_rwlAdapterLock);

        pAdapter = NULL;

        dwAdapterIndex = INVALID_IF_INDEX;
    }
    else
    {
        pleNode = RemoveHeadList(&g_leAddedAdapterList);

        pAdapter = CONTAINING_RECORD(pleNode,
                                     ADAPTER,
                                     leAdapterLink);

        RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

        InsertHeadList(&g_leMappedAdapterList,
                       &(pAdapter->leAdapterLink));

        ExitWriterFromDpcLevel(&g_rwlAdapterLock);


        RtAssert(pAdapter->byState is AS_ADDED);

        //
        // So we have a locked adapter
        //

        dwAdapterIndex = pAdapter->dwAdapterIndex;

        //
        // Map the adapter to the interface and refcount the adapter
        // to account for the fact that there is a stored pointer to it
        //

        pInterface->pAdapter = pAdapter;

        ReferenceAdapter(pAdapter);

        //
        // Setup the cross mapping
        //

        pAdapter->pInterface = pInterface;
        pAdapter->byState    = AS_MAPPED;

        ReferenceInterface(pInterface);

        Trace(CONN, INFO,
              ("DemandDialRequest: Found adapter %d free for %d\n",
               pAdapter->dwAdapterIndex,
               pInterface->dwIfIndex));

#if DBG

        Trace(CONN, INFO,
              ("DemandDialRequest: Adapter Index is %d. Name is %s\n",
               pAdapter->dwAdapterIndex,
               pAdapter->asDeviceNameA.Buffer));

#endif
    }

    //
    // Initialize the info to be sent to the router manager
    //

    pMsg->wnMsg.ddeEvent            = DDE_CONNECT_INTERFACE;
    pMsg->wnMsg.dwUserIfIndex       = pInterface->dwIfIndex;
    pMsg->wnMsg.dwAdapterIndex      = dwAdapterIndex;
    pMsg->wnMsg.dwPacketSrcAddr     = dwHdrSrc;
    pMsg->wnMsg.dwPacketDestAddr    = dwDest;
    pMsg->wnMsg.ulPacketLength      = uiLength;
    pMsg->wnMsg.byPacketProtocol    = byProtocol;

    if(uiLength)
    {
        RtlCopyMemory(pMsg->wnMsg.rgbyPacket,
                      pbyBuffer,
                      MIN(MAX_PACKET_COPY_SIZE,uiLength));
    }

    //
    // Complete any pending IRP or queue the notification
    //

    ExInitializeWorkItem(&pMsg->wqi,
                         WanpCompleteIrp,
                         pMsg);

    ExQueueWorkItem(&pMsg->wqi,
                    DelayedWorkQueue);



    // WanpCompleteIrp(pMsg);

    //
    // Ok so we are done with the adapter and the interface
    //

    RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));

    DereferenceInterface(pInterface);

    if(pAdapter)
    {
        RtReleaseSpinLock(&(pAdapter->rlLock),
                          kiIrql);
    }
    else
    {
        KeLowerIrql(kiIrql);
    }

    //
    // No need to deref the adapter, since we didnt call FindAdapter
    //

    Trace(CONN, INFO,
          ("DemandDialRequest: Returning adapter %d\n",
           dwAdapterIndex));

    return dwAdapterIndex;
}


PCONN_ENTRY
WanpCreateConnEntry(
    DIAL_USAGE  duUsage
    )

/*++

Routine Description:

    Allocate a connection entry and find a free slot for it in the
    connection table. Sets the slot into the conn entry
    The connection entry returned is not refcounted.

Locks:

    Must be called with the g_rlConnTableLock held.

Arguments:

    duUsage Type of the connection.

Return Value:

    Pointer to allocate conn entry (if successfull)

--*/

{
    PCONN_ENTRY pConnEntry;
    KIRQL       kiIrql;
    PULONG_PTR  puipTable;
    ULONG       ulSize;
    ULONG       i, ulIndex;

    TraceEnter(CONN, "CreateConnEntry");

    pConnEntry = AllocateConnection();

    if(pConnEntry is NULL)
    {
        return NULL;
    }

    RtlZeroMemory(pConnEntry,
                  sizeof(CONN_ENTRY));

    //
    // The refcount of a connection entry is set to 0 and not 1
    //

    InitConnEntryRefCount(pConnEntry);

    pConnEntry->byState = CS_CONNECTING;
    pConnEntry->duUsage = duUsage;    

    //
    // Find a free slot. g_ulNextIndex is a hint
    //

    for(i = 0, ulIndex = g_ulNextConnIndex;
        i < g_ulConnTableSize;
        i++)
    {
        //
        // Slot 0 is initialized to (ULONG_PTR)-1 so it cant match
        //

        if(g_puipConnTable[ulIndex] is (ULONG_PTR)0)
        {
            //
            // Free Slot
            //

            g_puipConnTable[ulIndex] = (ULONG_PTR)pConnEntry;

            g_rgulConns[duUsage]++;

            pConnEntry->ulSlotIndex = ulIndex;

            //
            // We just assume that the next one will be free
            // If not, the timer can fix it. If we get a connection before
            // the timer gets a chance to fix it then we will take a
            // perf hit
            //

            g_ulNextConnIndex++;

            g_ulNextConnIndex = g_ulNextConnIndex % g_ulConnTableSize;

            return pConnEntry;
        }

        ulIndex++;

        //
        // Wrap around
        //

        ulIndex = ulIndex % g_ulConnTableSize;
    }

    //
    // Couldnt find a slot. Grow the table. We are still holding the
    // lock. The way we do this is by growing the table in blocks of
    // 64 entries. We then copy out what we have and update the next index
    // etc
    //

    ulSize = (g_ulConnTableSize + WAN_CONN_TABLE_INCREMENT) * sizeof(ULONG_PTR);

    puipTable = RtAllocate(NonPagedPool,
                           ulSize,
                           WAN_CONN_TAG);

    if(puipTable is NULL)
    {
        Trace(CONN, ERROR,
              ("AllocateConnEntry: couldnt realloc table of size %d\n",
               ulSize));

        FreeConnection(pConnEntry);

        return NULL;
    }

    //
    // Zero out the new memory
    //

    RtlZeroMemory(puipTable,
                  ulSize);

    //
    // Copy out the old table
    //

    RtlCopyMemory(puipTable,
                  g_puipConnTable,
                  g_ulConnTableSize * sizeof(ULONG_PTR));


    //
    // Free the old table
    //

    RtFree(g_puipConnTable);

    //
    // Set up pointers, indices etc
    //

    g_puipConnTable = puipTable;

    //
    // Since the table was totally full, the next index will be
    // at the start of the new memory. Set the entry to that
    //

    g_puipConnTable[g_ulConnTableSize] = (ULONG_PTR)pConnEntry;

    g_rgulConns[duUsage]++;

    pConnEntry->ulSlotIndex = g_ulConnTableSize;

    //
    // Set the next index to one after the slot we just used
    //

    g_ulNextConnIndex = g_ulConnTableSize + 1;

    //
    // Increast the size to what is currently is
    //

    g_ulConnTableSize += WAN_CONN_TABLE_INCREMENT;

    return pConnEntry;
}

VOID
WanIpCloseLink(
    PVOID   pvAdapterContext,
    PVOID   pvLinkContext
    )


/*++

Routine Description:

    This function is called by IP when its ref counts on the link fall
    to 0.

Locks:

    None needed

Arguments:

    pvAdapterContext    The context we passed for the P2MP interface
    pvLinkContext       The context we passed for a link in IpAddLink()

Return Value:

    None

--*/

{
    PCONN_ENTRY pConnEntry;
    KIRQL       kiIrql;

    TraceEnter(CONN, "IpCloseLink");

    RtAssert(pvAdapterContext is g_pServerAdapter);

    pConnEntry = (PCONN_ENTRY)pvLinkContext;

#if DBG

    RtAcquireSpinLock(pConnEntry->prlLock, &kiIrql);

    pConnEntry->byState = CS_IP_DELETED_LINK;

    RtReleaseSpinLock(pConnEntry->prlLock, kiIrql);
    
#endif

    DereferenceConnEntry(pConnEntry);
}

VOID
WanpDeleteConnEntry(
    PCONN_ENTRY pConnEntry
    )

/*++

Routine Description:

    This function is called when the refcount on a connection falls to zero
    The connection entry is different from the other structures in wanarp
    in that even when the refcount falls to zero, the pAdapter has a
    pointer to the connection. However when we get here we know that
    no new sends could be forthcoming on this connection because we
    set the connection state to be disconnecting. We have already
    gotten a LinkDown indication on this and all our pending SendComplete's
    have been called

    We also sets the next free index for the connection table
    No shrinking is done here because we do that off a timer

Locks:

    Acquires the g_rlConnTableLock. The connection entry itself should
    not be locked

Arguments:

    pConnEntry    The connection entry to free

Return Value:

    None

--*/

{
    ULONG       ulIndex;
    KIRQL       kiIrql;
    PULONG_PTR   puipTable;
    SIZE_T      stSize;
    PADAPTER    pAdapter;


    //
    // Get the slot number
    //

    ulIndex = pConnEntry->ulSlotIndex;

    RtAcquireSpinLock(&g_rlConnTableLock,
                      &kiIrql);


    g_puipConnTable[ulIndex] = (ULONG_PTR)0;

#if DBG
    RtAssert((pConnEntry->duUsage is DU_CALLIN) or
             (pConnEntry->duUsage is DU_CALLOUT) or
             (pConnEntry->duUsage is DU_ROUTER));
#endif

    g_rgulConns[pConnEntry->duUsage]--;

    if(g_puipConnTable[g_ulNextConnIndex] isnot (ULONG_PTR)0)
    {
        g_ulNextConnIndex = ulIndex;
    }

    RtReleaseSpinLockFromDpcLevel(&g_rlConnTableLock);

    //
    // Get the adapter this connection is mapped to
    //

    pAdapter = pConnEntry->pAdapter;

#if DBG

    pConnEntry->ulSlotIndex = 0;
    pConnEntry->pAdapter    = NULL;

#endif

    //
    // Done with the connection entry
    //

    FreeConnection(pConnEntry);

    if(pAdapter is NULL)
    {
        KeLowerIrql(kiIrql);

        //
        // Wasnt mapped. Can happen when this function is called to
        // merely free resources from an error case
        //

        return;
    }


    //
    // Lock the adapter list
    //

    EnterWriterAtDpcLevel(&g_rwlAdapterLock);

    if(pAdapter is g_pServerAdapter)
    {
        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

        //
        // Client connection, simply deref the adapter
        //

        DereferenceAdapter(pAdapter);

        return;
    }

    ExitWriterFromDpcLevel(&g_rwlAdapterLock);

    //
    // Lock the adapter
    //

    RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

    //
    // Remove the entry from the adapter
    //

    pAdapter->pConnEntry = NULL;

    //
    // Done with the adapter
    //

    RtReleaseSpinLock(&(pAdapter->rlLock),
                      kiIrql);


    //
    // Called with no locks held
    //

    WanpUnmapAdapter(pAdapter);

    //
    // Dereference the adapter because the conn entry had a pointer
    // to it, which is now gone
    //

    DereferenceAdapter(pAdapter);

    return;
}

VOID
WanpNotifyRouterManager(
    PPENDING_NOTIFICATION   pMsg,
    PUMODE_INTERFACE        pInterface,
    PADAPTER                pAdapter,
    PCONN_ENTRY             pConnEntry,
    BOOLEAN                 bConnected
    )

/*++

Routine Description:

    Notifies the router manager when an interface is connected or
    disconnected

Locks:

    The interface must be locked

Arguments:

    pMsg
    pInterface      The interface being connected or disconnected
    pAdapter
    bConnected      Set to TRUE if the interface is being connected

Return Value:


--*/

{
    KIRQL                   kiIrql;

    TraceEnter(CONN, "WanpNotifyRouterManager");

    if(bConnected)
    {
        pMsg->wnMsg.ddeEvent        = DDE_INTERFACE_CONNECTED;
    }
    else
    {
        pMsg->wnMsg.ddeEvent        = DDE_INTERFACE_DISCONNECTED;
    }

    pMsg->wnMsg.dwUserIfIndex   = pInterface->dwIfIndex;
    pMsg->wnMsg.dwAdapterIndex  = pAdapter->dwAdapterIndex;
    pMsg->wnMsg.dwLocalAddr     = pConnEntry->dwLocalAddr;
    pMsg->wnMsg.dwLocalMask     = pConnEntry->dwLocalMask;
    pMsg->wnMsg.dwRemoteAddr    = pConnEntry->dwRemoteAddr;

    //
    // Complete any pending IRP or queue the notification
    //

    WanpCompleteIrp(pMsg);

}

PCONN_ENTRY
WanpGetConnEntryGivenAddress(
    DWORD   dwAddress
    )
{
    ULONG       i;
    KIRQL       kiIrql;
    PCONN_ENTRY pConnEntry;
    BOOLEAN     bFindFirst;

    pConnEntry = NULL;

    RtAcquireSpinLock(&g_rlConnTableLock,
                      &kiIrql);

    if((dwAddress is 0xFFFFFFFF) and
       (g_rgulConns[DU_CALLIN] is 1))
    {
        bFindFirst = TRUE;
    }
    else
    {
        bFindFirst = FALSE;
    }

    //
    // Slot 0 is never used
    //

    for(i = 1; i < g_ulConnTableSize; i++)
    {
        //
        // If there is a non-null connection and 
        // If either the dest matches, or we want to send a bcast to the 
        // first client (that is fully connected)
        //

        if(((PCONN_ENTRY)(g_puipConnTable[i]) isnot NULL) and
           ((((PCONN_ENTRY)(g_puipConnTable[i]))->dwRemoteAddr is dwAddress) or
            (bFindFirst and 
             (((PCONN_ENTRY)(g_puipConnTable[i]))->duUsage is DU_CALLIN) and
             (((PCONN_ENTRY)(g_puipConnTable[i]))->byState is CS_CONNECTED))))
        {
            pConnEntry = (PCONN_ENTRY)(g_puipConnTable[i]);

            ReferenceConnEntry(pConnEntry);

            if(pConnEntry->lRefCount < 2)
            {
#if DBG            
                REF_HIST_ENTRY  __rheTemp;
                InterlockedIncrement((PLONG)&((pConnEntry)->dwTotalRefOps));
                KeQuerySystemTime(&(__rheTemp.liChangeTime));
                __rheTemp.dwFileSig = __FILE_SIG__;
                __rheTemp.dwLine    = __LINE__;
                pConnEntry->rheHistory[(pConnEntry->dwTotalRefOps) % MAX_REF_HISTORY] =
                                                            __rheTemp;
                InterlockedIncrement((PLONG) &g_dwSendsOnDeletedLink);                                                            
#endif                                                            
                InterlockedDecrement((PLONG)&(pConnEntry->lRefCount));

                pConnEntry = NULL;
            }

            break;
        }
    }

    RtReleaseSpinLock(&g_rlConnTableLock,
                      kiIrql);

    return pConnEntry;
}

ULONG
WanpRemoveAllConnections(
    VOID
    )
{
    KIRQL   kiIrql;
    ULONG   ulCount, i;

    RtAcquireSpinLock(&g_rlConnTableLock,
                      &kiIrql);

    //
    // Slot 0 is never used
    //

    for(ulCount = 0, i = 1; i < g_ulConnTableSize; i++)
    {
        PCONN_ENTRY pConnEntry;

        pConnEntry = (PCONN_ENTRY)(g_puipConnTable[i]);

        if(pConnEntry is NULL)
        {
            continue;
        }

        g_rgulConns[pConnEntry->duUsage]--;

        FreeConnection(pConnEntry);

        ulCount++;

        g_puipConnTable[i] = 0;
    }

#if DBG

    RtAssert((g_rgulConns[DU_CALLIN] + g_rgulConns[DU_CALLOUT] + g_rgulConns[DU_ROUTER]) is 0);

#endif

    RtReleaseSpinLock(&g_rlConnTableLock,
                      kiIrql);

    return ulCount;
}

BOOLEAN
WanpIsConnectionTableEmpty(
    VOID
    )

{
    ULONG   i;
    KIRQL   kiIrql;

    RtAcquireSpinLock(&g_rlConnTableLock,
                      &kiIrql);

    for(i = 1; i < g_ulConnTableSize; i++)
    {
        PCONN_ENTRY pConnEntry;

        pConnEntry = (PCONN_ENTRY)(g_puipConnTable[i]);

        if(pConnEntry isnot NULL)
        {
            RtAssert((g_rgulConns[DU_CALLIN] + g_rgulConns[DU_CALLOUT] + g_rgulConns[DU_ROUTER]) isnot 0);

            RtReleaseSpinLock(&g_rlConnTableLock,
                              kiIrql);

            return FALSE;
        }
    }


    RtAssert((g_rgulConns[DU_CALLIN] + g_rgulConns[DU_CALLOUT] + g_rgulConns[DU_ROUTER]) is 0);


    RtReleaseSpinLock(&g_rlConnTableLock,
                      kiIrql);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\globals.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    wanarp\globals.h

Abstract:

    

Revision History:

    

--*/

#ifndef __WANARP_GLOBALS_H__
#define __WANARP_GLOBALS_H__

//
// Our IP Registration handle. Set at init time, and doesnt change over
// the course of a run of the driver. Thus isnt locked
//

HANDLE      g_hIpRegistration;

//
// Our NDIS handle. Again read-only after initialization
//

NDIS_HANDLE g_nhWanarpProtoHandle;

//
// NDIS handle of our pool. Again read-only after initialization
//

NDIS_HANDLE g_nhPacketPool;

//
// Callback functions into IP. Again read-only after initialization
//

IPRcvRtn	        g_pfnIpRcv;
IPRcvPktRtn         g_pfnIpRcvPkt;
IPTDCmpltRtn	    g_pfnIpTDComplete;
IPTxCmpltRtn	    g_pfnIpSendComplete;
IPStatusRtn	        g_pfnIpStatus;
IPRcvCmpltRtn	    g_pfnIpRcvComplete;
IP_ADD_INTERFACE    g_pfnIpAddInterface; 
IP_DEL_INTERFACE    g_pfnIpDeleteInterface;
IP_BIND_COMPLETE    g_pfnIpBindComplete;
IP_PNP              g_pfnIpPnp;
IP_ADD_LINK         g_pfnIpAddLink;
IP_DELETE_LINK      g_pfnIpDeleteLink;
IP_CHANGE_INDEX     g_pfnIpChangeIndex;
IP_RESERVE_INDEX    g_pfnIpReserveIndex;
IP_DERESERVE_INDEX  g_pfnIpDereserveIndex;
IPRcvPktRtn         g_pfnIpRcvPkt;


#endif // __WANARP_GLOBALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\driver.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ipinip\driver.h

Abstract:

    Headers for driver.c

Revision History:


--*/


//
// The number of IRP_MJ_CREATEs we have received
//

ULONG   g_ulNumCreates;

//
// The state of the driver
//

DWORD   g_dwDriverState;

//
// The lock to protect the driver state
//

RT_LOCK g_rlStateLock;

//
// The mutext that serializes binds and unbinds
//

WAN_RESOURCE   g_wrBindMutex;

//
// The state of the driver.
//

#define DRIVER_STOPPED      0
#define DRIVER_STARTING     1
#define DRIVER_STARTED      2


//
// Timeout value for start is 10 seconds.
// So in 100ns it becomes
//

#define START_TIMEOUT       (LONGLONG)(10 * 1000 * 1000 * 10)

//
// The event to signal when we have started
//

KEVENT  g_keStartEvent;

//
// The event to signal when all the threads go to 0 and state is STOPPED
//

KEVENT  g_keStateEvent;

//
// Event to signal when our close adapter function is done
//

KEVENT  g_keCloseEvent;

//
// The  number of "threads" in the driver
//

ULONG   g_ulNumThreads;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
WanDispatch(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

VOID
WanUnload(
    PDRIVER_OBJECT DriverObject
    );

BOOLEAN
WanpSetupExternalName(
    PUNICODE_STRING  pusNtName,
    PWCHAR           pwcDosName,
    BOOLEAN          bCreate
    );

NTSTATUS
WanpStartDriver(
    VOID
    );

VOID
WanpStopDriver(
    KIRQL           kiOldIrql
    );

NTSTATUS
WanpRegisterWithIp(
    VOID
    );

VOID
WanpDeregisterWithIp(
    VOID
    );

BOOLEAN
EnterDriverCode(
    VOID
    );

VOID
ExitDriverCode(
    VOID
    );

VOID
WanpSetDemandDialCallback(
    BOOLEAN    bSetPointer
    );

BOOLEAN
WanpInitializeDriverStructures(
    VOID
    );

NDIS_STATUS
WanpInitializeNdis(
    VOID
    );

NTSTATUS
OpenRegKey(
    OUT PHANDLE         phHandle,
    IN  PUNICODE_STRING pusKeyName
    );

NTSTATUS
GetRegDWORDValue(
    HANDLE           KeyHandle,
    PWCHAR           ValueName,
    PULONG           ValueData
    );

VOID
WanpDeinitializeNdis(
    VOID
    );

VOID
WanNdisUnload(
    VOID
    );

BOOLEAN
IsEntryOnList(
    PLIST_ENTRY pleHead,
    PLIST_ENTRY pleEntry
    );

VOID
WanpInitializeResource(
    IN  PWAN_RESOURCE   pLock
    );

VOID
WanpAcquireResource(
    IN  PWAN_RESOURCE   pLock
    );

VOID
WanpReleaseResource(
    IN  PWAN_RESOURCE   pLock
    );

INT
ConvertGuidToString(
    IN  GUID    *pGuid,
    OUT PWCHAR  pwszGuid
    );

VOID
WanpClearPendingIrps(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\inc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\wanarp\allinc.h

Abstract:

    WAN ARP main header.

Revision History:

    Gurdeep Singh Pall          7/31/95

--*/

#ifndef __WANARP_INC_H___
#define __WANARP_INC_H___


typedef unsigned long       DWORD, *PDWORD;
typedef unsigned short      WORD,  *PWORD;
typedef unsigned char       BYTE,  *PBYTE;
typedef void                *PVOID;

#include <ntddk.h>
#include <ndis.h>
#include <cxport.h>
#include <ip.h>
#include <ntddip.h>
#include <ntddtcp.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <tcpinfo.h>
#include <llinfo.h>
#include <ipfilter.h>
#include <tdistat.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <arpinfo.h>

#include <guiddef.h>

#include <crt\stdarg.h>

#include <ipifcons.h>

#include <wanpub.h>
#include <ddwanarp.h>

#define is      ==
#define isnot   !=
#define or      ||
#define and     &&

#include "llipif.h"

#include "debug.h"
#include "rwlock.h"

#include <bpool.h>

#include "wanarp.h"
#include "globals.h"
#include "adapter.h"
#include "ioctl.h"
#include "conn.h"
#include "driver.h"
#include "info.h"
#include "rcv.h"
#include "send.h"
#include "guid.h"


#endif // __WANARP_INC_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\driver.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\wanarp\driver.c

Abstract:

    WAN ARP driver shell.

Revision History:

    Gurdeep Singh Pall          8/2/95  Created

--*/

#define __FILE_SIG__    DRIVER_SIG

#include "inc.h"
#pragma hdrstop


BOOLEAN g_bExit;
BOOLEAN g_bPoolsInitialized;
NPAGED_LOOKASIDE_LIST    g_llNotificationBlocks;
NPAGED_LOOKASIDE_LIST       g_llConnBlocks;

#pragma alloc_text(INIT, DriverEntry)

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system and must be named
    "Driver Entry"
    The function is discardable since it is only called once
    On checked builds we read some values from registry and initialize the
    debugging
    We create a DEVICE_OBJECT for ourselves to field the IOCTLs, create 
    a DOS name for the device and initialize some events and spinlocks

Locks: 

    None

Arguments:

    DriverObject    Pointer to I/O subsystem created driver object
    RegistryPath    Points to driver key in HKLM\System\CCS\Services...

Return Value:

    STATUS_SUCCESS  if everything went as planned or some status code from
                    ntstatus.h

--*/

{
    NTSTATUS        nStatus;
    PDEVICE_OBJECT  pDeviceObject;
    UNICODE_STRING  usDeviceName, usParamString, usTempString;
    DWORD           dwVal, i;
    HANDLE          hRegKey;
    USHORT          usRegLen;
    PWCHAR          pwcBuffer;

    RtInitializeDebug();
    
    usRegLen = RegistryPath->Length +
               (sizeof(WCHAR) * (wcslen(L"\\Parameters") + 2));

    pwcBuffer = RtAllocate(NonPagedPool,
                           usRegLen,
                           WAN_STRING_TAG);

    if(pwcBuffer is NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pwcBuffer,
                  usRegLen);

    usParamString.MaximumLength = usRegLen;
    usParamString.Buffer        = pwcBuffer;

    RtlCopyUnicodeString(&usParamString,
                         RegistryPath);

    RtlInitUnicodeString(&usTempString,
                         L"\\Parameters");

    RtlAppendUnicodeStringToString(&usParamString,
                                   &usTempString);

    nStatus = OpenRegKey(&hRegKey,
                         &usParamString);

    RtFree(pwcBuffer);

    if(nStatus is STATUS_SUCCESS)
    {

#if RT_TRACE_DEBUG

        nStatus = GetRegDWORDValue(hRegKey,
                                   L"DebugLevel",
                                   &dwVal);

        if(nStatus is STATUS_SUCCESS)
        {
            g_byDebugLevel  = (BYTE)dwVal;
        }

        nStatus = GetRegDWORDValue(hRegKey,
                                   L"DebugComp",
                                   &dwVal);

        if(nStatus is STATUS_SUCCESS)
        {
            g_fDebugComp  = dwVal;
        }
#endif

#if DBG
        nStatus = GetRegDWORDValue(hRegKey,
                                   L"DebugBreak",
                                   &dwVal);

        if((nStatus is STATUS_SUCCESS) and
           (dwVal is 1))
        {
            DbgBreakPoint();
        }
#endif

        ZwClose(hRegKey);
    }

    TraceEnter(GLOBAL, "DriverEntry");

    //DbgBreakPoint();

    if(g_bExit)
    {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Initialize some globals (rest are all 0s)
    //
    
    g_dwDriverState = DRIVER_STOPPED;

    //
    // Create the device
    //

    RtlInitUnicodeString(&usDeviceName,
                         DD_WANARP_DEVICE_NAME_W);

    nStatus = IoCreateDevice(DriverObject,
                             0,
                             &usDeviceName,
                             FILE_DEVICE_NETWORK,
                             FILE_DEVICE_SECURE_OPEN,
                             FALSE,
                             &pDeviceObject);

    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(GLOBAL, ERROR,
              ("DriverEntry: Cant create device object %S, status %x.\n",
               DD_WANARP_DEVICE_NAME_W,
               nStatus));

        TraceLeave(GLOBAL, "DriverEntry");

        return nStatus;
    }

    //
    // Initialize the driver object
    //

    DriverObject->DriverUnload   = WanUnload;
    DriverObject->FastIoDispatch = NULL;

    for(i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
    {
        DriverObject->MajorFunction[i] = WanDispatch;
    }

    //
    // Initialize Events etc
    //
    
    WanpInitializeDriverStructures();
    
    if(!WanpSetupExternalName(&usDeviceName, 
                              WIN32_WANARP_SYMBOLIC_LINK,
                              TRUE))
    {
        Trace(GLOBAL,ERROR,
              ("DriverEntry: Win32 device name %S could not be created\n",
               WIN32_WANARP_SYMBOLIC_LINK));

        IoDeleteDevice(pDeviceObject);

        TraceLeave(GLOBAL, "DriverEntry");

        return  STATUS_UNSUCCESSFUL;
    }

    //
    // Register with IP
    //

    WanpAcquireResource(&g_wrBindMutex);

    nStatus = WanpRegisterWithIp();

    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(GLOBAL, ERROR,
              ("DriverEntry: RegisterWithIp failed %x\n",
               nStatus));

        WanpSetupExternalName(&usDeviceName, 
                              WIN32_WANARP_SYMBOLIC_LINK,
                              FALSE);
        
        IoDeleteDevice(pDeviceObject);

        WanpReleaseResource(&g_wrBindMutex);

        TraceLeave(GLOBAL, "InitializeDriver");

        return FALSE;
    }

    nStatus = WanpInitializeNdis();

    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(GLOBAL, ERROR,
              ("DriverEntry: IntializeNdis failed %x\n",
               nStatus));

        WanpDeregisterWithIp();
        
        WanpSetupExternalName(&usDeviceName, 
                              WIN32_WANARP_SYMBOLIC_LINK,
                              FALSE);
        
        IoDeleteDevice(pDeviceObject);

        WanpReleaseResource(&g_wrBindMutex);

        TraceLeave(GLOBAL, "InitializeDriver");

        return FALSE;
    }

    WanpReleaseResource(&g_wrBindMutex);

    TraceLeave(GLOBAL, "DriverEntry");

    return nStatus;
}

/*++

Routine Description:

    The functions which handles the IRP_MJ_CLEANUP IRP sent to the driver
    This function is called by WanDispatch so that it can acquire lock.
    This code is not pageable.

Locks:
    Takes spin lock g_rlStateLock
    
++*/

VOID
WanpDriverCleanupNotification(
    )
{            
    KIRQL           kiOldIrql;
    
    RtAcquireSpinLock(&g_rlStateLock,
              &kiOldIrql);


    if(--g_ulNumCreates is 0)
    {
        //
        // Last handle open is now closed; lets clean up
        //

        // this function releases the spin lock
        
        WanpStopDriver(kiOldIrql);
    }
    else
    {
        RtReleaseSpinLock(&g_rlStateLock,
              kiOldIrql);
    }

    return;
}

#pragma alloc_text(PAGE, WanDispatch)

NTSTATUS
WanDispatch(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )

/*++

Routine Description:

    The functions which handles the IRPs sent to the driver

Locks:

    This code is PAGEABLE so can not acquire locks
 
Arguments:
      

Return Value:

    STATUS_SUCCESS 

--*/

{
    PIO_STACK_LOCATION	irpStack;
    ULONG		        ulInputBuffLen;
    ULONG		        ulOutputBuffLen;
    ULONG		        ioControlCode;
    NTSTATUS	        nStatus;
    KIRQL               kiIrql;
    LARGE_INTEGER       liTimeOut;
    BOOLEAN             bEnter;

    
    PAGED_CODE();
    
    TraceEnter(GLOBAL, "WanDispatch");

    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //
    
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    switch (irpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:
        {
            
            Trace(GLOBAL, TRACE,
                  ("WanDispatch: IRP_MJ_CREATE\n"));

            //
            // We start the driver when the first CreateFile is done
            // But we need to serialize the Creates
            //

            nStatus = WanpStartDriver();
        
            if(nStatus isnot STATUS_SUCCESS)
            {
                //
                // If pending, wait on the start event
                //

                if(nStatus is STATUS_PENDING)
                {
                    nStatus = KeWaitForSingleObject((&g_keStartEvent),
                                                Executive,
                                                KernelMode,
                                                FALSE,
                                                NULL);
                }
                else
                {
                    break;
                }

            }
            
            //
            // Make sure the driver actually started
            //
            
            bEnter = EnterDriverCode();
            
            if(!bEnter)
            {
                Trace(GLOBAL, ERROR,
                      ("WanDispatch: Wait successful, but unable to start driver\n"));
                
                nStatus = STATUS_UNSUCCESSFUL;
            }
            else
            {
                ExitDriverCode();
            }
            
            break;
        }

        case IRP_MJ_CLOSE:
        {
            Trace(GLOBAL, TRACE,
                  ("WanDispatch: IRP_MJ_CLOSE\n"));

            //
            // We handle cleanup and not close
            //
            
            nStatus = STATUS_SUCCESS;

            break;
        }
        
        case IRP_MJ_CLEANUP:
        {
            Trace(GLOBAL, TRACE,
                  ("WanDispatch: IRP_MJ_CLEANUP\n"));

            nStatus = STATUS_SUCCESS;
            
            WanpDriverCleanupNotification();
            
            break;
        }

        case IRP_MJ_DEVICE_CONTROL:
        {
            DWORD   dwState;
            ULONG   ulControl;

            //
            // Get the control code and our code
            //
            
            ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;
           
            //
            // Get the pointer to the input/output buffer and it's length
            //

            ulInputBuffLen  = 
                irpStack->Parameters.DeviceIoControl.InputBufferLength;
            ulOutputBuffLen = 
                irpStack->Parameters.DeviceIoControl.OutputBufferLength;

 
            //
            // If the driver is stopping, dont process anything else
            //
            
            bEnter =  EnterDriverCode();
            
            if(!bEnter)
            {
                Trace(GLOBAL, ERROR,
                      ("WanDispatch: Driver is not started\n"));
                
                nStatus = STATUS_NO_SUCH_DEVICE;
                
                break;
            }
            
            switch(ioControlCode)
            {
                case IOCTL_WANARP_NOTIFICATION:
                {
                    nStatus = WanProcessNotification(Irp,
                                                     ulInputBuffLen,
                                                     ulOutputBuffLen);

                    break;
                }

                case IOCTL_WANARP_ADD_INTERFACE:
                {
                    nStatus = WanAddUserModeInterface(Irp,
                                                      ulInputBuffLen,
                                                      ulOutputBuffLen);

                    break;
                }

                case IOCTL_WANARP_DELETE_INTERFACE:
                {
                    nStatus = WanDeleteUserModeInterface(Irp,
                                                         ulInputBuffLen,
                                                         ulOutputBuffLen);

                    break;
                }
                
                case IOCTL_WANARP_CONNECT_FAILED:
                {
                    nStatus = WanProcessConnectionFailure(Irp,
                                                          ulInputBuffLen,
                                                          ulOutputBuffLen);

                    break;
                }

                case IOCTL_WANARP_GET_IF_STATS:
                {
                    nStatus = WanGetIfStats(Irp,
                                            ulInputBuffLen,
                                            ulOutputBuffLen);

                    break;
                }
               
                case IOCTL_WANARP_DELETE_ADAPTERS:
                {
                    nStatus = WanDeleteAdapters(Irp,
                                                ulInputBuffLen,
                                                ulOutputBuffLen);

                    break;
                }

                case IOCTL_WANARP_MAP_SERVER_ADAPTER:
                {
                    nStatus = WanMapServerAdapter(Irp,
                                                  ulInputBuffLen,
                                                  ulOutputBuffLen);

                    break;
                }

                case IOCTL_WANARP_QUEUE:
                {
                    nStatus = WanStartStopQueuing(Irp,
                                                  ulInputBuffLen,
                                                  ulOutputBuffLen);

                    break;
                }

                default:
                {
                    Trace(GLOBAL, ERROR,
                          ("WanDispatch: Unknown IRP_MJ_DEVICE_CONTROL %x\n",
                           ioControlCode));
                
                    nStatus = STATUS_INVALID_PARAMETER;
                }
            }        

            ExitDriverCode();
            
            break;
        }

        default:
        {
            Trace(GLOBAL, ERROR,
                  ("WanDispatch: Unknown IRP_MJ_XX - %x\n",
                   irpStack->MajorFunction));

            nStatus = STATUS_INVALID_PARAMETER;

            break;
        }
    }

    if(nStatus isnot STATUS_PENDING)
    {
        Irp->IoStatus.Status = nStatus;

        IoCompleteRequest(Irp,
                          IO_NETWORK_INCREMENT);
    }

    TraceLeave(GLOBAL, "WanDispatch");

    return nStatus;
}


#pragma alloc_text(PAGE, WanUnload)

VOID
WanUnload(
    PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Called by the I/O subsystem, when our driver is being unloaded
    
Locks:


Arguments:


Return Value:

    None

--*/

{
    UNICODE_STRING  usDeviceName;
    BOOLEAN         bWait;
    KIRQL           kiIrql;
    NDIS_STATUS     nsStatus;
    NTSTATUS        nStatus;

    TraceEnter(GLOBAL,"WanUnload");
    
    PAGED_CODE();

    //
    // The driver must have stopped before it came here
    //

    RtAssert(g_dwDriverState is DRIVER_STOPPED);

    //
    // Deregister from NDIS etc
    //

    WanpDeinitializeNdis();

    //
    // Clear out IP's state. Need to do this after all adapters have
    // been removed
    //

    WanpDeregisterWithIp();


    //
    // Remove ourself from NT and DOS namespace
    //
    
    RtlInitUnicodeString(&usDeviceName,
                         DD_WANARP_DEVICE_NAME_W);

    WanpSetupExternalName(&usDeviceName, 
                          WIN32_WANARP_SYMBOLIC_LINK,
                          FALSE);

    //
    // Free all our structures
    //

    if(g_puipConnTable)
    {
        RtFree(g_puipConnTable);
    }

    ExDeleteNPagedLookasideList(&g_llConnBlocks);
    ExDeleteNPagedLookasideList(&g_llNotificationBlocks);

    if(g_bPoolsInitialized)
    {
        FreeBufferPool(&g_bpHeaderBufferPool);
        FreeBufferPool(&g_bpDataBufferPool);

        g_bPoolsInitialized = FALSE;
    }

    //
    // Acquire and release the resource. This lets the close adapter thread
    // run if it is still around
    //

    WanpAcquireResource(&g_wrBindMutex);

    WanpReleaseResource(&g_wrBindMutex);

    //
    // See if we have any free memory
    //

    RtAuditMemory();
    
    //
    // Delete the device object
    //
    
    IoDeleteDevice(DriverObject->DeviceObject);

    TraceLeave(GLOBAL,"WanUnload");
}

#pragma alloc_text(PAGE, WanpSetupExternalName)

BOOLEAN
WanpSetupExternalName(
    PUNICODE_STRING  pusNtName,
    PWCHAR           pwcDosName,
    BOOLEAN          bCreate
    )

/*++

Routine Description:

    Setup or delete a symbolic link to DOS namespace
    
Locks:

Arguments:

    pusNtName   Name in NT space
    pwcDosName  Name in DOS space
    bCreate     Set to TRUE to create, FALSE to delete
    
Return Value:

    TRUE    if successful
    FALSE   otherwise

--*/

{
    UNICODE_STRING  usSymbolicLinkName;
    WCHAR           rgwcBuffer[100];

    PAGED_CODE();

    //
    // Form the full symbolic link name we wish to create.
    //

    usSymbolicLinkName.Buffer = rgwcBuffer;

    RtlInitUnicodeString(&usSymbolicLinkName,
                         pwcDosName);

    if(bCreate)
    {
        if(!NT_SUCCESS(IoCreateSymbolicLink(&usSymbolicLinkName,
                                            pusNtName)))
        {
            return FALSE;
        }
    }
    else
    {
        IoDeleteSymbolicLink(&usSymbolicLinkName);
    }

    return TRUE;
}

NTSTATUS
WanpStartDriver(
    VOID
    )

/*++

Routine Description:
      
    Main routine to start the driver. We call this when we get a CREATE irp
    If the driver has started, we return success. If someone is starting the
    driver, we return pending. The caller then needs to wait on g_keStartEvent
    We try and start the driver. If all goes well, we set the event and
    everyone parties on from there
    
Locks: 

    The function takes the g_rlStateLock to check the state and increment
    the number of CREATEs it has received (open handles)
    
Arguments:

    None

Return Value:

    STATUS_SUCCESS  if the driver started
    STATUS_PENDING  if the driver is being started by some other thread's

--*/

{
    KIRQL    kiOldIrql;
    NTSTATUS nStatus;
    DWORD    dwState;
 
    TraceEnter(GLOBAL, "StartDriver");

    RtAcquireSpinLock(&g_rlStateLock,
                      &kiOldIrql);

    g_ulNumCreates++;

    if(g_ulNumCreates isnot 1)
    {
        if(g_dwDriverState is DRIVER_STARTING)
        {
            //
            // Someone is trying to start the driver
            //

            Trace(GLOBAL, INFO,
                  ("StartDriver: Driver is being started by someone else\n"));

            nStatus = STATUS_PENDING;
        }
        else
        {
            //
            // If we are not the first CreateFile, and the driver is not 
            // starting then the driver must already be running
            //

            RtAssert(g_dwDriverState is DRIVER_STARTED);

            nStatus = STATUS_SUCCESS;
        }

        RtReleaseSpinLock(&g_rlStateLock,
                          kiOldIrql);
    
        return nStatus;
    }

    //
    // The first CreateFile
    //

    RtAssert(g_dwDriverState is DRIVER_STOPPED);

    //
    // Set the state to starting, release the lock and actually start 
    // the driver
    //

    g_dwDriverState = DRIVER_STARTING;

    RtReleaseSpinLock(&g_rlStateLock,
                      kiOldIrql);

    //
    // Must be called at PASSIVE because it waits for IP to finish
    //
    
    WanpSetDemandDialCallback(TRUE);
   
 
    RtAcquireSpinLock(&g_rlStateLock,
                      &kiOldIrql);

    g_dwDriverState = DRIVER_STARTED;
  
    //
    // Someone may have been waiting for us to start
    //
 
    KeSetEvent(&g_keStartEvent,
               0,
               FALSE);

    RtReleaseSpinLock(&g_rlStateLock,
                      kiOldIrql);

    TraceLeave(GLOBAL, "StartDriver");

    return STATUS_SUCCESS;
}

    
VOID
WanpStopDriver(
    KIRQL           kiOldIrql
    )

/*++

Routine Description:

    Called when we get an IRP_MJ_CLEANUP. It is the inverse of StartDriver
    If this is the last thread, we set the state to STOPPED and wait till
    all threads of execution have exited the driver.
    We then clean out resources
  
Locks: 

    The function is called with the g_rlStateLock. The function releases the 
    lock
    
Arguments:
      
    None
    
Return Value:

    None
    
--*/
{
    NTSTATUS        nStatus;
    BOOLEAN         bWait;
   
    TraceEnter(GLOBAL, "StopDriver");
    
    //
    // Set the state to stopping. Any reader will
    // return on seeing this. So essentially we are not
    // allowing any new readers in
    //
    
    g_dwDriverState = DRIVER_STOPPED;

    //
    // However there may already be readers. We wait
    // if there are any
    //
    
    bWait = (g_ulNumThreads > 0);
    
    RtReleaseSpinLock(&g_rlStateLock,
                      kiOldIrql);

    //
    // Now do a wait. We can do this since we are at PASSIVE
    //

    if(bWait)
    {
        Trace(GLOBAL, INFO,
              ("StopDriver: Need to wait for threads to exit\n"));

        do
        {
            nStatus = KeWaitForSingleObject(&g_keStateEvent,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            NULL);

        }while((nStatus is STATUS_USER_APC) or
               (nStatus is STATUS_ALERTED) or
               (nStatus is STATUS_TIMEOUT));
    }

    //
    // Cleanup all resources
    //

    WanpCleanOutInterfaces();

    WanpClearPendingIrps();
 
    TraceLeave(GLOBAL, "StopDriver");
}



NTSTATUS
WanpRegisterWithIp(
    VOID
    )

/*++

Routine Description:

    Registers the ARP module with IP

Locks:


Arguments:


Return Value:


--*/

{
    NDIS_STRING     nsWanName;
    WCHAR           pwszName[] = WANARP_ARP_NAME;

    TraceEnter(GLOBAL, "WanpRegisterWithIp");

    nsWanName.MaximumLength  = sizeof(pwszName);
    nsWanName.Length         = sizeof(WANARP_ARP_NAME) - sizeof(WCHAR);
    nsWanName.Buffer         = pwszName;

    if(IPRegisterARP(&nsWanName,
                     IP_ARP_BIND_VERSION,
                     WanIpBindAdapter,
                     &g_pfnIpAddInterface,
                     &g_pfnIpDeleteInterface,
                     &g_pfnIpBindComplete,
                     &g_pfnIpAddLink,
                     &g_pfnIpDeleteLink,
                     &g_pfnIpChangeIndex,
                     &g_pfnIpReserveIndex,
                     &g_pfnIpDereserveIndex,
                     &g_hIpRegistration) isnot IP_SUCCESS)
    {
        Trace(GLOBAL, ERROR,
              ("WanpRegisterWithIp: Couldnt register with IP\n"));

        TraceLeave(GLOBAL,
                  "WanpRegisterWithIp");

        return STATUS_UNSUCCESSFUL;
    }

    TraceLeave(GLOBAL,
              "WanpRegisterWithIp");

    return STATUS_SUCCESS;
}

VOID
WanpDeregisterWithIp(
    VOID
    )

/*++

Routine Description:

   DeRegisters the ARP module with IP

Locks:


Arguments:


Return Value:

--*/

{
    NTSTATUS    nStatus;

    TraceEnter(GLOBAL, "WanpDeregisterWithIP");

    nStatus = IPDeregisterARP(g_hIpRegistration);

    if(nStatus isnot STATUS_SUCCESS)    
    {
        Trace(GLOBAL, ERROR,
              ("WanpDeregisterWithIP: Couldnt deregister with IP. Error %x\n",
               nStatus));

    }

    g_pfnIpAddInterface     = NULL;
    g_pfnIpDeleteInterface  = NULL;
    g_pfnIpBindComplete     = NULL;
    g_pfnIpRcv              = NULL;
    g_pfnIpRcvComplete      = NULL;
    g_pfnIpSendComplete     = NULL;
    g_pfnIpTDComplete       = NULL;
    g_pfnIpStatus           = NULL;
    g_pfnIpRcvPkt           = NULL;
    g_pfnIpPnp              = NULL;
    g_hIpRegistration       = NULL;

    TraceLeave(GLOBAL, "WanpDeregisterWithIP");
}

BOOLEAN
EnterDriverCode(
    VOID
    )
{
    KIRQL   irql;
    BOOLEAN bEnter;
    ULONG   i;
    
    
    //
    // If we havent received any binds, sleep for 30 seconds
    //

    i = 0;

    while((g_lBindRcvd is 0) and
          (i < 3))
    {
        LARGE_INTEGER   liTimeOut;

        i++;

        //
        // Set this to 5,10,15 seconds
        //
        
        liTimeOut.QuadPart = (LONGLONG)((i+ 1) * 5 * 1000 * 1000 * 10 * -1);
        
        KeDelayExecutionThread(UserMode,
                               FALSE,
                               &liTimeOut);
    }

    if(g_lBindRcvd is 0)
    {
        return FALSE;
    }
    
    RtAcquireSpinLock(&g_rlStateLock,
                      &irql);

    if(g_dwDriverState is DRIVER_STARTED)
    {
        g_ulNumThreads++;

        bEnter = TRUE;
    }
    else
    {
        bEnter = FALSE;
    }

    RtReleaseSpinLock(&g_rlStateLock,
                      irql);

    return bEnter;
}


VOID
ExitDriverCode(
    VOID
    )
{
    KIRQL   irql;

    RtAcquireSpinLock(&g_rlStateLock,
                      &irql);

    g_ulNumThreads--;

    if((g_dwDriverState is DRIVER_STOPPED) and
       (g_ulNumThreads is 0))
    {
        KeSetEvent(&g_keStateEvent,
                   0,
                   FALSE);
    }

    RtReleaseSpinLock(&g_rlStateLock,
                      irql);

}

#pragma alloc_text(PAGE, WanpSetDemandDialCallback)

VOID
WanpSetDemandDialCallback(
    BOOLEAN    bSetPointer
    )

/*++

Routine Description:

    Sets the pointer to our demand dial request routine with the IP Stack

Locks:

    None, done at INIT time

Arguments:

    bSetPointer     TRUE:  set the pointer
                    FALSE: remove the pointer

Return Value:

    None
    
--*/

{
    PIRP                irp;
    HANDLE              handle;
    NTSTATUS            nStatus;
    KEVENT              tempevent;
    PFILE_OBJECT        fileObject;
    PDEVICE_OBJECT      deviceObject;
    IO_STATUS_BLOCK     ioStatusBlock;
    UNICODE_STRING      usDeviceName;
    
    IP_SET_MAP_ROUTE_HOOK_INFO  buffer;

    PAGED_CODE();

    //
    // Open IP driver
    //
    
    RtlInitUnicodeString(&usDeviceName,
                         DD_IP_DEVICE_NAME);

    nStatus = IoGetDeviceObjectPointer(&usDeviceName,
                                       SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
                                       &fileObject,
                                       &deviceObject);

    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(CONN, ERROR,
              ("SetDemandDialCallback: IoGetDeviceObjectPointer for %S failed with status %x\n",
               DD_IP_DEVICE_NAME,
               nStatus));

        return;
    }
    
    //
    // Reference the device object.
    //
    
    ObReferenceObject(deviceObject);
    
    //
    // IoGetDeviceObjectPointer put a reference on the file object.
    //
    
    ObDereferenceObject(fileObject);

    //
    // Allocate event to use for setting callback address
    //

    KeInitializeEvent(&tempevent,
                      SynchronizationEvent,
                      FALSE);

    if(bSetPointer)
    {
        buffer.MapRoutePtr  = WanDemandDialRequest;
    }
    else
    {
        buffer.MapRoutePtr  = NULL;
    }
    
    //
    // Build the IRP
    //
    
    irp = IoBuildDeviceIoControlRequest(IOCTL_IP_SET_MAP_ROUTE_POINTER,
                                        deviceObject,
                                        &buffer,
                                        sizeof(IP_SET_MAP_ROUTE_HOOK_INFO),
                                        NULL,
                                        0,
                                        FALSE,
                                        &tempevent,
                                        &ioStatusBlock);

    if (irp is NULL)
    {
        ObDereferenceObject(deviceObject);
        
        Trace(GLOBAL, ERROR,
              ("SetDemandDialCallback: Couldnt build IRP\n"));
    }
    else
    {
        nStatus = IoCallDriver(deviceObject, irp);
        
        if(nStatus is STATUS_PENDING)
        {
            nStatus = KeWaitForSingleObject(&tempevent,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            NULL);
        }
        
        //
        // "close" handle to IP driver
        //
        
        ObDereferenceObject(deviceObject);
    }

}

#pragma alloc_text(PAGE, WanpInitializeDriverStructures)

BOOLEAN
WanpInitializeDriverStructures(
    VOID
    )

/*++

Routine Description:

    Initializes the internal driver structures

Locks:

    None, called at init time

Arguments:

    None

Return Value:

    None
    
--*/

{
    ULONG   i;

    PAGED_CODE();

    //
    // Lock and event needed to keep track of threads in the driver
    //

    RtInitializeSpinLock(&g_rlStateLock);

    KeInitializeEvent(&g_keStateEvent,
                      SynchronizationEvent,
                      FALSE);

    KeInitializeEvent(&g_keStartEvent,
                      NotificationEvent,
                      FALSE);

    KeInitializeEvent(&g_keCloseEvent,
                      SynchronizationEvent,
                      FALSE);

    WanpInitializeResource(&g_wrBindMutex);
    
    InitRwLock(&g_rwlIfLock);
    InitRwLock(&g_rwlAdapterLock);

    InitializeListHead(&g_leIfList);

    InitializeListHead(&g_lePendingNotificationList);
    InitializeListHead(&g_lePendingIrpList);

    InitializeListHead(&g_leMappedAdapterList);
    InitializeListHead(&g_leChangeAdapterList);
    InitializeListHead(&g_leAddedAdapterList);
    InitializeListHead(&g_leFreeAdapterList);

    //
    // Initialize the connection table
    //

    g_puipConnTable = RtAllocate(NonPagedPool,
                                 WAN_INIT_CONN_TABLE_SIZE * sizeof(ULONG_PTR),
                                 WAN_CONN_TAG);

    if(g_puipConnTable is NULL)
    {
        Trace(GLOBAL, ERROR,
              ("InitDriverStructures: Couldnt alloc conn table of %d bytes\n",
               WAN_INIT_CONN_TABLE_SIZE * sizeof(ULONG_PTR)));
    
        return FALSE;
    }

    RtlZeroMemory(g_puipConnTable,
                  WAN_INIT_CONN_TABLE_SIZE * sizeof(ULONG_PTR));

    g_ulConnTableSize = WAN_INIT_CONN_TABLE_SIZE;

    //
    // The first slot is never used
    //

    g_puipConnTable[0] = (ULONG_PTR)-1;

    g_ulNextConnIndex = 1;

    RtInitializeSpinLock(&g_rlConnTableLock);

    //
    // Initialize the lookaside list for connection entries
    //

    ExInitializeNPagedLookasideList(&g_llConnBlocks,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(CONN_ENTRY),
                                    WAN_CONN_TAG,
                                    WANARP_CONN_LOOKASIDE_DEPTH);

    ExInitializeNPagedLookasideList(&g_llNotificationBlocks,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(PENDING_NOTIFICATION),
                                    WAN_NOTIFICATION_TAG,
                                    WANARP_NOTIFICATION_LOOKASIDE_DEPTH);

    //
    // Create the buffer pools
    //

    InitBufferPool(&g_bpHeaderBufferPool,
                   HEADER_BUFFER_SIZE,
                   0,
                   20,
                   0,
                   TRUE,
                   WAN_HEADER_TAG);

    InitBufferPool(&g_bpDataBufferPool,
                   DATA_BUFFER_SIZE,
                   0,
                   10,
                   0,
                   TRUE,
                   WAN_DATA_TAG);

    g_bPoolsInitialized = TRUE;

    return TRUE;
}

#pragma alloc_text(PAGE, WanpInitializeNdis)

NDIS_STATUS
WanpInitializeNdis(
    VOID
    )
{
    NDIS_STATUS                     nsStatus;
    NDIS_PROTOCOL_CHARACTERISTICS   npcWanChar;
    
    TraceEnter(GLOBAL, "InitializeNdis");

    PAGED_CODE();

    RtlZeroMemory(&npcWanChar,
                  sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
    
    npcWanChar.MajorNdisVersion     = 4;
    npcWanChar.MinorNdisVersion     = 0;

    npcWanChar.Flags = 0;

    npcWanChar.OpenAdapterCompleteHandler   = WanNdisOpenAdapterComplete;
    npcWanChar.CloseAdapterCompleteHandler  = WanNdisCloseAdapterComplete;

    npcWanChar.SendCompleteHandler         = WanNdisSendComplete;

    npcWanChar.TransferDataCompleteHandler = WanNdisTransferDataComplete;

    npcWanChar.ResetCompleteHandler     = WanNdisResetComplete;
    npcWanChar.RequestCompleteHandler   = WanNdisRequestComplete;

    npcWanChar.ReceiveHandler           = WanNdisReceive;

    npcWanChar.ReceiveCompleteHandler   = WanNdisReceiveComplete;
    
    npcWanChar.StatusHandler            = WanNdisStatus;
    npcWanChar.StatusCompleteHandler    = WanNdisStatusComplete;

    npcWanChar.ReceivePacketHandler     = WanNdisReceivePacket;

    //
    // No bind handler needed
    //

    npcWanChar.BindAdapterHandler       = WanNdisBindAdapter;
    npcWanChar.UnbindAdapterHandler     = WanNdisUnbindAdapter;
    npcWanChar.PnPEventHandler          = WanNdisPnPEvent;
    npcWanChar.UnloadHandler            = WanNdisUnload;
    
    //
    // Allocate the Packet Pool
    //
   
    g_nhPacketPool = (NDIS_HANDLE)WAN_PACKET_TAG;
 
    NdisAllocatePacketPoolEx(&nsStatus,
                             &g_nhPacketPool,
                             WAN_PACKET_POOL_COUNT,
                             WAN_PACKET_POOL_OVERFLOW,
                             sizeof(struct PCCommon));
    
    if(nsStatus isnot NDIS_STATUS_SUCCESS)
    {
        Trace(GLOBAL, ERROR,
              ("InitializeNdis: Unable to allocate packet pool. %x\n",
               nsStatus));

        g_nhPacketPool = NULL;

        return nsStatus;
    }
    
    NdisSetPacketPoolProtocolId(g_nhPacketPool,
                                NDIS_PROTOCOL_ID_TCP_IP);

    RtlInitUnicodeString(&npcWanChar.Name,
                         WANARP_NDIS_NAME);

    //
    // THIS MUST BE THE LAST THING DONE
    //

    NdisRegisterProtocol(&nsStatus,
                         &g_nhWanarpProtoHandle,
                         &npcWanChar,
                         sizeof(npcWanChar));


    TraceLeave(GLOBAL, "InitializeNdis");

    return nsStatus;
}

#pragma alloc_text(PAGE, WanpDeinitializeNdis)

VOID
WanpDeinitializeNdis(
    VOID
    )
{
    NTSTATUS        nStatus;
    LARGE_INTEGER   liTimeOut;

    PAGED_CODE();

    WanpAcquireResource(&g_wrBindMutex);

    if(g_nhNdiswanBinding isnot NULL)
    {
        WanpCloseNdisWan(NULL);
    }
    else
    {
        WanpReleaseResource(&g_wrBindMutex);
    }

    //
    // wait on the close event
    //

    nStatus = KeWaitForSingleObject(&g_keCloseEvent,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL);

    //
    // Wait for a 5 secs to let the ndis thread finish its stuff
    //

    /*liTimeOut.QuadPart = (LONGLONG)(5 * 1000 * 1000 * 10 * -1);

    KeDelayExecutionThread(UserMode,
                           FALSE,
                           &liTimeOut);
    */

    if(g_nhPacketPool isnot NULL)
    {
        NdisFreePacketPool(g_nhPacketPool);

        g_nhPacketPool = NULL;
    }

    NdisDeregisterProtocol(&nStatus,
                           g_nhWanarpProtoHandle);

    g_nhWanarpProtoHandle = NULL;
}
       

VOID
WanNdisUnload(
    VOID
    )
{
    return;
}

#pragma alloc_text(PAGE, OpenRegKey)

NTSTATUS
OpenRegKey(
    OUT PHANDLE         phHandle,
    IN  PUNICODE_STRING pusKeyName
    )
{
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   ObjectAttributes;

    PAGED_CODE();

    RtlZeroMemory(&ObjectAttributes,
                  sizeof(OBJECT_ATTRIBUTES));

    InitializeObjectAttributes(&ObjectAttributes,
                               pusKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(phHandle,
                       KEY_READ,
                       &ObjectAttributes);

    return Status;
}


#pragma alloc_text(PAGE, GetRegDWORDValue)

NTSTATUS
GetRegDWORDValue(
    HANDLE           KeyHandle,
    PWCHAR           ValueName,
    PULONG           ValueData
    )
{
    NTSTATUS                    status;
    ULONG                       resultLength;
    PKEY_VALUE_FULL_INFORMATION keyValueFullInformation;
    UCHAR                       keybuf[128];
    UNICODE_STRING              UValueName;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    keyValueFullInformation = (PKEY_VALUE_FULL_INFORMATION)keybuf;
    RtlZeroMemory(keyValueFullInformation, sizeof(keyValueFullInformation));


    status = ZwQueryValueKey(KeyHandle,
                             &UValueName,
                             KeyValueFullInformation,
                             keyValueFullInformation,
                             128,
                             &resultLength);

    if (NT_SUCCESS(status)) {
        if (keyValueFullInformation->Type != REG_DWORD) {
            status = STATUS_INVALID_PARAMETER_MIX;
        } else {
            *ValueData = *((ULONG UNALIGNED *)((PCHAR)keyValueFullInformation +
                             keyValueFullInformation->DataOffset));
        }
    }

    return status;
}

BOOLEAN
IsEntryOnList(
    PLIST_ENTRY pleHead,
    PLIST_ENTRY pleEntry
    )
{
    PLIST_ENTRY pleNode;

    for(pleNode = pleHead->Flink;
        pleNode isnot pleHead;
        pleNode = pleNode->Flink)
    {
        if(pleNode is pleEntry)
        {
            return TRUE;
        }
    }

    return FALSE;
}

VOID
WanpInitializeResource(
    IN  PWAN_RESOURCE   pLock
    )
{
    pLock->lWaitCount = 0;

    KeInitializeEvent(&(pLock->keEvent),
                      SynchronizationEvent,
                      FALSE);
}

VOID
WanpAcquireResource(
    IN  PWAN_RESOURCE   pLock
    )
{
    LONG        lNumWaiters;
    NTSTATUS    nStatus;

    lNumWaiters = InterlockedIncrement(&(pLock->lWaitCount));

    RtAssert(lNumWaiters >= 1);

    if(lNumWaiters isnot 1)
    {
        nStatus = KeWaitForSingleObject(&(pLock->keEvent),
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);
    }
}

VOID
WanpReleaseResource(
    IN  PWAN_RESOURCE   pLock
    )
{
    LONG   lNumWaiters;

    lNumWaiters = InterlockedDecrement(&(pLock->lWaitCount));

    RtAssert(lNumWaiters >= 0);

    if(lNumWaiters isnot 0)
    {
        KeSetEvent(&(pLock->keEvent),
                   0,
                   FALSE);
    }
}

VOID
WanpClearPendingIrps(
    VOID
    )
    
/*++

Routine Description:

    Called at cleanup time to return any pending IRPs    

Locks:

    Acquires the IoCancelSpinLock since it controls the pending irp list

Arguments:

    None

Return Value:

    None

--*/

{
    KIRQL   irql;

    TraceEnter(GLOBAL, "ClearPendingIrps");

    IoAcquireCancelSpinLock (&irql);

    while(!IsListEmpty(&g_lePendingIrpList))
    {
        PLIST_ENTRY pleNode;
        PIRP        pIrp;

        pleNode = RemoveHeadList(&g_lePendingIrpList);

        pIrp = CONTAINING_RECORD(pleNode,
                                 IRP,
                                 Tail.Overlay.ListEntry);

        IoSetCancelRoutine(pIrp,
                           NULL);

        pIrp->IoStatus.Status       = STATUS_NO_SUCH_DEVICE;
        pIrp->IoStatus.Information  = 0;

        //
        // release lock to complete the IRP
        //

        IoReleaseCancelSpinLock(irql);

        IoCompleteRequest(pIrp,
                          IO_NETWORK_INCREMENT);

        //
        // Reaquire the lock
        //

        IoAcquireCancelSpinLock(&irql);
    }

    IoReleaseCancelSpinLock(irql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\guid.c ===
/*++

Copyright (c) 1998  Microsoft Corporation


Module Name:

    wanarp2\guid.c

Abstract:

    Cut-n-Paste of rtl\guid.c but without UNICODE_STRINGs and non paged

Revision History:

    AmritanR    Created

--*/

#define __FILE_SIG__    GUID_SIG

#include "inc.h"
#pragma hdrstop

#define GUID_FORMAT_W   L"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"

int
swprintf(wchar_t *buffer, const wchar_t *format,  ... );

int
__cdecl
ScanHexFormat(
    IN const WCHAR* pwszBuffer,
    IN ULONG        ulCharCount,
    IN const WCHAR* pwszFormat,
    ...
    )

/*++

Routine Description:

    Scans a source Buffer and places values from that buffer into the parameters
    as specified by Format.

Arguments:

    pwszBuffer  Source buffer which is to be scanned.

    ulCharCount Maximum length in characters for which Buffer is searched.
                This implies that Buffer need not be UNICODE_NULL terminated.

    Format      Format string which defines both the acceptable string form as
                contained in pwszBuffer


Return Value:

    Returns the number of parameters filled if the end of the Buffer is reached,
    else -1 on an error.

--*/
{
    va_list ArgList;
    int     iFormatItems;

    va_start(ArgList, pwszFormat);

    //
    // Count of number of parameters filled
    //

    iFormatItems = 0;

    while(TRUE)
    {
        switch (*pwszFormat) 
        {
            case UNICODE_NULL:
            {
                //
                // end of string
                //

                return (*pwszBuffer && ulCharCount) ? -1 : iFormatItems;
            }

            case L'%':
            {
                //
                // Format specifier
                //

                pwszFormat++;

                if (*pwszFormat != L'%') 
                {
                    ULONG   ulNumber;
                    int     iWidth;
                    int     iLong;
                    PVOID   pvPointer;

                    //
                    // So it isnt a %%
                    //

                    iLong = 0;
                    iWidth = 0;

                    while(TRUE)
                    {
                        if((*pwszFormat >= L'0') && 
                           (*pwszFormat <= L'9')) 
                        {
                            iWidth = iWidth * 10 + *pwszFormat - '0';
                        } 
                        else
                        {
                            if(*pwszFormat == L'l') 
                            {
                                iLong++;
                            } 
                            else 
                            {
                                if((*pwszFormat == L'X') || 
                                   (*pwszFormat == L'x')) 
                                {
                                    break;
                                }
                            }
                        }
                       
                        //
                        // Move to the next specifier
                        //
 
                        pwszFormat++;
                    }

                    pwszFormat++;

                    for(ulNumber = 0; iWidth--; pwszBuffer++, ulCharCount--) 
                    {
                        if(!ulCharCount)
                        {
                            return -1;
                        }

                        ulNumber *= 16;

                        if((*pwszBuffer >= L'0') && 
                           (*pwszBuffer <= L'9')) 
                        {
                            ulNumber += (*pwszBuffer - L'0');
                        } 
                        else
                        {
                            if((*pwszBuffer >= L'a') && 
                               (*pwszBuffer <= L'f')) 
                            {
                                ulNumber += (*pwszBuffer - L'a' + 10);
                            }
                            else
                            {
                                if((*pwszBuffer >= L'A') && 
                                   (*pwszBuffer <= L'F')) 
                                {
                                    ulNumber += (*pwszBuffer - L'A' + 10);
                                } 
                                else 
                                {
                                    return -1;
                                }
                            }
                        }
                    }

                    pvPointer = va_arg(ArgList, PVOID);

                    if(iLong) 
                    {
                        *(PULONG)pvPointer = ulNumber;
                    } 
                    else 
                    {
                        *(PUSHORT)pvPointer = (USHORT)ulNumber;
                    }

                    iFormatItems++;

                    break;
                }
           
                //
                // NO BREAK
                // 

            }

            default:
            {
                if (!ulCharCount || (*pwszBuffer != *pwszFormat))
                {
                    return -1;
                }

                pwszBuffer++;

                ulCharCount--;

                pwszFormat++;

                break;
            }
        }
    }
}

INT
ConvertGuidToString(
    IN  GUID    *pGuid,
    OUT PWCHAR  pwszBuffer
    )

/*++

Routine Description:

    Constructs the standard string version of a GUID, in the form:
    "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    pGuid       Contains the GUID to translate.

    pwszBuffer  Space for storing the string. Must be >= 39 * sizeof(WCHAR)

Return Value:


--*/

{
    return swprintf(pwszBuffer, 
                    GUID_FORMAT_W, 
                    pGuid->Data1, 
                    pGuid->Data2, 
                    pGuid->Data3, 
                    pGuid->Data4[0], 
                    pGuid->Data4[1], 
                    pGuid->Data4[2], 
                    pGuid->Data4[3], 
                    pGuid->Data4[4], 
                    pGuid->Data4[5], 
                    pGuid->Data4[6], 
                    pGuid->Data4[7]);
}

NTSTATUS
ConvertStringToGuid(
    IN  PWCHAR  pwszGuid,
    IN  ULONG   ulStringLen,
    OUT GUID    *pGuid
    )

/*++

Routine Description:

    Retrieves a the binary format of a textual GUID presented in the standard
    string version of a GUID: "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    GuidString -
        Place from which to retrieve the textual form of the GUID.

    Guid -
        Place in which to put the binary form of the GUID.

Return Value:

    Returns STATUS_SUCCESS if the buffer contained a valid GUID, else
    STATUS_INVALID_PARAMETER if the string was invalid.

--*/

{
    USHORT    Data4[8];
    int       Count;

    if (ScanHexFormat(pwszGuid,
                      ulStringLen/sizeof(WCHAR),
                      GUID_FORMAT_W,
                      &pGuid->Data1, 
                      &pGuid->Data2, 
                      &pGuid->Data3, 
                      &Data4[0], 
                      &Data4[1], 
                      &Data4[2], 
                      &Data4[3], 
                      &Data4[4], 
                      &Data4[5], 
                      &Data4[6], 
                      &Data4[7]) == -1) 
    {
        return STATUS_INVALID_PARAMETER;
    }

    for(Count = 0; Count < sizeof(Data4)/sizeof(Data4[0]); Count++) 
    {
        pGuid->Data4[Count] = (UCHAR)Data4[Count];
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\guid.h ===
/*++

Copyright (c) 1998  Microsoft Corporation


Module Name:

    wanarp2\guid.h

Abstract:

    Header for guid.c

Revision History:

    AmritanR    Created

--*/

#pragma once

INT
ConvertGuidToString(
    IN  GUID    *pGuid,
    OUT PWCHAR  pwszBuffer
    );

NTSTATUS
ConvertStringToGuid(
    IN  PWCHAR  pwszGuid,
    IN  ULONG   ulStringLen,
    OUT GUID    *pGuid
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\info.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    wanarp\info.c

Abstract:

    The file contains the code that is involved with setting and
    getting info for the adapters and interfaces

Revision History:

    AmritanR

--*/

#define __FILE_SIG__    INFO_SIG

#include "inc.h"



INT
WanIpSetRequest(
    PVOID       pvContext,
    NDIS_OID    Oid,
    UINT        Type
    )
{
    return NDIS_STATUS_SUCCESS;
}


UINT
WanIpAddAddress(
    IN  PVOID   pvContext,
    IN  UINT    uiType,
    IN  DWORD   dwAddress,
    IN  DWORD   dwMask,
    IN  PVOID   pvUnused
    )

/*++

Routine Description:

    This routine is called by the upper layer to add an address as a local
    address, or specify the broadcast address for this Interface

Locks:


Arguments:


Return Value:
    NO_ERROR

--*/

{
    TraceEnter(ADPT, "WanAddAddress");

    Trace(ADPT, TRACE,
          ("AddAddress: %d.%d.%d.%d\n", PRINT_IPADDR(dwAddress)));

    TraceLeave(ADPT, "WanAddAddress");
    
    return (UINT)TRUE;
}

UINT
WanIpDeleteAddress(
    IN  PVOID   pvContext,
    IN  UINT    uiType,
    IN  DWORD   dwAddress,
    IN  DWORD   dwMask
    )

/*++

Routine Description:

    Called to delete a local or proxy address.
    
Locks:


Arguments:


Return Value:
    NO_ERROR

--*/

{
    TraceEnter(ADPT, "WanDeleteAddress");

    Trace(ADPT, TRACE,
          ("DeleteAddress: %d.%d.%d.%d\n", PRINT_IPADDR(dwAddress)));

    TraceLeave(ADPT, "WanDeleteAddress");
    
    return TRUE;
}

INT
WanIpQueryInfo(
    IN  PVOID           pvIfContext,
    IN  TDIObjectID     *pTdiObjId,
    IN  PNDIS_BUFFER    pnbBuffer,
    IN  PUINT           puiSize,
    IN  PVOID           pvContext
    )

/*++

Routine Description:

    Routine is called by IP to query the MIB-II information related
    to the UMODE_INTERFACE. IP passes us a pointer to the ADAPTER. We map 
    it to the UMODE_INTERFACE using the ADAPTER and pass back the 
    statistics related to that UMODE_INTERFACE
    
Locks:

    We acquire the adapter lock and get a pointer to the interface from the
    adapter. We dont lock the interface because all the info copied
    out is changed by InterlockedXxx. Also because the adapter has a mapping
    from to the interface, the interface can not be deleted since to
    to bring the refcount on the interface to 0, this mapping needs to be
    cleared from the adapter, which needs the adapter lock, which we are
    holding

Arguments:

    pvIfContext     The context we returned to IP, a pointer to the ADAPTER
    pTdiObjId
    pnbBuffer
    puiSize
    pvContext
    
Return Value:
    
    TDI_INVALID_REQUEST
    TDI_INVALID_PARAMETER
    TDI_BUFFER_TOO_SMALL
    TDI_BUFFER_OVERFLOW
    TDI_SUCCESS
    
--*/

{
    PADAPTER    pAdapter;
    PUMODE_INTERFACE  pInterface;
    ULONG       ulOffset;
    ULONG       ulBufferSize;
    UINT        BytesCopied = 0;
    BYTE        rgbyInfoBuff[sizeof(IFEntry)];
    DWORD       dwEntity;
    DWORD	    dwInstance;
    IFEntry     *pIFE;
    NTSTATUS    nStatus;
    KIRQL       kiIrql;
    
    dwEntity   = pTdiObjId->toi_entity.tei_entity;
    dwInstance = pTdiObjId->toi_entity.tei_instance;
    pAdapter   = (PADAPTER)pvIfContext;
 
    //
    // We support only Interface MIBs - no address xlation - pretty much like
    // a loopback i/f (per Henry circa 1994)
    //

    if((dwEntity isnot IF_ENTITY) or
       (dwInstance isnot pAdapter->dwIfInstance))
    {
	    return TDI_INVALID_REQUEST;
    }

    if(pTdiObjId->toi_type isnot INFO_TYPE_PROVIDER)
    {
        Trace(ADPT, INFO,
              ("IpQueryInfo: toi_type is wrong 0x%x\n",
               pTdiObjId->toi_type));

	    return TDI_INVALID_PARAMETER;
    }

    //
    // a safe initialization.
    //

    ulBufferSize = *puiSize;
    *puiSize     = 0;
    ulOffset     = 0;

    if(pTdiObjId->toi_class is INFO_CLASS_GENERIC)
    {
	    if(pTdiObjId->toi_id isnot ENTITY_TYPE_ID)
        {
            Trace(ADPT, INFO,
                  ("IpQueryInfo: toi_id is wrong 0x%x\n",
                  pTdiObjId->toi_id));
        
            return TDI_INVALID_PARAMETER;
        }

        //
        // He's trying to see what type we are.
        //
        
        if(ulBufferSize < sizeof(DWORD))
        {
            Trace(ADPT, ERROR,
                  ("IpQueryInfo: Buffer size %d too small\n",
                   ulBufferSize));

	    	return TDI_BUFFER_TOO_SMALL;
        }    

        *(PDWORD)&rgbyInfoBuff[0] = (dwEntity is AT_ENTITY) ? AT_ARP : IF_MIB;

#if NDISBUFFERISMDL
       
        nStatus = TdiCopyBufferToMdl(rgbyInfoBuff,
                                     0,
                                     sizeof(DWORD),
                                     (PMDL)pnbBuffer,
                                     0,
                                     &ulOffset);

#else
#error "Fix this"
#endif
        
        *puiSize = ulOffset;
        
        return nStatus;

    }


    if(pTdiObjId->toi_class isnot INFO_CLASS_PROTOCOL)
    {
        Trace(ADPT, INFO,
              ("IpQueryInfo: toi_class is wrong 0x%x\n",
              pTdiObjId->toi_class));

	    return TDI_INVALID_PARAMETER;
    }

    //
    // The usermust be asking for Interface level information.
    // See if we support what is being asked for
    //

    if(pTdiObjId->toi_id isnot IF_MIB_STATS_ID)
    {
        Trace(ADPT, INFO,
              ("IpQueryInfo: toi_id 0x%x is not MIB_STATS\n",
              pTdiObjId->toi_id));

        return TDI_INVALID_PARAMETER;
    }

    //
    // He's asking for statistics. Make sure his buffer is at least big
    // enough to hold the fixed part.
    //
    
    if(ulBufferSize < IFE_FIXED_SIZE)
    {
        Trace(ADPT, ERROR,
              ("IpQueryInfo: Buffer size %d smaller than IFE %d\n",
               ulBufferSize, IFE_FIXED_SIZE));

        return TDI_BUFFER_TOO_SMALL;
    }

    //
    // He's got enough to hold the fixed part. Build the IFEntry structure,
    // and copy it to his buffer.
    //

    pAdapter = (PADAPTER)pvIfContext;

    pIFE = (IFEntry *)rgbyInfoBuff;

    RtlZeroMemory(pIFE,
                  sizeof(IFEntry));

    RtAcquireSpinLock(&(pAdapter->rlLock),
                      &kiIrql);

    //
    // This stuff doesnt require an interface to be mapped
    //

    pIFE->if_index       = pAdapter->dwAdapterIndex;
    pIFE->if_type        = IF_TYPE_PPP;
    pIFE->if_physaddrlen = ARP_802_ADDR_LENGTH;
    pIFE->if_outqlen     = pAdapter->ulQueueLen;
    pIFE->if_descrlen    = VENDOR_DESCRIPTION_STRING_LEN;

    RtlCopyMemory(pIFE->if_physaddr,
                  pAdapter->rgbyHardwareAddr,
                  ARP_802_ADDR_LENGTH);

    if(pAdapter->byState isnot AS_MAPPED)
    {
        Trace(ADPT, INFO,
              ("IpQueryInfo: called for adapter %x that is unmapped\n",
               pAdapter));

#if 0
        RtReleaseSpinLock(&(pAdapter->rlLock),
                          kiIrql);

        return TDI_INVALID_PARAMETER;
#endif
    }
    else
    {
        //
        // Get a pointer to the interface and lock the interface
        //
    
        pInterface = pAdapter->pInterface;

        RtAssert(pInterface);
    
        if(pAdapter->pConnEntry is NULL)
        { 
            //
            // If a mapped adapter doesnt have an associated connection, then
            // it is either server adapter or router in process of connecting
            //

            RtAssert((pInterface->duUsage is DU_CALLIN) or
                     ((pInterface->duUsage is DU_ROUTER) and
                      (pInterface->dwOperState is IF_OPER_STATUS_CONNECTING)));

            pIFE->if_mtu     = WANARP_DEFAULT_MTU;
            pIFE->if_speed   = WANARP_DEFAULT_SPEED;
        }
        else
        {
            pIFE->if_mtu     = pAdapter->pConnEntry->ulMtu;
            pIFE->if_speed   = pAdapter->pConnEntry->ulSpeed;
        }
    
        pIFE->if_adminstatus     = pInterface->dwAdminState;
        pIFE->if_operstatus      = pInterface->dwOperState;
        pIFE->if_lastchange      = pInterface->dwLastChange;
        pIFE->if_inoctets        = pInterface->ulInOctets;
        pIFE->if_inucastpkts     = pInterface->ulInUniPkts;
        pIFE->if_innucastpkts    = pInterface->ulInNonUniPkts;
        pIFE->if_indiscards      = pInterface->ulInDiscards;
        pIFE->if_inerrors        = pInterface->ulInErrors;
        pIFE->if_inunknownprotos = pInterface->ulInUnknownProto;
        pIFE->if_outoctets       = pInterface->ulOutOctets;
        pIFE->if_outucastpkts    = pInterface->ulOutUniPkts;
        pIFE->if_outnucastpkts   = pInterface->ulOutNonUniPkts;
        pIFE->if_outdiscards     = pInterface->ulOutDiscards;
        pIFE->if_outerrors       = pInterface->ulOutErrors;
    }
    
#if NDISBUFFERISMDL

    nStatus = TdiCopyBufferToMdl(pIFE,
                                 0,
                                 IFE_FIXED_SIZE,
                                 (PMDL)pnbBuffer,
                                 0,
                                 &ulOffset);

#else
#error "Fix this"
#endif
 
    //
    // See if he has room for the descriptor string.
    //
    
    if(ulBufferSize < (IFE_FIXED_SIZE + VENDOR_DESCRIPTION_STRING_LEN))
    {
        Trace(ADPT, INFO,
              ("IpQueryInfo: Buffer size %d too small for VENDOR string\n",
               ulBufferSize));

        //
        // Not enough room to copy the desc. string.
        //
        
        *puiSize = IFE_FIXED_SIZE;

        RtReleaseSpinLock(&(pAdapter->rlLock),
                          kiIrql);
        
        return TDI_BUFFER_OVERFLOW;
    }

#if NDISBUFFERISMDL

    nStatus = TdiCopyBufferToMdl(VENDOR_DESCRIPTION_STRING,
                                 0,
                                 strlen(VENDOR_DESCRIPTION_STRING)+1,
                                 (PMDL)pnbBuffer,
                                 ulOffset,
                                 &ulOffset);

#else
#error "Fix this"
#endif
    
    *puiSize = IFE_FIXED_SIZE + VENDOR_DESCRIPTION_STRING_LEN;

    RtReleaseSpinLock(&(pAdapter->rlLock),
                      kiIrql);
    
    return TDI_SUCCESS;

}

INT
WanIpSetInfo(
    IN  PVOID       pvContext,
    IN  TDIObjectID *pTdiObjId,
    IN  PVOID       pvBuffer,
    IN  UINT        uiSize
    )

/*++

Routine Description:

    The set info routine. We dont do anything here

Locks:

    None because we arent changing anything

Arguments:

    pvContext
    pTdiObjId
    pvBuffer
    uiSize

Return Value:

    TDI_INVALID_REQUEST
    TDI_INVALID_PARAMETER
    TDI_BUFFER_TOO_SMALL
    TDI_SUCCESS
    
--*/

{
    INT         iStatus;
    IFEntry     *pIFE;
    DWORD       dwEntity;
    DWORD       dwInstance;
    PADAPTER    pAdapter;

    pIFE        = (IFEntry *)pvBuffer;
    dwEntity    = pTdiObjId->toi_entity.tei_entity;
    dwInstance  = pTdiObjId->toi_entity.tei_instance;
    pAdapter    = (PADAPTER)pvContext;

    //
    // Might be able to handle this.
    //

    if((dwEntity isnot IF_ENTITY) or
       (dwInstance isnot pAdapter->dwIfInstance))
    {
        return TDI_INVALID_REQUEST;
    }
    
    //
    // It's for the I/F level, see if it's for the statistics.
    //
    
    if (pTdiObjId->toi_class isnot INFO_CLASS_PROTOCOL)
    {
        Trace(ADPT, INFO,
              ("WanSetInfo: toi_class is wrong 0x%x\n",
              pTdiObjId->toi_class));

        return TDI_INVALID_PARAMETER;
    }

    if (pTdiObjId->toi_id isnot IF_MIB_STATS_ID)
    {
        Trace(ADPT, INFO,
              ("WanSetInfo: toi_id 0x%x is not MIB_STATS\n",
              pTdiObjId->toi_id));

        return TDI_INVALID_PARAMETER;
    }
    
    //
    // It's for the stats. Make sure it's a valid size.
    //

    if(uiSize < IFE_FIXED_SIZE)
    {
        Trace(ADPT, ERROR,
              ("WanSetInfo: Buffer size %d too small\n",
               uiSize));

        return TDI_BUFFER_TOO_SMALL;
    }
    
    //
    // We dont allow any sets on the adapters.
    // The only sets are via interfaces and those need to be done
    // using the IOCTLs. We could potentially allow sets on the UMODE_INTERFACE
    // that the adapter is mapped too, but that would be just another way
    // of achieving what the IOCTLS do
    //

    return TDI_SUCCESS;
}

INT
WanIpGetEntityList(
    IN  PVOID       pvContext,
    IN  TDIEntityID *pTdiEntityList,
    IN  PUINT       puiCount
    )

/*++

Routine Description:

    Called by IP to assign us a TDI entity id    

Locks:

    Takes the adapter lock.

Arguments:

    pvContext,
    pTdiEntityList,
    puiCount

Return Value:


--*/

{
    PADAPTER    pAdapter;
    UINT		uiEntityCount;
    UINT		uiMyIFBase;
    UINT		i;
    TDIEntityID *pTdiIFEntity;
    KIRQL       kiIrql;

    
    pAdapter = (PADAPTER)pvContext;

    RtAcquireSpinLock(&(pAdapter->rlLock),
                      &kiIrql);
    
    //
	// Walk down the list, looking for existing IF entities, and
	// adjust our base instance accordingly.
    //
    

    uiMyIFBase   = 0;
    pTdiIFEntity = NULL;
    
	for(i = 0;
        i < *puiCount;
        i++, pTdiEntityList++)
    {
		if(pTdiEntityList->tei_entity is IF_ENTITY)
        {
            //
            // if we are already on the list remember our entity item
            // o/w find an instance # for us.
            //
            
            if((pTdiEntityList->tei_instance is pAdapter->dwIfInstance) and
               (pTdiEntityList->tei_instance isnot INVALID_ENTITY_INSTANCE))
            {
                //
                // Matched our instance
                //
                
                pTdiIFEntity  = pTdiEntityList;
                
                break;
            }
            else
            {
                //
                // Take the max of the two
                //
                
                uiMyIFBase = uiMyIFBase > (pTdiEntityList->tei_instance + 1)?
                             uiMyIFBase : (pTdiEntityList->tei_instance + 1);
                
            }
        }
	}
	
    if(pTdiIFEntity is NULL )
    {
        //
        // we are not on the list.
        // make sure we have the room for it.
        //
        
        if (*puiCount >= MAX_TDI_ENTITIES)
        {
            return FALSE;
        }
        
        pAdapter->dwIfInstance = uiMyIFBase;

        //
        // Now fill it in.
        //
        
        pTdiEntityList->tei_entity   = IF_ENTITY;
        pTdiEntityList->tei_instance = uiMyIFBase;
        
        (*puiCount)++;
        
    }
    else
    {
        if(pAdapter->byState is AS_REMOVING)
        {
            //
            // If we are going away, remove our instance
            //

            pAdapter->dwIfInstance       = INVALID_ENTITY_INSTANCE;
            pTdiEntityList->tei_instance = INVALID_ENTITY_INSTANCE;
        }
    }

    RtReleaseSpinLock(&(pAdapter->rlLock),
                      kiIrql);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\rwlock.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tcpip\ip\ipmlock.h

Abstract:

    Reader Writer lock primitives for the IP Multicasting

Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/

//
// Need to include "debug.h" before this file is included because
// RT_LOCK is defined there
//

//
// A reader writer lock for kernel mode.
//

typedef struct _RW_LOCK
{
    RT_LOCK rlReadLock;
    RT_LOCK rlWriteLock;
    LONG    lReaderCount;
}RW_LOCK, *PRW_LOCK;

//
// VOID
// InitRwLock(
//  PRW_LOCK    pLock
//  )
//
//  Initializes the spin locks and the reader count
//


#define InitRwLock(l)                                           \
    RtInitializeSpinLock(&((l)->rlReadLock));                   \
    RtInitializeSpinLock(&((l)->rlWriteLock));                  \
    (l)->lReaderCount = 0
        
//
// VOID
// EnterReader(
//  PRW_LOCK    pLock,
//  PKIRQL      pCurrIrql 
//  )
//
// Acquires the Reader Spinlock (now thread is at DPC). 
// InterlockedIncrements the reader count (interlocked because the reader 
// lock is not taken when the count is decremented in ExitReader())
// If the thread is the first reader, also acquires the Writer Spinlock (at
// DPC to be more efficient) to block writers
// Releases the Reader Spinlock from DPC, so that it remains at DPC
// for the duration of the lock being held 
//
// If a writer is in the code, the first reader will wait on the Writer
// Spinlock and all subsequent readers will wait on the Reader Spinlock
// If a reader is in the code and is executing the EnterReader, then a new
// reader will wait for sometime on the Reader Spinlock, and then proceed
// on to the code (at DPC)
//



#define EnterReader(l, q)                                       \
    RtAcquireSpinLock(&((l)->rlReadLock), (q));                 \
    if(InterlockedIncrement(&((l)->lReaderCount)) == 1)         \
        RtAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock));       \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlReadLock))

#define EnterReaderAtDpcLevel(l)                                \
    RtAcquireSpinLockAtDpcLevel(&((l)->rlReadLock));            \
    if(InterlockedIncrement(&((l)->lReaderCount)) == 1)         \
        RtAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock));       \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlReadLock))

//
// VOID
// ExitReader(
//  PRW_LOCK    pLock,
//  KIRQL       kiOldIrql
//  )
//
// InterlockedDec the reader count.
// If this is the last reader, then release the Writer Spinlock to let
// other writers in
// Otherwise, just lower the irql to what was before the lock was
// acquired.  Either way, the irql is down to original irql
//

#define ExitReader(l, q)                                        \
    if(InterlockedDecrement(&((l)->lReaderCount)) == 0)         \
        RtReleaseSpinLock(&((l)->rlWriteLock), q);              \
    else                                                        \
        KeLowerIrql(q)

#define ExitReaderFromDpcLevel(l)                               \
    if(InterlockedDecrement(&((l)->lReaderCount)) == 0)         \
        RtReleaseSpinLockFromDpcLevel(&((l)->rlWriteLock))

//
// EnterWriter(
//  PRW_LOCK    pLock,
//  PKIRQL      pCurrIrql
//  )
//
// Acquire the reader and then the writer spin lock
// If there  are readers in the code, the first writer will wait
// on the Writer Spinlock.  All other writers will wait (with readers)
// on the Reader Spinlock
// If there is a writer in the code then a new writer will wait on 
// the Reader Spinlock

#define EnterWriter(l, q)                                       \
    RtAcquireSpinLock(&((l)->rlReadLock), (q));                 \
    RtAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock))

#define EnterWriterAtDpcLevel(l)                                \
    RtAcquireSpinLockAtDpcLevel(&((l)->rlReadLock));            \
    RtAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock))


//
// ExitWriter(
//  PRW_LOCK    pLock,
//  KIRQL       kiOldIrql
//  )
//
// Release both the locks
//

#define ExitWriter(l, q)                                        \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlWriteLock));         \
    RtReleaseSpinLock(&((l)->rlReadLock), q)


#define ExitWriterFromDpcLevel(l)                               \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlWriteLock));         \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlReadLock))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\info.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    wanarp\info.h

Abstract:

    Header for info.c

Revision History:

    AmritanR

--*/

#ifndef __WANARP_INFO_H__
#define __WANARP_INFO_H__

NDIS_STATUS
DoNDISRequest(NDIS_REQUEST_TYPE RT, NDIS_OID OID, void *Info, uint Length, uint
*Needed);

int
WanIpSetRequest(
    PVOID       pvContext,
    NDIS_OID    Oid,
    UINT        Type
    );

UINT
WanIpAddAddress(
    IN  PVOID   pvContext,
    IN  UINT    uiType,
    IN  DWORD   dwAddress,
    IN  DWORD   dwMask,
    IN  PVOID   pvUnused
    );

UINT
WanIpDeleteAddress(
    IN  PVOID   pvContext,
    IN  UINT    uiType,
    IN  DWORD   dwAddress,
    IN  DWORD   dwMask
    );

INT
WanIpQueryInfo(
    IN  PVOID           pvIfContext,
    IN  TDIObjectID     *pTdiObjId,
    IN  PNDIS_BUFFER    pnbBuffer,
    IN  PUINT           puiSize,
    IN  PVOID           pvContext
    );

INT
WanIpSetInfo(
    IN  PVOID       pvContext,
    IN  TDIObjectID *pTdiObjId,
    IN  PVOID       pvBuffer,
    IN  UINT        uiSize
    );

INT
WanIpGetEntityList(
    IN  PVOID       pvContext,
    IN  TDIEntityID *pTdiEntityList,
    IN  PUINT       puiCount
    );




#endif // __WANARP_INFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\ioctl.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\wanarp\ioctl.c

Abstract:

    Header for ioctl.c

Revision History:

   Amritansh Raghav 

--*/


//
// Notification events
//

typedef struct _PENDING_NOTIFICATION
{
    LIST_ENTRY          leNotificationLink;

    WORK_QUEUE_ITEM     wqi;

    WANARP_NOTIFICATION wnMsg;

}PENDING_NOTIFICATION, *PPENDING_NOTIFICATION;

// 
// The lookaside list for notifications
//

extern NPAGED_LOOKASIDE_LIST    g_llNotificationBlocks;

#define WANARP_NOTIFICATION_LOOKASIDE_DEPTH     4

//++
//
//  PPENDING_NOTIFICATION
//  AllocateNotification(
//      VOID
//      )
//
//  Allocate a notification blob from g_llNotificationBlocks
//
//--

#define AllocateNotification()              \
            ExAllocateFromNPagedLookasideList(&g_llNotificationBlocks)

//++
//
//  VOID
//  FreeNotification(
//      PPENDING_NOTIFICATION   pMsg
//      )
//
//  Free a notification blob to g_llNotificationBlocks
//
//--

#define FreeNotification(n)                 \
            ExFreeToNPagedLookasideList(&g_llNotificationBlocks, (n))


//
// List of pending notifications
//

LIST_ENTRY  g_lePendingNotificationList;

//
// List of pending IRPs
//

LIST_ENTRY  g_lePendingIrpList;


//
// Set to true if we want to queue notifications
//

BOOLEAN     g_bQueueNotifications;

NTSTATUS
WanProcessNotification(
    PIRP    pIrp,
    ULONG   ulInLength,
    ULONG   ulOutLength
    );

NTSTATUS
WanAddUserModeInterface(
    PIRP   pIrp,
    ULONG  ulInLength,
    ULONG  ulOutLength
    );

NTSTATUS
WanDeleteUserModeInterface(
    PIRP    pIrp,
    ULONG   ulInLength,
    ULONG   ulOutLength
    );

VOID
WanpCleanOutInterfaces(
    VOID
    );

VOID
WanpDeleteInterface(
    PUMODE_INTERFACE    pInterface
    );

NTSTATUS
WanDeleteAdapters(
    PIRP    pIrp,
    ULONG   ulInLength,
    ULONG   ulOutLength
    );

NTSTATUS
WanProcessConnectionFailure(
    PIRP   pIrp,
    ULONG  ulInLength,
    ULONG  ulOutLength
    );

NTSTATUS
WanGetIfStats(
    PIRP     pIrp,
    ULONG    ulInLength,
    ULONG    ulOutLength
    );

NTSTATUS
WanMapServerAdapter(
    PIRP     pIrp,
    ULONG    ulInLength,
    ULONG    ulOutLength
    );

NTSTATUS
WanStartStopQueuing(
    PIRP    pIrp,
    ULONG   ulInLength,
    ULONG   ulOutLength
    );

VOID
WanCancelNotificationIrp(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp
    );

VOID
WanpCompleteIrp(
    PPENDING_NOTIFICATION    pEvent
    );

NTSTATUS
WanpGetNewIndex(
    OUT PULONG  pulIndex
    );

VOID
WanpFreeIndex(
    IN  ULONG   ulIndex
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\rcv.c ===
/*++

Copyright (c) 1995  Microsoft Corporation


Module Name:

    net\routing\ip\wanarp2\rcv.c

Abstract:



Revision History:


--*/


#define __FILE_SIG__    RCV_SIG

#include "inc.h"

INT
WanNdisReceivePacket(
    IN NDIS_HANDLE  nhProtocolContext,
    IN PNDIS_PACKET pnpPacket
    )
{
    PNDIS_BUFFER    pnbBuffer;
    PVOID           pvFirstBuffer;
    UINT            uiFirstBufLen, uiTotalPacketLen;
    INT             iClientCount;
    NDIS_STATUS     nsStatus;

    TraceEnter(RCV, "NdisReceivePacket");

    NdisGetFirstBufferFromPacket(pnpPacket,
                                 &pnbBuffer,
                                 &pvFirstBuffer,
                                 &uiFirstBufLen,
                                 &uiTotalPacketLen);
    if (pvFirstBuffer==NULL)
        return 0;
        

    //
    // The first buffer better contain enough data
    //

    if (uiFirstBufLen < sizeof(ETH_HEADER) + sizeof(IP_HEADER))
        return 0;

    iClientCount = 0;

    nsStatus = WanReceiveCommon(nhProtocolContext,
                                pnpPacket,
                                pvFirstBuffer,
                                sizeof(ETH_HEADER),
                                (PVOID)((ULONG_PTR)pvFirstBuffer + sizeof(ETH_HEADER)),
                                uiFirstBufLen - sizeof(ETH_HEADER),
                                uiTotalPacketLen - sizeof(ETH_HEADER),
                                pnbBuffer,
                                &iClientCount);

    return iClientCount;
}

NDIS_STATUS
WanNdisReceive(
    NDIS_HANDLE     nhProtocolContext,
    NDIS_HANDLE     nhXferContext,
    VOID UNALIGNED  *pvHeader,
    UINT            uiHeaderLen,
    VOID UNALIGNED  *pvData,
    UINT            uiFirstBufferLen,
    UINT            uiTotalDataLen
    )
{
    TraceEnter(RCV, "NdisReceive");

    return WanReceiveCommon(nhProtocolContext,
                            nhXferContext,
                            pvHeader,
                            uiHeaderLen,
                            pvData,
                            uiFirstBufferLen,
                            uiTotalDataLen,
                            NULL,
                            NULL);
}

NDIS_STATUS
WanReceiveCommon(
    NDIS_HANDLE     nhProtocolContext,
    NDIS_HANDLE     nhXferContext,
    VOID UNALIGNED  *pvHeader,
    UINT            uiHeaderLen,
    VOID UNALIGNED  *pvData,
    UINT            uiFirstBufferLen,
    UINT            uiTotalDataLen,
    PMDL            pMdl,
    PINT            piClientCount
    )

/*++

Routine Description:

    The common receive handler for packet based or buffer based receives

Locks:

    Called at DPC (usually).
    Acquires the g_rlConnTable lock to get a pointer to the connection
    entry. Then locks either the entry itself or the adapter.

Arguments:

    nhProtocolContext
    nhXferContext
    pvHeader
    uiHeaderLen
    pvData
    uiFirstBufferLen
    uiTotalDataLen
    pMdl
    piClientCount

Return Value:

    NDIS_STATUS_NOT_ACCEPTED

--*/

{
    PCONN_ENTRY         pConnEntry;
    PADAPTER            pAdapter;
    PUMODE_INTERFACE    pInterface;
    ETH_HEADER UNALIGNED *pEthHeader;
    KIRQL               kiIrql;
    WORD                wType;
    ULONG               ulIndex;
    BOOLEAN             bNonUnicast;

#if DBG

    IP_HEADER UNALIGNED *pIpHeader;

#endif

    //
    // Pick out connection index from the buffer
    //

    pEthHeader = (ETH_HEADER UNALIGNED *)pvHeader;

    ulIndex = GetConnIndexFromAddr(pEthHeader->rgbyDestAddr);

    RtAcquireSpinLock(&g_rlConnTableLock,
                      &kiIrql);

    if(ulIndex >= g_ulConnTableSize)
    {
        Trace(RCV, ERROR,
              ("ReceiveCommon: Invalid index for conn entry %d\n",
               ulIndex));

        RtReleaseSpinLock(&g_rlConnTableLock,
                          kiIrql);

        return NDIS_STATUS_NOT_ACCEPTED;
    }
    
    pConnEntry = GetConnEntryGivenIndex(ulIndex);

    if(pConnEntry is NULL)
    {
        Trace(RCV, ERROR,
              ("ReceiveCommon: Couldnt find entry for conn %d\n",
               ulIndex));

        RtReleaseSpinLock(&g_rlConnTableLock,
                          kiIrql);

        return NDIS_STATUS_NOT_ACCEPTED;
    }

    //
    // Lock the connection entry or adapter
    //

    RtAcquireSpinLockAtDpcLevel(pConnEntry->prlLock);

    RtReleaseSpinLockFromDpcLevel(&g_rlConnTableLock);

    //
    // We can get this only on a connected entry
    //

    RtAssert(pConnEntry->byState is CS_CONNECTED);

    pAdapter = pConnEntry->pAdapter;

    //
    // A connected entry must have an adapter
    //

    RtAssert(pAdapter);

    //
    // The interface better also be present
    //

    pInterface = pAdapter->pInterface;

    RtAssert(pInterface);

    if(pConnEntry->duUsage isnot DU_CALLIN)
    {
        //
        // For non clients, also lock the interface
        //

        RtAcquireSpinLockAtDpcLevel(&(pInterface->rlLock));
    }

#if DBG

    Trace(RCV, INFO,
          ("ReceiveCommon: Extracted adapter %x with name %s\n",
           pAdapter,
           pAdapter->asDeviceNameA.Buffer));

    pIpHeader = (IP_HEADER UNALIGNED *)pvData;

    RtAssert((pIpHeader->byVerLen & 0xF0) is 0x40);
    RtAssert(LengthOfIpHeader(pIpHeader) >= 20);

    //
    // If the packet is not fragmented, then the data from its header
    // should be <= the data ndis gives us (<= because there may be
    // padding and ndis may be giving us trailing bytes)
    //

    //RtAssert(RtlUshortByteSwap(pIpHeader->wLength) <= uiTotalDataLen);

#endif

    //
    // Increment some stats. For the server interface, these can be
    // inconsistent
    //

    pInterface->ulInOctets += (uiTotalDataLen + uiHeaderLen);

    //
    // Verify this is a well formed packet
    //

    wType = RtlUshortByteSwap(pEthHeader->wType);

    if(wType isnot ARP_ETYPE_IP)
    {
        pInterface->ulInUnknownProto++;

        Trace(RCV, ERROR,
              ("ReceiveCommon: Type %d is wrong\n", wType));

        if(pConnEntry->duUsage isnot DU_CALLIN)
        {
            RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));
        }

        RtReleaseSpinLock(pConnEntry->prlLock,
                          kiIrql);

        DereferenceConnEntry(pConnEntry);

        return NDIS_STATUS_NOT_RECOGNIZED;
    }

    //
    // Need to figure out if this is a unicast or a broadcast. At the
    // link layer we dont have a concept of broadcast. So, we always mark
    // this as unicast. We can be smarter about this and look at the
    // IPHeader and decide based on the IP dest addr
    //

    bNonUnicast = FALSE;

    pInterface->ulInUniPkts++;

    //
    // Check if the filtering of the Netbios packets is enabled on this
    // connection. If so then do not indicate the packet.
    //

    if((pConnEntry->bFilterNetBios is TRUE) and
       (WanpDropNetbiosPacket((PBYTE)pvData,uiFirstBufferLen)))
    {
        pInterface->ulInDiscards++;

        Trace(RCV, TRACE,
              ("ReceiveCommon: Dropping Netbios packet\n", wType));

        if(pConnEntry->duUsage isnot DU_CALLIN)
        {
            RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));
        }

        RtReleaseSpinLock(pConnEntry->prlLock,
                          kiIrql);

        DereferenceConnEntry(pConnEntry);

        return NDIS_STATUS_NOT_ACCEPTED;
    }

    //
    // Release the lock BEFORE we tell IP
    //

    if(pConnEntry->duUsage isnot DU_CALLIN)
    {
        RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));
    }

    RtReleaseSpinLock(pConnEntry->prlLock,
                      kiIrql);

#if PKT_DBG

    Trace(RCV, ERROR,
          ("ReceiveCommon: \nMdl %x Pkt %x Hdr %x Data %x\n",
           pMdl,
           nhXferContext,
           pvHeader,
           pvData));

#endif // PKT_DBG

    if(pMdl)
    {
        g_pfnIpRcvPkt(pAdapter->pvIpContext,
                      (PBYTE)pvData,
                      uiFirstBufferLen,
                      uiTotalDataLen,
                      nhXferContext,
                      0,
                      bNonUnicast,
                      sizeof(ETH_HEADER),
                      pMdl,
                      piClientCount,
                      pConnEntry->pvIpLinkContext);
    }
    else
    {
        g_pfnIpRcv(pAdapter->pvIpContext,
                   (PBYTE)pvData,
                   uiFirstBufferLen,
                   uiTotalDataLen,
                   nhXferContext,
                   0,
                   bNonUnicast,
                   pConnEntry->pvIpLinkContext);
    }

    DereferenceConnEntry(pConnEntry);

    return NDIS_STATUS_SUCCESS;
}


VOID
WanNdisReceiveComplete(
    NDIS_HANDLE nhBindHandle
    )
{
    TraceEnter(RCV, "NdisReceiveComplete");

    g_pfnIpRcvComplete();
}

NDIS_STATUS
WanIpTransferData(
    PVOID        pvContext,
    NDIS_HANDLE  nhMacContext,
    UINT         uiProtoOffset,
    UINT         uiTransferOffset,
    UINT         uiTransferLength,
    PNDIS_PACKET pnpPacket,
    PUINT        puiTransferred
    )
{
    RtAssert(FALSE);

    return NDIS_STATUS_SUCCESS;
}

VOID
WanNdisTransferDataComplete(
    NDIS_HANDLE     nhProtocolContext,
    PNDIS_PACKET    pnpPacket,
    NDIS_STATUS     nsStatus,
    UINT            uiBytesCopied
    )
{
    RtAssert(FALSE);

    return;
}

UINT
WanIpReturnPacket(
    PVOID           pvContext,
    PNDIS_PACKET    pnpPacket
    )
{
    Trace(RCV, ERROR,
          ("IpReturnPacket: %x\n",
           pnpPacket));

    NdisReturnPackets(&pnpPacket,
                      1);

    return TRUE;
}

BOOLEAN
WanpDropNetbiosPacket(
    PBYTE       pbyBuffer,
    ULONG       ulBufferLen
    )
{
    IP_HEADER UNALIGNED *pIpHeader;
    PBYTE               pbyUdpPacket;
    WORD                wSrcPort;
    ULONG               ulIpHdrLen;

    pIpHeader = (IP_HEADER UNALIGNED *)pbyBuffer;

    if(pIpHeader->byProtocol is 0x11)
    {
        ulIpHdrLen = LengthOfIpHeader(pIpHeader);

        //
        // If we cant get to the 10th byte in the UDP packet in this
        // buffer, we just let the packet go
        //

        if(ulBufferLen < ulIpHdrLen + 10)
        {
            return FALSE;
        }

        pbyUdpPacket = (PBYTE)((ULONG_PTR)pbyBuffer + ulIpHdrLen);

        wSrcPort = *((WORD UNALIGNED *)pbyUdpPacket);

        if(wSrcPort is PORT137_NBO)
        {
            //
            // UDP port 137 is NETBIOS/IP traffic
            //

            //
            // Allow only WINS Query Requests to go through
            // WINS Query packets have x0000xxx in the 10th byte
            //

            if(((*(pbyUdpPacket + 10)) & 0x78) isnot 0)
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\ref.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    wanarp2\ref.h

Abstract:

    Generic structure referencing routines
    All these routines assume that the structure has the following field:

    LONG    lRefCount

    setting REF_DEBUG to 1 results in noisy output about when a structure
    is referenced and derefenced

Revision History:

   Amritansh Raghav

--*/


#if REF_DEBUG


#define InitStructureRefCount(s, p, r)                          \
{                                                               \
    DbgPrint("\n<>%s refcount set to %d for %x (%s, %d)\n\n",   \
             s, (r), (p), __FILE__, __LINE__);                  \
    (p)->lRefCount = r;                                         \
}

#define ReferenceStructure(s, p)                                \
{                                                               \
    DbgPrint("\n++Ref %s %x to %d (%s, %d)\n\n",                \
             s, p, InterlockedIncrement(&((p)->lRefCount)),     \
             __FILE__, __LINE__);                               \
}

#define DereferenceStructure(s, p, f)                           \
{                                                               \
    LONG __lTemp;                                               \
    __lTemp = InterlockedDecrement(&((p)->lRefCount));          \
    DbgPrint("\n--Deref %s %x to %d (%s, %d)\n\n",              \
             s, (p), __lTemp, __FILE__, __LINE__);              \
    if(__lTemp == 0)                                            \
    {                                                           \
         DbgPrint("\n>< Deleting %s at %x\n\n",                 \
                  s, (p));                                      \
        (f)((p));                                               \
    }                                                           \
}


#else // REF_DEBUG


#define InitStructureRefCount(s, p, r)                          \
    (p)->lRefCount = (r)

#define ReferenceStructure(s, p)                                \
    InterlockedIncrement(&((p)->lRefCount))

#define DereferenceStructure(s, p, f)                           \
{                                                               \
    if(InterlockedDecrement(&((p)->lRefCount)) == 0)            \
    {                                                           \
        (f)((p));                                               \
    }                                                           \
}


#endif // REF_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\ioctl.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\wanarp\ioctl.c

Abstract:

    IOCTL handlers for wanarp 

Revision History:

    AmritanR

--*/

#define __FILE_SIG__    IOCTL_SIG

#include "inc.h"


NTSTATUS
WanProcessNotification(
    PIRP    pIrp,
    ULONG   ulInLength,
    ULONG   ulOutLength
    )

/*++

Routine Description:
      
    The handler for IOCTL_WANARP_NOTIFICATION. We see if we have some info
    we wish to return to the caller and if we do, we return it. Otherwise,
    we pend the IRP and use it later when we need to report an event to
    the user mode
    
Locks: 

    Acquires the IoCancelSpinLock
    
Arguments:
      
    
Return Value:

    STATUS_PENDING
    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL
    
--*/

{
    KIRQL       kiIrql;
    PLIST_ENTRY pleNode;
    PVOID       pvIoBuffer;
    
    PPENDING_NOTIFICATION   pNotification;

    TraceEnter(CONN, "ProcessNotification");
 
    pvIoBuffer   = pIrp->AssociatedIrp.SystemBuffer;
    
    pIrp->IoStatus.Information = 0;

    if((ulInLength < sizeof(WANARP_NOTIFICATION)) or
       (ulOutLength < sizeof(WANARP_NOTIFICATION)))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }
    
        
    //
    // use cancel spin lock to prevent irp being cancelled during this call.
    //
    
    IoAcquireCancelSpinLock(&kiIrql);
    
    //
    // If we have a pending notification then complete it - else
    // queue the notification IRP
    //
    
    if(!IsListEmpty(&g_lePendingNotificationList))
    {
        //
        // We have some old info
        //

        Trace(GLOBAL, TRACE,
              ("ProcNotification: Pending notification being completed\n"));

        //
        // Remove it off the pending list
        //
        
        pleNode = RemoveHeadList(&g_lePendingNotificationList);

        //
        // Get a pointer to the structure
        //
        
        pNotification = CONTAINING_RECORD(pleNode,
                                          PENDING_NOTIFICATION,
                                          leNotificationLink);

        //
        // Copy out the event to the user mode buffer
        //
        
        RtlCopyMemory(pIrp->AssociatedIrp.SystemBuffer,
                      &pNotification->wnMsg,
                      sizeof(WANARP_NOTIFICATION));

        //
        // Mark the IRP as non pending (and hence non cancelable)
        //
        
        IoSetCancelRoutine(pIrp,
                           NULL);

        //
        // Fill the irp info
        //
        
        pIrp->IoStatus.Information = sizeof(WANARP_NOTIFICATION);

        
        IoReleaseCancelSpinLock(kiIrql);
        
        //
        // Free the allocated notification
        //
        
        FreeNotification(pNotification);
        
        return STATUS_SUCCESS;
    }


    Trace(GLOBAL, TRACE,
          ("ProcNotification: Notification being queued\n")); 


    //
    // Queue this IRP to use for later
    //

    //
    // Mark the irp as pending
    //
    
    IoMarkIrpPending(pIrp);

    //
    // Queue up the irp at the end
    //
    
    InsertTailList(&g_lePendingIrpList,
                   &(pIrp->Tail.Overlay.ListEntry));

    //
    // Set the cancel routine
    //
    
    IoSetCancelRoutine(pIrp,
                       WanCancelNotificationIrp);
        
    IoReleaseCancelSpinLock(kiIrql);
        
    return STATUS_PENDING;
}


NTSTATUS
WanAddUserModeInterface(
    PIRP   pIrp,
    ULONG  ulInLength,
    ULONG  ulOutLength
    )

/*++

Routine Description:
      
    The handler for IOCTL_WANARP_ADD_INTERFACE.
    We walk our list of interface and make sure we dont have an interface
    with the same user mode index as the one we are being asked to create.
    If this is a new interface, we create a UMODE_INTERFACE structure
    and string it to the list. If it is the server interface then we also
    keep a special pointer to it
    
Locks:

    Acquires the g_rwlIfLock as WRITER
    
Arguments:
      

Return Value:

    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL
    STATUS_OBJECT_NAME_EXISTS
    STATUS_OBJECT_NAME_NOT_FOUND
    STATUS_INSUFFICIENT_RESOURCES
    
--*/

{
    PVOID               pvIoBuffer;
    PUMODE_INTERFACE    pInterface;
    KIRQL               kiIrql;
    NTSTATUS            nStatus;

    PWANARP_ADD_INTERFACE_INFO  pAddIfInfo;

    TraceEnter(ADPT, "AddUserModeInterface");

    pvIoBuffer = pIrp->AssociatedIrp.SystemBuffer;

    pIrp->IoStatus.Information = 0;
    
    if(ulInLength < sizeof(WANARP_ADD_INTERFACE_INFO))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }
        
    pAddIfInfo = (PWANARP_ADD_INTERFACE_INFO)pvIoBuffer;

    if(pAddIfInfo->bCallinInterface)
    {
        if(ulOutLength < sizeof(WANARP_ADD_INTERFACE_INFO))
        {
            return STATUS_BUFFER_TOO_SMALL;
        }

        RtlZeroMemory(pAddIfInfo->rgwcDeviceName,
                      (WANARP_MAX_DEVICE_NAME_LEN + 2) * sizeof(WCHAR));

        EnterReader(&g_rwlAdapterLock,
                    &kiIrql);

        if(g_pServerAdapter is NULL)
        {
            ExitReader(&g_rwlAdapterLock,
                       kiIrql);

            Trace(ADPT, ERROR,
                  ("AddUserModeInterface: No Server adapter\n"));

            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        //
        // Lock out the server adapter
        //

        RtAcquireSpinLockAtDpcLevel(&(g_pServerAdapter->rlLock));

        RtAssert(g_pServerInterface);

        RtAcquireSpinLockAtDpcLevel(&(g_pServerInterface->rlLock));

        ExitReaderFromDpcLevel(&g_rwlAdapterLock);

        if(pAddIfInfo->dwUserIfIndex isnot WANARP_INVALID_IFINDEX)
        {
            //
            // In this case all we need to do is set the interface index
            // for the server adapter. It is OK for this index to be INVALID
            // in that case, the user is merely asking for the server
            // adapter name
            //

            g_pServerInterface->dwIfIndex = pAddIfInfo->dwUserIfIndex;
        }

        //
        // We also need to return the name to the user
        //

        RtAssert(g_pServerAdapter->usDeviceNameW.Length <= WANARP_MAX_DEVICE_NAME_LEN * sizeof(WCHAR));

        RtlCopyMemory(pAddIfInfo->rgwcDeviceName,
                      &(g_pServerAdapter->usDeviceNameW.Buffer[wcslen(TCPIP_IF_PREFIX) + 1]),
                      g_pServerAdapter->usDeviceNameW.Length - ((wcslen(TCPIP_IF_PREFIX) + 1) * sizeof(WCHAR)));

        //
        // Also copy out the index
        //

        pAddIfInfo->dwAdapterIndex = g_pServerInterface->dwRsvdAdapterIndex;

        RtReleaseSpinLockFromDpcLevel(&(g_pServerInterface->rlLock));

        RtReleaseSpinLock(&(g_pServerAdapter->rlLock),
                          kiIrql);

        //
        // We need to copy out info in this case
        //

        pIrp->IoStatus.Information = sizeof(WANARP_ADD_INTERFACE_INFO);

        return STATUS_SUCCESS;
    }

    EnterWriter(&g_rwlIfLock,
                &kiIrql);
    
    pInterface = WanpFindInterfaceGivenIndex(pAddIfInfo->dwUserIfIndex);

    if(pInterface isnot NULL)
    {
        //
        // Found an interface with the matching index. Not good
        //

        DereferenceInterface(pInterface);
       
        RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));

        ExitWriter(&g_rwlIfLock,
                   kiIrql);
                   
        Trace(ADPT, ERROR,
              ("AddUserModeInterface: %d already exists\n",
               pAddIfInfo->dwUserIfIndex));
        
        return STATUS_OBJECT_NAME_EXISTS;
    }
    
    ExitWriter(&g_rwlIfLock,
               kiIrql);

    pInterface = RtAllocate(NonPagedPool,
                            sizeof(UMODE_INTERFACE),
                            WAN_INTERFACE_TAG);

    if(pInterface is NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pInterface,
                  sizeof(UMODE_INTERFACE));

    //
    // Reserve an Index with IP
    // This sets the value to invalid if it cant find an index
    //

    nStatus = WanpGetNewIndex(&(pInterface->dwRsvdAdapterIndex));

    if(nStatus isnot STATUS_SUCCESS)
    {
        RtFree(pInterface);

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    Trace(ADPT, TRACE,
          ("AddUserModeInterface: for 0x%x - will use 0x%x\n",
           pAddIfInfo->dwUserIfIndex,
           pInterface->dwRsvdAdapterIndex));
    
    RtInitializeSpinLock(&(pInterface->rlLock));

    //
    // Initialize the interface
    //

    pInterface->dwIfIndex      = pAddIfInfo->dwUserIfIndex;
    pInterface->dwAdminState   = IF_ADMIN_STATUS_UP;
    pInterface->dwOperState    = IF_OPER_STATUS_DISCONNECTED;
    pInterface->dwLastChange   = GetTimeTicks();

    pAddIfInfo->dwAdapterIndex = pInterface->dwRsvdAdapterIndex;

    //
    // Now set the refcount to 1 to account for the fact that the interface
    // will be put on the g_leIfList.
    //

    InitInterfaceRefCount(pInterface);

    pInterface->duUsage = DU_ROUTER;

    EnterWriter(&g_rwlIfLock,
                &kiIrql);
    
    InsertHeadList(&g_leIfList,
                   &(pInterface->leIfLink));

    ExitWriter(&g_rwlIfLock,
               kiIrql);
   
    pIrp->IoStatus.Information = sizeof(WANARP_ADD_INTERFACE_INFO);
 
    return STATUS_SUCCESS;
}

NTSTATUS
WanDeleteUserModeInterface(
    PIRP    pIrp,
    ULONG   ulInLength,
    ULONG   ulOutLength
    )

/*++

Routine Description:

    Handler for IOCTL_WANARP_DELETE_INTERFACE.
    We lookup our list to see if we have the interface. If we do, then
    we remove the interface from the g_leIfList and dereference it.
    If the interface was not mapped, then this should be the last
    reference on the interface, otherwise when the refcount goes to 0, it
    will get deleted.
    
Locks: 

    Acquires the g_rwlIfLock as WRITER and then calls FindInterface
    which locks the interface in question
    
Arguments:
      

Return Value:

    STATUS_BUFFER_TOO_SMALL
    STATUS_OBJECT_NAME_NOT_FOUND
    STATUS_SUCCESS

--*/

{
    KIRQL               kiIrql;
    PUMODE_INTERFACE    pInterface;
    PVOID               pvIoBuffer;

    PWANARP_DELETE_INTERFACE_INFO  pDeleteInfo;
   
    TraceEnter(ADPT, "DeleteUserModeInterface");
 
    pvIoBuffer   = pIrp->AssociatedIrp.SystemBuffer;

    pIrp->IoStatus.Information = 0;

    if(ulInLength < sizeof(WANARP_DELETE_INTERFACE_INFO))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    
    pDeleteInfo = (PWANARP_DELETE_INTERFACE_INFO)pvIoBuffer;

    //
    // Cant service binds or unbinds here
    //

    WanpAcquireResource(&g_wrBindMutex);

    EnterWriter(&g_rwlIfLock,
                &kiIrql);
    
    //
    // Find the interface for the index
    //
    
    pInterface = WanpFindInterfaceGivenIndex(pDeleteInfo->dwUserIfIndex);
    
    //
    // If the interface is not found, bug out
    //

    Trace(ADPT, TRACE,
          ("DeleteUserModeInterface: Deleting i/f 0x%x\n",
           pDeleteInfo->dwUserIfIndex));

    if(pInterface is NULL)
    {
        ExitWriter(&g_rwlIfLock,
                   kiIrql);

        WanpReleaseResource(&g_wrBindMutex);
        
        Trace(ADPT, ERROR,
              ("DeleteUserModeInterface: Couldnt find i/f 0x%x\n",
               pDeleteInfo->dwUserIfIndex));

        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    RemoveEntryList(&(pInterface->leIfLink));

    ExitWriterFromDpcLevel(&g_rwlIfLock);
    
    //
    // If found, the interface is locked
    // So dereference it and remove it from the list. The interface may
    // not get deleted here because it is already mapped and has a connection
    // active on it.
    //
    
    if(pInterface->dwOperState >= IF_OPER_STATUS_CONNECTING)
    {
        Trace(ADPT, ERROR,
              ("DeleteUserModeInterface: I/f %d is in state %d\n",
               pInterface->dwIfIndex,
               pInterface->dwOperState));
    }

    RtReleaseSpinLock(&(pInterface->rlLock),
                      kiIrql);

    //
    // Dereference the interface twice. Once because we put a ref on it
    // when we called FindInterface... and once because we removed it
    // from the if list
    //

    DereferenceInterface(pInterface);
    
    DereferenceInterface(pInterface);

    WanpReleaseResource(&g_wrBindMutex);
    
    return STATUS_SUCCESS;
}

VOID
WanpCleanOutInterfaces(
    VOID
    )

/*++

Routine Description:

    Called to delete all the interface from the system.
    We remove the interface from the g_leIfList and dereference it.
    For the server interface we simply mark it as disconnected
    
Locks: 

    Acquires the g_rwlIfLock as WRITER
    
Arguments:
      

Return Value:

    None

--*/

{
    KIRQL               kiIrql;
    PUMODE_INTERFACE    pInterface;

   
    TraceEnter(ADPT, "CleanOutInterfaces");
 
    //
    // Cant service binds or unbinds here
    //

    WanpAcquireResource(&g_wrBindMutex);

    EnterWriter(&g_rwlAdapterLock,
                &kiIrql);
    
    EnterWriterAtDpcLevel(&g_rwlIfLock);

    while(!IsListEmpty(&g_leIfList))
    {
        PLIST_ENTRY pleNode;

        pleNode = RemoveHeadList(&g_leIfList);
        
        pInterface = CONTAINING_RECORD(pleNode,
                                       UMODE_INTERFACE,
                                       leIfLink);

        if(pInterface->dwOperState >= IF_OPER_STATUS_CONNECTING)
        {
            Trace(ADPT, ERROR,
                  ("CleanOutInterfaces: I/f %d is in state %d\n",
                   pInterface->dwIfIndex,
                   pInterface->dwOperState));
        }

        DereferenceInterface(pInterface);
    }

    //
    // What should we do with the server interface?
    //

    ExitWriterFromDpcLevel(&g_rwlIfLock);
    
    ExitWriter(&g_rwlAdapterLock,
               kiIrql);
    
    WanpReleaseResource(&g_wrBindMutex);
    
    return;
}

VOID
WanpDeleteInterface(
    PUMODE_INTERFACE    pInterface
    )

/*++

Routine Description

    Called by DereferenceInterface() when the refcount on an interface
    falls to 0

Locks

    The interface is neither locked nor refcounted. Since there are no
    stored pointers to the interface, this structure can not be accessed
    by anyone but this function

Arguments

    pInterface  The interface to delete

Return Value

    None
    
--*/

{
    PADAPTER    pAdapter;
   
    if(pInterface is g_pServerInterface)
    {
        //
        // If this is the server interface, make sure that all
        // connection entries are gone
        //
    }

    //
    // There should be no interface mapped to it because otherwise we wouldnt
    // be down to a refcount of 0
    //
    
    RtAssert(pInterface->dwRsvdAdapterIndex isnot INVALID_IF_INDEX);
    RtAssert(pInterface->dwRsvdAdapterIndex isnot 0);

    WanpFreeIndex(pInterface->dwRsvdAdapterIndex);

    RtAssert(pInterface->pAdapter is NULL);
   
    RtFree(pInterface);
 
}

NTSTATUS
WanProcessConnectionFailure(
    PIRP   pIrp,
    ULONG  ulInLength,
    ULONG  ulOutLength
    )

/*++

Routine Description:
      
    Handler for IOCTL_WANARP_CONNECT_FAILED
    We find the interface that failed to connect. If we do find one, we
    mark its state as disconnected and then see if it was mapped to an
    adapter (as it should be). If we find an adapter, we do funky stuff
    with lock orders, clean out the packets queued to the adapter and
    unmap the adapter.
    
Locks: 

    One of the more complex functions.
    We take the g_rwlIfLock to get to the interface and lock it.
    Then we get a pointer to the adapter, and ref it. We release the
    interface lock and lock the adapter. 
    
Arguments:
      

Return Value:

    STATUS_BUFFER_TOO_SMALL
    STATUS_OBJECT_NAME_NOT_FOUND
    STATUS_INVALID_PARAMETER
    STATUS_INVALID_DEVICE_STATE
    STATUS_SUCCESS

--*/

{
    PNDIS_PACKET        packet;
    PADAPTER            pAdapter;
    PUMODE_INTERFACE    pInterface;
    DWORD               dwIfIndex;
    PVOID               pvIoBuffer;
    KIRQL               kiIrql;
   
    TraceEnter(CONN, "ProcessConnectionFailure");
 
    pvIoBuffer   = pIrp->AssociatedIrp.SystemBuffer;

    pIrp->IoStatus.Information = 0;
    
    if(ulInLength < sizeof(WANARP_CONNECT_FAILED_INFO))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    dwIfIndex = ((PWANARP_CONNECT_FAILED_INFO)pvIoBuffer)->dwUserIfIndex;
    
    pIrp->IoStatus.Information = 0;

    //
    // Find the interface
    //
    
    EnterReader(&g_rwlIfLock,
                &kiIrql);
    
    pInterface = WanpFindInterfaceGivenIndex(dwIfIndex);

    if(pInterface is NULL)
    {
        ExitReader(&g_rwlIfLock,
                   kiIrql);
        
        Trace(CONN, ERROR,
              ("ProcessConnectionFailure: Couldnt find i/f for index %d\n",
               dwIfIndex));
        
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    if(pInterface is g_pServerInterface)
    {
        //
        // Cant get a disconnect on this
        //

        RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));

        DereferenceInterface(pInterface);
        
        ExitReader(&g_rwlIfLock,
                   kiIrql);
        
        Trace(CONN, ERROR,
              ("ProcessConnectionFailure: disconnect on server i/f (%d)n",
               dwIfIndex));
        
        return STATUS_INVALID_PARAMETER;
    }

    ExitReaderFromDpcLevel(&g_rwlIfLock);

    RtAssert(pInterface->dwIfIndex is dwIfIndex);
    
    //
    // So now the interface is locked.
    //
    
    Trace(CONN, TRACE,
          ("ProcessConnectionFailure for %d %p\n", pInterface->dwIfIndex, pInterface));
    

    if(pInterface->dwOperState isnot IF_OPER_STATUS_CONNECTING)
    {
        Trace(CONN, ERROR,
              ("ProcessConnectionFailure: %p is in state %d\n",
               pInterface,
               pInterface->dwOperState));

        RtReleaseSpinLock(&(pInterface->rlLock),
                          kiIrql);

        DereferenceInterface(pInterface);

        return STATUS_INVALID_DEVICE_STATE;
    }
 
    pAdapter = pInterface->pAdapter;

    if(pAdapter is NULL)
    {
        //
        // This is the case where we couldnt find an adapter added to IP
        // to make a DOD connection
        // We dont need to do too much here, just release the interface
        // lock and remove ref that was put by FindInterface()
        //

        RtAssert(pInterface->dwOperState is IF_OPER_STATUS_CONNECTING);

        pInterface->dwOperState = IF_OPER_STATUS_DISCONNECTED;
        pInterface->dwLastChange= GetTimeTicks();

        RtAssert(pInterface->ulPacketsPending is 0);

        RtReleaseSpinLock(&(pInterface->rlLock),
                          kiIrql);

        DereferenceInterface(pInterface);
    
        return STATUS_SUCCESS; 
    }
       
    //
    // We should never get a connection failure if have gotten a LinkUp
    //

    RtAssert(pAdapter->pConnEntry is NULL);
 
    //
    // If we do have an adapter then it can not go away because the 
    // interface has a refcount on it (i.e when we set the pAdapter field 
    // in the interface, we refcounted the adapter because we had a stored 
    // pointer to it)
    // 

    
    RtAssert(pInterface->dwOperState is IF_OPER_STATUS_CONNECTING);
    
    //
    // If the interface is still mapped, unmap it and drain any packets we 
    // may have queued
    //

    pInterface->ulPacketsPending  = 0;

    pInterface->dwOperState = IF_OPER_STATUS_DISCONNECTED;
    pInterface->dwLastChange= GetTimeTicks();
    
    //
    // The adapter can not go away because the interface has a refcount on
    // it (i.e when we set the pAdapter field in the interface, we
    // refcounted the adapter because we had a stored pointer to it)
    // 

    pAdapter = pInterface->pAdapter;

    RtAssert(pAdapter);
    
    //
    // Clear out the adapter field, BUT DONT DEREF the adapter
    //
    
    pInterface->pAdapter    = NULL;
    
    //
    // So we are done with the interface. We now go and clean out the
    // adapter. To do that we need to acquire the adapter lock. However we
    // can not do that since we have the interface lock. So we first
    // reference the adapter (so that it will be around). Then we 
    // let go of the interface lock. (The interface can not go away since
    // we put a refcount on the it when we called FindInterface). After
    // which we can acquire the adapter lock
    //

    ReferenceAdapter(pAdapter);
    
    RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));

    //
    // The adapter has to be around, because of the refcount
    //

    RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

    //
    // Make sure that the adapter still thinks that it is mapped to the
    // interface in question
    //

    if(pAdapter->pInterface is pInterface)
    {
        RtAssert(pAdapter->byState is AS_MAPPED);
        
        //
        // Drain all the packets
        //

        Trace(CONN, TRACE,
              ("ProcsConnFailure: Draining and freeing any queued packets\n"));

        
        while(!IsListEmpty(&(pAdapter->lePendingPktList)))
        {
            PLIST_ENTRY     pleNode;
            PNDIS_PACKET    pnpPacket;
            
            pleNode = RemoveHeadList(&(pAdapter->lePendingPktList));
            
            //
            // get to the packet structure in which LIST_ENTRY is embedded
            //
            
            pnpPacket = CONTAINING_RECORD(pleNode,
                                          NDIS_PACKET,
                                          MacReserved);
            
            WanpFreePacketAndBuffers(pnpPacket);
        }

        if(!IsListEmpty(&(pAdapter->lePendingHdrList)))
        {
            LIST_ENTRY  leTempList;

            leTempList = pAdapter->lePendingHdrList;

            pAdapter->lePendingHdrList.Flink->Blink = &leTempList;
            pAdapter->lePendingHdrList.Blink->Flink = &leTempList;
           
            InitializeListHead(&(pAdapter->lePendingHdrList));
 
            FreeBufferListToPool(&g_bpHeaderBufferPool,
                                 &leTempList);
        }
        
        pAdapter->pInterface = NULL;

        //
        // Deref the interface because we are clearing out a stored pointer
        //
        
        DereferenceInterface(pInterface);

        //
        // Deref the adapter now (due to the fact that we cleared out
        // the pAdapter field in pInterface
        //
        
        DereferenceAdapter(pAdapter);
    }

    //
    // Done with the adapter
    //

    RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));
   
    WanpUnmapAdapter(pAdapter);
 
    KeLowerIrql(kiIrql);

    //
    // Remove ref that was put by FindInterface()
    //
    
    DereferenceInterface(pInterface);

    //
    // Remove the ref that was put when we let go of the interface lock
    //

    DereferenceAdapter(pAdapter);
    
    return STATUS_SUCCESS;
}

NTSTATUS
WanGetIfStats(
    PIRP     pIrp,
    ULONG    ulInLength,
    ULONG    ulOutLength
    )

/*++

Routine Description:
      
  
Locks: 


Arguments:
      

Return Value:

    NO_ERROR

--*/

{
    PVOID                       pvIoBuffer;
    PWANARP_GET_IF_STATS_INFO   pInfo;
    KIRQL                       kiIrql;
    PUMODE_INTERFACE            pInterface;
 
    pvIoBuffer   = pIrp->AssociatedIrp.SystemBuffer;

    pIrp->IoStatus.Information = 0;
    
    if((ulOutLength < (FIELD_OFFSET(WANARP_GET_IF_STATS_INFO, ifeInfo)
                       + IFE_FIXED_SIZE))or 
       (ulInLength < (FIELD_OFFSET(WANARP_GET_IF_STATS_INFO, ifeInfo)
                      + IFE_FIXED_SIZE)))
    {   
        return STATUS_BUFFER_TOO_SMALL;
    }
        
    EnterReader(&g_rwlIfLock,
                &kiIrql);

    pInfo = (PWANARP_GET_IF_STATS_INFO)pvIoBuffer;

    pInterface = WanpFindInterfaceGivenIndex(pInfo->dwUserIfIndex);

    if(pInterface is NULL)
    {
        ExitReader(&g_rwlIfLock,
                   kiIrql);

        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    ExitReaderFromDpcLevel(&g_rwlIfLock);

    //
    // We dont take the adapter lock, because the adapter can not
    // go away while the interface is mapped to it.
    // Sure the qlen can be inconsistent, but hey
    //
    
    if((pInterface->pAdapter) and
       (pInterface->pAdapter->pConnEntry))
    {
        pInfo->ifeInfo.if_index   = pInterface->pAdapter->dwAdapterIndex;
        pInfo->ifeInfo.if_outqlen = pInterface->pAdapter->ulQueueLen;
        pInfo->ifeInfo.if_mtu     = pInterface->pAdapter->pConnEntry->ulMtu;
        pInfo->ifeInfo.if_speed   = pInterface->pAdapter->pConnEntry->ulSpeed;
    }
    else
    {
        pInfo->ifeInfo.if_index   = (uint)-1;
        pInfo->ifeInfo.if_outqlen = 0;
        pInfo->ifeInfo.if_mtu     = WANARP_DEFAULT_MTU;
        pInfo->ifeInfo.if_speed   = WANARP_DEFAULT_SPEED;
    }
    
    pInfo->ifeInfo.if_adminstatus       = pInterface->dwAdminState;
    pInfo->ifeInfo.if_operstatus        = pInterface->dwOperState;
    pInfo->ifeInfo.if_lastchange        = pInterface->dwLastChange;
    pInfo->ifeInfo.if_inoctets          = pInterface->ulInOctets;
    pInfo->ifeInfo.if_inucastpkts       = pInterface->ulInUniPkts;
    pInfo->ifeInfo.if_innucastpkts      = pInterface->ulInNonUniPkts;
    pInfo->if