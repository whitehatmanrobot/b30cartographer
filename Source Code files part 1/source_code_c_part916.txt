META_SCALEWINDOWEXT),
    WmfRecordTypeOffsetViewportOrg       = GDIP_WMF_RECORD_TO_EMFPLUS(META_OFFSETVIEWPORTORG),
    WmfRecordTypeScaleViewportExt        = GDIP_WMF_RECORD_TO_EMFPLUS(META_SCALEVIEWPORTEXT),
    WmfRecordTypeLineTo                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_LINETO),
    WmfRecordTypeMoveTo                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_MOVETO),
    WmfRecordTypeExcludeClipRect         = GDIP_WMF_RECORD_TO_EMFPLUS(META_EXCLUDECLIPRECT),
    WmfRecordTypeIntersectClipRect       = GDIP_WMF_RECORD_TO_EMFPLUS(META_INTERSECTCLIPRECT),
    WmfRecordTypeArc                     = GDIP_WMF_RECORD_TO_EMFPLUS(META_ARC),
    WmfRecordTypeEllipse                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_ELLIPSE),
    WmfRecordTypeFloodFill               = GDIP_WMF_RECORD_TO_EMFPLUS(META_FLOODFILL),
    WmfRecordTypePie                     = GDIP_WMF_RECORD_TO_EMFPLUS(META_PIE),
    WmfRecordTypeRectangle               = GDIP_WMF_RECORD_TO_EMFPLUS(META_RECTANGLE),
    WmfRecordTypeRoundRect               = GDIP_WMF_RECORD_TO_EMFPLUS(META_ROUNDRECT),
    WmfRecordTypePatBlt                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_PATBLT),
    WmfRecordTypeSaveDC                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_SAVEDC),
    WmfRecordTypeSetPixel                = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETPIXEL),
    WmfRecordTypeOffsetCilpRgn           = GDIP_WMF_RECORD_TO_EMFPLUS(META_OFFSETCLIPRGN),
    WmfRecordTypeTextOut                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_TEXTOUT),
    WmfRecordTypeBitBlt                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_BITBLT),
    WmfRecordTypeStretchBlt              = GDIP_WMF_RECORD_TO_EMFPLUS(META_STRETCHBLT),
    WmfRecordTypePolygon                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_POLYGON),
    WmfRecordTypePolyline                = GDIP_WMF_RECORD_TO_EMFPLUS(META_POLYLINE),
    WmfRecordTypeEscape                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_ESCAPE),
    WmfRecordTypeRestoreDC               = GDIP_WMF_RECORD_TO_EMFPLUS(META_RESTOREDC),
    WmfRecordTypeFillRegion              = GDIP_WMF_RECORD_TO_EMFPLUS(META_FILLREGION),
    WmfRecordTypeFrameRegion             = GDIP_WMF_RECORD_TO_EMFPLUS(META_FRAMEREGION),
    WmfRecordTypeInvertRegion            = GDIP_WMF_RECORD_TO_EMFPLUS(META_INVERTREGION),
    WmfRecordTypePaintRegion             = GDIP_WMF_RECORD_TO_EMFPLUS(META_PAINTREGION),
    WmfRecordTypeSelectClipRegion        = GDIP_WMF_RECORD_TO_EMFPLUS(META_SELECTCLIPREGION),
    WmfRecordTypeSelectObject            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SELECTOBJECT),
    WmfRecordTypeSetTextAlign            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTALIGN),
    WmfRecordTypeChord                   = GDIP_WMF_RECORD_TO_EMFPLUS(META_CHORD),
    WmfRecordTypeSetMapperFlags          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETMAPPERFLAGS),
    WmfRecordTypeExtTextOut              = GDIP_WMF_RECORD_TO_EMFPLUS(META_EXTTEXTOUT),
    WmfRecordTypeSetDIBToDev             = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETDIBTODEV),
    WmfRecordTypeSelectPalette           = GDIP_WMF_RECORD_TO_EMFPLUS(META_SELECTPALETTE),
    WmfRecordTypeRealizePalette          = GDIP_WMF_RECORD_TO_EMFPLUS(META_REALIZEPALETTE),
    WmfRecordTypeAnimatePalette          = GDIP_WMF_RECORD_TO_EMFPLUS(META_ANIMATEPALETTE),
    WmfRecordTypeSetPalEntries           = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETPALENTRIES),
    WmfRecordTypePolyPolygon             = GDIP_WMF_RECORD_TO_EMFPLUS(META_POLYPOLYGON),
    WmfRecordTypeResizePalette           = GDIP_WMF_RECORD_TO_EMFPLUS(META_RESIZEPALETTE),
    WmfRecordTypeDIBBitBlt               = GDIP_WMF_RECORD_TO_EMFPLUS(META_DIBBITBLT),
    WmfRecordTypeDIBStretchBlt           = GDIP_WMF_RECORD_TO_EMFPLUS(META_DIBSTRETCHBLT),
    WmfRecordTypeDIBCreatePatternBrush   = GDIP_WMF_RECORD_TO_EMFPLUS(META_DIBCREATEPATTERNBRUSH),
    WmfRecordTypeStretchDIB              = GDIP_WMF_RECORD_TO_EMFPLUS(META_STRETCHDIB),
    WmfRecordTypeExtFloodFill            = GDIP_WMF_RECORD_TO_EMFPLUS(META_EXTFLOODFILL),
    WmfRecordTypeSetLayout               = GDIP_WMF_RECORD_TO_EMFPLUS(0x0149), // META_SETLAYOUT
    WmfRecordTypeDeleteObject            = GDIP_WMF_RECORD_TO_EMFPLUS(META_DELETEOBJECT),
    WmfRecordTypeCreatePalette           = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEPALETTE),
    WmfRecordTypeCreatePatternBrush      = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEPATTERNBRUSH),
    WmfRecordTypeCreatePenIndirect       = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEPENINDIRECT),
    WmfRecordTypeCreateFontIndirect      = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEFONTINDIRECT),
    WmfRecordTypeCreateBrushIndirect     = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEBRUSHINDIRECT),
    WmfRecordTypeCreateRegion            = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEREGION),

    EmfRecordTypeHeader                  = EMR_HEADER,
    EmfRecordTypePolyBezier              = EMR_POLYBEZIER,
    EmfRecordTypePolygon                 = EMR_POLYGON,
    EmfRecordTypePolyline                = EMR_POLYLINE,
    EmfRecordTypePolyBezierTo            = EMR_POLYBEZIERTO,
    EmfRecordTypePolyLineTo              = EMR_POLYLINETO,
    EmfRecordTypePolyPolyline            = EMR_POLYPOLYLINE,
    EmfRecordTypePolyPolygon             = EMR_POLYPOLYGON,
    EmfRecordTypeSetWindowExtEx          = EMR_SETWINDOWEXTEX,
    EmfRecordTypeSetWindowOrgEx          = EMR_SETWINDOWORGEX,
    EmfRecordTypeSetViewportExtEx        = EMR_SETVIEWPORTEXTEX,
    EmfRecordTypeSetViewportOrgEx        = EMR_SETVIEWPORTORGEX,
    EmfRecordTypeSetBrushOrgEx           = EMR_SETBRUSHORGEX,
    EmfRecordTypeEOF                     = EMR_EOF,
    EmfRecordTypeSetPixelV               = EMR_SETPIXELV,
    EmfRecordTypeSetMapperFlags          = EMR_SETMAPPERFLAGS,
    EmfRecordTypeSetMapMode              = EMR_SETMAPMODE,
    EmfRecordTypeSetBkMode               = EMR_SETBKMODE,
    EmfRecordTypeSetPolyFillMode         = EMR_SETPOLYFILLMODE,
    EmfRecordTypeSetROP2                 = EMR_SETROP2,
    EmfRecordTypeSetStretchBltMode       = EMR_SETSTRETCHBLTMODE,
    EmfRecordTypeSetTextAlign            = EMR_SETTEXTALIGN,
    EmfRecordTypeSetColorAdjustment      = EMR_SETCOLORADJUSTMENT,
    EmfRecordTypeSetTextColor            = EMR_SETTEXTCOLOR,
    EmfRecordTypeSetBkColor              = EMR_SETBKCOLOR,
    EmfRecordTypeOffsetClipRgn           = EMR_OFFSETCLIPRGN,
    EmfRecordTypeMoveToEx                = EMR_MOVETOEX,
    EmfRecordTypeSetMetaRgn              = EMR_SETMETARGN,
    EmfRecordTypeExcludeClipRect         = EMR_EXCLUDECLIPRECT,
    EmfRecordTypeIntersectClipRect       = EMR_INTERSECTCLIPRECT,
    EmfRecordTypeScaleViewportExtEx      = EMR_SCALEVIEWPORTEXTEX,
    EmfRecordTypeScaleWindowExtEx        = EMR_SCALEWINDOWEXTEX,
    EmfRecordTypeSaveDC                  = EMR_SAVEDC,
    EmfRecordTypeRestoreDC               = EMR_RESTOREDC,
    EmfRecordTypeSetWorldTransform       = EMR_SETWORLDTRANSFORM,
    EmfRecordTypeModifyWorldTransform    = EMR_MODIFYWORLDTRANSFORM,
    EmfRecordTypeSelectObject            = EMR_SELECTOBJECT,
    EmfRecordTypeCreatePen               = EMR_CREATEPEN,
    EmfRecordTypeCreateBrushIndirect     = EMR_CREATEBRUSHINDIRECT,
    EmfRecordTypeDeleteObject            = EMR_DELETEOBJECT,
    EmfRecordTypeAngleArc                = EMR_ANGLEARC,
    EmfRecordTypeEllipse                 = EMR_ELLIPSE,
    EmfRecordTypeRectangle               = EMR_RECTANGLE,
    EmfRecordTypeRoundRect               = EMR_ROUNDRECT,
    EmfRecordTypeArc                     = EMR_ARC,
    EmfRecordTypeChord                   = EMR_CHORD,
    EmfRecordTypePie                     = EMR_PIE,
    EmfRecordTypeSelectPalette           = EMR_SELECTPALETTE,
    EmfRecordTypeCreatePalette           = EMR_CREATEPALETTE,
    EmfRecordTypeSetPaletteEntries       = EMR_SETPALETTEENTRIES,
    EmfRecordTypeResizePalette           = EMR_RESIZEPALETTE,
    EmfRecordTypeRealizePalette          = EMR_REALIZEPALETTE,
    EmfRecordTypeExtFloodFill            = EMR_EXTFLOODFILL,
    EmfRecordTypeLineTo                  = EMR_LINETO,
    EmfRecordTypeArcTo                   = EMR_ARCTO,
    EmfRecordTypePolyDraw                = EMR_POLYDRAW,
    EmfRecordTypeSetArcDirection         = EMR_SETARCDIRECTION,
    EmfRecordTypeSetMiterLimit           = EMR_SETMITERLIMIT,
    EmfRecordTypeBeginPath               = EMR_BEGINPATH,
    EmfRecordTypeEndPath                 = EMR_ENDPATH,
    EmfRecordTypeCloseFigure             = EMR_CLOSEFIGURE,
    EmfRecordTypeFillPath                = EMR_FILLPATH,
    EmfRecordTypeStrokeAndFillPath       = EMR_STROKEANDFILLPATH,
    EmfRecordTypeStrokePath              = EMR_STROKEPATH,
    EmfRecordTypeFlattenPath             = EMR_FLATTENPATH,
    EmfRecordTypeWidenPath               = EMR_WIDENPATH,
    EmfRecordTypeSelectClipPath          = EMR_SELECTCLIPPATH,
    EmfRecordTypeAbortPath               = EMR_ABORTPATH,
    EmfRecordTypeReserved_069            = 69,  // Not Used
    EmfRecordTypeGdiComment              = EMR_GDICOMMENT,
    EmfRecordTypeFillRgn                 = EMR_FILLRGN,
    EmfRecordTypeFrameRgn                = EMR_FRAMERGN,
    EmfRecordTypeInvertRgn               = EMR_INVERTRGN,
    EmfRecordTypePaintRgn                = EMR_PAINTRGN,
    EmfRecordTypeExtSelectClipRgn        = EMR_EXTSELECTCLIPRGN,
    EmfRecordTypeBitBlt                  = EMR_BITBLT,
    EmfRecordTypeStretchBlt              = EMR_STRETCHBLT,
    EmfRecordTypeMaskBlt                 = EMR_MASKBLT,
    EmfRecordTypePlgBlt                  = EMR_PLGBLT,
    EmfRecordTypeSetDIBitsToDevice       = EMR_SETDIBITSTODEVICE,
    EmfRecordTypeStretchDIBits           = EMR_STRETCHDIBITS,
    EmfRecordTypeExtCreateFontIndirect   = EMR_EXTCREATEFONTINDIRECTW,
    EmfRecordTypeExtTextOutA             = EMR_EXTTEXTOUTA,
    EmfRecordTypeExtTextOutW             = EMR_EXTTEXTOUTW,
    EmfRecordTypePolyBezier16            = EMR_POLYBEZIER16,
    EmfRecordTypePolygon16               = EMR_POLYGON16,
    EmfRecordTypePolyline16              = EMR_POLYLINE16,
    EmfRecordTypePolyBezierTo16          = EMR_POLYBEZIERTO16,
    EmfRecordTypePolylineTo16            = EMR_POLYLINETO16,
    EmfRecordTypePolyPolyline16          = EMR_POLYPOLYLINE16,
    EmfRecordTypePolyPolygon16           = EMR_POLYPOLYGON16,
    EmfRecordTypePolyDraw16              = EMR_POLYDRAW16,
    EmfRecordTypeCreateMonoBrush         = EMR_CREATEMONOBRUSH,
    EmfRecordTypeCreateDIBPatternBrushPt = EMR_CREATEDIBPATTERNBRUSHPT,
    EmfRecordTypeExtCreatePen            = EMR_EXTCREATEPEN,
    EmfRecordTypePolyTextOutA            = EMR_POLYTEXTOUTA,
    EmfRecordTypePolyTextOutW            = EMR_POLYTEXTOUTW,
    EmfRecordTypeSetICMMode              = 98,  // EMR_SETICMMODE,
    EmfRecordTypeCreateColorSpace        = 99,  // EMR_CREATECOLORSPACE,
    EmfRecordTypeSetColorSpace           = 100, // EMR_SETCOLORSPACE,
    EmfRecordTypeDeleteColorSpace        = 101, // EMR_DELETECOLORSPACE,
    EmfRecordTypeGLSRecord               = 102, // EMR_GLSRECORD,
    EmfRecordTypeGLSBoundedRecord        = 103, // EMR_GLSBOUNDEDRECORD,
    EmfRecordTypePixelFormat             = 104, // EMR_PIXELFORMAT,
    EmfRecordTypeDrawEscape              = 105, // EMR_RESERVED_105,
    EmfRecordTypeExtEscape               = 106, // EMR_RESERVED_106,
    EmfRecordTypeStartDoc                = 107, // EMR_RESERVED_107,
    EmfRecordTypeSmallTextOut            = 108, // EMR_RESERVED_108,
    EmfRecordTypeForceUFIMapping         = 109, // EMR_RESERVED_109,
    EmfRecordTypeNamedEscape             = 110, // EMR_RESERVED_110,
    EmfRecordTypeColorCorrectPalette     = 111, // EMR_COLORCORRECTPALETTE,
    EmfRecordTypeSetICMProfileA          = 112, // EMR_SETICMPROFILEA,
    EmfRecordTypeSetICMProfileW          = 113, // EMR_SETICMPROFILEW,
    EmfRecordTypeAlphaBlend              = 114, // EMR_ALPHABLEND,
    EmfRecordTypeSetLayout               = 115, // EMR_SETLAYOUT,
    EmfRecordTypeTransparentBlt          = 116, // EMR_TRANSPARENTBLT,
    EmfRecordTypeReserved_117            = 117, // Not Used
    EmfRecordTypeGradientFill            = 118, // EMR_GRADIENTFILL,
    EmfRecordTypeSetLinkedUFIs           = 119, // EMR_RESERVED_119,
    EmfRecordTypeSetTextJustification    = 120, // EMR_RESERVED_120,
    EmfRecordTypeColorMatchToTargetW     = 121, // EMR_COLORMATCHTOTARGETW,
    EmfRecordTypeCreateColorSpaceW       = 122, // EMR_CREATECOLORSPACEW,
    EmfRecordTypeMax                     = 122,
    EmfRecordTypeMin                     = 1,

    // That is the END of the GDI EMF records.

    // Now we start the list of EMF+ records.  We leave quite
    // a bit of room here for the addition of any new GDI
    // records that may be added later.

    EmfPlusRecordTypeInvalid = GDIP_EMFPLUS_RECORD_BASE,
    EmfPlusRecordTypeHeader,
    EmfPlusRecordTypeEndOfFile,

    EmfPlusRecordTypeComment,

    EmfPlusRecordTypeGetDC,    // the application grabbed the metafile dc

    EmfPlusRecordTypeMultiFormatStart,
    EmfPlusRecordTypeMultiFormatSection,
    EmfPlusRecordTypeMultiFormatEnd,

    // For all persistent objects
    EmfPlusRecordTypeObject, // brush,pen,path,region,image,font,string-format

    // Drawing Records
    EmfPlusRecordTypeClear,
    EmfPlusRecordTypeFillRects,
    EmfPlusRecordTypeDrawRects,
    EmfPlusRecordTypeFillPolygon,
    EmfPlusRecordTypeDrawLines,
    EmfPlusRecordTypeFillEllipse,
    EmfPlusRecordTypeDrawEllipse,
    EmfPlusRecordTypeFillPie,
    EmfPlusRecordTypeDrawPie,
    EmfPlusRecordTypeDrawArc,
    EmfPlusRecordTypeFillRegion,
    EmfPlusRecordTypeFillPath,
    EmfPlusRecordTypeDrawPath,
    EmfPlusRecordTypeFillClosedCurve,
    EmfPlusRecordTypeDrawClosedCurve,
    EmfPlusRecordTypeDrawCurve,
    EmfPlusRecordTypeDrawBeziers,
    EmfPlusRecordTypeDrawImage,
    EmfPlusRecordTypeDrawImagePoints,
    EmfPlusRecordTypeDrawString,

    // Graphics State Records
    EmfPlusRecordTypeSetRenderingOrigin,
    EmfPlusRecordTypeSetAntiAliasMode,
    EmfPlusRecordTypeSetTextRenderingHint,
    EmfPlusRecordTypeSetTextGammaValue,
    EmfPlusRecordTypeSetInterpolationMode,
    EmfPlusRecordTypeSetPixelOffsetMode,
    EmfPlusRecordTypeSetCompositingMode,
    EmfPlusRecordTypeSetCompositingQuality,
    EmfPlusRecordTypeSave,
    EmfPlusRecordTypeRestore,
    EmfPlusRecordTypeBeginContainer,
    EmfPlusRecordTypeBeginContainerNoParams,
    EmfPlusRecordTypeEndContainer,
    EmfPlusRecordTypeSetWorldTransform,
    EmfPlusRecordTypeResetWorldTransform,
    EmfPlusRecordTypeMultiplyWorldTransform,
    EmfPlusRecordTypeTranslateWorldTransform,
    EmfPlusRecordTypeScaleWorldTransform,
    EmfPlusRecordTypeRotateWorldTransform,
    EmfPlusRecordTypeSetPageTransform,
    EmfPlusRecordTypeResetClip,
    EmfPlusRecordTypeSetClipRect,
    EmfPlusRecordTypeSetClipPath,
    EmfPlusRecordTypeSetClipRegion,
    EmfPlusRecordTypeOffsetClip,

    // New record types must be added here (at the end) -- do not add above, 
    // since that will invalidate previous metafiles!
    EmfPlusRecordTypeDrawDriverString,

    // Have this here so you don't need to keep changing the value of
    // EmfPlusRecordTypeMax every time you add a new record.

    EmfPlusRecordTotal,

    EmfPlusRecordTypeMax = EmfPlusRecordTotal-1,
    EmfPlusRecordTypeMin = EmfPlusRecordTypeHeader,
};

//---------------------------------------------------------------------------
// StringFormatFlags
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// String format flags
//
//  DirectionRightToLeft          - For horizontal text, the reading order is
//                                  right to left. This value is called
//                                  the base embedding level by the Unicode
//                                  bidirectional engine.
//                                  For vertical text, columns are read from
//                                  right to left.
//                                  By default, horizontal or vertical text is
//                                  read from left to right.
//
//  DirectionVertical             - Individual lines of text are vertical. In
//                                  each line, characters progress from top to
//                                  bottom.
//                                  By default, lines of text are horizontal,
//                                  each new line below the previous line.
//
//  NoFitBlackBox                 - Allows parts of glyphs to overhang the
//                                  bounding rectangle.
//                                  By default glyphs are first aligned
//                                  inside the margines, then any glyphs which
//                                  still overhang the bounding box are
//                                  repositioned to avoid any overhang.
//                                  For example when an italic
//                                  lower case letter f in a font such as
//                                  Garamond is aligned at the far left of a
//                                  rectangle, the lower part of the f will
//                                  reach slightly further left than the left
//                                  edge of the rectangle. Setting this flag
//                                  will ensure the character aligns visually
//                                  with the lines above and below, but may
//                                  cause some pixels outside the formatting
//                                  rectangle to be clipped or painted.
//
//  NumberContextArabic           - Causes any initial numeric in the string to
//                                  be analysed for bidirection layout as if
//                                  it was preceeded by Arabic text.
//
//  DisableKashidaJustification   - Arabic text will not be justified by the
//                                  insertion of kashidas (i.e. extending the
//                                  joining line between characters). Instead
//                                  Arabic script will be justified by the
//                                  widening of the whitespace between words.
//
//  DisplayFormatControl          - Causes control characters such as the
//                                  left-to-right mark to be shown in the
//                                  output with a representative glyph.
//
//  DisableKerning                - Disables Truetype and OpenType kerning.
//
//  DisableLigatures              - Disables Truetype and OpenType ligatures.
//
//  LayoutLegacyBidi              - Causes the bidirection algorithm to use
//                                  slightly different classifications for
//                                  '+', '-' and '/' that make their layout
//                                  much closer to that expected by files
//                                  generated in Windows or by Windows
//                                  applications.
//
//  NoChanges                     - A text imager created with this flag set
//                                  does not support those APIs that change
//                                  it's contents or formatting, but for most
//                                  simple text will be significantly faster in
//                                  performing measurement and drawing
//                                  functions.
//
//  NoFontFallback                - Disables fallback to alternate fonts for
//                                  characters not supported in the requested
//                                  font. Any missing characters will be
//                                  be displayed with the fonts missing glyph,
//                                  usually an open square.
//
//  NoWrap                        - Disables wrapping of text between lines
//                                  when formatting within a rectangle.
//                                  NoWrap is implied when a point is passed
//                                  instead of a rectangle, or when the
//                                  specified rectangle has a zero line length.
//
//  NoClip                        - By default text is clipped to the
//                                  formatting rectangle. Setting NoClip
//                                  allows overhanging pixels to affect the
//                                  device outside the formatting rectangle.
//                                  Pixels at the end of the line may be
//                                  affected if the glyphs overhang their
//                                  cells, and either the NoFitBlackBox flag
//                                  has been set, or the glyph extends to far
//                                  to be fitted.
//                                  Pixels above/before the first line or
//                                  below/after the last line may be affected
//                                  if the glyphs extend beyond their cell
//                                  ascent / descent. This can occur rarely
//                                  with unusual diacritic mark combinations.

//---------------------------------------------------------------------------

enum StringFormatFlags
{
    StringFormatFlagsDirectionRightToLeft        = 0x00000001,
    StringFormatFlagsDirectionVertical           = 0x00000002,
    StringFormatFlagsNoFitBlackBox               = 0x00000004,
    StringFormatFlagsNumberContextArabic         = 0x00000008,
    StringFormatFlagsDisableKashidaJustification = 0x00000010,
    StringFormatFlagsDisplayFormatControl        = 0x00000020,
    StringFormatFlagsDisableKerning              = 0x00000040,
    StringFormatFlagsDisableLigatures            = 0x00000080,
    StringFormatFlagsLayoutLegacyBidi            = 0x00000100,
    StringFormatFlagsNoChanges                   = 0x00000200,
    StringFormatFlagsNoFontFallback              = 0x00000400,
    StringFormatFlagsMeasureTrailingSpaces       = 0x00000800,
    StringFormatFlagsNoWrap                      = 0x00001000,
    StringFormatFlagsLineLimit                   = 0x00002000,

    StringFormatFlagsNoClip                      = 0x00004000
};

//---------------------------------------------------------------------------
// StringTrimming
//---------------------------------------------------------------------------

enum StringTrimming {
    StringTrimmingNone              = 0,
    StringTrimmingCharacter         = 1,
    StringTrimmingWord              = 2,
    StringTrimmingEllipsisCharacter = 3,
    StringTrimmingEllipsisWord      = 4,
    StringTrimmingEllipsisPath      = 5
};

//---------------------------------------------------------------------------
// String units
//
// String units are like length units in CSS, they may be absolute, or
// they may be relative to a font size.
//
//---------------------------------------------------------------------------

enum StringUnit {
    StringUnitWorld        = UnitWorld,
    StringUnitDisplay      = UnitDisplay,
    StringUnitPixel        = UnitPixel,
    StringUnitPoint        = UnitPoint,
    StringUnitInch         = UnitInch,
    StringUnitDocument     = UnitDocument,
    StringUnitMillimeter   = UnitMillimeter,
    StringUnitEm           = 32
};

//---------------------------------------------------------------------------
// Line spacing flags
//---------------------------------------------------------------------------

enum LineSpacing {
    LineSpacingWorld                = UnitWorld,
    LineSpacingDisplay              = UnitDisplay,
    LineSpacingPixel                = UnitPixel,
    LineSpacingPoint                = UnitPoint,
    LineSpacingInch                 = UnitInch,
    LineSpacingDocument             = UnitDocument,
    LineSpacingMillimeter           = UnitMillimeter,

    LineSpacingRecommended          = 32,
    LineSpacingAtLeast              = 33,
    LineSpacingAtLeastMultiple      = 34,
    LineSpacingCell                 = 35,
    LineSpacingCellAtLeast          = 36,
    LineSpacingCellAtLeastMultiple  = 37
};

/// The following methods of linespacing are relative to the font size
//
// =========== Method ===========  =============== Relative to ===============
//
// LineSpacingRecommended          recommended line spacing specified by font
// LineSpacingAtLeast              max(recommended, tallest glyph cell)
// LineSpacingAtLeastMultiple      smallest multiple of recommended big enough
//                                 for all glyph cells on the line
// LineSpacingCell                 cell height
// LineSpacingCellAtLeast          max(font cell height, tallest glyph cell)
// LineSpacingCellAtLeastMultiple  smallest multiple of cell height big enough
//                                 for all glyph cells on the line

//---------------------------------------------------------------------------
// National language digit substitution
//---------------------------------------------------------------------------

enum StringDigitSubstitute
{
    StringDigitSubstituteUser        = 0,  // As NLS setting
    StringDigitSubstituteNone        = 1,
    StringDigitSubstituteNational    = 2,
    StringDigitSubstituteTraditional = 3
};

//---------------------------------------------------------------------------
// Hotkey prefix interpretation
//---------------------------------------------------------------------------

enum HotkeyPrefix
{
    HotkeyPrefixNone        = 0,
    HotkeyPrefixShow        = 1,
    HotkeyPrefixHide        = 2
};

//---------------------------------------------------------------------------
// Text alignment flags
//---------------------------------------------------------------------------

enum StringAlignment
{
    // Left edge for left-to-right text,
    // right for right-to-left text,
    // and top for vertical
    StringAlignmentNear   = 0,
    StringAlignmentCenter = 1,
    StringAlignmentFar    = 2
};

//---------------------------------------------------------------------------
// DriverStringOptions
//---------------------------------------------------------------------------

enum DriverStringOptions
{
    DriverStringOptionsCmapLookup             = 1,
    DriverStringOptionsVertical               = 2,
    DriverStringOptionsRealizedAdvance        = 4,
    DriverStringOptionsCompensateResolution   = 8
};

//---------------------------------------------------------------------------
// Flush Intention flags
//---------------------------------------------------------------------------

enum FlushIntention
{
    FlushIntentionFlush = 0,        // Flush all batched rendering operations
    FlushIntentionSync = 1          // Flush all batched rendering operations
                                    // and wait for them to complete
};

//---------------------------------------------------------------------------
// Window Change Notification types
//---------------------------------------------------------------------------

enum WindowNotifyEnum
{
   WindowNotifyEnumEnable = 0,
   WindowNotifyEnumDisable,
   WindowNotifyEnumPalette,
   WindowNotifyEnumDisplay,
   WindowNotifyEnumSysColor
};

//---------------------------------------------------------------------------
// Image encoder parameter related types
//---------------------------------------------------------------------------

#ifdef DCR_USE_NEW_145804
enum EncoderParameterValueType
#else
enum ValueType
#endif
{
    ValueTypeByte           = 1,    // 8-bit unsigned int
    ValueTypeASCII          = 2,    // 8-bit byte containing one 7-bit ASCII
                                    // code. NULL terminated.
    ValueTypeShort          = 3,    // 16-bit unsigned int
    ValueTypeLong           = 4,    // 32-bit unsigned int
    ValueTypeRational       = 5,    // Two Longs. The first Long is the
                                    // numerator, the second Long expresses the
                                    // denomintor.
    ValueTypeLongRange      = 6,    // Two longs which specify a range of
                                    // integer values. The first Long specifies
                                    // the lower end and the second one
                                    // specifies the higher end. All values
                                    // are inclusive at both ends
    ValueTypeUndefined      = 7,    // 8-bit byte that can take any value
                                    // depending on field definition
    ValueTypeRationalRange  = 8     // Two Rationals. The first Rational
                                    // specifies the lower end and the second
                                    // specifies the higher end. All values
                                    // are inclusive at both ends
};

//---------------------------------------------------------------------------
// Image encoder value types
//---------------------------------------------------------------------------

enum EncoderValue
{
    EncoderValueColorTypeCMYK,
    EncoderValueColorTypeYCCK,
    EncoderValueCompressionLZW,
    EncoderValueCompressionCCITT3,
    EncoderValueCompressionCCITT4,
    EncoderValueCompressionRle,
    EncoderValueCompressionNone,
    EncoderValueScanMethodInterlaced,
    EncoderValueScanMethodNonInterlaced,
    EncoderValueVersionGif87,
    EncoderValueVersionGif89,
    EncoderValueRenderProgressive,
    EncoderValueRenderNonProgressive,
    EncoderValueTransformRotate90,
    EncoderValueTransformRotate180,
    EncoderValueTransformRotate270,
    EncoderValueTransformFlipHorizontal,
    EncoderValueTransformFlipVertical,
    #ifdef DCR_USE_NEW_140861
    EncoderValueMultiFrame,
    #else
    EncodeValueMultiFrame,
    #endif
    EncoderValueLastFrame,
    EncoderValueFlush,
    #ifdef DCR_USE_NEW_140861
    EncoderValueFrameDimensionTime,
    EncoderValueFrameDimensionResolution,
    EncoderValueFrameDimensionPage
    #else
    EncodeValueFrameDimensionTime,
    EncodeValueFrameDimensionResolution,
    EncodeValueFrameDimensionPage
    #endif
};

//---------------------------------------------------------------------------
// Graphics layout values (support for Middle East localization)
//---------------------------------------------------------------------------

enum GraphicsLayout
{
    GraphicsLayoutNormal,
    GraphicsLayoutMirrored,
    GraphicsLayoutMirroredIgnoreImages,
    GraphicsLayoutMirroredForceImages
};

//---------------------------------------------------------------------------
// Image layout values (support for Middle East localization)
//---------------------------------------------------------------------------

enum ImageLayout
{
    ImageLayoutNormal,
    ImageLayoutIgnoreMirrored
};

#endif // !_GDIPLUSENUMS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusfontfamily.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Abstract:
*
*   Font family API related declarations
*
* Revision History:
*
*
*   06/30/1999 cameronb
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUS_FONT_FAMILY_H
#define _GDIPLUS_FONT_FAMILY_H

inline 
FontFamily::FontFamily() :
    nativeFamily (NULL),
    lastResult    (Ok)
{
}

inline 
FontFamily::FontFamily(
    IN const WCHAR*          name,
    IN const FontCollection* fontCollection
)
{
    nativeFamily = NULL;
    lastResult = DllExports::GdipCreateFontFamilyFromName(
        name,
        fontCollection ? fontCollection->nativeFontCollection : NULL,
        &nativeFamily
    );
    
#ifndef DCR_USE_NEW_135429
    if ((INT) lastResult >= 10)
        lastResult = NotFound;
#endif
}

// private method
inline
FontFamily::FontFamily(
    IN GpFontFamily *nativeOrig,
    IN Status status
)
{
    lastResult    = status;
    nativeFamily = nativeOrig;
}

// Generic font family access

inline const FontFamily *
FontFamily::GenericSansSerif() 
{
    if (GenericSansSerifFontFamily != NULL)
    {
        return GenericSansSerifFontFamily;
    }

    GenericSansSerifFontFamily =
        (FontFamily*) GenericSansSerifFontFamilyBuffer;

    GenericSansSerifFontFamily->lastResult =
        DllExports::GdipGetGenericFontFamilySansSerif(
            &(GenericSansSerifFontFamily->nativeFamily)
        );

#ifndef DCR_USE_NEW_135429
    if ((INT) GenericSansSerifFontFamily->lastResult >= 10)
        GenericSansSerifFontFamily->lastResult = NotFound;
#endif

    return GenericSansSerifFontFamily;
}

inline const FontFamily *
FontFamily::GenericSerif() 
{
    if (GenericSerifFontFamily != NULL)
    {
        return GenericSerifFontFamily;
    }

    GenericSerifFontFamily =
        (FontFamily*) GenericSerifFontFamilyBuffer;

    GenericSerifFontFamily->lastResult =
        DllExports::GdipGetGenericFontFamilySerif(
            &(GenericSerifFontFamily->nativeFamily)
        );

#ifndef DCR_USE_NEW_135429
    if ((INT) GenericSerifFontFamily->lastResult >= 10)
        GenericSerifFontFamily->lastResult = NotFound;
#endif

    return GenericSerifFontFamily;
}

inline const FontFamily *
FontFamily::GenericMonospace()
{
    if (GenericMonospaceFontFamily != NULL)
    {
        return GenericMonospaceFontFamily;
    }

    GenericMonospaceFontFamily =
        (FontFamily*) GenericMonospaceFontFamilyBuffer;

    GenericMonospaceFontFamily->lastResult =
        DllExports::GdipGetGenericFontFamilyMonospace(
            &(GenericMonospaceFontFamily->nativeFamily)
        );

#ifndef DCR_USE_NEW_135429
    if ((INT) GenericMonospaceFontFamily->lastResult >= 10)
        GenericMonospaceFontFamily->lastResult = NotFound;
#endif

    return GenericMonospaceFontFamily;
}

inline FontFamily::~FontFamily()
{
    DllExports::GdipDeleteFontFamily (nativeFamily);
}

inline FontFamily *
FontFamily::Clone() const
{
    GpFontFamily * clonedFamily = NULL;

    SetStatus(DllExports::GdipCloneFontFamily (nativeFamily, &clonedFamily));

    return new FontFamily(clonedFamily, lastResult);
}

inline Status 
FontFamily::GetFamilyName(
    IN WCHAR name[LF_FACESIZE],
    IN LANGID language
) const
{
    return SetStatus(DllExports::GdipGetFamilyName(nativeFamily, 
                                                   name, 
                                                   language));
}

inline BOOL 
FontFamily::IsStyleAvailable(IN INT style) const
{
    BOOL    StyleAvailable;
    Status  status;

    status = SetStatus(DllExports::GdipIsStyleAvailable(nativeFamily, style, &StyleAvailable));

    if (status != Ok)
        StyleAvailable = FALSE;

    return StyleAvailable;
}


inline UINT16 
FontFamily::GetEmHeight(IN INT style) const
{
    UINT16  EmHeight;

    SetStatus(DllExports::GdipGetEmHeight(nativeFamily, style, &EmHeight));

    return EmHeight;
}

inline UINT16 
FontFamily::GetCellAscent(IN INT style) const
{
    UINT16  CellAscent;

    SetStatus(DllExports::GdipGetCellAscent(nativeFamily, style, &CellAscent));

    return CellAscent;
}

inline UINT16 
FontFamily::GetCellDescent(IN INT style) const
{
    UINT16  CellDescent;

    SetStatus(DllExports::GdipGetCellDescent(nativeFamily, style, &CellDescent));

    return CellDescent;
}


inline UINT16 
FontFamily::GetLineSpacing(IN INT style) const
{
    UINT16  LineSpacing;

    SetStatus(DllExports::GdipGetLineSpacing(nativeFamily, style, &LineSpacing));

    return LineSpacing;

}

#ifdef TEXTV2

// The following APIs return data from the font OS/2 table

inline INT16 
FontFamily::GetTypographicAscent(IN INT style) const
{
    INT16  TypographicAscent;

    SetStatus(DllExports::GdipGetTypographicAscent(nativeFamily, style, &TypographicAscent));

    return TypographicAscent;
}

inline INT16 
FontFamily::GetTypographicDescent(IN INT style) const
{
    INT16   TypographicDescent;

    SetStatus(DllExports::GdipGetTypographicDescent(nativeFamily, style, &TypographicDescent));

    return TypographicDescent;
}

inline INT16 
FontFamily::GetTypographicLineGap(IN INT style) const
{
    INT16   TypographicLineGap;

    SetStatus(DllExports::GdipGetTypographicLineGap(nativeFamily, style, &TypographicLineGap));

    return TypographicLineGap;
}

#endif

///////////////////////////////////////////////////////////

// GetLastStatus - return last error code and clear error code

inline Status 
FontFamily::GetLastStatus() const
{
    Status lastStatus = lastResult;
    lastResult = Ok;

    return lastStatus;
}

// protected method
inline Status
FontFamily::SetStatus(Status status) const 
{
    if (status != Ok)
        return (lastResult = status);
    else
        return status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusgraphics.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Graphics.hpp
*
* Abstract:
*
*   Declarations for Graphics class
*
* Revision History:
*
*   12/04/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSGRAPHICS_H
#define _GDIPLUSGRAPHICS_H

/**
 * Represent a graphics context
 */
class Graphics : public GdiplusBase
{
public:
    friend class Region;
    friend class GraphicsPath;
    friend class Image;
    friend class Bitmap;
    friend class Metafile;
    friend class Font;
    friend class FontFamily;
    friend class FontCollection;
    friend class CachedBitmap;

    // Get a graphics context from an existing Win32 HDC or HWND
    static Graphics* FromHDC(IN HDC hdc)
    {
        return new Graphics(hdc);
    }

    static Graphics* FromHDC(IN HDC hdc, 
                             IN HANDLE hdevice)
    {
        return new Graphics(hdc, hdevice);
    }

    static Graphics* FromHWND(IN HWND hwnd,
                              IN BOOL icm = FALSE)
    {
        return new Graphics(hwnd, icm);
    }

    static Graphics* FromImage(IN Image *image)
    {
        return new Graphics(image);
    }

    Graphics(IN HDC hdc)
    {
        GpGraphics *graphics = NULL;

        lastResult = DllExports::GdipCreateFromHDC(hdc, &graphics);

        SetNativeGraphics(graphics);
    }

    Graphics(IN HDC hdc, 
             IN HANDLE hdevice)
    {
        GpGraphics *graphics = NULL;

        lastResult = DllExports::GdipCreateFromHDC2(hdc, hdevice, &graphics);

        SetNativeGraphics(graphics);
    }

    Graphics(IN HWND hwnd, 
             IN BOOL icm = FALSE)
    {
        GpGraphics *graphics = NULL;

        if (icm) 
        {
            lastResult = DllExports::GdipCreateFromHWNDICM(hwnd, &graphics);
        }
        else
        {
            lastResult = DllExports::GdipCreateFromHWND(hwnd, &graphics);
        }

        SetNativeGraphics(graphics);
    }

    Graphics(IN Image* image)
    {
        GpGraphics *graphics = NULL;

        if (image != NULL)
        {
            lastResult = DllExports::GdipGetImageGraphicsContext(
                                                                image->nativeImage, &graphics);
        }
        SetNativeGraphics(graphics);
    }

    ~Graphics()
    {
        DllExports::GdipDeleteGraphics(nativeGraphics);
    }

    VOID Flush(IN FlushIntention intention = FlushIntentionFlush)
    {
        DllExports::GdipFlush(nativeGraphics, intention);
    }

    //------------------------------------------------------------------------
    // Interop methods
    //------------------------------------------------------------------------

    // Locks the graphics until ReleaseDC is called
    HDC GetHDC()
    {
        HDC     hdc = NULL;

        SetStatus(DllExports::GdipGetDC(nativeGraphics, &hdc));

        return hdc;
    }

    VOID ReleaseHDC(IN HDC hdc)
    {
        SetStatus(DllExports::GdipReleaseDC(nativeGraphics, hdc));
    }

    //------------------------------------------------------------------------
    // Rendering modes
    //------------------------------------------------------------------------

    Status SetRenderingOrigin(IN INT x, IN INT y)
    {
        return SetStatus(
            DllExports::GdipSetRenderingOrigin(
                nativeGraphics, x, y
            )
        );
    }

    Status GetRenderingOrigin(OUT INT *x, OUT INT *y)
    {
        return SetStatus(
            DllExports::GdipGetRenderingOrigin(
                nativeGraphics, x, y
            )
        );
    }

    Status SetCompositingMode(IN CompositingMode compositingMode)
    {
        return SetStatus(DllExports::GdipSetCompositingMode(nativeGraphics,
                                                            compositingMode));
    }

    CompositingMode GetCompositingMode() const
    {
        CompositingMode mode;

        SetStatus(DllExports::GdipGetCompositingMode(nativeGraphics,
                                                     &mode));

        return mode;
    }

    Status SetCompositingQuality(IN CompositingQuality compositingQuality)
    {
        return SetStatus(DllExports::GdipSetCompositingQuality(
            nativeGraphics,
            compositingQuality));
    }

    CompositingQuality GetCompositingQuality() const
    {
        CompositingQuality quality;

        SetStatus(DllExports::GdipGetCompositingQuality(
            nativeGraphics,
            &quality));

        return quality;
    }
    
    Status SetTextRenderingHint(IN TextRenderingHint newMode)
    {
        return SetStatus(DllExports::GdipSetTextRenderingHint(nativeGraphics,
                                                          newMode));
    }
    
    TextRenderingHint GetTextRenderingHint() const
    {
        TextRenderingHint hint;

        SetStatus(DllExports::GdipGetTextRenderingHint(nativeGraphics,
                                                   &hint));

        return hint;
    }

    Status SetTextGammaValue(IN UINT gammaValue)
    {
        return SetStatus(DllExports::GdipSetTextGammaValue(nativeGraphics,
                                                          gammaValue));
    }

    UINT GetTextGammaValue() const
    {
        UINT gammaValue;

        SetStatus(DllExports::GdipGetTextGammaValue(nativeGraphics,
                                                    &gammaValue));

        return gammaValue;
    }

    InterpolationMode GetInterpolationMode() const
    {
        InterpolationMode mode = InterpolationModeInvalid;

        SetStatus(DllExports::GdipGetInterpolationMode(nativeGraphics,
                                                           &mode));

        return mode;
    }

    Status SetInterpolationMode(IN InterpolationMode interpolationMode)
    {
        return SetStatus(DllExports::GdipSetInterpolationMode(nativeGraphics,
                                                           interpolationMode));
    }

    SmoothingMode GetSmoothingMode() const
    {
        SmoothingMode smoothingMode = SmoothingModeInvalid;

        SetStatus(DllExports::GdipGetSmoothingMode(nativeGraphics,
                                                   &smoothingMode));

        return smoothingMode;
    }

    Status SetSmoothingMode(IN SmoothingMode smoothingMode)
    {
        return SetStatus(DllExports::GdipSetSmoothingMode(nativeGraphics,
                                                          smoothingMode));
    }

    PixelOffsetMode GetPixelOffsetMode() const
    {
        PixelOffsetMode pixelOffsetMode = PixelOffsetModeInvalid;

        SetStatus(DllExports::GdipGetPixelOffsetMode(nativeGraphics,
                                                     &pixelOffsetMode));

        return pixelOffsetMode;
    }

    Status SetPixelOffsetMode(IN PixelOffsetMode pixelOffsetMode)
    {
        return SetStatus(DllExports::GdipSetPixelOffsetMode(nativeGraphics,
                                                            pixelOffsetMode));
    }

    //------------------------------------------------------------------------
    // Manipulate the current world transform
    //------------------------------------------------------------------------

    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetWorldTransform(nativeGraphics,
                                                        matrix->nativeMatrix));
    }
    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetWorldTransform(nativeGraphics));
    }

    Status MultiplyTransform(IN Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyWorldTransform(nativeGraphics,
                                                                matrix->nativeMatrix,
                                                                order));
    }

    Status TranslateTransform(IN REAL dx, 
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateWorldTransform(nativeGraphics,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleWorldTransform(nativeGraphics,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateWorldTransform(nativeGraphics,
                                                              angle, order));
    }

    /**
     * Return the current world transform
     */

    Status GetTransform(OUT Matrix* matrix) const
    {
        return SetStatus(DllExports::GdipGetWorldTransform(nativeGraphics,
                                                           matrix->nativeMatrix));
    }

    /**
     * Manipulate the current page transform
     */

    Status SetPageUnit(IN Unit unit)
    {
        return SetStatus(DllExports::GdipSetPageUnit(nativeGraphics,
                                                     unit));
    }

    Status SetPageScale(IN REAL scale)
    {
        return SetStatus(DllExports::GdipSetPageScale(nativeGraphics,
                                                      scale));
    }

    /**
     * Retrieve the current page transform information
     * notes @ these are atomic
     */
    Unit GetPageUnit() const
    {
        Unit unit;

        SetStatus(DllExports::GdipGetPageUnit(nativeGraphics, &unit));

        return unit;
    }

    REAL GetPageScale() const
    {
        REAL scale;

        SetStatus(DllExports::GdipGetPageScale(nativeGraphics, &scale));

        return scale;
    }

    REAL GetDpiX() const
    {
        REAL dpi;

        SetStatus(DllExports::GdipGetDpiX(nativeGraphics, &dpi));

        return dpi;
    }

    REAL GetDpiY() const
    {
        REAL dpi;

        SetStatus(DllExports::GdipGetDpiY(nativeGraphics, &dpi));

        return dpi;
    }

    /**
     * Transform points in the current graphics context
     */
    // float version
    Status TransformPoints(IN CoordinateSpace destSpace,
                           IN CoordinateSpace srcSpace,
                           IN OUT PointF* pts,
                           IN INT count) const
    {
        return SetStatus(DllExports::GdipTransformPoints(nativeGraphics,
                                                         destSpace,
                                                         srcSpace,
                                                         pts,
                                                         count));
    }

    // integer version
    Status TransformPoints(IN CoordinateSpace destSpace,
                           IN CoordinateSpace srcSpace,
                           IN OUT Point* pts,
                           IN INT count) const
    {

        return SetStatus(DllExports::GdipTransformPointsI(nativeGraphics,
                                                          destSpace,
                                                          srcSpace,
                                                          pts,
                                                          count));
    }

    //------------------------------------------------------------------------
    // GetNearestColor (for <= 8bpp surfaces)
    // Note: alpha is ignored
    //------------------------------------------------------------------------
    Status GetNearestColor(IN OUT Color* color) const 
    {
        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        ARGB argb = color->GetValue();

        Status status = SetStatus(DllExports::GdipGetNearestColor(nativeGraphics, &argb));
        
        color->SetValue(argb);

        return status;
    }

    /**
     * Vector drawing methods
     *
     * @notes Do we need a set of methods that take
     *  integer coordinate parameters?
     */

    // float version
    Status DrawLine(IN const Pen* pen, 
                    IN REAL x1, 
                    IN REAL y1, 
                    IN REAL x2, 
                    IN REAL y2)
    {
        return SetStatus(DllExports::GdipDrawLine(nativeGraphics,
                                                  pen->nativePen, x1, y1, x2,
                                                  y2));
    }

    Status DrawLine(IN const Pen* pen, 
                    IN const PointF& pt1, 
                    IN const PointF& pt2)
    {
        return DrawLine(pen, pt1.X, pt1.Y, pt2.X, pt2.Y);
    }

    Status DrawLines(IN const Pen* pen, 
                     IN const PointF* points, 
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawLines(nativeGraphics,
                                                   pen->nativePen,
                                                   points, count));
    }

    // int version
    Status DrawLine(IN const Pen* pen, 
                    IN INT x1, 
                    IN INT y1, 
                    IN INT x2, 
                    IN INT y2)
    {
        return SetStatus(DllExports::GdipDrawLineI(nativeGraphics,
                                                   pen->nativePen,
                                                   x1,
                                                   y1,
                                                   x2,
                                                   y2));
    }

    Status DrawLine(IN const Pen* pen, 
                    IN const Point& pt1, 
                    IN const Point& pt2)
    {
        return DrawLine(pen,
                        pt1.X,
                        pt1.Y,
                        pt2.X,
                        pt2.Y);
    }

    Status DrawLines(IN const Pen* pen, 
                     IN const Point* points, 
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawLinesI(nativeGraphics,
                                                    pen->nativePen,
                                                    points,
                                                    count));
    }

    // float version
    Status DrawArc(IN const Pen* pen, 
                   IN REAL x, 
                   IN REAL y, 
                   IN REAL width,
                   IN REAL height, 
                   IN REAL startAngle, 
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawArc(nativeGraphics,
                                                 pen->nativePen,
                                                 x,
                                                 y,
                                                 width,
                                                 height,
                                                 startAngle,
                                                 sweepAngle));
    }

    Status DrawArc(IN const Pen* pen, 
                   IN const RectF& rect,
                   IN REAL startAngle, 
                   IN REAL sweepAngle)
    {
        return DrawArc(pen, rect.X, rect.Y, rect.Width, rect.Height,
                       startAngle, sweepAngle);
    }

    // int version
    Status DrawArc(IN const Pen* pen, 
                   IN INT x, 
                   IN INT y, 
                   IN INT width,
                   IN INT height, 
                   IN REAL startAngle, 
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawArcI(nativeGraphics,
                                                  pen->nativePen,
                                                  x,
                                                  y,
                                                  width,
                                                  height,
                                                  startAngle,
                                                  sweepAngle));
    }


    Status DrawArc(IN const Pen* pen, 
                   IN const Rect& rect,
                   IN REAL startAngle, 
                   IN REAL sweepAngle)
    {
        return DrawArc(pen,
                       rect.X,
                       rect.Y,
                       rect.Width,
                       rect.Height,
                       startAngle,
                       sweepAngle);
    }

    // float version
    Status DrawBezier(IN const Pen* pen, 
                      IN REAL x1, 
                      IN REAL y1, 
                      IN REAL x2, 
                      IN REAL y2,
                      IN REAL x3, 
                      IN REAL y3, 
                      IN REAL x4, 
                      IN REAL y4)
    {
        return SetStatus(DllExports::GdipDrawBezier(nativeGraphics,
                                                    pen->nativePen, x1, y1,
                                                    x2, y2, x3, y3, x4, y4));
    }

    Status DrawBezier(IN const Pen* pen, 
                      IN const PointF& pt1, 
                      IN const PointF& pt2,
                      IN const PointF& pt3, 
                      IN const PointF& pt4)
    {
        return DrawBezier(pen,
                          pt1.X,
                          pt1.Y,
                          pt2.X,
                          pt2.Y,
                          pt3.X,
                          pt3.Y,
                          pt4.X,
                          pt4.Y);
    }

    Status DrawBeziers(IN const Pen* pen,
                       IN const PointF* points, 
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawBeziers(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count));
    }

    // int version
    Status DrawBezier(IN const Pen* pen,
                      IN INT x1, 
                      IN INT y1, 
                      IN INT x2, 
                      IN INT y2,
                      IN INT x3, 
                      IN INT y3,
                      IN INT x4, 
                      IN INT y4)
    {
        return SetStatus(DllExports::GdipDrawBezierI(nativeGraphics,
                                                     pen->nativePen,
                                                     x1,
                                                     y1,
                                                     x2,
                                                     y2,
                                                     x3,
                                                     y3,
                                                     x4,
                                                     y4));
    }

    Status DrawBezier(IN const Pen* pen,
                      IN const Point& pt1,
                      IN const Point& pt2,
                      IN const Point& pt3,
                      IN const Point& pt4)
    {
        return DrawBezier(pen,
                          pt1.X,
                          pt1.Y,
                          pt2.X,
                          pt2.Y,
                          pt3.X,
                          pt3.Y,
                          pt4.X,
                          pt4.Y);
    }

    Status DrawBeziers(IN const Pen* pen, 
                       IN const Point* points, 
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawBeziersI(nativeGraphics,
                                                      pen->nativePen,
                                                      points,
                                                      count));
    }

    // float version
    Status DrawRectangle(IN const Pen* pen, 
                         IN const RectF& rect)
    {
        return DrawRectangle(pen, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status DrawRectangle(IN const Pen* pen, 
                         IN REAL x, 
                         IN REAL y, 
                         IN REAL width,
                         IN REAL height)
    {
        return SetStatus(DllExports::GdipDrawRectangle(nativeGraphics,
                                                       pen->nativePen, x, y,
                                                       width, height));
    }

    Status DrawRectangles(IN const Pen* pen, 
                          IN const RectF* rects, 
                          IN INT count)
    {
        return SetStatus(DllExports::GdipDrawRectangles(nativeGraphics,
                                                        pen->nativePen,
                                                        rects, count));
    }

    // integer version
    Status DrawRectangle(IN const Pen* pen, 
                         IN const Rect& rect)
    {
        return DrawRectangle(pen,
                             rect.X,
                             rect.Y,
                             rect.Width,
                             rect.Height);
    }

    Status DrawRectangle(IN const Pen* pen, 
                         IN INT x, 
                         IN INT y, 
                         IN INT width, 
                         IN INT height)
    {
        return SetStatus(DllExports::GdipDrawRectangleI(nativeGraphics,
                                                        pen->nativePen,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    Status DrawRectangles(IN const Pen* pen, 
                          IN const Rect* rects, 
                          IN INT count)
    {
        return SetStatus(DllExports::GdipDrawRectanglesI(nativeGraphics,
                                                         pen->nativePen,
                                                         rects,
                                                         count));
    }

    // float version
    Status DrawEllipse(IN const Pen* pen, 
                       IN const RectF& rect)
    {
        return DrawEllipse(pen, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status DrawEllipse(IN const Pen* pen, 
                       IN REAL x, 
                       IN REAL y, 
                       IN REAL width, 
                       IN REAL height)
    {
        return SetStatus(DllExports::GdipDrawEllipse(nativeGraphics,
                                                     pen->nativePen,
                                                     x,
                                                     y,
                                                     width,
                                                     height));
    }

    // integer version
    Status DrawEllipse(IN const Pen* pen, 
                       IN const Rect& rect)
    {
        return DrawEllipse(pen,
                           rect.X,
                           rect.Y,
                           rect.Width,
                           rect.Height);
    }

    Status DrawEllipse(IN const Pen* pen, 
                       IN INT x, 
                       IN INT y, 
                       IN INT width, 
                       IN INT height)
    {
        return SetStatus(DllExports::GdipDrawEllipseI(nativeGraphics,
                                                      pen->nativePen,
                                                      x,
                                                      y,
                                                      width,
                                                      height));
    }

    // floating point version
    Status DrawPie(IN const Pen* pen, 
                   IN const RectF& rect, 
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return DrawPie(pen,
                       rect.X,
                       rect.Y,
                       rect.Width,
                       rect.Height,
                       startAngle,
                       sweepAngle);
    }

    Status DrawPie(IN const Pen* pen, 
                   IN REAL x, 
                   IN REAL y, 
                   IN REAL width,
                   IN REAL height, 
                   IN REAL startAngle, 
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawPie(nativeGraphics,
                                                 pen->nativePen,
                                                 x,
                                                 y,
                                                 width,
                                                 height,
                                                 startAngle,
                                                 sweepAngle));
    }

    // integer point version
    Status DrawPie(IN const Pen* pen, 
                   IN const Rect& rect,
                   IN REAL startAngle, 
                   IN REAL sweepAngle)
    {
        return DrawPie(pen,
                       rect.X,
                       rect.Y,
                       rect.Width,
                       rect.Height,
                       startAngle,
                       sweepAngle);
    }

    Status DrawPie(IN const Pen* pen, 
                   IN INT x, 
                   IN INT y, 
                   IN INT width, 
                   IN INT height,
                   IN REAL startAngle, 
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawPieI(nativeGraphics,
                                                  pen->nativePen,
                                                  x,
                                                  y,
                                                  width,
                                                  height,
                                                  startAngle,
                                                  sweepAngle));
    }

    // float version
    Status DrawPolygon(IN const Pen* pen, 
                       IN const PointF* points, 
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawPolygon(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count));
    }

    // integer version
    Status DrawPolygon(IN const Pen* pen, 
                       IN const Point* points, 
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawPolygonI(nativeGraphics,
                                                      pen->nativePen,
                                                      points,
                                                      count));
    }

    // float version
    Status DrawPath(IN const Pen* pen, 
                    IN const GraphicsPath* path)
    {
        return SetStatus(DllExports::GdipDrawPath(nativeGraphics,
                                                  pen->nativePen,
                                                  path->nativePath));
    }

    // float version
    Status DrawCurve(IN const Pen* pen, 
                     IN const PointF* points, 
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawCurve(nativeGraphics,
                                                   pen->nativePen, points,
                                                   count));
    }

    Status DrawCurve(IN const Pen* pen, 
                     IN const PointF* points, 
                     IN INT count,
                     IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawCurve2(nativeGraphics,
                                                    pen->nativePen, points,
                                                    count, tension));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const PointF* points, 
                     IN INT count,
                     IN INT offset, 
                     IN INT numberOfSegments, 
                     IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipDrawCurve3(nativeGraphics,
                                                    pen->nativePen, points,
                                                    count, offset,
                                                    numberOfSegments, tension));
    }

    // integer version
    Status DrawCurve(IN const Pen* pen, 
                     IN const Point* points, 
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawCurveI(nativeGraphics,
                                                    pen->nativePen,
                                                    points,
                                                    count));
    }

    Status DrawCurve(IN const Pen* pen, 
                     IN const Point* points, 
                     IN INT count,
                     IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawCurve2I(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count,
                                                     tension));
    }

    Status DrawCurve(IN const Pen* pen, 
                     IN const Point* points, 
                     IN INT count,
                     IN INT offset, 
                     IN INT numberOfSegments, 
                     IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipDrawCurve3I(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count,
                                                     offset,
                                                     numberOfSegments,
                                                     tension));
    }

    // float version
    Status DrawClosedCurve(IN const Pen* pen, 
                           IN const PointF* points, 
                           IN INT count)
    {
        return SetStatus(DllExports::GdipDrawClosedCurve(nativeGraphics,
                                                         pen->nativePen,
                                                         points, count));
    }

    Status DrawClosedCurve(IN const Pen *pen, 
                           IN const PointF* points, 
                           IN INT count,
                           IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawClosedCurve2(nativeGraphics,
                                                          pen->nativePen,
                                                          points, count,
                                                          tension));
    }

    // integer version
    Status DrawClosedCurve(IN const Pen* pen, 
                           IN const Point* points, 
                           IN INT count)
    {
        return SetStatus(DllExports::GdipDrawClosedCurveI(nativeGraphics,
                                                          pen->nativePen,
                                                          points,
                                                          count));
    }

    Status DrawClosedCurve(IN const Pen *pen, 
                           IN const Point* points, 
                           IN INT count,
                           IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawClosedCurve2I(nativeGraphics,
                                                           pen->nativePen,
                                                           points,
                                                           count,
                                                           tension));
    }

    Status Clear(IN const Color &color)
    {
        return SetStatus(DllExports::GdipGraphicsClear(
            nativeGraphics,
            color.GetValue()));
    }

    // float version
    Status FillRectangle(IN const Brush* brush, 
                         IN const RectF& rect)
    {
        return FillRectangle(brush, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status FillRectangle(IN const Brush* brush, 
                         IN REAL x, 
                         IN REAL y, 
                         IN REAL width,
                         IN REAL height)
    {
        return SetStatus(DllExports::GdipFillRectangle(nativeGraphics,
                                                       brush->nativeBrush, x, y,
                                                       width, height));
    }

    Status FillRectangles(IN const Brush* brush, 
                          IN const RectF* rects, 
                          IN INT count)
    {
        return SetStatus(DllExports::GdipFillRectangles(nativeGraphics,
                                                        brush->nativeBrush,
                                                        rects, count));
    }

    // integer version
    Status FillRectangle(IN const Brush* brush, 
                         IN const Rect& rect)
    {
        return FillRectangle(brush,
                             rect.X,
                             rect.Y,
                             rect.Width,
                             rect.Height);
    }

    Status FillRectangle(IN const Brush* brush, 
                         IN INT x, 
                         IN INT y, 
                         IN INT width,
                         IN INT height)
    {
        return SetStatus(DllExports::GdipFillRectangleI(nativeGraphics,
                                                        brush->nativeBrush,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    Status FillRectangles(IN const Brush* brush, 
                          IN const Rect* rects, 
                          IN INT count)
    {
        return SetStatus(DllExports::GdipFillRectanglesI(nativeGraphics,
                                                         brush->nativeBrush,
                                                         rects,
                                                         count));
    }

    // float version
    Status FillPolygon(IN const Brush* brush, 
                       IN const PointF* points,
                       IN INT count)
    {
        return FillPolygon(brush, points, count, FillModeAlternate);
    }

    Status FillPolygon(IN const Brush* brush, 
                       IN const PointF* points, 
                       IN INT count,
                       IN FillMode fillMode)
    {
        return SetStatus(DllExports::GdipFillPolygon(nativeGraphics,
                                                     brush->nativeBrush,
                                                     points, count, fillMode));
    }

    // integer version
    Status FillPolygon(IN const Brush* brush, 
                       IN const Point* points, 
                       IN INT count)
    {
        return FillPolygon(brush, points, count, FillModeAlternate);
    }

    Status FillPolygon(IN const Brush* brush, 
                       IN const Point* points, 
                       IN INT count,
                       IN FillMode fillMode)
    {
        return SetStatus(DllExports::GdipFillPolygonI(nativeGraphics,
                                                      brush->nativeBrush,
                                                      points, count,
                                                      fillMode));
    }

    // float version
    Status FillEllipse(IN const Brush* brush, 
                       IN const RectF& rect)
    {
        return FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status FillEllipse(IN const Brush* brush, 
                       IN REAL x, 
                       IN REAL y, 
                       IN REAL width,
                       IN REAL height)
    {
        return SetStatus(DllExports::GdipFillEllipse(nativeGraphics,
                                                     brush->nativeBrush, x, y,
                                                     width, height));
    }

    // integer version
    Status FillEllipse(IN const Brush* brush, 
                       IN const Rect& rect)
    {
        return FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status FillEllipse(IN const Brush* brush, 
                       IN INT x, 
                       IN INT y, 
                       IN INT width, 
                       IN INT height)
    {
        return SetStatus(DllExports::GdipFillEllipseI(nativeGraphics,
                                                      brush->nativeBrush,
                                                      x,
                                                      y,
                                                      width,
                                                      height));
    }

    // float version
    Status FillPie(IN const Brush* brush, 
                   IN const RectF& rect, 
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return FillPie(brush, rect.X, rect.Y, rect.Width, rect.Height,
                       startAngle, sweepAngle);
    }

    Status FillPie(IN const Brush* brush, 
                   IN REAL x, 
                   IN REAL y, 
                   IN REAL width,
                   IN REAL height, 
                   IN REAL startAngle, 
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipFillPie(nativeGraphics,
                                                 brush->nativeBrush, x, y,
                                                 width, height, startAngle,
                                                 sweepAngle));
    }

    // integer version
    Status FillPie(IN const Brush* brush, 
                   IN const Rect& rect, 
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return FillPie(brush, rect.X, rect.Y, rect.Width, rect.Height,
                       startAngle, sweepAngle);
    }

    Status FillPie(IN const Brush* brush, 
                   IN INT x, 
                   IN INT y, 
                   IN INT width,
                   IN INT height, 
                   IN REAL startAngle, 
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipFillPieI(nativeGraphics,
                                                  brush->nativeBrush,
                                                  x,
                                                  y,
                                                  width,
                                                  height,
                                                  startAngle,
                                                  sweepAngle));
    }

    Status FillPath(IN const Brush* brush, 
                    IN const GraphicsPath* path)
    {
        return SetStatus(DllExports::GdipFillPath(nativeGraphics,
                                                  brush->nativeBrush,
                                                  path->nativePath));
    }

    // float version
    Status FillClosedCurve(IN const Brush* brush, 
                           IN const PointF* points, 
                           IN INT count)
    {
        return SetStatus(DllExports::GdipFillClosedCurve(nativeGraphics,
                                                         brush->nativeBrush,
                                                         points, count));

    }

    Status FillClosedCurve(IN const Brush* brush, 
                           IN const PointF* points, 
                           IN INT count,
                           IN FillMode fillMode, 
                           IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipFillClosedCurve2(nativeGraphics,
                                                          brush->nativeBrush,
                                                          points, count,
                                                          tension, fillMode));
    }

    // integer version
    Status FillClosedCurve(IN const Brush* brush, 
                           IN const Point* points,
                           IN INT count)
    {
        return SetStatus(DllExports::GdipFillClosedCurveI(nativeGraphics,
                                                          brush->nativeBrush,
                                                          points,
                                                          count));
    }

    Status FillClosedCurve(IN const Brush* brush, 
                           IN const Point* points, 
                           IN INT count,
                           IN FillMode fillMode, 
                           IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipFillClosedCurve2I(nativeGraphics,
                                                           brush->nativeBrush,
                                                           points, count,
                                                           tension, fillMode));
    }

    // float version
    Status FillRegion(IN const Brush* brush, 
                      IN const Region* region)
    {
        return SetStatus(DllExports::GdipFillRegion(nativeGraphics,
                                                    brush->nativeBrush,
                                                    region->nativeRegion));
    }

    // DrawString and MeasureString
    Status
    DrawString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const RectF        &layoutRect,
        IN const StringFormat *stringFormat,
        IN const Brush        *brush
    )
    {
        return SetStatus(DllExports::GdipDrawString(
            nativeGraphics,
            string,
            length,
            font->nativeFont,
            &layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            brush->nativeBrush
        ));
    }

    Status
    DrawString(
        const WCHAR        *string,
        INT                 length,
        const Font         *font,
        const PointF       &origin,
        const Brush        *brush
    )
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipDrawString(
            nativeGraphics,
            string,
            length,
            font->nativeFont,
            &rect,
            NULL,
            brush->nativeBrush
        ));
    }

    Status
    DrawString(
        const WCHAR        *string,
        INT                 length,
        const Font         *font,
        const PointF       &origin,
        const StringFormat *stringFormat,
        const Brush        *brush
    )
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipDrawString(
            nativeGraphics,
            string,
            length,
            font->nativeFont,
            &rect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            brush->nativeBrush
        ));
    }

    Status
    MeasureString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const RectF        &layoutRect,
        IN const StringFormat *stringFormat,
        OUT RectF             *boundingBox,
        OUT INT               *codepointsFitted = 0,
        OUT INT               *linesFilled      = 0
    ) const
    {
        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font->nativeFont,
            &layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            boundingBox,
            codepointsFitted,
            linesFilled
        ));
    }

    Status
    MeasureString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const SizeF        &layoutRectSize,
        IN const StringFormat *stringFormat,
        OUT SizeF             *size,
        OUT INT               *codepointsFitted = 0,
        OUT INT               *linesFilled      = 0
    ) const
    {
        RectF   layoutRect(0, 0, layoutRectSize.Width, layoutRectSize.Height);
        RectF   boundingBox;
        Status  status;
            
        if (size == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        status = SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font->nativeFont,
            &layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            size ? &boundingBox : NULL,
            codepointsFitted,
            linesFilled
        ));

        if (size && status == Ok)
        {
            size->Width  = boundingBox.Width;
            size->Height = boundingBox.Height;
        }

        return status;
    }

    Status
    MeasureString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const PointF       &origin,
        IN const StringFormat *stringFormat,
        OUT RectF             *boundingBox
    ) const
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font->nativeFont,
            &rect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            boundingBox,
            NULL,
            NULL
        ));
    }


    Status
    MeasureString(
        IN const WCHAR  *string,
        IN INT           length,
        IN const Font   *font,
        IN const RectF  &layoutRect,
        OUT RectF       *boundingBox
    ) const 
    {
        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font->nativeFont,
            &layoutRect,
            NULL,
            boundingBox,
            NULL,
            NULL
        ));
    }

    Status
    MeasureString(
        IN const WCHAR  *string,
        IN INT           length,
        IN const Font   *font,
        IN const PointF &origin,
        OUT RectF       *boundingBox
    ) const
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font->nativeFont,
            &rect,
            NULL,
            boundingBox,
            NULL,
            NULL
        ));
    }

    Status
    MeasureStringRegion(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const RectF        &layoutRect,
        IN const StringFormat *stringFormat,
        IN INT                 firstCharacterIndex,
        IN INT                 characterCount,
        OUT Region            *region
    ) const
    {
        if (region == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        return (SetStatus(DllExports::GdipMeasureStringRegion(
            nativeGraphics,
            string,
            length,
            font->nativeFont,
            layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            firstCharacterIndex,
            characterCount,
            region->nativeRegion)));
    }

    Status DrawDriverString(
        IN const UINT16  *text,
        IN INT            length,
        IN const Font    *font,
        IN const Brush   *brush,
        IN const PointF  *positions,
        IN INT            flags,
        IN Matrix        *matrix
    )
    {
        return SetStatus(DllExports::GdipDrawDriverString(
            nativeGraphics,
            text,
            length,
            font ? font->nativeFont : NULL,
            brush ? brush->nativeBrush : NULL,
            positions,
            flags,
            matrix ? matrix->nativeMatrix : NULL
        ));
    }

    Status MeasureDriverString(
        IN const UINT16  *text,
        IN INT            length,
        IN const Font    *font,
        IN const PointF  *positions,
        IN INT            flags,
        IN Matrix        *matrix,
        OUT RectF        *boundingBox
    ) const
    {
        return SetStatus(DllExports::GdipMeasureDriverString(
            nativeGraphics,
            text,
            length,
            font ? font->nativeFont : NULL,
            positions,
            flags,
            matrix ? matrix->nativeMatrix : NULL,
            boundingBox
        ));
    }

    Status DriverStringPointToCodepoint(
        IN const UINT16  *text,
        IN INT            length,
        IN const Font    *font,
        IN const PointF  *positions,
        IN INT            flags,
        IN Matrix        *matrix,
        IN const PointF  &hit,
        OUT INT          *index,
        OUT BOOL         *rightEdge,
        OUT REAL         *distance
    )
    {
        return SetStatus(DllExports::GdipDriverStringPointToCodepoint(
            nativeGraphics,
            text,
            length,
            font ? font->nativeFont : NULL,
            positions,
            flags,
            matrix ? matrix->nativeMatrix : NULL,
            &hit,
            index,
            rightEdge,
            distance
        ));
    }


    // Draw a cached bitmap on this graphics destination offset by
    // x, y. Note this will fail with WrongState if the CachedBitmap
    // native format differs from this Graphics.

    Status DrawCachedBitmap(IN CachedBitmap *cb,
                            IN INT x, 
                            IN INT y)
    {
        return SetStatus(DllExports::GdipDrawCachedBitmap(
            nativeGraphics, 
            cb->nativeCachedBitmap,
            x, y
        ));
    }

    /**
     * Draw images (both bitmap and vector)
     */
    // float version
    Status DrawImage(IN Image* image,
                     IN const PointF& point)
    {
        return DrawImage(image, point.X, point.Y);
    }

    Status DrawImage(IN Image* image, 
                     IN REAL x, 
                     IN REAL y)
    {
        return SetStatus(DllExports::GdipDrawImage(nativeGraphics,
                                                   image ? image->nativeImage
                                                         : NULL,
                                                   x,
                                                   y));
    }

    Status DrawImage(IN Image* image, 
                     IN RectF& rect)
    {
        return DrawImage(image, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status DrawImage(IN Image* image,
                     IN REAL x, 
                     IN REAL y, 
                     IN REAL width, 
                     IN REAL height)
    {
        return SetStatus(DllExports::GdipDrawImageRect(nativeGraphics,
                                                       image ? image->nativeImage
                                                             : NULL,
                                                       x,
                                                       y,
                                                       width,
                                                       height));
    }

    // integer version
    Status DrawImage(IN Image* image, 
                     IN const Point& point)
    {
        return DrawImage(image, point.X, point.Y);
    }

    Status DrawImage(IN Image* image, 
                     IN INT x, 
                     IN INT y)
    {
        return SetStatus(DllExports::GdipDrawImageI(nativeGraphics,
                                                    image ? image->nativeImage
                                                          : NULL,
                                                    x,
                                                    y));
    }

    Status DrawImage(IN Image* image, 
                     IN const Rect& rect)
    {
        return DrawImage(image,
                         rect.X,
                         rect.Y,
                         rect.Width,
                         rect.Height);
    }

    Status DrawImage(IN Image* image,
                     IN INT x, 
                     IN INT y,
                     IN INT width,
                     IN INT height) {
        return SetStatus(DllExports::GdipDrawImageRectI(nativeGraphics,
                                                        image ? image->nativeImage
                                                              : NULL,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    /**
     * Affine or perspective blt
     *  destPoints.length = 3: rect => parallelogram
     *      destPoints[0] <=> top-left corner of the source rectangle
     *      destPoints[1] <=> top-right corner
     *      destPoints[2] <=> bottom-left corner
     *  destPoints.length = 4: rect => quad
     *      destPoints[3] <=> bottom-right corner
     *
     *  @notes Perspective blt only works for bitmap images.
     */
    Status DrawImage(IN Image* image,
                     IN const PointF* destPoints, 
                     IN INT count)
    {
        if (count != 3 && count != 4)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipDrawImagePoints(nativeGraphics,
                                                         image ? image->nativeImage
                                                               : NULL,
                                                         destPoints, count));
    }

    Status DrawImage(IN Image* image, 
                     IN const Point* destPoints, 
                     IN INT count)
    {
        if (count != 3 && count != 4)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipDrawImagePointsI(nativeGraphics,
                                                          image ? image->nativeImage
                                                                : NULL,
                                                          destPoints,
                                                          count));
    }

    /**
     * We need another set of methods similar to the ones above
     * that take an additional Rect parameter to specify the
     * portion of the source image to be drawn.
     */
    // float version
    Status DrawImage(IN Image* image,
                     IN REAL x, 
                     IN REAL y, 
                     IN REAL srcx, 
                     IN REAL srcy,
                     IN REAL srcwidth, 
                     IN REAL srcheight, 
                     IN Unit srcUnit)
    {
        return SetStatus(DllExports::GdipDrawImagePointRect(nativeGraphics,
                                                            image ? image->nativeImage
                                                                  : NULL,
                                                            x, y,
                                                            srcx, srcy,
                                                            srcwidth, srcheight, srcUnit));
    }

    Status DrawImage(IN Image* image,
                     IN const RectF& destRect,
                     IN REAL srcx, 
                     IN REAL srcy, 
                     IN REAL srcwidth,
                     IN REAL srcheight,
                     IN Unit srcUnit,
                     IN ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImageRectRect(nativeGraphics,
                                                           image ? image->nativeImage
                                                                 : NULL,
                                                           destRect.X,
                                                           destRect.Y,
                                                           destRect.Width,
                                                           destRect.Height,
                                                           srcx, srcy,
                                                           srcwidth, srcheight,
                                                           srcUnit,
                                                           imageAttributes
                                                            ? imageAttributes->nativeImageAttr
                                                            : NULL,
                                                           callback,
                                                           callbackData));
    }

    Status DrawImage(IN Image* image, 
                     IN const PointF* destPoints,
                     IN INT count, 
                     IN REAL srcx, 
                     IN REAL srcy, 
                     IN REAL srcwidth,
                     IN REAL srcheight, 
                     IN Unit srcUnit,
                     IN ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImagePointsRect(nativeGraphics,
                                                             image ? image->nativeImage
                                                                   : NULL,
                                                             destPoints, count,
                                                             srcx, srcy,
                                                             srcwidth,
                                                             srcheight,
                                                             srcUnit,
                                                             imageAttributes
                                                              ? imageAttributes->nativeImageAttr
                                                              : NULL,
                                                             callback,
                                                             callbackData));
    }

    // integer version
    Status DrawImage(IN Image* image, 
                     IN INT x, 
                     IN INT y, 
                     IN INT srcx, 
                     IN INT srcy,
                     IN INT srcwidth, 
                     IN INT srcheight, 
                     IN Unit srcUnit)
    {
        return SetStatus(DllExports::GdipDrawImagePointRectI(nativeGraphics,
                                                             image ? image->nativeImage
                                                                   : NULL,
                                                             x,
                                                             y,
                                                             srcx,
                                                             srcy,
                                                             srcwidth,
                                                             srcheight,
                                                             srcUnit));
    }

    Status DrawImage(IN Image* image, 
                     IN const Rect& destRect,
                     IN INT srcx, 
                     IN INT srcy, 
                     IN INT srcwidth, 
                     IN INT srcheight,
                     IN Unit srcUnit,
                     IN ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImageRectRectI(nativeGraphics,
                                                            image ? image->nativeImage
                                                                  : NULL,
                                                            destRect.X,
                                                            destRect.Y,
                                                            destRect.Width,
                                                            destRect.Height,
                                                            srcx,
                                                            srcy,
                                                            srcwidth,
                                                            srcheight,
                                                            srcUnit,
                                                            imageAttributes
                                                            ? imageAttributes->nativeImageAttr
                                                            : NULL,
                                                            callback,
                                                            callbackData));
    }

    Status DrawImage(IN Image* image, 
                     IN const Point* destPoints,
                     IN INT count, 
                     IN INT srcx, 
                     IN INT srcy, 
                     IN INT srcwidth, 
                     IN INT srcheight,
                     IN Unit srcUnit,
                     IN ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImagePointsRectI(nativeGraphics,
                                                              image ? image->nativeImage
                                                                    : NULL,
                                                              destPoints,
                                                              count,
                                                              srcx,
                                                              srcy,
                                                              srcwidth,
                                                              srcheight,
                                                              srcUnit,
                                                              imageAttributes
                                                               ? imageAttributes->nativeImageAttr
                                                               : NULL,
                                                              callback,
                                                              callbackData));
    }

    // The following methods are for playing an EMF+ to a graphics
    // via the enumeration interface.  Each record of the EMF+ is
    // sent to the callback (along with the callbackData).  Then
    // the callback can invoke the Metafile::PlayRecord method
    // to play the particular record.

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF &          destPoint,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPoint(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point &           destPoint,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPointI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const RectF &           destRect,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestRect(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Rect &            destRect,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestRectI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF *          destPoints,
        IN INT                     count,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPoints(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point *           destPoints,
        IN INT                     count,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPointsI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF &          destPoint,
        IN const RectF &           srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPoint(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point &           destPoint,
        IN const Rect &            srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPointI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const RectF &           destRect,
        IN const RectF &           srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestRect(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Rect &            destRect,
        IN const Rect &            srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestRectI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF *          destPoints,
        IN INT                     count,
        IN const RectF &           srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPoints(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point *           destPoints,
        IN INT                     count,
        IN const Rect &            srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPointsI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    /**
      * Clipping region operations
      *
      * @notes Simply incredible redundancy here.
      */
    Status SetClip(IN const Graphics* g, 
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipGraphics(nativeGraphics,
                                                         g->nativeGraphics,
                                                         combineMode));
    }

    Status SetClip(IN const RectF& rect, 
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipRect(nativeGraphics,
                                                     rect.X, rect.Y,
                                                     rect.Width, rect.Height,
                                                     combineMode));
    }

    Status SetClip(IN const Rect& rect, 
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipRectI(nativeGraphics,
                                                      rect.X, rect.Y,
                                                      rect.Width, rect.Height,
                                                      combineMode));
    }

    Status SetClip(IN const GraphicsPath* path,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipPath(nativeGraphics,
                                                     path->nativePath,
                                                     combineMode));
    }

    Status SetClip(IN const Region* region,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipRegion(nativeGraphics,
                                                       region->nativeRegion,
                                                       combineMode));
    }

    // This is different than the other SetClip methods because it assumes
    // that the HRGN is already in device units, so it doesn't transform
    // the coordinates in the HRGN.
    Status SetClip(IN HRGN hRgn, 
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipHrgn(nativeGraphics, hRgn,
                                                     combineMode));
    }

    Status IntersectClip(IN const RectF& rect)
    {
        return SetStatus(DllExports::GdipSetClipRect(nativeGraphics,
                                                     rect.X, rect.Y,
                                                     rect.Width, rect.Height,
                                                     CombineModeIntersect));
    }

    Status IntersectClip(IN const Rect& rect)
    {
        return SetStatus(DllExports::GdipSetClipRectI(nativeGraphics,
                                                      rect.X, rect.Y,
                                                      rect.Width, rect.Height,
                                                      CombineModeIntersect));
    }

    Status IntersectClip(IN const Region* region)
    {
        return SetStatus(DllExports::GdipSetClipRegion(nativeGraphics,
                                                       region->nativeRegion,
                                                       CombineModeIntersect));
    }

    Status ExcludeClip(IN const RectF& rect)
    {
        return SetStatus(DllExports::GdipSetClipRect(nativeGraphics,
                                                     rect.X, rect.Y,
                                                     rect.Width, rect.Height,
                                                     CombineModeExclude));
    }

    Status ExcludeClip(IN const Rect& rect)
    {
        return SetStatus(DllExports::GdipSetClipRectI(nativeGraphics,
                                                      rect.X, rect.Y,
                                                      rect.Width, rect.Height,
                                                      CombineModeExclude));
    }

    Status ExcludeClip(IN const Region* region)
    {
        return SetStatus(DllExports::GdipSetClipRegion(nativeGraphics,
                                                       region->nativeRegion,
                                                       CombineModeExclude));
    }

    Status ResetClip()
    {
        return SetStatus(DllExports::GdipResetClip(nativeGraphics));
    }

    Status TranslateClip(IN REAL dx, 
                         IN REAL dy)
    {
        return SetStatus(DllExports::GdipTranslateClip(nativeGraphics, dx, dy));
    }

    Status TranslateClip(IN INT dx, 
                         IN INT dy)
    {
        return SetStatus(DllExports::GdipTranslateClipI(nativeGraphics,
                                                        dx, dy));
    }

    /**
     *  GetClip region from graphics context
     */
    Status GetClip(OUT Region* region) const
    {
        return SetStatus(DllExports::GdipGetClip(nativeGraphics, 
                                                 region->nativeRegion));
    }

    /**
     * Hit testing operations
     */
    Status GetClipBounds(OUT RectF* rect) const
    {
        return SetStatus(DllExports::GdipGetClipBounds(nativeGraphics, rect));
    }

    Status GetClipBounds(OUT Rect* rect) const
    {
        return SetStatus(DllExports::GdipGetClipBoundsI(nativeGraphics, rect));
    }

    BOOL IsClipEmpty() const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsClipEmpty(nativeGraphics, &booln));

        return booln;
    }

    Status GetVisibleClipBounds(OUT RectF *rect) const
    {

        return SetStatus(DllExports::GdipGetVisibleClipBounds(nativeGraphics,
                                                              rect));
    }

    Status GetVisibleClipBounds(OUT Rect *rect) const
    {
       return SetStatus(DllExports::GdipGetVisibleClipBoundsI(nativeGraphics,
                                                              rect));
    }

    BOOL IsVisibleClipEmpty() const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsVisibleClipEmpty(nativeGraphics, &booln));

        return booln;
    }

    BOOL IsVisible(IN INT x,
                   IN INT y) const
    {
        return IsVisible(Point(x,y));
    }

    BOOL IsVisible(IN const Point& point) const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsVisiblePointI(nativeGraphics,
                                                  point.X,
                                                  point.Y,
                                                  &booln));

        return booln;
    }

    BOOL IsVisible(IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height) const
    {
        return IsVisible(Rect(x, y, width, height));
    }

    BOOL IsVisible(IN const Rect& rect) const
    {
        
        BOOL booln = TRUE;

        SetStatus(DllExports::GdipIsVisibleRectI(nativeGraphics,
                                                 rect.X,
                                                 rect.Y,
                                                 rect.Width,
                                                 rect.Height,
                                                 &booln));
        return booln;
    }

    BOOL IsVisible(IN REAL x,
                   IN REAL y) const
    {
        return IsVisible(PointF(x, y));
    }

    BOOL IsVisible(IN const PointF& point) const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsVisiblePoint(nativeGraphics,
                                                 point.X,
                                                 point.Y,
                                                 &booln));

        return booln;
    }

    BOOL IsVisible(IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height) const
    {
        return IsVisible(RectF(x, y, width, height));
    }

    BOOL IsVisible(IN const RectF& rect) const
    {
        BOOL booln = TRUE;

        SetStatus(DllExports::GdipIsVisibleRect(nativeGraphics,
                                                rect.X,
                                                rect.Y,
                                                rect.Width,
                                                rect.Height,
                                                &booln));
        return booln;
    }

    /**
     * Save/restore graphics state
     */
    GraphicsState Save() const
    {
        GraphicsState gstate;

        SetStatus(DllExports::GdipSaveGraphics(nativeGraphics, &gstate));

        return gstate;
    }

    Status Restore(IN GraphicsState gstate)
    {
        return SetStatus(DllExports::GdipRestoreGraphics(nativeGraphics,
                                                         gstate));
    }

    /**
     * Begin and end container drawing
     */
    GraphicsContainer BeginContainer(IN const RectF &dstrect,
                                     IN const RectF &srcrect,
                                     IN Unit         unit)
    {
        GraphicsContainer state;

        SetStatus(DllExports::GdipBeginContainer(nativeGraphics, &dstrect,
                                                 &srcrect, unit, &state));

        return state;
    }

    /**
     * Begin and end container drawing
     */
    GraphicsContainer BeginContainer(IN const Rect    &dstrect,
                                     IN const Rect    &srcrect,
                                     IN Unit           unit)
    {
        GraphicsContainer state;

        SetStatus(DllExports::GdipBeginContainerI(nativeGraphics, &dstrect,
                                                  &srcrect, unit, &state));

        return state;
    }

    GraphicsContainer BeginContainer()
    {
        GraphicsContainer state;

        SetStatus(DllExports::GdipBeginContainer2(nativeGraphics, &state));

        return state;
    }

    Status EndContainer(IN GraphicsContainer state)
    {
        return SetStatus(DllExports::GdipEndContainer(nativeGraphics, state));
    }

    // only valid when recording metafiles
    Status AddMetafileComment(IN const BYTE * data,
                              IN UINT sizeData)
    {
        return SetStatus(DllExports::GdipComment(nativeGraphics, sizeData, data));
    }

    /**
     * Get/SetLayout
     * Support for Middle East localization (right-to-left mirroring)
     */
    GraphicsLayout GetLayout() const
    {
        GraphicsLayout layout;

        SetStatus(DllExports::GdipGetGraphicsLayout(nativeGraphics, &layout));

        return layout;
    }

    Status SetLayout(IN const GraphicsLayout layout)
    {
        SetStatus(DllExports::GdipSetGraphicsLayout(nativeGraphics, layout));
    }

    static HPALETTE GetHalftonePalette()
    {
        return DllExports::GdipCreateHalftonePalette();
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

protected:
    Graphics(const Graphics& graphics)
    {
        graphics;
        SetStatus(NotImplemented);
    }

    Graphics& operator=(const Graphics& graphics)
    {
        graphics;
        SetStatus(NotImplemented);
        return *this;
    }

    Graphics(GpGraphics* graphics)
    {
        lastResult = Ok;
        SetNativeGraphics(graphics);
    }

    VOID SetNativeGraphics(GpGraphics *graphics)
    {
        this->nativeGraphics = graphics;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    // Methods necessary to subclass Graphics for extension test.

    GpGraphics* GetNativeGraphics()
    {
        return this->nativeGraphics;
    }

    GpPen* GetNativePen(const Pen* pen)
    {
        return pen->nativePen;
    }

protected:
    GpGraphics* nativeGraphics;
    mutable Status lastResult;

};

//----------------------------------------------------------------------------
// Extra implementation of GraphicsPath methods that use Graphics
//----------------------------------------------------------------------------

/**
 * Get the bounds of the path object with the given transform.
 * This is not always the tightest bounds.
 */

inline Status
GraphicsPath::GetBounds(
    OUT RectF* bounds, 
    IN const Matrix* matrix,
    IN const Pen* pen) const 
{
    GpMatrix* nativeMatrix = NULL;
    GpPen* nativePen = NULL;

    if (matrix)
        nativeMatrix = matrix->nativeMatrix;

    if (pen)
        nativePen = pen->nativePen;

    return SetStatus(DllExports::GdipGetPathWorldBounds(nativePath, bounds,
                                                   nativeMatrix, nativePen));
}

// integer version
inline Status
GraphicsPath::GetBounds(
    OUT Rect* bounds,
    IN const Matrix* matrix,
    IN const Pen* pen
) const
{
    GpMatrix* nativeMatrix = NULL;
    GpPen* nativePen = NULL;

    if (matrix)
        nativeMatrix = matrix->nativeMatrix;

    if (pen)
        nativePen = pen->nativePen;

    return SetStatus(DllExports::GdipGetPathWorldBoundsI(nativePath, bounds,
                                                    nativeMatrix, nativePen));
}

//----------------------------------------------------------------------------
// Hit testing operations
//----------------------------------------------------------------------------

inline BOOL
GraphicsPath::IsVisible(
    IN REAL x, 
    IN REAL y, 
    IN const Graphics* g) const
{
   BOOL booln = FALSE;

   GpGraphics* nativeGraphics = NULL;

   if (g)
       nativeGraphics = g->nativeGraphics;

   SetStatus(DllExports::GdipIsVisiblePathPoint(nativePath,
                                                x, y, nativeGraphics,
                                                &booln));
   return booln;
}

inline BOOL
GraphicsPath::IsVisible(
    IN INT x, 
    IN INT y, 
    IN const Graphics* g) const
{
   BOOL booln = FALSE;

   GpGraphics* nativeGraphics = NULL;

   if (g)
       nativeGraphics = g->nativeGraphics;

   SetStatus(DllExports::GdipIsVisiblePathPointI(nativePath,
                                                 x, y, nativeGraphics,
                                                 &booln));
   return booln;
}

inline BOOL
GraphicsPath::IsOutlineVisible(
    IN REAL x, 
    IN REAL y, 
    IN const Pen* pen,
    IN const Graphics* g) const
{
    BOOL booln = FALSE;

    GpGraphics* nativeGraphics = NULL;
    GpPen* nativePen = NULL;

    if(g)
        nativeGraphics = g->nativeGraphics;
    if(pen)
        nativePen = pen->nativePen;

    SetStatus(DllExports::GdipIsOutlineVisiblePathPoint(nativePath,
                                                        x, y, nativePen, nativeGraphics,
                                                        &booln));
    return booln;
}

inline BOOL
GraphicsPath::IsOutlineVisible(
    IN INT x, 
    IN INT y, 
    IN const Pen* pen,
    IN const Graphics* g) const
{
    BOOL booln = FALSE;

    GpGraphics* nativeGraphics = NULL;
    GpPen* nativePen = NULL;

    if(g)
        nativeGraphics = g->nativeGraphics;
    if(pen)
        nativePen = pen->nativePen;

    SetStatus(DllExports::GdipIsOutlineVisiblePathPointI(nativePath,
                                                         x, y, nativePen, nativeGraphics,
                                                         &booln));
    return booln;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusgpstubs.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusGpStubs.hpp
*
* Abstract:
*
*   GDI+ Native C++ public header file
*
* Revision History:
*
*   03/03/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSGPSTUBS_H
#define _GDIPLUSGPSTUBS_H

//---------------------------------------------------------------------------
// GDI+ classes for forward reference
//---------------------------------------------------------------------------

class Graphics;
class Pen;
class Brush;
class Matrix;
class Bitmap;
class Metafile;
class GraphicsPath;
class PathIterator;
class Region;
class Image;
class TextureBrush;
class HatchBrush;
class SolidBrush;
class LinearGradientBrush;
class PathGradientBrush;
class Font;
class FontFamily;
class FontCollection;
class InstalledFontCollection;
class PrivateFontCollection;
class ImageAttributes;
class CachedBitmap;

//---------------------------------------------------------------------------
// Internal GDI+ classes for internal type checking
//---------------------------------------------------------------------------
class GpGraphics {};

class GpBrush {};
class GpTexture : public GpBrush {};
class GpSolidFill : public GpBrush {};
class GpLineGradient : public GpBrush {};
class GpPathGradient : public GpBrush {};
class GpHatch : public GpBrush {};

class GpPen {};
class GpCustomLineCap {};
class GpAdjustableArrowCap : public GpCustomLineCap {};

class GpImage {};
class GpBitmap : public GpImage {};
class GpMetafile : public GpImage {};
class GpImageAttributes {};

class GpPath {};
class GpRegion {};
class GpPathIterator {};

class GpFontFamily {};
class GpFont {};
class GpStringFormat {};
class GpFontCollection {};
class GpInstalledFontCollection : public GpFontCollection {};
class GpPrivateFontCollection : public GpFontCollection {};

class GpCachedBitmap;

typedef Status GpStatus;
typedef FillMode GpFillMode;
typedef WrapMode GpWrapMode;
typedef Unit GpUnit;
typedef CoordinateSpace GpCoordinateSpace;
typedef PointF GpPointF;
typedef Point GpPoint;
typedef RectF GpRectF;
typedef Rect GpRect;
typedef SizeF GpSizeF;
typedef HatchStyle GpHatchStyle;
typedef DashStyle GpDashStyle;
typedef LineCap GpLineCap;

typedef PenAlignment GpPenAlignment;

typedef LineJoin GpLineJoin;
typedef PenType GpPenType;

typedef Matrix GpMatrix;
typedef BrushType GpBrushType;
typedef MatrixOrder GpMatrixOrder;
typedef FlushIntention GpFlushIntention;
typedef PathData GpPathData;

#endif  // !_GDIPLUSGPSTUBS.HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusimaging.h ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   GdiplusImaging.h
*
* Abstract:
*
*   GUIDs defined and used by the imaging library
*
* Revision History:
*
*   03/28/2000 ericvan
*       Created it.
*
\**************************************************************************/
#ifndef _GDIPLUSIMAGING_H
#define _GDIPLUSIMAGING_H

//---------------------------------------------------------------------------
// Image file format identifiers
//---------------------------------------------------------------------------

DEFINE_GUID(ImageFormatUndefined, 0xb96b3ca9,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatMemoryBMP, 0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatBMP, 0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatEMF, 0xb96b3cac,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatWMF, 0xb96b3cad,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatJPEG, 0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatPNG, 0xb96b3caf,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatGIF, 0xb96b3cb0,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatTIFF, 0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatEXIF, 0xb96b3cb2,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
#ifndef DCR_USE_NEW_140855
DEFINE_GUID(ImageFormatPhotoCD, 0xb96b3cb3,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatFlashPIX, 0xb96b3cb4,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
#endif
DEFINE_GUID(ImageFormatIcon, 0xb96b3cb5,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//---------------------------------------------------------------------------
// Predefined multi-frame dimension IDs
//---------------------------------------------------------------------------

DEFINE_GUID(FrameDimensionTime, 0x6aedbd6d,0x3fb5,0x418a,0x83,0xa6,0x7f,0x45,0x22,0x9d,0xc8,0x72);
DEFINE_GUID(FrameDimensionResolution, 0x84236f7b,0x3bd3,0x428f,0x8d,0xab,0x4e,0xa1,0x43,0x9c,0xa3,0x15);
DEFINE_GUID(FrameDimensionPage, 0x7462dc86,0x6180,0x4c7e,0x8e,0x3f,0xee,0x73,0x33,0xa7,0xa4,0x83);

//---------------------------------------------------------------------------
// Property sets
//---------------------------------------------------------------------------

DEFINE_GUID(FormatIDImageInformation, 0xe5836cbe,0x5eef,0x4f1d,0xac,0xde,0xae,0x4c,0x43,0xb6,0x08,0xce);
DEFINE_GUID(FormatIDJpegAppHeaders, 0x1c4afdcd,0x6177,0x43cf,0xab,0xc7,0x5f,0x51,0xaf,0x39,0xee,0x85);

#ifndef DCR_USE_NEW_140855
//---------------------------------------------------------------------------
// Decoder parameter sets
//---------------------------------------------------------------------------
DEFINE_GUID(DecoderTransColor, 0xb7a98c8f,0xdce7,0x457d,0xbf,0xa5,0xce,0xa7,0x1b,0xd1,0x4d,0xd6);
DEFINE_GUID(DecoderTransRange, 0xabeed189,0xd988,0x4d03,0xb4,0x25,0x57,0x10,0x55,0xc7,0x6a,0xd1);
DEFINE_GUID(DecoderOutputChannel, 0x2ff8f51e,0x724d,0x45fe,0x86,0xce,0x17,0x77,0xa0,0x56,0xda,0x60);
DEFINE_GUID(DecoderIconRes, 0x5c656eec,0xe94f,0x45ba,0xa6,0xf6,0x10,0x62,0xe8,0x5f,0x4a,0x7f);
#endif

//---------------------------------------------------------------------------
// Encoder parameter sets
//---------------------------------------------------------------------------

DEFINE_GUID(EncoderCompression, 0xe09d739d,0xccd4,0x44ee,0x8e,0xba,0x3f,0xbf,0x8b,0xe4,0xfc,0x58);
DEFINE_GUID(EncoderColorDepth, 0x66087055,0xad66,0x4c7c,0x9a,0x18,0x38,0xa2,0x31,0x0b,0x83,0x37);
DEFINE_GUID(EncoderScanMethod, 0x3a4e2661,0x3109,0x4e56,0x85,0x36,0x42,0xc1,0x56,0xe7,0xdc,0xfa);
DEFINE_GUID(EncoderVersion, 0x24d18c76,0x814a,0x41a4,0xbf,0x53,0x1c,0x21,0x9c,0xcc,0xf7,0x97);
DEFINE_GUID(EncoderRenderMethod, 0x6d42c53a,0x229a,0x4825,0x8b,0xb7,0x5c,0x99,0xe2,0xb9,0xa8,0xb8);
DEFINE_GUID(EncoderQuality, 0x1d5be4b5,0xfa4a,0x452d,0x9c,0xdd,0x5d,0xb3,0x51,0x05,0xe7,0xeb);
DEFINE_GUID(EncoderTransformation,0x8d0eb2d1,0xa58e,0x4ea8,0xaa,0x14,0x10,0x80,0x74,0xb7,0xb6,0xf9);
DEFINE_GUID(EncoderLuminanceTable,0xedb33bce,0x0266,0x4a77,0xb9,0x04,0x27,0x21,0x60,0x99,0xe7,0x17);
DEFINE_GUID(EncoderChrominanceTable,0xf2e455dc,0x09b3,0x4316,0x82,0x60,0x67,0x6a,0xda,0x32,0x48,0x1c);
DEFINE_GUID(EncoderSaveFlag,0x292266fc,0xac40,0x47bf,0x8c, 0xfc, 0xa8, 0x5b, 0x89, 0xa6, 0x55, 0xde);

//--------------------------------------------------------------------------
// ImageCodecInfo structure
//--------------------------------------------------------------------------

class ImageCodecInfo
{
public:          
    CLSID Clsid;
    GUID  FormatID;
    const WCHAR* CodecName;
    const WCHAR* DllName;
    const WCHAR* FormatDescription;
    const WCHAR* FilenameExtension;
    const WCHAR* MimeType;
    DWORD Flags;
    DWORD Version;
    DWORD SigCount;
    DWORD SigSize;
    const BYTE* SigPattern;
    const BYTE* SigMask;
};

//--------------------------------------------------------------------------
// Information flags about image codecs
//--------------------------------------------------------------------------

enum ImageCodecFlags
{
    ImageCodecFlagsEncoder            = 0x00000001,
    ImageCodecFlagsDecoder            = 0x00000002,
    ImageCodecFlagsSupportBitmap      = 0x00000004,
    ImageCodecFlagsSupportVector      = 0x00000008,
    ImageCodecFlagsSeekableEncode     = 0x00000010,
    ImageCodecFlagsBlockingDecode     = 0x00000020,

    ImageCodecFlagsBuiltin            = 0x00010000,
    ImageCodecFlagsSystem             = 0x00020000,
    ImageCodecFlagsUser               = 0x00040000
};

//---------------------------------------------------------------------------
// Access modes used when calling Image::LockBits
//---------------------------------------------------------------------------

enum ImageLockMode
{
    ImageLockModeRead        = 0x0001,
    ImageLockModeWrite       = 0x0002,
    ImageLockModeUserInputBuf= 0x0004
};

//---------------------------------------------------------------------------
// Information about image pixel data
//---------------------------------------------------------------------------

class BitmapData
{
public:
    UINT Width;
    UINT Height;
    INT Stride;
    PixelFormat PixelFormat;
    VOID* Scan0;
    UINT_PTR Reserved;
};

//---------------------------------------------------------------------------
// Image flags
//---------------------------------------------------------------------------

enum ImageFlags
{
    ImageFlagsNone                = 0,

    // Low-word: shared with SINKFLAG_x

    ImageFlagsScalable            = 0x0001,
    ImageFlagsHasAlpha            = 0x0002,
    ImageFlagsHasTranslucent      = 0x0004,
    ImageFlagsPartiallyScalable   = 0x0008,

    // Low-word: color space definition

    ImageFlagsColorSpaceRGB       = 0x0010,
    ImageFlagsColorSpaceCMYK      = 0x0020,
    ImageFlagsColorSpaceGRAY      = 0x0040,
    ImageFlagsColorSpaceYCBCR     = 0x0080,
    ImageFlagsColorSpaceYCCK      = 0x0100,
 
    // Low-word: image size info

    ImageFlagsHasRealDPI          = 0x1000,
    ImageFlagsHasRealPixelSize    = 0x2000,

    // High-word

    ImageFlagsReadOnly            = 0x00010000,
    ImageFlagsCaching             = 0x00020000
};

//---------------------------------------------------------------------------
// Encoder Parameter structure
//---------------------------------------------------------------------------
class EncoderParameter
{
public:
    GUID    Guid;               // GUID of the parameter
    ULONG   NumberOfValues;     // Number of the parameter values
    ULONG   Type;               // Value type, like ValueTypeLONG  etc.
    VOID*   Value;              // A pointer to the parameter values
};

//---------------------------------------------------------------------------
// Encoder Parameters structure
//---------------------------------------------------------------------------
class EncoderParameters
{
public:
    UINT Count;                      // Number of parameters in this structure
    EncoderParameter Parameter[1];   // Parameter values
};

//---------------------------------------------------------------------------
// Property Item
//---------------------------------------------------------------------------
class PropertyItem
{
public:
    PROPID  id;                 // ID of this property
    ULONG   length;             // Length of the property value, in bytes
    WORD    type;               // Type of the value, as one of TAG_TYPE_XXX
                                // defined above
    VOID*   value;              // property value
};

#ifdef DCR_USE_NEW_140857
//---------------------------------------------------------------------------
// Image property types 
//---------------------------------------------------------------------------
#define PropertyTagTypeByte        1
#define PropertyTagTypeASCII       2
#define PropertyTagTypeShort       3
#define PropertyTagTypeLong        4
#define PropertyTagTypeRational    5
#define PropertyTagTypeUndefined   7
#define PropertyTagTypeSLONG       9
#define PropertyTagTypeSRational  10
#endif

//---------------------------------------------------------------------------
// Image property ID tags
//---------------------------------------------------------------------------

#define PropertyTagExifIFD             0x8769
#define PropertyTagGpsIFD              0x8825

#define PropertyTagNewSubfileType      0x00FE
#define PropertyTagSubfileType         0x00FF
#define PropertyTagImageWidth          0x0100
#define PropertyTagImageHeight         0x0101
#define PropertyTagBitsPerSample       0x0102
#define PropertyTagCompression         0x0103
#define PropertyTagPhotometricInterp   0x0106
#define PropertyTagThreshHolding       0x0107
#define PropertyTagCellWidth           0x0108
#define PropertyTagCellHeight          0x0109
#define PropertyTagFillOrder           0x010A
#define PropertyTagDocumentName        0x010D
#define PropertyTagImageDescription    0x010E
#define PropertyTagEquipMake           0x010F
#define PropertyTagEquipModel          0x0110
#define PropertyTagStripOffsets        0x0111
#define PropertyTagOrientation         0x0112
#define PropertyTagSamplesPerPixel     0x0115
#define PropertyTagRowsPerStrip        0x0116
#define PropertyTagStripBytesCount     0x0117
#define PropertyTagMinSampleValue      0x0118
#define PropertyTagMaxSampleValue      0x0119
#define PropertyTagXResolution         0x011A   // Image resolution in width direction
#define PropertyTagYResolution         0x011B   // Image resolution in height direction
#define PropertyTagPlanarConfig        0x011C   // Image data arrangement
#define PropertyTagPageName            0x011D
#define PropertyTagXPosition           0x011E
#define PropertyTagYPosition           0x011F
#define PropertyTagFreeOffset          0x0120
#define PropertyTagFreeByteCounts      0x0121
#define PropertyTagGrayResponseUnit    0x0122
#define PropertyTagGrayResponseCurve   0x0123
#define PropertyTagT4Option            0x0124
#define PropertyTagT6Option            0x0125
#define PropertyTagResolutionUnit      0x0128   // Unit of X and Y resolution
#define PropertyTagPageNumber          0x0129
#define PropertyTagTransferFuncition   0x012D
#define PropertyTagSoftwareUsed        0x0131
#define PropertyTagDateTime            0x0132
#define PropertyTagArtist              0x013B
#define PropertyTagHostComputer        0x013C
#define PropertyTagPredictor           0x013D
#define PropertyTagWhitePoint          0x013E
#define PropertyTagPrimaryChromaticities 0x013F
#define PropertyTagColorMap            0x0140
#define PropertyTagHalftoneHints       0x0141
#define PropertyTagTileWidth           0x0142
#define PropertyTagTileLength          0x0143
#define PropertyTagTileOffset          0x0144
#define PropertyTagTileByteCounts      0x0145
#define PropertyTagInkSet              0x014C
#define PropertyTagInkNames            0x014D
#define PropertyTagNumberOfInks        0x014E
#define PropertyTagDotRange            0x0150
#define PropertyTagTargetPrinter       0x0151
#define PropertyTagExtraSamples        0x0152
#define PropertyTagSampleFormat        0x0153
#define PropertyTagSMinSampleValue     0x0154
#define PropertyTagSMaxSampleValue     0x0155
#define PropertyTagTransferRange       0x0156

#define PropertyTagJPEGProc            0x0200
#define PropertyTagJPEGInterFormat     0x0201
#define PropertyTagJPEGInterLength     0x0202
#define PropertyTagJPEGRestartInterval 0x0203
#define PropertyTagJPEGLosslessPredictors  0x0205
#define PropertyTagJPEGPointTransforms     0x0206
#define PropertyTagJPEGQTables         0x0207
#define PropertyTagJPEGDCTables        0x0208
#define PropertyTagJPEGACTables        0x0209

#define PropertyTagYCbCrCoefficients   0x0211
#define PropertyTagYCbCrSubsampling    0x0212
#define PropertyTagYCbCrPositioning    0x0213
#define PropertyTagREFBlackWhite       0x0214

#define PropertyTagICCProfile          0x0300
#define PropertyTagGamma               0x0301
#define PropertyTagICCProfileDescriptor 0x0302
#define PropertyTagSRGBRenderingIntent 0x0303

#define PropertyTagImageTitle          0x0320
#define PropertyTagCopyright           0x8298

// Extra TAGs (Like Adobe Image Information tags etc.)

#define PropertyTagResolutionXUnit           0x5001
#define PropertyTagResolutionYUnit           0x5002
#define PropertyTagResolutionXLengthUnit     0x5003
#define PropertyTagResolutionYLengthUnit     0x5004
#define PropertyTagPrintFlags                0x5005
#define PropertyTagPrintFlagsVersion         0x5006
#define PropertyTagPrintFlagsCrop            0x5007
#define PropertyTagPrintFlagsBleedWidth      0x5008
#define PropertyTagPrintFlagsBleedWidthScale 0x5009
#define PropertyTagHalftoneLPI               0x500A
#define PropertyTagHalftoneLPIUnit           0x500B
#define PropertyTagHalftoneDegree            0x500C
#define PropertyTagHalftoneShape             0x500D
#define PropertyTagHalftoneMisc              0x500E
#define PropertyTagHalftoneScreen            0x500F
#define PropertyTagJPEGQuality               0x5010
#define PropertyTagGridSize                  0x5011
#define PropertyTagThumbnailFormat           0x5012  // 1 = JPEG, 0 = RAW RGB
#define PropertyTagThumbnailWidth            0x5013
#define PropertyTagThumbnailHeight           0x5014
#define PropertyTagThumbnailColorDepth       0x5015
#define PropertyTagThumbnailPlanes           0x5016
#define PropertyTagThumbnailRawBytes         0x5017
#define PropertyTagThumbnailSize             0x5018
#define PropertyTagThumbnailCompressedSize   0x5019
#define PropertyTagColorTransferFunction     0x501A
#define PropertyTagThumbnailData             0x501B// RAW thumbnail bits in
                                                   // JPEG format or RGB format
                                                   // depends on
                                                   // PropertyTagThumbnailFormat

// Thumbnail related TAGs
                                                
#define PropertyTagThumbnailImageWidth       0x5020  // Thumbnail width
#define PropertyTagThumbnailImageHeight      0x5021  // Thumbnail height
#define PropertyTagThumbnailBitsPerSample    0x5022  // Number of bits per
                                                     // component
#define PropertyTagThumbnailCompression      0x5023  // Compression Scheme
#define PropertyTagThumbnailPhotometricInterp 0x5024 // Pixel composition
#define PropertyTagThumbnailImageDescription 0x5025  // Image Tile
#define PropertyTagThumbnailEquipMake        0x5026  // Manufacturer of Image
                                                     // Input equipment
#define PropertyTagThumbnailEquipModel       0x5027  // Model of Image input
                                                     // equipment
#define PropertyTagThumbnailStripOffsets     0x5028  // Image data location
#define PropertyTagThumbnailOrientation      0x5029  // Orientation of image
#define PropertyTagThumbnailSamplesPerPixel  0x502A  // Number of components
#define PropertyTagThumbnailRowsPerStrip     0x502B  // Number of rows per strip
#define PropertyTagThumbnailStripBytesCount  0x502C  // Bytes per compressed
                                                     // strip
#define PropertyTagThumbnailResolutionX      0x502D  // Resolution in width
                                                     // direction
#define PropertyTagThumbnailResolutionY      0x502E  // Resolution in height
                                                     // direction
#define PropertyTagThumbnailPlanarConfig     0x502F  // Image data arrangement
#define PropertyTagThumbnailResolutionUnit   0x5030  // Unit of X and Y
                                                     // Resolution
#define PropertyTagThumbnailTransferFunction 0x5031  // Transfer function
#define PropertyTagThumbnailSoftwareUsed     0x5032  // Software used
#define PropertyTagThumbnailDateTime         0x5033  // File change date and
                                                     // time
#define PropertyTagThumbnailArtist           0x5034  // Person who created the
                                                     // image
#define PropertyTagThumbnailWhitePoint       0x5035  // White point chromaticity
#define PropertyTagThumbnailPrimaryChromaticities 0x5036 
                                                     // Chromaticities of
                                                     // primaries
#define PropertyTagThumbnailYCbCrCoefficients 0x5037 // Color space transforma-
                                                     // tion coefficients
#define PropertyTagThumbnailYCbCrSubsampling 0x5038  // Subsampling ratio of Y
                                                     // to C
#define PropertyTagThumbnailYCbCrPositioning 0x5039  // Y and C position
#define PropertyTagThumbnailRefBlackWhite    0x503A  // Pair of black and white
                                                     // reference values
#define PropertyTagThumbnailCopyRight        0x503B  // CopyRight holder

#define PropertyTagLuminanceTable            0x5090
#define PropertyTagChrominanceTable          0x5091

#define PropertyTagFrameDelay                0x5100
#define PropertyTagLoopCount                 0x5101

#define PropertyTagPixelUnit         0x5110  // Unit specifier for pixel/unit
#define PropertyTagPixelPerUnitX     0x5111  // Pixels per unit in X
#define PropertyTagPixelPerUnitY     0x5112  // Pixels per unit in Y
#define PropertyTagPaletteHistogram  0x5113  // Palette histogram

// EXIF specific tag

#define PropertyTagExifExposureTime  0x829A
#define PropertyTagExifFNumber       0x829D

#define PropertyTagExifExposureProg  0x8822
#define PropertyTagExifSpectralSense 0x8824
#define PropertyTagExifISOSpeed      0x8827
#define PropertyTagExifOECF          0x8828

#define PropertyTagExifVer            0x9000
#define PropertyTagExifDTOrig         0x9003 // Date & time of original
#define PropertyTagExifDTDigitized    0x9004 // Date & time of digital data generation

#define PropertyTagExifCompConfig     0x9101
#define PropertyTagExifCompBPP        0x9102

#define PropertyTagExifShutterSpeed   0x9201
#define PropertyTagExifAperture       0x9202
#define PropertyTagExifBrightness     0x9203
#define PropertyTagExifExposureBias   0x9204
#define PropertyTagExifMaxAperture    0x9205
#define PropertyTagExifSubjectDist    0x9206
#define PropertyTagExifMeteringMode   0x9207
#define PropertyTagExifLightSource    0x9208
#define PropertyTagExifFlash          0x9209
#define PropertyTagExifFocalLength    0x920A
#define PropertyTagExifMakerNote      0x927C
#define PropertyTagExifUserComment    0x9286
#define PropertyTagExifDTSubsec       0x9290  // Date & Time subseconds
#define PropertyTagExifDTOrigSS       0x9291  // Date & Time original subseconds
#define PropertyTagExifDTDigSS        0x9292  // Date & TIme digitized subseconds

#define PropertyTagExifFPXVer         0xA000
#define PropertyTagExifColorSpace     0xA001
#define PropertyTagExifPixXDim        0xA002
#define PropertyTagExifPixYDim        0xA003
#define PropertyTagExifRelatedWav     0xA004  // related sound file
#define PropertyTagExifInterop        0xA005
#define PropertyTagExifFlashEnergy    0xA20B
#define PropertyTagExifSpatialFR      0xA20C  // Spatial Frequency Response
#define PropertyTagExifFocalXRes      0xA20E  // Focal Plane X Resolution
#define PropertyTagExifFocalYRes      0xA20F  // Focal Plane Y Resolution
#define PropertyTagExifFocalResUnit   0xA210  // Focal Plane Resolution Unit
#define PropertyTagExifSubjectLoc     0xA214
#define PropertyTagExifExposureIndex  0xA215
#define PropertyTagExifSensingMethod  0xA217
#define PropertyTagExifFileSource     0xA300
#define PropertyTagExifSceneType      0xA301
#define PropertyTagExifCfaPattern     0xA302

#define PropertyTagGpsVer             0x0000
#define PropertyTagGpsLatitudeRef     0x0001
#define PropertyTagGpsLatitude        0x0002
#define PropertyTagGpsLongitudeRef    0x0003
#define PropertyTagGpsLongitude       0x0004
#define PropertyTagGpsAltitudeRef     0x0005
#define PropertyTagGpsAltitude        0x0006
#define PropertyTagGpsGpsTime         0x0007
#define PropertyTagGpsGpsSatellites   0x0008
#define PropertyTagGpsGpsStatus       0x0009
#define PropertyTagGpsGpsMeasureMode  0x00A
#define PropertyTagGpsGpsDop          0x000B  // Measurement precision
#define PropertyTagGpsSpeedRef        0x000C
#define PropertyTagGpsSpeed           0x000D
#define PropertyTagGpsTrackRef        0x000E
#define PropertyTagGpsTrack           0x000F
#define PropertyTagGpsImgDirRef       0x0010
#define PropertyTagGpsImgDir          0x0011
#define PropertyTagGpsMapDatum        0x0012
#define PropertyTagGpsDestLatRef      0x0013
#define PropertyTagGpsDestLat         0x0014
#define PropertyTagGpsDestLongRef     0x0015
#define PropertyTagGpsDestLong        0x0016
#define PropertyTagGpsDestBearRef     0x0017
#define PropertyTagGpsDestBear        0x0018
#define PropertyTagGpsDestDistRef     0x0019
#define PropertyTagGpsDestDist        0x001A

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusimageattributes.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Image Attributes
*
* Abstract:
*
*   Class for color adjustment object passed to Graphics.DrawImage
*
* Revision History:
*
*   15-Nov-1999 gilmanw
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSIMAGEATTRIBUTES_H
#define _GDIPLUSIMAGEATTRIBUTES_H

class GpImageAttributes;

// There are 5 possible sets of color adjustments:
//          ColorAdjustDefault,
//          ColorAdjustBitmap,
//          ColorAdjustBrush,
//          ColorAdjustPen,
//          ColorAdjustText,

// Bitmaps, Brushes, Pens, and Text will all use any color adjustments
// that have been set into the default ImageAttributes until their own
// color adjustments have been set.  So as soon as any "Set" method is
// called for Bitmaps, Brushes, Pens, or Text, then they start from
// scratch with only the color adjustments that have been set for them.
// Calling Reset removes any individual color adjustments for a type
// and makes it revert back to using all the default color adjustments
// (if any).  The SetToIdentity method is a way to force a type to
// have no color adjustments at all, regardless of what previous adjustments
// have been set for the defaults or for that type.

class ImageAttributes : public GdiplusBase
{
    friend class Graphics;
    friend class TextureBrush;

public:

    ImageAttributes()
    {
        nativeImageAttr = NULL;
        lastResult = DllExports::GdipCreateImageAttributes(&nativeImageAttr);
    }

    ~ImageAttributes()
    {
        DllExports::GdipDisposeImageAttributes(nativeImageAttr);
    }

    ImageAttributes* Clone() const
    {
        GpImageAttributes* clone;

        SetStatus(DllExports::GdipCloneImageAttributes(
                                            nativeImageAttr,
                                            &clone));

        return new ImageAttributes(clone, lastResult);
    }

    // Set to identity, regardless of what the default color adjustment is.
    Status
    SetToIdentity(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesToIdentity(
                                            nativeImageAttr,
                                            type));
    }

    // Remove any individual color adjustments, and go back to using the default
    Status
    Reset(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipResetImageAttributes(
                                            nativeImageAttr,
                                            type));
    }

    Status
    SetColorMatrix(
        IN const ColorMatrix *colorMatrix,
        IN ColorMatrixFlags mode = ColorMatrixFlagsDefault,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorMatrix,
                                            NULL,
                                            mode));
    }

    Status ClearColorMatrix(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL,
                                            NULL,
                                            ColorMatrixFlagsDefault));
    }

    Status
    SetColorMatrices(
        IN const ColorMatrix *colorMatrix,
        IN const ColorMatrix *grayMatrix,
        IN ColorMatrixFlags mode = ColorMatrixFlagsDefault,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorMatrix,
                                            grayMatrix,
                                            mode));
    }

    Status ClearColorMatrices(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL,
                                            NULL,
                                            ColorMatrixFlagsDefault));
    }

    Status SetThreshold(
        IN REAL threshold,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesThreshold(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            threshold));
    }

    Status ClearThreshold(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesThreshold(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            0.0));
    }

    Status SetGamma(
        IN REAL gamma,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesGamma(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            gamma));
    }

    Status ClearGamma(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesGamma(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            0.0));
    }

    Status SetNoOp(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesNoOp(
                                            nativeImageAttr,
                                            type,
                                            TRUE));
    }

    Status ClearNoOp(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesNoOp(
                                            nativeImageAttr,
                                            type,
                                            FALSE));
    }

    Status SetColorKey(
        IN const Color& colorLow, 
        IN const Color& colorHigh,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorKeys(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorLow.GetValue(),
                                            colorHigh.GetValue()));
    }

    Status ClearColorKey(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorKeys(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL,
                                            NULL));
    }

    Status SetOutputChannel(
        IN ColorChannelFlags channelFlags,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannel(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            channelFlags));
    }
    
    Status ClearOutputChannel(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannel(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            ColorChannelFlagsLast));
    }

    Status SetOutputChannelColorProfile(
        IN const WCHAR *colorProfileFilename,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannelColorProfile(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorProfileFilename));
    }
    
    Status ClearOutputChannelColorProfile(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannelColorProfile(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL));
    }
    
    Status SetRemapTable(
        IN UINT mapSize, 
        IN const ColorMap *map,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesRemapTable(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            mapSize,
                                            map));
    }

    Status ClearRemapTable(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesRemapTable(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            0,
                                            NULL));
    }

    Status SetBrushRemapTable(IN UINT mapSize, 
                              IN ColorMap *map)
    {
        return this->SetRemapTable(mapSize, map, ColorAdjustTypeBrush);
    }

    Status ClearBrushRemapTable()
    {
        return this->ClearRemapTable(ColorAdjustTypeBrush);
    }

    Status SetWrapMode(IN WrapMode wrap, 
                       IN const Color& color = Color(), 
                       IN BOOL clamp = FALSE) 
    {
        ARGB argb = color.GetValue();

        return SetStatus(DllExports::GdipSetImageAttributesWrapMode(
                           nativeImageAttr, wrap, argb, clamp));
    }

    #ifndef DCR_USE_NEW_145139
    Status SetICMMode(IN BOOL on)
    {
        on;
        // This is not implemented.
        // The supported method for doing ICM conversion from the embedded 
        // ICC profile is to use the Bitmap constructor from a file or stream
        // and specify TRUE for the useIcm parameter. This will cause the 
        // image to be ICM converted when it's loaded from the file/stream
        // if the profile exists.
        return SetStatus(NotImplemented);
//          DllExports::GdipSetImageAttributesICMMode(nativeImageAttr, on)
    }
    #endif

    // The flags of the palette are ignored.
    Status GetAdjustedPalette(IN OUT ColorPalette* colorPalette,
                              IN ColorAdjustType colorAdjustType) const 
    {
        return SetStatus(DllExports::GdipGetImageAttributesAdjustedPalette(
                           nativeImageAttr, colorPalette, colorAdjustType));
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;
    
        return lastStatus;
    }
    

protected:
    ImageAttributes(GpImageAttributes* imageAttr, Status status)
    {
        SetNativeImageAttr(imageAttr);
        lastResult = status;
    }

    VOID SetNativeImageAttr(GpImageAttributes* nativeImageAttr)
    {
        this->nativeImageAttr = nativeImageAttr;
    }
    
    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else 
            return status;
    }

protected:
    GpImageAttributes* nativeImageAttr;
    mutable Status lastResult;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusheaders.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusHeaders.hpp
*
* Abstract:
*
*   GDI+ Native C++ public header file
*
* Revision History:
*
*   03/03/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSHEADERS_H
#define _GDIPLUSHEADERS_H

//--------------------------------------------------------------------------
// Abstract base class for regions
//--------------------------------------------------------------------------

//  Include the class declarations here and have inline class implementation
//  in separate file to avoid circular references.

class Region : public GdiplusBase
{
public:
    friend class Graphics;

    Region();
    Region(IN const RectF& rect);
    Region(IN const Rect& rect);
    Region(IN const GraphicsPath* path);
    Region(IN const BYTE* regionData, IN INT size);
    Region(IN HRGN hRgn);
    static Region* FromHRGN(IN HRGN hRgn);

    ~Region();
    Region* Clone() const;

    Status MakeInfinite();
    Status MakeEmpty();

    // Get the size of the buffer needed for the GetData method
    UINT GetDataSize() const;

    // buffer     - where to put the data
    // bufferSize - how big the buffer is (should be at least as big as GetDataSize())
    // sizeFilled - if not NULL, this is an OUT param that says how many bytes
    //              of data were written to the buffer.
    Status GetData(OUT BYTE* buffer,
                   IN UINT bufferSize,
                   OUT UINT* sizeFilled = NULL) const;

    Status Intersect(IN const Rect& rect);
    Status Intersect(IN const RectF& rect);
    Status Intersect(IN const GraphicsPath* path);
    Status Intersect(IN const Region* region);
    Status Union(IN const Rect& rect);
    Status Union(IN const RectF& rect);
    Status Union(IN const GraphicsPath* path);
    Status Union(IN const Region* region);
    Status Xor(IN const Rect& rect);
    Status Xor(IN const RectF& rect);
    Status Xor(IN const GraphicsPath* path);
    Status Xor(IN const Region* region);
    Status Exclude(IN const Rect& rect);
    Status Exclude(IN const RectF& rect);
    Status Exclude(IN const GraphicsPath* path);
    Status Exclude(IN const Region* region);
    Status Complement(IN const Rect& rect);
    Status Complement(IN const RectF& rect);
    Status Complement(IN const GraphicsPath* path);
    Status Complement(IN const Region* region);
    Status Translate(IN REAL dx,
                     IN REAL dy);
    Status Translate(IN INT dx,
                     IN INT dy);
    Status Transform(IN const Matrix* matrix);

    Status GetBounds(OUT Rect* rect,
                     IN const Graphics* g) const;

    Status GetBounds(OUT RectF* rect,
                     IN const Graphics* g) const;

    HRGN   GetHRGN  (IN const Graphics * g) const;

    BOOL IsEmpty(IN const Graphics *g) const;
    BOOL IsInfinite(IN const Graphics *g) const;

    BOOL IsVisible(IN INT x,
                   IN INT y,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(Point(x, y), g);
    }

    BOOL IsVisible(IN const Point& point,
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN REAL x,
                   IN REAL y,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(PointF(x, y), g);
    }

    BOOL IsVisible(IN const PointF& point,
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height,
                   IN const Graphics* g) const
    {
        return IsVisible(Rect(x, y, width, height), g);
    }

    BOOL IsVisible(IN const Rect& rect,
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(RectF(x, y, width, height), g);
    }

    BOOL IsVisible(IN const RectF& rect,
                   IN const Graphics* g = NULL) const;

    BOOL Equals(IN const Region* region,
                IN const Graphics* g) const;

    UINT GetRegionScansCount(IN const Matrix* matrix) const;
    Status GetRegionScans(IN const Matrix* matrix,
                          OUT RectF* rects,
                          OUT INT* count) const;
    Status GetRegionScans(IN const Matrix* matrix,
                          OUT Rect*  rects,
                          OUT INT* count) const;
    Status GetLastStatus() const;

protected:
    Region(const Region &region)
    {
        region; // reference parameter
        SetStatus(NotImplemented);
    }

    Region& operator=(const Region &region)
    {
       region;  // reference parameter
       SetStatus(NotImplemented);
       return *this;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    Region(GpRegion* nativeRegion);

    VOID SetNativeRegion(GpRegion* nativeRegion);

protected:
    GpRegion* nativeRegion;
    mutable Status lastResult;
};


//--------------------------------------------------------------------------
// Abstract base class for FontFamily
//--------------------------------------------------------------------------

class FontFamily : public GdiplusBase
{
public:
    friend class Font;
    friend class Graphics;
    friend class GraphicsPath;
    friend class FontCollection;

    FontFamily();

    FontFamily(
        IN const WCHAR          *name,
        IN const FontCollection *fontCollection = NULL
    );

    ~FontFamily();

    static const FontFamily *GenericSansSerif();
    static const FontFamily *GenericSerif();
    static const FontFamily *GenericMonospace();

    Status GetFamilyName(
        OUT WCHAR        name[LF_FACESIZE],
        IN LANGID        language = 0
    ) const;

//  Copy operator
    FontFamily * Clone() const;

    BOOL    IsAvailable() const
    {
        return (nativeFamily != NULL);
    };

    BOOL    IsStyleAvailable(IN INT style) const;

    UINT16  GetEmHeight     (IN INT style) const;
    UINT16  GetCellAscent   (IN INT style) const;
    UINT16  GetCellDescent  (IN INT style) const;
    UINT16  GetLineSpacing  (IN INT style) const;

    ///////////////////////////////////////////////////////////

    Status GetLastStatus() const;

protected:
    Status SetStatus(Status status) const;

    // private constructor for copy
    FontFamily(GpFontFamily * nativeFamily, Status status);

///////////////////////////////////////
//  Data members
protected:

    GpFontFamily    *nativeFamily;
    mutable Status   lastResult;
};

static FontFamily *GenericSansSerifFontFamily = NULL;
static FontFamily *GenericSerifFontFamily     = NULL;
static FontFamily *GenericMonospaceFontFamily = NULL;

static BYTE GenericSansSerifFontFamilyBuffer[sizeof(FontFamily)] = {0};
static BYTE GenericSerifFontFamilyBuffer    [sizeof(FontFamily)] = {0};
static BYTE GenericMonospaceFontFamilyBuffer[sizeof(FontFamily)] = {0};


//--------------------------------------------------------------------------
// Abstract base class for fonts
//--------------------------------------------------------------------------

class Font : public GdiplusBase
{
public:
    friend class Graphics;

    Font(IN HDC hdc);
    Font(IN HDC hdc,
         IN const LOGFONTA* logfont);
    Font(IN HDC hdc,
         IN const LOGFONTW* logfont);

    Font(
        IN const FontFamily * family,
        IN REAL         emSize,
        IN INT          style   = FontStyleRegular,
        IN Unit         unit    = UnitPoint
    );

    Font(
        IN const WCHAR *           familyName,
        IN REAL                    emSize,
        IN INT                     style   = FontStyleRegular,
        IN Unit                    unit    = UnitPoint,
        IN const FontCollection *  fontCollection = NULL
    );

    Status GetLogFontA(IN const Graphics* g,
                       OUT  LOGFONTA * logfontA) const;
    Status GetLogFontW(IN const Graphics* g,
                       OUT LOGFONTW * logfontW) const;

    Font* Clone() const;
    ~Font();
    BOOL        IsAvailable()   const;
    INT         GetStyle()      const;
    REAL        GetSize()       const;
    Unit        GetUnit()       const;
    Status      GetLastStatus() const;
    REAL        GetHeight(IN const Graphics *graphics = NULL) const;

    Status GetFamily(OUT FontFamily *family) const;

protected:
    Font(GpFont* font, Status status);
    VOID SetNativeFont(GpFont *Font);
    Status SetStatus(Status status) const;

protected:
    /*
     * handle to native line texture object
     */

    GpFont* nativeFont;
    mutable Status lastResult;
};

//--------------------------------------------------------------------------
// Abstract base classes for font collections
//--------------------------------------------------------------------------

class FontCollection : public GdiplusBase
{
public:
    friend class FontFamily;

    FontCollection();
    virtual ~FontCollection();

    INT GetFamilyCount() const;     // number of enumerable families in the collection

    Status GetFamilies(             // enumerate the fonts in a collection
        IN INT           numSought,
        OUT FontFamily * gpfamilies,
        OUT INT        * numFound
    ) const;

    Status GetLastStatus() const;

protected:
    Status SetStatus(Status status) const ;

    GpFontCollection *nativeFontCollection;
    mutable Status    lastResult;
};


class InstalledFontCollection : public FontCollection
{
public:
    InstalledFontCollection();
    ~InstalledFontCollection();

protected:
    // we will make these functions public in version 2
    Status InstallFontFile(IN const WCHAR* filename);
    Status UninstallFontFile(IN const WCHAR* filename);
    Status SetStatus(Status status) const ;
};


class PrivateFontCollection : public FontCollection
{
public:
    PrivateFontCollection();
    ~PrivateFontCollection();

    Status AddFontFile(IN const WCHAR* filename);
    Status AddMemoryFont(IN const VOID* memory,
                         IN INT length);
};


//--------------------------------------------------------------------------
// Abstract base class for bitmap image and metafile
//--------------------------------------------------------------------------

// !!! Note:
//  Include the class declarations here and have the inline class
//  implementation in a separate file.  This is done to resolve a
//  circular dependency since one of the Bitmap methods needs to
//  access the private member nativeGraphics of the Graphics object.

class Image : public GdiplusBase
{
public:
    friend class Brush;
    friend class TextureBrush;
    friend class Graphics;

#ifndef DCR_USE_NEW_140782
    Image(
        IN const WCHAR* filename
    );
    
    Image(
        IN IStream* stream
    );
    
    static Image* FromFile(
        IN const WCHAR* filename
    );
    
    static Image* FromStream(
        IN IStream* stream
    );
#else
    Image(
        IN const WCHAR* filename, 
        IN BOOL useEmbeddedColorManagement = FALSE
    );
    
    Image(
        IN IStream* stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );
    
    static Image* FromFile(
        IN const WCHAR* filename,
        IN BOOL useEmbeddedColorManagement = FALSE
    );
    
    static Image* FromStream(
        IN IStream* stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );
#endif    
        
    virtual ~Image();
    virtual Image* Clone();

    Status Save(IN const WCHAR* filename,
                IN const CLSID* clsidEncoder,
                IN const EncoderParameters *encoderParams = NULL);
    Status Save(IN IStream* stream,
                IN const CLSID* clsidEncoder,
                IN const EncoderParameters *encoderParams = NULL);
    Status SaveAdd(IN const EncoderParameters* encoderParams);
    Status SaveAdd(IN Image* newImage,
                   IN const EncoderParameters* encoderParams);

    ImageType GetType() const;
    Status GetPhysicalDimension(OUT SizeF* size);
    Status GetBounds(OUT RectF* srcRect,
                     OUT Unit* srcUnit);

    UINT GetWidth();
    UINT GetHeight();
    REAL GetHorizontalResolution();
    REAL GetVerticalResolution();
    UINT GetFlags();
    Status GetRawFormat(OUT GUID *format);
    PixelFormat GetPixelFormat();

    INT GetPaletteSize();
    Status GetPalette(OUT ColorPalette* palette,
                      IN INT size);
    Status SetPalette(IN const ColorPalette* palette);

    Image* GetThumbnailImage(IN UINT thumbWidth,
                             IN UINT thumbHeight,
                             IN GetThumbnailImageAbort callback = NULL,
                             IN VOID* callbackData = NULL);
    UINT GetFrameDimensionsCount();
    Status GetFrameDimensionsList(OUT GUID* dimensionIDs,
                                  IN UINT count);
    UINT GetFrameCount(IN const GUID* dimensionID);
    Status SelectActiveFrame(IN const GUID* dimensionID,
                             IN UINT frameIndex);
    UINT GetPropertyCount();
    Status GetPropertyIdList(IN UINT numOfProperty,
                             OUT PROPID* list);
    UINT GetPropertyItemSize(IN PROPID propId);
    Status GetPropertyItem(IN PROPID propId,
                           IN UINT propSize,
                           OUT PropertyItem* buffer);
    Status GetPropertySize(OUT UINT* totalBufferSize,
                           OUT UINT* numProperties);
    Status GetAllPropertyItems(IN UINT totalBufferSize,
                               IN UINT numProperties,
                               OUT PropertyItem* allItems);
    Status RemovePropertyItem(IN PROPID propId);
    Status SetPropertyItem(IN const PropertyItem* item);

    UINT  GetEncoderParameterListSize(IN const CLSID* clsidEncoder);
    Status GetEncoderParameterList(IN const CLSID* clsidEncoder,
                                   IN UINT size,
                                   OUT EncoderParameters* buffer);

    // Support for Middle East localization (right-to-left mirroring)
    ImageLayout GetLayout() const;
    Status SetLayout(IN const ImageLayout layout);

    Status GetLastStatus() const;

protected:

    Image() {}

    Image(GpImage *nativeImage, Status status);

    VOID SetNativeImage(GpImage* nativeImage);

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    GpImage* nativeImage;
    mutable Status lastResult;
    mutable Status loadStatus;

protected:

    // Disable copy constructor and assignment operator

    Image(IN const Image& C);
    Image& operator=(IN const Image& C);
};

class Bitmap : public Image
{
public:
    friend class Image;
    friend class CachedBitmap;

    Bitmap(
        IN const WCHAR *filename,
        IN BOOL useEmbeddedColorManagement = FALSE
    );
    
    Bitmap(
        IN IStream *stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );
    
    static Bitmap* FromFile(
        IN const WCHAR *filename,
        IN BOOL useEmbeddedColorManagement = FALSE
    );
    
    static Bitmap* FromStream(
        IN IStream *stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );
    
    Bitmap(IN INT width,
           IN INT height,
           IN INT stride, PixelFormat format,
           IN BYTE* scan0);
    Bitmap(IN INT width,
           IN INT height,
           IN PixelFormat format = PixelFormat32bppARGB);
    Bitmap(IN INT width,
           IN INT height,
           IN  Graphics* target);

    Bitmap* Clone(IN const Rect& rect,
                  IN PixelFormat format);
    Bitmap* Clone(IN INT x,
                  IN INT y,
                  IN INT width,
                  IN INT height,
                  IN PixelFormat format);
    Bitmap* Clone(IN const RectF& rect,
                  IN PixelFormat format);
    Bitmap* Clone(IN REAL x,
                  IN REAL y,
                  IN REAL width,
                  IN REAL height,
                  IN PixelFormat format);

    Status LockBits(IN const Rect& rect,
                    IN UINT flags,
                    IN PixelFormat format,
                    OUT BitmapData* lockedBitmapData);
    Status UnlockBits(IN BitmapData* lockedBitmapData);
    Status GetPixel(IN INT x,
                    IN INT y,
                    OUT Color *color);
    Status SetPixel(IN INT x,
                    IN INT y,
                    IN const Color &color);
    Status SetResolution(IN REAL xdpi,
                         IN REAL ydpi);

    // GDI interop:

    Bitmap(IN IDirectDrawSurface7* surface);
    Bitmap(IN const BITMAPINFO* gdiBitmapInfo,
           IN VOID* gdiBitmapData);
    Bitmap(IN HBITMAP hbm,
           IN HPALETTE hpal);
    Bitmap(IN HICON hicon);
    Bitmap(IN HINSTANCE hInstance,
           IN const WCHAR * bitmapName);
    static Bitmap* FromDirectDrawSurface7(IN IDirectDrawSurface7* surface);
    static Bitmap* FromBITMAPINFO(IN const BITMAPINFO* gdiBitmapInfo,
                                  IN VOID* gdiBitmapData);
    static Bitmap* FromHBITMAP(IN HBITMAP hbm,
                               IN HPALETTE hpal);
    static Bitmap* FromHICON(IN HICON hicon);
    static Bitmap* FromResource(IN HINSTANCE hInstance,
                                IN const WCHAR * bitmapName);

    Status GetHBITMAP(IN const Color& colorBackground,
                      OUT HBITMAP *hbmReturn);
    Status GetHICON(HICON *hicon);

protected:
    Bitmap(GpBitmap *nativeBitmap);
};

class CustomLineCap : public GdiplusBase
{
public:
    friend class Pen;

    CustomLineCap(
        IN const GraphicsPath* fillPath,
        IN const GraphicsPath* strokePath,
        IN LineCap baseCap = LineCapFlat,
        IN REAL baseInset = 0
        );
    virtual ~CustomLineCap();

    CustomLineCap* Clone() const;

    Status SetStrokeCap(IN LineCap strokeCap)
    {
        // This changes both start and and caps.

        return SetStrokeCaps(strokeCap, strokeCap);
    }

    Status SetStrokeCaps(IN LineCap startCap,
                         IN LineCap endCap);
    Status GetStrokeCaps(OUT LineCap* startCap,
                         OUT LineCap* endCap) const;
    Status SetStrokeJoin(IN LineJoin lineJoin);
    LineJoin GetStrokeJoin() const;
    Status SetBaseCap(IN LineCap baseCap);
    LineCap GetBaseCap() const;
    Status SetBaseInset(IN REAL inset);
    REAL GetBaseInset() const;
    Status SetWidthScale(IN REAL widthScale);
    REAL GetWidthScale() const;

protected:
    CustomLineCap();

    CustomLineCap(const CustomLineCap& customLineCap)
    {
        customLineCap;
        SetStatus(NotImplemented);
    }

    CustomLineCap& operator=(const CustomLineCap& customLineCap)
    {
        customLineCap;
        SetStatus(NotImplemented);
        return *this;
    }

    CustomLineCap(GpCustomLineCap* nativeCap, Status status)
    {
        lastResult = status;
        SetNativeCap(nativeCap);
    }

    VOID SetNativeCap(GpCustomLineCap* nativeCap)
    {
        this->nativeCap = nativeCap;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpCustomLineCap* nativeCap;
    mutable Status lastResult;
};

class CachedBitmap : public GdiplusBase
{
    friend Graphics;

public:
    CachedBitmap(IN Bitmap *bitmap,
                 IN Graphics *graphics);
    virtual ~CachedBitmap();

    Status GetLastStatus() const;

protected:
    GpCachedBitmap *nativeCachedBitmap;
    mutable Status lastResult;
};

#endif  // !_GDIPLUSHEADERS.HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusimagecodec.h ===
/**************************************************************************\
*
* Copyright (c) 2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusImageCodec.h
*
* Abstract:
*
*   APIs for imaging codecs.
*
* Revision History:
*
*   12/21/1999 dchinn
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSIMAGECODEC_H
#define _GDIPLUSIMAGECODEC_H

//--------------------------------------------------------------------------
// Codec Management APIs
//--------------------------------------------------------------------------

inline Status 
GetImageDecodersSize(
    OUT UINT *numDecoders,
    OUT UINT *size)
{
    return DllExports::GdipGetImageDecodersSize(numDecoders, size);
}


inline Status 
GetImageDecoders(
    IN UINT numDecoders,
    IN UINT size,
    OUT ImageCodecInfo *decoders)
{
    return DllExports::GdipGetImageDecoders(numDecoders, size, decoders);
}


inline Status 
GetImageEncodersSize(
    OUT UINT *numEncoders, 
    OUT UINT *size)
{
    return DllExports::GdipGetImageEncodersSize(numEncoders, size);
}


inline Status 
GetImageEncoders(
    IN UINT numEncoders,
    IN UINT size,
    OUT ImageCodecInfo *encoders)
{
    return DllExports::GdipGetImageEncoders(numEncoders, size, encoders);
}

inline Status 
AddImageCodec(
    IN const ImageCodecInfo* codec)
{
    return DllExports::GdipAddImageCodec(codec);
}

inline Status 
RemoveImageCodec(
    IN const ImageCodecInfo* codec)
{
    return DllExports::GdipRemoveImageCodec(codec);
}

#endif  // _GDIPLUSIMAGECODEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusmem.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusMem.h
*
* Abstract:
*
*   Flat GDI+ Memory Allocators - header file
*
* Revision History:
*
*   04/27/2000 gillesk
*       Added Memory APIs
*
\**************************************************************************/

// TODO: this file style needs to be made internally consistent with the way
//       it handles breaking the long argument lists across multiple lines

#ifndef _GDIPLUSMEM_H
#define _GDIPLUSMEM_H

#define WINGDIPAPI __stdcall

// currently, only C++ wrapper API's force const.

#ifdef _GDIPLUS_H
#define GDIPCONST const
#else
#define GDIPCONST
#endif

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
// Memory Allocation APIs
//----------------------------------------------------------------------------

void* WINGDIPAPI
GdipAlloc(size_t size);

void WINGDIPAPI
GdipFree(void* ptr);

#ifdef __cplusplus
}
#endif

#endif // !_GDIPLUSMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdipluslinecaps.h ===
/**************************************************************************\
* 
* Copyright (c) 2000, Microsoft Corp.  All Rights Reserved.
*
* Abstract:
*
*   APIs for Custom Line Caps
*
* Revision History:
*
*   02/23/2000 ikkof
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSLINECAPS_H
#define _GDIPLUSLINECAPS_H

inline 
CustomLineCap::CustomLineCap(
    IN const GraphicsPath* fillPath,
    IN const GraphicsPath* strokePath,
    IN LineCap baseCap,
    IN REAL baseInset
    )
{
    nativeCap = NULL;
    GpPath* nativeFillPath = NULL;
    GpPath* nativeStrokePath = NULL;

    if(fillPath)
        nativeFillPath = fillPath->nativePath;
    if(strokePath)
        nativeStrokePath = strokePath->nativePath;

    lastResult = DllExports::GdipCreateCustomLineCap(
                    nativeFillPath, nativeStrokePath,
                    baseCap, baseInset, &nativeCap);
}

inline 
CustomLineCap::CustomLineCap()
{
    // This is used for default constructor for subclasses.
    // So don't create a nativeCap.

    nativeCap = NULL;
    lastResult = Ok;
}

inline 
CustomLineCap::~CustomLineCap()
{
    DllExports::GdipDeleteCustomLineCap(nativeCap);
}

inline Status 
CustomLineCap::SetStrokeCaps(
    IN LineCap startCap, 
    IN LineCap endCap)
{
    return SetStatus(DllExports::GdipSetCustomLineCapStrokeCaps(nativeCap,
                startCap, endCap));
}

inline Status 
CustomLineCap::GetStrokeCaps(
    OUT LineCap* startCap, 
    OUT LineCap* endCap) const
{
    return SetStatus(DllExports::GdipGetCustomLineCapStrokeCaps(nativeCap,
                 startCap, endCap));
}

inline Status 
CustomLineCap::SetStrokeJoin(
    IN LineJoin lineJoin)
{
    return SetStatus(DllExports::GdipSetCustomLineCapStrokeJoin(nativeCap, lineJoin));
}

inline LineJoin 
CustomLineCap::GetStrokeJoin() const
{
    LineJoin lineJoin;

    SetStatus(DllExports::GdipGetCustomLineCapStrokeJoin(nativeCap, &lineJoin));

    return lineJoin;
}

inline Status 
CustomLineCap::SetBaseCap(IN LineCap baseCap)
{
    return SetStatus(DllExports::GdipSetCustomLineCapBaseCap(nativeCap, baseCap));
}

inline LineCap 
CustomLineCap::GetBaseCap() const
{
    LineCap baseCap;
    SetStatus(DllExports::GdipGetCustomLineCapBaseCap(nativeCap, &baseCap));

    return baseCap;
}

inline Status 
CustomLineCap::SetBaseInset(IN REAL inset)
{
    return SetStatus(DllExports::GdipSetCustomLineCapBaseInset(nativeCap, inset));
}

inline REAL 
CustomLineCap::GetBaseInset() const
{
    REAL inset;
    SetStatus(DllExports::GdipGetCustomLineCapBaseInset(nativeCap, &inset));

    return inset;
}


inline Status 
CustomLineCap::SetWidthScale(IN REAL widthScale)
{
    return SetStatus(DllExports::GdipSetCustomLineCapWidthScale(nativeCap, widthScale));
}

inline REAL 
CustomLineCap::GetWidthScale() const
{
    REAL widthScale;
    SetStatus(DllExports::GdipGetCustomLineCapWidthScale(nativeCap, &widthScale));

    return widthScale;
}

inline CustomLineCap* 
CustomLineCap::Clone() const
{
    GpCustomLineCap *newNativeLineCap = NULL;
    
    SetStatus(DllExports::GdipCloneCustomLineCap(nativeCap, &newNativeLineCap));

    if (lastResult == Ok) 
    {
        CustomLineCap *newLineCap = new CustomLineCap(newNativeLineCap, lastResult);
        if (newLineCap == NULL) 
        {
            SetStatus(DllExports::GdipDeleteCustomLineCap(newNativeLineCap));
        }

        return newLineCap;
    }

    return NULL;
}

class AdjustableArrowCap : public CustomLineCap
{
public:

    AdjustableArrowCap(
        IN REAL height,
        IN REAL width,
        IN BOOL isFilled = TRUE
        )
    {
        GpAdjustableArrowCap* cap = NULL;

        lastResult = DllExports::GdipCreateAdjustableArrowCap(
                        height, width, isFilled, &cap);
        SetNativeCap(cap);
    }

    Status SetHeight(IN REAL height)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapHeight(
                            cap, height));
    }

    REAL GetHeight() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        REAL height;
        SetStatus(DllExports::GdipGetAdjustableArrowCapHeight(
                            cap, &height));

        return height;
    }

    Status SetWidth(IN REAL width)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapWidth(
                            cap, width));
    }

    REAL GetWidth() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        REAL width;
        SetStatus(DllExports::GdipGetAdjustableArrowCapWidth(
                            cap, &width));

        return width;
    }

    Status SetMiddleInset(IN REAL middleInset)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapMiddleInset(
                            cap, middleInset));
    }

    REAL GetMiddleInset() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        REAL middleInset;
        SetStatus(DllExports::GdipGetAdjustableArrowCapMiddleInset(
                            cap, &middleInset));

        return middleInset;
    }

    Status SetFillState(IN BOOL isFilled)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapFillState(
                            cap, isFilled));
    }

    BOOL IsFilled() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        BOOL isFilled;
        SetStatus(DllExports::GdipGetAdjustableArrowCapFillState(
                            cap, &isFilled));

        return isFilled;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusmetafile.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Metafile.h
*
* Abstract:
*
*   Metafile related declarations
*
* Revision History:
*
*   4/26/1999 DCurtis
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSMETAFILE_H
#define _GDIPLUSMETAFILE_H

class Metafile : public Image
{
public:
    friend class Image;

    // Read a metafile
    Metafile()
    {
        SetNativeImage(NULL);
        lastResult = Ok;
    }

    // Playback a metafile from a HMETAFILE
    // If deleteWmf is TRUE, then when the metafile is deleted,
    // the hWmf will also be deleted.  Otherwise, it won't be.
    Metafile(IN HMETAFILE hWmf,
             IN APMFileHeader * apmFileHeader, 
             IN BOOL deleteWmf = FALSE)
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipCreateMetafileFromWmf(hWmf, deleteWmf, apmFileHeader, &metafile);

        SetNativeImage(metafile);
    }

    // Playback a metafile from a HENHMETAFILE
    // If deleteEmf is TRUE, then when the metafile is deleted,
    // the hEmf will also be deleted.  Otherwise, it won't be.
    Metafile(IN HENHMETAFILE hEmf, 
             IN BOOL deleteEmf = FALSE)
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipCreateMetafileFromEmf(hEmf, deleteEmf, &metafile);

        SetNativeImage(metafile);
    }

    // Playback a metafile from a file
    Metafile(IN const WCHAR* filename)
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipCreateMetafileFromFile(filename, &metafile);

        SetNativeImage(metafile);
    }

    // Playback a metafile from a stream
    Metafile(IN IStream* stream)
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipCreateMetafileFromStream(stream, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to memory
    Metafile(
        IN HDC                 referenceHdc,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafile(
                        referenceHdc, type, NULL, MetafileFrameUnitGdi,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to memory
    Metafile(
        IN HDC                 referenceHdc,
        IN const RectF &       frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafile(
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to memory
    Metafile(
        IN HDC                 referenceHdc,
        IN const Rect &        frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileI(
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to a file
    Metafile(
        IN const WCHAR*        fileName,
        IN HDC                 referenceHdc,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileFileName(fileName,
                        referenceHdc, type, NULL, MetafileFrameUnitGdi,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to a file
    Metafile(
        IN const WCHAR*        fileName,
        IN HDC                 referenceHdc,
        IN const RectF &       frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileFileName(fileName,
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to a file
    Metafile(
        IN const WCHAR*        fileName,
        IN HDC                 referenceHdc,
        IN const Rect &        frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileFileNameI(fileName,
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to a stream
    Metafile(
        IN IStream *           stream,
        IN HDC                 referenceHdc,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileStream(stream,
                        referenceHdc, type, NULL, MetafileFrameUnitGdi,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to a stream
    Metafile(
        IN IStream *           stream,
        IN HDC                 referenceHdc,
        IN const RectF &       frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileStream(stream,
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Write a metafile to a stream with down-level GDI records
    Metafile(
        IN IStream *           stream,
        IN HDC                 referenceHdc,
        IN const Rect &        frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileStreamI(stream,
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    static Status GetMetafileHeader(
        IN HMETAFILE           hWmf,
        IN APMFileHeader *     apmFileHeader,
        OUT MetafileHeader *   header
        )
    {
        return DllExports::GdipGetMetafileHeaderFromWmf(hWmf, apmFileHeader, header);
    }

    static Status GetMetafileHeader(
        IN HENHMETAFILE        hEmf,
        OUT MetafileHeader *   header
        )
    {
        return DllExports::GdipGetMetafileHeaderFromEmf(hEmf, header);
    }

    static Status GetMetafileHeader(
        IN const WCHAR*        filename,
        OUT MetafileHeader *   header
        )
    {
        return DllExports::GdipGetMetafileHeaderFromFile(filename, header);
    }

    static Status GetMetafileHeader(
        IN IStream *           stream,
        OUT MetafileHeader *   header
        )
    {
        return DllExports::GdipGetMetafileHeaderFromStream(stream, header);
    }

    Status GetMetafileHeader(
        OUT MetafileHeader *    header
        ) const
    {
        return SetStatus(DllExports::GdipGetMetafileHeaderFromMetafile(
                                              (GpMetafile *)nativeImage, 
                                              header));
    }

    // Once this method is called, the Metafile object is in an invalid state
    // and can no longer be used.  It is the responsiblity of the caller to
    // invoke DeleteEnhMetaFile to delete this hEmf.

    HENHMETAFILE GetHENHMETAFILE()
    {
        HENHMETAFILE hEmf;

        SetStatus(DllExports::GdipGetHemfFromMetafile((GpMetafile *)nativeImage, &hEmf));

        return hEmf;
    }

    // Used in conjuction with Graphics::EnumerateMetafile to play an EMF+
    // The data must be DWORD aligned if it's an EMF or EMF+.  It must be
    // WORD aligned if it's a WMF.
    Status 
    PlayRecord(
        IN EmfPlusRecordType   recordType,
        IN UINT                flags,
        IN UINT                dataSize,
        IN const BYTE *        data
        ) const
    {
        return SetStatus(DllExports::GdipPlayMetafileRecord(
                                (GpMetafile *)nativeImage,
                                recordType,
                                flags,
                                dataSize,
                                data));
    }
};

#endif // !_METAFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusmatrix.h ===
/**************************************************************************\
* 
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Gdiplus.hpp
*
* Abstract:
*
*   GDI+ Native C++ public header file
*
* Revision History:
*
*   03/03/1999 davidx
*       Created it.
*
\**************************************************************************/

class Matrix : public GdiplusBase
{
public:
    friend class Graphics;
    friend class GraphicsPath;
    friend class TextureBrush;
    friend class LinearGradientBrush;
    friend class PathGradientBrush;
    friend class Pen;
    friend class Region;
    
    // Default constructor - set to identity matrix

    Matrix()
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix(&matrix);
    
        SetNativeMatrix(matrix);
    }

    Matrix(IN REAL m11, 
           IN REAL m12,
           IN REAL m21, 
           IN REAL m22,
           IN REAL dx, 
           IN REAL dy)
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix2(m11, m12, m21, m22, 
                                                      dx, dy, &matrix);
    
        SetNativeMatrix(matrix);
    }
    
    Matrix(IN const RectF& rect, 
           IN const PointF* dstplg)
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix3(&rect, 
                                                   dstplg,
                                                   &matrix);

        SetNativeMatrix(matrix);
    }

    Matrix(IN const Rect& rect, 
           IN const Point* dstplg)
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix3I(&rect, 
                                                    dstplg,
                                                    &matrix);

        SetNativeMatrix(matrix);
    }

    ~Matrix()
    {
        DllExports::GdipDeleteMatrix(nativeMatrix);
    }

    Matrix *Clone() const
    {
        GpMatrix *cloneMatrix = NULL;

        SetStatus(DllExports::GdipCloneMatrix(nativeMatrix,
                                                  &cloneMatrix));

        if (lastResult != Ok)
            return NULL;

        return new Matrix(cloneMatrix);
    }

    Status GetElements(OUT REAL *m) const 
    {
        return SetStatus(DllExports::GdipGetMatrixElements(nativeMatrix, m));
    }
    
    Status SetElements(IN REAL m11, 
                       IN REAL m12, 
                       IN REAL m21, 
                       IN REAL m22, 
                       IN REAL dx, 
                       IN REAL dy)
    {
        return SetStatus(DllExports::GdipSetMatrixElements(nativeMatrix,
                            m11, m12, m21, m22, dx, dy));
    }

    REAL OffsetX() const
    {
        REAL elements[6];

        if (GetElements(&elements[0]) == Ok)
            return elements[4];
        else 
            return 0.0f;
    }

    REAL OffsetY() const
    {
       REAL elements[6];

       if (GetElements(&elements[0]) == Ok)
           return elements[5];
       else 
           return 0.0f;
    }

    Status Reset()
    {
        // set identity matrix elements 
        return SetStatus(DllExports::GdipSetMatrixElements(nativeMatrix,
                                             1.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    }

    Status Multiply(IN const Matrix *matrix, 
                    IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyMatrix(nativeMatrix, 
                                          matrix->nativeMatrix,
                                          order));
    }

    Status Translate(IN REAL offsetX, 
                     IN REAL offsetY, 
                     IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, offsetX, offsetY, order));
    }

    Status Scale(IN REAL scaleX, 
                 IN REAL scaleY, 
                 IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleMatrix(nativeMatrix, scaleX, scaleY, order));
    }

    Status Rotate(IN REAL angle, 
                  IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateMatrix(nativeMatrix, angle, order));
    }
    
    Status RotateAt(IN REAL angle, 
                    IN const PointF& center, 
                    IN MatrixOrder order = MatrixOrderPrepend)
    {
        if(order == MatrixOrderPrepend)
        {
            SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, center.X, center.Y, order));
            SetStatus(DllExports::GdipRotateMatrix(nativeMatrix, angle, order));
            return SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, - center.X, - center.Y, order));
        }
        else
        {
            SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, - center.X, - center.Y, order));
            SetStatus(DllExports::GdipRotateMatrix(nativeMatrix, angle, order));
            return SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, center.X, center.Y, order));
        }
    }

    Status Shear(IN REAL shearX, 
                 IN REAL shearY,
                 IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipShearMatrix(nativeMatrix, shearX, shearY, order));
    }

    Status Invert()
    {
        return SetStatus(DllExports::GdipInvertMatrix(nativeMatrix));
    }

    // float version
    Status TransformPoints(IN OUT PointF* pts, 
                           IN INT count = 1) const
    {
        return SetStatus(DllExports::GdipTransformMatrixPoints(nativeMatrix, pts, count));
    }
    
    Status TransformPoints(IN OUT Point* pts, 
                           IN INT count = 1) const
    {
        return SetStatus(DllExports::GdipTransformMatrixPointsI(nativeMatrix, 
                                                                pts, 
                                                                count));
    }

    Status TransformVectors(IN OUT PointF* pts, 
                            IN INT count = 1) const
    { 
        return SetStatus(DllExports::GdipVectorTransformMatrixPoints(nativeMatrix, pts, count));
    }

    Status TransformVectors(IN OUT Point* pts, 
                            IN INT count = 1) const
    { 
       return SetStatus(DllExports::GdipVectorTransformMatrixPointsI(nativeMatrix, 
                                                                    pts, 
                                                                    count));
    }
    
    BOOL IsInvertible() const
    {
        BOOL result = FALSE;

        SetStatus(DllExports::GdipIsMatrixInvertible(nativeMatrix, &result));
    
        return result;
    }

    BOOL IsIdentity() const
    {
       BOOL result = FALSE;

       SetStatus(DllExports::GdipIsMatrixIdentity(nativeMatrix, &result));
    
       return result;
    }

    BOOL Equals(IN const Matrix *matrix) const
    {
       BOOL result = FALSE;

       SetStatus(DllExports::GdipIsMatrixEqual(nativeMatrix,
                                                 matrix->nativeMatrix, &result));
   
       return result;
    }
    
    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;
 
        return lastStatus;
    }

protected:
    Matrix(const Matrix& matrix)
    {
        matrix;
        SetStatus(NotImplemented);
        SetNativeMatrix(NULL);
    }

    Matrix& operator=(const Matrix& matrix)
    {
        matrix;
        SetStatus(NotImplemented);
        return *this;
    }

    Matrix(GpMatrix *nativeMatrix)
    {
        lastResult = Ok;
        SetNativeMatrix(nativeMatrix);
    }
    
    VOID SetNativeMatrix(GpMatrix *nativeMatrix)
    {
        this->nativeMatrix = nativeMatrix;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpMatrix *nativeMatrix;
    mutable Status lastResult;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusmetaheader.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Metafile headers
*
* Abstract:
*
*   Declarations for various metafile header structures.
*
* Revision History:
*
*   10/15/1999 DCurtis
*       Created it.
*   10/15/1999 AGodfrey
*       Moved it to a separate file.
*
\**************************************************************************/

#ifndef _GDIPLUSMETAHEADER_H
#define _GDIPLUSMETAHEADER_H

typedef struct
{
    DWORD   iType;              // Record type EMR_HEADER
    DWORD   nSize;              // Record size in bytes.  This may be greater
                                // than the sizeof(ENHMETAHEADER).
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    RECTL   rclFrame;           // Inclusive-inclusive Picture Frame of metafile in .01 mm units
    DWORD   dSignature;         // Signature.  Must be ENHMETA_SIGNATURE.
    DWORD   nVersion;           // Version number
    DWORD   nBytes;             // Size of the metafile in bytes
    DWORD   nRecords;           // Number of records in the metafile
    WORD    nHandles;           // Number of handles in the handle table
                                // Handle index zero is reserved.
    WORD    sReserved;          // Reserved.  Must be zero.
    DWORD   nDescription;       // Number of chars in the unicode description string
                                // This is 0 if there is no description string
    DWORD   offDescription;     // Offset to the metafile description record.
                                // This is 0 if there is no description string
    DWORD   nPalEntries;        // Number of entries in the metafile palette.
    SIZEL   szlDevice;          // Size of the reference device in pels
    SIZEL   szlMillimeters;     // Size of the reference device in millimeters
} ENHMETAHEADER3;

// Aldus Placeable Metafiles

// Placeable Metafiles were created by Aldus Corporation as a non-standard
// way of specifying how a metafile is mapped and scaled on an output device.
// Placeable metafiles are quite wide-spread, but not directly supported by
// the Windows API. To playback a placeable metafile using the Windows API,
// you will first need to strip the placeable metafile header from the file.
// This is typically performed by copying the metafile to a temporary file
// starting at file offset 22 (0x16). The contents of the temporary file may
// then be used as input to the Windows GetMetaFile(), PlayMetaFile(),
// CopyMetaFile(), etc. GDI functions.

// Each placeable metafile begins with a 22-byte header,
//  followed by a standard metafile:

#include <pshpack2.h>   // set structure packing to 2

typedef struct
{
    INT16           Left;
    INT16           Top;
    INT16           Right;
    INT16           Bottom;
} APMRect16;

typedef struct
{
    UINT32          Key;            // GDIP_WMF_ALDUSKEY
    INT16           Hmf;            // Metafile HANDLE number (always 0)
    APMRect16       BoundingBox;    // Coordinates in metafile units
    INT16           Inch;           // Number of metafile units per inch
    UINT32          Reserved;       // Reserved (always 0)
    INT16           Checksum;       // Checksum value for previous 10 WORDs
} APMFileHeader;

#include <poppack.h>

// Key contains a special identification value that indicates the presence
// of a placeable metafile header and is always 0x9AC6CDD7.

// Handle is used to stored the handle of the metafile in memory. When written
// to disk, this field is not used and will always contains the value 0.

// Left, Top, Right, and Bottom contain the coordinates of the upper-left
// and lower-right corners of the image on the output device. These are
// measured in twips.

// A twip (meaning "twentieth of a point") is the logical unit of measurement
// used in Windows Metafiles. A twip is equal to 1/1440 of an inch. Thus 720
// twips equal 1/2 inch, while 32,768 twips is 22.75 inches.

// Inch contains the number of twips per inch used to represent the image.
// Normally, there are 1440 twips per inch; however, this number may be
// changed to scale the image. A value of 720 indicates that the image is
// double its normal size, or scaled to a factor of 2:1. A value of 360
// indicates a scale of 4:1, while a value of 2880 indicates that the image
// is scaled down in size by a factor of two. A value of 1440 indicates
// a 1:1 scale ratio.

// Reserved is not used and is always set to 0.

// Checksum contains a checksum value for the previous 10 WORDs in the header.
// This value can be used in an attempt to detect if the metafile has become
// corrupted. The checksum is calculated by XORing each WORD value to an
// initial value of 0.

// If the metafile was recorded with a reference Hdc that was a display.
#define GDIP_EMFPLUSFLAGS_DISPLAY       0x00000001

class MetafileHeader
{
public:
    MetafileType        Type;
    UINT                Size;               // Size of the metafile (in bytes)
    UINT                Version;            // EMF+, EMF, or WMF version
    UINT                EmfPlusFlags;
    REAL                DpiX;
    REAL                DpiY;
    INT                 X;                  // Bounds in device units
    INT                 Y;
    INT                 Width;
    INT                 Height;
    union
    {
        METAHEADER      WmfHeader;
        ENHMETAHEADER3  EmfHeader;
    };
    INT                 EmfPlusHeaderSize;  // size of the EMF+ header in file
    INT                 LogicalDpiX;        // Logical Dpi of reference Hdc
    INT                 LogicalDpiY;        // usually valid only for EMF+ files

public:
    // Get the metafile type
    MetafileType GetType() const { return Type; }

    // Get the size of the metafile in BYTEs
    UINT GetMetafileSize() const { return Size; }

    // If IsEmfPlus, this is the EMF+ version; else it is the WMF or EMF version
    UINT GetVersion() const { return Version; }

    // Get the EMF+ flags associated with the metafile
    UINT GetEmfPlusFlags() const { return EmfPlusFlags; }

    // Get the X Dpi of the metafile
    REAL GetDpiX() const { return DpiX; }

    // Get the Y Dpi of the metafile
    REAL GetDpiY() const { return DpiY; }

    // Get the bounds of the metafile in device units
    VOID GetBounds (OUT Rect *rect) const
    {
        rect->X = X;
        rect->Y = Y;
        rect->Width = Width;
        rect->Height = Height;
    }
    
    // Is it any type of WMF (standard or Aldus Placeable Metafile)?
    BOOL IsWmf() const
    {
       return ((Type == MetafileTypeWmf) || (Type == MetafileTypeWmfAldus));
    }

    // Is this an Aldus Placeable Metafile?
    BOOL IsWmfAldus() const { return (Type == MetafileTypeWmf); }

    // Is this an EMF (not an EMF+)?
    BOOL IsEmf() const { return (Type == MetafileTypeEmf); }

    // Is this an EMF or EMF+ file?
    BOOL IsEmfOrEmfPlus() const { return (Type >= MetafileTypeEmf); }

    // Is this an EMF+ file?
    BOOL IsEmfPlus() const { return (Type >= MetafileTypeEmfPlusOnly); }

    // Is this an EMF+ dual (has dual, down-level records) file?
    BOOL IsEmfPlusDual() const { return (Type == MetafileTypeEmfPlusDual); }

    // Is this an EMF+ only (no dual records) file?
    BOOL IsEmfPlusOnly() const { return (Type == MetafileTypeEmfPlusOnly); }

    // If it's an EMF+ file, was it recorded against a display Hdc?
    BOOL IsDisplay() const
    {
        return (IsEmfPlus() &&
                ((EmfPlusFlags & GDIP_EMFPLUSFLAGS_DISPLAY) != 0));
    }

    // Get the WMF header of the metafile (if it is a WMF)
    const METAHEADER * GetWmfHeader() const
    {
        if (IsWmf())
        {
            return &WmfHeader;
        }
        return NULL;
    }

    // Get the EMF header of the metafile (if it is an EMF)
    const ENHMETAHEADER3 * GetEmfHeader() const
    {
        if (IsEmfOrEmfPlus())
        {
            return &EmfHeader;
        }
        return NULL;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdipluspen.h ===
/**************************************************************************\
* 
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Abstract:
*
*   Pen API related declarations
*
* Revision History:
*
*   12/09/1998 andrewgo
*       Flesh out pen interfaces.
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/
#ifndef _GDIPLUSPEN_H
#define _GDIPLUSPEN_H

//--------------------------------------------------------------------------
// class for various pen types
//--------------------------------------------------------------------------

class Pen : public GdiplusBase
{
public:
    friend class GraphicsPath;
    friend class Graphics;

    // abstract Clone() can't be implemented here because it can't
    // new an object with pure virtual functions

    // Constructors

    Pen(IN const Color& color, 
        IN REAL width = 1.0f)
    {
        Unit unit = UnitWorld;
        nativePen = NULL;
        lastResult = DllExports::GdipCreatePen1(color.GetValue(),
                                    width, unit, &nativePen);
    }

    Pen(IN const Brush* brush, 
        IN REAL width = 1.0f)
    {
        Unit unit = UnitWorld;
        nativePen = NULL;
        lastResult = DllExports::GdipCreatePen2(brush->nativeBrush,
                                    width, unit, &nativePen);
    }

    ~Pen()
    {
        DllExports::GdipDeletePen(nativePen);
    }

    Pen* Clone() const
    {
        GpPen *clonePen = NULL;

        lastResult = DllExports::GdipClonePen(nativePen, &clonePen);
   
        return new Pen(clonePen, lastResult);
    }

    Status SetWidth(IN REAL width)
    {
        return SetStatus(DllExports::GdipSetPenWidth(nativePen, width));
    }

    REAL GetWidth() const
    {
        REAL width;

        SetStatus(DllExports::GdipGetPenWidth(nativePen, &width));
        
        return width;
    }
    
    // Set/get line caps: start, end, and dash

    // Line cap and join APIs by using LineCap and LineJoin enums.

    Status SetLineCap(IN LineCap startCap, 
                      IN LineCap endCap, 
                      IN LineCap dashCap)
    {
        return SetStatus(DllExports::GdipSetPenLineCap(nativePen, 
                                   startCap, endCap, dashCap));
    }

    Status SetStartCap(IN LineCap startCap)
    {
        return SetStatus(DllExports::GdipSetPenStartCap(nativePen, startCap));
    }

    Status SetEndCap(IN LineCap endCap)
    {
        return SetStatus(DllExports::GdipSetPenEndCap(nativePen, endCap));
    }

    Status SetDashCap(IN LineCap dashCap)
    {
        return SetStatus(DllExports::GdipSetPenDashCap(nativePen, dashCap));
    }

    LineCap GetStartCap() const
    {
        LineCap startCap;

        SetStatus(DllExports::GdipGetPenStartCap(nativePen, &startCap));
        
        return startCap;
    }

    LineCap GetEndCap() const
    {
        LineCap endCap;

        SetStatus(DllExports::GdipGetPenEndCap(nativePen, &endCap));

        return endCap;
    }

    LineCap GetDashCap() const
    {
        LineCap dashCap;

        SetStatus(DllExports::GdipGetPenDashCap(nativePen, &dashCap));

        return dashCap;
    }

    // Set/get line join

    Status SetLineJoin(IN LineJoin lineJoin)
    {
        return SetStatus(DllExports::GdipSetPenLineJoin(nativePen, lineJoin));
    }

    LineJoin GetLineJoin() const
    {
        LineJoin lineJoin;
        
        SetStatus(DllExports::GdipGetPenLineJoin(nativePen, &lineJoin));
        
        return lineJoin;
    }

    Status SetCustomStartCap(IN const CustomLineCap* customCap)
    {
        GpCustomLineCap* nativeCap = NULL;
        if(customCap)
            nativeCap = customCap->nativeCap;

        return SetStatus(DllExports::GdipSetPenCustomStartCap(nativePen, nativeCap));
    }

    Status GetCustomStartCap(OUT CustomLineCap* customCap) const
    {
        if(!customCap)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipGetPenCustomStartCap(nativePen, &(customCap->nativeCap)));
    }

    Status SetCustomEndCap(IN const CustomLineCap* customCap)
    {
        GpCustomLineCap* nativeCap = NULL;
        if(customCap)
            nativeCap = customCap->nativeCap;

        return SetStatus(DllExports::GdipSetPenCustomEndCap(nativePen, nativeCap));
    }

    Status GetCustomEndCap(OUT CustomLineCap* customCap) const
    {
        if(!customCap)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipGetPenCustomEndCap(nativePen, &(customCap->nativeCap)));
    }

    Status SetMiterLimit(IN REAL miterLimit)
    {
        return SetStatus(DllExports::GdipSetPenMiterLimit(nativePen, miterLimit));
    }

    REAL GetMiterLimit() const
    {
        REAL miterLimit;

        SetStatus(DllExports::GdipGetPenMiterLimit(nativePen, &miterLimit));

        return miterLimit;
    }

    // Set/get pen mode
    Status SetAlignment(IN PenAlignment penAlignment)
    {
        return SetStatus(DllExports::GdipSetPenMode(nativePen, penAlignment));
    }

    PenAlignment GetAlignment() const
    {
        PenAlignment penAlignment;
        
        SetStatus(DllExports::GdipGetPenMode(nativePen, &penAlignment));
        
        return penAlignment;
    }
    
    // Set/get pen transform
    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetPenTransform(nativePen, 
                                                         matrix->nativeMatrix));
    }

    Status GetTransform(OUT Matrix* matrix) const
    {
        return SetStatus(DllExports::GdipGetPenTransform(nativePen, matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetPenTransform(nativePen));
    }

    Status MultiplyTransform(IN Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyPenTransform(nativePen,
                                                              matrix->nativeMatrix,
                                                              order));
    }

    Status TranslateTransform(IN REAL dx, 
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslatePenTransform(nativePen,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScalePenTransform(nativePen,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotatePenTransform(nativePen,
                                                              angle, order));
    }

    PenType GetPenType() const
    {
       PenType type;
       SetStatus(DllExports::GdipGetPenFillType(nativePen, &type));

       return type;
    }

    Status SetColor(IN const Color& color)
    {
        return SetStatus(DllExports::GdipSetPenColor(nativePen,
                                                     color.GetValue()));
    }

    Status SetBrush(IN const Brush* brush)
    {
        return SetStatus(DllExports::GdipSetPenBrushFill(nativePen, 
                                       brush->nativeBrush));
    }

    Status GetColor(OUT Color* color)
    {
        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        PenType type = GetPenType();

        if (type != PenTypeSolidColor) 
        {
            return WrongState;
        }
        
        ARGB argb;
        
        SetStatus(DllExports::GdipGetPenColor(nativePen,
                                              &argb));
        if (lastResult == Ok)
        {
            color->SetValue(argb);
        }
        
        return lastResult;
    }

    Brush* GetBrush() const
    {
       PenType type = GetPenType();

       Brush* brush = NULL;

       switch(type)
       {
       case PenTypeSolidColor:
           brush = new SolidBrush();
           break;

       case PenTypeHatchFill:
           brush = new HatchBrush();
           break;

       case PenTypeTextureFill:
           brush = new TextureBrush();
           break;

       case PenTypePathGradient:
           brush = new Brush();
           break;

       case PenTypeLinearGradient:
           brush = new LinearGradientBrush();
           break;

       default:
           break;
       }

       if(brush)
       {
           GpBrush* nativeBrush;

           SetStatus(DllExports::GdipGetPenBrushFill(nativePen, &nativeBrush));
           brush->SetNativeBrush(nativeBrush);
       }

       return brush;
    }

    DashStyle GetDashStyle() const
    {
        DashStyle dashStyle;

        SetStatus(DllExports::GdipGetPenDashStyle(nativePen, &dashStyle));

        return dashStyle;
    }

    Status SetDashStyle(IN DashStyle dashStyle)
    {
        return SetStatus(DllExports::GdipSetPenDashStyle(nativePen, dashStyle));
    }

    REAL GetDashOffset() const
    {
        REAL dashOffset;

        SetStatus(DllExports::GdipGetPenDashOffset(nativePen, &dashOffset));

        return dashOffset;
    }

    Status SetDashOffset(IN REAL dashOffset)
    {
        return SetStatus(DllExports::GdipSetPenDashOffset(nativePen, dashOffset));
    }
    
    Status SetDashPattern(IN const REAL* dashArray, IN INT count)
    {
        return SetStatus(DllExports::GdipSetPenDashArray(nativePen, dashArray, 
                                                    count));
    }
    
    INT GetDashPatternCount() const
    {
        INT count = 0;
        
        SetStatus(DllExports::GdipGetPenDashCount(nativePen, &count));
        
        return count;
    }

    Status GetDashPattern(OUT REAL* dashArray, 
                          IN INT count) const
    {
        if (dashArray == NULL || count <= 0)
            return SetStatus(InvalidParameter); 
        
        return SetStatus(DllExports::GdipGetPenDashArray(nativePen, 
                                                         dashArray, 
                                                         count));
    }

    Status SetCompoundArray(IN const REAL* compoundArray,
                            IN INT count)
    {
        return SetStatus(DllExports::GdipSetPenCompoundArray(nativePen, compoundArray, 
                                                    count));
    }

    INT GetCompoundArrayCount() const
    {
        INT count = 0;
        
        SetStatus(DllExports::GdipGetPenCompoundCount(nativePen, &count));
        
        return count;
    }

    Status GetCompoundArray(OUT REAL* compoundArray, 
                            IN INT count) const
    {
        if (compoundArray == NULL || count <= 0)
            return SetStatus(InvalidParameter); 
        
        return SetStatus(DllExports::GdipGetPenCompoundArray(nativePen, 
                                                             compoundArray, 
                                                             count));
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

protected:
    Pen(const Pen& pen)
    {
        pen;
        SetStatus(NotImplemented);
        SetNativePen(NULL);
    }

    Pen& operator=(const Pen& pen)
    {
        pen;
        SetStatus(NotImplemented);
        return *this;
    }

    Pen(GpPen* nativePen, Status status)
    {
        lastResult = status;
        SetNativePen(nativePen);
    }

    VOID SetNativePen(GpPen* nativePen)
    {
        this->nativePen = nativePen;
    }
    
    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else 
            return status;
    }

protected:
    GpPen* nativePen;
    mutable Status lastResult;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdipluspixelformats.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Gdiplus pixel formats
*
* Abstract:
*
*   Definitions for color types, palettes, pixel format IDs.
*
* Notes:
*
*   imaging.h
*
* Revision History:
*
*   10/13/1999 agodfrey
*       Separated it from imaging.h
*
\**************************************************************************/

#ifndef _GDIPLUSPIXELFORMATS_H
#define _GDIPLUSPIXELFORMATS_H

/*
 * 32-bit and 64-bit ARGB pixel value
 */

typedef DWORD ARGB;
typedef DWORDLONG ARGB64;

#define ALPHA_SHIFT 24
#define RED_SHIFT   16
#define GREEN_SHIFT 8
#define BLUE_SHIFT  0
#define ALPHA_MASK  ((ARGB) 0xff << ALPHA_SHIFT)

/*
 * In-memory pixel data formats:
 *  bits 0-7 = format index
 *  bits 8-15 = pixel size (in bits)
 *  bits 16-23 = flags
 *  bits 24-31 = reserved
 */

enum PixelFormat
{
    PixelFormatIndexed      = 0x00010000, // Indexes into a palette
    PixelFormatGDI          = 0x00020000, // Is a GDI-supported format
    PixelFormatAlpha        = 0x00040000, // Has an alpha component
    PixelFormatPAlpha       = 0x00080000, // Uses pre-multiplied alpha
    PixelFormatExtended     = 0x00100000, // Uses extended color (16 bits per channel)
    PixelFormatCanonical    = 0x00200000, // ?

    PixelFormatUndefined       =  0,
    PixelFormatDontCare        =  0,

    PixelFormat1bppIndexed     =  1 | ( 1 << 8) | PixelFormatIndexed
                                                | PixelFormatGDI,
    PixelFormat4bppIndexed     =  2 | ( 4 << 8) | PixelFormatIndexed
                                                | PixelFormatGDI,
    PixelFormat8bppIndexed     =  3 | ( 8 << 8) | PixelFormatIndexed
                                                | PixelFormatGDI,
    PixelFormat16bppGrayScale  =  4 | (16 << 8) | PixelFormatExtended,
    PixelFormat16bppRGB555     =  5 | (16 << 8) | PixelFormatGDI,
    PixelFormat16bppRGB565     =  6 | (16 << 8) | PixelFormatGDI,
    PixelFormat16bppARGB1555   =  7 | (16 << 8) | PixelFormatAlpha
                                                | PixelFormatGDI,
    PixelFormat24bppRGB        =  8 | (24 << 8) | PixelFormatGDI,
    PixelFormat32bppRGB        =  9 | (32 << 8) | PixelFormatGDI,
    PixelFormat32bppARGB       = 10 | (32 << 8) | PixelFormatAlpha
                                                | PixelFormatGDI
                                                | PixelFormatCanonical,
    PixelFormat32bppPARGB      = 11 | (32 << 8) | PixelFormatAlpha
                                                | PixelFormatPAlpha
                                                | PixelFormatGDI,
    PixelFormat48bppRGB        = 12 | (48 << 8) | PixelFormatExtended,
    PixelFormat64bppARGB       = 13 | (64 << 8) | PixelFormatAlpha
                                                | PixelFormatCanonical
                                                | PixelFormatExtended,
    PixelFormat64bppPARGB      = 14 | (64 << 8) | PixelFormatAlpha
                                                | PixelFormatPAlpha
                                                | PixelFormatExtended,
    PixelFormat24bppBGR        = 15 | (24 << 8) | PixelFormatGDI,
    PixelFormatMax             = 16
};

/*
 * Return the pixel size for the specified format (in bits)
 */

inline UINT
GetPixelFormatSize(
                   PixelFormat pixfmt
    )
{
    return (pixfmt >> 8) & 0xff;
}

/*
 * Determine if the specified pixel format is an indexed color format
 */

inline BOOL
IsIndexedPixelFormat(
                     PixelFormat pixfmt
    )
{
    return (pixfmt & PixelFormatIndexed) != 0;
}

/*
 * Determine if the pixel format can have alpha channel
 */

inline BOOL
IsAlphaPixelFormat(
                     PixelFormat pixfmt
)
{
   return (pixfmt & PixelFormatAlpha) != 0;
}

/*
 * Determine if the pixel format is an extended format,
 * i.e. supports 16-bit per channel
 */

inline BOOL
IsExtendedPixelFormat(
                     PixelFormat pixfmt
    )
{
   return (pixfmt & PixelFormatExtended) != 0;
}

/*
 * Determine if the pixel format is canonical format:
 *   PixelFormat32bppARGB
 *   PixelFormat32bppPARGB
 *   PixelFormat64bppARGB
 *   PixelFormat64bppPARGB
 */

inline BOOL
IsCanonicalPixelFormat(
                     PixelFormat pixfmt
    )
{
   return (pixfmt & PixelFormatCanonical) != 0;
}

/*
 * Color palette
 * palette entries are limited to 32bpp ARGB pixel format
 */ 

enum PaletteFlags
{
    PaletteFlagsHasAlpha    = 0x0001,
    PaletteFlagsGrayScale   = 0x0002,
    PaletteFlagsHalftone    = 0x0004
};

struct ColorPalette
{
public:
    UINT Flags;             // palette flags
    UINT Count;             // number of color entries
    ARGB Entries[1];        // palette color entries
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusstringformat.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Abstract:
*
*   String format specification for DrawString and text APIs
*
* Revision History:
*
*   08/05/1999 dbrown
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSSTRINGFORMAT_H
#define _GDIPLUSSTRINGFORMAT_H

class StringFormat : public GdiplusBase
{
public:
    friend class Graphics;
    friend class GraphicsPath;

    StringFormat(
        IN INT     formatFlags,
        IN LANGID  language = LANG_NEUTRAL
    )
    {
        nativeFormat = NULL;
        lastError = DllExports::GdipCreateStringFormat(
            formatFlags,
            language,
            &nativeFormat
        );
    }

    static const StringFormat *GenericDefault();
    static const StringFormat *GenericTypographic();

    // Constructor based on existing string format

    StringFormat(
        IN const StringFormat *format
    )
    {
        lastError = DllExports::GdipCloneStringFormat(
            format->nativeFormat,
            &nativeFormat
        );
    }

    StringFormat *Clone() const
    {
        GpStringFormat *clonedStringFormat = NULL;

        lastError = DllExports::GdipCloneStringFormat(
            nativeFormat,
            &clonedStringFormat
        );

        if (lastError == Ok)
            return new StringFormat(clonedStringFormat, lastError);
        else
            return NULL;
    }

    ~StringFormat()
    {
        DllExports::GdipDeleteStringFormat(nativeFormat);
    }

    Status SetFormatFlags(IN INT flags)
    {
        return SetStatus(DllExports::GdipSetStringFormatFlags(
            nativeFormat,
            flags
        ));
    }

    INT GetFormatFlags() const
    {
        INT flags;
        SetStatus(DllExports::GdipGetStringFormatFlags(nativeFormat, &flags));
        return flags;
    }

    Status SetLineSpacing(
        IN REAL        amount = 1.0f,
        IN LineSpacing method = LineSpacingRecommended
    )
    {
        return SetStatus(DllExports::GdipSetStringFormatLineSpacing(
            nativeFormat,
            amount,
            method
        ));
    }

    Status SetAlignment(IN StringAlignment align)
    {
        return SetStatus(DllExports::GdipSetStringFormatAlign(
            nativeFormat,
            align
        ));
    }

    StringAlignment GetAlignment() const
    {
        StringAlignment alignment;
        SetStatus(DllExports::GdipGetStringFormatAlign(
            nativeFormat,
            &alignment
        ));
        return alignment;
    }

    Status SetLineAlignment(IN StringAlignment align)
    {
        return SetStatus(DllExports::GdipSetStringFormatLineAlign(
            nativeFormat,
            align
        ));
    }

    StringAlignment GetLineAlignment() const
    {
        StringAlignment alignment;
        SetStatus(DllExports::GdipGetStringFormatLineAlign(
            nativeFormat,
            &alignment
        ));
        return alignment;
    }

    Status SetHotkeyPrefix(IN HotkeyPrefix hotkeyPrefix)
    {
        return SetStatus(DllExports::GdipSetStringFormatHotkeyPrefix(
            nativeFormat,
            (INT)hotkeyPrefix
        ));
    }

    HotkeyPrefix GetHotkeyPrefix() const
    {
        HotkeyPrefix hotkeyPrefix;
        SetStatus(DllExports::GdipGetStringFormatHotkeyPrefix(
            nativeFormat,
            (INT*)&hotkeyPrefix
        ));
        return hotkeyPrefix;
    }

    Status SetTabStops(
        IN REAL    firstTabOffset,
        IN INT     count,
        IN REAL    *tabStops
    )
    {
        return SetStatus(DllExports::GdipSetStringFormatTabStops(
            nativeFormat,
            firstTabOffset,
            count,
            tabStops
        ));
    }

    INT GetTabStopCount() const
    {
        INT count;
        SetStatus(DllExports::GdipGetStringFormatTabStopCount(nativeFormat, &count));
        return count;
    }

    Status GetTabStops(
        IN INT     count,
        OUT REAL   *firstTabOffset,
        OUT REAL   *tabStops
    ) const
    {
        return SetStatus(DllExports::GdipGetStringFormatTabStops(
            nativeFormat,
            count,
            firstTabOffset,
            tabStops
        ));
    }

#ifdef DCR_USE_NEW_146933
    Status SetDigitSubstitution(
        IN LANGID                language, 
        IN StringDigitSubstitute substitute
    )
    {
        return SetStatus(DllExports::GdipSetStringFormatDigitSubstitution(
            nativeFormat,        
            language,
            substitute
        ));
    }

    LANGID GetDigitSubstitutionLanguage(
    )
    {
        LANGID language;
        SetStatus(DllExports::GdipGetStringFormatDigitSubstitution(
            nativeFormat,        
            &language,
            NULL
        ));
        return language;
    }
    
    StringDigitSubstitute GetDigitSubstitutionMethod(
    )
    {
        StringDigitSubstitute substitute;
        SetStatus(DllExports::GdipGetStringFormatDigitSubstitution(
            nativeFormat,        
            NULL,
            &substitute
        ));
        return substitute;
    }
#endif // DCR_USE_NEW_146933

    // String trimming. How to handle more text than can be displayed
    // in the limits available.

    Status SetTrimming(IN StringTrimming trimming)
    {
        return SetStatus(DllExports::GdipSetStringFormatTrimming(
            nativeFormat,
            trimming
        ));
    }

    StringTrimming StringFormat::GetTrimming() const
    {
        StringTrimming trimming;
        SetStatus(DllExports::GdipGetStringFormatTrimming(
            nativeFormat,
            &trimming
        ));
        return trimming;
    }

    // GetLastStatus - return last error code and clear error code

    Status GetLastStatus() const
    {
        Status lastStatus = lastError;
        lastError = Ok;

        return lastStatus;
    }


    // Empty constructor used for static generic values

    StringFormat() :
        nativeFormat (NULL),
        lastError    (NotImplemented)
    {}


protected:

    Status SetStatus(GpStatus newStatus) const
    {
        if (newStatus == Ok)
        {
            return Ok;
        }
        else
        {
            return lastError = newStatus;
        }
    }


// Not allowed and move to private
    StringFormat(const StringFormat &source)
    {
        nativeFormat = NULL;
        lastError = DllExports::GdipCloneStringFormat(
            source.nativeFormat,
            &nativeFormat
        );
    }

    StringFormat& operator=(const StringFormat &source)
    {
        DllExports::GdipDeleteStringFormat(nativeFormat);
        lastError = DllExports::GdipCloneStringFormat(
            source.nativeFormat,
            &nativeFormat
        );
        return *this;
    }


    // private constructor for copy
    StringFormat(GpStringFormat * clonedStringFormat, Status status)
    {
        lastError = status;
        nativeFormat = clonedStringFormat;

    }

    GpStringFormat *nativeFormat;
    mutable Status  lastError;
};

// Generic constant string formats.

static BYTE GenericTypographicStringFormatBuffer[sizeof(StringFormat)] = {0};
static BYTE GenericDefaultStringFormatBuffer[sizeof(StringFormat)] = {0};

static StringFormat *GenericTypographicStringFormat = NULL;
static StringFormat *GenericDefaultStringFormat     = NULL;

// Define the generic string formats


inline const StringFormat *StringFormat::GenericDefault()
{
    if (GenericDefaultStringFormat != NULL)
    {
        return GenericDefaultStringFormat;
    }

    GenericDefaultStringFormat =
        (StringFormat*)GenericDefaultStringFormatBuffer;

    GenericDefaultStringFormat->lastError =
        DllExports::GdipStringFormatGetGenericDefault(
            &(GenericDefaultStringFormat->nativeFormat)
        );

    return GenericDefaultStringFormat;
}

inline const StringFormat *StringFormat::GenericTypographic()
{
    if (GenericTypographicStringFormat != NULL)
    {
        return GenericTypographicStringFormat;
    }

    GenericTypographicStringFormat =
        (StringFormat*)GenericTypographicStringFormatBuffer;

    GenericTypographicStringFormat->lastError =
        DllExports::GdipStringFormatGetGenericTypographic(
            &GenericTypographicStringFormat->nativeFormat
        );

    return GenericTypographicStringFormat;
}

#endif // !_GDIPLUSSTRINGFORMAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\icecap.h ===
//-----------------------------------------------------------------------------
//
//  File: Icecap.h
//  Copyright (C) 1997-1998 Microsoft Corporation
//  All rights reserved.
//
//  This header file is part of IceCAP 4.0.0382.  It is
//  MICROSOFT CONFIDENTIAL, and should not be distributed except under NDA.
//
//-----------------------------------------------------------------------------

// ICECAP.H
// interface to the Datalocality APIs

#ifndef __ICECAP_H__
#define __ICECAP_H__

#ifndef DONTUSEICECAPLIB
#pragma comment(lib, "IceCAP.lib")
#endif	// USEICECAPLIB

#ifdef __cplusplus
extern "C" {
#endif

// Defines for Levels and Id's
#define PROFILE_GLOBALLEVEL 1
#define PROFILE_PROCESSLEVEL 2
#define PROFILE_THREADLEVEL 3
#define PROFILE_CURRENTID ((unsigned long)0xFFFFFFFF)

// Start/Stop Api's
int _declspec(dllimport) _stdcall StopProfile(int nLevel, unsigned long dwId);
int _declspec(dllimport) _stdcall StartProfile(int nLevel, unsigned long dwId);

// Suspend/Resume Api's
int _declspec(dllimport) _stdcall SuspendProfile(int nLevel, unsigned long dwId);
int _declspec(dllimport) _stdcall ResumeProfile(int nLevel, unsigned long dwId);

// Mark Api's
int _declspec(dllimport) _stdcall MarkProfile(long lMarker);

// xxxProfile return codes
#define PROFILE_OK 0						// xxxProfile call successful
#define PROFILE_ERROR_NOT_YET_IMPLEMENTED 1 // api or level,id combination not supported yet
#define PROFILE_ERROR_MODE_NEVER 2		// mode was never when called
#define PROFILE_ERROR_LEVEL_NOEXIST 3	// level doesn't exist
#define PROFILE_ERROR_ID_NOEXIST 4		// id doesn't exist

// MarkProfile return codes
#define MARK_OK			0			// Mark was taken successfully
#define MARK_ERROR_MODE_NEVER	1	// Profiling was never when MarkProfile called
#define MARK_ERROR_PRO_OFF	2		// old define until tests fixed
#define MARK_ERROR_MODE_OFF	2		// Profiling was off when MarkProfile called
#define MARK_ERROR_MARKER_RESERVED 3	// Mark value passed is a reserved value

// Icecap 3.x Compatibility defines
#define StartCAP() StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)
#define StopCAP() StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)
#define SuspendCAP() SuspendProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)
#define ResumeCAP() ResumeProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)

#define StartCAPAll() StartProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)
#define StopCAPAll() StopProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)
#define SuspendCAPAll() SuspendProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)
#define ResumeCAPAll() ResumeProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)

#define MarkCAP(mark) MarkProfile(mark)

// DataLocality 1.x Compatibility defines
#define StartDLP() StartCAP()
#define StopDLP() StopCAP()
#define MarkDLP(mark) MarkCAP(mark)

//
// USER DEFINED COUNTER HELPERS AND TYPES
//

// COUNTER_FUNCTION_PROLOGE and EPILOGE
//
// These functions are supplied to protect the state of registers
// that the IceCAP collection probes rely on.  We did everything we
// could to eliminate instructions during collection.  Your mission,
// if you choose to accept it, is the same.
//
#define COUNTER_FUNCTION_PROLOGE	_asm push ecx _asm push ebx _asm push ebp
#define COUNTER_FUNCTION_EPILOGE	_asm pop ebp _asm pop ebx _asm pop ecx _asm ret

#ifndef USER_COUNTER_INFO_DEFINED
#define USER_COUNTER_INFO_DEFINED

// CONSTS AND ENUMS
//

// UserCounterType
//
// These enumerations describe how the counter works.
//
// MonotonicallyIncreasing	--	This describes a counter that will increment
//								by one each time some 'event' occurs.  An
//								example would be a counter that tracks the
//								number of memory allocations.  Each allocation
//								increments the number by one.
//
// MonotonicallyDecreasint	--	This describes a counter that will decrement
//								by one each time some 'event' occurs.  An
//								example would be a counter that tracks a limited
//								resource.  Each use of the resource decrements
//								the number by one.
//
// RandomIncreasing --			This describes a counter that will increase for
//								each 'event' that occurs, but by an undetermined
//								amount.  An example would be the total memory
//								allocated.  Each allocation would add it's size
//								to the counter, but each allocation being potentially
//								different, causes the counter to go up by a random
//								amount each time.
//
// RandomDecreasing --			This describes a coutner that will decrease for
//								each 'event' that occurs, but by an undetermined
//								amount.  An example would be a limited resource
//								that can be used in bunches.  Each use fo the
//								the resource would cause the number to descrease
//								by a random amount.
//
// Random --					This number can either go up, or go down.  An
//								example would be the total amount of available
//								memory, which can either go up (as memory is
//								free'd), or go down (as memory is allocated).
//
enum UserCounterType
{
	MonotonicallyIncreasing,
	MonotonicallyDecreasing,
	RandomIncreasing,
	RandomDecreasing,
	Random
};

// TYPEDEFS
//

typedef signed __int64	COUNTER, *PCOUNTER;

///////////////////////////////////////////////////////////////
// USERCOUNTERINFO
//
// This structure descibes a user defined counter so that
// IceCAP can use it during profiling runs.
//
// History:  9-21-98 BarryNo Created
//
///////////////////////////////////////////////////////////////
typedef struct _USERCOUNTERINFO
{
	char  szCounterFuncName[32];	// Name of the function
	enum UserCounterType	ct;				// Describes the type of number we will be collecting
	char szName[32];				// Name of user counter

} USERCOUNTERINFO, *PUSERCOUNTERINFO;

#endif  // USER_COUNTER_INFO_DEFINED

#ifdef __cplusplus
}
#endif

#endif // __ICECAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdipluspath.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   path.hpp
*
* Abstract:
*
*   Path related declarations
*
* Revision History:
*
*   12/06/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSPATH_H
#define _GDIPLUSPATH_H

class GraphicsPath : public GdiplusBase
{
public:
    friend class Graphics;
    friend class Region;
    friend class PathGradientBrush;
    friend class GraphicsPathIterator;
    friend class CustomLineCap;

    // Path constructors

    GraphicsPath(IN FillMode fillMode = FillModeAlternate)
    {
        nativePath = NULL;
        lastResult = DllExports::GdipCreatePath(fillMode, &nativePath);
    }

    GraphicsPath(IN const PointF* points,
                 IN const BYTE* types,
                 IN INT count,
                 IN FillMode fillMode = FillModeAlternate)
    {
        nativePath = NULL;
        lastResult = DllExports::GdipCreatePath2(points,
                                                 types,
                                                 count,
                                                 fillMode,
                                                 &nativePath);
    }

    GraphicsPath(IN const Point* points,
                 IN const BYTE* types,
                 IN INT count,
                 IN FillMode fillMode = FillModeAlternate)
    {
        nativePath = NULL;
        lastResult = DllExports::GdipCreatePath2I(points,
                                                  types,
                                                  count,
                                                  fillMode,
                                                  &nativePath);
    }

    ~GraphicsPath()
    {
        DllExports::GdipDeletePath(nativePath);
    }

    /**
     * Make a copy of the current path object
     */
    GraphicsPath* Clone() const
    {
        GpPath *clonepath = NULL;

        SetStatus(DllExports::GdipClonePath(nativePath, &clonepath));

        return new GraphicsPath(clonepath);
    }

    /**
     * Reset the path object to empty (and fill mode to FillModeAlternate)
     */
    Status Reset()
    {
        return SetStatus(DllExports::GdipResetPath(nativePath));
    }

    /**
     * Get path fill mode information
     */
    FillMode GetFillMode() const
    {
        FillMode fillmode = FillModeAlternate;

        SetStatus(DllExports::GdipGetPathFillMode(nativePath, &fillmode));

        return fillmode;
    }

    /**
     * Set path fill mode information
     */
    Status SetFillMode(IN FillMode fillmode)
    {
        return SetStatus(DllExports::GdipSetPathFillMode(nativePath, fillmode));
    }

    /**
     * Set/get path data
     */
    Status GetPathData(OUT PathData* pathData) const
    {
        if (pathData == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        INT count = GetPointCount();
        
        if ((count <= 0) || (pathData->Count>0 && pathData->Count<count))
        {
            pathData->Count = 0;
            if (pathData->Points)
            {
                delete pathData->Points;
                pathData->Points = NULL;
            }

            if (pathData->Types) 
            {
                delete pathData->Types;
                pathData->Types = NULL;
            }

            if (count <= 0)
            {
                return lastResult;
            }
        }

        if (pathData->Count == 0) 
        {
            pathData->Points = new PointF[count];
            if (pathData->Points == NULL) 
            {
                return SetStatus(OutOfMemory);
            
            }
            pathData->Types = new byte[count];
            if (pathData->Types == NULL) 
            {
                delete pathData->Points;
                pathData->Points = NULL;

                return SetStatus(OutOfMemory);
            }
            pathData->Count = count;
        }

        return SetStatus(DllExports::GdipGetPathData(nativePath, pathData));
    }

    /**
     * Start/end a subpath
     */
    Status StartFigure()
    {
        return SetStatus(DllExports::GdipStartPathFigure(nativePath));
    }

    Status CloseFigure()
    {
        return SetStatus(DllExports::GdipClosePathFigure(nativePath));
    }

    Status CloseAllFigures()
    {
        return SetStatus(DllExports::GdipClosePathFigures(nativePath));
    }

    Status SetMarker()
    {
        return SetStatus(DllExports::GdipSetPathMarker(nativePath));
    }

    Status ClearMarkers()
    {
        return SetStatus(DllExports::GdipClearPathMarkers(nativePath));
    }

    Status Reverse()
    {
        return SetStatus(DllExports::GdipReversePath(nativePath));
    }

    Status GetLastPoint(OUT PointF* lastPoint) const
    {
        return SetStatus(DllExports::GdipGetPathLastPoint(nativePath, lastPoint));
    }

    /**
     * Add lines to the path object
     */
    // float version
    Status AddLine(IN const PointF& pt1, 
                   IN const PointF& pt2)
    {
        return AddLine(pt1.X, pt1.Y, pt2.X, pt2.Y);
    }

    Status AddLine(IN REAL x1,
                   IN REAL y1, 
                   IN REAL x2, 
                   IN REAL y2)
    {
        return SetStatus(DllExports::GdipAddPathLine(nativePath, x1, y1, x2, y2));
    }

    Status AddLines(IN const PointF* points, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathLine2(nativePath, points, count));
    }

    // integer version
    Status AddLine(IN const Point& pt1, 
                   IN const Point& pt2)
    {
        return AddLine(pt1.X,
                       pt1.Y,
                       pt2.X,
                       pt2.Y);
    }

    Status AddLine(IN INT x1, 
                   IN INT y1, 
                   IN INT x2, 
                   IN INT y2)
    {
        return SetStatus(DllExports::GdipAddPathLineI(nativePath,
                                                     x1,
                                                     y1,
                                                     x2,
                                                     y2));
    }

    Status AddLines(IN const Point* points, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathLine2I(nativePath,
                                                       points,
                                                       count));
    }

    /**
     * Add an arc to the path object
     */
    // float version
    Status AddArc(IN const RectF& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddArc(rect.X, rect.Y, rect.Width, rect.Height,
                      startAngle, sweepAngle);
    }

    Status AddArc(IN REAL x, 
                  IN REAL y, 
                  IN REAL width, 
                  IN REAL height,
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathArc(nativePath, x, y, width, height,
                                      startAngle, sweepAngle));
    }

    // integer version
    Status AddArc(IN const Rect& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddArc(rect.X, rect.Y, rect.Width, rect.Height,
                      startAngle, sweepAngle);
    }

    Status AddArc(IN INT x, 
                  IN INT y, 
                  IN INT width, 
                  IN INT height,
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathArcI(nativePath,
                                                    x,
                                                    y,
                                                    width,
                                                    height,
                                                    startAngle,
                                                    sweepAngle));
    }

    /**
     * Add Bezier curves to the path object
     */
    // float version
    Status AddBezier(IN const PointF& pt1, 
                     IN const PointF& pt2,
                     IN const PointF& pt3, 
                     IN const PointF& pt4)
    {
        return AddBezier(pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X,
                         pt4.Y);
    }

    Status AddBezier(IN REAL x1, 
                     IN REAL y1, 
                     IN REAL x2, 
                     IN REAL y2,
                     IN REAL x3, 
                     IN REAL y3, 
                     IN REAL x4, 
                     IN REAL y4)
    {
        return SetStatus(DllExports::GdipAddPathBezier(nativePath, x1, y1, x2, y2,
                                     x3, y3, x4, y4));
    }

    Status AddBeziers(IN const PointF* points, 
                      IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathBeziers(nativePath, points, count));
    }

    // integer version
    Status AddBezier(IN const Point& pt1, 
                     IN const Point& pt2,
                     IN const Point& pt3, 
                     IN const Point& pt4)
    {
       return AddBezier(pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X,
                        pt4.Y);
    }

    Status AddBezier(IN INT x1, 
                     IN INT y1, 
                     IN INT x2, 
                     IN INT y2,
                     IN INT x3,
                     IN INT y3, 
                     IN INT x4, 
                     IN INT y4)
    {
       return SetStatus(DllExports::GdipAddPathBezierI(nativePath,
                                                      x1,
                                                      y1,
                                                      x2,
                                                      y2,
                                                      x3,
                                                      y3,
                                                      x4,
                                                      y4));
    }

    Status AddBeziers(IN const Point* points,
                      IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathBeziersI(nativePath,
                                                        points,
                                                        count));
    }

    // float version
    Status AddCurve(IN const PointF* points, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathCurve(nativePath,
                                                      points,
                                                      count));
    }

    Status AddCurve(IN const PointF* points, 
                    IN INT count,
                    IN REAL tension)
    {
        return SetStatus(DllExports::GdipAddPathCurve2(nativePath,
                                                       points,
                                                       count,
                                                       tension));
    }

    Status AddCurve(IN const PointF* points, 
                    IN INT count, 
                    IN INT offset,
                    IN INT numberOfSegments, 
                    IN REAL tension)
    {
        return SetStatus(DllExports::GdipAddPathCurve3(nativePath,
                                                       points,
                                                       count,
                                                       offset,
                                                       numberOfSegments,
                                                       tension));
    }

    // integer version
    Status AddCurve(IN const Point* points, 
                    IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathCurveI(nativePath,
                                                     points,
                                                     count));
    }

    Status AddCurve(IN const Point* points, 
                    IN INT count, 
                    IN REAL tension)
    {
       return SetStatus(DllExports::GdipAddPathCurve2I(nativePath,
                                                      points,
                                                      count,
                                                      tension));
    }

    Status AddCurve(IN const Point* points, 
                    IN INT count, 
                    IN INT offset,
                    IN INT numberOfSegments, 
                    IN REAL tension)
    {
       return SetStatus(DllExports::GdipAddPathCurve3I(nativePath,
                                                      points,
                                                      count,
                                                      offset,
                                                      numberOfSegments,
                                                      tension));
    }

    // float version
    Status AddClosedCurve(IN const PointF* points, 
                          IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathClosedCurve(nativePath,
                                                            points,
                                                            count));
    }

    Status AddClosedCurve(IN const PointF* points, 
                          IN INT count, 
                          IN REAL tension)
    {
        return SetStatus(DllExports::GdipAddPathClosedCurve2(nativePath,
                                                             points,
                                                             count,
                                                             tension));
    }

    // integer version
    Status AddClosedCurve(IN const Point* points, 
                          IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathClosedCurveI(nativePath,
                                                            points,
                                                            count));
    }


    Status AddClosedCurve(IN const Point* points, 
                          IN INT count,
                          IN REAL tension)
    {
       return SetStatus(DllExports::GdipAddPathClosedCurve2I(nativePath,
                                                             points,
                                                             count,
                                                             tension));
    }


    /**
     * Add closed shapes to the path object
     */

    // float version
    Status AddRectangle(IN const RectF& rect)
    {
        return SetStatus(DllExports::GdipAddPathRectangle(nativePath,
                                                          rect.X,
                                                          rect.Y,
                                                          rect.Width,
                                                          rect.Height));
    }

    Status AddRectangles(IN const RectF* rects, 
                         IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathRectangles(nativePath,
                                                           rects,
                                                           count));
    }

    // integer version
    Status AddRectangle(IN const Rect& rect)
    {
        return SetStatus(DllExports::GdipAddPathRectangleI(nativePath,
                                                          rect.X,
                                                          rect.Y,
                                                          rect.Width,
                                                          rect.Height));
    }

    Status AddRectangles(IN const Rect* rects, INT count)
    {
        return SetStatus(DllExports::GdipAddPathRectanglesI(nativePath,
                                                           rects,
                                                           count));
    }

    // float version
    Status AddEllipse(IN const RectF& rect)
    {
        return AddEllipse(rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status AddEllipse(IN REAL x, 
                      IN REAL y, 
                      IN REAL width, 
                      IN REAL height)
    {
        return SetStatus(DllExports::GdipAddPathEllipse(nativePath,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    // integer version
    Status AddEllipse(IN const Rect& rect)
    {
        return AddEllipse(rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status AddEllipse(IN INT x, 
                      IN INT y, 
                      IN INT width, 
                      IN INT height)
    {
        return SetStatus(DllExports::GdipAddPathEllipseI(nativePath,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    // float version
    Status AddPie(IN const RectF& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddPie(rect.X, rect.Y, rect.Width, rect.Height, startAngle,
                      sweepAngle);
    }

    Status AddPie(IN REAL x, 
                  IN REAL y, 
                  IN REAL width, 
                  IN REAL height, 
                  IN REAL startAngle,
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathPie(nativePath, x, y, width, height,
                                      startAngle, sweepAngle));
    }

    // integer version
    Status AddPie(IN const Rect& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddPie(rect.X,
                      rect.Y,
                      rect.Width,
                      rect.Height,
                      startAngle,
                      sweepAngle);
    }

    Status AddPie(IN INT x, 
                  IN INT y, 
                  IN INT width, 
                  IN INT height, 
                  IN REAL startAngle,
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathPieI(nativePath,
                                                    x,
                                                    y,
                                                    width,
                                                    height,
                                                    startAngle,
                                                    sweepAngle));
    }

    // float version
    Status AddPolygon(IN const PointF* points, 
                      IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathPolygon(nativePath, points, count));
    }

    // integer version
    Status AddPolygon(IN const Point* points, 
                      IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathPolygonI(nativePath, points, count));
    }

    Status AddPath(IN const GraphicsPath* addingPath, 
                   IN BOOL connect)
    {
        GpPath* nativePath2 = NULL;
        if(addingPath)
            nativePath2 = addingPath->nativePath;

        return SetStatus(DllExports::GdipAddPathPath(nativePath, nativePath2, connect));
    }

    // AddString point version

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // In world units
        IN const PointF        &origin,
        IN const StringFormat  *format
    )
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipAddPathString(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &rect,
            format ? format->nativeFormat : NULL
        ));
    }

    // AddString rectangle version

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // In world units
        IN const RectF         &layoutRect,
        IN const StringFormat  *format
    )
    {
        return SetStatus(DllExports::GdipAddPathString(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &layoutRect,
            format ? format->nativeFormat : NULL
        ));
    }

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // In world units
        IN const Point         &origin,
        IN const StringFormat  *format
    )
    {
        Rect rect(origin.X, origin.Y, 0, 0);

        return SetStatus(DllExports::GdipAddPathStringI(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &rect,
            format ? format->nativeFormat : NULL
        ));
    }

    // AddString rectangle version

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // In world units
        IN const Rect          &layoutRect,
        IN const StringFormat  *format
    )
    {
        return SetStatus(DllExports::GdipAddPathStringI(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &layoutRect,
            format ? format->nativeFormat : NULL
        ));
    }
    
    /**
     * Transforms the path object
     */
    Status Transform(IN const Matrix* matrix)
    {
        if(matrix)
            return SetStatus(DllExports::GdipTransformPath(nativePath, matrix->nativeMatrix));
        else
            return Ok;  // No need to transform.
    }

    /**
     * Get the bounds of the path object with the given transform.
     * This is not always the tightest bounds.
     *
     * Defined in GdiplusGraphics.h.
     */
    Status GetBounds(OUT RectF* bounds, 
                     IN const Matrix* matrix = NULL, 
                     IN const Pen* pen = NULL) const;

    // integer version (defined in GdiplusGraphics.h)
    Status GetBounds(OUT Rect* bounds,
                     IN const Matrix* matrix = NULL, 
                     IN const Pen* pen = NULL) const;

    /**
     * Flatten the path object
     * Once this is called, the resultant path is made of line segments and
     * the original path information is lost.
     * When matrix = NULL, the identity matrix is assumed.
     */
    Status Flatten(IN const Matrix* matrix = NULL, 
                   IN REAL flatness = 0.25f)
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
            nativeMatrix = matrix->nativeMatrix;

        return SetStatus(DllExports::GdipFlattenPath(nativePath, nativeMatrix, flatness));
    }

    /**
     * Widen the path object
     * When removeSelfIntersects is TRUE, this returns the widened path
     * without self intersections.
     * When it is FALSE, it returns the widened path with selfintersections.
     * The latter is faster and is usually safficient for filling.
     */
    Status Widen(IN const Pen* pen, 
                 IN const Matrix* matrix = NULL,
                 IN BOOL removeSelfIntersects = TRUE)
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
            nativeMatrix = matrix->nativeMatrix;

        return SetStatus(DllExports::GdipWidenPathWithMinimumResolutions(nativePath, pen->nativePen,
            0, 0, nativeMatrix, removeSelfIntersects));
    }

    /**
     * Widen the path object
     * This is equivalent to Widen() method except that
     * The widths of the widened path are larger than the given
     * minimum resolutions in x and y coordinates after the transform.
     * This is usefull when widening a path with the limited device resolutions.
     */

    Status Widen(IN const Pen* pen, 
                 IN REAL minXres, 
                 IN REAL minYres, 
                 IN const Matrix* matrix = NULL,
                 IN BOOL removeSelfIntersects = TRUE)
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
            nativeMatrix = matrix->nativeMatrix;

        return SetStatus(DllExports::GdipWidenPathWithMinimumResolutions(nativePath, pen->nativePen,
            minXres, minYres, nativeMatrix, removeSelfIntersects));
    }

    /**
     * Warp the path object
     * Once this is called, the resultant path is made of line segments and
     * the original path information is lost.
     * When matrix = NULL, the identity matrix is assumed.
     */
    Status Warp(IN const PointF* destPoints, 
                IN INT count,
                IN const RectF& srcRect, 
                IN const Matrix* matrix = NULL,
                IN WarpMode warpMode = WarpModePerspective,
                IN REAL flatness = 0.25f)
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
            nativeMatrix = matrix->nativeMatrix;

        return SetStatus(DllExports::GdipWarpPath(
                                        nativePath,
                                        nativeMatrix,
                                        destPoints,
                                        count,
                                        srcRect.X,
                                        srcRect.Y,
                                        srcRect.Width,
                                        srcRect.Height,
                                        warpMode,
                                        flatness));
    }

    /**
     * Return the number of points in the current path
     */
    INT GetPointCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetPointCount(nativePath, &count));

        return count;
    }

    /**
     * Return the path point type information
     */
    Status GetPathTypes(OUT BYTE* types, 
                        IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathTypes(nativePath, types, count));
    }

    /**
     * Return the path point coordinate information
     * @notes Should there be PathData that contains types[] and points[]
     *        for get & set purposes.
     */
    Status GetPathPoints(OUT PointF* points, 
                         IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathPoints(nativePath, points, count));
    }

    // integer version
    Status GetPathPoints(OUT Point* points, 
                         IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathPointsI(nativePath, points, count));
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

    /**
     * Hit testing operations
     *
     * inline implementation is in gdiplusgraphics.h.
     */

    BOOL IsVisible(IN const PointF& point, 
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(point.X, point.Y, g);
    }
    
    BOOL IsVisible(IN REAL x, 
                   IN REAL y, 
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN const Point& point,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(point.X, point.Y, g);
    }

    BOOL IsVisible(IN INT x, 
                   IN INT y, 
                   IN const Graphics* g = NULL) const;
    
    BOOL IsOutlineVisible(IN const PointF& point,
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const
    {
        return IsOutlineVisible(point.X, point.Y, pen, g);
    }

    BOOL IsOutlineVisible(IN REAL x, 
                          IN REAL y, 
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const;

    BOOL IsOutlineVisible(IN const Point& point,
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const
    {
        return IsOutlineVisible(point.X, point.Y, pen, g);
    }
    
    BOOL IsOutlineVisible(IN INT x, 
                          IN INT y, 
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const;

protected:
    GraphicsPath(const GraphicsPath& path)
    {
        path;
        SetStatus(NotImplemented);
        SetNativePath(NULL);
    }

    GraphicsPath& operator=(const GraphicsPath& path)
    {
        path;
        SetStatus(NotImplemented);
        return *this;
    }

    GraphicsPath(GpPath* nativePath)
    {
        lastResult = Ok;
        SetNativePath(nativePath);
    }

    VOID SetNativePath(GpPath *nativePath)
    {
        this->nativePath = nativePath;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpPath* nativePath;
    mutable Status lastResult;
};


//--------------------------------------------------------------------------
// GraphisPathIterator class
//--------------------------------------------------------------------------

class GraphicsPathIterator : public GdiplusBase
{
public:

    GraphicsPathIterator(IN const GraphicsPath* path)
    {
        GpPath* nativePath = NULL;
        if(path)
            nativePath = path->nativePath;

        GpPathIterator *iter = NULL;
        lastResult = DllExports::GdipCreatePathIter(&iter, nativePath);
        SetNativeIterator(iter);
    }

    ~GraphicsPathIterator()
    {
        DllExports::GdipDeletePathIter(nativeIterator);
    }


    INT NextSubpath(OUT INT* startIndex,
                    OUT INT* endIndex,
                    OUT BOOL* isClosed)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterNextSubpath(nativeIterator,
            &resultCount, startIndex, endIndex, isClosed));

        return resultCount;
    }


    INT NextSubpath(IN const GraphicsPath* path, 
                    OUT BOOL* isClosed)
    {
        GpPath* nativePath = NULL;

        INT resultCount;

        if(path)
            nativePath= path->nativePath;

        SetStatus(DllExports::GdipPathIterNextSubpathPath(nativeIterator,
            &resultCount, nativePath, isClosed));

        return resultCount;
    }

    INT NextPathType(OUT BYTE* pathType, 
                     OUT INT* startIndex, 
                     OUT INT* endIndex)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterNextPathType(nativeIterator,
            &resultCount, pathType, startIndex, endIndex));

        return resultCount;
    }

    INT NextMarker(OUT INT* startIndex, 
                   OUT INT* endIndex)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterNextMarker(nativeIterator,
            &resultCount, startIndex, endIndex));

        return resultCount;
    }


    INT NextMarker(IN const GraphicsPath* path)
    {
        GpPath* nativePath = NULL;

        INT resultCount;

        if(path)
            nativePath= path->nativePath;

        SetStatus(DllExports::GdipPathIterNextMarkerPath(nativeIterator,
            &resultCount, nativePath));

        return resultCount;
    }

    INT GetCount() const
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterGetCount(nativeIterator, &resultCount));

        return resultCount;
    }

    INT GetSubpathCount() const
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterGetSubpathCount(nativeIterator, &resultCount));

        return resultCount;
    }

    BOOL HasCurve() const
    {
        BOOL hasCurve;

        SetStatus(DllExports::GdipPathIterHasCurve(nativeIterator, &hasCurve));

        return hasCurve;
    }

    VOID Rewind()
    {
        SetStatus(DllExports::GdipPathIterRewind(nativeIterator));
    }

    INT Enumerate(OUT PointF *points,
                  OUT BYTE *types, 
                  IN INT count)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterEnumerate(nativeIterator,
            &resultCount, points, types, count));

        return resultCount;
    }

    INT CopyData(OUT PointF* points, 
                 OUT BYTE* types,
                 IN INT startIndex, 
                 IN INT endIndex)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterCopyData(nativeIterator,
            &resultCount, points, types, startIndex, endIndex));

        return resultCount;
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

protected:
    VOID SetNativeIterator(GpPathIterator *nativeIterator)
    {
        this->nativeIterator = nativeIterator;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpPathIterator* nativeIterator;
    mutable Status lastResult;
};


//--------------------------------------------------------------------------
// Represent polygon gradient brush object
//--------------------------------------------------------------------------

class PathGradientBrush : public Brush
{
public:
    friend class Pen;

    PathGradientBrush(
        IN const PointF* points,
        IN INT count,
        IN WrapMode wrapMode = WrapModeClamp)
    {
        GpPathGradient *brush = NULL;

        lastResult = DllExports::GdipCreatePathGradient(
                                        points, count,
                                        wrapMode, &brush);
        SetNativeBrush(brush);
    }

    PathGradientBrush(
        IN const Point* points,
        IN INT count,
        IN WrapMode wrapMode = WrapModeClamp)
    {
        GpPathGradient *brush = NULL;

        lastResult = DllExports::GdipCreatePathGradientI(
                                        points, count,
                                        wrapMode, &brush);

        SetNativeBrush(brush);
    }

    PathGradientBrush(
        IN const GraphicsPath* path
        )
    {
        GpPathGradient *brush = NULL;

        lastResult = DllExports::GdipCreatePathGradientFromPath(
                                        path->nativePath, &brush);
        SetNativeBrush(brush);
    }

    // Get/set colors

    Status GetCenterColor(OUT Color* color) const
    {
        ARGB argb;
        
        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }

        SetStatus(DllExports::GdipGetPathGradientCenterColor(
                       (GpPathGradient*) nativeBrush, &argb));

        color->SetValue(argb);

        return lastResult;
    }

    Status SetCenterColor(IN const Color& color)
    {
        SetStatus(DllExports::GdipSetPathGradientCenterColor(
                       (GpPathGradient*) nativeBrush,
                       color.GetValue()));

        return lastResult;
    }

    INT GetPointCount() const
    {
        INT count;

        SetStatus(DllExports::GdipGetPathGradientPointCount(
                       (GpPathGradient*) nativeBrush, &count));

        return count;
    }

    INT GetSurroundColorCount() const
    {
        INT count;

        SetStatus(DllExports::GdipGetPathGradientSurroundColorCount(
                       (GpPathGradient*) nativeBrush, &count));

        return count;
    }

    Status GetSurroundColors(OUT Color* colors, 
                             IN OUT INT* count) const
    {
        if(colors == NULL || count == NULL)
        {
            return SetStatus(InvalidParameter);
        }

        INT count1;
        
        SetStatus(DllExports::GdipGetPathGradientSurroundColorCount(
                        (GpPathGradient*) nativeBrush, &count1));

        if(lastResult != Ok)
            return lastResult;

        if((*count < count1) || (count1 <= 0))
            return SetStatus(InsufficientBuffer);

        ARGB* argbs = (ARGB*) new ARGB[count1];
        if(argbs == NULL)
            return SetStatus(OutOfMemory);

        SetStatus(DllExports::GdipGetPathGradientSurroundColorsWithCount(
                    (GpPathGradient*)nativeBrush, argbs, &count1));

        if(lastResult == Ok)
        {
            for(INT i = 0; i < count1; i++)
            {
                colors[i].SetValue(argbs[i]);
            }        
            *count = count1;
        }

        delete [] argbs;
        return lastResult;
    }

    Status SetSurroundColors(IN const Color* colors, 
                             IN OUT INT* count)
    {
        if(colors == NULL || count == NULL)
        {
            return SetStatus(InvalidParameter);
        }

        INT count1 = GetPointCount();

        if((*count > count1) || (count1 <= 0))
            return SetStatus(InvalidParameter);

        count1 = *count;

        ARGB* argbs = (ARGB*) new ARGB[count1];
        if(argbs == NULL)
            return SetStatus(OutOfMemory);

        for(INT i = 0; i < count1; i++)
        {
            argbs[i] = colors[i].GetValue();
        }

        SetStatus(DllExports::GdipSetPathGradientSurroundColorsWithCount(
                    (GpPathGradient*)nativeBrush, argbs, &count1));

        if(lastResult == Ok)
            *count = count1;

        delete [] argbs;

        return lastResult;
    }

    Status GetGraphicsPath(OUT GraphicsPath* path) const
    {
        if(path == NULL)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipGetPathGradientPath(
                    (GpPathGradient*)nativeBrush, path->nativePath));
    }

    Status SetGraphicsPath(IN const GraphicsPath* path)
    {
        if(path == NULL)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipSetPathGradientPath(
                    (GpPathGradient*)nativeBrush, path->nativePath));
    }

    Status GetCenterPoint(OUT PointF* point) const
    {
        return SetStatus(DllExports::GdipGetPathGradientCenterPoint(
                                (GpPathGradient*)nativeBrush,
                                point));
    }


    Status GetCenterPoint(OUT Point* point) const
    {
        return SetStatus(DllExports::GdipGetPathGradientCenterPointI(
                                (GpPathGradient*)nativeBrush,
                                point));
    }

    Status SetCenterPoint(IN const PointF& point)
    {
        return SetStatus(DllExports::GdipSetPathGradientCenterPoint(
                                (GpPathGradient*)nativeBrush,
                                &point));
    }

    Status SetCenterPoint(IN const Point& point)
    {
        return SetStatus(DllExports::GdipSetPathGradientCenterPointI(
                                (GpPathGradient*)nativeBrush,
                                &point));
    }

    Status GetRectangle(OUT RectF* rect) const
    {
        return SetStatus(DllExports::GdipGetPathGradientRect(
                            (GpPathGradient*)nativeBrush, rect));
    }

    Status GetRectangle(OUT Rect* rect) const
    {
        return SetStatus(DllExports::GdipGetPathGradientRectI(
                            (GpPathGradient*)nativeBrush, rect));
    }

    // Gamma correction.

    Status SetGammaCorrection(IN BOOL useGammaCorrection)
    {
        return SetStatus(DllExports::GdipSetPathGradientGammaCorrection(
            (GpPathGradient*)nativeBrush, useGammaCorrection));
    }

    BOOL GetGammaCorrection() const
    {
        BOOL useGammaCorrection;

        SetStatus(DllExports::GdipGetPathGradientGammaCorrection(
            (GpPathGradient*)nativeBrush, &useGammaCorrection));

        return useGammaCorrection;
    }

    INT GetBlendCount() const
    {
       INT count = 0;

       SetStatus(DllExports::GdipGetPathGradientBlendCount(
                           (GpPathGradient*) nativeBrush, &count));

       return count;
    }

    Status GetBlend(OUT REAL* blendFactors,
                    OUT REAL* blendPositions,
                    IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathGradientBlend(
                            (GpPathGradient*)nativeBrush,
                            blendFactors, blendPositions, count));
    }

    Status SetBlend(IN REAL* blendFactors, 
                    IN REAL* blendPositions, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipSetPathGradientBlend(
                            (GpPathGradient*)nativeBrush,
                            blendFactors, blendPositions, count));
    }

    INT GetInterpolationColorCount() const
    {
       INT count = 0;

       SetStatus(DllExports::GdipGetPathGradientPresetBlendCount(
                        (GpPathGradient*) nativeBrush, &count));

       return count;
    }

    Status SetInterpolationColors(IN const Color* presetColors,
                                  IN REAL* blendPositions, 
                                  IN INT count)
    {
        if ((count <= 0) || !presetColors) 
        {
            return SetStatus(InvalidParameter);
        }

        ARGB* argbs = (ARGB*) new ARGB[count];
        if(argbs)
        {
            for(INT i = 0; i < count; i++)
            {
                argbs[i] = presetColors[i].GetValue();
            }

            Status status = SetStatus(DllExports::GdipSetPathGradientPresetBlend(
                                    (GpPathGradient*) nativeBrush,
                                    argbs,
                                    blendPositions,
                                    count));
            delete[] argbs;
            return status;
        }
        else
        {
            return SetStatus(OutOfMemory);
        }
    }

    Status GetInterpolationColors(OUT Color* presetColors,
                                  OUT REAL* blendPositions, 
                                  IN INT count) const
    {
        if ((count <= 0) || !presetColors) 
        {
            return SetStatus(InvalidParameter);
        }

        ARGB* argbs = (ARGB*) new ARGB[count];
        
        if (!argbs)
        {
            return SetStatus(OutOfMemory);
        }

        GpStatus status = SetStatus(DllExports::GdipGetPathGradientPresetBlend(
                                (GpPathGradient*)nativeBrush,
                                argbs,
                                blendPositions,
                                count));
        
        for(INT i = 0; i < count; i++)
        {
            presetColors[i] = Color(argbs[i]);
        }
        delete [] argbs;
        
        return status;
    }

    Status SetBlendBellShape(IN REAL focus, 
                             IN REAL scale = 1.0)
    {
        return SetStatus(DllExports::GdipSetPathGradientSigmaBlend(
                            (GpPathGradient*)nativeBrush, focus, scale));
    }

    #ifdef DCR_USE_NEW_145135
    Status SetBlendTriangularShape(
        IN REAL focus,
        IN REAL scale = 1.0
    )
    #else
    Status SetBlendTrianglarShape(IN REAL focus,
                                  IN REAL scale = 1.0)
    #endif                              
    {
        return SetStatus(DllExports::GdipSetPathGradientLinearBlend(
                            (GpPathGradient*)nativeBrush, focus, scale));
    }

    /**
     * Get/set brush transform
     */
    Status GetTransform(OUT Matrix *matrix) const
    {
        return SetStatus(DllExports::GdipGetPathGradientTransform(
                            (GpPathGradient*) nativeBrush, matrix->nativeMatrix));
    }

    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetPathGradientTransform(
                            (GpPathGradient*) nativeBrush, matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetPathGradientTransform((GpPathGradient*)nativeBrush));
    }

    Status MultiplyTransform(IN Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyPathGradientTransform((GpPathGradient*)nativeBrush,
                                                                matrix->nativeMatrix,
                                                                order));
    }

    Status TranslateTransform(IN REAL dx, 
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslatePathGradientTransform((GpPathGradient*)nativeBrush,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScalePathGradientTransform((GpPathGradient*)nativeBrush,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotatePathGradientTransform((GpPathGradient*)nativeBrush,
                                                              angle, order));
    }

    /**
     * Get/set brush focus scales
     */
    Status GetFocusScales(OUT REAL* xScale, 
                          OUT REAL* yScale) const
    {
        return SetStatus(DllExports::GdipGetPathGradientFocusScales(
                            (GpPathGradient*) nativeBrush, xScale, yScale));
    }

    Status SetFocusScales(IN REAL xScale,
                          IN REAL yScale)
    {
        return SetStatus(DllExports::GdipSetPathGradientFocusScales(
                            (GpPathGradient*) nativeBrush, xScale, yScale));
    }

    /**
     * Get/set brush wrapping mode
     */
    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetPathGradientWrapMode(
                     (GpPathGradient*) nativeBrush, &wrapMode));

        return wrapMode;
    }

    Status SetWrapMode(IN WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetPathGradientWrapMode(
                            (GpPathGradient*) nativeBrush, wrapMode));
    }

protected:

    PathGradientBrush()
    {
    }
};


#endif // !_GRAPHICSPATH_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplustypes.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusTypes.hpp
*
* Abstract:
*
*   Basic types used by GDI+
*
* Notes:
*
*   Only simple, generic types should go here. Imaging.dll depends on this file,
*   so it doesn't want to pick up a whole lot of unrelated
*   stuff. If your module needs some new, complicated types, give it its
*   own file.
*
* Revision History:
*
*   12/01/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSTYPES_H
#define _GDIPLUSTYPES_H
    
//--------------------------------------------------------------------------
// LIB version initialization functions
//--------------------------------------------------------------------------

typedef VOID (__cdecl *DEBUGEVENTFUNCTION)(INT level, CHAR *message);

extern "C" BOOL __stdcall InitializeGdiplus(DEBUGEVENTFUNCTION);
extern "C" VOID __stdcall UninitializeGdiplus();

//--------------------------------------------------------------------------
// Callback functions
//--------------------------------------------------------------------------

extern "C" {
typedef BOOL (CALLBACK * ImageAbort)(VOID *);
typedef ImageAbort DrawImageAbort;
typedef ImageAbort GetThumbnailImageAbort;
}

// Callback for EnumerateMetafile methods.  The parameters are:

//      recordType      WMF, EMF, or EMF+ record type
//      flags           (always 0 for WMF/EMF records)
//      dataSize        size of the record data (in bytes), or 0 if no data
//      data            pointer to the record data, or NULL if no data
//      callbackData    pointer to callbackData, if any

// This method can then call Metafile::PlayRecord to play the 
// record that was just enumerated.  If this method  returns 
// FALSE, the enumeration process is aborted.  Otherwise, it continues.

extern "C" {
typedef BOOL (CALLBACK * EnumerateMetafileProc)(EmfPlusRecordType,UINT,UINT,const BYTE*,VOID*);
}

//--------------------------------------------------------------------------
// Primitive data types
//
// NOTE:
//  Types already defined in standard header files:
//      INT32
//      UINT32
//      INT64
//      UINT64
//
//  Avoid using the following types:
//      LONG - use INT
//      ULONG - use UINT
//      DWORD - use UINT32
//--------------------------------------------------------------------------

typedef short INT16;                // signed 16-bit integer
typedef unsigned short UINT16;      // unsigned 16-bit integer
typedef float REAL;                 // double precision floating-point number

#define REAL_MAX            FLT_MAX
#define REAL_MIN            FLT_MIN
#define REAL_TOLERANCE     (FLT_MIN * 100)
#define REAL_EPSILON        1.192092896e-07F        /* FLT_EPSILON */

//--------------------------------------------------------------------------
// Forward declarations of various internal classes
//--------------------------------------------------------------------------

class Size;
class SizeF;
class Point;
class PointF;
class Rect;
class RectF;

//--------------------------------------------------------------------------
// Return values from any GDI+ API
//--------------------------------------------------------------------------

enum Status
{
    Ok = 0,
    GenericError = 1,
    InvalidParameter = 2,
    OutOfMemory = 3,
    ObjectBusy = 4,
    InsufficientBuffer = 5,
    NotImplemented = 6,
    Win32Error = 7,
    WrongState = 8,
    Aborted = 9,
#ifdef DCR_USE_NEW_135429    
    FileNotFound = 10,
    ValueOverflow = 11,
    AccessDenied = 12,
    UnknownImageFormat = 13,
    FontFamilyNotFound = 14,
    FontStyleNotFound = 15,
    NotTrueTypeFont = 16
#else
    NotFound = 10,
    ValueOverflow = 11
#endif    

};

//--------------------------------------------------------------------------
// Represents a dimension in a 2D coordinate system
//  (floating-point coordinates)
//--------------------------------------------------------------------------

class SizeF
{
public:

   // Default constructor
    SizeF()
    {
        Width = Height = 0.0f;
    }

    SizeF(IN const SizeF& size)
    {
        Width = size.Width;
        Height = size.Height;
    }

    SizeF(IN REAL width, 
          IN REAL height)
    {
        Width = width;
        Height = height;
    }

    SizeF operator+(IN const SizeF& sz) const
    {
        return SizeF(Width + sz.Width,
                     Height + sz.Height);
    }

    SizeF operator-(IN const SizeF& sz) const
    {
        return SizeF(Width - sz.Width,
                     Height - sz.Height);
    }

    BOOL Equals(IN const SizeF& sz) const
    {
        return (Width == sz.Width) && (Height == sz.Height);
    }

    BOOL Empty() const
    {    
        return (Width == 0.0f && Height == 0.0f);
    }

public:

    REAL Width;
    REAL Height;
};

//--------------------------------------------------------------------------
// Represents a dimension in a 2D coordinate system
//  (integer coordinates)
//--------------------------------------------------------------------------

class Size
{
public:

   // Default constructor
    Size()
    {
        Width = Height = 0;
    }

    Size(IN const Size& size)
    {
        Width = size.Width;
        Height = size.Height;
    }

    Size(IN INT width,
         IN INT height)
    {
        Width = width;
        Height = height;
    }

    Size operator+(IN const Size& sz) const
    {
        return Size(Width + sz.Width,
                    Height + sz.Height);
    }

    Size operator-(IN const Size& sz) const
    {
        return Size(Width - sz.Width,
                    Height - sz.Height);
    }

    BOOL Equals(IN const Size& sz) const
    {
        return (Width == sz.Width) && (Height == sz.Height);
    }

    BOOL Empty() const
    {    
        return (Width == 0 && Height == 0);
    }

public:

    INT Width;
    INT Height;
};

//--------------------------------------------------------------------------
// Represents a location in a 2D coordinate system
//  (floating-point coordinates)
//--------------------------------------------------------------------------

class PointF
{
public:
   PointF()
   {
       X = Y = 0.0f;
   }

   PointF(IN const PointF &point)
   {
       X = point.X;
       Y = point.Y;
   }

   PointF(IN const SizeF &size)
   {
       X = size.Width;
       Y = size.Height;
   }

   PointF(IN REAL x, 
          IN REAL y)
   {
       X = x;
       Y = y;
   }
   
   PointF operator+(IN const PointF& point) const
   {
       return PointF(X + point.X,
                     Y + point.Y);
   }

   PointF operator-(IN const PointF& point) const
   {
       return PointF(X - point.X,
                     Y - point.Y);
   }

   BOOL Equals(IN const PointF& point)
   {
       return (X == point.X) && (Y == point.Y);
   }

public:

    REAL X;
    REAL Y;
};

//--------------------------------------------------------------------------
// Represents a location in a 2D coordinate system
//  (integer coordinates)
//--------------------------------------------------------------------------

class Point
{
public:
   Point()
   {
       X = Y = 0;
   }

   Point(IN const Point &point)
   {
       X = point.X;
       Y = point.Y;
   }

   Point(IN const Size &size)
   {
       X = size.Width;
       Y = size.Height;
   }

   Point(IN INT x,
         IN INT y)
   {
       X = x;
       Y = y;
   }
   
   Point operator+(IN const Point& point) const
   {
       return Point(X + point.X,
                    Y + point.Y);
   }

   Point operator-(IN const Point& point) const
   {
       return Point(X - point.X,
                    Y - point.Y);
   }

   BOOL Equals(IN const Point& point)
   {
       return (X == point.X) && (Y == point.Y);
   }

public:

    INT X;
    INT Y;
};

//--------------------------------------------------------------------------
// Represents a rectangle in a 2D coordinate system
//  (floating-point coordinates)
//--------------------------------------------------------------------------

class RectF
{
public:

    // Default constructor

    RectF()
    {
        X = Y = Width = Height = 0.0f;
    }

    RectF(IN REAL x, 
          IN REAL y, 
          IN REAL width, 
          IN REAL height)
    {
        X = x;
        Y = y;
        Width = width;
        Height = height;
    }

    RectF(IN const PointF& location,
          IN const SizeF& size)
    {
        X = location.X;
        Y = location.Y;
        Width = size.Width;
        Height = size.Height;
    }

    RectF* Clone() const
    {
        return new RectF(X, Y, Width, Height);
    }

    VOID GetLocation(OUT PointF* point) const
    {
        point->X = X;
        point->Y = Y;
    }

    VOID GetSize(OUT SizeF* size) const
    {
        size->Width = Width;
        size->Height = Height;
    }

    VOID GetBounds(OUT RectF* rect) const
    {
        rect->X = X;
        rect->Y = Y;
        rect->Width = Width;
        rect->Height = Height;
    }

    // Return the left, top, right, and bottom
    // coordinates of the rectangle

    REAL GetLeft() const
    {
        return X;
    }

    REAL GetTop() const
    {
        return Y;
    }
    
    REAL GetRight() const
    {
        return X+Width;
    }

    REAL GetBottom() const
    {
        return Y+Height;
    }

    // Determine if the rectangle is empty
    BOOL IsEmptyArea() const
    {
        return (Width <= REAL_EPSILON) || (Height <= REAL_EPSILON);
    }
    
    BOOL Equals(IN const RectF & rect) const
    {
        return X == rect.X && 
               Y == rect.Y && 
               Width == rect.Width && 
               Height == rect.Height;
    }

    BOOL Contains(IN REAL x, 
                  IN REAL y) const
    {
        return x >= X && x < X+Width &&
               y >= Y && y < Y+Height;
    }

    BOOL Contains(IN const PointF& pt) const
    {
        return Contains(pt.X, pt.Y);
    }

    BOOL Contains(IN const RectF& rect) const
    {
        return (X <= rect.X) && (rect.GetRight() <= GetRight()) &&
               (Y <= rect.Y) && (rect.GetBottom() <= GetBottom()); 
    }
    
    VOID Inflate(IN REAL dx, 
                 IN REAL dy)
    {
        X -= dx;
        Y -= dy;
        Width += 2*dx;
        Height += 2*dy;
    }

    VOID Inflate(IN const PointF& point)
    {
        Inflate(point.X, point.Y);
    }
    
    // Intersect the current rect with the specified object

    BOOL Intersect(IN const RectF& rect)
    {
        return Intersect(*this, *this, rect);
    }

    // Intersect rect a and b and save the result into c
    // Notice that c may be the same object as a or b.

    static BOOL Intersect(OUT RectF& c,
                          IN const RectF& a, 
                          IN const RectF& b)
    {
        REAL right = min(a.GetRight(), b.GetRight());
        REAL bottom = min(a.GetBottom(), b.GetBottom());
        REAL left = max(a.GetLeft(), b.GetLeft());
        REAL top = max(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    // Determine if the specified rect intersects with the
    // current rect object.

    BOOL IntersectsWith(IN const RectF& rect) const 
    {
        return (GetLeft() < rect.GetRight() &&
                GetTop() < rect.GetTop() &&
                GetRight() > rect.GetLeft() &&
                GetBottom() > rect.GetTop());
    }

    static BOOL Union(OUT RectF& c, 
                      IN const RectF& a, 
                      IN const RectF& b)
    {
        REAL right = max(a.GetRight(), b.GetRight());
        REAL bottom = max(a.GetBottom(), b.GetBottom());
        REAL left = min(a.GetLeft(), b.GetLeft());
        REAL top = min(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    VOID Offset(IN const PointF& point)
    {
        Offset(point.X, point.Y);
    }

    VOID Offset(IN REAL dx, 
                IN REAL dy)
    {
        X += dx;
        Y += dy;
    }

public:

    REAL X;
    REAL Y;
    REAL Width;
    REAL Height;
};

//--------------------------------------------------------------------------
// Represents a rectangle in a 2D coordinate system
//  (integer coordinates)
//--------------------------------------------------------------------------

class Rect
{
public:

    // Default constructor

    Rect()
    {
        X = Y = Width = Height = 0;
    }

    Rect(IN INT x, 
         IN INT y, 
         IN INT width, 
         IN INT height)
    {
        X = x;
        Y = y;
        Width = width;
        Height = height;
    }

    Rect(IN const Point& location, 
         IN const Size& size)
    {
        X = location.X;
        Y = location.Y;
        Width = size.Width;
        Height = size.Height;
    }

    Rect* Clone() const
    {
        return new Rect(X, Y, Width, Height);
    }

    VOID GetLocation(OUT Point* point) const
    {
        point->X = X;
        point->Y = Y;
    }

    VOID GetSize(OUT Size* size) const
    {
        size->Width = Width;
        size->Height = Height;
    }

    VOID GetBounds(OUT Rect* rect) const
    {
        rect->X = X;
        rect->Y = Y;
        rect->Width = Width;
        rect->Height = Height;
    }

    // Return the left, top, right, and bottom
    // coordinates of the rectangle

    INT GetLeft() const
    {
        return X;
    }

    INT GetTop() const
    {
        return Y;
    }
    
    INT GetRight() const
    {
        return X+Width;
    }

    INT GetBottom() const
    {
        return Y+Height;
    }

    // Determine if the rectangle is empty
    BOOL IsEmptyArea() const
    {
        return (Width <= 0) || (Height <= 0);
    }

    BOOL Equals(IN const Rect & rect) const
    {
        return X == rect.X &&
               Y == rect.Y &&
               Width == rect.Width &&
               Height == rect.Height;
    }

    BOOL Contains(IN INT x, 
                  IN INT y) const
    {
        return x >= X && x < X+Width &&
               y >= Y && y < Y+Height;
    }

    BOOL Contains(IN const Point& pt) const 
    {
        return Contains(pt.X, pt.Y);
    }

    BOOL Contains(IN Rect& rect) const
    {
        return (X <= rect.X) && (rect.GetRight() <= GetRight()) &&
               (Y <= rect.Y) && (rect.GetBottom() <= GetBottom()); 
    }
    
    VOID Inflate(IN INT dx, 
                 IN INT dy)
    {
        X -= dx;
        Y -= dy;
        Width += 2*dx;
        Height += 2*dy;
    }

    VOID Inflate(IN const Point& point)
    {
        Inflate(point.X, point.Y);
    }
    
    // Intersect the current rect with the specified object

    BOOL Intersect(IN const Rect& rect)
    {
        return Intersect(*this, *this, rect);
    }

    // Intersect rect a and b and save the result into c
    // Notice that c may be the same object as a or b.

    static BOOL Intersect(OUT Rect& c,
                          IN const Rect& a, 
                          IN const Rect& b)
    {
        INT right = min(a.GetRight(), b.GetRight());
        INT bottom = min(a.GetBottom(), b.GetBottom());
        INT left = max(a.GetLeft(), b.GetLeft());
        INT top = max(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    // Determine if the specified rect intersects with the
    // current rect object.

    BOOL IntersectsWith(IN const Rect& rect) const
    {
        return (GetLeft() < rect.GetRight() &&
                GetTop() < rect.GetTop() &&
                GetRight() > rect.GetLeft() &&
                GetBottom() > rect.GetTop());
    }

    static BOOL Union(OUT Rect& c,
                      IN const Rect& a,
                      IN const Rect& b)
    {
        INT right = max(a.GetRight(), b.GetRight());
        INT bottom = max(a.GetBottom(), b.GetBottom());
        INT left = min(a.GetLeft(), b.GetLeft());
        INT top = min(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    VOID Offset(IN const Point& point)
    {
        Offset(point.X, point.Y);
    }

    VOID Offset(IN INT dx, 
                IN INT dy)
    {
        X += dx;
        Y += dy;
    }

public:

    INT X;
    INT Y;
    INT Width;
    INT Height;
};

// A user must mange memory for PathData.

class PathData
{
public:
    PathData()
    {
        Count = 0;
        Points = NULL;
        Types = NULL;
    }

    ~PathData()
    {
        if (Points != NULL) 
        {
            delete Points;
        }
        
        if (Types != NULL) 
        {
            delete Types;
        }
    }

public:
    INT Count;
    PointF* Points;
    BYTE* Types;
};

#endif // !_GDIPLUSTYPES_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\outpos.h ===
/*----------------------------------------------------------------------------
	%%File: OUTPOS.H
	%%Unit: OUTPOS
	%%Contact: seijia

	mapping from public and private pos
----------------------------------------------------------------------------*/

#ifndef __OUTPOS_H__
#define __OUTPOS_H__

#define JPOS_UNDEFINED		0

#define JPOS_MEISHI_FUTSU		100		//
#define JPOS_MEISHI_SAHEN		101		//
#define JPOS_MEISHI_ZAHEN		102		//
#define JPOS_MEISHI_KEIYOUDOUSHI		103		//`
#define JPOS_HUKUSIMEISHI		104		//I
#define JPOS_MEISA_KEIDOU		105		//`
#define JPOS_JINMEI		106		//l
#define JPOS_JINMEI_SEI		107		//
#define JPOS_JINMEI_MEI		108		//
#define JPOS_CHIMEI		109		//n
#define JPOS_CHIMEI_KUNI		110		//
#define JPOS_CHIMEI_KEN		111		//
#define JPOS_CHIMEI_GUN		112		//S
#define JPOS_CHIMEI_KU		113		//
#define JPOS_CHIMEI_SHI		114		//s
#define JPOS_CHIMEI_MACHI		115		//
#define JPOS_CHIMEI_MURA		116		//
#define JPOS_CHIMEI_EKI		117		//w
#define JPOS_SONOTA		118		//L
#define JPOS_SHAMEI		119		//
#define JPOS_SOSHIKI		120		//gD
#define JPOS_KENCHIKU		121		//z
#define JPOS_BUPPIN		122		//i
#define JPOS_DAIMEISHI		123		//
#define JPOS_DAIMEISHI_NINSHOU		124		//l
#define JPOS_DAIMEISHI_SHIJI		125		//w
#define JPOS_KAZU		126		//
#define JPOS_KAZU_SURYOU		127		//
#define JPOS_KAZU_SUSHI		128		//
#define JPOS_5DAN_AWA		200		//s
#define JPOS_5DAN_KA		201		//s
#define JPOS_5DAN_GA		202		//s
#define JPOS_5DAN_SA		203		//s
#define JPOS_5DAN_TA		204		//s
#define JPOS_5DAN_NA		205		//s
#define JPOS_5DAN_BA		206		//s
#define JPOS_5DAN_MA		207		//s
#define JPOS_5DAN_RA		208		//s
#define JPOS_5DAN_AWAUON		209		//s
#define JPOS_5DAN_KASOKUON		210		//s
#define JPOS_5DAN_RAHEN		211		//si
#define JPOS_4DAN_HA		212		//sli
#define JPOS_1DAN		213		//i
#define JPOS_TOKUSHU_KAHEN		214		//
#define JPOS_TOKUSHU_SAHENSURU		215		//
#define JPOS_TOKUSHU_SAHEN		216		//si
#define JPOS_TOKUSHU_ZAHEN		217		//si
#define JPOS_TOKUSHU_NAHEN		218		//si
#define JPOS_KURU_KI		219		//
#define JPOS_KURU_KITA		220		//
#define JPOS_KURU_KITARA		221		//
#define JPOS_KURU_KITARI		222		//
#define JPOS_KURU_KITAROU		223		//
#define JPOS_KURU_KITE		224		//
#define JPOS_KURU_KUREBA		225		//
#define JPOS_KURU_KO		226		//ij
#define JPOS_KURU_KOI		227		//
#define JPOS_KURU_KOYOU		228		//
#define JPOS_SURU_SA		229		//
#define JPOS_SURU_SI		230		//
#define JPOS_SURU_SITA		231		//
#define JPOS_SURU_SITARA		232		//
#define JPOS_SURU_SIATRI		233		//
#define JPOS_SURU_SITAROU		234		//
#define JPOS_SURU_SITE		235		//
#define JPOS_SURU_SIYOU		236		//
#define JPOS_SURU_SUREBA		237		//
#define JPOS_SURU_SE		238		//
#define JPOS_SURU_SEYO		239		//^
#define JPOS_KEIYOU		300		//`e
#define JPOS_KEIYOU_GARU		301		//`e
#define JPOS_KEIYOU_GE		302		//`e
#define JPOS_KEIYOU_ME		303		//`e
#define JPOS_KEIYOU_YUU		304		//`e
#define JPOS_KEIYOU_U		305		//`e
#define JPOS_KEIDOU		400		//`e
#define JPOS_KEIDOU_NO		401		//`e
#define JPOS_KEIDOU_TARU		402		//`e
#define JPOS_KEIDOU_GARU		403		//`e
#define JPOS_FUKUSHI		500		//
#define JPOS_FUKUSHI_SAHEN		501		//
#define JPOS_FUKUSHI_NI		502		//
#define JPOS_FUKUSHI_NANO		503		//
#define JPOS_FUKUSHI_DA		504		//
#define JPOS_FUKUSHI_TO		505		//
#define JPOS_FUKUSHI_TOSURU		506		//
#define JPOS_RENTAISHI		600		//A
#define JPOS_RENTAISHI_SHIJI		601		//wA
#define JPOS_SETSUZOKUSHI		650		//
#define JPOS_KANDOUSHI		670		//
#define JPOS_SETTOU		700		//
#define JPOS_SETTOU_KAKU		701		//P
#define JPOS_SETTOU_SAI		702		//Q
#define JPOS_SETTOU_FUKU		703		//R
#define JPOS_SETTOU_MI		704		//S
#define JPOS_SETTOU_DAISHOU		705		//T
#define JPOS_SETTOU_KOUTEI		706		//U
#define JPOS_SETTOU_CHOUTAN		707		//V
#define JPOS_SETTOU_SHINKYU		708		//W
#define JPOS_SETTOU_JINMEI		709		//l
#define JPOS_SETTOU_CHIMEI		710		//n
#define JPOS_SETTOU_SONOTA		711		//L
#define JPOS_SETTOU_JOSUSHI		712		//Ou
#define JPOS_SETTOU_TEINEI_O		713		//JP
#define JPOS_SETTOU_TEINEI_GO		714		//JQ
#define JPOS_SETTOU_TEINEI_ON		715		//JR
#define JPOS_SETSUBI		800		//
#define JPOS_SETSUBI_TEKI		801		//P
#define JPOS_SETSUBI_SEI		802		//Q
#define JPOS_SETSUBI_KA		803		//R
#define JPOS_SETSUBI_CHU		804		//S
#define JPOS_SETSUBI_FU		805		//T
#define JPOS_SETSUBI_RYU		806		//U
#define JPOS_SETSUBI_YOU		807		//V
#define JPOS_SETSUBI_KATA		808		//W
#define JPOS_SETSUBI_MEISHIRENDAKU		809		//A
#define JPOS_SETSUBI_JINMEI		810		//l
#define JPOS_SETSUBI_CHIMEI		811		//n
#define JPOS_SETSUBI_KUNI		812		//
#define JPOS_SETSUBI_KEN		813		//
#define JPOS_SETSUBI_GUN		814		//S
#define JPOS_SETSUBI_KU		815		//
#define JPOS_SETSUBI_SHI		816		//s
#define JPOS_SETSUBI_MACHI		817		//P
#define JPOS_SETSUBI_CHOU		818		//Q
#define JPOS_SETSUBI_MURA		819		//P
#define JPOS_SETSUBI_SON		820		//Q
#define JPOS_SETSUBI_EKI		821		//w
#define JPOS_SETSUBI_SONOTA		822		//L
#define JPOS_SETSUBI_SHAMEI		823		//
#define JPOS_SETSUBI_SOSHIKI		824		//gD
#define JPOS_SETSUBI_KENCHIKU		825		//z
#define JPOS_RENYOU_SETSUBI		826		//Ap
#define JPOS_SETSUBI_JOSUSHI		827		//u
#define JPOS_SETSUBI_JOSUSHIPLUS		828		//u{
#define JPOS_SETSUBI_JIKAN		829		//
#define JPOS_SETSUBI_JIKANPLUS		830		//{
#define JPOS_SETSUBI_TEINEI		831		//J
#define JPOS_SETSUBI_SAN		832		//JP
#define JPOS_SETSUBI_KUN		833		//JQ
#define JPOS_SETSUBI_SAMA		834		//JR
#define JPOS_SETSUBI_DONO		835		//JS
#define JPOS_SETSUBI_FUKUSU		836		//
#define JPOS_SETSUBI_TACHI		837		//P
#define JPOS_SETSUBI_RA		838		//Q
#define JPOS_TANKANJI		900		//P
#define JPOS_TANKANJI_KAO		901		//
#define JPOS_KANYOUKU		902		//p
#define JPOS_DOKURITSUGO		903		//
#define JPOS_FUTEIGO		904		//s
#define JPOS_KIGOU		905		//L
#define JPOS_EIJI		906		//p
#define JPOS_KUTEN		907		//_
#define JPOS_TOUTEN		908		//_
#define JPOS_KANJI		909		//s\
#define JPOS_OPENBRACE		910		//J
#define JPOS_CLOSEBRACE		911		//


#pragma pack (push, 1)
//POS table data structure
typedef struct _POSTBL
{
	WORD		nPos;					//pos number
	BYTE		*szName;				//name of pos
} POSTBL;
#pragma pack (pop)

#ifdef __cplusplus
extern "C" {
#endif

//function prototypes
extern POSTBL *ObtainPosTable(int *pcPos);
extern WORD WPosExtFromIn(WORD wPos);
extern WORD WPosInFromExt(WORD wPos);
#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif

#endif //__OUTPOS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusregion.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Region.hpp
*
* Abstract:
*
*   Region API related declarations
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/

#ifndef _GDIPLUSREGION_H
#define _GDIPLUSREGION_H

/**
 * Construct a new region object
 */

inline 
Region::Region()
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegion(&region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const RectF& rect)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionRect(&rect, &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const Rect& rect)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionRectI(&rect, &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const GraphicsPath* path)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionPath(path->nativePath, &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const BYTE* regionData, IN INT size)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionRgnData(regionData, size, &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN HRGN hRgn)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionHrgn(hRgn, &region);

    SetNativeRegion(region);
}

inline 
Region* Region::FromHRGN(IN HRGN hRgn)
{
    GpRegion *region = NULL;

    if (DllExports::GdipCreateRegionHrgn(hRgn, &region) == Ok)
    {
        Region* newRegion = new Region(region);

        if (newRegion == NULL) 
        {
            DllExports::GdipDeleteRegion(region);
        }

        return newRegion;
    }
    else
        return NULL;
}

inline 
Region::~Region()
{
    DllExports::GdipDeleteRegion(nativeRegion);
}

/**
 * Make a copy of the region object
 */
inline Region* 
Region::Clone() const
{
    GpRegion *region = NULL;

    SetStatus(DllExports::GdipCloneRegion(nativeRegion, &region));

    return new Region(region);
}

inline Status 
Region::MakeInfinite()
{
    return SetStatus(DllExports::GdipSetInfinite(nativeRegion));
}

inline Status 
Region::MakeEmpty()
{
    return SetStatus(DllExports::GdipSetEmpty(nativeRegion));
}

/**
 * Region operations
 */
inline Status 
Region::Intersect(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, CombineModeIntersect));
}

inline Status 
Region::Intersect(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, CombineModeIntersect));
}

inline Status 
Region::Intersect(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, path->nativePath, CombineModeIntersect));
}

inline Status 
Region::Intersect(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion, region->nativeRegion, CombineModeIntersect));
}

inline Status 
Region::Union(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, CombineModeUnion));
}

inline Status 
Region::Union(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, CombineModeUnion));
}

inline Status 
Region::Union(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, path->nativePath, CombineModeUnion));
}

inline Status 
Region::Union(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion, region->nativeRegion, CombineModeUnion));
}

inline Status 
Region::Xor(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, CombineModeXor));
}

inline Status 
Region::Xor(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, CombineModeXor));
}

inline Status 
Region::Xor(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, path->nativePath, CombineModeXor));
}

inline Status 
Region::Xor(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion, region->nativeRegion, CombineModeXor));
}

inline Status 
Region::Exclude(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, CombineModeExclude));
}

inline Status 
Region::Exclude(IN const Rect& rect)
{
     return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, CombineModeExclude));
}

inline Status 
Region::Exclude(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, path->nativePath, CombineModeExclude));
}

inline Status
Region::Exclude(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion,
                                               region->nativeRegion, CombineModeExclude));
}

inline Status 
Region::Complement(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, CombineModeComplement));
}

inline Status 
Region::Complement(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, CombineModeComplement));
}

inline Status 
Region::Complement(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion,
                                                path->nativePath, CombineModeComplement));
}

inline Status 
Region::Complement(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion,
                                                  region->nativeRegion, CombineModeComplement));
}

/**
 * Transform operations
 */
inline Status 
Region::Translate(IN REAL dx, 
                  IN REAL dy)
{
    return SetStatus(DllExports::GdipTranslateRegion(nativeRegion, dx, dy));
}

inline Status 
Region::Translate(IN INT dx, 
                  IN INT dy)
{
    return SetStatus(DllExports::GdipTranslateRegionI(nativeRegion, dx, dy));
}

inline Status 
Region::Transform(IN const Matrix* matrix)
{
    return SetStatus(DllExports::GdipTransformRegion(nativeRegion, matrix->nativeMatrix));
}

/**
 * Get region attributes
 */
inline Status 
Region::GetBounds(OUT RectF* rect,
                  IN const Graphics* g) const
{
    return SetStatus(DllExports::GdipGetRegionBounds(nativeRegion,
                                                g->nativeGraphics,
                                                rect));
}

inline Status 
Region::GetBounds(OUT Rect* rect,
                  IN const Graphics* g) const
{
    return SetStatus(DllExports::GdipGetRegionBoundsI(nativeRegion,
                                                g->nativeGraphics,
                                                rect));
}

inline HRGN
Region::GetHRGN(IN const Graphics* g) const
{
    HRGN hrgn;

    SetStatus(DllExports::GdipGetRegionHRgn(nativeRegion,
                                            g->nativeGraphics,
                                            &hrgn));

    return hrgn;
}

inline BOOL 
Region::IsEmpty(IN const Graphics *g) const
{
    BOOL booln = FALSE;
   
    SetStatus(DllExports::GdipIsEmptyRegion(nativeRegion,
                                            g->nativeGraphics,
                                            &booln));

    return booln;
}

inline BOOL 
Region::IsInfinite(IN const Graphics *g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsInfiniteRegion(nativeRegion,
                                                 g->nativeGraphics,
                                                 &booln));

    return booln;
}

inline BOOL 
Region::Equals(IN const Region* region, 
               IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsEqualRegion(nativeRegion,
                                              region->nativeRegion,
                                              g->nativeGraphics,
                                              &booln));
    return booln;
}

// Get the size of the buffer needed for the GetData method
inline UINT 
Region::GetDataSize() const
{
    UINT     bufferSize = 0;
    
    SetStatus(DllExports::GdipGetRegionDataSize(nativeRegion, &bufferSize));
    
    return bufferSize;
}

// buffer     - where to put the data
// bufferSize - how big the buffer is (should be at least as big as GetDataSize())
// sizeFilled - if not NULL, this is an OUT param that says how many bytes
//              of data were written to the buffer.
inline Status 
Region::GetData(OUT BYTE* buffer, 
                IN UINT bufferSize, 
                OUT UINT* sizeFilled) const
{
    return SetStatus(DllExports::GdipGetRegionData(nativeRegion, buffer, bufferSize, sizeFilled));
}

/**
 * Hit testing operations
 */
inline BOOL 
Region::IsVisible(IN const PointF& point, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsVisibleRegionPoint(nativeRegion,
                                     point.X, point.Y, 
                                     (g == NULL) ? NULL : g->nativeGraphics,
                                     &booln));
    return booln;
}

inline BOOL 
Region::IsVisible(IN const RectF& rect, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsVisibleRegionRect(nativeRegion, rect.X,
                                                    rect.Y, rect.Width,
                                                    rect.Height,
                                                    (g == NULL) ? NULL : g->nativeGraphics,
                                                    &booln));
    return booln;
}

inline BOOL 
Region::IsVisible(IN const Point& point, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;


    SetStatus(DllExports::GdipIsVisibleRegionPointI(nativeRegion,
                                                   point.X,
                                                   point.Y,
                                                   (g == NULL) ? NULL : g->nativeGraphics,
                                                   &booln));
    return booln;
}

inline BOOL 
Region::IsVisible(IN const Rect& rect, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsVisibleRegionRectI(nativeRegion,
                                                  rect.X,
                                                  rect.Y,
                                                  rect.Width,
                                                  rect.Height,
                                                  (g == NULL) ? NULL : g->nativeGraphics,
                                                  &booln));
    return booln;
}

inline UINT 
Region::GetRegionScansCount(IN const Matrix* matrix) const
{
    UINT count = 0;

    SetStatus(DllExports::GdipGetRegionScansCount(nativeRegion,
                                                  &count,
                                                  matrix->nativeMatrix));
    return count;
}

inline Status 
Region::GetRegionScans(
    IN const Matrix* matrix,
    OUT RectF* rects,
    IN OUT INT* count) const
{
    return SetStatus(DllExports::GdipGetRegionScans(nativeRegion,
                                          rects,
                                          count,
                                          matrix->nativeMatrix));
}

// If rects is NULL, return the count of rects in the region.
// Otherwise, assume rects is big enough to hold all the region rects
// and fill them in and return the number of rects filled in.
// The rects are returned in the units specified by the matrix
// (which is typically a world-to-device transform).
// Note that the number of rects returned can vary, depending on the
// matrix that is used.
inline Status 
Region::GetRegionScans(
    IN const Matrix* matrix,
    OUT Rect* rects,       // NULL to just get the count
    IN OUT INT* count) const
{
    return SetStatus(DllExports::GdipGetRegionScansI(nativeRegion,
                                          rects,
                                          count,
                                          matrix->nativeMatrix));
}

// protected method
inline Region::Region(GpRegion* nativeRegion)
{
    SetNativeRegion(nativeRegion);
}

// protected method
inline VOID Region::SetNativeRegion(GpRegion* nativeRegion)
{
    this->nativeRegion = nativeRegion;
}

inline Status Region::GetLastStatus() const
{
    Status lastStatus = lastResult;
    lastResult = Ok;

    return lastStatus;
}

#endif // !_GDIPLUSREGION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\imeapp.h ===
//
//	%%Title: IMEAPP
//	%%Unit: COM
//	%%Contact: TakeshiF/SeijiA
//	%%Date: 97/06/20
//	%%File: imeapp.h
//
//	Private API / Message service
//

#ifndef __IMEUP_H__
#define __IMEUP_H__

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#include "actdict.h"

//// START

/***********************************************************************
	Msg:	WM_MSIME_SERVICE
	Desc: 	service functions
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_SERVICE		TEXT("MSIMEService")

#define	VERSION_ID_JAPAN	0x01000000
#define	VERSION_ID_KOREA	0x02000000
#define	VERSION_ID_TC		0x04000000
#define	VERSION_ID_PRC		0x08000000

#define	VERSION_ID_IMEJP98	(VERSION_ID_JAPAN | 0x980)
#define	VERSION_ID_IMEJP98A	(VERSION_ID_JAPAN | 0x98a)


/***********************************************************************
	Msg:	WM_MSIME_AUTOCOMPLETE
	Desc: 	use IImeActiveDict to support auto-complete
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_AUTOCOMPLETE 		TEXT("MSIMEAutoComplete")

// AutoComplete Version
#define VERSION_AUTOCOMPETE		1

// Dictionary Structure
typedef struct _IMEDICT
{
	int				cbSize;			//size of this structure
	HIMC			hIMC;			//IME context
	IImeActiveDict	*pdict;			//program dictionary
} IMEDICT;

//WParam definition
#define FID_AUTO_VERSION		1
#define FID_AUTO_ACTIVATE		2
#define FID_AUTO_DEACTIVATE		3


/***********************************************************************
	Msg:	WM_MSIME_WORDSTAT
	Desc: 	use IImeActiveDict to get word statistics
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_WORDSTAT 		TEXT("MSIMEWordStatistics")

// WordStat Version
#define VERSION_WORDSTAT		1

// WParam definition
#define FID_STAT_VERSION		1
#define FID_STAT_GIVESTAT		2


/***********************************************************************
	Msg:	WM_MSIME_DOCKDICT
	Desc: 	use IImeActiveDict to dock dictionary
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_DOCKDICT 		TEXT("MSIMEDockActiveDict")

// Dictionary Docking Version
#define VERSION_DOCKDICT		1

// WParam definition
#define FID_DOCK_VERSION		1
#define FID_DOCK_ACTIVATE		2
#define FID_DOCK_DEACTIVATE		3


/***********************************************************************
	Msg:	WM_MSIME_MOUSE
	Desc: 	mouse operation definition                
	Owner: 	kentu				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_MOUSE 		TEXT("MSIMEMouseOperation")

// Mouse Operation Version (return value of IMEMOUSE_VERSION)
#define VERSION_MOUSE_OPERATION		1

// Mouse operation result
#define IMEMOUSERET_NOTHANDLED		(-1)

//WParam definition for WM_IME_MOUSE.
#define IMEMOUSE_VERSION	0xff	// mouse supported?

#define IMEMOUSE_NONE		0x00	// no mouse button was pushed
#define IMEMOUSE_LDOWN		0x01
#define IMEMOUSE_RDOWN		0x02
#define IMEMOUSE_MDOWN		0x04
#define IMEMOUSE_WUP		0x10	// wheel up
#define IMEMOUSE_WDOWN		0x20	// wheel down


/***********************************************************************
	Msg:	WM_MSIME_RECONVERT/WM_MSIME_RECONVERTREQUEST
	Desc: 	reconversion
	Owner: 	takeshif				
 ***********************************************************************/

// wParam of WM_MSIME_RECONVERTREQUEST
#define FID_RECONVERT_VERSION	0x10000000

// Private reconversion Version
#define VERSION_RECONVERSION		1

// Label for RegisterWindowMessage
#define	RWM_RECONVERT			TEXT("MSIMEReconvert")
#define	RWM_RECONVERTREQUEST	TEXT("MSIMEReconvertRequest")

/***********************************************************************
	Msg:	WM_MSIME_DOCUMENTFEED
	Desc: 	reconversion
	Owner: 	takeshif				
	Usage: SendMessage( hwndApp, WM_MSIME_DOCUMENTFEED, VERSION_DOCUMENTFEED,
				(RECONVERTSTRING*)pReconv );
	wParam: VERSION_DOCUMENTFEED
	lParam: Pointer of RECONVERTSTRING structure
	return: size of RECONVERTSTRING structure
 ***********************************************************************/

// wParam of WM_MSIME_DOCUMENTFEED (set current docfeed version)
#define VERSION_DOCUMENTFEED		1

// lParam is pointer of RECONVERTSTRING structure

// Label for RegisterWindowMessage
#define	RWM_DOCUMENTFEED	TEXT("MSIMEDocumentFeed")

/***********************************************************************
	Msg:	WM_MSIME_QUERYHIDECARET
	Desc: 	composition UI
	Owner: 	takeshif				
	Usage: SendMessage( hwndDefUI, WM_MSIME_QUERYHIDECARET, 0, 0 );
	wParam: reserved
	lParam: reserved
	return: Non-zero = shows caret. Zero = hide caret.
 ***********************************************************************/

// wParam of WM_MSIME_QUERYHIDECARET
#define VERSION_QUERYHIDECARET		1

// Label for RegisterWindowMessage
#define	RWM_QUERYHIDECARET	TEXT("MSIMEQueryHideCaret")

/***********************************************************************
	Msg:	WM_MSIME_QUERYPOSITION
	Desc: 	composition UI
	Owner: 	takeshif				
	Usage: SendMessage( hwndApp, WM_MSIME_QUERYPOSITION, 0, (IMEPOSITION*)pPs );
	wParam: reserved. must be 0.
	lParam: pointer of IMEPOSITION structure
	return: Non-zero = accepted. Zero = not accepted.
 ***********************************************************************/

// wParam of WM_MSIME_QUERYPOSITION
#define VERSION_QUERYPOSITION		1

// Label for RegisterWindowMessage
#define	RWM_QUERYPOSITION	TEXT("MSIMEQueryPosition")


/***********************************************************************
	Msg:	WM_MSIME_MODEBIAS
	Desc: 	input mode bias
	Owner: 	takeshif
	Usage: SendMessage( hwndDefUI, WM_MSIME_MODEBIAS, MODEBIAS_xxxx, 0 );
	wParam: see below MODEBIAS_xxxx
	lParam: reserved
	return: Non-zero = accepted. Zero = not accepted.
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_MODEBIAS			TEXT("MSIMEModeBias")

// wParam - bias setting
#define MODEBIAS_DEFAULT				0x00000000	// reset all of bias setting
#define MODEBIAS_FILENAME				0x00000001
#define MODEBIAS_URL					0x00000002
#define MODEBIAS_DISABLEAUTOCONV		0x00000010


/***********************************************************************
	Msg:	WM_MSIME_SHOWIMEPAD
	Desc: 	show ImePad
	Owner: 	toshiaK
	Usage: SendMessage( hwndDefUI, WM_MSIME_SHOWIMEPAD, 0, 0 );
	wParam: reserved
	lParam: reserved
	return: Non-zero = accepted. Zero = not accepted.
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_SHOWIMEPAD			TEXT("MSIMEShowImePad")


/***********************************************************************
	Msg:	WM_MSIME_KEYMAP
	Desc: 	key map sharing with apps
	Owner: 	HiroakiK
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_KEYMAP				TEXT("MSIMEKeyMap")
#define	RWM_CHGKEYMAP			TEXT("MSIMEChangeKeyMap")
#define	RWM_NTFYKEYMAP			TEXT("MSIMENotifyKeyMap")


#define FID_MSIME_KMS_VERSION		1
#define FID_MSIME_KMS_INIT			2
#define FID_MSIME_KMS_TERM			3
#define FID_MSIME_KMS_DEL_KEYLIST	4
#define FID_MSIME_KMS_NOTIFY		5
#define FID_MSIME_KMS_GETMAP		6
#define FID_MSIME_KMS_INVOKE		7
#define FID_MSIME_KMS_SETMAP		8



#define IMEKMS_NOCOMPOSITION        0
#define IMEKMS_COMPOSITION          1
#define IMEKMS_SELECTION            2
#define IMEKMS_IMEOFF               3
#define IMEKMS_2NDLEVEL             4
#define IMEKMS_INPTGL               5



typedef struct tagIMEKMSINIT {
	INT			cbSize;
	HWND		hWnd;	// Window which receives notification from IME.
						// If hWnd is NULL, no notification is posted
						// to Input context.
} IMEKMSINIT;


typedef struct tagIMEKMSKEY {
	DWORD dwStatus;		//Shift-Control combination status.
						//Any combination of constants below
						//(defined in IMM.H)
						// 0x0000 (default)
						// MOD_CONTROL     0x0002
						// MOD_SHIFT       0x0004
						// Alt key and Win key is not processed by IME. 
	
	DWORD dwCompStatus;	//Composition string status
						//One of the constants below
						// IMEKMS_NOCOMPOSITION  No composition string      
						// IMEKMS_COMPOSITION    Some composition string
						// IMEKMS_SELECTION      Selection exists in apps
						// IMEKMS_IMEOFF         IME Off state
						// IMEKMS_2NDLEVEL       2nd stage on 2 stroke key operation
						
	
	DWORD dwVKEY;		// VKEY code defined in IMM.H
	union {
		DWORD dwControl;// IME Functionality ID
		DWORD dwNotUsed;
	};
	union {
		WCHAR pwszDscr[31];// The pointer to string of description of this functionalify
		WCHAR pwszNoUse[31];
	};
} IMEKMSKEY;

typedef struct tagIMEKMS {
	INT			cbSize;
	HIMC		hIMC;
	LANGID		idLang;
	DWORD		cKeyList;
	IMEKMSKEY	*pKeyList;
} IMEKMS;

typedef struct tagIMEKMSNTFY {
	INT			cbSize;
	HIMC		hIMC;
	BOOL		fSelect;
} IMEKMSNTFY;

typedef struct tagIMEKMSKMP {
	INT			cbSize;			//[in] size of this structure
	HIMC		hIMC;			//[in] Input context
	WORD		wVKStart;		//[in] VKEY start
	WORD		wVKEnd;			//[in] VKEY end
	INT			cKeyList;		//[out] number of IMEKMSKEY
	IMEKMSKEY	*pKeyList;		//[out] retrieve buffer of IMEKMSKEY
								//      Must be GlobalMemFree by clients
} IMEKMSKMP;

typedef struct tagIMEKMSINVK {
	INT			cbSize;
	HIMC		hIMC;
	DWORD		dwControl;
} IMEKMSINVK;


//// END

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif	// __cplusplus


#endif // __IMEUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\zmouse.h ===
/******************************************************************************\
*       ZMOUSE.H - Include file for MSDELTA Zoom mouse DLL. 
*
*       AUTHOR - Paul Henderson, July 1995
*                Lora McCambridge January 1996
*       REVISIONS - 
*        Lora McCambridge April 1996 - removing WM_MOUSEWHEEL, this
*             message will only be available via the OS.  Applications
*             must now register the message MSH_MOUSEWHEEL, and
*             use that message for messages from MSWHEEL.  
*       LKM May 1996 - Added add'l #defines for class and title of the wheel
*                      module window to reflect the MSH_ style.
*                    - Added #defines for WHEEL SUPPORT and Scroll Lines
*                    - Added inline function HwndMsWheel, apps can use
*                      this function to retrieve the handle to mswheel,
*                      get the message ID's for the registered messages,
*                      the flag for 3d support, and the value for scroll
*                      lines. Please in function at end of file.
*
*       Copyright (C) 1995, 1996 Microsoft Corporation.
*       All rights reserved. 
\******************************************************************************/


/**************************************************************************
	 Client Appplication (API) Defines for Wheel rolling
***************************************************************************/


// Apps need to call RegisterWindowMessage using the #define below to
// get the message number that is sent to the foreground window
// when a wheel roll occurs

#define MSH_MOUSEWHEEL "MSWHEEL_ROLLMSG"
   // wParam = zDelta expressed in multiples of WHEEL_DELTA
   // lParam is the mouse coordinates

#define WHEEL_DELTA      120      // Default value for rolling one detent


#ifndef WM_MOUSEWHEEL
#define WM_MOUSEWHEEL (WM_MOUSELAST+1)  // message that will be supported
                                        // by the OS 
#endif


/**************************************************************************
    Client Appplication (API) Defines for
	 determining 3D support active
	 determining # of Scroll Lines
***************************************************************************/

// Class name for Magellan/Z MSWHEEL window
// use FindWindow to get hwnd to MSWHEEL
#define MOUSEZ_CLASSNAME  "MouseZ"           // wheel window class  
#define MOUSEZ_TITLE      "Magellan MSWHEEL" // wheel window title

#define MSH_WHEELMODULE_CLASS (MOUSEZ_CLASSNAME)
#define MSH_WHEELMODULE_TITLE (MOUSEZ_TITLE)

// Apps need to call RegisterWindowMessage using the #defines below to
// get the message number that can be sent to the MSWHEEL window to
// query if wheel support is active (MSH_WHEELSUPPORT), and the message
// number to query the number of scroll lines (MSH_SCROLLLINES).  
// To send a message to MSWheel window, use FindWindow with the #defines
// for CLASS and TITLE above.  If FindWindow fails to find the MSWHEEL
// window or the return from SendMessage is false, then Wheel support
// is currently not available.

#define MSH_WHEELSUPPORT "MSH_WHEELSUPPORT_MSG" // name of msg to send
                                                // to query for wheel support
// MSH_WHEELSUPPORT
//    wParam - not used 
//    lParam - not used
//    returns BOOL - TRUE if wheel support is active, FALSE otherwise

                                
#define MSH_SCROLL_LINES "MSH_SCROLL_LINES_MSG"

// MSH_SCROLL_LINES
//    wParam - not used 
//    lParam - not used
//    returns int  - number of lines to scroll on a wheel roll

#ifndef  WHEEL_PAGESCROLL  
#define WHEEL_PAGESCROLL  (UINT_MAX)    // signifies to scroll a page, to
					// be defined in updated winuser.h
					// in SDK release for NT4.0
#endif 


// NB!! The remainder of the original header file has been deleted since it
// doesn't compile.  RichEdit doesn't need the remainder in any event.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\imm.h ===
/**********************************************************************/
/*      IMM.H - Input Method Manager definitions                      */
/*                                                                    */
/*      Copyright (c) 1993-1995  Microsoft Corporation                */
/**********************************************************************/

#ifndef _IMM_
#define _IMM_        // defined if IMM.H has been included

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _WINUSER_
#define VK_PROCESSKEY 0x0E5
#endif

#ifndef IMM_WINVER
#define IMM_WINVER 0x040A
#endif

//#if(IMM_WINVER >= 0x040A)
//DECLARE_HANDLE(HIMC);
//#else
typedef DWORD     HIMC;
//#endif

//#if(IMM_WINVER >= 0x040A)
//DECLARE_HANDLE(HIMCC);
//#else
typedef DWORD     HIMCC;
//#endif

typedef HKL FAR  *LPHKL;
typedef UINT FAR *LPUINT;

#define NULLIMC  ((HIMC)0)

typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM, NEAR *NPCOMPOSITIONFORM, FAR *LPCOMPOSITIONFORM;

typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM, NEAR *NPCANDIDATEFORM, FAR *LPCANDIDATEFORM;

typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST, NEAR *NPCANDIDATELIST, FAR *LPCANDIDATELIST;

typedef struct tagREGISTERWORDA {
    LPSTR   lpReading;
    LPSTR   lpWord;
} REGISTERWORDA, *PREGISTERWORDA, NEAR *NPREGISTERWORDA, FAR *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR  lpReading;
    LPWSTR  lpWord;
} REGISTERWORDW, *PREGISTERWORDW, NEAR *NPREGISTERWORDW, FAR *LPREGISTERWORDW;
#ifdef UNICODE
typedef REGISTERWORDW REGISTERWORD;
typedef PREGISTERWORDW PREGISTERWORD;
typedef NPREGISTERWORDW NPREGISTERWORD;
typedef LPREGISTERWORDW LPREGISTERWORD;
#else
typedef REGISTERWORDA REGISTERWORD;
typedef PREGISTERWORDA PREGISTERWORD;
typedef NPREGISTERWORDA NPREGISTERWORD;
typedef LPREGISTERWORDA LPREGISTERWORD;
#endif // UNICODE

#if(IMM_WINVER >= 0x040A)
typedef struct tagRECONVERTSTRING {
    DWORD dwSize;
    DWORD dwVersion;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwTargetStrLen;
    DWORD dwTargetStrOffset;
} RECONVERTSTRING, *PRECONVERTSTRING, NEAR *NPRECONVERTSTRING, FAR *LPRECONVERTSTRING;
#endif

#define STYLE_DESCRIPTION_SIZE  32

typedef struct tagSTYLEBUFA {
    DWORD       dwStyle;
    CHAR        szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFA, *PSTYLEBUFA, NEAR *NPSTYLEBUFA, FAR *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD       dwStyle;
    WCHAR       szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFW, *PSTYLEBUFW, NEAR *NPSTYLEBUFW, FAR *LPSTYLEBUFW;
#ifdef UNICODE
typedef STYLEBUFW STYLEBUF;
typedef PSTYLEBUFW PSTYLEBUF;
typedef NPSTYLEBUFW NPSTYLEBUF;
typedef LPSTYLEBUFW LPSTYLEBUF;
#else
typedef STYLEBUFA STYLEBUF;
typedef PSTYLEBUFA PSTYLEBUF;
typedef NPSTYLEBUFA NPSTYLEBUF;
typedef LPSTYLEBUFA LPSTYLEBUF;
#endif // UNICODE

#if(IMM_WINVER >= 0x040A)
#define IMEMENUITEM_STRING_SIZE 80 

typedef struct tagIMEMENUITEMINFOA {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    CHAR        szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOA, *PIMEMENUITEMINFOA, NEAR *NPIMEMENUITEMINFOA, FAR *LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    WCHAR       szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOW, *PIMEMENUITEMINFOW, NEAR *NPIMEMENUITEMINFOW, FAR *LPIMEMENUITEMINFOW;
#ifdef UNICODE
typedef IMEMENUITEMINFOW IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOW PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOW NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOW LPIMEMENUITEMINFO;
#else
typedef IMEMENUITEMINFOA IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOA PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOA NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOA LPIMEMENUITEMINFO;
#endif // UNICODE

typedef struct tagIMECHARPOSITION {
    DWORD       dwSize;
    DWORD       dwCharPos;
    POINT       pt;
    UINT        cLineHeight;
    RECT        rcDocument;
} IMECHARPOSITION, *PIMECHARPOSITION, NEAR *NPIMECHARPOSITION, FAR *LPIMECHARPOSITION;

#endif /* IMM_WINVER >= 0x040A */

// prototype of IMM API

HKL  WINAPI ImmInstallIMEA(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText);
HKL  WINAPI ImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText);
#ifdef UNICODE
#define ImmInstallIME  ImmInstallIMEW
#else
#define ImmInstallIME  ImmInstallIMEA
#endif // !UNICODE

HWND WINAPI ImmGetDefaultIMEWnd(HWND);

UINT WINAPI ImmGetDescriptionA(HKL, LPSTR, UINT uBufLen);
UINT WINAPI ImmGetDescriptionW(HKL, LPWSTR, UINT uBufLen);
#ifdef UNICODE
#define ImmGetDescription  ImmGetDescriptionW
#else
#define ImmGetDescription  ImmGetDescriptionA
#endif // !UNICODE

UINT WINAPI ImmGetIMEFileNameA(HKL, LPSTR, UINT uBufLen);
UINT WINAPI ImmGetIMEFileNameW(HKL, LPWSTR, UINT uBufLen);
#ifdef UNICODE
#define ImmGetIMEFileName  ImmGetIMEFileNameW
#else
#define ImmGetIMEFileName  ImmGetIMEFileNameA
#endif // !UNICODE

DWORD WINAPI ImmGetProperty(HKL, DWORD);

BOOL WINAPI ImmIsIME(HKL);

BOOL WINAPI ImmSimulateHotKey(HWND, DWORD);

HIMC WINAPI ImmCreateContext(void);
BOOL WINAPI ImmDestroyContext(HIMC);
HIMC WINAPI ImmGetContext(HWND);
BOOL WINAPI ImmReleaseContext(HWND, HIMC);
HIMC WINAPI ImmAssociateContext(HWND, HIMC);
#if(IMM_WINVER >= 0x040A)
BOOL WINAPI ImmAssociateContextEx(HWND, HIMC, DWORD);
#endif /* IMM_WINVER >= 0x040A */

LONG  WINAPI ImmGetCompositionStringA(HIMC, DWORD, LPVOID, DWORD);
LONG  WINAPI ImmGetCompositionStringW(HIMC, DWORD, LPVOID, DWORD);
#ifdef UNICODE
#define ImmGetCompositionString  ImmGetCompositionStringW
#else
#define ImmGetCompositionString  ImmGetCompositionStringA
#endif // !UNICODE

BOOL  WINAPI ImmSetCompositionStringA(HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD);
BOOL  WINAPI ImmSetCompositionStringW(HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD);
#ifdef UNICODE
#define ImmSetCompositionString  ImmSetCompositionStringW
#else
#define ImmSetCompositionString  ImmSetCompositionStringA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListCountA(HIMC, LPDWORD);
DWORD WINAPI ImmGetCandidateListCountW(HIMC, LPDWORD);
#ifdef UNICODE
#define ImmGetCandidateListCount  ImmGetCandidateListCountW
#else
#define ImmGetCandidateListCount  ImmGetCandidateListCountA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListA(HIMC, DWORD, LPCANDIDATELIST, DWORD);
DWORD WINAPI ImmGetCandidateListW(HIMC, DWORD, LPCANDIDATELIST, DWORD);
#ifdef UNICODE
#define ImmGetCandidateList  ImmGetCandidateListW
#else
#define ImmGetCandidateList  ImmGetCandidateListA
#endif // !UNICODE

DWORD WINAPI ImmGetGuideLineA(HIMC, DWORD, LPSTR, DWORD);
DWORD WINAPI ImmGetGuideLineW(HIMC, DWORD, LPWSTR, DWORD);
#ifdef UNICODE
#define ImmGetGuideLine  ImmGetGuideLineW
#else
#define ImmGetGuideLine  ImmGetGuideLineA
#endif // !UNICODE

BOOL WINAPI ImmGetConversionStatus(HIMC, LPDWORD, LPDWORD);
BOOL WINAPI ImmSetConversionStatus(HIMC, DWORD, DWORD);
BOOL WINAPI ImmGetOpenStatus(HIMC);
BOOL WINAPI ImmSetOpenStatus(HIMC, BOOL);

BOOL WINAPI ImmGetCompositionFontA(HIMC, LPLOGFONTA);
BOOL WINAPI ImmGetCompositionFontW(HIMC, LPLOGFONTW);
#ifdef UNICODE
#define ImmGetCompositionFont  ImmGetCompositionFontW
#else
#define ImmGetCompositionFont  ImmGetCompositionFontA
#endif // !UNICODE

BOOL WINAPI ImmSetCompositionFontA(HIMC, LPLOGFONTA);
BOOL WINAPI ImmSetCompositionFontW(HIMC, LPLOGFONTW);
#ifdef UNICODE
#define ImmSetCompositionFont  ImmSetCompositionFontW
#else
#define ImmSetCompositionFont  ImmSetCompositionFontA
#endif // !UNICODE

BOOL    WINAPI ImmConfigureIMEA(HKL, HWND, DWORD, LPVOID);
BOOL    WINAPI ImmConfigureIMEW(HKL, HWND, DWORD, LPVOID);
#ifdef UNICODE
#define ImmConfigureIME  ImmConfigureIMEW
#else
#define ImmConfigureIME  ImmConfigureIMEA
#endif // !UNICODE

LRESULT WINAPI ImmEscapeA(HKL, HIMC, UINT, LPVOID);
LRESULT WINAPI ImmEscapeW(HKL, HIMC, UINT, LPVOID);
#if 0
#ifdef UNICODE
#define ImmEscape  ImmEscapeW
#else
#define ImmEscape  ImmEscapeA
#endif // !UNICODE
#endif
DWORD   WINAPI ImmGetConversionListA(HKL, HIMC, LPCSTR, LPCANDIDATELIST, DWORD, UINT);
DWORD   WINAPI ImmGetConversionListW(HKL, HIMC, LPCWSTR, LPCANDIDATELIST, DWORD, UINT);
#ifdef UNICODE
#define ImmGetConversionList  ImmGetConversionListW
#else
#define ImmGetConversionList  ImmGetConversionListA
#endif // !UNICODE

BOOL    WINAPI ImmNotifyIME(HIMC, DWORD, DWORD, DWORD);

BOOL WINAPI ImmGetStatusWindowPos(HIMC, LPPOINT);
BOOL WINAPI ImmSetStatusWindowPos(HIMC, LPPOINT);
BOOL WINAPI ImmGetCompositionWindow(HIMC, LPCOMPOSITIONFORM);
BOOL WINAPI ImmSetCompositionWindow(HIMC, LPCOMPOSITIONFORM);
BOOL WINAPI ImmGetCandidateWindow(HIMC, DWORD, LPCANDIDATEFORM);
BOOL WINAPI ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM);

BOOL WINAPI ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM);
BOOL WINAPI ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM);
#ifdef UNICODE
#define ImmIsUIMessage  ImmIsUIMessageW
#else
#define ImmIsUIMessage  ImmIsUIMessageA
#endif // !UNICODE

UINT WINAPI ImmGetVirtualKey(HWND);

typedef int (CALLBACK *REGISTERWORDENUMPROCA)(LPCSTR, DWORD, LPCSTR, LPVOID);
typedef int (CALLBACK *REGISTERWORDENUMPROCW)(LPCWSTR, DWORD, LPCWSTR, LPVOID);
#ifdef UNICODE
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCW
#else
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCA
#endif // !UNICODE

BOOL WINAPI ImmRegisterWordA(HKL, LPCSTR, DWORD, LPCSTR);
BOOL WINAPI ImmRegisterWordW(HKL, LPCWSTR, DWORD, LPCWSTR);
#ifdef UNICODE
#define ImmRegisterWord  ImmRegisterWordW
#else
#define ImmRegisterWord  ImmRegisterWordA
#endif // !UNICODE

BOOL WINAPI ImmUnregisterWordA(HKL, LPCSTR, DWORD, LPCSTR);
BOOL WINAPI ImmUnregisterWordW(HKL, LPCWSTR, DWORD, LPCWSTR);
#ifdef UNICODE
#define ImmUnregisterWord  ImmUnregisterWordW
#else
#define ImmUnregisterWord  ImmUnregisterWordA
#endif // !UNICODE

UINT WINAPI ImmGetRegisterWordStyleA(HKL, UINT, LPSTYLEBUFA);
UINT WINAPI ImmGetRegisterWordStyleW(HKL, UINT, LPSTYLEBUFW);
#ifdef UNICODE
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleW
#else
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleA
#endif // !UNICODE

UINT WINAPI ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR, DWORD, LPCSTR, LPVOID);
UINT WINAPI ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR, DWORD, LPCWSTR, LPVOID);
#ifdef UNICODE
#define ImmEnumRegisterWord  ImmEnumRegisterWordW
#else
#define ImmEnumRegisterWord  ImmEnumRegisterWordA
#endif // !UNICODE

#if(IMM_WINVER >= 0x040A)
BOOL WINAPI ImmDisableIME(DWORD);
DWORD WINAPI ImmGetImeMenuItemsA(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA, LPIMEMENUITEMINFOA, DWORD);
DWORD WINAPI ImmGetImeMenuItemsW(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW, LPIMEMENUITEMINFOW, DWORD);
#ifdef UNICODE
#define ImmGetImeMenuItems  ImmGetImeMenuItemsW
#else
#define ImmGetImeMenuItems  ImmGetImeMenuItemsA
#endif // !UNICODE
#ifdef UNICODE
#define ImmRequestMessage  ImmRequestMessageW
#else
#define ImmRequestMessage  ImmRequestMessageA
#endif // !UNICODE
#endif /* IMM_WINVER >= 0x040A */

// the IME related messages
#define WM_CONVERTREQUESTEX             0x0108
#define WM_IME_STARTCOMPOSITION         0x010D
#define WM_IME_ENDCOMPOSITION           0x010E
#define WM_IME_COMPOSITION              0x010F
#define WM_IME_KEYLAST                  0x010F

#define WM_IME_SETCONTEXT               0x0281
#define WM_IME_NOTIFY                   0x0282
#define WM_IME_CONTROL                  0x0283
#define WM_IME_COMPOSITIONFULL          0x0284
#define WM_IME_SELECT                   0x0285
#define WM_IME_CHAR                     0x0286
#define WM_IME_REQUEST                  0x0288

#define WM_IME_KEYDOWN                  0x0290
#define WM_IME_KEYUP                    0x0291

// wParam for WM_IME_CONTROL                 
#define IMC_GETCANDIDATEPOS             0x0007
#define IMC_SETCANDIDATEPOS             0x0008
#define IMC_GETCOMPOSITIONFONT          0x0009
#define IMC_SETCOMPOSITIONFONT          0x000A
#define IMC_GETCOMPOSITIONWINDOW        0x000B
#define IMC_SETCOMPOSITIONWINDOW        0x000C
#define IMC_GETSTATUSWINDOWPOS          0x000F
#define IMC_SETSTATUSWINDOWPOS          0x0010
#define IMC_CLOSESTATUSWINDOW           0x0021
#define IMC_OPENSTATUSWINDOW            0x0022

// wParam for WM_IME_CONTROL to the soft keyboard
// dwAction for ImmNotifyIME
#define NI_OPENCANDIDATE                0x0010
#define NI_CLOSECANDIDATE               0x0011
#define NI_SELECTCANDIDATESTR           0x0012
#define NI_CHANGECANDIDATELIST          0x0013
#define NI_FINALIZECONVERSIONRESULT     0x0014
#define NI_COMPOSITIONSTR               0x0015
#define NI_SETCANDIDATE_PAGESTART       0x0016
#define NI_SETCANDIDATE_PAGESIZE        0x0017
#define NI_IMEMENUSELECTED              0x0018

// lParam for WM_IME_SETCONTEXT
#define ISC_SHOWUICANDIDATEWINDOW       0x00000001
#define ISC_SHOWUICOMPOSITIONWINDOW     0x80000000
#define ISC_SHOWUIGUIDELINE             0x40000000
#define ISC_SHOWUIALLCANDIDATEWINDOW    0x0000000F
#define ISC_SHOWUIALL                   0xC000000F

// dwIndex for ImmNotifyIME/NI_COMPOSITIONSTR
#define CPS_COMPLETE                    0x0001
#define CPS_CONVERT                     0x0002
#define CPS_REVERT                      0x0003
#define CPS_CANCEL                      0x0004

// the modifiers of hot key
#define MOD_ALT                         0x0001
#define MOD_CONTROL                     0x0002
#define MOD_SHIFT                       0x0004

#define MOD_LEFT                        0x8000
#define MOD_RIGHT                       0x4000

#define MOD_ON_KEYUP                    0x0800
#define MOD_IGNORE_ALL_MODIFIER         0x0400

// Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F
#define IME_CHOTKEY_IME_NONIME_TOGGLE           0x10
#define IME_CHOTKEY_SHAPE_TOGGLE                0x11
#define IME_CHOTKEY_SYMBOL_TOGGLE               0x12

// Windows for Japanese Edition hot key ID from 0x30 - 0x4F
#define IME_JHOTKEY_CLOSE_OPEN                  0x30

// Windows for Korean Edition hot key ID from 0x50 - 0x6F
#define IME_KHOTKEY_SHAPE_TOGGLE                0x50
#define IME_KHOTKEY_HANJACONVERT                0x51
#define IME_KHOTKEY_ENGLISH                     0x52

// Windows for Tranditional Chinese Edition hot key ID from 0x70 - 0x8F
#define IME_THOTKEY_IME_NONIME_TOGGLE           0x70
#define IME_THOTKEY_SHAPE_TOGGLE                0x71
#define IME_THOTKEY_SYMBOL_TOGGLE               0x72

// direct switch hot key ID from 0x100 - 0x11F
#define IME_HOTKEY_DSWITCH_FIRST                0x100
#define IME_HOTKEY_DSWITCH_LAST                 0x11F

// IME private hot key from 0x200 - 0x21F
#define IME_HOTKEY_PRIVATE_FIRST                0x200
#define IME_ITHOTKEY_RESEND_RESULTSTR           0x200
#define IME_ITHOTKEY_PREVIOUS_COMPOSITION       0x201
#define IME_ITHOTKEY_UISTYLE_TOGGLE             0x202
#define IME_ITHOTKEY_RECONVERTSTRING            0x203
#define IME_HOTKEY_PRIVATE_LAST                 0x21F

// dwSystemInfoFlags bits

// parameter of ImmGetCompositionString
#define GCS_COMPREADSTR                 0x0001
#define GCS_COMPREADATTR                0x0002
#define GCS_COMPREADCLAUSE              0x0004
#define GCS_COMPSTR                     0x0008
#define GCS_COMPATTR                    0x0010
#define GCS_COMPCLAUSE                  0x0020
#define GCS_CURSORPOS                   0x0080
#define GCS_DELTASTART                  0x0100
#define GCS_RESULTREADSTR               0x0200
#define GCS_RESULTREADCLAUSE            0x0400
#define GCS_RESULTSTR                   0x0800
#define GCS_RESULTCLAUSE                0x1000

// style bit flags for WM_IME_COMPOSITION
#define CS_INSERTCHAR                   0x2000
#define CS_NOMOVECARET                  0x4000

// bits of fdwInit of INPUTCONTEXT
// IME version constants
#define IMEVER_0310                     0x0003000A
#define IMEVER_0400                     0x00040000

// IME property bits
#define IME_PROP_AT_CARET               0x00010000
#define IME_PROP_SPECIAL_UI             0x00020000
#define IME_PROP_CANDLIST_START_FROM_1  0x00040000
#define IME_PROP_UNICODE                0x00080000
#define IME_PROP_COMPLETE_ON_UNSELECT   0x00100000

// IME UICapability bits
#define UI_CAP_2700                     0x00000001
#define UI_CAP_ROT90                    0x00000002
#define UI_CAP_ROTANY                   0x00000004

// ImmSetCompositionString Capability bits
#define SCS_CAP_COMPSTR                 0x00000001
#define SCS_CAP_MAKEREAD                0x00000002
#define SCS_CAP_SETRECONVERTSTRING      0x00000004

// IME WM_IME_SELECT inheritance Capability bits
#define SELECT_CAP_CONVERSION           0x00000001
#define SELECT_CAP_SENTENCE             0x00000002

// ID for deIndex of ImmGetGuideLine
#define GGL_LEVEL                       0x00000001
#define GGL_INDEX                       0x00000002
#define GGL_STRING                      0x00000003
#define GGL_PRIVATE                     0x00000004

// ID for dwLevel of GUIDELINE Structure
#define GL_LEVEL_NOGUIDELINE            0x00000000
#define GL_LEVEL_FATAL                  0x00000001
#define GL_LEVEL_ERROR                  0x00000002
#define GL_LEVEL_WARNING                0x00000003
#define GL_LEVEL_INFORMATION            0x00000004

// ID for dwIndex of GUIDELINE Structure
#define GL_ID_UNKNOWN                   0x00000000
#define GL_ID_NOMODULE                  0x00000001
#define GL_ID_NODICTIONARY              0x00000010
#define GL_ID_CANNOTSAVE                0x00000011
#define GL_ID_NOCONVERT                 0x00000020
#define GL_ID_TYPINGERROR               0x00000021
#define GL_ID_TOOMANYSTROKE             0x00000022
#define GL_ID_READINGCONFLICT           0x00000023
#define GL_ID_INPUTREADING              0x00000024
#define GL_ID_INPUTRADICAL              0x00000025
#define GL_ID_INPUTCODE                 0x00000026
#define GL_ID_INPUTSYMBOL               0x00000027
#define GL_ID_CHOOSECANDIDATE           0x00000028
#define GL_ID_REVERSECONVERSION         0x00000029
#define GL_ID_PRIVATE_FIRST             0x00008000
#define GL_ID_PRIVATE_LAST              0x0000FFFF

// ID for dwIndex of ImmGetProperty
#define IGP_GETIMEVERSION               (DWORD)(-4)
#define IGP_PROPERTY                    0x00000004
#define IGP_CONVERSION                  0x00000008
#define IGP_SENTENCE                    0x0000000c
#define IGP_UI                          0x00000010
#define IGP_SETCOMPSTR                  0x00000014
#define IGP_SELECT                      0x00000018

// dwIndex for ImmSetCompositionString API
#define SCS_SETSTR                      (GCS_COMPREADSTR|GCS_COMPSTR)
#define SCS_CHANGEATTR                  (GCS_COMPREADATTR|GCS_COMPATTR)
#define SCS_CHANGECLAUSE                (GCS_COMPREADCLAUSE|GCS_COMPCLAUSE)
#define SCS_SETRECONVERTSTRING          0x00010000
#define SCS_QUERYRECONVERTSTRING        0x00020000

// attribute for COMPOSITIONSTRING Structure
#define ATTR_INPUT                      0x00
#define ATTR_TARGET_CONVERTED           0x01
#define ATTR_CONVERTED                  0x02
#define ATTR_TARGET_NOTCONVERTED        0x03
#define ATTR_INPUT_ERROR                0x04
#define ATTR_FIXEDCONVERTED             0x05

// bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW
#define CFS_DEFAULT                     0x0000
#define CFS_RECT                        0x0001
#define CFS_POINT                       0x0002
#define CFS_FORCE_POSITION              0x0020
#define CFS_CANDIDATEPOS                0x0040
#define CFS_EXCLUDE                     0x0080

// conversion direction for ImmGetConversionList
#define GCL_CONVERSION                  0x0001
#define GCL_REVERSECONVERSION           0x0002
#define GCL_REVERSE_LENGTH              0x0003

// bit field for conversion mode
#define IME_CMODE_ALPHANUMERIC          0x0000
#define IME_CMODE_NATIVE                0x0001
#define IME_CMODE_CHINESE               IME_CMODE_NATIVE
#define IME_CMODE_HANGEUL               IME_CMODE_NATIVE
#define IME_CMODE_JAPANESE              IME_CMODE_NATIVE
#define IME_CMODE_KATAKANA              0x0002  // only effect under IME_CMODE_NATIVE
#define IME_CMODE_LANGUAGE              0x0003
#define IME_CMODE_FULLSHAPE             0x0008
#define IME_CMODE_ROMAN                 0x0010
#define IME_CMODE_CHARCODE              0x0020
#define IME_CMODE_HANJACONVERT          0x0040
#define IME_CMODE_SOFTKBD               0x0080
#define IME_CMODE_NOCONVERSION          0x0100
#define IME_CMODE_EUDC                  0x0200
#define IME_CMODE_SYMBOL                0x0400
#define IME_CMODE_FIXED                 0x0800

#define IME_SMODE_NONE                  0x0000
#define IME_SMODE_PLAURALCLAUSE         0x0001
#define IME_SMODE_SINGLECONVERT         0x0002
#define IME_SMODE_AUTOMATIC             0x0004
#define IME_SMODE_PHRASEPREDICT         0x0008
#define IME_SMODE_CONVERSATION          0x0010

// style of candidate
#define IME_CAND_UNKNOWN                0x0000
#define IME_CAND_READ                   0x0001
#define IME_CAND_CODE                   0x0002
#define IME_CAND_MEANING                0x0003
#define IME_CAND_RADICAL                0x0004
#define IME_CAND_STROKE                 0x0005

// wParam of report message WM_IME_NOTIFY
#define IMN_CLOSESTATUSWINDOW            0x0001
#define IMN_OPENSTATUSWINDOW             0x0002
#define IMN_CHANGECANDIDATE              0x0003
#define IMN_CLOSECANDIDATE               0x0004
#define IMN_OPENCANDIDATE                0x0005
#define IMN_SETCONVERSIONMODE            0x0006
#define IMN_SETSENTENCEMODE              0x0007
#define IMN_SETOPENSTATUS                0x0008
#define IMN_SETCANDIDATEPOS              0x0009
#define IMN_SETCOMPOSITIONFONT           0x000A
#define IMN_SETCOMPOSITIONWINDOW         0x000B
#define IMN_SETSTATUSWINDOWPOS           0x000C
#define IMN_GUIDELINE                    0x000D
#define IMN_PRIVATE                      0x000E

#if(IMM_WINVER >= 0x040A)
// wParam of report message WM_IME_REQUEST
#define IMR_COMPOSITIONWINDOW      0x0001
#define IMR_CANDIDATEWINDOW        0x0002
#define IMR_COMPOSITIONFONT        0x0003
#define IMR_RECONVERTSTRING        0x0004
#define IMR_CONFIRMRECONVERTSTRING 0x0005
#define IMR_QUERYCHARPOSITION      0x0006
#define IMR_DOCUMENTFEED           0x0007
#endif

// error code of ImmGetCompositionString
#define IMM_ERROR_NODATA                (-1)
#define IMM_ERROR_GENERAL               (-2)

// dialog mode of ImmConfigureIME
#define IME_CONFIG_GENERAL              1
#define IME_CONFIG_REGISTERWORD         2
#define IME_CONFIG_SELECTDICTIONARY     3

// dialog mode of ImmEscape
#define IME_ESC_QUERY_SUPPORT           0x0003
#define IME_ESC_RESERVED_FIRST          0x0004
#define IME_ESC_RESERVED_LAST           0x07FF
#define IME_ESC_PRIVATE_FIRST           0x0800
#define IME_ESC_PRIVATE_LAST            0x0FFF
#define IME_ESC_SEQUENCE_TO_INTERNAL    0x1001
#define IME_ESC_GET_EUDC_DICTIONARY     0x1003
#define IME_ESC_SET_EUDC_DICTIONARY     0x1004
#define IME_ESC_MAX_KEY                 0x1005
#define IME_ESC_IME_NAME                0x1006
#define IME_ESC_SYNC_HOTKEY             0x1007
#define IME_ESC_HANJA_MODE              0x1008
#define IME_ESC_AUTOMATA                0x1009
#define IME_ESC_PRIVATE_HOTKEY          0x100a
#define IME_ESC_GETHELPFILENAME         0x100b

// style of word registration
#define IME_REGWORD_STYLE_EUDC          0x00000001
#define IME_REGWORD_STYLE_USER_FIRST    0x80000000
#define IME_REGWORD_STYLE_USER_LAST     0xFFFFFFFF

#if(IMM_WINVER >= 0x040A)
// dwFlags for ImmAssociateContextEx
#define IACE_CHILDREN                   0x0001
#define IACE_DEFAULT                    0x0010
#define IACE_IGNORENOCONTEXT            0x0020

// dwFlags for ImmGetImeMenuItems
#define IGIMIF_RIGHTMENU                0x00000001

// dwType for ImmGetImeMenuItems
#define IGIMII_CMODE                    0x00000001
#define IGIMII_SMODE                    0x00000002
#define IGIMII_CONFIGURE                0x00000004
#define IGIMII_TOOLS                    0x00000008
#define IGIMII_HELP                     0x00000010
#define IGIMII_OTHER                    0x00000020
#define IGIMII_INPUTTOOLS               0x00000040

// fType of IMEMENUITEMINFO structure
#define IMFT_RADIOCHECK 0x00001
#define IMFT_SEPARATOR  0x00002
#define IMFT_SUBMENU    0x00004

// fState of IMEMENUITEMINFO structure
#define IMFS_GRAYED          MFS_GRAYED
#define IMFS_DISABLED        MFS_DISABLED
#define IMFS_CHECKED         MFS_CHECKED
#define IMFS_HILITE          MFS_HILITE
#define IMFS_ENABLED         MFS_ENABLED
#define IMFS_UNCHECKED       MFS_UNCHECKED
#define IMFS_UNHILITE        MFS_UNHILITE
#define IMFS_DEFAULT         MFS_DEFAULT
#endif /* IMM_WINVER >= 0x040A */

// type of soft keyboard
// for Windows Tranditional Chinese Edition
#define SOFTKEYBOARD_TYPE_T1            0x0001
// for Windows Simplified Chinese Edition
#define SOFTKEYBOARD_TYPE_C1            0x0002

#ifdef __cplusplus
}
#endif

#endif  // _IMM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\imaging.h ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   imaging.h
*
* Abstract:
*
*   Public SDK header file for the imaging library
*
* Notes:
*
*   This is hand-coded for now. Eventually it'll be automatically
*   generated from an IDL file.
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _IMAGING_H
#define _IMAGING_H

#include "GdiplusPixelFormats.h"
#include "GdiplusImaging.h"

//
// Imaging library GUIDS:
//  image file format identifiers
//  interface and class identifers
//

#include "imgguids.h"

//
// Image Property types
//

#define TAG_TYPE_BYTE       1   // 8-bit unsigned int
#define TAG_TYPE_ASCII      2   // 8-bit byte containing one 7-bit ASCII code.
                                // NULL terminated.
#define TAG_TYPE_SHORT      3   // 16-bit unsigned int
#define TAG_TYPE_LONG       4   // 32-bit unsigned int
#define TAG_TYPE_RATIONAL   5   // Two LONGs.  The first LONG is the numerator,
                                // the second LONG expresses the denomintor.
#define TAG_TYPE_UNDEFINED  7   // 8-bit byte that can take any value depending
                                // on field definition
#define TAG_TYPE_SLONG      9   // 32-bit singed integer (2's compliment
                                // notation)
#define TAG_TYPE_SRATIONAL  10  // Two SLONGs. First is numerator, second is
                                // denominator.


//
// Image property ID tags (PROPID's from the EXIF tags)
//

#define TAG_EXIF_IFD            0x8769
#define TAG_GPS_IFD             0x8825

#define TAG_NEW_SUBFILE_TYPE    0x00FE
#define TAG_SUBFILE_TYPE        0x00FF
#define TAG_IMAGE_WIDTH         0x0100
#define TAG_IMAGE_HEIGHT        0x0101
#define TAG_BITS_PER_SAMPLE     0x0102
#define TAG_COMPRESSION         0x0103
#define TAG_PHOTOMETRIC_INTERP  0x0106
#define TAG_THRESH_HOLDING      0x0107
#define TAG_CELL_WIDTH          0x0108
#define TAG_CELL_HEIGHT         0x0109
#define TAG_FILL_ORDER          0x010A
#define TAG_DOCUMENT_NAME       0x010D
#define TAG_IMAGE_DESCRIPTION   0x010E
#define TAG_EQUIP_MAKE          0x010F
#define TAG_EQUIP_MODEL         0x0110
#define TAG_STRIP_OFFSETS       0x0111
#define TAG_ORIENTATION         0x0112
#define TAG_SAMPLES_PER_PIXEL   0x0115
#define TAG_ROWS_PER_STRIP      0x0116
#define TAG_STRIP_BYTES_COUNT   0x0117
#define TAG_MIN_SAMPLE_VALUE    0x0118
#define TAG_MAX_SAMPLE_VALUE    0x0119
#define TAG_X_RESOLUTION        0x011A  // Image resolution in width direction
#define TAG_Y_RESOLUTION        0x011B  // Image resolution in height direction
#define TAG_PLANAR_CONFIG       0x011C  // Image data arrangement
#define TAG_PAGE_NAME           0x011D
#define TAG_X_POSITION          0x011E
#define TAG_Y_POSITION          0x011F
#define TAG_FREE_OFFSET         0x0120
#define TAG_FREE_BYTE_COUNTS    0x0121
#define TAG_GRAY_RESPONSE_UNIT  0x0122
#define TAG_GRAY_RESPONSE_CURVE 0x0123
#define TAG_T4_OPTION           0x0124
#define TAG_T6_OPTION           0x0125
#define TAG_RESOLUTION_UNIT     0x0128  // Unit of X and Y resolution
#define TAG_PAGE_NUMBER         0x0129
#define TAG_TRANSFER_FUNCTION   0x012D
#define TAG_SOFTWARE_USED       0x0131
#define TAG_DATE_TIME           0x0132
#define TAG_ARTIST              0x013B
#define TAG_HOST_COMPUTER       0x013C
#define TAG_PREDICTOR           0x013D
#define TAG_WHITE_POINT         0x013E
#define TAG_PRIMAY_CHROMATICS   0x013F
#define TAG_COLOR_MAP           0x0140
#define TAG_HALFTONE_HINTS      0x0141
#define TAG_TILE_WIDTH          0x0142
#define TAG_TILE_LENGTH         0x0143
#define TAG_TILE_OFFSET         0x0144
#define TAG_TILE_BYTE_COUNTS    0x0145
#define TAG_INK_SET             0x014C
#define TAG_INK_NAMES           0x014D
#define TAG_NUMBER_OF_INKS      0x014E
#define TAG_DOT_RANGE           0x0150
#define TAG_TARGET_PRINTER      0x0151
#define TAG_EXTRA_SAMPLES       0x0152
#define TAG_SAMPLE_FORMAT       0x0153
#define TAG_SMIN_SAMPLE_VALUE   0x0154
#define TAG_SMAX_SAMPLE_VALUE   0x0155
#define TAG_TRANSFER_RANGE      0x0156

#define TAG_JPEG_PROC           0x0200
#define TAG_JPEG_INTER_FORMAT   0x0201
#define TAG_JPEG_INTER_LENGTH   0x0202
#define TAG_JPEG_RESTART_INTERVAL     0x0203
#define TAG_JPEG_LOSSLESS_PREDICTORS  0x0205
#define TAG_JPEG_POINT_TRANSFORMS     0x0206
#define TAG_JPEG_Q_TABLES       0x0207
#define TAG_JPEG_DC_TABLES      0x0208
#define TAG_JPEG_AC_TABLES      0x0209

#define TAG_YCbCr_COEFFICIENTS  0x0211
#define TAG_YCbCr_SUBSAMPLING   0x0212
#define TAG_YCbCr_POSITIONING   0x0213
#define TAG_REF_BLACK_WHITE     0x0214

// ICC profile and gamma
#define TAG_ICC_PROFILE         0x0300
#define TAG_GAMMA               0x0301
#define TAG_ICC_PROFILE_DESCRIPTOR  0x0302
#define TAG_SRGB_RENDERING_INTENT   0x0303

#define TAG_IMAGE_TITLE         0x0320

#define TAG_COPYRIGHT           0x8298

// Extra TAGs (Like Adobe Image Information tags etc.)

#define TAG_RESOLUTION_X_UNIT           0x5001
#define TAG_RESOLUTION_Y_UNIT           0x5002
#define TAG_RESOLUTION_X_LENGTH_UNIT    0x5003
#define TAG_RESOLUTION_Y_LENGTH_UNIT    0x5004
#define TAG_PRINT_FLAGS                 0x5005
#define TAG_PRINT_FLAGS_VERSION         0x5006
#define TAG_PRINT_FLAGS_CROP            0x5007
#define TAG_PRINT_FLAGS_BLEEDWIDTH      0x5008
#define TAG_PRINT_FLAGS_BLEEDWIDTHSCALE 0x5009
#define TAG_HALFTONE_LPI                0x500A
#define TAG_HALFTONE_LPI_UNIT           0x500B
#define TAG_HALFTONE_DEGREE             0x500C
#define TAG_HALFTONE_SHAPE              0x500D
#define TAG_HALFTONE_MISC               0x500E
#define TAG_HALFTONE_SCREEN             0x500F
#define TAG_JPEG_QUALITY                0x5010
#define TAG_GRID_SIZE                   0x5011
#define TAG_THUMBNAIL_FORMAT            0x5012  // 1 = JPEG, 0 = RAW RGB
#define TAG_THUMBNAIL_WIDTH             0x5013
#define TAG_THUMBNAIL_HEIGHT            0x5014
#define TAG_THUMBNAIL_COLORDEPTH        0x5015
#define TAG_THUMBNAIL_PLANES            0x5016
#define TAG_THUMBNAIL_RAWBYTES          0x5017
#define TAG_THUMBNAIL_SIZE              0x5018
#define TAG_THUMBNAIL_COMPRESSED_SIZE   0x5019
#define TAG_COLORTRANSFER_FUNCTION      0x501A
#define TAG_THUMBNAIL_DATA              0x501B  // RAW thumbnail bits in JPEG
                                                // format or RGB format depends
                                                // on TAG_THUMBNAIL_FORMAT

// Thumbnail related TAGs
                                                
#define TAG_THUMBNAIL_IMAGE_WIDTH       0x5020  // Thumbnail width
#define TAG_THUMBNAIL_IMAGE_HEIGHT      0x5021  // Thumbnail height
#define TAG_THUMBNAIL_BITS_PER_SAMPLE   0x5022  // Number of bits per component
#define TAG_THUMBNAIL_COMPRESSION       0x5023  // Compression Scheme
#define TAG_THUMBNAIL_PHOTOMETRIC_INTERP 0x5024 // Pixel composition
#define TAG_THUMBNAIL_IMAGE_DESCRIPTION 0x5025  // Image Tile
#define TAG_THUMBNAIL_EQUIP_MAKE        0x5026  // Manufacturer of Image Input
                                                // equipment
#define TAG_THUMBNAIL_EQUIP_MODEL       0x5027  // Model of Image input
                                                // equipment
#define TAG_THUMBNAIL_STRIP_OFFSETS     0x5028  // Image data location
#define TAG_THUMBNAIL_ORIENTATION       0x5029  // Orientation of image
#define TAG_THUMBNAIL_SAMPLES_PER_PIXEL 0x502A  // Number of components
#define TAG_THUMBNAIL_ROWS_PER_STRIP    0x502B  // Number of rows per strip
#define TAG_THUMBNAIL_STRIP_BYTES_COUNT 0x502C  // Bytes per compressed strip
#define TAG_THUMBNAIL_RESOLUTION_X      0x502D  // Resolution in width direction
#define TAG_THUMBNAIL_RESOLUTION_Y      0x502E  // Resolution in height direc
#define TAG_THUMBNAIL_PLANAR_CONFIG     0x502F  // Image data arrangement
#define TAG_THUMBNAIL_RESOLUTION_UNIT   0x5030  // Unit of X and Y Resolution
#define TAG_THUMBNAIL_TRANSFER_FUNCTION 0x5031  // Transfer function
#define TAG_THUMBNAIL_SOFTWARE_USED     0x5032  // Software used
#define TAG_THUMBNAIL_DATE_TIME         0x5033  // File change date and time
#define TAG_THUMBNAIL_ARTIST            0x5034  // Person who created the image
#define TAG_THUMBNAIL_WHITE_POINT       0x5035  // White point chromaticity
#define TAG_THUMBNAIL_PRIMAY_CHROMATICS 0x5036  // Chromaticities of primaries
#define TAG_THUMBNAIL_YCbCr_COEFFICIENTS 0x5037 // Color space transformation
                                                // coefficients
#define TAG_THUMBNAIL_YCbCr_SUBSAMPLING 0x5038  // Subsampling ratio of Y to C
#define TAG_THUMBNAIL_YCbCr_POSITIONING 0x5039  // Y and C position
#define TAG_THUMBNAIL_REF_BLACK_WHITE   0x503A  // Pair of black and white
                                                // reference values
#define TAG_THUMBNAIL_COPYRIGHT         0x503B  // CopyRight holder

// Special JPEG internal values

#define TAG_LUMINANCE_TABLE             0x5090
#define TAG_CHROMINANCE_TABLE           0x5091

// GIF image

#define TAG_FRAMEDELAY                  0x5100
#define TAG_LOOPCOUNT                   0x5101

// PNG Image

#define TAG_PIXEL_UNIT                  0x5110  // Unit specifier for pixel/unit
#define TAG_PIXEL_PER_UNIT_X            0x5111  // Pixels per unit in X
#define TAG_PIXEL_PER_UNIT_Y            0x5112  // Pixels per unit in Y
#define TAG_PALETTE_HISTOGRAM           0x5113  // Palette histogram

// EXIF specific tag

#define EXIF_TAG_EXPOSURE_TIME  0x829A
#define EXIF_TAG_F_NUMBER       0x829D

#define EXIF_TAG_EXPOSURE_PROG  0x8822
#define EXIF_TAG_SPECTRAL_SENSE 0x8824
#define EXIF_TAG_ISO_SPEED      0x8827
#define EXIF_TAG_OECF           0x8828

#define EXIF_TAG_VER            0x9000
#define EXIF_TAG_D_T_ORIG       0x9003 // Date & time of original
#define EXIF_TAG_D_T_DIGITIZED  0x9004 // Date & time of digital data generation

#define EXIF_TAG_COMP_CONFIG    0x9101
#define EXIF_TAG_COMP_BPP       0x9102

#define EXIF_TAG_SHUTTER_SPEED  0x9201
#define EXIF_TAG_APERATURE      0x9202
#define EXIF_TAG_BRIGHTNESS     0x9203
#define EXIF_TAG_EXPOSURE_BIAS  0x9204
#define EXIF_TAG_MAX_APERATURE  0x9205
#define EXIF_TAG_SUBJECT_DIST   0x9206
#define EXIF_TAG_METERING_MODE  0x9207
#define EXIF_TAG_LIGHT_SOURCE   0x9208
#define EXIF_TAG_FLASH          0x9209
#define EXIF_TAG_FOCAL_LENGTH   0x920A
#define EXIF_TAG_MAKER_NOTE     0x927C
#define EXIF_TAG_USER_COMMENT   0x9286
#define EXIF_TAG_D_T_SUBSEC     0x9290  // Date & Time subseconds
#define EXIF_TAG_D_T_ORIG_SS    0x9291  // Date & Time original subseconds
#define EXIF_TAG_D_T_DIG_SS     0x9292  // Date & TIme digitized subseconds

#define EXIF_TAG_FPX_VER        0xA000
#define EXIF_TAG_COLOR_SPACE    0xA001
#define EXIF_TAG_PIX_X_DIM      0xA002
#define EXIF_TAG_PIX_Y_DIM      0xA003
#define EXIF_TAG_RELATED_WAV    0xA004  // related sound file
#define EXIF_TAG_INTEROP        0xA005
#define EXIF_TAG_FLASH_ENERGY   0xA20B
#define EXIF_TAG_SPATIAL_FR     0xA20C  // Spatial Frequency Response
#define EXIF_TAG_FOCAL_X_RES    0xA20E  // Focal Plane X Resolution
#define EXIF_TAG_FOCAL_Y_RES    0xA20F  // Focal Plane Y Resolution
#define EXIF_TAG_FOCAL_RES_UNIT 0xA210  // Focal Plane Resolution Unit
#define EXIF_TAG_SUBJECT_LOC    0xA214
#define EXIF_TAG_EXPOSURE_INDEX 0xA215
#define EXIF_TAG_SENSING_METHOD 0xA217
#define EXIF_TAG_FILE_SOURCE    0xA300
#define EXIF_TAG_SCENE_TYPE     0xA301
#define EXIF_TAG_CFA_PATTERN    0xA302

#define GPS_TAG_VER             0x0000
#define GPS_TAG_LATTITUDE_REF   0x0001
#define GPS_TAG_LATTITUDE       0x0002
#define GPS_TAG_LONGITUDE_REF   0x0003
#define GPS_TAG_LONGITUDE       0x0004
#define GPS_TAG_ALTITUDE_REF    0x0005
#define GPS_TAG_ALTITUDE        0x0006
#define GPS_TAG_GPS_TIME        0x0007
#define GPS_TAG_GPS_SATELLITES  0x0008
#define GPS_TAG_GPS_STATUS      0x0009
#define GPS_TAG_GPS_MEASURE_MODE 0x00A
#define GPS_TAG_GPS_DOP         0x000B  // Measurement precision
#define GPS_TAG_SPEED_REF       0x000C
#define GPS_TAG_SPEED           0x000D
#define GPS_TAG_TRACK_REF       0x000E
#define GPS_TAG_TRACK           0x000F
#define GPS_TAG_IMG_DIR_REF     0x0010
#define GPS_TAG_IMG_DIR         0x0011
#define GPS_TAG_MAP_DATUM       0x0012
#define GPS_TAG_DEST_LAT_REF    0x0013
#define GPS_TAG_DEST_LAT        0x0014
#define GPS_TAG_DEST_LONG_REF   0x0015
#define GPS_TAG_DEST_LONG       0x0016
#define GPS_TAG_DEST_BEAR_REF   0x0017
#define GPS_TAG_DEST_BEAR       0x0018
#define GPS_TAG_DEST_DIST_REF   0x0019
#define GPS_TAG_DEST_DIST       0x001A

#define MAKEARGB(a, r, g, b) \
        (((ARGB) ((a) & 0xff) << ALPHA_SHIFT) | \
         ((ARGB) ((r) & 0xff) <<   RED_SHIFT) | \
         ((ARGB) ((g) & 0xff) << GREEN_SHIFT) | \
         ((ARGB) ((b) & 0xff) <<  BLUE_SHIFT))

typedef PixelFormat PixelFormatID;

// Map COM Flags to GDI+ Flags
#define PIXFMTFLAG_INDEXED      PixelFormatIndexed
#define PIXFMTFLAG_GDI          PixelFormatGDI
#define PIXFMTFLAG_ALPHA        PixelFormatAlpha
#define PIXFMTFLAG_PALPHA       PixelFormatPAlpha
#define PIXFMTFLAG_EXTENDED     PixelFormatExtended
#define PIXFMTFLAG_CANONICAL    PixelFormatCanonical
#define PIXFMT_UNDEFINED        PixelFormatUndefined
#define PIXFMT_DONTCARE         PixelFormatDontCare
#define PIXFMT_1BPP_INDEXED     PixelFormat1bppIndexed
#define PIXFMT_4BPP_INDEXED     PixelFormat4bppIndexed
#define PIXFMT_8BPP_INDEXED     PixelFormat8bppIndexed
#define PIXFMT_16BPP_GRAYSCALE  PixelFormat16bppGrayScale
#define PIXFMT_16BPP_RGB555     PixelFormat16bppRGB555
#define PIXFMT_16BPP_RGB565     PixelFormat16bppRGB565
#define PIXFMT_16BPP_ARGB1555   PixelFormat16bppARGB1555
#define PIXFMT_24BPP_RGB        PixelFormat24bppRGB
#define PIXFMT_32BPP_RGB        PixelFormat32bppRGB
#define PIXFMT_32BPP_ARGB       PixelFormat32bppARGB
#define PIXFMT_32BPP_PARGB      PixelFormat32bppPARGB
#define PIXFMT_48BPP_RGB        PixelFormat48bppRGB
#define PIXFMT_64BPP_ARGB       PixelFormat64bppARGB
#define PIXFMT_64BPP_PARGB      PixelFormat64bppPARGB
#define PIXFMT_24BPP_BGR        PixelFormat24bppBGR
#define PIXFMT_MAX              PixelFormatMax

#define PALFLAG_HASALPHA        PaletteFlagsHasAlpha
#define PALFLAG_GRAYSCALE       PaletteFlagsGrayScale
#define PALFLAG_HALFTONE        PaletteFlagsHalftone

#define IMGLOCK_READ              ImageLockModeRead
#define IMGLOCK_WRITE             ImageLockModeWrite
#define IMGLOCK_USERINPUTBUF      ImageLockModeUserInputBuf

#define IMGFLAG_NONE                ImageFlagsNone
#define IMGFLAG_SCALABLE            ImageFlagsScalable
#define IMGFLAG_HASALPHA            ImageFlagsHasAlpha
#define IMGFLAG_HASTRANSLUCENT      ImageFlagsHasTranslucent
#define IMGFLAG_PARTIALLY_SCALABLE  ImageFlagsPartiallyScalable
#define IMGFLAG_COLORSPACE_RGB      ImageFlagsColorSpaceRGB
#define IMGFLAG_COLORSPACE_CMYK     ImageFlagsColorSpaceCMYK
#define IMGFLAG_COLORSPACE_GRAY     ImageFlagsColorSpaceGRAY
#define IMGFLAG_COLORSPACE_YCBCR    ImageFlagsColorSpaceYCBCR
#define IMGFLAG_COLORSPACE_YCCK     ImageFlagsColorSpaceYCCK
#define IMGFLAG_HASREALDPI          ImageFlagsHasRealDPI
#define IMGFLAG_HASREALPIXELSIZE    ImageFlagsHasRealPixelSize
#define IMGFLAG_READONLY            ImageFlagsReadOnly
#define IMGFLAG_CACHING             ImageFlagsCaching

#define ImageFlag                   ImageFlags


//
// Decoder flags
//

/* Only used in COM interface */
enum DecoderInitFlag
{
    DecoderInitFlagNone        = 0,

    // NOBLOCK indicates that the caller requires non-blocking
    // behavior.  This will be honored only by non-blocking decoders, that
    // is, decoders that don't have the IMGCODEC_BLOCKING_DECODE flag.

    DecoderInitFlagNoBlock     = 0x0001,

    // Choose built-in decoders first before looking at any
    // installed plugin decoders.

    DecoderInitFlagBuiltIn1st  = 0x0002
};

#define DECODERINIT_NONE          DecoderInitFlagNone
#define DECODERINIT_NOBLOCK       DecoderInitFlagNoBlock
#define DECODERINIT_BUILTIN1ST    DecoderInitFlagBuiltIn1st

/* Only used in COM interface */
enum BufferDisposalFlag
{
    BufferDisposalFlagNone,
    BufferDisposalFlagGlobalFree,
    BufferDisposalFlagCoTaskMemFree,
    BufferDisposalFlagUnmapView
};
    
#define DISPOSAL_NONE            BufferDisposalFlagNone
#define DISPOSAL_GLOBALFREE      BufferDisposalFlagGlobalFree
#define DISPOSAL_COTASKMEMFREE   BufferDisposalFlagCoTaskMemFree
#define DISPOSAL_UNMAPVIEW       BufferDisposalFlagUnmapView

//---------------------------------------------------------------------------
// Intepolation hints used by resize/rotation operations
//---------------------------------------------------------------------------
enum InterpolationHint
{
    InterpolationHintDefault,
    InterpolationHintNearestNeighbor,
    InterpolationHintBilinear,
    InterpolationHintAveraging,
    InterpolationHintBicubic
};

#define INTERP_DEFAULT              InterpolationHintDefault
#define INTERP_NEAREST_NEIGHBOR     InterpolationHintNearestNeighbor
#define INTERP_BILINEAR             InterpolationHintBilinear
#define INTERP_AVERAGING            InterpolationHintAveraging
#define INTERP_BICUBIC              InterpolationHintBicubic

#define IMGCODEC_ENCODER          ImageCodecFlagsEncoder
#define IMGCODEC_DECODER          ImageCodecFlagsDecoder
#define IMGCODEC_SUPPORT_BITMAP   ImageCodecFlagsSupportBitmap
#define IMGCODEC_SUPPORT_VECTOR   ImageCodecFlagsSupportVector
#define IMGCODEC_SEEKABLE_ENCODE  ImageCodecFlagsSeekableEncode
#define IMGCODEC_BLOCKING_DECODE  ImageCodecFlagsBlockingDecode

#define IMGCODEC_BUILTIN          ImageCodecFlagsBuiltin
#define IMGCODEC_SYSTEM           ImageCodecFlagsSystem
#define IMGCODEC_USER             ImageCodecFlagsUser

//
// Identifier for channel(s) in a pixel
//
/* Only used internally */
enum ChannelID
{
    ChannelID_Alpha      = 0x00000001,
    ChannelID_Red        = 0x00000002,
    ChannelID_Green      = 0x00000004,
    ChannelID_Blue       = 0x00000008,
    ChannelID_Color      = ChannelID_Red|ChannelID_Green|ChannelID_Blue,
    ChannelID_All        = ChannelID_Color|ChannelID_Alpha,
    
    ChannelID_Intensity  = 0x00010000
};

//
// Data structure for communicating to an image sink
//

/* Only used internally */
enum SinkFlags
{
    // Low-word: shared with ImgFlagx

    SinkFlagsScalable          = ImageFlagsScalable,
    SinkFlagsHasAlpha          = ImageFlagsHasAlpha,
    SinkFlagsPartiallyScalable = ImageFlagsPartiallyScalable,
    
    // High-word

    SinkFlagsTopDown    = 0x00010000,
    SinkFlagsBottomUp   = 0x00020000,
    SinkFlagsFullWidth  = 0x00040000,
    SinkFlagsMultipass  = 0x00080000,
    SinkFlagsComposite  = 0x00100000,
    SinkFlagsWantProps  = 0x00200000
};

#define SINKFLAG_SCALABLE           SinkFlagsScalable
#define SINKFLAG_HASALPHA           SinkFlagsHasAlpha
#define SINKFLAG_PARTIALLY_SCALABLE SinkFlagsPartiallyScalable
#define SINKFLAG_TOPDOWN    SinkFlagsTopDown
#define SINKFLAG_BOTTOMUP   SinkFlagsBottomUp
#define SINKFLAG_FULLWIDTH  SinkFlagsFullWidth
#define SINKFLAG_MULTIPASS  SinkFlagsMultipass
#define SINKFLAG_COMPOSITE  SinkFlagsComposite
#define SINKFLAG_WANTPROPS  SinkFlagsWantProps

/* Only used internally */
struct ImageInfo
{
    GUID RawDataFormat;
    PixelFormat PixelFormat;
    UINT Width, Height;
    UINT TileWidth, TileHeight;
    double Xdpi, Ydpi;
    UINT Flags;
};

//
// Data structure for passing encoder paramaters
//

// NOTE:
//  Should this be in GdiplusTypes.h instead?  Leave imaging.h for stuff
//  shared between the internal stuff and the API?
//
// Note: "EncoderParam" and "EncoderParams" should be removed after SHELL and
// and other team stops using COM interface

// !! To remove
struct EncoderParam
{
    GUID    paramGuid;
    char*   Value;
};

// !! To remove
struct EncoderParams
{
    UINT Count;
    EncoderParam Params[1];
};

//
// Interface and class identifiers
//

interface IImagingFactory;
interface IImage;
interface IBitmapImage;
interface IImageDecoder;
interface IImageEncoder;
interface IImageSink;
interface IBasicBitmapOps;


//--------------------------------------------------------------------------
// Imaging utility factory object
//  This is a CoCreate-able object.
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDA7-072B-11D3-9D7B-0000F81EF32E")
IImagingFactory : public IUnknown
{
public:

    // Create an image object from an input stream
    //  stream doesn't have to seekable
    //  caller should Release the stream if call is successful

    STDMETHOD(CreateImageFromStream)(
        IN IStream* stream,
        OUT IImage** image
        ) = 0;

    // Create an image object from a file

    STDMETHOD(CreateImageFromFile)(
        IN const WCHAR* filename,
        OUT IImage** image
        ) = 0;
    
    // Create an image object from a memory buffer

    STDMETHOD(CreateImageFromBuffer)(
        IN const VOID* buf,
        IN UINT size,
        IN BufferDisposalFlag disposalFlag,
        OUT IImage** image
        ) = 0;

    // Create a new bitmap image object

    STDMETHOD(CreateNewBitmap)(
        IN UINT width,
        IN UINT height,
        IN PixelFormatID pixelFormat,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create a bitmap image from an IImage object

    STDMETHOD(CreateBitmapFromImage)(
        IN IImage* image,
        IN OPTIONAL UINT width,
        IN OPTIONAL UINT height,
        IN OPTIONAL PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create a new bitmap image object on user-supplied memory buffer

    STDMETHOD(CreateBitmapFromBuffer)(
        IN BitmapData* bitmapData,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create an image decoder object to process the given input stream

    STDMETHOD(CreateImageDecoder)(
        IN IStream* stream,
        IN DecoderInitFlag flags,
        OUT IImageDecoder** decoder
        ) = 0;

    // Create an image encoder object that can output data in the
    // specified image file format.

    STDMETHOD(CreateImageEncoderToStream)(
        IN const CLSID* clsid,
        IN IStream* stream,
        OUT IImageEncoder** encoder
        ) = 0;

    STDMETHOD(CreateImageEncoderToFile)(
        IN const CLSID* clsid,
        IN const WCHAR* filename,
        OUT IImageEncoder** encoder
        ) = 0;

    // Get a list of all currently installed image decoders

    STDMETHOD(GetInstalledDecoders)(
        OUT UINT* count,
        OUT ImageCodecInfo** decoders
        ) = 0;

    // Get a list of all currently installed image decoders

    STDMETHOD(GetInstalledEncoders)(
        OUT UINT* count,
        OUT ImageCodecInfo** encoders
        ) = 0;

    // Install an image encoder / decoder
    //  caller should do the regular COM component
    //  installation before calling this method

    STDMETHOD(InstallImageCodec)(
        IN const ImageCodecInfo* codecInfo
        ) = 0;

    // Uninstall an image encoder / decoder

    STDMETHOD(UninstallImageCodec)(
        IN const WCHAR* codecName,
        IN UINT flags
        ) = 0;

    // Create an in-memory IPropertySetStorage object

    STDMETHOD(CreateMemoryPropertyStore)(
        IN OPTIONAL HGLOBAL hmem,
        OUT IPropertySetStorage** propSet
        ) = 0;
};


//--------------------------------------------------------------------------
// Image interface
//  bitmap image
//  vector image
//  procedural image
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDA9-072B-11D3-9D7B-0000F81EF32E")
IImage : public IUnknown
{
public:

    // Get the device-independent physical dimension of the image
    //  in unit of 0.01mm

    STDMETHOD(GetPhysicalDimension)(
        OUT SIZE* size
        ) = 0;

    // Get basic image info

    STDMETHOD(GetImageInfo)(
        OUT ImageInfo* imageInfo
        ) = 0;

    // Set image flags

    STDMETHOD(SetImageFlags)(
        IN UINT flags
        ) = 0;

    // Display the image in a GDI device context

    STDMETHOD(Draw)(
        IN HDC hdc,
        IN const RECT* dstRect,
        IN OPTIONAL const RECT* srcRect
        ) = 0;

    // Push image data into an IImageSink

    STDMETHOD(PushIntoSink)(
        IN IImageSink* sink
        ) = 0;

    // Get a thumbnail representation for the image object

    STDMETHOD(GetThumbnail)(
        IN OPTIONAL UINT thumbWidth,
        IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage
        ) = 0;

    // Get/set the properties in the standard property set
    //  x-res
    //  y-res
    //  gamma
    //  ICC profile
    //  thumbnail
    //  tile width
    //  tile height
    //
    // Property-related methods

    STDMETHOD(GetProperties)(
        IN DWORD mode,
        OUT IPropertySetStorage** propSet
        ) = 0;
};


//--------------------------------------------------------------------------
// Bitmap interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAA-072B-11D3-9D7B-0000F81EF32E")
IBitmapImage : public IUnknown
{
public:

    // Get bitmap dimensions in pixels

    STDMETHOD(GetSize)(
        OUT SIZE* size
        ) = 0;

    // Get bitmap pixel format

    STDMETHOD(GetPixelFormatID)(
        OUT PixelFormatID* pixelFormat
        ) = 0;

    // Access bitmap data in the specified pixel format
    //  must support at least PIXFMT_DONTCARE and
    //  the caninocal formats.

    STDMETHOD(LockBits)(
        IN const RECT* rect,
        IN UINT flags,
        IN PixelFormatID pixelFormat,
        IN OUT BitmapData* lockedBitmapData
        ) = 0;

    STDMETHOD(UnlockBits)(
        IN const BitmapData* lockedBitmapData
        ) = 0;

    // Set/get palette associated with the bitmap image

    STDMETHOD(GetPalette)(
        OUT ColorPalette** palette
        ) = 0;

    STDMETHOD(SetPalette)(
        IN const ColorPalette* palette
        ) = 0;
};


//--------------------------------------------------------------------------
// Interface for performing basic operations on a bitmap image
//  This can be QI'ed from an IBitmapImage object.
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAF-072B-11D3-9D7B-0000F81EF32E")
IBasicBitmapOps : public IUnknown
{
public:

    // Clone an area of the bitmap image

    STDMETHOD(Clone)(
        IN OPTIONAL const RECT* rect,
        OUT IBitmapImage** outbmp
        );

    // Flip the bitmap image in x- and/or y-direction

    STDMETHOD(Flip)(
        IN BOOL flipX,
        IN BOOL flipY,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Resize the bitmap image

    STDMETHOD(Resize)(
        IN UINT newWidth,
        IN UINT newHeight,
        IN PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Rotate the bitmap image by the specified angle

    STDMETHOD(Rotate)(
        IN FLOAT angle,
        IN InterpolationHint hints,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Adjust the brightness of the bitmap image

    STDMETHOD(AdjustBrightness)(
        IN FLOAT percent
        ) = 0;
    
    // Adjust the contrast of the bitmap image

    STDMETHOD(AdjustContrast)(
        IN FLOAT shadow,
        IN FLOAT highlight
        ) = 0;
    
    // Adjust the gamma of the bitmap image

    STDMETHOD(AdjustGamma)(
        IN FLOAT gamma
        ) = 0;
};


//--------------------------------------------------------------------------
// Image decoder interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAB-072B-11D3-9D7B-0000F81EF32E")
IImageDecoder : public IUnknown
{
public:

    // Initialize the image decoder object

    STDMETHOD(InitDecoder)(
        IN IStream* stream,
        IN DecoderInitFlag flags
        ) = 0;

    // Clean up the image decoder object

    STDMETHOD(TerminateDecoder)() = 0;

    // Start decoding the current frame

    STDMETHOD(BeginDecode)(
        IN IImageSink* sink,
        IN OPTIONAL IPropertySetStorage* newPropSet
        ) = 0;

    // Continue decoding

    STDMETHOD(Decode)() = 0;

    // Stop decoding the current frame

    STDMETHOD(EndDecode)(
        IN HRESULT statusCode
        ) = 0;

    // Query multi-frame dimensions

    STDMETHOD(GetFrameDimensionsCount)(
        OUT UINT* count
        ) = 0;

    STDMETHOD(GetFrameDimensionsList)(
        OUT GUID* dimensionIDs,
        IN OUT UINT count
        ) = 0;
    // To be removed
    STDMETHOD(QueryFrameDimensions)(
        OUT UINT* count,
        OUT GUID** dimensionIDs
        ) = 0;

    // Get number of frames for the specified dimension

    STDMETHOD(GetFrameCount)(
        IN const GUID* dimensionID,
        OUT UINT* count
        ) = 0;

    // Select currently active frame

    STDMETHOD(SelectActiveFrame)(
        IN const GUID* dimensionID,
        IN UINT frameIndex
        ) = 0;

    // Get basic information about the image

    STDMETHOD(GetImageInfo)(
        OUT ImageInfo* imageInfo
        ) = 0;

    // Get image thumbnail

    STDMETHOD(GetThumbnail)(
        IN OPTIONAL UINT thumbWidth,
        IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage
        ) = 0;

    // Property/metadata related methods

    STDMETHOD(GetProperties)(
        OUT IPropertySetStorage** propSet
        ) = 0;

    // Query decoder parameters

    STDMETHOD(QueryDecoderParam)(
        IN GUID     Guid
        ) = 0;

    // Set decoder parameters

    STDMETHOD(SetDecoderParam)(
        IN GUID     Guid,
        IN UINT     Length,
        IN PVOID    Value
        ) = 0;
    
    // Property related functions

    STDMETHOD(GetPropertyCount)(
        OUT UINT* numOfProperty
        ) = 0;

    STDMETHOD(GetPropertyIdList)(
        IN UINT numOfProperty,
  	    IN OUT PROPID* list
        ) = 0;

    STDMETHOD(GetPropertyItemSize)(
        IN PROPID propId, 
        OUT UINT* size
        ) = 0;
    
    STDMETHOD(GetPropertyItem)(
        IN PROPID propId,
        IN UINT propSize,
        IN OUT PropertyItem* buffer
        ) = 0;

    STDMETHOD(GetPropertySize)(
        OUT UINT* totalBufferSize,
		OUT UINT* numProperties
        ) = 0;

    STDMETHOD(GetAllPropertyItems)(
        IN UINT totalBufferSize,
        IN UINT numProperties,
        IN OUT PropertyItem* allItems
        ) = 0;

    STDMETHOD(RemovePropertyItem)(
        IN PROPID   propId
        ) = 0;

    STDMETHOD(SetPropertyItem)(
        IN PropertyItem item
        ) = 0;
};


//--------------------------------------------------------------------------
// Image decode sink interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAE-072B-11D3-9D7B-0000F81EF32E")
IImageSink : public IUnknown
{
public:

    // Begin the sink process

    STDMETHOD(BeginSink)(
        IN OUT ImageInfo* imageInfo,
        OUT OPTIONAL RECT* subarea
        ) = 0;

    // End the sink process

    STDMETHOD(EndSink)(
        IN HRESULT statusCode
        ) = 0;

    // Pass the color palette to the image sink

    STDMETHOD(SetPalette)(
        IN const ColorPalette* palette
        ) = 0;

    // Ask the sink to allocate pixel data buffer

    STDMETHOD(GetPixelDataBuffer)(
        IN const RECT* rect,
        IN PixelFormatID pixelFormat,
        IN BOOL lastPass,
        OUT BitmapData* bitmapData
        ) = 0;

    // Give the sink pixel data and release data buffer

    STDMETHOD(ReleasePixelDataBuffer)(
        IN const BitmapData* bitmapData
        ) = 0;

    // Push pixel data

    STDMETHOD(PushPixelData)(
        IN const RECT* rect,
        IN const BitmapData* bitmapData,
        IN BOOL lastPass
        ) = 0;

    // Push raw image data

    STDMETHOD(PushRawData)(
        IN const VOID* buffer,
        IN UINT bufsize
        ) = 0;

    // Methods for passing metadata / properties

    STDMETHOD(PushProperties)(
        IN IPropertySetStorage* propSet
        ) = 0;
    
    STDMETHOD(NeedTransform)(
        OUT UINT* rotation
        ) = 0;

    STDMETHOD(NeedRawProperty)(
        ) = 0;
    
    STDMETHOD(PushRawInfo)(
        IN OUT void* info
        ) = 0;

    STDMETHOD(GetPropertyBuffer)(
        IN     UINT            uiTotalBufferSize,
        IN OUT PropertyItem**  ppBuffer
        ) = 0;
    
    STDMETHOD(PushPropertyItems)(
        IN UINT             numOfItems,
        IN UINT             uiTotalBufferSize,
        IN PropertyItem*    item
        ) = 0;
};


//--------------------------------------------------------------------------
// Image encoder interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAC-072B-11D3-9D7B-0000F81EF32E")
IImageEncoder : public IUnknown
{
public:

    // Initialize the image encoder object

    STDMETHOD(InitEncoder)(
        IN IStream* stream
        ) = 0;
    
    // Clean up the image encoder object

    STDMETHOD(TerminateEncoder)() = 0;

    // Get an IImageSink interface for encoding the next frame

    STDMETHOD(GetEncodeSink)(
        OUT IImageSink** sink
        ) = 0;
    
    // Set active frame dimension

    STDMETHOD(SetFrameDimension)(
        IN const GUID* dimensionID
        ) = 0;
    
    // Query encoder parameters

    STDMETHOD(QueryEncoderParam)(
        OUT EncoderParams** Params
    ) = 0;

    // Set encoder parameters

    STDMETHOD(SetEncoderParam)(
        IN EncoderParams* Param
        ) = 0;
    
    STDMETHOD(GetEncoderParameterListSize)(
       	OUT UINT* size
        ) = 0;

    STDMETHOD(GetEncoderParameterList)(
        IN UINT	  size,
        OUT EncoderParameters* Params
        ) = 0;

    STDMETHOD(SetEncoderParameters)(
        IN const EncoderParameters* Param
        ) = 0;
};


//--------------------------------------------------------------------------
// Imaging library error codes
//
// !!! TODO
//  How does one pick a facility code?
//
// Standard error code used:
//  E_INVALIDARG
//  E_OUTOFMEMORY
//  E_NOTIMPL
//  E_ACCESSDENIED
//  E_PENDING
//--------------------------------------------------------------------------

#define FACILITY_IMAGING        0x87b
#define MAKE_IMGERR(n)          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_IMAGING, n)
#define IMGERR_OBJECTBUSY       MAKE_IMGERR(1)
#define IMGERR_NOPALETTE        MAKE_IMGERR(2)
#define IMGERR_BADLOCK          MAKE_IMGERR(3)
#define IMGERR_BADUNLOCK        MAKE_IMGERR(4)
#define IMGERR_NOCONVERSION     MAKE_IMGERR(5)
#define IMGERR_CODECNOTFOUND    MAKE_IMGERR(6)
#define IMGERR_NOFRAME          MAKE_IMGERR(7)
#define IMGERR_ABORT            MAKE_IMGERR(8)
#define IMGERR_FAILLOADCODEC    MAKE_IMGERR(9)

#endif // !_IMAGING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\imgguids.h ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   imgguids.h
*
* Abstract:
*
*   GUIDs defined and used by the imaging library
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

//
// Image file format identifiers
//

DEFINE_GUID(IMGFMT_UNDEFINED, 0xb96b3ca9,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_MEMORYBMP, 0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_BMP, 0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_EMF, 0xb96b3cac,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_WMF, 0xb96b3cad,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_JPEG, 0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_PNG, 0xb96b3caf,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_GIF, 0xb96b3cb0,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_TIFF, 0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_EXIF, 0xb96b3cb2,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_PHOTOCD, 0xb96b3cb3,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_FLASHPIX, 0xb96b3cb4,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_ICO, 0xb96b3cb5,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//
// Interface and class identifiers
//

DEFINE_GUID(IID_IImagingFactory, 0x327abda7,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(CLSID_ImagingFactory, 0x327abda8,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImage, 0x327abda9,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IBitmapImage, 0x327abdaa,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageDecoder, 0x327abdab,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageEncoder, 0x327abdac,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageSink, 0x327abdae,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IBasicBitmapOps, 0x327abdaf,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//
// Predefined multi-frame dimension IDs
//

DEFINE_GUID(FRAMEDIM_TIME, 0x6aedbd6d,0x3fb5,0x418a,0x83,0xa6,0x7f,0x45,0x22,0x9d,0xc8,0x72);
DEFINE_GUID(FRAMEDIM_RESOLUTION, 0x84236f7b,0x3bd3,0x428f,0x8d,0xab,0x4e,0xa1,0x43,0x9c,0xa3,0x15);
DEFINE_GUID(FRAMEDIM_PAGE, 0x7462dc86,0x6180,0x4c7e,0x8e,0x3f,0xee,0x73,0x33,0xa7,0xa4,0x83);

//
// Property sets
//

DEFINE_GUID(FMTID_ImageInformation, 0xe5836cbe,0x5eef,0x4f1d,0xac,0xde,0xae,0x4c,0x43,0xb6,0x08,0xce);
DEFINE_GUID(FMTID_JpegAppHeaders, 0x1c4afdcd,0x6177,0x43cf,0xab,0xc7,0x5f,0x51,0xaf,0x39,0xee,0x85);

//
// Decoder parameter sets
//
DEFINE_GUID(DECODER_TRANSCOLOR, 0xb7a98c8f,0xdce7,0x457d,0xbf,0xa5,0xce,0xa7,0x1b,0xd1,0x4d,0xd6);
DEFINE_GUID(DECODER_TRANSRANGE, 0xabeed189,0xd988,0x4d03,0xb4,0x25,0x57,0x10,0x55,0xc7,0x6a,0xd1);
DEFINE_GUID(DECODER_OUTPUTCHANNEL, 0x2ff8f51e,0x724d,0x45fe,0x86,0xce,0x17,0x77,0xa0,0x56,0xda,0x60);
DEFINE_GUID(DECODER_ICONRES, 0x5c656eec,0xe94f,0x45ba,0xa6,0xf6,0x10,0x62,0xe8,0x5f,0x4a,0x7f);
 
//
// Encoder parameter sets
//
DEFINE_GUID(ENCODER_COMPRESSION, 0xe09d739d,0xccd4,0x44ee,0x8e,0xba,0x3f,0xbf,0x8b,0xe4,0xfc,0x58);
DEFINE_GUID(ENCODER_COLORDEPTH, 0x66087055,0xad66,0x4c7c,0x9a,0x18,0x38,0xa2,0x31,0x0b,0x83,0x37);
DEFINE_GUID(ENCODER_SCANMETHOD, 0x3a4e2661,0x3109,0x4e56,0x85,0x36,0x42,0xc1,0x56,0xe7,0xdc,0xfa);
DEFINE_GUID(ENCODER_VERSION, 0x24d18c76,0x814a,0x41a4,0xbf,0x53,0x1c,0x21,0x9c,0xcc,0xf7,0x97);
DEFINE_GUID(ENCODER_RENDERMETHOD, 0x6d42c53a,0x229a,0x4825,0x8b,0xb7,0x5c,0x99,0xe2,0xb9,0xa8,0xb8);
DEFINE_GUID(ENCODER_QUALITY, 0x1d5be4b5,0xfa4a,0x452d,0x9c,0xdd,0x5d,0xb3,0x51,0x05,0xe7,0xeb);
DEFINE_GUID(ENCODER_ROTATION,0x109555d4,0x2ab6,0x4379,0xa8,0x3f,0x5d,0x78,0xfa,0x53,0x8c,0x45);
DEFINE_GUID(ENCODER_TRANSFORMATION,0x8d0eb2d1,0xa58e,0x4ea8,0xaa,0x14,0x10,0x80,0x74,0xb7,0xb6,0xf9);
DEFINE_GUID(ENCODER_LUMINANCE_TABLE,0xedb33bce,0x0266,0x4a77,0xb9,0x04,0x27,0x21,0x60,0x99,0xe7,0x17);
DEFINE_GUID(ENCODER_CHROMINANCE_TABLE,0xf2e455dc,0x09b3,0x4316,0x82,0x60,0x67,0x6a,0xda,0x32,0x48,0x1c);
DEFINE_GUID(ENCODER_SAVE_FLAG,0x292266fc,0xac40,0x47bf,0x8c, 0xfc, 0xa8, 0x5b, 0x89, 0xa6, 0x55, 0xde);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\richole.h ===
#ifndef _RICHOLE_
#define _RICHOLE_

/*
 *	RICHOLE.H
 *
 *	Purpose:
 *		OLE Extensions to the Rich Text Editor
 *
 *	Copyright (c) 1985-1996, Microsoft Corporation
 */

// Structure passed to GetObject and InsertObject
typedef struct _reobject
{
	DWORD			cbStruct;			// Size of structure
	LONG			cp;					// Character position of object
	CLSID			clsid;				// Class ID of object
	LPOLEOBJECT		poleobj;			// OLE object interface
	LPSTORAGE		pstg;				// Associated storage interface
	LPOLECLIENTSITE	polesite;			// Associated client site interface
	SIZEL			sizel;				// Size of object (may be 0,0)
	DWORD			dvaspect;			// Display aspect to use
	DWORD			dwFlags;			// Object status flags
	DWORD			dwUser;				// Dword for user's use
} REOBJECT;

// Flags to specify which interfaces should be returned in the structure above
#define REO_GETOBJ_NO_INTERFACES	(0x00000000L)
#define REO_GETOBJ_POLEOBJ			(0x00000001L)
#define REO_GETOBJ_PSTG				(0x00000002L)
#define REO_GETOBJ_POLESITE			(0x00000004L)
#define REO_GETOBJ_ALL_INTERFACES	(0x00000007L)

// Place object at selection
#define REO_CP_SELECTION ((ULONG) -1L)

// Use character position to specify object instead of index
#define REO_IOB_SELECTION ((ULONG) -1L)
#define REO_IOB_USE_CP ((ULONG) -2L)

// Object flags
#define REO_NULL			(0x00000000L)	// No flags
#define REO_READWRITEMASK	(0x000007FFL)	// Mask out RO bits
#define REO_CANROTATE		(0x00000080L)	// Object knows how to display itself rotated
#define REO_OWNERDRAWSELECT	(0x00000040L)	// Owner draws selected object
#define REO_DONTNEEDPALETTE	(0x00000020L)	// Object doesn't need palette
#define REO_BLANK			(0x00000010L)	// Object is blank
#define REO_DYNAMICSIZE		(0x00000008L)	// Object defines size always
#define REO_INVERTEDSELECT	(0x00000004L)	// Object drawn all inverted if sel
#define REO_BELOWBASELINE	(0x00000002L)	// Object sits below the baseline
#define REO_RESIZABLE		(0x00000001L)	// Object may be resized
#define REO_USEASBACKGROUND	(0x00000400L)	// Use object as background picture
#define REO_WRAPTEXTAROUND  (0x00000200L)	// Wrap text around the object
#define REO_ALIGNTORIGHT	(0x00000100L)	// Align object to view's right side
											// Only makes sense when REO_WRAPTEXTAROUND is set

#define REO_LINK			(0x80000000L)	// Object is a link (RO)
#define REO_STATIC			(0x40000000L)	// Object is static (RO)
#define REO_SELECTED		(0x08000000L)	// Object selected (RO)
#define REO_OPEN			(0x04000000L)	// Object open in its server (RO)
#define REO_INPLACEACTIVE	(0x02000000L)	// Object in place active (RO)
#define REO_HILITED			(0x01000000L)	// Object is to be hilited (RO)
#define REO_LINKAVAILABLE	(0x00800000L)	// Link believed available (RO)
#define REO_GETMETAFILE		(0x00400000L)	// Object requires metafile (RO)

// Flags for IRichEditOle::GetClipboardData(),
// IRichEditOleCallback::GetClipboardData() and
// IRichEditOleCallback::QueryAcceptData()
#define RECO_PASTE			(0x00000000L)	// paste from clipboard
#define RECO_DROP			(0x00000001L)	// drop
#define RECO_COPY			(0x00000002L)	// copy to the clipboard
#define RECO_CUT			(0x00000003L)	// cut to the clipboard
#define RECO_DRAG			(0x00000004L)	// drag

/*
 *	IRichEditOle
 *
 *	Purpose:
 *		Interface used by the client of RichEdit to perform OLE-related
 *		operations.
 *
 *	//$ REVIEW:
 *		The methods herein may just want to be regular Windows messages.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOle

DECLARE_INTERFACE_(IRichEditOle, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOle methods ***
    STDMETHOD(GetClientSite) (THIS_ LPOLECLIENTSITE FAR * lplpolesite) PURE;
	STDMETHOD_(LONG,GetObjectCount) (THIS) PURE;
	STDMETHOD_(LONG,GetLinkCount) (THIS) PURE;
	STDMETHOD(GetObject) (THIS_ LONG iob, REOBJECT FAR * lpreobject,
						  DWORD dwFlags) PURE;
    STDMETHOD(InsertObject) (THIS_ REOBJECT FAR * lpreobject) PURE;
	STDMETHOD(ConvertObject) (THIS_ LONG iob, REFCLSID rclsidNew,
							  LPCSTR lpstrUserTypeNew) PURE;
	STDMETHOD(ActivateAs) (THIS_ REFCLSID rclsid, REFCLSID rclsidAs) PURE;
	STDMETHOD(SetHostNames) (THIS_ LPCSTR lpstrContainerApp,
							 LPCSTR lpstrContainerObj) PURE;
	STDMETHOD(SetLinkAvailable) (THIS_ LONG iob, BOOL fAvailable) PURE;
	STDMETHOD(SetDvaspect) (THIS_ LONG iob, DWORD dvaspect) PURE;
	STDMETHOD(HandsOffStorage) (THIS_ LONG iob) PURE;
	STDMETHOD(SaveCompleted) (THIS_ LONG iob, LPSTORAGE lpstg) PURE;
	STDMETHOD(InPlaceDeactivate) (THIS) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(ImportDataObject) (THIS_ LPDATAOBJECT lpdataobj,
									CLIPFORMAT cf, HGLOBAL hMetaPict) PURE;
};
typedef         IRichEditOle FAR * LPRICHEDITOLE;

/*
 *	IRichEditOleCallback
 *
 *	Purpose:
 *		Interface used by the RichEdit to get OLE-related stuff from the
 *		application using RichEdit.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOleCallback

DECLARE_INTERFACE_(IRichEditOleCallback, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOleCallback methods ***
	STDMETHOD(GetNewStorage) (THIS_ LPSTORAGE FAR * lplpstg) PURE;
    STDMETHOD(GetInPlaceContext) (THIS_ LPOLEINPLACEFRAME FAR * lplpFrame,
								  LPOLEINPLACEUIWINDOW FAR * lplpDoc,
								  LPOLEINPLACEFRAMEINFO lpFrameInfo) PURE;
	STDMETHOD(ShowContainerUI) (THIS_ BOOL fShow) PURE;
	STDMETHOD(QueryInsertObject) (THIS_ LPCLSID lpclsid, LPSTORAGE lpstg,
									LONG cp) PURE;
	STDMETHOD(DeleteObject) (THIS_ LPOLEOBJECT lpoleobj) PURE;
	STDMETHOD(QueryAcceptData) (THIS_ LPDATAOBJECT lpdataobj,
								CLIPFORMAT FAR * lpcfFormat, DWORD reco,
								BOOL fReally, HGLOBAL hMetaPict) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(GetDragDropEffect) (THIS_ BOOL fDrag, DWORD grfKeyState,
									LPDWORD pdwEffect) PURE;
	STDMETHOD(GetContextMenu) (THIS_ WORD seltype, LPOLEOBJECT lpoleobj,
									CHARRANGE FAR * lpchrg,
									HMENU FAR * lphmenu) PURE;
};
typedef         IRichEditOleCallback FAR * LPRICHEDITOLECALLBACK;

#ifndef MAC
// RichEdit interface GUIDs
DEFINE_GUID(IID_IRichEditOle,         0x00020D00, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IRichEditOleCallback, 0x00020D03, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
#endif // !MAC

#endif // _RICHOLE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\warning.h ===
#pragma warning(3:4092)   // sizeof returns 'unsigned long'
#pragma warning(3:4121)   // structure is sensitive to alignment
#pragma warning(3:4125)   // decimal digit in octal sequence
#pragma warning(3:4130)   // logical operation on address of string constant
#pragma warning(3:4132)   // const object should be initialized
#pragma warning(4:4206)   // Source File is empty
#pragma warning(4:4101)   // Unreferenced local variable
#pragma warning(4:4208)   // delete[exp] - exp evaluated but ignored
#pragma warning(3:4212)   // function declaration used ellipsis
#pragma warning(3:4242)   // convertion possible loss of data
#pragma warning(4:4312)   // conversion to type of greater size
#pragma warning(error:4700)    // Local used w/o being initialized
#pragma warning(error:4259)    // pure virtual function was not defined
#pragma warning(error:4071)    // no function prototype given
#pragma warning(error:4072)    // no function prototype given (fastcall)
#pragma warning(error:4171)    // no function prototype given (old style)
#pragma warning(error:4013)    // 'function' undefined - assuming extern returning int
#pragma warning(error:4551)    // Function call missing argument list
#pragma warning(error:4806)    // unsafe operation involving type 'bool'
#pragma warning(4:4509)   // use of SEH with destructor
#pragma warning(4:4177)   // pragma data_seg s/b at global scope
#pragma warning(disable:4786)  // identifier was truncated to 255 chararcers in debug information.

#if 0
#pragma warning(3:4100)   // Unreferenced formal parameter
#pragma warning(3:4701)   // local may be used w/o init
#pragma warning(3:4702)   // Unreachable code
#pragma warning(3:4705)   // Statement has no effect
#pragma warning(3:4706)   // assignment w/i conditional expression
#pragma warning(3:4709)   // command operator w/o index expression
#endif

#ifndef __cplusplus
#undef try
#undef except
#undef finally
#undef leave
#define try                         __try
#define except                      __except
#define finally                     __finally
#define leave                       __leave
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\ourtypes.h ===
/*
 *	@doc INTERNAL
 *
 *	@module	OURTYPES.H	-- Miscellaneous type declarations |
 *	
 *	Original Author: <nl>
 *		DGreen
 *
 *	History: <nl>
 *		02/19/98  KeithCu  Cleaned up
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _OURTYPES_H_
#define _OURTYPES_H_

// WM_SYSKEYDOWN masks for lKeyData
#define SYS_ALTERNATE		0x20000000
#define SYS_PREVKEYSTATE	0x40000000


#ifndef WINDOWS
#define WINDOWS
#endif

#define CchSzAToSzW(_szA, _szW, _cbSzW)	\
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (_szA), -1, (_szW),	\
						(_cbSzW) / sizeof(WCHAR))

#define CchSzWToSzA(_szW, _szA, _cbSzA)	\
	WideCharToMultiByte(CP_ACP, 0, (_szW), -1, (_szA), (_cbSzA), NULL, NULL)

#define UsesMakeOLESTRX(_cchMax)	WCHAR szWT[_cchMax]
#define UsesMakeOLESTR				UsesMakeOLESTRX(MAX_PATH)
#define MakeOLESTR(_szA)	\
	(CchSzAToSzW((_szA), szWT, sizeof(szWT)) ? szWT : NULL)

#endif //_OURTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\imeshare.h ===
/******************************************************************************
**	I M E  S H A R E  .  H													 **
**			KentU,KotaroY/MSKK											 	 **
**																			 **
**   With this piece of code, the client Applications will be able to refer	 **
**	the same TrueInline style described in the Registry.					 **
**	 This library should allow clients to get decoration style (either color **
**	and various underlines)													 **
**	 For underlines, applications are allowed to substitute some of 		 **
**	predefined underlines to other predefined one.							 **
**																			 **
**	Oct./23/1995 : Start writing.											 **
**  Jun./19/1997 : Add new CPP interface.	[KotaroY]						 **
**  Sep./02/1997 : Rewrite. True object-based architecture.	[KotaroY]		 **
**																			 **
******************************************************************************/

#ifndef __IMESHARE_H__
#define __IMESHARE_H__

#include <windows.h>

#ifdef IMESHARE_CPL
#include "resource.h"
#endif

#define IMECDECL __cdecl
#define IMESHAREAPI  __declspec( dllimport )

typedef WORD	LID;


#define UINTIMEBOGUS 0xffffffff


#define IMESATTR_MIN					0
#define IMESATTR_INPUT 					ATTR_INPUT
#define IMESATTR_TARGET_CONVERTED		ATTR_TARGET_CONVERTED
#define	IMESATTR_CONVERTED				ATTR_CONVERTED
#define IMESATTR_TARGET_NOTCONVERTED	ATTR_TARGET_NOTCONVERTED
#define IMESATTR_INPUT_ERROR			ATTR_INPUT_ERROR
#define IMESATTR_FIXEDCONVERTED			5
#define IMESATTR_MAX					5
#define CATR (IMESATTR_MAX - IMESATTR_MIN + 1)


#define IMESTY_UL_MIN				2002
#define IMESTY_UL_NONE				2002
#define	IMESTY_UL_SINGLE			2003
//OLD #define IMESTY_UL_DOUBLE			2004
#define IMESTY_UL_DOTTED			2005
#define IMESTY_UL_THICK				2006
//OLD #define IMESTY_UL_DASHLINE			2007
//OLD #define IMESTY_UL_DOTDASH			2008
//OLD #define IMESTY_UL_DOTDOTDASH		2009
//OLD #define IMESTY_UL_WAVE				2010
#define IMESTY_UL_LOWER				2011
#define IMESTY_UL_THICKLOWER		2012
#define IMESTY_UL_THICKDITHLOWER	2013
#define IMESTY_UL_DITHLOWER			2014
#define IMESTY_UL_MAX				2014
#define CIMEUL (IMESTY_UL_MAX - IMESTY_UL_MIN + 1)
				//WARNING: Based on an assumption that all IDSsty definitions id are consecutive.


//Naming convention IdstyIMEShare[return type][property][subgrouping]
#define IdstyIMEShareSubText			0x0000
#define IdstyIMEShareSubBack			0x0001
#define IdstyIMEShareSubUl				0x0002
#define IdstyIMEShareFBold				0x0100
#define IdstyIMEShareFItalic			0x0200
#define IdstyIMEShareFUl				0x0300
#define IdstyIMEShareUKul				0x0400
#define IdstyIMEShareFWinCol			0x0500
#define IdstyIMEShareFFundCol			0x0600
#define IdstyIMEShareFRGBCol			0x0700
#define IdstyIMEShareFSpecCol			0x0800
#define IdstyIMEShareRGBCol				0x0900
#define IdstyIMEShareFSpecColText		0x0a00
#define IdstyIMEShareFSpecColWindow		0x0b00

#ifdef IMESHARE_CPL
#define IdstyIMEShareUSpecColId			0x0c00
#define IdstyIMEShareUWinColId			0x0d00
#define IdstyIMEShareUFundColId			0x0e00
#define IdstyIMEShareGrfSty				0x0f00
#endif	// IMESHARE_CPL

#define COLOR_RGB  0	  //RGB()
#define COLOR_WIN  1	  //Windows' color scheme.
#define COLOR_FUND 2	  //one of 16 fundamental color
#define COLOR_SPEC 3	  //special color.


#ifdef IMESHARE_CPL
#define STY_PLAIN					IDS_STYPLAIN
#define	STY_BOLD					IDS_STYBOLD
#define STY_ITALIC					IDS_STYITALIC

#define IMECOL_SPEC_MIN				IDS_COLAPPTEXT
#define IMECOL_APPTEXT					IDS_COLAPPTEXT
#define IMECOL_APPWINDOW				IDS_COLAPPWINDOW
#define IMECOL_SPEC_MAX				IDS_COLAPPWINDOW + 1
#define COL_FUND_MIN				IDS_COLBLACK
#define COL_BLACK					IDS_COLBLACK
#define COL_BLUE					IDS_COLBLUE
#define COL_CYAN					IDS_COLCYAN
#define COL_GREEN					IDS_COLGREEN
#define COL_MAGENTA					IDS_COLMAGENTA
#define COL_RED						IDS_COLRED
#define COL_YELLOW					IDS_COLYELLOW
#define COL_WHITE					IDS_COLWHITE
#define COL_DKBLUE					IDS_COLDKBLUE
#define COL_DKCYAN					IDS_COLDKCYAN
#define COL_DKGREEN					IDS_COLDKGREEN
#define COL_DKMAGENTA				IDS_COLDKMAGENTA
#define COL_DKRED					IDS_COLDKRED
#define COL_DKYELLOW				IDS_COLDKYELLOW
#define COL_DKGRAY					IDS_COLDKGRAY
#define COL_LTGRAY					IDS_COLLTGRAY
#define COL_FUND_MAX				IDS_COLLTGRAY + 1

#define COL_WIN_MIN					IDS_COLSCROLLBAR
#define COL_WIN_SCROLLBAR 			IDS_COLSCROLLBAR
#define COL_WIN_BACKGROUND			IDS_COLBACKGROUND
#define COL_WIN_ACTIVECAPTION		IDS_COLACTIVECAPTION
#define COL_WIN_INACTIVECAPTION		IDS_COLINACTIVECAPTION
#define COL_WIN_MENU				IDS_COLMENU
#define COL_WIN_WINDOW				IDS_COLWINDOW
#define COL_WIN_WINDOWFRAME			IDS_COLWINDOWFRAME
#define COL_WIN_MENUTEXT			IDS_COLMENUTEXT
#define COL_WIN_WINDOWTEXT			IDS_COLWINDOWTEXT
#define COL_WIN_CAPTIONTEXT			IDS_COLCAPTIONTEXT
#define COL_WIN_ACTIVEBORDER		IDS_COLACTIVEBORDER
#define COL_WIN_INACTIVEBORDER		IDS_COLINACTIVEBORDER
#define COL_WIN_APPWORKSPACE		IDS_COLAPPWORKSPACE
#define COL_WIN_HIGHLIGHT			IDS_COLHIGHLIGHT
#define COL_WIN_HIGHLIGHTTEXT		IDS_COLHIGHLIGHTTEXT
#define COL_WIN_BTNFACE				IDS_COLBTNFACE
#define COL_WIN_BTNSHADOW			IDS_COLBTNSHADOW
#define COL_WIN_GRAYTEXT			IDS_COLGRAYTEXT
#define COL_WIN_BTNTEXT				IDS_COLBTNTEXT
#define COL_WIN_INACTIVECAPTIONTEXT	IDS_COLINACTIVECAPTIONTEXT
#define COL_WIN_SHADOW				IDS_COLSHADOW
#define COL_WIN_BTNHIGHLIGHT		IDS_COLBTNHIGHLIGHT
#define COL_WIN_BTNDKSHADOW			IDS_COLBTNDKSHADOW
#define COL_WIN_BTNLIGHT			IDS_COLBTNLIGHT
#define COL_WIN_INFOTEXT			IDS_COLINFOTEXT
#define COL_WIN_INFOWINDOW			IDS_COLINFOWINDOW
#define COL_WIN_MAC					COL_WIN_INFOWINDOW + 1

#define RGB_BLACK	(RGB(  0,  0,  0))
#define RGB_BLUE	(RGB(  0,  0,255))
#define RGB_CYAN	(RGB(  0,255,255))
#define RGB_GREEN   (RGB(  0,255,  0))
#define RGB_MAGENTA (RGB(255,  0,255))
#define RGB_RED		(RGB(255,  0,  0))
#define RGB_YELLOW  (RGB(255,255,  0))
#define RGB_WHITE   (RGB(255,255,255))
#define RGB_DKBLUE  (RGB(  0,  0,127))
#define RGB_DKCYAN  (RGB(  0,127,127))
#define RGB_DKGREEN (RGB(  0,127,  0))
#define RGB_DKMAGENTA (RGB(127,  0,127))
#define RGB_DKRED   (RGB(127,  0,  0))
#define RGB_DKYELLOW (RGB(127,127,  0))
#define RGB_DKGRAY  (RGB(127,127,127))
#define RGB_LTGRAY  (RGB(192,192,192))

#endif	// IMESHARE_CPL


typedef struct {
	union {
		UINT grfsty;
		struct {
			UINT	fBold:1;
			UINT	fItalic:1;
			UINT	fUl:1;
			UINT	idUl:(sizeof(UINT) * 8 - 3);
		};
	};
} GRFSTY;




#ifdef __cplusplus

class CIMEShare{
public:
	virtual void	IMECDECL CustomizeIMEShare()=0;
	virtual BOOL	IMECDECL FSupportSty(UINT sty, UINT styAltered)=0;
	virtual LID		IMECDECL LidSetLid(LID lid)=0;
	virtual LID		IMECDECL LidGetLid(void)=0;
	virtual DWORD	IMECDECL DwGetIMEStyle(const UINT attr, const UINT idsty)=0;
	virtual BOOL	IMECDECL FDeleteIMEShare(void)=0;
	virtual DWORD	IMECDECL DwGetIMEStyleCpl(const UINT attr, const UINT idsty)=0;
	virtual BOOL	IMECDECL FSetIMEStyleCpl(const UINT attr, const UINT idsty, DWORD dwval)=0;
	virtual BOOL	IMECDECL FSaveIMEShareCpl(void)=0;
};

#else  //!__cplusplus

typedef struct _CIMEShare CIMEShare;

typedef struct _CIMEShareVtbl{
	void (IMECDECL *CustomizeIMEShare)(CIMEShare *This);
	BOOL (IMECDECL *FSupportSty)(CIMEShare *This, UINT sty, UINT styAlered);
	unsigned short (IMECDECL *LidSetLid)(CIMEShare *This, unsigned short lid);
    unsigned short (IMECDECL *LidGetLid)(CIMEShare *This);
	DWORD (IMECDECL *DwGetIMEStyle)(CIMEShare *This, UINT attr, UINT idsty);
	BOOL (IMECDECL *FDeleteIMEShare)(CIMEShare *This);

	DWORD (IMECDECL *DwGetIMEStyleCpl)(CIMEShare *This, UINT attr, UINT idsty);
	BOOL (IMECDECL *FSetIMEStyleCpl)(CIMEShare *This, UINT attr, UINT idsty, DWORD dwVal);
	BOOL (IMECDECL *FSaveIMEShareCpl)(CIMEShare *This);
} CIMEShareVtbl;

typedef struct _CIMEShare{
	const CIMEShareVtbl *lpVtbl;
} CIMEShare;

#endif //__cplusplus


#ifdef __cplusplus
extern "C"{
#endif
CIMEShare * IMECDECL PIMEShareCreate();
typedef CIMEShare * (IMECDECL FNPIMESHARECREATE)(void);
#ifdef __cplusplus
}
#endif




#ifdef OBSOLETE

typedef struct {
	UINT colorId;
	union {
		COLORREF	rgb;
		UINT		colorWin;
		UINT		colorSpec;
		UINT		colorFund;
	};
} IMECOLORSTY;

typedef struct {
	union {
		GRFSTY	grfsty;
		struct {
			UINT	fBold:1;
			UINT	fItalic:1;
			UINT	fUl:1;
			UINT	idUl:(sizeof(UINT) * 8 - 3);
		};
	};

	union {
		IMECOLORSTY colorstyText;
		struct {
			UINT	colorIdText;
			union {
				COLORREF	rgbText;
				UINT		colorWinText;
				UINT		colorSpecText;
				UINT		colorFundText;
			};
		};
	};

	union {
		IMECOLORSTY colorstyBack;
		struct {
			UINT	colorIdBack;
			union {
				COLORREF	rgbBack;
				UINT		colorWinBack;
				UINT		colorSpecBack;
				UINT		colorFundBack;
			};
		};
	};

	union {
		IMECOLORSTY colorstyUl;
		struct {
			UINT	colorIdUl;
			union {
				COLORREF	rgbUl;
				UINT		colorWinUl;
				UINT		colorSpecUl;
				UINT		colorFundUl;
			};
		};
	};
} IMESTYLE;

#ifdef __cplusplus
extern "C"{
#endif
//Functions

#if 0	// no need to redefine DllMain.
#ifndef PEGASUS
IMESHAREAPI BOOL	WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
#endif
#endif

IMESHAREAPI BOOL	IMECDECL FInitIMEShare();
IMESHAREAPI void	IMECDECL CustomizeIMEShare();
IMESHAREAPI void	IMECDECL EndIMEShare();

// Multilingual support
LID IMECDECL LidGetLid(void);
LID IMECDECL LidSetLid(LID NewValue);

//Refresh notify support
IMESHAREAPI BOOL	IMECDECL FRefreshStyle();

//substitution
IMESHAREAPI BOOL	IMECDECL FSupportSty(UINT sty, UINT styAltered);

//style handling                            
IMESHAREAPI const IMESTYLE * IMECDECL PIMEStyleFromAttr(const UINT attr);
IMESHAREAPI const IMECOLORSTY * IMECDECL PColorStyleTextFromIMEStyle(const IMESTYLE * pimestyle);
IMESHAREAPI const IMECOLORSTY * IMECDECL PColorStyleBackFromIMEStyle(const IMESTYLE * pimestyle);
#define PIMESTY(x) (PIMEStyleFromAttr(x))
#define PTEXTIMECOL(x) (PColorStyleTextFromIMEStyle(PIMESTY(x)))
#define PBACKIMECOL(x) (PColorStyleBackFromIMEStyle(PIMESTY(x)))
IMESHAREAPI BOOL	IMECDECL FBoldIMEStyle(const IMESTYLE *pimestyle);
IMESHAREAPI BOOL	IMECDECL FItalicIMEStyle(const IMESTYLE *pimestyle);
IMESHAREAPI BOOL	IMECDECL FUlIMEStyle(const IMESTYLE *pimestyle);
IMESHAREAPI UINT	IMECDECL IdUlIMEStyle(const IMESTYLE *pimestyle);

//color handling
IMESHAREAPI BOOL	IMECDECL FWinIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FFundamentalIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FRGBIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FSpecialIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FSpecialTextIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FSpecialWindowIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI COLORREF	IMECDECL RGBFromIMEColorStyle(const IMECOLORSTY *pcolorstyle);

#ifdef IMESHARE_CPL
IMESHAREAPI UINT	IMECDECL IdSpecialFromIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI UINT	IMECDECL IdWinFromIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI UINT	IMECDECL IdFundamentalFromIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI GRFSTY	IMECDECL GrfStyIMEStyle(const IMESTYLE *pimestyle);
IMESHAREAPI BOOL	IMECDECL FGetIMEStyleAttr(IMESTYLE *pimestyle, const UINT attr);
IMESHAREAPI BOOL	IMECDECL FSetIMEStyleAttr(const IMESTYLE *pimestyle, const UINT attr);
IMESHAREAPI BOOL	IMECDECL FSetIMEColorStyle(UINT attr, BOOL fTextCol, UINT id, DWORD col);
IMESHAREAPI BOOL	IMECDECL FSetIMEStyle(const UINT attr, BOOL fBold, BOOL fItalic, BOOL fUl, UINT idUl);
IMESHAREAPI BOOL	IMECDECL FSaveIMEShareSetting(void);
#endif // IMESHARE_CPL
#ifdef __cplusplus
}
#endif
#endif // OBSOLETE


#endif	// __IMESHARE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\autonum.h ===
#ifndef AUTONUM_DEFINED
#define AUTONUM_DEFINED

#include "lsdefs.h"

#include "plscbk.h"
#include "plsrun.h"
#include "pilsobj.h"
#include "plnobj.h"
#include "pdobj.h"
#include "pfmti.h"
#include "pbrko.h"
#include "pobjdim.h"
#include "pdispi.h"
#include "plsdocin.h"
#include "pposichn.h"
#include "plocchnk.h"
#include "plsfgi.h"
#include "pheights.h"
#include "plsqin.h"
#include "plsqout.h"
#include "plssubl.h"
#include "breakrec.h"
#include "brkcond.h"
#include "fmtres.h"
#include "mwcls.h"
#include "lstxtcfg.h"
#include "lskalign.h"
#include "lskjust.h"
#include "plsdnode.h"
#include "plstbcon.h"
#include "plschp.h"
#include "lstflow.h"
#include "brkkind.h"

	LSERR WINAPI AutonumCreateILSObj(POLS, PLSC,  PCLSCBK, DWORD, PILSOBJ*);
	/* CreateILSObj
	 *  pols (IN):
	 *  plsc (IN): LS context
	 *  plscbk (IN): callbacks
	 *  idObj (IN): id of the object
	 *  &pilsobj (OUT): object ilsobj
	*/

	LSERR  SetAutonumConfig(PILSOBJ , const LSTXTCFG*);
	/* SetAutonumConfig
	*	pilsobj	(IN): object ilsobj
	*	plstxtconfig  (IN): definition of special characters 
	*/


	LSERR WINAPI AutonumDestroyILSObj(PILSOBJ);
	/* DestroyILSObj
	 *  pilsobj (IN): object ilsobj
	*/

	LSERR WINAPI AutonumSetDoc(PILSOBJ, PCLSDOCINF);
	/* SetDoc
	 *  pilsobj (IN): object ilsobj
	 *  lsdocinf (IN): initialization data at document level
	*/

	LSERR WINAPI AutonumCreateLNObj(PCILSOBJ, PLNOBJ*);
	/* CreateLNObj
	 *  pilsobj (IN): object ilsobj
	 *  &plnobj (OUT): object lnobj
	*/

	LSERR WINAPI AutonumDestroyLNObj(PLNOBJ);
	/* DestroyLNObj
	 *  plnobj (OUT): object lnobj
	*/

	LSERR WINAPI AutonumFmt(PLNOBJ, PCFMTIN, FMTRES*);
	/* Fmt
	 *  plnobj (IN): object lnobj
	 *  pfmtin (IN): formatting input
	 *  &fmtres (OUT): formatting result
	*/

	LSERR WINAPI AutonumTruncateChunk(PCLOCCHNK, PPOSICHNK);
	/* Truncate
	 *  plocchnk (IN): locchnk to truncate
	 *  posichnk (OUT): truncation point
	*/

	LSERR WINAPI AutonumFindPrevBreakChunk(PCLOCCHNK, PCPOSICHNK, BRKCOND, PBRKOUT);
	/* FindPrevBreakChunk
	 *  plocchnk (IN): locchnk to break
	 *  pposichnk (IN): place to start looking for break
	 *  brkcond (IN): recommmendation about the break after chunk
	 *  &brkout (OUT): results of breaking
	*/

	LSERR WINAPI AutonumFindNextBreakChunk(PCLOCCHNK, PCPOSICHNK, BRKCOND, PBRKOUT);
	/* FindNextBreakChunk
	 *  plocchnk (IN): locchnk to break
	 *  pposichnk (IN): place to start looking for break
	 *  brkcond (IN): recommmendation about the break before chunk
	 *  &brkout (OUT): results of breaking
	*/

	LSERR WINAPI AutonumForceBreakChunk(PCLOCCHNK, PCPOSICHNK, PBRKOUT);
	/* ForceBreakChunk
	 *  plocchnk (IN): locchnk to break
	 *  pposichnk (IN): place to start looking for break
	 *  &brkout (OUT): results of breaking
	*/

	LSERR WINAPI AutonumSetBreak(PDOBJ, BRKKIND, DWORD, BREAKREC*, DWORD*);
	/* SetBreak
	 *  pdobj (IN): dobj which is broken
	 *  brkkind (IN): Previous/Next/Force/Imposed was chosen
	 *  rgBreakRecord (IN): array of break records
	 *	nBreakRecord (IN): size of array
	 *	nActualBreakRecord (IN): actual number of used elements in array
	*/

	LSERR WINAPI AutonumGetSpecialEffectsInside(PDOBJ, UINT*);
	/* GetSpecialEffects
	 *  pdobj (IN): dobj
	 *  &EffectsFlags (OUT): Special effects inside of this object
	*/

	LSERR WINAPI AutonumCalcPresentation(PDOBJ, long, LSKJUST, BOOL);
	/* CalcPresentation
	 *  pdobj (IN): dobj
	 *  dup (IN): dup of dobj
	 *  lskj (IN) current justification mode
	 *  fLastOnLine (IN) this boolean is ignored by autonumbering object
	*/

	LSERR WINAPI AutonumQueryPointPcp(PDOBJ, PCPOINTUV, PCLSQIN, PLSQOUT);
	/* QueryPointPcp
	 *  pdobj (IN): dobj to query
	 * 	ppointuvQuery (IN): query point (uQuery,vQuery)
     *	plsqin (IN): query input
     *	plsqout (OUT): query output
	*/
	
	LSERR WINAPI AutonumQueryCpPpoint(PDOBJ, LSDCP, PCLSQIN, PLSQOUT);
	/* QueryCpPpoint
	 *  pdobj (IN): dobj to query
	 *  dcp (IN):  dcp for the query
     *	plsqin (IN): query input
     *	plsqout (OUT): query output
	*/
	
	LSERR WINAPI AutonumEnumerate(PDOBJ, PLSRUN, PCLSCHP, LSCP, LSDCP, LSTFLOW, BOOL,
												BOOL, const POINT*, PCHEIGHTS, long);
	/* Enum object
	 *  pdobj (IN): dobj to enumerate
	 *  plsrun (IN): from DNODE
	 *  plschp (IN): from DNODE
	 *  cpFirst (IN): from DNODE
	 *  dcp (IN): from DNODE
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryNeeded (IN):
	 *  pptStart (IN): starting position (top left), iff fGeometryNeeded
	 *  pheightsPres(IN): from DNODE, relevant iff fGeometryNeeded
	 *  dupRun(IN): from DNODE, relevant iff fGeometryNeeded
	*/


	LSERR WINAPI AutonumDisplay(PDOBJ, PCDISPIN);
	/* Display
	 *  pdobj (IN): dobj to display
	 *  pdispin (IN): input display info
	*/

	LSERR WINAPI AutonumDestroyDobj(PDOBJ);
	/* DestroyDObj
	 *  pdobj (IN): dobj to destroy
	*/


	void AllignAutonum95(long, long, LSKALIGN, long, PLSDNODE, long*, long*);
	/* 
	 * AllignAutotonum95 
	 *	durSpaceAnm (IN) : space after autonumber
	 *	durWidthAnm (IN) : distance from indent to main text
	 *	lskalign (IN) : allignment for autonumber
	 *	durUsed (IN) : width of autonumbering text
	 *	plsdnAnmAfter( IN) : tab dnode to put durAfter
	 *	pdurBefore (OUT) : calculated distance from indent to autonumber 
	 *	pdurAfter (OUT) : calculated distance from autonumber to main text
	 */

	LSERR AllignAutonum(PLSTABSCONTEXT, LSKALIGN, BOOL, PLSDNODE , long, long, long*, long*);
	/* 
	 * AllignAutonum95 
	 *	plstabscontext (IN) : tabs context
	 *	lskalign (IN) : allignment for autonumber
	 *	fAllignmentAfter (IN) : is there tab after autonumber
	 *	plsdnAnmAfter ( IN) : tab dnode to put durAfter
	 *	urAfterAnm (IN) : pen position after autonumber
	 *	durUsed (IN) : width of autonumbering text
	 *	pdurBefore (OUT) : calculated distance from indent to autonumber 
	 *	pdurAfter (OUT) : calculated distance from autonumber to main text
	 */

#endif /* AUTONUM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\break.h ===
#ifndef BREAK_DEFINED
#define BREAK_DEFINED

#include "lsdefs.h"
#include "fmtres.h"
#include "objdim.h"
#include "plssubl.h"
#include "breakrec.h"
#include "brkpos.h"
#include "brkkind.h"
#include "endres.h"
#include "plsdnode.h"



LSERR BreakGeneralCase(
					  PLSC,				/* IN: LineServices context		*/
					  BOOL,  			/* fHardStop				*/
					  DWORD,			/* IN: size of the output array			*/
					  BREAKREC*,		/* OUT: output array of break records	*/
					  DWORD*,			/* OUT:actual number of records in array*/
					  LSDCP*,			/* OUT: dcpDepend				*/
					  LSCP*,			/* OUT: cpLim					*/
					  ENDRES*,			/* OUT: how line ended			*/
					  BOOL*);			/* OUT fSuccessful: false means insufficient fetch */

LSERR BreakQuickCase(
					  PLSC,			/* IN: LineServices context		*/
					  BOOL,  		/* fHardStop				*/
					  LSDCP*,		/* OUT: dcpDepend				*/
					  LSCP*,		/* OUT: cpLim					*/
					  BOOL* ,		/* OUT: fSuccessful?			*/
					  ENDRES*);		/* OUT: how line ended			*/

LSERR TruncateSublineCore(
							PLSSUBL,		/* IN: subline context			*/
							long,			/* IN: urColumnMax				*/
							LSCP*);			/* OUT: cpTruncate 				*/

LSERR FindPrevBreakSublineCore(
							PLSSUBL,		/* IN: subline context			*/
							BOOL,			/* IN: fFirstSubline					*/
							LSCP,			/* IN: truncation cp			*/
							long,			/* IN: urColumnMax				*/
							BOOL*,			/* OUT: fSuccessful?			*/
							LSCP*,			/* OUT: cpBreak					*/
							POBJDIM,		/* OUT: objdimSub up to break	*/
							BRKPOS*);		/* OUT: Before/Inside/After		*/


LSERR FindNextBreakSublineCore(
							PLSSUBL,		/* IN: subline context			*/
							BOOL,			/* IN: fFirstSubline					*/
							LSCP,			/* IN: truncation cp			*/
							long,			/* IN: urColumnMax				*/
							BOOL*,			/* OUT: fSuccessful?			*/
							LSCP*,			/* OUT: cpBreak					*/
							POBJDIM,		/* OUT: objdimSub up to break	*/			
							BRKPOS*);		/* OUT: Before/Inside/After		*/

LSERR ForceBreakSublineCore(
							PLSSUBL,		/* IN: subline context			*/
							BOOL,			/* IN: fFirstSubline					*/
							LSCP,			/* IN: truncation cp			*/
							long,			/* IN: urColumnMax				*/
							LSCP*,			/* OUT: cpBreak					*/
							POBJDIM,		/* OUT: objdimSub up to break	*/			
							BRKPOS*);		/* OUT: Before/Inside/After		*/

LSERR SetBreakSublineCore(
							PLSSUBL,		/* IN: subline context			*/
							BRKKIND,		/* IN: Prev/Next/Force/Imposed	*/					
							DWORD,			/* IN: size of the output array			*/
							BREAKREC*,		/* OUT: output array of break records	*/
							DWORD*);		/* OUT:actual number of records in array*/

LSERR WINAPI SqueezeSublineCore(
							  PLSSUBL,		/* IN: subline context		*/
							  long,			/* IN: durTarget			*/
							  BOOL*,		/* OUT: fSuccessful?		*/
							  long*);		/* OUT: if nof successful, 
													extra dur 			*/

LSERR  GetMinDurBreaksCore	(PLSC plsc, /* IN: LineServices context		*/
							 long* pdurMinInclTrail, /* OUT: min dur between breaks including trailing area */
							 long* pdurMinExclTrail);/* OUT: min dur between breaks excluding trailing area */

LSERR  GetLineDurCore		(PLSC plsc, /* IN: LineServices context		*/
							 long* pdurInclTrail, /* OUT: dur of line incl. trailing area */
							 long* pdurExclTrail);/* OUT: dur of line excl. trailing area */

LSERR FCanBreakBeforeNextChunkCore(PLSC  plsc,  /* IN: LineServices context		*/
								   PLSDNODE plsdn,	/* IN: Last DNODE of the current chunk */
								   BOOL* pfCanBreakBeforeNextChunk); /* OUT: Can break before next chunk ? */



#endif /* BREAK_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\disptext.h ===
#ifndef DISPTEXT_DEFINED
#define DISPTEXT_DEFINED

#include "lsidefs.h"
#include "pdobj.h"
#include "pdispi.h"
#include "lskjust.h"

LSERR WINAPI DisplayText(PDOBJ, PCDISPIN);
LSERR WINAPI CalcPresentationText(PDOBJ, long, LSKJUST, BOOL);

#endif /* ndef DISPTEXT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\dispmain.h ===
#ifndef DISPMAIN_DEFINED
#define DISPMAIN_DEFINED

#include "lsidefs.h"

#include "lsc.h"
#include "lsdnode.h"
#include "lssubl.h"
#include "lstflow.h"
#include "plssubl.h"
#include "dispmisc.h"
#include "dispi.h"
#include "dispul.h"	


LSERR DisplaySublineCore(		
						PLSSUBL,		/* subline to display */
						const POINT*, 	/* pptOrg (x,y) starting point */
						UINT, 			/* kDisp : transparent or opaque */
						const RECT*, 	/* &rcClip: clipping rect (x,y) */
						long, 			/* upLimUnderline */
						long); 			/* upStartLine */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\dispul.h ===
#ifndef DISPUL_DEFINED
#define DISPUL_DEFINED

#include "lsdefs.h"
#include "dispi.h"
#include "plsdnode.h"

/* all we need to remember about a merge is in this structure - enough to draw UL */
/* in case of bad metrics, only first three are filled. */
typedef struct {
	UINT kul;						/* kind of UL-line, simple, wavy, etc, opaque to LS */
    DWORD cNumberOfLines;			/* number of lines in UL: possible values 1,2 */
	long vpUnderlineOrigin;			/* UnderlineOrigin position */
	long dvpFirstUnderlineOffset;	/* from UnderlineOrigin position */
	long dvpFirstUnderlineSize;		
	long dvpGapBetweenLines;		
	long dvpSecondUnderlineSize;	
} LSULMETRIC;

/* all we need to remember - enough to draw SS */
typedef struct {
	UINT kul;				/* kind of SS-line, same as UL-types */
    DWORD cNumberOfLines;	/* number of lines in SS: possible values 1,2 */
	long dvp1stSSSize;		/* SS line width */
	long dvp1stSSOffset;	/* position relative to the baseline, filled page direction (normally > 0) */
	long dvp2ndSSSize;		/* 1stSS is common for single and double SS, save space */
	long dvp2ndSSOffset;	/* normally dvp1stSSOffset < dvp2ndSSOffset */
} LSSTRIKEMETRIC;

LSERR GetUnderlineMergeMetric(
				PLSC, 
				PLSDNODE, 			/* dnode to start UL merging */
				POINTUV,			/* starting pen point (u,v) */
				long,				/* upLimUnderline */
				LSTFLOW, 
				LSCP, 				/* cpLimBreak */
				LSULMETRIC*,	 	/* merge metrics */
				int*, 				/* nodes to display in the merge */
				BOOL*);				/* good metrics? */

LSERR DrawUnderlineMerge(
				PLSC, 
				PLSDNODE, 			/* dnode to start underlining */
				const POINT*, 		/* pptOrg (x,y) */
				int, 				/* nodes to display in the merge */
				long,				/* upStartUnderline */
				BOOL,				/* good metrics? */
				const LSULMETRIC*, 	/* merge metrics */
				UINT, 				/* kDisp : transparent or opaque */
				const RECT*, 		/* &rcClip: clipping rect (x,y) */
				long,				/* upLimUnderline */
				LSTFLOW); 


LSERR GetStrikeMetric(
				PLSC,
				PLSDNODE, 			/* dnode to strike */
				LSTFLOW, 
				LSSTRIKEMETRIC*,	/* strike metrics */
				BOOL*);				/* good metrics? */

LSERR StrikeDnode(PLSC,
				PLSDNODE, 				/* dnode to start underlining */
				const POINT*, 			/* pptOrg (x,y) */
				POINTUV,				/* starting pen point (u,v) */
				const LSSTRIKEMETRIC*,	/* merge metrics */
				UINT, 					/* kDisp : transparent or opaque */
				const RECT*, 			/* &rcClip: clipping rect (x,y) */
				long,					/* upLimUnderline */
				LSTFLOW); 

#endif /* ndef DISPUL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\dispmisc.h ===
#ifndef DISPMISC_DEFINED
#define DISPMISC_DEFINED

#include "lsidefs.h"
#include "plsdnode.h"
#include "plssubl.h"
#include "lstflow.h"


// 			Rectangle (usually clip rectangle) in local coordinate system
//
//	U grows to the right, v grows up, so normally upLeft < upRight, vpTop > vpBottom
//	Upper left corner belongs to the rectangle, lower right corner doesn't.
//	That means:
//	upRight - upLeft equals dupLength.
//	Rectangle that contains one point (0,0) is {0,0,-1,1}.
//	Shading rectangle for dnode starting at (u0,v0) is {u0, v0+dvpAscent, u0+dupLen, v0-dvpDescent}
//	Note this last line reflects the big LS convention: 
//			v0+dvpAscent belongs to line, v0-dvpDescent doesn't.


typedef struct tagRECTUV
{
    long    upLeft;
    long    vpTop;
    long    upRight;
    long    vpBottom;
} RECTUV;

typedef const RECTUV* 	PCRECTUV;
typedef RECTUV* 		PRECTUV;


/* 	CreateDisplayTree sets plsdnUpTemp in sublines to be displayed with given subline,
 *	rejects wrong sublines, submitted for display, sets fAcceptedForDisplay in good ones
 */

void CreateDisplayTree(PLSSUBL);		/* IN: the uppermost subline */

/* 	DestroyDisplayTree nulls plsdnUpTemp in sublines displayed with given subline.
 */
 
void DestroyDisplayTree(PLSSUBL);		/* IN: the uppermost subline */


/* AdvanceToNextNode moves to the next dnode to be displayed (maybe changing sublines),
 * updating current pen, returning pointer to the next dnode 
 */

PLSDNODE AdvanceToNextDnode(PLSDNODE,	/* IN: current dnode */
							LSTFLOW, 	/* IN: current (main) text flow */
							POINTUV*);	/* INOUT: current pen position (u,v) */

PLSDNODE AdvanceToFirstDnode(PLSSUBL,	/* IN: main subline */
							LSTFLOW, 	/* IN: current (main) text flow */
							POINTUV*);	/* INOUT: current pen position (u,v) */

/* AdvanceToNextSubmittingDnode moves to the next dnode which submitted for display,
 * updating current pen, returning pointer to the next dnode 
 */

PLSDNODE AdvanceToNextSubmittingDnode(
							PLSDNODE,	/* IN: current dnode */
							LSTFLOW, 	/* IN: current (main) text flow */
							POINTUV*);	/* INOUT: current pen position (u,v) */

PLSDNODE AdvanceToFirstSubmittingDnode(
							PLSSUBL,	/* IN: main subline */
							LSTFLOW, 	/* IN: current (main) text flow */
							POINTUV*);	/* INOUT: current pen position (u,v) */

							
// NB Victork - following functions were used only for upClipLeft, upClipRight optimization.
// If we'll decide that we do need that optimization after Word integration - I'll uncomment.


#ifdef NEVER
/* RectUVFromRectXY calculates (clip) rectangle in local (u,v) coordinates given
								(clip) rectangle in (x,y) and point of origin */

void RectUVFromRectXY(const POINT*, 	/* IN: point of origin for local coordinates (x,y) */
						const RECT*,	/* IN: input rectangle (x,y) */
						LSTFLOW, 		/* IN: local text flow */
						PRECTUV);		/* OUT: output rectangle (u,v) */


/* RectXYFromRectUV calculates rectangle in (x,y) coordinates given
					rectangle in local (u,v) coordinates and point of origin (x,y) */

void RectXYFromRectUV(const POINT*, 	/* IN: point of origin for local coordinates (x,y) */
						PCRECTUV,		/* IN: input rectangle (u,v) */
						LSTFLOW, 		/* IN: local text flow */
						RECT*);			/* OUT: output rectangle (x,y) */
#endif /* NEVER */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\chnutils.h ===
#ifndef CHNUTILS_DEFINED
#define CHNUTILS_DEFINED

/*   Chunk & group chunk utilities   							*/

#include "lsidefs.h"
#include "plsdnode.h"
#include "lsgrchnk.h"
#include "plocchnk.h"
#include "pposichn.h"
#include "dninfo.h"
#include "plschcon.h"
#include "lstflow.h"
#include "lschcon.h"
#include "lscbk.h"
#include "port.h"
#include "posichnk.h"


/*  MACROS -----------------------------------------------------------------*/

#define  FlushSublineChunkContext(plschnkcontext)		\
					(plschnkcontext)->FLocationValid = fFalse;\
					(plschnkcontext)->FChunkValid = fFalse;\
					(plschnkcontext)->FGroupChunk = fFalse;\
					(plschnkcontext)->FBorderInside = fFalse;\
					(plschnkcontext)->grpfTnti = 0;\
					(plschnkcontext)->fNTIAppliedToLastChunk = fFalse;\
					(plschnkcontext)->locchnkCurrent.clschnk = 0;\


#define  InitSublineChunkContext(plschnkcontext, urFirst, vrFirst)		\
					FlushSublineChunkContext(plschnkcontext); \
					(plschnkcontext)->urFirstChunk = (urFirst); \
					(plschnkcontext)->vrFirstChunk = (vrFirst); 

#define   IdObjFromChnk(plocchnk)	(Assert((plocchnk)->clschnk > 0),	\
		  						((plocchnk)->plschnk[0].plschp->idObj))

#define InvalidateChunk(plschnkcontext) \
	(plschnkcontext)->FChunkValid = fFalse;

#define InvalidateChunkLocation(plschnkcontext) \
	(plschnkcontext)->FLocationValid = fFalse;

#define SetNTIAppliedToLastChunk(plschnkcontext) \
		(plschnkcontext)->fNTIAppliedToLastChunk = fTrue;

#define FlushNTIAppliedToLastChunk(plschnkcontext) \
		(plschnkcontext)->fNTIAppliedToLastChunk = fFalse;

#define FNTIAppliedToLastChunk(plschnkcontext) \
		(plschnkcontext)->fNTIAppliedToLastChunk


#define FIsChunkBoundary(plsdn, idObjChnk, cpBase)  \
		(((plsdn) == NULL) || \
		 (FIsDnodeBorder(plsdn) ? fFalse : \
			((FIsDnodePen(plsdn))  \
			||  ((plsdn)->fTab) \
			|| ((idObjChnk) != IdObjFromDnode(plsdn)) \
			||  (((cpBase) >= 0) ? ((plsdn)->cpFirst < 0) : ((plsdn)->cpFirst >= 0)))))
/* last check verifies that we are not crossing boundaries of autonumber */

#define SetUrColumnMaxForChunks(plschnkcontext, Ur)   \
	(plschnkcontext)->locchnkCurrent.lsfgi.urColumnMax = Ur;

#define GetUrColumnMaxForChunks(plschnkcontext)   \
		(plschnkcontext)->locchnkCurrent.lsfgi.urColumnMax 

#define GetChunkArray(plschnkcontext)  (plschnkcontext)->locchnkCurrent.plschnk

#define GetChunkSize(plschnkcontext)  (plschnkcontext)->locchnkCurrent.clschnk


#define 		FlushNominalToIdealState(plschnkcontext)  \
				(plschnkcontext)->grpfTnti = 0;

#define   		SetNominalToIdealFlags(plschnkcontext, plschp)  \
				AddNominalToIdealFlags(((plschnkcontext)->grpfTnti), plschp);

#define DnodeFromChunk(plschunkcontext, ichnk) \
		(Assert(((DWORD) ichnk) < (plschunkcontext)->locchnkCurrent.clschnk), \
		 (plschunkcontext)->pplsdnChunk[ichnk])

#define LastDnodeFromChunk(plschunkcontext) \
		 DnodeFromChunk(plschunkcontext, (plschunkcontext)->locchnkCurrent.clschnk - 1)

/* L O C  D N O D E  F R O M  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: LocDnodeFromChunk
    %%Contact: igorzv

Parameters:
	plschuncontext	-	(IN) LineServices context
	ichnk			-	(IN) index in chunk
	pplsdn			-	(OUT) dnode to fill in
	ppoint				(OUT) position of dnode

----------------------------------------------------------------------------*/

#define LocDnodeFromChunk(plschunkcontext, ichnk, pplsdn, ppoint) \
	Assert((DWORD)(ichnk) < (plschunkcontext)->locchnkCurrent.clschnk); \
	Assert((ichnk) != ichnkOutside); \
	(ppoint)->u = (plschunkcontext)->locchnkCurrent.ppointUvLoc[ichnk].u; \
	(ppoint)->v = (plschunkcontext)->locchnkCurrent.ppointUvLoc[ichnk].v; \
	*(pplsdn) = (plschunkcontext)->pplsdnChunk[ichnk];


	
#define 	ApplyFFirstSublineToChunk(plschunkcontext, fFirstSubline) \
	(plschunkcontext)->locchnkCurrent.lsfgi.fFirstOnLine = \
		FIsFirstOnLine(plschunkcontext->pplsdnChunk[0]) \
									&& fFirstSubline ;	


#define GetFFirstOnLineChunk(plocchnk) \
	(plocchnk)->lsfgi.fFirstOnLine 


#define NumberOfDnodesInChunk(plocchnk) \
			(plocchnk)->clschnk


#define GetPointChunkStart(plocchnk, point) \
			point.u = plocchnk->lsfgi.urPen;  \
			point.v = plocchnk->lsfgi.vrPen; 

#define PosInChunkAfterChunk(plocchnk, posichnk) \
			posichnk.ichnk = plocchnk->clschnk - 1; \
			posichnk.dcp = plocchnk->plschnk[plocchnk->clschnk - 1].dcp;

/* ROUTINES ----------------------------------------------------------------------*/


LSERR 	FillChunkArray(PLSCHUNKCONTEXT plschunkcontext ,	/* IN: LS chunk context */
					   PLSDNODE plsdn);	 				/* IN: last dnode in a chunk  */


LSERR CollectChunkAround(PLSCHUNKCONTEXT plschnukcontext,	/* IN: LS chunk context */
					     PLSDNODE plsdn,	 		    /* IN:  dnode to collect chunk arround  */
						 LSTFLOW  lstflow,				/* IN: text flow */
						 POINTUV* ppoint);  			/* IN: position of dnode */

LSERR CollectPreviousChunk(PLSCHUNKCONTEXT plschunkcontext,/* IN: LS chunk context */
					      BOOL* pfSuccessful);			/* fSuccessful does previous chunk exist  */

LSERR CollectNextChunk(PLSCHUNKCONTEXT plschunkcontext,	/* IN: LS chunk context */
					   BOOL* pfSuccessful);				/* fSuccessful does next chunk exist  */

LSERR GetUrPenAtBeginingOfLastChunk(PLSCHUNKCONTEXT plschunkcontext,	/* IN: LS chunk context */
									PLSDNODE plsdnFirst,	/* IN: First dnode in a chunk (used for checks */
									PLSDNODE plsdnLast,		/* IN: last dnode in a chunk */
									POINTUV* ppoint,			/* IN: point after lst dnode */
									long* purPen);			/* OUT: ur before chunk */



void SetPosInChunk(PLSCHUNKCONTEXT plschunkcontext,		/* IN: LS chunk context */
				   PLSDNODE	plsdn,						/* IN: position to convert to position in a current chunk */
				   LSDCP dcp,							/* IN: dcp in the dnode	*/
				   PPOSICHNK pposinchnk);				/* OUT: position in a current chunk */



enum CollectSublines
{
	CollectSublinesNone,
	CollectSublinesForJustification,
	CollectSublinesForCompression,
	CollectSublinesForDisplay,
	CollectSublinesForDecimalTab,
	CollectSublinesForTrailingArea,
};

typedef enum CollectSublines COLLECTSUBLINES;


typedef struct grchunkext
{
	PLSCHUNKCONTEXT plschunkcontext;/* Chunk context  */
	DWORD	iobjText;				/* idobj of text 	*/
	enum COLLECTSUBLINES Purpose;	/* for what purpose we are collecting group chunk */
	LSGRCHNK lsgrchnk;				/* group chunk   */
	PLSDNODE plsdnFirst;			/* group chunk was collected between plsdnFirst */
	PLSDNODE plsdnNext;				/* and plsdnNext */
									/*(both plsdnFirst and plsdnNext are in a main subline)*/
	PLSDNODE plsdnLastUsed;			/* last dnode that participates in calculation of above fields*/
									/* can be on the second level */
	long durTotal;					/* durTotal of all dnodes between First and Last */
	long durTextTotal;				/* durTextTotal of all text dnodes between First and Last */
	long dupNonTextTotal;			/* dupNonTextTotal of all non text dnodes between First and Last (including pens) */
	DWORD cNonTextObjects;			/* number of non text objects  (excliding pens)    */
	PLSDNODE* pplsdnNonText;		/* array of non text objects */
	BOOL* pfNonTextExpandAfter;			/* array of flags for non text objects */
	DWORD cNonTextObjectsExpand;	/* number of non text objects that can be expanded */
	/* fields below are valid only for group chunk collected for compression or justification */
	POSICHNK posichnkBeforeTrailing;/* information about last text cp before trailing area */
	PLSDNODE plsdnStartTrailing;	/* dnode where trailing area starts */
	long durTrailing;				/* dur of trailing area in  group chunk */
	LSDCP dcpTrailing;				/* amount of characters in trailing are */
	BOOL fClosingBorderStartsTrailing;/* closing border located just before trailing area */

} GRCHUNKEXT;


#define FFirstOnLineGroupChunk(pgrchunkext, plsc)  \
		(Assert(FIsLSDNODE((pgrchunkext)->plsdnFirst)), \
		((pgrchunkext)->plsdnFirst->plsdnPrev == NULL && \
		(IdObjFromDnode((pgrchunkext)->plsdnFirst) == IobjTextFromLsc(&(plsc)->lsiobjcontext))))
				

void InitGroupChunkExt(PLSCHUNKCONTEXT plschnkcontext,  /* Chunk context  */
					   DWORD iobjText,					/* text iobj      */
			  	       GRCHUNKEXT* pgrchunkext);		/* OUT: structure to initialize */




LSERR CollectTextGroupChunk(
			 		 PLSDNODE plsdnFirst,			/* IN: First Dnode				*/
					 LSCP cpLim,					/* IN: cpLim(boundary) for collecting,
										 			group chunk can stop before this boundary but can't go beyond */
					 COLLECTSUBLINES Purpose, 		/* IN: what sublines to take from complex object */

					 GRCHUNKEXT* pgrchunkext);		/* OUT: extended group chunk	*/

LSERR CollectPreviousTextGroupChunk(		
			 		 PLSDNODE plsdnEnd,				/* IN: last dnode of a chunk */
					 COLLECTSUBLINES Purpose, 		/* IN: what sublines to take from complex object */
					 BOOL fAllSimpleText,			/* IN: we have only simple text in this line */
					 GRCHUNKEXT* pgrchunkext);  	/* OUT: extended group chunk	*/

/* G E T  T R A I L I N G  I N F O  F O R  T E X T  G R O U P  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: GetTrailingInfoForTextGroupChunk
    %%Contact: igorzv

Parameters:
	plsdnLastDnode		-	(IN) dnode where to start calculation of trailing area
	dcpLastDnode			(IN) dcp in this dnode
	iobjText			-	(IN) iobj of text
	pdurTrailing		-	(OUT) dur of trailing area in  group chunk
	pdcpTrailing		-	(OUT) dcp of trailing area in chunk
	pplsdnStartTrailingText -	(OUT) dnode where trailing area starts
	pdcpStartTrailingText-	(OUT) with pcDnodesTrailing defines last character in text before
								  trailing area, doesn't valid if pcDnodesTrailing == 0
	pcDnodesTrailing	-	(OUT) number of dnodes in trailing area
	pplsdnStartTrailingObject -(OUT) dnode on the upper level where trailing are starts
	pdcpStartTrailingText	-(OUT) dcp in such dnode 
	pfClosingBorderStartsTrailing - (OUT) closing border located just before trailing area
----------------------------------------------------------------------------*/
	
LSERR GetTrailingInfoForTextGroupChunk
				(PLSDNODE plsdnLast, LSDCP dcpLastDnode, DWORD iobjText,
				 long* pdurTrailing, LSDCP* pdcpTrailing,
				 PLSDNODE* pplsdnStartTrailingText, LSDCP* pdcpStartTrailingText,
				 int* pcDnodesTrailing, PLSDNODE* pplsdnStartTrailingObject,
				 LSDCP* pdcpStartTrailingObject, BOOL* pfClosingBorderStartsTrailing);


LSERR AllocChunkArrays(PLSCHUNKCONTEXT plschunkcontext, LSCBK* plscbk, POLS pols,
					   PLSIOBJCONTEXT plsiobjcontext);

void DisposeChunkArrays(PLSCHUNKCONTEXT plschunkcontext);


LSERR DuplicateChunkContext(PLSCHUNKCONTEXT plschunkcontextOld, 
							PLSCHUNKCONTEXT* pplschunkcontextNew);

void DestroyChunkContext(PLSCHUNKCONTEXT plschunkcontext);


void FindPointOffset(
			  PLSDNODE plsdnFirst,			/* IN: dnode from the boundaries of which
											to calculate offset  */
			  enum lsdevice lsdev,			/* IN: presentation or reference device */
			  LSTFLOW lstflow,				/* IN: text flow to use for calculation */
			  COLLECTSUBLINES Purpose,		/* IN: what sublines to take from a complex object */
			  PLSDNODE plsdnContainsPoint,	/* IN: dnode contains point */
			  long duInDnode,				/* IN: offset in the dnode */
			  long* pduOffset);				/* OUT: offset from the starting point */

#endif /* CHNUTILS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\dnutils.h ===
#ifndef DNUTILS_DEFINED
#define DNUTILS_DEFINED

#include "lsdefs.h"
#include "plsdnode.h"
#include "objdim.h"
#include "lscbk.h"
#include "plsiocon.h"
#include "pqheap.h"



/* ROUTINES ---------------------------------------------------------------------------*/


LSERR FindListDims(PLSDNODE, PLSDNODE, OBJDIM*);

void FindListDup(PLSDNODE, LSCP, long*);

void FindListFinalPenMovement(PLSDNODE plsdnFirst, PLSDNODE plsdnLast, long *pdur, long *pdvr, long *pdvp);

LSERR DestroyDnodeList(LSCBK*, POLS, PLSIOBJCONTEXT, PLSDNODE plsdn, BOOL fDontReleaseRuns);

long DurBorderFromDnodeInside(PLSDNODE plsdn); /* IN: dnode inside borders */

BOOL FSpacesOnly(PLSDNODE plsdn, DWORD iObjText);

#define MovePointBack(ptpen, dur, dvr) \
		(ptpen)->u -= (dur); \
		(ptpen)->v -= (dvr); 


#define  GetPointBeforeDnodeFromPointAfter(pnode, ptpen) \
	MovePointBack(ptpen, DurFromDnode(pnode), DvrFromDnode(pnode));


#endif /* DNUTILS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\dninfo.h ===
#ifndef DNINFO_DEFINED
#define DNINFO_DEFINED

#include "lsdnode.h"
#include "lssubl.h"

/* MACROS --------------------------------------------------------------------------*/


#define IdObjFromDnode(p)  (Assert((p)->klsdn == klsdnReal), (p)->u.real.lschp.idObj)

#define PdobjFromDnode(p)  (Assert((p)->klsdn == klsdnReal), (p)->u.real.pdobj)

#define DupFromRealDnode(p) ((Assert((p)->klsdn == klsdnReal), \
							(p)->u.real.dup ))
#define DurFromRealDnode(p) ((Assert((p)->klsdn == klsdnReal), \
							(p)->u.real.objdim.dur ))

#define DvrFromRealDnode(p) (Assert((p)->klsdn == klsdnReal), \
							0)

#define DvpFromRealDnode(p) (Assert((p)->klsdn == klsdnReal), \
							0)

#define DupFromDnode(p)  (((p)->klsdn == klsdnReal)  ? \
						     DupFromRealDnode(p) : \
							 (Assert((p)->klsdn == klsdnPenBorder), (p)->u.pen.dup))
#define DurFromDnode(p)  (((p)->klsdn == klsdnReal)  ? \
						     DurFromRealDnode(p) : \
							 (Assert((p)->klsdn == klsdnPenBorder), (p)->u.pen.dur))
#define DvrFromDnode(p)  (((p)->klsdn == klsdnReal)  ? \
						     DvrFromRealDnode(p) : \
							 (Assert((p)->klsdn == klsdnPenBorder), (p)->u.pen.dvr))

#define DvpFromDnode(p)  (((p)->klsdn == klsdnReal)  ? \
						     DvpFromRealDnode(p) : \
							 (Assert((p)->klsdn == klsdnPenBorder), (p)->u.pen.dvp))


/* dnode is not in content if it either  auto-decimal tab or was created as a part 
of autonumbering. In both these cases and only in them it's cpFirst is negative  */
#define  FIsNotInContent(plsdn)   (Assert(FIsLSDNODE(plsdn)), ((plsdn)->cpFirst < 0 ))

#define  SublineFromDnode(plsdn)   ((plsdn)->plssubl)

#define  LstflowFromDnode(plsdn)   (LstflowFromSubline(SublineFromDnode(plsdn)))

/* dnode is first on line if it in content (not autonumber) and previous dnode either
null or not in content or is opening border which has previous dnode satisfying two
coditions above */
#define FIsFirstOnLine(plsdn)		( \
									!FIsNotInContent(plsdn) \
									&& \
										(	((plsdn)->plsdnPrev == NULL) \
										||	FIsNotInContent((plsdn)->plsdnPrev) \
										||	(	FIsDnodeOpenBorder((plsdn)->plsdnPrev) \
											&&	(	((plsdn)->plsdnPrev->plsdnPrev  == NULL)\
												||	FIsNotInContent((plsdn)->plsdnPrev->plsdnPrev) \
												) \
											) \
										) \
									)


#define FIsOutOfBoundary(plsdn, cpLim) \
		(((plsdn) == NULL) || \
		 ((plsdn)->cpLimOriginal > (cpLim)) || \
		 (FIsDnodeOpenBorder(plsdn) && ((plsdn)->cpLimOriginal == (cpLim))) \
		)

#define FDnodeBeforeCpLim(plsdn, cpLim) \
		!FIsOutOfBoundary((plsdn), (cpLim))

#define FDnodeAfterCpFirst(plsdn, cpF) \
		( \
		((plsdn) != NULL) \
		&&	( \
		    ((plsdn)->cpFirst > (cpF)) \
		    ||	( \
				((plsdn)->cpFirst == (cpF)) \
				&& (FIsDnodeReal(plsdn) || FIsDnodeOpenBorder(plsdn)) \
				) \
			) \
		) 

#define FDnodeHasBorder(plsdn)     /* doesn't work properly for pens */ \
	   (Assert(((plsdn) == NULL || !FIsDnodePen(plsdn))), \
		((plsdn) == NULL ? fFalse : \
		 ((FIsDnodeBorder(plsdn) ? fTrue : \
		   (plsdn)->u.real.lschp.fBorder))) \
       )

/*  macros bellow handle dup in sync with dur during formatting */
		 
#define SetDnodeDurFmt(plsdn, durNew) \
		Assert(FIsDnodeReal(plsdn)); \
		(plsdn)->u.real.objdim.dur = (durNew); \
		if (!(plsdn)->fRigidDup) \
			(plsdn)->u.real.dup = (durNew);

#define ModifyDnodeDurFmt(plsdn, ddur) \
		Assert(FIsDnodeReal(plsdn)); \
		(plsdn)->u.real.objdim.dur += (ddur); \
		if (!(plsdn)->fRigidDup) \
			(plsdn)->u.real.dup += (ddur);

#define SetDnodeObjdimFmt(plsdn, objdimNew) \
		Assert(FIsDnodeReal(plsdn)); \
		(plsdn)->u.real.objdim = (objdimNew); \
		if (!(plsdn)->fRigidDup) \
			(plsdn)->u.real.dup = (objdimNew).dur;

#define SetPenBorderDurFmt(plsdn, durNew) \
		Assert(!FIsDnodeReal(plsdn)); \
		(plsdn)->u.pen.dur = (durNew); \
		if (!(plsdn)->fRigidDup) \
			(plsdn)->u.pen.dup = (durNew);

#define ModifyPenBorderDurFmt(plsdn, ddur) \
		Assert(!FIsDnodeReal(plsdn)); \
		(plsdn)->u.pen.dur += (ddur); \
		if (!(plsdn)->fRigidDup) \
			(plsdn)->u.pen.dup += (ddur);


#endif /* DNINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\iobj.h ===
#ifndef IOBJ_DEFINED
#define IOBJ_DEFINED

#include "lsdefs.h"
#include "lsimeth.h"
#include "lsdocinf.h"
#include "plsiocon.h"
#include "lsiocon.h"

#define IobjTextFromLsc(plsiobjcontext)		((plsiobjcontext)->iobjMac - 2)

#define IobjAutonumFromLsc(plsiobjcontext)		((plsiobjcontext)->iobjMac - 1)

#define FIobjValid(plsiobjcontext,iobj)  (iobj < (plsiobjcontext)->iobjMac)

#define PilsobjFromLsc(plsiobjcontext,iobj)	( Assert(FIobjValid((plsiobjcontext),(iobj))),\
								 (plsiobjcontext)->rgobj[iobj].pilsobj)
#define PLsimFromLsc(plsiobjcontext,iobj)	( Assert(FIobjValid((plsiobjcontext),(iobj))),\
								&((plsiobjcontext)->rgobj[iobj].lsim))



#endif /* IOBJ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\enumcore.h ===
#ifndef ENUMCORE_DEFINED
#define ENUMCORE_DEFINED

#include "lsidefs.h"

#include "lsdnode.h"
#include "plssubl.h"

LSERR EnumSublineCore(PLSSUBL plssubl, BOOL fReverseOrder, BOOL fGeometryNeeded, 
					const POINT* pptOrg, long upLeftIndent);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lscaltbd.h ===
#ifndef LSCALTBD_DEFINED
#define LSCALTBD_DEFINED

#include "lsdefs.h"
#include "lsktab.h"


typedef struct
{
	enum lsktab lskt;					/* Kind of tab */
	long ur;							/* Offset of tab position */
	WCHAR wchTabLeader;					/* character for tab leader */
										/*   if 0, no leader is used*/
	WCHAR wchCharTab;					/* character for tab allignment for the special kind of tab stop */
	BYTE fDefault;						/* default tab position */
	BYTE fHangingTab;					/* hanging tab			*/
} LSCALTBD;


#endif /* !LSCALTBD_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\getfmtst.h ===
#ifndef GETFMTST_DEFINED
#define GETFMTST_DEFINED

#include "lsline.h"

/*  MACROS ---------------------------------------------------------------*/

#define GetDnodeToFinish(plsc)	((plsc)->lslistcontext.plsdnToFinish)


#define GetCurrentSubline(plsc)	((plsc)->lslistcontext.plssublCurrent)


#define GetCurrentCpLimSubl(plssubl)	((plssubl)->cpLim)
#define GetCurrentCpLim(plsc)			GetCurrentCpLimSubl(GetCurrentSubline(plsc))

#define GetCurrentUrSubl(plssubl)		((plssubl)->urCur)
#define GetCurrentUr(plsc)			GetCurrentUrSubl(GetCurrentSubline(plsc))

#define GetCurrentVrSubl(plssubl)		((plssubl)->vrCur)
#define GetCurrentVr(plsc)			GetCurrentVrSubl(GetCurrentSubline(plsc))

#define GetCurrentPointSubl(plssubl,point)	(((point).u =(plssubl)->urCur), \
									 ((point).v =(plssubl)->vrCur))
#define GetCurrentPoint(plsc, point)			GetCurrentPointSubl(GetCurrentSubline(plsc), point)


#define GetCurrentDnodeSubl(plssubl)	((plssubl)->plsdnLast)
#define GetCurrentDnode(plsc)			GetCurrentDnodeSubl(GetCurrentSubline(plsc))

#define GetWhereToPutLinkSubl(plssubl, Append) \
							(((Append) != NULL)   ?  \
								(&((Append)->plsdnNext)) : \
									(&((plssubl)->plsdnFirst)))
#define GetWhereToPutLink(plsc,Append)			GetWhereToPutLinkSubl(GetCurrentSubline(plsc), (Append))


#define GetCurrentLstflow(plsc)		LstflowFromSubline(GetCurrentSubline(plsc))

#define GetLastDnodeDisplaySubl(plssubl)	((plssubl)->plsdnLastDisplay)
#define GetLastDnodeDisplay(plsc)		GetLastDnodeDisplaySubl(GetCurrentSubline(plsc))

#endif /* GETFMTST_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\iobjln.h ===
#ifndef IOBJLN_DEFINED
#define IOBJLN_DEFINED

#include "lsdefs.h"
#include "plsline.h"

#define PlnobjFromLsline(plsline,iobj)   \
						((Assert(FIsLSLINE(plsline)),\
						Assert(iobj < (plsline)->lssubl.plsc->lsiobjcontext.iobjMac),\
						(plsline)->rgplnobj[iobj]))




#endif /* IOBJLN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lsc.h ===
#ifndef LSC_DEFINED
#define LSC_DEFINED


#include "lsidefs.h"
#include "plsdnode.h" 
#include "plsline.h"
#include "plssubl.h"
#include "pqheap.h"
#include "lsiocon.h"
#include "lstbcon.h"
#include "lscbk.h"
#include "lsdocinf.h"
#include "lschcon.h"
#include "lsbrjust.h"


typedef LSCHUNKCONTEXT LSCHUNKCONTEXTSTORAGE;



#define tagLSC		Tag('L','S','C',':')	 
#define FIsLSC(p)	FHasTag(p,tagLSC)


enum LsState		/* state and activity of Line Services */				
{
	LsStateNotReady,				/*  doc properties has not been set		*/
	LsStateFree,					/*  ready and are not involved in any activity */
	LsStateCreatingContext,			/*  LsCreatContext is working		*/
	LsStateDestroyingContext,		/*  LsDestroyContext is working		*/
	LsStateSettingDoc,				/*  LsSetDoc is working 			*/
	LsStateFormatting,    			/*  LsCreateLine (formating stage) is working 		*/
	LsStateBreaking,    			/*  LsCreateLine (breaking stage) is working 		*/
	LsStateDestroyingLine,			/*  LsDestroyLine is working						*/
	LsStatePreparingForDisplay,		/*  PrepareLineForDisplayProc called from LsDisplay or queries is working */
	LsStateDisplaying,				/*  LsDisplayLine is working						*/
	LsStateQuerying,				/*  we are within one of queries					*/
	LsStateEnumerating				/*  LsEnumLine is working					*/
};

typedef enum LsState LSSTATE;


typedef struct
/* this contains information that is used during preparaning for display time */
{
	BOOL fLineCompressed;  /* default value is fFalse, 
							is set to fTrue in breaking time if we apply compression to fit text into a line */
	BOOL fLineContainsAutoNumber;

	BOOL fUnderlineTrailSpacesRM;		/* Underline trailing spaces until RM?*/

	BOOL fForgetLastTabAlignment;		/* disregard dup of the last tab during center or right aligment
											if last tab is not left tab Word - bug compatibility */

	BOOL fNominalToIdealEncounted;		/* nominal to ideal has been applied during formatting */

	BOOL fForeignObjectEncounted;		/* object different from text happend during formatting */

	BOOL fTabEncounted;					/* tab dnode was created during formatting */


	BOOL fNonLeftTabEncounted;			/* tab dnode with non left tab stop was created */

	BOOL fSubmittedSublineEncounted;	/* LsdnSubmitSublines was called during formatting */

	BOOL fAutodecimalTabPresent;		/* there is autodecimal tab on this line */

	
	LSKJUST lskj;						/* justification type */

	LSKALIGN lskalign;					/* Alignment type */

	LSBREAKJUST lsbrj;					/* break/justification behavior */

	long urLeftIndent;					/* left indent */

	long urStartAutonumberingText;		/* starting position of autonumbering text */

	long urStartMainText;				/* starting position of text after autonumber */

	long urRightMarginJustify;			/* right margin for justification	*/

}  LSADJUSTCONTEXT;


typedef struct
/* This structure contains information which is used for snap to grid allignment. Is not valid if snap to 
grid is off */ 
{
	long urColumn; /* scaled to reference device value of uaColumn which has been passed to LsCreateLine */
}  LSGRIDTCONTEXT;


typedef struct
/* This structure contains current state of a formatting process. Good place for all information that is
   important only during formatting time */ 
{
	PLSDNODE plsdnToFinish;
	PLSSUBL	 plssublCurrent;
	DWORD	 nDepthFormatLineCurrent;

}  LSLISTCONTEXT;

struct lscontext
{
	DWORD tag;
	
	POLS pols;

	LSCBK lscbk;

	BOOL fDontReleaseRuns;
	
	long cLinesActive;
	PLSLINE plslineCur;

	PLSLINE plslineDisplay;		/* temporary */

	PQHEAP pqhLines;
	PQHEAP pqhAllDNodesRecycled;
	LSCHUNKCONTEXTSTORAGE lschunkcontextStorage;	/* memory that is shared by all main sublines */

   	LSSTATE lsstate;

	BOOL  fIgnoreSplatBreak; 

	BOOL fLimSplat;						/* Splat to display at cpLimPara */

	BOOL fHyphenated;	   /* current line was ended by hyphen */

	BOOL fAdvanceBack;	  /* current line contains advance pen with negative move */

	DWORD grpfManager;				/* Manager part of lsffi flags 			*/

	long urRightMarginBreak;

	long lMarginIncreaseCoefficient;	/* used for increasing right margin
										 LONG_MIN means don't increase */

	long urHangingTab;		/* used by autonumber */

	LSDOCINF lsdocinf;

    LSTABSCONTEXT lstabscontext;

	LSADJUSTCONTEXT lsadjustcontext;

	LSGRIDTCONTEXT lsgridcontext;

	LSLISTCONTEXT lslistcontext;

	LSIOBJCONTEXT lsiobjcontext;  /* should be last*/

};

#define FDisplay(p)			(Assert(FIsLSC(p)), (p)->lsdocinf.fDisplay)
#define FIsLSCBusy(p)		(Assert(FIsLSC(p)), \
							!(((p)->lsstate == LsStateNotReady) || ((p)->lsstate == LsStateFree))) 
#define FFormattingAllowed(p)	(Assert(FIsLSC(p)), (p)->lsstate == LsStateFormatting)
#define FBreakingAllowed(p)		(Assert(FIsLSC(p)), (p)->lsstate == LsStateBreaking)

#define FWorkWithCurrentLine(plsc) (Assert(FIsLSC(plsc)), \
								    ((plsc)->lsstate == LsStateFormatting || \
									 (plsc)->lsstate == LsStateBreaking || \
									 (plsc)->lsstate == LsStatePreparingForDisplay))

#define FBreakthroughLine(plsc)     ((plsc)->plslineCur->lslinfo.fTabInMarginExLine)

#define GetPqhAllDNodes(plsc)   ((plsc)->plslineCur->pqhAllDNodes) 


#ifdef DEBUG
/* this function verify that nobody spoiled context */
BOOL FIsLsContextValid(PLSC plsc);
#endif 


#endif /* LSC_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lscfmtfl.h ===
#ifndef LSCFMTFL_DEFINED
#define LSCFMTFL_DEFINED

#include "port.h"

#define TurnOnAllSimpleText(plsc) \
		(plsc)->plslineCur->fAllSimpleText = fTrue;

#define TurnOffAllSimpleText(plsc) \
		(plsc)->plslineCur->fAllSimpleText = fFalse;

#define FAllSimpleText(plsc) \
		(plsc)->plslineCur->fAllSimpleText
//---------------------------------------------------------------

#define TurnOnLineCompressed(plsc) \
		(plsc)->lsadjustcontext.fLineCompressed = fTrue;

#define TurnOffLineCompressed(plsc) \
		(plsc)->lsadjustcontext.fLineCompressed = fFalse;

#define FLineCompressed(plsc) \
		(plsc)->lsadjustcontext.fLineCompressed

#define SetLineCompressed(plsc,f) \
		(plsc)->lsadjustcontext.fLineCompressed = (f);
//---------------------------------------------------------------

#define FLineContainsAutoNumber(plsc) \
		(plsc)->lsadjustcontext.fLineContainsAutoNumber

#define SetLineLineContainsAutoNumber(plsc,f) \
		(plsc)->lsadjustcontext.fLineContainsAutoNumber = (f);
//---------------------------------------------------------------

#define FUnderlineTrailSpacesRM(plsc) \
		(plsc)->lsadjustcontext.fUnderlineTrailSpacesRM

#define SetUnderlineTrailSpacesRM(plsc,f) \
		(plsc)->lsadjustcontext.fUnderlineTrailSpacesRM = (f);


//---------------------------------------------------------------

#define FForgetLastTabAlignment(plsc) \
		(plsc)->lsadjustcontext.ForgetLastTabAlignment

#define SetForgetLastTabAlignment(plsc,f) \
		(plsc)->lsadjustcontext.fForgetLastTabAlignment = (f);

//---------------------------------------------------------------

#define TurnOnNonRealDnodeEncounted(plsc) \
		(plsc)->plslineCur->fNonRealDnodeEncounted = fTrue;

#define TurnOffNonRealDnodeEncounted(plsc) \
		(plsc)->plslineCur->fNonRealDnodeEncounted = fFalse;

#define FNonRealDnodeEncounted(plsc) \
		(plsc)->plslineCur->fNonRealDnodeEncounted

//---------------------------------------------------------------

#define TurnOnNonZeroDvpPosEncounted(plsc) \
		(plsc)->plslineCur->fNonZeroDvpPosEncounted = fTrue;

#define TurnOffNonZeroDvpPosEncounted(plsc) \
		(plsc)->plslineCur->fNonZeroDvpPosEncounted = fFalse;

#define FNonZeroDvpPosEncounted(plsc) \
		(plsc)->plslineCur->fNonZeroDvpPosEncounted
//---------------------------------------------------------------

#define FlushAggregatedDisplayFlags(plsc) \
		(plsc)->plslineCur->AggregatedDisplayFlags = 0;

#define AddToAggregatedDisplayFlags(plsc, plschp) \
		AddDisplayFlags((plsc)->plslineCur->AggregatedDisplayFlags, (plschp)) 

#define AggregatedDisplayFlags(plsc) \
		(plsc)->plslineCur->AggregatedDisplayFlags

//---------------------------------------------------------------

#define TurnOnNominalToIdealEncounted(plsc) \
		(plsc)->lsadjustcontext.fNominalToIdealEncounted = fTrue;

#define TurnOffNominalToIdealEncounted(plsc) \
		(plsc)->lsadjustcontext.fNominalToIdealEncounted = fFalse;

#define FNominalToIdealEncounted(plsc) \
		(plsc)->lsadjustcontext.fNominalToIdealEncounted
//---------------------------------------------------------------

#define TurnOnForeignObjectEncounted(plsc) \
		(plsc)->lsadjustcontext.fForeignObjectEncounted = fTrue;

#define TurnOffForeignObjectEncounted(plsc) \
		(plsc)->lsadjustcontext.fForeignObjectEncounted = fFalse;

#define FForeignObjectEncounted(plsc) \
		(plsc)->lsadjustcontext.fForeignObjectEncounted

//---------------------------------------------------------------

#define TurnOnTabEncounted(plsc) \
		(plsc)->lsadjustcontext.fTabEncounted = fTrue;

#define TurnOffTabEncounted(plsc) \
		(plsc)->lsadjustcontext.fTabEncounted = fFalse;

#define FTabEncounted(plsc) \
		(plsc)->lsadjustcontext.fTabEncounted

//---------------------------------------------------------------

#define TurnOnNonLeftTabEncounted(plsc) \
		(plsc)->lsadjustcontext.fNonLeftTabEncounted = fTrue;

#define TurnOffNonLeftTabEncounted(plsc) \
		(plsc)->lsadjustcontext.fNonLeftTabEncounted = fFalse;

#define FNonLeftTabEncounted(plsc) \
		(plsc)->lsadjustcontext.fNonLeftTabEncounted


//---------------------------------------------------------------

#define TurnOnSubmittedSublineEncounted(plsc) \
		(plsc)->lsadjustcontext.fSubmittedSublineEncounted = fTrue;

#define TurnOffSubmittedSublineEncounted(plsc) \
		(plsc)->lsadjustcontext.fSubmittedSublineEncounted = fFalse;

#define FSubmittedSublineEncounted(plsc) \
		(plsc)->lsadjustcontext.fSubmittedSublineEncounted

//---------------------------------------------------------------

#define TurnOnAutodecimalTabPresent(plsc) \
		(plsc)->lsadjustcontext.fAutodecimalTabPresent = fTrue;

#define TurnOffAutodecimalTabPresent(plsc) \
		(plsc)->lsadjustcontext.fAutodecimalTabPresent = fFalse;

#define FAutodecimalTabPresent(plsc) \
		(plsc)->lsadjustcontext.fAutodecimalTabPresent

//---------------------------------------------------------------
#define FBorderEncounted(plsc) \
		(AggregatedDisplayFlags(plsc) & fPortDisplayBorder)
	

#endif /* LSCFMTFL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\limqmem.h ===
#define limLines		1
#define limAllDNodes	8
#define limCaltbd		64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lsdnfinp.h ===
#ifndef LSDNFINT_DEFINED
#define LSDNFINT_DEFINED

/* Access routines for contents of DNODES */

#include "lsdefs.h"
#include "plssubl.h"
#include "plsrun.h"
#include "plschp.h"
#include "fmtres.h"


LSERR WINAPI LsdnFinishDelete(
							  PLSC,				/* IN: Pointer to LS Context */
					  		  LSDCP);			/* IN: dcp to add			 */

LSERR WINAPI LsdnFinishBySubline(PLSC,			/* IN: Pointer to LS Context */
							  	LSDCP,     		/* IN: dcp adopted           */
								PLSSUBL);		/* IN: Subline context		 */

LSERR WINAPI LsdnFinishByOneChar(				/* allows replacement by simple DNODE only */
							  PLSC,				/* IN: Pointer to LS Context */
							  long,				/* IN: urColumnMax			 */
							  WCHAR,			/* IN: character to replace	 */
							  PCLSCHP,			/* IN: lschp for character   */
							  PLSRUN,			/* IN: plsrun for character  */
							  FMTRES*);			/* OUT:Result of the Repl formatter*/


#endif /* !LSDNFINT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lschcon.h ===
#ifndef LSCHCON_DEFINED
#define LSCHCON_DEFINED

#include "lsidefs.h"
#include "plsdnode.h"
#include "locchnk.h"
#include "plscbk.h"
#include "plssubl.h"
#include "plsiocon.h"

typedef struct lschunkcontext
{
	DWORD cchnkMax;  /* current restriction on size of arrays */
	BOOL FChunkValid; /* because of some operations with glyphs (ligatures across dnodes )
					  chunk can not be reused */
	BOOL  FLocationValid; /* location has been calculated for this array */
		/* for chunk (not group chunk) until location is not valid locchnkCurrent.ppointUv
		  contains witdth of border may be two before dnode */
	BOOL  FGroupChunk; /* current chunk is group chunk */
	BOOL  FBorderInside; /* there is a border inside chunk or group chunk */
	PLSDNODE* pplsdnChunk; /* dnodes in chunk */
	DWORD grpfTnti;  /* summarized nominal to ideal flags of chunk */
	BOOL fNTIAppliedToLastChunk; /* nominal to ideal has been applied to the last chunk */
	LOCCHNK locchnkCurrent; /* current located chunk */ 
	DWORD* pcont; /* array that used for group chuncks */
	PLSCBK plscbk;		/* call backs */
	POLS pols;			/* clients information for callbacks */
	long urFirstChunk;	/* ur of the first chunk : for optimization */
	long vrFirstChunk;	/* vr of the first chunk : for optimization */
	DWORD cNonTextMax;  /* current restriction on size of arrays of non text objects*/
	PLSDNODE* pplsdnNonText;	/* array of non text objects */
	BOOL* pfNonTextExpandAfter;	/* array of flags for non text objects */
	LONG* pdurOpenBorderBefore;	/* array of widths of previous open border */
	LONG* pdurCloseBorderAfter;	/* array of widths of next close border */
	PLSIOBJCONTEXT plsiobjcontext; /* object methods */
	
	
}  LSCHUNKCONTEXT;

#endif /* LSCHCON_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lsiocon.h ===
#ifndef LSIOCON_DEFINED
#define LSIOCON_DEFINED

#include "lsdefs.h"
#include "pilsobj.h"
#include "lsimeth.h"

typedef struct lsiobjcontext
{
	DWORD iobjMac;
	struct OBJ
    {
		PILSOBJ pilsobj;
		LSIMETHODS lsim;
	} rgobj[1];
}  LSIOBJCONTEXT;


#endif /* LSIOCON_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lsdntext.h ===
#ifndef LSDNTEXT_DEFINED
#define LSDNTEXT_DEFINED

/* Text to manager interface routines */

#include "lsidefs.h"
#include "plsdnode.h"
#include "pobjdim.h"
#include "plsrun.h"
#include "stopres.h"

LSERR LsdnSetSimpleWidth(
						   PLSC,		/* IN: Pointer to LS Context */
						   PLSDNODE,	/* IN: DNODE to be modified  */
						   long);		/* IN: dur */

LSERR LsdnModifySimpleWidth(
						   PLSC,		/* IN: Pointer to LS Context */
						   PLSDNODE,	/* IN: DNODE to be modified  */
						   long);		/* IN: ddur */

LSERR LsdnSetTextDup(PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the dnode	 */
					 long);    			/* IN: dup to be set		 */

LSERR LsdnModifyTextDup(PLSC,			/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the dnode	 */
					 long);    			/* IN: ddup					 */

LSERR LsdnGetObjDim(
						  PLSC,			/* IN: Pointer to LS Context */
					 	  PLSDNODE,		/* IN: plsdn -- DNODE */
					 	  POBJDIM);		/* OUT: dimensions of DNODE */

LSERR LsdnFInChildList(					/* Used to switch off hyphenation in child list */ 
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the dnode	 */
					 BOOL*);   			/* OUT: fInChildList		 */

LSERR LsdnResetWidthInPreviousDnodes(	/* Used at SetBreak time for hyphen/nonreqhyphen cases */ 
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the dnode	 */
					 long,				/* IN: durChangePrev (don't change if 0)	*/
					 long);   			/* IN: durChangePrevPrev (don't change if 0)  */

LSERR LsdnGetUrPenAtBeginningOfChunk(	/* Used by SnapGrid 			*/ 
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the first dnode in chunk */
					 long*,   			/* OUT: purPen							  */
					 long*);   			/* OUT: purColumnMax					  */

LSERR LsdnResetDcpMerge(
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the first dnode in chunk */
					 LSCP,				/* IN: cpFirstNew	*/
					 LSDCP);			/* IN: dcpNew	*/

LSERR LsdnResetDcp(
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the first dnode in chunk */
					 LSDCP);			/* IN: dcpNew	*/

LSERR LsdnSetStopr(
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the dnode */
					 STOPRES);			/* IN: Stop result			*/


LSERR LsdnSetHyphenated(PLSC);			/* IN: Pointer to LS Context */

LSERR LsdnGetBorderAfter(
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the first dnode in chunk */
					 long*);			/* OUT: dur of the border after this DNODE */

LSERR LsdnGetCpFirst(
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the first dnode in chunk */
					 LSCP*);			/* OUT: cpFirst of this DNODE */

LSERR LsdnGetPlsrun(
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the first dnode in chunk */
					 PLSRUN*);			/* OUT: plsrun of this DNODE */

LSERR LsdnGetLeftIndentDur(
					 PLSC,				/* IN: Pointer to LS Context */
					 long*);			/* OUT: dur of the left margin */

LSERR LsdnFCanBreakBeforeNextChunk(
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Last DNODE of the current chunk */
					 BOOL*);			/* OUT: Can break before next chunk ? */

LSERR LsdnFStoppedAfterChunk(
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Last DNODE of the current chunk */
					 BOOL*);			/* OUT: Splat or Hidden Text, producing fmtrStopped after chunk? */

#endif /* !LSDNTEXT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lsidefs.h ===
#ifndef LSIDEFS_DEFINED
#define LSIDEFS_DEFINED

/*
	Disable non standard comment warning to allow "//" comments since such
	comments are in the public headers.
*/
#pragma warning (disable : 4001)

/* For ICECAP builds turn off the static directive */
#ifdef ICECAP
#define static
#endif /* ICECAP */

/* Common utility macros shared by all of Line Services
 */

#include "lsdefs.h"		/* Make external common defines visible internally */

/* ****************************************************************** */
/* Item #1: The Assert() family of macros.
 *
 *  Assert() generates no code for non-debug builds.
 *  AssertSz() is like Assert(), but you specify a string to print.
 *      victork: AssertSz() is unaccessible 
 *  AssertBool() validates that its parameter is either "1" or "0".
 *  AssertDo() checks the result of an expression that is ALWAYS
 *   compiled, even in non-debug builds.
 *  AssertErr asserts there is an error with displaying a string
 *  AssertImplies(a, b) checks that a implies b
 */
#ifdef DEBUG

 void (WINAPI* pfnAssertFailed)(char*, char*, int);
 #define AssertSz(f, sz)	\
	 (void)( (f) || (pfnAssertFailed(sz, __FILE__, __LINE__), 0) )
 #define AssertDo(f)		Assert((f) != 0)

#else /* !DEBUG */

 #define AssertSz(f, sz) 	(void)(0)
 #define AssertDo(f)		(f)

#endif /* DEBUG */

#define AssertEx(f)		AssertSz((f), "!(" #f ")")
#define AssertBool(f)	AssertSz(((f) | 1) == 1, "boolean not zero or one");
 /* use AssertBool(fFoo) before assuming "(fFoo == 1 || fFoo == 0)" */
#define Assert(f)		AssertEx(f)
#define NotReached()	AssertSz(fFalse, "NotReached() declaration reached")
#define AssertErr(sz)	(pfnAssertFailed(sz, __FILE__, __LINE__), 0)
#define FImplies(a,b) (!(a)||(b))
#define AssertImplies(a, b) AssertSz(FImplies(a, b), #a " => " #b)


#pragma warning(disable:4705)		/* Disable "Code has no effect" */


/* ****************************************************************** */
/* Item #2:
 *  A macro to compute the amount of storage required for an instance
 *  of a datatype which is defined with a repeating last element:
 *
 *	struct s
 *	{
 *		int a,b,c;
 *		struct q
 *		{
 *			long x,y,z;
 *		} rgq[1];
 *	};
 *
 * To determine the number of bytes required to hold a "struct s" 
 * with "N" repeating elements of type "rgq", use "cbRep(struct s, rgq, N)";
 */

#include <stddef.h>
#define cbRep(s,r,n)	(offsetof(s,r) + (n) * (sizeof(s) - offsetof(s,r)))


/* ****************************************************************** */
/* Item #3:
 *  Macros which work with tags for validating the types of structures.
 *
 *   tagInvalid denotes a tag which will not be used for valid object types.
 *
 *   Tag('A','B','C','D') generates a DWORD which looks like "ABCD" in a
 *   Little-Endian debugger memory dump.
 *
 *   FHasTag() assumes that the structure parameter has a DWORD member
 *   named "tag", and checks it against the tag parameter.
 *
 * To use these macros, define a unique tag for each data type and a macro
 * which performs typechecking for the type:
 *  #define tagFOO		tag('F','O','O','@')
 *  #define FIsFoo(p)	FHasTag(p,tagFoo)
 *
 * Next, initialize the tag when the structure is allocated:
 *
 *  pfoo->tag = tagFOO;
 *
 * Then, for all APIs which manipulate items of type FOO, validate the
 * type of the parameter before doing any work with it.
 *
 *  if (!FIsFoo(pfoo))
 *     {
 *     // return an error.
 *     }
 */

#define tagInvalid		((DWORD) 0xB4B4B4B4)
#define Tag(a,b,c,d)	((DWORD)(d)<<24 | (DWORD)(c)<<16 | (DWORD)(b)<<8 | (a))
#define FHasTag(p,t)	((p) != NULL && (p)->tag == (t))

/* ****************************************************************** */
/* Item #4:
 *
 * Clever code from Word.h meaning:  "a >= b && a <= c"
 * (When b and c are constants, this can be done with one test and branch.)
 */

#define FBetween(a, b, c)	(Assert(b <= c), \
		(unsigned)((a) - (b)) <= (unsigned)((c) - (b))\
		)


/* ****************************************************************** */
/* Item #4:
 *
 * Macro meaning:  I'm ignoring this parameter on purpose.
 */
#define Unreferenced(a)	((void)a)


#endif /* LSIDEFS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lsgrchnk.h ===
#ifndef LSGRCHNK_DEFINED
#define LSGRCHNK_DEFINED

#include "lsidefs.h"
#include "lschnke.h"

#define fcontNonTextBefore	1
#define fcontExpandBefore	2
#define fcontNonTextAfter	4
#define fcontExpandAfter	8

typedef	struct lsgrchnk
{
	DWORD clsgrchnk;
	PLSCHNK plschnk;
	DWORD* pcont;
} LSGRCHNK;

#endif  /* !LSGRCHNK_DEFINED   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lsdnode.h ===
#ifndef LSDNODE_DEFINED
#define LSDNODE_DEFINED

#include "lsidefs.h"
#include "plsdnode.h"
#include "pdobj.h"
#include "objdim.h"
#include "plsrun.h"
#include "lschp.h"
#include "plssubl.h"

#define klsdnReal	0
#define klsdnPenBorder	1

#define tagLSDNODE		Tag('L','S','D', 'N')
#define FIsLSDNODE(plsdn)	(FHasTag(plsdn,tagLSDNODE))

struct lsdnode
{
	DWORD tag;

	PLSDNODE plsdnNext,plsdnPrev;
	LSCP cpFirst;
	LSCP cpLimOriginal;				/* is not equal to cpFirst + dcp in a case when 
									   glyph context goes across hidden text */
	PLSSUBL plssubl;  				/* subline which contains this dnode */

	LSDCP dcp;							/* 					 */
	UINT klsdn : 1;						/* klsdnReal, klsdnPenBorder */
	UINT fAdvancedPen : 1;				/* advanced pen, valid only if kldnPenBorder and not fBorder */
	UINT fBorderNode : 1;				/* border, valid only if kldnPenBorder  */
	UINT fOpenBorder :1;				/* open or close border, valid only if fBorder */
	UINT fRigidDup : 1;					/* Rigid dup is set		 */
	UINT fTab : 1;						/* tab 					*/
	UINT icaltbd : 8;					/* index in the lscaltbd array in lsc.h */
	UINT fEndOfColumn : 1;				/* dnode represents end of column */
	UINT fEndOfSection : 1;				/* dnode represents end of section */
	UINT fEndOfPage : 1;				/* dnode represents end of page */			
	UINT fEndOfPara : 1;				/* dnode represents end of paragraph */			
	UINT fAltEndOfPara : 1;				/* dnode represents alternative end of paragraphe */			
	UINT fSoftCR : 1;					/* dnode represents end of line */
	UINT fInsideBorder: 1;				/* is true if dnode is inside bordered sequence or one
										of the dnodes under him is inside bordered sequence */
	UINT fAutoDecTab: 1;				/* auto decimal tab */
	UINT fTabForAutonumber: 1;			/* tab which is added at the end of autonumber */
	UINT fBorderMovedFromTrailingArea: 1;/* closing border which was moved to the begining of
										    trailing area */

	UINT pad1 : 8;

	union								/* variant record */
	{
		struct							/* valid iff klsdn==klsdnReal */
		{
			LSCHP lschp;
			PLSRUN plsrun;
			OBJDIM objdim;
			long dup;					/* width of object in pres pixels	*/
			PDOBJ pdobj;

			struct
			{
				DWORD cSubline;				/* number of sublines 	*/
				PLSSUBL* rgpsubl;			/* array of such sublines 	*/
				BOOL fUseForJustification;
				BOOL fUseForCompression;
				BOOL fUseForDisplay;
				BOOL fUseForDecimalTab;
				BOOL fUseForTrailingArea;
	
			} * pinfosubl;					/* information how object participates in 
											justification or display*/

		} real;

		struct							/* valid iff klsdn==klsdnPen */
		{
			long dup,dvp;
			long dur,dvr;
		} pen;


	} u;
};

#define FIsDnodeReal(plsdn) 	(Assert(FIsLSDNODE(plsdn)), 	((plsdn)->klsdn == klsdnReal))

#define FIsDnodePen(plsdn) 		(Assert(FIsLSDNODE(plsdn)), \
								(((plsdn)->klsdn == klsdnPenBorder) && \
								 (!(plsdn)->fBorderNode)))

#define FIsDnodeBorder(plsdn) 	(Assert(FIsLSDNODE(plsdn)), \
								(((plsdn)->klsdn == klsdnPenBorder) && \
								 ((plsdn)->fBorderNode)))

#define FIsDnodeOpenBorder(plsdn)  (FIsDnodeBorder(plsdn) && \
								   ((plsdn)->fOpenBorder))	

#define FIsDnodeCloseBorder(plsdn)  (FIsDnodeBorder(plsdn) && \
								   !((plsdn)->fOpenBorder))	

#define FIsDnodeSplat(plsdn) ((plsdn)->fEndOfSection || \
								(plsdn)->fEndOfColumn || (plsdn)->fEndOfPage )	
	
#define FIsDnodeEndPara(plsdn) (plsdn)->fEndOfPara
								
#define FIsDnodeAltEndPara(plsdn) (plsdn)->fAltEndOfPara

#define FIsDnodeSoftCR(plsdn) (plsdn)->fSoftCr


#endif /* !LSDNODE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lsmem.h ===
#ifndef LSMEM_DEFINED
#define LSMEM_DEFINED

#include <string.h>

#pragma intrinsic(memset, memcpy, memcmp)			/* To avoid c run-time */

#endif /* !LSMEM_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lsline.h ===
#ifndef LSLINE_DEFINED
#define LSLINE_DEFINED

#include "plsline.h"
#include "plsdnode.h"
#include "plnobj.h"
#include "lslinfo.h"
#include "lspap.h"
#include "lsidefs.h"
#include "lssubl.h"

#define tagLSLINE		Tag('L','I','N','E')
#define FIsLSLINE(plsline)	FHasTag(plsline,tagLSLINE)
#define FLineValid(plsline, plsc)	((FIsLSLINE(plsline)) && (plsline->lssubl.plsc == plsc))


struct lsline
{
	DWORD tag;

	LSSUBL lssubl;			/* structure that describes main subline */

	LSLINFO	lslinfo;

	PQHEAP pqhAllDNodes;

	long upStartAutonumberingText;	/* starting position of autonumering text
									calculated in PrepForDisplay*/
	long upLimAutonumberingText;	/* end of autonumering text	
									calculated in PrepForDisplay*/
	long upStartMainText;			/* starting position of main text
									calculated in PrepForDisplay*/
	long upStartTrailing;
	long upLimLine;					/* end of line
									calculated in PrepForDisplay*/

	long dvpAbove;				/* Vertical extent -- prev. & ref. coords */
	long dvpBelow;

	long upRightMarginJustify;	/* Width of column, calculated in PrepForDisplay            */

	long upLimUnderline;    	/* boundary of underlining, calculated in PrepForDisplay    */


	enum ksplat kspl;		   /* kind of splat to show on this line */

	
	BOOL fAllSimpleText;  /* this variable is used only for optimization and is not handled 
							 strictly:  if it is true then only text can be in a line,
							 but backward sometimes (when dnode was deleted or after break)
							 is not true;  */
 
	BOOL fCollectVisual;

	BOOL fNonRealDnodeEncounted;		/* pen dnode was created during formatting */

	BOOL fNonZeroDvpPosEncounted;		/* run with non zero  was formatted in the line */

	WORD  AggregatedDisplayFlags;		/* aggregated bites from all runs formatted on this line */

	WORD pad;

	PLNOBJ rgplnobj[1];  		/*  array of plnobj    	*/
								/* should be the last	*/
};


enum ksplat	
{
	ksplNone,
	ksplColumnBreak,
	ksplSectionBreak,
	ksplPageBreak
};


#endif /* !LSLINE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lsfetch.h ===
#ifndef LSFETCH_DEFINED
#define LSFETCH_DEFINED

#include "lsdefs.h"
#include "lsfrun.h"
#include "lsesc.h"
#include "fmtres.h"
#include "plsdnode.h"
#include "lstflow.h"
#include "plssubl.h"
#include "tabutils.h"
#include "chnutils.h"
#include "lsffi.h"


#define InitFormattingContext(plsc, urLeft, cpLimStart)		\
							InitLineTabsContext((plsc)->lstabscontext,(plsc)->urRightMarginBreak, \
												(cpLimStart),\
												(plsc)->grpfManager & fFmiResolveTabsAsWord97);\
							InitSublineChunkContext((plsc)->plslineCur->lssubl.plschunkcontext,\
										urLeft, 0);\
							(plsc)->lslistcontext.plsdnToFinish = NULL;\
							(plsc)->lslistcontext.plssublCurrent = &((plsc)->plslineCur->lssubl);\
							(plsc)->lslistcontext.plssublCurrent->cpLim = (cpLimStart);\
							(plsc)->lslistcontext.plssublCurrent->urCur = (urLeft);\
							(plsc)->lslistcontext.plssublCurrent->urColumnMax = (plsc)->urRightMarginBreak;\
							(plsc)->lslistcontext.nDepthFormatLineCurrent = 1;\
							Assert((plsc)->lslistcontext.plssublCurrent->vrCur == 0);\
							Assert((plsc)->lslistcontext.plssublCurrent->plsdnLast == NULL);


LSERR 	FetchAppendEscResumeCore(
			PLSC plsc,					/* IN: LineServices context 	*/
			long urColumnMax,			/* IN: urColumnMax				*/
			const LSESC* plsesc,		/* IN: escape characters		*/
			DWORD clsesc,				/* IN: # of escape characters	*/
			const BREAKREC* rgbreakrec,	/* IN: input array of break records */
			DWORD cbreakrec,			/* IN: number of records in input array */
			FMTRES* pfmtres,			/* OUT: result of last formatter*/
			LSCP*	  pcpLim,			/* OUT: cpLim */
			PLSDNODE* pplsdnFirst,		/* OUT: plsdnFirst				*/
			PLSDNODE* pplsdnLast,		/* OUT: plsdnLast				*/
			long*	  pur);				/* OUT: result pen position 	*/

LSERR 	FetchAppendEscCore(
			PLSC plsc,					/* IN: LineServices context		*/
			long urColumnMax,			/* IN: urColumnMax				*/
			const LSESC* plsesc,		/* IN: escape characters		*/
			DWORD clsesc,				/* IN: # of escape characters	*/
			FMTRES* pfmtres,			/* OUT: result of last formatter*/
			LSCP*	  pcpLim,			/* OUT: cpLim */
			PLSDNODE* pplsdnFirst,		/* OUT: plsdnFirst				*/
			PLSDNODE* pplsdnLast,		/* OUT: plsdnLast				*/
			long*    pur);				/* OUT: result pen position		*/

LSERR	QuickFormatting(
			PLSC plsc,					/* IN: LineServices context		*/
	        LSFRUN* plsfrun,			/* IN: already featched run				*/
			long urColumnMax,			/* IN: urColumnMax				*/
			BOOL* pfGeneral,			/* OUT: quick formatting was stopped: we should general formatting */
			BOOL* pfHardStop,			/* OUT: formatting has been stoped due to special situation, not because
												exceeded margin*/
			LSCP*	  pcpLim,			/* OUT: cpLim */
			long*   pur);				/* OUT: result pen position		*/



LSERR	ProcessOneRun(	
			PLSC plsc,					/* IN: LineServices context		*/
		    long urColumnMax,			/* IN: urColumnMax				*/
		    const LSFRUN* plsfrun,		/* IN: given run				*/
			const BREAKREC* rgbreakrec,	/* IN: input array of break records */
			DWORD cbreakrec,			/* IN: number of records in input array */
		    FMTRES* pfmtres);			/* OUT: result of last formatter*/

LSERR 	CreateSublineCore(
			 PLSC plsc,			/* IN: LS context			*/
			 LSCP cpFirst,		/* IN: cpFirst				*/
			 long urColumnMax,	/* IN: urColumnMax			*/
			 LSTFLOW lstflow,	/* IN: text flow			*/
			 BOOL);				/* IN: fContiguos 			*/
						  

LSERR   FinishSublineCore(
			 PLSSUBL);			/* IN: subline to finish	*/

LSERR FormatAnm(
			 PLSC plsc,					/* IN: LS context			*/
			 PLSFRUN plsfrunMainText);
LSERR InitializeAutoDecTab(
			 PLSC plsc,		/* IN: LS context			*/
			 long durAutoDecimalTab); /* IN:auto decimal tab offset */

LSERR HandleTab( 
			 PLSC plsc);	/* IN: LS context			*/


LSERR  CloseCurrentBorder(PLSC plsc);  /* IN: LS context			*/

long RightMarginIncreasing(PLSC plsc, long urColumnMax);



#endif /* LSFETCH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lsqrycon.h ===
#ifndef LSQUERYCONTEXT_DEFINED
#define LSQUERYCONTEXT_DEFINED

#include "lsdefs.h"
#include "plsqsinf.h"
#include "lscell.h"


typedef struct lsquerycontext			
{
	PLSQSUBINFO	plsqsubinfo;		/* array of query results, allocated by client */
	DWORD		cQueryMax;			/* size of the array (maximum query depth) */
	DWORD		cQueryLim;			/* size of already filled part of the array */
	LSTEXTCELL	lstextcell;			/* text cell info and pointer to the text dnode */

} LSQUERYCONTEXT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lsstring.h ===
#ifndef LSSTRING_DEFINED
#define LSSTRING_DEFINED

#include "lsidefs.h"
#include "pilsobj.h"
#include "plnobj.h"
#include "plsrun.h"
#include "lstflow.h"
#include "txtobj.h"

LSERR GetWidths(PLNOBJ, PLSRUN, long, LPWSTR, LSCP, long, long, LSTFLOW, long*, long*);
/*
  PLNOBJ (IN) - pointer to lnobj
  PLSRUN (IN) - plsrun
  long (IN) - first index in dur array to use
  LPWSTR (IN) - array of characters
  LSCP (IN) - cpFirst
  long(IN) - number of characters
  long (IN) - width until right margin
  LSTFLOW (IN) - text flow
  long* (OUT) - number of characters for which width has been fetched
  long* (OUT) - total width of these characters
*/


LSERR FormatString(PLNOBJ, PTXTOBJ, WCHAR*, long, long*, long, long);
/* function is called to format  a Local Run
  PLNOBJ (IN) - pointer to lnobj
  PTXTOBJ (IN) - pointer to dobj
  WCHAR* (IN) - pointer to the character array
  long (IN) - number of characters
  long* (IN) - pointer to the spaces array
  long (IN) - number of spaces
  long (IN) - width of all chars
*/

LSERR FillRegularPresWidths(PLNOBJ, PLSRUN, LSTFLOW, PTXTOBJ);
/*
  PLNOBJ (IN) - pointer to lnobj
  PLSRUN (IN) - plsrun
  LSTFLOW (IN) - lstflow
  PTXTOBJ (IN) - pointer to dobj
*/


LSERR GetOneCharDur(PILSOBJ, PLSRUN, WCHAR, LSTFLOW, long*);
/*
  PILSOBJ (IN) - pointer to the ilsobj 
  PLSRUN (IN) - plsrun
  WCHAR (IN) - character code
  LSTFLOW (IN) - text flow
  long* (OUT) - presentation width of the character
*/

LSERR GetOneCharDup(PILSOBJ, PLSRUN, WCHAR, LSTFLOW, long, long*);
/*
  PILSOBJ (IN) - pointer to the ilsobj 
  PLSRUN (IN) - plsrun
  WCHAR (IN) - character code
  LSTFLOW (IN) - text flow
  long (IN) - reference width of the character
  long* (OUT) - presentation width of the character
*/

LSERR GetVisiCharDup(PILSOBJ, PLSRUN, WCHAR, LSTFLOW, long*);
/*
  PILSOBJ (IN) - pointer to the ilsobj 
  PLSRUN (IN) - plsrun
  WCHAR (IN) - visi character code
  LSTFLOW (IN) - text flow
  long* (OUT) - presentation width of the character
*/

LSERR AddCharacterWithWidth(PLNOBJ, PTXTOBJ, WCHAR, long, WCHAR, long);
/* adds character with specified width in the display list
  PLNOBJ (IN) - pointer to lnobj
  PTXTOBJ (IN) - pointer to dobj
  WCHAR (IN)  - character for rgwchOrig
  long (IN) - width in reference units
  WCHAR (IN)  - character for rgwch
  long (IN) - width in preview units
*/

void FixSpaces(PLNOBJ, PTXTOBJ, WCHAR);
/*
  PLNOBJ (IN) - pointer to lnobj
  PTXTOBJ (IN) - pointer to dobj
  WCHAR (IN) - VisiSpace code
*/

LSERR AddSpaces(PLNOBJ, PTXTOBJ, long, long);
/*
  PLNOBJ (IN) - pointer to the lnobj
  PTXTOBJ (IN) - poiter to dobj
  long (IN) - reference width of space;
  long (IN) - number of trailing spaces to be added 
*/

void FlushStringState(PILSOBJ);
/*
  PILSOBJ (IN) - pointer to the ilsobj 
*/

LSERR IncreaseWchMacBy2(PLNOBJ);
/*
  PLNOBJ (IN) - pointer to the lnobj
*/

#endif /* !LSSTRING_DEFINED                                                */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lssubl.h ===
#ifndef LSSUBL_DEFINED
#define LSSUBL_DEFINED


#include "lsidefs.h"
#include "plsdnode.h"
#include "lstflow.h"
#include "plschcon.h"
#include "posinln.h"
#include "objdim.h"
#include "brkkind.h"




#define tagLSSUBL		Tag('L','S','S','L')	 
#define FIsLSSUBL(p)	FHasTag(p,tagLSSUBL)


typedef struct brkcontext
	{
	POSINLINE posinlineBreakPrev; /* information about previous break */
	OBJDIM objdimBreakPrev;
	BRKKIND brkkindForPrev;
	BOOL fBreakPrevValid;

	POSINLINE posinlineBreakNext; /* information about next break */
	OBJDIM objdimBreakNext;
	BRKKIND brkkindForNext;
	BOOL fBreakNextValid;

	POSINLINE posinlineBreakForce; /* information about force break */
	OBJDIM objdimBreakForce;
	BRKKIND brkkindForForce;
	BOOL fBreakForceValid;
	}
BRKCONTEXT;


typedef struct lssubl

{
	DWORD tag;     						/* tag for safety checks   */

	PLSC plsc;							/* LineServices context
										   parameter to CreateSubLine */
	LSCP cpFirst;						/* cp for the first fetch
										   parameter to CreateSubLine */
	LSTFLOW lstflow;					/* text flow of the subline
										   parameter to CreateSubLine */

	long urColumnMax;					/* max lenght to fit into a main line
										   parameter to CreateSubLine */


	LSCP cpLim;							/* during formatting is a cpFirst for the next fetch 		
										   after SetBreak indicates boundary of the line */

	LSCP cpLimDisplay;					/* doesn't consider splat char */

	PLSDNODE plsdnFirst;				/* starting dnode in a subline */

	PLSDNODE plsdnLast;					/* last dnode in a subline 
										   during formatting serves as psdnToAppend */

	PLSDNODE plsdnLastDisplay;			/* doesn't consider splat dnode */

	PLSCHUNKCONTEXT plschunkcontext;

	PLSDNODE plsdnUpTemp;				/* temporary used for collecting group chunk */

	long urCur, vrCur;					/* Current pen position in reference units */

	BRKCONTEXT* pbrkcontext;			/* information about break opportunites */

	BYTE fContiguous;					/* if TRUE such line has the same coordinate system as main line
										   and is allowed to have tabs,
										   otherwise coordinates of the line starts from 0,0
										   parameter to CreateSubLine */


	BYTE fDupInvalid;					/* TRUE before preparing line for display */
	BYTE fMain;							/* is this subline main */

	BYTE fAcceptedForDisplay;			/* subline was submitted for display and accepted */

	BYTE fRightMarginExceeded;			/* used for low level subline to avoid double call to
										   nominal to ideal */

} LSSUBL;


#define LstflowFromSubline(plssubl)  ((plssubl)->lstflow)

#define PlschunkcontextFromSubline(plssubl)  ((plssubl)->plschunkcontext)

#define FIsSubLineMain(plssubl) (plssubl)->fMain

#endif /* LSSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lstxtbr1.h ===
#ifndef LSTXTBR1_DEFINED
#define LSTXTBR1_DEFINED

#include "lsidefs.h"
#include "breakrec.h"
#include "brkkind.h"
#include "pdobj.h"
#include "plocchnk.h"
#include "pposichn.h"
#include "plsfgi.h"
#include "pbrko.h"
#include "pobjdim.h"


LSERR QuickBreakText(PDOBJ, BOOL*, LSDCP*, POBJDIM);	
LSERR WINAPI SetBreakText(PDOBJ, BRKKIND, DWORD, BREAKREC*, DWORD*);
LSERR WINAPI ForceBreakText(PCLOCCHNK, PCPOSICHNK, PBRKOUT);
LSERR WINAPI TruncateText(PCLOCCHNK, PPOSICHNK);
#endif  /* !LSTXTBR1_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lstbcon.h ===
#ifndef LSTBCON_DEFINED
#define LSTBCON_DEFINED

#include "lsdefs.h"
#include "lscaltbd.h"
#include "plsdnode.h"
#include "plscbk.h"
#include "plschcon.h"
#include "lsdocinf.h"

typedef struct lstabscontext
{
/* tabs from current PAP */	
	BYTE fTabsInitialized;
	long durIncrementalTab;	   	   /* scaled from LSPAP.lstabs                                 */
	DWORD ccaltbdMax;			/* Maximum number of records in pTbd */
	DWORD icaltbdMac;			   /* number of tabs records in pTbd */
	LSCALTBD* pcaltbd; 		/* distilled from LSPAP.lstabs, with effect of hanging tab  */
							   	   /*  factored in                                             */
	/* Pending Tab info */
	long urBeforePendingTab;
	PLSDNODE plsdnPendingTab;

	PLSCBK   plscbk;			/* call backs */
	POLS pols;					/* client's information for callbacks */
	LSDOCINF* plsdocinf;		/* here we can take resolution */
	long urColumnMax;			/* column width to solve break through tab  problem */
	LSCP cpInPara;				/* cp to use for fetching tabs						*/
	BOOL fResolveTabsAsWord97;

}  LSTABSCONTEXT;

#endif /* LSTBCON_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lsqcore.h ===
#ifndef LSQCORE_DEFINED
#define LSQCORE_DEFINED

#include "lsdefs.h"
#include "plssubl.h"
#include "plsqsinf.h"
#include "plscell.h"


LSERR QuerySublineCpPpointCore(
								PLSSUBL,		/* IN: pointer to subline info 				*/
								LSCP,			/* IN: cpQuery 								*/
								DWORD,      	/* IN: nDepthQueryMax						*/
								PLSQSUBINFO,	/* OUT: array[nDepthQueryMax] of LSQSUBINFO	*/
								DWORD*,		 	/* OUT: nActualDepth						*/
								PLSTEXTCELL);	/* OUT: Text cell info						*/

LSERR QuerySublinePointPcpCore(
								PLSSUBL,		/* IN: pointer to subline info 				*/
						 	   	PCPOINTUV,		/* IN: query point in the subline coordinate system:
						 	   						Text flow is the text flow of the subline,
 													zero point is at the starting point.   	*/
								DWORD,      	/* IN: 	nDepthQueryMax						*/
								PLSQSUBINFO,	/* OUT: array[nDepthQueryMax] of LSQSUBINFO	*/
								DWORD*,			/* OUT: nActualDepth						*/
								PLSTEXTCELL);	/* OUT: Text cell info						*/

#define idObjText	idObjTextChp		
#define idObjNone	(idObjTextChp - 1)


#endif /* !LSQCORE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lstext.h ===
#ifndef LSTEXT_DEFINED
#define LSTEXT_DEFINED

#include "lsidefs.h"
#include "pdobj.h"
#include "lsgrchnk.h"

/* Standard methods */
#include "lstxtini.h"
#include "lstxtfmt.h"
#include "lstxtjst.h"
#include "disptext.h"
#include "lstxtbrk.h"
#include "lstxtbr1.h"
#include "lstxtnti.h"
#include "lstxttab.h"
#include "lstxtqry.h"
#include "textenum.h"


#endif /* !LSTEXT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lstxtbrk.h ===
#ifndef LSTXTBRK_DEFINED
#define LSTXTBRK_DEFINED

#include "lsidefs.h"
#include "pdobj.h"
#include "plocchnk.h"
#include "pposichn.h"
#include "pbrko.h"
#include "brkcond.h"

LSERR WINAPI FindPrevBreakText(PCLOCCHNK, PCPOSICHNK, BRKCOND, PBRKOUT);
LSERR WINAPI FindNextBreakText(PCLOCCHNK, PCPOSICHNK, BRKCOND, PBRKOUT);

#endif  /* !LSTXTBRK_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lstxtbrs.h ===
#ifndef LSTXTBRS_DEFINED
#define LSTXTBRS_DEFINED

#include "lsidefs.h"
#include "pdobj.h"
#include "plocchnk.h"
#include "pobjdim.h"
#include "lstflow.h"
#include "lschnke.h"
#include "txtils.h"
#include "txtobj.h"

typedef struct hyphout
{
	long durHyphen;
	long dupHyphen;
	long durPrev;
	long dupPrev;
	long durPrevPrev;
	long dupPrevPrev;
	long ddurDnodePrev;
	long ddurDnodePrevPrev;
	long durChangeTotal;
	long iwchLim;
	long dwchYsr;
	WCHAR wchPrev;
	WCHAR wchPrevPrev;
	long igindHyphen;
	long igindPrev;
	long igindPrevPrev;

	GINDEX gindHyphen;
	GINDEX gindPrev;
	GINDEX gindPrevPrev;
} HYPHOUT;

typedef struct ysrinf
{
	WORD kysr;							/* Kind of Ysr - see "lskysr.h" */
	WCHAR wchYsr;						/* YSR char code  */
} YSRINF;


#define FCanBreak(pilsobj,b1, b2) \
	((pilsobj)->plsbrk[(pilsobj)->pilsbrk[(pilsobj)->cBreakingClasses * (b1) + (b2)]].fBreak)

#define FCanBreakAcrossSpaces(pilsobj, b1, b2) \
	((pilsobj)->plsbrk[(pilsobj)->pilsbrk[pilsobj->cBreakingClasses * (b1) + (b2)]].fBreakAcrossSpaces)

BOOL FindNonSpaceBefore(PCLSCHNK rglschnk, long itxtobjCur, long iwchCur,
									long* pitxtobjBefore, long* piwchBefore);
BOOL FindNonSpaceAfter(PCLSCHNK rglschnk, DWORD clschnk, long itxtobjCur, long iwchCur,
									long* pitxtobjAfter, long* piwchAfter);
BOOL FindPrevChar(PCLSCHNK rglschnk, long itxtobjCur, long iwchCur,
																long* pitxtobjBefore, long* piwchBefore);
BOOL FindNextChar(PCLSCHNK rglschnk, DWORD clschnk, long itxtobjSpace, long iwchSpace,
									long* pitxtobjAfter, long* piwchAfter);
LSERR CalcPartWidths(PTXTOBJ ptxtobj, long dwchLim, POBJDIM pobjdim, long* pdur);
LSERR CalcPartWidthsGlyphs(PTXTOBJ ptxtobj, long dwchLim, POBJDIM pobjdim, long* pdur);
LSERR CheckHotZone(PCLOCCHNK plocchnk, long itxtobj, long iwch, BOOL* pfInHyphenZone);
LSERR ProcessYsr(PCLOCCHNK plocchnk, long itxtobjYsr, long dwchYsr, long itxtobjPrev, long itxtobjPrevPrev, 
														YSRINF ysrinf, BOOL* pfSuccess, HYPHOUT* phyphout);
LSERR GetPbrkinf(PILSOBJ pilsobj, PDOBJ pdobj, BRKKIND brkkind, BREAKINFO** ppbrkinf);


#endif  /* !LSTXTBRS_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lstxtglf.h ===
#ifndef LSTXTGLF_DEFINED
#define LSTXTGLF_DEFINED

#include "lsidefs.h"
#include "pilsobj.h"
#include "lsgrchnk.h"
#include "lsdevice.h"
#include "lstflow.h"

LSERR ApplyGlyphExpand(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, LSDEVICE lsdev,
						long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLast,
						long duToDistribute, long* rgdu, long* rgduGind, long* rgduRight, long* rgduGright,
						BOOL* pfFullyJustified);


#endif  /* !LSTXTGLF_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lstxtcmp.h ===
#ifndef LSTXTCMP_DEFINED
#define LSTXTCMP_DEFINED

#include "lsidefs.h"
#include "pilsobj.h"
#include "lsgrchnk.h"
#include "lstflow.h"
#include "mwcls.h"

LSERR FetchCompressInfo(const LSGRCHNK* plsgrchnk, BOOL fFirstOnLine, LSTFLOW lstflow,
							long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLim,
							long durCompressMaxStop, long* pdurCompressTotal);
void GetCompLastCharInfo(PILSOBJ pilsobj, long iwchLast, MWCLS* pmwcls,
														long* pdurCompRight, long* pdurCompLeft);

void CompressLastCharRight(PILSOBJ pilsobj, long iwchLast, long durToAdjustRight);
LSERR ApplyCompress(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, 
					long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLim, long durToCompress);
LSERR ApplyExpand(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, BOOL fScaled,
				long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLim,
				DWORD cNonTextObjects, long durToExpand, long* pdurExtNonText, BOOL* pfFinalAdjustNeeded);
void ApplyDistribution(const LSGRCHNK* plsgrchnk, DWORD cNonText,
									   long durToDistribute, long* pdurNonTextObjects);

#endif  /* !LSTXTCMP_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lstxtini.h ===
#ifndef LSTXTINI_DEFINED
#define LSTXTINI_DEFINED

#include "lsidefs.h"
#include "lstxtcfg.h"
#include "lsbrk.h"
#include "lspairac.h"
#include "lspract.h"
#include "lsexpan.h"
#include "pilsobj.h"
#include "plnobj.h"
#include "plscbk.h"
#include "plsdocin.h"
#include "tlpr.h"

/* Standard methods */
LSERR WINAPI CreateILSObjText(POLS, PCLSC, PCLSCBK, DWORD, PILSOBJ*);
LSERR WINAPI DestroyILSObjText(PILSOBJ);
LSERR WINAPI SetDocText(PILSOBJ, PCLSDOCINF);
LSERR WINAPI CreateLNObjText(PCILSOBJ, PLNOBJ*);
LSERR WINAPI DestroyLNObjText(PLNOBJ);

/* Text-specific interface */
LSERR SetTextConfig(PILSOBJ,			/* IN: Text ILSOBJ					*/
					const LSTXTCFG*);	/* IN: HLSC-specific text config	*/

LSERR SetTextLineParams(PLNOBJ,			/* IN: Text LNOBJ					*/
						const TLPR*);	/* IN: text doc props				*/

LSERR ModifyTextLineEnding(
					PLNOBJ,				/* IN: Text LNOBJ					*/
					LSKEOP);			/* IN: Kind of line ending			*/

LSERR SetTextBreaking(
					PILSOBJ,			/* IN: Text ILSOBJ					*/
					DWORD,				/* IN: Number of breaking info units*/
					const LSBRK*,		/* IN: Breaking info units array	*/
					DWORD,				/* IN: Number of breaking classes	*/
					const BYTE*);		/* IN: Breaking information(square):
											  indexes in the LSEXPAN array  */
LSERR SetTextModWidthPairs(
					PILSOBJ,			/* IN: Text ILSOBJ					 */
					DWORD,				/* IN: Number of mod pairs info units*/ 
					const LSPAIRACT*,	/* IN: Mod pairs info units array  	 */
					DWORD,				/* IN: Number of Mod Width classes	 */
					const BYTE*);		/* IN: Mod width information:
											  indexes in the LSPAIRACT array */
LSERR SetTextCompression(
					PILSOBJ,			/* IN: Text ILSOBJ					 */
				  	DWORD,				/* IN: Number of compression priorities*/
					DWORD,				/* IN: Number of compression info units*/
					const LSPRACT*,		/* IN: Compession info units array 	*/
					DWORD,				/* IN: Number of Mod Width classes	*/
					const BYTE*);		/* IN: Compression information:
											  indexes in the LSPRACT array  */
LSERR SetTextExpansion(
					PILSOBJ,			/* IN: Text ILSOBJ					 */
					DWORD,				/* IN: Number of expansion info units*/
					const LSEXPAN*,		/* IN: Expansion info units array	*/
					DWORD,				/* IN: Number of Mod Width classes	*/
					const BYTE*);		/* IN: Expansion information:
											  indexes in the LSEXPAN array  */

#endif /* !LSTXTINI_DEFINED											  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lstxtjst.h ===
#ifndef LSTXTJST_DEFINED
#define LSTXTJST_DEFINED

#include "lsidefs.h"
#include "plnobj.h"
#include "lskjust.h"
#include "plocchnk.h"
#include "pposichn.h"
#include "lsgrchnk.h"
#include "lstflow.h"

LSERR AdjustText(
					LSKJUST, 			/* IN: justification type			*/
					long,				/* IN: durColumnMax	(from the last
											   tab	position)				*/
					long,				/* IN: durTotal	(from the last tab
										   position without trailing area)	*/
					long,				/* IN: dup available				*/
					const LSGRCHNK*,	/* IN: Group of chunks				*/
					PCPOSICHNK pposichnkBeforeTrailing,
										/* Information about last
												 cp before trailing area	*/
					LSTFLOW,			/* IN: Text flow					*/
					BOOL,				/* IN: compression?					*/
					DWORD,				/* IN: Number of non-text objects	*/
					BOOL,				/* IN: Suppress wiggling?			*/
					BOOL,				/* IN: Exact synchronization?		*/
					BOOL,				/* IN: fForcedBreak?				*/
					BOOL,				/* IN: Suppress trailing spaces?	*/
					long*,				/* OUT: dup of text in chunk		*/
					long*,				/* OUT: dup of trailing part		*/
					long*,				/* OUT: additional dup of non-text	*/
					DWORD*);			/* OUT: pcExtNonTextObjects			*/

void GetTrailInfoText(
					PDOBJ,				/* IN: pdobj						*/
					LSDCP,				/* IN: dcp in dobj					*/
					DWORD*,				/* OUT: number of trailing spaces	*/
					long*);				/* OUT: dur of the trailing area	*/


BOOL FSuspectDeviceDifferent(
					PLNOBJ);				/* IN: Text plnobj	
					*/
/* Returns True if: no dangerous Visi Characters, no non-req hyphens, opt. non-break, opt. break */

BOOL FQuickScaling(
					PLNOBJ,				/* IN: Text plnobj					*/
					BOOL,				/* IN: fVertical					*/
					long);				/* IN: durTotal						*/
/* Returns True if: no dangerous Visi Characters, no additional allocations for DOBJ's, durTotal is
	less than accepatable for fast scaling
*/

void QuickAdjustExact(
					PDOBJ*,				/* IN: array of PDOBJs				*/
					DWORD,				/* IN: number of elements in array	*/
					DWORD,				/* IN: number of trailing spaces	*/
					BOOL,				/* IN: fVertical					*/
					long*,				/* OUT: dup of text in chunk		*/
					long*);				/* OUT: dup of trailing part		*/


LSERR CanCompressText(
					const LSGRCHNK*,	/* IN: Group of chunks				*/
					PCPOSICHNK pposichnkBeforeTrailing,
										/* Information about last
												 cp before trailing area	*/
					LSTFLOW,			/* IN: Text flow					*/
					long,				/* IN: dur to compress				*/
					BOOL*,				/* OUT: can compress?				*/
					BOOL*,				/* OUT: actual compression?			*/
					long*);				/* OUT: pdurNonSufficient			*/


LSERR DistributeInText(					/* 									*/
					const LSGRCHNK*,	/* IN: group chunk of text			*/
					LSTFLOW,			/* IN: Text flow					*/
					DWORD,				/* IN: Number of non-text objects	*/
				   	long,	            /* IN: durToDistribute				*/
					long*);				/*OUT: additional dur of  non-text  */

#endif  /* !LSTXTJST_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lstxtmap.h ===
#ifndef LSTXTMAP_DEFINED
#define LSTXTMAP_DEFINED

#include "lsidefs.h"
#include "pilsobj.h"
#include "txtobj.h"

long IgindFirstFromIwchVeryFirst (PTXTOBJ ptxtobj, long igindVeryFirst, long iwch);
long IgindLastFromIwchVeryFirst (PTXTOBJ ptxtobj, long igindVeryFirst, long iwch);

long IgindFirstFromIwch(PTXTOBJ ptxtobj, long iwch); /* iwch can be Lim for ptxtobj */
long IgindLastFromIwch(PTXTOBJ ptxtobj, long iwch);
long IgindBaseFromIgind(PILSOBJ pilsobj, long igind); /* Last glyph with non-zero width before igind */
long IwchFirstFromIgind(PTXTOBJ ptxtobj, long igind);
long IwchLastFromIwch(PTXTOBJ ptxtobj, long iwch);
long IwchPrevLastFromIwch(PTXTOBJ ptxtobj, long iwch);
BOOL FIwchOneToOne(PILSOBJ pilsobj, long iwch);
BOOL FIwchLastInContext(PILSOBJ pilsobj, long iwch);
BOOL FIwchFirstInContext(PILSOBJ pilsobj, long iwch);
BOOL FIgindLastInContext(PILSOBJ pilsobj, long igind);
BOOL FIgindFirstInContext(PILSOBJ pilsobj, long igind);
long DcpAfterContextFromDcp(PTXTOBJ ptxtobj, long dcp);
void InterpretMap(PLNOBJ pilsobj, long iwchFirst, long dwch, long igindFirst, long cgind);

#endif  /* !LSTXTMAP_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lstxtfmt.h ===
#ifndef LSTXTFMT_DEFINED
#define LSTXTFMT_DEFINED

#include "lsidefs.h"
#include "plnobj.h"
#include "pdobj.h"
#include "pfmti.h"
#include "fmtres.h"


LSERR WINAPI FmtText(PLNOBJ, PCFMTIN, FMTRES*);
LSERR WINAPI DestroyDObjText(PDOBJ);

LSERR LsSublineFinishedText(PLNOBJ plnobj);

#endif  /* !LSTXTFMT_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lstxtffi.h ===
#ifndef LSTXTFFI_DEFINED
#define LSTXTFFI_DEFINED

#include "lsffi.h"

#define fTxtVisiCondHyphens			fFmiVisiCondHyphens
#define fTxtVisiParaMarks			fFmiVisiParaMarks
#define fTxtVisiSpaces				fFmiVisiSpaces
#define fTxtVisiTabs				fFmiVisiTabs
#define fTxtVisiBreaks				fFmiVisiBreaks
#define fTxtDoHyphenation			fFmiDoHyphenation
#define fTxtWrapTrailingSpaces		fFmiWrapTrailingSpaces
#define fTxtWrapAllSpaces			fFmiWrapAllSpaces
#define fTxtPunctStartLine			fFmiPunctStartLine
#define fTxtHangingPunct			fFmiHangingPunct
#define fTxtApplyBreakingRules		fFmiApplyBreakingRules
#define fTxtFCheckTruncateBefore	fFmiFCheckTruncateBefore
#define fTxtDrawInCharCodes			fFmiDrawInCharCodes
#define fTxtSpacesInfluenceHeight	fFmiSpacesInfluenceHeight
#define fTxtIndentChangesHyphenZone	fFmiIndentChangesHyphenZone
#define fTxtNoPunctAfterAutoNumber	fFmiNoPunctAfterAutoNumber	
#define	fTxtTreatHyphenAsRegular	fFmiTreatHyphenAsRegular
#endif /* !LSTXTFFI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lstxtmod.h ===
#ifndef LSTXTMOD_DEFINED
#define LSTXTMOD_DEFINED

#include "lsidefs.h"

#include "pilsobj.h"
#include "plsems.h"
#include "lsact.h"

void GetChanges(LSACT lsact, PLSEMS plsems, long durCur, BOOL fByIsPlus, BYTE* pside, long* pddurChange);
void TranslateChanges(BYTE sideRecom, long durAdjustRecom, long durCur, long durRight, long durLeft,
														 BYTE* psideFinal, long* pdurChange);
void InterpretChanges(PILSOBJ pilsobj, long iwch, BYTE side, long ddurChange, long* pddurChangeLeft, long* pddurChangeRight);
void ApplyChanges(PILSOBJ pilsobj, long iwch, BYTE side, long ddurChange);
void UndoAppliedChanges(PILSOBJ pilsobj, long iwch, BYTE side, long* pddurChange);
void ApplyGlyphChanges(PILSOBJ pilsobj, long igind, long ddurChange);
#endif  /* !LSTXTMOD_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lstxtqry.h ===
#ifndef LSTXTQRY_DEFINED
#define LSTXTQRY_DEFINED

#include "lsdefs.h"
#include "pdobj.h"
#include "plsqin.h"
#include "plsqout.h"
#include "gprop.h"

LSERR WINAPI QueryPointPcpText(PDOBJ, PCPOINTUV, PCLSQIN, PLSQOUT);
/* QueryTextPointPcp
 *  pdobj (IN): dobj to query
 * 	ppointuvQuery (IN): query point (uQuery,vQuery)
 *	plsqin (IN): query input
 *	plsqout (OUT): query output
 */

LSERR WINAPI QueryCpPpointText(PDOBJ, LSDCP, PCLSQIN, PLSQOUT);
/* QueryTextPointPcp
 *  pdobj (IN): dobj to query
 *  dcp (IN):  dcp for the query
 *	plsqin (IN): query input
 *	plsqout (OUT): query output
 */
LSERR WINAPI QueryTextCellDetails(
						 	PDOBJ,
							LSDCP,		/* IN: dcpStartCell	*/
							DWORD,		/* IN: cCharsInCell */
							DWORD,		/* IN: cGlyphsInCell */
							LPWSTR,		/* OUT: pointer array[nCharsInCell] of char codes */
							PGINDEX,	/* OUT: pointer array[nGlyphsInCell] of glyph indices */
							long*,		/* OUT: pointer array[nGlyphsCell] of glyph widths */
							PGOFFSET,	/* OUT: pointer array[nGlyphsInCell] of glyph offsets */
							PGPROP);	/* OUT: pointer array[nGlyphsInCell] of glyph handles */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lstxttab.h ===
#ifndef LSTXTTAB_DEFINED
#define LSTXTTAB_DEFINED

#include "lsidefs.h"
#include "lsgrchnk.h"
#include "lsdevice.h"
#include "pdobj.h"

#define idobjOutside 0xFFFFFFFF


LSERR SetTabLeader(PDOBJ,				/* IN: Tab dobj */
				   WCHAR);	            /* IN: wchTabLeader */

LSERR LsGetDecimalPoint(
					const LSGRCHNK*,	/* IN: group chunk of tab-to-tab text */
					enum lsdevice,		/* IN: lsdevice						*/
					DWORD*,				/* OUT: index of DObj with decimal */
					long*);				/* OUT: duToDecimalPoint */

LSERR LsGetCharTab(
					const LSGRCHNK*,	/* IN: group chunk of tab-to-tab text */
					WCHAR wchCharTab,	/* IN: Character for CharTab		*/
					enum lsdevice,		/* IN: lsdevice						*/
					DWORD*,				/* OUT: index of DObj with Character */
					long*);				/* OUT: duToCharacter */

#endif  /* !LSTXTTAB_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lstxtscl.h ===
#ifndef LSTXTSCL_DEFINED
#define LSTXTSCL_DEFINED

#include "lsidefs.h"
#include "pilsobj.h"
#include "lsgrchnk.h"
#include "lskjust.h"
#include "lstflow.h"

void ApplyWysi(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow);
void ApplyNonExactWysi(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow);
void ScaleSpaces(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, long itxtobjLast, long iwchLast);
void ScaleCharSides(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, BOOL* pfLeftSideAffected, BOOL* pfGlyphsDetected);
void ScaleExtNonText(PILSOBJ pilsobj, LSTFLOW lstflow, long durExtNonText, long* pdupExtNonText);
void GetDupLastChar(const LSGRCHNK* plsgrchnk, long iwchLast, long* pdupHangingChar);
void ScaleGlyphSides(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow);
void UpdateGlyphOffsets(const LSGRCHNK* plsgrchnk);
void SetBeforeJustCopy(const LSGRCHNK* plsgrchnk);
LSERR FillDupPen(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, long itxtobjLast, long iwchLast);
LSERR FinalAdjustmentOnPres(const LSGRCHNK* plsgrchnk, long itxtobjLast, long iwchLast,
			long dupAvailable, BOOL fFinalAdjustNeeded, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			long* pdupText, long* pdupTail);

#endif  /* !LSTXTSCL_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lstxtnti.h ===
#ifndef LSTXTNTI_DEFINED
#define LSTXTNTI_DEFINED

#include "lsidefs.h"
#include "lstflow.h"
#include "mwcls.h"
#include "lschnke.h"
#include "pheights.h"

LSERR NominalToIdealText(
					DWORD,				/* IN: grpfTnti flags---see tnti.h	*/
					LSTFLOW,			/* IN: lstflow						*/
					BOOL,				/* IN: fFirstOnLine					*/
					BOOL,				/* IN: fAutoNumberPresent			*/
					DWORD,				/* IN: number of dobj's in chunk	*/
					const LSCHNKE*);	/* IN: rgchnk--chunk				*/

LSERR GetFirstCharInChunk(
					DWORD,				/* IN: number of dobj's in chunk	*/
					const LSCHNKE*,		/* IN: rgchnk--chunk				*/
					BOOL*,				/* OUT: fSuccessful					*/
					WCHAR*,				/* OUT: char code					*/
					PLSRUN*,			/* OUT: plsrun of character			*/
					PHEIGHTS,			/* OUT: heightsPres of character	*/
					MWCLS*);			/* OUT: ModWidthClass of char		*/

LSERR GetLastCharInChunk(
					DWORD,				/* IN: number of dobj's in chunk	*/
					const LSCHNKE*,		/* IN: rgchnk--chunk				*/
					BOOL*,				/* OUT: fSuccessful					*/
					WCHAR*,				/* OUT: char code					*/
					PLSRUN*,			/* OUT: plsrun of character			*/
					PHEIGHTS,			/* OUT: heightsPres of character	*/
					MWCLS*);			/* OUT: ModWidthClass of char		*/

LSERR ModifyFirstCharInChunk(
					DWORD,				/* IN: number of dobj's in chunk	*/
					const LSCHNKE*,		/* IN: rgchnk--chunk				*/
					long);				/* IN: durChange					*/

LSERR ModifyLastCharInChunk(
					DWORD,				/* IN: number of dobj's in chunk	*/
					const LSCHNKE*,		/* IN: rgchnk--chunk				*/
					long);				/* IN: durChange					*/

LSERR CutTextDobj(
					DWORD,				/* IN: number of dobj's in chunk	*/
					const LSCHNKE*);	/* IN: rgchnk--chunk				*/

#endif  /* !LSTXTNTI_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\lstxtwrd.h ===
#ifndef LSTXTWRD_DEFINED
#define LSTXTWRD_DEFINED

#include "lsidefs.h"
#include "lsgrchnk.h"

void FullPositiveSpaceJustification(
		const LSGRCHNK*,				/* IN: Group chunk to justify   */
		long,							/* IN: itxtobjAfterStartSpaces  */
		long,							/* IN: iwchAfterStartSpaces     */
		long,						 	/* IN: itxtobjLast				*/
		long,							/* IN: iwchLast					*/
		long*, 							/* IN: rgdu						*/
 		long*,							/* IN: rgduGind					*/
		long,							/* IN: duToDistribute			*/
		BOOL*);							/* OUT: pfSpaceFound			*/

void NegativeSpaceJustification(
		const LSGRCHNK*,				/* IN: Group chunk to justify   */
		long,							/* IN: itxtobjAfterStartSpaces  */
		long,							/* IN: iwchAfterStartSpaces     */
		long,						 	/* IN: itxtobjLast				*/
		long,							/* IN: iwchLast					*/
		long*, 							/* IN: rgdu						*/
 		long*,							/* IN: rgduGind					*/
		long);							/* IN: duSqueeze				*/

#endif  /* !LSTXTWRD_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\ntiman.h ===
#ifndef NTIMAN_DEFINED
#define NTIMAN_DEFINED

#include "lsidefs.h"
#include "tnti.h"
#include "plsdnode.h"
#include "plschcon.h"
#include "plsiocon.h"
#include "lskjust.h"
#include "port.h"

/* MACROS ---------------------------------------------------------------------------*/

			

#define 		FApplyNominalToIdeal(plschp)\
				(GetNominalToIdealFlagsFromLschp(plschp) != 0)


#define			GetNominalToIdealFlags(plschnkcontext) \
				(plschnkcontext)->grpfTnti

#define			FNominalToIdealBecauseOfParagraphProperties(grpf, lskjust) \
				 ((grpf) & fFmiPunctStartLine) || \
				 ((grpf) & fFmiHangingPunct) || \
				 ((lskjust) == lskjSnapGrid)


/* ROUTINES ---------------------------------------------------------------*/

LSERR ApplyNominalToIdeal(
						  PLSCHUNKCONTEXT, /* LS chunk context */
						  PLSIOBJCONTEXT, /* installed objects */
						  DWORD ,		/* grpf */
						  LSKJUST,		/* kind of justification */
						  BOOL,			/* fIsSubLineMain */
						  BOOL,			/* fLineContainsAutoNumber*/
						  PLSDNODE);	/* last dnode of text */

LSERR ApplyModWidthToPrecedingChar(
						  PLSCHUNKCONTEXT, /* LS chunk context */
						  PLSIOBJCONTEXT, /* installed objects */
						  DWORD ,		/* grpf */
						  LSKJUST,		/* kind of justification */
    					  PLSDNODE); /* non-text dnode after text */

LSERR CutPossibleContextViolation(
						  PLSCHUNKCONTEXT, /* LS chunk context */
						  PLSDNODE ); /* last dnode of text */ 

#endif /* NTIMAN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\plschcon.h ===
#ifndef PLSCHCON_DEFINED
#define PLSCHCON_DEFINED

struct lschunkcontext;
typedef struct lschunkcontext* PLSCHUNKCONTEXT;

#endif /* PLSCHCON_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\objhelp.h ===
#ifndef OBJHELP_DEFINED
#define OBJHELP_DEFINED

#include	"lsdefs.h"
#include	"lstflow.h"
#include	"pobjdim.h"
#include	"plssubl.h"
#include	"lsesc.h"
#include	"plsdnode.h"
#include	"fmtres.h"
#include	"plsqin.h"
#include	"plsqout.h"
#include	"breakrec.h"
#include	"plnobj.h"
#include	"pdobj.h"
#include	"pfmti.h"
#include	"plsrun.h"
#include	"pheights.h"
#include	"mwcls.h"
#include	"brkkind.h"
#include	"pbrko.h"

#define ZeroMemory(a, b) memset(a, 0, b);

#ifdef DEBUG

#define Undefined(pvar) \
{int i; for (i=0; i<sizeof(*pvar); i++) ((BYTE*)pvar) [i] = 255; };

#else

#define Undefined(var) ; /* Nothing in ship-version */

#endif

#define AllocateMemory(pilsobj, cb) ((pilsobj)->lscbk.pfnNewPtr((pilsobj)->pols, (cb)))
#define FreeMemory(pilsobj, ptr) (pilsobj)->lscbk.pfnDisposePtr((pilsobj)->pols, (ptr))

#define NBreaksToSave 3 /* Number of break records to store in objects */

/*
 *	Proc: GetBreakRecordIndex 
 *	Return number of break record based on brkkind enumeration.
 *
 */


DWORD GetBreakRecordIndex (BRKKIND brkkind);

/*
 *	Proc: GetBreakRecordIndex 
 *  Fill trailing info in BRKOUT as if there is no trailing spaces
 *	
 */


LSERR FormatLine(
	PLSC plsc,
	LSCP cpStart,
	long durColMax,
	LSTFLOW lstflow,
	PLSSUBL *pplssubl,
	DWORD cdwlsesc,
	const LSESC *plsesc,
	POBJDIM pobjdim,
	LSCP *pcpOut,
	PLSDNODE *pplsdnStart,
	PLSDNODE *pplsdnEnd,
	FMTRES *pfmtres);

LSERR FormatResumedLine(
	PLSC plsc,
	LSCP cpStart,
	long durColMax,
	LSTFLOW lstflow,
	PLSSUBL *pplssubl,
	DWORD cdwlsesc,
	const LSESC *plsesc,
	POBJDIM pobjdim,
	LSCP *pcpOut,
	PLSDNODE *pplsdnStart,
	PLSDNODE *pplsdnEnd,
	FMTRES *pfmtres,
	const BREAKREC *pbreakrec,
	DWORD cbreakrec);

LSERR CreateQueryResult(
	PLSSUBL plssubl,			/*(IN): subline of ruby */
	long dupAdj,				/*(IN): u offset of start of subline */
	long dvpAdj,				/*(IN): v offset of start of subline */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout);			/*(OUT): query output */

/*
 *  Implementation of LSIMETHOD for objects that do not support the resuming
 *	of formatting. Ruby, Tatenakayoko and Hih are examples of this kind of
 *	object.
 */
LSERR WINAPI ObjHelpFmtResume(
	PLNOBJ plnobj,				/* (IN): object lnobj */
	const BREAKREC *rgBreakRecord,	/* (IN): array of break records */
	DWORD nBreakRecord,			/* (IN): size of the break records array */
	PCFMTIN pcfmtin,			/* (IN): formatting input */
	FMTRES *pfmtres);			/* (OUT): formatting result */

/*
 *  Implementation of LSIMETHOD for objects that do nothing for mod width.
 *	Tatenakayoko and Hih are examples of this kind of object.
 */
LSERR WINAPI ObjHelpGetModWidthChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the preceding char */
	PCHEIGHTS pcheightsRef,		/* (IN): height info about character */
	WCHAR wchar,				/* (IN): preceding character */
	MWCLS mwcls,				/* (IN): ModWidth class of preceding character */
	long *pdurChange);			/* (OUT): amount by which width of the preceding char is to be changed */

/*
 *		Implementation of LSIMETHOD for objects that do nothing for SetBreak.
 *		Tatenakayoko and Hih are examples of this kind of object.
 */

LSERR WINAPI ObjHelpSetBreak(
	PDOBJ pdobj,				/* (IN): dobj which is broken */
	BRKKIND brkkind,			/* (IN): Previous / Next / Force / Imposed was chosen */
	DWORD cBreakRecord,			/* (IN): size of array */
	BREAKREC *rgBreakRecord,	/* (IN): array of break records */
	DWORD *pcActualBreakRecord);	/* (IN): actual number of used elements in array */

/*
 *		Default implementation of LSIMETHOD for objects that do not
 *		allow expanding the previous character.
 */

LSERR WINAPI ObjHelpFExpandWithPrecedingChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the preceding char */
	WCHAR wchar,				/* (IN): preceding character */
	MWCLS mwcls,				/* (IN): ModWidth class of preceding character*/ 
	BOOL *pfExpand);			/* (OUT): (OUT): expand preceding character? */

/*
 *		Default implementation of LSIMETHOD for objects that do not
 *		allow expanding themselves.
 */
LSERR WINAPI ObjHelpFExpandWithFollowingChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the following char */
	WCHAR wchar,				/* (IN): following character */
	MWCLS mwcls,				/* (IN): ModWidth class of following character*/ 
	BOOL *pfExpand);			/* (OUT): expand object? */

#endif /* !OBJHELP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\plsiocon.h ===
#ifndef PLSIOCON_DEFINED
#define PLSIOCON_DEFINED

struct lsiobjcontext;
typedef struct lsiobjcontext* PLSIOBJCONTEXT;

#endif /* PLSIOCON_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\plstbcon.h ===
#ifndef PLSTBCON_DEFINED
#define PLSTBCON_DEFINED

struct lstabscontext;
typedef struct lstabscontext* PLSTABSCONTEXT;

#endif /* PLSTBCON_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\pqheap.h ===
#ifndef PQHEAP_DEFINED
#define PQHEAP_DEFINED

typedef struct qheap* PQHEAP;

#endif /* PQHEAP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\prepdisp.h ===
#ifndef PREPDISP_DEFINED
#define PREPDISP_DEFINED

#include "lsidefs.h"
#include "plsline.h"
#include "plssubl.h"
#include "lskjust.h"

LSERR PrepareLineForDisplayProc(PLSLINE);

LSERR MatchPresSubline(PLSSUBL);		/* IN: subline context		*/

LSERR AdjustSubline(PLSSUBL,			/* IN: subline context		*/
						LSKJUST,		/* IN: justification type	*/
						long,			/* IN: dup desired			*/
						BOOL);			/* IN: fTrue - compress, fFalse - expand */
						

#endif /* PREPDISP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\port.h ===
#ifndef PORT_DEFINED
#define PORT_DEFINED

#include "lsdefs.h"

#ifndef BIG_ENDIAN
#define fPortTntiKern				0x0001
#define fPortTntiModWidthOnRun		0x0002
#define fPortTntiModWidthSpace		0x0004
#define fPortTntiModWidthPairs		0x0008
#define fPortTntiCompressOnRun		0x0010
#define fPortTntiCompressSpace		0x0020
#define fPortTntiCompressTable		0x0040
#define fPortTntiExpandOnRun		0x0080
#define fPortTntiExpandSpace		0x0100
#define fPortTntiExpandTable		0x0200
#define fPortTntiGlyphBased			0x0400
#else
#define fPortTntiKern				0x8000
#define fPortTntiModWidthOnRun		0x4000
#define fPortTntiModWidthSpace		0x2000
#define fPortTntiModWidthPairs		0x1000
#define fPortTntiCompressOnRun		0x0800
#define fPortTntiCompressSpace		0x0400
#define fPortTntiCompressTable		0x0200
#define fPortTntiExpandOnRun		0x0100
#define fPortTntiExpandSpace		0x0080
#define fPortTntiExpandTable		0x0040
#define fPortTntiGlyphBased			0x0020
#endif

#ifndef BIG_ENDIAN
#define fPortDisplayInvisible		0x0001
#define fPortDisplayUnderline		0x0002
#define fPortDisplayStrike			0x0004
#define fPortDisplayShade			0x0008
#define fPortDisplayBorder			0x0010
#define fPortDisplayHyphen			0x0020
#define fPortDisplayCheckForReplaceChar		0x0040
#else
#define fPortDisplayInvisible		0x8000
#define fPortDisplayUnderline		0x4000
#define fPortDisplayStrike			0x2000
#define fPortDisplayShade			0x1000
#define fPortDisplayBorder			0x0800
#define fPortDisplayHyphen			0x0400
#define fPortDisplayCheckForReplaceChar		0x0200
#endif


struct lschpint							/* Character properties */
{
	WORD idObj;							/* Object type */
	BYTE dcpMaxContext;

	BYTE EffectsFlags;

    /* Property flags */
	struct 
		{
		WORD Flags1;
		WORD Flags2;
		} cast;

	
	long dvpPos;  		/* for dvpPos values, */
						/*  pos => raised, neg => lowered, */
};

typedef struct lschpint LSCHPINT;



#define 		FIsTntiFlagsCastWorks(plschp) \
				((UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiKern) != 0) \
						== (plschp)->fApplyKern && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiModWidthOnRun) != 0) \
						== (plschp)->fModWidthOnRun && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiModWidthSpace) != 0) \
						== (plschp)->fModWidthSpace && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiModWidthPairs) != 0) \
						== (plschp)->fModWidthPairs && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiCompressOnRun) != 0) \
						== (plschp)->fCompressOnRun && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiCompressSpace) != 0) \
						== (plschp)->fCompressSpace && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiCompressTable) != 0) \
						== (plschp)->fCompressTable && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiExpandOnRun) != 0) \
						== (plschp)->fExpandOnRun && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiExpandSpace) != 0) \
						== (plschp)->fExpandSpace && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiExpandTable) != 0) \
						== (plschp)->fExpandTable  && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiGlyphBased) != 0) \
						== (plschp)->fGlyphBased  \
				)

#define   		AddNominalToIdealFlags(storage, plschp)  \
				Assert(FIsTntiFlagsCastWorks(plschp)); \
				(storage) |= \
				((LSCHPINT*) (plschp))->cast.Flags1  ;

#define 		GetNominalToIdealFlagsFromLschp(plschp) \
				( Assert(FIsTntiFlagsCastWorks(plschp)), \
				  (((LSCHPINT*) (plschp))->cast.Flags1) \
				)  


#define 		FIsDisplayFlagsCastWorks(plschp) \
				((UINT)(((((LSCHPINT*) (plschp))->cast.Flags2) &  fPortDisplayInvisible) != 0) \
						== (plschp)->fInvisible && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags2) &  fPortDisplayUnderline) != 0) \
						== (plschp)->fUnderline && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags2) &  fPortDisplayStrike) != 0) \
						== (plschp)->fStrike && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags2) &  fPortDisplayShade) != 0) \
						== (plschp)->fShade && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags2) &  fPortDisplayBorder) != 0) \
						== (plschp)->fBorder && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags2) &  fPortDisplayHyphen) != 0) \
						== (plschp)->fHyphen && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags2) &  fPortDisplayCheckForReplaceChar) != 0) \
						== (plschp)->fCheckForReplaceChar  \
				)

				
#define   		AddDisplayFlags(storage, plschp)  \
				Assert(FIsDisplayFlagsCastWorks((plschp)));   \
				(storage) |= \
				((LSCHPINT*) (plschp))->cast.Flags2  ;


#endif /* CHNUTILS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\posinln.h ===
#ifndef POSINLN_DEFINED
#define POSINLN_DEFINED

#include "lsdefs.h"
#include "plssubl.h"
#include "plsdnode.h"

typedef struct posinline
{
	PLSSUBL plssubl;			/* subline where position is located */
	PLSDNODE plsdn;				/* dnode where position is located */
	POINTUV  pointStart;		/* pen position before this dnode */
	LSDCP 	 dcp;				/* dcp in the dnode 			  */
} POSINLINE;

#endif /* POSINLN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\qheap.h ===
#ifndef QHEAP_DEFINED
#define QHEAP_DEFINED

#include "lsidefs.h"
#include "pqheap.h"

PQHEAP CreateQuickHeap(PLSC, DWORD, DWORD, BOOL);
void DestroyQuickHeap(PQHEAP);
void* PvNewQuickProc(PQHEAP);
void DisposeQuickPvProc(PQHEAP, void*);
void FlushQuickHeap(PQHEAP);

#ifdef DEBUG
DWORD CbObjQuick(PQHEAP);
#endif


#define PvNewQuick(pqh, cb) \
		(Assert((cb) == CbObjQuick(pqh)), PvNewQuickProc(pqh))

#define DisposeQuickPv(pqh, pv, size) \
		(Assert(size == CbObjQuick(pqh)), DisposeQuickPvProc(pqh,pv))

#endif /* QHEAP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\setfmtst.h ===
#ifndef SETFMTST_DEFINED
#define SETFMTST_DEFINED

#include "zqfromza.h"
#include "lsdefs.h"


/* M A X */
/*----------------------------------------------------------------------------
    %%Macro: Max
    %%Contact: igorzv

	Returns the maximum of two values a and b.
----------------------------------------------------------------------------*/
#define Max(a,b)			((a) < (b) ? (b) : (a))



#define SetDnodeToFinish(plsc, plsdn)	((plsc)->lslistcontext.plsdnToFinish = plsdn)

#define SetCurrentSubline(plsc, plssubl)	((plsc)->lslistcontext.plssublCurrent = plssubl)

#define AdvanceCurrentCpLimSubl(plssubl, dcp)  ((plssubl)->cpLim += dcp)
#define AdvanceCurrentCpLim(plsc, dcp)			AdvanceCurrentCpLimSubl(GetCurrentSubline(plsc), dcp)

#define SetCurrentCpLimSubl(plssubl, cp)  ((plssubl)->cpLim = cp)
#define SetCurrentCpLim(plsc, cp)			SetCurrentCpLimSubl(GetCurrentSubline(plsc), cp)

#define SetCurrentUrSubl(plssubl, ur)		((plssubl)->urCur = ur)
#define SetCurrentUr(plsc, ur)			SetCurrentUrSubl(GetCurrentSubline(plsc), ur)

#define SetCurrentVrSubl(plssubl, vr)		((plssubl)->vrCur = vr)
#define SetCurrentVr(plsc, vr)			SetCurrentVrSubl(GetCurrentSubline(plsc), vr)

#define AdvanceCurrentUrSubl(plssubl, dur)		if ((plssubl)->urCur >= uLsInfiniteRM - dur) \
													return lserrTooLongParagraph; \
												((plssubl)->urCur += dur);
#define AdvanceCurrentUr(plsc, dur)			AdvanceCurrentUrSubl(GetCurrentSubline(plsc), dur)

#define AdvanceCurrentVrSubl(plssubl, dvr)		if ((plssubl)->vrCur >= uLsInfiniteRM - dvr) \
													return lserrTooLongParagraph; \
												((plssubl)->vrCur += dvr);

#define AdvanceCurrentVr(plsc, dvr)			AdvanceCurrentVrSubl(GetCurrentSubline(plsc), dvr)

#define SetCurrentDnodeSubl(plssubl, plsdn)	((plssubl)->plsdnLast = (plsdn)); \
											if ((plsdn) == NULL) ((plssubl)->plsdnFirst = NULL);
#define SetCurrentDnode(plsc, plsdn)			SetCurrentDnodeSubl(GetCurrentSubline(plsc), plsdn)

#define SetBreakthroughLine(plsc, urRightMargin)    \
				(plsc)->plslineCur->lslinfo.fTabInMarginExLine = fTrue; \
				(plsc)->lsadjustcontext.urRightMarginJustify = \
				(plsc)->urRightMarginBreak == 0 ?  \
						(plsc)->lsadjustcontext.urRightMarginJustify + (urRightMargin) \
						: \
							((plsc)->lsadjustcontext.urRightMarginJustify / \
									(plsc)->urRightMarginBreak )\
							* (urRightMargin); \
				(plsc)->urRightMarginBreak = (urRightMargin); \
				(plsc)->plslineCur->lssubl.urColumnMax = (urRightMargin); \

#define IncreaseFormatDepth(plsc)  ((plsc)->lslistcontext.nDepthFormatLineCurrent++, \
									(plsc)->plslineCur->lslinfo.nDepthFormatLineMax = \
										Max((plsc)->lslistcontext.nDepthFormatLineCurrent, \
											(plsc)->plslineCur->lslinfo.nDepthFormatLineMax))

#define DecreaseFormatDepth(plsc)  ((plsc)->lslistcontext.nDepthFormatLineCurrent--)

#define SetCpLimDisplaySubl(plssubl, cp)	((plssubl)->cpLimDisplay = cp)
#define SetCpLimDisplay(plsc, cp)	SetCpLimDisplaySubl(GetCurrentSubline(plsc), cp)

#define SetLastDnodeDisplaySubl(plssubl, plsdn)	((plssubl)->plsdnLastDisplay = plsdn)
#define SetLastDnodeDisplay(plsc, plsdn)		SetLastDnodeDisplaySubl(GetCurrentSubline(plsc), plsdn)

#endif /* SETFMTST_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\sobjhelp.h ===
#ifndef SOBJHELP_DEFINED
#define SOBJHELP_DEFINED

/*
 *	sobjhelp.h
 *
 *	This file contains interface that help simple objects (objects
 *	which don't break internally) handle breaking and queries. All objects
 *	that use these routines must as the first entry in their dobj
 *	structure define an SObjCommon entry which these routines 
 *	will cast dobj's to. Current users of this interface are
 *	HIH, Ruby and Tatenakayoko.
 *
 */

typedef struct SOBJHELP
{
	OBJDIM		objdimAll;		/* dimensions of object */
	LSDCP		dcp;			/* characters contained in objects */
	long		durModAfter;	/* Mod width after - need if we break to remove
								   the character following we naturally have to
								   remove the space modification it caused. */
} SOBJHELP, *PSOBJHELP;

LSERR WINAPI SobjTruncateChunk(
	PCLOCCHNK plocchnk,			/* (IN): locchnk to truncate */
	PPOSICHNK posichnk);		/* (OUT): truncation point */

LSERR WINAPI SobjFindPrevBreakChunk(
	PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
	PCPOSICHNK pcpoischnk,		/* (IN): place to start looking for break */
	BRKCOND brkcond,			/* (IN): recommmendation about the break after chunk */
	PBRKOUT pbrkout);			/* (OUT): results of breaking */

LSERR WINAPI SobjFindNextBreakChunk(
	PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
	PCPOSICHNK pcpoischnk,		/* (IN): place to start looking for break */
	BRKCOND brkcond,			/* (IN): recommmendation about the break before chunk */
	PBRKOUT pbrkout);			/* (OUT): results of breaking */

LSERR WINAPI SobjForceBreakChunk(
	PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
	PCPOSICHNK pcposichnk,		/* (IN): place to start looking for break */
	PBRKOUT pbrkout);			/* (OUT): results of breaking */

#endif /* SOBJHELP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\stopres.h ===
#ifndef STOPRES_DEFINED
#define STOPRES_DEFINED


enum stopres
{
	stoprEndPara,						/* reached defined para end (from LSPAP) */
	stoprAltEndPara,					/* reached defined alt para end (LSPAP) */
	stoprSoftCR,						/* reached Soft CR (from LSTXTCFG) */
	stoprEndColumn,						/* reached end column character */
	stoprEndSection,					/* reached end section character */
	stoprEndPage,						/* reached end page character */
};

typedef enum stopres STOPRES;

#endif /* !FMTRES_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\tnti.h ===
#ifndef TNTI_DEFINED
#define TNTI_DEFINED

#include "lsdefs.h"
#include "port.h"

#define fTntiKern				fPortTntiKern
#define fTntiModWidthOnRun		fPortTntiModWidthOnRun
#define fTntiModWidthSpace		fPortTntiModWidthSpace
#define fTntiModWidthPairs		fPortTntiModWidthPairs
#define fTntiCompressOnRun		fPortTntiCompressOnRun
#define fTntiCompressSpace		fPortTntiCompressSpace
#define fTntiCompressTable		fPortTntiCompressTable
#define fTntiExpandOnRun		fPortTntiExpandOnRun
#define fTntiExpandSpace		fPortTntiExpandSpace
#define fTntiExpandTable		fPortTntiExpandTable
#define fTntiGlyphBased			fPortTntiGlyphBased

#endif /* !TNTI_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\tlpr.h ===
#ifndef TLPR_DEFINED
#define TLPR_DEFINED

#include "lsdefs.h"
#include "lskeop.h"

#include "lstxtffi.h"

typedef struct tlpr						/* text line properties */
{
	DWORD grpfText;						/* text part of lsffi.h---fTxt flags */
	BOOL fSnapGrid;
	long duaHyphenationZone;			/* Hyphenation zone --- document property */
	LSKEOP lskeop;						/* Kind of para ending	*/
} TLPR;			

#endif /* !TLPR_DEFINED                          */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\tabutils.h ===
#ifndef TABUTILS_DEFINED
#define TABUTILS_DEFINED

#include "lsdefs.h"
#include "plstbcon.h"
#include "plsdnode.h"
#include "lsktab.h"
#include "plssubl.h"

#define SetCpInPara(lstabscontext, cp) \
						lstabscontext.cpInPara = (cp);
   

#define InitLineTabsContext(lstabscontext, ColumnMax, cp, ResolveTabsAsWord97)      \
						lstabscontext.fTabsInitialized = fFalse;\
						lstabscontext.urColumnMax = (ColumnMax);\
						lstabscontext.plsdnPendingTab = NULL;\
						lstabscontext.fResolveTabsAsWord97 = (ResolveTabsAsWord97);\
						SetCpInPara(lstabscontext, cp);


#define CancelPendingTab(plstabscontext) 		((plstabscontext)->plsdnPendingTab = NULL)


LSERR GetCurTabInfoCore(
							PLSTABSCONTEXT plstabscontext,	/* IN: Pointer to LS tabs context */
							PLSDNODE plsdnTab,				/* IN: plsdnTab		*/
							long urBeforeTab,				/* IN: position before this tab */
							BOOL fResolveAllTabsAsLeft,		/* IN: switch all other tab to left */
							LSKTAB* plsktab,				/* OUT: Type of current tab  */
							BOOL* pfBreakThroughTab);		/* OUT: fBreakThroughTab		*/						

LSERR ResolvePrevTabCore(
						PLSTABSCONTEXT plstabscontext,	/* IN: Pointer to LS tabs context */
						PLSDNODE plsdnCurrent,			/* IN: current dnode */
						long urCurrentPen,				/* IN: Current pen position */
						long* pdurPendingTab);			/* OUT: offset because of pending tab */

LSERR InitTabsContextForAutoDecimalTab(PLSTABSCONTEXT plstabscontext,	/* IN: Pointer to LS tabs context */
									  long durAutoDecimalTab);			/* IN: durAutoDecimalTab */

LSERR GetMarginAfterBreakThroughTab(PLSTABSCONTEXT plstabscontext,	/* IN: pointer to LS tabs context */
								   PLSDNODE plsdnTab,				/* IN: tab which triggered breakthrough tab */
								   long* purNewMargin);				/* OUT: new margin because of breakthrough tab */


#endif /* TABUTILS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\txtconst.h ===
#ifndef TXTCONST_DEFINED
#define TXTCONST_DEFINED

#define txtobjMaxM 10

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\sublutil.h ===
#ifndef SUBLUTIL_DEFINED
#define SUBLUTIL_DEFINED

#include "lsdefs.h"
#include "plssubl.h"
#include "plsrun.h"
#include "pobjdim.h"
#include "plsiocon.h"
#include "lscbk.h"
#include "pqheap.h"

/* ROUTINES ------------------------------------------------------------------------------*/

LSERR	DestroySublineCore(PLSSUBL plssubl,LSCBK* plscbk, POLS pols,
						   PLSIOBJCONTEXT plsiobjcontext, BOOL fDontReleaseRuns);

LSERR	GetObjDimSublineCore(
							 PLSSUBL plssubl,			/* IN: subline			*/
							 POBJDIM pobjdim);			/* OUT: dimension of subline */

LSERR  GetDupSublineCore(
							PLSSUBL plssubl,			/* IN: Subline Context			*/
					 	    long* pdup);				/* OUT: dup of subline			*/


LSERR   GetSpecialEffectsSublineCore(
									 PLSSUBL plssubl,	/* IN: subline			*/
									 PLSIOBJCONTEXT plsiobjcontext, /* objects methods */
									 UINT* pEffectsFlags);	/* OUT: special effects */

BOOL   FAreTabsPensInSubline(
						   PLSSUBL plssubl);				/* IN: subline */

LSERR	GetPlsrunFromSublineCore(
							    PLSSUBL	plssubl,		/* IN: subline */
								DWORD   crgPlsrun,		/* IN: size of array */
								PLSRUN* rgPlsrun);		/* OUT: array of plsruns */

LSERR	GetNumberDnodesCore(
							PLSSUBL	plssubl,	/* IN: subline */
							DWORD* cDnodes);	/* OUT: numberof dnodes in subline */


							
LSERR 	GetVisibleDcpInSublineCore(
								   PLSSUBL plssubl,	 /* IN: subline						*/
								   LSDCP*  pndcp);	 /* OUT:amount of visible characters in subline */

LSERR 	FIsSublineEmpty(
						PLSSUBL plssubl,		/* IN: subline						*/
						 BOOL*  pfEmpty);		/* OUT:is this subline empty */

LSERR GetDurTrailInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							long*);				/* OUT: width of trailing area
																 in subline		*/

LSERR GetDurTrailWithPensInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							long*);				/* OUT: width of trailing area
																 in subline		*/

#endif /* SUBLUTIL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\textenum.h ===
#ifndef TEXTENUM_DEFINED
#define TEXTENUM_DEFINED

#include "lsidefs.h"
#include "plsrun.h"
#include "pdobj.h"

LSERR WINAPI EnumObjText(PDOBJ, PLSRUN, PCLSCHP, LSCP, LSDCP, LSTFLOW, BOOL,
												BOOL, const POINT*, PCHEIGHTS, long);
	/* Enum object
	 *  pdobj (IN): dobj to enumerate
	 *  plsrun (IN): from DNODE
	 *  plschp (IN): from DNODE
	 *  cpFirst (IN): from DNODE
	 *  dcp (IN): from DNODE
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryNeeded (IN):
	 *  pptStart (IN): starting position (top left), iff fGeometryNeeded
	 *  pheightsPres(IN): from DNODE, relevant iff fGeometryNeeded
	 *  dupRun(IN): from DNODE, relevant iff fGeometryNeeded
	*/


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\txtginf.h ===
#ifndef TXTGINF_DEFINED
#define TXTGINF_DEFINED

#include "lsidefs.h"

#define		ginffFirstInContext	1
#define		ginffLastInContext	2
#define		ginffOneToOne		4

typedef BYTE TXTGINF;

#endif /* !TXTGINF_DEFINED													*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\txtinf.h ===
#ifndef TXTINF_DEFINED
#define TXTINF_DEFINED

#include "lsidefs.h"

struct txtinf
{
	UINT mwcls : 7;

	UINT fModWidthOnRun : 1;
	UINT fModWidthSpace : 1;
	UINT fHangingPunct : 1;
	UINT fFirstInContext : 1;
	UINT fLastInContext : 1;
	UINT fOneToOne : 1;
		
	UINT prior : 3;
	UINT side : 2;
	UINT fExpand : 1;
};

typedef struct txtinf TXTINF;

#endif /* !TXTINF_DEFINED													*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\brkcls.h ===
#ifndef BRKCLS_DEFINED
#define BRKCLS_DEFINED

#include "lsdefs.h"

typedef DWORD BRKCLS;

#endif /* !BRKCLS_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\txtln.h ===
#ifndef TXTLN_DEFINED
#define TXTLN_DEFINED

#include "lsidefs.h"
#include "plnobj.h"
#include "pilsobj.h"
#include "txtobj.h"
#include "txtginf.h"
#include "gmap.h"
#include "gprop.h"
#include "exptype.h"


struct lnobj
{
	PILSOBJ pilsobj;			/* pointer to txtils						*/
	long wchMax;				/* size of char-based arrays				*/
	TXTOBJ* ptxtobj;			/* pointer to current rgtxtobj array		*/
	TXTOBJ* ptxtobjFirst;		/* pointer to the first rgtxtobj array		*/
	WCHAR* pwch;				/* pointer to rgwch	(char-based)			*/
	long* pdup;					/* pointer to rgdup (char-based)			*/
	long* pdupPenAlloc;			/* pointer to rgdupPen after
								   allocation (char-based)					*/
	long* pdupPen;				/* pointer to rgdupPen 
									 equals pdup or pdupPenAlloc			*/

	long gindMax;				/* size of glyph-based arrays				*/
	GINDEX* pgind;				/* pointer to rggind (glyph-based)			*/
	long* pdupGind;				/* pointer to rgdup (glyph-based)			*/
	GOFFSET* pgoffs;			/* pointer to rggoffs						*/
	long* pdupBeforeJust;		/* pointer to rgdupBeforeJust (glyph-based)	*/
	GMAP* pgmap;				/* pointer to rggmap array (char-based)		*/
	GPROP* pgprop;				/* pointer to rggprop						*/
	EXPTYPE* pexpt;				/* pointer to rgexpt						*/

	PTXTOBJ pdobjHyphen;		/* in case hyphenation took place---
									dobj of YSR char, otehrwise---NULL		*/
	DWORD dwchYsr;				/* length (in iwch) of the Ysr sequence
									including hyphen sign					*/
	BOOL fDrawInCharCodes;		/* Output in metafile---no glyphs, please	*/
};

#endif /* !TXTLN_DEFINED									*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\breakrec.h ===
#ifndef BREAKREC_DEFINED
#define BREAKREC_DEFINED

#include "lsdefs.h"

/* ---------------------------------------------------------------------- */

struct breakrec
{
	DWORD idobj;
	LSCP cpFirst;
};

typedef struct breakrec BREAKREC;

#endif /* !BREAKREC_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\txtils.h ===
#ifndef TXTILS_DEFINED
#define TXTILS_DEFINED

#include "lsidefs.h"
#include "pilsobj.h"
#include "plsrun.h"
#include "plshyph.h"
#include "pheights.h"
#include "plsems.h"
#include "pdobj.h"
#include "lsdevres.h"
#include "lsdevice.h"
#include "lskeop.h"
#include "lstflow.h"
#include "lsact.h"
#include "lspract.h"
#include "lspairac.h"
#include "lsexpan.h"
#include "lsbrk.h"
#include "mwcls.h"
#include "brkcls.h"
#include "brkcond.h"
#include "brkkind.h"
#include "lsexpinf.h"
#include "txtln.h"
#include "txtobj.h"
#include "txtinf.h"
#include "txtginf.h"
#include "lscbk.h"

typedef	enum {
	brktNormal,
	brktHyphen,
	brktNonReq,
	brktOptBreak
} BRKT;

typedef struct
{
	PDOBJ pdobj;
	BRKKIND brkkind;
	LSDCP dcp;
	BRKT brkt;	
	union {
		struct {
			long durFix;
			long igindLim;
		} normal;
		struct {
			long iwchLim;
			long dwchYsr;
			long durHyphen;
			long dupHyphen;
			long durPrev;
			long dupPrev;
			long durPrevPrev;
			long dupPrevPrev;
			long ddurDnodePrev;
			WCHAR wchPrev;
			WCHAR wchPrevPrev;
			GINDEX gindHyphen;
			GINDEX gindPrev;
			GINDEX gindPrevPrev;
			GINDEX gindPad1;	/* makes number of gind's even */
			long igindHyphen;
			long igindPrev;
			long igindPrevPrev;
		} hyphen;
		struct {
			long iwchLim;
			long dwchYsr;
			long durHyphen;
			long dupHyphen;
			long durPrev;
			long dupPrev;
			long durPrevPrev;
			long dupPrevPrev;
			long ddurDnodePrev;
			long ddurDnodePrevPrev;
			long ddurTotal;
			WCHAR wchHyphenPres;
			WCHAR wchPrev;
			WCHAR wchPrevPrev;
			WCHAR wchPad1;	/* makes number of wch's even */
			GINDEX gindPrev;
			GINDEX gindPrevPrev;
			long igindPrev;
			long igindPrevPrev;
		} nonreq;
	} u;
} BREAKINFO;

#define clabRegular 0
#define clabSpace 1
#define clabTab 2
#define clabEOP1 3
#define clabEOP2 4
#define clabAltEOP 5
#define clabEndLineInPara 6
#define clabColumnBreak 7
#define clabSectionBreak 8
#define clabPageBreak 9
#define clabNonBreakSpace 10
#define clabNonBreakHyphen 11
#define clabNonReqHyphen 12
#define clabEmSpace 13
#define clabEnSpace 14
#define clabNull 15
#define clabHardHyphen 16
#define clabNarrowSpace 17
#define clabOptBreak 18
#define clabNonBreak 19
#define clabFESpace	20
#define clabJoiner	21
#define clabNonJoiner 22
#define clabToReplace 23
#define clabSuspicious 32

#define fSpecMask 0x1F

#define wchSpecMax  24

#define wchAddM 50
#define gindAddM 30
#define wSpacesMaxM 30

typedef BYTE CLABEL;

struct ilsobj
{
	PCLSCBK plscbk;				/* Callbacks								*/

	POLS pols;					/* Line Services owner's context			*/
	PLSC plsc;					/* LS's context								*/
	PLNOBJ plnobj;				/* Available lnobj							*/
	
	long wchMax;				/* size of char-based arrays				*/
	long wchMac;				/* last used index in char-based arrays		*/
	WCHAR* pwchOrig;			/* pointer to rgwchOrig (char-based)		*/
	long* pdur;					/* pointer to rgdur	(char-based)			*/
	long* pdurLeft;				/* pointer to rgdurLeft	(char-based)		*/
	long* pdurRight;			/* pointer to rgdurRight (char-based)		*/
	long* pduAdjust;			/* useful compression/expansion/kerning info
									(char-based)							*/
	TXTINF* ptxtinf;			/* pointer to rgtxtinf (char-based)			*/

	long wSpacesMax;			/* size of rgwSpaces array					*/
	long wSpacesMac;			/* last used index in rgwSpaces array		*/
	long* pwSpaces;				/* pointer to rgwSpaces						*/

	long gindMax;				/* size of glyph-based arrays				*/
	long gindMac;				/* last used index in glyph-based arrays	*/

	long* pdurGind;				/* pointer to rgdurGind array (glyph-based)	*/
	TXTGINF* pginf;				/* pointer to rgginf						*/
	
	long* pduGright;			/* pointer to rgduGright (glyph-based)		*/
	LSEXPINFO* plsexpinf;		/* useful glyph-expandion info (glyph-based)*/


	DWORD txtobjMac;			/* last used index in rgtxtobj array		*/
  
	BOOL fNotSimpleText;		/* Set at NTI time; used in AdjustText		*/ 
	BOOL fDifficultForAdjust;	/* Set at formatting time; used to decide if 
								 			QuickAdjustText possible		*/ 

	long iwchCompressFetchedFirst;/* index of the first char with known compr. */
	long itxtobjCompressFetchedLim;/* index of the lim chunk element with known compr. */
	long iwchCompressFetchedLim;/* index of the lim char with known compr. */

	long iwchFetchedWidth;		/* Fetched unused width starts here			*/	
	WCHAR wchFetchedWidthFirst;	/* Expected first char of run				*/
	WCHAR wchPad1;				/* Makes number of chars even				*/
	LSCP cpFirstFetchedWidth;	/* cp from which we expect next run to start */
	long dcpFetchedWidth;		/* N of chars with fetched width			 */
	long durFetchedWidth;		/* width of the piece						*/

	BOOL fTruncatedBefore;

	DWORD breakinfMax;
	DWORD breakinfMac;
	BREAKINFO* pbreakinf;

	long MagicConstantX;
	long durRightMaxX;
	long MagicConstantY;
	long durRightMaxY;

	BOOL fDisplay;				
	BOOL fPresEqualRef;			/* Modified due to Visi issues				*/
	LSDEVRES lsdevres;

	DWORD grpf;					/* flags from lsffi.h --- includes			*/
								/* fHyphenate and fWrapspaces				*/
	BOOL fSnapGrid;
	long duaHyphenationZone;

	LSKEOP lskeop;				/* Kind of line ending						*/

	WCHAR wchSpace;				/* space code								*/
	WCHAR wchHyphen;			/* hyphen code								*/
	WCHAR wchReplace;			/* replace char code						*/
	WCHAR wchNonBreakSpace;		/* non-break space char code				*/

	WCHAR wchVisiNull;			/* visi char for wch=0						*/
	WCHAR wchVisiEndPara;		/* visi char for end of paragraph			*/
	WCHAR wchVisiAltEndPara;	/* visi char for end of table cell			*/
	WCHAR wchVisiEndLineInPara;	/* visi char for wchEndLineInPara (CCRJ)	*/
	WCHAR wchVisiSpace;			/* visi space								*/
	WCHAR wchVisiNonBreakSpace;	/* visi NonBreakSpace						*/
	WCHAR wchVisiNonBreakHyphen;/* visi NonBreakHyphen						*/
	WCHAR wchVisiNonReqHyphen;	/* visi NonReqHyphen						*/
	WCHAR wchVisiTab;			/* visi Tab									*/
	WCHAR wchVisiEmSpace;		/* visi emSpace								*/
	WCHAR wchVisiEnSpace;		/* visi enSpace								*/
	WCHAR wchVisiNarrowSpace;	/* visi NarrowSpace							*/
	WCHAR wchVisiOptBreak;      /* visi char for wchOptBreak				*/
	WCHAR wchVisiNoBreak;		/* visi char for wchNoBreak					*/
	WCHAR wchVisiFESpace;		/* visi char for wchOptBreak				*/
	WCHAR wchPad2;				/* makes number of wch's even				*/

	DWORD cwchSpec;				/* number of special characters > 255		*/
	WCHAR rgwchSpec[wchSpecMax];/* array of special characters  > 255		*/
	CLABEL rgbKind[wchSpecMax];	/* array of meanings of Spec characters>255	*/
	CLABEL rgbSwitch[256];		/* switch table with Special Characters		*/

	DWORD cModWidthClasses;		/* number of ModWidth classes				*/
	DWORD cCompPrior;			/* number of compression priorities			*/

	DWORD clspairact;			/* number of mod pairs info units			*/
	LSPAIRACT* plspairact;		/* pointer to rglspairact(ModPair info unts)*/
	BYTE* pilspairact;			/* rgilspairact(ModPair info---square)		*/

	DWORD clspract;				/* number of compression info units			*/
	LSPRACT* plspract;			/* pointer to rglspract(compress info units)*/
	BYTE* pilspract;			/* rgilspract(comp info---linear)			*/

	DWORD clsexpan;				/* number of expansion info units			*/
	LSEXPAN* plsexpan;			/* pointer to rglsexpan(expan info units)	*/
	BYTE* pilsexpan;			/* rgilsexpan(expan info---square)			*/

	DWORD cBreakingClasses;		/* number of ModWidth classes				*/
	DWORD clsbrk;				/* number of breaking info units			*/
	LSBRK* plsbrk;				/* pointer to rglsbrk(breaking info units)	*/
	BYTE* pilsbrk;				/* rgilsbrk(breaking info---square)			*/
};


#endif /* !TXTILS_DEFINED													*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\brkkind.h ===
#ifndef BRKKIND_DEFINED
#define BRKKIND_DEFINED

#include "lsdefs.h"

typedef enum
{
	brkkindImposedAfter,
	brkkindPrev,
	brkkindNext,
	brkkindForce

} BRKKIND;


#endif /* !BRKKIND_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\brkcond.h ===
#ifndef BRKCOND_DEFINED
#define BRKCOND_DEFINED

#include "lsdefs.h"

typedef enum
{
	brkcondPlease,
	brkcondCan,
	brkcondNever
} BRKCOND;


#endif /* !BRKCOND_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inci\txtobj.h ===
#ifndef TXTOBJ_DEFINED
#define TXTOBJ_DEFINED

#include "lsidefs.h"
#include "plsdnode.h"
#include "plnobj.h"

#define txtkindRegular 0
#define txtkindHardHyphen 1
#define txtkindTab 2
#define txtkindNonReqHyphen 3
#define txtkindYsrChar 4
#define txtkindNonBreakSpace 5			/* Used in decimal tab logic		*/
#define txtkindNonBreakHyphen 6
#define txtkindOptNonBreak 7
#define txtkindSpecSpace 8
#define txtkindOptBreak 9
#define txtkindEOL 10

#define txtfMonospaced 		1
#define txtfVisi			2
#define txtfModWidthClassed	4
#define txtfGlyphBased		8
#define txtfSkipAtNti		16
#define txtfSkipAtWysi		32
#define txtfFirstShaping	64
#define txtfLastShaping		128


struct txtobj
{
	PLSDNODE plsdnUpNode;		/* upper DNode								*/
	PLNOBJ plnobj;

	long iwchFirst; 			/* index of the first char of dobj in rgwch */
	long iwchLim;				/* index of the lim char of dobj in rgwch	*/

	WORD txtkind;
	WORD txtf;

	union
	{
		struct
		{
			long iwSpacesFirst;	/* index of the first Space-index in wSpaces*/
			long iwSpacesLim;	/* index of the lim  Space-index in wSpaces	*/
		} reg;

		struct
		{	  
			WCHAR wch;			/* char code for Tab or Visi Tab			*/
			WCHAR wchTabLeader;	/* leaders info								*/
		} tab;					/* use this for the txtkindTab				*/

	} u;
 
	long igindFirst; 			/* index of the first glyph of dobj in rgwch*/
	long igindLim;				/* index of the lim glyph of dobj in rgwch	*/

	long dupBefore;
};

typedef struct txtobj TXTOBJ;
typedef TXTOBJ* PTXTOBJ;

#endif /* !TXTOBJ_DEFINED													*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\brko.h ===
#ifndef BRKO_DEFINED
#define BRKO_DEFINED

#include "lsdefs.h"
#include "pbrko.h"
#include "objdim.h"
#include "posichnk.h"
#include "brkcond.h"

typedef struct brkout						/* break output */ 
{
	BOOL fSuccessful;						/* break result */
	BRKCOND brkcond;						/* iff !fSuccessful, recommendation on the other side */
	POSICHNK posichnk;
	OBJDIM objdim;
} BRKOUT;


#endif /* !BRKO_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\brkpos.h ===
#ifndef BRKPOS_DEFINED
#define BRKPOS_DEFINED

#include "lsdefs.h"

typedef enum
{
	brkposBeforeFirstDnode,
	brkposInside,
	brkposAfterLastDnode

} BRKPOS;


#endif /* !BRKPOS_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\endres.h ===
#ifndef ENDRES_DEFINED
#define ENDRES_DEFINED

enum endres
{
	endrNormal,
	endrHyphenated,
	endrEndPara,
	endrAltEndPara,
	endrSoftCR,
	endrEndColumn,
	endrEndSection,
	endrEndPage,
	endrEndParaSection,
	endrStopped
};

typedef enum endres ENDRES;

#endif /* ENDRES_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\dispi.h ===
#ifndef DISPI_DEFINED
#define DISPI_DEFINED

#include "lsdefs.h"
#include "pdispi.h"
#include "plsrun.h"
#include "plschp.h"
#include "heights.h"
#include "lstflow.h"

typedef struct dispin
{
	POINT 	ptPen;					/* starting pen position (x,y) */
	PCLSCHP plschp;					/* CHP for this display object */
	PLSRUN 	plsrun;					/* client pointer to run */

	UINT 	kDispMode;				/* display mode, opaque, etc */
	LSTFLOW lstflow;	 			/* text direction and orientation */
	RECT* 	prcClip;				/* clip rectangle (x,y) */

	BOOL 	fDrawUnderline;			/* Draw underline while displaying */
	BOOL 	fDrawStrikethrough;		/* Draw strikethrough while Displaying */

	HEIGHTS heightsPres;
	long 	dup;
	long	dupLimUnderline;		/* less than dup if trailing spaces */
} DISPIN;	

#endif /* !DISPI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\fmti.h ===
#ifndef FMTIO_DEFINED
#define FMTIO_DEFINED

#include "lsdefs.h"
#include "pfmti.h"
#include "plsdnode.h"
#include "lsfgi.h"
#include "lsfrun.h"
#include "lstxm.h"

/* ------------------------------------------------------------------------ */

struct fmtin
{
	LSFGI lsfgi;
	LSFRUN lsfrun;
	PLSDNODE plsdnTop;
	LSTXM lstxmPres;
	LSTXM lstxmRef;
};

/* ------------------------------------------------------------------------ */


#endif /* !FMTIO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\exptype.h ===
#ifndef EXPTYPE_DEFINED
#define EXPTYPE_DEFINED

#include "lsdefs.h"

typedef BYTE EXPTYPE;

/* kinds of glyph expansion */
#define	exptNone  0
#define	exptAddWhiteSpace 1
#define	exptAddInkContinuous 2
#define	exptAddInkDiscrete 3

typedef EXPTYPE* PEXPTYPE;
typedef const EXPTYPE* PCEXPTYPE;


#endif /* !EXPTYPE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\fmtres.h ===
#ifndef FMTRES_DEFINED
#define FMTRES_DEFINED

/* used in fmtio.h and lsfd.h */

enum fmtres							/* Why did the formatter return? */
{
	fmtrCompletedRun,				/* no problems */
	fmtrExceededMargin,				/* reached right margin */
	fmtrTab,						/* reached tab				  */
	fmtrStopped						
};

typedef enum fmtres FMTRES;

#endif /* !FMTRES_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\gmap.h ===
#ifndef GMAP_DEFINED
#define GMAP_DEFINED

#include "lsdefs.h"

typedef WORD GMAP;
typedef GMAP* PGMAP;
typedef const GMAP* PCGMAP;

#endif /* !GMAP_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\kamount.h ===
#ifndef KAMOUNT_DEFINED
#define KAMOUNT_DEFINED

#include "lsdefs.h"
/* Interpretation for kamnBy... is as follows:
	Compression			-
	Expansion			+
	PunctStartLine   	-
	ModWidthPairs		-
	ModWidthSpace		+
	ModWidthOnRun		+
*/


typedef BYTE KAMOUNT;

#define kamntNone				0
#define kamntToHalfEm			1
#define kamntToQuarterEm		2
#define kamntToThirdEm			3
#define kamntTo15Sixteenth		4
#define kamntByHalfEm			5
#define kamntByQuarterEm		6
#define kamntByEighthEm			7
#define kamntByUserDefinedExpan	8	
#define kamntByUserDefinedComp	9	
#define kamntToUserDefinedExpan	10	
#define kamntToUserDefinedComp	11	


#endif /* !KAMOUNT_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\gprop.h ===
#ifndef GPROP_DEFINED
#define GPROP_DEFINED

#include "lsdefs.h"

typedef WORD GPROP;
typedef GPROP* PGPROP;
typedef const GPROP* PCGPROP;

#endif /* !GPROPS_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\locchnk.h ===
#ifndef LOCCHNK_DEFINED
#define LOCCHNK_DEFINED

#include "lsdefs.h"
#include "lsfgi.h"
#include "lschnke.h"

typedef struct locchnk					/* located chnk					*/
{
	LSFGI lsfgi;						/* location of chunk			*/
	DWORD clschnk;						/* number of dobj's in chunk	*/
	PLSCHNK plschnk;					/* chunk 						*/
	PPOINTUV ppointUvLoc;				/* location of each chunk's node*/
} LOCCHNK;



#endif /* !LOCCHNK_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\hih.h ===
#ifndef HIH_DEFINED
#define HIH_DEFINED

#include "lsimeth.h"

/*
 *	H(orizontal)I(n)H(orizontal)
 *
 *	This object is designed to help client implementations which use 
 *	Tatenakayoko and wish to be able to convert the display from vertical
 *	to horizontal and then to display the Tatenakayoko text as horizontal.
 *	To do this the client application simply changes the object handler
 *	from the Tatenakayoko handler to this object handler and the text
 *	will be displayed horizontally.
 *	
 */

/* typedef for callback to client for enumeration */
typedef LSERR(WINAPI * PFNHIHENUM)(
	POLS pols,				/*(IN): client context */
	PLSRUN plsrun,			/*(IN): from DNODE */
	PCLSCHP plschp,			/*(IN): from DNODE */
	LSCP cp,				/*(IN): from DNODE */
	LSDCP dcp,				/*(IN): from DNODE */
	LSTFLOW lstflow,		/*(IN): text flow*/
	BOOL fReverse,			/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,	/*(IN): */
	const POINT* pt,		/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,	/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun,			/*(IN): from DNODE, relevant iff fGeometryNeeded*/
	PLSSUBL plssubl);		/*(IN): subline in hih object. */

/*
 *
 *	HIH object initialization data that the client application must return
 *	when the HIH object handler calls the GetObjectHandlerInfo callback.
 */

#define HIH_VERSION 0x300

typedef struct HIHINIT
{
	DWORD				dwVersion;		/* Version. Must be HIH_VERSION */
	WCHAR				wchEndHih;		/* Escape for end of HIH object */
	WCHAR				wchUnused1;
	WCHAR				wchUnused2;
	WCHAR				wchUnused3;
	PFNHIHENUM			pfnEnum;		/* Enumeration callback */
} HIHINIT, *PHIHINIT;

LSERR WINAPI LsGetHihLsimethods(
	LSIMETHODS *plsim);

/* GetHihLsimethods
 *	
 *	plsim (OUT): Hih object methods for Line Services
 *
 */

#endif /* HIH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\heights.h ===
#ifndef HEIGHTS_DEFINED
#define HEIGHTS_DEFINED

#include "lsdefs.h"
#include "pheights.h"

#define dvHeightIgnore 0x7FFFFFFF

typedef struct heights
{
	long dvAscent;
	long dvDescent;
	long dvMultiLineHeight;
} HEIGHTS;

#endif /* !HEIGHTS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsact.h ===
#ifndef LSACT_DEFINED
#define LSACT_DEFINED

#include "lsdefs.h"
#include "kamount.h"

#define sideNone				0		/* means no action				*/
#define sideLeft				1
#define sideRight				2
#define sideLeftRight			3		/* Review(segeyge): how to distribute?*/

typedef struct lsact					/* action							*/
{
	BYTE side;							/* side of action (left/right/both)	*/
	KAMOUNT kamnt;						/* amount of action					*/
} LSACT;


#endif /* !LSACT_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsbrk.h ===
#ifndef LSBRK_DEFINED
#define LSBRK_DEFINED

#include "lsdefs.h"

typedef struct lsbrk					/* breaking information unit		*/
{
	BYTE fBreak;						/* break for neibours	*/
	BYTE fBreakAcrossSpaces;			/* break across spaces	*/
} LSBRK;									


#endif /* !LSBRK_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lscell.h ===
#ifndef LSCELL_DEFINED
#define LSCELL_DEFINED

#include "lsdefs.h"
#include "plscell.h"
#include "pcelldet.h"
#include "plscell.h"

struct lstextcell
{
	LSCP cpStartCell;
	LSCP cpEndCell;
 	POINTUV pointUvStartCell;		/* In coordinate system of main line/subline */
	long dupCell;					/* In direction lstflowSubline			*/

	DWORD cCharsInCell;
	DWORD cGlyphsInCell;

	PCELLDETAILS pCellDetails;

};

typedef struct lstextcell LSTEXTCELL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsbrjust.h ===
#ifndef LSBRJUST_DEFINED
#define LSBRJUST_DEFINED

enum lsbreakjust							/* kinds of breaking/justification */
{
	lsbrjBreakJustify,						/* Regular US */
	lsbrjBreakWithCompJustify,				/* FE & Newspaper */
	lsbrjBreakThenExpand,					/* Arabic			 */
	lsbrjBreakThenSqueeze					/* Word Perfect			 */
};

typedef enum lsbreakjust LSBREAKJUST;

#endif /* !LSBRJUST_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lschnke.h ===
#ifndef LSCHNKE_DEFINED
#define LSCHNKE_DEFINED

#include "lsdefs.h"
#include "plschp.h"
#include "plsrun.h"
#include "pdobj.h"

typedef struct lschnke
{
	LSCP cpFirst;
	LSDCP dcp;
	PCLSCHP plschp;
	PLSRUN plsrun;
	PDOBJ pdobj;
} LSCHNKE;

typedef LSCHNKE* PLSCHNK;
typedef const LSCHNKE* PCLSCHNK;

#endif  /* !LSCHNKE_DEFINED   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lscontxt.h ===
#ifndef LSCONTXT_DEFINED
#define LSCONTXT_DEFINED

#include "lsdefs.h"
#include "lscbk.h"
#include "lstxtcfg.h"
#include "lsimeth.h"


typedef struct 
{
	DWORD version;						/* version number	*/
	DWORD cInstalledHandlers;
	const LSIMETHODS* pInstalledHandlers; /* Installed handlers */
	LSTXTCFG lstxtcfg;					/* Straight-text configuration data */
	POLS pols;							/* Client data for this context */
	LSCBK lscbk;						/* LineServices client callbacks */
	BOOL fDontReleaseRuns;				/* Optimization---don't call pfnReleaseRun */
} LSCONTEXTINFO;


LSERR WINAPI LsCreateContext(const LSCONTEXTINFO*, PLSC*);
LSERR WINAPI LsDestroyContext(PLSC);

#endif /* LSCONTXT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lschp.h ===
#ifndef LSCHP_DEFINED
#define LSCHP_DEFINED

#include "lsdefs.h"
#include "plschp.h"

#define idObjTextChp	((WORD)~0)		/* idObj for FetchRun to use  */
										/*  when returning a text run */
										/*  (Internal id will differ.) */

/* LS expects that for GlyphBased runs the following flags are set to FALSE:
			fApplyKern
			fModWidthSpace
			fModWidthPairs
			fCompressTable
*/

struct lschp							/* Character properties */
{
	WORD idObj;							/* Object type */
	BYTE dcpMaxContext;

	BYTE EffectsFlags;

    /* Property flags */
	UINT fApplyKern : 1;
	UINT fModWidthOnRun:1;
	UINT fModWidthSpace:1;
	UINT fModWidthPairs:1;
	UINT fCompressOnRun:1;
	UINT fCompressSpace:1;
	UINT fCompressTable:1;
	UINT fExpandOnRun:1;
	UINT fExpandSpace:1;
	UINT fExpandTable:1;
	UINT fGlyphBased : 1;

	UINT pad1:5;

	UINT fInvisible : 1;
	UINT fUnderline : 1;				
	UINT fStrike : 1;
	UINT fShade : 1;				
	UINT fBorder : 1;				
	UINT fHyphen : 1;					/* Hyphenation opportunity (YSR info) */
	UINT fCheckForReplaceChar : 1;		/* Activate the replace char mechanizm for Yen	*/

	UINT pad2:9;
										/* for dvpPos values, */
										/*  pos => raised, neg => lowered, */
	long dvpPos;
};

typedef struct lschp LSCHP;

#endif /* !LSCHP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lscbk.h ===
#ifndef LSCBK_DEFINED
#define LSCBK_DEFINED

/* LineServices callbacks */

#include "lsdefs.h"
#include "lsdevice.h"
#include "lsksplat.h"
#include "lskjust.h"
#include "lstflow.h"
#include "endres.h"
#include "mwcls.h"
#include "lsact.h"
#include "lspract.h"
#include "brkcond.h"
#include "brkcls.h"
#include "gprop.h"
#include "gmap.h"
#include "lsexpinf.h"
#include "lskalign.h"
#include "plstabs.h"
#include "pheights.h"
#include "plsrun.h"
#include "plscbk.h"
#include "plschp.h"
#include "plspap.h"
#include "plstxm.h"
#include "plshyph.h"
#include "plsstinf.h"
#include "plsulinf.h"
#include "plsems.h"

#define cpFirstAnm (-0x7FFFFFFF)   /* Used for the fetch of the first Autonumber run */


struct lscbk	/* Interfaces to application-specific callbacks */
{
	/* Dynamic memory APIs */
	void* (WINAPI* pfnNewPtr)(POLS, DWORD);
	void  (WINAPI* pfnDisposePtr)(POLS, void*);
	void* (WINAPI* pfnReallocPtr)(POLS, void*, DWORD);


	LSERR (WINAPI* pfnFetchRun)(POLS, LSCP,
							    LPCWSTR*, DWORD*, BOOL*, PLSCHP, PLSRUN*);
	/* FetchRun:
	 *  pols (IN):
	 *  cp (IN):
	 *  &lpwchRun (OUT): run of characters.
	 *  &cchRun (OUT): number of characters in run
	 *  &fHidden (OUT) : hidden run?
	 *  &lsChp (OUT): char properties of run 
	 *  &plsrun (OUT): abstract representation of run properties
	 */

	LSERR (WINAPI* pfnGetAutoNumberInfo)(POLS, LSKALIGN*, PLSCHP, PLSRUN*, WCHAR*, PLSCHP, PLSRUN*, BOOL*, long*, long*);

	/* GetAutoNumberInfo:
	 *  pols (IN):
	 *  &lskalAnm (OUT):
	 *  &lschpAnm (OUT): lschp for Anm
	 *  &plsrunAnm (OUT): plsrun for Anm
	 *  &wchAdd (OUT): character to add (Nil is treated as none)
	 *  &lschpWch (OUT): lschp for added char
	 *  &plsrunWch (OUT): plsrun for added char
	 *  &fWord95Model(OUT):
	 *  &duaSpaceAnm(OUT):	relevant iff fWord95Model
	 *  &duaWidthAnm(OUT):	relevant iff fWord95Model
	 */

	LSERR (WINAPI* pfnGetNumericSeparators)(POLS, PLSRUN, WCHAR*,WCHAR*);
	/* GetNumericSeparators:
	 *  pols (IN):
	 *  plsrun (IN): run pointer as returned from FetchRun
	 *  &wchDecimal (OUT): decimal separator for this run.
	 *  &wchThousands (OUT): thousands separator for this run
	 */

	LSERR (WINAPI* pfnCheckForDigit)(POLS, PLSRUN, WCHAR, BOOL*);
	/* GetNumericSeparators:
	 *  pols (IN):
	 *  plsrun (IN): run pointer as returned from FetchRun
	 *  wch (IN): character to check
	 *  &fIsDigit (OUT): this character is digit
	 */

	LSERR (WINAPI* pfnFetchPap)(POLS, LSCP, PLSPAP);
	/* FetchPap:
	 *  pols (IN):
	 *  cp (IN): an arbitrary cp value inside the paragraph
	 *  &lsPap (OUT): Paragraph properties.
	 */

	LSERR (WINAPI* pfnFetchTabs)(POLS, LSCP, PLSTABS, BOOL*, long*, WCHAR*);
	/* FetchTabs:
	 *  pols (IN):
	 *  cp (IN): an arbitrary cp value inside the paragraph
	 *  &lstabs (OUT): tabs array
	 *  &fHangingTab (OUT): there is hanging tab
	 *  &duaHangingTab (OUT): dua of hanging tab
	 *  &wchHangingTabLeader (OUT): leader of hanging tab
	 */

	LSERR (WINAPI* pfnGetBreakThroughTab)(POLS, long, long, long*);
	/* GetBreakThroughTab:
	 *  pols (IN):
	 *  uaRightMargin (IN): right margin for breaking
	 *  uaTabPos (IN): breakthrough tab position
	 *  uaRightMarginNew (OUT): new right margin
	 */

	LSERR (WINAPI* pfnFGetLastLineJustification)(POLS, LSKJUST, LSKALIGN, ENDRES, BOOL*, LSKALIGN*);
	/* FGetLastLineJustification:
	 *  pols (IN):
	 *  lskj (IN): kind of justification for the paragraph
	 *  lskal (IN): kind of alignment for the paragraph
	 *  endr (IN): result of formatting
	 *  &fJustifyLastLine (OUT): should last line be fully justified
	 *  &lskalLine (OUT): kind of alignment for this line
	 */

	LSERR (WINAPI* pfnCheckParaBoundaries)(POLS, LSCP, LSCP, BOOL*);
	/* CheckParaBoundaries:
	 *  pols (IN):
	 *  cpOld (IN):
	 *  cpNew (IN):
	 *  &fChanged (OUT): "Dangerous" change between paragraph properties.
	 */

	LSERR (WINAPI* pfnGetRunCharWidths)(POLS, PLSRUN, 
									 	LSDEVICE, LPCWSTR,
										DWORD, long, LSTFLOW,
										int*,long*,long*);
	/* GetRunCharWidths:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  lsDeviceID (IN): presentation or reference
	 *  lpwchRun (IN): run of characters
	 *  cwchRun (IN): number of characters in run
	 *  du (IN): available space for characters
	 *  kTFlow (IN): text direction and orientation
	 *  rgDu (OUT): widths of characters
	 *  &duRun (OUT): sum of widths in rgDx[0] to rgDu[limDx-1]
	 *  &limDu (OUT): number of widths fetched
	 */

	LSERR (WINAPI* pfnCheckRunKernability)(POLS, PLSRUN,PLSRUN, BOOL*);
	/* CheckRunKernability:
	 *  pols (IN):
	 *  plsrunLeft (IN): 1st of pair of adjacent runs
	 *  plsrunRight (IN): 2nd of pair of adjacent runs
	 *  &fKernable (OUT) : if TRUE, Line Service may kern between these runs
	 */

	LSERR (WINAPI* pfnGetRunCharKerning)(POLS, PLSRUN,
										 LSDEVICE, LPCWSTR,
										 DWORD, LSTFLOW, int*);
	/* GetRunCharKerning:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  lsDeviceID (IN): presentation or reference
	 *  lpwchRun (IN): run of characters
	 *  cwchRun (IN): number of characters in run
	 *  kTFlow (IN): text direction and orientation
	 *  rgDu (OUT): widths of characters
	 */

	LSERR (WINAPI* pfnGetRunTextMetrics)(POLS, PLSRUN,
										 LSDEVICE, LSTFLOW, PLSTXM);
	/* GetRunTextMetrics:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  deviceID (IN):  presentation, reference, or absolute
	 *  kTFlow (IN): text direction and orientation
	 *  &lsTxMet (OUT): Text metrics
	 */

	LSERR (WINAPI* pfnGetRunUnderlineInfo)(POLS, PLSRUN, PCHEIGHTS, LSTFLOW,
										   PLSULINFO);
	/* GetRunUnderlineInfo:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  heightsPres (IN):
	 *  kTFlow (IN): text direction and orientation
	 *  &lsUlInfo (OUT): Underline information
	 */

	LSERR (WINAPI* pfnGetRunStrikethroughInfo)(POLS, PLSRUN, PCHEIGHTS, LSTFLOW,
											  PLSSTINFO);
	/* GetRunStrikethroughInfo:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  heightsPres (IN):
	 *  kTFlow (IN): text direction and orientation
	 *  &lsStInfo (OUT): Strikethrough information
	 */

	LSERR (WINAPI* pfnGetBorderInfo)(POLS, PLSRUN, LSTFLOW, long*, long*);
	/* GetBorderInfo:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  kTFlow (IN): text direction and orientation
	 *  &durBorder (OUT): Width of the border on the reference device
	 *  &dupBorder (OUT): Width of the border on the presentation device
	 */


	LSERR (WINAPI* pfnReleaseRun)(POLS, PLSRUN);
	/* ReleaseRun:
	 *  pols (IN):
	 *  plsrun (IN): run to be released, from GetRun() or FetchRun()
	 */

	LSERR (WINAPI* pfnHyphenate)(POLS, PCLSHYPH, LSCP, LSCP, PLSHYPH);
	/* Hyphenate:
	 *  pols (IN):
	 *  &lsHyphLast (IN): last hyphenation found. kysr==kysrNil means "none"
	 *  cpBeginWord (IN): 1st cp in word which exceeds column
	 *  cpExceed (IN): 1st which exceeds column, in this word
	 *  &lsHyph (OUT): hyphenation results. kysr==kysrNil means "none"
	 */

	LSERR (WINAPI* pfnGetHyphenInfo)(POLS, PLSRUN, DWORD*, WCHAR*);
	/* GetHyphenInfo:
	 *  pols (IN):
	 *  plsrun (IN):
     *  kysr (OUT)	  Ysr type - see "lskysr.h"
     *  wchYsr (OUT)  Character code of YSR
	*/

	LSERR (WINAPI* pfnDrawUnderline)(POLS, PLSRUN, UINT,
								const POINT*, DWORD, DWORD, LSTFLOW,
								UINT, const RECT*);
	/* DrawUnderline:
	 *  pols (IN):
	 *  plsrun (IN): run to use for the underlining
	 *  kUlbase (IN): underline kind 
	 *  pptStart (IN): starting position (top left)
	 *  dupUL (IN): underline width
	 *  dvpUL (IN) : underline thickness
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnDrawStrikethrough)(POLS, PLSRUN, UINT,
								const POINT*, DWORD, DWORD, LSTFLOW,
								UINT, const RECT*);
	/* DrawStrikethrough:
	 *  pols (IN):
	 *  plsrun (IN): the run for the strikethrough
	 *  kStbase (IN): strikethrough kind 
	 *  pptStart (IN): starting position (top left)
	 *  dupSt (IN): strikethrough width
	 *  dvpSt (IN) : strikethrough thickness
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnDrawBorder)(POLS, PLSRUN, const POINT*, PCHEIGHTS, PCHEIGHTS,
								  PCHEIGHTS, PCHEIGHTS, long, long, LSTFLOW, UINT, const RECT*);

	/* DrawBorder:
	 *  pols (IN):
	 *  plsrun (IN): plsrun of the first bordered run
	 *  pptStart (IN): starting point for the border
	 *  pheightsLineFull (IN): height of the line including SpaceBefore & SpaceAfter
	 *  pheightsLineWithoutAddedSpace (IN): height of the line without SpaceBefore & SpaceAfter
	 *  pheightsSubline (IN): height of subline
	 *  pheightsRuns (IN): height of collected runs to be bordered
	 *  dupBorder (IN): width of one border
	 *  dupRunsInclBorders (IN): width of collected runs
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnDrawUnderlineAsText)(POLS, PLSRUN, const POINT*,
										   long, LSTFLOW, UINT, const RECT*);
	/* DrawUnderlineAsText:
	 *  pols (IN):
	 *  plsrun (IN): run to use for the underlining
	 *  pptStart (IN): starting pen position
	 *  dupLine (IN): length of UL
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnFInterruptUnderline)(POLS, PLSRUN, LSCP, PLSRUN, LSCP,BOOL*);
	/* FInterruptUnderline:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the previous run
	 *  cpLastFirst (IN): cp of the last character of the previous run
	 *  plsrunSecond (IN): run pointer for the current run
	 *  cpStartSecond (IN): cp of the first character of the current run
	 *  &fInterruptUnderline (OUT): do you want to interrupt drawing of the underline between these runs
	 */

	LSERR (WINAPI* pfnFInterruptShade)(POLS, PLSRUN, PLSRUN, BOOL*);
	/* FInterruptShade:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the previous run
	 *  plsrunSecond (IN): run pointer for the current run
	 *  &fInterruptShade (OUT): do you want to interrupt shading between these runs
	 */

	LSERR (WINAPI* pfnFInterruptBorder)(POLS, PLSRUN, PLSRUN, BOOL*);
	/* FInterruptBorder:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the previous run
	 *  plsrunSecond (IN): run pointer for the current run
	 *  &fInterruptBorder (OUT): do you want to interrupt border between these runs
	 */


	LSERR (WINAPI* pfnShadeRectangle)(POLS, PLSRUN, const POINT*, PCHEIGHTS, PCHEIGHTS,
								  PCHEIGHTS, PCHEIGHTS, PCHEIGHTS, long, long, LSTFLOW, UINT, const RECT*);

	/* ShadeRectangle:
	 *  pols (IN):
	 *  plsrun (IN): plsrun of the first shaded run
	 *  pptStart (IN): starting point for the shading rectangle
	 *  pheightsLineWithAddSpace(IN): height of the line including SpaceBefore & SpaceAfter (main baseline, 
	 *						lstflow of main line)
	 *  pheightsLineWithoutAddedSpace (IN): height of the line without SpaceBefore & SpaceAfter
	 *  pheightsSubline (IN): height of subline (local baseline, lstflow of subline)
	 *  pheightsRunsExclTrail (IN): height of collected runs to be shaded excluding 
	 *									trailing spaces area (local baseline, lstflow of subline)
	 *  pheightsRunsInclTrail (IN): height of collected runs to be shaded including
	 *									trailing spaces area (local baseline, lstflow of subline)
	 *  dupRunsExclTrail (IN): width of collected runs excluding trailing spaces area
	 *  dupRunsInclTrail (IN): width of collected runs including trailing spaces area
	 *  kTFlow (IN): text direction and orientation of subline
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnDrawTextRun)(POLS, PLSRUN, BOOL, BOOL, 
								   const POINT*, LPCWSTR, const int*, DWORD, 
								   LSTFLOW, UINT, const POINT*, PCHEIGHTS, long, long, const RECT*);
	/* DrawTextRun:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  fStrikeout (IN) :
	 *  fUnderline (IN) :
	 *  pptText (IN): starting point for the text output
	 *  lpwchRun (IN): run of characters
	 *  rgDupRun (IN): widths of characters
	 *  cwchRun (IN): number of characters in run
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN): display mode - opaque, transparent
	 *  pptRun (IN): starting point of the run
	 *  heightsPres (IN): presentation heights for this run
	 *  dupRun (IN): presentation width for this run
	 *  dupLimUnderline (IN): underlining limit
	 *  pRectClip (IN): clipping rectangle
	 */

    LSERR (WINAPI* pfnDrawSplatLine)(POLS, enum lsksplat, LSCP, const POINT*,
									 PCHEIGHTS, PCHEIGHTS, PCHEIGHTS, long, LSTFLOW,
									 UINT, const RECT*);
	/* DrawSplatLine:
	 *  pols (IN):
	 *  ksplat (IN): See definitions in lsksplat.h
	 *  cpSplat (IN): location of the break character which caused the splat.
	 *  pptSplatLine (IN) : starting position of the splat line
	 *  pheightsLineFull (IN): height of the line including SpaceBefore & SpaceAfter
	 *  pheightsLineWithoutAddedSpace (IN): height of the line without SpaceBefore & SpaceAfter
	 *  pheightsSubline (IN): height of subline
	 *  dup (IN): distance to right margin
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN): display mode - opaque, transparent
	 *  &rcClip (IN) : clipping rectangle
	 */


/* Advanced typography enabling API's */

	/* Glyph enabling */

	LSERR (WINAPI* pfnFInterruptShaping)(POLS, LSTFLOW, PLSRUN, PLSRUN, BOOL*);
	/* FInterruptShaping:
	 *  pols (IN):
	 *  kTFlow (IN): text direction and orientation
	 *  plsrunFirst (IN): run pointer for the previous run
	 *  plsrunSecond (IN): run pointer for the current run
	 *  &fInterruptShaping (OUT): do you want to interrupt character shaping between these runs
	*/

	LSERR (WINAPI* pfnGetGlyphs)(POLS, PLSRUN, LPCWSTR, DWORD, LSTFLOW, PGMAP, PGINDEX*, PGPROP*, DWORD*);
	/* GetGlyphs:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  pwch (IN): pointer to the string of character codes
	 *  cwch (IN): number of characters to be shaped
	 *  kTFlow (IN): text direction and orientation
	 *  rgGmap (OUT): parallel to the char codes mapping wch->glyph info
	 *  &rgGindex (OUT): array of output glyph indices
	 *  &rgGprop (OUT): array of output glyph properties
	 *  &cgindex (OUT): number of output glyph indices
	 */

	LSERR (WINAPI* pfnGetGlyphPositions)(POLS, PLSRUN, LSDEVICE, LPWSTR, PCGMAP, DWORD,
											PCGINDEX, PCGPROP, DWORD, LSTFLOW, int*, PGOFFSET);
	/* GetGlyphPositions:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  lsDeviceID (IN): presentation or reference
	 *  pwch (IN): pointer to the string of character codes
	 *  pgmap (IN): array of wch->glyph mapping
	 *  cwch (IN): number of characters to be shaped
	 *  rgGindex (IN): array of glyph indices
	 *  rgGprop (IN): array of glyph properties
	 *  cgindex (IN): number glyph indices
	 *  kTFlow (IN): text direction and orientation
	 *  rgDu (OUT): array of widths of glyphs
	 *  rgGoffset (OUT): array of offsets of glyphs
	 */

	LSERR (WINAPI* pfnResetRunContents)(POLS, PLSRUN, LSCP, LSDCP, LSCP, LSDCP);
	/* ResetRunContents:
	 *  pols (IN):
	 *  plsrun (IN): run pointer as returned from FetchRun
	 *  cpFirstOld (IN): cpFirst before shaping
	 *  dcpOld (IN): dcp before shaping
	 *  cpFirstNew (IN): cpFirst after shaping
	 *  dcpNew (IN): dcp after shaping
	 */

	LSERR (WINAPI* pfnDrawGlyphs)(POLS, PLSRUN, BOOL, BOOL, PCGINDEX, const int*, const int*,
						PGOFFSET, PGPROP, PCEXPTYPE, DWORD,
						LSTFLOW, UINT, const POINT*, PCHEIGHTS, long, long, const RECT*);
	/* DrawGlyphs:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  fStrikeout (IN) :
	 *  fUnderline (IN) :
	 *  pglyph (IN): array of glyph indices
	 *  rgDu (IN): array of widths of glyphs
	 *  rgDuBeforeJust (IN): array of widths of glyphs before justification
	 *  rgGoffset (IN): array of offsets of glyphs
	 *  rgGprop (IN): array of glyph properties
	 *  rgExpType (IN): array of glyph expansion types
	 *  cglyph (IN): number glyph indices
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN): display mode - opaque, transparent
	 *  pptRun (IN): starting point of the run
	 *  heightsPres (IN): presentation heights for this run
	 *  dupRun (IN): presentation width for this run
	 *  dupLimUnderline (IN): underlining limit
	 *  pRectClip (IN): clipping rectangle
	 */

	/* Glyph justification */

	LSERR (WINAPI* pfnGetGlyphExpansionInfo)(POLS, PLSRUN, LSDEVICE, LPCWSTR, PCGMAP, DWORD, 
							PCGINDEX, PCGPROP, DWORD, LSTFLOW, BOOL, PEXPTYPE, LSEXPINFO*);
	/* GetGlyphExpansionInfo:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  lsDeviceID (IN): presentation or reference
	 *  pwch (IN): pointer to the string of character codes
	 *  rggmap (IN): array of wchar->glyph mapping
	 *  cwch (IN): number of characters to be shaped
	 *  rgglyph (IN): array of glyph indices
	 *  rgProp (IN): array of glyph properties
	 *  cglyph (IN): number glyph indices
	 *  kTFlow (IN): text direction and orientation
	 *  fLastTextChunkOnLine (IN): Last text chunk on line?
	 *  rgExpType (OUT): array of glyph expansion types
	 *  rgexpinfo (OUT): array of glyph expansion info
	 */

	LSERR (WINAPI* pfnGetGlyphExpansionInkInfo)(POLS, PLSRUN, LSDEVICE, GINDEX, GPROP, LSTFLOW, DWORD, long*);
	/* GetGlyphExpansionInkInfo:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  lsDeviceID (IN): presentation or reference
	 *  gindex (IN): glyph index
	 *  gprop (IN): glyph properties
	 *  kTFlow (IN): text direction and orientation
	 *  cAddInkDiscrete (IN): number of discrete values (minus 1, because maximum is already known)
	 *  rgDu (OUT): array of discrete values
	 */

	/* FarEast realted typograpy issues */

	LSERR (WINAPI* pfnGetEms)(POLS, PLSRUN, LSTFLOW, PLSEMS);
	/* GetEms:
	 *  pols (IN):
	 *  plsrun (IN): run pointer as returned from FetchRun
	 *  kTFlow (IN): text direction and orientation
	 *  &lsems (OUT): different fractions of EM in appropriate pixels
	 */

	LSERR (WINAPI* pfnPunctStartLine)(POLS, PLSRUN, MWCLS, WCHAR, LSACT*);
	/* PunctStartLine:
	 *  pols (IN):
	 *  plsrun (IN): run pointer for the char
	 *  mwcls (IN): mod width class for the char
	 *  wch (IN): char
	 *  &lsact (OUT): action on the first char on the line
	 */

	LSERR (WINAPI* pfnModWidthOnRun)(POLS, PLSRUN, WCHAR, PLSRUN, WCHAR,
									   LSACT*);
	/* ModWidthOnRun:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the first char
	 *  wchFirst (IN): first char
	 *  plsrunSecond (IN): run pointer for the second char
	 *  wchSecond (IN): second char
	 *  &lsact (OUT): action on the last char in 1st run
	 */

	LSERR (WINAPI* pfnModWidthSpace)(POLS, PLSRUN, PLSRUN, WCHAR, PLSRUN, WCHAR,
									 LSACT*);
	/* ModWidthSpace:
	 *  pols (IN):
	 *  plsrunCur (IN): run pointer for the current run
	 *  plsrunPrev (IN): run pointer for the previous char
	 *  wchPrev (IN): previous char
	 *  plsrunNext (IN): run pointer for the next char
	 *  wchNext (IN): next char
	 *  &lsact (OUT): action on space's width
	 */

	LSERR (WINAPI* pfnCompOnRun)(POLS, PLSRUN, WCHAR, PLSRUN, WCHAR,
								   LSPRACT*);
	/* CompOnRun:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the first char
	 *  wchFirst (IN): first char
	 *  plsrunSecond (IN): run pointer for the second char
	 *  wchSecond (IN): second char
	 *  &lspract (OUT): prioritized action on the last char in 1st run
	 */

	LSERR (WINAPI* pfnCompWidthSpace)(POLS, PLSRUN, PLSRUN, WCHAR, PLSRUN, WCHAR,
									  LSPRACT*);
	/* CompWidthSpace:
	 *  pols (IN):
	 *  plsrunCur (IN): run pointer for the current run
	 *  plsrunPrev (IN): run pointer for the previous char
	 *  wchPrev (IN): previous char
	 *  plsrunNext (IN): run pointer for the next char
	 *  wchNext (IN): next char
	 *  &lspract (OUT): prioritized action on space's width
	 */


	LSERR (WINAPI* pfnExpOnRun)(POLS, PLSRUN, WCHAR, PLSRUN, WCHAR,
								  LSACT*);
	/* ExpOnRun:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the first char
	 *  wchFirst (IN): first char
	 *  plsrunSecond (IN): run pointer for the second char
	 *  wchSecond (IN): second char
	 *  &lsact (OUT): action on the last run char from 1st run
	 */

	LSERR (WINAPI* pfnExpWidthSpace)(POLS, PLSRUN, PLSRUN, WCHAR, PLSRUN,
									   WCHAR, LSACT*);
	/* ExpWidthSpace:
	 *  pols (IN):
	 *  plsrunCur (IN): run pointer for the current run
	 *  plsrunPrev (IN): run pointer for the previous char
	 *  wchPrev (IN): previous char
	 *  plsrunNext (IN): run pointer for the next char
	 *  wchNext (IN): next char
	 *  &lsact (OUT): action on space's width
	 */

	LSERR (WINAPI* pfnGetModWidthClasses)(POLS, PLSRUN, const WCHAR*, DWORD, MWCLS*);
	/* GetModWidthClasses:
	 *  pols (IN):
	 *  plsrun (IN): run pointer for the characters
	 *  rgwch (IN): array of characters
	 *  cwch (IN): number of characters in the rgwch array
	 *  rgmwcls(OUT): array of ModWidthClass's for chars from the rgwch array
	 */

	LSERR (WINAPI* pfnGetBreakingClasses)(POLS, PLSRUN, LSCP, WCHAR, BRKCLS*, BRKCLS*);
	/* GetBreakingClasses:
	 *  pols (IN):
	 *  plsrun (IN): run pointer for the char
	 *  cp (IN): cp of the character
	 *  wch (IN): character
	 *  &brkclsFirst (OUT): breaking class for this char as the leading one in a pair
	 *  &brkclsSecond (OUT): breaking class for this char as the following one in a pair
	 */

	LSERR (WINAPI* pfnFTruncateBefore)(POLS, PLSRUN, LSCP, WCHAR, long, PLSRUN, LSCP, WCHAR, long, long, BOOL*);
	/* FTruncateBefore:
	 *  pols (IN):
	 *	plsrunCur (IN): plsrun of the current character 
	 *  cpCur (IN): cp of truncation char
	 *  wchCur (IN): truncation character 
	 *  durCur (IN): width of truncation character
	 *	plsrunPrev (IN): plsrun of the previous character 
	 *  cpPrev (IN): cp of the previous character
	 *  wchPrev (IN): previous character 
	 *  durPrev (IN): width of truncation character
	 *  durCut (IN): width from the RM until the end of the current character
	 *  &fTruncateBefore (OUT): truncation point is before this character
	 * 			(if it exceeds RM)
	 */
	
	LSERR (WINAPI* pfnCanBreakBeforeChar)(POLS, BRKCLS, BRKCOND*);
	/* CanBreakBeforeChar:
	 *  pols (IN):
	 *	brkcls (IN): breaking class for the char as the following one in a pair
	 *  &brktxtBefore (OUT): break condition before the character
	 */

	LSERR (WINAPI* pfnCanBreakAfterChar)(POLS, BRKCLS, BRKCOND*);
	/* CanBreakAfterChar:
	 *  pols (IN):
	 *  brkcls (IN): breaking class for the char as the leading one in a pair
	 *  &brktxtAfter (OUT): break text condition after the character
	 */


	LSERR (WINAPI* pfnFHangingPunct)(POLS, PLSRUN, MWCLS, WCHAR, BOOL*);
	/* FHangingPunct:
	 *  pols (IN):
	 *  plsrun (IN): run pointer for the char
	 *  mwcls (IN): mod width class of this char
	 *  wch (IN): character
	 *  &fHangingPunct (OUT): can be pushed to the right margin?
	 */

	LSERR (WINAPI* pfnGetSnapGrid)(POLS, WCHAR*, PLSRUN*, LSCP*, DWORD, BOOL*, DWORD*);
	/* GetGridInfo:
	 *  pols (IN):
	 *  rgwch (IN): array of characters
	 *  rgplsrun (IN): array of corresponding plsrun's
	 *  rgcp (IN): array of corresponding cp's
	 *  iwch (IN): number of characters
	 *	rgfSnap (OUT): array of fSnap flags for all characters
	 *	pwGridNumber (OUT): number of grid points on the line
	 */

	LSERR (WINAPI* pfnDrawEffects)(POLS, PLSRUN, UINT,
								   const POINT*, LPCWSTR, const int*, const int*, DWORD, 
								   LSTFLOW, UINT, PCHEIGHTS, long, long, const RECT*);
	/* DrawTextRun:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  EffectsFlags (IN): set of client defined special effects bits
	 *  ppt (IN): output location
	 *  lpwchRun (IN): run of characters
	 *  rgDupRun (IN): widths of characters
	 *  rgDupLeftCut (IN): dup cut from the left side of the char
	 *  cwchRun (IN): number of characters in run
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN): display mode - opaque, transparent
	 *  heightsPres (IN): presentation heights for this run
	 *  dupRun (IN): presentation width for this run
	 *  dupLimUnderline (IN): underlining limit
	 *  pRectClip (IN): clipping rectangle
	 */

	LSERR (WINAPI* pfnFCancelHangingPunct)(POLS, LSCP, LSCP, WCHAR, MWCLS, BOOL*);

	/* FCancelHangingPunct:
	 *  pols (IN):
	 *  cpLim (IN): cpLim of the line
	 *  cpLastAdjustable (IN): cp of the last adjustable character on the line
	 *  wch (IN): last character
	 *  mwcls (IN): mod width class of this char
	 *  pfCancelHangingPunct (OUT): cancel hanging punctuation?
	*/

	LSERR (WINAPI* pfnModifyCompAtLastChar)(POLS, LSCP, LSCP, WCHAR, MWCLS, long, long, long*);

	/* ModifyCompAtLastChar:
	 *  pols (IN):
	 *  cpLim (IN): cpLim of the line
	 *  cpLastAdjustable (IN): cp of the last adjustable character on the line
	 *  wch (IN): last character
	 *  mwcls (IN): mod width class of this char
	 *  durCompLastRight (IN): suggested compression on the right side
	 *  durCompLastLeft (IN): suggested compression on the left side
	 *  pdurCahngeComp (OUT): change compression amount on the last char
	*/

	/* Enumeration callbacks */

	LSERR (WINAPI* pfnEnumText)(POLS, PLSRUN, LSCP, LSDCP, LPCWSTR, DWORD, LSTFLOW, BOOL,
											BOOL, const POINT*, PCHEIGHTS, long, BOOL, long*);
	/* EnumText:
	 *  pols (IN):
	 *  plsrun (IN): from DNODE
	 *  cpFirst (IN): from DNODE
	 *  dcp (IN): from DNODE
	 *  rgwch(IN): array of characters
	 *  cwch(IN): number of characters
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryProvided (IN):
	 *  pptStart (IN): starting position, iff fGeometryProvided
	 *  pheightsPres(IN): from DNODE, relevant iff fGeometryProvided
	 *  dupRun(IN): from DNODE, relevant iff fGeometryProvided
	 *  fCharWidthProvided (IN):
	 *  rgdup(IN): array of character widths, iff fCharWidthProvided
	*/

	LSERR (WINAPI* pfnEnumTab)(POLS, PLSRUN, LSCP, LPCWSTR, WCHAR, LSTFLOW, BOOL,
													BOOL, const POINT*, PCHEIGHTS, long);
	/* EnumTab:
	 *  pols (IN):
	 *  plsrun (IN): from DNODE
	 *  cpFirst (IN): from DNODE
	 *  rgwch(IN): Pointer to one Tab character
	 *  wchTabLeader (IN): tab leader
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryProvided (IN):
	 *  pptStart (IN): starting position, iff fGeometryProvided
	 *  pheightsPres(IN): from DNODE, relevant iff fGeometryProvided
	 *  dupRun(IN): from DNODE, relevant iff fGeometryProvided
	*/

	LSERR (WINAPI* pfnEnumPen)(POLS, BOOL, LSTFLOW, BOOL, BOOL, const POINT*, long, long);
	/* EnumPen:
	 *  pols (IN):
	 *  fBorder (IN):
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryProvided (IN):
	 *  pptStart (IN): starting position, iff fGeometryProvided
	 *  dup(IN): from DNODE iff fGeometryProvided
	 *  dvp(IN): from DNODE iff fGeometryProvided
	*/

	/* Objects bundling */

	LSERR (WINAPI* pfnGetObjectHandlerInfo)(POLS, DWORD, void*);
	/* GetObjectHandlerInfo:
	 *  pols (IN):
	 *  idObj (IN): id of the object handler
	 *  pObjectInfo (OUT): initialization information of the specified object
	*/


	/* Debugging APIs */
	void (WINAPI *pfnAssertFailed)(char*, char*, int);

};
typedef struct lscbk LSCBK;

#endif /* !LSCBK_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lscrline.h ===
#ifndef LSCRLINE_DEFINED
#define LSCRLINE_DEFINED

#include "lsdefs.h"
#include "plsline.h"
#include "breakrec.h"
#include "lslinfo.h"

LSERR WINAPI LsCreateLine(PLSC,				/* IN: ptr to line services context		*/
						  LSCP,				/* IN: cpFirst							*/
						  long,				/* IN: duaColumn						*/
						  const BREAKREC*,	/* IN: input array of break records		*/
						  DWORD,			/* IN: number of records in input array	*/
						  DWORD,			/* IN: size of the output array			*/
						  BREAKREC*,		/* OUT: output array of break records	*/
						  DWORD*,			/* OUT:actual number of records in array*/
						  LSLINFO*,			/* OUT: visible line info				*/
						  PLSLINE*);		/* OUT: ptr to line opaque to client	*/

LSERR WINAPI LsModifyLineHeight(PLSC,		/* IN: ptr to line services context 	*/
								PLSLINE,	/* IN: ptr to line -- opaque to client	*/
								long,		/* IN: dvpAbove							*/
								long,		/* IN: dvpAscent						*/
								long,		/* IN: dvpDescent						*/	
								long);		/* IN: dvpBelow							*/	

LSERR WINAPI LsDestroyLine(PLSC,			/* IN: ptr to line services context		*/
						   PLSLINE);		/* IN: ptr to line -- opaque to client	*/

LSERR WINAPI LsGetLineDur(PLSC,				/* IN: ptr to line services context 	*/
						  PLSLINE,			/* IN: ptr to line -- opaque to client	*/
						  long*,			/* OUT: dur of line incl. trailing area	*/
						  long*);			/* OUT: dur of line excl. trailing area	*/

LSERR WINAPI LsGetMinDurBreaks(PLSC,		/* IN: ptr to line services context 	*/
						  	   PLSLINE,		/* IN: ptr to line -- opaque to client	*/
						  	   long*,		/* OUT: min dur between breaks including 
																	trailing area	*/
						  	   long*);		/* OUT: min dur between breaks excluding 
																	trailing area	*/

#endif /* !LSCRLINE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsdevice.h ===
#ifndef LSDEVICE_DEFINED
#define LSDEVICE_DEFINED

enum lsdevice				/* Parameter for pfnGetRunTextMetrics callback */
{
	lsdevPres,
	lsdevReference
};

typedef enum lsdevice LSDEVICE;

#endif /* !LSDEVICE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsdevres.h ===
#ifndef LSDEVRES_DEFINED
#define LSDEVRES_DEFINED

typedef struct
{
	long dxpInch, dypInch;				/* resolution of preview device */
	long dxrInch, dyrInch;				/* resolution of reference device */
} LSDEVRES;

#endif /* !LSDEVRES_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsdnfin.h ===
#ifndef LSDNFIN_DEFINED
#define LSDNFIN_DEFINED

/* Access routines for contents of DNODES */

#include "lsdefs.h"
#include "plsrun.h"
#include "plsfrun.h"
#include "plschp.h"
#include "pobjdim.h"
#include "pdobj.h"


LSERR WINAPI LsdnFinishRegular(
							  PLSC,				/* IN: Pointer to LS Context */
							  LSDCP,     		/* IN: dcp adopted           */
							  PLSRUN,   		/* IN: PLSRUN  		         */
							  PCLSCHP,  		/* IN: CHP          	     */
							  PDOBJ,    		/* IN: PDOBJ             	 */ 
							  PCOBJDIM);		/* IN: OBJDIM      		     */

LSERR WINAPI LsdnFinishRegularAddAdvancePen(
							  PLSC,				/* IN: Pointer to LS Context */
							  LSDCP,     		/* IN: dcp adopted           */
							  PLSRUN,   		/* IN: PLSRUN  		         */
							  PCLSCHP,  		/* IN: CHP          	     */
							  PDOBJ,    		/* IN: PDOBJ             	 */ 
							  PCOBJDIM,			/* IN: OBJDIM      		     */
							  long,				/* IN: durPen				 */
							  long,				/* IN: dvrPen				 */
							  long);			/* IN: dvpPen 				 */

LSERR WINAPI LsdnFinishByPen(PLSC,				/* IN: Pointer to LS Context */
						   LSDCP, 	    		/* IN: dcp	adopted          */
						   PLSRUN,		   		/* IN: PLSRUN  		         */
						   PDOBJ,	    		/* IN: PDOBJ             	 */ 
						   long,    	 		/* IN: dur         		     */
						   long,     			/* IN: dvr             		 */
						   long);   			/* IN: dvp          	     */

LSERR WINAPI LsdnFinishDeleteAll(PLSC,			/* IN: Pointer to LS Context */
					  			LSDCP);			/* IN: dcp adopted			 */

#endif /* !LSDNFIN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsdnset.h ===
#ifndef LSDNSET_DEFINED
#define LSDNSET_DEFINED

/* Access routines for contents of DNODES */

#include "lsdefs.h"
#include "plssubl.h"
#include "plsdnode.h"
#include "pobjdim.h"
#include "lsktab.h"
#include "lskeop.h"

LSERR WINAPI LsdnQueryObjDimRange(
								  PLSC,			/* IN: Pointer to LS Context */
							 	  PLSDNODE,		/* IN: plsdnFirst -- First DNODE in range */
								  PLSDNODE,		/* IN: plsdnLast -- Last DNODE in range */
							 	  POBJDIM);		/* OUT: dimensions of range */


LSERR WINAPI LsdnResetObjDim(
								 PLSC,			/* IN: Pointer to LS Context	*/
								 PLSDNODE,		/* IN: plsdnFirst 				*/
								 PCOBJDIM);		/* IN: dimensions of dnode 		*/


LSERR WINAPI LsdnQueryPenNode(
							  PLSC,				/* IN: Pointer to LS Context*/
						  	  PLSDNODE,			/* IN: DNODE queried		*/
						  	  long*,			/* OUT: &dvpPen				*/
						  	  long*,			/* OUT: &durPen				*/
						  	  long*);			/* OUT: &dvrPen				*/


LSERR WINAPI LsdnResetPenNode(
							  PLSC,				/* IN: Pointer to LS Context */
						  	  PLSDNODE,			/* IN: DNODE to be modified */
						  	  long,				/* IN: dvpPen */
						  	  long,				/* IN: durPen */
						  	  long);			/* IN: dvrPen */

LSERR WINAPI LsdnSetRigidDup(
							 PLSC,				/* IN: Pointer to LS Context */
							 PLSDNODE,			/* IN: DNODE to be modified	 */
							 long);				/* IN: dup					 */

LSERR WINAPI LsdnGetDup(
							 PLSC,				/* IN: Pointer to LS Context */
							 PLSDNODE,			/* IN: DNODE queried		 */
							 long*);			/* OUT: dup					 */

LSERR WINAPI LsdnSetAbsBaseLine(
								PLSC,			/* IN: Pointer to LS Context */
							  	long);    		/* IN: new vaBase            */

LSERR WINAPI LsdnModifyParaEnding(
								PLSC,			/* IN: Pointer to LS Context */
								LSKEOP);		/* IN: Kind of line ending			*/

LSERR WINAPI LsdnResolvePrevTab(PLSC);			/* IN: Pointer to LS Context */

LSERR WINAPI LsdnGetCurTabInfo(
							PLSC,				/* IN: Pointer to LS Context */
							LSKTAB*);			/* OUT: Type of current tab  */

LSERR WINAPI LsdnSkipCurTab(PLSC);					/* IN: Pointer to LS Context */

LSERR WINAPI LsdnDistribute(
							PLSC,				/* IN: Pointer to LS Context	*/
							PLSDNODE,			/* IN: First DNODE				*/
							PLSDNODE,			/* IN: Last DNODE				*/
							long);				/* IN: durToDistribute			*/

LSERR WINAPI LsdnSubmitSublines(
							PLSC,				/* IN: Pointer to LS Context	*/
							PLSDNODE,			/* IN: DNODE					*/
							DWORD,				/* IN: cSublinesSubmitted		*/
							PLSSUBL*,			/* IN: rgpsublSubmitted			*/
							BOOL,				/* IN: fUseForJustification		*/
							BOOL,				/* IN: fUseForCompression		*/
							BOOL,				/* IN: fUseForDisplay			*/
							BOOL,				/* IN: fUseForDecimalTab		*/
							BOOL				/* IN: fUseForTrailingArea		*/
							);											
LSERR WINAPI LsdnGetFormatDepth(
							PLSC,				/* IN: Pointer to LS Context	*/
							DWORD*);			/* OUT: nDepthFormatLineMax		*/

#endif /* !LSDNSET_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsdocinf.h ===
#ifndef LSDOCINF_DEFINED
#define LSDOCINF_DEFINED

#include "lsdefs.h"
#include "plsdocin.h"
#include "lsdevres.h"

typedef struct lsdocinf
{
	BOOL fDisplay;
	BOOL fPresEqualRef;
	LSDEVRES lsdevres;
} LSDOCINF;

#endif /* !LSDOCINF_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lscrsubl.h ===
#ifndef LSCRSUBL_DEFINED
#define LSCRSUBL_DEFINED

/* Line services formatter fetch/dispatcher interface (to LsCreateLine())
 */

#include "lsdefs.h"
#include "lsfrun.h"
#include "lsesc.h"
#include "plssubl.h"
#include "plsdnode.h"
#include "fmtres.h"
#include "objdim.h"
#include "lstflow.h"
#include "lskjust.h"
#include "breakrec.h"
#include "brkkind.h"
#include "brkpos.h"

LSERR WINAPI LsCreateSubline(
							PLSC,			/* IN: LS context						*/
							LSCP,			/* IN: cpFirst							*/
						    long,			/* IN: urColumnMax						*/
							LSTFLOW,		/* IN: text flow						*/
							BOOL);			/* IN: fContiguous						*/

LSERR WINAPI LsFetchAppendToCurrentSubline(
							PLSC,			/* IN: LS context						*/
							LSDCP,			/* IN:Increase cp before fetching		*/
						    const LSESC*,	/* IN: escape characters				*/
						    DWORD,			/* IN: # of escape characters			*/
							BOOL*,			/* OUT: Successful?---if not, finish 
												subline, destroy it and start anew	*/
						    FMTRES*,		/* OUT: result of last formatter		*/
						    LSCP*,			/* OUT: cpLim							*/
						    PLSDNODE*,		/* OUT: First DNODE created				*/
						 	PLSDNODE*);		/* OUT: Last DNODE created				*/

LSERR WINAPI LsFetchAppendToCurrentSublineResume(
							PLSC,			/* IN: LS context						*/
							const BREAKREC*,/* IN: array of break records			*/
							DWORD,			/* IN: number of records in array		*/
							LSDCP,			/* IN:Increase cp before fetching		*/
						    const LSESC*,	/* IN: escape characters				*/
						    DWORD,			/* IN: # of escape characters			*/
							BOOL*,			/* OUT: Successful?---if not, finish 
												subline, destroy it and start anew	*/
						    FMTRES*,		/* OUT: result of last formatter		*/
						    LSCP*,			/* OUT: cpLim							*/
						    PLSDNODE*,		/* OUT: First DNODE created				*/
						 	PLSDNODE*);		/* OUT: Last DNODE created				*/

LSERR WINAPI LsAppendRunToCurrentSubline(		/* Simple runs only	*/
							PLSC,			/* IN: LS context						*/
						    const LSFRUN*,	/* IN: given run						*/
							BOOL*,			/* OUT: Successful?---if not, finish 
												subline, destroy it and start anew	*/
						    FMTRES*,		/* OUT: result of last formatter		*/
						    LSCP*,			/* OUT: cpLim							*/
						    PLSDNODE*);		/* OUT: DNODE created					*/

LSERR WINAPI LsResetRMInCurrentSubline(
							PLSC,			/* IN: LS context						*/
						    long);			/* IN: urColumnMax						*/

LSERR WINAPI LsFinishCurrentSubline(
							PLSC,			/* IN: LS context						*/
							PLSSUBL*);		/* OUT: subline context					*/


LSERR WINAPI LsTruncateSubline(
							PLSSUBL,		/* IN: subline context					*/
							long,			/* IN: urColumnMax						*/
							LSCP*);			/* OUT: cpTruncate 						*/

LSERR WINAPI LsFindPrevBreakSubline(
							PLSSUBL,		/* IN: subline context					*/
							BOOL,			/* IN: fFirstSubline					*/
							LSCP,			/* IN: truncation cp					*/
						    long,			/* IN: urColumnMax						*/
							BOOL*,			/* OUT: fSuccessful?					*/
							LSCP*,			/* OUT: cpBreak							*/
							POBJDIM,		/* OUT: objdimSub up to break			*/
							BRKPOS*);		/* OUT: Before/Inside/After				*/

LSERR WINAPI LsFindNextBreakSubline(
							PLSSUBL,		/* IN: subline context					*/
							BOOL,			/* IN: fFirstSubline					*/
							LSCP,			/* IN: truncation cp					*/
						    long,			/* IN: urColumnMax						*/
							BOOL*,			/* OUT: fSuccessful?					*/
							LSCP*,			/* OUT: cpBreak							*/
							POBJDIM,		/* OUT: objdimSub up to break			*/			
							BRKPOS*);		/* OUT: Before/Inside/After				*/

LSERR WINAPI LsForceBreakSubline(
							PLSSUBL,		/* IN: subline context					*/
							BOOL,			/* IN: fFirstSubline					*/
							LSCP,			/* IN: truncation cp					*/
						    long,			/* IN: urColumnMax						*/
							LSCP*,			/* OUT: cpBreak							*/
							POBJDIM,		/* OUT: objdimSub up to break			*/			
							BRKPOS*);		/* OUT: Before/Inside/After				*/

LSERR WINAPI LsSetBreakSubline(
							PLSSUBL,		/* IN: subline context					*/
							BRKKIND,		/* IN: Prev/Next/Force/Imposed			*/			
							DWORD,			/* IN: size of array					*/
							BREAKREC*, 		/* OUT: array of break records			*/
							DWORD*);		/* OUT: number of used elements of the array*/

LSERR WINAPI LsDestroySubline(PLSSUBL);

LSERR WINAPI LsMatchPresSubline(
							  PLSSUBL);		/* IN: subline context		*/

LSERR WINAPI LsExpandSubline(
							  PLSSUBL,		/* IN: subline context		*/
							  LSKJUST,		/* IN: justification type	*/
							  long);		/* IN: dup					*/

LSERR WINAPI LsCompressSubline(
							  PLSSUBL,		/* IN: subline context		*/
							  LSKJUST,		/* IN: justification type	*/
							  long);		/* IN: dup					*/

LSERR WINAPI LsSqueezeSubline(
							  PLSSUBL,		/* IN: subline context		*/
							  long,			/* IN: durTarget			*/
							  BOOL*,		/* OUT: fSuccessful?		*/
							  long*);		/* OUT: if nof successful, 
													extra dur 			*/

LSERR WINAPI LsGetSpecialEffectsSubline(
							  PLSSUBL,		/* IN: subline context		*/
							  UINT*);		/* OUT: special effects		*/

#endif /* !LSCRSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsdefs.h ===
/* Common definitions for line services
 */

#ifndef LSDEFS_DEFINED
#define LSDEFS_DEFINED

#ifdef UNIX
#include <wchar.h>
#endif

#if defined(_NO_WINDOWS)

/* <windows.h> must be included FIRST, if at all. */
/* We define basic types if <windows.h> is not included. */

#ifndef NULL
#define NULL    ((void *)0)
#endif /* NULL */

#define WINAPI __stdcall
#define FALSE	0
#define TRUE	1

typedef int BOOL;
typedef long LONG;
typedef unsigned long DWORD;
typedef unsigned short WORD;
typedef unsigned int UINT;
typedef unsigned char BYTE;
typedef int INT;
#ifdef UNIX
typedef wchar_t WCHAR;
#else
typedef WORD WCHAR;
#endif
typedef const WCHAR* LPCWSTR;
typedef WCHAR* LPWSTR;

typedef struct tagRECT
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECT;

typedef struct tagPOINT
{
    LONG  x;
    LONG  y;
} POINT;

#endif /* WINVER */


/* Line services definitions */
struct lscontext;					/* Opaque to clients */
typedef struct lscontext* PLSC;
typedef const struct lscontext* PCLSC;

struct ols;								/* Owner of LineServices */
typedef struct ols* POLS;				/*  (Opaque to LineService) */

typedef long LSCP;
typedef DWORD LSDCP;

typedef WORD GINDEX;
typedef GINDEX* PGINDEX;
typedef const GINDEX* PCGINDEX;

typedef struct tagPOINTUV
{
    LONG  u;
    LONG  v;
} POINTUV;

typedef POINTUV* PPOINTUV;
typedef const POINTUV* PCPOINTUV;

typedef struct tagGOFFSET
{
    LONG  du;
    LONG  dv;
} GOFFSET;

typedef GOFFSET* PGOFFSET;
typedef const GOFFSET* PCGOFFSET;

/* Line services error codes */
typedef long LSERR;
#define lserrNone						( 0L)
#ifdef LSERRSTOP				/* stop immediately, don't return error */
#define lserrInvalidParameter   		AssertErr("lserrInvalidParameter")  	
#define lserrOutOfMemory    			AssertErr("lserrOutOfMemory")
#define lserrNullOutputParameter  		AssertErr("lserrNullOutputParameter")
#define lserrInvalidContext    			AssertErr("lserrInvalidContext")
#define lserrInvalidLine    			AssertErr("lserrInvalidLine")
#define lserrInvalidDnode    			AssertErr("lserrInvalidDnode")
#define lserrInvalidDeviceResolution 	AssertErr("lserrInvalidDeviceResolution")
#define lserrInvalidRun  			   	AssertErr("lserrInvalidRun")
#define lserrMismatchLineContext  		AssertErr("lserrMismatchLineContext")
#define lserrContextInUse    			AssertErr("lserrContextInUse")
#define lserrDuplicateSpecialCharacter 	AssertErr("lserrDuplicateSpecialCharacter")
#define lserrInvalidAutonumRun  		AssertErr("lserrInvalidAutonumRun")
#define lserrFormattingFunctionDisabled AssertErr("lserrFormattingFunctionDisabled")
#define lserrUnfinishedDnode   			AssertErr("lserrUnfinishedDnode")
#define lserrInvalidDnodeType   		AssertErr("lserrInvalidDnodeType")
#define lserrInvalidPenDnode   			AssertErr("lserrInvalidPenDnode")
#define lserrInvalidNonPenDnode   		AssertErr("lserrInvalidNonPenDnode")
#define lserrInvalidBaselinePenDnode 	AssertErr("lserrInvalidBaselinePenDnode")
#define lserrInvalidFormatterResult  	AssertErr("lserrInvalidFormatterResult")
#define lserrInvalidObjectIdFetched  	AssertErr("lserrInvalidObjectIdFetched")
#define lserrInvalidDcpFetched   		AssertErr("lserrInvalidDcpFetched")
#define lserrInvalidCpContentFetched 	AssertErr("lserrInvalidCpContentFetched")
#define lserrInvalidBookmarkType  		AssertErr("lserrInvalidBookmarkType")
#define lserrSetDocDisabled    			AssertErr("lserrSetDocDisabled")
#define lserrFiniFunctionDisabled  		AssertErr("lserrFiniFunctionDisabled")
#define lserrCurrentDnodeIsNotTab  		AssertErr("lserrCurrentDnodeIsNotTab")
#define lserrPendingTabIsNotResolved	AssertErr("lserrPendingTabIsNotResolved")
#define lserrWrongFiniFunction 			AssertErr("lserrWrongFiniFunction")
#define lserrInvalidBreakingClass		AssertErr("lserrInvalidBreakingClass")
#define lserrBreakingTableNotSet		AssertErr("lserrBreakingTableNotSet")
#define lserrInvalidModWidthClass		AssertErr("lserrInvalidModWidthClass")
#define lserrModWidthPairsNotSet		AssertErr("lserrModWidthPairsNotSet")
#define lserrWrongTruncationPoint 		AssertErr("lserrWrongTruncationPoint")
#define lserrWrongBreak 				AssertErr("lserrWrongBreak")
#define lserrDupInvalid 				AssertErr("lserrDupInvalid")
#define lserrRubyInvalidVersion			AssertErr("lserrRubyVersionInvalid")
#define lserrTatenakayokoInvalidVersion	AssertErr("lserrTatenakayokoInvalidVersion")
#define lserrWarichuInvalidVersion		AssertErr("lserrWarichuInvalidVersion")
#define lserrWarichuInvalidData			AssertErr("lserrWarichuInvalidData")
#define lserrCreateSublineDisabled		AssertErr("lserrCreateSublineDisabled")
#define lserrCurrentSublineDoesNotExist	AssertErr("lserrCurrentSublineDoesNotExist")
#define lserrCpOutsideSubline			AssertErr("lserrCpOutsideSubline")
#define lserrHihInvalidVersion			AssertErr("lserrHihInvalidVersion")
#define lserrInsufficientQueryDepth		AssertErr("lserrInsufficientQueryDepth")
#define lserrInsufficientBreakRecBuffer	AssertErr("lserrInsufficientBreakRecBuffer")
#define lserrInvalidBreakRecord			AssertErr("lserrInvalidBreakRecord")
#define lserrInvalidPap					AssertErr("lserrInvalidPap")
#define lserrContradictoryQueryInput	AssertErr("lserrContradictoryQueryInput")
#define lserrLineIsNotActive			AssertErr("lserrLineIsNotActive")
#define lserrTooLongParagraph			AssertErr("lserrTooLongParagraph")
#else
#define lserrInvalidParameter			(-1L)
#define lserrOutOfMemory				(-2L)
#define lserrNullOutputParameter		(-3L)
#define lserrInvalidContext				(-4L)
#define lserrInvalidLine				(-5L)
#define lserrInvalidDnode				(-6L)
#define lserrInvalidDeviceResolution	(-7L)
#define lserrInvalidRun					(-8L)
#define lserrMismatchLineContext		(-9L)
#define lserrContextInUse				(-10L)
#define lserrDuplicateSpecialCharacter	(-11L)
#define lserrInvalidAutonumRun			(-12L)
#define lserrFormattingFunctionDisabled	(-13L)
#define lserrUnfinishedDnode			(-14L)
#define lserrInvalidDnodeType			(-15L)
#define lserrInvalidPenDnode			(-16L)
#define lserrInvalidNonPenDnode			(-17L)
#define lserrInvalidBaselinePenDnode	(-18L)
#define lserrInvalidFormatterResult		(-19L)
#define lserrInvalidObjectIdFetched		(-20L)
#define lserrInvalidDcpFetched			(-21L)
#define lserrInvalidCpContentFetched	(-22L)
#define lserrInvalidBookmarkType		(-23L)
#define lserrSetDocDisabled				(-24L)
#define lserrFiniFunctionDisabled		(-25L)
#define lserrCurrentDnodeIsNotTab		(-26L)
#define lserrPendingTabIsNotResolved    (-27L)
#define lserrWrongFiniFunction 			(-28L)
#define lserrInvalidBreakingClass		(-29L)
#define lserrBreakingTableNotSet		(-30L)
#define lserrInvalidModWidthClass		(-31L)
#define lserrModWidthPairsNotSet		(-32L)
#define lserrWrongTruncationPoint 		(-33L)
#define lserrWrongBreak 				(-34L)
#define	lserrDupInvalid					(-35L)
#define lserrRubyInvalidVersion			(-36L)
#define lserrTatenakayokoInvalidVersion	(-37L)
#define lserrWarichuInvalidVersion		(-38L)
#define lserrWarichuInvalidData			(-39L)
#define lserrCreateSublineDisabled		(-40L)
#define lserrCurrentSublineDoesNotExist	(-41L)
#define lserrCpOutsideSubline			(-42L)
#define lserrHihInvalidVersion			(-43L)
#define lserrInsufficientQueryDepth		(-44L)
#define lserrInsufficientBreakRecBuffer	(-45L)
#define lserrInvalidBreakRecord			(-46L)
#define lserrInvalidPap					(-47L)
#define lserrContradictoryQueryInput	(-48L)
#define lserrLineIsNotActive			(-49L)
#define lserrTooLongParagraph			(-50L)
#endif	/* LSERRORSTOP */


#ifndef fTrue
#define fTrue	1
#define fFalse	0
#endif

#define uLsInfiniteRM	0x3FFFFFFF

#define czaUnitInch					(1440L) /* 1440 absolute units per inch */

#endif /* LSDEFS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsems.h ===
#ifndef LSEMS_DEFINED
#define LSEMS_DEFINED

#include "lsdefs.h"

typedef struct lsems
{
	long em;		/* one em			*/
	long em2;		/* half em			*/
	long em3;		/* third em			*/
	long em4;		/* quater em		*/
	long em8;		/* eighth em		*/
	long em16;		/* 15/16 of em		*/
	long udExp;		/* user defined expansion	*/
	long udComp;	/* user defined compression*/
} LSEMS;



#endif /* !LSEMS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsdsply.h ===
#ifndef LSDSPLY_DEFINED
#define LSDSPLY_DEFINED

#include "lsdefs.h"
#include "plsline.h"

LSERR WINAPI LsDisplayLine(PLSLINE, const POINT*, UINT, const RECT*);
/* LsDisplayLine
 *  pline (IN)
 *  ppt (IN)
 *  kDisp (IN): transparent or opaque
 *  &rcClip (IN): clipping rect
 */

#endif /* !LSDSPLY_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsdssubl.h ===
#ifndef LSDSSUBL_DEFINED
#define LSDSSUBL_DEFINED

/* Line services formatter fetch/dispatcher interface (to LsCreateLine())
 */

#include "lsdefs.h"
#include "plssubl.h"


LSERR WINAPI LsDisplaySubline(
							PLSSUBL,			/* IN: subline context			*/
							const POINT*,		/* IN: starting position(xp, yp)*/
							UINT,				/* IN: display mode, opaque, etc */
							const RECT*);		/* IN: clip rectangle (xp, yp,...) */

#endif /* !LSDSSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsensubl.h ===
#ifndef LSENSUBL_DEFINED
#define LSENSUBL_DEFINED

/* Line services formatter fetch/dispatcher interface (to LsCreateLine())
 */

#include "lsdefs.h"
#include "plssubl.h"


LSERR WINAPI LsEnumSubline(PLSSUBL,
						   BOOL,			/* IN: enumerate in reverse order?					*/
						   BOOL,			/* IN: geometry needed?								*/
						   const POINT*);	/* IN: starting position(xp, yp) iff fGeometryNeeded*/
#endif /* !LSENSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsenum.h ===
#ifndef LSENUM_DEFINED
#define LSENUM_DEFINED

#include "lsdefs.h"
#include "plsline.h"

LSERR WINAPI LsEnumLine(PLSLINE,
					   	BOOL,			/* IN: enumerate in reverse order?					*/
						BOOL,			/* IN: geometry needed?								*/
						const POINT*);	/* IN: starting position(xp, yp) iff fGeometryNeeded*/

#endif /* LSENUM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsesc.h ===
#ifndef LSESC_DEFINED
#define LSESC_DEFINED

/* Definition of Line Services escape characters.
 * Used for LsFetchDispatchEsc().
 */

#include "lsdefs.h"

typedef struct
{
	WCHAR wchFirst, wchLast;			/* Range of chars codes */
} LSESC;


#endif /* !LSESC_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsexpan.h ===
#ifndef LSEXPAN_DEFINED
#define LSEXPAN_DEFINED

#include "lsdefs.h"
#include "lsact.h"

typedef struct lsexpan					/* expansion information unit		*/
{
	BYTE fFullScaled;					/* expand for full justification	*/
	BYTE fFullInterletter;				/* expand for distributed justification	*/
} LSEXPAN;									


#endif /* !LSEXPAN_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsfgi.h ===
#ifndef LSFGI_DEFINED
#define LSFGI_DEFINED

#include "lsdefs.h"
#include "lstflow.h"
#include "plsfgi.h"

/* ------------------------------------------------------------------------ */

struct lsfgi							/* Formatter geometry input */
{
	BOOL fFirstOnLine;	/* REVIEW sergeyge(elik): Query instead of this member? */
	LSCP cpFirst;
	long urPen,vrPen;
	long urColumnMax;
	LSTFLOW lstflow;
};
typedef struct lsfgi LSFGI;

#endif /* !LSFGI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsexpinf.h ===
#ifndef LSEXPINF_DEFINED
#define LSEXPINF_DEFINED

#include "lsdefs.h"
#include "exptype.h"

#define lsexpinfInfinity	0x1FFFFF

/* ------------------------------------------------------------------------ */

struct lsexpinfo							/* Expansion info */
{
	long duMax;
	union
	{
		struct
		{
			long duMin;
		} AddInkContinuous;
	
		struct
		{
			DWORD cwidths;
		} AddInkDiscrete;

	} u;

	BYTE prior;
	BYTE fCanBeUsedForResidual;
	WORD pad;
};

typedef struct lsexpinfo LSEXPINFO;

#endif /* !LSEXPINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lshyph.h ===
#ifndef LSHYPH_DEFINED
#define LSHYPH_DEFINED

#include "lsdefs.h"
#include "plshyph.h"

struct lshyph							/* Output of pfnHyphenate callback */
{
	UINT kysr;							/* Kind of Ysr - see "lskysr.h" */
	LSCP cpYsr;							/* cp value of YSR */
	WCHAR wchYsr;						/* YSR char code  */
};

#endif /* !LSHYPH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsffi.h ===
#ifndef LSFFI_DEFINED
#define LSFFI_DEFINED


/* Line Services "format flags" (from LSPAP ) */

/* Visi flags	*/
#define fFmiVisiCondHyphens			0x00000001L
#define fFmiVisiParaMarks			0x00000002L
#define fFmiVisiSpaces				0x00000004L
#define fFmiVisiTabs				0x00000008L
#define fFmiVisiSplats				0x00000010L
#define fFmiVisiBreaks				0x00000020L


/* Advanced typography enabling    */
#define fFmiPunctStartLine			0x00000040L
#define fFmiHangingPunct			0x00000080L
#define fFmiApplyBreakingRules		0x00000100L

/* WYSIWYG flags */
#define fFmiPresSuppressWiggle		0x00000200L
#define fFmiPresExactSync			0x00000400L

/* Autonumbering flags */
#define fFmiAnm						0x00000800L

/* Miscellaneous flags */
#define fFmiAutoDecimalTab			0x00001000L
#define fFmiUnderlineTrailSpacesRM	0x00002000L

#define fFmiSpacesInfluenceHeight	0x00004000L

#define fFmiIgnoreSplatBreak		0x00010000L
#define fFmiLimSplat				0x00020000L
#define fFmiAllowSplatLine			0x00040000L

#define	fFmiForceBreakAsNext		0x00080000L
#define fFmiFCheckTruncateBefore	0x00100000L

#define fFmiDoHyphenation			0x00200000L

#define fFmiDrawInCharCodes			0x00400000L

#define	fFmiTreatHyphenAsRegular	0x00800000L
#define fFmiWrapTrailingSpaces		0x01000000L
#define fFmiWrapAllSpaces			0x02000000L

/* Compatibility flags for bugs in older versions of WORD */
#define fFmiForgetLastTabAlignment	0x10000000L
#define fFmiIndentChangesHyphenZone	0x20000000L
#define fFmiNoPunctAfterAutoNumber	0x40000000L
#define fFmiResolveTabsAsWord97		0x80000000L

#endif /* !LSFFI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lskalign.h ===
#ifndef LSKALIGN_DEFINED
#define LSKALIGN_DEFINED

enum lskalign							/* kinds of para alignment */
{
	lskalLeft,
	lskalCentered,
	lskalRight,
};

typedef enum lskalign LSKALIGN;

#endif /* !LSKALIGN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsfrun.h ===
#ifndef LSFRUN_DEFINED
#define LSFRUN_DEFINED

#include "lsdefs.h"
#include "plschp.h"
#include "plsrun.h"
#include "plsfrun.h"

struct lsfrun							/* Formatter run */
{
	PCLSCHP plschp;
	PLSRUN plsrun;
	LPCWSTR lpwchRun;
	DWORD cwchRun;
};
typedef struct lsfrun LSFRUN;

#endif /* !LSFRUN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsimeth.h ===
#ifndef LSIMETH_DEFINED
#define LSIMETH_DEFINED

#include "lsdefs.h"

#include "plscbk.h"
#include "plsrun.h"
#include "pilsobj.h"
#include "plnobj.h"
#include "pdobj.h"
#include "pfmti.h"
#include "pbrko.h"
#include "pobjdim.h"
#include "pdispi.h"
#include "plsdocin.h"
#include "pposichn.h"
#include "plocchnk.h"
#include "plsfgi.h"
#include "pheights.h"
#include "plsqin.h"
#include "plsqout.h"
#include "plssubl.h"
#include "plschp.h"
#include "lstflow.h"
#include "lskjust.h"
#include "breakrec.h"
#include "brkcond.h"
#include "brkkind.h"
#include "fmtres.h"
#include "mwcls.h"

typedef struct
{
	LSERR (WINAPI* pfnCreateILSObj)(POLS, PLSC,  PCLSCBK, DWORD, PILSOBJ*);
	/* CreateILSObj
	 *  pols (IN):
	 *  plsc (IN): LS context
	 *  plscbk (IN): callbacks
	 *  idObj (IN): id of the object
	 *  &pilsobj (OUT): object ilsobj
	*/

	LSERR (WINAPI* pfnDestroyILSObj)(PILSOBJ);
	/* DestroyILSObj
	 *  pilsobj (IN): object ilsobj
	*/

	LSERR (WINAPI* pfnSetDoc)(PILSOBJ, PCLSDOCINF);
	/* SetDoc
	 *  pilsobj (IN): object ilsobj
	 *  lsdocinf (IN): initialization data at document level
	*/

	LSERR (WINAPI* pfnCreateLNObj)(PCILSOBJ, PLNOBJ*);
	/* CreateLNObj
	 *  pilsobj (IN): object ilsobj
	 *  &plnobj (OUT): object lnobj
	*/

	LSERR (WINAPI* pfnDestroyLNObj)(PLNOBJ);
	/* DestroyLNObj
	 *  plnobj (OUT): object lnobj
	*/

	LSERR (WINAPI* pfnFmt)(PLNOBJ, PCFMTIN, FMTRES*);
	/* Fmt
	 *  plnobj (IN): object lnobj
	 *  pfmtin (IN): formatting input
	 *  &fmtres (OUT): formatting result
	*/

	LSERR (WINAPI* pfnFmtResume)(PLNOBJ, const BREAKREC*, DWORD, PCFMTIN, FMTRES*);
	/* FmtResume
	 *  plnobj (IN): object lnobj
	 *  rgBreakRecord (IN): array of break records
	 *	nBreakRecord (IN): size of the break records array
	 *  pfmtin (IN): formatting input
	 *  &fmtres (OUT): formatting result
	*/

	LSERR (WINAPI* pfnGetModWidthPrecedingChar)(PDOBJ, PLSRUN, PLSRUN, PCHEIGHTS, WCHAR, MWCLS, long*);
	/* GetModWidthPrecedingChar
	 *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the preceding char
     *  heightsRef (IN): height info about character
	 *  wchar (IN): preceding character
	 *  mwcls (IN): ModWidth class of preceding character
	 *  &durChange (OUT): amount by which width of the preceding char is to be changed
	*/

	LSERR (WINAPI* pfnGetModWidthFollowingChar)(PDOBJ, PLSRUN, PLSRUN, PCHEIGHTS, WCHAR, MWCLS, long*);
	/* GetModWidthPrecedingChar
	 *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the following char
     *  heightsRef (IN): height info about character
	 *  wchar (IN): following character
	 *  mwcls (IN): ModWidth class of the following character
	 *  &durChange (OUT): amount by which width of the following char is to be changed
	*/

	LSERR (WINAPI* pfnTruncateChunk)(PCLOCCHNK, PPOSICHNK);
	/* Truncate
	 *  plocchnk (IN): locchnk to truncate
	 *  posichnk (OUT): truncation point
	*/

	LSERR (WINAPI* pfnFindPrevBreakChunk)(PCLOCCHNK, PCPOSICHNK, BRKCOND, PBRKOUT);
	/* FindPrevBreakChunk
	 *  plocchnk (IN): locchnk to break
	 *  pposichnk (IN): place to start looking for break
	 *  brkcond (IN): recommmendation about the break after chunk
	 *  &brkout (OUT): results of breaking
	*/

	LSERR (WINAPI* pfnFindNextBreakChunk)(PCLOCCHNK, PCPOSICHNK, BRKCOND, PBRKOUT);
	/* FindNextBreakChunk
	 *  plocchnk (IN): locchnk to break
	 *  pposichnk (IN): place to start looking for break
	 *  brkcond (IN): recommmendation about the break before chunk
	 *  &brkout (OUT): results of breaking
	*/

	LSERR (WINAPI* pfnForceBreakChunk)(PCLOCCHNK, PCPOSICHNK, PBRKOUT);
	/* ForceBreakChunk
	 *  plocchnk (IN): locchnk to break
	 *  pposichnk (IN): place to start looking for break
	 *  &brkout (OUT): results of breaking
	*/

	LSERR (WINAPI* pfnSetBreak)(PDOBJ, BRKKIND, DWORD, BREAKREC*, DWORD*);
	/* SetBreak
	 *  pdobj (IN): dobj which is broken
	 *  brkkind (IN): Previous/Next/Force/Imposed was chosen
	 *	nBreakRecord (IN): size of array
	 *  rgBreakRecord (OUT): array of break records
	 *	nActualBreakRecord (OUT): actual number of used elements in array
	*/

	LSERR (WINAPI* pfnGetSpecialEffectsInside)(PDOBJ, UINT*);
	/* GetSpecialEffects
	 *  pdobj (IN): dobj
	 *  &EffectsFlags (OUT): Special effects inside of this object
	*/

	LSERR (WINAPI* pfnFExpandWithPrecedingChar)(PDOBJ, PLSRUN, PLSRUN, WCHAR, MWCLS, BOOL*);
	/* FExpandWithPrecedingChar
	 *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the preceding char
	 *  wchar (IN): preceding character
	 *  mwcls (IN): ModWidth class of preceding character
	 *  &fExpand (OUT): expand preceding character?
	*/

	LSERR (WINAPI* pfnFExpandWithFollowingChar)(PDOBJ, PLSRUN, PLSRUN, WCHAR, MWCLS, BOOL*);
	/* FExpandWithFollowingChar
	 *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the following char
	 *  wchar (IN): following character
	 *  mwcls (IN): ModWidth class of the following character
	 *  &fExpand (OUT): expand object?
	*/
	LSERR (WINAPI* pfnCalcPresentation)(PDOBJ, long, LSKJUST, BOOL);
	/* CalcPresentation
	 *  pdobj (IN): dobj
	 *  dup (IN): dup of dobj
	 *  lskj (IN): current justification mode
	 *  fLastVisibleOnLine (IN): this object is last visible object on line
	*/

	LSERR (WINAPI* pfnQueryPointPcp)(PDOBJ, PCPOINTUV, PCLSQIN, PLSQOUT);
	/* QueryPointPcp
	 *  pdobj (IN): dobj to query
	 * 	ppointuvQuery (IN): query point (uQuery,vQuery)
     *	plsqin (IN): query input
     *	plsqout (OUT): query output
	*/
	
	LSERR (WINAPI* pfnQueryCpPpoint)(PDOBJ, LSDCP, PCLSQIN, PLSQOUT);
	/* QueryCpPpoint
	 *  pdobj (IN): dobj to query
	 *  dcp (IN):  dcp for the query
     *	plsqin (IN): query input
     *	plsqout (OUT): query output
	*/

	LSERR (WINAPI* pfnEnum)(PDOBJ, PLSRUN, PCLSCHP, LSCP, LSDCP, LSTFLOW, BOOL,
												BOOL, const POINT*, PCHEIGHTS, long);
	/* Enum object
	 *  pdobj (IN): dobj to enumerate
	 *  plsrun (IN): from DNODE
	 *  plschp (IN): from DNODE
	 *  cpFirst (IN): from DNODE
	 *  dcp (IN): from DNODE
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryNeeded (IN):
	 *  pptStart (IN): starting position, iff fGeometryNeeded
	 *  pheightsPres(IN): from DNODE, relevant iff fGeometryNeeded
	 *  dupRun(IN): from DNODE, relevant iff fGeometryNeeded
	*/

	LSERR (WINAPI* pfnDisplay)(PDOBJ, PCDISPIN);
	/* Display
	 *  pdobj (IN): dobj to display
	 *  pdispin (IN): input display info
	*/

	LSERR (WINAPI* pfnDestroyDObj)(PDOBJ);
	/* DestroyDObj
	 *  pdobj (IN): dobj to destroy
	*/

} LSIMETHODS;

#endif /* LSIMETH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lskeop.h ===
#ifndef LSKEOP_DEFINED
#define LSKEOP_DEFINED

enum lskeop							/* kinds of para ending */
{
	lskeopEndPara1,
	lskeopEndPara2,
	lskeopEndPara12,
	lskeopEndParaAlt
};

typedef enum lskeop LSKEOP;

#endif /* !LSKEOP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lskjust.h ===
#ifndef LSKJUST_DEFINED
#define LSKJUST_DEFINED

enum lskjust							/* kinds of para justification */
{
	lskjNone,
	lskjFullInterWord,
	lskjFullInterLetterAligned,
	lskjFullScaled,
	lskjFullGlyphs,
	lskjSnapGrid
};

typedef enum lskjust LSKJUST;

#endif /* !LSKJUST_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsksplat.h ===
#ifndef LSKSPLAT_DEFINED
#define LSKSPLAT_DEFINED

enum lsksplat							/* Kind of splat */
{
	lsksplPageBreak,
	lsksplColumnBreak,
	lsksplSectionBreak
};

#endif /* !LSKSPLAT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lskysr.h ===
#ifndef LSKYSR_DEFINED
#define LSKYSR_DEFINED

/* kysr codes: for LSCHP.kysr - Kind of YSR */
#define	kysrNil				0		/* No Hyphenation				*/
#define kysrNormal			1		/* Normal Hyphenation			*/
#define kysrAddBefore		2		/* Add letter before hyphen		*/
#define kysrChangeBefore	3		/* Change letter before hyphen	*/
#define kysrDeleteBefore	4		/* Delete letter before hyphen	*/
#define kysrChangeAfter		5		/* Change letter after hyphen	*/
#define kysrDelAndChange	6		/* Delete letter before the hyphen and */
									/* change the letter preceding the ... */

#endif /* !LSKYSR_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsktab.h ===
#ifndef LSKTAB_DEFINED
#define LSKTAB_DEFINED

#include "lsdefs.h"


enum lsktab								/* Kinds of tabs */
{
	lsktLeft,
	lsktCenter,
	lsktRight,
	lsktDecimal,
	lsktChar
};

typedef enum lsktab LSKTAB;


#endif  /* !LSKTAB_DEFINED     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lslinfo.h ===
#ifndef LSLINFO_DEFINED
#define LSLINFO_DEFINED

#include "lsdefs.h"
#include "endres.h"

typedef struct
{
	long dvpAscent;
	long dvrAscent;
	long dvpDescent;
	long dvrDescent;

	long dvpMultiLineHeight;
	long dvrMultiLineHeight;

	long dvpAscentAutoNumber;
	long dvrAscentAutoNumber;
	long dvpDescentAutoNumber;
	long dvrDescentAutoNumber;

	LSCP cpLim;					/* First cp which is NOT on this line */
	LSDCP dcpDepend;			/* # of chars wrapped to next line  */
	LSCP cpFirstVis;			/* First actual (not hidden) character in a line*/
								/* allows client to use character properties from the correct paragraph */


	ENDRES endr;				/* How line ended */
	BOOL fAdvanced;
	long vaAdvance;				/* Valid iff (fAdvanced != 0) */

	BOOL fFirstLineInPara;
	BOOL fTabInMarginExLine;
	BOOL fForcedBreak;

	DWORD nDepthFormatLineMax;  /* Formatting depth of the line (1--for plain line) */

	UINT EffectsFlags;			/* set of client defined special effects flags */
} LSLINFO;

#endif /* !LSLINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsqin.h ===
#ifndef LSQIN_DEFINED
#define LSQIN_DEFINED

#include "lsdefs.h"
#include "heights.h"
#include "lstflow.h"
#include "plsrun.h"
#include "plsqin.h"

typedef struct lsqin			
{
	LSTFLOW	lstflowSubline;
	PLSRUN plsrun;					/* PLSRUN this cp belongs to */
	LSCP cpFirstRun;
	LSDCP dcpRun;
	HEIGHTS	heightsPresRun;			/* In direction lstflowSubline */
	long dupRun;					/* In direction lstflowSubline			*/
	long dvpPosRun;					/* in direction of lstflowSubline	*/

} LSQIN;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lspairac.h ===
#ifndef LSPAIRAC_DEFINED
#define LSPAIRAC_DEFINED

#include "lsdefs.h"
#include "lsact.h"


typedef struct lspairact				/* Mod width pair unit				*/
{
	LSACT lsactFirst;					/* Action on first char				*/
	LSACT lsactSecond;					/* Action on second char			*/
} LSPAIRACT;									


#endif /* !LSPAIRAC_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lspract.h ===
#ifndef LSPRACT_DEFINED
#define LSPRACT_DEFINED

#include "lsdefs.h"
#include "lsact.h"

#define prior0					0		/* means priority is not defined	*/
#define prior1					1
#define prior2					2
#define prior3					3
#define prior4					4
#define prior5					5

typedef struct lspract					/* prioritized action 				*/
{
	BYTE prior;							/* priority							*/
	LSACT lsact;						/* action							*/
} LSPRACT;									


#endif /* !LSPRACTION_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lspap.h ===
#ifndef LSPAP_DEFINED
#define LSPAP_DEFINED

#include "lsdefs.h"
#include "plspap.h"
#include "lskjust.h"
#include "lskalign.h"
#include "lsbrjust.h"
#include "lskeop.h"
#include "lstflow.h"

/* ---------------------------------------------------------------------- */

struct lspap
{
	LSCP cpFirst;						/* 1st cp for this paragraph */
	LSCP cpFirstContent;				/* 1st cp of "content" in the para */

	DWORD grpf;							/* line services format flags (lsffi.h)*/

	long uaLeft;						/* left boundary for line				*/
	long uaRightBreak;					/* right boundary for break */
	long uaRightJustify;					/* right boundary for justification */
	long duaIndent;
	long duaHyphenationZone;

	LSBREAKJUST lsbrj;					/* Break/Justification behavior	*/
	LSKJUST lskj;						/* Justification type */
	LSKALIGN lskal;						/* Alignment type */

	long duaAutoDecimalTab;

	LSKEOP lskeop;						/* kind of paragraph ending */
	
	LSTFLOW lstflow;					/* Main text flow direction */

};

typedef struct lspap LSPAP;

#endif /* !LSPAP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsqout.h ===
#ifndef LSQOUT_DEFINED
#define LSQOUT_DEFINED

#include "lsdefs.h"
#include "heights.h"
#include "lscell.h"
#include "plssubl.h"
#include "plsqout.h"


typedef struct lsqout			
{
 	POINTUV pointUvStartObj;		/* In coordinate system of parent subline
										relative to the beginning of dnode	*/
	HEIGHTS	heightsPresObj;			/* In direction of parent subline */
	long dupObj;					/* In direction lstflowSubline			*/

	LSTEXTCELL lstextcell;			/* in coordinate system of parent subline,
										relative to the beginning of dnode	*/

	PLSSUBL plssubl;
 	POINTUV pointUvStartSubline;	/* In coordinate system of parent subline
										relative to the beginning of dnode	*/

} LSQOUT;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsqline.h ===
#ifndef LSQLINE_DEFINED
#define LSQLINE_DEFINED

#include "lsdefs.h"
#include "plsline.h"
#include "plsqsinf.h"
#include "plscell.h"
#include "pcelldet.h"
#include "gprop.h"

LSERR WINAPI  LsQueryLineCpPpoint(
							PLSLINE,	/* IN: pointer to line info -- opaque to client	*/
							LSCP,		/* IN: cpQuery									*/
							DWORD,      /* IN: nDepthQueryMax							*/
							PLSQSUBINFO,/* OUT: array[nDepthQueryMax] of LSQSUBINFO		*/
							DWORD*,		 /* OUT: nActualDepth							*/
							PLSTEXTCELL);/* OUT: Text cell info							*/


LSERR WINAPI LsQueryLinePointPcp(
							PLSLINE,	/* IN: pointer to line -- opaque to client			*/
						 	PCPOINTUV,	/* IN: query point (uQuery,vQuery) (line text flow)	*/
							DWORD,      /* IN: nDepthQueryMax								*/
							PLSQSUBINFO,/* OUT: array[nDepthQueryMax] of LSQSUBINFO			*/
							DWORD*,      /* OUT: nActualDepth	*/
							PLSTEXTCELL);/* OUT: Text cell info */

LSERR WINAPI LsQueryTextCellDetails(
							PLSLINE,	/* IN: pointer to line -- opaque to client				*/
						 	PCELLDETAILS,/* IN: query point (uQuery,vQuery) (line text flow)	*/
							LSCP,		/* IN: cpStartCell										*/
							DWORD,		/* IN: nCharsInContext									*/
							DWORD,		/* IN: nGlyphsInContext									*/
							WCHAR*,		/* OUT: pointer array[nCharsInContext] of char codes	*/
							PGINDEX,	/* OUT: pointer array[nGlyphsInContext] of glyph indices*/
							long*,		/* OUT: pointer array[nGlyphsInContext] of glyph widths	*/
							PGOFFSET,	/* OUT: pointer array[nGlyphsInContext] of glyph offsets*/
							PGPROP);	/* OUT: pointer array[nGlyphsInContext] of glyph handles*/

/*
 *	Query point and output point are in the coordinate system of the line.
 *	Text flow is the text flow of the line, zero point is at the starting point of the line. 
 */


LSERR WINAPI LsQueryLineDup(PLSLINE,	/* IN: pointer to line -- opaque to client	*/
							long*,		/* OUT: upStartAutonumberingText			*/
							long*,		/* OUT: upLimAutonumberingText				*/
							long*,		/* OUT: upStartMainText						*/
							long*,		/* OUT: upStartTrailing						*/
							long*);		/* OUT: upLimLine							*/

LSERR WINAPI LsQueryFLineEmpty(
							PLSLINE,	/* IN: pointer to line -- opaque to client 	*/
							BOOL*);		/* OUT: Is line empty? 						*/

#endif /* !LSQLINE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsqsinfo.h ===
#ifndef LSQSINFO_DEFINED
#define LSQSINFO_DEFINED

#include "lsdefs.h"
#include "heights.h"
#include "lstflow.h"
#include "plsrun.h"
#include "plsqsinf.h"


typedef struct lsqsubinfo			
{
	LSTFLOW	lstflowSubline;
	LSCP cpFirstSubline;
	LSDCP dcpSubline;
 	POINTUV pointUvStartSubline;	/* In coordinate system of main line/subline */
	HEIGHTS	heightsPresSubline;		/* In direction lstflowSubline */
	long dupSubline;				/* In direction lstflowSubline			*/


	DWORD idobj;
	PLSRUN plsrun;
	LSCP cpFirstRun;
	LSDCP dcpRun;
 	POINTUV pointUvStartRun;		/* In coordinate system of main line/subline */
	HEIGHTS	heightsPresRun;			/* In direction lstflowSubline */
	long dupRun;					/* In direction lstflowSubline			*/
	long dvpPosRun;					/* in direction of lstflowSubline	*/

	long dupBorderBefore;			/* in direction of lstflowSubline	*/
	long dupBorderAfter;			/* in direction of lstflowSubline	*/

 	POINTUV pointUvStartObj;		/* Set by Object, translated to coord system of main line/subline */
	HEIGHTS	heightsPresObj;			/* Set by Object, in direction lstflowSubline */
	long dupObj;					/* Set by Object, in direction lstflowSubline			*/


} LSQSUBINFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsqsubl.h ===
#ifndef LSQSUBL_DEFINED
#define LSQSUBL_DEFINED

/* Line services formatter fetch/dispatcher interface (to LsCreateLine())
 */

#include "lsdefs.h"
#include "plssubl.h"
#include "plsqsinf.h"
#include "plscell.h"

LSERR WINAPI LsQueryCpPpointSubline(
							PLSSUBL,		/* IN: subline context			*/
							LSCP, 			/* IN: cpQuery 					*/
							DWORD,      	/* IN: nDepthQueryMax			*/
							PLSQSUBINFO,	/* OUT: array[nDepthQueryMax] of LSQSUBINFO	*/
							DWORD*,			/* OUT: nActualDepth			*/
							PLSTEXTCELL);	/* OUT: Text cell info			*/
							
LSERR WINAPI LsQueryPointPcpSubline(
							PLSSUBL,		/* IN: subline context			*/
						 	PCPOINTUV,		/* IN: query point from the subline beginning */
							DWORD,      	/* IN: nDepthQueryMax			*/
							PLSQSUBINFO,	/* OUT: array[nDepthQueryMax] of LSQSUBINFO */
							DWORD*,		 	/* OUT: nActualDepth			*/
							PLSTEXTCELL);	/* OUT: Text cell info			*/


#endif /* !LSQSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lstabs.h ===
#ifndef LSTABS_DEFINED
#define LSTABS_DEFINED

#include "lsdefs.h"
#include "lsktab.h"

/* ---------------------------------------------------------------------- */


/* ---------------------------------------------------------------------- */

typedef struct
{
	enum lsktab lskt;					/* Kind of tab */
	long ua;							/* tab position */
	WCHAR wchTabLeader;					/* character for tab leader */
										/*   if 0, no leader is used*/
	WCHAR wchCharTab;					/* Character for CharTab	*/
} LSTBD;

/* ---------------------------------------------------------------------- */

typedef struct lstabs
{
	long duaIncrementalTab;				/* "Default" tab behavior */
	DWORD iTabUserDefMac;
	LSTBD* pTab;				
} LSTABS;


#endif /* !LSTABS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lssubset.h ===
#ifndef LSSUBSET_DEFINED
#define LSSUBSET_DEFINED

/* Access routines for contents of DNODES */

#include "lsdefs.h"
#include "plsrun.h"
#include "plssubl.h"
#include "pobjdim.h"
#include "lstflow.h"

			
LSERR WINAPI LssbGetObjDimSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							LSTFLOW*,			/* OUT: subline's lstflow		*/
					 	    POBJDIM);			/* OUT: dimensions of subline	*/
							
LSERR WINAPI LssbGetDupSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							LSTFLOW*,			/* OUT: subline's lstflow		*/
					 	    long*);				/* OUT: dup of subline			*/

LSERR WINAPI LssbFDonePresSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							BOOL*);				/* OUT: Is it CalcPres'd		*/

LSERR WINAPI LssbFDoneDisplay(
							PLSSUBL,			/* IN: Subline Context			*/
							BOOL*);				/* OUT: Is it displayed			*/

LSERR WINAPI LssbGetPlsrunsFromSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							DWORD,				/* IN: N of DNODES in subline	*/
							PLSRUN*);			/* OUT: array of PLSRUN's		*/

LSERR WINAPI LssbGetNumberDnodesInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							DWORD*);			/* OUT: N of DNODES in subline	*/

LSERR WINAPI LssbGetVisibleDcpInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							LSDCP*);			/* OUT: N of characters			*/

LSERR WINAPI LssbGetDurTrailInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							long*);				/* OUT: width of trailing area	*/
	
LSERR WINAPI LssbGetDurTrailWithPensInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							long*);				/* OUT: width of trailing area
													including pens in subline	*/
LSERR WINAPI LssbFIsSublineEmpty(
							PLSSUBL plssubl,	/* IN: subline					*/
							BOOL*  pfEmpty);	/* OUT:is this subline empty	*/


#endif /* !LSSUBSET_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsstinfo.h ===
#ifndef LSSTINFO_DEFINED
#define LSSTINFO_DEFINED

#include "lsdefs.h"
#include "plsstinf.h"

/* 
 * all strikethrough offsets are relative to the baseline and positive upwards (filled page direction),
 * so normally dvpLowerStrikethroughOffset > 0 and if cNumberOfLines == 2
 * dvpLowerStrikethroughOffset < dvpUpperStrikethroughOffset
 */

struct lsstinfo
{
    UINT  kstbase;						/* base kind of strikethrough  */
    DWORD cNumberOfLines;				/* number of lines: possible values 1,2*/

	long dvpLowerStrikethroughOffset ;	/* if NumberOfLines != 2 only data for 
											lower line should be filled in */
	long dvpLowerStrikethroughSize;
	long dvpUpperStrikethroughOffset;	
	long dvpUpperStrikethroughSize;

};
typedef struct lsstinfo LSSTINFO;


#endif /* !LSSTINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lssetdoc.h ===
#ifndef LSSETDOC_DEFINED
#define LSSETDOC_DEFINED

#include "lsdefs.h"
#include "lsdevres.h"
#include "lspract.h"
#include "lspairac.h"
#include "lsexpan.h"
#include "lsbrk.h"

LSERR WINAPI LsSetDoc(PLSC,				/* IN: ptr to line services context */
					  BOOL,				/* IN: Intend to display? 			*/
					  BOOL,				/* IN: Ref & Pres Devices are equal?*/
					  const LSDEVRES*); /* IN: device resolutions 			*/

LSERR WINAPI LsSetModWidthPairs(
					  PLSC,				/* IN: ptr to line services context */
					  DWORD,			/* IN: Number of mod pairs info units*/ 
					  const LSPAIRACT*,	/* IN: Mod pairs info units array  */
					  DWORD,			/* IN: Number of Mod Width classes	*/
					  const BYTE*);		/* IN: Mod width information(square):
											  indexes in the LSPAIRACT array */
LSERR WINAPI LsSetCompression(
					  PLSC,				/* IN: ptr to line services context */
					  DWORD,			/* IN: Number of compression priorities*/
					  DWORD,			/* IN: Number of compression info units*/
					  const LSPRACT*,	/* IN: Compession info units array 	*/
					  DWORD,			/* IN: Number of Mod Width classes	*/
					  const BYTE*);		/* IN: Compression information:
											  indexes in the LSPRACT array  */
LSERR WINAPI LsSetExpansion(
					  PLSC,				/* IN: ptr to line services context */
					  DWORD,			/* IN: Number of expansion info units*/
					  const LSEXPAN*,	/* IN: Expansion info units array	*/
					  DWORD,			/* IN: Number of Mod Width classes	*/
					  const BYTE*);		/* IN: Expansion information(square):
											  indexes in the LSEXPAN array  */
LSERR WINAPI LsSetBreaking(
					  PLSC,				/* IN: ptr to line services context */
					  DWORD,			/* IN: Number of breaking info units*/
					  const LSBRK*,		/* IN: Breaking info units array	*/
					  DWORD,			/* IN: Number of breaking classes	*/
					  const BYTE*);		/* IN: Breaking information(square):
											  indexes in the LSBRK array  */


#endif /* !LSSETDOC_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lstxm.h ===
#ifndef LSTXM_DEFINED
#define LSTXM_DEFINED

#include "lsdefs.h"
#include "plstxm.h"
/*igorzv** good explanation according text flow issue is needed here /
/* A few words about the v-vector and the sign bit: 
 *
 * dvDescent is positive downwards.		
 * v is positive upwards during formatting.
 */

struct lstxm
{
	long dvAscent;
	long dvDescent;

	long dvMultiLineHeight;
	BOOL fMonospaced;
};
typedef struct lstxm LSTXM;


#endif /* !LSTXM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lstflow.h ===
#ifndef LSTFLOW_DEFINED
#define LSTFLOW_DEFINED

#include "lsdefs.h"

typedef DWORD  LSTFLOW;

#define lstflowDefault	0  

#define lstflowES		0  
#define lstflowEN		1  
#define lstflowSE		2  
#define lstflowSW		3  
#define lstflowWS		4  
#define lstflowWN		5  
#define lstflowNE		6  
#define lstflowNW		7  

/*
 *	The eight possible text flows are listed clockwise starting with default (Latin) one.
 *
 *	lstflowES is the coordinate system used when line grows to East and text grows to South.
 *	(Next letter is to the right (east) of previous, next line is created below (south) the previous.) 
 *
 *	For lstflowES positive u moves to the right, positive v moves up. (V axis is always in the direction
 *	of ascender, opposite to text growing direction.
 *
 *	Notice it is not the way axes are pointing in the default Windows mapping mode MM_TEXT. 
 *	In MM_TEXT vertical (y) axis increase from top to bottom, 
 *	in lstflowES vertical (v) axis increase from bottom to top.
 */
 
#define fUDirection			0x00000004L
#define fVDirection			0x00000001L
#define fUVertical			0x00000002L

/*
 *	The three bits that constitute lstflow happens to have well defined meanings.
 *
 *	Middle bit: on for vertical writing, off for horizontal.
 *	First (low value) bit: "on" means v-axis points right or down (positive).
 *	Third bit: "off" means u-axis points right or down (positive).
 *
 * See examples of usage in lstfset.c
 *
 */


#endif /* !LSTFLOW_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lstfset.h ===
#ifndef LSTFSET_DEFINED
#define LSTFSET_DEFINED

/* Service routines for some standard text flow change tasks */

#include "lsdefs.h"
#include "lstflow.h"

/* 
 * LsPointXYFromPointUV calculates pointxyOut given (x,y) pointxyIn and (u,v) vector 
 *  
 *  (pointxyOut = pointxyIn + vectoruv)
 */

LSERR WINAPI LsPointXYFromPointUV(const POINT*, 	/* IN: input point (x,y) */
									LSTFLOW,	 	/* IN: text flow for */
									PCPOINTUV,		/* IN: vector in (u,v) */
									POINT*);		/* OUT: (x,y) point */


/* 
 * LsPointUV1FromPointUV2 calculates vector in uv2 coordinates given begin and end of it in uv1.
 *  
 *  (vectorUV22 = pointUV1b - pointUV1a)
 *
 *	Usually pointUV1a is the starting point of uv2 coordinate system and it is easier to think 
 *		about output vector as a point in it.
 */

LSERR WINAPI LsPointUV2FromPointUV1(LSTFLOW,	 	/* IN: text flow 1 (TF1) */
									PCPOINTUV,	 	/* IN: starting point (TF1) */
									PCPOINTUV,		/* IN: ending point (TF1) */
									LSTFLOW,	 	/* IN: text flow 2 (TF2) */
									PPOINTUV);		/* OUT: vector in TF2 */


#endif /* !LSTFSET_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\mwcls.h ===
#ifndef MWCLS_DEFINED
#define MWCLS_DEFINED

#include "lsdefs.h"

typedef BYTE MWCLS;

#endif /* !MWCLS_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lstxtcfg.h ===
#ifndef LSTXTCFG_DEFINED
#define LSTXTCFG_DEFINED

#include "lsdefs.h"
#include "plstxtcf.h"

typedef struct lstxtcfg
{
	long cEstimatedCharsPerLine;

	WCHAR wchUndef;
	WCHAR wchNull;
	WCHAR wchSpace;
	WCHAR wchHyphen;
	WCHAR wchTab;
	WCHAR wchEndPara1;
	WCHAR wchEndPara2;
	WCHAR wchAltEndPara;
	WCHAR wchEndLineInPara;				/* Word "CCRJ", */
	WCHAR wchColumnBreak;
	WCHAR wchSectionBreak;
	WCHAR wchPageBreak;
	WCHAR wchNonBreakSpace;				/* char code of non-breaking space */
	WCHAR wchNonBreakHyphen;
	WCHAR wchNonReqHyphen;				/* discretionary hyphen */
	WCHAR wchEmDash;
	WCHAR wchEnDash;
	WCHAR wchEmSpace;
	WCHAR wchEnSpace;
	WCHAR wchNarrowSpace;
	WCHAR wchOptBreak;
	WCHAR wchNoBreak;
	WCHAR wchFESpace;
	WCHAR wchJoiner;
	WCHAR wchNonJoiner;
	WCHAR wchToReplace;					/* backslash in FE Word				*/
	WCHAR wchReplace;					/* Yen in FE Word				*/


	WCHAR wchVisiNull;					/* visi char for wch==wchNull		*/
	WCHAR wchVisiAltEndPara;			/* visi char for end "table cell"	*/
	WCHAR wchVisiEndLineInPara;			/* visi char for wchEndLineInPara	*/
	WCHAR wchVisiEndPara;				/* visi char for "end para"			*/
	WCHAR wchVisiSpace;					/* visi char for "space"			*/
	WCHAR wchVisiNonBreakSpace;			/* visi char for wchNonBreakSpace	*/
	WCHAR wchVisiNonBreakHyphen;		/* visi char for wchNonBreakHyphen	*/
	WCHAR wchVisiNonReqHyphen;			/* visi char for wchNonReqHyphen	*/
	WCHAR wchVisiTab;					/* visi char for "tab"				*/
	WCHAR wchVisiEmSpace;				/* visi char for wchEmSpace			*/
	WCHAR wchVisiEnSpace;				/* visi char for wchEnSpace			*/
	WCHAR wchVisiNarrowSpace;			/* visi char for wchNarrowSpace		*/
	WCHAR wchVisiOptBreak;              /* visi char for wchOptBreak		*/
	WCHAR wchVisiNoBreak;				/* visi char for wchNoBreak			*/
	WCHAR wchVisiFESpace;				/* visi char for wchOptBreak		*/

	WCHAR wchEscAnmRun;

	WCHAR wchPad;
} LSTXTCFG;

#endif /* !LSTXTCFG_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\objdim.h ===
#ifndef OBJDIM_DEFINED
#define OBJDIM_DEFINED

#include "lsdefs.h"
#include "pobjdim.h"
#include "heights.h"

typedef struct objdim							/* Object dimensions */
{
	HEIGHTS heightsRef;	
	HEIGHTS heightsPres;	
	long dur;
} OBJDIM;

#endif /* !OBJDIM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\lsulinfo.h ===
#ifndef LSULINFO_DEFINED
#define LSULINFO_DEFINED

#include "lsdefs.h"
#include "plsulinf.h"

/* 
 * Both Offsets are relative to the local baseline and positive "down" (towards blank page), 
 * so in horizontal Latin case dvpFirstUnderlineOffset usually is bigger than zero. 
 *
 * dvpUnderlineOrigin points to UnderlineOrigin - the place where (main part of the) letter ends and 
 * area for underlining begins. For Latin letters it is the Latin baseline. UnderlineOrigin shows if
 * one run of two runs is higher; runs with the same UnderlineOrigin can have their underlines averaged.
 *
 * dvpFirstUnderlineOffset points to the beginning of the closest to the UnderlineOrigin underline.
 * You have "underlining from above" case if dvpUnderlineOrigin > dvpFirstUnderlineOffset.
 *
 * Everything else should be positive. Instead of dvpSecondUnderlineOffset of the previous version dvpGap 
 * is used. Second underline is further away from the UnderlineOrigin than first underline, so
 * dvpSecondUnderlineOffset = dvpFirstUnderlineOffset + dvpFirstUnderlineSize + dvpGap in normal case.
 * In "underlining from above" case there will be minuses instead of pluses.
 *
 * Main merging rules: 
 *
 * LS will not merge runs with different kulbase or different cNumberOfLines.
 * LS will not merge runs with different negative dvpPos (subscripts)
 * LS will not merge subscripts with superscripts or baseline runs
 * LS will not merge "underlined above" run with "underlined below" run.
 *
 * If merging is possible: 
 * Runs with the same UnderlineOrigin are averaged.
 * If UnderlineOrigins are different, the run with higher UnderlineOrigin takes metrics from neighbor.
 */

struct lsulinfo
{
    UINT  kulbase;						/* base kind of underline */
    DWORD cNumberOfLines;				/* number of lines: possible values 1,2*/

	long dvpUnderlineOriginOffset;		/* UnderlineOrigin decides which run is higher */
	long dvpFirstUnderlineOffset;		/* offset for start of the (first) underline */
	long dvpFirstUnderlineSize;			/* width of the (first) underline */
	
	long dvpGapBetweenLines;			/* If NumberOfLines != 2, dvpGapBetweenLines */
	long dvpSecondUnderlineSize;		/* 	and dvpSecondUnderlineSize are ignored. */
	
};
typedef struct lsulinfo LSULINFO;


#endif /* !LSULINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\pcelldet.h ===
#ifndef PCELLDET_DEFINED
#define PCELLDET_DEFINED

struct celldetails;
typedef struct celldetails* PCELLDETAILS;

#endif /* !PCELLDET_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\pbrko.h ===
#ifndef PBRKO_DEFINED
#define PBRKO_DEFINED

struct brkout;
typedef struct brkout* PBRKOUT;

#endif /* !PBRKO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\pdispi.h ===
#ifndef PDISPI_DEFINED
#define PDISPI_DEFINED

struct dispin;
typedef const struct dispin *PCDISPIN;

#endif /* !PDISPI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\pdobj.h ===
#ifndef PDOBJ_DEFINED
#define PDOBJ_DEFINED

struct dobj;
typedef struct dobj* PDOBJ;

#endif /* PDOBJ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\pfmti.h ===
#ifndef PFMTI_DEFINED
#define PFMTI_DEFINED

struct fmtin;
typedef const struct fmtin *PCFMTIN;

#endif /* !PFMTI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\pheights.h ===
#ifndef PHEIGHTS_DEFINED
#define PHEIGHTS_DEFINED

struct heights;
typedef struct heights* PHEIGHTS;
typedef const struct heights* PCHEIGHTS;

#endif /* !POBJDIME_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\pilsobj.h ===
#ifndef PILSOBJ_DEFINED
#define PILSOBJ_DEFINED

struct ilsobj;

typedef struct ilsobj* PILSOBJ;
typedef const PILSOBJ PCILSOBJ;

#endif /* PILSOBJ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plscell.h ===
#ifndef PLSCELL_DEFINED
#define PLSCELL_DEFINED

struct lstextcell;
typedef struct lstextcell* PLSTEXTCELL;
typedef const struct lstextcell* PCLSTEXTCELL;

#endif /* !PLSCELL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plschp.h ===
#ifndef PLSCHP_DEFINED
#define PLSCHP_DEFINED

struct lschp;
typedef struct lschp* PLSCHP;
typedef const struct lschp* PCLSCHP;

#endif /* !PLSCHP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plocchnk.h ===
#ifndef PLOCCHNK_DEFINED
#define PLOCCHNK_DEFINED

struct locchnk;
typedef const struct locchnk* PCLOCCHNK;
typedef struct locchnk* PLOCCHNK;

#endif /* !PLSLOCCH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plnobj.h ===
#ifndef PLNOBJ_DEFINED
#define PLNOBJ_DEFINED

struct lnobj;
typedef struct lnobj* PLNOBJ;

#endif /* PLNOBJ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plscbk.h ===
#ifndef PLSCBK_DEFINED
#define PLSCBK_DEFINED

struct lscbk;
typedef struct lscbk* PLSCBK;
typedef const struct lscbk* PCLSCBK;

#endif /* !PLSCBK_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plsdnode.h ===
#ifndef PLSDNODE_DEFINED
#define PLSDNODE_DEFINED

struct lsdnode;
typedef struct lsdnode* PLSDNODE;

#endif /* PLSDNODE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plsdocin.h ===
#ifndef PLSDOCINF_DEFINED
#define PLSDOCINF_DEFINED

struct lsdocinf;
typedef const struct lsdocinf* PCLSDOCINF;
#endif /* !PLSDOCINF_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plsems.h ===
#ifndef PLSEMS_DEFINED
#define PLSEMS_DEFINED

struct lsems;

typedef struct lsems* PLSEMS;

#endif /* !PLSEMS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plsfrun.h ===
#ifndef PLSFRUN_DEFINED
#define PLSFRUN_DEFINED

struct lsfrun;
typedef struct lsfrun* PLSFRUN;
typedef const struct lsfrun* PCLSFRUN;

#endif /* PLSRUN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plshyph.h ===
#ifndef PLSHYPH_DEFINED
#define PLSHYPH_DEFINED

struct lshyph;
typedef struct lshyph* PLSHYPH;
typedef const struct lshyph* PCLSHYPH;

#endif /* !PLSHYPH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plsline.h ===
#ifndef PLSLINE_DEFINED
#define PLSLINE_DEFINED

struct lsline;
typedef struct lsline* PLSLINE;

#endif /* PLSLINE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plspap.h ===
#ifndef PLSPAP_DEFINED
#define PLSPAP_DEFINED

struct lspap;
typedef struct lspap* PLSPAP;

#endif /* !PLSPAP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plsfgi.h ===
#ifndef PLSFGI_DEFINED
#define PLSFGI_DEFINED

struct lsfgi;
typedef struct lsfgi* PLSFGI;

#endif /* !PLSFGI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plsqout.h ===
#ifndef PLSQOUT_DEFINED
#define PLSQOUT_DEFINED

struct lsqout;
typedef struct lsqout* PLSQOUT;

#endif /* !PLSQOUT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plsqin.h ===
#ifndef PLSQIN_DEFINED
#define PLSQIN_DEFINED

struct lsqin;
typedef struct lsqin* PLSQIN;
typedef const struct lsqin* PCLSQIN;

#endif /* !PLSQIN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plsrun.h ===
#ifndef PLSRUN_DEFINED
#define PLSRUN_DEFINED

struct lsrun;
typedef struct lsrun* PLSRUN;

#endif /* PLSRUN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plsstinf.h ===
#ifndef PLSSTINFO_DEFINED
#define PLSSTINFO_DEFINED

struct lsstinfo;
typedef struct lsstinfo* PLSSTINFO;

#endif /* !PLSSTINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plsqsinf.h ===
#ifndef PLSQSINF_DEFINED
#define PLSQSINF_DEFINED

struct lsqsubinfo;
typedef struct lsqsubinfo* PLSQSUBINFO;
typedef const struct lsqsubinfo* PCLSQSUBINFO;

#endif /* !PLSQSINF_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plssubl.h ===
#ifndef PLSSUBL_DEFINED
#define PLSSUBL_DEFINED

struct lssubl;
typedef struct lssubl* PLSSUBL;

#endif /* PLSSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plstxm.h ===
#ifndef PLSTXM_DEFINED
#define PLSTXM_DEFINED

struct lstxm;
typedef struct lstxm* PLSTXM;

#endif /* !PLSTXM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plstxtcf.h ===
#ifndef PLSTXTCF_DEFINED
#define PLSTXTCF_DEFINED

struct lstxtcfg;
typedef struct lstxtcfg *PLSTXTCFG;
typedef const struct lstxtcfg *PCLSTXTCFG;

#endif /* PLSTXTCF_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plstabs.h ===
#ifndef PLSTABS_DEFINED
#define PLSTABS_DEFINED

struct lstabs;
typedef struct lstabs* PLSTABS;
typedef const struct lstabs* PCLSTABS;

#endif /* PLSTABS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\plsulinf.h ===
#ifndef PLSULINFO_DEFINED
#define PLSULINFO_DEFINED

struct lsulinfo;
typedef struct lsulinfo* PLSULINFO;

#endif /* !PLSULINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\pposichn.h ===
#ifndef PPOSICHN_DEFINED
#define PPOSICHN_DEFINED

struct posichnk;
typedef const struct posichnk* PCPOSICHNK;
typedef struct posichnk* PPOSICHNK;

#endif /* !PPOSICHN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\pobjdim.h ===
#ifndef POBJDIM_DEFINED
#define POBJDIM_DEFINED

struct objdim;
typedef struct objdim* POBJDIM;
typedef const struct objdim* PCOBJDIM;

#endif /* !POBJDIM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\posichnk.h ===
#ifndef POSICHNK_DEFINED
#define POSICHNK_DEFINED

#include "lsdefs.h"
#include "pposichn.h"

#define ichnkOutside 0xFFFFFFFF

typedef struct posichnk					/* position in chunk		*/
{
	long ichnk;							/* index in the chunk array	*/
	LSDCP dcp;							/* from beginning of dobj	*/
} POSICHNK;



#endif /* !POSICHNK_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\robj.h ===
#ifndef ROBJ_DEFINED
#define ROBJ_DEFINED

#include "lsimeth.h"

#define REVERSE_VERSION 0x300

/* Prototype for Reverse Object enumeration callback */
typedef LSERR (WINAPI * PFNREVERSEENUM)(
	POLS pols,				/*(IN): client context */
	PLSRUN plsrun,			/*(IN): from DNODE */
	PCLSCHP plschp,			/*(IN): from DNODE */
	LSCP cp,				/*(IN): from DNODE */
	LSDCP dcp,				/*(IN): from DNODE */
	LSTFLOW lstflow,		/*(IN): text flow */
	BOOL fReverse,			/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,	/*(IN): */
	const POINT* pt,		/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,	/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun,			/*(IN): from DNODE, relevant iff fGeometryNeeded */
	LSTFLOW lstflowSubline,	/*(IN): lstflow of subline in reverse object */
	PLSSUBL plssubl);		/*(IN): subline in reverse object. */

/*
 *
 *	Reverse Object initialization data that the client application must return
 *	when the Reverse Object handler calls the GetObjectHandlerInfo callback.
 *
 */


/* Prototype for Reverse Object get info */

typedef LSERR (WINAPI * PFNREVERSEGETINFO)
(
	POLS	pols,
	LSCP	cp,
	PLSRUN	plsrun,

	BOOL	* pfDoNotBreakAround,
	BOOL	* pfSuppressTrailingSpaces
);

typedef struct REVERSEINIT
{
        DWORD					dwVersion;		/* Version. Must be REVERSE_VERSION */
        WCHAR					wchEndReverse;	/* Escape char for end of Reverse Object */

		WCHAR					wchUnused1;		/* Unused for alignment */
		PFNREVERSEGETINFO		pfnGetRobjInfo;	/* Callback GetInfo */
		PFNREVERSEENUM			pfnEnum;		/* Enumeration callback */

} REVERSEINIT;

LSERR WINAPI LsGetReverseLsimethods(
        LSIMETHODS *plsim);

/* GetReverseLsimethods
 *
 *	plsim (OUT): Reverse Object Handler methods for Line Services.
 *
 */

#endif /* ROBJ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\ruby.h ===
#ifndef RUBY_DEFINED
#define RUBY_DEFINED

#include	"lsimeth.h"

/* Only valid version number for Ruby initialization */
#define RUBY_VERSION 0x300

/* Used for intialization to tell Ruby object which line comes first */
typedef enum rubysyntax { RubyPronunciationLineFirst, RubyMainLineFirst } RUBYSYNTAX;


/* Type of Adjustment for Ruby text returned by FetchRubyPosition callback */
enum rubycharjust { 
	rcjCenter, 		/* Centering occurs on longer text line */

	rcj010, 		/* Difference in space between longer text
					 * and shorter is distributed in the shorter
					 * string evenly between each character 
					 */

	rcj121,			/* Difference in space between longer string
					 * and shorter is distributed in the shorter
					 * using a ratio of 1:2:1 which corresponds
					 * to lead : inter-character : end.
					 */

	rcjLeft,		/* Align ruby with the left of the main line.
					 */

	rcjRight		/* Align ruby with the right of the main line.
					 */
};

/* Location of character input to FetchRubyWidthAdjust callback */
enum rubycharloc {
	rubyBefore,		/* Character preceeds Ruby object */
	rubyAfter		/* Character follows Ruby object */
};

/*
 *
 *	Ruby Object callbacks to client application
 *
 */
typedef struct RUBYCBK
{
	LSERR (WINAPI *pfnFetchRubyPosition)(
		POLS pols,
		LSCP cp,
		LSTFLOW lstflow,
		DWORD cdwMainRuns,
		const PLSRUN *pplsrunMain,
		PCHEIGHTS pcheightsRefMain,
		PCHEIGHTS pcheightsPresMain,
		DWORD cdwRubyRuns,
		const PLSRUN *pplsrunRuby,
		PCHEIGHTS pcheightsRefRuby,
		PCHEIGHTS pcheightsPresRuby,
		PHEIGHTS pheightsRefRubyObj,
		PHEIGHTS pheightsPresRubyObj,
		long *pdvpOffsetMainBaseline,
		long *pdvrOffsetRubyBaseline,
		long *pdvpOffsetRubyBaseline,
		enum rubycharjust *prubycharjust,
		BOOL *pfSpecialLineStartEnd);

	/* FetchRubyPosition
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Ruby object.
	 *
	 *  lstflow (IN): the lstflow of Ruby parent subline
	 *
	 *	pplsrunMain	(IN): array of PLSRUNs created by the client application 
	 *			for each of the runs in the main text for the Ruby object.
	 *
	 *	pcheightsRefMain (IN): height of the line of the main text in reference 
	 *			device units.
	 *
	 *	pcheightsPresMain (IN): height of the line of the main text in presentation
	 *			device units.
	 *
	 *	cdwRubyRuns	(IN): count of pronunciation runs supplied in the following 
	 *			parameter.
	 *
	 *	pplsrunRuby	(IN): array of PLSRUNS created by the client application for 
	 *			each of the runs in the pronunciation text for the Ruby object.
	 *
	 *	pcheightsRefRuby (IN): height of the line of the Ruby pronunciation text in 
	 *			reference device units.
	 *
	 *	pcheightsPresRuby (IN): height of the line of the Ruby pronunciation text in 
	 *			presentation device units.
	 *
	 *	pheightsRefRubyObj	(OUT): returned height values in reference device units
	 *			that ruby object will report back to line services.
	 *
	 *	pheightsPresRubyObj	(OUT): returned height values in presentation device units
	 *			that ruby object will report back to line services.
	 *
	 *	pdvpOffsetMainBaseline (OUT): offset of baseline of main line of Ruby
	 *			text from base line of Ruby object in presentation units. Note
	 *			a negative value puts the baseline of the main line below the 
	 *			base line of the Ruby object.
	 *
	 *	pdvrOffsetRubyBaseline (OUT): offset of baseline of pronunciation line
	 *			of Ruby text from base line of Ruby object in reference units. 
	 *			Note a negative value puts the baseline of the pronunciation line 
	 *			below the base line of the Ruby object.
	 *
	 *	pdvpOffsetRubyBaseline (OUT): offset of baseline of pronunciation line
	 *			of Ruby text from base line of Ruby object in presentation units. 
	 *			Note a negative value puts the baseline of the pronunciation line 
	 *			below the base line of the Ruby object.
	 *
	 *	prubycharjust (OUT): type of justification to use for Ruby Object.
	 *
	 *	pfSpecialLineStartEnd (OUT): specifies that the optional alignment that 
	 *			overrides the usual centering algorithm when the Ruby is the 
	 *			first or last character of the line.
	 *
	 */

	LSERR (WINAPI *pfnFetchRubyWidthAdjust)(
		POLS pols,
		LSCP cp,
		PLSRUN plsrunForChar,
		WCHAR wch,
		MWCLS mwclsForChar,
		PLSRUN plsrunForRuby,
		enum rubycharloc rcl,
		long durMaxOverhang,
		long *pdurAdjustChar,
		long *pdurAdjustRuby);

	/* FetchRubyWidthAdjust
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Ruby object.
	 *
	 *	plsrunForChar (IN): the run that is either previous or following the 
	 *			Ruby object.
	 *
	 *	wch (IN): character that is either before or after the Ruby object.
	 *
	 *	mwcls (IN): mod width class for the character.
	 *
	 *	plsrunForRuby (IN): plsrun for entire ruby object.
	 *
	 *	rcl	(IN): tells the location of the character.
	 *
	 *	durMaxOverhang (IN): designates the maximum amount of overhang that is 
	 *			possible following the JIS spec with respect to overhang. 
	 *			Adjusting the Ruby object by a negative value whose absolute 
	 *			value is greater than durMaxOverhang will cause part of the 
	 *			main text to be clipped. If the value of this parameter is 0, 
	 *			this indicates that there is no possible overhang.
	 *
	 *	pdurAdjustChar (OUT): designates the amount to adjust the width of the 
	 *			character prior to or following the Ruby object. Returing a negative 
	 *			value will decrease the size of the character preceeding or following 
	 *			the Ruby while returning a positive value will increase the size 
	 *			of that character.
	 *
	 *	pdurAdjustRuby (OUT): designates the amount adjust the width of the Ruby 
	 *			object. Returing a negative value will decrease the size of the 
	 *			Ruby object and potentially cause the Ruby pronunciation text to 
	 *			overhang the preceeding or following character while returning a 
	 *			positive value will increase the size of the Ruby object.
	 */

	LSERR (WINAPI* pfnRubyEnum)(
		POLS pols,
		PLSRUN plsrun,		
		PCLSCHP plschp,	
		LSCP cp,		
		LSDCP dcp,		
		LSTFLOW lstflow,	
		BOOL fReverse,		
		BOOL fGeometryNeeded,	
		const POINT* pt,		
		PCHEIGHTS pcheights,	
		long dupRun,		
		const POINT *ptMain,	
		PCHEIGHTS pcheightsMain,
		long dupMain,		
		const POINT *ptRuby,	
		PCHEIGHTS pcheightsRuby,
		long dupRuby,	
		PLSSUBL plssublMain,	
		PLSSUBL plssublRuby);	

	/* RubyEnum
	 * 
	 *	pols (IN): client context.
	 *
	 *  plsrun (IN): plsrun for the entire Ruby Object.
	 *
	 *	plschp (IN): is lschp for lead character of Ruby Object.
	 *
	 *	cp (IN): is cp of first character of Ruby Object.
	 *
	 *	dcp (IN): is number of characters in Ruby Object
	 *
	 *	lstflow (IN): is text flow at Ruby Object.
	 *
	 *	fReverse (IN): is whether text should be reversed for visual order.
	 *
	 *	fGeometryNeeded (IN): is whether Geometry should be returned.
	 *
	 *	pt (IN): is starting position , iff fGeometryNeeded .
	 *
	 *	pcheights (IN):	is height of Ruby object, iff fGeometryNeeded.
	 *
	 *	dupRun (IN): is length of Ruby Object, iff fGeometryNeeded.
	 *
	 *	ptMain (IN): is starting point for main line iff fGeometryNeeded
	 *
	 *	pcheightsMain (IN): is height of main line iff fGeometryNeeded
	 *
	 *	dupMain (IN): is length of main line iff fGeometryNeeded
	 *
	 *	ptRuby (IN): is point for Ruby pronunciation line iff fGeometryNeeded
	 *
	 *	pcheightsRuby (IN): is height for ruby line iff fGeometryNeeded
	 *
	 *	dupRuby (IN): is length of Ruby line iff fGeometryNeeded
	 *
	 *	plssublMain (IN): is main subline.
	 *
	 *	plssublRuby (IN): is Ruby subline.
	 *
	 */

} RUBYCBK;

/*
 *
 *	Ruby Object initialization data that the client application must return
 *	when the Ruby object handler calls the GetObjectHandlerInfo callback.
 *
 */
typedef struct RUBYINIT
{
	DWORD				dwVersion;		/* Version of the structure */
	RUBYSYNTAX			rubysyntax;		/* Used to determine order of lines during format */
	WCHAR				wchEscRuby;		/* Escape char for end of Ruby pronunciation line */
	WCHAR				wchEscMain;		/* Escape char for end of main text */
	WCHAR				wchUnused1;		/* For aligment */
	WCHAR				wchUnused2;		/* For aligment */
	RUBYCBK				rcbk;			/* Ruby callbacks */
} RUBYINIT;

LSERR WINAPI LsGetRubyLsimethods(
	LSIMETHODS *plsim);

/* GetRubyLsimethods
 *
 *	plsim (OUT): Ruby object methods for Line Services.
 *
 */

#endif /* RUBY_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\vruby.h ===
/* Vertical ruby interfaces */
/* Contact: antons */

#ifndef VRUBY_DEFINED
#define VRUBY_DEFINED

#include "lsimeth.h"

/* Only valid version number for Ruby initialization */

#define VRUBY_VERSION 0x300

/* Used for intialization to tell Ruby object which line comes first */

typedef enum vrubysyntax { VRubyPronunciationLineFirst, VRubyMainLineFirst } VRUBYSYNTAX;

/*
 *
 *	Vertical Ruby Object callbacks to client application
 *
 */

typedef struct VRUBYCBK
{
	LSERR (WINAPI *pfnFetchVRubyPosition)
	(
		/* in */

		POLS			pols,
		LSCP			cp,
		LSTFLOW			lstflow,
		PLSRUN			plsrun,
		PCHEIGHTS		pcheightsRefMain,
		PCHEIGHTS		pcheightsPresMain,
		long			dvrRuby,

		/* out */

		PHEIGHTS		pheightsPresRubyT,
		PHEIGHTS		pheightsRefRubyT,
		LONG*			 pdurAdjust
	);

	LSERR (WINAPI* pfnVRubyEnum)
	(
		POLS pols,
		PLSRUN plsrun,		
		PCLSCHP plschp,	
		LSCP cp,		
		LSDCP dcp,		
		LSTFLOW lstflow,	
		BOOL fReverse,		
		BOOL fGeometryNeeded,	
		const POINT* pt,		
		PCHEIGHTS pcheights,	
		long dupRun,		
		const POINT *ptMain,	
		PCHEIGHTS pcheightsMain,
		long dupMain,		
		const POINT *ptRuby,	
		PCHEIGHTS pcheightsRuby,
		long dupRuby,	
		PLSSUBL plssublMain,	
		PLSSUBL plssublRuby
	);

} VRUBYCBK;

/*
 *
 *	Ruby Object initialization data that the client application must return
 *	when the Ruby object handler calls the GetObjectHandlerInfo callback.
 *
 */
typedef struct VRUBYINIT
{
	DWORD				dwVersion;		/* Version of the structure (must be VRUBY_VERSION) */
	VRUBYSYNTAX			vrubysyntax;	/* Used to determine order of lines during format */
	WCHAR				wchEscRuby;		/* Escape char for end of Ruby pronunciation line */
	WCHAR				wchEscMain;		/* Escape char for end of main text */
	VRUBYCBK			vrcbk;			/* Ruby callbacks */

} VRUBYINIT;


LSERR WINAPI LsGetVRubyLsimethods ( LSIMETHODS *plsim );

/* GetRubyLsimethods
 *
 *	plsim (OUT): Ruby object methods for Line Services.
 *
 */


#endif /* VRUBY_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\warichu.h ===
#ifndef WARICHU_DEFINED
#define WARICHU_DEFINED

#include	"lsimeth.h"

/* Character location for pfnFetchWarichuWidthAdjust callback */
enum warichucharloc {
	warichuBegin,				/* Character preceeds Warichu object */
	warichuEnd					/* Character follows Warichu object */
};

/*
 *
 * Warichu Object Callbacks to Client
 *
 */
typedef struct WARICHUCBK
{
	LSERR (WINAPI* pfnGetWarichuInfo)(
		POLS pols,
		LSCP cp,
		LSTFLOW lstflow,
		PCOBJDIM pcobjdimFirst,
		PCOBJDIM pcobjdimSecond,
		PHEIGHTS pheightsRef,
		PHEIGHTS pheightsPres,
		long *pdvpDescentReservedForClient);

	/* GetWarichuInfo
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Warichu object.
	 *
     *  lstflow (IN): the lstflow of Warichu parent subline
	 *
	 *	pcobjdimFirst (IN): dimensions of first line of Warichu.
	 *
	 *	pcobjdimSecond (IN): dimensions of second line of Warichu.
	 *
	 *	pheightsRef (OUT): specifies heights for Warichu object in reference
	 *			device units.
	 *
	 *	pheightsPres (OUT): specifies heights for Warichu object in presentation
	 *			device units.
	 *
	 *	pdvpDescentReservedForClient (OUT): specifies the part of the descent area 
	 *			that the client is reserving for its own use (usually for the purpose 
	 *			of underlining) in presentation device units. The object will begin its 
	 *			display area below the baseline at the difference between 
	 *			pheightsRef->dvDescent and *pdvpDescentReservedForClient. 
	 *
	 */

	LSERR (WINAPI* pfnFetchWarichuWidthAdjust)(
		POLS pols,
		LSCP cp,
		enum warichucharloc wcl,
		PLSRUN plsrunForChar,
		WCHAR wch,
		MWCLS mwclsForChar,
		PLSRUN plsrunWarichuBracket,
		long *pdurAdjustChar,
		long *pdurAdjustBracket);

	/* FetchWarichuWidthAdjust
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Warichu object.
	 *
	 *  wcl (IN): specifies the location of the character and bracket.
	 *
	 *  plsrunForChar (IN): the run of the character that is either previous or 
	 *		following the Warichu object. Whether preceeding or following is 
	 *		determined by value of the wcl parameter above.
	 *
	 *	wch (IN): character that is either preceeding or following the Warichu 
	 *		object.
	 *
	 *	mwclsForChar (IN): mod width class for the wch parameter.
	 *
	 *	plsrunWarichuBracket (IN): plsrun for leading or following bracket of 
	 *		the Warichu.
	 *
	 *	pdurAdjustChar (OUT): the amount that the width of the input character 
	 *		should be adjusted. A negative value means the width of the input 
	 *		character should be made smaller.
	 *
	 *	pdurAdjustBracket (OUT): the amount that the width of the Warichu bracket
	 *		should be adjusted.  A negative value means the width of the Warichu 
	 *		bracket should be made smaller.
	 */

	LSERR (WINAPI* pfnWarichuEnum)(
		POLS pols,
		PLSRUN plsrun,		
		PCLSCHP plschp,	
		LSCP cp,		
		LSDCP dcp,		
		LSTFLOW lstflow,	
		BOOL fReverse,		
		BOOL fGeometryNeeded,	
		const POINT* pt,		
		PCHEIGHTS pcheights,	
		long dupRun,		
		const POINT *ptLeadBracket,	
		PCHEIGHTS pcheightsLeadBracket,
		long dupLeadBracket,		
		const POINT *ptTrailBracket,	
		PCHEIGHTS pcheightsTrailBracket,
		long dupTrailBracket,
		const POINT *ptFirst,	
		PCHEIGHTS pcheightsFirst,
		long dupFirst,		
		const POINT *ptSecond,	
		PCHEIGHTS pcheightsSecond,
		long dupSecond,
		PLSSUBL plssublLeadBracket,
		PLSSUBL plssublTrailBracket,
		PLSSUBL plssublFirst,	
		PLSSUBL plssublSecond);	

	/* WarichuEnum
	 * 
	 *	pols (IN): client context.
	 *
	 *  plsrun (IN): plsrun for the entire Warichu Object.
	 *
	 *	plschp (IN): is lschp for lead character of Warichu Object.
	 *
	 *	cp (IN): is cp of first character of Warichu Object.
	 *
	 *	dcp (IN): is number of characters in Warichu Object
	 *
	 *	lstflow (IN): is text flow at Warichu Object.
	 *
	 *	fReverse (IN): is whether text should be reversed for visual order.
	 *
	 *	fGeometryNeeded (IN): is whether Geometry should be returned.
	 *
	 *	pt (IN): is starting position , iff fGeometryNeeded .
	 *
	 *	pcheights (IN):	is height of Warichu object, iff fGeometryNeeded.
	 *
	 *	dupRun (IN): is length of Warichu Object, iff fGeometryNeeded.
	 *
	 *	ptLeadBracket (IN):	is point for second line iff fGeometryNeeded and 
	 *		plssublLeadBracket not NULL.
	 *
	 *	pcheightsLeadBracket (IN): is height for Warichu line iff fGeometryNeeded 
	 *		and plssublLeadBracket not NULL.
	 *
	 *	dupLeadBracket (IN): is length of Warichu line iff fGeometryNeeded and 
	 *		plssublLeadBracket not NULL.
	 *
	 *	ptTrailBracket (IN): is point for second line iff fGeometryNeeded and 
	 *		plssublLeadBracket not NULL.
	 *
	 *	pcheightsTrailBracket (IN):	is  height for Warichu  line iff fGeometryNeeded 
	 *		and plssublTrailBracket not NULL.
	 *
	 *	dupTrailBracket (IN): is length of Warichu line iff fGeometryNeeded and 
	 *		plssublTrailBracket not NULL.
	 *
	 *	ptFirst (IN): is starting point for main line iff fGeometryNeeded
	 *
	 *	pcheightsFirst (IN): is height of main line iff fGeometryNeeded
	 *
	 *	dupFirst (IN): is length of main line iff fGeometryNeeded
	 *
	 *	ptSecond (IN): is point for second line iff fGeometryNeeded and 
	 *		plssublSecond not NULL.
	 *
	 *	pcheightsSecond (IN): is height for Warichu line iff fGeometryNeeded 
	 *		and plssublSecond not NULL.
	 *
	 *	dupSecond (IN):	is length of Warichu line iff fGeometryNeeded and 
	 *		plssublSecond not NULL.
	 *
	 *	plssublLeadBracket (IN): is subline for lead bracket.
	 *
	 *	plssublTrailBracket (IN): is subline for trail bracket.
	 *
	 *	plssublFirst (IN): is first subline in Warichu object.
	 *
	 *	plssublSecond (IN):	is second subline in Warichu object.
	 *
	 */

} WARICHUCBK;

#define WARICHU_VERSION 0x300

/*
 * 
 *	Warichi object initialization data that the client application must return
 *	when the Warichu object handler calls the GetObjectHandlerInfo callback.
 */
typedef struct WARICHUINIT
{
	DWORD				dwVersion;			/* Version must be WARICHU_VERSION */
	WCHAR				wchEndFirstBracket;	/* Escape char to end first bracket */
	WCHAR				wchEndText;			/* Escape char to end text */
	WCHAR				wchEndWarichu;		/* Escape char to end object */
	WCHAR				wchUnused;			/* For alignment */
	WARICHUCBK			warichcbk;			/* Callbacks */
	BOOL				fContiguousFetch;	/* Always refetch whole subline & closing brace
											   after reformatting inside warichu */
} WARICHUINIT;

LSERR WINAPI LsGetWarichuLsimethods(
	LSIMETHODS *plsim);

/* GetWarichuLsimethods
 *
 *	plsim (OUT): Warichu object callbacks.
 */

#endif /* WARICHU_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\tatenak.h ===
#ifndef TATENAKYOKO_DEFINED
#define TATENAKYOKO_DEFINED

#include "lsimeth.h"

/*
 *
 *	Tatenakayoko object callbacks to client application
 *
 */
typedef struct TATENAKYOKOCBK
{
	LSERR (WINAPI *pfnGetTatenakayokoLinePosition)(
		POLS pols,
		LSCP cp,
		LSTFLOW lstflow,
		PLSRUN plsrun,
		long dvr,
		PHEIGHTS pheightsRef,
		PHEIGHTS pheightsPres,
		long *pdvpDescentReservedForClient);

	/* GetTatenakayokoLinePosition
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Tatenakayoko object.
	 *
	 *  lstflow (IN): the lstflow of Tatenakayoko parent subline
	 *
	 *	plsrun (IN): the plsrun of the Tatenakayoko object.
	 *
	 *	dvr	(IN): the total height of the tatenakayoko object with respect to 
	 *			the current flow of the line in reference units.
	 *
	 *	pheightsRef	(OUT): specifies heights of Tatenakayoko object in reference
	 *			device units. 
	 *
	 *	pdvrDescentReservedForClient (OUT): specifies the part of the descent area 
	 *			that the client is reserving for its own use (usually for the purpose 
	 *			of underlining) in reference device units. The object will begin its 
	 *			display area below the baseline at the difference between *pdvrDescent 
	 *			and *pdvrDescentReservedForClient. 
	 *
	 *	pheightsPres (OUT): specifies heights of Tatenakayoko object in presenatation
	 *			device units. 
	 *
	 *	pdvpDescentReservedForClient (OUT): specifies the part of the descent area 
	 *			that the client is reserving for its own use (usually for the purpose 
	 *			of underlining) in presentation device units. The object will begin its 
	 *			display area below the baseline at the difference between *pdvpDescent 
	 *			and pheightsPres.dvDescent. 
	 *
	 */

	LSERR (WINAPI* pfnTatenakayokoEnum)(
		POLS pols,
		PLSRUN plsrun,		
		PCLSCHP plschp,	
		LSCP cp,		
		LSDCP dcp,		
		LSTFLOW lstflow,	
		BOOL fReverse,		
		BOOL fGeometryNeeded,	
		const POINT* pt,		
		PCHEIGHTS pcheights,	
		long dupRun,
		LSTFLOW lstflowT,
		PLSSUBL plssubl);

	/* TatenakayokoEnum
	 * 
	 *	pols (IN): client context.
	 *
	 *  plsrun (IN): plsrun for the entire Tatenakayoko Object.
	 *
	 *	plschp (IN): is lschp for lead character of Tatenakayoko Object.
	 *
	 *	cp (IN): is cp of first character of Tatenakayoko Object.
	 *
	 *	dcp (IN): is number of characters in Tatenakayoko Object
	 *
	 *	lstflow (IN): is text flow at Tatenakayoko Object.
	 *
	 *	fReverse (IN): is whether text should be reversed for visual order.
	 *
	 *	fGeometryNeeded (IN): is whether Geometry should be returned.
	 *
	 *	pt (IN): is starting position , iff fGeometryNeeded .
	 *
	 *	pcheights (IN):	is height of Tatenakayoko object, iff fGeometryNeeded.
	 *
	 *	dupRun (IN): is length of Tatenakayoko Object, iff fGeometryNeeded.
	 *
	 *	lstflowT (IN): is text flow for Tatenakayoko object.
	 *
	 *	plssubl (IN): is subline for Tatenakayoko object.
	 */

} TATENAKAYOKOCBK;

/*
 *
 *	Tatenakayoko object initialization data that the client application must return
 *	when the Tatenakayoko object handler calls the GetObjectHandlerInfo callback.
 */

#define TATENAKAYOKO_VERSION 0x300

typedef struct TATENAKAYOKOINIT
{
	DWORD				dwVersion;			/* Version. Only TATENAKAYOKO_VERSION is valid. */
	WCHAR				wchEndTatenakayoko;	/* Character marking end of Tatenakayoko object */
	WCHAR				wchUnused1;			/* For alignment */
	WCHAR				wchUnused2;			/* For alignment */
	WCHAR				wchUnused3;			/* For alignment */
	TATENAKAYOKOCBK		tatenakayokocbk;	/* Client application callbacks */
} TATENAKAYOKOINIT, *PTATENAKAYOKOINIT;

LSERR WINAPI LsGetTatenakayokoLsimethods(
	LSIMETHODS *plsim);

/* GetTatenakayokoLsimethods
 *	
 *	plsim (OUT): Tatenakayoko object methods for Line Services
 *
 */

#endif /* TATENAKYOKO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lsinc\zqfromza.h ===
#ifndef ZQFROMZQ_DEFINED
#define ZQFROMZQ_DEFINED

#include "lsdefs.h"

#define zqLim	1491309L				/* higher resolution will overflow */

long ZqFromZa_C (long, long);

#ifdef _X86_

long ZqFromZa_Asm (long, long);
__int64 Div64_Asm (__int64, __int64);
__int64 Mul64_Asm (__int64, __int64);

#define ZqFromZa(dzqInch,za) ZqFromZa_Asm ((dzqInch),(za))

#define Div64(DVND,DVSR) Div64_Asm ((DVND),(DVSR))
#define Mul64(A,B) Mul64_Asm ((A),(B))

#else

#define ZqFromZa(dzqInch,za) ZqFromZa_C ((dzqInch),(za))

#define Div64(DVND,DVSR) ((__int64) (DVND) / (__int64) (DVSR))
#define Mul64(A,B) ((__int64) (A) * (__int64) (B))

#endif

long ZaFromZq(long, long);
long LsLwMultDivR(long, long, long);

#define I_UpFromUa(pdevres,ua)	(ZqFromZa((pdevres)->dxpInch, (ua)))
#define I_UrFromUa(pdevres,ua)	(ZqFromZa((pdevres)->dxrInch, (ua)))
#define I_VpFromVa(pdevres,va)	(ZqFromZa((pdevres)->dypInch, (va)))
#define I_VrFromVa(pdevres,va)	(ZqFromZa((pdevres)->dyrInch, (va)))
#define I_UaFromUp(pdevres,up)	(ZaFromZq((pdevres)->dxpInch, (up)))
#define I_VaFromVp(pdevres,vp)	(ZaFromZq((pdevres)->dypInch, (vp)))
#define I_UaFromUr(pdevres,ur)	(ZaFromZq((pdevres)->dxrInch, (ur)))
#define I_VaFromVr(pdevres,vr)	(ZaFromZq((pdevres)->dyrInch, (vr)))



#define UpFromUa(tfl,pdevres,ua) (((tfl) & fUVertical) ? \
		I_VpFromVa(pdevres,ua) :\
		I_UpFromUa(pdevres,ua) \
)

#define UrFromUa(tfl,pdevres,ua) (((tfl) & fUVertical) ? \
		I_VrFromVa(pdevres,ua) :\
		I_UrFromUa(pdevres,ua) \
)

#define VpFromVa(tfl,pdevres,va) ((tfl) & fUVertical) ? \
		I_UpFromUa(pdevres,va) :\
		I_VpFromVa(pdevres,va) \
)

#define VrFromVa(tfl,pdevres,va) (((tfl) & fUVertical) ? \
		I_UrFromUa(pdevres,va) :\
		I_VrFromVa(pdevres,va) \
)

#define UaFromUp(tfl,pdevres,up) (((tfl) & fUVertical) ? \
		I_VaFromVp(pdevres,up) :\
		I_UaFromUp(pdevres,up) \
)

#define VaFromVp(tfl,pdevres,vp)	(((tfl) & fUVertical) ? \
		I_UaFromUp(pdevres,vp) :\
		I_VaFromVp(pdevres,vp) \
)

#define UaFromUr(tfl,pdevres,ur)	(((tfl) & fUVertical) ?	\
		I_VaFromVr(pdevres,ur) :\
		I_UaFromUr(pdevres,ur) \
)

#define VaFromVr(tfl,pdevres,vr)	(((tfl) & fUVertical) ?	\
		I_UaFromUr(pdevres,vr) :\
		I_VaFromVr(pdevres,vr) \
)

/*
#define UpFromUr(pdevres,ur)	UpFromUa(pdevres, UaFromUr(pdevres, ur))
#define VpFromVr(pdevres,vr)	VpFromVa(pdevres, VaFromVr(pdevres, vr))
*/
#define UpFromUr(tfl,pdevres,ur)	(((tfl) & fUVertical) ? \
								LsLwMultDivR(ur, (pdevres)->dypInch, (pdevres)->dyrInch): \
								LsLwMultDivR(ur, (pdevres)->dxpInch, (pdevres)->dxrInch) \
									)
#define VpFromVr(tfl,pdevres,vr)	(((tfl) & fUVertical) ? \
								LsLwMultDivR(vr, (pdevres)->dxpInch, (pdevres)->dxrInch): \
								LsLwMultDivR(vr, (pdevres)->dypInch, (pdevres)->dyrInch) \
									)
#define UrFromUp(tfl,pdevres,up)	(((tfl) & fUVertical) ? \
								LsLwMultDivR(up, (pdevres)->dyrInch, (pdevres)->dypInch): \
								LsLwMultDivR(up, (pdevres)->dxrInch, (pdevres)->dxpInch) \
									)
#define VrFromVp(tfl,pdevres,vp)	(((tfl) & fUVertical) ? \
								LsLwMultDivR(vp, (pdevres)->dxrInch, (pdevres)->dxpInch): \
								LsLwMultDivR(vp, (pdevres)->dyrInch, (pdevres)->dypInch) \
									)

#endif /* ZQFROMZQ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\chnutils.c ===
#include "lsmem.h"						/* memset() */

#include "lsidefs.h"
#include "chnutils.h"
#include "iobj.h"
#include "dninfo.h"
#include "locchnk.h"
#include "posichnk.h"
#include "plschcon.h"
#include "lschcon.h"
#include "lscbk.h"
#include "limqmem.h"
#include "lstext.h"

#ifdef DEBUG
#define DebugMemset(a,b,c)		if ((a) != NULL) memset(a,b,c); else
#else
#define DebugMemset(a,b,c)		(void)(0)
#endif


static LSERR SetChunkArraysSize(PLSCHUNKCONTEXT, DWORD);
static LSERR IncreaseChunkArrays(PLSCHUNKCONTEXT);
static LSERR IncreaseGroupChunkNonTextArrays(PLSCHUNKCONTEXT plschunkcontext);
static LSERR ConvertChunkToGroupChunk(GRCHUNKEXT*, LSCP);
static void LocateChunk(PLSCHUNKCONTEXT plschnukcontext,/* IN: LS chunk context */
					     PLSDNODE plsdn,	 		    /* IN:  dnode to collect chunk arround  */
						 LSTFLOW  lstflow,				/* IN: text flow */
						 POINTUV* ppoint);  			/* IN: position of dnode */
static LSERR FExpandBeforeNonTextObject(GRCHUNKEXT* pgrchunkext, DWORD cTextBeforePrevioustNonText,
									   BOOL* pfExpand);
static LSERR FExpandAfterNonTextObject(GRCHUNKEXT* pgrchunkext, DWORD cTextBeforeLastNonText,
									   BOOL* pfExpand);

typedef struct groupchunkiterator
	{
	COLLECTSUBLINES Purpose; /* what sublines to take from a complex object */
	PLSDNODE plsdnFirst; /* dnode from which we started collecting */
	PLSDNODE plsdnStart; /* dnode where to start search for next, if NULL then 
							use plsdnFirst as first opportunity */
	LSCP cpLim;			/* boundary for group chunk if we go forward */
	BOOL fForward;		/* direction of traversing is forward otherwise it's backward*/
	}
GROUPCHUNKITERATOR;


static void CreateGroupChunkIterator(
					GROUPCHUNKITERATOR* pgroupchunkiterator, /* handler for iterator */
					COLLECTSUBLINES Purpose, /* what sublines to take from a complex object */
					PLSDNODE plsdnFirst, /* dnode from which we started collecting */
					LSCP cpLim,			/* boundary for group chunk if we go forward */
					BOOL fForward);		/* direction of traversing is forward otherwise it's backward*/


					
static void DestroyGroupChunkIterator(
					GROUPCHUNKITERATOR* pgroupchunkiterator); /* handler for iterator */



static PLSDNODE ContinueGroupChunk(
					GROUPCHUNKITERATOR* pgroupchunkiterator, /* handler for iterator */
					BOOL* pfSuccessful);				/* OUT: do we find dnode */

static PLSDNODE GetNextDnodeInGroupChunk(
					GROUPCHUNKITERATOR* pgroupchunkiterator, /* handler for iterator */
					BOOL* pfSuccessful);				/* OUT: do we find dnode */





#define  LschnkeFromDnode(plschnke, plsdn) \
		 (plschnke)->cpFirst = plsdn->cpFirst; \
		 (plschnke)->dcp = (plsdn)->dcp; \
		 (plschnke)->plschp = &((plsdn)->u.real.lschp); \
		 (plschnke)->plsrun = (plsdn)->u.real.plsrun; \
		 (plschnke)->pdobj = (plsdn)->u.real.pdobj; 


#define FIsGroupChunkBoundary(plsdn, cpLim, cpBase)  \
		(FIsOutOfBoundary((plsdn), (cpLim))  \
		||(FIsDnodePen(plsdn) && (!(plsdn)->fAdvancedPen)) \
		|| ((plsdn)->fTab) \
		||  (((cpBase) >= 0) ? ((plsdn)->cpFirst < 0) : ((plsdn)->cpFirst >= 0)))
/* last check verifies that we are not crossing boundaries of autonumber */

#define FIsGroupChunkStartBoundary(plsdn, cpBase)  \
		(((plsdn) == NULL)  \
		||(FIsDnodePen(plsdn) && (!(plsdn)->fAdvancedPen)) \
		|| ((plsdn)->fTab) \
		||  (((cpBase) >= 0) ? ((plsdn)->cpFirst < 0) : ((plsdn)->cpFirst >= 0)))
/* last check verifies that we are not crossing boundaries of autonumber */

#define FIsGrchnkExtValid(plschunkcontext, pgrchunkext)  \
		(((plschunkcontext) == (pgrchunkext)->plschunkcontext)  &&\
		 ((pgrchunkext)->lsgrchnk.plschnk == (plschunkcontext)->locchnkCurrent.plschnk) &&\
		 ((pgrchunkext)->lsgrchnk.pcont == (plschunkcontext)->pcont) &&\
		 ((pgrchunkext)->pplsdnNonText == (plschunkcontext)->pplsdnNonText) &&\
		 ((pgrchunkext)->pfNonTextExpandAfter == (plschunkcontext)->pfNonTextExpandAfter) \
        )
 
#define FDnodeInsideSubline(plssubl, plsdn) \
	    (FDnodeBeforeCpLim(plsdn, (plssubl)->cpLim) \
		&& FDnodeAfterCpFirst(plsdn, (plssubl)->cpFirst)) 

#define FUseForPurpose(plsdn, purpose)  \
		(*(&((plsdn)->u.real.pinfosubl->fUseForJustification) + (purpose -1)))

#define FIsUsageFlagsCastWorks(plsdn)  \
		((plsdn)->u.real.pinfosubl->fUseForCompression == \
					FUseForPurpose(plsdn, CollectSublinesForCompression) && \
		 (plsdn)->u.real.pinfosubl->fUseForJustification == \
					FUseForPurpose(plsdn, CollectSublinesForJustification)  && \
		 (plsdn)->u.real.pinfosubl->fUseForDisplay == \
					FUseForPurpose(plsdn, CollectSublinesForDisplay)  && \
		 (plsdn)->u.real.pinfosubl->fUseForDecimalTab == \
					FUseForPurpose(plsdn, CollectSublinesForDecimalTab) && \
		 (plsdn)->u.real.pinfosubl->fUseForTrailingArea == \
					FUseForPurpose(plsdn, CollectSublinesForTrailingArea))

#define GetSubmittedSublines(plsdn, purpose) \
	   ((((purpose) == CollectSublinesNone) || \
		 (Assert(FIsDnodeReal(plsdn)), (plsdn)->u.real.pinfosubl == NULL) || \
		 ((plsdn)->u.real.pinfosubl->rgpsubl == NULL)) ?  \
			NULL :  (Assert(FIsUsageFlagsCastWorks(plsdn)), \
					 (FUseForPurpose(plsdn, purpose)) ? \
					(plsdn)->u.real.pinfosubl->rgpsubl : NULL))

#define GetNumberSubmittedSublines(plsdn) \
			(Assert((plsdn)->u.real.pinfosubl != NULL), (plsdn)->u.real.pinfosubl->cSubline)

#define FColinearTflows(t1, t2)  \
			(((t1) & fUVertical) == ((t2) & fUVertical))

#define FSameSemiPlaneTflows(t1, t2)  \
			(((t1) & fUDirection) == ((t2) & fUDirection))

#define FParallelTflows(t1,t2) \
		Assert(FColinearTflows(t1, t2)), \
		FSameSemiPlaneTflows(t1, t2)   // we assume here that they are colinear 



/* C O L L E C T  C H U N K  A R O U N D*/
/*----------------------------------------------------------------------------
    %%Function: CollectChunkAround
    %%Contact: igorzv

Parameters:
	plsc			-		(IN) chunk context
	plsdn			-	    (IN) dnode to collect chunk arround
	lstflow			-		(IN) lstflow
	ppoint					(IN) starting position of dnode

Fill in cnunk elements array for chunk arround pposinline->plsdn
Calculate location of the chunk
----------------------------------------------------------------------------*/

LSERR CollectChunkAround(PLSCHUNKCONTEXT plschunkcontext, PLSDNODE plsdnInChunk, 
						 LSTFLOW lstflow, POINTUV* ppoint)  
						  
{
	WORD idObjChnk;
	PLSDNODE plsdnNext;
	PLSDNODE plsdnCurrent;
	PLOCCHNK plocchnk;
	LSCHNKE* plschnke;
	DWORD clschnk;
	LSERR lserr;
	LSCP cpInChunk;

	Assert(FIsLSDNODE(plsdnInChunk));

	plocchnk = &(plschunkcontext->locchnkCurrent);
	clschnk = plocchnk->clschnk;
	plschnke = plocchnk->plschnk;
	plsdnCurrent = plsdnInChunk;
	cpInChunk = plsdnInChunk->cpFirst;
	
	
	/* check: has this chunk already collected? */
	/* chunk was already collected if there is some chunk and our dnode is within this chunk
	   and nothing was added to list after chunk was collected  			*/
	/* we turn off optimisation for dnodes with dcp=0 (ex. pens) because of a problem how
	   to figure out that dnode is within chunk */
	if ((!plschunkcontext->FChunkValid) || (plschunkcontext->FGroupChunk)  
		||(plschnke[0].cpFirst > plsdnCurrent->cpFirst)
		|| (plschnke[clschnk - 1].cpFirst < plsdnCurrent->cpFirst)
		|| (plsdnCurrent->dcp == 0) 
		|| (plschnke[0].dcp == 0)
		|| ((plschunkcontext->pplsdnChunk[clschnk - 1])->plsdnNext != NULL))
		{
		/* we need to recollect chunk  */

		/* we don't allow caller to pass border as a plsdnInChunk */
		Assert(!FIsDnodeBorder(plsdnInChunk));

		if ( FIsDnodePen(plsdnInChunk) || plsdnInChunk->fTab || FIsDnodeSplat(plsdnInChunk))
			{
			/* for pens and tabs chunk consists of one element and we collect it right away */
			plocchnk->clschnk = 1;
			Assert(plocchnk->clschnk <= plschunkcontext->cchnkMax);
			LschnkeFromDnode((&(plschnke[0])), plsdnInChunk);
			plschunkcontext->pplsdnChunk[0] = plsdnInChunk;
			plschunkcontext->FChunkValid = fTrue;
			plschunkcontext->FLocationValid = fFalse;
			plschunkcontext->FGroupChunk = fFalse;
			/* we should here calculate width of border before dnode, the same way it done
			   in FillChunkArray */
			plschunkcontext->pdurOpenBorderBefore[0] = 0;
			plschunkcontext->pdurCloseBorderAfter[0] = 0;
			plschunkcontext->FBorderInside = fFalse;
			plsdnCurrent = plsdnInChunk->plsdnPrev;
			if (plsdnCurrent != NULL && FIsDnodeOpenBorder(plsdnCurrent))
				{
				plschunkcontext->FBorderInside = fTrue;
				plschunkcontext->pdurOpenBorderBefore[0] += DurFromDnode(plsdnCurrent);
				}
			plsdnCurrent = plsdnInChunk->plsdnNext;
			if (plsdnCurrent != NULL && FIsDnodeCloseBorder(plsdnCurrent))
				{
				plschunkcontext->FBorderInside = fTrue;
				plschunkcontext->pdurCloseBorderAfter[0] += DurFromDnode(plsdnCurrent);
				}
			}
		else
			{
	
			idObjChnk = IdObjFromDnode(plsdnInChunk);
			
			/* go to the end of chunk   */
			plsdnNext = plsdnCurrent->plsdnNext;
			while(!FIsChunkBoundary(plsdnNext, idObjChnk, cpInChunk))
				{
				plsdnCurrent = plsdnNext;
				plsdnNext = plsdnCurrent->plsdnNext;
				}
			
			lserr = FillChunkArray(plschunkcontext, plsdnCurrent);
			if (lserr != lserrNone)
				return lserr;
			}
		}
			
	/* check: is chunck located  */
	if (!plschunkcontext->FLocationValid)
		{
		LocateChunk(plschunkcontext, plsdnInChunk, lstflow, ppoint);
		}
	
	return lserrNone;

}

/* L O C A T E   C H U N K  */
/*----------------------------------------------------------------------------
    %%Function: CollectPreviousChunk
    %%Contact: igorzv

Parameters:
	plsc			-		(IN) chunk context
	plsdn			-	    (IN) dnode to collect chunk arround
	lstflow			-		(IN) lstflow
	ppoint					(IN) starting position of dnode

Calculates location of the chunk. We assume here that pointUv.u in locchunk
contains before this procedure width of border before dnode.
After procedure we put location there 
/*----------------------------------------------------------------------------*/


static void LocateChunk(PLSCHUNKCONTEXT plschunkcontext, PLSDNODE plsdnInChunk, 
						 LSTFLOW lstflow, POINTUV* ppoint)	
	{
	PLSDNODE plsdnFirst;
	PLOCCHNK plocchnk;
	PLSDNODE* pplsdnChunk;
	PLSDNODE plsdnCurrent;
	long urPen,vrPen;
	LONG i;
	PPOINTUV ppointUv;
	LONG* pdurOpenBorderBefore;
	LONG* pdurCloseBorderAfter;

	Assert(!FIsDnodeBorder(plsdnInChunk));  /* we don't allow border as in input */

	plocchnk = &(plschunkcontext->locchnkCurrent);
	plsdnFirst = plschunkcontext->pplsdnChunk[0];
	plocchnk->lsfgi.fFirstOnLine = FIsFirstOnLine(plsdnFirst)   
										&& FIsSubLineMain(SublineFromDnode(plsdnFirst));   
	plocchnk->lsfgi.cpFirst = plsdnFirst->cpFirst;		
	plocchnk->lsfgi.lstflow = lstflow;  		
	/* we can't set urColumnMax here, because during breaking object handler can change it */
	/* and we suppose that caller use  for this purpose SetUrColumnMaxForChunks */
	
	pplsdnChunk = plschunkcontext->pplsdnChunk;
	ppointUv = plocchnk->ppointUvLoc;
	pdurOpenBorderBefore = plschunkcontext->pdurOpenBorderBefore;
	pdurCloseBorderAfter = plschunkcontext->pdurCloseBorderAfter;

	/* calculation of pen position  before chunk */
	if (plsdnFirst->plsdnPrev == NULL)      /* optimization */
		{
		urPen = plschunkcontext->urFirstChunk;		
		vrPen = plschunkcontext->vrFirstChunk;	
		}
	else
		{
		plsdnCurrent = plsdnInChunk; 
		urPen = ppoint->u;
		vrPen = ppoint->v;
		
		for (i = 0; pplsdnChunk[i] != plsdnCurrent; i++)
			{
			Assert(i < (LONG) plocchnk->clschnk);      
			urPen -= DurFromDnode(pplsdnChunk[i]);
			vrPen -= DvrFromDnode(pplsdnChunk[i]);
			/* substract also border before dnode */
			urPen -= pdurOpenBorderBefore[i];
			urPen -= pdurCloseBorderAfter[i];
			}
		/* and now open border before plsdnCurrent */
		urPen -= pdurOpenBorderBefore[i];

		}

	plocchnk->lsfgi.urPen = urPen;
	plocchnk->lsfgi.vrPen = vrPen;

	/* location of all dnodes */
	for (i = 0; i < (LONG) plocchnk->clschnk; i++)
		{
		urPen += pdurOpenBorderBefore[i]; /* count border */
		if (i != 0) urPen += pdurCloseBorderAfter[i - 1];
		ppointUv[i].u = urPen;
		ppointUv[i].v = vrPen;
		urPen += DurFromDnode(pplsdnChunk[i]);
		vrPen += DvrFromDnode(pplsdnChunk[i]);
		}

	plschunkcontext->FLocationValid = fTrue;
	}

/* C O L L E C T  P R E V I O U S  C H U N K  */
/*----------------------------------------------------------------------------
    %%Function: CollectPreviousChunk
    %%Contact: igorzv

Parameters:
	plschuncontext				-	(IN) chunk context
	pfSuccessful		-			(OUT) does previous chunk exist 

Check that we are in the begining of line,
othewise call CollectChunkAround with the previous dnode
----------------------------------------------------------------------------*/


LSERR CollectPreviousChunk(PLSCHUNKCONTEXT plschunkcontext,	 
					   BOOL* pfSuccessful )		
{
	PLOCCHNK plocchnk;
	POINTUV point;
	PLSDNODE plsdn;


	plocchnk = &(plschunkcontext->locchnkCurrent);

	if (FIsFirstOnLine(plschunkcontext->pplsdnChunk[0]))  
		{
		*pfSuccessful = fFalse;
		return lserrNone;
		}
	else
		{
		plsdn = plschunkcontext->pplsdnChunk[0]->plsdnPrev;
		point = plocchnk->ppointUvLoc[0];
		while (FIsDnodeBorder(plsdn))
			{
			point.u -= DurFromDnode(plsdn);
			point.v -= DvrFromDnode(plsdn);
			plsdn = plsdn->plsdnPrev;
			}

		point.u -= DurFromDnode(plsdn);
		point.v -= DvrFromDnode(plsdn);

		*pfSuccessful = fTrue;
		return CollectChunkAround(plschunkcontext, plsdn, 
								  plocchnk->lsfgi.lstflow, &point);
		}
}

/* C O L L E C T  N E X T  C H U N K  */
/*----------------------------------------------------------------------------
    %%Function: CollectNextChunk
    %%Contact: igorzv

Parameters:
	plschuncontext				-	(IN) chunk context
	pfSuccessful		-	(OUT) does next chunk exist 

Check that we are in the end of list, in this case return *pfSuccessful and don't change chunk
othewise call CollectChunkAround with the next dnode
----------------------------------------------------------------------------*/


LSERR CollectNextChunk(PLSCHUNKCONTEXT plschunkcontext,	 
					   BOOL* pfSuccessful )		
	{
	PLOCCHNK plocchnk;
	DWORD clschnk;
	PLSDNODE* pplsdnChunk;
	POINTUV point; 
	PLSDNODE plsdn;
	
	
	plocchnk = &(plschunkcontext->locchnkCurrent);
	clschnk = plocchnk->clschnk;
	Assert(clschnk > 0);
	pplsdnChunk = plschunkcontext->pplsdnChunk;
	
	point = plocchnk->ppointUvLoc[clschnk - 1];
	point.u += DurFromDnode(pplsdnChunk[clschnk - 1]);
	point.v += DvrFromDnode(pplsdnChunk[clschnk - 1]);
	
	plsdn = pplsdnChunk[clschnk - 1]->plsdnNext;
	/* skip borders */
	while (plsdn != NULL && FIsDnodeBorder(plsdn))
		{
		point.u += DurFromDnode(plsdn);
		point.v += DvrFromDnode(plsdn);
		plsdn = plsdn->plsdnNext;
		}

	if (plsdn == NULL)
		{
		*pfSuccessful = fFalse;
		return lserrNone;
		}
	else
		{
		*pfSuccessful = fTrue;
		return CollectChunkAround(plschunkcontext, plsdn, 
			plocchnk->lsfgi.lstflow, &point);
		}
	}

/* F I L L  C H U N K  A R R A Y*/
/*----------------------------------------------------------------------------
    %%Function: FillChunkArray
    %%Contact: igorzv

Parameters:
	plschuncontext		-	(IN) chunk context
	plsdnLast			-	(IN) last dnode in chunk

Fill in chunk elements array for chunk before plsdnLast
----------------------------------------------------------------------------*/
LSERR 	FillChunkArray(PLSCHUNKCONTEXT  plschunkcontext,
						 PLSDNODE  plsdnLast) 
{
	PLSDNODE plsdnCurrent, plsdnPrev;
	WORD idObjChnk;
	PLOCCHNK plocchnk;
	LSCHNKE* plschnke;
	LONG clschnke;
	LSERR lserr;
	LONG i;
	LSCP cpInChunk;
	PPOINTUV ppointUv;
	LONG* pdurOpenBorderBefore;
	LONG* pdurCloseBorderAfter;

	Assert(FIsLSDNODE(plsdnLast));

	Assert(!plsdnLast->fTab);  /* for optimization we assume that caller will resolve */
	Assert(! FIsDnodePen(plsdnLast)); /* pen and tabs */
	Assert(!FIsDnodeSplat(plsdnLast));

	plocchnk = &(plschunkcontext->locchnkCurrent);

	/* skip borders in the end of chunk to figure out what idObj this chunk has */
	while (FIsDnodeBorder(plsdnLast))
		{
		plsdnLast = plsdnLast->plsdnPrev;
		Assert(FIsLSDNODE(plsdnLast));
		}

	idObjChnk = IdObjFromDnode(plsdnLast);
	cpInChunk = plsdnLast->cpFirst;

	/* go to the begining of chunk calculating amount of elements */
	plsdnCurrent = plsdnLast;
	plsdnPrev = plsdnCurrent->plsdnPrev;
	clschnke = 1;

	while (!FIsChunkBoundary(plsdnPrev, idObjChnk, cpInChunk))
			{
			plsdnCurrent = plsdnPrev;
			plsdnPrev = plsdnCurrent->plsdnPrev;
			if (!FIsDnodeBorder(plsdnCurrent)) clschnke++; /* we don't put borders into array */
			}
	/* plsdnCurrent is first dnode in chunk, clschnke is amount of chnk elements */

	if (clschnke > (LONG) plschunkcontext->cchnkMax)
		{
		lserr = SetChunkArraysSize(plschunkcontext, clschnke);
		if (lserr != lserrNone)
			return lserr;
		}
	
	

	/* fill in array of chunk elements   */
	FlushNominalToIdealState(plschunkcontext);
	plschnke = plocchnk->plschnk;
	plocchnk->clschnk = clschnke;
	ppointUv = plocchnk->ppointUvLoc;
	pdurOpenBorderBefore = plschunkcontext->pdurOpenBorderBefore;
	pdurCloseBorderAfter = plschunkcontext->pdurCloseBorderAfter;
	plschunkcontext->FBorderInside = fFalse;

	for (i=0; i < clschnke; i++)
		{
		Assert(!FIsChunkBoundary(plsdnCurrent, idObjChnk, cpInChunk));
		ppointUv[i].u = 0;
		pdurOpenBorderBefore[i] = 0;
		if (i != 0) pdurCloseBorderAfter[i - 1] = 0;
		while (FIsDnodeBorder(plsdnCurrent))
			{
			/* calculates border widths */
			plschunkcontext->FBorderInside = fTrue;
			if (FIsDnodeOpenBorder(plsdnCurrent))
				{
				pdurOpenBorderBefore[i] += DurFromDnode(plsdnCurrent);
				}
			else
				{
				if (i != 0) pdurCloseBorderAfter[i - 1] += DurFromDnode(plsdnCurrent);
				}
				
			plsdnCurrent = plsdnCurrent->plsdnNext;
			}

		LschnkeFromDnode(plschnke, plsdnCurrent);
		plschunkcontext->pplsdnChunk[i] = plsdnCurrent;
		SetNominalToIdealFlags(plschunkcontext, &(plsdnCurrent->u.real.lschp));

		plsdnCurrent = plsdnCurrent->plsdnNext;

		plschnke++;
		}

	/* closing border after chunk */
	if (plsdnCurrent != NULL && FIsDnodeCloseBorder(plsdnCurrent))
		{
		plschunkcontext->FBorderInside = fTrue;
		pdurCloseBorderAfter[clschnke - 1] = DurFromDnode(plsdnCurrent);
		}
	else
		{
		pdurCloseBorderAfter[clschnke - 1] = 0;
		}

	plschunkcontext->FChunkValid = fTrue;	
	plschunkcontext->FLocationValid = fFalse; /* chunk we collected is not located and */
	plschunkcontext->FGroupChunk = fFalse;	/* is not group */

	return lserrNone;

}


/* S E T  P O S  I N  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: SetPosInChunk
    %%Contact: igorzv

Parameters:
	plschunkcontext		-	(IN) LineServices context
	PLSDNODE plsdn		-	(IN) dnode
	LSDCP dcp			-	(IN) dcp
	pposichnk			-	(OUT) position in chunk to fill in

Convert position in line to position in chunk
----------------------------------------------------------------------------*/

void SetPosInChunk(PLSCHUNKCONTEXT plschunkcontext, PLSDNODE plsdn,
				   LSDCP dcp, PPOSICHNK pposichnk)
{

	LONG i;
	LONG clschnkMac;
	PLSDNODE* pplsdnChunk;
	
	Assert(FIsLSDNODE(plsdn));

	pplsdnChunk = plschunkcontext->pplsdnChunk;
	clschnkMac = plschunkcontext->locchnkCurrent.clschnk;  
	for (i=0; (i < clschnkMac) && (plsdn != pplsdnChunk[i]) ; i++);

	Assert(i < clschnkMac);

	pposichnk->dcp = dcp;
	pposichnk->ichnk = i;

}


		 
/* I N I T  G R O U P  C H U N K  E X T */
/*----------------------------------------------------------------------------
    %%Function: InitGroupChunkExt
    %%Contact: igorzv

Parameters:
	plschunkcontext				-	(IN) chunkcontext context
	iobjText				-		(IN) idobj of text
	pgrchunkext			-	(OUT) structure to initialize

Link GroupChunkExt with state 
Fill in default values
----------------------------------------------------------------------------*/


void InitGroupChunkExt(PLSCHUNKCONTEXT plschunkcontext, DWORD iobjText,
					   GRCHUNKEXT* pgrchunkext)
{
	Assert(pgrchunkext != NULL);
	
	pgrchunkext->plschunkcontext = plschunkcontext;

	pgrchunkext->iobjText = iobjText;
	
	/* we don't need to flush everything here */
	/* we will do this in CollectGroupChunk procedures */

	pgrchunkext->lsgrchnk.plschnk = plschunkcontext->locchnkCurrent.plschnk;
	pgrchunkext->lsgrchnk.pcont = plschunkcontext->pcont;
	pgrchunkext->pfNonTextExpandAfter = plschunkcontext->pfNonTextExpandAfter;
	pgrchunkext->pplsdnNonText = plschunkcontext->pplsdnNonText;
}




/* C O L L E C T  T E X T  G R O U P  C H U N K*/
/*----------------------------------------------------------------------------
%%Function: CollectTextGroupChunk
%%Contact: igorzv

  Parameters:
  plsdnFirst			-	(IN) start dnode
  cpLim				-   (IN) boundary for group chunk
  Purpose				-	(IN) what subline to take from complex object
  pgrchunkext			-	(OUT) group chunk to fill in
  
	Fill in group chunk structure with text dnodes located from plsdFirst 
----------------------------------------------------------------------------*/



LSERR CollectTextGroupChunk(		
							PLSDNODE plsdnFirst,
							LSCP cpLim,
							COLLECTSUBLINES Purpose,
							GRCHUNKEXT* pgrchunkext)
	{
	PLSCHUNKCONTEXT plschunkcontext = pgrchunkext->plschunkcontext;
	DWORD iobjText = pgrchunkext->iobjText;
	PLOCCHNK plocchnk;
	DWORD cChunk;
	PLSDNODE plsdnCurrent;
	BOOL fPreviousIsNonText = fFalse;
	LSERR lserr;
	LSCHNKE* plschnke;
	BOOL fSuccessful;
	BOOL fExpand;
	DWORD cTextBeforeLastNonText = 0;
	GROUPCHUNKITERATOR groupchunkiterator;
	PLSDNODE plsdnLastForTrailing;
	int cDnodesTrailing;
	LSDCP dcpStartTrailing;
	PLSDNODE plsdnTrailingObject;
	LSDCP dcpTrailingObject;
	
	
	Assert(FIsLSDNODE(plsdnFirst));
	Assert(FIsGrchnkExtValid(plschunkcontext, pgrchunkext)); 
	
	
	
	/* we try to optimize here in a case when group chunk consist of one (last in a line)
	chunk 	and this chunk has been already collected */
	plocchnk = &(plschunkcontext->locchnkCurrent);
	cChunk = plocchnk->clschnk;
	
	/* if we have text chunk without borders started with plsdnFirst 
	and going up or beyond cpLim */
	if ((cChunk > 0) &&
		(plschunkcontext->FChunkValid) && 
		(!plschunkcontext->FGroupChunk) && 
		(!plschunkcontext->FBorderInside) && 
		(IdObjFromChnk(plocchnk) ==  pgrchunkext->iobjText) && 
		(plschunkcontext->pplsdnChunk[0] == plsdnFirst)
		&& (!plsdnFirst->fTab)
		&& (FIsOutOfBoundary((plschunkcontext->pplsdnChunk[cChunk - 1])->plsdnNext, cpLim)))
		{
		pgrchunkext->Purpose = Purpose;
		return ConvertChunkToGroupChunk(pgrchunkext, cpLim);
		}
	
	/* we have to go through general procedure */
	
	/* flush group chunk				*/
	pgrchunkext->plsdnFirst = plsdnFirst;
	pgrchunkext->durTotal = 0;
	pgrchunkext->durTextTotal = 0;
	pgrchunkext->dupNonTextTotal = 0;
	pgrchunkext->cNonTextObjects = 0;
	pgrchunkext->cNonTextObjectsExpand = 0;
	pgrchunkext->lsgrchnk.clsgrchnk = 0;
	pgrchunkext->plsdnNext = NULL;
	pgrchunkext->plsdnLastUsed = NULL;
	plschunkcontext->FGroupChunk = fTrue;
	plschunkcontext->FBorderInside = fFalse;
	pgrchunkext->Purpose = Purpose;
	
	CreateGroupChunkIterator(&groupchunkiterator, 
		Purpose, plsdnFirst, cpLim,	fTrue);	
	
	plsdnCurrent = GetNextDnodeInGroupChunk(&groupchunkiterator, &fSuccessful);
	
	while(fSuccessful)
		{
		pgrchunkext->plsdnLastUsed = plsdnCurrent;
		
		/* fill in array of elements   */
		if (FIsDnodeReal(plsdnCurrent) && !FIsDnodeSplat(plsdnCurrent)) /* not a pen border or splat*/
			{
			if (IdObjFromDnode(plsdnCurrent) == iobjText) /* is text */
				{
				
				pgrchunkext->lsgrchnk.clsgrchnk++;
				if (pgrchunkext->lsgrchnk.clsgrchnk > plschunkcontext->cchnkMax)
					{
					lserr = IncreaseChunkArrays(plschunkcontext);
					if (lserr != lserrNone)
						{
						DestroyGroupChunkIterator(&groupchunkiterator);
						return lserr;
						}
					pgrchunkext->lsgrchnk.plschnk = plschunkcontext->locchnkCurrent.plschnk;
					pgrchunkext->lsgrchnk.pcont = plschunkcontext->pcont;
					Assert(FIsGrchnkExtValid(plschunkcontext, pgrchunkext)); 
					}
				
				/* fill in group chunk element */
				plschnke = &(pgrchunkext->lsgrchnk.plschnk[pgrchunkext->lsgrchnk.clsgrchnk - 1]);
				LschnkeFromDnode(plschnke, plsdnCurrent);
				
				/* fill in array of dnodes in context */
				plschunkcontext->pplsdnChunk[pgrchunkext->lsgrchnk.clsgrchnk - 1] = plsdnCurrent;
				
				/* flash flags */
				pgrchunkext->lsgrchnk.pcont[pgrchunkext->lsgrchnk.clsgrchnk - 1] = 0;
				
				/* set flags  */
				if (fPreviousIsNonText)
					{
					pgrchunkext->lsgrchnk.pcont[pgrchunkext->lsgrchnk.clsgrchnk - 1] |=
						fcontNonTextBefore;  
					}
				
				
				fPreviousIsNonText = fFalse;
				
				/* calculate integrated information   */
				pgrchunkext->durTextTotal += plsdnCurrent->u.real.objdim.dur;
				pgrchunkext->durTotal += plsdnCurrent->u.real.objdim.dur;
				}
			else
				{
				/* resolve expansion after previous non text */
				if (pgrchunkext->cNonTextObjects > 0)
					{
					lserr = FExpandAfterNonTextObject(pgrchunkext, cTextBeforeLastNonText, 
						&fExpand);
					if (lserr != lserrNone)
						{
						DestroyGroupChunkIterator(&groupchunkiterator);
						return lserr;
						}
					
					pgrchunkext->pfNonTextExpandAfter[pgrchunkext->cNonTextObjects - 1] =
						fExpand;
					
					if (fExpand)
						{
						/* increase amount of expandable non text objects */
						pgrchunkext->cNonTextObjectsExpand++;
						/* it was text between two non texts */
						if (!fPreviousIsNonText)
							{
							Assert(pgrchunkext->lsgrchnk.clsgrchnk > cTextBeforeLastNonText);
							pgrchunkext->lsgrchnk.pcont[cTextBeforeLastNonText] |=
								fcontExpandBefore; 
							}
						}
					}
				
				
				pgrchunkext->cNonTextObjects++;
				if (pgrchunkext->cNonTextObjects > plschunkcontext->cNonTextMax)
					{
					lserr = IncreaseGroupChunkNonTextArrays(plschunkcontext);
					if (lserr != lserrNone)
						{
						DestroyGroupChunkIterator(&groupchunkiterator);
						return lserr;
						}
					pgrchunkext->pplsdnNonText = plschunkcontext->pplsdnNonText;
					pgrchunkext->pfNonTextExpandAfter = plschunkcontext->pfNonTextExpandAfter;
					Assert(FIsGrchnkExtValid(plschunkcontext, pgrchunkext)); 
					}
				
				/* fill in array of non text dnodes in context */
				plschunkcontext->pplsdnNonText[pgrchunkext->cNonTextObjects - 1] = plsdnCurrent;
				
				
				/* set flags in previous text */
				if (!fPreviousIsNonText && pgrchunkext->lsgrchnk.clsgrchnk >= 1)
					{
					Assert(pgrchunkext->lsgrchnk.clsgrchnk >= 1);
					pgrchunkext->lsgrchnk.pcont[pgrchunkext->lsgrchnk.clsgrchnk  - 1] |=
						(fcontNonTextAfter); 
					
					/* resolve expansion before current non text */
					Assert(cTextBeforeLastNonText < pgrchunkext->lsgrchnk.clsgrchnk);
					lserr =FExpandBeforeNonTextObject(pgrchunkext, cTextBeforeLastNonText,
						&fExpand);
					if (lserr != lserrNone)
						{
						DestroyGroupChunkIterator(&groupchunkiterator);
						return lserr;
						}
					if (fExpand)
						{
						pgrchunkext->lsgrchnk.pcont[pgrchunkext->lsgrchnk.clsgrchnk  - 1] |=
							fcontExpandAfter;
						}
					}
				
				fPreviousIsNonText = fTrue;
				cTextBeforeLastNonText = pgrchunkext->lsgrchnk.clsgrchnk;
				
				/* calculate integrated information   */
				pgrchunkext->durTotal += DurFromRealDnode(plsdnCurrent);
				pgrchunkext->dupNonTextTotal += DupFromRealDnode(plsdnCurrent);
				} /* non -text */
			} /* real dnode */
			else
				{  /* pen  or border*/
				Assert(FIsDnodePen(plsdnCurrent) ||
					FIsDnodeBorder(plsdnCurrent) || FIsDnodeSplat(plsdnCurrent));
				Assert(FIsDnodeBorder(plsdnCurrent) || FIsDnodeSplat(plsdnCurrent) ||
					plsdnCurrent->fAdvancedPen); /* only advanced pens are allowed here */
				
				if (FIsDnodeBorder(plsdnCurrent)) 
					plschunkcontext->FBorderInside = fTrue;
				
				pgrchunkext->durTotal += DurFromDnode(plsdnCurrent);
				pgrchunkext->dupNonTextTotal += DupFromDnode(plsdnCurrent);
				}
			
			/* prepare next iteration */
			plsdnCurrent = GetNextDnodeInGroupChunk(&groupchunkiterator, &fSuccessful);
		}
		
		/* resolve expansion after previous non text */
		if (pgrchunkext->cNonTextObjects > 0)
			{
			lserr = FExpandAfterNonTextObject(pgrchunkext, cTextBeforeLastNonText, 
				&fExpand);
			if (lserr != lserrNone)
				{
				DestroyGroupChunkIterator(&groupchunkiterator);
				return lserr;
				}
			
			pgrchunkext->pfNonTextExpandAfter[pgrchunkext->cNonTextObjects - 1] |=
				fExpand;
			
			if (fExpand)
				{
				/* increase amount of expandable non text objects */
				pgrchunkext->cNonTextObjectsExpand++;
				/* it was text between two non texts */
				if (!fPreviousIsNonText)
					{
					Assert(pgrchunkext->lsgrchnk.clsgrchnk > cTextBeforeLastNonText);
					pgrchunkext->lsgrchnk.pcont[cTextBeforeLastNonText] |=
						fcontExpandBefore; 
					}
				}
			}
		
		pgrchunkext->plsdnNext = plsdnCurrent;
		
		DestroyGroupChunkIterator(&groupchunkiterator);
		
		/* because collecting of group chunk can be called before SetBreak, dcp of last
		dnode, if it come from lower level, should be cut using  cpLim */
		
		if ((pgrchunkext->lsgrchnk.clsgrchnk > 0) &&
			(plschunkcontext->pplsdnChunk[pgrchunkext->lsgrchnk.clsgrchnk - 1]->cpLimOriginal 
			> cpLim)
			)
			{
			pgrchunkext->lsgrchnk.plschnk[pgrchunkext->lsgrchnk.clsgrchnk - 1].dcp =
				cpLim - 
				plschunkcontext->pplsdnChunk[pgrchunkext->lsgrchnk.clsgrchnk - 1]->cpFirst;
			}
		
		if (Purpose == CollectSublinesForJustification || 
			Purpose == CollectSublinesForCompression)
			{
			/* we should find here last dnode on the upper level before chunk boundary */
			if (pgrchunkext->plsdnLastUsed == NULL)
				{
				/* first dnode is already out of boundary, it can happened with tabs or pens  */
				Assert(pgrchunkext->plsdnFirst == pgrchunkext->plsdnNext);
				plsdnLastForTrailing = pgrchunkext->plsdnFirst;
				}
			else if (pgrchunkext->plsdnNext != NULL)
				{
				plsdnLastForTrailing = pgrchunkext->plsdnNext->plsdnPrev;
				}
			else
				{
				plsdnLastForTrailing = (SublineFromDnode(pgrchunkext->plsdnFirst))->plsdnLast;
				}
			
			lserr = GetTrailingInfoForTextGroupChunk
				(plsdnLastForTrailing, plsdnLastForTrailing->dcp,
				iobjText, &(pgrchunkext->durTrailing), &(pgrchunkext->dcpTrailing),
				&(pgrchunkext->plsdnStartTrailing), 
				&dcpStartTrailing,
				&cDnodesTrailing, &plsdnTrailingObject, &dcpTrailingObject,
				&(pgrchunkext->fClosingBorderStartsTrailing));
			
			if (lserr != lserrNone)
				{
				return lserr;
				}
			
			if (cDnodesTrailing == 0)
				{
				if (pgrchunkext->lsgrchnk.clsgrchnk != 0)
					{
					pgrchunkext->posichnkBeforeTrailing.ichnk = pgrchunkext->lsgrchnk.clsgrchnk - 1;
					pgrchunkext->posichnkBeforeTrailing.dcp = pgrchunkext->lsgrchnk.plschnk
						[pgrchunkext->posichnkBeforeTrailing.ichnk].dcp;
					}
				else
					{
					/* in this case posichnkBeforeTrailing doesn't make any sense and we can't use
					code above not to triger memory violation, so we put zeroes just to put something */
					pgrchunkext->posichnkBeforeTrailing.ichnk = 0;
					pgrchunkext->posichnkBeforeTrailing.dcp = 0;
					}
				}
			else
				{
				pgrchunkext->posichnkBeforeTrailing.ichnk = pgrchunkext->lsgrchnk.clsgrchnk 
					- cDnodesTrailing;
				if (FIsDnodeReal(pgrchunkext->plsdnStartTrailing) 
					&& IdObjFromDnode(pgrchunkext->plsdnStartTrailing) == iobjText)
					{
					pgrchunkext->posichnkBeforeTrailing.dcp = dcpStartTrailing;
					}
				else
					{
					/* trailing area was interupted by non text, we report to text starting of trailing before
					previous text */
					Assert(pgrchunkext->plsdnStartTrailing->dcp == dcpStartTrailing);
					pgrchunkext->posichnkBeforeTrailing.dcp = 0;
					}
				}
			}
		
		
		return lserrNone;
		
	}
	
	


/* C O N T I N U E  G R O U P  C H U N K*/
/*----------------------------------------------------------------------------
    %%Function: ContinueGroupChunk
    %%Contact: igorzv

Parameters:
	pgroupchunkiterator	-(IN) handler for iterator 
	pfSuccessful	-	(OUT) do we find dnode in this group chunk 

Start traversing list for collecting group chunk 
----------------------------------------------------------------------------*/

PLSDNODE ContinueGroupChunk(
							GROUPCHUNKITERATOR* pgroupchunkiterator, 
							BOOL* pfSuccessful)
	{
	PLSSUBL plssubl;
	PLSSUBL* rgpsubl;
	PLSDNODE plsdnStart = pgroupchunkiterator->plsdnStart;
	BOOL fBoundaryCondition;
	int cSublines;

	/* we assume here that dnode out of group chunk boundary can happen only on main subline of
	the group chunk */

	fBoundaryCondition = pgroupchunkiterator->fForward ? 
		FIsGroupChunkBoundary(plsdnStart, pgroupchunkiterator->cpLim, 
			pgroupchunkiterator->plsdnFirst->cpFirst) :
		FIsGroupChunkStartBoundary(plsdnStart, pgroupchunkiterator->plsdnFirst->cpFirst) ;
		

	if (fBoundaryCondition)		/* we out of limits */
		{	
		AssertImplies(plsdnStart != NULL, FIsLSDNODE(plsdnStart));
		AssertImplies(plsdnStart != NULL, 
			SublineFromDnode(plsdnStart) == SublineFromDnode(pgroupchunkiterator->plsdnFirst));
		*pfSuccessful = fFalse;
		return plsdnStart;
		}

	Assert(FIsLSDNODE(plsdnStart));
	plssubl = SublineFromDnode(plsdnStart);

	/* we assume here that here that plsnStart is valid dnode within subline*/
	Assert(!FIsOutOfBoundary(plsdnStart, plssubl->cpLim));

	*pfSuccessful = fTrue;

	if (FIsDnodeBorder(plsdnStart) || FIsDnodePen(plsdnStart))
		{
		return plsdnStart;
		}

	rgpsubl = GetSubmittedSublines(plsdnStart, pgroupchunkiterator->Purpose);

	if (rgpsubl == NULL)
		{
		return plsdnStart;
		}
	else
		{
		cSublines = GetNumberSubmittedSublines(plsdnStart);
		if (cSublines > 0)
			{
			plssubl = pgroupchunkiterator->fForward ? 
				rgpsubl[0] : rgpsubl[cSublines - 1];
			/* we assume here that empty subline can not be submitted */
			Assert(!FIsOutOfBoundary(plssubl->plsdnFirst, plssubl->cpLim));
			plssubl->plsdnUpTemp = plsdnStart;
			pgroupchunkiterator->plsdnStart = pgroupchunkiterator->fForward ?
				plssubl->plsdnFirst : plssubl->plsdnLast;
			return ContinueGroupChunk(pgroupchunkiterator, pfSuccessful);
			}
		else
			{
			return plsdnStart;
			}
		}
	}


/* G E T  N E X T  D N O D E  I N  G R O U P  C H U N K*/
/*----------------------------------------------------------------------------
    %%Function: GetNextDnodeInGroupChunk
    %%Contact: igorzv

Parameters:
	pgroupchunkiterator	-(IN) handler for iterator 
	pfSuccessful	-	(OUT) do we find dnode in this group chunk 

Continue traversing list for collecting group chunk 
----------------------------------------------------------------------------*/

PLSDNODE GetNextDnodeInGroupChunk(
					GROUPCHUNKITERATOR* pgroupchunkiterator, 
					BOOL* pfSuccessful)
	{
	LONG i;
	PLSSUBL plssubl;
	PLSDNODE plsdnNext;
	PLSDNODE plsdnUp;
	PLSSUBL* rgpsubl;
	LONG cSublines;
	PLSDNODE plsdnStart = pgroupchunkiterator->plsdnStart;

	if (plsdnStart == NULL)  /* first iteration */
		{
		pgroupchunkiterator->plsdnStart = pgroupchunkiterator->plsdnFirst;
		return ContinueGroupChunk(pgroupchunkiterator, pfSuccessful);
		}

	Assert(FIsLSDNODE(plsdnStart));
	
	plssubl = plsdnStart->plssubl;
	plsdnNext = pgroupchunkiterator->fForward ? 
					plsdnStart->plsdnNext : plsdnStart->plsdnPrev;

	/* we are in one of submitted sublines and this subline ended */
	if (plssubl != SublineFromDnode(pgroupchunkiterator->plsdnFirst) && 
		FIsOutOfBoundary(plsdnNext, plssubl->cpLim)) 
		{
		plsdnUp = plssubl->plsdnUpTemp;
		Assert(FIsLSDNODE(plsdnUp));
		/* flush temporary field */
		plssubl->plsdnUpTemp = NULL;

		rgpsubl = GetSubmittedSublines(plsdnUp, pgroupchunkiterator->Purpose);
		cSublines = GetNumberSubmittedSublines(plsdnUp);
		Assert(rgpsubl != NULL);
		Assert(cSublines > 0);

		/* find index in a array of submitted sublines */
		for (i=0; i < cSublines	&& plssubl != rgpsubl[i]; i++);
		Assert(i < cSublines);

		if ( (pgroupchunkiterator->fForward && i == cSublines - 1) ||
			 (!pgroupchunkiterator->fForward && i == 0)
		   )
		/* array ended: return to the upper level */
			{
			pgroupchunkiterator->plsdnStart = plsdnUp;
			return GetNextDnodeInGroupChunk(pgroupchunkiterator, pfSuccessful);
			}
		else
			{
			plssubl = pgroupchunkiterator->fForward ? 
						rgpsubl[i + 1] : rgpsubl[i - 1];
			/* we assume here that empty subline can not be submitted */
			Assert(!FIsOutOfBoundary(plssubl->plsdnFirst, plssubl->cpLim));
			plssubl->plsdnUpTemp = plsdnUp;
			pgroupchunkiterator->plsdnStart = plssubl->plsdnFirst;
			return ContinueGroupChunk(pgroupchunkiterator, pfSuccessful);
			}
		}
	else /* we can continue with the same subline */
		{
		pgroupchunkiterator->plsdnStart = plsdnNext;
		return ContinueGroupChunk(pgroupchunkiterator, pfSuccessful);
		}

	}

/* C R E A T E  G R O U P  C H U N K  I T E R A T O R*/
/*----------------------------------------------------------------------------
    %%Function: CreateGroupChunkIterator
    %%Contact: igorzv

Parameters:
	pgroupchunkiterator	-(IN) handler for iterator 
	Purpose				-(INI what sublines to take from a complex object 
	plsdnFirst			-(IN) dnode from which we started collecting 
	cpLim				-(IN) boundary for group chunk if we go forward 
	fForward			-(IN) direction of traversing is forward otherwise it's backward

----------------------------------------------------------------------------*/
static void CreateGroupChunkIterator(
					GROUPCHUNKITERATOR* pgroupchunkiterator, 
					COLLECTSUBLINES Purpose, 
					PLSDNODE plsdnFirst, 
					LSCP cpLim,			
					BOOL fForward)
	{
	pgroupchunkiterator->Purpose = Purpose;
	pgroupchunkiterator->plsdnFirst = plsdnFirst;
	pgroupchunkiterator->plsdnStart = NULL;
	pgroupchunkiterator->cpLim = cpLim;
	pgroupchunkiterator->fForward = fForward;
	}

/* D E S T R O Y  G R O U P  C H U N K  I T E R A T O R*/
/*----------------------------------------------------------------------------
    %%Function: DesroyGroupChunkIterator
    %%Contact: igorzv

Parameters:
	pgroupchunkiterator	-(IN) handler for iterator 

----------------------------------------------------------------------------*/
static void DestroyGroupChunkIterator(
									  GROUPCHUNKITERATOR* pgroupchunkiterator) 
	{
	PLSSUBL plssubl;
	PLSDNODE plsdn;
	if (pgroupchunkiterator->plsdnStart != NULL)
		{
		plssubl = SublineFromDnode(pgroupchunkiterator->plsdnStart);
		while (SublineFromDnode(pgroupchunkiterator->plsdnFirst) != plssubl)
			{
			plsdn = plssubl->plsdnUpTemp;
			Assert(FIsLSDNODE(plsdn));
			plssubl->plsdnUpTemp = NULL;
			plssubl = SublineFromDnode(plsdn);
			}
		}
	}

/* F  E X P A N D  B E F O R E  N O N  T E X T  O B J E C T*/
/*----------------------------------------------------------------------------
    %%Function: FExpandBeforeNonTextObject
    %%Contact: igorzv

Parameters:
	pgrchunkext					-	(IN) group chunk
	cTextBeforePreviousNonText	-	(IN) number of text before previous non text 
										 to calculate contiguous chunk
	pfExpand					-	(OUT) to expand dnode before non text

----------------------------------------------------------------------------*/
static LSERR FExpandBeforeNonTextObject(GRCHUNKEXT* pgrchunkext, DWORD cTextBeforePrevioustNonText,
									   BOOL* pfExpand)
	{
	DWORD cTextBetween;
	LSERR lserr;
	BOOL fSuccessful;
	WCHAR wchar;
	PLSRUN plsrunText;
	HEIGHTS heightsText;
	MWCLS mwcls;
	DWORD iobj;
	LSIMETHODS* plsim;
	PLSDNODE plsdnNonText;

	*pfExpand = fTrue;

	cTextBetween = pgrchunkext->lsgrchnk.clsgrchnk - cTextBeforePrevioustNonText;
	if (cTextBetween)
		{
		lserr = GetLastCharInChunk(cTextBetween,
				(pgrchunkext->lsgrchnk.plschnk + cTextBeforePrevioustNonText), &fSuccessful,
				&wchar, &plsrunText, &heightsText, &mwcls);
		if (lserr != lserrNone)
			return lserr; 
		if (fSuccessful)
			{
			plsdnNonText = pgrchunkext->pplsdnNonText[pgrchunkext->cNonTextObjects - 1];
			iobj = IdObjFromDnode(plsdnNonText);
			plsim = PLsimFromLsc(pgrchunkext->plschunkcontext->plsiobjcontext, iobj);
			if (plsim->pfnFExpandWithPrecedingChar != NULL)
				{
				lserr = plsim->pfnFExpandWithPrecedingChar(plsdnNonText->u.real.pdobj,
					plsdnNonText->u.real.plsrun, plsrunText, wchar,
					mwcls, pfExpand);
				if (lserr != lserrNone)
					return lserr;
				}  /* object has this method */
			}	/* call back from text was successful  */
		}
	return lserrNone;
	}

/* F  E X P A N D  A F T E R  N O N  T E X T  O B J E C T*/
/*----------------------------------------------------------------------------
    %%Function: FExpandAfterNonTextObject
    %%Contact: igorzv

Parameters:
	pgrchunkext					-	(IN) group chunk
	cTextBeforeLastNonText		-	(IN) number of text before last non text 
										 to calculate contiguous chunk
	pfExpand					-	(OUT) to expand dnode before non text

----------------------------------------------------------------------------*/
static LSERR FExpandAfterNonTextObject(GRCHUNKEXT* pgrchunkext, DWORD cTextBeforeLastNonText,
									   BOOL* pfExpand)
	{
	DWORD cTextBetween;
	LSERR lserr;
	BOOL fSuccessful;
	WCHAR wchar;
	PLSRUN plsrunText;
	HEIGHTS heightsText;
	MWCLS mwcls;
	DWORD iobj;
	LSIMETHODS* plsim;
	PLSDNODE plsdnNonText;

	*pfExpand = fTrue;

	cTextBetween = pgrchunkext->lsgrchnk.clsgrchnk - cTextBeforeLastNonText;
	if (cTextBetween)
		{
		lserr = GetFirstCharInChunk(cTextBetween,
				(pgrchunkext->lsgrchnk.plschnk + cTextBeforeLastNonText), &fSuccessful,
				&wchar, &plsrunText, &heightsText, &mwcls);
		if (lserr != lserrNone)
			return lserr; 
		if (fSuccessful)
			{
			plsdnNonText = pgrchunkext->pplsdnNonText[pgrchunkext->cNonTextObjects - 1];
			iobj = IdObjFromDnode(plsdnNonText);
			plsim = PLsimFromLsc(pgrchunkext->plschunkcontext->plsiobjcontext, iobj);
			if (plsim->pfnFExpandWithFollowingChar != NULL)
				{
				lserr = plsim->pfnFExpandWithFollowingChar(plsdnNonText->u.real.pdobj,
					plsdnNonText->u.real.plsrun, plsrunText, wchar,
					mwcls, pfExpand);
				if (lserr != lserrNone)
					return lserr;
				}  /* object has this method */
			}	/* call back from text was successful  */
		}
	return lserrNone;
	}


/* C O L L E C T  P R E V I O U S  T E X T  G R O U P  C H U N K*/
/*----------------------------------------------------------------------------
    %%Function: CollectPreviousTextGroupChunk
    %%Contact: igorzv

Parameters:
	plsdnEnd			-	(IN) end dnode
	sublinnesToCollect		(IN) what subline to take from complex object
	pgrchunkext			-	(OUT) group chunk to fill in

Fill in group chunk structure with text dnodes located before  plsdEnd
----------------------------------------------------------------------------*/



LSERR CollectPreviousTextGroupChunk(		
			 		 PLSDNODE plsdnEnd,
					 COLLECTSUBLINES Purpose,
					 BOOL fAllSimpleText,
					 GRCHUNKEXT* pgrchunkext)
{
	LSCHUNKCONTEXT* plschunkcontext = pgrchunkext->plschunkcontext;
	PLOCCHNK plocchnk;
	DWORD cChunk;
	LSCP cpLim;
	PLSDNODE plsdn;
	PLSDNODE plsdnPrev;

	Assert(FIsLSDNODE(plsdnEnd));
	Assert(FIsGrchnkExtValid(plschunkcontext, pgrchunkext)); 

	/* we try to optimize here in a case when there is only text in line  */
	/* chunk of text has been already collected */
	plocchnk = &(plschunkcontext->locchnkCurrent);
	cChunk = plocchnk->clschnk;
	cpLim = plsdnEnd->cpLimOriginal; 

	if (fAllSimpleText && cChunk > 0) 
		{
		/* chunk goes up to the end of a line */
		Assert((plschunkcontext->pplsdnChunk[cChunk - 1])->plsdnNext == NULL);
		pgrchunkext->Purpose = Purpose;
		return ConvertChunkToGroupChunk(pgrchunkext, cpLim);
		}

	/* go backward to the start of group chunk  */
	plsdn = plsdnEnd;
	plsdnPrev = plsdn->plsdnPrev;
	while (!FIsGroupChunkStartBoundary(plsdnPrev, plsdnEnd->cpFirst))
		{
		plsdn = plsdnPrev;
		plsdnPrev = plsdn->plsdnPrev;
		}
	
	return CollectTextGroupChunk(plsdn, cpLim, Purpose, pgrchunkext);
	
}

/* C O N V E R T  C H U N K  T O  G R O U P  C H U N K*/
/*----------------------------------------------------------------------------
    %%Function: ConvertChunkToGroupChunk
    %%Contact: igorzv

Parameters:
	cpLim			-		(IN) cpLim
	pgrchunkext			-	(OUT) group chunk to fill in

Fill in group chunk structure with text dnodes located before  plsdEnd
We assume here that chunk doesn't contain border.
----------------------------------------------------------------------------*/


static LSERR ConvertChunkToGroupChunk(GRCHUNKEXT* pgrchunkext, LSCP cpLim)
{
	DWORD clsgrchnkCollected = 0;
	long durTotal = 0;
	LSCHUNKCONTEXT* plschunkcontext = pgrchunkext->plschunkcontext;
	PLOCCHNK plocchnk;
	LONG cChunk;
	LONG i;
	BOOL fLineEnded;
	PLSDNODE plsdn;
	long durTrailingDnode;
	LSDCP dcpTrailingDnode;

	Assert(FIsGrchnkExtValid(plschunkcontext, pgrchunkext)); 

	plocchnk = &(plschunkcontext->locchnkCurrent);
	cChunk = (int) plocchnk->clschnk;
	fLineEnded = fFalse;

	for (i = 0; (i < cChunk) && !fLineEnded; i ++)
		{
		clsgrchnkCollected++;
		pgrchunkext->lsgrchnk.pcont[i] = 0; 
		plsdn = plschunkcontext->pplsdnChunk[i];
		durTotal += DurFromRealDnode(plsdn);
		
		/* if we are in last dnode before cpLim there is possibility 
		that during break it was changed 
		so we  should rewrite dcp in chunk element and quit */
		if ((LSCP)(plsdn->cpLimOriginal) == cpLim)
			{
			plocchnk->plschnk[i].dcp = plsdn->dcp;
			fLineEnded = fTrue;
			}
		}

	/* fill in header  of groupchunkext   */
	pgrchunkext->plsdnFirst = plschunkcontext->pplsdnChunk[0];;
	pgrchunkext->plsdnLastUsed = plschunkcontext->pplsdnChunk[clsgrchnkCollected - 1];
	pgrchunkext->plsdnNext = pgrchunkext->plsdnLastUsed->plsdnNext;
	pgrchunkext->durTotal = durTotal;
	pgrchunkext->durTextTotal = durTotal;
	pgrchunkext->dupNonTextTotal = 0;
	pgrchunkext->cNonTextObjects = 0;
	pgrchunkext->cNonTextObjectsExpand = 0;
	pgrchunkext->lsgrchnk.clsgrchnk = clsgrchnkCollected;

	plschunkcontext->FGroupChunk = fTrue;

	if (pgrchunkext->Purpose == CollectSublinesForJustification || 
		pgrchunkext->Purpose == CollectSublinesForCompression)
		{
		Assert(clsgrchnkCollected > 0);
		pgrchunkext->durTrailing = 0;
		pgrchunkext->dcpTrailing = 0;
		plsdn = NULL;
		dcpTrailingDnode = 0;

		pgrchunkext->fClosingBorderStartsTrailing = fFalse;
		
		for (i = clsgrchnkCollected - 1; i >= 0; i--)
			{
			plsdn = plschunkcontext->pplsdnChunk[i];
			GetTrailInfoText(PdobjFromDnode(plsdn), plsdn->dcp,
				&dcpTrailingDnode, &durTrailingDnode);
			pgrchunkext->durTrailing += durTrailingDnode;
			pgrchunkext->dcpTrailing += dcpTrailingDnode;
			
			/* add opening border before previous dnode */
			if (i < (int) (clsgrchnkCollected - 1))
				pgrchunkext->durTrailing += plschunkcontext->pdurOpenBorderBefore[i +1];

			if (dcpTrailingDnode != 0) 
				/* add closing border after */
				pgrchunkext->durTrailing += plschunkcontext->pdurCloseBorderAfter[i];
			else
				{
				pgrchunkext->fClosingBorderStartsTrailing = 
					(plschunkcontext->pdurCloseBorderAfter[i] != 0);
				}
			
			if (plsdn->dcp != dcpTrailingDnode)
				break;
			
			}
		
		pgrchunkext->plsdnStartTrailing = plsdn;

		if (i == -1) i = 0;
		
		pgrchunkext->posichnkBeforeTrailing.ichnk = i;
		pgrchunkext->posichnkBeforeTrailing.dcp = plsdn->dcp - dcpTrailingDnode;
		}
	

	return lserrNone;
}

/* G E T  T R A I L I N G  I N F O  F O R  T E X T  G R O U P  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: GetTrailingInfoForTextGroupChunk
    %%Contact: igorzv

Parameters:
	plsdnLastDnode		-	(IN) dnode where to start calculation of trailing area
	dcpLastDnode		-	(IN) dcp in this dnode
	iobjText			-	(IN) iobj of text
	pdurTrailing		-	(OUT) dur of trailing area in  group chunk
	pdcpTrailing		-	(OUT) dcp of trailing area in chunk
	pplsdnStartTrailing -	(OUT) dnode where trailing area starts
	pdcpStartTrailing-	(OUT) with pcDnodesTrailing defines last character in text before
								  trailing area
	pcDnodesTrailing	-	(OUT) number of text dnodes participates in trailing area
	pplsdnStartTrailingObject -(OUT) dnode on the upper level where trailing are starts
	pdcpStartTrailingObject	-(OUT) dcp in such dnode 
	pfClosingBorderStartsTrailing - (OUT) closing border located just before trailing area
----------------------------------------------------------------------------*/
	
LSERR GetTrailingInfoForTextGroupChunk
				(PLSDNODE plsdnLast, LSDCP dcpLastDnode, DWORD iobjText,
				 long* pdurTrailing, LSDCP* pdcpTrailing,
				 PLSDNODE* pplsdnStartTrailing, LSDCP* pdcpStartTrailing,
				 int* pcDnodesTrailing, PLSDNODE* pplsdnStartTrailingObject,
				 LSDCP* pdcpStartTrailingObject, BOOL* pfClosingBorderStartsTrailing)
	{
	PLSDNODE plsdn;
	long durTrailingDnode;
	LSDCP dcpTrailingDnode;
	BOOL fSuccessful;
	LSDCP dcpDnode;
	GROUPCHUNKITERATOR groupchunkiterator;
	LSCP cpLim;
	LSCP cpLimTrail;
	LSSUBL* plssubl;
	long durPrevClosingBorder = 0;

	*pdurTrailing = 0;
	*pdcpTrailing = 0;
	*pplsdnStartTrailing = plsdnLast;
	*pdcpStartTrailing = dcpLastDnode;
	*pcDnodesTrailing = 0;
	if (plsdnLast->dcp == dcpLastDnode)
		cpLim = plsdnLast->cpLimOriginal;
	else
		cpLim = plsdnLast->cpFirst + dcpLastDnode;
	
	CreateGroupChunkIterator(&groupchunkiterator, 
					CollectSublinesForTrailingArea, plsdnLast, 
					cpLim, fFalse);	

	plsdn = GetNextDnodeInGroupChunk(&groupchunkiterator, &fSuccessful);
	
	while(fSuccessful)
		{
		*pplsdnStartTrailing = plsdn;
		/* this procedure can be called before SetBreak so we should calculate 
			dcp of last dnode in chunk using cpLim */
		if (plsdn->cpLimOriginal > cpLim)
			dcpDnode = cpLim - plsdn->cpFirst;
		else
			dcpDnode = plsdn->dcp;
		*pdcpStartTrailing = dcpDnode;

		if (FIsDnodeReal(plsdn) && !FIsDnodeSplat(plsdn)) /* not a pen border or splat*/
			{
			if (IdObjFromDnode(plsdn) == iobjText) /* is text */
				{

				GetTrailInfoText(PdobjFromDnode(plsdn), dcpDnode,
					&dcpTrailingDnode, &durTrailingDnode);

				(*pcDnodesTrailing)++;

				if (dcpTrailingDnode == 0)
					{
					break;
					}
				
				*pdurTrailing += durTrailingDnode;
				*pdcpTrailing += dcpTrailingDnode;
				*pdcpStartTrailing -= dcpTrailingDnode;
				*pdurTrailing += durPrevClosingBorder;
				durPrevClosingBorder = 0;

				if (dcpDnode != dcpTrailingDnode)
					break;
				}
			else
				{
				/* object which did not submit subline for trailing */
				break;
				}
			
			}
		else
			{
			/* border or splat */
			if (FIsDnodeCloseBorder(plsdn))
				{
				durPrevClosingBorder = DurFromDnode(plsdn);
				}
			else
				{
				*pdurTrailing += DurFromDnode(plsdn);
				}
			*pdcpTrailing += plsdn->dcp;
			}

		plsdn = GetNextDnodeInGroupChunk(&groupchunkiterator, &fSuccessful);

		}

	*pfClosingBorderStartsTrailing = (durPrevClosingBorder != 0);

	if (*pcDnodesTrailing == 0)
		{
		*pplsdnStartTrailingObject = plsdnLast;
		*pdcpStartTrailingObject = dcpLastDnode;
		}
	else if (SublineFromDnode(*pplsdnStartTrailing) == 
		     SublineFromDnode(plsdnLast))
		{
		*pplsdnStartTrailingObject = *pplsdnStartTrailing;
		*pdcpStartTrailingObject = *pdcpStartTrailing;
		}
	/* the last dnode we've checked was on the lower level */
	else if (fSuccessful) /* and we actually stopped on it */
		{
		if ((*pplsdnStartTrailing)->dcp == *pdcpStartTrailing)
			cpLimTrail = (*pplsdnStartTrailing)->cpLimOriginal;
		else
			cpLimTrail = (*pplsdnStartTrailing)->cpFirst + *pdcpStartTrailing;

		plsdn = *pplsdnStartTrailing;
		plssubl = SublineFromDnode(plsdn);
		while (SublineFromDnode(plsdnLast) != plssubl)
			{
			plsdn = plssubl->plsdnUpTemp;
			Assert(FIsLSDNODE(plsdn));
			plssubl = SublineFromDnode(plsdn);
			}
		*pplsdnStartTrailingObject = plsdn;
		if (plsdn->cpLimOriginal > cpLimTrail)
			*pdcpStartTrailingObject = cpLimTrail - plsdn->cpFirst;
		else
			*pdcpStartTrailingObject = plsdn->dcp;
		}
	else
		{
		/* we went through all group chunk and the last dnode under investigation was on lower level */
		/* plsdn is dnode before group chunk */
		if (plsdn == NULL) /* there is nothing before group chunk */
			{
			*pplsdnStartTrailingObject = (SublineFromDnode(plsdnLast))->plsdnFirst;
			}
		else
			{
			*pplsdnStartTrailingObject = plsdn->plsdnNext;
			}
		Assert(FIsLSDNODE(*pplsdnStartTrailingObject));

		*pdcpStartTrailingObject = 0;
		}

	DestroyGroupChunkIterator(&groupchunkiterator);

	return lserrNone;
	}


/* A L L O C  C H U N K  A R R A Y S */
/*----------------------------------------------------------------------------
    %%Function: AllocChunkArrays
    %%Contact: igorzv

Parameters:
	plschunkcontext				-	(IN) chunk context
	plscbk						-	(IN) callbacks
	pols						-   (IN) pols for callbacks
	plsiobjcontext				-	(IN) pointer to a table of methods
----------------------------------------------------------------------------*/
LSERR AllocChunkArrays(PLSCHUNKCONTEXT plschunkcontext, LSCBK* plscbk, POLS pols,
					   PLSIOBJCONTEXT plsiobjcontext)
	{

	plschunkcontext->pplsdnChunk = plscbk->pfnNewPtr(pols, 
											sizeof(PLSDNODE)*limAllDNodes);
	plschunkcontext->pcont = plscbk->pfnNewPtr(pols, 
											sizeof(DWORD)*limAllDNodes);
	plschunkcontext->locchnkCurrent.plschnk = plscbk->pfnNewPtr(pols, 
											sizeof(LSCHNKE)*limAllDNodes);
	plschunkcontext->locchnkCurrent.ppointUvLoc = plscbk->pfnNewPtr(pols, 
											sizeof(POINTUV)*limAllDNodes);
	plschunkcontext->pfNonTextExpandAfter = plscbk->pfnNewPtr(pols, 
											sizeof(BOOL)*limAllDNodes);
	plschunkcontext->pplsdnNonText = plscbk->pfnNewPtr(pols, 
											sizeof(PLSDNODE)*limAllDNodes);
	plschunkcontext->pdurOpenBorderBefore = plscbk->pfnNewPtr(pols, 
											sizeof(LONG)*limAllDNodes);
	plschunkcontext->pdurCloseBorderAfter = plscbk->pfnNewPtr(pols, 
											sizeof(LONG)*limAllDNodes);

	plschunkcontext->cchnkMax = limAllDNodes;
	plschunkcontext->cNonTextMax = limAllDNodes;
	plschunkcontext->plscbk = plscbk;
	plschunkcontext->pols = pols;
	plschunkcontext->plsiobjcontext = plsiobjcontext;

	if (plschunkcontext->pplsdnChunk == NULL || plschunkcontext->pcont == NULL
		|| plschunkcontext->locchnkCurrent.plschnk == NULL
		|| plschunkcontext->locchnkCurrent.ppointUvLoc == NULL
		|| plschunkcontext->pfNonTextExpandAfter == NULL 
		|| plschunkcontext->pplsdnNonText == NULL
		||plschunkcontext->pdurOpenBorderBefore == NULL
		||plschunkcontext->pdurCloseBorderAfter == NULL
	   )
		{
		return lserrOutOfMemory;
		}
	else
		{
		return lserrNone;
		}

	}
/* G E T  U R  P E N  A T  B E G I N I N G  O F  L A S T  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: GetUrPenAtBeginingOfLastChunk
    %%Contact: igorzv

Parameters:
	plschunkcontext				-	(IN) chunk context
	plsdnFirst					-	(IN) First dnode in a chunk (used for checks)
	plsdnLast					-	(IN) last dnode in subline
	point						-	(IN) point after last dnode
	purPen						-	(OUT) ur before chunk
----------------------------------------------------------------------------*/

LSERR GetUrPenAtBeginingOfLastChunk(PLSCHUNKCONTEXT plschunkcontext,PLSDNODE plsdnFirst,
									PLSDNODE plsdnLast,	POINTUV* ppoint,
									long* purPen)		
	{
	/* chunk must be already collected and has plsdnFirst as the first element */
	Assert(plschunkcontext->locchnkCurrent.clschnk != 0);
	Assert(!plschunkcontext->FGroupChunk);
	Assert(plschunkcontext->pplsdnChunk[0]== plsdnFirst);
	
	if (plschunkcontext->locchnkCurrent.clschnk == 0 ||
		plschunkcontext->FGroupChunk ||
		plschunkcontext->pplsdnChunk[0]!= plsdnFirst)
		return lserrInvalidParameter;

	
	/* calculate point before the last dnode */
	ppoint->u -= DurFromDnode(plsdnLast);
	ppoint->v -= DvrFromDnode(plsdnLast);

	/* go back until first dnode in chunk */
	while(plsdnLast != plsdnFirst)
		{
		plsdnLast = plsdnLast->plsdnPrev;
		Assert(FIsLSDNODE(plsdnLast));
		ppoint->u -= DurFromDnode(plsdnLast);
		ppoint->v -= DvrFromDnode(plsdnLast);
		}

	
	/* locate chunk  */
	if (!plschunkcontext->FLocationValid)
		{
		LocateChunk(plschunkcontext, plsdnFirst, LstflowFromDnode(plsdnFirst), ppoint);
		}
	
	*purPen = plschunkcontext->locchnkCurrent.lsfgi.urPen;
	return lserrNone;
	}

/* F I N D  P O I N T  O F F S E T   */
/*----------------------------------------------------------------------------
    %%Function: FindPointOffset
    %%Contact: igorzv

Parameters:
	plsdnFirst			-	(IN) dnode from the boundaries of which to calculate offset  
	lsdev				-	(IN) presentation or reference device 
	lstflowBase				-	(IN) text flow to use for calculation 
	Purpose				-	(IN) what sublines to take from a complex object 
	plsdnContainsPoint	-	(IN) dnode contains point 
	duInDnode,			-	(IN) offset in the dnode 
	pduOffset			-	(OUT) offset from the starting point 

----------------------------------------------------------------------------*/
void FindPointOffset(PLSDNODE plsdnFirst,	enum lsdevice lsdev,
			  LSTFLOW lstflowBase, COLLECTSUBLINES Purpose,	
			  PLSDNODE plsdnContainsPoint, long duInDnode,	
			  long* pduOffset)
	{
	PLSDNODE plsdnCurrent;
	PLSSUBL plssubl;
	LSTFLOW lstflow;
	LSCP cpFirstDnode;
	PLSSUBL* rgpsubl;
	long cSublines;
	long i;
	long duOffsetSubline;

	plssubl = SublineFromDnode(plsdnFirst);
	lstflow = LstflowFromSubline(plssubl);
	cpFirstDnode = plsdnContainsPoint->cpFirst;
	*pduOffset = 0;

	if (FParallelTflows(lstflow, lstflowBase))
		{
		for(plsdnCurrent = plsdnFirst; 
			plsdnCurrent->cpLimOriginal <= cpFirstDnode && (plsdnCurrent != plsdnContainsPoint);
			/* second check is to catch situation when plsdnContainsPoint has dcp = 0 */
			plsdnCurrent = plsdnCurrent->plsdnNext)
			{
			Assert(FIsLSDNODE(plsdnCurrent));
			if (lsdev == lsdevReference)
				{
				*pduOffset += DurFromDnode(plsdnCurrent);
				}
			else
				{
				Assert(lsdev == lsdevPres);
				*pduOffset += DupFromDnode(plsdnCurrent);
				}
			}

		Assert(FIsLSDNODE(plsdnCurrent));
		
		if (FIsDnodeReal(plsdnCurrent))
			rgpsubl = GetSubmittedSublines(plsdnCurrent, Purpose);
		else
			rgpsubl = NULL;

		if (rgpsubl == NULL)
			{
			Assert(plsdnCurrent == plsdnContainsPoint);
			*pduOffset += duInDnode;
			}
		else
			{
			cSublines = GetNumberSubmittedSublines(plsdnCurrent);
			
			/* if everything is correct we should always find subline in this loop,
			check (i < cSublines) is just to avoid infinite loop and catch situation in a Assert */
			for (i = 0; (i < cSublines) && !FDnodeInsideSubline(rgpsubl[i], plsdnContainsPoint); i++)
				{
				plssubl = rgpsubl[i];
				Assert(FIsLSSUBL(plssubl));
				for (plsdnCurrent = plssubl->plsdnFirst; 
					FDnodeBeforeCpLim(plsdnCurrent, plssubl->cpLim); 
					plsdnCurrent = plsdnCurrent->plsdnNext)
					{
					Assert(FIsLSDNODE(plsdnCurrent));
					if (lsdev == lsdevReference)
						{
						*pduOffset += DurFromDnode(plsdnCurrent);
						}
					else
						{
						Assert(lsdev == lsdevPres);
						*pduOffset += DupFromDnode(plsdnCurrent);
						}
					}
				}
				     

			
			Assert(i != cSublines);
			plssubl = rgpsubl[i];
			Assert(FIsLSSUBL(plssubl));

			FindPointOffset(plssubl->plsdnFirst, lsdev, lstflowBase,
							Purpose, plsdnContainsPoint, duInDnode,	
							&duOffsetSubline);

			*pduOffset += duOffsetSubline;

			}
		}
	else
		{
		for(plsdnCurrent = plssubl->plsdnLast; 
			plsdnCurrent->cpFirst > cpFirstDnode && (plsdnCurrent != plsdnContainsPoint);
			/* second check is to catch situation when plsdnContainsPoint has dcp = 0 */
			plsdnCurrent = plsdnCurrent->plsdnPrev)
			{
			Assert(FIsLSDNODE(plsdnCurrent));
			if (lsdev == lsdevReference)
				{
				*pduOffset += DurFromDnode(plsdnCurrent);
				}
			else
				{
				Assert(lsdev == lsdevPres);
				*pduOffset += DupFromDnode(plsdnCurrent);
				}
			}

		Assert(FIsLSDNODE(plsdnCurrent));

		if (FIsDnodeReal(plsdnCurrent))
			rgpsubl = GetSubmittedSublines(plsdnCurrent, Purpose);
		else
			rgpsubl = NULL;


		if (rgpsubl == NULL)
			{
			Assert(plsdnCurrent == plsdnContainsPoint);
			if (lsdev == lsdevReference)
				{
				*pduOffset += (DurFromDnode(plsdnCurrent) - duInDnode);
				}
			else
				{
				Assert(lsdev == lsdevPres);
				*pduOffset += (DupFromDnode(plsdnCurrent) - duInDnode);
				}
			}
		else
			{
			cSublines = GetNumberSubmittedSublines(plsdnCurrent);
			
			
			/* if everything is correct we should always find subline in this loop,
			check (i >= 0) is just to avoid infinite loop and catch situation in a Assert */
			for (i = cSublines - 1; (i >= 0) && !FDnodeInsideSubline(rgpsubl[i], plsdnContainsPoint); i--)
				{
				plssubl = rgpsubl[i];
				Assert(FIsLSSUBL(plssubl));
				for (plsdnCurrent = plssubl->plsdnFirst; 
					FDnodeBeforeCpLim(plsdnCurrent, plssubl->cpLim); 
					plsdnCurrent = plsdnCurrent->plsdnNext)
					{
					Assert(FIsLSDNODE(plsdnCurrent));
					if (lsdev == lsdevReference)
						{
						*pduOffset += DurFromDnode(plsdnCurrent);
						}
					else
						{
						Assert(lsdev == lsdevPres);
						*pduOffset += DupFromDnode(plsdnCurrent);
						}
					}
				}
			
			Assert(i >= 0);
			plssubl = rgpsubl[i];
			Assert(FIsLSSUBL(plssubl));

			FindPointOffset(plssubl->plsdnFirst, lsdev, lstflowBase,
							Purpose, plsdnContainsPoint, duInDnode,	
							&duOffsetSubline);

			*pduOffset += duOffsetSubline;

			}
		}

	}



/* D I S P O S E  C H U N K  A R R A Y S */
/*----------------------------------------------------------------------------
    %%Function: AllocChunkArrays
    %%Contact: igorzv

Parameters:
	plschunkcontext				-	(IN) chunk context
----------------------------------------------------------------------------*/
void DisposeChunkArrays(PLSCHUNKCONTEXT plschunkcontext)
	{
	if (plschunkcontext->pplsdnChunk != NULL)
		plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pplsdnChunk);
	if (plschunkcontext->pcont != NULL)
		plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pcont);
	if (plschunkcontext->locchnkCurrent.plschnk != NULL)
		plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols, 
										  plschunkcontext->locchnkCurrent.plschnk);
	if (plschunkcontext->locchnkCurrent.ppointUvLoc != NULL)
		plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols, 
										  plschunkcontext->locchnkCurrent.ppointUvLoc);
	if (plschunkcontext->pplsdnNonText != NULL)
		plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pplsdnNonText);
	if (plschunkcontext->pfNonTextExpandAfter != NULL)
		plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pfNonTextExpandAfter);
	if (plschunkcontext->pdurOpenBorderBefore != NULL)
		plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pdurOpenBorderBefore);
	if (plschunkcontext->pdurCloseBorderAfter != NULL)
		plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pdurCloseBorderAfter);

	}

/* S E T  C H U N K  A R R A Y S  S I Z E   */
/*----------------------------------------------------------------------------
    %%Function: SetChunkArraysSize
    %%Contact: igorzv

Parameters:
	plschunkcontext				-	(IN) chunk context
	cchnkMax			-	(IN) new max size for array
----------------------------------------------------------------------------*/

static LSERR SetChunkArraysSize(PLSCHUNKCONTEXT plschunkcontext, DWORD cchnkMax)
{

/* arrays pfNonTextExpandAfter and pplsdnNonText should not be touched here:
   they are independable */

	plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pplsdnChunk);
	plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pcont);
	plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols, 
										  plschunkcontext->locchnkCurrent.plschnk);
	plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols, 
										  plschunkcontext->locchnkCurrent.ppointUvLoc);
	plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pdurOpenBorderBefore);
	plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pdurCloseBorderAfter);


	/* create arrays for chunks  */
	plschunkcontext->pplsdnChunk = plschunkcontext->plscbk->pfnNewPtr(plschunkcontext->pols, 
											sizeof(PLSDNODE)*cchnkMax);
	plschunkcontext->pcont = plschunkcontext->plscbk->pfnNewPtr(plschunkcontext->pols, 
											sizeof(DWORD)*cchnkMax);
	plschunkcontext->locchnkCurrent.plschnk = plschunkcontext->plscbk->pfnNewPtr(plschunkcontext->pols, 
											sizeof(LSCHNKE)*cchnkMax);
	plschunkcontext->locchnkCurrent.ppointUvLoc = plschunkcontext->plscbk->pfnNewPtr(plschunkcontext->pols, 
											sizeof(POINTUV)*cchnkMax);
	plschunkcontext->pdurOpenBorderBefore = plschunkcontext->plscbk->pfnNewPtr(plschunkcontext->pols, 
											sizeof(LONG)*cchnkMax);
	plschunkcontext->pdurCloseBorderAfter = plschunkcontext->plscbk->pfnNewPtr(plschunkcontext->pols, 
											sizeof(LONG)*cchnkMax);


	if (plschunkcontext->pplsdnChunk == NULL || plschunkcontext->pcont == NULL
		|| plschunkcontext->locchnkCurrent.plschnk == NULL
		|| plschunkcontext->locchnkCurrent.ppointUvLoc == NULL
		|| plschunkcontext->pdurOpenBorderBefore == NULL
		|| plschunkcontext->pdurCloseBorderAfter == NULL
	   )
		return lserrOutOfMemory;

	plschunkcontext->cchnkMax = cchnkMax;

	return lserrNone;

}


/* I N C R E A S E  C H U N K  A R R A Y S  S I Z E   */
/*----------------------------------------------------------------------------
    %%Function: IncreaseChunkArrays
    %%Contact: igorzv

Parameters:
	plschunkcontext				-	(IN) chunk context

The difference from previous function is that we don't now final size 
and going to increase size step by step
----------------------------------------------------------------------------*/

static LSERR IncreaseChunkArrays(PLSCHUNKCONTEXT plschunkcontext)
{
/* arrays pfNonTextExpandAfter and pplsdnNonText should not be touched here:
   they are independable */

	DWORD cchnkMax;

	cchnkMax = plschunkcontext->cchnkMax + limAllDNodes;


	/* create arrays for chunks  */
	plschunkcontext->pplsdnChunk = plschunkcontext->plscbk->pfnReallocPtr(plschunkcontext->pols, 
											plschunkcontext->pplsdnChunk,
											sizeof(PLSDNODE)*cchnkMax);
	plschunkcontext->pcont = plschunkcontext->plscbk->pfnReallocPtr(plschunkcontext->pols,
											plschunkcontext->pcont, 
											sizeof(DWORD)*cchnkMax);
	plschunkcontext->locchnkCurrent.plschnk = plschunkcontext->plscbk->pfnReallocPtr(plschunkcontext->pols, 
											plschunkcontext->locchnkCurrent.plschnk,
											sizeof(LSCHNKE)*cchnkMax);
	plschunkcontext->locchnkCurrent.ppointUvLoc = plschunkcontext->plscbk->pfnReallocPtr(plschunkcontext->pols, 
											plschunkcontext->locchnkCurrent.ppointUvLoc,
											sizeof(POINTUV)*cchnkMax);
	plschunkcontext->pdurOpenBorderBefore = plschunkcontext->plscbk->pfnReallocPtr(plschunkcontext->pols, 
											plschunkcontext->pdurOpenBorderBefore,
											sizeof(LONG)*cchnkMax);
	plschunkcontext->pdurCloseBorderAfter = plschunkcontext->plscbk->pfnReallocPtr(plschunkcontext->pols, 
											plschunkcontext->pdurCloseBorderAfter,
											sizeof(LONG)*cchnkMax);

	if (plschunkcontext->pplsdnChunk == NULL || plschunkcontext->pcont == NULL
		|| plschunkcontext->locchnkCurrent.plschnk == NULL
		|| plschunkcontext->locchnkCurrent.ppointUvLoc == NULL
		|| plschunkcontext->pdurOpenBorderBefore == NULL
		|| plschunkcontext->pdurCloseBorderAfter == NULL
	   )
		return lserrOutOfMemory;

	plschunkcontext->cchnkMax = cchnkMax;

	return lserrNone;

}

/* D U P L I C A T E  C H U N K  C O N T E X T  */
/*----------------------------------------------------------------------------
    %%Function: DuplicateChunkContext
    %%Contact: igorzv

Parameters:
	plschunkcontextOld				-	(IN) chunk context to duplicate
	pplschunkcontextNew				-	(OUT) new chunk context 

----------------------------------------------------------------------------*/

LSERR DuplicateChunkContext(PLSCHUNKCONTEXT plschunkcontextOld, 
							PLSCHUNKCONTEXT* pplschunkcontextNew)
	{
	*pplschunkcontextNew = plschunkcontextOld->plscbk->pfnNewPtr(plschunkcontextOld->pols,
											sizeof(LSCHUNKCONTEXT));
	if (*pplschunkcontextNew == NULL)
		return lserrOutOfMemory;

	memcpy(*pplschunkcontextNew, plschunkcontextOld, sizeof(LSCHUNKCONTEXT));

	/* but we need to use new arrays */
	/* create arrays for chunks  */
	(*pplschunkcontextNew)->pplsdnChunk = (*pplschunkcontextNew)->plscbk->pfnNewPtr((*pplschunkcontextNew)->pols, 
											sizeof(PLSDNODE) * ((*pplschunkcontextNew)->cchnkMax));
	(*pplschunkcontextNew)->pcont = (*pplschunkcontextNew)->plscbk->pfnNewPtr((*pplschunkcontextNew)->pols, 
											sizeof(DWORD) * ((*pplschunkcontextNew)->cchnkMax));
	(*pplschunkcontextNew)->locchnkCurrent.plschnk =
					(*pplschunkcontextNew)->plscbk->pfnNewPtr((*pplschunkcontextNew)->pols, 
											sizeof(LSCHNKE) * ((*pplschunkcontextNew)->cchnkMax));
	(*pplschunkcontextNew)->locchnkCurrent.ppointUvLoc = 
					(*pplschunkcontextNew)->plscbk->pfnNewPtr((*pplschunkcontextNew)->pols, 
											sizeof(POINTUV) * ((*pplschunkcontextNew)->cchnkMax));
	(*pplschunkcontextNew)->pfNonTextExpandAfter = 
					(*pplschunkcontextNew)->plscbk->pfnNewPtr((*pplschunkcontextNew)->pols, 
											sizeof(BOOL) * ((*pplschunkcontextNew)->cNonTextMax));
	(*pplschunkcontextNew)->pplsdnNonText = 
					(*pplschunkcontextNew)->plscbk->pfnNewPtr((*pplschunkcontextNew)->pols, 
											sizeof(PLSDNODE) * ((*pplschunkcontextNew)->cNonTextMax));
	(*pplschunkcontextNew)->pdurOpenBorderBefore = 
					(*pplschunkcontextNew)->plscbk->pfnNewPtr((*pplschunkcontextNew)->pols, 
											sizeof(LONG) * ((*pplschunkcontextNew)->cchnkMax));
	(*pplschunkcontextNew)->pdurCloseBorderAfter = 
					(*pplschunkcontextNew)->plscbk->pfnNewPtr((*pplschunkcontextNew)->pols, 
											sizeof(LONG) * ((*pplschunkcontextNew)->cchnkMax));


	if ((*pplschunkcontextNew)->pplsdnChunk == NULL || (*pplschunkcontextNew)->pcont == NULL
		|| (*pplschunkcontextNew)->locchnkCurrent.plschnk == NULL
		|| (*pplschunkcontextNew)->locchnkCurrent.ppointUvLoc == NULL
		|| (*pplschunkcontextNew)->pfNonTextExpandAfter == NULL
		|| (*pplschunkcontextNew)->pplsdnNonText == NULL
		|| (*pplschunkcontextNew)->pdurOpenBorderBefore == NULL
		|| (*pplschunkcontextNew)->pdurCloseBorderAfter == NULL
	   )
		return lserrOutOfMemory;

	/* copy valid parts of the arrays */
	memcpy ((*pplschunkcontextNew)->pplsdnChunk, plschunkcontextOld->pplsdnChunk,
						plschunkcontextOld->locchnkCurrent.clschnk * sizeof(PLSDNODE));
	memcpy ((*pplschunkcontextNew)->pcont, plschunkcontextOld->pcont,
						plschunkcontextOld->locchnkCurrent.clschnk * sizeof(DWORD));
	memcpy ((*pplschunkcontextNew)->locchnkCurrent.plschnk, plschunkcontextOld->locchnkCurrent.plschnk,
						plschunkcontextOld->locchnkCurrent.clschnk * sizeof(LSCHNKE));
	memcpy ((*pplschunkcontextNew)->locchnkCurrent.ppointUvLoc, plschunkcontextOld->locchnkCurrent.ppointUvLoc,
						plschunkcontextOld->locchnkCurrent.clschnk * sizeof(POINTUV));
	memcpy ((*pplschunkcontextNew)->pfNonTextExpandAfter, plschunkcontextOld->pfNonTextExpandAfter,
						plschunkcontextOld->cNonTextMax * sizeof(BOOL));
	memcpy ((*pplschunkcontextNew)->pplsdnNonText, plschunkcontextOld->pplsdnNonText,
						plschunkcontextOld->cNonTextMax * sizeof(PLSDNODE));
	memcpy ((*pplschunkcontextNew)->pdurOpenBorderBefore, plschunkcontextOld->pdurOpenBorderBefore,
						plschunkcontextOld->locchnkCurrent.clschnk * sizeof(LONG));
	memcpy ((*pplschunkcontextNew)->pdurCloseBorderAfter, plschunkcontextOld->pdurCloseBorderAfter,
						plschunkcontextOld->locchnkCurrent.clschnk * sizeof(LONG));


	return lserrNone;

	}

/* D E S T R O Y  C H U N K  C O N T E X T  */
/*----------------------------------------------------------------------------
    %%Function: DestroyChunkContext
    %%Contact: igorzv

Parameters:
	plschunkcontext					-	(IN) chunk context to destroy

----------------------------------------------------------------------------*/

void DestroyChunkContext(PLSCHUNKCONTEXT plschunkcontext)
	{
	POLS pols = plschunkcontext->pols;
	LSCBK* plscbk = plschunkcontext->plscbk;
	DisposeChunkArrays(plschunkcontext);
	DebugMemset(plschunkcontext, 0xE9, sizeof(LSCHUNKCONTEXT));
	plscbk->pfnDisposePtr(pols, plschunkcontext);

	}


/* I N C R E A S E  G R O U P  C H U N K  N O N  T E X T  A R R A Y S  S I Z E   */
/*----------------------------------------------------------------------------
    %%Function: SetGroupChunkNonTextArraysSize
    %%Contact: igorzv

Parameters:
	plschunkcontext				-	(IN) chunk context

The difference from previous function is that we don't now final size 
and going to increase size step by step
----------------------------------------------------------------------------*/

static LSERR IncreaseGroupChunkNonTextArrays(PLSCHUNKCONTEXT plschunkcontext)
{

	DWORD cNonTextMax;

	cNonTextMax = plschunkcontext->cNonTextMax + limAllDNodes;


	/* create arrays for chunks  */
	plschunkcontext->pplsdnNonText = plschunkcontext->plscbk->pfnReallocPtr(plschunkcontext->pols, 
											plschunkcontext->pplsdnNonText,
											sizeof(PLSDNODE)*cNonTextMax);
	plschunkcontext->pfNonTextExpandAfter = plschunkcontext->plscbk->pfnReallocPtr(plschunkcontext->pols,
											plschunkcontext->pfNonTextExpandAfter, 
											sizeof(BOOL)*cNonTextMax);

	if (plschunkcontext->pplsdnNonText == NULL || plschunkcontext->pfNonTextExpandAfter == NULL)
		return lserrOutOfMemory;

	plschunkcontext->cNonTextMax = cNonTextMax;

	return lserrNone;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\autonum.c ===
#include	"lsidefs.h"
#include	"autonum.h"
#include	"lscbk.h"
#include	<limits.h>
#include	"lsmem.h"						/* memset() */
#include	"lsesc.h"
#include	"fmti.h"
#include	"objdim.h"
#include	"lscrsubl.h"
#include	"lssubset.h"
#include	"lsdnfin.h"
#include	"lsdssubl.h"
#include	"dispi.h"
#include	"lsdnode.h"
#include	"tabutils.h"
#include	"lscaltbd.h"
#include	"lstbcon.h"
#include	"lsdnset.h"
#include	"lsensubl.h"
#include	"dninfo.h"


struct ilsobj
{
    POLS				pols;
	LSCBK				lscbk;
	PLSC				plsc;
	DWORD				idObj;
	LSESC				lsescautonum;
};



struct dobj
{
	PILSOBJ				pilsobj;			/* ILS object */
	PLSSUBL				plssubl;			/* Handle to subline for autonumbering text */
};

		
#define ZeroMemory(a, b) memset(a, 0, b);

/* M A X */
/*----------------------------------------------------------------------------
    %%Macro: Max
    %%Contact: igorzv

	Returns the maximum of two values a and b.
----------------------------------------------------------------------------*/
#define Max(a,b)			((a) < (b) ? (b) : (a))


/* A U T O N U M  C R E A T E  I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: autonumCreateILSObj
	%%Contact: igorzv
	Parameters
	pols	-	(IN) client application context	
	plsc	-	(IN) ls context
	pclscbk	-	(IN) callbacks to client application
	idObj	-	(IN) id of the object
	ppilsobj-	(OUT)object ilsobj


	Create the ILS object for all autonumbering objects.
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumCreateILSObj(POLS pols,	PLSC plsc, 
				PCLSCBK pclscbk, DWORD idObj, PILSOBJ *ppilsobj)
{
    PILSOBJ pilsobj;


    pilsobj = pclscbk->pfnNewPtr(pols, sizeof(*pilsobj));

	if (NULL == pilsobj)
	{
		return lserrOutOfMemory;
	}

    pilsobj->pols = pols;
    pilsobj->lscbk = *pclscbk;
	pilsobj->plsc = plsc;
	pilsobj->idObj = idObj;

	*ppilsobj = pilsobj;
	return lserrNone;
}

/* S E T  A U T O N U M  C O N F I G */
/*----------------------------------------------------------------------------
	%%Function: SetAutonumConfig
	%%Contact: igorzv
	Parameters
	pilsobj			-	(IN) object ilsobj
	plstxtconfig	-	(IN) definition of special characters 

	Set ecs character for autonumbering sequence
----------------------------------------------------------------------------*/
LSERR  SetAutonumConfig(PILSOBJ pilsobj, const LSTXTCFG* plstxtconfig)
	{

	pilsobj->lsescautonum.wchFirst = plstxtconfig->wchEscAnmRun;
	pilsobj->lsescautonum.wchLast = plstxtconfig->wchEscAnmRun;

	return lserrNone;
	}

/* A U T O N U M   D E S T R O Y  I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: AutonumDestroyILSObj
	%%Contact: igorzv
	Parameters
	pilsobj			-	(IN) object ilsobj

	Free all resources assocaiated with autonum ILS object.
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumDestroyILSObj(PILSOBJ pilsobj)	
{
	pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pilsobj);
	return lserrNone;
}

/* A U T O N U M   S E T  D O C */
/*----------------------------------------------------------------------------
	%%Function: AutonumSetDoc
	%%Contact: igorzv
	Parameters
	pilsobj			-	(IN) object ilsobj
	pclsdocinf		-	(IN) initialization data of the document level

	Empty function
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumSetDoc(PILSOBJ pilsobj,	PCLSDOCINF pclsdocinf)		
{
	Unreferenced(pilsobj);
	Unreferenced(pclsdocinf);

	return lserrNone;
}


/* A U T O N U M   C R E A T E   L N O B J */
/*----------------------------------------------------------------------------
	%%Function: AutonumCreateLNObj
	%%Contact: igorzv
	Parameters
	pilsobj			-	(IN) object ilsobj
	pplnobj			-	(OUT)object lnobj

	Create the Line Object for the autonum. No real need for a line
	object so don't allocated it.
	
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumCreateLNObj(	PCILSOBJ pcilsobj, PLNOBJ *pplnobj)	
{
	*pplnobj = (PLNOBJ) pcilsobj;
	return lserrNone;
}

/* A U T O N U M  D E S T R O Y  L N O B J */
/*----------------------------------------------------------------------------
	%%Function: AautonumDestroyLNObj
	%%Contact: igorzv
	Parameters
	pplnobj			-	(IN) object lnobj


	Frees resources associated with the autonum line object. Since
	there isn't any this is a no-op.
	
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumDestroyLNObj(PLNOBJ plnobj)				

{
	Unreferenced(plnobj);
	return lserrNone;
}

/* A U T O N U M   F M T */
/*----------------------------------------------------------------------------
	%%Function: AutonumFmt
	%%Contact: igorzv
	Parameters
	pplnobj		-	(IN) object lnobj
	pcfmtin		-	(IN) formatting input
	pfmtres		-	(OUT)formatting result

	Format the autonum object. 
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumFmt(PLNOBJ plnobj, PCFMTIN pcfmtin,	FMTRES *pfmtres)	
{
	PDOBJ pdobj;
	LSERR lserr;
	PILSOBJ pilsobj = (PILSOBJ) plnobj;
	LSCP cpStartMain = pcfmtin->lsfgi.cpFirst;
	LSCP cpOut;
	LSTFLOW lstflow = pcfmtin->lsfgi.lstflow;
	FMTRES fmtres;
	OBJDIM objdimAll;
	LSDCP dcp;
	PLSDNODE plsdnFirst;
	PLSDNODE plsdnLast;
	BOOL fSuccessful;

    /*
     * Allocate the DOBJ
     */
    pdobj = pilsobj->lscbk.pfnNewPtr(pilsobj->pols, sizeof(*pdobj));

    if (NULL == pdobj)
		{
		return lserrOutOfMemory;
		}

	ZeroMemory(pdobj, sizeof(*pdobj));
	pdobj->pilsobj = pilsobj;

	/*
	 * Build main line of text
	 */

	lserr = LsCreateSubline(pilsobj->plsc, cpStartMain,	uLsInfiniteRM,
							lstflow, fFalse);	/*  because fContiguous is false 
												all tabs will be skipped*/ 
	if (lserr != lserrNone)
		{
		AutonumDestroyDobj(pdobj);
		return lserr;
		}

	lserr = LsFetchAppendToCurrentSubline(pilsobj->plsc, 0,	&(pilsobj->lsescautonum),
						    1, &fSuccessful, &fmtres,	&cpOut,	&plsdnFirst, &plsdnLast);

	/* because we formatting with uLsInfiniteRM margin result should be successful */

	if (lserr != lserrNone)
		{
		AutonumDestroyDobj(pdobj);
		return lserr;
		}

	if (fmtres != fmtrCompletedRun)
		{
		AutonumDestroyDobj(pdobj);
		return lserrInvalidAutonumRun;
		}

	lserr = LsFinishCurrentSubline(pilsobj->plsc, &(pdobj->plssubl));	

	if (lserr != lserrNone)
		{
		AutonumDestroyDobj(pdobj);
		return lserr;
		}

	// submit subline for display
	lserr = LsdnSubmitSublines(pilsobj->plsc, pcfmtin->plsdnTop,	
							1, &(pdobj->plssubl),
							fFalse, fFalse, fTrue, fFalse, fFalse);	
	if (lserr != lserrNone)
		{
		AutonumDestroyDobj(pdobj);
		return lserr;
		}

	/* 
	 *	Calculate the object dimensions.
	 */

	lserr = LssbGetObjDimSubline(pdobj->plssubl, &lstflow, &objdimAll);
	if (lserr != lserrNone)
		{
		AutonumDestroyDobj(pdobj);
		return lserr;
		}

	/* for multiline heights use ascent  */
	objdimAll.heightsRef.dvMultiLineHeight = objdimAll.heightsRef.dvAscent;
	objdimAll.heightsPres.dvMultiLineHeight = objdimAll.heightsPres.dvAscent;
	
	dcp = cpOut - cpStartMain + 1;  /* additional is esc character */
	
	lserr = LsdnFinishRegular(pilsobj->plsc, dcp, 
		pcfmtin->lsfrun.plsrun, pcfmtin->lsfrun.plschp, pdobj, 
			&objdimAll);

	if (lserr != lserrNone)
		{
		AutonumDestroyDobj(pdobj);
		return lserr;
		}
	

	*pfmtres = fmtrCompletedRun;

	return lserrNone;
}



/* A U T O N U M   G E T  S P E C I A L  E F F E C T S  I N S I D E */
/*----------------------------------------------------------------------------
	%%Function: AutonumGetSpecialEffectsInside
	%%Contact: igorzv
	Parameters
	pdobj			-	(IN) structure describes object
	*pEffectsFlags	-	(OUT)Special effects for this object
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumGetSpecialEffectsInside(PDOBJ pdobj, UINT *pEffectsFlags)	
{
	return LsGetSpecialEffectsSubline(pdobj->plssubl, pEffectsFlags);
}

/* A U T O N U M  C A L C  P R E S E N T A T I O N */
/*----------------------------------------------------------------------------
	%%Function: AutonumCalcPresentation
	%%Contact: igorzv
	Parameters
	pdobj			-	(IN) structure describes object
	dup				-	(IN) is not used
	lskj			-	(IN) current justification mode

	This just makes the line match the calculated presentation of the line.
	
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumCalcPresentation(PDOBJ pdobj, long dup, LSKJUST lskjust, BOOL fLastOnLine)	
{
	Unreferenced(dup);
	Unreferenced(lskjust);
	Unreferenced(fLastOnLine);

	return LsMatchPresSubline(pdobj->plssubl);

}

/* A U T O N U M  Q U E R Y  P O I N T  P C P */
/*----------------------------------------------------------------------------
	%%Function: AutonumQueryPointPcp
	%%Contact: igorzv

	Should never be called
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumQueryPointPcp(PDOBJ pdobj, PCPOINTUV ppointuvQuery,	
								  PCLSQIN plsqin, PLSQOUT plsqout)	
{
	Unreferenced(pdobj);
	Unreferenced(ppointuvQuery);
	Unreferenced(plsqin);
	Unreferenced(plsqout);

	NotReached();

	return lserrInvalidParameter;

}
	
/* A U T O N U M   Q U E R Y  C P  P P O I N T */
/*----------------------------------------------------------------------------
	%%Function: AutonumQueryCpPpoint
	%%Contact: igorzv

  Should never be called

----------------------------------------------------------------------------*/
LSERR WINAPI AutonumQueryCpPpoint(PDOBJ pdobj, LSDCP dcp,	
								  PCLSQIN plsqin, PLSQOUT plsqout)
{
	Unreferenced(pdobj);
	Unreferenced(dcp);
	Unreferenced(plsqin);
	Unreferenced(plsqout);

	NotReached();

	return lserrInvalidParameter;
}

/* A U T O N U M   T R U N C A T E  C H U N K */
/*----------------------------------------------------------------------------
	%%Function: AutonumTruncateChunk
	%%Contact: igorzv

  Should never be called

----------------------------------------------------------------------------*/
LSERR WINAPI AutonumTruncateChunk(PCLOCCHNK pclocchnk, PPOSICHNK pposichnk)
{
	Unreferenced(pclocchnk);
	Unreferenced(pposichnk);
	NotReached();

	return lserrInvalidParameter;
}	

/* A U T O N U M   F I N D  P R E V   B R E A K  C H U N K */
/*----------------------------------------------------------------------------
	%%Function: AutonumFindPrevBreakChunk
	%%Contact: igorzv

  Should never be called

----------------------------------------------------------------------------*/
LSERR WINAPI AutonumFindPrevBreakChunk(PCLOCCHNK pclocchnk, PCPOSICHNK pposichnk,
									   BRKCOND brkcond, PBRKOUT pbrkout)
{
	Unreferenced(pclocchnk);
	Unreferenced(pposichnk);
	Unreferenced(brkcond);
	Unreferenced(pbrkout);
	NotReached();

	return lserrInvalidParameter;
}	

/* A U T O N U M   F I N D  N E X T   B R E A K  C H U N K */
/*----------------------------------------------------------------------------
	%%Function: AutonumFindNextBreakChunk
	%%Contact: igorzv

  Should never be called

----------------------------------------------------------------------------*/
LSERR WINAPI AutonumFindNextBreakChunk(PCLOCCHNK pclocchnk, PCPOSICHNK pposichnk,
									   BRKCOND brkcond, PBRKOUT pbrkout)
{
	Unreferenced(pclocchnk);
	Unreferenced(pposichnk);
	Unreferenced(brkcond);
	Unreferenced(pbrkout);
	NotReached();

	return lserrInvalidParameter;
}	

/* A U T O N U M   F O R C E   B R E A K  C H U N K */
/*----------------------------------------------------------------------------
	%%Function: AutonumForceBreakChunk
	%%Contact: igorzv

  Should never be called

----------------------------------------------------------------------------*/
LSERR WINAPI AutonumForceBreakChunk(PCLOCCHNK pclocchnk, PCPOSICHNK pposichnk,
									   PBRKOUT pbrkout)
{
	Unreferenced(pclocchnk);
	Unreferenced(pposichnk);
	Unreferenced(pbrkout);
	NotReached();

	return lserrInvalidParameter;
}	

/* A U T O N U M   S E T   B R E A K   */
/*----------------------------------------------------------------------------
	%%Function: AutonumSetBreak
	%%Contact: igorzv

  Should never be called

----------------------------------------------------------------------------*/
LSERR WINAPI AutonumSetBreak(PDOBJ pdobj, BRKKIND brkkind, DWORD nbreakrecord,
							 BREAKREC* rgbreakrec, DWORD* pnactualbreakrecord)
{
	Unreferenced(pdobj);
	Unreferenced(brkkind);
	Unreferenced(rgbreakrec);
	Unreferenced(nbreakrecord);
	Unreferenced(pnactualbreakrecord);
	NotReached();

	return lserrInvalidParameter;
}	


/* A U T O N U M  D I S P L A Y */
/*----------------------------------------------------------------------------
	%%Function: AutonumDisplay
	%%Contact: igorzv
	Parameters
	pdobj		-	(IN) structure describes object
	pcdispin	-	(IN) info for display


	Displays subline	
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumDisplay(PDOBJ pdobj, PCDISPIN pcdispin)
{
	BOOL fDisplayed;

	LSERR lserr = LssbFDoneDisplay(pdobj->plssubl, &fDisplayed);

	if (lserr != lserrNone)
		{
		return lserr;
		}

	if (fDisplayed)
		{
		return lserrNone;
		}
	else
		{
		/* display the autonum line */
		return LsDisplaySubline(pdobj->plssubl, &(pcdispin->ptPen), pcdispin->kDispMode, 
			pcdispin->prcClip);
		}

}

/* A U T O N U M  D E S T R O Y  D O B J */
/*----------------------------------------------------------------------------
	%%Function: AutonumDestroyDobj
	%%Contact: igorzv
	Parameters
	pdobj		-	(IN) structure describes object

	Free all resources connected with the input dobj.
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumDestroyDobj(PDOBJ pdobj)
{
	LSERR lserr = lserrNone;
	PILSOBJ pilsobj = pdobj->pilsobj;

	if (pdobj->plssubl != NULL)
		{
		lserr = LsDestroySubline(pdobj->plssubl);
		}

    pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pdobj);
	return lserr;
}

/* A L L I G N  A U T O N U M  95 */
/*----------------------------------------------------------------------------
	%%Function: AllignAutonum95
	%%Contact: igorzv
	Parameters
	durSpaceAnm		-	(IN) space after autonumber
	durWidthAnm		-	(IN) distance from indent to main text
	lskalignAnM			-	(IN) allignment for autonumber
	plsdnAnmAfter	-	(IN) tab dnode to put durAfter
	durUsed			-	(IN)  width of autonumbering text
	pdurBefore		-	(OUT)calculated distance from indent to autonumber 
	pdurAfter		-	(OUT)calculated distance from autonumber to main text

	Calculates space before and after autonumber for the case Word95 model.
----------------------------------------------------------------------------*/
	
void AllignAutonum95(long durSpaceAnm, long durWidthAnm, LSKALIGN lskalignAnm,
					   long durUsed, PLSDNODE plsdnAnmAfter, long* pdurBefore, long* pdurAfter)
	{
	long durExtra;
	long durJust;
	long durRemain;
	
	durExtra = Max(0, durWidthAnm - durUsed);
	durRemain = Max(0, durExtra - durSpaceAnm);
	
	*pdurBefore = 0;
	
	switch (lskalignAnm)
		{
		case lskalLeft:
			*pdurAfter = Max(durSpaceAnm,durExtra);
			break;
			
		case lskalCentered:
			durJust = ((DWORD)durExtra) / 2;
			if (durJust >= durSpaceAnm)
				{
				*pdurBefore = durJust;
				*pdurAfter = durJust;			
				}
			else
				{
				/* Justified will not fit -- treat as flushleft */
				*pdurBefore = durRemain;
				*pdurAfter = durSpaceAnm;
				}
			break;
			
		case lskalRight:
			*pdurBefore = durRemain;
			*pdurAfter = durSpaceAnm;
			break;
			
		default:
			NotReached();
		}

	Assert(FIsDnodeReal(plsdnAnmAfter));
	Assert(plsdnAnmAfter->fTab);

	SetDnodeDurFmt(plsdnAnmAfter, *pdurAfter);
	plsdnAnmAfter->icaltbd = 0xFF;		/* spoil icaltbd */
	
	}


/* A L L I G N  A U T O N U M */
/*----------------------------------------------------------------------------
	%%Function: AllignAutonum
	%%Contact: igorzv
	Parameters
	plstabscontext	-	(IN) tabs context
	lskalignAnm			-	(IN) allignment for autonumber
	fAllignmentAfter-	(IN) is there tab after autonumber
	plsdnAnmAfter	-	(IN) tab dnode to put durAfter
	urAfterAnm		-	(IN) pen position after autonumber
	durUsed			-	(IN) width of autonumbering text
	pdurBefore		-	(OUT)calculated distance from indent to autonumber 
	pdurAfter		-	(OUT)calculated distance from autonumber to main text

	Calculates space before and after autonumber for the case Word95 model.
----------------------------------------------------------------------------*/
LSERR AllignAutonum(PLSTABSCONTEXT plstabscontext, LSKALIGN lskalignAnm, 
				   BOOL fAllignmentAfter, PLSDNODE plsdnAnmAfter,
				   long urAfterAnm, long durUsed,
				   long* pdurBefore, long* pdurAfter)
	{
	LSERR lserr;
	LSKTAB lsktab;
	BOOL fBreakThroughTab;
	LSCALTBD* plscaltbd;  
	
	/* resolving durBefore */
	
	switch (lskalignAnm)
		{
		case lskalLeft:
			*pdurBefore = 0;
			break;
			
		case lskalCentered:
			*pdurBefore = -durUsed/2;
			break;
			
		case lskalRight:
			*pdurBefore = -durUsed;
			break;
			
		default:
			NotReached();
		}
	
	
	/*	resolving  durAfter  */
	*pdurAfter = 0;
	if (fAllignmentAfter)
		{
		Assert(FIsDnodeReal(plsdnAnmAfter));
		Assert(plsdnAnmAfter->fTab);

		plsdnAnmAfter->fTabForAutonumber = fTrue;

		urAfterAnm += *pdurBefore; 
		
		lserr = GetCurTabInfoCore(plstabscontext, plsdnAnmAfter,	
					urAfterAnm,	fTrue, &lsktab, &fBreakThroughTab);
		if (lserr != lserrNone) 
			return lserr;
		
		plscaltbd = &(plstabscontext->pcaltbd[plsdnAnmAfter->icaltbd]);
		
		*pdurAfter = plsdnAnmAfter->u.real.objdim.dur;
		}
	return lserrNone;
	}

LSERR WINAPI AutonumEnumerate(PDOBJ pdobj, PLSRUN plsrun, PCLSCHP plschp, LSCP cpFirst, LSDCP dcp, 
					LSTFLOW lstflow, BOOL fReverseOrder, BOOL fGeometryProvided, 
					const POINT* pptStart, PCHEIGHTS pheightsPres, long dupRun)
				  
{

	Unreferenced(plschp);
	Unreferenced(plsrun);
	Unreferenced(cpFirst);
	Unreferenced(dcp);
	Unreferenced(lstflow);
	Unreferenced(fGeometryProvided);
	Unreferenced(pheightsPres);
	Unreferenced(dupRun);

	return LsEnumSubline(pdobj->plssubl, fReverseOrder,	fGeometryProvided,	
						 pptStart);	

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\break.c ===
#include "lsidefs.h"
#include "break.h"
#include "brko.h"
#include "chnutils.h"
#include "dninfo.h"
#include "dnutils.h"
#include "getfmtst.h"
#include "iobj.h"
#include "iobjln.h"
#include "locchnk.h"
#include "lsc.h"
#include "lsdnode.h"
#include "lsline.h"
#include "lstext.h"
#include "plocchnk.h"
#include "posichnk.h"
#include "setfmtst.h"
#include "posinln.h"
#include "lscfmtfl.h"

#include "lsmem.h"						/* memset() */
#include "limits.h"





static LSERR TruncateCore(  	
					PLSSUBL,				/* IN: subline where to find truncation point */
				  	long,					/* IN: urColumnMax				*/   
					POSINLINE*,				/* OUT:position of truncation point */
					BOOL*);					/* OUT:fAllLineAfterRightMargin */

 
static LSERR FindNextBreakCore(
						 long,				/* IN: urColumnMax				*/   
						 POSINLINE*,		/* IN: start break search       */
						 BOOL, 				/* IN: to apply rules for first character to 
											the first character of this subline */
						 BOOL,				/* IN: fStopped					*/
						 BRKOUT*,			/* OUT: breaking information 	*/
						 POSINLINE*,		/* OUT: position of break		*/
						 BRKKIND*);			/* OUT: how dnode was broken	*/

static LSERR FindPrevBreakCore(
						 long,				/* IN: urColumnMax				*/   
						 POSINLINE*,		/* IN: start break search       */
						 BOOL, 				/* IN: to apply rules for first character to 
											the first character of this subline */
						 BRKOUT*,			/* OUT: breaking information 	*/
						 POSINLINE*,		/* OUT: position of break		*/
						 BRKKIND*);			/* OUT: how dnode was broken	*/

static LSERR ForceBreakCore(
						 long,				/* IN: urColumnMax				*/   
						 POSINLINE*,		/* IN: where to do force break  */
						 BOOL,				/* IN: fStopped */
						 BOOL, 				/* IN: to apply rules for first character to 
											the first character of this subline */
						 BOOL,				/* IN: fAllLineAfterRightMargin	*/
						 BRKOUT*,			/* OUT: breaking information 	*/
						 POSINLINE*,		/* OUT: position of break		*/
						 BRKKIND*);			/* OUT: how dnode was broken	*/

static LSERR SetBreakCore(
						 POSINLINE*,		/* IN: where to do  break		*/
						 OBJDIM*,			/* IN: objdim of break dnode	*/
						 BRKKIND,			/* IN: how break was found */
						 BOOL,				/* IN fHardStop				*/
						 BOOL,			    /* IN: fGlueEop */
						 DWORD,				/* IN: size of the output array			*/
						 BREAKREC*,			/* OUT: output array of break records	*/
						 DWORD*,			/* OUT:actual number of records in array*/
						 LSCP*,				/* OUT: cpLim					*/
						 LSDCP*,			/* OUT dcpDepend				*/
						 ENDRES*,			/* OUT: endr					*/
						 BOOL*);			/* OUT fSuccessful: false means insufficient fetch */
				

static void 	GetPosInLineTruncateFromCp(
							PLSSUBL,		/* IN: subline						*/
							LSCP,			/* IN: cp of a position */
							BOOL,			/* direction of snaping */
							POSINLINE*	);	/* OUT: position in a subline */


static LSERR BreakTabPenSplat(
						 PLOCCHNK,	/* IN: chunk contains tab or pen */
						 BOOL,		/* IN: we are searching next break*/
						 BOOL,		/* IN: breakthrough tab	*/
						 BOOL,		/* IN: splat */
						 BRKCOND,	/* IN: condition of boundary break */
						 OBJDIM*,	/* IN: to fill in objdim of break */
						 BRKOUT*);	/* OUT: breaking information */

static LSERR ForceBreakTabPenSplat(
							  PLOCCHNK,	 /* IN: chunk contains tab or pen */
							  OBJDIM*,	 /* IN: to fill in objdim of break  */
							  BRKOUT*);	 /* OUT: breaking information */


static void FindFirstDnodeContainsRightMargin(
					long urColumnMax,				/* IN: position of right margin */
					POSINLINE* pposinlineTruncate); /* OUT: first dnode contains right margin */

static void ApplyBordersForTruncation(POSINLINE* pposinlineTruncate, /* IN, OUT: position of truncation point */
									  long* purColumnMaxTruncate, /* IN, OUT: position of right margin */
									  BOOL* pfTruncationFound); /* OUT: this procedure can find truncation itself */

static LSERR MoveClosingBorderAfterBreak(PLSSUBL plssubl,		/* IN subline */
										BOOL fChangeList, /* IN: do we need to change dnode list
										and change pplsdnBreak, or only to recalculate durBreak */
										PLSDNODE* pplsdnBreak, /* IN, OUT: break dnode */
										long* purBreak); /* IN, OUT: position after break */


static void	RemoveBorderDnodeFromList(PLSDNODE plsdnBorder); /*IN: border dnode */

static LSERR MoveBreakAfterPreviousDnode(
									PLSCHUNKCONTEXT plschunkcontext, /* chunk context */
									BRKOUT* pbrkout, /* IN,OUT brkout which can be changed */
									OBJDIM* pobjdimPrev, /* suggested objdim for the dnode in previous chunk 
														if NULL take objdim of dnode */
									BRKKIND*);			/* OUT: how dnode was broken	*/


#define FCompressionFlagsAreOn(plsc) \
			((plsc)->lsadjustcontext.lsbrj == lsbrjBreakWithCompJustify)

#define FCompressionPossible(plsc, fAllLineAfterRightMargin) \
			(FCompressionFlagsAreOn(plsc) && \
			 !FBreakthroughLine(plsc)  && \
			 !fAllLineAfterRightMargin)

#define GoPrevPosInLine(pposinline, fEndOfContent)  \
		if (((pposinline)->plsdn->plsdnPrev != NULL ) \
			&& !FIsNotInContent((pposinline)->plsdn->plsdnPrev)) \
			{\
			(pposinline)->plsdn = (pposinline)->plsdn->plsdnPrev; \
			Assert(FIsLSDNODE((pposinline)->plsdn)); \
			(pposinline)->dcp = (pposinline)->plsdn->dcp;\
			(pposinline)->pointStart.u -= DurFromDnode((pposinline)->plsdn); \
			(pposinline)->pointStart.v -= DvrFromDnode((pposinline)->plsdn); \
			(fEndOfContent) = fFalse; \
			}\
		else\
			{\
			(fEndOfContent) = fTrue; \
			}

#define GoNextPosInLine(pposinline)  \
		(pposinline)->pointStart.u += DurFromDnode((pposinline)->plsdn);\
		(pposinline)->pointStart.v += DvrFromDnode((pposinline)->plsdn);\
		(pposinline)->plsdn = (pposinline)->plsdn->plsdnNext;\
		Assert(FIsLSDNODE((pposinline)->plsdn));\
		(pposinline)->dcp = 0;\


#define GetCpLimFromPosInLine(posinline) \
			(((posinline).plsdn->dcp == (posinline).dcp) ? \
				((posinline).plsdn->cpLimOriginal) : \
				((posinline).plsdn->cpFirst + (posinline).dcp ))

#define		IsItTextDnode(plsdn, plsc) \
			((plsdn) == NULL) ? fFalse : \
			(IdObjFromDnode(plsdn) == IobjTextFromLsc(&plsc->lsiobjcontext))
			
#define	ResolvePosInChunk(plschunkcontext, posichnk, pposinline) \
					(pposinline)->dcp = (posichnk).dcp; \
					LocDnodeFromChunk((plschunkcontext), (posichnk).ichnk, \
							&((pposinline)->plsdn),&((pposinline)->pointStart)); 

#define GetCpFromPosInChunk(plschunkcontext, posichnk) \
		((DnodeFromChunk(plschunkcontext, (posichnk).ichnk))->cpFirst + (posichnk).dcp)

/* last two lines turn off check for lines ended with hard break and sublines ended
   by esc character */

#define GetBrkpos(plsdn, dcpBreak) \
((FIsFirstOnLine(plsdn)) && ((dcpBreak) == 0) ?  brkposBeforeFirstDnode :\
	((((plsdn)->plsdnNext == NULL) \
	  || (FIsDnodeCloseBorder((plsdn)->plsdnNext) && (plsdn)->plsdnNext->plsdnNext == NULL) \
	 ) \
	 && ((dcpBreak) == (plsdn)->dcp) \
    ) ? brkposAfterLastDnode : \
			brkposInside\
)

		 
#define EndrFromBreakDnode(plsdnBreak)\
	(plsdnBreak == NULL) ? endrStopped : \
		(plsdnBreak->fEndOfPara) ? endrEndPara : \
			(plsdnBreak->fAltEndOfPara) ? endrAltEndPara : \
				(plsdnBreak->fSoftCR) ? endrSoftCR : \
					(plsdnBreak->fEndOfColumn) ? endrEndColumn : \
						(plsdnBreak->fEndOfSection) ? endrEndSection : \
							(plsdnBreak->fEndOfPage) ? endrEndPage : \
								endrStopped

/* ---------------------------------------------------------------------- */

/* B R E A K  G E N E R A L  C A S E */
/*----------------------------------------------------------------------------
    %%Function: BreakGeneralCase
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	fHardStop		-	(IN) is formatting sopped because of hard break or special situation	
	breakrecMaxCurrent-	(IN) size of the array of current line's break records
	pbreakrecCurrent-	(OUT) current line's break records
	pbreakrecMacCurrent-(OUT) actual number of current line's break records 
	pdcpDepend		-	(OUT) dcpDepend		
	pCpLimLine 		-	(OUT) cpLimLine	
	pendr			-	(OUT) how the line ended
	pfSuccessful	-	(OUT) fSuccessful: false means insufficient fetch

    Main procedure of breaking
	Breaking can be unsuccessful if we didn't fetch enough
----------------------------------------------------------------------------*/
LSERR BreakGeneralCase(PLSC plsc, BOOL fHardStop, DWORD breakrecMaxCurrent,
					  BREAKREC* pbreakrecCurrent, DWORD* pbreakrecMacCurrent,
					  LSDCP* pdcpDepend, LSCP* pcpLimLine, ENDRES* pendr,
					  BOOL* pfSuccessful)		
{
	LSERR lserr;
	POSINLINE posinlineTruncate; /* position of truncation point */
	POSINLINE posinlineBreak; /* position of break point */
	BRKOUT brkout;
	GRCHUNKEXT grchnkextCompression;
	BOOL fCanCompress;
	long durToCompress;
	BOOL fLineCompressed;
	long durExtra;
	BOOL fEndOfContent;
	BOOL fAllLineAfterRightMargin;
	BRKKIND brkkindDnodeBreak;
	LSDCP dcpOld;
	PLSDNODE plsdnLastNotBorder;

	
	Assert(FBreakingAllowed(plsc));

	*pfSuccessful = fTrue;

	/* set flag how line was ended */   /*REVIEW*/
	if (!fHardStop)
		GetCurrentSubline(plsc)->fRightMarginExceeded = fTrue;
	
	if 	(GetCurrentDnode(plsc) == NULL) /* it  can happend with fmtrStopped */
		{
		*pdcpDepend = 0;
		*pcpLimLine = GetCurrentCpLim(plsc);
		*pendr = endrStopped;
		return lserrNone;
		}
	
	if (fHardStop && (GetCurrentUr(plsc) <= plsc->urRightMarginBreak))
	/* we have hard break before right margin or there is no content in a line, 
	so break is found */
		{
		posinlineBreak.plssubl = GetCurrentSubline(plsc);
		GetCurrentPoint(plsc, posinlineBreak.pointStart);
		posinlineBreak.plsdn = GetCurrentDnode(plsc);
		GetPointBeforeDnodeFromPointAfter(posinlineBreak.plsdn, &(posinlineBreak.pointStart));
		posinlineBreak.dcp = posinlineBreak.plsdn->dcp;
		/* skip back closing border after hard break */
		while (FIsDnodeBorder(posinlineBreak.plsdn))
			{
			GoPrevPosInLine(&posinlineBreak, fEndOfContent);
			Assert(!fEndOfContent);
			}

		brkout.objdim = posinlineBreak.plsdn->u.real.objdim;

		return SetBreakCore(&posinlineBreak, &brkout.objdim, brkkindImposedAfter, 
							 fHardStop, fTrue, breakrecMaxCurrent, pbreakrecCurrent, 
							 pbreakrecMacCurrent, pcpLimLine, 
							 pdcpDepend, pendr, pfSuccessful);	
		}

	Assert(GetCurrentDnode(plsc) != NULL); /* case of empty list - end of section in the begining
											  of a line should be handled in previous if */

	lserr = TruncateCore(GetCurrentSubline(plsc), plsc->urRightMarginBreak,
						 &posinlineTruncate, &fAllLineAfterRightMargin);		
	if (lserr != lserrNone)
		{
		return lserr;
		}
	
	Assert(!FIsNotInContent(posinlineTruncate.plsdn));
      	
	if (FCompressionPossible(plsc, fAllLineAfterRightMargin))
   		{
		 
        lserr = FindNextBreakCore(plsc->urRightMarginBreak, &posinlineTruncate,	fTrue,
					  fHardStop, &brkout, &posinlineBreak, &brkkindDnodeBreak);	
		if (lserr != lserrNone)
			{
			return lserr;
			}
		
		InitGroupChunkExt(PlschunkcontextFromSubline(GetCurrentSubline(plsc)),
						IobjTextFromLsc(&plsc->lsiobjcontext), &grchnkextCompression);


		if (!brkout.fSuccessful)     
			{
		/* we can't find break and if we still can compress the amount that is over right
		   margin we should fetch more  */
			plsdnLastNotBorder = LastDnodeFromChunk(PlschunkcontextFromSubline(GetCurrentSubline(plsc)));
			Assert(!FIsDnodeBorder(plsdnLastNotBorder));
			/* last dnode from chunk which was collected in FindNextBreak will give us last not border dnode,
			we should store it before we change chunk context */

			lserr = CollectPreviousTextGroupChunk(GetCurrentDnode(plsc), CollectSublinesForCompression,
										  FAllSimpleText(plsc),
										  &grchnkextCompression);
			if (lserr != lserrNone)
				return lserr;

			durToCompress = GetCurrentUr(plsc) - plsc->urRightMarginBreak
								- grchnkextCompression.durTrailing;

			if ((brkout.brkcond == brkcondPlease || brkout.brkcond == brkcondCan)
				&& FIsDnodeReal(plsdnLastNotBorder)
			   )
				{
				/* In such case if we fetch more break may be possible after last dnode with also
				possible dur. So in our optimization check we are taking min from two durs */
				if (brkout.objdim.dur < DurFromDnode(plsdnLastNotBorder))
					{
					durToCompress -= (DurFromDnode(plsdnLastNotBorder) - brkout.objdim.dur);
					}
				}

			if (FDnodeHasBorder(grchnkextCompression.plsdnStartTrailing)
				&& !grchnkextCompression.fClosingBorderStartsTrailing)
				{
				/* we should reserve room for closing border */
				/* if border is not exactly before trailing area it was counted as a part of durTrailing
				   so we should add it again */
				durToCompress += DurBorderFromDnodeInside(grchnkextCompression.plsdnStartTrailing);
				}

			lserr = CanCompressText(&(grchnkextCompression.lsgrchnk), 
							&(grchnkextCompression.posichnkBeforeTrailing),
							LstflowFromSubline(GetCurrentSubline(plsc)),
							durToCompress,	&fCanCompress,
							&fLineCompressed, &durExtra);
			if (lserr != lserrNone)
				return lserr;
		
			
			if (fCanCompress)
				{
				/* increase right margin and fetch more */
				*pfSuccessful = fFalse;
				return lserrNone;
				}
			}
		else
			{

			/* temporary change dcp in break dnode */
			dcpOld = posinlineBreak.plsdn->dcp;
			posinlineBreak.plsdn->dcp = posinlineBreak.dcp;

			lserr = CollectPreviousTextGroupChunk(posinlineBreak.plsdn, CollectSublinesForCompression,
										FAllSimpleText(plsc),
										&grchnkextCompression);
			if (lserr != lserrNone)
				return lserr;

			durToCompress = posinlineBreak.pointStart.u + brkout.objdim.dur 
								- plsc->urRightMarginBreak
								- grchnkextCompression.durTrailing;

			if (posinlineBreak.plsdn->plsdnNext != NULL && 
				FIsDnodeCloseBorder(posinlineBreak.plsdn->plsdnNext))
				{
				/* closing border after dnode is a part of collected group chunk
				 so can participate in durTrailing see also calculation below */
				 durToCompress += DurFromDnode(posinlineBreak.plsdn->plsdnNext);
				}

			if (FDnodeHasBorder(grchnkextCompression.plsdnStartTrailing) 
				&& !grchnkextCompression.fClosingBorderStartsTrailing)
				{
				/* we should reserve room for closing border */
				/* if closing border is right after non trailing area we already counted it */
				durToCompress += DurBorderFromDnodeInside(grchnkextCompression.plsdnStartTrailing);
				}

			/* restore dcp in break dnode */
			posinlineBreak.plsdn->dcp = dcpOld;

			lserr = CanCompressText(&(grchnkextCompression.lsgrchnk), 
							&(grchnkextCompression.posichnkBeforeTrailing),
							LstflowFromSubline(GetCurrentSubline(plsc)),
 							durToCompress, &fCanCompress, &fLineCompressed, &durExtra);
			if (lserr != lserrNone)
				return lserr;
		
	        
			if (fCanCompress) 
				{
				SetLineCompressed(plsc, fLineCompressed);
				return SetBreakCore(&posinlineBreak, &brkout.objdim, brkkindDnodeBreak,
							 fHardStop, fTrue, breakrecMaxCurrent, pbreakrecCurrent, 
							 pbreakrecMacCurrent, pcpLimLine,
							 pdcpDepend, pendr, pfSuccessful);	
				}
			}
		}  /* FCompressionPossible */


	if (!fAllLineAfterRightMargin) 
	/* opposite is possible if we have left indent or auto number bigger then right margin */
	/* then we go to the force break */
		{
	
    	lserr = FindPrevBreakCore(plsc->urRightMarginBreak, &posinlineTruncate,	fTrue,
					  &brkout, &posinlineBreak, &brkkindDnodeBreak);	

		if (lserr != lserrNone)
			{
			return lserr;
			}
	
		if (brkout.fSuccessful) 
			{
			return SetBreakCore(&posinlineBreak, &brkout.objdim, brkkindDnodeBreak,
							 fHardStop, fTrue, breakrecMaxCurrent, pbreakrecCurrent, 
							 pbreakrecMacCurrent, pcpLimLine, 
							 pdcpDepend, pendr, pfSuccessful);	
			}

      	}


	/*   handling line without break opportunity   ( force break )   */
	plsc->plslineCur->lslinfo.fForcedBreak = fTrue;

	lserr = ForceBreakCore (plsc->urRightMarginBreak, &posinlineTruncate,
						fHardStop, fTrue, fAllLineAfterRightMargin,
						&brkout, &posinlineBreak, &brkkindDnodeBreak);	

	if (lserr != lserrNone)
		{
		return lserr;
		}

	/* not successful return means insufficient fetch */
	if (!brkout.fSuccessful)
		{
		*pfSuccessful = fFalse;
		return lserrNone;
		}


	return SetBreakCore(&posinlineBreak, &brkout.objdim, brkkindDnodeBreak, 
							 fHardStop, fTrue, breakrecMaxCurrent, pbreakrecCurrent, 
							 pbreakrecMacCurrent, pcpLimLine,
							 pdcpDepend, pendr, pfSuccessful);
}



/* ---------------------------------------------------------------------- */

/* T R U N C A T E  C O R E */
/*----------------------------------------------------------------------------
    %%Function: TruncateCore
    %%Contact: igorzv
Parameters:
	plssubl				-	(IN) subline where to find truncation point
	urColumnMax			-	(IN) position of right margin
	pposinlineTruncate	-	(OUT) position of truncation point
	pfAllLineAfterRightMargin(OUT) because of left indent or autonumber all line is
								  after right margin

Find dnode that exceeds right margin and then asked it's handler to find 
truncation point
----------------------------------------------------------------------------*/
LSERR TruncateCore(PLSSUBL plssubl, long urColumnMax,  
					POSINLINE* pposinlineTruncate, BOOL* pfAllLineAfterRightMargin)				

{
	LSERR lserr;
	DWORD idObj;
	POINTUV point;
	POSICHNK posichnk;
	PLSCHUNKCONTEXT plschunkcontext;
	LOCCHNK* plocchnk;
	PLSC plsc = plssubl->plsc;
	PLSSUBL plssublOld;
	long urColumnMaxTruncate;
	BOOL fEndOfContent;
	BOOL fTruncationFound = fFalse;
	
	Assert(FBreakingAllowed(plsc));
	Assert((pposinlineTruncate != NULL) ); 

	plschunkcontext = PlschunkcontextFromSubline(plssubl);
	plocchnk = &(plschunkcontext->locchnkCurrent);
	
	GetCurrentPointSubl(plssubl, point);
	/* length of the subline should be larger then lenght of the column */
	Assert(point.u >= urColumnMax);

	pposinlineTruncate->plssubl = plssubl;
	pposinlineTruncate->pointStart = point;
	pposinlineTruncate->plsdn = GetCurrentDnodeSubl(plssubl);
	GetPointBeforeDnodeFromPointAfter(pposinlineTruncate->plsdn, &(pposinlineTruncate->pointStart));
	pposinlineTruncate->dcp = 0;


	/* find dnode contains right margin */
	if (!plsc->fAdvanceBack)
		{
		fEndOfContent = fFalse;
		while ((pposinlineTruncate->pointStart.u > urColumnMax)
			&& !fEndOfContent)
			{
			GoPrevPosInLine(pposinlineTruncate, fEndOfContent);
			}
		}
	else
		{
		/* in this case there is possible to have more then one dnode that contains right margin*/
		/* so we call more comprehensive procedure to find exactly the first one */
		FindFirstDnodeContainsRightMargin(urColumnMax, pposinlineTruncate);
		}

	*pfAllLineAfterRightMargin = fFalse;
	if (pposinlineTruncate->pointStart.u > urColumnMax) 
		{
		*pfAllLineAfterRightMargin = fTrue;
		}

		
	urColumnMaxTruncate = urColumnMax;
	if (FDnodeHasBorder(pposinlineTruncate->plsdn))
		{
		ApplyBordersForTruncation(pposinlineTruncate, &urColumnMaxTruncate, 
								  &fTruncationFound);
		}

	if (!fTruncationFound)
		{
		/* if pen or tab or we don't find dnode that starts before right margin return immediately */
		/* last case possible if we have left indent or auto number bigger then right margin */
		if (FIsDnodePen(pposinlineTruncate->plsdn) || pposinlineTruncate->plsdn->fTab || 
			FIsDnodeSplat(pposinlineTruncate->plsdn) ||
			pposinlineTruncate->pointStart.u > urColumnMaxTruncate)
			{
			return lserrNone;
			}
		
		SetUrColumnMaxForChunks(plschunkcontext, urColumnMaxTruncate);  
		
		lserr = CollectChunkAround(plschunkcontext, pposinlineTruncate->plsdn,
			pposinlineTruncate->plssubl->lstflow, 
			&pposinlineTruncate->pointStart);
		if (lserr != lserrNone)
			return lserr;
		
		idObj = IdObjFromChnk(plocchnk);
		
		/* we allow object handler to formate subline,
		so we restore current subline after calling him */
		plssublOld = GetCurrentSubline(plsc);
		SetCurrentSubline(plsc, NULL);
		
		lserr = PLsimFromLsc(&plsc->lsiobjcontext, idObj)->pfnTruncateChunk(
			plocchnk, &posichnk);
		if (lserr != lserrNone)
			return lserr;
		
		SetCurrentSubline(plsc, plssublOld);
		
		ResolvePosInChunk(plschunkcontext, posichnk, pposinlineTruncate); 
		
		
		/* if text sets truncation point before him, then move it after previous dnode */
		if (pposinlineTruncate->dcp == 0)
			{
			/* we allow this only for text */
			if (idObj == IobjTextFromLsc(&plsc->lsiobjcontext))
				{
				do
					{
					GoPrevPosInLine(pposinlineTruncate, fEndOfContent);
					Assert(!fEndOfContent); 
					/* such situation cann't occurs on the boundary of chunck */
					}
					while (FIsDnodeBorder(pposinlineTruncate->plsdn));
				}
			else
				{
				return lserrWrongTruncationPoint;
				}
			}
		}
	
	return lserrNone;
}

/* ---------------------------------------------------------------------- */

/* A P P L Y  B O R D E R S  F O R  T R U N C A T I O N */
/*----------------------------------------------------------------------------
    %%Function: ApplyBordersForTruncation
    %%Contact: igorzv
Parameters:
	pposinlineTruncate		-	(IN, OUT) position of truncation point
	purColumnMax			-	(IN, OUT) position of right margin
	pfTruncationFound		-	(OUT) this procedure can find truncation itself 

Change right margin because of border and find dnode to call truncation method.
----------------------------------------------------------------------------*/
static void ApplyBordersForTruncation(POSINLINE* pposinlineTruncate, 
									  long* purColumnMaxTruncate, BOOL* pfTruncationFound)
	{
	long durBorder;
	BOOL fEndOfContent = fFalse;
	PLSDNODE plsdn;

	*pfTruncationFound = fFalse;
	
	/* go back until open border or autonumber */ 
	if (FIsDnodeOpenBorder(pposinlineTruncate->plsdn))
		{
		/* move after border */
		durBorder = pposinlineTruncate->plsdn->u.pen.dur;
		GoNextPosInLine(pposinlineTruncate);
		Assert(!FIsDnodeBorder(pposinlineTruncate->plsdn)); 
		/* we should not have empty list between borders */
		}
	else
		{
		while (!FIsDnodeOpenBorder(pposinlineTruncate->plsdn->plsdnPrev) && !fEndOfContent)
			{
			GoPrevPosInLine(pposinlineTruncate, fEndOfContent);
			}
		if (!fEndOfContent)  /* we stopped on opening border */
			{
			Assert(pposinlineTruncate->plsdn->plsdnPrev);
			durBorder = pposinlineTruncate->plsdn->plsdnPrev->u.pen.dur;
			}
		else
			{
			/* we stopped because of autonumber */
			/* now we only need to take width of border from border dnode which located before 
			autonumber */
			plsdn = pposinlineTruncate->plsdn->plsdnPrev;
			while (!FIsDnodeOpenBorder(plsdn))
				{
				plsdn = plsdn->plsdnPrev;
				Assert(FIsLSDNODE(plsdn));
				}
			durBorder = plsdn->u.pen.dur;
			}
		}
	
	/* do we have enough room to put both opening and closing border */
	if (pposinlineTruncate->pointStart.u + durBorder <= *purColumnMaxTruncate)
		{
		/* if yes decrease margin and find new truncation dnode */
		*purColumnMaxTruncate -= durBorder;
		while (pposinlineTruncate->pointStart.u + DurFromDnode(pposinlineTruncate->plsdn)
			<= *purColumnMaxTruncate)
			{
			GoNextPosInLine(pposinlineTruncate);
			Assert(!FIsDnodeBorder(pposinlineTruncate->plsdn));
			/* this assert can be proved using the fact that end of closing border is beyond 
			original right margin */
			}
		}
	else
		{
		/* set truncation as the first character of this dnode */
		*pfTruncationFound = fTrue;
		pposinlineTruncate->dcp = 1;
		}
	}


/* ---------------------------------------------------------------------- */

/*  F I N D  P R E V  B R E A K  C O R E */
/*----------------------------------------------------------------------------
    %%Function: FindPrevBreakCore
    %%Contact: igorzv
Parameters:
	urColumnMax		-		(IN) width of column
	pposinlineTruncate -	(IN) position of truncation point
	fFirstSubline	-		(IN) to apply rules for first character to the first character of
							 this subline 
	pbrkout			-		(OUT)breaking information
	pposinlineBreak	-		(OUT)position of breaking point
	pbrkkindDnodeBreak	-	(OUT) how break was found

Going backword try to find first break opportunity before truncation point
----------------------------------------------------------------------------*/


LSERR FindPrevBreakCore( long urColumnMax,
						 POSINLINE* pposinlineTruncate, BOOL fFirstSubline,
						 BRKOUT* pbrkout, POSINLINE* pposinlineBreak,
						 BRKKIND* pbrkkindDnodeBreak)	
	{
	
	LSERR lserr;
	DWORD idObj;
	POSICHNK posichnk;
	BOOL fFound;
	PLSDNODE plsdn;
	PLSCHUNKCONTEXT plschunkcontext;
	LOCCHNK* plocchnk;
	BRKCOND brkcond;
	PLSC plsc = pposinlineTruncate->plssubl->plsc;
	POINTUV pointChunkStart;
	PLSSUBL plssublOld;
	
	
	Assert(FBreakingAllowed(plsc));
	Assert(FIsLSDNODE(pposinlineTruncate->plsdn));
	Assert(pposinlineBreak != NULL);

	*pbrkkindDnodeBreak = brkkindPrev;
	
	plschunkcontext = PlschunkcontextFromSubline(pposinlineTruncate->plssubl);
	plocchnk = &(plschunkcontext->locchnkCurrent);
	
	SetUrColumnMaxForChunks(plschunkcontext, urColumnMax);  

	Assert(!FIsDnodeBorder(pposinlineTruncate->plsdn));
	
	lserr = CollectChunkAround(plschunkcontext, pposinlineTruncate->plsdn,
		pposinlineTruncate->plssubl->lstflow, 
		&pposinlineTruncate->pointStart);
	if (lserr != lserrNone)
		return lserr;

	/* set fFirstOnLine */
	ApplyFFirstSublineToChunk(plschunkcontext, fFirstSubline);
	
	SetPosInChunk(plschunkcontext, pposinlineTruncate->plsdn, pposinlineTruncate->dcp, &posichnk);
	
	fFound = fTrue;
	
	/* for the chunk around truncation point we allow to make break after if it's text and
	   don't allow otherwise.
	   REVIEW:Such decision simplifyes code but produces some problems 
	   (with objects known so far more theoretical then practical).
	   There are two bad cases: non-text after text which (non-text) prohibites to break before
	and text which allowes to break*/
	
	idObj = IdObjFromChnk(plocchnk);
	
	if (idObj == IobjTextFromLsc(&plsc->lsiobjcontext))
		brkcond = brkcondCan;
	else
		brkcond = brkcondNever;
	
	while (fFound)
		{ 
		Assert(NumberOfDnodesInChunk(plocchnk) != 0);
		plsdn = plschunkcontext->pplsdnChunk[0];
		GetPointChunkStart(plocchnk, pointChunkStart);
		
		
		if (FIsDnodePen(plsdn) || plsdn->fTab || FIsDnodeSplat(plsdn))
			{
			Assert(NumberOfDnodesInChunk(plocchnk) == 1);
			/* only advance pen is allowed here */
			Assert(!FIsDnodePen(plsdn) || plsdn->fAdvancedPen);
			/* for the case of a pen we are passing garbage as an objdim 
			here assuming that it never be used */
			lserr = BreakTabPenSplat(plocchnk, fFalse, FBreakthroughLine(plsc),
									FIsDnodeSplat(plsdn), brkcond, 
									&(plsdn->u.real.objdim), pbrkout);
			if (lserr != lserrNone)
				return lserr;
			}
		else
			{
			
			idObj = IdObjFromDnode(plsdn);
			
			
			/* we allow object handler to formate subline,
			so we restore current subline after calling him */
			plssublOld = GetCurrentSubline(plsc);
			SetCurrentSubline(plsc, NULL);
			
			lserr = PLsimFromLsc(&plsc->lsiobjcontext, idObj)->pfnFindPrevBreakChunk(plocchnk,  
								&posichnk, brkcond, pbrkout);
			if (lserr != lserrNone)
				return lserr;
			
			SetCurrentSubline(plsc, plssublOld);

			
			} /* non tab */
		
		if (pbrkout->fSuccessful)  break;
		
		/* prepare next iteration */
		lserr = CollectPreviousChunk(plschunkcontext, &fFound);
		if (lserr != lserrNone)
			return lserr;
		
		if (fFound) 
			{
			posichnk.ichnk = ichnkOutside;
			/* posichnk.dcp is invalid */
			/* prepare brkcond for next iteration */
			brkcond = pbrkout->brkcond;
			}
		
		}  /* while */
	
	
	if (pbrkout->fSuccessful)
		{
		pposinlineBreak->plssubl = pposinlineTruncate->plssubl;


		if (pbrkout->posichnk.dcp == 0 && FIsDnodeReal(plschunkcontext->pplsdnChunk[0]))
			/* break before dnode */
			{
			lserr = MoveBreakAfterPreviousDnode(plschunkcontext, pbrkout, NULL, pbrkkindDnodeBreak); 
			/* this procedure can change chunkcontext */
			if (lserr != lserrNone)
				return lserr;

			}

		ResolvePosInChunk(plschunkcontext, (pbrkout->posichnk), pposinlineBreak);

		}
	
	
	return lserrNone;
	
}

/* ---------------------------------------------------------------------- */

/*  F I N D  N E X T  B R E A K  C O R E */
/*----------------------------------------------------------------------------
    %%Function: FindNextBreakCore
    %%Contact: igorzv
Parameters:
	urColumnMax		-		(IN) width of column
	pposinlineTruncate -	(IN) position of truncation point
	fFirstSubline	-		(IN) to apply rules for first character to the first character of
							 this subline 
	fStopped		-		(IN) formatting has been stopped by client
	pbrkout			-		(OUT) breaking information
	pposinlineBreak	-		(OUT) position of breaking point
	pbrkkindDnodeBreak	-	(OUT) how break was found

Going forward try to find first break opportunity after truncation point

----------------------------------------------------------------------------*/


LSERR FindNextBreakCore( long urColumnMax,  
						 POSINLINE* pposinlineTruncate, BOOL fFirstSubline, BOOL fStopped,
						 BRKOUT* pbrkout, POSINLINE* pposinlineBreak, BRKKIND* pbrkkindDnodeBreak)	

{

	LSERR lserr;
	DWORD idObj;
	POSICHNK posichnk;
	BOOL fFound;
	PLSDNODE plsdn;
	PLSCHUNKCONTEXT plschunkcontext;
	LOCCHNK* plocchnk;
	BRKCOND brkcond;
	PLSC plsc = pposinlineTruncate->plssubl->plsc;
	POINTUV pointChunkStart;
	PLSSUBL plssublOld;
	OBJDIM objdimPrevious;

	Assert(FBreakingAllowed(plsc));
	Assert(FIsLSDNODE(pposinlineTruncate->plsdn));
	Assert(pposinlineBreak != NULL);

	*pbrkkindDnodeBreak = brkkindNext;

	plschunkcontext = PlschunkcontextFromSubline(pposinlineTruncate->plssubl);
	plocchnk = &(plschunkcontext->locchnkCurrent);
	
	SetUrColumnMaxForChunks(plschunkcontext, urColumnMax); /* will be used by LsdnCheckAvailableSpace */ 

	Assert(!FIsDnodeBorder(pposinlineTruncate->plsdn));

	lserr = CollectChunkAround(plschunkcontext, pposinlineTruncate->plsdn,
							  pposinlineTruncate->plssubl->lstflow, 
							  &pposinlineTruncate->pointStart);
	if (lserr != lserrNone)
		return lserr;

	/* set fFirstOnLine */
	ApplyFFirstSublineToChunk(plschunkcontext, fFirstSubline);

	SetPosInChunk(plschunkcontext, pposinlineTruncate->plsdn,
				  pposinlineTruncate->dcp, &posichnk);

	fFound = fTrue;

	/* for the chunk around truncation point we prohibite to make break before */
	brkcond = brkcondNever;

	while (fFound)
		{ 
		Assert(NumberOfDnodesInChunk(plocchnk) != 0);
		plsdn = plschunkcontext->pplsdnChunk[0];

		GetPointChunkStart(plocchnk, pointChunkStart);
			
		if (FIsDnodePen(plsdn) || plsdn->fTab || FIsDnodeSplat(plsdn))
			{
			Assert(NumberOfDnodesInChunk(plocchnk) == 1);
			/* only advance pen is allowed here */
			Assert(!FIsDnodePen(plsdn) || plsdn->fAdvancedPen);
			/* for the case of a pen we are passing garbage as an objdim 
			here assuming that it never be used */
			lserr = BreakTabPenSplat(plocchnk, fTrue, FBreakthroughLine(plsc),
									FIsDnodeSplat(plsdn), brkcond, 
									&(plsdn->u.real.objdim), pbrkout);
			if (lserr != lserrNone)
				return lserr;
			}
		else
			{
			idObj = IdObjFromChnk(plocchnk);


			/* we allow object handler to formate subline,
			so we restore current subline after calling him */
			plssublOld = GetCurrentSubline(plsc);
			SetCurrentSubline(plsc, NULL);

			lserr = PLsimFromLsc(&plsc->lsiobjcontext, idObj)->pfnFindNextBreakChunk(plocchnk, 
				&posichnk, brkcond, pbrkout);
			if (lserr != lserrNone)
				return lserr;


			SetCurrentSubline(plsc, plssublOld);
			
			/* We ignore returned objdim in a case of brkcondNever. We don't expect 
			object to set correct one */
			if (!pbrkout->fSuccessful && pbrkout->brkcond == brkcondNever)
				pbrkout->objdim = (LastDnodeFromChunk(plschunkcontext))->u.real.objdim; 

				
			}  /* non tab */

		if (pbrkout->fSuccessful)  break;

		
		lserr = CollectNextChunk(plschunkcontext, &fFound);
		if (lserr != lserrNone)
			return lserr;

		if (fFound) 
			{
			posichnk.ichnk = ichnkOutside;
			/* posichnk.dcp is invalid */
			/* prepare brkcond for next iteration */
			brkcond = pbrkout->brkcond;
			/* we save objdim and trailing info for the case when next object 
			returns break before and we actually will set break in current object. */
			objdimPrevious = pbrkout->objdim;
			}

		}

	/* we cannot find break but formatting has been stopped by client */
	if (fStopped && !pbrkout->fSuccessful)
		{
		/* set break after last dnode */
		PosInChunkAfterChunk(plocchnk, pbrkout->posichnk);
		pbrkout->objdim = 
			(LastDnodeFromChunk(plschunkcontext))->u.real.objdim; 
		 /* We should use last dnode in chunk here to be sure not to get closing border.
		In the case of pen it's garbage, we assume that will not be used */
		pbrkout->fSuccessful = fTrue;
		}

	if (pbrkout->fSuccessful)
		{

		pposinlineBreak->plssubl = pposinlineTruncate->plssubl;
		if (pbrkout->posichnk.dcp == 0 && FIsDnodeReal(plschunkcontext->pplsdnChunk[0]))
			/* break before dnode */
			{
			lserr = MoveBreakAfterPreviousDnode(plschunkcontext, pbrkout, &objdimPrevious, pbrkkindDnodeBreak); 
			/* this procedure can change chunkcontext */
			if (lserr != lserrNone)
				return lserr;
			/* REVIEW: Is it possible to have garbage in objdimPrevious (somebody break brkcond */
			
			}
		
		ResolvePosInChunk(plschunkcontext, (pbrkout->posichnk), pposinlineBreak); 
		

		}
	else
		{
		}

	return lserrNone;
}


/* ---------------------------------------------------------------------- */

/*  F O R C E  B R E A K  C O R E */
/*----------------------------------------------------------------------------
    %%Function: ForceBreakCore
    %%Contact: igorzv
Parameters:
	urColumnMax		-		(IN) width of column
	pposinlineTruncate -	(IN) position of truncation point
	fStopped			-	(IN) formatting ended with hard break
	fFirstSubline	-		(IN) to apply rules for first character to the first character of
							 this subline 
	fAllLineAfterRightMargin(IN) lead to pass chunk otside in force break methods.
	pbrkout			-		(OUT)breaking information
	pposinlineBreak	-		(OUT)position of breaking point
	pbrkkindDnodeBreak	-	(OUT) how break was found

Invokes force break of chunk around truncation point
----------------------------------------------------------------------------*/



LSERR ForceBreakCore(
					 long urColumnMax,	
					 POSINLINE* pposinlineTruncate, 
					 BOOL fStopped, BOOL fFirstSubline,
					 BOOL fAllLineAfterRightMargin,
					 BRKOUT* pbrkout,
					 POSINLINE* pposinlineBreak, BRKKIND* pbrkkindDnodeBreak)
	{
	
	LSERR lserr;
	DWORD idObj;
	POSICHNK posichnk;
	LSCHUNKCONTEXT* plschunkcontext;
	LOCCHNK* plocchnk;
	PLSC plsc = pposinlineTruncate->plssubl->plsc;
	PLSSUBL plssublOld;
	
	
	Assert(FBreakingAllowed(plsc));
	Assert(FIsLSDNODE(pposinlineTruncate->plsdn));
	Assert(pposinlineBreak != NULL);
	
	*pbrkkindDnodeBreak = brkkindForce;
	
	plschunkcontext = PlschunkcontextFromSubline(pposinlineTruncate->plssubl);
	plocchnk = &(plschunkcontext->locchnkCurrent);
	
	if (plsc->grpfManager & fFmiForceBreakAsNext &&
		FIsSubLineMain(pposinlineTruncate->plssubl))
		/* find next break opportunity, client will scroll */
		{
		lserr = FindNextBreakCore(urColumnMax, pposinlineTruncate, fFirstSubline,
			fStopped, pbrkout, pposinlineBreak, pbrkkindDnodeBreak);
		if (lserr != lserrNone)
			return lserr;
		
		if (!pbrkout->fSuccessful)
			{
			/* increase right margin and fetch more */
			return lserrNone;
			}
		
		}
	else
		/* use force break method */
		{
		SetUrColumnMaxForChunks(plschunkcontext, urColumnMax);  
		
		Assert(!FIsDnodeBorder(pposinlineTruncate->plsdn));

		lserr = CollectChunkAround(plschunkcontext, pposinlineTruncate->plsdn,
			pposinlineTruncate->plssubl->lstflow, 
			&pposinlineTruncate->pointStart);
		if (lserr != lserrNone)
			{
			return lserr;
			}
		
		/* set fFirstOnLine */
		ApplyFFirstSublineToChunk(plschunkcontext, fFirstSubline);

		if (!fAllLineAfterRightMargin)
			{
			SetPosInChunk(plschunkcontext, pposinlineTruncate->plsdn,
				pposinlineTruncate->dcp, &posichnk);
			}
		else /* all chunk already behind right margin */
			{
			posichnk.ichnk = ichnkOutside;
			/* posichnk.dcp is invalid */
			}
		
		if (FIsDnodePen(pposinlineTruncate->plsdn) ||
			pposinlineTruncate->plsdn->fTab || FIsDnodeSplat(pposinlineTruncate->plsdn))
			{
			Assert(NumberOfDnodesInChunk(plocchnk) == 1);
			/* only advance pen is allowed here */
			Assert(!FIsDnodePen(pposinlineTruncate->plsdn) ||
				pposinlineTruncate->plsdn->fAdvancedPen);
			
			/* for the case of a pen we are passing garbage as an objdim 
			here assuming that it never be used */

			lserr = ForceBreakTabPenSplat(plocchnk, 
										  &(pposinlineTruncate->plsdn->u.real.objdim), 
										  pbrkout);
			if (lserr != lserrNone)
				return lserr;
			}
		else
			{
			
			idObj = IdObjFromChnk(plocchnk);
			
			/* we allow object handler to formate subline,
			so we restore current subline after calling him */
			plssublOld = GetCurrentSubline(plsc);
			SetCurrentSubline(plsc, NULL);
			
			lserr = PLsimFromLsc(&plsc->lsiobjcontext, idObj)->pfnForceBreakChunk(plocchnk, &posichnk, pbrkout);
			if (lserr != lserrNone)
				{
				return lserr;
				}
			

			SetCurrentSubline(plsc, plssublOld);
			}
		
		Assert(pbrkout->fSuccessful);
		

		pposinlineBreak->plssubl = pposinlineTruncate->plssubl;
		if (pbrkout->posichnk.dcp == 0 && FIsDnodeReal(plschunkcontext->pplsdnChunk[0]))
			/* break before dnode */
			{
			lserr = MoveBreakAfterPreviousDnode(plschunkcontext, pbrkout, NULL, pbrkkindDnodeBreak); 
			/* this procedure can change chunkcontext */
			if (lserr != lserrNone)
				return lserr;

			}

		ResolvePosInChunk(plschunkcontext, (pbrkout->posichnk), pposinlineBreak); 
		

		}
	return lserrNone;
}

/* ---------------------------------------------------------------------- */

/*  M O V E  B R E A K  A F T E R  P R E V I O U S  D N O D E */
/*----------------------------------------------------------------------------
    %%Function: MoveBreakAfterPreviousDnode
    %%Contact: igorzv
Parameters:
	plschunkcontext			-	(IN) chunk context
	pbrkout					-	(IN,OUT) brkout which can be changed 
	pobjdimPrev				-	(IN) suggested objdim for the dnode in previous chunk,
									 if NULL take objdim of dnode
	pbrkkind				-	(IN, OUT) how dnode was broken
----------------------------------------------------------------------------*/
static LSERR MoveBreakAfterPreviousDnode(
										 PLSCHUNKCONTEXT plschunkcontext,
										 BRKOUT* pbrkout, 
										 OBJDIM* pobjdimPrev,
										 BRKKIND* pbrkkind )	



	{
	LOCCHNK* plocchnk;
	LSERR lserr;
	BOOL fFound;
	
	Assert(pbrkout->posichnk.dcp == 0);
	Assert(FIsDnodeReal(plschunkcontext->pplsdnChunk[0]));
	
	/* because we do all operations on chunks we skip borders */
	
	plocchnk = &(plschunkcontext->locchnkCurrent);
	/* if break was set before chunk reset it after previous chunk */
	if (pbrkout->posichnk.ichnk == 0)
		{
		lserr = CollectPreviousChunk(plschunkcontext, &fFound);
		if (lserr != lserrNone)
			return lserr;
		
		if (fFound)
			{
			pbrkout->posichnk.ichnk = plocchnk->clschnk - 1;
			pbrkout->posichnk.dcp = plschunkcontext->pplsdnChunk[plocchnk->clschnk - 1]->dcp;
			if (pobjdimPrev != NULL)
				{
				pbrkout->objdim = *pobjdimPrev;
				}
			else
				{
				pbrkout->objdim = plschunkcontext->pplsdnChunk[plocchnk->clschnk - 1]
				->u.real.objdim; /* if it's pen then objdim is garbage which doesn't matter */
				*pbrkkind = brkkindImposedAfter; /* geometry has not prepared by object */
				}
			}

		}
	else
		{	/* just break after previous chunk element */
			pbrkout->posichnk.ichnk --;
			pbrkout->posichnk.dcp = plschunkcontext->pplsdnChunk[pbrkout->posichnk.ichnk]->dcp;
			pbrkout->objdim = plschunkcontext->pplsdnChunk[pbrkout->posichnk.ichnk]
												->u.real.objdim;
			*pbrkkind = brkkindImposedAfter; /* geometry has not prepared by object */
		}

	return lserrNone;
	}
	
/* ---------------------------------------------------------------------- */

/*  B R E A K  T A B  P E N  S P L A T*/
/*----------------------------------------------------------------------------
    %%Function: BreakTabPenSplat
    %%Contact: igorzv
Parameters:
	plocchnk			-	(IN) chunk contains tab or pen 
	fFindNext			-	(IN) is this functions used for next break
	fBreakThroughTab	-	(IN) there is a situation of breakthrough tab
	fSplat				-	(IN) we are breaking splat
	brkcond				-	(IN) condition of boundary break	
	pobjdim					(IN) to fill in objdim of break
	pbrkout				-	(OUT)breaking information

	
----------------------------------------------------------------------------*/


static LSERR BreakTabPenSplat(PLOCCHNK plocchnk, BOOL fFindNext, BOOL fBreakThroughTab, 
						 BOOL fSplat, BRKCOND brkcond, OBJDIM* pobjdim, BRKOUT* pbrkout)
	{
	Assert(NumberOfDnodesInChunk(plocchnk) == 1);

	if (fSplat)
		{
		pbrkout->fSuccessful = fTrue;
		PosInChunkAfterChunk(plocchnk, pbrkout->posichnk);
		pbrkout->objdim = *pobjdim;
		return lserrNone;
		}

	if (GetFFirstOnLineChunk(plocchnk) ||
		(fFindNext && brkcond == brkcondNever) ||
		fBreakThroughTab)
		{
		pbrkout->fSuccessful = fFalse;
		pbrkout->brkcond = brkcondCan;
		pbrkout->objdim = *pobjdim;
		return lserrNone;
		}
	else
		{
		pbrkout->fSuccessful = fTrue;
		pbrkout->posichnk.ichnk = 0;
		pbrkout->posichnk.dcp = 0;
		memset(&(pbrkout->objdim), 0, sizeof(pbrkout->objdim));
		return lserrNone;
		}
	}


/* ---------------------------------------------------------------------- */

/*  F O R C E  B R E A K  T A B  P E N  S P L A T*/
/*----------------------------------------------------------------------------
    %%Function: ForceBreakTabPenSplat
    %%Contact: igorzv
Parameters:
	plocchnk			-	(IN) chunk contains tab or pen 
	pobjdim					(IN) to fill in objdim of break
	pbrkout			-		(OUT)breaking information

	Returns break after chunk
----------------------------------------------------------------------------*/


static LSERR ForceBreakTabPenSplat(PLOCCHNK plocchnk, 
					 OBJDIM* pobjdim, BRKOUT* pbrkout)
	{
	Assert(NumberOfDnodesInChunk(plocchnk) == 1);
	
	pbrkout->fSuccessful = fTrue;
	PosInChunkAfterChunk(plocchnk, pbrkout->posichnk);
	pbrkout->objdim = *pobjdim;
	return lserrNone;
	
	}

/* ---------------------------------------------------------------------- */

/*  S E T  B R E A K  C O R E */
/*----------------------------------------------------------------------------
    %%Function: SetBreakCore
    %%Contact: igorzv
Parameters:
	pposinlineBreak	-		(IN) position of breaking point
	pobjdim			-		(IN) objdim of a breaking dnode
	brkkind			-		(IN) how break was found
	fStopped		-		(IN) formatting ends with hard break
	fGlueEop			-	(IN) if break after dnode check EOP after it
	breakrecMaxCurrent	-	(IN) size of the array of current line's break records
	pbreakrecCurrent	-	(OUT) current line's break records
	pbreakrecMacCurrent	-	(OUT) actual number of current line's break records 
	pcpLimLine		-		(OUT) cpLim of line to fill in
	pdcpDepend		-		(OUT) amount of characters after break that was formated to
								  make breaking decision
	pendr			-		(OUT) how line ends
	pfSuccessful	-		(OUT) fSuccessful: false means insufficient fetch 
	
Fill in break info
Change pfmtres in the case when hard break that we have because of excedeed margin 
	doesn't fit
If dcpBreak == 0  set break after previous dnode 
Call handler of break dnode to notice him about break
Set current context after break point
----------------------------------------------------------------------------*/

static LSERR SetBreakCore(
						  POSINLINE* pposinlineBreak, OBJDIM* pobjdim, BRKKIND brkkind,
						  BOOL fHardStop, BOOL fGlueEop, DWORD breakrecMaxCurrent,
						  BREAKREC* pbreakrecCurrent, DWORD* pbreakrecMacCurrent,
					      LSCP* pcpLimLine, LSDCP* pdcpDepend, ENDRES* pendr, 
						  BOOL* pfSuccessful)
	{
	
	DWORD idObj;
	PLSDNODE plsdnToChange;
	LSERR lserr;
	LSDCP dcpBreak;
	POINTUV pointBeforeDnode;
	long urBreak;
	long vrBreak;
	PLSSUBL plssubl = pposinlineBreak->plssubl;
	PLSC plsc = plssubl->plsc;
	PLSDNODE plsdnBreak;
	PLSSUBL plssublOld;
	BOOL fCrackDnode = fFalse;
	PLSDNODE plsdn;
	long urAdd;
	
	
	plsdnBreak = pposinlineBreak->plsdn;
	dcpBreak = pposinlineBreak->dcp;
	pointBeforeDnode = pposinlineBreak->pointStart;

	Assert(!FIsDnodeBorder(plsdnBreak));  /* border will be added later */
	AssertImplies(FIsFirstOnLine(plsdnBreak), dcpBreak != 0); /*to avoid infinitive loop */
	
	plsdnToChange = plsdnBreak;
	if (plsdnToChange->dcp != dcpBreak)
		/* if break is not after dnode than change cpLimOriginal */
		{
		plsdnToChange->cpLimOriginal = plsdnToChange->cpFirst + dcpBreak;
		plsdnToChange->dcp = dcpBreak;	
		fCrackDnode = fTrue;
		}
	
	if (FIsDnodeReal(plsdnToChange))
		SetDnodeObjdimFmt(plsdnToChange, *pobjdim);
	
	
	/* set state after break point  */
	urBreak = pointBeforeDnode.u + DurFromDnode(plsdnBreak);
	vrBreak = pointBeforeDnode.v + DvrFromDnode(plsdnBreak);
	
	if (FIsDnodeReal(plsdnBreak) && !plsdnBreak->fTab && !FIsDnodeSplat(plsdnBreak)) /* call set break of break dnode */
		{

		idObj = IdObjFromDnode(plsdnBreak);
		/* we allow object handler to formate subline,
		so we restore current subline after calling him */
		plssublOld = GetCurrentSubline(plsc);
		SetCurrentSubline(plsc, NULL);
		
		
		lserr = PLsimFromLsc(&plsc->lsiobjcontext, idObj)->pfnSetBreak(
					plsdnBreak->u.real.pdobj, brkkind, breakrecMaxCurrent, pbreakrecCurrent, 
					pbreakrecMacCurrent);
		if (lserr != lserrNone)
			return lserr;
		

		SetCurrentSubline(plsc, plssublOld);
		}

		/* if break after dnode and after it we have end of paragraph or spalt then we 
		should set break after end of paragraph  */
		if (fGlueEop && !fCrackDnode)
			{
			plsdn = plsdnBreak->plsdnNext;
			urAdd = 0;
			/* skip borders */
			while(plsdn != NULL && FIsDnodeBorder(plsdn))
				{
				urAdd += DurFromDnode(plsdn);
				plsdn = plsdn->plsdnNext;
				}
			
			if (plsdn == NULL && !fHardStop)
				{
				/* nothing has been fetched after break dnode which is not hard break */
				/* increase right margin and fetch more */
				*pfSuccessful = fFalse;
				return lserrNone;
				}
			
			AssertImplies(plsdn == NULL, fHardStop);
			/* next dnode EOP */
			if (plsdn != NULL && (FIsDnodeEndPara(plsdn) || FIsDnodeAltEndPara(plsdn)
								  || FIsDnodeSplat(plsdn)))
				{
				plsdnBreak = plsdn;
				urBreak += urAdd;
				urBreak += DurFromDnode(plsdn);
				}
			}

	/* move closing border */
	if (FBorderEncounted(plsc))
		{
		lserr = MoveClosingBorderAfterBreak(plssubl, fTrue, &plsdnBreak, &urBreak);
		if (lserr != lserrNone)
			return lserr;
		}


	/* below we handle situation of hard break that has stopped formatting */
	/* and if such dnode actually doesn't fit
	   we need to change final fmtres (can happened because of exceeded margin for formatting) */
	/* it's important to execute this check after moving border, because afterward border will
		never be next to hard break dnode */
	if (plsdnBreak != GetCurrentDnodeSubl(plssubl) || fCrackDnode)
		{
		fHardStop = fFalse;
		}

	/* prepare output */
	if (fHardStop)
		{
		/* in such case we should include hidden text after last dnode to a line */
		*pcpLimLine = GetCurrentCpLimSubl(plssubl);
		*pendr = EndrFromBreakDnode(plsdnBreak);
		}
	else
		{
		*pcpLimLine = (plsdnBreak)->cpLimOriginal;
		*pendr = endrNormal;
		}
	if (plsc->fHyphenated)  /* REVIEW why in context */
		{
		Assert(*pendr == endrNormal);
		*pendr = endrHyphenated;
		}

	*pdcpDepend = GetCurrentCpLimSubl(plssubl) - *pcpLimLine;
	

	/* set position of break in a subline */
	SetCurrentCpLimSubl(plssubl, *pcpLimLine);
	SetCurrentDnodeSubl(plssubl, plsdnBreak);
	SetCurrentUrSubl(plssubl, urBreak); 
	SetCurrentVrSubl(plssubl, vrBreak); 

	/* set boundaries for display */
	if (FIsDnodeSplat(plsdnBreak))
		{
		SetCpLimDisplaySubl(plssubl, GetCurrentCpLimSubl(plssubl) - 1);
		SetLastDnodeDisplaySubl(plssubl, GetCurrentDnodeSubl(plssubl)->plsdnPrev);
		}
	else
		{
		SetCpLimDisplaySubl(plssubl, GetCurrentCpLimSubl(plssubl));
		SetLastDnodeDisplaySubl(plssubl, GetCurrentDnodeSubl(plssubl));
		}
	
	return lserrNone;
	}

/* ---------------------------------------------------------------------- */

/*  M O V E  C L O S I N G  B O R D E R  A F T E R  B R E A K */
/*----------------------------------------------------------------------------
    %%Function: MoveClosingBorderAfterBreak
    %%Contact: igorzv
Parameters:
	plsc				-	(IN) subline
	fChangeList			-	(IN) do we need to change dnode list
								and change pplsdnBreak, or only to recalculate durBreak 
	pplsdnBreak			-	(IN,OUT) break dnode
	purBreak			-	(IN, OUT) position after break

  This procedure puts closing border into correct place, 
  takes into account trailing space logic.
----------------------------------------------------------------------------*/
LSERR MoveClosingBorderAfterBreak(PLSSUBL plssubl, BOOL fChangeList, PLSDNODE* pplsdnBreak,
								  long* purBreak) 
	{
	PLSDNODE plsdnBorder, plsdnBeforeBorder;
	long durBorder;
	PLSDNODE plsdnLastClosingBorder = NULL;
	LSERR lserr;
	PLSDNODE plsdnNext, plsdnPrev;
	PLSC plsc = plssubl->plsc;
	BOOL fBreakReached;
	BOOL fClosingBorderInsideBreak = fFalse;
	
	Assert(!FIsDnodePen(*pplsdnBreak));
	
	/* find dnode to insert border after, plus delete all borders which starts 
	inside trailing area*/
	plsdnBeforeBorder = GetCurrentDnodeSubl(plssubl);
	fBreakReached = (plsdnBeforeBorder == *pplsdnBreak);

	while (!fBreakReached 
		   ||
		   (plsdnBeforeBorder != NULL 
			&& (!FIsDnodeReal(plsdnBeforeBorder) 
			    || (FSpacesOnly(plsdnBeforeBorder, IobjTextFromLsc(&plsc->lsiobjcontext)))
			   )
		   )
		  )
		{
		/* pens can be only advanced so there is an object before REVIEW*/
		/* we skip borders in trailing area */
		plsdnPrev = plsdnBeforeBorder->plsdnPrev;
		if (FIsDnodeBorder(plsdnBeforeBorder))
			{
			if (FIsDnodeOpenBorder(plsdnBeforeBorder))
				{
				/* delete such dnode and correspondent closing border */
				/* decrease position of break */
				if (fBreakReached)
					*purBreak -= DurFromDnode(plsdnBeforeBorder);
				if (fChangeList)
					{
					RemoveBorderDnodeFromList(plsdnBeforeBorder);
					lserr = DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext,
						  plsdnBeforeBorder, plsc->fDontReleaseRuns);
					if (lserr != lserrNone)
						return lserr;
					}

				if (plsdnLastClosingBorder != NULL)
					{
					/* decrease position of break */
					if (fClosingBorderInsideBreak)
						*purBreak -= DurFromDnode(plsdnLastClosingBorder);
					if (fChangeList)
						{
						RemoveBorderDnodeFromList(plsdnLastClosingBorder);
						lserr = DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext,
							plsdnLastClosingBorder, plsc->fDontReleaseRuns);
						if (lserr != lserrNone)
							return lserr;
						}
					plsdnLastClosingBorder = NULL;
					}
				
				}
			else  /* closing border */
				{
				plsdnLastClosingBorder = plsdnBeforeBorder;
				fClosingBorderInsideBreak = fBreakReached;
				}
			}

		plsdnBeforeBorder = plsdnPrev;
		if (plsdnBeforeBorder == *pplsdnBreak)
			fBreakReached = fTrue;
		}
	
	if (plsdnBeforeBorder != NULL && FDnodeHasBorder(plsdnBeforeBorder))
		/* otherwise we don't need to move border */
		{
		
		/* set closing border */
		plsdnBorder = plsdnLastClosingBorder;
		Assert(FIsLSDNODE(plsdnBorder));
		Assert(FIsDnodeBorder(plsdnBorder));
		Assert(!plsdnBorder->fOpenBorder);
		
		if (fChangeList)
			{
			if (plsdnBeforeBorder->plsdnNext != plsdnBorder) /* otherwise nothing to move */
				{
				/* break link with closing border in the old place */
				RemoveBorderDnodeFromList(plsdnBorder);
				
				/* insert closing border into it new place */
				plsdnNext = plsdnBeforeBorder->plsdnNext;
				plsdnBeforeBorder->plsdnNext = plsdnBorder;
				plsdnBorder->plsdnPrev = plsdnBeforeBorder;
				plsdnBorder->plsdnNext = plsdnNext;
				if (plsdnNext != NULL)
					plsdnNext->plsdnPrev = plsdnBorder;
				plsdnBorder->fBorderMovedFromTrailingArea = fTrue;
				}
			
			/* change cp in border dnode */
			plsdnBorder->cpFirst = plsdnBeforeBorder->cpLimOriginal;
			plsdnBorder->cpLimOriginal = plsdnBorder->cpFirst;
			}
		
		/* increase widths of the line */
		if (!fClosingBorderInsideBreak)
			{
			durBorder = plsdnBorder->u.pen.dur;
			*purBreak += durBorder;
			}
		
		/* if we add closing border right after breaking dnode than consider border 
		as new breaking dnode */
		if (plsdnBeforeBorder == *pplsdnBreak && fChangeList)
			{
			*pplsdnBreak = plsdnBorder;
			}
		}
	return lserrNone;
	}


/* ---------------------------------------------------------------------- */

/*  R E M O V E  B O R D E R  D N O D E  F R O M  L I S T */
/*----------------------------------------------------------------------------
    %%Function: RemoveBorderDnodeFromList
    %%Contact: igorzv
Parameters:
	plsdnBorder			-	(IN) border dnode to remove

  This procedure removes border dnode from the list of dnodes.
----------------------------------------------------------------------------*/
static void	RemoveBorderDnodeFromList(PLSDNODE plsdnBorder)
	{
	PLSDNODE plsdnPrev;
	PLSDNODE plsdnNext;

	plsdnPrev = plsdnBorder->plsdnPrev;
	plsdnNext = plsdnBorder->plsdnNext;

	if (plsdnPrev != NULL)
		{
		plsdnPrev->plsdnNext = plsdnNext;
		}
	else
		{
		/* border was the first so change first dnode of subline */
		(SublineFromDnode(plsdnBorder))->plsdnFirst = plsdnNext;
		}

	if (plsdnNext != NULL)
		{
		plsdnNext->plsdnPrev = plsdnPrev;
		}
	else
		/* if border was the last then set new last dnode of subline */
		{
		SetCurrentDnodeSubl(SublineFromDnode(plsdnBorder), plsdnPrev);
		}
	
	plsdnBorder->plsdnNext = NULL;
	plsdnBorder->plsdnPrev = NULL;

	InvalidateChunk(PlschunkcontextFromSubline(SublineFromDnode(plsdnBorder)));
	}
/* ---------------------------------------------------------------------- */

/*  B R E A K  Q U I C K  C A S E */
/*----------------------------------------------------------------------------
    %%Function: BreakQuickCase
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) LineServices context
	fHardStop		-	(IN) formatting ended with hard break				
	pdcpDepend		-	(OUT) amount of characters after cpLim that was formated to find break
	pcpLim			-	(OUT) cpLim of line
	pfSuccessful	-	(OUT) can we find break through quick break
	pendr			-	(OUT) how line ended

  This quick procedure works if we have only text in a line.
  We try to find break just in the last dnode
----------------------------------------------------------------------------*/

LSERR BreakQuickCase(PLSC plsc, BOOL fHardStop, LSDCP* pdcpDepend,		
					 LSCP* pcpLim,	BOOL*  pfSuccessful, ENDRES* pendr)
					 
					 
	{
	LSDCP dcpBreak; 
	PLSDNODE plsdnBreak = GetCurrentDnode(plsc);
	LSERR lserr;
	
	*pfSuccessful = fFalse; 
	
	if (!fHardStop)
		{
		
		OBJDIM objdimBreak;
		
		lserr = QuickBreakText(plsdnBreak->u.real.pdobj, pfSuccessful, &dcpBreak, &objdimBreak );
		if (lserr != lserrNone)
			return lserr;
		
		if (*pfSuccessful)
			{  /* we found break */
			AdvanceCurrentUr(plsc, objdimBreak.dur - plsdnBreak->u.real.objdim.dur); 
			SetDnodeObjdimFmt(plsdnBreak, objdimBreak);
			plsdnBreak->dcp = dcpBreak;
			Assert(dcpBreak > 0); /* we don't allow Quickbreak to break before him */
			
								  /* in the case of QuickBreak cpLim is always equal to cpFirst + dcp,
			because otherwise is possible only with glyphs */
			plsdnBreak->cpLimOriginal = plsdnBreak->cpFirst + dcpBreak;
			*pcpLim = plsdnBreak->cpLimOriginal;
			*pdcpDepend = GetCurrentCpLim(plsc) - *pcpLim;
			*pendr = endrNormal;
			SetCurrentCpLim(plsc, *pcpLim);
			/* set boundaries for display */
			SetCpLimDisplay(plsc, *pcpLim);
			SetLastDnodeDisplay(plsc, plsdnBreak);
			}
		}   
	else   /* hard break */
		{
		*pfSuccessful = fTrue;
		*pcpLim = GetCurrentCpLim(plsc);
		*pdcpDepend = 0;
		/* plsdnBreak can be NULL because of deleting splat */
		*pendr = EndrFromBreakDnode(plsdnBreak);
		/* set boundaries for display */
		if (plsdnBreak != NULL && FIsDnodeSplat(plsdnBreak)) 
			{
			SetCpLimDisplay(plsc, *pcpLim - 1);
			SetLastDnodeDisplay(plsc, plsdnBreak->plsdnPrev);
			}
		else
			{
			SetCpLimDisplay(plsc, *pcpLim);
			SetLastDnodeDisplay(plsc, plsdnBreak);
			}
		}
	return lserrNone;
	}

/* ---------------------------------------------------------------------- */

/*  T R U N C A T E  S U B L I N E   C O R E */
/*----------------------------------------------------------------------------
    %%Function: TruncateSublineCore
    %%Contact: igorzv
Parameters:
	plssubl		-	(IN) subline context		
	urColumnMax	-	(IN) urColumnMax				
	pcpTruncate	-	(OUT) cpTruncate 				

----------------------------------------------------------------------------*/
LSERR TruncateSublineCore(PLSSUBL plssubl, long urColumnMax, LSCP* pcpTruncate)		
	{
	LSERR lserr;
	POSINLINE posinlineTruncate;
	BOOL fAllLineAfterRightMargin;

	Assert(FIsLSSUBL(plssubl));

	lserr = TruncateCore(plssubl, urColumnMax, &posinlineTruncate, &fAllLineAfterRightMargin);
	Assert(!fAllLineAfterRightMargin);
	if (lserr != lserrNone)
		return lserr;

	*pcpTruncate = GetCpLimFromPosInLine(posinlineTruncate) - 1;
	return lserrNone;
	}


/* ---------------------------------------------------------------------- */

/*  F I N D  P R E V  B R E A K  S U B L I N E   C O R E */
/*----------------------------------------------------------------------------
    %%Function: FindPrevBreakSublineCore
    %%Contact: igorzv
Parameters:
	plssubl			-		(IN) subline context	
	fFirstSubline	-		(IN) to apply rules for first character to the first character of
							 this subline 
	cpTruncate		-		(IN) truncation cp
	urColumnMax		-		(IN) urColumnMax				
	pfSuccessful	-		(OUT) do we find break?
	pcpBreak		-		(OUT) cp of break
	pobdimBreakSubline	-	(OUT) objdimSub up to break
	pbrkpos			-	(OUT) Before/Inside/After			

----------------------------------------------------------------------------*/

LSERR FindPrevBreakSublineCore(PLSSUBL plssubl, BOOL fFirstSubline, LSCP cpTruncate,
							long urColumnMax, BOOL* pfSuccessful, 
							LSCP* pcpBreak, POBJDIM pobdimBreakSubline, BRKPOS* pbrkpos)				
	{
	LSERR lserr;
	POSINLINE posinlineTruncate;
	BRKOUT brkout;
	PLSDNODE plsdnBreak;
	LSDCP dcpDnodeOld;
	OBJDIM objdimDnodeOld;
	PLSDNODE plsdnToChange;

	Assert(FIsLSSUBL(plssubl));

	if (plssubl->plsdnFirst == NULL)
		{
		*pfSuccessful = fFalse;
		return lserrNone;
		}

	if (cpTruncate < plssubl->plsdnFirst->cpFirst)
		{
		*pfSuccessful = fFalse;
		return lserrNone;
		}

	GetPosInLineTruncateFromCp(plssubl, cpTruncate, fTrue, &posinlineTruncate);

	lserr = FindPrevBreakCore(urColumnMax, &posinlineTruncate, fFirstSubline, 
							  &brkout, &(plssubl->pbrkcontext->posinlineBreakPrev),
							  &(plssubl->pbrkcontext->brkkindForPrev));
	if (lserr != lserrNone)
		return lserr;

	*pfSuccessful = brkout.fSuccessful;

	if (*pfSuccessful)
		{
		*pcpBreak = GetCpLimFromPosInLine(plssubl->pbrkcontext->posinlineBreakPrev);
		plssubl->pbrkcontext->objdimBreakPrev = brkout.objdim;
		plssubl->pbrkcontext->fBreakPrevValid = fTrue;
		plsdnBreak = plssubl->pbrkcontext->posinlineBreakPrev.plsdn;
		*pbrkpos = GetBrkpos(plsdnBreak,
						   plssubl->pbrkcontext->posinlineBreakPrev.dcp);
		
		/* we temporary change dnode to calculate objdim from the begining of subline */
		plsdnToChange = plsdnBreak; /* later plsdnBreak can be changed because of borders */
		dcpDnodeOld = plsdnToChange->dcp;
		objdimDnodeOld = plsdnToChange->u.real.objdim;
		plsdnToChange->dcp = plssubl->pbrkcontext->posinlineBreakPrev.dcp;
		SetDnodeObjdimFmt(plsdnToChange, brkout.objdim);


		lserr = FindListDims(plssubl->plsdnFirst, plsdnBreak, pobdimBreakSubline);
		if (lserr != lserrNone)
			return lserr;

		/* recalculate durBreak taking into account possible changes because of borders */
		if (FBorderEncounted(plssubl->plsc))
			{
			lserr = MoveClosingBorderAfterBreak(plssubl, fFalse, &plsdnBreak, 
												&(pobdimBreakSubline->dur));
			if (lserr != lserrNone)
				return lserr;
		}


		/*restore dnode */
		plsdnToChange->dcp = dcpDnodeOld ;
		SetDnodeObjdimFmt(plsdnToChange, objdimDnodeOld);
		}

	return lserrNone;
	}

/* ---------------------------------------------------------------------- */

/*  F I N D  N E X T  B R E A K  S U B L I N E   C O R E */
/*----------------------------------------------------------------------------
    %%Function: FindNextBreakSublineCore
    %%Contact: igorzv
Parameters:
	plssubl			-		(IN) subline context	
	fFirstSubline	-		(IN) to apply rules for first character to the first character of
							 this subline 
	cpTruncate		-		(IN) truncation cp
	urColumnMax		-		(IN) urColumnMax				
	pfSuccessful	-		(OUT) do we find break?
	pcpBreak		-		(OUT) cp of break
	pobdimBreakSubline	-	(OUT) objdimSub up to break
	pbrkpos			-	(OUT) Before/Inside/After			

----------------------------------------------------------------------------*/

LSERR FindNextBreakSublineCore(PLSSUBL plssubl, BOOL fFirstSubline, LSCP cpTruncate,
							long urColumnMax, BOOL* pfSuccessful,		
							LSCP* pcpBreak, POBJDIM pobdimBreakSubline, BRKPOS* pbrkpos)			
	{
	LSERR lserr;
	POSINLINE posinlineTruncate;
	BRKOUT brkout;
	PLSDNODE plsdnBreak;
	LSDCP dcpDnodeOld;
	OBJDIM objdimDnodeOld;
	PLSDNODE plsdnToChange;

	Assert(FIsLSSUBL(plssubl));

	if (plssubl->plsdnFirst == NULL)
		{
		*pfSuccessful = fFalse;
		return lserrNone;
		}

	if (cpTruncate >= plssubl->plsdnLast->cpLimOriginal)
		{
		*pfSuccessful = fFalse;
		return lserrNone;
		}

	GetPosInLineTruncateFromCp(plssubl, cpTruncate, fFalse, &posinlineTruncate);

	lserr = FindNextBreakCore(urColumnMax, &posinlineTruncate, fFirstSubline, fFalse, 
							  &brkout, &(plssubl->pbrkcontext->posinlineBreakNext), 
							  &(plssubl->pbrkcontext->brkkindForNext));
	if (lserr != lserrNone)
		return lserr;

	*pfSuccessful = brkout.fSuccessful;

	if (*pfSuccessful)
		{

		*pcpBreak = GetCpLimFromPosInLine(plssubl->pbrkcontext->posinlineBreakNext);
		plssubl->pbrkcontext->objdimBreakNext = brkout.objdim;
		plssubl->pbrkcontext->fBreakNextValid = fTrue;
		plsdnBreak = plssubl->pbrkcontext->posinlineBreakNext.plsdn;
		*pbrkpos = GetBrkpos(plsdnBreak,
						   plssubl->pbrkcontext->posinlineBreakNext.dcp);

		/* we temporary change dnode to calculate objdim from the begining of subline */
		plsdnToChange = plsdnBreak; /* later plsdnBreak can be changed because of borders */
		dcpDnodeOld = plsdnToChange->dcp;
		objdimDnodeOld = plsdnToChange->u.real.objdim;
		plsdnToChange->dcp = plssubl->pbrkcontext->posinlineBreakNext.dcp;
		SetDnodeObjdimFmt(plsdnToChange, brkout.objdim);

		lserr = FindListDims(plssubl->plsdnFirst, plsdnBreak, pobdimBreakSubline);
		if (lserr != lserrNone)
			return lserr;

		/* recalculate durBreak taking into account possible changes because of borders */
		if (FBorderEncounted(plssubl->plsc))
			{
			lserr = MoveClosingBorderAfterBreak(plssubl, fFalse, 
							&plsdnBreak, &(pobdimBreakSubline->dur));
			if (lserr != lserrNone)
				return lserr;
			}
	
		/*restore dnode */
		plsdnToChange->dcp = dcpDnodeOld ;
		SetDnodeObjdimFmt(plsdnToChange, objdimDnodeOld);
		}

	return lserrNone;
	}

/* ---------------------------------------------------------------------- */

/*  F O R C E  B R E A K  S U B L I N E   C O R E */
/*----------------------------------------------------------------------------
    %%Function: ForceBreakSublineCore
    %%Contact: igorzv
Parameters:
	plssubl			-		(IN) subline context	
	fFirstSubline	-		(IN) to apply rules for first character to the first character of
							 this subline 
	cpTruncate		-		(IN) truncation cp
	urColumnMax		-		(IN) urColumnMax				
	pcpBreak		-		(OUT) cp of break
	pobdimBreakSubline	-	(OUT) objdimSub up to break
	pbkrpos			-	(OUT) Before/Inside/After			

----------------------------------------------------------------------------*/

LSERR ForceBreakSublineCore(PLSSUBL plssubl, BOOL fFirstSubline, LSCP cpTruncate, 
							long urColumnMax, LSCP* pcpBreak,
							POBJDIM pobdimBreakSubline, BRKPOS* pbrkpos)	
	{
	LSERR lserr;
	BRKOUT brkout;
	LSDCP dcpDnodeOld;
	PLSDNODE plsdnBreak;
	OBJDIM objdimDnodeOld;
	POSINLINE posinlineTruncate;
	PLSDNODE plsdnToChange;

	Assert(FIsLSSUBL(plssubl));

	if (plssubl->plsdnFirst == NULL)
		return lserrCpOutsideSubline;

	if (cpTruncate < plssubl->plsdnFirst->cpFirst)
		cpTruncate = plssubl->plsdnFirst->cpFirst;

	GetPosInLineTruncateFromCp(plssubl, cpTruncate, fTrue, &posinlineTruncate);

	lserr = ForceBreakCore(urColumnMax, &posinlineTruncate,
							fFalse, fFirstSubline, fFalse, &brkout, 
							&(plssubl->pbrkcontext->posinlineBreakForce),
							  &(plssubl->pbrkcontext->brkkindForForce));
	if (lserr != lserrNone)
		return lserr;
	
	Assert(brkout.fSuccessful); /* force break should be successful for not a main line */
	
	*pcpBreak = GetCpLimFromPosInLine(plssubl->pbrkcontext->posinlineBreakForce);
	plssubl->pbrkcontext->objdimBreakForce = brkout.objdim;
	plssubl->pbrkcontext->fBreakForceValid = fTrue;
	plsdnBreak = plssubl->pbrkcontext->posinlineBreakForce.plsdn;
	*pbrkpos = GetBrkpos(plsdnBreak,
					   plssubl->pbrkcontext->posinlineBreakForce.dcp);
	
	/* we temporary change dnode to calculate objdim from the begining of subline */
	plsdnToChange = plsdnBreak; /* later plsdnBreak can be changed because of borders */
	dcpDnodeOld = plsdnToChange->dcp;
	objdimDnodeOld = plsdnToChange->u.real.objdim;
	plsdnToChange->dcp = plssubl->pbrkcontext->posinlineBreakForce.dcp;
	SetDnodeObjdimFmt(plsdnToChange, brkout.objdim);
	
	lserr = FindListDims(plssubl->plsdnFirst, plsdnBreak, pobdimBreakSubline);
	if (lserr != lserrNone)
		return lserr;
	
	/* recalculate durBreak taking into account possible changes because of borders */
	if (FBorderEncounted(plssubl->plsc))
		{
		lserr = MoveClosingBorderAfterBreak(plssubl, fFalse, 
					&plsdnBreak, &(pobdimBreakSubline->dur));
		if (lserr != lserrNone)
			return lserr;
		}

	/*restore dnode */
	plsdnToChange->dcp = dcpDnodeOld ;
	SetDnodeObjdimFmt(plsdnToChange, objdimDnodeOld);
	
	return lserrNone;
	}

/* ---------------------------------------------------------------------- */

/*  S E T  B R E A K  S U B L I N E   C O R E */
/*----------------------------------------------------------------------------
    %%Function: SetBreakSublineCore
    %%Contact: igorzv
Parameters:
	plssubl				-	(IN) subline context	
	brkkind,			-	(IN) Prev/Next/Force/Imposed						
	breakrecMaxCurrent	-	(IN) size of the array of current line's break records
	pbreakrecCurrent	-	(OUT) current line's break records
	pbreakrecMacCurrent	-	(OUT) actual number of current line's break records 
----------------------------------------------------------------------------*/

LSERR SetBreakSublineCore(PLSSUBL plssubl, BRKKIND brkkind, DWORD breakrecMaxCurrent,
							BREAKREC* pbreakrecCurrent, DWORD* pbreakrecMacCurrent)		

	{
	POSINLINE* pposinline;
	LSCP cpLim;
	LSDCP dcpDepend;
	OBJDIM* pobjdim;
	POSINLINE posinlineImposedAfter;
	BRKKIND brkkindDnode;
	BOOL fEndOfContent;
	ENDRES endr;
	BOOL fSuccessful;


	Assert(FIsLSSUBL(plssubl));


	/* invalidate chunkcontext, otherwise we will have wrong result of optimization there */
	InvalidateChunk(plssubl->plschunkcontext);

	switch (brkkind)
		{
		case brkkindPrev:
			if (!plssubl->pbrkcontext->fBreakPrevValid)
				return lserrWrongBreak;
			pposinline = &(plssubl->pbrkcontext->posinlineBreakPrev);
			pobjdim = &(plssubl->pbrkcontext->objdimBreakPrev);
			brkkindDnode = plssubl->pbrkcontext->brkkindForPrev;
			break;
		case brkkindNext:
			if (!plssubl->pbrkcontext->fBreakNextValid)
				return lserrWrongBreak;
			pposinline = &(plssubl->pbrkcontext->posinlineBreakNext);
			pobjdim = &(plssubl->pbrkcontext->objdimBreakNext);
			brkkindDnode = plssubl->pbrkcontext->brkkindForNext;
			break;
		case brkkindForce:
			if (!plssubl->pbrkcontext->fBreakForceValid)
				return lserrWrongBreak;
			pposinline = &(plssubl->pbrkcontext->posinlineBreakForce);
			pobjdim = &(plssubl->pbrkcontext->objdimBreakForce);
			brkkindDnode = plssubl->pbrkcontext->brkkindForForce;
			break;
		case brkkindImposedAfter:
			/* subline is empty: nothing to do */
			if (plssubl->plsdnFirst == NULL)
				return lserrNone;
			posinlineImposedAfter.plssubl =  plssubl;
			posinlineImposedAfter.plsdn = GetCurrentDnodeSubl(plssubl);
			GetCurrentPointSubl(plssubl, posinlineImposedAfter.pointStart);
			GetPointBeforeDnodeFromPointAfter(posinlineImposedAfter.plsdn,
							&(posinlineImposedAfter.pointStart));
			posinlineImposedAfter.dcp = GetCurrentDnodeSubl(plssubl)->dcp;
			while (FIsDnodeBorder(posinlineImposedAfter.plsdn))
				{
				GoPrevPosInLine(&posinlineImposedAfter, fEndOfContent);
				Assert(!fEndOfContent);
				}

			pposinline = &posinlineImposedAfter;
			/* for the case of a pen  we are passing garbage as an objdim, 
			 assuming that it will never be used */
			pobjdim = &(posinlineImposedAfter.plsdn->u.real.objdim);
			brkkindDnode = brkkindImposedAfter;
			break;
		default:
			return lserrWrongBreak;
		}




	return SetBreakCore(pposinline,	pobjdim, brkkindDnode, fFalse, fFalse, breakrecMaxCurrent,
						pbreakrecCurrent, pbreakrecMacCurrent, 
						&cpLim, &dcpDepend, &endr, &fSuccessful);
	}


/* ---------------------------------------------------------------------- */

/*  S Q U E E Z E  S U B L I N E   C O R E */
/*----------------------------------------------------------------------------
    %%Function: SqueezeSublineCore
    %%Contact: igorzv
Parameters:
	plssubl		-	(IN) subline context	
	durTarget	-	(IN) desirable width
	pfSuceessful-	(OUT) do we achieve the goal
	pdurExtra	-	(OUT) if nof successful, how much we fail
----------------------------------------------------------------------------*/
LSERR WINAPI SqueezeSublineCore(PLSSUBL plssubl, long durTarget, 
								BOOL* pfSuccessful, long* pdurExtra)														
	{
	
	GRCHUNKEXT grchnkextCompression;
	PLSC plsc;
	long durToCompress;
	BOOL fLineCompressed;
	LSERR lserr;
	
	Assert(FIsLSSUBL(plssubl));
	
	plsc = plssubl->plsc;
	durToCompress = GetCurrentUrSubl(plssubl) - durTarget; 

	InitGroupChunkExt(PlschunkcontextFromSubline(plssubl),
						IobjTextFromLsc(&plsc->lsiobjcontext), &grchnkextCompression);
	
	if (durToCompress > 0)
		{
		
		lserr = CollectPreviousTextGroupChunk(GetCurrentDnodeSubl(plssubl), CollectSublinesForCompression,
										  fFalse, /* simple text */
										  &grchnkextCompression);
		if (lserr != lserrNone)
			return lserr;
		
		durToCompress -= grchnkextCompression.durTrailing;

		if (FDnodeHasBorder(grchnkextCompression.plsdnStartTrailing))
			{
			/* we should reserve room for closing border */
			durToCompress += DurBorderFromDnodeInside(grchnkextCompression.plsdnStartTrailing);
			}

		lserr = CanCompressText(&(grchnkextCompression.lsgrchnk), 
								&(grchnkextCompression.posichnkBeforeTrailing),
								LstflowFromSubline(plssubl),
								durToCompress,	pfSuccessful,
								&fLineCompressed, pdurExtra);

		if (lserr != lserrNone)
			return lserr;
		
		
		}
	else 
		{
		*pdurExtra = 0; 
		*pfSuccessful = fTrue;
		}
	return lserrNone;
	
	}

/* ---------------------------------------------------------------------- */

/*  G E T  P O S  I N  L I N E  T R U N C A T E  F R O M  C P   */
/*----------------------------------------------------------------------------
    %%Function: GetPosInLineTruncateFromCp
    %%Contact: igorzv
Parameters:
	plssubl		-	(IN) subline context	
	cp			-	(IN) cp of position
	pposinline	-	(OUT) position in a subline
----------------------------------------------------------------------------*/
void GetPosInLineTruncateFromCp(
							PLSSUBL plssubl,	/* IN: subline						*/
							LSCP cp,			/* IN: cp of a position */
							BOOL fSnapPrev,		/* IN: direction of snapping hidden cp */
							POSINLINE* pposinline)	/* OUT: position in a subline */
	{
	PLSDNODE plsdn;
	BOOL fSuccessful = fFalse;
	BOOL fLastReached = fFalse;
	BOOL fPassed = fFalse;
	LSDCP dcp;

	Assert(FIsLSSUBL(plssubl));

	pposinline->plssubl = plssubl;
	pposinline->pointStart.u = 0;
	pposinline->pointStart.v = 0;

	plsdn = plssubl->plsdnFirst;
	while(!fSuccessful && !fLastReached &&!fPassed)
		{
		Assert(plsdn != NULL);
		Assert(FIsLSDNODE(plsdn));

		if (plsdn == plssubl->plsdnLast)
			fLastReached = fTrue;

		if (plsdn->cpFirst > cp) /* our cp is not inside any dnode */
			{
			fPassed = fTrue;
			}
		else
			{
			if (cp < plsdn->cpLimOriginal)
				{
				fSuccessful = fTrue;
				pposinline->plsdn = plsdn;
				dcp = cp - plsdn->cpFirst + 1;
				if (dcp <= plsdn->dcp)		/* such calculations are because of a case of ligature */
					pposinline->dcp = dcp;  /* across hiden text, in such case cpLimOriginal */
				else						/* is not equal to cpFirst + dcp	*/
					pposinline->dcp = plsdn->dcp;	/* such calculation doesn't guarantee exact cp, */
				}							/* but at least in the same ligature */
			else
				{
				if (!fLastReached)
					{
					pposinline->pointStart.u += DurFromDnode(plsdn);
					pposinline->pointStart.v += DvrFromDnode(plsdn);
					plsdn = plsdn->plsdnNext;
					}
				}
			}
		}

	if (!fSuccessful)
		{
		if (fSnapPrev)
			{
			/* snap to previous dnode */
			if (fPassed)
				{
				Assert(plsdn != NULL); /* we don't allow caller to pass cp before first dnode */
				plsdn = plsdn->plsdnPrev;
				/* skip borders */
				while(FIsDnodeBorder(plsdn))
					{
					plsdn = plsdn->plsdnPrev;
					}
				Assert(plsdn != NULL); 
				pposinline->plsdn = plsdn;
				pposinline->dcp = plsdn->dcp;
				pposinline->pointStart.u -= DurFromDnode(plsdn);
				pposinline->pointStart.v -= DvrFromDnode(plsdn);
				}
			else
				{
				Assert(fLastReached);
				/* skip borders */
				while(FIsDnodeBorder(plsdn))
					{
					plsdn = plsdn->plsdnPrev;
					}
				Assert(plsdn != NULL); 
				pposinline->plsdn = plsdn;
				pposinline->dcp = plsdn->dcp;
				}
			}
		else
			{
			/* snap to current dnode */
			if (fPassed)
				{
				/* skip borders */
				while(FIsDnodeBorder(plsdn))
					{
					plsdn = plsdn->plsdnNext;
					}
				Assert(plsdn != NULL); 
				pposinline->plsdn = plsdn;
				pposinline->dcp = 1;
				}
			else
				{
				Assert(fLastReached);
				/* we don't allow caller to pass cp after last dnode */
				NotReached();
				}
			}

		}

	}
/* ---------------------------------------------------------------------- */

/*  F I N D  F I R S T  D N O D E  C O N T A I N S  R I G H T  M A R G I N */
/*----------------------------------------------------------------------------
    %%Function: FindFirstDnodeContainsRightMargin
    %%Contact: igorzv
Parameters:
	urColumnMax	-	(IN) right margin
	pposinline	-	(IN,OUT) position in a subline: before position in the end,
							 after first position contains right margin
----------------------------------------------------------------------------*/

static void FindFirstDnodeContainsRightMargin(long urColumnMax, POSINLINE* pposinlineTruncate)
	{
	POSINLINE posinline;
	BOOL fOutside;
	BOOL fFound = fFalse;
	BOOL fEndOfContent;
	
	posinline = *pposinlineTruncate;

	// we know that last done ends after right margin
	Assert(posinline.pointStart.u + DurFromDnode(posinline.plsdn) > urColumnMax);
	fOutside = fTrue;
	
	fEndOfContent = fFalse;
	do 
		{
		if (posinline.pointStart.u <= urColumnMax)
			{
			if (fOutside)
				{
				fFound = fTrue;
				*pposinlineTruncate = posinline;
				}
			fOutside = fFalse;
			}
		else
			{
			fOutside = fTrue;
			}
		GoPrevPosInLine(&posinline, fEndOfContent);	
		}	while (!fEndOfContent);

	if (!fFound)
		{
		*pposinlineTruncate = posinline;  // we cann't right dnode and return fisrt dnode to report situation
		}
	}


/* ---------------------------------------------------------------------- */

/*  G E T  L I N E  D U R  C O R E */
/*----------------------------------------------------------------------------
    %%Function: GetLineDurCore
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) LS context
	pdurInclTrail	-	(OUT) dur of line incl. trailing area
	pdurExclTrail	-	(OUT)  dur of line excl. trailing area

----------------------------------------------------------------------------*/

LSERR  GetLineDurCore	(PLSC plsc,	long* pdurInclTrail, long* pdurExclTrail)
	{
	PLSDNODE plsdn;
	LSERR lserr;
	long durTrail;
	LSDCP dcpTrail;
	PLSDNODE plsdnStartTrail;
	LSDCP dcpStartTrailingText;
	int cDnodesTrailing;
	PLSDNODE plsdnTrailingObject;
	LSDCP dcpTrailingObject;
	BOOL fClosingBorderStartsTrailing;

	plsdn = GetCurrentDnode(plsc); 
	*pdurInclTrail = GetCurrentUr(plsc);
	*pdurExclTrail = *pdurInclTrail;

	
	if (plsdn != NULL && !FIsNotInContent(plsdn))
		{
		
		lserr = GetTrailingInfoForTextGroupChunk(plsdn, plsdn->dcp, 
			IobjTextFromLsc(&plsc->lsiobjcontext),
			&durTrail, &dcpTrail, &plsdnStartTrail,
			&dcpStartTrailingText, &cDnodesTrailing, &plsdnTrailingObject,
			&dcpTrailingObject, &fClosingBorderStartsTrailing);
		
		if (lserr != lserrNone) 
			return lserr;
		
		*pdurExclTrail = *pdurInclTrail - durTrail;
		}
	
	return lserrNone;
	
	}


/* ---------------------------------------------------------------------- */

/*  G E T  M I N  D U R  B R E A K S  C O R E */
/*----------------------------------------------------------------------------
    %%Function: GetMinDurBreaksCore
    %%Contact: igorzv
Parameters:
	plsc				-	(IN) LS context
	pdurMinInclTrail	-	(OUT) min dur between breaks including trailing area
	pdurMinExclTrail	-	(OUT) min dur between breaks excluding trailing area

----------------------------------------------------------------------------*/

LSERR  GetMinDurBreaksCore	(PLSC plsc,	long* pdurMinInclTrail, long* pdurMinExclTrail)
	{
	LSERR lserr;
	PLSCHUNKCONTEXT plschunkcontext;
	LOCCHNK* plocchnk;
	POINTUV point;
	long durTrail;
	DWORD cchTrail;
	POSINLINE posinline;
	POSINLINE posinlineBreak;
	BRKOUT brkout;
	long urBreakInclTrail = 0;
	long urBreakExclTrail = 0;
	long urBreakInclTrailPrev;
	long urBreakExclTrailPrev;
	BOOL fEndOfContent = fFalse;
	BRKKIND brkkind;
	PLSDNODE plsdnStartTrail;
	LSDCP dcpStartTrailingText;
	int cDnodesTrailing;
	PLSDNODE plsdnTrailingObject;
	LSDCP dcpTrailingObject;
	BOOL fClosingBorderStartsTrailing;
	
	
	plschunkcontext = PlschunkcontextFromSubline(GetCurrentSubline(plsc));
	plocchnk = &(plschunkcontext->locchnkCurrent);
	
	*pdurMinInclTrail = 0;
	*pdurMinExclTrail = 0;
	GetCurrentPoint(plsc, point);
	posinline.plssubl = GetCurrentSubline(plsc);
	posinline.pointStart = point;
	posinline.plsdn = GetCurrentDnode(plsc); 
	
	urBreakInclTrail = GetCurrentUr(plsc);
	urBreakExclTrail = urBreakInclTrail;

	/* REVIEW rewrite without code duplication and some probably superflous lines */
	/* don't forget about problem of dnode which submitted subline for trailing and skiping trailing
	area( tailing area in subline and dcp in parent dnode */


	if (posinline.plsdn != NULL && !FIsNotInContent(posinline.plsdn))
		{
		GetPointBeforeDnodeFromPointAfter(posinline.plsdn, &(posinline.pointStart));
		posinline.dcp = posinline.plsdn->dcp;
		
		lserr = GetTrailingInfoForTextGroupChunk(posinline.plsdn, posinline.dcp, 
			IobjTextFromLsc(&plsc->lsiobjcontext),
			&durTrail, &cchTrail, &plsdnStartTrail,
			&dcpStartTrailingText, &cDnodesTrailing,
			&plsdnTrailingObject, &dcpTrailingObject, &fClosingBorderStartsTrailing);
		
		if (lserr != lserrNone) 
			return lserr;
		
		urBreakExclTrail = urBreakInclTrail - durTrail;
		
		/* move before trailing area */
		while (posinline.plsdn != plsdnTrailingObject)
			{
			Assert(!fEndOfContent);
			GoPrevPosInLine(&posinline, fEndOfContent);
			}
		posinline.dcp = dcpTrailingObject;
		if (posinline.dcp == 0) /* move break before previous dnode */
			{
			do
				{
				GoPrevPosInLine(&posinline, fEndOfContent);
				/* we allow to put break before the first dnode but stop loop here */
				}
				while (!fEndOfContent && FIsDnodeBorder(posinline.plsdn) );
			}
		}
	else
		{
		fEndOfContent = fTrue;
		}

	if (fEndOfContent)
		{
		*pdurMinInclTrail = urBreakInclTrail;
		*pdurMinExclTrail = urBreakExclTrail;
		}


	while(!fEndOfContent)
		{
		/* find previous break */
		lserr = FindPrevBreakCore(urBreakInclTrail, &posinline,	fTrue,
			&brkout, &posinlineBreak, &brkkind);	
		if (lserr != lserrNone)
			return lserr;
		
		if (brkout.fSuccessful)
			{
			urBreakInclTrailPrev = posinlineBreak.pointStart.u + brkout.objdim.dur;
			lserr = GetTrailingInfoForTextGroupChunk(posinlineBreak.plsdn, 
				posinlineBreak.dcp, 
				IobjTextFromLsc(&plsc->lsiobjcontext),
				&durTrail, &cchTrail, &plsdnStartTrail,
				&dcpStartTrailingText, &cDnodesTrailing,
				&plsdnTrailingObject, &dcpTrailingObject, &fClosingBorderStartsTrailing);
			
			if (lserr != lserrNone) 
				return lserr;
			
			urBreakExclTrailPrev = urBreakInclTrailPrev - durTrail;
			
			/* commands bellow prepare posinline for the next iteration */
			if (posinlineBreak.plsdn->cpFirst > posinline.plsdn->cpFirst 
				|| (posinlineBreak.plsdn == posinline.plsdn && 
				    posinlineBreak.dcp >= posinline.dcp
					)
			   )
				{
				/* we are trying to avoid an infinite loop */
				if (posinline.dcp != 0) posinline.dcp--; 
				/* posinline.dcp can be equal to 0 here in the case pen, 
				code bellow under if (posinline.dcp == 0) will help us to avoid infinite loop in such case*/ 
				}
			else
				{
				posinline = posinlineBreak;
				/* move before trailing area */
				while (posinline.plsdn != plsdnTrailingObject)
					{
					Assert(!fEndOfContent);
					GoPrevPosInLine(&posinline, fEndOfContent);
					}
				posinline.dcp = dcpTrailingObject;

				}
			
			if (posinline.dcp == 0) /* move break before previous dnode */
				{
				do
					{
					GoPrevPosInLine(&posinline, fEndOfContent);
					/* we allow to put break before the first dnode but stop loop here */
					}
				while (!fEndOfContent && FIsDnodeBorder(posinline.plsdn) );
				}
			}
		else
			{
			urBreakInclTrailPrev = 0;
			urBreakExclTrailPrev = 0;
			fEndOfContent = fTrue;
			}
		
		/* calculate current value of the maximum distance between two break opportunites */
		if (urBreakInclTrail - urBreakInclTrailPrev > *pdurMinInclTrail)
			*pdurMinInclTrail = urBreakInclTrail - urBreakInclTrailPrev;
		
		if (urBreakExclTrail - urBreakInclTrailPrev > *pdurMinExclTrail)
			*pdurMinExclTrail = urBreakExclTrail - urBreakInclTrailPrev;
		
		/* prepare next iteration */
		urBreakInclTrail = urBreakInclTrailPrev;
		urBreakExclTrail = urBreakExclTrailPrev;
		
		}
	return lserrNone;
	
	}
	

/* F  C A N  B E F O R E  N E X T  C H U N K  C O R E */
/*----------------------------------------------------------------------------
    %%Function: FCanBreakBeforeNextChunkCore
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Last DNODE of the current chunk 
	pfCanBreakBeforeNextChun-(OUT) Can break before next chunk ? 

Called by text during find previous break when it's going to set break after last text dnode.
Procedure forwards this question to the next after text object
----------------------------------------------------------------------------*/

LSERR FCanBreakBeforeNextChunkCore(PLSC  plsc, PLSDNODE plsdn,	BOOL* pfCanBreakBeforeNextChunk)
	{
	LSERR lserr;
	PLSCHUNKCONTEXT plschunkcontextOld;
	PLSCHUNKCONTEXT plschunkcontextNew;
	BOOL fFound;
	PLSDNODE plsdnInChunk;
	DWORD idObj;
	POSICHNK posichnk;
	BRKCOND brkcond;
	PLSSUBL plssublOld;
	BRKOUT brkout;
	
	
	plschunkcontextOld = PlschunkcontextFromSubline(SublineFromDnode(plsdn));
	/* plsdnode should be the last dnode of the current chunk */
	Assert(plsdn == LastDnodeFromChunk(plschunkcontextOld));
	
	lserr = DuplicateChunkContext(plschunkcontextOld, &plschunkcontextNew);
	if (lserr != lserrNone)
		return lserr;
	
	lserr = CollectNextChunk(plschunkcontextNew, &fFound);
	if (lserr != lserrNone)
		return lserr;
	
	if (fFound)
		{
		plsdnInChunk = plschunkcontextNew->pplsdnChunk[0];
		
		if (FIsDnodePen(plsdnInChunk) || plsdnInChunk->fTab || FIsDnodeSplat(plsdnInChunk))
			{
			*pfCanBreakBeforeNextChunk = fTrue;
			}
		else
			{
			idObj = IdObjFromDnode(plsdnInChunk);
			
			
			/* we allow object handler to formate subline,
			so we restore current subline after calling him */
			plssublOld = GetCurrentSubline(plsc);
			SetCurrentSubline(plsc, NULL);
			
			
			/* we set truncation point to the first cp in chunk */
			posichnk.ichnk = 0;
			posichnk.dcp = 1;
			brkcond = brkcondCan;
			
			lserr = PLsimFromLsc(
				&plsc->lsiobjcontext, idObj)->pfnFindPrevBreakChunk(&(plschunkcontextNew->locchnkCurrent),  
				&posichnk, brkcond, &brkout);
			if (lserr != lserrNone)
				return lserr;
			
			SetCurrentSubline(plsc, plssublOld);
			
			if (!brkout.fSuccessful && brkout.brkcond == brkcondNever)
				*pfCanBreakBeforeNextChunk = fFalse;
			else
				*pfCanBreakBeforeNextChunk = fTrue;
			
			}
		}
	
	else
		{
		/* it cann't happen on a main subline */
		Assert(!FIsSubLineMain(SublineFromDnode(plsdn)));
		*pfCanBreakBeforeNextChunk = fTrue;
		}
	
	
	DestroyChunkContext(plschunkcontextNew);
	return lserrNone;
	
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\dispmisc.c ===
#include "dispmisc.h"
#include "lsdnode.h"
#include "lssubl.h"

static long	AddSublineAdvanceWidth(PLSSUBL plssubl);
static PLSDNODE AdvanceToNextVisualDnodeCore(PLSDNODE, LSTFLOW, POINTUV*);
static PLSDNODE NextVisualDnodeOnTheLevel(PLSDNODE pdn, LSTFLOW lstflowMain);

#define fUVerticalPlusVDirection	(fUVertical|fVDirection)			// see comments in lstfset.c 

// Has this dnode submitted subline(s) for display?
#define FIsSubmittingDnode(pdn) 	(FIsDnodeReal(pdn) && (pdn)->u.real.pinfosubl != NULL && 	\
									(pdn)->u.real.pinfosubl->fUseForDisplay)

// Has this dnode accepted subline(s) for display?
#define FIsAcceptingDnode(pdn) 	(FIsDnodeReal(pdn) && (pdn)->u.real.pinfosubl != NULL && 	\
									((pdn)->u.real.pinfosubl->rgpsubl)[0]->fAcceptedForDisplay)


//    %%Function:	CreateDisplayTree
//    %%Contact:	victork
//
/* 	CreateDisplayTree sets plsdnUpTemp in sublines to be displayed with given subline,
 *	rejects wrong sublines, submitted for display, sets fAcceptedForDisplay in good ones
 */

void CreateDisplayTree(PLSSUBL plssubl)
{
	LSTFLOW 	lstflowMain = plssubl->lstflow;	
	
	PLSDNODE 	pdn = plssubl->plsdnFirst;
	
	long		dupSum;
	BOOL 		fAccept;
	DWORD		i;
	LSTFLOW 	lstflowSubline;	
	
	while (pdn != NULL)							/* don't care about break */
		{
		if (FIsSubmittingDnode(pdn))
			{

			Assert(pdn->u.real.pinfosubl->cSubline > 0);
			
			fAccept = fTrue;

			lstflowSubline = ((pdn->u.real.pinfosubl->rgpsubl)[0])->lstflow;

			// reject if one tflow is vertical, another is horizontal or v-directions are not the same
			//		(see explanation of bits meaning in lstfset.c)
			
			if ((lstflowSubline ^ lstflowMain) & fUVerticalPlusVDirection)
				{
				fAccept = fFalse;
				}
				
			dupSum = 0;
			
			for (i = 0; i < pdn->u.real.pinfosubl->cSubline; i++)
				{
				dupSum += AddSublineAdvanceWidth((pdn->u.real.pinfosubl->rgpsubl)[i]);
				
				// all tflows should be the same
				
				if (((pdn->u.real.pinfosubl->rgpsubl)[i])->lstflow != lstflowSubline)
					{
					fAccept = fFalse;
					}
					
				// Submitting empty sublines is prohibited
				
				if (((pdn->u.real.pinfosubl->rgpsubl)[i])->plsdnFirst == NULL)
					{
					fAccept = fFalse;
					}		
				}
				
			// reject if sublines don't sum up to the dnode width
			
			if (dupSum != pdn->u.real.dup)
				{
				fAccept = fFalse;
				}
				
			if (fAccept)
				{
				for (i = 0; i < pdn->u.real.pinfosubl->cSubline; i++)
					{
					((pdn->u.real.pinfosubl->rgpsubl)[i])->plsdnUpTemp = pdn;
					((pdn->u.real.pinfosubl->rgpsubl)[i])->fAcceptedForDisplay = fTrue;
					CreateDisplayTree((pdn->u.real.pinfosubl->rgpsubl)[i]);
					}
				}
			}
				
		pdn = pdn->plsdnNext;
		}
}


//    %%Function:	DestroyDisplayTree
//    %%Contact:	victork
//
/*
 * 	DestroyDisplayTree nulls plsdnUpTemp in sublines displayed with given subline.
 */

void DestroyDisplayTree(PLSSUBL plssubl)
{
	PLSDNODE 	pdn = plssubl->plsdnFirst;
	DWORD		i;
	
	while (pdn != NULL)							/* don't care about break */
		{
		if (FIsAcceptingDnode(pdn))
			{
			for (i = 0; i < pdn->u.real.pinfosubl->cSubline; i++)
				{
				((pdn->u.real.pinfosubl->rgpsubl)[i])->plsdnUpTemp = NULL;
				((pdn->u.real.pinfosubl->rgpsubl)[i])->fAcceptedForDisplay = fFalse;
				DestroyDisplayTree((pdn->u.real.pinfosubl->rgpsubl)[i]);
				}
			}
				
		pdn = pdn->plsdnNext;
		}
}


//    %%Function:	AdvanceToNextDnode
//    %%Contact:	victork
//
/* 
 *	Advance to the next (visual) node and update pen position, skipping submitting dnodes.
 */
 
PLSDNODE AdvanceToNextDnode(PLSDNODE pdn, LSTFLOW lstflowMain, POINTUV* pptpen)
{
	// move to the next
	
	pdn = AdvanceToNextVisualDnodeCore(pdn, lstflowMain, pptpen);

	// skip submitting dnodes
	
	while (pdn != NULL && FIsAcceptingDnode(pdn))
		{
		pdn = AdvanceToNextVisualDnodeCore(pdn, lstflowMain, pptpen);
		}
		
	return pdn;	
}

//    %%Function:	AdvanceToFirstDnode
//    %%Contact:	victork
//
PLSDNODE AdvanceToFirstDnode(PLSSUBL plssubl, LSTFLOW lstflowMain, POINTUV* pptpen)
{
	PLSDNODE pdn = plssubl->plsdnFirst;

	if (pdn != NULL && FIsAcceptingDnode(pdn))
		{
		pdn = AdvanceToNextDnode(pdn, lstflowMain, pptpen);
		}
		
	return pdn;	
}


//    %%Function:	AdvanceToNextSubmittingDnode
//    %%Contact:	victork
//
/* 
 *	Advance to the next (visual) node and update pen position, stopping only at submitting dnodes.
 */
 
PLSDNODE AdvanceToNextSubmittingDnode(PLSDNODE pdn, LSTFLOW lstflowMain, POINTUV* pptpen)
{
	// move to the next
	
	pdn = AdvanceToNextVisualDnodeCore(pdn, lstflowMain, pptpen);

	// skip non-submitting dnodes
	
	while (pdn != NULL && !FIsAcceptingDnode(pdn))
		{
		pdn = AdvanceToNextVisualDnodeCore(pdn, lstflowMain, pptpen);
		}
		
	return pdn;	
}

//    %%Function:	AdvanceToFirstSubmittingDnode
//    %%Contact:	victork
//
PLSDNODE AdvanceToFirstSubmittingDnode(PLSSUBL plssubl, LSTFLOW lstflowMain, POINTUV* pptpen)
{
	PLSDNODE pdn = plssubl->plsdnFirst;

	if (pdn != NULL && !FIsAcceptingDnode(pdn))
		{
		pdn = AdvanceToNextSubmittingDnode(pdn, lstflowMain, pptpen);
		}
		
	return pdn;	
}


//    %%Function:	AdvanceToNextVisualDnodeCore
//    %%Contact:	victork
//
/* 
 *	Advance to the next node and update pen position
 *	Goes into sublines, submitted for display, traversing the whole display tree.
 *	Stops at dnodes that submitted subline on the way down, skips them going up, so that
 *	every dnode is visited once with pen position at the start of it in visual order.
 */

static PLSDNODE AdvanceToNextVisualDnodeCore(PLSDNODE pdn, LSTFLOW lstflowMain, POINTUV* pptpen)
{

	PLSDNODE 	pdnNextVisual, pdnTop;
	PLSSUBL		plssublCurrent;
	long		cSublines, i;
	PLSSUBL* 	rgpsubl;

	if (FIsAcceptingDnode(pdn))
		{
		
		// Last time we stopped at submitting dnode -
		//	now don't move pen point, go down to the VisualStart of the VisualFirst subline.
		
		rgpsubl = pdn->u.real.pinfosubl->rgpsubl;
		cSublines = pdn->u.real.pinfosubl->cSubline;
		
		if (rgpsubl[0]->lstflow == lstflowMain)
			{
			pdnNextVisual = rgpsubl[0]->plsdnFirst;
			}
		else
			{
			pdnNextVisual = rgpsubl[cSublines - 1]->plsdnLastDisplay;
			}
		}
	else
		{
		// update pen position - we always move to the (visual) right, all vs are the same tflow
		
		if (pdn->klsdn == klsdnReal)
			{
			pptpen->u += pdn->u.real.dup;										
			}
		else
			{
			pptpen->u += pdn->u.pen.dup;
			pptpen->v += pdn->u.pen.dvp;
			}
			
		plssublCurrent = pdn->plssubl;

		// go to the next dnode of the current subline in visual order
		
		pdnNextVisual = NextVisualDnodeOnTheLevel(pdn, lstflowMain);

		// If current subline is ended, (try) change subline.
			
		if (pdnNextVisual == NULL)
			{
			// 		Change subline
			//
			//	In the loop: pdnNextVisual != NULL signals that next dnode is successfully found.
			//	If 	pdnNextVisual == NULL, plssublCurrent is the subline just exhausted.
			//	One run of the loop replaces current subline with another subline on the same level
			//	(such change always ends the loop) or with parent subline.
			
			while (pdnNextVisual == NULL && plssublCurrent->plsdnUpTemp != NULL)
				{
				
				// find (the index of) the current subline in the list of submitted sublines
				
				pdnTop = plssublCurrent->plsdnUpTemp;
				rgpsubl = pdnTop->u.real.pinfosubl->rgpsubl;
				cSublines = pdnTop->u.real.pinfosubl->cSubline;
				
				for (i=0; i < cSublines && plssublCurrent != rgpsubl[i]; i++);
				
				Assert(i < cSublines);

				// do we have "next" subline? If we do, pdnNextVisual we seek "starts" it.
				
				if (pdnTop->plssubl->lstflow == lstflowMain)
					{
					i++;
					if (i < cSublines)
						{
						plssublCurrent = rgpsubl[i];
						pdnNextVisual = plssublCurrent->plsdnFirst;
						}
					}
				else
					{
					i--;
					if (i >= 0)
						{
						plssublCurrent = rgpsubl[i];
						pdnNextVisual = plssublCurrent->plsdnLastDisplay;
						}
					}

				//	We don't, let's try next dnode on the upper level.
				
				if (pdnNextVisual == NULL)
					{
					plssublCurrent = pdnTop->plssubl;
					pdnNextVisual = NextVisualDnodeOnTheLevel(pdnTop, lstflowMain);
					}
				}
			}
		}
	
	return pdnNextVisual;
}


//    %%Function:	NextVisualDnodeOnTheLevel
//    %%Contact:	victork
//
// find next dnode on the level moving right or left, signalling end with a NULL

static PLSDNODE NextVisualDnodeOnTheLevel(PLSDNODE pdn, LSTFLOW lstflowMain)
{
	if (pdn->plssubl->lstflow == lstflowMain)
		{
		if (pdn == pdn->plssubl->plsdnLastDisplay)
			{
			return NULL;
			}
		else
			{
			return pdn->plsdnNext;
			}
		}
	return pdn->plsdnPrev;
}


//    %%Function:	AddSublineAdvanceWidth
//    %%Contact:	victork
//
// Note: It is not subline width as calculated in GetObjDimSubline

static long	AddSublineAdvanceWidth(PLSSUBL plssubl)
{
	long		dupSum;
	PLSDNODE 	pdn;

	pdn = plssubl->plsdnFirst;
	dupSum = 0;
	
	while (pdn != NULL)
		{
		if (pdn->klsdn == klsdnReal)
			{
			dupSum += pdn->u.real.dup;
			}
		else 								/*  pen, border */
			{  
			dupSum += pdn->u.pen.dup;
			}

		if (pdn == plssubl->plsdnLastDisplay)
			{
			pdn = NULL;
			}
		else
			{
			pdn = pdn->plsdnNext;
			Assert(pdn != NULL);				// plsdnLastDisplay should prevent this	
			}
		}
		
	return dupSum;
}


// NB Victork - following functions were used only for upClipLeft, upClipRight optimization.
// If we'll decide that we do need that optimization after Word integration - I'll uncomment.

#ifdef NEVER
//    %%Function:	RectUVFromRectXY
//    %%Contact:	victork
//
//	There is an assymetry in the definition of the rectangle.
//	(Left, Top) belongs to rectangle and (Right, Bottom) doesn't,
//  It makes following procedures hard to understand and write.
//	So I first cut off the points that don't belong, then turn the rectangle, then add extra 
//	points again and hope compiler will make it fast.

// RectUVFromRectXY calculates (clip) rectangle in local (u,v) coordinates given
//								(clip) rectangle in (x,y) and point of origin 

void RectUVFromRectXY(const POINT* pptXY, 		/* IN: point of origin for local coordinates (x,y) */
						const RECT* prectXY,	/* IN: input rectangle (x,y) */
						LSTFLOW lstflow, 		/* IN: local text flow */
						RECTUV* prectUV)		/* OUT: output rectangle (u,v) */
{
	switch (lstflow)
		{
		case lstflowES:												/* latin */
			prectUV->upLeft = (prectXY->left - pptXY->x);
			prectUV->upRight = (prectXY->right - 1 - pptXY->x) + 1;
			prectUV->vpTop = -(prectXY->top - pptXY->y);
			prectUV->vpBottom = -(prectXY->bottom - 1 - pptXY->y) - 1;
			return;

		case lstflowSW:												/* vertical FE */
			prectUV->upLeft = (prectXY->top - pptXY->y);
			prectUV->upRight = (prectXY->bottom - 1 - pptXY->y) + 1;
			prectUV->vpTop = (prectXY->right - 1 - pptXY->x);
			prectUV->vpBottom = (prectXY->left - pptXY->x) - 1;
			return;

		case lstflowWS:												/* BiDi */
			prectUV->upLeft = -(prectXY->right - 1 - pptXY->x);
			prectUV->upRight = -(prectXY->left - pptXY->x) + 1;
			prectUV->vpTop = -(prectXY->top - pptXY->y);
			prectUV->vpBottom = -(prectXY->bottom - 1 - pptXY->y) - 1;
			return;

		case lstflowEN:
			prectUV->upLeft = (prectXY->left - pptXY->x);
			prectUV->upRight = (prectXY->right - 1 - pptXY->x) + 1;
			prectUV->vpTop = (prectXY->bottom - 1 - pptXY->y);
			prectUV->vpBottom = (prectXY->top - pptXY->y) - 1;
			return;

		case lstflowSE:
			prectUV->upLeft = (prectXY->top - pptXY->y);
			prectUV->upRight = (prectXY->bottom - 1 - pptXY->y) + 1;
			prectUV->vpTop = -(prectXY->left - pptXY->x);
			prectUV->vpBottom = -(prectXY->right - 1 - pptXY->x) - 1;
			return;

		case lstflowWN:
			prectUV->upLeft = -(prectXY->right - 1 - pptXY->x);
			prectUV->upRight = -(prectXY->left - pptXY->x) + 1;
			prectUV->vpTop = (prectXY->bottom - 1 - pptXY->y);
			prectUV->vpBottom = (prectXY->top - pptXY->y) - 1;
			return;

		case lstflowNE:
			prectUV->upLeft = -(prectXY->bottom - 1 - pptXY->y);
			prectUV->upRight = -(prectXY->top - pptXY->y) + 1;
			prectUV->vpTop = -(prectXY->left - pptXY->x);
			prectUV->vpBottom = -(prectXY->right - 1 - pptXY->x) - 1;
			return;

		case lstflowNW:
			prectUV->upLeft = -(prectXY->bottom - 1 - pptXY->y);
			prectUV->upRight = -(prectXY->top - pptXY->y) + 1;
			prectUV->vpTop = (prectXY->right - 1 - pptXY->x);
			prectUV->vpBottom = (prectXY->left - pptXY->x) - 1;
			return;
		default:
			NotReached();
		}
}


//    %%Function:	RectXYFromRectUV
//    %%Contact:	victork
//
// RectXYFromRectUV calculates rectangle in (x,y) coordinates given rectangle in local (u,v) 
//							and point of origin (x,y) for local coordinate system


void RectXYFromRectUV(const POINT* pptXY, 		/* IN: point of origin for local coordinates (x,y) */
						PCRECTUV prectUV,		/* IN: input rectangle (u,v) */
						LSTFLOW lstflow, 		/* IN: local text flow */
						RECT* prectXY)			/* OUT: output rectangle (x,y) */
{
	switch (lstflow)
		{
		case lstflowES:												/* latin */
			prectXY->left = pptXY->x + prectUV->upLeft;
			prectXY->right = pptXY->x + (prectUV->upRight - 1) + 1;
			prectXY->top = pptXY->y - (prectUV->vpTop);
			prectXY->bottom = pptXY->y - (prectUV->vpBottom + 1) + 1;
			return;

		case lstflowSW:												/* vertical FE */
			prectXY->left = pptXY->x + (prectUV->vpBottom + 1);
			prectXY->right = pptXY->x + (prectUV->vpTop) + 1;
			prectXY->top = pptXY->y + prectUV->upLeft;
			prectXY->bottom = pptXY->y + (prectUV->upRight - 1) + 1;
			return;

		case lstflowWS:												/* BiDi */
			prectXY->left = pptXY->x - (prectUV->upRight - 1);
			prectXY->right = pptXY->x - prectUV->upLeft + 1;
			prectXY->top = pptXY->y - (prectUV->vpTop);
			prectXY->bottom = pptXY->y - (prectUV->vpBottom + 1) + 1;
			return;

		case lstflowEN:
			prectXY->left = pptXY->x + prectUV->upLeft;
			prectXY->right = pptXY->x + (prectUV->upRight - 1) + 1;
			prectXY->top = pptXY->y + (prectUV->vpBottom + 1);
			prectXY->bottom = pptXY->y + (prectUV->vpTop) + 1;
			return;

		case lstflowSE:
			prectXY->left = pptXY->x - (prectUV->vpTop);
			prectXY->right = pptXY->x - (prectUV->vpBottom + 1) + 1;
			prectXY->top = pptXY->y + prectUV->upLeft;
			prectXY->bottom = pptXY->y + (prectUV->upRight - 1) + 1;
			return;

		case lstflowWN:
			prectXY->left = pptXY->x - (prectUV->upRight - 1);
			prectXY->right = pptXY->x - prectUV->upLeft + 1;
			prectXY->top = pptXY->y + (prectUV->vpBottom + 1);
			prectXY->bottom = pptXY->y + (prectUV->vpTop) + 1;
			return;

		case lstflowNE:
			prectXY->left = pptXY->x - (prectUV->vpTop);
			prectXY->right = pptXY->x - (prectUV->vpBottom + 1) + 1;
			prectXY->top = pptXY->y - (prectUV->upRight - 1);
			prectXY->bottom = pptXY->y - prectUV->upLeft + 1;
			return;

		case lstflowNW:
			prectXY->left = pptXY->x + (prectUV->vpBottom + 1);
			prectXY->right = pptXY->x + (prectUV->vpTop) + 1;
			prectXY->top = pptXY->y - (prectUV->upRight - 1);
			prectXY->bottom = pptXY->y - prectUV->upLeft + 1;
			return;
			
		default:
			NotReached();
		}
}
#endif /* NEVER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\disptext.c ===
/*
 *	Contains Display and CalcPres methods of display object
 */ 

#include "disptext.h"
#include "dispmisc.h"
#include "lsdevice.h"
#include "lstfset.h"
#include "lstxtmap.h"
#include "dispi.h"
#include "txtobj.h"
#include "txtln.h"
#include "txtils.h"
#include "lschp.h"

#define TABBUFSIZE 32

static LSERR DisplayGlyphs(PTXTOBJ ptxtobj, PCDISPIN pdispin);
static LSERR DisplayTabLeader(PCDISPIN pdispin, PILSOBJ pilsobj, WCHAR wchtl);

//    %%Function:	DisplayText
//    %%Contact:	victork
//
LSERR WINAPI DisplayText(PDOBJ pdo, PCDISPIN pdispin)
{
   	LSERR 	lserr;
	PTXTOBJ ptxtobj;
	WCHAR 	wchSave;
	WCHAR* 	pwch;
	int 	iwch;
	int 	cwch;
	PILSOBJ pilsobj;
	POINT	ptOrg, ptExtTextOut;
	POINTUV	ptLeftCut;

	long 	dupStart;
	long 	dupPenStart;
	long* 	pdup;
	long* 	pdupPen;
	long* 	rgdupLeftCut;
	int 	i;
	void* 	(WINAPI* pfnNewPtr)(POLS, DWORD);
	void  	(WINAPI* pfnDisposePtr)(POLS, void*);


	ptxtobj = (PTXTOBJ) pdo;
	pilsobj = ptxtobj->plnobj->pilsobj;

	Assert(ptxtobj->txtkind == txtkindRegular 			||
			ptxtobj->txtkind == txtkindHardHyphen  		||
			ptxtobj->txtkind == txtkindTab 				||
			ptxtobj->txtkind == txtkindNonReqHyphen 	||
			ptxtobj->txtkind == txtkindYsrChar			|| 
			ptxtobj->txtkind == txtkindNonBreakSpace 	||	
			ptxtobj->txtkind == txtkindNonBreakHyphen	||
			ptxtobj->txtkind == txtkindOptNonBreak 		||
			ptxtobj->txtkind == txtkindSpecSpace		|| 
			ptxtobj->txtkind == txtkindOptBreak 		||
			ptxtobj->txtkind == txtkindEOL );

	if (ptxtobj->txtkind == txtkindTab) 				
		{
		Assert(ptxtobj->dupBefore == 0);

		if (pdispin->dup <= 0)								/* do nothing for zero-length tab */
			{
			return lserrNone;
			}

		// Draw tab only if it is visi case

		if (ptxtobj->txtf&txtfVisi)
			{
			lserr = (*pilsobj->plscbk->pfnDrawTextRun)(pilsobj->pols, pdispin->plsrun,
											FALSE, FALSE,					/* Tab leader will take care of UL */
											&(pdispin->ptPen), &(pilsobj->wchVisiTab), 
											(const int*) &(pdispin->dup), 1, 
											pdispin->lstflow, (const) pdispin->kDispMode, 
											&(pdispin->ptPen), &(pdispin->heightsPres), pdispin->dup, 
											pdispin->dupLimUnderline, pdispin->prcClip);
			if (lserr != lserrNone) return lserr;
			}

		if (ptxtobj->u.tab.wchTabLeader == pilsobj->wchSpace)
			{
			
			// it is OK to draw the space in one take
			
			lserr = (*pilsobj->plscbk->pfnDrawTextRun)(pilsobj->pols, pdispin->plsrun,
											pdispin->fDrawStrikethrough, pdispin->fDrawUnderline,
											&(pdispin->ptPen), &(pilsobj->wchSpace), 
											(const int*) &(pdispin->dup), 1, 
											pdispin->lstflow, (const) pdispin->kDispMode, 
											&(pdispin->ptPen), &(pdispin->heightsPres), pdispin->dup, 
											pdispin->dupLimUnderline, pdispin->prcClip);
			}
		else
			{
			
			// we should apply tab leader alingment logic
			
			lserr = DisplayTabLeader(pdispin, pilsobj, ptxtobj->u.tab.wchTabLeader);
			}

		return lserr;
		}

	if (ptxtobj->txtf & txtfGlyphBased)
		{
		return DisplayGlyphs(ptxtobj, pdispin);
		}
		
	iwch = ptxtobj->iwchFirst;
	pwch = ptxtobj->plnobj->pwch + iwch;
	cwch = ptxtobj->iwchLim - iwch;
	
	if (cwch == 0)									// nothing to display
		{
		return lserrNone;
		}

	Assert(ptxtobj->plnobj->pdupPen == ptxtobj->plnobj->pdup || ptxtobj->plnobj->pdupPen == ptxtobj->plnobj->pdupPenAlloc);

	pdupPen = ptxtobj->plnobj->pdupPen + iwch;

	ptOrg = pdispin->ptPen;

	if (ptxtobj->dupBefore == 0)
		{
		ptExtTextOut = ptOrg;
		}
	else
		{
		ptLeftCut.u = -ptxtobj->dupBefore;
		ptLeftCut.v = 0;
		LsPointXYFromPointUV(&(ptOrg), pdispin->lstflow, &ptLeftCut, &ptExtTextOut);
		}

	// Have to deal with special spaces before DrawTextRun
	
	if (ptxtobj->txtkind == txtkindSpecSpace && !(ptxtobj->txtf&txtfVisi))
		{
		wchSave = *pwch;								// remember actual code
		
		for (i = 0; i < cwch; i++)
			{
			pwch[i] = pilsobj->wchSpace;				// replace special spaces with the normal space
			}
			
		lserr = (*pilsobj->plscbk->pfnDrawTextRun)(pilsobj->pols, pdispin->plsrun, 
										pdispin->fDrawStrikethrough, pdispin->fDrawUnderline,
	                               		&ptExtTextOut, pwch, (const int*) pdupPen, cwch,
										pdispin->lstflow, pdispin->kDispMode, 
										&ptOrg, &(pdispin->heightsPres), 
										pdispin->dup, pdispin->dupLimUnderline, pdispin->prcClip);
		if (lserr != lserrNone) return lserr;
		
		for (i = 0; i < cwch; i++)
			{
			pwch[i] = wchSave;							// restore special spaces
			}
		}
	else
		{
		lserr = (*pilsobj->plscbk->pfnDrawTextRun)(pilsobj->pols, pdispin->plsrun, 
										pdispin->fDrawStrikethrough, pdispin->fDrawUnderline,
	                               		&ptExtTextOut, pwch, (const int*) pdupPen, cwch,
										pdispin->lstflow, pdispin->kDispMode, 
										&ptOrg, &(pdispin->heightsPres), 
										pdispin->dup, pdispin->dupLimUnderline, pdispin->prcClip);
		if (lserr != lserrNone) return lserr;
		}


	if (pdispin->plschp->EffectsFlags)
		{
		pfnNewPtr = pilsobj->plscbk->pfnNewPtr;
		pfnDisposePtr = pilsobj->plscbk->pfnDisposePtr;

		/* create array for LeftCut info */
		rgdupLeftCut = pfnNewPtr(pilsobj->pols, cwch * sizeof(*rgdupLeftCut));
		if (rgdupLeftCut == NULL)
			return lserrOutOfMemory;

		/* fill LeftCut info array */
		pdup = ptxtobj->plnobj->pdup + iwch;
		dupStart = pdup[0];								/* the beginning of char */
		dupPenStart = pdupPen[0];						/* starting position for drawing char */

		for (i = 1; i < cwch; i++)
			{
			rgdupLeftCut[i] = dupStart - dupPenStart;
			dupStart  += pdup[i];
			dupPenStart  += pdupPen[i];
			}

		rgdupLeftCut[0] = ptxtobj->dupBefore;

		lserr = (*pilsobj->plscbk->pfnDrawEffects)(pilsobj->pols, pdispin->plsrun, pdispin->plschp->EffectsFlags,
	                               		&(ptOrg), pwch, (const int*) pdup, (const int*) rgdupLeftCut, 
										ptxtobj->iwchLim - iwch,
										pdispin->lstflow, pdispin->kDispMode, &(pdispin->heightsPres), 
										pdispin->dup, pdispin->dupLimUnderline, pdispin->prcClip);

		/* dispose of the array for LeftCut info */
		pfnDisposePtr(pilsobj->pols, rgdupLeftCut);
		}

	return lserr;
}




//    %%Function:	DisplayTabLeader
//    %%Contact:	victork
//
static LSERR DisplayTabLeader(PCDISPIN pdispin, PILSOBJ pilsobj, WCHAR wchtl)
{
	LSTFLOW lstflow = pdispin->lstflow;
	LONG	dupSum, dupCh, dupAdj, z, zOnGrid;
	BOOL 	fGrow;
	WCHAR	rgwch[TABBUFSIZE];
	LONG	rgdup[TABBUFSIZE];
	LONG	dupbuf;
	int		i = 0, cwch, cwchout;
	LSERR	lserr;
	POINT	pt;
	POINTUV	ptAdj = {0,0};

	lserr = (*pilsobj->plscbk->pfnGetRunCharWidths)(pilsobj->pols, pdispin->plsrun,
						lsdevPres, (LPCWSTR) &wchtl, 1,
						pdispin->dup, lstflow, (int*) &dupCh, &dupSum, (LONG*) &i);
						
	if (lserr != lserrNone) return lserr;
	
	if (i == 0 || dupCh <= 0) dupCh = 1;	

	for (i = 0; i < TABBUFSIZE; ++i)
		{
		rgwch[i] = wchtl;
		rgdup[i] = dupCh;
		}

	/* advance to next multiple of dupCh 
	
		dupAdj is the distance between "pt.z" and the next integral multiple of dupch.
		I.e. dupAdj = N * dupCh - "pt.x" where N is the smallest integer such that
		N * dupCh is not less than "pt.x" in Latin case. 
		The starting pen position will be "rounded"	to this "dupCh stop" by the assignment 
		"pt.z += dupAdj" in the code below.
		
		Complications are:	
		
		depending on lstflow "z" can be either x or y;
		depending on lstflow next can be bigger (Grow) or smaller;
		Simple formula dupAdj = (ptPen.x + dupCh - 1) / dupCh * dupCh - ptPen.x	does not
			necessarily work if ptPen.x is negative;
	*/

	if (lstflow & fUVertical)
		{
		z = pdispin->ptPen.y;
		}
	else
		{
		z = pdispin->ptPen.x;
		}

	if (lstflow & fUDirection)
		{
		fGrow = fFalse;
		}
	else
		{
		fGrow = fTrue;
		}

	zOnGrid = (z / dupCh) * dupCh;

	// zOnGrid is on grid, but maybe from the wrong side

	if (zOnGrid == z)
		{
		dupAdj = 0;
		}
	else if (zOnGrid > z)
		{
		if (fGrow)
			{
			dupAdj = zOnGrid - z;				// zOnGrid is the point we want
			}
		else
			{
			dupAdj = dupCh - (zOnGrid - z);		// zOnGrid is on the wrong side
			}
		}
	else	// zOnGrid < z
		{
		if (!fGrow)
			{
			dupAdj = z - zOnGrid;				// zOnGrid is the point we want
			}
		else
			{
			dupAdj = dupCh - (z - zOnGrid);		// zOnGrid is on the wrong side
			}
		}

	cwch = (pdispin->dup - dupAdj) / dupCh;	/* always round down */
	dupbuf = dupCh * TABBUFSIZE;

#ifdef NEVER			//  We've decided to kill rcClip optimization for now.
	while (cwch > 0 && up <= pdispin->rcClip.right && lserr == lserrNone)
#endif /* NEVER */

	while (cwch > 0 && lserr == lserrNone)
		{
		cwchout = cwch < TABBUFSIZE ? cwch : TABBUFSIZE;
		
		ptAdj.u = dupAdj;
		LsPointXYFromPointUV(&(pdispin->ptPen), lstflow, &ptAdj, &(pt));

		lserr =  (*pilsobj->plscbk->pfnDrawTextRun)(pilsobj->pols, pdispin->plsrun, 
									pdispin->fDrawStrikethrough, pdispin->fDrawUnderline,
                               		&pt, rgwch, (const int*) rgdup, cwchout,
									lstflow, pdispin->kDispMode, &pt, &(pdispin->heightsPres), 
									dupCh * cwchout, pdispin->dupLimUnderline, pdispin->prcClip);
		cwch -= cwchout;
		dupAdj += dupbuf;
		}
	return lserr;
}


//    %%Function:	DisplayGlyphs
//    %%Contact:	victork
//
static LSERR DisplayGlyphs(PTXTOBJ ptxtobj, PCDISPIN pdispin)
{
   	LSERR	lserr;
	PLNOBJ	plnobj = ptxtobj->plnobj;
	PILSOBJ	pilsobj = plnobj->pilsobj;

	WCHAR* 	pwch;
	int 	iwch;
	int 	cwch;

	if (plnobj->fDrawInCharCodes)
		{
		// for meta-file output we call pfnDrawTextRun without widths
		
		iwch = ptxtobj->iwchFirst;
		pwch = ptxtobj->plnobj->pwch + iwch;
		cwch = ptxtobj->iwchLim - iwch;
		
		lserr = (*pilsobj->plscbk->pfnDrawTextRun)(pilsobj->pols, pdispin->plsrun, 
										pdispin->fDrawStrikethrough, pdispin->fDrawUnderline,
	                               		&(pdispin->ptPen), pwch, NULL, cwch,
										pdispin->lstflow, pdispin->kDispMode, 
										&(pdispin->ptPen), &(pdispin->heightsPres), 
										pdispin->dup, pdispin->dupLimUnderline, pdispin->prcClip);
		}
	else
		{
		lserr = (*pilsobj->plscbk->pfnDrawGlyphs)(pilsobj->pols, pdispin->plsrun, 
										pdispin->fDrawStrikethrough, pdispin->fDrawUnderline,
										&plnobj->pgind[ptxtobj->igindFirst],
										(const int*)&plnobj->pdupGind[ptxtobj->igindFirst],
										(const int*)&plnobj->pdupBeforeJust[ptxtobj->igindFirst],
										&plnobj->pgoffs[ptxtobj->igindFirst],
										&plnobj->pgprop[ptxtobj->igindFirst],
										&plnobj->pexpt[ptxtobj->igindFirst],
										ptxtobj->igindLim - ptxtobj->igindFirst,
										pdispin->lstflow, pdispin->kDispMode, 
										&(pdispin->ptPen), &(pdispin->heightsPres), 
										pdispin->dup, pdispin->dupLimUnderline, pdispin->prcClip);
		}
									
	return lserr;
	
}


//    %%Function:	CalcPresentationText
//    %%Contact:	victork
//
/*	
 *	CalcPres for text is called only for the dnode between autonumbering dnode and main text.
 *	The dnode should contain one character (space).
 */

LSERR WINAPI CalcPresentationText(PDOBJ pdobj, long dup, LSKJUST lskj, BOOL fLastOnLine)
{

	PTXTOBJ ptxtobj = (PTXTOBJ)pdobj;

	Unreferenced(lskj);
	Unreferenced(fLastOnLine);
	
	Assert(ptxtobj->txtkind == txtkindRegular);
	Assert(ptxtobj->iwchFirst + 1 == ptxtobj->iwchLim);

	(ptxtobj->plnobj->pdup)[ptxtobj->iwchFirst] = dup;

	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\dispul.c ===
#include "dispul.h"
#include "lsc.h"    
#include "lsdnode.h"
#include "lstfset.h"
#include "lsulinfo.h"
#include "lsstinfo.h"
#include "dninfo.h"
#include "dispmisc.h"

#include "zqfromza.h"


/* GetULMetric output */
typedef struct {
    UINT kul;                   
    DWORD cNumberOfLines;       
    __int64 dvpUnderlineOriginOffset;       
    __int64 dvpFirstUnderlineOffset;    
    __int64 dvpFirstUnderlineSize;      
    __int64 dvpGapBetweenLines;     
    __int64 dvpSecondUnderlineSize; 
} ULMETRIC;

/* weighted sums for averaging */
typedef struct {
    __int64 dupSum;                     // the sum of weights
    
    __int64 dvpFirstUnderlineOffset;        // unnormalized values -
    __int64 dvpFirstUnderlineSize;      
    __int64 dvpGapBetweenLines;         // divide them by dupSum    
    __int64 dvpSecondUnderlineSize;     // to get weighted averages
} ULMETRICSUM;

//    %%Function:   InitULMetricSums
//    %%Contact:    victork
//
// Neighbouring dnodes with good metrics and same baseline get averaged.
// We use weighted average with dnode width for weights.
// If the first dnode to participate in averaging happens to have zero width (almost never),
// we arbitrarily change width to 1. This hack changes result very slightly and in a very rare case,
// but simplify the logic considerably.

static void InitULMetricSums(long dup, const ULMETRIC* pulm, ULMETRICSUM* pulmSum)
{
    Assert(dup >= 0);
    
    if (dup == 0)
        {
        dup = 1;
        }
    pulmSum->dvpFirstUnderlineOffset = Mul64 (pulm->dvpFirstUnderlineOffset, dup);
    pulmSum->dvpFirstUnderlineSize = Mul64 (pulm->dvpFirstUnderlineSize, dup);
    pulmSum->dvpGapBetweenLines = Mul64 (pulm->dvpGapBetweenLines, dup);
    pulmSum->dvpSecondUnderlineSize = Mul64 (pulm->dvpSecondUnderlineSize, dup);

    pulmSum->dupSum = dup;
}

//    %%Function:   AddToULMetricSums
//    %%Contact:    victork
//
static void AddToULMetricSums(long dup, const ULMETRIC* pulm, ULMETRICSUM* pulmSum)
{
    Assert(dup >= 0);
    
    /* Add to running sums */

    pulmSum->dvpFirstUnderlineOffset += Mul64 (pulm->dvpFirstUnderlineOffset, dup);
    pulmSum->dvpFirstUnderlineSize += Mul64 (pulm->dvpFirstUnderlineSize, dup);
    pulmSum->dvpGapBetweenLines += Mul64 (pulm->dvpGapBetweenLines, dup);
    pulmSum->dvpSecondUnderlineSize += Mul64 (pulm->dvpSecondUnderlineSize, dup);

    pulmSum->dupSum += dup;
}

//    %%Function:   GetAveragedMetrics
//    %%Contact:    victork
//
static void GetAveragedMetrics(const ULMETRICSUM* pulmSum, LSULMETRIC* pulm)
{
    __int64 dupSum = pulmSum->dupSum;
    
    Assert(dupSum > 0);
    
    /* divide by sum of weights */
    
    pulm->dvpFirstUnderlineOffset = (long) Div64 (pulmSum->dvpFirstUnderlineOffset + Div64 (dupSum, 2), dupSum);
    pulm->dvpFirstUnderlineSize = (long) Div64 (pulmSum->dvpFirstUnderlineSize + Div64 (dupSum, 2), dupSum);
    pulm->dvpGapBetweenLines = (long) Div64 (pulmSum->dvpGapBetweenLines + Div64 (dupSum, 2), dupSum);
    pulm->dvpSecondUnderlineSize = (long) Div64 (pulmSum->dvpSecondUnderlineSize + Div64 (dupSum, 2), dupSum);

    Assert (pulm->dvpFirstUnderlineOffset == Div64 (pulmSum->dvpFirstUnderlineOffset + Div64 (dupSum, 2), dupSum));
    Assert (pulm->dvpFirstUnderlineSize == Div64 (pulmSum->dvpFirstUnderlineSize + Div64 (dupSum, 2), dupSum));
    Assert (pulm->dvpGapBetweenLines == Div64 (pulmSum->dvpGapBetweenLines + Div64 (dupSum, 2), dupSum));
    Assert (pulm->dvpSecondUnderlineSize == Div64 (pulmSum->dvpSecondUnderlineSize + Div64 (dupSum, 2), dupSum));
}

//    %%Function:   GetULMetric
//    %%Contact:    victork
//
/*
 *      Normally, when underlining goes on the under (negative, descent) side,
 *          dvpFirstUnderlineOffset >= 0.
 *      However, underlining on the other side is possible too, (vertical Japanese)
 *
 *      Notice that offsets are from dnode baseline, not from the current baseline, so
 *      underline can be both above current baseline and on the under side for raised dnodes.
 *
 *      We have to be compatible with Word meaning what's good for him should be good for us (pity).
 *      For example, Word sometimes allow the lower UL to be below descent.
 */

static LSERR GetULMetric(PLSC plsc, PLSDNODE pdn, LSTFLOW lstflow,
                        BOOL* pfUnderlineFromBelow, ULMETRIC* pulm, BOOL *pfGood)
{
    LSULINFO lsulinfo;
    LSERR   lserr;
    long    dvpUnderlineLim;

    lserr = (*plsc->lscbk.pfnGetRunUnderlineInfo)(plsc->pols, pdn->u.real.plsrun,
                                                    &(pdn->u.real.objdim.heightsPres), lstflow,
                                                    &lsulinfo);
    if (lserr != lserrNone) return lserr;

    pulm->kul = lsulinfo.kulbase;
    pulm->cNumberOfLines = lsulinfo.cNumberOfLines;
    
    pulm->dvpFirstUnderlineSize = lsulinfo.dvpFirstUnderlineSize;

    *pfUnderlineFromBelow = (lsulinfo.dvpFirstUnderlineOffset >= lsulinfo.dvpUnderlineOriginOffset);

    if (*pfUnderlineFromBelow)
        {
        pulm->dvpFirstUnderlineOffset = lsulinfo.dvpFirstUnderlineOffset;
        pulm->dvpUnderlineOriginOffset = lsulinfo.dvpUnderlineOriginOffset;
        dvpUnderlineLim = pdn->u.real.objdim.heightsPres.dvDescent + pdn->u.real.lschp.dvpPos;
        }
    else
        {
        pulm->dvpFirstUnderlineOffset = -lsulinfo.dvpFirstUnderlineOffset;
        pulm->dvpUnderlineOriginOffset = -lsulinfo.dvpUnderlineOriginOffset;
        dvpUnderlineLim = pdn->u.real.objdim.heightsPres.dvAscent + 1 - pdn->u.real.lschp.dvpPos;
        }

    *pfGood = pulm->dvpFirstUnderlineSize > 0 &&
                (dvpUnderlineLim == 0 || pulm->dvpFirstUnderlineOffset < dvpUnderlineLim);
    
    if (lsulinfo.cNumberOfLines == 2)
        {
        pulm->dvpGapBetweenLines = lsulinfo.dvpGapBetweenLines;
        pulm->dvpSecondUnderlineSize = lsulinfo.dvpSecondUnderlineSize;
        
        *pfGood = *pfGood && pulm->dvpSecondUnderlineSize > 0;
        }
    else
    	{
    	Assert (lsulinfo.cNumberOfLines == 1);
    	
        pulm->dvpGapBetweenLines = 0;
        pulm->dvpSecondUnderlineSize = 0;
        };
   	   

    if (!*pfGood)
        {
        pulm->dvpUnderlineOriginOffset = 0;     // to provide good input to DrawUnderlineAsText
        }

    // dvpFirstUnderlineOffset was relative to local baseline until this moment, it is relative
    //  to the UnderlineOrigin from now on. (because we average runs with the same UnderlineOrigin)
    pulm->dvpFirstUnderlineOffset -= pulm->dvpUnderlineOriginOffset;

	// The notion of bad metrics was introduced in Word to deal with particular, now obsolete, printers.
	// Word doesn't support them any more, other clients never cared about them.
	// We drop the support for them now too.
	// The assignment below makes a lot of code in dispul.c and dispmain.c unneeded or unreachable.
	// Callback pfnDrawUnderlineAsText will never be called now. Input parameter fUnderline to 
	// pfnDrawTextRun is now always False.
	// Now is not the time to make big changes, maybe later.
	
	*pfGood = fTrue;
    
    return lserrNone;
}

//    %%Function:   GetUnderlineOrigin
//    %%Contact:    victork
//
/* normal and raised text are in the same group, lowered texts doesn't mix */

// Note: dvpUnderlineOriginOffset is relative to the local baseline, positive means down the page
//          in case of fUnderlineFromBelow - bigger means lower.
// dvpUnderlineOrigin is relative to the current baseline, negative means down the page
//          in case of fUnderlineFromBelow - bigger means higher (sign changed).
//
static void GetUnderlineOrigin(PLSDNODE pdn, BOOL fUnderlineFromBelow, long dvpUnderlineOriginOffset,
                            long* pdvpSubscriptOffset, long* pdvpUnderlineOrigin)

{
    if (fUnderlineFromBelow)
        {
        *pdvpSubscriptOffset = pdn->u.real.lschp.dvpPos;
        *pdvpUnderlineOrigin = pdn->u.real.lschp.dvpPos - dvpUnderlineOriginOffset;
        }
    else
        {
        *pdvpSubscriptOffset = -pdn->u.real.lschp.dvpPos;
        *pdvpUnderlineOrigin = -pdn->u.real.lschp.dvpPos - dvpUnderlineOriginOffset;
        }
        
    if (*pdvpSubscriptOffset > 0)
        {
        *pdvpSubscriptOffset = 0;       // put all superscripts in the baseline group
        }
    
    return;
}

//    %%Function:   GetUnderlineMergeMetric
//    %%Contact:    victork
//
/* For aesthetics, we try to underline dnodes (typically text) on the same side of
    the baseline (normal text and superscripts are considered to be on the
    same side of the baseline, versus subscripts, which are on the other side) with one
    continuous underline in even thickness. The underline metric used is the
    average from all those dnodes which are at the lowest height in the
    merge group. Merge is sometimes not possible because some dnodes may have
    bad underline metric. The following rules describe the merge decision
    under all possible scenarios. The dnodes in question are all on the same
    side of the baseline, i.e, there is never a merge of underline if it involes
    crossing the baseline.

Rules for merging underlined dnodes on the same side of the baseline

A. current: good Metric, new dnode: good metric
                                Merge?      Metric Used
    new dnode same height   :   yes         average
    new dnode lower         :   yes         new dnode
    new dnode higher        :   yes         current

B. current: good Metric, new dnode: bad metric
                                Merge?      Metric Used
    new dnode same height   :   no
    new dnode lower         :   no
    new dnode higher        :   yes         current

C. current: bad Metric, new dnode: good metric
                                Merge?      Metric Used
    new dnode same height   :   no
    new dnode lower         :   yes         new dnode
    new dnode higher        :   no

B. current: bad Metric, new dnode: bad metric
                                Merge?      Metric Used (baseline only)
    new dnode same height   :   no
    new dnode lower         :   yes         new dnode
    new dnode higher        :   yes         current

*/
LSERR GetUnderlineMergeMetric(PLSC plsc, PLSDNODE pdn, POINTUV pt, long upLimUnderline,
                    LSTFLOW lstflow, LSCP cpLimBreak, LSULMETRIC* pulmMerge, int* pcdnodes, BOOL* pfGoodMerge)
{
    LSERR       lserr;
    
    long        dupNew;
    long        dvpUnderlineOriginMerge, dvpUnderlineOriginNew;
    long        dvpSubscriptOffsetNew, dvpSubscriptOffsetMerge;
    BOOL        fGoodNew;
    BOOL        fUnderlineFromBelowMerge, fUnderlineFromBelowNew;
    ULMETRIC    ulm;
    ULMETRICSUM ulmSum;
    UINT        kulMerge;               
    DWORD       cNumberOfLinesMerge;

    lserr = GetULMetric(plsc, pdn, lstflow, &fUnderlineFromBelowMerge, &ulm, pfGoodMerge);
    if (lserr != lserrNone) return lserr;

    *pcdnodes = 1;  /* Counter for number of dnodes participationg in UL merge */
        
    kulMerge = ulm.kul;
    cNumberOfLinesMerge = ulm.cNumberOfLines;

    /* Initialize running sums with current dnode */
    dupNew = pdn->u.real.dup;
    InitULMetricSums(dupNew, &ulm, &ulmSum);

    GetUnderlineOrigin(pdn, fUnderlineFromBelowMerge, (long)ulm.dvpUnderlineOriginOffset,
                        &dvpSubscriptOffsetMerge, &dvpUnderlineOriginMerge);
        
    /* March down display list to collect merge participants */
    pdn = AdvanceToNextDnode(pdn, lstflow, &pt);


    /* Iterate till end of list, or end of UL */
    while (FDnodeBeforeCpLim(pdn, cpLimBreak)
            && pdn->klsdn == klsdnReal
            && !pdn->u.real.lschp.fInvisible
            && pdn->u.real.lschp.fUnderline && pt.u < upLimUnderline
            )
        {   
        /* loop invariance:
         *  *pcdnodes are merged already, merge ends at pt.u,
         *  dvpUnderlineOriginMerge reflect lowest dnode in merge group,
         *  other variables ending with Merge - other Merge info
         *  ulmSum contains ulm info of Merge, entries in it are not normalized yet.
         */

        lserr = GetULMetric(plsc, pdn, lstflow, &fUnderlineFromBelowNew, &ulm, &fGoodNew);
        if (lserr != lserrNone) return lserr;

        /* break if new dnode has different underline type or position */
        
        GetUnderlineOrigin(pdn, fUnderlineFromBelowNew, (long)ulm.dvpUnderlineOriginOffset,
                                &dvpSubscriptOffsetNew, &dvpUnderlineOriginNew);

        if (ulm.kul != kulMerge ||
                ulm.cNumberOfLines != cNumberOfLinesMerge ||
                dvpSubscriptOffsetNew != dvpSubscriptOffsetMerge ||
                fUnderlineFromBelowNew != fUnderlineFromBelowMerge)
            {
            break;
            }

        /* Type and position are the same - try to extend merge */
        
        dupNew = pdn->u.real.dup;

        if (dvpUnderlineOriginNew < dvpUnderlineOriginMerge)    
            {                                   /* new dnode lower - previous metrics is irrelevant     */
            if (*pfGoodMerge && !fGoodNew)
                break;                          /* except we won't change from good to bad          */

            dvpUnderlineOriginMerge = dvpUnderlineOriginNew;
            *pfGoodMerge = fGoodNew;
            if (fGoodNew)                       /* New good metrics - */
                {                               /* restart running sums from this dnode */      
                InitULMetricSums(dupNew, &ulm, &ulmSum);
                }
            }

        else if (dvpUnderlineOriginNew > dvpUnderlineOriginMerge)
            {                                   /* new dnode higher - new metrics is irrelevant     */
            if (!*pfGoodMerge && fGoodNew)
                break;                          /* except we won't throw away good for bad      */
            }
            /* NB We are not adding contribution of higher dnode to running sums */

        else                                    /* new dnode the same height */
            if (*pfGoodMerge && fGoodNew)
                {
                /* Add contribution of current dnode to running sums */
                AddToULMetricSums(dupNew, &ulm, &ulmSum);
                }
            else                                /* dvpUnderlineOriginNew == dvpUnderlineOriginMerge && */
                break;                          /* !both good */

        /* Advance to next dnode */
        ++*pcdnodes;
        pdn = AdvanceToNextDnode(pdn, lstflow, &pt);
        }


    pulmMerge->kul = kulMerge;
    pulmMerge->cNumberOfLines = cNumberOfLinesMerge;
    
    if (*pfGoodMerge)
        {
        GetAveragedMetrics(&ulmSum, pulmMerge);
        }

    if (!fUnderlineFromBelowMerge)
        {
        pulmMerge->dvpFirstUnderlineOffset = -pulmMerge->dvpFirstUnderlineOffset;
        dvpUnderlineOriginMerge = -dvpUnderlineOriginMerge;
        }

    pulmMerge->vpUnderlineOrigin = pt.v + dvpUnderlineOriginMerge;
    
    return lserrNone;
}

//    %%Function:   DrawUnderlineMerge
//    %%Contact:    victork
//
LSERR DrawUnderlineMerge(PLSC plsc, PLSDNODE pdn, const POINT* pptOrg, int cdnodes, long upUnderlineStart,
                        BOOL fgoodmetric, const LSULMETRIC* pulm, UINT kdispmode,
                        const RECT* prectclip, long upLimUnderline, LSTFLOW lstflow)

{
/*  pdn is the first of cdnodes dnodes, merged and averaged by LSULMetric. Now we cut this merge into
 *  smaller ones if client wants interruption. Merge here means this smaller merge.
 */
    LSERR   lserr;
    POINTUV ptUnderlineStart[2];
    long    dvpUnderlineSize[2];
    long    dup = 0;
    
    BOOL    fInterruptUnderline;
    BOOL    fFirstNode = TRUE;
    PLSRUN  plsrunFirstInMerge, plsrunPrevious, plsrunCurrent = NULL;
    LSCP    cpLastInPrevious, cpFirstInCurrent = 0;
    LSDCP   dcpCurrent = 0;
    
    int     cLines, i;

    POINT   ptXY;
    POINTUV ptDummy = {0,0};
    
    cLines = (fgoodmetric && pulm->cNumberOfLines == 2) ? 2 : 1;

    ptUnderlineStart[0].u = upUnderlineStart;

    if (fgoodmetric)
        ptUnderlineStart[0].v = pulm->vpUnderlineOrigin - pulm->dvpFirstUnderlineOffset;
    else
        ptUnderlineStart[0].v = pulm->vpUnderlineOrigin;

    dvpUnderlineSize[0] = pulm->dvpFirstUnderlineSize;

    if (cLines == 2)
        {
        ptUnderlineStart[1].u = upUnderlineStart;
        ptUnderlineStart[1].v = ptUnderlineStart[0].v - pulm->dvpFirstUnderlineSize -
                                                        pulm->dvpGapBetweenLines;
        dvpUnderlineSize[1] = pulm->dvpSecondUnderlineSize;
        }

    plsrunFirstInMerge = pdn->u.real.plsrun;

    while (cdnodes >= 0)    /* cdnodes is at least 1 coming in */
        {
        Assert(FIsDnodeReal(pdn));
        /* Check to flush out pending UL */
        if (fFirstNode)
            {
            fFirstNode = FALSE;
            fInterruptUnderline = FALSE;
            plsrunCurrent = pdn->u.real.plsrun;
            cpFirstInCurrent = pdn->cpFirst;
            dcpCurrent = pdn->dcp;
            }
        else if (cdnodes != 0)
            {
            plsrunPrevious = plsrunCurrent;
            cpLastInPrevious = cpFirstInCurrent + dcpCurrent - 1;
            plsrunCurrent = pdn->u.real.plsrun;
            cpFirstInCurrent = pdn->cpFirst;
            dcpCurrent = pdn->dcp;
            lserr = (*plsc->lscbk.pfnFInterruptUnderline)(plsc->pols, plsrunPrevious, cpLastInPrevious,
                                plsrunCurrent, cpFirstInCurrent, &fInterruptUnderline);
            if (lserr != lserrNone) return lserr;
            }
        else                                        /* we've come to the last one */
            fInterruptUnderline = TRUE;

        if (fInterruptUnderline)
            {   
            if (ptUnderlineStart[0].u + dup > upLimUnderline)
                {
                dup = upLimUnderline - ptUnderlineStart[0].u;
                }

            Assert(dup >= 0);                       /* upLimUnderline should not change */

            if (fgoodmetric)
                for (i = 0; i < cLines; ++i)
                    {
                    LsPointXYFromPointUV(pptOrg, lstflow, &ptUnderlineStart[i], &ptXY);

                    lserr = (*plsc->lscbk.pfnDrawUnderline)(plsc->pols, plsrunFirstInMerge, pulm->kul,
                                    &ptXY, dup, dvpUnderlineSize[i], lstflow, kdispmode, prectclip);
                    if (lserr != lserrNone) return lserr;
                    }
            else
                {
                LsPointXYFromPointUV(pptOrg, lstflow, &ptUnderlineStart[0], &ptXY);
                
                lserr = (*plsc->lscbk.pfnDrawUnderlineAsText)(plsc->pols, plsrunFirstInMerge, &ptXY,
                                                                dup, kdispmode, lstflow, prectclip);
                if (lserr != lserrNone) return lserr;
                }

            /* reset states to start with current dnode */
            ptUnderlineStart[0].u += dup;
            if (cLines == 2) ptUnderlineStart[1].u += dup;
            dup = 0;
            plsrunFirstInMerge = pdn->u.real.plsrun;
            }
            
        dup += pdn->u.real.dup;
        --cdnodes;
        if (cdnodes > 0)
            {
            pdn = AdvanceToNextDnode(pdn, lstflow, &ptDummy);
            }
        }
    return lserrNone;
}

//    %%Function:   GetStrikeMetric
//    %%Contact:    victork
//
LSERR GetStrikeMetric(PLSC plsc, PLSDNODE pdn, LSTFLOW lstflow, LSSTRIKEMETRIC* pstm, BOOL* pfgood)
{
    LSSTINFO lsstinfo;
    LSERR lserr;
    long dvpAscent = pdn->u.real.objdim.heightsPres.dvAscent;               // dvpUppermost
    long dvpDescent = -pdn->u.real.objdim.heightsPres.dvDescent + 1;        // dvpLowest

    lserr = (*plsc->lscbk.pfnGetRunStrikethroughInfo)(plsc->pols, pdn->u.real.plsrun,
                                        &(pdn->u.real.objdim.heightsPres), lstflow, &lsstinfo);
    if (lserr != lserrNone) return lserr;

    pstm->cNumberOfLines = lsstinfo.cNumberOfLines;
    pstm->kul = lsstinfo.kstbase;

    if (lsstinfo.cNumberOfLines == 2)
        {
        *pfgood = lsstinfo.dvpLowerStrikethroughOffset  >= dvpDescent
                && lsstinfo.dvpLowerStrikethroughSize  > 0
                && lsstinfo.dvpUpperStrikethroughOffset > lsstinfo.dvpLowerStrikethroughOffset  + lsstinfo.dvpLowerStrikethroughSize
                && lsstinfo.dvpUpperStrikethroughSize > 0
                && lsstinfo.dvpUpperStrikethroughOffset + lsstinfo.dvpUpperStrikethroughSize <= dvpAscent;
        if (*pfgood)
            {
            pstm->dvp1stSSSize = lsstinfo.dvpLowerStrikethroughSize;
            pstm->dvp1stSSOffset = lsstinfo.dvpLowerStrikethroughOffset;
            pstm->dvp2ndSSSize = lsstinfo.dvpUpperStrikethroughSize;
            pstm->dvp2ndSSOffset = lsstinfo.dvpUpperStrikethroughOffset;
            }
        }
    else
        {
        *pfgood = lsstinfo.dvpLowerStrikethroughOffset  >= dvpDescent
                && lsstinfo.dvpLowerStrikethroughSize  > 0
                && lsstinfo.dvpLowerStrikethroughOffset  + lsstinfo.dvpLowerStrikethroughSize  <= dvpAscent;
        if (*pfgood)
            {
            pstm->dvp1stSSSize = lsstinfo.dvpLowerStrikethroughSize;
            pstm->dvp1stSSOffset = lsstinfo.dvpLowerStrikethroughOffset;
            }
        }
    return lserrNone;
}

//    %%Function:   StrikeDnode
//    %%Contact:    victork
//
LSERR StrikeDnode(PLSC plsc, PLSDNODE pdn, const POINT* pptOrg, POINTUV pt, const LSSTRIKEMETRIC* pstm,
                    UINT kdispmode, const RECT* prectclip, long upLimUnderline, LSTFLOW lstflow)
{

    LSERR lserr = lserrNone;
    
    long    dup;
    POINT   ptXY;


    if (pt.u < upLimUnderline)
        {
        dup = pdn->u.real.dup;
        if (pt.u + dup > upLimUnderline) dup = upLimUnderline - pt.u;

        pt.v += pdn->u.real.lschp.dvpPos + pstm->dvp1stSSOffset;
        LsPointXYFromPointUV(pptOrg, lstflow, &pt, &ptXY);
        
        lserr = (*plsc->lscbk.pfnDrawStrikethrough)(plsc->pols, pdn->u.real.plsrun, pstm->kul,
                            &ptXY, dup, pstm->dvp1stSSSize, lstflow, kdispmode, prectclip);

        if (lserr == lserrNone && pstm->cNumberOfLines == 2)
            {
            pt.v += pstm->dvp2ndSSOffset - pstm->dvp1stSSOffset;
            LsPointXYFromPointUV(pptOrg, lstflow, &pt, &ptXY);
            
            lserr = (*plsc->lscbk.pfnDrawStrikethrough)(plsc->pols, pdn->u.real.plsrun, pstm->kul,
                                &ptXY, dup, pstm->dvp2ndSSSize, lstflow, kdispmode, prectclip);
            }
        }

    return lserr;

}

// Note:    Lstfow and BiDi
// Lstfow used in this file is always lstflow of the main subline.
// It doesn't matter if no sublines are submitted and looks logical for submitted dnodes.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\dispmain.c ===
#include "dispmain.h"
#include "lsc.h"
#include "lsdnode.h"
#include "lstflow.h"
#include "lsline.h"
#include "lssubl.h"
#include "dispul.h"	
#include "lstfset.h"
#include "lssubset.h"
#include "dispmisc.h"
#include "dispi.h"
#include "dninfo.h"
#include "memory.h"
#include "port.h"


static LSERR DisplayDnode(PLSC plsc, PLSDNODE pdn, const POINT* pptOrg, POINTUV pt,
				UINT kdispmode,	LSTFLOW lstflow, const RECT* prectClip, 
				BOOL fDrawStrike, BOOL fDrawUnderline, long upLimUnderline);
				
static LSERR ShadeSubline(PLSSUBL plssubl, const POINT* pptOrg, UINT kdispmode,
						const RECT* prectClip, long upLimUnderline, long upLeftIndent);

static LSERR DrawBorders(PLSSUBL plssubl, const POINT* pptOrg, UINT kdispmode,
						const RECT* prectClip, long upLimUnderline, long upLeftIndent);

static long GetDupUnderline(long up, long dup, long upLimUnderline);

static BOOL FGetNeighboringOpeningBorder(PLSDNODE pdnClosingBorder, PLSDNODE pdnNext, POINTUV* pptStart, 
										LSCP cpLim,	LSTFLOW	lstflowMain,
										PLSDNODE* ppdnOpeningBorder, POINTUV* pptStartOpeningBorder);

#define FIsDnodeToShade(pdn, cpLim) 	(FDnodeBeforeCpLim(pdn, cpLim) && FIsDnodeReal(pdn) && 	\
									!(pdn)->u.real.lschp.fInvisible && (pdn)->u.real.lschp.fShade)

#define UpdateMaximum(a,b)		if ((a) < (b)) (a) = (b); else

#define FIsDnodeOpeningBorder(pdn, lstflowMain)	((pdn)->fOpenBorder ^ ((pdn)->plssubl->lstflow != (lstflowMain)))
#define FIsDnodeClosingBorder(pdn, lstflowMain)	(!FIsDnodeOpeningBorder(pdn, lstflowMain))




//    %%Function:	DisplaySublineCore
//    %%Contact:	victork
//
// 
//	Displays subline with shading, striking and underlining, merging consecutive underlined dnodes
//	
//	Logic to select underlining method:
//	
//	If (metrics_are_good)
//		Draw_by_fnDrawUnderline;
//	else
//		if (There_is_merging_going)
//			Draw_by_pfnDrawUnderlineAsText;
//		else
//			Draw_along_with_Display;

LSERR DisplaySublineCore(		
						PLSSUBL plssubl,			/* subline to display */
						const POINT* pptOrg, 		/*  (x,y) starting point */
						UINT kdispmode,				/*  transparent or opaque */
						const RECT* prectClip, 		/*  clipping rect (x,y) */
						long upLimUnderline,
						long upLeftIndent)
{
	LSERR 		lserr;
	LSCP		cpLim = plssubl->cpLimDisplay;
	PLSC		plsc = plssubl->plsc;
	LSTFLOW		lstflowMain = plssubl->lstflow;
	BOOL 		fCollectVisual = plsc->plslineDisplay->fCollectVisual;

	LSSTRIKEMETRIC lsstrikemetric;

	//	Underline merge group - normal scenario: we first count dnodes willing to participate 
	//	in merging looking ahead, then draw them, then underline them as a whole
	
	PLSDNODE pdnFirstInGroup = NULL;			/* First dnode in Underline merge group */
	int 	cdnodesLeftInGroup = 0;				/* these are not displayed yet */
	int 	cdnodesToUnderline = 0;				/* these are already displayed */
	BOOL 	fGoodUnderline = fFalse;			/* is there metric for UL */
	LSULMETRIC lsulmetric;						/* merge metric info (if fGoodUnderline) */
	long 	upUnderlineStart = 0;				/* Starting point for the group */
	BOOL 	fMergeUnderline = fFalse;			/* There is more then one dnode in the group */

	BOOL 	fUnderlineWithDisplay, fStrikeWithDisplay;

	POINTUV		pt;
	PLSDNODE	pdn;

	FLineValid(plsc->plslineDisplay, plsc);					// Assert the display context is valid
	
	Assert(plssubl->plsdnUpTemp == NULL);					// against displaying accepted sublines

	if (fCollectVisual)
		{
		CreateDisplayTree(plssubl);
		}

	if (plsc->plslineDisplay->AggregatedDisplayFlags & fPortDisplayShade)
		{
		lserr = ShadeSubline(plssubl, pptOrg, kdispmode, prectClip, upLimUnderline, upLeftIndent);
		if (lserr != lserrNone) return lserr;
		}

	pt.u = upLeftIndent;						
	pt.v = 0;
	
	pdn = AdvanceToFirstDnode(plssubl, lstflowMain, &pt);

	while (FDnodeBeforeCpLim(pdn, cpLim))
		{

		if (pdn->klsdn == klsdnReal && !pdn->u.real.lschp.fInvisible)
			{	
			/* Real dnode */
				
			fStrikeWithDisplay = fFalse;
			if (pdn->u.real.lschp.fStrike)
				{
				BOOL fGoodStrike;
				lserr = GetStrikeMetric(plsc, pdn, lstflowMain, &lsstrikemetric, &fGoodStrike);
				if (lserr != lserrNone) return lserr;
				fStrikeWithDisplay = !fGoodStrike;
				}

			fUnderlineWithDisplay = fFalse;
			if (pdn->u.real.lschp.fUnderline && pt.u < upLimUnderline)	
				{	
				/* Node has underline */
				
				if (cdnodesLeftInGroup  == 0) 
					{ 
					/* There are no on-going UL group */
					/* Find out how many dnodes will participate in the merge and what metric to use */
					
					lserr = GetUnderlineMergeMetric(plsc, pdn, pt, upLimUnderline, lstflowMain, 
										cpLim, &lsulmetric, &cdnodesLeftInGroup , &fGoodUnderline);
					if (lserr != lserrNone) return lserr;
					fMergeUnderline = (cdnodesLeftInGroup  > 1);
					cdnodesToUnderline = 0;
					}

				if (!fGoodUnderline)				
					fUnderlineWithDisplay = !fMergeUnderline;
				else
					fUnderlineWithDisplay = fFalse;

				if (!fUnderlineWithDisplay)
					{
					if (cdnodesToUnderline == 0)
						{	
						/* Mark starting point of underline merge */
						
						pdnFirstInGroup = pdn;
						upUnderlineStart = pt.u;
						}
						
					/* Add to pending UL dnode count */
					
					++cdnodesToUnderline;	
					}
					
				// current dnode will be displayed shortly - consider it done
				
				--cdnodesLeftInGroup ;		
				}							
			
			lserr = DisplayDnode(plsc, pdn, pptOrg, pt, kdispmode, lstflowMain, prectClip,
									fStrikeWithDisplay, fUnderlineWithDisplay, upLimUnderline);
			if (lserr != lserrNone) return lserr;
			
			if (pdn->u.real.lschp.fStrike && !fStrikeWithDisplay)
				{
				lserr = StrikeDnode(plsc, pdn, pptOrg, pt, &lsstrikemetric, kdispmode, prectClip, 
										upLimUnderline, lstflowMain);
				if (lserr != lserrNone) return lserr;
				}
				
			/* Draw any pending UL after last dnode in group has been drawn */
			
			if (cdnodesToUnderline != 0 && cdnodesLeftInGroup  == 0)
				{
				lserr = DrawUnderlineMerge(plsc, pdnFirstInGroup, pptOrg, 
									cdnodesToUnderline, upUnderlineStart, fGoodUnderline, &lsulmetric, 
									kdispmode, prectClip, upLimUnderline, lstflowMain);
				if (lserr != lserrNone) return lserr;
				
				cdnodesToUnderline = 0;
				}
			}
			
		pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);
		}
		
	if (fCollectVisual)
		{
		// call display method for submitting dnodes
		
		pt.u = upLeftIndent;						
		pt.v = 0;
		
		pdn = AdvanceToFirstSubmittingDnode(plssubl, lstflowMain, &pt);

		while (FDnodeBeforeCpLim(pdn, cpLim))
			{
			lserr = DisplayDnode(plsc, pdn, pptOrg, pt, kdispmode, lstflowMain, prectClip,
									fFalse, fFalse, upLimUnderline);
			if (lserr != lserrNone) return lserr;
			
			pdn = AdvanceToNextSubmittingDnode(pdn, lstflowMain, &pt);
			}
		}
		
	if (plsc->plslineDisplay->AggregatedDisplayFlags & fPortDisplayBorder)
		{
		lserr = DrawBorders(plssubl, pptOrg, kdispmode, prectClip, upLimUnderline, upLeftIndent);
		if (lserr != lserrNone) return lserr;
		}

	if (fCollectVisual)
		{
		// destroy display tree

		DestroyDisplayTree(plssubl);
		}

	return lserrNone;			
}

//    %%Function:	DisplayDnode
//    %%Contact:	victork

static LSERR DisplayDnode(PLSC plsc, PLSDNODE pdn, const POINT* pptOrg, POINTUV pt,
						UINT kdispmode,	LSTFLOW lstflowMain, const RECT* prectClip,
						BOOL fDrawStrike, BOOL fDrawUnderline, long upLimUnderline)
{
	PDOBJ 	pdobj;
	DISPIN 	dispin;

	pdobj = pdn->u.real.pdobj;

	dispin.plschp = &(pdn->u.real.lschp);
	dispin.plsrun = pdn->u.real.plsrun;
	
	dispin.kDispMode = kdispmode;
	dispin.lstflow = pdn->plssubl->lstflow;								
	dispin.prcClip = (RECT*) prectClip;

	dispin.fDrawUnderline = fDrawUnderline;
	dispin.fDrawStrikethrough = fDrawStrike;
	
	dispin.heightsPres = pdn->u.real.objdim.heightsPres;
	dispin.dup = pdn->u.real.dup;
	
	dispin.dupLimUnderline = GetDupUnderline(pt.u, dispin.dup, upLimUnderline);

	if (dispin.lstflow != lstflowMain)
		{
		// Dnode lstflow is opposite to lstflowMain - get real starting point
		
		pt.u = pt.u + dispin.dup - 1;

		// Partial underlining can only happen on the top level
		
		Assert(dispin.dupLimUnderline == 0 || dispin.dupLimUnderline == dispin.dup);
		}

	pt.v += pdn->u.real.lschp.dvpPos;
	
	LsPointXYFromPointUV(pptOrg, lstflowMain, &pt, &(dispin.ptPen));
	
	
	return (*plsc->lsiobjcontext.rgobj[pdn->u.real.lschp.idObj].lsim.pfnDisplay)(pdobj, &dispin);
}


//    %%Function:	ShadeSubline
//    %%Contact:	victork

LSERR ShadeSubline(PLSSUBL plssubl,				/* subline to shade */
					const POINT* pptOrg, 		/*  (x,y) starting point */
					UINT kdispmode,				/*  transparent or opaque */
					const RECT* prectClip, 		/*  clipping rect (x,y) */
					long upLimUnderline,
					long upLeftIndent)
{
	LSERR 		lserr;
	LSCP		cpLim = plssubl->cpLimDisplay;
	PLSC		plsc = plssubl->plsc;
	PLSLINE		plsline = plsc->plslineDisplay;
	LSTFLOW		lstflowMain = plssubl->lstflow;

	POINTUV		pt;
	PLSDNODE	pdn;

	HEIGHTS		heightsLineWithAddedSpace;
	HEIGHTS		heightsLineWithoutAddedSpace;
	OBJDIM		objdimSubline;
	
	POINT		ptStart;
	PLSRUN		plsrunFirst, plsrunPrevious;
	long		upStart;
	long		dupInclTrail, dupExclTrail;
	HEIGHTS		heightsRunsInclTrail;
	HEIGHTS		heightsRunsExclTrail;

	BOOL	 	fInterruptShading;
	BOOL 		fCollectVisual = plsc->plslineDisplay->fCollectVisual;


	heightsLineWithAddedSpace.dvAscent = plsline->dvpAbove + plsline->lslinfo.dvpAscent;
	heightsLineWithAddedSpace.dvDescent = plsline->dvpBelow + plsline->lslinfo.dvpDescent;
	heightsLineWithAddedSpace.dvMultiLineHeight = dvHeightIgnore;
	
	heightsLineWithoutAddedSpace.dvAscent = plsline->lslinfo.dvpAscent;
	heightsLineWithoutAddedSpace.dvDescent = plsline->lslinfo.dvpDescent;
	heightsLineWithoutAddedSpace.dvMultiLineHeight = dvHeightIgnore;
	
	lserr = LssbGetObjDimSubline(plssubl, &lstflowMain, &objdimSubline);
	if (lserr != lserrNone) return lserr;
	
	if (fCollectVisual)
		{
		// shade submitting dnodes - pretend they are on the top level, no merging for them
		
		pt.u = upLeftIndent;						
		pt.v = 0;
		
		pdn = AdvanceToFirstSubmittingDnode(plssubl, lstflowMain, &pt);

		while (FDnodeBeforeCpLim(pdn, cpLim))
			{
			if (FIsDnodeToShade(pdn, cpLim))
				{
				LsPointXYFromPointUV(pptOrg, lstflowMain, &pt, &ptStart);
				dupInclTrail = pdn->u.real.dup;
				dupExclTrail = GetDupUnderline(pt.u, dupInclTrail, upLimUnderline);
				lserr = (*plsc->lscbk.pfnShadeRectangle)(plsc->pols, pdn->u.real.plsrun, &ptStart, 
									&heightsLineWithAddedSpace,	&heightsLineWithoutAddedSpace, 
									&(objdimSubline.heightsPres),
									&(pdn->u.real.objdim.heightsPres), &(pdn->u.real.objdim.heightsPres),
									dupExclTrail, dupInclTrail, 
									lstflowMain, kdispmode, prectClip);
				if (lserr != lserrNone) return lserr;
				}
			
			pdn = AdvanceToNextSubmittingDnode(pdn, lstflowMain, &pt);
			}
		}


	pt.u = upLeftIndent;						
	pt.v = 0;
	
	pdn = AdvanceToFirstDnode(plssubl, lstflowMain, &pt);

	while (FDnodeBeforeCpLim(pdn, cpLim)  && !FIsDnodeToShade(pdn, cpLim))
		{
		pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);
		}

	// next loop will do one shading merge at a run

	while (FDnodeBeforeCpLim(pdn, cpLim))
		{
		// pdn is the first dnode to participate in the shade merge
		// initialize the merge with this dnode data
		
		LsPointXYFromPointUV(pptOrg, lstflowMain, &pt, &ptStart);
		plsrunFirst = pdn->u.real.plsrun;
		upStart = pt.u;
		
		heightsRunsInclTrail = pdn->u.real.objdim.heightsPres;

		// What should we have in heightsRunsExclTrail if all shading is in trailing spaces?
		// I decided to put heights of the first run there for convenience sake
		// Client can check for dupExclTrail == 0.
		
		heightsRunsExclTrail = heightsRunsInclTrail;

		// We will now append to the merge as many dnodes as possible
		// The loop will stop when dnode doesn't need to be shaded - while condition
		// or if callback says two dnodes are not to be shaded together - break inside

		plsrunPrevious = pdn->u.real.plsrun;
		pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);
	
		while (FIsDnodeToShade(pdn, cpLim))
			{
			lserr = (*plsc->lscbk.pfnFInterruptShade)(plsc->pols, plsrunPrevious,pdn->u.real.plsrun,
														&fInterruptShading);
			if (lserr != lserrNone) return lserr;

			if (fInterruptShading)
				{
				break;
				}
				
			plsrunPrevious = pdn->u.real.plsrun;

			UpdateMaximum(heightsRunsInclTrail.dvAscent, pdn->u.real.objdim.heightsPres.dvAscent);
			UpdateMaximum(heightsRunsInclTrail.dvDescent, pdn->u.real.objdim.heightsPres.dvDescent);
			UpdateMaximum(heightsRunsInclTrail.dvMultiLineHeight, pdn->u.real.objdim.heightsPres.dvMultiLineHeight);

			if (pt.u < upLimUnderline)
				{
				UpdateMaximum(heightsRunsExclTrail.dvAscent, pdn->u.real.objdim.heightsPres.dvAscent);
				UpdateMaximum(heightsRunsExclTrail.dvDescent, pdn->u.real.objdim.heightsPres.dvDescent);
				UpdateMaximum(heightsRunsExclTrail.dvMultiLineHeight, pdn->u.real.objdim.heightsPres.dvMultiLineHeight);
				}

			pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);
			}
			
		// Merge is stopped - time to draw
		
		dupInclTrail = pt.u - upStart;
		dupExclTrail = GetDupUnderline(upStart, dupInclTrail, upLimUnderline);

		lserr = (*plsc->lscbk.pfnShadeRectangle)(plsc->pols, plsrunFirst, &ptStart, 
									&heightsLineWithAddedSpace,	&heightsLineWithoutAddedSpace, 
									&(objdimSubline.heightsPres),
									&heightsRunsExclTrail, &heightsRunsInclTrail, 
									dupExclTrail, dupInclTrail, 
									lstflowMain, kdispmode, prectClip);
		if (lserr != lserrNone) return lserr;

		// get to the beginning of the next shade merge
		
		while (FDnodeBeforeCpLim(pdn, cpLim)  && !FIsDnodeToShade(pdn, cpLim))
			{
			pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);
			}
		
		}
		
	return lserrNone;
}

//    %%Function:	GetDupUnderline
//    %%Contact:	victork
//
// Calculate dup of underlined part (of dnode). Deals with situations when upLimUnderline is
//  outside of [upStart, upStart + dup]

static long GetDupUnderline(long upStart, long dup, long upLimUnderline)

{
	long dupLimUnderline;
	
	dupLimUnderline = upLimUnderline - upStart;
	
	if (dupLimUnderline >= dup)
		{
		dupLimUnderline = dup;
		}
	else if (dupLimUnderline < 0)
		{
		dupLimUnderline = 0;
		}

	return dupLimUnderline;
}

//    %%Function:	DrawBorders
//    %%Contact:	victork

LSERR DrawBorders(PLSSUBL plssubl,
					const POINT* pptOrg, 		/*  (x,y) starting point */
					UINT kdispmode,				/*  transparent or opaque */
					const RECT* prectClip, 		/*  clipping rect (x,y) */
					long upLimUnderline,
					long upLeftIndent)
{
	LSERR 		lserr;
	LSCP		cpLim = plssubl->cpLimDisplay;
	PLSC		plsc = plssubl->plsc;
	PLSLINE		plsline = plsc->plslineDisplay;
	LSTFLOW		lstflowMain = plssubl->lstflow;

	HEIGHTS		heightsLineWithAddedSpace;
	HEIGHTS		heightsLineWithoutAddedSpace;
	OBJDIM		objdimSubline;
	HEIGHTS		heightsRuns;

	long		upStart, dupBorder, dupBordered;
	POINT		ptStart;
	PLSRUN		plsrunOpeningBorder, plsrunClosingBorder;
	POINTUV		pt, ptAfterClosingBorder;
	PLSDNODE	pdn, pdnPrev, pdnClosingBorder, pdnAfterClosingBorder;

	BOOL	 	fClosingOpeningBorderSequenceFound;
	PLSDNODE	pdnNextOpeningBorder;
	POINTUV		ptStartNextOpeningBorder;
	BOOL	 	fInterruptBorder;

	heightsLineWithAddedSpace.dvAscent = plsline->dvpAbove + plsline->lslinfo.dvpAscent;
	heightsLineWithAddedSpace.dvDescent = plsline->dvpBelow + plsline->lslinfo.dvpDescent;
	heightsLineWithAddedSpace.dvMultiLineHeight = dvHeightIgnore;
	
	heightsLineWithoutAddedSpace.dvAscent = plsline->lslinfo.dvpAscent;
	heightsLineWithoutAddedSpace.dvDescent = plsline->lslinfo.dvpDescent;
	heightsLineWithoutAddedSpace.dvMultiLineHeight = dvHeightIgnore;
	
	lserr = LssbGetObjDimSubline(plssubl, &lstflowMain, &objdimSubline);
	if (lserr != lserrNone) return lserr;
	
	pt.u = upLeftIndent;						
	pt.v = 0;
	
	pdn = AdvanceToFirstDnode(plssubl, lstflowMain, &pt);

	// next loop will draw one border at a run

	while (FDnodeBeforeCpLim(pdn, cpLim))
		{
		// first find an opening border

		while (FDnodeBeforeCpLim(pdn, cpLim) && !FIsDnodeBorder(pdn))
			{
			pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);
			}

		if (FDnodeBeforeCpLim(pdn, cpLim))
			{
			// border is found - it must be an opening one

			Assert(FIsDnodeOpeningBorder(pdn, lstflowMain));

			// remember the starting point and border width
			
			upStart = pt.u;
			LsPointXYFromPointUV(pptOrg, lstflowMain, &pt, &ptStart);
			dupBorder = pdn->u.pen.dup;

			// take lsrun from the first bordered run
			
			pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);

			Assert(FDnodeBeforeCpLim(pdn, cpLim) && FIsDnodeReal(pdn));

			plsrunOpeningBorder = pdn->u.real.plsrun;

			// start collecting max run height
			
			heightsRuns = pdn->u.real.objdim.heightsPres;

			// now look for an closing border to draw, collecting max run height
			// loop will be ended by break
			
			for (;;)
				{
				// find a border

				pdnPrev = NULL;

				while (FDnodeBeforeCpLim(pdn, cpLim) && !FIsDnodeBorder(pdn))
					{
					if (FIsDnodeReal(pdn))
						{
						UpdateMaximum(heightsRuns.dvAscent, pdn->u.real.objdim.heightsPres.dvAscent);
						UpdateMaximum(heightsRuns.dvDescent, pdn->u.real.objdim.heightsPres.dvDescent);
						UpdateMaximum(heightsRuns.dvMultiLineHeight, pdn->u.real.objdim.heightsPres.dvMultiLineHeight);
						}
						
					pdnPrev = pdn;
					pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);
					}
					
				Assert(FDnodeBeforeCpLim(pdn, cpLim));
				
				// border is found - it must be a closing one
				// Sequence opening border - closing border is prohibited by formatting

				Assert(pdnPrev != NULL);						
				Assert(FIsDnodeReal(pdnPrev));
				Assert(FIsDnodeClosingBorder(pdn, lstflowMain));
				Assert(pdn->u.pen.dup == dupBorder);

				pdnClosingBorder = pdn;
				plsrunClosingBorder = pdnPrev->u.real.plsrun;
				
				pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);
				
				ptAfterClosingBorder = pt;
				pdnAfterClosingBorder = pdn;

				// check for the "surplus borders" situation: closing border and opening border of the same
				// type brought together by submitting sublines. (Hard to check at formatting time)
				
				// It can be more complicated if there are bordered trailing spaces between the two borders
				// (Trailing spaces can happen in the middle of the line in Bidi case). The problem is
				// that border is moved away from trailing spaces at SetBreak time. We try to restore 
				// bordering of trailing spaces when they are in the middle of bordered line below.
				
				fClosingOpeningBorderSequenceFound = FGetNeighboringOpeningBorder(pdnClosingBorder, pdn, &pt, 
											cpLim, lstflowMain,	&pdnNextOpeningBorder, &ptStartNextOpeningBorder);
				
				if (fClosingOpeningBorderSequenceFound)
					{
					pdn = pdnNextOpeningBorder;
					pt = ptStartNextOpeningBorder;
					
					pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);

					Assert(FDnodeBeforeCpLim(pdn, cpLim) && FIsDnodeReal(pdn));

					lserr = (*plsc->lscbk.pfnFInterruptBorder)(plsc->pols, plsrunClosingBorder, 
										pdn->u.real.plsrun,	&fInterruptBorder);
					if (lserr != lserrNone) return lserr;
					
					if (!fInterruptBorder)
						{
						// Client decided against interrupting border here. These two border dnodes
						// will be ignored. Space reserved for them by formatting will be left empty.
						// Continue seeking for closing border starting from pdn
						
						continue;
						}
					}
					
				// No special situation - we are ready to display
				
				// Well, we are almost ready. Word doesn't normally draw borders in trailing spaces, 
				// just reserve space for them and leave this space blank. In FE Word, however,  
				// borders are drawn if underlining of trailing spaces is required.
				// We hack in the following way: Borders in trailing area are deleted after formatting.
				// If there are a border which opens in text and closes in trailing spaces, it is moved
				// to the left to exclude trailing spaces. If the fUnderlineTrailSpacesRM flag is on 
				// the "moved" border is marked and now have to be displayed up to upLimUnderline.
				// Yes, it's bad, it will appear painted over already displayed spaces (queries!) and 
				// what about a scenario when not all trailing spaces are bordered? We know, we know.
				// Word can even get a "negative" border with a negative advance field.

				dupBordered = ptAfterClosingBorder.u - upStart;
				
				if (pdnClosingBorder->fBorderMovedFromTrailingArea)
					{
					Assert(ptAfterClosingBorder.u <= upLimUnderline);
					
					dupBordered = upLimUnderline - upStart;
					}
					
				lserr = (*plsc->lscbk.pfnDrawBorder)(plsc->pols, plsrunOpeningBorder, &ptStart, 
										&heightsLineWithAddedSpace,	&heightsLineWithoutAddedSpace, 
										&(objdimSubline.heightsPres), &heightsRuns,
										dupBorder, dupBordered,
										lstflowMain, kdispmode, prectClip);
				if (lserr != lserrNone) return lserr;
				
				// maybe we peeped ahead checking for the surplus borders - return
				
				pdn = pdnAfterClosingBorder;
				pt = ptAfterClosingBorder;
				break;
				}
			}

			// Previous border is drawn, start looking for the next one from pdn.
		}
		
	return lserrNone;
}


// Find an opening border neighboring pdnClosingBorder broght together by submitting sublines. 
// Ignore trailing spaces that lost their borders during SetBreak - their heights will be ignored.

// Input: 	pdnClosingBorder
//			pdnNext - next to pdnClosingBorder (in visual order)
//			ptStart - starting poing of pdnNext (in visual order)
//			cpLim and lstflowMain
// Output:	pdnOpeningBorder and ptStartOpeningBorder


static BOOL FGetNeighboringOpeningBorder(PLSDNODE pdnClosingBorder, PLSDNODE pdnNext, POINTUV* pptStart, 
										LSCP cpLim,	LSTFLOW	lstflowMain,
										PLSDNODE* ppdnOpeningBorder, POINTUV* pptStartOpeningBorder)
{
	PLSDNODE	pdn;
	POINTUV		pt;

	pdn = pdnNext;
	pt = *pptStart;
	
	// skip spaces that were bordered once
	// not sure about spaces, but what else could be skipped?
	
	while (FDnodeBeforeCpLim(pdn, cpLim) && FIsDnodeReal(pdn) && pdn->u.real.lschp.fBorder)
		{
		pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);
		}

	if (!FDnodeBeforeCpLim(pdn, cpLim))
		{
		return fFalse;
		}

	// looking for an opening border from another subline

	if (FIsDnodeOpeningBorder(pdn, lstflowMain) && pdn->plssubl != pdnClosingBorder->plssubl)
		{
		*ppdnOpeningBorder = pdn;
		*pptStartOpeningBorder = pt;
		return fTrue;
		}

	return fFalse;
}

	
// N.B. 
//	Interruption of underlining/shading logic by invisible dnode is OK, because we are sure that no
//		underlining/shading is allowed in preprinted forms.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\dnutils.c ===
#include "dnutils.h"
#include "dninfo.h"
#include "iobj.h"
#include "lsdnode.h"
#include "lscbk.h"
#include "qheap.h"
#include "lstext.h"
#include "lsmem.h"						/* memset() prototype */


#define FIsOutOfLine(plsc, plsdn)  \
		(((plsdn) == NULL) ||   \
		  (((plsc)->plslineCur->lslinfo.cpLim != 0) && ((plsc)->plslineCur->lslinfo.cpLim <= (plsdn)->cpFirst)))





/* F I N D  L I S T  D U P */
/*----------------------------------------------------------------------------
    %%Function: FindListDup
    %%Contact: igorzv

    Visit each node in the list of DNODES, until reaching cpLim
	Compute dup between start and end points.
----------------------------------------------------------------------------*/
void FindListDup(PLSDNODE plsdnFirst, LSCP cpLim, long *pdup)
{
	PLSDNODE plsdn;

	/* tolerate pldnFirst == NULL */

	*pdup = 0;
	plsdn = plsdnFirst;

	while (plsdn != NULL && plsdn->cpLimOriginal <= cpLim)
		{
		Assert(FIsLSDNODE(plsdn));
		*pdup += DupFromDnode(plsdn);
		plsdn = plsdn->plsdnNext;
		}

}

/* F I N D  L I S T  F I N A L  P E N  M O V E M E N T*/
/*----------------------------------------------------------------------------
    %%Function: FindListFinalPenMovement
    %%Contact: igorzv

    Visit each node in the list of DNODES, until reaching cpLim
	Compute dur dvr dvp  between start and end points.
----------------------------------------------------------------------------*/
void FindListFinalPenMovement(PLSDNODE plsdnFirst, PLSDNODE plsdnLast, long *pdur, long *pdvr, long *pdvp)
{
	PLSDNODE plsdn;

	/* tolerate pldnFirst == NULL */

	*pdur = 0;
	*pdvr = 0;
	*pdvp = 0;
	plsdn = plsdnFirst;

	while (plsdn != NULL && plsdn->plsdnPrev != plsdnLast)
		{
		Assert(FIsLSDNODE(plsdn));
		*pdur += DurFromDnode(plsdn);
		*pdvr += DvrFromDnode(plsdn);
		*pdvp += DvpFromDnode(plsdn);
		plsdn = plsdn->plsdnNext;
		}

}

/* F I N D  L I S T  D I M S */
/*----------------------------------------------------------------------------
    %%Function: FindListDims
    %%Contact: igorzv

    Visit each node in the list of DNODES, until reaching plsdnLast.
	Compute OBJDIM which describes the list.
----------------------------------------------------------------------------*/
LSERR FindListDims(PLSDNODE plsdnFirst, PLSDNODE plsdnLast, OBJDIM* pobjdimList)
{
	PLSDNODE plsdn;
	long urPen = 0;
	long urLim = 0;
	long vpPen = 0;
	long vrPen = 0;
	OBJDIM objdimFound;
	long dvpNode, dvrNode, durNode;
	long dvpAscentNext;
	long dvrAscentNext;
	long dvpDescentNext;
	long dvrDescentNext;
	long dvpLineHeight;
	long dvrLineHeight;
	POBJDIM pobjdimNode;
	BOOL fFindLast;
	OBJDIM* pobjdimLastSkiped = NULL;


	/* N.B. Tolerate an empty input list! */
	Assert(((plsdnFirst == NULL) && (plsdnLast == NULL)) || (FIsLSDNODE(plsdnFirst) && FIsLSDNODE(plsdnLast)));

	/* the most efficient way to put zeroes in heights */
	memset(&objdimFound, 0, sizeof objdimFound);

	/* quick return if list is empty */
	if (plsdnFirst == NULL)
		{
		*pobjdimList = objdimFound;   /* in objdim will be zeroes */
		return lserrNone;
		}


	fFindLast = fFalse;
	for (plsdn = plsdnFirst; !fFindLast ; plsdn = plsdn->plsdnNext)
		{
		if (plsdn == NULL)
		/* we dont found plsdnLast, so return error */
			return lserrInvalidParameter;

		if (plsdn == plsdnLast)
			fFindLast = fTrue;


		if (plsdn->klsdn == klsdnReal)
			{
			pobjdimNode = &plsdn->u.real.objdim;
			durNode = pobjdimNode->dur;
			Assert(durNode >= 0);
			dvrNode = 0;
			dvpNode = 0;

			dvpAscentNext = pobjdimNode->heightsPres.dvAscent + vpPen;
			dvrAscentNext = pobjdimNode->heightsRef.dvAscent + vrPen;
			dvpDescentNext = pobjdimNode->heightsPres.dvDescent - vpPen;
			dvrDescentNext = pobjdimNode->heightsRef.dvDescent - vrPen;
			dvpLineHeight = pobjdimNode->heightsPres.dvMultiLineHeight;
			dvrLineHeight = pobjdimNode->heightsRef.dvMultiLineHeight;

			if (dvrLineHeight != dvHeightIgnore) /* dvrLineHeight == dvHeightIgnore */
												 /* for us is sign that we  */
				{						/* should not take into account for height calculation 
										this dnode */
				if (objdimFound.heightsPres.dvAscent < dvpAscentNext)
					objdimFound.heightsPres.dvAscent = dvpAscentNext;
				if (objdimFound.heightsRef.dvAscent < dvrAscentNext)
					objdimFound.heightsRef.dvAscent = dvrAscentNext;
				if (objdimFound.heightsPres.dvDescent < dvpDescentNext)
					objdimFound.heightsPres.dvDescent = dvpDescentNext;
				if (objdimFound.heightsRef.dvDescent < dvrDescentNext)
					objdimFound.heightsRef.dvDescent = dvrDescentNext;
				if (objdimFound.heightsPres.dvMultiLineHeight < dvpLineHeight)
					objdimFound.heightsPres.dvMultiLineHeight = dvpLineHeight;
				if (objdimFound.heightsRef.dvMultiLineHeight < dvrLineHeight)
					objdimFound.heightsRef.dvMultiLineHeight = dvrLineHeight;
				}

			else	/*  if final heights is 0, we will take  ascent and desent from
					   this dnode */
				{
				pobjdimLastSkiped = pobjdimNode;
				}
					

			}
		else 			/*  klsdnPenOrBorder*/
			{  
			dvpNode = plsdn->u.pen.dvp;
			durNode = plsdn->u.pen.dur;
			dvrNode = plsdn->u.pen.dvr;
			}


		vpPen += dvpNode;
		urPen += durNode;
		vrPen += dvrNode;
		if (urLim < urPen)
			urLim = urPen;
		}

	if (objdimFound.heightsRef.dvAscent == 0 && objdimFound.heightsRef.dvDescent == 0
		&& pobjdimLastSkiped != NULL)
		{
		objdimFound.heightsPres.dvAscent = pobjdimLastSkiped->heightsPres.dvAscent + vpPen;
		objdimFound.heightsRef.dvAscent = pobjdimLastSkiped->heightsRef.dvAscent + vrPen;
		objdimFound.heightsPres.dvDescent = pobjdimLastSkiped->heightsPres.dvDescent - vpPen;
		objdimFound.heightsRef.dvDescent = pobjdimLastSkiped->heightsRef.dvDescent - vrPen;
		objdimFound.heightsPres.dvMultiLineHeight = dvHeightIgnore;
		objdimFound.heightsRef.dvMultiLineHeight = dvHeightIgnore;
		}


	*pobjdimList = objdimFound;
	pobjdimList->dur = urLim;
	return lserrNone;
}




/* D E S T R O Y  D N O D E  L I S T   */
/*----------------------------------------------------------------------------
    %%Function: DestroyDnodeList
    %%Contact: igorzv

Parameters:
	plscbk				-	(IN) callbacks
	pols				-	(IN) pols to pass for callbacks
	plsiobjcontext		-	(IN) object handlers 
	plsdn				-	(IN) first dnode in list
	fDontReleaseRuns	-	(IN) not to call release run
----------------------------------------------------------------------------*/
LSERR DestroyDnodeList(LSCBK* plscbk, POLS pols, PLSIOBJCONTEXT plsiobjcontext,
					   PLSDNODE plsdn, BOOL fDontReleaseRuns)
{
	LSERR lserr, lserrFinal = lserrNone;
	PLSDNODE plsdnNext;
	PDOBJ pdobj;
	PLSRUN plsrun;
	DWORD iobj;


	if (plsdn == NULL)
		return lserrNone;

	Assert(FIsLSDNODE(plsdn));

	/* link with this dnode should  be broken before */
	Assert(plsdn->plsdnPrev == NULL || plsdn->plsdnPrev->plsdnNext != plsdn );

	for (;  plsdn != NULL;  plsdn = plsdnNext)
		{

		Assert(FIsLSDNODE(plsdn));

		if (plsdn->klsdn == klsdnReal)
			{
			if (plsdn->u.real.pinfosubl != NULL)
				{
				if (plsdn->u.real.pinfosubl->rgpsubl != NULL)
					{
					plscbk->pfnDisposePtr(pols, plsdn->u.real.pinfosubl->rgpsubl);
					}

				plscbk->pfnDisposePtr(pols, plsdn->u.real.pinfosubl);
				}

			iobj = plsdn->u.real.lschp.idObj;
			plsrun = plsdn->u.real.plsrun;
			pdobj = plsdn->u.real.pdobj;
			}
		else
			{
			Assert (FIsDnodePen(plsdn) || FIsDnodeBorder(plsdn));
			iobj = 0;
			plsrun = NULL;
			pdobj = NULL;
			}

		if (plsrun != NULL && !fDontReleaseRuns)
			{
			lserr = plscbk->pfnReleaseRun(pols, plsrun);
			if (lserr != lserrNone && lserrFinal == lserrNone)
				lserrFinal = lserr;
			}

		if (pdobj != NULL)
			{
			lserr = (PLsimFromLsc(plsiobjcontext, iobj))->pfnDestroyDObj (pdobj);
			if (lserr != lserrNone && lserrFinal == lserrNone)
				lserrFinal = lserr;
			}

		plsdn->tag = tagInvalid;
		plsdnNext = plsdn->plsdnNext;
		}

	return lserrFinal;
}


/* ---------------------------------------------------------------------- */

/*  D U R  B O R D E R  F R O M  D N O D E  I N S I D E*/
/*----------------------------------------------------------------------------
    %%Function: DurBorderFromDnodeInside
    %%Contact: igorzv
Parameters:
	plsdn	-	(IN) dnode inside borders 
----------------------------------------------------------------------------*/
long DurBorderFromDnodeInside(PLSDNODE plsdn) /* IN: dnode inside borders */
	{
	PLSDNODE plsdnBorder = plsdn;
	while (!FIsDnodeBorder(plsdnBorder))
		{
		plsdnBorder = plsdnBorder->plsdnPrev;
		Assert(FIsLSDNODE(plsdnBorder));
		}
	
	Assert(FIsDnodeBorder(plsdnBorder));
	Assert(plsdnBorder->fOpenBorder);
				
	return plsdnBorder->u.pen.dur;
				
	}

/* ---------------------------------------------------------------------- */

/*  F  S P A C E S  O N L Y*/
/*----------------------------------------------------------------------------
    %%Function: FSpacesOnly
    %%Contact: igorzv
Parameters:
	plsdn	-	(IN) dnode 
	iObjText-	(IN) id for text dnode 
----------------------------------------------------------------------------*/
BOOL FSpacesOnly(PLSDNODE plsdn, DWORD iObjText)
	{
	DWORD dcpTrailing;
	long durTrailing;

	if (FIsDnodeSplat(plsdn))
		return fTrue;
	else if (FIsDnodeReal(plsdn) 
			 && (IdObjFromDnode(plsdn) == iObjText)
			 && !(plsdn->fTab))
		{
		GetTrailInfoText(PdobjFromDnode(plsdn), plsdn->dcp,
					&dcpTrailing, &durTrailing);	
		if (dcpTrailing == plsdn->dcp)
			return fTrue;
		}
	return fFalse;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\enumcore.c ===
#include "enumcore.h"
#include "lsc.h"
#include "lssubl.h"
#include "heights.h"
#include "lsdnode.h"
#include "dninfo.h"
#include "lstfset.h"

static LSERR EnumerateDnode(PLSC plsc, PLSDNODE pdn, POINTUV pt, BOOL fReverse,
					BOOL fGeometry, const POINT* pptOrg);

//    %%Function:	EnumSublineCore
//    %%Contact:	victork
//
/*
 *	Enumerates subline calling enumeration callback for pens, methods for objects.
 *	Provides geometry information if needed (Prepdisp should be done already in this case.)
 *	Notice that auto-decimal tab is enumerated as a tab before Prepdisp and as a pen after.
 */

LSERR EnumSublineCore(PLSSUBL plssubl, BOOL fReverse, BOOL fGeometry, 
					const POINT* pptOrg, long upLeftIndent)
{
	LSERR 		lserr;
	LSCP		cpLim = plssubl->cpLimDisplay;
	PLSC		plsc = plssubl->plsc;

	PLSDNODE	pdn;
	POINTUV		pt	= {0,0};				// init'ed to get rid of assert.

	if (plssubl->plsdnFirst == NULL)
		{
		return lserrNone;					// early exit for empty sublines
		}

	Assert(!fGeometry || plssubl->fDupInvalid == fFalse);
	
	if (fReverse)
		{
		pdn = plssubl->plsdnFirst;

		if (fGeometry)
			{
			pt.u = upLeftIndent;						
			pt.v = 0;

			while (FDnodeBeforeCpLim(pdn, cpLim))
				{
				if (pdn->klsdn == klsdnReal)
					{				
					pt.u += pdn->u.real.dup;
					}
				else
					{
					pt.u += pdn->u.pen.dup;					
					pt.v += pdn->u.pen.dvp;
					}
				
				pdn = pdn->plsdnNext;
				}
			}

		pdn = plssubl->plsdnLastDisplay;
			
		while (pdn != NULL)
			{
			if (fGeometry)
				{
				// pt is now after pdn, downdate it to point before
				if (pdn->klsdn == klsdnReal)
					{				
					pt.u -= pdn->u.real.dup;
					}
				else
					{
					pt.u -= pdn->u.pen.dup;					
					pt.v -= pdn->u.pen.dvp;
					}
				}

			lserr = EnumerateDnode(plsc, pdn, pt, fReverse, fGeometry, pptOrg);
			if (lserr != lserrNone) return lserr;

			pdn = pdn->plsdnPrev;
			}
		}
	else
		{
		pdn = plssubl->plsdnFirst;

		pt.u = upLeftIndent;						
		pt.v = 0;

		while (FDnodeBeforeCpLim(pdn, cpLim))
			{
			lserr = EnumerateDnode(plsc, pdn, pt, fReverse, fGeometry, pptOrg);
			if (lserr != lserrNone) return lserr;

			if (fGeometry)
				{
				if (pdn->klsdn == klsdnReal)
					{				
					pt.u += pdn->u.real.dup;
					}
				else
					{
					pt.u += pdn->u.pen.dup;					
					pt.v += pdn->u.pen.dvp;
					}
				}
				
			pdn = pdn->plsdnNext;
			}
		}		
		

	return lserrNone;			
}

//    %%Function:	EnumerateDnode
//    %%Contact:	victork
//
static LSERR EnumerateDnode(PLSC plsc, PLSDNODE pdn, POINTUV pt, BOOL fReverse,
							BOOL fGeometry, const POINT* pptOrg)
{
	POINTUV	ptRaised;
	POINT	ptXY;
	LSTFLOW	lstflow = pdn->plssubl->lstflow;

	if (pdn->klsdn == klsdnReal)
		{
		if (pdn->u.real.pdobj == NULL)
			{
			// How could it happen:
			// we substitute autodecimal tab by a pen at  PrepareLineForDisplay time. 
			// Pens don't require plsrun, so we are fine at display.
			// If Client doesn't ask for geometry, the substitution might not happen

			Assert (!fGeometry);
			Assert (pdn->fTab);
			Assert(pdn->cpFirst < 0);
			Assert(plsc->lsadjustcontext.fAutodecimalTabPresent);
			
			return plsc->lscbk.pfnEnumPen(plsc->pols, fFalse, lstflow, 
						fReverse, fFalse, &ptXY, 0, 0);
			}
		else
			{
			if (fGeometry)
				{
				ptRaised = pt;
				ptRaised.v += pdn->u.real.lschp.dvpPos;

				LsPointXYFromPointUV(pptOrg, lstflow, &ptRaised, &(ptXY));
				}

			return (*plsc->lsiobjcontext.rgobj[pdn->u.real.lschp.idObj].lsim.pfnEnum)
				(pdn->u.real.pdobj, pdn->u.real.plsrun, &(pdn->u.real.lschp), pdn->cpFirst, pdn->dcp,
				lstflow, fReverse, fGeometry, &ptXY, &pdn->u.real.objdim.heightsPres, pdn->u.real.dup);
			}
		}
	else
		{
		return plsc->lscbk.pfnEnumPen(plsc->pols, pdn->fBorderNode, lstflow, 
					fReverse, fGeometry, &ptXY, pdn->u.pen.dup, pdn->u.pen.dvp);
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lnutils.c ===
/*   obsolete */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\hih.c ===
#include	"lsmem.h"
#include	"limits.h"
#include	"hih.h"
#include	"objhelp.h"
#include	"lscbk.h"
#include	"lsdevres.h"
#include	"pdobj.h"
#include	"objdim.h"
#include	"plssubl.h"
#include	"plsdnode.h"
#include	"pilsobj.h"
#include	"lscrsubl.h"
#include	"lssubset.h"
#include	"lsdnset.h"
#include	"zqfromza.h"
#include	"lsdocinf.h"
#include	"fmti.h"
#include	"posichnk.h"
#include	"locchnk.h"
#include	"lsdnfin.h"
#include	"brko.h"
#include	"lspap.h"
#include	"plspap.h"
#include	"lsqsubl.h"
#include	"dispi.h"
#include	"lsdssubl.h"
#include	"lsems.h"
#include	"dispmisc.h"
#include	"sobjhelp.h"

#define HIH_ESC_CNT	1


struct ilsobj
{
    POLS				pols;
	LSCBK				lscbk;
	PLSC				plsc;
	PFNHIHENUM			pfnEnum;
	LSESC				lsescHih;
};


struct dobj
{
	SOBJHELP			sobjhelp;			/* common area for simple objects */	
	PILSOBJ				pilsobj;			/* ILS object */
	LSCP				cpStart;			/* Starting LS cp for object */
	PLSSUBL				plssubl;			/* Handle to second line */
};


/* H I H F R E E D O B J */
/*----------------------------------------------------------------------------
	%%Function: HihFreeDobj
	%%Contact: antons

		Free all resources associated with Hih dobj.
	
----------------------------------------------------------------------------*/
static LSERR HihFreeDobj (PDOBJ pdobj)
{
	LSERR lserr = lserrNone;
	
	PILSOBJ pilsobj = pdobj->pilsobj;

	if (pdobj->plssubl != NULL)
		{
		lserr = LsDestroySubline(pdobj->plssubl);
		}

    pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pdobj);

	return lserr;
}


/* H I H C R E A T E I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: HihCreateILSObj
	%%Contact: ricksa

		CreateILSObj

		Create the ILS object for all Hih objects.
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihCreateILSObj(
	POLS pols,				/* (IN): client application context */
	PLSC plsc,				/* (IN): LS context */
	PCLSCBK pclscbk,		/* (IN): callbacks to client application */
	DWORD idObj,			/* (IN): id of the object */
	PILSOBJ *ppilsobj)		/* (OUT): object ilsobj */
{
    PILSOBJ pilsobj;
	LSERR lserr;
	HIHINIT hihinit;
	hihinit.dwVersion = HIH_VERSION;

	/* Get initialization data */
	lserr = pclscbk->pfnGetObjectHandlerInfo(pols, idObj, &hihinit);

	if (lserr != lserrNone)
		{
		return lserr;
		}

    pilsobj = pclscbk->pfnNewPtr(pols, sizeof(*pilsobj));

	if (NULL == pilsobj)
	{
		return lserrOutOfMemory;
	}

    pilsobj->pols = pols;
    pilsobj->lscbk = *pclscbk;
	pilsobj->plsc = plsc;
	pilsobj->lsescHih.wchFirst = hihinit.wchEndHih;
	pilsobj->lsescHih.wchLast = hihinit.wchEndHih;
	pilsobj->pfnEnum = hihinit.pfnEnum;
	*ppilsobj = pilsobj;
	return lserrNone;
}

/* H I H D E S T R O Y I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: HihDestroyILSObj
	%%Contact: ricksa

		DestroyILSObj

		Free all resources assocaiated with Hih ILS object.
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihDestroyILSObj(
	PILSOBJ pilsobj)			/* (IN): object ilsobj */
{
	pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pilsobj);
	return lserrNone;
}

/* H I H S E T D O C */
/*----------------------------------------------------------------------------
	%%Function: HihSetDoc
	%%Contact: ricksa

		SetDoc

		Keep track of device information for scaling purposes.
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihSetDoc(
	PILSOBJ pilsobj,			/* (IN): object ilsobj */
	PCLSDOCINF pclsdocinf)		/* (IN): initialization data of the document level */
{
	Unreferenced(pilsobj);
	Unreferenced(pclsdocinf);
	return lserrNone;
}


/* H I H C R E A T E L N O B J */
/*----------------------------------------------------------------------------
	%%Function: HihCreateLNObj
	%%Contact: ricksa

		CreateLNObj

		Create the Line Object for the Hih. No real need for a line
		object so don't allocated it.
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihCreateLNObj(
	PCILSOBJ pcilsobj,			/* (IN): object ilsobj */
	PLNOBJ *pplnobj)			/* (OUT): object lnobj */
{
	*pplnobj = (PLNOBJ) pcilsobj;
	return lserrNone;
}

/* H I H D E S T R O Y L N O B J */
/*----------------------------------------------------------------------------
	%%Function: HihDestroyLNObj
	%%Contact: ricksa

		DestroyLNObj

		Frees resources associated with the Hih line object. Since
		there isn't any this is a no-op.
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihDestroyLNObj(
	PLNOBJ plnobj)				/* (OUT): object lnobj */

{
	Unreferenced(plnobj);
	return lserrNone;
}

/* H I H F M T */
/*----------------------------------------------------------------------------
	%%Function: HihFmt
	%%Contact: ricksa

		Fmt

		Format the Hih object. 
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihFmt(
    PLNOBJ plnobj,				/* (IN): object lnobj */
    PCFMTIN pcfmtin,			/* (IN): formatting input */
    FMTRES *pfmtres)			/* (OUT): formatting result */
{
	PDOBJ pdobj;
	LSERR lserr;
	PILSOBJ pilsobj = (PILSOBJ) plnobj;
	POLS pols = pilsobj->pols;
	LSCP cpStartMain = pcfmtin->lsfgi.cpFirst + 1;
	LSCP cpOut;
	FMTRES fmtres;
	FMTRES fmtr = fmtrCompletedRun;

    /*
     * Allocate the DOBJ
     */
     
    pdobj = pilsobj->lscbk.pfnNewPtr(pols, sizeof(*pdobj));

    if (NULL == pdobj)
		{
		return lserrOutOfMemory;
		}

	ZeroMemory(pdobj, sizeof(*pdobj));
	pdobj->pilsobj = pilsobj;
	pdobj->cpStart = pcfmtin->lsfgi.cpFirst;

	/*
	 * Build main line of text
	 */
	 
	lserr = FormatLine(pilsobj->plsc, cpStartMain, LONG_MAX, pcfmtin->lsfgi.lstflow,
		&pdobj->plssubl, HIH_ESC_CNT, &pilsobj->lsescHih,
			&pdobj->sobjhelp.objdimAll, &cpOut, NULL, NULL, &fmtres);

	if (lserr != lserrNone)
		{
		HihFreeDobj(pdobj); /* do not need to check return error code */

		return lserr;
		}

	/*
	 * Note: the + 2 in the following is because cpStartMain is + 1 from the
	 * actual start of the object (it is the cpStartMain of the Hih
	 * data) and additional + 1 for the escape character at the end of the
	 * tatenakayoko.
	 */

	Assert (fmtres != fmtrExceededMargin);

	pdobj->sobjhelp.dcp = cpOut - cpStartMain + 2;

	lserr = LsdnFinishRegular(pilsobj->plsc, pdobj->sobjhelp.dcp, 
		pcfmtin->lsfrun.plsrun, pcfmtin->lsfrun.plschp, pdobj, 
			&pdobj->sobjhelp.objdimAll);
		
	if (lserr != lserrNone)
		{
		HihFreeDobj(pdobj); /* do not need to check return error code */

		return lserr;
		}

	if (pcfmtin->lsfgi.urPen + pdobj->sobjhelp.objdimAll.dur > pcfmtin->lsfgi.urColumnMax)
		{
		fmtr = fmtrExceededMargin;
		}

	*pfmtres = fmtr;

	return lserrNone;
}



/* H I H G E T S P E C I A L E F F E C T S I N S I D E */
/*----------------------------------------------------------------------------
	%%Function: HihGetSpecialEffectsInside
	%%Contact: ricksa

		GetSpecialEffectsInside

		.

----------------------------------------------------------------------------*/
LSERR WINAPI HihGetSpecialEffectsInside(
	PDOBJ pdobj,				/* (IN): dobj */
	UINT *pEffectsFlags)		/* (OUT): Special effects for this object */
{
	return LsGetSpecialEffectsSubline(pdobj->plssubl, pEffectsFlags);
}

/* H I H C A L C P R E S E N T A T I O N */
/*----------------------------------------------------------------------------
	%%Function: HihCalcPresentation
	%%Contact: ricksa

		CalcPresentation
	
		This has three jobs. First it distributes space to the shorter string
		if so requested. Next it prepares each line for presentation. Finally,
		it calculates the positions of the lines in output device coordinates.
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihCalcPresentation(
	PDOBJ pdobj,				/* (IN): dobj */
	long dup,					/* (IN): dup of dobj */
	LSKJUST lskjust,			/* (IN): Justification type */
	BOOL fLastVisibleOnLine )	/* (IN): Is this object last visible on line? */
{
	Unreferenced (fLastVisibleOnLine);	
	Unreferenced(dup);
	Unreferenced (lskjust);
	return LsMatchPresSubline(pdobj->plssubl);

}

/* H I H Q U E R Y P O I N T P C P */
/*----------------------------------------------------------------------------
	%%Function: HihQueryPointPcp
	%%Contact: ricksa

		Map dup to dcp

		Just call through to Query result helper.

----------------------------------------------------------------------------*/
LSERR WINAPI HihQueryPointPcp(
	PDOBJ pdobj,				/*(IN): dobj to query */
	PCPOINTUV ppointuvQuery,	/*(IN): query point (uQuery,vQuery) */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	Unreferenced(ppointuvQuery);
	return CreateQueryResult(pdobj->plssubl, 0, 0, plsqin, plsqout);
}
	
/* H I H Q U E R Y C P P P O I N T */
/*----------------------------------------------------------------------------
	%%Function: HihQueryCpPpoint
	%%Contact: ricksa

		Map dcp to dup

		Just call through to Query result helper.

----------------------------------------------------------------------------*/
LSERR WINAPI HihQueryCpPpoint(
	PDOBJ pdobj,				/*(IN): dobj to query, */
	LSDCP dcp,					/*(IN): dcp for the query */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	Unreferenced(dcp);
	return CreateQueryResult(pdobj->plssubl, 0, 0, plsqin, plsqout);
}

	
/* H I H D I S P L A Y */
/*----------------------------------------------------------------------------
	%%Function: HihDisplay
	%%Contact: ricksa

		Display

		This calculates the positions of the various lines for the
		display and then displays them.
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihDisplay(
	PDOBJ pdobj,				/*(IN): dobj to display */
	PCDISPIN pcdispin)			/*(IN): info for display */
{

	/* display the Hih line */
	return LsDisplaySubline(pdobj->plssubl, &pcdispin->ptPen, pcdispin->kDispMode, 
		pcdispin->prcClip);
}

/* H I H D E S T R O Y D O B J */
/*----------------------------------------------------------------------------
	%%Function: HihDestroyDobj
	%%Contact: ricksa

		DestroyDobj

		Free all resources connected with the input dobj.
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihDestroyDobj(
	PDOBJ pdobj)				/*(IN): dobj to destroy */
{
	return HihFreeDobj(pdobj);
}

/* H I H E N U M */
/*----------------------------------------------------------------------------
	%%Function: HihEnum
	%%Contact: ricksa

		Enumeration callback - passed to client.
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihEnum(
	PDOBJ pdobj,				/*(IN): dobj to enumerate */
	PLSRUN plsrun,				/*(IN): from DNODE */
	PCLSCHP plschp,				/*(IN): from DNODE */
	LSCP cp,					/*(IN): from DNODE */
	LSDCP dcp,					/*(IN): from DNODE */
	LSTFLOW lstflow,			/*(IN): text flow*/
	BOOL fReverse,				/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,		/*(IN): */
	const POINT* pt,			/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,		/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun)				/*(IN): from DNODE, relevant iff fGeometryNeeded */
{
	return pdobj->pilsobj->pfnEnum(pdobj->pilsobj->pols, plsrun, plschp, cp, 
		dcp, lstflow, fReverse, fGeometryNeeded, pt, pcheights, dupRun, 
			pdobj->plssubl);
}
	

/* H I H H A N D L E R I N I T */
/*----------------------------------------------------------------------------
	%%Function: HihHandlerInit
	%%Contact: ricksa

		Initialize global Hih data and return LSIMETHODS.
	
----------------------------------------------------------------------------*/
LSERR WINAPI LsGetHihLsimethods(
	LSIMETHODS *plsim)
{
	plsim->pfnCreateILSObj = HihCreateILSObj;
	plsim->pfnDestroyILSObj = HihDestroyILSObj;
	plsim->pfnSetDoc = HihSetDoc;
	plsim->pfnCreateLNObj = HihCreateLNObj;
	plsim->pfnDestroyLNObj = HihDestroyLNObj;
	plsim->pfnFmt = HihFmt;
	plsim->pfnFmtResume = ObjHelpFmtResume;
	plsim->pfnGetModWidthPrecedingChar = ObjHelpGetModWidthChar;
	plsim->pfnGetModWidthFollowingChar = ObjHelpGetModWidthChar;
	plsim->pfnTruncateChunk = SobjTruncateChunk;
	plsim->pfnFindPrevBreakChunk = SobjFindPrevBreakChunk;
	plsim->pfnFindNextBreakChunk = SobjFindNextBreakChunk;
	plsim->pfnForceBreakChunk = SobjForceBreakChunk;
	plsim->pfnSetBreak = ObjHelpSetBreak;
	plsim->pfnGetSpecialEffectsInside = HihGetSpecialEffectsInside;
	plsim->pfnFExpandWithPrecedingChar = ObjHelpFExpandWithPrecedingChar;
	plsim->pfnFExpandWithFollowingChar = ObjHelpFExpandWithFollowingChar;
	plsim->pfnCalcPresentation = HihCalcPresentation;
	plsim->pfnQueryPointPcp = HihQueryPointPcp;
	plsim->pfnQueryCpPpoint = HihQueryCpPpoint;
	plsim->pfnDisplay = HihDisplay;
	plsim->pfnDestroyDObj = HihDestroyDobj;
	plsim->pfnEnum = HihEnum;
	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lscrsubl.c ===
/* LSCRSUBL.C						*/

#include "lscrsubl.h"
#include "lsidefs.h"
#include "lsc.h"
#include "lsfetch.h"
#include "getfmtst.h"
#include "setfmtst.h"
#include "fmtres.h"
#include "sublutil.h"
#include "break.h"
#include "prepdisp.h"

#include <limits.h>

#define DO_COMPRESSION	fTrue
#define DO_EXPANSION	fFalse


static LSERR ErrorInCurrentSubline(PLSC plsc, LSERR error)
	{
	Assert(GetCurrentSubline(plsc) != NULL);
	DestroySublineCore(GetCurrentSubline(plsc),&plsc->lscbk, plsc->pols,
		&plsc->lsiobjcontext, plsc->fDontReleaseRuns);
	SetCurrentSubline(plsc, NULL);
	return error;
	}

/* ---------------------------------------------------------------------- */

/*  L S  C R E A T E  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsCreateSubline
    %%Contact: igorzv
Parameters:
	plsc		-			(IN) LS context
	cpFirst		-			(IN) first cp of a subline
	urColumnMax	-			(IN) width restriction for a subline
	lstflow		-			(IN) text flow of a subline
	fContiguos	-			(IN) if TRUE such line has the same coordinate system as main line
							and is allowed to have tabs

----------------------------------------------------------------------------*/
LSERR WINAPI LsCreateSubline(PLSC plsc,	LSCP cpFirst, long urColumnMax,	
							LSTFLOW lstflow, BOOL fContiguos)
	{
	

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc) && !FBreakingAllowed(plsc)) return lserrCreateSublineDisabled;

	if (GetCurrentSubline(plsc) != NULL) return lserrCreateSublineDisabled; 

	if (fContiguos)  /* this flag is allowed only in formating time and only within fmt method */
		{
		if (!FFormattingAllowed(plsc)) return lserrInvalidParameter;
		if (GetDnodeToFinish(plsc) == NULL) return lserrInvalidParameter;
		if (!(SublineFromDnode(GetDnodeToFinish(plsc))->fContiguous)) 
			fContiguos = fFalse;
		}
	if (urColumnMax > uLsInfiniteRM) 
		urColumnMax = uLsInfiniteRM;

	return CreateSublineCore(plsc, cpFirst, urColumnMax, lstflow, fContiguos);	
	}

/* ---------------------------------------------------------------------- */

/*  L S  F E T C H  A P P E N D  T O  C U R R E N T  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsFetchAppendToCurrentSubline
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) LS context
	lsdcp		-		(IN) increse cp before fetching
	plsesc		-		(IN) escape characters
	cEsc		-		(IN) # of escape characters
	pfSuccessful-		(OUT) Successful?---if not, finish 
												subline, destroy it and start anew	
	pfmtres		-		(OUT) result of last formatter
	pcpLim	-			(OUT) where we stop fetching
	pplsdnFirst		-	(OUT) first dnode that was created
	pplsdnLast		-	(OUT) last dnode that was created

----------------------------------------------------------------------------*/

LSERR WINAPI LsFetchAppendToCurrentSubline(PLSC plsc, LSDCP lsdcp,
										   const LSESC* plsesc, DWORD cEsc, 
										   BOOL *pfSuccessful, FMTRES* pfmtres,
										   LSCP* pcpLim, PLSDNODE* pplsdnFirst, 
										   PLSDNODE* pplsdnLast)
	{
	LSERR lserr;
	PLSSUBL plssubl;
	long dur;
	long urColumnMaxIncreased;
	BOOL fDone = fFalse;
	LSSTATE lsstateOld;
	BOOL fFirstIteration = fTrue;
	PLSDNODE plsdnFirstCurrent;
	PLSDNODE plsdnLastCurrent;
	
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;
	
	plssubl = GetCurrentSubline(plsc);
	if (plssubl == NULL) return lserrFormattingFunctionDisabled; 

	/* client can use this function only in formatting or breaking time */
	if (!FFormattingAllowed(plsc) && !FBreakingAllowed(plsc)) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 
	
	/* in formatting time it should be some dnode to finish */
	if (FFormattingAllowed(plsc) && GetDnodeToFinish(plsc) == NULL) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 
	
	/* we don't allow to continue formatting if right margin is exceeded */
	if (plssubl->fRightMarginExceeded) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 
	
	*pfSuccessful = fTrue;
	
	/* we must to set state to formatting and later restore the old one */
	lsstateOld = plssubl->plsc->lsstate;
	plssubl->plsc->lsstate = LsStateFormatting;
	
	
	/*Initialization;    */
	AdvanceCurrentCpLimSubl(plssubl, lsdcp);
	*pplsdnLast = NULL;
	
	urColumnMaxIncreased = RightMarginIncreasing(plsc, plssubl->urColumnMax);
	
	while(!fDone)  /* we continue fetching 	when we have 
		tab that are not allowed in our subline */
		{
		lserr = FetchAppendEscCore(plsc, urColumnMaxIncreased, plsesc, cEsc, pfmtres,
				pcpLim, &plsdnFirstCurrent, &plsdnLastCurrent, &dur);
		if (lserr != lserrNone)
			return ErrorInCurrentSubline(plsc, lserr); 
			
		Assert((plsdnFirstCurrent == NULL) == (plsdnLastCurrent == NULL));
		Assert((plsdnLastCurrent == NULL) || ((plsdnLastCurrent)->plsdnNext == NULL));

		if (fFirstIteration)
			{
			*pplsdnFirst = plsdnFirstCurrent;
			fFirstIteration = fFalse;
			}
		if (plsdnLastCurrent != NULL)
			*pplsdnLast = plsdnLastCurrent;

		if (*pfmtres == fmtrTab && !plssubl->fContiguous)
			{
			fDone = fFalse;
			}
		else
			{
			fDone = fTrue;
			}
		}
	plsc->lsstate = lsstateOld;
		
	if (*pfmtres == fmtrExceededMargin)
		{
		if (GetCurrentUrSubl(plssubl) <= plssubl->urColumnMax)
			{
			*pfSuccessful = fFalse;
			if (plsc->lMarginIncreaseCoefficient >= uLsInfiniteRM / 2 )
				plsc->lMarginIncreaseCoefficient = uLsInfiniteRM;
			else
				plsc->lMarginIncreaseCoefficient *= 2; /* increase coefficient to be successful
												   next time */
			return lserrNone;
			}

		plssubl->fRightMarginExceeded = fTrue;
		}
		
	Assert((*pplsdnFirst == NULL) == (*pplsdnLast == NULL));
	Assert((*pplsdnLast == NULL) || ((*pplsdnLast)->plsdnNext == NULL));
		
		
	return lserrNone;
	}
/* ---------------------------------------------------------------------- */

/*  L S  F E T C H  A P P E N D   T O  C U R R E N T  S U B L I N E  R E S U M E*/
/*----------------------------------------------------------------------------
    %%Function: LsFetchAppendToCurrentSublineResume
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) LS context
	rgbreakrec	-		(IN) input array of break records 
	cbreakrec,			(IN) number of records in input array 
	lsdcp		-		(IN) increse cp before fetching
	plsesc		-		(IN) escape characters
	cEsc		-		(IN) # of escape characters
	pfSuccessful-		(OUT) Successful?---if not, finish 
												subline, destroy it and start anew	
	pfmtres		-		(OUT) result of last formatter
	pcpLim	-			(OUT) where we stop fetching
	pplsdnFirst		-	(OUT) first dnode that was created
	pplsdnLast		-	(OUT) last dnode that was created

----------------------------------------------------------------------------*/

LSERR WINAPI LsFetchAppendToCurrentSublineResume(PLSC plsc, const BREAKREC* rgbreakrec,
						   DWORD cbreakrec, LSDCP lsdcp, const LSESC* plsesc, 
						   DWORD cEsc, BOOL *pfSuccessful, 
						   FMTRES* pfmtres, LSCP* pcpLim, PLSDNODE* pplsdnFirst, 
						   PLSDNODE* pplsdnLast)
	{
	LSERR lserr;
	PLSSUBL plssubl;
	long dur;
	long urColumnMaxIncreased;
	BOOL fDone = fFalse;
	LSSTATE lsstateOld;
	BOOL fFirstIteration = fTrue;
	PLSDNODE plsdnFirstCurrent;
	PLSDNODE plsdnLastCurrent;
	
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;
	
	plssubl = GetCurrentSubline(plsc);
	if (plssubl == NULL) return lserrFormattingFunctionDisabled; 

	/* client can use this function only in formatting or breaking time */
	if (!FFormattingAllowed(plsc) && !FBreakingAllowed(plsc)) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 
	
	/* in formatting time it should be some dnode to finish */
	if (FFormattingAllowed(plsc) && GetDnodeToFinish(plsc) == NULL) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 
	
	/* subline should be empty to use this function */
	if (GetCurrentDnode(plsc) != NULL) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 
	
	/* we don't allow to continue formatting if right margin is exceeded */
	if (plssubl->fRightMarginExceeded) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 

	*pfSuccessful = fTrue;

	/* we must to set state to formatting and later restore the old one */
	lsstateOld = plssubl->plsc->lsstate;
	plssubl->plsc->lsstate = LsStateFormatting;
	
	
	/*Initialization;    */
	AdvanceCurrentCpLimSubl(plssubl, lsdcp);
	*pplsdnLast = NULL;
	
	urColumnMaxIncreased = RightMarginIncreasing(plsc, plssubl->urColumnMax);
	
	while(!fDone)  /* we continue fetching 	when we have 
		tab that are not allowed in our subline */
		{
		if (fFirstIteration)
			{
			lserr = FetchAppendEscResumeCore(plsc, urColumnMaxIncreased, plsesc, cEsc, rgbreakrec,
						   cbreakrec,pfmtres,	pcpLim, &plsdnFirstCurrent,
						   &plsdnLastCurrent, &dur);
			}
		else
			{
			lserr = FetchAppendEscCore(plsc, urColumnMaxIncreased, plsesc, cEsc, pfmtres,
					pcpLim, &plsdnFirstCurrent, &plsdnLastCurrent, &dur);
			}
		if (lserr != lserrNone)
			return ErrorInCurrentSubline(plsc, lserr); 
			
		Assert((plsdnFirstCurrent == NULL) == (plsdnLastCurrent == NULL));
		Assert((plsdnLastCurrent == NULL) || ((plsdnLastCurrent)->plsdnNext == NULL));

		if (fFirstIteration)
			{
			*pplsdnFirst = plsdnFirstCurrent;
			fFirstIteration = fFalse;
			}
		if (plsdnLastCurrent != NULL)
			*pplsdnLast = plsdnLastCurrent;
			
		if (*pfmtres == fmtrTab && !plssubl->fContiguous)
			{
			fDone = fFalse;
			}
		else
			{
			fDone = fTrue;
			}
		}

	plsc->lsstate = lsstateOld;

	if (*pfmtres == fmtrExceededMargin)
		{
		if (GetCurrentUrSubl(plssubl) <= plssubl->urColumnMax)
			{
			*pfSuccessful = fFalse;
			if (plsc->lMarginIncreaseCoefficient >= uLsInfiniteRM / 2 )
				plsc->lMarginIncreaseCoefficient = uLsInfiniteRM;
			else
				plsc->lMarginIncreaseCoefficient *= 2; /* increase coefficient to be successful
												   next time */
			return lserrNone;
			}

		plssubl->fRightMarginExceeded = fTrue;
		}
			
	Assert((*pplsdnFirst == NULL) == (*pplsdnLast == NULL));
	Assert((*pplsdnLast == NULL) || ((*pplsdnLast)->plsdnNext == NULL));
		
		
	return lserrNone;
	}

/* ---------------------------------------------------------------------- */

/*  L S  A P P E N D  R U N  T O  C U R R E N T  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsAppendRunToCurrentSubline
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) LS context
	plsfrun		-		(IN) given run
	pfSuccessful-		(OUT) Successful?---if not, finish 
												subline, destroy it and start anew	
	pfmtres		-		(OUT) result of last formatter
	pcpLim		-		(OUT) where we stop fetching
	pplsdn		-		(OUT) dnode created

----------------------------------------------------------------------------*/
LSERR WINAPI LsAppendRunToCurrentSubline(PLSC plsc,	const LSFRUN* plsfrun, BOOL *pfSuccessful,	
						    FMTRES* pfmtres, LSCP* pcpLim, PLSDNODE* pplsdn)	
	{
	LSERR lserr;
	PLSSUBL plssubl;
	LSSTATE lsstateOld;
	long urColumnMaxIncreased;
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	plssubl = GetCurrentSubline(plsc);
	if (plssubl == NULL) return lserrFormattingFunctionDisabled; 

	/* client can use this function only in formatting or breaking time */
	if (!FFormattingAllowed(plsc) && !FBreakingAllowed(plsc)) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 
	
	/* in formatting time it should be some dnode to finish */
	if (FFormattingAllowed(plsc) && GetDnodeToFinish(plsc) == NULL) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 

	/* we don't allow to continue formatting if right margin is exceeded */
	if (plssubl->fRightMarginExceeded) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 

	*pfSuccessful = fTrue;

	/* we must to set state to formatting and later restore the old one */
	lsstateOld = plssubl->plsc->lsstate;
	plssubl->plsc->lsstate = LsStateFormatting;

	urColumnMaxIncreased = RightMarginIncreasing(plsc, plssubl->urColumnMax);

	lserr = ProcessOneRun(plsc, urColumnMaxIncreased, plsfrun, NULL, 0, pfmtres);
	if (lserr != lserrNone)
		return ErrorInCurrentSubline(plsc, lserr); 
	
	plsc->lsstate = lsstateOld;

	if (*pfmtres == fmtrExceededMargin)
		{
		if (GetCurrentUrSubl(plssubl) <= plssubl->urColumnMax)
			{
			*pfSuccessful = fFalse;
			if (plsc->lMarginIncreaseCoefficient >= uLsInfiniteRM / 2 )
				plsc->lMarginIncreaseCoefficient = uLsInfiniteRM;
			else
				plsc->lMarginIncreaseCoefficient *= 2; /* increase coefficient to be successful
												   next time */
			return lserrNone;
			}

		plssubl->fRightMarginExceeded = fTrue;
		}
			

	/* prepare output */
	*pplsdn = GetCurrentDnodeSubl(plssubl);
	*pcpLim = GetCurrentCpLimSubl(plssubl);

	return lserrNone;
	}

/* ---------------------------------------------------------------------- */

/*  L S  R E S E T  R M  I N  C U R R E N T  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsResetRMInCurrentSubline
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) LS context
	urColumnMax	-		(IN) new value of right margin

----------------------------------------------------------------------------*/
LSERR WINAPI LsResetRMInCurrentSubline(PLSC plsc, long urColumnMax)	
	{
	PLSSUBL plssubl;

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	plssubl = GetCurrentSubline(plsc);

	if (plssubl == NULL) return lserrCurrentSublineDoesNotExist;

	/* we don't allow to change right margin if it is exceeded */
	if (plssubl->fRightMarginExceeded) return lserrFormattingFunctionDisabled; 

	Assert(FIsLSSUBL(plssubl));

	plssubl->urColumnMax = urColumnMax;

	return lserrNone;
	}


/* ---------------------------------------------------------------------- */

/*  L S  F I N I S H  C U R R E N T  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsFinishCurrentSubline
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) LS context
	pplssubl	-		(OUT) subline context

----------------------------------------------------------------------------*/
LSERR WINAPI LsFinishCurrentSubline(PLSC plsc, PLSSUBL* pplssubl)
	{
	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	*pplssubl = GetCurrentSubline(plsc);

	if (*pplssubl == NULL) return lserrCurrentSublineDoesNotExist;

	Assert(FIsLSSUBL(*pplssubl));

	return FinishSublineCore(*pplssubl);
	}


/* ---------------------------------------------------------------------- */

/*  L S  T R U N C A T E  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsTruncateSubline
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) LS context
	urColumnMax	-		(IN) right margin
	pcpTruncate	-		(OUT) truncation point

----------------------------------------------------------------------------*/

LSERR WINAPI LsTruncateSubline(PLSSUBL plssubl, long urColumnMax, LSCP* pcpTruncate)
	{
	LSERR lserr;
	LSSTATE lsstateOld;

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	/* it's error if urColumnmMax is biger then lenght of subline */
	if (urColumnMax >= GetCurrentUrSubl(plssubl)) return lserrInvalidParameter;

	/* we must to set state to breaking and later restore the old one */
	lsstateOld = plssubl->plsc->lsstate;
	plssubl->plsc->lsstate = LsStateBreaking;
	
	lserr = TruncateSublineCore(plssubl, urColumnMax,	pcpTruncate);

	plssubl->plsc->lsstate = lsstateOld;

	return lserr;
	}


/* ---------------------------------------------------------------------- */

/*  L S  F I N D  P R E V  B R E A K  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsFindPrevBreakSubline
    %%Contact: igorzv
Parameters:
	plssubl			-	(IN) subline context
	fFirstSubline	-	(IN) to apply rules for first character to the first character of
							 this subline 
	cpTruncate		-	(IN) truncation point
	urColumnMax		-	(IN) right margin
	pfSuccessful	-	(OUT) do we find break?
	pcpBreak		-	(OUT) position of break
	pobjdimSubline	-	(OUT) objdim from begining of the subline up to break
	pbkpos			-	(OUT) Before/Inside/After			

----------------------------------------------------------------------------*/
LSERR WINAPI LsFindPrevBreakSubline(PLSSUBL plssubl, BOOL fFirstSubline, LSCP cpTruncate,	
						    long urColumnMax, BOOL* pfSuccessful, LSCP* pcpBreak,
							POBJDIM pobjdimSubline, BRKPOS* pbkpos)	
	{
	LSERR lserr;
	LSSTATE lsstateOld;

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	/* we must to set state to breaking and later retore the old one */
	lsstateOld = plssubl->plsc->lsstate;
	plssubl->plsc->lsstate = LsStateBreaking;
	
	lserr = FindPrevBreakSublineCore(plssubl, fFirstSubline, cpTruncate, urColumnMax, 
									pfSuccessful, pcpBreak, pobjdimSubline, pbkpos);

	plssubl->plsc->lsstate = lsstateOld;

	return lserr;
	}

/* ---------------------------------------------------------------------- */

/*  L S  F I N D  N E X T  B R E A K  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsFindNextBreakSubline
    %%Contact: igorzv
Parameters:
	plssubl			-	(IN) subline context
	fFirstSubline	-	(IN) to apply rules for first character to the first character of
							 this subline 
	cpTruncate		-	(IN) truncation point
	urColumnMax		-	(IN) right margin
	pfSuccessful	-	(OUT) do we find break?
	pcpBreak		-	(OUT) position of break
	pobjdimSubline	-	(OUT) objdim from begining of the subline up to break
	pbkpos			-	(OUT) Before/Inside/After			

----------------------------------------------------------------------------*/
LSERR WINAPI LsFindNextBreakSubline(PLSSUBL plssubl, BOOL fFirstSubline, LSCP cpTruncate,	
						    long urColumnMax, BOOL* pfSuccessful, LSCP* pcpBreak,
							POBJDIM pobjdimSubline, BRKPOS* pbkpos)		
	{
	LSERR lserr;
	LSSTATE lsstateOld;

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	/* we must to set state to breaking and later retore the old one */
	lsstateOld = plssubl->plsc->lsstate;
	plssubl->plsc->lsstate = LsStateBreaking;
	
	lserr = FindNextBreakSublineCore(plssubl, fFirstSubline, cpTruncate, urColumnMax, 
									pfSuccessful, pcpBreak, pobjdimSubline, pbkpos);

	plssubl->plsc->lsstate = lsstateOld;

	return lserr;
	}

/* ---------------------------------------------------------------------- */

/*  L S  F O R C E  B R E A K  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsForceBreakSubline
    %%Contact: igorzv
Parameters:
	plssubl			-	(IN) subline context
	fFirstSubline	-	(IN) to apply rules for first character to the first character of
							 this subline 
	cpTruncate		-	(IN) truncation point
	urColumnMax		-	(IN) right margin
	pcpBreak		-	(OUT) position of break
	pobjdimSubline	-	(OUT) objdim from begining of the subline up to break
	pbkpos			-	(OUT) Before/Inside/After			

----------------------------------------------------------------------------*/

LSERR WINAPI LsForceBreakSubline(PLSSUBL plssubl, BOOL fFirstSubline, LSCP cpTruncate,	
						    long urColumnMax, LSCP* pcpBreak,
							POBJDIM pobjdimSubline, BRKPOS* pbkpos)		
	{
	LSERR lserr;
	LSSTATE lsstateOld;

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	/* we must to set state to breaking and later retore the old one */
	lsstateOld = plssubl->plsc->lsstate;
	plssubl->plsc->lsstate = LsStateBreaking;
	
	lserr = ForceBreakSublineCore(plssubl, fFirstSubline, cpTruncate, urColumnMax, 
									pcpBreak, pobjdimSubline, pbkpos);

	plssubl->plsc->lsstate = lsstateOld;

	return lserr;
	}


/* ---------------------------------------------------------------------- */

/*  L S  S E T  B R E A K  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsSetBreakSubline
    %%Contact: igorzv
Parameters:
	plssubl				-	(IN) subline context
	brkkind,			-	(IN) Prev/Next/Force/Imposed						
	breakrecMaxCurrent	-	(IN) size of array
	pbreakrecCurrent	-	(OUT) array of break records
	pbreakrecMacCurrent	-	(OUT)  number of used elements of the array

----------------------------------------------------------------------------*/
LSERR WINAPI LsSetBreakSubline(PLSSUBL plssubl,	BRKKIND brkkind, DWORD breakrecMaxCurrent,
							   BREAKREC* pbreakrecCurrent, 
							   DWORD* pbreakrecMacCurrent)

	{
	LSERR lserr;
	LSSTATE lsstateOld;

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	/* we must to set state to breaking and later retore the old one */
	lsstateOld = plssubl->plsc->lsstate;
	plssubl->plsc->lsstate = LsStateBreaking;
	
	lserr = SetBreakSublineCore(plssubl, brkkind, breakrecMaxCurrent,
						pbreakrecCurrent, pbreakrecMacCurrent);

	plssubl->plsc->lsstate = lsstateOld;

	return lserr;
	}

/* ---------------------------------------------------------------------- */

/*  L S  D E S T R O Y  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsDestroySubline
    %%Contact: igorzv
Parameters:
	plssubl				-	(IN) subline context

----------------------------------------------------------------------------*/

LSERR WINAPI LsDestroySubline(PLSSUBL plssubl)
	{
	PLSC plsc;
	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	plsc = plssubl->plsc;
	Assert(FIsLSC(plsc));

	return DestroySublineCore(plssubl,&plsc->lscbk, plsc->pols,
		&plsc->lsiobjcontext, plsc->fDontReleaseRuns);
	}


/* ---------------------------------------------------------------------- */

/*  L S  M A T C H  P R E S  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsMatchPresSubline
    %%Contact: igorzv
Parameters:
	plssubl				-	(IN) subline context

----------------------------------------------------------------------------*/
LSERR WINAPI LsMatchPresSubline(PLSSUBL plssubl)
	{
	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	return MatchPresSubline(plssubl);
	}


/* ---------------------------------------------------------------------- */

/*  L S  E X P A N D  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsExpandSubline
    %%Contact: igorzv
Parameters:
	plssubl		-	(IN) subline context
	lskjust		-	(IN) justification type
	dup			-	(IN) amount to expand

----------------------------------------------------------------------------*/
LSERR WINAPI LsExpandSubline(PLSSUBL plssubl, LSKJUST lskjust, long dup)	
	{
	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	return AdjustSubline(plssubl, lskjust, dup, DO_EXPANSION);
	}


/* ---------------------------------------------------------------------- */

/*  L S  C O M P R E S S  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsCompressSubline
    %%Contact: igorzv
Parameters:
	plssubl		-	(IN) subline context
	lskjust		-	(IN) justification type
	dup			-	(IN) amount to compress

----------------------------------------------------------------------------*/
LSERR WINAPI LsCompressSubline(PLSSUBL plssubl, LSKJUST lskjust, long dup)
	{
	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	return AdjustSubline(plssubl, lskjust, dup, DO_COMPRESSION);
	}


/* ---------------------------------------------------------------------- */

/*  L S  G E T  S P E C I A L  E F F E C T S  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsGetSpecialEffectsSubline
    %%Contact: igorzv
Parameters:
	plssubl				-	(IN) subline context
	pfSpecialEffects	-	(OUT)special effects

----------------------------------------------------------------------------*/
LSERR WINAPI LsGetSpecialEffectsSubline(PLSSUBL plssubl, UINT* pfSpecialEffects)
	{
	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	return GetSpecialEffectsSublineCore(plssubl, &(plssubl->plsc->lsiobjcontext),
										pfSpecialEffects);
	}


/* ---------------------------------------------------------------------- */

/*  L S  S Q U E E Z E  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsSqueezeSubline
    %%Contact: igorzv
Parameters:
	plssubl			-	(IN) subline context
	durTarget		-	(IN) target width of subline
	pfSuccessful	-	(OUT)do we achieve the goal
	pdurExtra		-	(OUT)if nof successful, extra dur we have from the goal

----------------------------------------------------------------------------*/
LSERR WINAPI LsSqueezeSubline(
							  PLSSUBL plssubl,		/* IN: subline context		*/
							  long durTarget,			/* IN: durTarget			*/
							  BOOL* pfSuccessful,		/* OUT: fSuccessful?		*/
							  long* pdurExtra)	/* OUT: if nof successful, 
													extra dur 			*/

	{
	LSERR lserr;
	LSSTATE lsstateOld;

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	/* we must to set state to breaking and later retore the old one */
	lsstateOld = plssubl->plsc->lsstate;
	plssubl->plsc->lsstate = LsStateBreaking;
	
	lserr = SqueezeSublineCore(plssubl, durTarget, pfSuccessful, pdurExtra);

	plssubl->plsc->lsstate = lsstateOld;

	return lserr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lsdnset.c ===
#include "lsdnset.h"
#include "lsc.h"
#include "lsdnode.h"
#include "dnutils.h"
#include "iobj.h"
#include "ntiman.h"
#include "tabutils.h"
#include "getfmtst.h"
#include "setfmtst.h"
#include "lstext.h"
#include "dninfo.h"
#include "chnutils.h"
#include "lssubl.h"
#include "sublutil.h"
#include "lscfmtfl.h"
#include "iobjln.h"

#include "lsmem.h"						/* memset() */

#define FColinearTflows(t1, t2)  \
			(((t1) & fUVertical) == ((t2) & fUVertical))


/* L S D N  Q U E R Y  O B J  D I M  R A N G E */
/*----------------------------------------------------------------------------
    %%Function: LsdnQueryObjDimRange
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsdnFirst		-	(IN) first dnode in the range
	plsdnLast		-	(IN) last dnode in the range
	pobjdim			-	(OUT) geometry of the range

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnQueryObjDimRange(PLSC plsc,
					  PLSDNODE plsdnFirst, PLSDNODE plsdnLast,
					  POBJDIM pobjdim)
{
	PLSDNODE plsdn;
	LSERR lserr;

	if (pobjdim == NULL)
		return lserrNullOutputParameter;

	if (!FIsLSC(plsc))
		return lserrInvalidContext;

	/* if client call us with empty range return right away */
	if (plsdnFirst == NULL)
		{
		if (plsdnLast != NULL) 
			return lserrInvalidDnode;
		memset(pobjdim, 0, sizeof(OBJDIM));
		return lserrNone;
		}

	if (!FIsLSDNODE(plsdnFirst))
		return lserrInvalidDnode;
	if (!FIsLSDNODE(plsdnLast))
		return lserrInvalidDnode;
	if (plsdnFirst->plssubl != plsdnLast->plssubl)							
		return lserrInvalidDnode;

	/* we should call NominalToIdeal if we are in formating stage and range intersects last chunk 
	and this chunk is chunk of text*/
	plsdn = plsdnLast;
	/* to find chunk where we are we should skip back borders */
	while (plsdn != NULL && FIsDnodeBorder(plsdn))
		{
		plsdn = plsdn->plsdnPrev;
		}

	if ((plsc->lsstate == LsStateFormatting) && 
		 FNominalToIdealEncounted(plsc) &&
		(plsdn != NULL) && 
		FIsDnodeReal(plsdn) &&
		(IdObjFromDnode(plsdn) == IobjTextFromLsc(&plsc->lsiobjcontext)) 
	   )
		{
		for(; !FIsChunkBoundary(plsdn->plsdnNext, IobjTextFromLsc(&plsc->lsiobjcontext),
								plsdnLast->cpFirst);
			   plsdn=plsdn->plsdnNext);
		if (plsdn->plsdnNext == NULL)
			{
			lserr = ApplyNominalToIdeal(PlschunkcontextFromSubline(plsdnFirst->plssubl),
				&plsc->lsiobjcontext, plsc->grpfManager, plsc->lsadjustcontext.lskj,
				FIsSubLineMain(SublineFromDnode(plsdn)), FLineContainsAutoNumber(plsc),
				plsdn);
			if (lserr != lserrNone)
				return lserr;
			}
		}  


	return FindListDims(plsdnFirst, plsdnLast, pobjdim);


}

/* L S D N  G E T  C U R  T A B  I N F O */
/*----------------------------------------------------------------------------
    %%Function: LsdnGetCurTabInfo
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsktab			-	(OUT) type of current tab

  Finds tab stop nearest to the current pen position and returns type of such tab stop.
----------------------------------------------------------------------------*/

LSERR WINAPI LsdnGetCurTabInfo(PLSC plsc, LSKTAB* plsktab)
{
	PLSDNODE plsdnTab;
	LSTABSCONTEXT* plstabscontext;
	BOOL fBreakThroughTab;
	LSERR lserr;
	long urNewMargin;
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	if (plsktab == NULL) return lserrInvalidParameter;

	plsdnTab = GetCurrentDnode(plsc);
	plstabscontext = &(plsc->lstabscontext);

	Assert(FIsLSDNODE(plsdnTab));
	if (!plsdnTab->fTab) return lserrCurrentDnodeIsNotTab;
	Assert(FIsDnodeReal(plsdnTab));

	if (plstabscontext->plsdnPendingTab != NULL) return lserrPendingTabIsNotResolved;


	lserr = GetCurTabInfoCore(&plsc->lstabscontext, plsdnTab, GetCurrentUr(plsc), fFalse,
			plsktab, &fBreakThroughTab);
	if (lserr != lserrNone)
		return lserr;

	TurnOnTabEncounted(plsc);
	if (*plsktab != lsktLeft)
		TurnOnNonLeftTabEncounted(plsc);


	/* move current pen position */
	AdvanceCurrentUr(plsc, DurFromDnode(plsdnTab));

	if (fBreakThroughTab)
		{
		lserr = GetMarginAfterBreakThroughTab(&plsc->lstabscontext, plsdnTab, &urNewMargin);
		if (lserr != lserrNone)
			return lserr;

		SetBreakthroughLine(plsc, urNewMargin);
		}

	return lserrNone;

}

/* L S D N  R E S O L V E  P R E V  T A B */
/*----------------------------------------------------------------------------
    %%Function: LsdnResolvePrevTab
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnResolvePrevTab(PLSC plsc)
{
	long dur;
	LSERR lserr;

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	lserr = ResolvePrevTabCore(&plsc->lstabscontext, GetCurrentDnode(plsc), GetCurrentUr(plsc),
							  &dur);
	if (lserr != lserrNone)
		return lserr;

	AdvanceCurrentUr(plsc, dur);

	return lserrNone;

}

/* L S D N  S K I P  C U R  T A B */
/*----------------------------------------------------------------------------
    %%Function: LsdnSkipCurTab
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnSkipCurTab(PLSC plsc)				/* IN: Pointer to LS Context */
{

	PLSDNODE plsdnTab;
	LSTABSCONTEXT* plstabscontext;

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	plsdnTab = GetCurrentDnode(plsc);
	plstabscontext = &(plsc->lstabscontext);

	Assert(FIsLSDNODE(plsdnTab));
	if (!plsdnTab->fTab) return lserrCurrentDnodeIsNotTab;
	Assert(FIsDnodeReal(plsdnTab));


	if (plstabscontext->plsdnPendingTab != NULL)
		{
		CancelPendingTab(&plsc->lstabscontext);
		}
	else
		{
		AdvanceCurrentUr(plsc, - plsdnTab->u.real.objdim.dur);
		SetDnodeDurFmt(plsdnTab, 0);
		}

	return lserrNone;
}

/* L S D N  S E T  R I G I D  D U P */
/*----------------------------------------------------------------------------
    %%Function: LsdnSetRigidDup
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsdn			-	(IN) dnode to be modified
	dup				-	(IN) dup to put in the dnode

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnSetRigidDup(PLSC plsc,	PLSDNODE plsdn,	long dup)
{

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FIsLSDNODE(plsdn)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;


	plsdn->fRigidDup = fTrue;

	if (plsdn->klsdn == klsdnReal)
		{
		plsdn->u.real.dup = dup;
		}
	else 
		{
		plsdn->u.pen.dup = dup;
		}

	return lserrNone;
}

/* L S D N  G E T  D U P */
/*----------------------------------------------------------------------------
    %%Function: LsdnGetDup
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsdn			-	(IN) dnode queried
	dup				-	(OUT) dup of this dnode

----------------------------------------------------------------------------*/
	
LSERR WINAPI LsdnGetDup(PLSC plsc, PLSDNODE plsdn, long* pdup)	
{

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FIsLSDNODE(plsdn)) return lserrInvalidParameter;

	/* check that dup in dnode is valid */

	if (plsdn->plssubl->fDupInvalid && !plsdn->fRigidDup)
		return lserrDupInvalid;

	*pdup = DupFromDnode(plsdn);

	return lserrNone;
}

/* L S D N  R E S E T  O B J  D I M */
/*----------------------------------------------------------------------------
    %%Function: LsdnResetObjDim
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsdn			-	(IN) dnode to be modified
	pobjdimNew		-	(IN) new dimensions of the dnode

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnResetObjDim(PLSC plsc,	PLSDNODE plsdn,	PCOBJDIM pobjdimNew)	

{
	long durOld;

	if (!FIsLSC(plsc)) return lserrInvalidParameter;
	if (!FIsLSDNODE(plsdn)) return lserrInvalidParameter;
	if (!FIsDnodeReal(plsdn)) return lserrInvalidParameter;

	/* we should be in the stage of formatting or breaking */    
	if (!FFormattingAllowed(plsc) && !FBreakingAllowed(plsc))
		return lserrFormattingFunctionDisabled;

	durOld = plsdn->u.real.objdim.dur;
	
	SetDnodeObjdimFmt(plsdn, *pobjdimNew);

	/* update current pen position */
	AdvanceCurrentUrSubl(plsdn->plssubl, (plsdn->u.real.objdim.dur - durOld));

	return lserrNone;
}

/* L S D N  R E S E T  P E N  N O D E */
/*----------------------------------------------------------------------------
    %%Function: LsdnResetPenNode
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsdnPen		-	(IN) dnode to be modified
	dvpPen			-	(IN) new dvp of the dnode
	durPen			-	(IN) new dur of the dnode
	dvrPen			-	(IN) new dvr of the dnode

----------------------------------------------------------------------------*/


LSERR WINAPI LsdnResetPenNode(PLSC plsc, PLSDNODE plsdnPen,	
						  	  long dvpPen, long durPen, long dvrPen)	

{
	long durOld;
	long dvrOld;

	if (!FIsLSC(plsc)) return lserrInvalidParameter;
	if (!FIsLSDNODE(plsdnPen)) return lserrInvalidParameter;
	if (!FIsDnodePen(plsdnPen)) return lserrInvalidParameter;

	/* we should be in the stage of formatting  */
	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;
	if (GetDnodeToFinish(plsc) == NULL) return lserrFormattingFunctionDisabled; 
	if (!FIsDnodeReal(GetDnodeToFinish(plsc)) )
			return lserrFormattingFunctionDisabled; 
	if (plsdnPen->plssubl != GetCurrentSubline(plsc)) return lserrInvalidParameter;

	durOld = plsdnPen->u.pen.dur;
	dvrOld = plsdnPen->u.pen.dvr;

	plsdnPen->u.pen.dvp = dvpPen;
	SetPenBorderDurFmt(plsdnPen, durPen);
	plsdnPen->u.pen.dvr = dvrPen;

	/* update current pen position */
	AdvanceCurrentUr(plsc, plsdnPen->u.pen.dur - durOld);
	AdvanceCurrentVr(plsc, plsdnPen->u.pen.dvr - dvrOld);

	return lserrNone;
}

/* L S D N  Q U E R Y  N O D E */
/*----------------------------------------------------------------------------
    %%Function: LsdnQueryPenNode
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsdnPen		-	(IN) dnode quried
	pdvpPen			-	(OUT) dvp of the dnode
	pdurPen			-	(OUT) dur of the dnode
	pdvrPen			-	(OUT) dvr of the dnode

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnQueryPenNode(PLSC plsc, PLSDNODE plsdnPen,	
						  	  long* pdvpPen, long* pdurPen,	long* pdvrPen)		

{

	if (!FIsLSC(plsc)) return lserrInvalidParameter;
	if (!FIsLSDNODE(plsdnPen)) return lserrInvalidParameter;
	if (!FIsDnodePen(plsdnPen)) return lserrInvalidParameter;


	*pdvpPen = plsdnPen->u.pen.dvp;
	*pdurPen = plsdnPen->u.pen.dur;
	*pdvrPen = plsdnPen->u.pen.dvr;

	return lserrNone;
}

/* L S D N  S E T  A B S  B A S E  L I N E */
/*----------------------------------------------------------------------------
    %%Function:  LsdnSetAbsBaseLine
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	vaAdvanceNew	-	(IN) new vaBase

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnSetAbsBaseLine(PLSC plsc, long vaAdvanceNew)	
{

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	/* we should be in the stage of formatting*/
	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;
	
	plsc->plslineCur->lslinfo.fAdvanced = fTrue;
	plsc->plslineCur->lslinfo.vaAdvance = vaAdvanceNew;

	return lserrNone;
}


#define PlnobjFromLsc(plsc,iobj)	((Assert(FIsLSC(plsc)), PlnobjFromLsline((plsc)->plslineCur,iobj)))

/* L S D N  M O D I F Y  P A R A  E N D I N G*/
/*----------------------------------------------------------------------------
    %%Function:  LsdnModifyParaEnding
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	lskeop			-	(IN) Kind of line ending

----------------------------------------------------------------------------*/
LSERR WINAPI LsdnModifyParaEnding(PLSC plsc, LSKEOP lskeop)
{
	LSERR lserr;
	DWORD iobjText; 
	PLNOBJ plnobjText;  

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	/* we should be in the stage of formatting*/
	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;
	
	iobjText = IobjTextFromLsc(&plsc->lsiobjcontext);
	plnobjText = PlnobjFromLsc(plsc, iobjText);

	lserr = ModifyTextLineEnding(plnobjText, lskeop);

	return lserr;
}

/* L S D N  D I S T R I B U T E */
/*----------------------------------------------------------------------------
    %%Function:  LsdnDistribute
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsdnFirst		-	(IN) first dnode in the range
	plsdnFirst		-	(IN) last dnode in the range
	durToDistribute	-	(IN) amount to distribute between dnodes

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnDistribute(PLSC plsc, PLSDNODE plsdnFirst, 
							PLSDNODE plsdnLast,	long durToDistribute)

{
	GRCHUNKEXT grchunkext;
	LSERR lserr;
	long durToNonText;
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;
	if (!FIsLSDNODE(plsdnFirst)) return lserrInvalidParameter;
	if (!FIsLSDNODE(plsdnLast)) return lserrInvalidParameter;

	/* we should be in the stage of formatting or breaking*/
	if (!FFormattingAllowed(plsc) && !FBreakingAllowed(plsc))
		return lserrFormattingFunctionDisabled;

	InitGroupChunkExt(PlschunkcontextFromSubline(plsdnFirst->plssubl),
					  IobjTextFromLsc(&plsc->lsiobjcontext), &grchunkext);	

	/* skip first pen dnodes  */

	while (FIsDnodePen(plsdnFirst) && (plsdnFirst != plsdnLast))
		{
		plsdnFirst = plsdnFirst->plsdnNext;
		if (plsdnFirst == NULL)  /* plsdnFirst and plksdnLast are not in the same level */
			return lserrInvalidParameter;
		}

	if (FIsDnodePen(plsdnFirst)) /* only pens are in the list so there is no business for us */
		return lserrNone;

	while (FIsDnodePen(plsdnLast) && (plsdnLast != plsdnFirst))
		{
		plsdnLast = plsdnLast->plsdnPrev;
		if (plsdnLast == NULL)  /* plsdnFirst and plksdnLast are not in the same level */
			return lserrInvalidParameter;
		}

	Assert(!FIsDnodePen(plsdnLast));

	lserr = CollectTextGroupChunk(plsdnFirst, plsdnLast->cpFirst + plsdnLast->dcp,
								  CollectSublinesNone, &grchunkext);
	if (lserr != lserrNone)
		return lserr;

	/* Because of rigid dup it doesn't make sense to change dur of non text objects 
	   We inforce text to distrubute everything among text by setting amount of
	   non text to 0 */

	return DistributeInText(&(grchunkext.lsgrchnk), 
							LstflowFromSubline(SublineFromDnode(plsdnFirst)),
							0, durToDistribute, &durToNonText);

}


/* L S D N  S U B M I T  S U B L I N E S */
/*----------------------------------------------------------------------------
    %%Function:  LsdnSubmitSublines
    %%Contact: igorzv
Parameters:
	plsc					-	(IN) ptr to line services context 
	plsdnode				-	(IN) dnode 
	cSubline				-	(IN) amount of submitted sublines 
	rgpsubl					-	(IN) array of submitted sublines 
	fUseForJustification	-	(IN) to use for justification
	fUseForCompression		-	(IN) to use for compression
	fUseForDisplay			-	(IN) to use for display
	fUseForDecimalTab		-	(IN) to use for decimal tab
	fUseForTrailingArea		-	(IN) to use for calculating trailing area

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnSubmitSublines(PLSC plsc, PLSDNODE plsdnode,	
							DWORD cSubline, PLSSUBL* rgpsubl,	
							BOOL fUseForJustification, BOOL fUseForCompression,
							BOOL fUseForDisplay, BOOL fUseForDecimalTab, 
							BOOL fUseForTrailingArea)	
	{
	DWORD i;
	BOOL fEmpty = fFalse;
	BOOL fEmptyWork;
	BOOL fTabOrPen = fFalse;
	BOOL fNotColinearTflow = fFalse;
	BOOL fNotSameTflow = fFalse;
	LSERR lserr;
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;
	if (!FIsLSDNODE(plsdnode)) return lserrInvalidParameter;
	if (!FIsDnodeReal(plsdnode)) return lserrInvalidParameter;

	/* we should be in the stage of formatting or breaking*/
	if (!FFormattingAllowed(plsc) && !FBreakingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	/* this procedure can be called many times for the same dnode, so
	   we should dispose memory allocated in previous call */
	if (plsdnode->u.real.pinfosubl != NULL)
		{
		if (plsdnode->u.real.pinfosubl->rgpsubl != NULL)
			{
			plsc->lscbk.pfnDisposePtr(plsc->pols, plsdnode->u.real.pinfosubl->rgpsubl);
			}

		plsc->lscbk.pfnDisposePtr(plsc->pols, plsdnode->u.real.pinfosubl);
		plsdnode->u.real.pinfosubl = NULL;
		}

	/* if nothing submitted return right away */
	if (cSubline == 0)
		return lserrNone;

	TurnOnSubmittedSublineEncounted(plsc);

	/* calculate some properties of sublines  to decide accept or not */
	for (i = 0; i < cSubline; i++)
		{
		if (rgpsubl[i] == NULL) return lserrInvalidParameter;
		if (!FIsLSSUBL(rgpsubl[i])) return lserrInvalidParameter;

		lserr = FIsSublineEmpty(rgpsubl[i], &fEmptyWork);
		if (lserr != lserrNone)
			return lserr;
		if (fEmptyWork) fEmpty = fTrue;

		if (FAreTabsPensInSubline(rgpsubl[i])) 
			fTabOrPen = fTrue;

		if (LstflowFromSubline(SublineFromDnode(plsdnode)) != 
			LstflowFromSubline(rgpsubl[i]))
			fNotSameTflow = fTrue;
		
		if (!FColinearTflows(LstflowFromSubline(SublineFromDnode(plsdnode)),
			LstflowFromSubline(rgpsubl[i])))
			fNotColinearTflow = fTrue;
			
		}


	plsdnode->u.real.pinfosubl = plsc->lscbk.pfnNewPtr(plsc->pols,
											sizeof(*(plsdnode->u.real.pinfosubl)));

	if (plsdnode->u.real.pinfosubl == NULL)
		return lserrOutOfMemory;

	plsdnode->u.real.pinfosubl->cSubline = cSubline;
	plsdnode->u.real.pinfosubl->rgpsubl = plsc->lscbk.pfnNewPtr(plsc->pols,
											sizeof(PLSSUBL) * cSubline);
	if (plsdnode->u.real.pinfosubl->rgpsubl == NULL)
			return lserrOutOfMemory;

	/* copy array of sublines */
	for (i = 0; i < cSubline; i++)
		{
		plsdnode->u.real.pinfosubl->rgpsubl[i] = rgpsubl[i];
		}

	/* set flags */
	plsdnode->u.real.pinfosubl->fUseForJustification = 
		fUseForJustification && !fEmpty && !fTabOrPen && !fNotColinearTflow ;
	plsdnode->u.real.pinfosubl->fUseForCompression = 
		fUseForCompression && plsdnode->u.real.pinfosubl->fUseForJustification;
	/* if subline is submitted for compression it should also submitted for justification */
	plsdnode->u.real.pinfosubl->fUseForTrailingArea = 
		fUseForTrailingArea && plsdnode->u.real.pinfosubl->fUseForCompression;
	/* if subline is submitted for trailing area  it should also be submitted for compression
	which implies submitting for justification */
	plsdnode->u.real.pinfosubl->fUseForDisplay = 
		fUseForDisplay && !fEmpty && !(plsc->grpfManager & fFmiDrawInCharCodes);
	plsdnode->u.real.pinfosubl->fUseForDecimalTab = 
		fUseForDecimalTab && !fEmpty && !fTabOrPen;


	return lserrNone;
	}

/* L S D N  G E T  F O R M A T  D E P T H */
/*----------------------------------------------------------------------------
    %%Function:  LsdnGetFormatDepth
    %%Contact: igorzv
Parameters:
	plsc					-	(IN) ptr to line services context 
	pnDepthFormatLineMax	-	(OUT) maximum depth of sublines 

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnGetFormatDepth(
							PLSC plsc,				/* IN: Pointer to LS Context	*/
							DWORD* pnDepthFormatLineMax)			/* OUT: nDepthFormatLineMax		*/
	{
	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	/* we should be in the stage of formatting or breaking*/
	if (!FFormattingAllowed(plsc) && !FBreakingAllowed(plsc)) 
		return lserrFormattingFunctionDisabled;

	Assert(FWorkWithCurrentLine(plsc));

	*pnDepthFormatLineMax = plsc->plslineCur->lslinfo.nDepthFormatLineMax;

	return lserrNone;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lscontxt.c ===
#include "lsidefs.h"
#include "pilsobj.h"
#include "plsline.h"
#include "lstext.h"
#include "lscbk.h"
#include "lsc.h"
#include "lscontxt.h"
#include "limqmem.h"
#include "qheap.h"
#include "lsline.h"
#include "lsdnode.h"
#include "iobj.h"
#include "chnutils.h"
#include "autonum.h"

#include "lsmem.h"						/* memset() */



static LSERR CannotCreateLsContext(PLSC, LSERR);
static LSERR  InitObject(PLSC plsc, DWORD iobj, const LSIMETHODS* plsim);
static LSERR RemoveContextObjects(PLSC plsc);

#ifdef DEBUG
#ifdef LSTEST_ASSERTSTOP

/* We use it to run debug LS with ship build of WORD */

int nZero = 0;

void AssertFailedStop (char* pzstrMsg, char* pzstrFile, int nLine)
{
	Unreferenced (pzstrMsg);
	Unreferenced (pzstrFile);
	Unreferenced (nLine);

	nZero = nZero / nZero;

	return;
}

#endif
#endif


/* L S  C R E A T E  C O N T E X T */
/*----------------------------------------------------------------------------
    %%Function: LsCreateContext
    %%Contact: igorzv

Parameters:
	plsci 		-   (IN) structure which contains clients setings
	pplsc		-   (OUT) pointer to created contexts (opaque to clients)

    Creates a Line Services context.
	Typically called once, at the beginning of time.
----------------------------------------------------------------------------*/
LSERR WINAPI LsCreateContext(const LSCONTEXTINFO* plsci, PLSC* pplsc)
{
	static LSIMETHODS const lsimText = 
	{
		CreateILSObjText,
		DestroyILSObjText,
		SetDocText,
		CreateLNObjText,
		DestroyLNObjText,
		FmtText,
		NULL,
		NULL,         
		NULL,
		TruncateText,
		FindPrevBreakText,
		FindNextBreakText,
		ForceBreakText,
		SetBreakText,
		NULL,
		NULL,
		NULL,
		CalcPresentationText,
		QueryPointPcpText,
		QueryCpPpointText,
		EnumObjText,
		DisplayText,
		DestroyDObjText,
	};

	static LSIMETHODS const lsimAutonum = 
	{
		AutonumCreateILSObj,
		AutonumDestroyILSObj,
		AutonumSetDoc,
		AutonumCreateLNObj,
		AutonumDestroyLNObj,
		AutonumFmt,
		NULL,
		NULL,         
		NULL,
		AutonumTruncateChunk,
		AutonumFindPrevBreakChunk,
		AutonumFindNextBreakChunk,
		AutonumForceBreakChunk,
		AutonumSetBreak,
		AutonumGetSpecialEffectsInside,
		NULL,
		NULL,
		AutonumCalcPresentation,
		AutonumQueryPointPcp,
		AutonumQueryCpPpoint,
		AutonumEnumerate,
		AutonumDisplay,
		AutonumDestroyDobj,
	};

	DWORD const iobjText = plsci->cInstalledHandlers;
	DWORD const iobjAutonum = plsci->cInstalledHandlers + 1; 
	DWORD const iobjMac = iobjText + 2;
	POLS const pols = plsci->pols;
	const LSIMETHODS* const plsim = plsci->pInstalledHandlers;

	DWORD iobj;
	PLSC plsc;
	LSERR lserr;
	

#ifdef DEBUG
#ifdef LSTEST_ASSERTSTOP

	/* We use this option when run debug LS with ship WORD */

	pfnAssertFailed = AssertFailedStop;

#else

    pfnAssertFailed = plsci->lscbk.pfnAssertFailed;

#endif
#endif

	if (pplsc == NULL)
		return lserrNullOutputParameter;

	*pplsc = NULL;

	/* Allocate memory for the context and clean it
	 */
	plsc = plsci->lscbk.pfnNewPtr(pols, cbRep(struct lscontext, lsiobjcontext.rgobj, iobjMac));
	if (plsc == NULL)
		return lserrOutOfMemory;
	memset(plsc, 0, cbRep(struct lscontext, lsiobjcontext.rgobj, iobjMac)); 

	/* Initialize the fixed-size part of the context
	 */
	plsc->tag = tagLSC;
	plsc->pols = pols;
	plsc->lscbk = plsci->lscbk;
	plsc->fDontReleaseRuns = plsci->fDontReleaseRuns;
	

	plsc->cLinesActive = 0;
	plsc->plslineCur = NULL;

	plsc->lsstate = LsStateCreatingContext;

	plsc->pqhLines = CreateQuickHeap(plsc, limLines,
									 cbRep(struct lsline, rgplnobj, iobjMac), fFalse);
	plsc->pqhAllDNodesRecycled = CreateQuickHeap(plsc, limAllDNodes,
										 sizeof (struct lsdnode), fTrue);
	if (plsc->pqhLines == NULL || plsc->pqhAllDNodesRecycled == NULL )
		{
		return CannotCreateLsContext(plsc, lserrOutOfMemory);
		}


	/* create arrays for chunks  */
	lserr = AllocChunkArrays(&plsc->lschunkcontextStorage, &plsc->lscbk, plsc->pols,
		&plsc->lsiobjcontext);
	if (lserr != lserrNone)
		return CannotCreateLsContext(plsc, lserr);


	/* create array for tabs  */
	plsc->lstabscontext.pcaltbd = plsci->lscbk.pfnNewPtr(pols, 
											sizeof(LSCALTBD)*limCaltbd);

	plsc->lstabscontext.ccaltbdMax = limCaltbd;

	if (plsc->lstabscontext.pcaltbd == NULL )
		{
		return CannotCreateLsContext(plsc, lserrOutOfMemory);
		}

	/*  set links in lstabscontext */
	plsc->lstabscontext.plscbk = &plsc->lscbk;
	plsc->lstabscontext.pols = plsc->pols;
	plsc->lstabscontext.plsdocinf = &plsc->lsdocinf;


	/* ****************************************************************** */
	/* Initialize the "static" array part of the context
	 * "Text" is the last element of the array
	 */
	plsc->lsiobjcontext.iobjMac = iobjMac;
	for (iobj = 0;  iobj < iobjText;  iobj++)
		{
		lserr = InitObject(plsc, iobj, &plsim[iobj]);
		if (lserr != lserrNone)
			return CannotCreateLsContext(plsc, lserr);
		}

	lserr = InitObject(plsc, iobjText, &lsimText);
	if (lserr != lserrNone)
		return CannotCreateLsContext(plsc, lserr);

	/* Set text Config				*/
	lserr = SetTextConfig(PilsobjFromLsc(&plsc->lsiobjcontext, iobjText), &(plsci->lstxtcfg));
	if (lserr != lserrNone)
		return CannotCreateLsContext(plsc, lserr);

	lserr = InitObject(plsc, iobjAutonum, &lsimAutonum);
	if (lserr != lserrNone)
		return CannotCreateLsContext(plsc, lserr);

	/* Set text Config				*/
	lserr = SetAutonumConfig(PilsobjFromLsc(&plsc->lsiobjcontext, iobjAutonum), 
					&(plsci->lstxtcfg));
	if (lserr != lserrNone)
		return CannotCreateLsContext(plsc, lserr);


	plsc->lsstate = LsStateNotReady;  /* nobody can use context before LsSetDoc  */


	/* we set other variavles by memset, bellow we check that we get what we want  */
	Assert(plsc->cLinesActive == 0);
	Assert(plsc->plslineCur == NULL);
	Assert(plsc->fIgnoreSplatBreak == 0);
	Assert(plsc->fLimSplat == fFalse);
	Assert(plsc->fHyphenated == fFalse);
	Assert(plsc->fAdvanceBack == fFalse);
	Assert(plsc->grpfManager == 0);
	Assert(plsc->urRightMarginBreak == 0);
	Assert(plsc->lMarginIncreaseCoefficient == 0);


	Assert(plsc->lsdocinf.fDisplay == fFalse);
	Assert(plsc->lsdocinf.fPresEqualRef == fFalse);
	Assert(plsc->lsdocinf.lsdevres.dxpInch == 0);
	Assert(plsc->lsdocinf.lsdevres.dxrInch == 0);
	Assert(plsc->lsdocinf.lsdevres.dypInch == 0);
	Assert(plsc->lsdocinf.lsdevres.dyrInch == 0);

	Assert(plsc->lstabscontext.fTabsInitialized == fFalse);
	Assert(plsc->lstabscontext.durIncrementalTab == 0);
	Assert(plsc->lstabscontext.urBeforePendingTab == 0);
	Assert(plsc->lstabscontext.plsdnPendingTab == NULL);
	Assert(plsc->lstabscontext.icaltbdMac == 0);
	Assert(plsc->lstabscontext.urColumnMax == 0);
	Assert(plsc->lstabscontext.fResolveTabsAsWord97 == fFalse);

	Assert(plsc->lsadjustcontext.fLineCompressed == fFalse);
	Assert(plsc->lsadjustcontext.fLineContainsAutoNumber == fFalse);
	Assert(plsc->lsadjustcontext.fUnderlineTrailSpacesRM == fFalse);
	Assert(plsc->lsadjustcontext.fForgetLastTabAlignment == fFalse);
	Assert(plsc->lsadjustcontext.fNominalToIdealEncounted == fFalse);
	Assert(plsc->lsadjustcontext.fForeignObjectEncounted == fFalse);
	Assert(plsc->lsadjustcontext.fTabEncounted == fFalse);
	Assert(plsc->lsadjustcontext.fNonLeftTabEncounted == fFalse);
	Assert(plsc->lsadjustcontext.fSubmittedSublineEncounted == fFalse);
	Assert(plsc->lsadjustcontext.fAutodecimalTabPresent == fFalse);
	Assert(plsc->lsadjustcontext.lskj == lskjNone);
	Assert(plsc->lsadjustcontext.lskalign == lskalLeft);
	Assert(plsc->lsadjustcontext.lsbrj == lsbrjBreakJustify);
	Assert(plsc->lsadjustcontext.urLeftIndent == 0);
	Assert(plsc->lsadjustcontext.urStartAutonumberingText == 0);
	Assert(plsc->lsadjustcontext.urStartMainText == 0);
	Assert(plsc->lsadjustcontext.urRightMarginJustify == 0);

	Assert(plsc->lschunkcontextStorage.FChunkValid == fFalse);
	Assert(plsc->lschunkcontextStorage.FLocationValid == fFalse);
	Assert(plsc->lschunkcontextStorage.FGroupChunk == fFalse);
	Assert(plsc->lschunkcontextStorage.FBorderInside == fFalse);
	Assert(plsc->lschunkcontextStorage.grpfTnti == 0);
	Assert(plsc->lschunkcontextStorage.fNTIAppliedToLastChunk == fFalse);
	Assert(plsc->lschunkcontextStorage.locchnkCurrent.clschnk == 0);
	Assert(plsc->lschunkcontextStorage.locchnkCurrent.lsfgi.fFirstOnLine == fFalse);
	Assert(plsc->lschunkcontextStorage.locchnkCurrent.lsfgi.cpFirst == fFalse);
	Assert(plsc->lschunkcontextStorage.locchnkCurrent.lsfgi.urPen == 0);
	Assert(plsc->lschunkcontextStorage.locchnkCurrent.lsfgi.vrPen == 0);
	Assert(plsc->lschunkcontextStorage.locchnkCurrent.lsfgi.urColumnMax == 0);
	Assert(plsc->lschunkcontextStorage.locchnkCurrent.lsfgi.lstflow == 0);


	Assert(plsc->lslistcontext.plsdnToFinish == NULL);
	Assert(plsc->lslistcontext.plssublCurrent == NULL);
	Assert(plsc->lslistcontext.nDepthFormatLineCurrent == 0);

	/* Everything worked, so set the output parameter and return success
	 */
	*pplsc = plsc;
	return lserrNone;
}

/* C A N N O T  C R E A T E  L S  C O N T E X T */
/*----------------------------------------------------------------------------
    %%Function: CannotCreateLsContext
    %%Contact: igorzv

Parameters:
	plsc		-	partually created context
	lseReturn 	-	error code

    Utility function called when an error occurs when an LSC is
	partially created.
----------------------------------------------------------------------------*/
static LSERR CannotCreateLsContext(PLSC plsc, LSERR lseReturn)
{
	plsc->lsstate = LsStateFree;   /* otherwise destroy will not work */
	(void) LsDestroyContext(plsc);
	return lseReturn;
}




/* L S  D E S T R O Y  C O N T E X T */
/*----------------------------------------------------------------------------
    %%Function: LsDestroyContext
    %%Contact: igorzv

Parameters:
	plsc		-	(IN) ptr to line services context 

    Frees all resources associated with a Line Services context,
	which was created by CreateLsContext.
----------------------------------------------------------------------------*/

LSERR WINAPI LsDestroyContext(PLSC plsc) 
{
	LSERR lserr = lserrNone;

	if (plsc != NULL)
		{
		if (!FIsLSC(plsc))
			return lserrInvalidContext;

		if (plsc->cLinesActive != 0 || FIsLSCBusy(plsc))
			return lserrContextInUse;

		plsc->lsstate = LsStateDestroyingContext;

		DestroyQuickHeap(plsc->pqhLines);
		Assert(plsc->pqhAllDNodesRecycled != NULL);
		DestroyQuickHeap(plsc->pqhAllDNodesRecycled);

		DisposeChunkArrays(&plsc->lschunkcontextStorage);
		
		plsc->lscbk.pfnDisposePtr(plsc->pols, plsc->lstabscontext.pcaltbd);


		lserr = RemoveContextObjects(plsc);


		plsc->tag = tagInvalid;
		plsc->lscbk.pfnDisposePtr(plsc->pols, plsc);
		}

	return lserr;
}

 static LSERR  InitObject(PLSC plsc, DWORD iobj, const LSIMETHODS* plsim)
{
	struct OBJ *pobj;
	LSERR lserr;
	
	Assert(FIsLSC(plsc));
	Assert(plsc->lsstate == LsStateCreatingContext);
	Assert(iobj < plsc->lsiobjcontext.iobjMac);

	pobj = &(plsc->lsiobjcontext.rgobj[iobj]);
	pobj->lsim = *plsim;
	Assert(pobj->pilsobj == NULL); 

	lserr = pobj->lsim.pfnCreateILSObj(plsc->pols, plsc, &(plsc->lscbk), iobj, &(pobj->pilsobj));
	if (lserr != lserrNone)
		{
		if (pobj->pilsobj != NULL)
			{
			pobj->lsim.pfnDestroyILSObj(pobj->pilsobj);
			pobj->pilsobj = NULL;
			}
		return lserr;
		}

	return lserrNone;   
	
}
/* R E M O V E  C O N T E X T  O B J E C T S */
/*----------------------------------------------------------------------------
    %%Function: RemoveContextObjects
    %%Contact: igorzv
Parameter:
	plsc		-	(IN) ptr to line services context 

    Removes a set of installed objects from an LSC.
	Destroy all ilsobj 
----------------------------------------------------------------------------*/
LSERR RemoveContextObjects(PLSC plsc)
{
	DWORD iobjMac;
	LSERR lserr, lserrFinal = lserrNone;
	DWORD iobj;
	PILSOBJ pilsobj;

	Assert(FIsLSC(plsc));
	Assert(plsc->lsstate == LsStateDestroyingContext);

	iobjMac = plsc->lsiobjcontext.iobjMac;
	
	for (iobj = 0;  iobj < iobjMac;  iobj++)
		{
		pilsobj = plsc->lsiobjcontext.rgobj[iobj].pilsobj;
		if (pilsobj != NULL)
			{
			lserr = plsc->lsiobjcontext.rgobj[iobj].lsim.pfnDestroyILSObj(pilsobj);
			plsc->lsiobjcontext.rgobj[iobj].pilsobj = NULL;
			if (lserr != lserrNone)
				lserrFinal = lserr;
			}
		}

	return lserrFinal;	
}


#ifdef DEBUG
/* F  I S  L S C O N T E X T   V A L I D*/
/*----------------------------------------------------------------------------
    %%Function: FIsLsContextValid
    %%Contact: igorzv

Parameters:
	plsc		-	(IN) ptr to line services context 

this function verify that nobody spoiled context, all reasonable integrity checks 
should be here 																		
----------------------------------------------------------------------------*/


BOOL FIsLsContextValid(PLSC plsc)
{
	DWORD iobjText = IobjTextFromLsc(&plsc->lsiobjcontext);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnCreateILSObj ==CreateILSObjText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnDestroyILSObj == DestroyILSObjText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnSetDoc == SetDocText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnCreateLNObj == CreateLNObjText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnDestroyLNObj == DestroyLNObjText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnTruncateChunk == TruncateText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnFindPrevBreakChunk == FindPrevBreakText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnFindNextBreakChunk == FindNextBreakText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnForceBreakChunk == ForceBreakText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnDisplay == DisplayText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnQueryPointPcp == QueryPointPcpText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnQueryCpPpoint == QueryCpPpointText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnDestroyDObj == DestroyDObjText);
	Assert(plsc->lschunkcontextStorage.pcont != NULL);
	Assert(plsc->lschunkcontextStorage.pplsdnChunk != NULL);
	Assert(plsc->lschunkcontextStorage.locchnkCurrent.plschnk != NULL);
	Assert(plsc->lschunkcontextStorage.pplsdnNonText != NULL);
	Assert(plsc->lschunkcontextStorage.pfNonTextExpandAfter != NULL);
	Assert(plsc->lschunkcontextStorage.pdurOpenBorderBefore != NULL);
	Assert(plsc->lschunkcontextStorage.pdurCloseBorderAfter != NULL);

	return fTrue; /* if we here than everything OK  */
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lscrline.c ===
#include <limits.h>
#include "lsmem.h"						/* memset() */


#include "break.h"
#include "dnutils.h"
#include "iobj.h"
#include "iobjln.h"
#include "lsc.h"
#include "lschp.h"
#include "lscrline.h"
#include "lsdevres.h"
#include "lskysr.h"
#include "lsffi.h"
#include "lsidefs.h"
#include "lsline.h"
#include "lsfetch.h"
#include "lstext.h"
#include "prepdisp.h"
#include "tlpr.h"
#include "qheap.h"
#include "sublutil.h"
#include "zqfromza.h"
#include "lscfmtfl.h"
#include "limqmem.h"
#include "ntiman.h"



typedef struct   
{
	long urLeft;
	BOOL fAutoDecimalTab;
	long durAutoDecimalTab;
	LSCP cpFirstVis;
	BOOL fAutonumber;
	BOOL fStopped;
	BOOL fYsrChangeAfter;
	WCHAR wchYsr;  /* we need memory to keep wchYsr for kysrChangeAfter  */

} LINEGEOMETRY;

static LSERR CreateLineCore(PLSC,			/* IN: ptr to line services context */			
						  LSCP,				/* IN: starting cp in line */
						  long,				/* IN: column width in twips */
						  const BREAKREC*,	/* IN: previous line's break records */	
						  DWORD,			/* IN: number of previous line's break records */
						  DWORD,			/* IN: size of the array of current line's break records */
						  BREAKREC*,		/* OUT: current line's break records */
						  DWORD*,			/* OUT: actual number of current line's break records */
						  LSLINFO*,			/* OUT: visible line info to fill in		*/
						  PLSLINE*,			/* OUT: ptr to line opaque to client */
						  BOOL*);			/* OUT fSuccessful: false means insufficient fetch */

static BOOL FRoundingOK(void);
static LSERR CannotCreateLine(PLSLINE*,	/* IN: ponter to a line structure to be deleted */
							  LSERR);	/* IN: code of an error							*/

static LSERR ErrReleasePreFetchedRun (PLSC,			/* IN: ptr to line services context */	
									  PLSRUN,	/* IN: ponter to a run structure to be deleted */
									  LSERR);	/* IN: code of an error							*/

static LSERR EndFormatting(PLSC,		/* IN: ptr to line services context */
						   enum endres,	/* IN: type of line ending to put in lslinfo */
						   LSCP,		/* IN: cpLim to put in lslinfo */ 
						   LSDCP,		/* IN: dcpDepend to put in lslinfo*/								
						   LSLINFO*);	/* OUT: lslinfo to fill in, output of LsCreateLine*/
static LSERR FiniFormatGeneralCase (
				PLSC,			/* IN: ptr to line services context */ 
				const BREAKREC*,/* IN: input array of break records		*/
				DWORD,			/* IN: number of records in input array	*/
				DWORD,			/* IN: size of the output array			*/
				BREAKREC*,		/* OUT: output array of break records	*/
				DWORD*,			/* OUT:actual number of records in array*/
				LSLINFO*,		/* OUT: lslinfo to fill in, output of LsCreateLine*/
				BOOL*);			/* OUT fSuccessful: false means insufficient fetch */

static LSERR FiniEndLine(PLSC,		/* IN: ptr to line services context */
						 ENDRES,	/* IN: how the line ended */
						 LSCP		/* IN: cpLim of a line as a result of breaking,
										   can be changed in this procedure*/,
						 LSDCP,		/* IN: dcpDepend (amount of characters after breaking point 
										   that has participated in breaking decision) 
										   can be changed in this procedure  */	
						 LSLINFO*);	/* OUT: lslinfo to fill in, output of LsCreateLine*/

static LSERR FetchUntilVisible(
				PLSC,	 /* IN: ptr to line services context */
				LSPAP*,	 /* IN/OUT current lspap before and after */
				LSCP*,	 /* IN/OUT current cp before and after */
				LSFRUN*, /* IN/OUT current lsfrun before and after */
				PLSCHP,  /* IN/OUT current lschp before and after */
				BOOL*,	 /* OUT fStopped: procedure stopped fetching because has not been allowed
						        to go across paragraph boundaries (result CheckPara Boundaries) */
				BOOL*);  /* OUT fNewPara: procedure crossed paragraph boundaries */

static LSERR InitTextParams(PLSC,			/* IN: ptr to line services context */
							LSCP,			/* IN: cp to start fetch	*/
							long,			/* IN: duaColumn	*/
							LSFRUN*,		/* OUT: lsfrun of the first run		*/
							PLSCHP,			/* OUT: lsfrun of the first run		*/
							LINEGEOMETRY*);	/* OUT: set of flags and parameters about a line */

static LSERR FiniAuto(PLSC ,			/* IN: ptr to line services context */ 
					  BOOL ,			/* IN: fAutonumber	*/
					  BOOL ,			/* IN: fAutoDecimalTab	*/
					  PLSFRUN ,			/* IN: first run of the main text */
					  long,				/* IN: durAutoDecimalTab	*/	
					  const BREAKREC*,	/* IN: input array of break records		*/
					  DWORD,			/* IN: number of records in input array	*/
					  DWORD,			/* IN: size of the output array			*/
					  BREAKREC*,		/* OUT: output array of break records	*/
					  DWORD*,			/* OUT:actual number of records in array*/
					  LSLINFO*,			/* OUT: lslinfo to fill in, output of LsCreateLine*/
					  BOOL*);			/* OUT fSuccessful: false means insufficient fetch */

static LSERR InitCurLine(PLSC plsc,		/* IN: ptr to line services context */
						 LSCP cpFirst);	/* IN: first cp in al line */

static LSERR RemoveLineObjects(PLSLINE plsline);	/* IN: ponter to a line structure */

static LSERR GetYsrChangeAfterRun(
					PLSC plsc,				/* IN: ptr to line services context */ 
					LSCP cp,				/* IN: cp to start fetch	*/
					BOOL* pfYsrChangeAfter,	/* OUT: is it hyphenation of the previous line */
					PLSFRUN plsfrun,		/* OUT: lsfrun of modified first run	*/
					PLSCHP plschp,			/* OUT: lschp of modified first run	*/
					LINEGEOMETRY*);			/* OUT: to put wchYsr */

static LSERR FillTextParams(
				PLSC plsc,				/* IN: ptr to line services context */ 
				LSCP cp,				/* IN: cp to start fetch	*/
				long duaCol,			/* IN: duaColumn	*/
				PLSPAP plspap,			/* IN: paragraph properties */
				BOOL fFirstLineInPara,	/* IN: flag fFirstLineInPara */
				BOOL fStopped,			/* IN: flag fStopped	*/
				LINEGEOMETRY*);			/* OUT: set of flags and parameters about a line */	

static LSERR FiniChangeAfter(
						PLSC plsc,			/* IN: ptr to line services context */ 
						LSFRUN* plsfrun,	/* IN: lsfrun of modified first run	*/ 
						const BREAKREC*,	/* IN: input array of break records		*/
						DWORD,				/* IN: number of records in input array	*/
						DWORD,				/* IN: size of the output array			*/
						BREAKREC*,			/* OUT: output array of break records	*/
						DWORD*,				/* OUT:actual number of records in array*/
						LSLINFO*,			/* OUT: lslinfo to fill in, output of LsCreateLine*/
						BOOL*);				/* OUT fSuccessful: false means insufficient fetch */





/* L I M  R G */
/*----------------------------------------------------------------------------
    %%Function: LimRg
    %%Contact: lenoxb

    Returns # of elements in an array.
----------------------------------------------------------------------------*/
#define LimRg(rg)	(sizeof(rg)/sizeof((rg)[0]))





#define  fFmiAdvancedFormatting  (fFmiPunctStartLine | fFmiHangingPunct)
							  	  

#define FBreakJustSimple(lsbrj)  (lsbrj == lsbrjBreakJustify || lsbrj == lsbrjBreakThenSqueeze)

#define FAdvancedTypographyEnabled(plsc, cbreakrec)  \
						(FNominalToIdealBecauseOfParagraphProperties(plsc->grpfManager, \
								plsc->lsadjustcontext.lskj) || \
						 !FBreakJustSimple((plsc)->lsadjustcontext.lsbrj) ||\
						 cbreakrec != 0 \
						 )

#define fFmiSpecialSpaceBreaking (fFmiWrapTrailingSpaces | fFmiWrapAllSpaces)

#define fFmiQuickBreakProhibited (fFmiSpecialSpaceBreaking | fFmiDoHyphenation)

/* F T R Y  Q U I C K  B R E A K */
/*----------------------------------------------------------------------------
    %%Macro: FTryQuickBreak
    %%Contact: igorzv

    "Returns" fTrue when the formatter flags indicate that it it may be
	possible to use QuickBreakText() instead of the more expensive
	BreakGeneralCase().
----------------------------------------------------------------------------*/
#define FTryQuickBreak(plsc) ((((plsc)->grpfManager & fFmiQuickBreakProhibited) == 0) && \
							  ((plsc)->lMarginIncreaseCoefficient == LONG_MIN) \
                             )


#define GetMainSubline(plsc)	\
							(Assert(FWorkWithCurrentLine(plsc)),\
							&((plsc)->plslineCur->lssubl))

#define FPapInconsistent(plspap)	\
					((((plspap)->lsbrj == lsbrjBreakJustify ||  \
					   (plspap)->lsbrj == lsbrjBreakWithCompJustify) \
							&& (plspap)->uaRightBreak < uLsInfiniteRM \
							&& (plspap)->uaRightBreak != (plspap)->uaRightJustify) \
				||	 ((plspap)->lsbrj == lsbrjBreakThenExpand \
							&& (plspap)->uaRightBreak < (plspap)->uaRightJustify) \
				||	 ((plspap)->lsbrj == lsbrjBreakThenSqueeze \
							&& (plspap)->uaRightBreak > (plspap)->uaRightJustify) \
				||	 ((plspap)->lsbrj != lsbrjBreakWithCompJustify \
							&& (plspap)->grpf & fFmiHangingPunct) \
				||   ((plspap)->lsbrj == lsbrjBreakWithCompJustify \
							&& (plspap)->lskj == lskjFullGlyphs))

/* ---------------------------------------------------------------------- */

/* L S  C R E A T E  L I N E */
/*----------------------------------------------------------------------------
    %%Function: LsCreateLine
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	cpFirst			-	(IN) starting cp in line
	duaColumn		-	(IN) column width in twips
	pbreakrecPrev	-	(IN) previous line's break records 
	breakrecMacPrev	-	(IN) number of previous line's break records 
	breakrecMaxCurrent-	(IN) size of the array of current line's break records
	pbreakrecCurrent-	(OUT) current line's break records
	pbreakrecMacCurrent-(OUT) actual number of current line's break records 
	plsinfo		-	(OUT) visible line info to fill in
	pplsline	-	(OUT) ptr to line opaque to client 

    An exported LineServices API.
----------------------------------------------------------------------------*/

LSERR WINAPI LsCreateLine(PLSC plsc,			
						  LSCP cpFirst,			
						  long duaColumn,
						  const BREAKREC* pbreakrecPrev,
						  DWORD breakrecMacPrev,
						  DWORD breakrecMaxCurrent,
						  BREAKREC* pbreakrecCurrent,
						  DWORD* pbreakrecMacCurrent,
						  LSLINFO* plslinfo,		
						  PLSLINE* pplsline)	
	{
	
	
	LSERR lserr;
	BOOL fSuccessful;
	
	
	/* Check parameters and enviroment   	*/
	
	
	Assert(FRoundingOK());
	
	if (plslinfo == NULL || pplsline == NULL || pbreakrecMacCurrent == NULL)
		return lserrNullOutputParameter;
	
	*pplsline = NULL;
	*pbreakrecMacCurrent = 0;  /* it's very important to initialize number of break records 
							   because for example quick break doesn't work with break records */
	
	if (!FIsLSC(plsc))
		return lserrInvalidContext;
	
	if (plsc->lsstate != LsStateFree)
		return lserrContextInUse;
	
	Assert(FIsLsContextValid(plsc));

	if (pbreakrecPrev == NULL && breakrecMacPrev != 0)
		return lserrInvalidParameter;
	
	if (pbreakrecCurrent == NULL && breakrecMaxCurrent != 0)
		return lserrInvalidParameter;
	
	if (duaColumn < 0)
		return lserrInvalidParameter;

	if (duaColumn > uLsInfiniteRM) 
		duaColumn = uLsInfiniteRM;

	/* if we have current line we  must prepare it for display before creating of new line  */
	/* can change context. We've delayed this untill last moment because of optimisation reasons */
	if (plsc->plslineCur != NULL)
		{
		lserr = PrepareLineForDisplayProc(plsc->plslineCur);
		if (lserr != lserrNone)
			return lserr;
		plsc->plslineCur = NULL;
		}
	
	plsc->lMarginIncreaseCoefficient = LONG_MIN;

	do	/* loop allowing change of exceeded right margin if it's not sufficient */
		{
		lserr = CreateLineCore(plsc, cpFirst, duaColumn, pbreakrecPrev, breakrecMacPrev,
							breakrecMaxCurrent, pbreakrecCurrent, pbreakrecMacCurrent,
							plslinfo, pplsline, &fSuccessful);

		if (lserr != lserrNone)
			return lserr;

		if (!fSuccessful)
			{	/* coefficient has not been sufficient before so increase it */
			if (plsc->lMarginIncreaseCoefficient == LONG_MIN)
				plsc->lMarginIncreaseCoefficient = 1;
			else
				{
				if (plsc->lMarginIncreaseCoefficient >= uLsInfiniteRM / 2 )
					plsc->lMarginIncreaseCoefficient = uLsInfiniteRM;
				else
					plsc->lMarginIncreaseCoefficient *= 2;
				}
			}
		}
	while (!fSuccessful);


#ifdef DEBUG
#ifdef LSTEST_GETMINDUR

	/* Test LsGetMinDurBreaks () */

	if ((lserr == lserrNone) && (plslinfo->endr != endrNormal) &&
		(plslinfo->endr != endrHyphenated) && (! (plsc->grpfManager & fFmiDoHyphenation)) )
		{
		/* Line was ended with hard break / stopped */

		long durMinInclTrail;
		long durMinExclTrail;

		lserr = LsGetMinDurBreaks ( plsc, *pplsline, &durMinInclTrail, 
								    &durMinExclTrail );
		};

#endif /* LSTEST_GETMINDUR */
#endif /* DEBUG */


	return lserr;

	}


/* ---------------------------------------------------------------------- */

/* C R E A T E  L I N E   C O R E*/
/*----------------------------------------------------------------------------
    %%Function: CreateLineCore
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	cpFirst			-	(IN) starting cp in line
	duaColumn		-	(IN) column width in twips
	pbreakrecPrev	-	(IN) previous line's break records 
	breakrecMacPrev	-	(IN) number of previous line's break records 
	breakrecMaxCurrent-	(IN) size of the array of current line's break records
	pbreakrecCurrent-	(OUT) current line's break records
	pbreakrecMacCurrent-(OUT) actual number of current line's break records 
	plsinfo			-	(OUT) visible line info to fill in
	pplsline		-	(OUT) ptr to line opaque to client 
	pfSuccessful	-	(OUT) fSuccessful: false means insufficient fetch

	Internal procedure organized to handle error in choosing extended right margin
----------------------------------------------------------------------------*/

static LSERR CreateLineCore(PLSC plsc,			
						  LSCP cpFirst,			
						  long duaColumn,
						  const BREAKREC* pbreakrecPrev,
						  DWORD breakrecMacPrev,
						  DWORD breakrecMaxCurrent,
						  BREAKREC* pbreakrecCurrent,
						  DWORD* pbreakrecMacCurrent,
						  LSLINFO* plslinfo,		
						  PLSLINE* pplsline,
						  BOOL* pfSuccessful)	
{


	PLSLINE plsline;
	LINEGEOMETRY lgeom;
	LSCHP lschp;
	LSERR lserr;
	BOOL fGeneral = fFalse;
	BOOL fHardStop;
	BOOL fSuccessfulQuickBreak;
	LSCP cpLimLine;
	LSDCP dcpDepend = 0;
	LSFRUN lsfrun;
	long urFinalPen;
	long urColumnMaxIncreased;
	ENDRES endr = endrNormal;


	/*Initialization;   */

	*pfSuccessful = fTrue;

	lsfrun.plschp = &lschp;  /* we use the same area for lschips */
								 /* because we pasing pointer to const nobody can change it */


	plsline= PvNewQuick(plsc->pqhLines, cbRep(struct lsline, rgplnobj, plsc->lsiobjcontext.iobjMac));
	if (plsline == NULL)
		return lserrOutOfMemory;

	plsc->lsstate = LsStateFormatting; /* We start here  forwating line. After this momemt we must 
										  free context before return. We do this either in CannotCreateLine (error)
										  or EndFormatting (success)   */

	plsc->plslineCur = plsline;
	*pplsline = plsline;

	lserr = InitCurLine (plsc, cpFirst);  
	if (lserr != lserrNone)
		return CannotCreateLine(pplsline, lserr);


	/* check initial value of flags */
	Assert(FAllSimpleText(plsc));
	Assert(!FNonRealDnodeEncounted(plsc));
	Assert(!FNonZeroDvpPosEncounted(plsc));
	Assert(AggregatedDisplayFlags(plsc) == 0);
	Assert(!FNominalToIdealEncounted(plsc));
	Assert(!FForeignObjectEncounted(plsc));
	Assert(!FTabEncounted(plsc));
	Assert(!FNonLeftTabEncounted(plsc));
	Assert(!FSubmittedSublineEncounted(plsc));
	Assert(!FAutodecimalTabPresent(plsc));
	
	plsc->cLinesActive += 1;


	lserr = InitTextParams(plsc, cpFirst, duaColumn, &lsfrun, &lschp, &lgeom);
	if (lserr != lserrNone)
		return CannotCreateLine(pplsline,lserr);

	/* prepare starting set for formatting */
	InitFormattingContext(plsc,  lgeom.urLeft, lgeom.cpFirstVis); 


	/* REVIEW comments */
	if (lgeom.fStopped)
		{
		plsc->lsstate = LsStateBreaking;  /* we now in a stage of breaking */

		lserr = FiniEndLine(plsc, endrStopped, lgeom.cpFirstVis, 0, plslinfo);
		if (lserr != lserrNone)
			return CannotCreateLine(pplsline,lserr);
		else
			return lserrNone;
		}
		
	/* change first character because of hyphenation */
	if (lgeom.fYsrChangeAfter)
		{
		Assert(!(lgeom.fAutonumber) || (lgeom.fAutoDecimalTab));

		lserr = FiniChangeAfter(plsc, &lsfrun, pbreakrecPrev,
								breakrecMacPrev, breakrecMaxCurrent,
								pbreakrecCurrent, pbreakrecMacCurrent, plslinfo, pfSuccessful);

		if (lserr != lserrNone || !*pfSuccessful)
			return CannotCreateLine(pplsline, lserr);
		else
			return lserrNone;
		}
	/* important note to understand code flow : The situation below can happened
	   only for first line in a paragraph, the situation above never can happened 
	   for such line. */

	/* if autonumbering or auto-decimal tab */
	if ((lgeom.fAutonumber) || (lgeom.fAutoDecimalTab))
		{
		Assert(!lgeom.fYsrChangeAfter);

		TurnOffAllSimpleText(plsc);

		/* we will release plsrun in FiniAuto */

		lserr = FiniAuto(plsc, lgeom.fAutonumber, lgeom.fAutoDecimalTab, &lsfrun,
						lgeom.durAutoDecimalTab, pbreakrecPrev,
						breakrecMacPrev, breakrecMaxCurrent,
						pbreakrecCurrent, pbreakrecMacCurrent, plslinfo, pfSuccessful); 

		if (lserr != lserrNone || !*pfSuccessful)
			return CannotCreateLine(pplsline, lserr);
		else
			return lserrNone;
		}

	if (FAdvancedTypographyEnabled(plsc, breakrecMacPrev ))
		{
		/* we should release run here, in general procedure we will fetch it again */
		if (!plsc->fDontReleaseRuns)
			{
			lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, lsfrun.plsrun);
			if (lserr != lserrNone)
				return CannotCreateLine(pplsline,lserr);
			}

		lserr = FiniFormatGeneralCase(plsc, pbreakrecPrev,
						breakrecMacPrev, breakrecMaxCurrent,
						pbreakrecCurrent, pbreakrecMacCurrent, plslinfo, pfSuccessful); 
		
		if (lserr != lserrNone || !*pfSuccessful)
			return CannotCreateLine(pplsline,lserr);
		else
			return lserrNone;
		}

	/* it is possible that width of column is negative: in such scase we'll 
	use another right margin*/
	if (plsc->urRightMarginBreak <= 0 && plsc->lMarginIncreaseCoefficient == LONG_MIN)
		plsc->lMarginIncreaseCoefficient = 1;

	if (plsc->lMarginIncreaseCoefficient != LONG_MIN)
		{
		urColumnMaxIncreased = RightMarginIncreasing(plsc, plsc->urRightMarginBreak);
		}
	else
		{
		urColumnMaxIncreased = plsc->urRightMarginBreak;
		}

 	lserr = QuickFormatting(plsc, &lsfrun, urColumnMaxIncreased,
							&fGeneral, &fHardStop, &cpLimLine, &urFinalPen);	

	if (lserr != lserrNone)
		return CannotCreateLine(pplsline,lserr);


	if (fGeneral)
		{
		lserr = FiniFormatGeneralCase(plsc, pbreakrecPrev,
									  breakrecMacPrev, breakrecMaxCurrent,
									  pbreakrecCurrent, pbreakrecMacCurrent,
									  plslinfo, pfSuccessful); 
 
		if (lserr != lserrNone || !*pfSuccessful)
			return CannotCreateLine(pplsline, lserr);
		else
			return lserrNone;
		}
 
	plsc->lsstate = LsStateBreaking;  /* we now in a stage of breaking */
	if (FTryQuickBreak(plsc))
		{
		lserr = BreakQuickCase(plsc, fHardStop, &dcpDepend, &cpLimLine, 
							   &fSuccessfulQuickBreak, &endr);		
		if (lserr != lserrNone)
			return CannotCreateLine(pplsline,lserr);
		}
	else
		{
		fSuccessfulQuickBreak = fFalse;
		}

	if (fSuccessfulQuickBreak)
		{
		if (endr == endrNormal || endr == endrAltEndPara ||   
			(endr == endrEndPara && !plsc->fLimSplat))
			{
			lserr = EndFormatting(plsc, endr, cpLimLine,
				dcpDepend, plslinfo);
			if (lserr != lserrNone)
				return CannotCreateLine(pplsline,lserr);
			else
				return lserrNone;
			}
		else	/* there is splat that is handled in FiniEndLine */
			{
			lserr = FiniEndLine(plsc, endr, cpLimLine, dcpDepend, plslinfo);
			if (lserr != lserrNone)
				return CannotCreateLine(pplsline, lserr);
			else
				return lserrNone;
			}
		}
	else
		{
		/*  here we should use BreakGeneralCase */
		lserr = BreakGeneralCase(plsc, fHardStop, breakrecMaxCurrent,
								pbreakrecCurrent, pbreakrecMacCurrent,&dcpDepend, 
								&cpLimLine, &endr, pfSuccessful); 
		if (lserr != lserrNone || !*pfSuccessful)
			return CannotCreateLine(pplsline,lserr);

		lserr = FiniEndLine(plsc, endr, cpLimLine, dcpDepend, plslinfo);
		if (lserr != lserrNone)
			return CannotCreateLine(pplsline, lserr);
     	else
		 	return lserrNone;
		}


}   /* end LsCreateLine   */


/* ---------------------------------------------------------------------- */

/* F I N I  F O R M A T  G E N E R A L   C A S E*/
/*----------------------------------------------------------------------------
    %%Function: FiniFormatGeneralCase 
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	pbreakrecPrev	-	(IN) previous line's break records 
	breakrecMacPrev	-	(IN) number of previous line's break records 
	breakrecMaxCurrent-	(IN) size of the array of current line's break records
	pbreakrecCurrent-	(OUT) current line's break records
	pbreakrecMacCurrent-(OUT) actual number of current line's break records 
	plsinfo		-		(OUT) visible line info to fill in
	pfSuccessful	-	(OUT) fSuccessful: false means insufficient fetch

    Formatting and breaking in a case when "quick formatting" is prohibit
----------------------------------------------------------------------------*/
static LSERR FiniFormatGeneralCase (PLSC  plsc,					
									const BREAKREC* pbreakrecPrev,
									DWORD breakrecMacPrev,
									DWORD breakrecMaxCurrent,
									BREAKREC* pbreakrecCurrent,
									DWORD* pbreakrecMacCurrent,
									LSLINFO* plslinfo, BOOL* pfSuccessful)			 
									
									
									
	{
	long urColumnMaxIncreased;
	FMTRES fmtres;
	LSERR lserr;
	LSCP cpLimLine;
	LSDCP dcpDepend;
	PLSDNODE plsdnFirst, plsdnLast;
	long urFinal;
	ENDRES endr;
	
	
	Assert(FIsLSC(plsc));
	Assert(FFormattingAllowed(plsc));
	Assert(plslinfo != NULL);
	
	*pfSuccessful = fTrue;

	if (plsc->lMarginIncreaseCoefficient == LONG_MIN) /* we are here for the first time */
		{
		/* increase right margin for nominal to ideal and compression */
		if (!FBreakJustSimple(plsc->lsadjustcontext.lsbrj))
			plsc->lMarginIncreaseCoefficient = 2;
		else 
			plsc->lMarginIncreaseCoefficient = 1;
		}

	urColumnMaxIncreased = RightMarginIncreasing(plsc, plsc->urRightMarginBreak);
	
	if (FNominalToIdealBecauseOfParagraphProperties(plsc->grpfManager,
		 plsc->lsadjustcontext.lskj))
		 TurnOnNominalToIdealEncounted(plsc);
	
	if (breakrecMacPrev != 0)
		lserr = FetchAppendEscResumeCore(plsc, urColumnMaxIncreased, NULL, 0,
										pbreakrecPrev, breakrecMacPrev, 
										&fmtres, &cpLimLine, &plsdnFirst,
										&plsdnLast, &urFinal);
	else
		lserr = FetchAppendEscCore(plsc, urColumnMaxIncreased, NULL, 0, 
									&fmtres, &cpLimLine, &plsdnFirst,
									&plsdnLast, &urFinal);
	if (lserr != lserrNone) 
		return lserr;
	
	
	/* fetch append esc can be stopped because of tab */
	/* so we have loop for tabs here				  */
	while (fmtres == fmtrTab)
		{
		lserr = HandleTab(plsc);
		if (lserr != lserrNone) 
			return lserr;

		if (FBreakthroughLine(plsc))
			{
			urColumnMaxIncreased = RightMarginIncreasing(plsc, plsc->urRightMarginBreak);
			}
		
		lserr = FetchAppendEscCore(plsc, urColumnMaxIncreased, NULL, 0, 
			&fmtres, &cpLimLine, &plsdnFirst,
			&plsdnLast, &urFinal);
		if (lserr != lserrNone) 
			return lserr;
		}
		
	Assert(fmtres == fmtrStopped || fmtres == fmtrExceededMargin);
	
	/* skip back pen dnodes */
	while (plsdnLast != NULL && FIsDnodePen(plsdnLast)) 
		{
		plsdnLast = plsdnLast->plsdnPrev;
		}

	/* close last border */
	if (FDnodeHasBorder(plsdnLast) && !FIsDnodeCloseBorder(plsdnLast))
		{
		lserr = CloseCurrentBorder(plsc);
		if (lserr != lserrNone)
			return lserr;
		}

	if (fmtres == fmtrExceededMargin 
		&& (urFinal <= plsc->urRightMarginBreak 	/* it's important for truncation to have <= here */
			|| plsdnLast == NULL || FIsNotInContent(plsdnLast)   /* this can happen if in nominal
											to ideal (dcpMaxContext) we deleted everything 
											in content, but starting point
											of content is already behind right margin */
			)
		) 
		{
		/* return unsuccessful	*/
		*pfSuccessful = fFalse;
		return lserrNone;
		}
	else
		{
		plsc->lsstate = LsStateBreaking;  /* we now in a stage of breaking */
		lserr = BreakGeneralCase(plsc, (fmtres == fmtrStopped), breakrecMaxCurrent,
			pbreakrecCurrent, pbreakrecMacCurrent,
			&dcpDepend, &cpLimLine, &endr, pfSuccessful);

		if (lserr != lserrNone || !*pfSuccessful)
			return lserr;
		
		/* because, we work with increased margin we can resolve pending tab only after break */
		/* we use here that after breaking decision  we set state after break point*/
		lserr = HandleTab(plsc);
		if (lserr != lserrNone)
			return lserr;
		
		return FiniEndLine(plsc, endr, cpLimLine, dcpDepend, plslinfo);
		}	
		
		
	}
	

/* ---------------------------------------------------------------------- */

/* F I N I  E N D  L I N E  */
/*----------------------------------------------------------------------------
    %%Function: FiniEndLine	
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) ptr to line services context 
	endr		-		(IN) how the line ended
	cpLimLine	-		(IN) cpLim of a line as a result of breaking,
										   can be changed in this procedure
	dcpDepend	-		(IN) amount of characters after breaking point 
										   that has participated in breaking decision,
										   can be changed in this procedure  	
	plsinfo		-		(OUT) visible line info to fill in

    Handles splat, calculates heights, special effects
----------------------------------------------------------------------------*/

static LSERR FiniEndLine(PLSC plsc, ENDRES endr, LSCP cpLimLine, 
						 LSDCP dcpDepend, LSLINFO* plslinfo)	

{
	LSLINFO* plslinfoState;
	OBJDIM objdim;
	LSERR lserr; 
	PLSLINE plsline;
	BOOL fEmpty;
	ENDRES endrOld;
	
	Assert(FIsLSC(plsc));
	Assert(plslinfo != NULL);

	plsline = plsc->plslineCur;
	plslinfoState = &(plsline->lslinfo);


	endrOld = endr;
	if (endr == endrEndPara && plsc->fLimSplat)
		{
		endr = endrEndParaSection;
		cpLimLine++;
		}

	/* handling splat   */
    if (endr == endrEndColumn || endr == endrEndSection || 
		endr == endrEndParaSection|| endr == endrEndPage)
		{
 
		if (plsc->grpfManager & fFmiVisiSplats)
			{
			switch (endr)
				{
			case endrEndColumn:			plsline->kspl = ksplColumnBreak;	break;
			case endrEndSection:		plsline->kspl = ksplSectionBreak;	break;
			case endrEndParaSection:	plsline->kspl = ksplSectionBreak;	break;
			case endrEndPage:			plsline->kspl = ksplPageBreak;		break;
				}
			}

		lserr = FIsSublineEmpty(GetMainSubline(plsc), &fEmpty);
		if (lserr != lserrNone)
			return lserr;

		if (!fEmpty && (plsc->grpfManager & fFmiAllowSplatLine))
			{
			cpLimLine--;
			dcpDepend++;
			plsline->kspl = ksplNone;
			if (endrOld == endrEndPara)
				{
				endr = endrEndPara;
				}
			else
				{
				endr = endrNormal;
				}
			}

		}



 	/* Height calculation;       */	
		
	lserr = GetObjDimSublineCore(GetMainSubline(plsc), &objdim);
	if (lserr != lserrNone)
			return lserr;

	plslinfoState->dvrAscent = objdim.heightsRef.dvAscent;
	plslinfoState->dvpAscent = objdim.heightsPres.dvAscent;
	plslinfoState->dvrDescent = objdim.heightsRef.dvDescent;
	plslinfoState->dvpDescent = objdim.heightsPres.dvDescent;
	plslinfoState->dvpMultiLineHeight = objdim.heightsPres.dvMultiLineHeight;
	plslinfoState->dvrMultiLineHeight = objdim.heightsRef.dvMultiLineHeight;

	/* calculation plslinfoState->EffectsFlags*/
	if (plslinfoState->EffectsFlags) /* some run with special effects happend during formating */
		{
		lserr = GetSpecialEffectsSublineCore(GetMainSubline(plsc), 
							&plsc->lsiobjcontext, &plslinfoState->EffectsFlags);
		if (lserr != lserrNone)
			return lserr;
		}


	return EndFormatting(plsc, endr, cpLimLine, dcpDepend, plslinfo);


}



/* ---------------------------------------------------------------------- */
/* F I N I  A U T O */
/*----------------------------------------------------------------------------
    %%Function: FiniAuto
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	fAutonumber		-	(IN) does this line containes autonimber
	fAutoDecimaltab	-	(IN) does this line containes autodecimal tab
	plsfrunMainText	-	(IN) first run of main text
	durAutoDecimalTab-	(IN) tab stop for autodecimal tab 
	pbreakrecPrev	-	(IN) previous line's break records 
	breakrecMacPrev	-	(IN) number of previous line's break records 
	breakrecMaxCurrent-	(IN) size of the array of current line's break records
	pbreakrecCurrent-	(OUT) current line's break records
	pbreakrecMacCurrent-(OUT) actual number of current line's break records 
	plsinfo		-		(OUT) visible line info to fill in
	pfSuccessful	-	(OUT) fSuccessful: false means insufficient fetch

    Completes CreateLine logic for autonumbering and auto-decimal tab 
----------------------------------------------------------------------------*/
static LSERR FiniAuto(
					 PLSC plsc,
					 BOOL fAutonumber,
					 BOOL fAutoDecimalTab,
					 PLSFRUN plsfrunMainText,
					 long durAutoDecimalTab,
					 const BREAKREC* pbreakrecPrev,
					 DWORD breakrecMacPrev,
					 DWORD breakrecMaxCurrent,
				     BREAKREC* pbreakrecCurrent,
					 DWORD* pbreakrecMacCurrent,
					 LSLINFO* plslinfo, BOOL* pfSuccessful)
{
	LSERR lserr;


		if (plsc->lMarginIncreaseCoefficient == LONG_MIN)
			plsc->lMarginIncreaseCoefficient = 1;

		if (fAutonumber)		/*autonumbering  */
		{
		lserr = FormatAnm(plsc, plsfrunMainText);
		if (lserr != lserrNone)
			{
			return ErrReleasePreFetchedRun(plsc, plsfrunMainText->plsrun, lserr);
			}
		}

	if (fAutoDecimalTab)
		{
		lserr = InitializeAutoDecTab(plsc, durAutoDecimalTab); 
		if (lserr != lserrNone)
			{
			return ErrReleasePreFetchedRun(plsc, plsfrunMainText->plsrun, lserr);
			}
		}

	/* we should release run here, in general procedure we will fetch it again */
	if (!plsc->fDontReleaseRuns)
		{
		lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, plsfrunMainText->plsrun);
		if (lserr != lserrNone)
			return lserr;
		}

	return FiniFormatGeneralCase(plsc, pbreakrecPrev,
						  breakrecMacPrev, breakrecMaxCurrent,
						  pbreakrecCurrent, pbreakrecMacCurrent, plslinfo, pfSuccessful);
}

/* F I N I  C H A N G E  A F T E R */
/*----------------------------------------------------------------------------
    %%Function: FiniChangeAfter
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsfrun,		-	(IN) lsfrun of modified first run	 
	pbreakrecPrev	-	(IN) previous line's break records 
	breakrecMacPrev	-	(IN) number of previous line's break records 
	breakrecMaxCurrent-	(IN) size of the array of current line's break records
	pbreakrecCurrent-	(OUT) current line's break records
	pbreakrecMacCurrent-(OUT) actual number of current line's break records 
	plsinfo		-		(OUT) visible line info to fill in
	pfSuccessful	-	(OUT) fSuccessful: false means insufficient fetch

    Completes CreateLine logic for change after because of hyphenation
----------------------------------------------------------------------------*/

static LSERR FiniChangeAfter(PLSC plsc, LSFRUN* plsfrun, const BREAKREC* pbreakrecPrev,
					 DWORD breakrecMacPrev,
					 DWORD breakrecMaxCurrent,
				     BREAKREC* pbreakrecCurrent,
					 DWORD* pbreakrecMacCurrent,
					 LSLINFO* plslinfo, BOOL* pfSuccessful)
	{

	LSERR lserr;
	FMTRES fmtres;

	lserr = ProcessOneRun(plsc, plsc->urRightMarginBreak, plsfrun, NULL, 0, &fmtres); 
	if (lserr != lserrNone)
		return lserr;

	return FiniFormatGeneralCase(plsc, pbreakrecPrev,
						  breakrecMacPrev, breakrecMaxCurrent,
						  pbreakrecCurrent, pbreakrecMacCurrent, plslinfo, pfSuccessful);
	}

/* ---------------------------------------------------------------------- */

/* E N D  F O R M A T T I N G*/
/*----------------------------------------------------------------------------
    %%Function: EndFormatting
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) ptr to line services context 
	endres		-		(IN) how line ends
	cpLimLine	-		(IN) cpLim of a line as a result of breaking,
										   can be changed in this procedure
	dcpDepend	-		(IN) amount of characters after breaking point 
										   that has participated in breaking decision,
										   can be changed in this procedure  	
	plsinfo		-		(OUT) visible line info to fill in

    Filles in lslinfo
----------------------------------------------------------------------------*/


static LSERR EndFormatting (PLSC plsc, enum endres endr,
							LSCP cpLimLine, LSDCP dcpDepend, LSLINFO* plslinfo)

{

	PLSLINE plsline = plsc->plslineCur;
	LSLINFO* plslinfoContext = &(plsline->lslinfo);


	Assert(FIsLSC(plsc));
	Assert(plslinfo != NULL);


	plslinfoContext->cpLim = cpLimLine;
	plslinfoContext->dcpDepend = dcpDepend;
	plslinfoContext->endr = endr;

  	
	*plslinfo = *plslinfoContext;
	plsc->lsstate = LsStateFree;  /* we always return through this procedure (in a case of success )
									 so we free context here */
	return lserrNone;
}

/*----------------------------------------------------------------------------
/* L S  M O D I F Y  L I N E  H E I G H T */
/*----------------------------------------------------------------------------
    %%Function: LsModifyLineHeight
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) ptr to line services context 
	psline		-		(IN) ptr to a line to be modified
	dvpAbove	-		(IN) dvpAbove to set in plsline
	dvpAscent	-		(IN) dvpAscent to set in plsline
	dvpDescent	-		(IN) dvpDescent to set in plsline
	dvpBelow	-		(IN) dvpBelow to set in plsline

	An exported LineServices API.
	Modifies heights in a plsline structure
----------------------------------------------------------------------------*/
LSERR WINAPI LsModifyLineHeight(PLSC plsc,
								PLSLINE plsline,
								long dvpAbove,
								long dvpAscent,
								long dvpDescent,
								long dvpBelow)
{
	if (!FIsLSC(plsc))
		return lserrInvalidContext;

	if (!FIsLSLINE(plsline))
		return lserrInvalidLine;

	if (plsline->lssubl.plsc != plsc)
		return lserrMismatchLineContext;

	if (plsc->lsstate != LsStateFree)
		return lserrContextInUse;



	plsline->dvpAbove = dvpAbove;
	plsline->lslinfo.dvpAscent = dvpAscent;
	plsline->lslinfo.dvpDescent = dvpDescent;
	plsline->dvpBelow = dvpBelow;
	return lserrNone;
}

/*----------------------------------------------------------------------------
/* L S  D E S T R O Y   L I N E  */
/*----------------------------------------------------------------------------
    %%Function: LsDestroyLine
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) ptr to line services context 
	psline		-		(IN) ptr to a line to be deleted

	An exported LineServices API.
	Removed plsline structure , dnode list, line objects structures
----------------------------------------------------------------------------*/

LSERR WINAPI LsDestroyLine(PLSC plsc,		/* IN: ptr to line services context */
						   PLSLINE plsline)	/* IN: ptr to line -- opaque to client */
{
	POLS pols;
	LSERR lserrNew, lserr = lserrNone;

	if (!FIsLSC(plsc))
		return lserrInvalidContext;

	if (!FIsLSLINE(plsline))
		return lserrInvalidLine;

	if (plsline->lssubl.plsc != plsc)
		return lserrMismatchLineContext;

	if (plsc->lsstate != LsStateFree)
		return lserrContextInUse;

	Assert(FIsLsContextValid(plsc));
	Assert(plsc->cLinesActive > 0);

	plsc->lsstate = LsStateDestroyingLine;

	pols = plsc->pols;

	/* optimization */
	/* we use here that text doesn't have pinfosubl and DestroyDobj is actually empty for text */
	if (!plsc->fDontReleaseRuns || !plsline->fAllSimpleText)
		{

		lserrNew = DestroyDnodeList(&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
								plsline->lssubl.plsdnFirst, plsc->fDontReleaseRuns);
		if (lserrNew != lserrNone && lserr == lserrNone)
			lserr = lserrNew;  
		}

	if (plsline == plsc->plslineCur)
		plsc->plslineCur = NULL;  


	lserrNew = RemoveLineObjects(plsline);
	if (lserrNew != lserrNone && lserr == lserrNone)
		lserr = lserrNew; 
	
	/* flush heap of dnodes */
	if (plsline->pqhAllDNodes != NULL)
		FlushQuickHeap(plsline->pqhAllDNodes);

	if (plsc->pqhAllDNodesRecycled != NULL)
				DestroyQuickHeap(plsc->pqhAllDNodesRecycled);

	/* recycle quick heap of dnodes */
	plsc->pqhAllDNodesRecycled = plsline->pqhAllDNodes;


	plsline->tag = tagInvalid;
	DisposeQuickPv(plsc->pqhLines, plsline,
			 cbRep(struct lsline, rgplnobj, plsc->lsiobjcontext.iobjMac));

	plsc->cLinesActive -= 1;

	plsc->lsstate = LsStateFree;
	return lserr;
}

/* ---------------------------------------------------------------------- */

/*  L S  G E T  L I N E  D U R   */
/*----------------------------------------------------------------------------
    %%Function: LsGetLineDur
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) LS context
	plsline			-	(IN) ptr to a line 
	pdurInclTrail	-	(OUT) dur of line incl. trailing area
	pdurExclTrail	-	(OUT)  dur of line excl. trailing area

----------------------------------------------------------------------------*/
LSERR  WINAPI LsGetLineDur	(PLSC plsc,	PLSLINE plsline,
							 long* pdurInclTrail, long* pdurExclTrail)
	{
	LSERR lserr;

	if (!FIsLSC(plsc))
		return lserrInvalidContext;

	if (!FIsLSLINE(plsline))
		return lserrInvalidLine;

	if (plsline->lssubl.plsc != plsc)
		return lserrMismatchLineContext;

	if (plsc->lsstate != LsStateFree)
		return lserrContextInUse;

	Assert(FIsLsContextValid(plsc));
	Assert(plsc->cLinesActive > 0);

	/* check that the line is active */
	if (plsline != plsc->plslineCur)
		return lserrLineIsNotActive;

	/* set breaking state */
	plsc->lsstate = LsStateBreaking;  

	lserr = GetLineDurCore(plsc, pdurInclTrail, pdurExclTrail);

	plsc->lsstate = LsStateFree; 
	
	return lserr;

	}
/* ---------------------------------------------------------------------- */

/*  L S  G E T  M I N  D U R  B R E A K S  */
/*----------------------------------------------------------------------------
    %%Function: LsGetMinDurBreaks
    %%Contact: igorzv
Parameters:
	plsc				-	(IN) LS context
	plsline				-	(IN) ptr to a line 
	pdurMinInclTrail	-	(OUT) min dur between breaks including trailing area
	pdurMinExclTrail	-	(OUT) min dur between breaks excluding trailing area

----------------------------------------------------------------------------*/

LSERR  WINAPI LsGetMinDurBreaks		(PLSC plsc,	PLSLINE plsline,
									 long* pdurMinInclTrail, long* pdurMinExclTrail)
	{
	LSERR lserr;

	if (!FIsLSC(plsc))
		return lserrInvalidContext;

	if (!FIsLSLINE(plsline))
		return lserrInvalidLine;

	if (plsline->lssubl.plsc != plsc)
		return lserrMismatchLineContext;

	if (plsc->lsstate != LsStateFree)
		return lserrContextInUse;

	Assert(FIsLsContextValid(plsc));
	Assert(plsc->cLinesActive > 0);

	/* check that the line is active */
	if (plsline != plsc->plslineCur)
		return lserrLineIsNotActive;

	/* set breaking state */
	plsc->lsstate = LsStateBreaking;  

	lserr = GetMinDurBreaksCore(plsc, pdurMinInclTrail, pdurMinExclTrail);

	plsc->lsstate = LsStateFree; 
	
	return lserr;

	}

/*----------------------------------------------------------------------*/
#define grpfTextMask ( \
		fFmiVisiCondHyphens | \
		fFmiVisiParaMarks | \
		fFmiVisiSpaces | \
		fFmiVisiTabs | \
		fFmiVisiBreaks | \
		fFmiDoHyphenation | \
		fFmiWrapTrailingSpaces | \
		fFmiWrapAllSpaces | \
		fFmiPunctStartLine | \
		fFmiHangingPunct | \
		fFmiApplyBreakingRules | \
		fFmiFCheckTruncateBefore | \
		fFmiDrawInCharCodes | \
		fFmiSpacesInfluenceHeight  | \
		fFmiIndentChangesHyphenZone | \
		fFmiNoPunctAfterAutoNumber  | \
		fFmiTreatHyphenAsRegular \
		)


/*----------------------------------------------------------------------------*/
/* I N I T  T E X T  P A R A M S */
/*----------------------------------------------------------------------------
    %%Function: InitTextParams
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) ptr to line services context 
	cp,			-		(IN) cp to start fetch	
	duaCol		-		(IN) duaColumn	
	plsfrun		-		(IN) lsfrun of the first run	
	plschp		-		(OUT) lsfrun of the first run	
	plgeom		-		(OUT) set of flags and parameters about a line 


    LsCreateLine calls this function at the beginning of the line in order
	to skip over vanished text, fetch an LSPAP, and invoke the text APIs
	SetTextLineParams().
----------------------------------------------------------------------------*/
static LSERR InitTextParams(PLSC plsc, LSCP cp, long duaCol,
							LSFRUN* plsfrun, PLSCHP plschp, LINEGEOMETRY* plgeom)
	{
	LSERR lserr;
	LSPAP lspap;
	POLS pols = plsc->pols;
	BOOL fFirstLineInPara;
	BOOL fHidden;
	BOOL fStopped = fFalse;
	BOOL fNoLinesParaBefore;
	BOOL fNewPara;
	
	plsfrun->lpwchRun = NULL;
	plsfrun->plsrun = NULL;
	plsfrun->cwchRun = 0;

	plgeom->fYsrChangeAfter = fFalse;
	
	Assert(cp >= 0);
	
	lserr = plsc->lscbk.pfnFetchPap(pols, cp, &lspap);
	if (lserr != lserrNone)
		return lserr;
	if (FPapInconsistent(&lspap))
		return lserrInvalidPap;
	
	/* N.B. lspap.cpFirstContent may be negative, which indicates
	* "no content in this paragraph".
	*/
	
	fNoLinesParaBefore = lspap.cpFirstContent < 0 || cp <= lspap.cpFirstContent;
	
	if (!fNoLinesParaBefore && (lspap.grpf & fFmiDoHyphenation))
		{
		lserr = GetYsrChangeAfterRun(plsc, cp, &plgeom->fYsrChangeAfter, plsfrun, plschp, plgeom);
		if (lserr != lserrNone)
			return lserr;
		
		if (plgeom->fYsrChangeAfter)
			{
			fFirstLineInPara = fFalse;
			fStopped = fFalse;
			lserr = FillTextParams(plsc, cp, duaCol, &lspap, fFirstLineInPara, 
				fStopped, plgeom);
			if (lserr != lserrNone)
				return ErrReleasePreFetchedRun(plsc, plsfrun->plsrun, lserr);
			else
				return lserrNone;
			}
		}
	
	lserr = plsc->lscbk.pfnFetchRun(pols, cp,&plsfrun->lpwchRun, &plsfrun->cwchRun,
									&fHidden, plschp,	&plsfrun->plsrun);
	if (lserr != lserrNone)
		return lserr;
	
	
	if (fHidden)		/* vanished text */
		{
		lserr = FetchUntilVisible(plsc, &lspap, &cp, plsfrun, plschp, 
			&fStopped, &fNewPara);
		if (lserr != lserrNone)
			return lserr;
		if (fNewPara)
			fNoLinesParaBefore = fTrue;
		}
	
	fFirstLineInPara = fNoLinesParaBefore && FBetween(lspap.cpFirstContent, 0, cp);
	lserr = FillTextParams(plsc, cp, duaCol, &lspap, fFirstLineInPara,
		fStopped, plgeom);
	if (lserr != lserrNone)
		return ErrReleasePreFetchedRun(plsc, plsfrun->plsrun, lserr);
	else
		return lserrNone;
	
	}

/*----------------------------------------------------------------------------*/
/* G E T  Y S R  C H A N G E  A F T E R  R U N */
/*----------------------------------------------------------------------------
    %%Function: GetYsrChangeAfterRun
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) ptr to line services context 
	cp,			-		(IN) cp to start fetch	
	pfYsrChangeAfter	(OUT) is it hyphenation of the previous line 
	plsfrun,			(OUT) lsfrun of modified first run
	plschp				(OUT) lschp of modified first run
	plsgeom				(OUT) to put wchYsr 


	InitTextParams calls this procedure if there is a possibility 
	for previous line to be hyphenated.
	If previous line has been hyphenated with ysr change after procedure returns
	modified first run for a line
----------------------------------------------------------------------------*/

static LSERR GetYsrChangeAfterRun(PLSC plsc, LSCP cp, BOOL* pfYsrChangeAfter,
								  PLSFRUN plsfrun, PLSCHP plschp, LINEGEOMETRY* plgeom)
	{
	LSFRUN lsfrunPrev;
	LSCHP lschpPrev;
	BOOL fHidden;
	LSERR lserr;
	
	lsfrunPrev.plschp = &lschpPrev;
	*pfYsrChangeAfter = fFalse;
	
	/* Fetch run at cp-1 to handle ysrChangeAfter from previous line.
	*/
	lserr = plsc->lscbk.pfnFetchRun(plsc->pols, cp-1, &lsfrunPrev.lpwchRun,
		&lsfrunPrev.cwchRun, &fHidden, 
		&lschpPrev, &lsfrunPrev.plsrun);
	if (lserr != lserrNone)
		return lserr;

	/* previous run is hyphenated text */
	if (!fHidden && ((lsfrunPrev.plschp)->idObj == idObjTextChp)
		&& (lsfrunPrev.plschp)->fHyphen)
		{
		DWORD kysr;
		WCHAR wchYsr;
		Assert(lsfrunPrev.cwchRun == 1);
		
		lserr = plsc->lscbk.pfnGetHyphenInfo(plsc->pols, lsfrunPrev.plsrun, &kysr, &wchYsr);
		if (lserr != lserrNone)
			return ErrReleasePreFetchedRun(plsc, lsfrunPrev.plsrun, lserr);
		
		if ((kysr == kysrChangeAfter) &&
			(wchYsr != 0))
			{
			lserr = plsc->lscbk.pfnFetchRun(plsc->pols, cp, &plsfrun->lpwchRun,
				&plsfrun->cwchRun, &fHidden, 
				plschp, &plsfrun->plsrun);
			if (lserr != lserrNone)
				return ErrReleasePreFetchedRun(plsc, lsfrunPrev.plsrun, lserr);
			
			if (!fHidden)
				{
				Assert((plsfrun->plschp)->idObj == idObjTextChp);
				plgeom->wchYsr = wchYsr;
				/* Synthesize a 1-byte run */
				plsfrun->lpwchRun = &plgeom->wchYsr; /* here is the only reason to keep wchrChar in lgeom
				we cann't use local memory to keep it */
				plsfrun->cwchRun = 1;
				plschp->fHyphen = kysrNil; 
				
				*pfYsrChangeAfter = fTrue;
				}
			else
				{
				if (!plsc->fDontReleaseRuns)
					{
					lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, plsfrun->plsrun);
					if (lserr != lserrNone)
						return ErrReleasePreFetchedRun(plsc, lsfrunPrev.plsrun, lserr);
					
					}
				}
			}
		}
	/* Release run from previous line */
	if (!plsc->fDontReleaseRuns)
		{
		
		lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, lsfrunPrev.plsrun);
		if (lserr != lserrNone)
			return ErrReleasePreFetchedRun(plsc, plsfrun->plsrun, lserr);
		}
	return lserrNone;
	}

/*----------------------------------------------------------------------------*/
/* F I L L  T E X T  P A R A M S */
/*----------------------------------------------------------------------------
    %%Function: FillTextParamsTextParams
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) ptr to line services context 
	cp,			-		(IN) cp to start fetch	
	duaCol		-		(IN) duaColumn	
	plspap		-		(IN) paragraph properties
	fFirstLineInPara-	(IN) flag fFirstLineInPara 
	fStopped	-		(IN) flag fStopped	
	plgeom		-		(OUT) set of flags and parameters about a line 


    LsCreateLine calls this function at the beginning of the line in order
	to skip over vanished text, fetch an LSPAP, and invoke the text APIs
	SetTextLineParams().
----------------------------------------------------------------------------*/

static LSERR FillTextParams(PLSC plsc, LSCP cp, long duaCol, PLSPAP plspap,
			   BOOL fFirstLineInPara, BOOL fStopped, LINEGEOMETRY* plgeom)
	{
	LSERR lserr;
	TLPR tlpr;
	DWORD iobjText;
	PILSOBJ pilsobjText;
	PLNOBJ plnobjText;
	long uaLeft;
	PLSLINE plsline = plsc->plslineCur;
	long duaColumnMaxBreak;
	long duaColumnMaxJustify;
	long urLeft;

	/* Copy information from lspap to context  current line  and local for LsCreateLine structure lgeom */
	
	uaLeft = plspap->uaLeft;
	if (fFirstLineInPara)
		uaLeft += plspap->duaIndent;
	urLeft = UrFromUa(LstflowFromSubline(GetMainSubline(plsc)),
		&plsc->lsdocinf.lsdevres, uaLeft);

	
	/* line  */
	plsline->lslinfo.fFirstLineInPara = fFirstLineInPara;
	plsline->lslinfo.cpFirstVis = cp;
	plsline->lssubl.lstflow = plspap->lstflow;
	
	if (duaCol != uLsInfiniteRM && plspap->uaRightBreak < uLsInfiniteRM 
		&& plspap->uaRightJustify < uLsInfiniteRM)
		{
		duaColumnMaxBreak = duaCol - plspap->uaRightBreak;
		duaColumnMaxJustify = duaCol - plspap->uaRightJustify;
		}
	else{
		if (duaCol == uLsInfiniteRM)
			{
			duaColumnMaxBreak = uLsInfiniteRM;
			duaColumnMaxJustify = uLsInfiniteRM;
			}
		else
			{
			if (plspap->uaRightBreak >= uLsInfiniteRM)
				duaColumnMaxBreak = uLsInfiniteRM;
			else
				duaColumnMaxBreak = duaCol - plspap->uaRightBreak;
			if (plspap->uaRightJustify >= uLsInfiniteRM)
				duaColumnMaxJustify = uLsInfiniteRM;
			else
				duaColumnMaxJustify = duaCol - plspap->uaRightJustify;
			}
		}
				
	
	/* fill in context for adjustment */
	SetLineLineContainsAutoNumber(plsc, (plspap->grpf & fFmiAnm) && fFirstLineInPara);
	SetUnderlineTrailSpacesRM(plsc, plspap->grpf & fFmiUnderlineTrailSpacesRM);
	SetForgetLastTabAlignment(plsc, plspap->grpf & fFmiForgetLastTabAlignment);
	plsc->lsadjustcontext.lskj = plspap->lskj;
	plsc->lsadjustcontext.lskalign = plspap->lskal;
	plsc->lsadjustcontext.lsbrj = plspap->lsbrj;
	plsc->lsadjustcontext.urLeftIndent = urLeft;
	plsc->lsadjustcontext.urStartAutonumberingText =0;
	plsc->lsadjustcontext.urStartMainText = urLeft; /* autonumber can change it later */
	if (duaColumnMaxJustify != uLsInfiniteRM)
		{
		plsc->lsadjustcontext.urRightMarginJustify = UrFromUa(
												 LstflowFromSubline(GetMainSubline(plsc)),
												 &(plsc->lsdocinf.lsdevres), duaColumnMaxJustify);
		}
	else
		{
		plsc->lsadjustcontext.urRightMarginJustify = uLsInfiniteRM;
		}
	if (duaColumnMaxBreak != uLsInfiniteRM)
		{
		plsc->urRightMarginBreak = UrFromUa(LstflowFromSubline(GetMainSubline(plsc)),
								&(plsc->lsdocinf.lsdevres), duaColumnMaxBreak); 
		}
	else
		{
		plsc->urRightMarginBreak = uLsInfiniteRM;
		}
	plsc->fIgnoreSplatBreak = plspap->grpf & fFmiIgnoreSplatBreak;
	plsc->grpfManager = plspap->grpf;
	plsc->fLimSplat = plspap->grpf & fFmiLimSplat;
	plsc->urHangingTab = UrFromUa(LstflowFromSubline(GetMainSubline(plsc)),
								 &(plsc->lsdocinf.lsdevres), plspap->uaLeft); 

	/* snap grid */
	if (plspap->lskj == lskjSnapGrid)
		{
		if (duaCol != uLsInfiniteRM)
			{
			plsc->lsgridcontext.urColumn = UrFromUa(
				LstflowFromSubline(GetMainSubline(plsc)),
				&(plsc->lsdocinf.lsdevres), duaCol);
			}
		else
			{
			plsc->lsgridcontext.urColumn = uLsInfiniteRM;
			}
		}
	
	/* lgeom */
	plgeom->cpFirstVis = cp;			
	plgeom->urLeft = urLeft;
	plgeom->fAutonumber =  (plspap->grpf & fFmiAnm) && fFirstLineInPara;
	if (plspap->grpf & fFmiAutoDecimalTab)
		{
		plgeom->fAutoDecimalTab = fTrue;
		plgeom->durAutoDecimalTab = UrFromUa(LstflowFromSubline(GetMainSubline(plsc)),
			&(plsc->lsdocinf.lsdevres), plspap->duaAutoDecimalTab);
		}
	else
		{
		plgeom->fAutoDecimalTab = fFalse;
		plgeom->durAutoDecimalTab = LONG_MIN;
		}
	plgeom->fStopped = fStopped;
	
	
	/* prepare tlpr for text */
	
	tlpr.grpfText = (plspap->grpf & grpfTextMask);
	tlpr.fSnapGrid = (plspap->lskj == lskjSnapGrid);
	tlpr.duaHyphenationZone = plspap->duaHyphenationZone;
	tlpr.lskeop = plspap->lskeop;
	
	
	/* we know that here is the first place we need plnobjText and we are creating it */
	iobjText = IobjTextFromLsc(&(plsc->lsiobjcontext));
	Assert( PlnobjFromLsline(plsline,iobjText) == NULL);
	pilsobjText = PilsobjFromLsc(&(plsc->lsiobjcontext), iobjText);
	lserr = CreateLNObjText(pilsobjText, &(plsline->rgplnobj[iobjText]));
	if (lserr != lserrNone)
		return lserr;
	plnobjText = PlnobjFromLsline(plsline, iobjText);
	
	lserr = SetTextLineParams(plnobjText, &tlpr);
	if (lserr != lserrNone)
		return lserr;
	
	return lserrNone;
	}

/*----------------------------------------------------------------------------
/* F E T C H  U N T I L  V I S I B L E */
/*----------------------------------------------------------------------------
    %%Function: FetchUntilVisible
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) ptr to line services context 
	plspap		-		(IN/OUT) current lspap before and after 
	pcp			-		(IN/OUT) current cp before and after 
	plsfrun		-		(IN/OUT) current lsfrun before and after 
	plschp		-		(IN/OUT) current lschp before and after 
	pfStopped	-		(OUT) fStopped: procedure stopped fetching because has not been allowed
						        to go across paragraph boundaries (result CheckPara Boundaries)
	pfNewPara	-		(OUT) fNewPara: procedure crossed paragraph boundaries 

	Releases the supplied PLSRUN, if any, and fetches runs, starting at
	the supplied cp, until a non-vanished run is fetched. As paragraph
	boundaries are crossed, the LSPAP is updated.

----------------------------------------------------------------------------*/
static LSERR FetchUntilVisible(PLSC plsc, LSPAP* plspap, LSCP* pcp,	
							   LSFRUN* plsfrun, PLSCHP plschp,
							   BOOL* pfStopped,	BOOL* pfNewPara)	
	{
	LSERR lserr;
	LSCP dcpPrevRun = plsfrun->cwchRun;
	BOOL fHidden;
	*pfStopped = fFalse;
	*pfNewPara = fFalse;
	
	/* we assume here that this finction is called only after hidden run has been fetched
	   and such run is passed as an input parameter */
	
	do
		{
		const PLSRUN plsrunT = plsfrun->plsrun;
		
		
		*pcp += dcpPrevRun;
		lserr = plsc->lscbk.pfnCheckParaBoundaries(plsc->pols, *pcp - dcpPrevRun, *pcp, pfStopped);
		if (lserr != lserrNone)
			return ErrReleasePreFetchedRun(plsc, plsrunT, lserr);
		if (*pfStopped)
			return lserrNone;
		
		lserr = plsc->lscbk.pfnFetchPap(plsc->pols, *pcp, plspap);
		if (lserr != lserrNone)
			return ErrReleasePreFetchedRun(plsc, plsrunT, lserr);
		if (FPapInconsistent(plspap))
			return ErrReleasePreFetchedRun(plsc, plsrunT, lserrInvalidPap);
		
		if ((*pcp - dcpPrevRun) < plspap->cpFirst)
			*pfNewPara = fTrue;
		
		
		plsfrun->plsrun = NULL;
		if (plsrunT != NULL && !plsc->fDontReleaseRuns)
			{
			lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, plsrunT);
			if (lserr != lserrNone)
				return lserr;
			}
		
		
		lserr = plsc->lscbk.pfnFetchRun(plsc->pols, *pcp,
			&plsfrun->lpwchRun,
			&plsfrun->cwchRun,
			&fHidden,
			plschp,
			&plsfrun->plsrun);
		if (lserr != lserrNone)
			return lserr;
		
		dcpPrevRun = plsfrun->cwchRun;
		}
		while (fHidden);
		
		return lserrNone;
	}




/* I N I T  C U R  L I N E  */
/*----------------------------------------------------------------------------
    %%Function: InitCurLine
    %%Contact: igorzv

Parameters:
	plsc		-	(IN) ptr to line services context 
	cpFirst		-	(IN) starting cp for a line

	Set default value in lsline
----------------------------------------------------------------------------*/

static LSERR InitCurLine(PLSC plsc, LSCP cpFirst)
{
	PLSLINE plsline = plsc->plslineCur;

	memset(plsline, 0, cbRep(struct lsline, rgplnobj, plsc->lsiobjcontext.iobjMac));
	plsline->tag = tagLSLINE;
	plsline->lssubl.tag = tagLSSUBL;
	plsline->lssubl.plsc = plsc;
	plsline->lssubl.cpFirst = cpFirst;

	/* reuse quick heap for dnodes if it possible */
	if (plsc->pqhAllDNodesRecycled != NULL)
		{
		plsline->pqhAllDNodes = plsc->pqhAllDNodesRecycled;
		plsc->pqhAllDNodesRecycled = NULL;
		}
	else
		{
		plsline->pqhAllDNodes = CreateQuickHeap(plsc, limAllDNodes,
										 sizeof (struct lsdnode), fTrue);
		if (plsline->pqhAllDNodes == NULL  )
			return lserrOutOfMemory;

		}

	plsline->lssubl.fDupInvalid = fTrue;
	plsline->lssubl.fContiguous = fTrue;
	plsline->lssubl.plschunkcontext = &(plsc->lschunkcontextStorage);
	plsline->lssubl.fMain = fTrue;
	TurnOnAllSimpleText(plsc); 
	plsline->lslinfo.nDepthFormatLineMax = 1;
	TurnOffLineCompressed(plsc);
	TurnOffNominalToIdealEncounted(plsc);
	TurnOffForeignObjectEncounted(plsc);
	TurnOffTabEncounted(plsc);
	TurnOffNonLeftTabEncounted(plsc);
	TurnOffSubmittedSublineEncounted(plsc);
	TurnOffAutodecimalTabPresent(plsc);
	plsc->fHyphenated = fFalse;
	plsc->fAdvanceBack = fFalse;


	/* we use memset to set default value, below we check that after memset we really have
	correct defaults   */
	Assert(plsline->lssubl.plsdnFirst == NULL);  
	Assert(plsline->lssubl.urColumnMax == 0);  
	Assert(plsline->lssubl.cpLim == 0);  
 	Assert(plsline->lssubl.plsdnLast == NULL);  
	Assert(plsline->lssubl.urCur == 0);  
	Assert(plsline->lssubl.vrCur == 0);  
	Assert(plsline->lssubl.fAcceptedForDisplay == fFalse);  
	Assert(plsline->lssubl.fRightMarginExceeded == fFalse);
 	Assert(plsline->lssubl.plsdnUpTemp == NULL);  
	Assert(plsline->lssubl.pbrkcontext == NULL);

	Assert(plsline->lslinfo.dvpAscent == 0);  /* lslinfo   */
	Assert(plsline->lslinfo.dvrAscent == 0);
	Assert(plsline->lslinfo.dvpDescent == 0);
	Assert(plsline->lslinfo.dvrDescent == 0);
	Assert(plsline->lslinfo.dvpMultiLineHeight == 0);
	Assert(plsline->lslinfo.dvrMultiLineHeight == 0);
	Assert(plsline->lslinfo.dvpAscentAutoNumber == 0);
	Assert(plsline->lslinfo.dvrAscentAutoNumber == 0);
	Assert(plsline->lslinfo.dvpDescentAutoNumber == 0);
	Assert(plsline->lslinfo.dvrDescentAutoNumber == 0);
	Assert(plsline->lslinfo.cpLim == 0);
	Assert(plsline->lslinfo.dcpDepend == 0);
	Assert(plsline->lslinfo.cpFirstVis == 0);
	Assert(plsline->lslinfo.endr == endrNormal);
	Assert(plsline->lslinfo.fAdvanced == fFalse);
	Assert(plsline->lslinfo.vaAdvance == 0);
	Assert(plsline->lslinfo.fFirstLineInPara == fFalse);
	Assert(plsline->lslinfo.EffectsFlags == 0);
	Assert(plsline->lslinfo.fTabInMarginExLine == fFalse);
	Assert(plsline->lslinfo.fForcedBreak == fFalse);

	Assert(plsline->upStartAutonumberingText == 0);  
	Assert(plsline->upLimAutonumberingText == 0);  
	Assert(plsline->upStartMainText == 0);  
	Assert(plsline->upLimLine == 0);  
	Assert(plsline->dvpAbove == 0);  
	Assert(plsline->dvpBelow == 0);  
	Assert(plsline->upRightMarginJustify == 0);  
	Assert(plsline->upLimUnderline == 0);  
	Assert(plsline->kspl == ksplNone);
	Assert(!plsline->fCollectVisual);
	Assert(!plsline->fNonRealDnodeEncounted);
	Assert(!plsline->fNonZeroDvpPosEncounted);
	Assert(plsline->AggregatedDisplayFlags == 0);
	Assert(plsline->pad == 0);

#ifdef DEBUG
	{
		DWORD i;
		for (i=0; i < plsc->lsiobjcontext.iobjMac; i++)
			{
			Assert(plsline->rgplnobj[i] == NULL);
			}
	}
#endif

	return lserrNone;
}


/*----------------------------------------------------------------------------
/* C A N N O T  C R E A T E  L I N E */
/*----------------------------------------------------------------------------
    %%Function: CannotCreateLine
    %%Contact: igorzv
Parameters:
	pplsline	-	(IN) ponter to a line structure to be deleted	
	lserr		-	(IN) code of an error	

	Called when LsCreateLine needs to return for an error condition.
----------------------------------------------------------------------------*/
static LSERR CannotCreateLine(PLSLINE* pplsline, LSERR lserr) 
{
	LSERR lserrIgnore;
	PLSLINE plsline = *pplsline;
	PLSC plsc = plsline->lssubl.plsc;

	plsc->plslineCur = NULL; 
	plsc->lsstate = LsStateFree;  /*  we need free context to destroy line */

	lserrIgnore = LsDestroyLine(plsc, plsline);

	*pplsline = NULL;   
	return lserr;
}

/*----------------------------------------------------------------------------
/* E R R  R E L E A S E  P R E F E T C H E D  R U N */
/*----------------------------------------------------------------------------
    %%Function: ErrReleasePreFetchedRun
    %%Contact: igorzv
Parameters:
	plsc		-	(IN) ptr to line services context 
	plsrun		-	(IN) ponter to a run structure to be deleted	
	lserr		-	(IN) code of an error	

	Called in a error situation when fist run of main text has been prefetched .
----------------------------------------------------------------------------*/
static LSERR ErrReleasePreFetchedRun(PLSC plsc, PLSRUN plsrun, LSERR lserr) 
{
	LSERR lserrIgnore;

	if (!plsc->fDontReleaseRuns)
			lserrIgnore = plsc->lscbk.pfnReleaseRun(plsc->pols, plsrun);

	return lserr;
}


/* R E M O V E  L I N E  O B J E C T S */
/*----------------------------------------------------------------------------
    %%Function: RemoveLineObjects
    %%Contact: igorzv
Parameter:
	plsc		-	(IN) ponter to a line structure

    Removes a line context of installed objects from an line.
----------------------------------------------------------------------------*/
LSERR RemoveLineObjects(PLSLINE plsline)
{
	DWORD iobjMac;
	PLSC plsc;
	LSERR lserr, lserrFinal = lserrNone;
	DWORD iobj;
	PLNOBJ plnobj;

	Assert(FIsLSLINE(plsline));

	plsc = plsline->lssubl.plsc;
	Assert(FIsLSC(plsc));
	Assert(plsc->lsstate == LsStateDestroyingLine);
	
	iobjMac = plsc->lsiobjcontext.iobjMac;	

	for (iobj = 0;  iobj < iobjMac;  iobj++)
		{
		plnobj = plsline->rgplnobj[iobj];
		if (plnobj != NULL)
			{
			lserr = plsc->lsiobjcontext.rgobj[iobj].lsim.pfnDestroyLNObj(plnobj);
			plsline->rgplnobj[iobj] = NULL;
			if (lserr != lserrNone)
				lserrFinal = lserr;
			}
		}

	return lserrFinal;	
}




#ifdef DEBUG
/* F R O U N D I N G  O K */
/*----------------------------------------------------------------------------
    %%Function: FRoundingOK
    %%Contact: lenoxb

    Checks for correctness of rounding algorithm in converting absolute to
	device units, to agree with Word 6.0.

	Checks that:
		0.5 rounds up to 1.0,
		1.4 rounds down to 1.4, 
		-0.5 rounds down to -1.0, and
		-1.4 rounds up to -1.0.
		
----------------------------------------------------------------------------*/
static BOOL FRoundingOK(void)
{
	LSDEVRES devresT;

	Assert((czaUnitInch % 10) == 0);

	devresT.dxpInch = czaUnitInch / 10;

	if (UpFromUa(lstflowDefault, &devresT, 5) != 1)
		return fFalse;
	if (UpFromUa(lstflowDefault, &devresT, 14) != 1)
		return fFalse;
	if (UpFromUa(lstflowDefault, &devresT, -5) != -1)
		return fFalse;
	if (UpFromUa(lstflowDefault, &devresT, -14) != -1)
		return fFalse;

	return fTrue;
}
#endif /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lsdnfin.c ===
/* LSDNFIN.C					*/
#include "lsdnfin.h"
#include "lsidefs.h"
#include "lsc.h"
#include "getfmtst.h"
#include "setfmtst.h"
#include "dninfo.h"
#include "lschp.h"
#include "lsffi.h"
#include "iobj.h"
#include "dnutils.h"
#include "lsfrun.h"
#include "lsfetch.h"
#include "qheap.h"
#include "sublutil.h"
#include "lsmem.h"
#include "lscfmtfl.h"
#include "ntiman.h"

#ifdef DEBUG
#define DebugMemset(a,b,c)		if ((a) != NULL) memset(a,b,c); else
#else
#define DebugMemset(a,b,c)		(void)(0)
#endif



#define IsLschpFlagsValid(plsc, plschp)  fTrue

/* Word violates condition bellow and it is not very important to us, so I deleted body of this macro,
but not deleted macro itself to have a place where to put such checks later */

//		((((plsc)->lsadjustcontext.lsbrj == lsbrjBreakWithCompJustify) || ((plsc)->lsadjustcontext.lskj == lskjSnapGrid)) ? \
//		fTrue :\
//		(!((plschp)->fCompressOnRun || (plschp)->fCompressSpace || (plschp)->fCompressTable))) 



/* L S D N  F I N I S H   R E G U L A R */
/*----------------------------------------------------------------------------
    %%Function: LsdnFinishRegular
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	lsdcp				-	(IN) dcp adopted
	plsrun				-	(IN) plsrun of dnode		
	plschp				-	(IN) plschp of dnode
	pdobj				-	(IN) pdobj of dnode
	pobjdim				-	(IN) pobjdim of dnode

Finish creating dnode
----------------------------------------------------------------------------*/

LSERR WINAPI LsdnFinishRegular(
							  PLSC  plsc,			
							  LSDCP lsdcp,     		
							  PLSRUN plsrun,   		
							  PCLSCHP plschp,  		
							  PDOBJ pdobj,    		
							  PCOBJDIM pobjdim) 	
{
	
	PLSDNODE plsdn;
	LSERR lserr;
	PLSSUBL plssubl;
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	/* all sublines should be closed */
	if (GetCurrentSubline(plsc) != NULL) return lserrFormattingFunctionDisabled;

	plsdn = GetDnodeToFinish(plsc);
	
	if (plsdn == NULL) return lserrFiniFunctionDisabled;

	plssubl = SublineFromDnode(plsdn);

	plsdn->u.real.pdobj = pdobj;
	/* if handler changed plsrun that we passed to him than we should release previous one */
	/* Attention: we have assumption here that new one has another plsrun     				*/
	if (plsdn->u.real.plsrun != plsrun && !plsc->fDontReleaseRuns)
		{
		lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, plsdn->u.real.plsrun);
		plsdn->u.real.plsrun = plsrun; /* to release it later */
		if (lserr != lserrNone)
			return lserr;
		}

	plsdn->dcp = lsdcp;
	plsdn->cpLimOriginal = plsdn->cpFirst + lsdcp;
	Assert(FIsDnodeReal(plsdn)); /* this is default value */
	Assert(pobjdim->dur >= 0);
	SetDnodeObjdimFmt(plsdn, *pobjdim);

	Assert(IsLschpFlagsValid(plsc, plschp));
	plsdn->u.real.lschp = *plschp;
	/*  Special effects */
	plsc->plslineCur->lslinfo.EffectsFlags |= plschp->EffectsFlags;  
	/* set flags for display */
	if (plschp->dvpPos != 0)
		TurnOnNonZeroDvpPosEncounted(plsc);
	AddToAggregatedDisplayFlags(plsc, plschp);
	if (FApplyNominalToIdeal(plschp))
		TurnOnNominalToIdealEncounted(plsc);



	if (plsdn->u.real.lschp.idObj == idObjTextChp)
		plsdn->u.real.lschp.idObj = (WORD) IobjTextFromLsc(&plsc->lsiobjcontext);


	AssertImplies(plsc->lsdocinf.fPresEqualRef, 
		plsdn->u.real.objdim.heightsPres.dvAscent == plsdn->u.real.objdim.heightsRef.dvAscent);
	AssertImplies(plsc->lsdocinf.fPresEqualRef, 
		plsdn->u.real.objdim.heightsPres.dvDescent == plsdn->u.real.objdim.heightsRef.dvDescent);
	AssertImplies(plsc->lsdocinf.fPresEqualRef, 
		plsdn->u.real.objdim.heightsPres.dvMultiLineHeight 
				== plsdn->u.real.objdim.heightsRef.dvMultiLineHeight);


	/* nobody can change current dnode after plsdn was constructed  */
	Assert(GetCurrentDnodeSubl(plssubl) == plsdn->plsdnPrev);

	*(GetWhereToPutLinkSubl(plssubl, plsdn->plsdnPrev)) = plsdn;
	
	
	SetCurrentDnodeSubl(plssubl, plsdn);
	SetDnodeToFinish(plsc, NULL);	
	
	AdvanceCurrentCpLimSubl(plssubl, lsdcp);
	AdvanceCurrentUrSubl(plssubl, pobjdim->dur);
	return lserrNone;
}

/* L S D N  F I N I S H   R E G U L A R  A D D  A D V A N C E D  P E N */
/*----------------------------------------------------------------------------
    %%Function: LsdnFinishRegularAddAdvancePen
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	lsdcp				-	(IN) dcp adopted
	plsrun				-	(IN) plsrun of dnode		
	plschp				-	(IN) plschp of dnode
	pdobj				-	(IN) pdobj of dnode
	pobjdim				-	(IN) pobjdim of dnode
	durPen				-	(IN) dur of advanced pen 
	dvrPen				-	(IN) dvr of advanced pen 
	dvpPen				-	(IN) dvp of advanced pen 

  Finish creating dnode and add advanced pen after such dnode 
----------------------------------------------------------------------------*/

LSERR WINAPI LsdnFinishRegularAddAdvancePen(
							  PLSC plsc,			/* IN: Pointer to LS Context */
							  LSDCP lsdcp,     		/* IN: dcp adopted           */
							  PLSRUN plsrun,   		/* IN: PLSRUN  		         */
							  PCLSCHP plschp,  		/* IN: CHP          	     */
							  PDOBJ pdobj,    		/* IN: PDOBJ             	 */ 
							  PCOBJDIM pobjdim,		/* IN: OBJDIM      		     */
							  long durPen,			/* IN: durPen				 */
							  long dvrPen,			/* IN: dvrPen				 */
							  long dvpPen)			/* IN: dvpPen 				 */
	{
	LSERR lserr;
	PLSDNODE plsdnPrev;
	PLSDNODE plsdnPen;
	PLSSUBL plssubl;

	/* we don't have checks of parameters here because they are in LsdnFinishRegular */

	plsdnPrev = GetDnodeToFinish(plsc);	/* we should store it before calling LsdnFinishRegular */
	plssubl = SublineFromDnode(plsdnPrev);
		
	lserr = LsdnFinishRegular(plsc, lsdcp, plsrun, plschp, pdobj, pobjdim);
	if (lserr != lserrNone)
		return lserr;

	/* create and fill in pen dnode */
	plsdnPen = PvNewQuick(GetPqhAllDNodes(plsc), sizeof *plsdnPen);
	if (plsdnPen == NULL)
		return lserrOutOfMemory;
	plsdnPen->tag = tagLSDNODE;
	plsdnPen->cpFirst = GetCurrentCpLimSubl(plssubl);
	plsdnPen->cpLimOriginal = plsdnPen->cpFirst;
	plsdnPen->plsdnPrev = plsdnPrev;
	plsdnPen->plsdnNext = NULL;
	plsdnPen->plssubl = plssubl;
	plsdnPen->dcp = 0;
	/* flush all flags, bellow check that result is what  we expect */ \
	*((DWORD *) ((&(plsdnPen)->dcp)+1)) = 0;\
	Assert((plsdnPen)->fRigidDup == fFalse);\
	Assert((plsdnPen)->fTab == fFalse);\
	Assert((plsdnPen)->icaltbd == 0);\
	Assert((plsdnPen)->fBorderNode == fFalse);\
	Assert((plsdnPen)->fOpenBorder == fFalse);\
	Assert((plsdnPen)->fEndOfSection == fFalse); \
	Assert((plsdnPen)->fEndOfColumn == fFalse); \
	Assert((plsdnPen)->fEndOfPage == fFalse); \
	Assert((plsdnPen)->fEndOfPara == fFalse); \
	Assert((plsdnPen)->fAltEndOfPara == fFalse); \
	Assert((plsdnPen)->fSoftCR == fFalse); \
	Assert((plsdnPen)->fInsideBorder == fFalse); \
	Assert((plsdnPen)->fAutoDecTab == fFalse); \
	Assert((plsdnPen)->fTabForAutonumber == fFalse);
	plsdnPen->klsdn = klsdnPenBorder;
	plsdnPen->fAdvancedPen = fTrue;
	SetPenBorderDurFmt(plsdnPen, durPen);
	plsdnPen->u.pen.dvr = dvrPen;
	plsdnPen->u.pen.dvp = dvpPen;
	
	/* maintain list */
	plsdnPrev->plsdnNext = plsdnPen;
	SetCurrentDnodeSubl(plssubl, plsdnPen);
	AdvanceCurrentUrSubl(plssubl, durPen);
	AdvanceCurrentVrSubl(plssubl, dvrPen);

	if (durPen < 0)
		plsc->fAdvanceBack = fTrue;

	TurnOnNonRealDnodeEncounted(plsc);
		
	return lserrNone;
	}

/* L S D N  F I N I S H   D E L E T E */
/*----------------------------------------------------------------------------
    %%Function: LsdnFinishDelete
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	lsdcp				-	(IN) dcp adopted

Delete dnode due to the will of formater
----------------------------------------------------------------------------*/


LSERR WINAPI LsdnFinishDelete(
							  PLSC plsc,				/* IN: Pointer to LS Context */
					  		  LSDCP lsdcp)		/* IN: dcp to add			 */
	{
	PLSDNODE plsdn;
	PLSSUBL plssubl;
	LSERR lserr;
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	/* all sublines should be closed */
	if (GetCurrentSubline(plsc) != NULL) return lserrFormattingFunctionDisabled;

	plsdn = GetDnodeToFinish(plsc);
	
	if (plsdn == NULL) return lserrFiniFunctionDisabled;

	plssubl = SublineFromDnode(plsdn);

	/* nobody can change current dnode after plsdn was constructed  */
	Assert(GetCurrentDnodeSubl(plssubl) == plsdn->plsdnPrev);

	Assert(plsdn->plsdnNext == NULL);
	lserr = DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext,
					  plsdn, plsc->fDontReleaseRuns);
	if (lserr != lserrNone)
		return lserr;

	SetDnodeToFinish(plsc, NULL);	
	
	AdvanceCurrentCpLimSubl(plssubl, lsdcp);

	return lserrNone;
	}


/* L S D N  F I N I S H  P E N  */
/*----------------------------------------------------------------------------
    %%Function: LsdnFinishSimpleRegular
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	lsdcp				-	(IN) dcp adopted
	plsrun				-	(IN) plsrun of dnode		
	plschp				-	(IN) plschp of dnode
	dur, dvr, dvp		-   (IN) variables to put in pen dnode 

Finish dnode as a pen
----------------------------------------------------------------------------*/

LSERR WINAPI LsdnFinishByPen(PLSC plsc,				/* IN: Pointer to LS Context */
						   LSDCP lsdcp, 	   		/* IN: dcp	adopted          */
						   PLSRUN plsrun,	   		/* IN: PLSRUN  		         */
						   PDOBJ pdobj,	    		/* IN: PDOBJ             	 */ 
						   long durPen,    			/* IN: dur         		     */
						   long dvrPen,     		/* IN: dvr             		 */
						   long dvpPen)   			/* IN: dvp          	     */
	{
	PLSDNODE plsdn;
	LSERR lserr;
	PLSSUBL plssubl;
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	/* all sublines should be closed */
	if (GetCurrentSubline(plsc) != NULL) return lserrFormattingFunctionDisabled;

	plsdn = GetDnodeToFinish(plsc);
	
	if (plsdn == NULL) return lserrFiniFunctionDisabled;

	plssubl = SublineFromDnode(plsdn);

	if (plsrun != NULL && !plsc->fDontReleaseRuns)
		{
		lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, plsrun);
		if (lserr != lserrNone)	return lserr;
		}

	/* caller pass pdobj to us only to destroy it*/
	if (pdobj != NULL)
		{
		Assert(plsdn->u.real.lschp.idObj != idObjTextChp);
		lserr = (PLsimFromLsc(&plsc->lsiobjcontext, 
			plsdn->u.real.lschp.idObj))->pfnDestroyDObj (pdobj);
		if (lserr != lserrNone)	return lserr;
		}


	
	plsdn->dcp = lsdcp;
	plsdn->cpLimOriginal = plsdn->cpFirst + lsdcp;
	plsdn->klsdn = klsdnPenBorder;
	plsdn->fBorderNode = fFalse;
	SetPenBorderDurFmt(plsdn, durPen);
	plsdn->u.pen.dvr = dvrPen;
	plsdn->u.pen.dvp = dvpPen;

	/* nobody can change current dnode after plsdn was constructed  */
	Assert(GetCurrentDnodeSubl(plssubl) == plsdn->plsdnPrev);

	*(GetWhereToPutLinkSubl(plssubl, plsdn->plsdnPrev)) = plsdn;
	
	
	SetCurrentDnodeSubl(plssubl, plsdn);
	SetDnodeToFinish(plsc, NULL);	
	
	AdvanceCurrentCpLimSubl(plssubl, lsdcp);
	AdvanceCurrentUrSubl(plssubl, durPen);
	AdvanceCurrentVrSubl(plssubl, dvrPen);

	TurnOnNonRealDnodeEncounted(plsc);

	return lserrNone;
	}


/* L S D N  F I N I S H  B Y  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsdnFinishBySubline
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	lsdcp				-	(IN) increase cp by this number before hanldler ends
	plssubl				-	(IN) subline to substitute dnode to finish

Delete dnode and include child list in the upper level
----------------------------------------------------------------------------*/

LSERR WINAPI LsdnFinishBySubline(PLSC plsc,			/* IN: Pointer to LS Context */
							  	LSDCP lsdcp,     		/* IN: dcp adopted           */
								PLSSUBL plssubl)		/* IN: Subline context		 */
	{
	PLSDNODE plsdnParent;
	PLSDNODE plsdnChildFirst;
	PLSDNODE plsdnChildCurrent, plsdnChildPrevious;
	PLSSUBL plssublParent;
	LSERR lserr;

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	/* all sublines should be closed */
	if (GetCurrentSubline(plsc) != NULL) return lserrFormattingFunctionDisabled;

	plsdnParent = GetDnodeToFinish(plsc);
	
	if (plsdnParent == NULL) return lserrFiniFunctionDisabled;

	plssublParent = SublineFromDnode(plsdnParent);

	
	AdvanceCurrentCpLimSubl(plssublParent, lsdcp);

	plsdnChildFirst = plssubl->plsdnFirst;

	/* go through child list change subline and calculate resulting pen movement  */
	plsdnChildCurrent = plsdnChildFirst;
	plsdnChildPrevious = NULL;
	while (plsdnChildPrevious != plssubl->plsdnLast)
		{
		plsdnChildCurrent->plssubl = plssublParent;
		AdvanceCurrentUrSubl(plssublParent, DurFromDnode(plsdnChildCurrent));
		AdvanceCurrentVrSubl(plssublParent, DvrFromDnode(plsdnChildCurrent));
		plsdnChildPrevious = plsdnChildCurrent;
		plsdnChildCurrent = plsdnChildCurrent->plsdnNext;
		} 
	

	/* include subline's list to upper level */
	*(GetWhereToPutLinkSubl(plssublParent, plsdnParent->plsdnPrev)) = plsdnChildFirst;
	if (plsdnChildFirst != NULL && plsdnParent->plsdnPrev != NULL) 
		plsdnChildFirst->plsdnPrev = plsdnParent->plsdnPrev;

	/* if subline's list is empty than dnode before parent should be made current */
	if (plsdnChildFirst == NULL)
		{
		/* if subline's list is empty than dnode before parent should be made current */
		SetCurrentDnodeSubl(plssublParent, plsdnParent->plsdnPrev);
		}
	else
		{
		/* else last dnode in subline is now current dnode */
		SetCurrentDnodeSubl(plssublParent, plssubl->plsdnLast);
		}

	/* delete parent dnode */
	lserr = DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext,
					  plsdnParent, plsc->fDontReleaseRuns);
	if (lserr != lserrNone)
		return lserr;

	/* set first dnode of subline to NULL and destroy subline will not erase dnodes that has 
	been promoted to the upper level */
	plssubl->plsdnFirst = NULL;

	lserr = DestroySublineCore(plssubl,&plsc->lscbk, plsc->pols,
			&plsc->lsiobjcontext, plsc->fDontReleaseRuns);
	if (lserr != lserrNone)
		return lserr;

	SetDnodeToFinish(plsc, NULL);	
	
	return lserrNone;
	}

/* L S D N  F I N I S H  D E L E T E  A L L*/
/*----------------------------------------------------------------------------
    %%Function: LsdnFinishDeleteAll
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	dcpToAdvance		-	(IN) increase cp by this number before hanldler ends

Delete parent dnode and include child list in the upper level
----------------------------------------------------------------------------*/


LSERR WINAPI LsdnFinishDeleteAll(PLSC plsc,			/* IN: Pointer to LS Context */
					  			LSDCP lsdcp)			/* IN: dcp adopted			 */
	{
	PLSDNODE plsdnParent;
	PLSDNODE plsdnFirstOnLine;
	PLSDNODE plsdnFirstInContents;
	PLSDNODE plsdnLastBeforeContents;
	LSERR lserr;
	long dvpPen;
	long durPen;
	long dvrPen;
	PLSSUBL plssublMain;

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	/* all sublines should be closed */
	if (GetCurrentSubline(plsc) != NULL) return lserrFormattingFunctionDisabled;

	plsdnParent = GetDnodeToFinish(plsc);
	
	if (plsdnParent == NULL) return lserrFiniFunctionDisabled;

	plssublMain = &plsc->plslineCur->lssubl;

	
	AdvanceCurrentCpLimSubl(plssublMain, lsdcp);
	
	plsdnFirstOnLine = plssublMain->plsdnFirst;

	plsdnFirstInContents = plsdnFirstOnLine;
	plsdnLastBeforeContents = NULL;
	while (plsdnFirstInContents != NULL && FIsNotInContent(plsdnFirstInContents))
		{
		plsdnLastBeforeContents = plsdnFirstInContents;
		plsdnFirstInContents = plsdnFirstInContents->plsdnNext;
		}

	/* restore state as it was before starting formatting content*/
	plsc->lstabscontext.plsdnPendingTab = NULL;
	plsc->plslineCur->lslinfo.fAdvanced = 0;
	plsc->plslineCur->lslinfo.EffectsFlags = 0;

	/* break link with contest*/
	if (plsdnFirstInContents != NULL)
		*(GetWhereToPutLinkSubl(plssublMain, plsdnFirstInContents->plsdnPrev)) = NULL;
	/* set dnode to append */
	SetCurrentDnodeSubl(plssublMain, plsdnLastBeforeContents);
	/* set current subline */
	SetCurrentSubline(plsc, plssublMain);

	/* recalculate current position */
	if (plsdnFirstInContents != NULL)
		{
		FindListFinalPenMovement(plsdnFirstInContents, plssublMain->plsdnLast,
							 &durPen, &dvrPen, &dvpPen);
		AdvanceCurrentUrSubl(plssublMain, -durPen);
		AdvanceCurrentVrSubl(plssublMain, -dvrPen);

		}

	/* delete content before this parent dnode */
	if (plsdnFirstInContents != NULL)
		{
		lserr = DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext,
					  plsdnFirstInContents, plsc->fDontReleaseRuns);
		if (lserr != lserrNone)
			return lserr;
		}

	/* delete parent dnode and child list*/
	lserr = DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext,
					  plsdnParent, plsc->fDontReleaseRuns);
	if (lserr != lserrNone)
		return lserr;

	SetDnodeToFinish(plsc, NULL);	

	return lserrNone;
	}

LSERR WINAPI LsdnFinishByOneChar(				/* allows replacement by simple DNODE only */
							  PLSC plsc,				/* IN: Pointer to LS Context */
							  long urColumnMax,				/* IN: urColumnMax			 */
							  WCHAR ch,			/* IN: character to replace	 */
							  PCLSCHP plschp,			/* IN: lschp for character   */
							  PLSRUN plsrun,			/* IN: plsrun for character  */
							  FMTRES* pfmtres)		/* OUT:Result of the Repl formatter*/
	{	
	LSERR lserr;
	LSFRUN lsfrun;	
	PLSDNODE plsdn;
	PLSSUBL plssubl;
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	/* all sublines should be closed */
	if (GetCurrentSubline(plsc) != NULL) return lserrFormattingFunctionDisabled;

	plsdn = GetDnodeToFinish(plsc);
	
	if (plsdn == NULL) return lserrFiniFunctionDisabled;

	plssubl = SublineFromDnode(plsdn);

	/* nobody can change current dnode after plsdn was constructed  */
	Assert(GetCurrentDnodeSubl(plssubl) == plsdn->plsdnPrev);

	if (plsdn->dcp != 1) return lserrWrongFiniFunction;


	lserr = LsdnFinishDelete(plsc, 0);
	if (lserr != lserrNone)
		return lserr;

	Assert(IsLschpFlagsValid(plsc, plschp));
	lsfrun.plschp = plschp;
	/*  Special effects */
	plsc->plslineCur->lslinfo.EffectsFlags |= plschp->EffectsFlags;   
	lsfrun.plsrun = plsrun;
	lsfrun.lpwchRun = &ch;
	lsfrun.cwchRun = 1;

	/* to ProcessOneRun work properly we need to temporarely restore current subline */
	SetCurrentSubline(plsc, plssubl);
	lserr = ProcessOneRun(plsc, urColumnMax, &lsfrun, NULL, 0, pfmtres);
	if (lserr != lserrNone)
		return lserr;

	SetCurrentSubline(plsc, NULL);

	return lserrNone;

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lsdsply.c ===
#include "lsdsply.h"
#include "lsc.h"
#include "lsline.h"
#include "lssubl.h"
#include "heights.h"
#include "lstflow.h"
#include "lssubset.h"
#include "lstfset.h"
#include "port.h"
#include "prepdisp.h"
#include "dispmain.h"

static LSERR LSDrawBreaks(PLSC, PLSLINE, const POINT*, UINT, const RECT*);


#define grpfQuickDisplayMask   (fPortDisplayInvisible 	| \
								fPortDisplayUnderline 	| \
								fPortDisplayStrike 		| \
								fPortDisplayShade 		| \
								fPortDisplayBorder 		  \
								)


//    %%Function:	LsDisplayLine
//    %%Contact:	victork
//
/*
 * Displays formatted line (main subline) from the given point.
 * Assumes background has been properly erased.
 */
	
LSERR WINAPI LsDisplayLine(PLSLINE plsline, const POINT* pptOrg, UINT kdispmode, const RECT *prectClip)
{

	PLSC		plsc;
	LSERR 		lserr;

	PLSSUBL		plssubl;
	LSCP		cpLim;
	LSTFLOW		lstflow;
	
	POINTUV		pt;
	PLSDNODE	pdn;

	PDOBJ 		pdobj;
	DISPIN 		dispin;

	if (!FIsLSLINE(plsline)) return lserrInvalidParameter;

	plsc = plsline->lssubl.plsc;
	Assert(FIsLSC(plsc));

	if (plsc->lsstate != LsStateFree) return lserrContextInUse;

	lserr = PrepareLineForDisplayProc(plsline);

	plsc->lsstate = LsStateFree;
	
	if (lserr != lserrNone) return lserr;

	plsc->lsstate = LsStateDisplaying;

	Assert(plsline->lslinfo.dvpDescent >= 0);
	Assert(plsline->lslinfo.dvpAscent >= 0);
	Assert(plsline->upStartAutonumberingText <= plsline->upLimAutonumberingText);
	Assert(plsline->upLimAutonumberingText <= plsline->upStartMainText);
	// Assert(plsline->upStartMainText <= plsline->upLimUnderline) wrong - negative advance pen
	Assert(plsline->upLimUnderline <= plsline->upLimLine);

	plssubl = &(plsline->lssubl);

	plsc->plslineDisplay = plsline;				// set up display context

	if (plsline->lssubl.plsdnLastDisplay == NULL)
		{
		// do nothing - happens with only splat on the line
		}
	

	else // Do it quick way or call general procedure
	
	if (!plsline->fNonZeroDvpPosEncounted 					&&
			!plsline->fNonRealDnodeEncounted				&&
			((plsline->AggregatedDisplayFlags == 0) || 
			((plsline->AggregatedDisplayFlags & grpfQuickDisplayMask) == 0)
			)
		   )
		
		{

		cpLim = plssubl->cpLimDisplay;
		lstflow = plssubl->lstflow;
		
		dispin.dupLimUnderline = 0;
		dispin.fDrawUnderline = fFalse;
		dispin.fDrawStrikethrough = fFalse;
	
		dispin.kDispMode = kdispmode;
		dispin.lstflow = lstflow;								
		dispin.prcClip = (RECT*) prectClip;
		
		pt.u = plsline->upStartAutonumberingText;						
		pt.v = 0;
		pdn = plssubl->plsdnFirst;

		// can use the loop condition instead of FDnodeBeforeCpLim macro - no borders
		
		for (;;)
			{

			Assert(pdn->klsdn == klsdnReal);

			pdobj = pdn->u.real.pdobj;
			dispin.plschp = &(pdn->u.real.lschp);
			dispin.plsrun = pdn->u.real.plsrun;
			dispin.heightsPres = pdn->u.real.objdim.heightsPres;
			dispin.dup = pdn->u.real.dup;
			
			LsPointXYFromPointUV(pptOrg, lstflow, &pt, &(dispin.ptPen));
			
			lserr = (*plsc->lsiobjcontext.rgobj[pdn->u.real.lschp.idObj].lsim.pfnDisplay)
													(pdobj, &dispin);

			if (pdn == plsline->lssubl.plsdnLastDisplay || lserr != lserrNone)
				{
				break;
				}
			
			pt.u += pdn->u.real.dup;										
			pdn = pdn->plsdnNext;

			}

		}
	else
		{
		lserr = DisplaySublineCore(plssubl, pptOrg, kdispmode, prectClip,
									plsline->upLimUnderline,
									plsline->upStartAutonumberingText);
		}

	if (lserr == lserrNone && plsline->kspl != ksplNone)
		{
		lserr = LSDrawBreaks(plsc, plsline, pptOrg,	kdispmode, prectClip);
		}

	plsc->plslineDisplay = NULL;				// invalidate display context
	plsc->lsstate = LsStateFree;
	return lserr;
}

//    %%Function:	LSDrawBreaks
//    %%Contact:	victork
//
static LSERR LSDrawBreaks(PLSC plsc, PLSLINE plsline, const POINT* pptOrg, UINT kdispmode, const RECT* prectClip)
{

	LSERR 	lserr;
	POINTUV 		ptUV;
	POINT 			pt;
	long 			dup;
	enum lsksplat 	lsks;

	LSTFLOW	lstflow = plsline->lssubl.lstflow;
	
	HEIGHTS	heightsLineFull;
	HEIGHTS	heightsLineWithoutAddedSpace;
	OBJDIM	objdimSubline;

	heightsLineFull.dvAscent = plsline->dvpAbove + plsline->lslinfo.dvpAscent;
	heightsLineFull.dvDescent = plsline->dvpBelow + plsline->lslinfo.dvpDescent;
	heightsLineFull.dvMultiLineHeight = dvHeightIgnore;
	
	heightsLineWithoutAddedSpace.dvAscent = plsline->lslinfo.dvpAscent;
	heightsLineWithoutAddedSpace.dvDescent = plsline->lslinfo.dvpDescent;
	heightsLineWithoutAddedSpace.dvMultiLineHeight = dvHeightIgnore;
	
	lserr = LssbGetObjDimSubline(&(plsline->lssubl), &lstflow, &objdimSubline);
	
	if (lserr == lserrNone)
		{
		ptUV.u = plsline->upLimLine;
		ptUV.v = 0;

		dup = plsline->upRightMarginJustify - plsline->upLimLine;

		if (plsline->kspl == ksplPageBreak)
			lsks = lsksplPageBreak;
		else if (plsline->kspl == ksplColumnBreak)
			lsks = lsksplColumnBreak;
		else
			lsks = lsksplSectionBreak;

		LsPointXYFromPointUV(pptOrg, lstflow, &ptUV, &pt);
		
		return (*plsc->lscbk.pfnDrawSplatLine) (plsc->pols, lsks, plsline->lslinfo.cpLim - 1, &pt,
												&(heightsLineFull), &(heightsLineWithoutAddedSpace),
												&(objdimSubline.heightsPres),
												dup, lstflow, kdispmode, prectClip);
		}

	return lserr;
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lsdntext.c ===
/* LSDNTEXT.C								*/
#include "lsdntext.h"
#include "lsidefs.h"
#include "lsc.h"
#include "lsdnode.h"
#include "iobj.h"
#include "dninfo.h"
#include "getfmtst.h"
#include "setfmtst.h"
#include "chnutils.h"
#include "dnutils.h"
#include "break.h"

static LSERR ResetDcpCore(PLSC plsc, PLSDNODE plsdn, LSCP cpFirstNew,
						  LSDCP dcpNew, BOOL fMerge);	


/* L S D N  S E T  T E X T  D U P*/
/*----------------------------------------------------------------------------
    %%Function: LsdnSetTextDup
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Pointer to the dnode
	dup					-	(IN) dup to be set

Set dup in dnode  
----------------------------------------------------------------------------*/
LSERR LsdnSetTextDup(PLSC plsc,	PLSDNODE plsdn, long dup)
{
	Unreferenced(plsc);  /* to avoid warning in shiping version */
	
	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));
	Assert(FIsDnodeReal(plsdn));
	Assert(IobjTextFromLsc(&plsc->lsiobjcontext) == IdObjFromDnode(plsdn));
	Assert(dup >= 0);

	plsdn->u.real.dup = dup;
   	return lserrNone;		

}


/* L S D N  M O D I F Y  T E X T  D U P*/
/*----------------------------------------------------------------------------
    %%Function: LsdnModifyTextDup
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Pointer to the dnode
	ddup				-	(IN) ddup 

modify dup in dnode  
----------------------------------------------------------------------------*/
LSERR LsdnModifyTextDup(PLSC plsc,	PLSDNODE plsdn, long ddup)
{
	Unreferenced(plsc);  /* to avoid warning in shiping version */

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));
	Assert(FIsDnodeReal(plsdn));
	Assert(IobjTextFromLsc(&plsc->lsiobjcontext) == IdObjFromDnode(plsdn));

	plsdn->u.real.dup += ddup;
	Assert(plsdn->u.real.dup >= 0);

   	return lserrNone;		

}

/* L S D N  G E T  O B J  D I M */
/*----------------------------------------------------------------------------
    %%Function: LsdnGetObjDim
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Pointer to the dnode
	pobjdim				-	(OUT) dimensions of DNODE

return objdim of dnode 
----------------------------------------------------------------------------*/
LSERR LsdnGetObjDim(PLSC plsc, PLSDNODE plsdn, POBJDIM pobjdim )		
{
	Unreferenced(plsc);  /* to avoid warning in shiping version */

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));
	Assert(FIsDnodeReal(plsdn));
	Assert(IobjTextFromLsc(&plsc->lsiobjcontext) == IdObjFromDnode(plsdn));

	*pobjdim = plsdn->u.real.objdim;
   	return lserrNone;		

}

/* L S D N  G E T  C P  F I R S T*/
/*----------------------------------------------------------------------------
    %%Function: LsdnGetObjDim
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Pointer to the dnode
	pcpFirst			-	(OUT) cpFirst of this DNODE

return cpFirst of dnode
----------------------------------------------------------------------------*/
LSERR LsdnGetCpFirst(PLSC plsc, PLSDNODE plsdn, LSCP* pcpFirst )		
{
	Unreferenced(plsc);  /* to avoid warning in shiping version */

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));
	Assert(FIsDnodeReal(plsdn));
	Assert(IobjTextFromLsc(&plsc->lsiobjcontext) == IdObjFromDnode(plsdn));

	*pcpFirst = plsdn->cpFirst;
   	return lserrNone;		

}

/* L S D N  G E T  P L S R U N*/
/*----------------------------------------------------------------------------
    %%Function: LsdnGetPlsrun
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Pointer to the dnode
	pplsrun				-	(OUT) plsrun of this DNODE

return cpFirst of dnode
----------------------------------------------------------------------------*/
LSERR LsdnGetPlsrun(PLSC plsc, PLSDNODE plsdn, PLSRUN* pplsrun )		
{
	Unreferenced(plsc);  /* to avoid warning in shiping version */

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));
	Assert(FIsDnodeReal(plsdn));
	Assert(IobjTextFromLsc(&plsc->lsiobjcontext) == IdObjFromDnode(plsdn));

	*pplsrun = plsdn->u.real.plsrun;
   	return lserrNone;		

}




/* L S D N  M O D I F Y  S I M P L E  W I D T H*/
/*----------------------------------------------------------------------------
    %%Function: LsdnModifySimpleWidth
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Pointer to the dnode
	ddur			-		(IN) ddur

modify dur in dnode  
----------------------------------------------------------------------------*/
LSERR LsdnModifySimpleWidth(PLSC plsc,	PLSDNODE plsdn, long ddur)
{

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));

	Unreferenced(plsc);
	
	if (ddur != 0)
		{
		if (plsdn->klsdn == klsdnReal)
			{
			ModifyDnodeDurFmt(plsdn, ddur);
			Assert(plsdn->u.real.objdim.dur >= 0);
			}
		else /* pen */
			{
			ModifyPenBorderDurFmt(plsdn, ddur);
			}
		AdvanceCurrentUrSubl(plsdn->plssubl, ddur);
		/* after such changes in dnode location of chunk should be recalculatted */
		InvalidateChunkLocation(PlschunkcontextFromSubline(plsdn->plssubl));

		}
   	return lserrNone;		

}

/* L S D N  S E T  S I M P L E  W I D T H*/
/*----------------------------------------------------------------------------
    %%Function: LsdnSetySimpleWidth
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Pointer to the dnode
	dur			-			(IN) new dur

modify dur in dnode  
----------------------------------------------------------------------------*/
LSERR LsdnSetSimpleWidth(PLSC plsc,	PLSDNODE plsdn, long dur)
	{
	long ddur;
	
	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));
	Assert(dur >= 0);
	
	Unreferenced(plsc);
	
	
	if (plsdn->klsdn == klsdnReal)
		{
		ddur = dur - plsdn->u.real.objdim.dur;
		SetDnodeDurFmt(plsdn, dur);
		}
	else /* pen */
		{
		ddur = dur - plsdn->u.pen.dur;
		SetPenBorderDurFmt(plsdn, dur);
		}
	
	AdvanceCurrentUrSubl(plsdn->plssubl, ddur);
	/* after such changes in dnode location of chunk should be recalculatted */
	InvalidateChunkLocation(PlschunkcontextFromSubline(plsdn->plssubl));
   	return lserrNone;		
	
	}

/* L S D N  F  I N  C H I L D  L I S T*/
/*----------------------------------------------------------------------------
    %%Function: LsdnFInChildList
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Pointer to the dnode
	pfInChildList		-	(OUT) is this in a low level subline

Used for switching off hyphenation in child list
----------------------------------------------------------------------------*/

LSERR LsdnFInChildList(PLSC plsc, PLSDNODE plsdn, BOOL* pfInChildList)  
	{
	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));
	Unreferenced(plsc);    /* to avoid warning in shiping version */

	*pfInChildList = ! (FIsSubLineMain(SublineFromDnode(plsdn)));

	return lserrNone;
	}

/* L S D N  S E T  H Y P H E N A T E D*/
/*----------------------------------------------------------------------------
    %%Function: LsdnSetHyphenated
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 

Set thet current line has been hyphenated
----------------------------------------------------------------------------*/
LSERR LsdnSetHyphenated(PLSC plsc)		
	{

	Assert(FIsLSC(plsc));

	plsc->fHyphenated = fTrue;

	return lserrNone;
	}

/* L S D N  R E S E T  W I T H  I N  P R E V I O U S  D N O D E S*/
/*----------------------------------------------------------------------------
    %%Function: LsdnResetWidthInPreviousDnodes
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) dnode
	durChangePrev		-	(IN) durChangePrev (don't change if 0)
	durChangePrevPrev	-	(IN) durChangePrevPrev (don't change if 0) 

  Used at SetBreak time for hyphen/nonreqhyphen cases
----------------------------------------------------------------------------*/
LSERR LsdnResetWidthInPreviousDnodes(PLSC plsc,	PLSDNODE plsdn,	
					 long durChangePrev, long durChangePrevPrev)  
	{

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));
	Assert(FBreakingAllowed(plsc)); /* this procedure are called only in breaking time */
	Assert(FIsDnodeReal(plsdn));
	Assert(IdObjFromDnode(plsdn) == IobjTextFromLsc(&plsc->lsiobjcontext)); /* only text can do this */

	Unreferenced(plsc);    /* to avoid warning in shiping version */

	/* change dnode  */
	ModifyDnodeDurFmt(plsdn, -(durChangePrev + durChangePrevPrev));
	
	/* change previous dnode */
	if (durChangePrev != 0)
		{
		Assert(plsdn->plsdnPrev != NULL);
		Assert(FIsDnodeReal(plsdn->plsdnPrev));
		 /* only with text we can do this */
		Assert(IdObjFromDnode(plsdn->plsdnPrev) == IobjTextFromLsc(&plsc->lsiobjcontext));

		ModifyDnodeDurFmt(plsdn->plsdnPrev, durChangePrev);
		}

	/* change dnode before previous  */
	if (durChangePrevPrev != 0)
		{
		Assert(plsdn->plsdnPrev != NULL);
		Assert(plsdn->plsdnPrev->plsdnPrev != NULL);
		Assert(FIsDnodeReal(plsdn->plsdnPrev->plsdnPrev));
		 /* only with text we can do this */
		Assert(IdObjFromDnode(plsdn->plsdnPrev->plsdnPrev) == IobjTextFromLsc(&plsc->lsiobjcontext));

		ModifyDnodeDurFmt(plsdn->plsdnPrev->plsdnPrev, durChangePrevPrev);
		}

	/* this procedure doesn't change resulting pen position */

	/* after such changes in dnode location of chunk should be recalculatted */
	InvalidateChunkLocation(PlschunkcontextFromSubline(plsdn->plssubl));

	return lserrNone;
	}

/* L S D N  G E T  U R  P E N  A T  B E G I N N I N G  O F  C H U N K*/
/*----------------------------------------------------------------------------
    %%Function: LsdnGetUrPenAtBeginningOfChunk
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) first dnode in chunk
	purPen				-	(OUT) position of the begining of the chunk
	purColumnMax		-	(OUT) width of column

  Used by SnapGrid
----------------------------------------------------------------------------*/
LSERR LsdnGetUrPenAtBeginningOfChunk(PLSC plsc,	PLSDNODE plsdn,	
					 long* purPen, long* purColumnMax)   	
	{
	PLSSUBL plssubl = SublineFromDnode(plsdn);
	POINTUV point;

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));

	*purColumnMax = plsc->lsgridcontext.urColumn;
	GetCurrentPointSubl(plssubl, point);

	return GetUrPenAtBeginingOfLastChunk(plssubl->plschunkcontext, plsdn, 
			GetCurrentDnodeSubl(plssubl), &point, purPen);

			
	}


/* L S D N  R E S E T  D C P  M E R G E*/
/*----------------------------------------------------------------------------
    %%Function: LsdnResetDcpMerge
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) dnode 
	cpFirstNew			-	(IN) new cpFirst to put in the dnode
	dcpNew				-	(IN) new dcp to put in the dnode

  Reset amount of characters in the dnode due to shaping glyph together
----------------------------------------------------------------------------*/
LSERR LsdnResetDcpMerge(PLSC plsc, PLSDNODE plsdn, LSCP cpFirstNew, LSDCP dcpNew)
	{
	return ResetDcpCore(plsc, plsdn, cpFirstNew, dcpNew, fTrue);
	}

/* L S D N  R E S E T  D C P  */
/*----------------------------------------------------------------------------
    %%Function: LsdnResetDcp
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) dnode 
	dcpNew				-	(IN) new dcp to put in the dnode

  Cut amount of characters in the dnode.
----------------------------------------------------------------------------*/
LSERR LsdnResetDcp(PLSC plsc, PLSDNODE plsdn, LSDCP dcpNew)
	{
	return ResetDcpCore(plsc, plsdn, plsdn->cpFirst, dcpNew, fFalse);
	}

/*  R E S E T  D C P  C O R E*/
/*----------------------------------------------------------------------------
    %%Function: ResetDcpCore
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) dnode 
	cpFirstNew			-	(IN) new cpFirst to put in the dnode
	dcpNew				-	(IN) new dcp to put in the dnode
	fMerge				-	(IN) characters from the next dnode moves to previous

  Internal procedure which implements both LsdnResetDcpMerge and LsdnResetDcp
----------------------------------------------------------------------------*/
static LSERR ResetDcpCore(PLSC plsc, PLSDNODE plsdn, LSCP cpFirstNew,
						  LSDCP dcpNew, BOOL fMerge)	
	{
	LSERR lserr;
	PLSDNODE plsdnPrev;
	PLSDNODE plsdnNext;
	PLSDNODE plsdnPrevNonBorder;
	PLSDNODE plsdnFirstDelete;
	PLSDNODE plsdnLastDelete;
	PLSDNODE plsdnBorder;

	Assert(FIsLSDNODE(plsdn));
	Assert(FIsDnodeReal(plsdn));

	/* if everything stays the same return right away */
	if ((cpFirstNew == plsdn->cpFirst) && (dcpNew == plsdn->dcp))
		   	return lserrNone;	

	/* after such changes in dnodes chunk should be recollected */
	InvalidateChunk(PlschunkcontextFromSubline(plsdn->plssubl));
	
	lserr = plsc->lscbk.pfnResetRunContents(plsc->pols, plsdn->u.real.plsrun, plsdn->cpFirst,
		plsdn->dcp, cpFirstNew, dcpNew);
	if (lserr != lserrNone)
		return lserr;

	plsdn->cpFirst = cpFirstNew;
	plsdn->dcp = dcpNew;

	if (plsdn->cpFirst + (LSCP) plsdn->dcp > plsdn->cpLimOriginal)
		plsdn->cpLimOriginal = plsdn->cpFirst + plsdn->dcp;

	if (dcpNew == 0)  /* delete this dnode */
		{
		/* check that objdim has been zeroed */
		Assert(DurFromDnode(plsdn) == 0);
		Assert(DvrFromDnode(plsdn) == 0);

		plsdnPrev = plsdn->plsdnPrev;
		plsdnNext = plsdn->plsdnNext;

		if (fMerge)
			{
			plsdnPrevNonBorder = plsdnPrev;
			Assert(FIsLSDNODE(plsdnPrevNonBorder));
			while(FIsDnodeBorder(plsdnPrevNonBorder))
				{
				plsdnPrevNonBorder = plsdnPrevNonBorder->plsdnPrev;
				Assert(FIsLSDNODE(plsdnPrevNonBorder));
				}
			
			/* set cpLimOriginal  */
			plsdnPrevNonBorder->cpLimOriginal = plsdn->cpLimOriginal;
			plsdnBorder = plsdnPrevNonBorder->plsdnNext;
			while(FIsDnodeBorder(plsdnBorder))
				{
				plsdnBorder->cpFirst = plsdn->cpLimOriginal;
				plsdnBorder->cpLimOriginal = plsdn->cpLimOriginal;
				plsdnBorder = plsdnBorder->plsdnNext;
				Assert(FIsLSDNODE(plsdnBorder));
				}
			Assert(plsdnBorder == plsdn);
			}

		if ((plsdnPrev != NULL && FIsDnodeOpenBorder(plsdnPrev))
			&& (plsdnNext == NULL 
			    || (FIsDnodeBorder(plsdnNext) &&  !FIsDnodeOpenBorder(plsdnNext))
			   )
			)
			/* we should delete  empty borders */
			{
			plsdnFirstDelete = plsdnPrev;
			if (plsdnNext != NULL)
				{
				plsdnLastDelete = plsdnNext;
				AdvanceCurrentUrSubl(SublineFromDnode(plsdnFirstDelete),
					  -DurFromDnode(plsdnFirstDelete));
				AdvanceCurrentUrSubl(SublineFromDnode(plsdnLastDelete),
					  -DurFromDnode(plsdnLastDelete));
				}
			else 
				{
				plsdnLastDelete = plsdn;
				AdvanceCurrentUrSubl(SublineFromDnode(plsdnFirstDelete),
					  -DurFromDnode(plsdnFirstDelete));
				}

			plsdnPrev = plsdnFirstDelete->plsdnPrev;
			plsdnNext = plsdnLastDelete->plsdnNext;
			}
		else
			{
			plsdnFirstDelete = plsdn;
			plsdnLastDelete = plsdn;
			}

		/*set links */
		if (plsdnPrev != NULL)
			{
			Assert(FIsLSDNODE(plsdnPrev));
			plsdnPrev->plsdnNext = plsdnNext;
			}

		if (plsdnNext != NULL)
			{
			Assert(FIsLSDNODE(plsdnNext));
			plsdnNext->plsdnPrev = plsdnPrev;
			}
		else
			{
			/* this dnode was the last one so we need to change state */
			SetCurrentDnodeSubl(plsdn->plssubl, plsdnPrev);
			}


		/* break link with next and destroy */
		plsdnLastDelete->plsdnNext = NULL;
		lserr = DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
				plsdnFirstDelete, plsc->fDontReleaseRuns);
		if (lserr != lserrNone)
			return lserr;
		}


   	return lserrNone;	

}

/* L S D N  G E T  B O R D E R  A F T E R */
/*----------------------------------------------------------------------------
    %%Function: LsdnCheckAvailableSpace
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) dnode to find closing border for
	pdurBorder			-	(OUT) dur of the border after this DNODE

----------------------------------------------------------------------------*/
LSERR LsdnGetBorderAfter(PLSC plsc,	PLSDNODE plsdn,	
					 long* pdurBorder)	
	{
	Unreferenced(plsc);  /* to avoid warning in shiping version */

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));

	*pdurBorder = 0;
	if (FDnodeHasBorder(plsdn))
		{
		*pdurBorder = DurBorderFromDnodeInside(plsdn);
		}
	return lserrNone;

	}

/* L S D N  G E T  G E T  L E F T  I N D E N T  D U R */
/*----------------------------------------------------------------------------
    %%Function: LsdnGetLeftIndentDur
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	pdurLeft			-	(OUT) dur of the left margin

----------------------------------------------------------------------------*/
LSERR LsdnGetLeftIndentDur(PLSC plsc, long* pdurLeft)		
	{

	Assert(FIsLSC(plsc));

	*pdurLeft = plsc->lsadjustcontext.urLeftIndent;

	return lserrNone;
	}

/* L S D N  S E T  S T O P R */
/*----------------------------------------------------------------------------
    %%Function: LsdnSetStopr
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) dnode 
	stopres				-	(IN) kind of hard break

  Set flag correspondent to a type of hard break into dnode
----------------------------------------------------------------------------*/
LSERR LsdnSetStopr(PLSC plsc, PLSDNODE plsdn, STOPRES stopres)	
	{
	Unreferenced(plsc);  /* to avoid warning in shiping version */

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));
	Assert(!plsdn->fEndOfColumn && !plsdn->fEndOfPage && !plsdn->fEndOfSection &&
		   !plsdn->fEndOfPara && !plsdn->fAltEndOfPara && !plsdn->fSoftCR);
	
	switch (stopres)
		{
		case stoprEndColumn:
			plsdn->fEndOfColumn = fTrue;
			break;
		case stoprEndPage:
			plsdn->fEndOfPage = fTrue;
			break;
		case stoprEndSection:
			plsdn->fEndOfSection = fTrue;
			break;
		case stoprEndPara:
			plsdn->fEndOfPara = fTrue;
			break;
		case stoprAltEndPara:
			plsdn->fAltEndOfPara = fTrue;
			break;
		case stoprSoftCR:
			plsdn->fSoftCR = fTrue;
			break;
		default:
			NotReached();
		}

   	return lserrNone;		

}

/* L S D N  F  C A N  B E F O R E  N E X T  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: LsdnFCanBreakBeforeNextChunk
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Last DNODE of the current chunk 
	pfCanBreakBeforeNextChunk-(OUT) Can break before next chunk ? 

Called by text during find previous break when it's going to set break after last text dnode.
Procedure forwards this question to the next after text object
----------------------------------------------------------------------------*/

LSERR LsdnFCanBreakBeforeNextChunk(PLSC  plsc, PLSDNODE plsdn,	BOOL* pfCanBreakBeforeNextChunk)
	{
	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));

	return FCanBreakBeforeNextChunkCore (plsc, plsdn, pfCanBreakBeforeNextChunk);
	}

/* L S D N  F  S T O P P E D  A F T E R  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: LsdnFStoppedAfterChunk
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Last DNODE of the current chunk 
	pfStoppedAfterChunk-(OUT) Splat or Hidden Text, producing fmtrStopped after chunk? 

Called by text during find previous break when breaking rules prohibit text to break after last dnode,
but is must do this because of splat.
----------------------------------------------------------------------------*/

LSERR LsdnFStoppedAfterChunk(PLSC  plsc, PLSDNODE plsdn,	BOOL* pfStoppedAfterChunk)
	{
	PLSDNODE plsdnNext;

	Unreferenced(plsc);  /* to avoid warning in shiping version */

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));

	if (!FIsSubLineMain(SublineFromDnode(plsdn)))
		*pfStoppedAfterChunk = fFalse;
	else 
		{
		plsdnNext = plsdn->plsdnNext;
		if (plsdnNext == NULL || FIsDnodeSplat(plsdnNext))
			*pfStoppedAfterChunk = fTrue;
		else
			*pfStoppedAfterChunk = fFalse;
		}
	return lserrNone;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lsdssubl.c ===
#include "lsdssubl.h"
#include <limits.h>
#include "lsc.h"
#include "dispmain.h"
#include "lssubl.h"

//    %%Function:	LsDisplaySubline
//    %%Contact:	victork
//

LSERR WINAPI LsDisplaySubline(PLSSUBL plssubl, const POINT* pptorg, UINT kdispmode, const RECT *prectClip)
{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	
	if (plssubl->plsc->lsstate != LsStateDisplaying) return lserrContextInUse;		/* change lserr later */ 

	return DisplaySublineCore(plssubl, pptorg, kdispmode, prectClip,
								LONG_MAX,					/* upLimUnderline ignored */
								0);							/* dupLeftIndent */

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lsensubl.c ===
#include "lsensubl.h"
#include "lsc.h"
#include "lssubl.h"
#include "enumcore.h"


//    %%Function:	LsEnumSubline
//    %%Contact:	victork
//
/*
 * Enumerates subline (from the given point is fGeometry needed).
 */
	
LSERR WINAPI LsEnumSubline(PLSSUBL plssubl, BOOL fReverseOrder, BOOL fGeometryNeeded, const POINT* pptorg)
{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	
	if (plssubl->plsc->lsstate != LsStateEnumerating) return lserrContextInUse;

	return EnumSublineCore(plssubl, fReverseOrder, fGeometryNeeded, pptorg, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lsqline.c ===
#include "lsqline.h"
#include "lsc.h"
#include "lsline.h"
#include "lslinfo.h"
#include "lsqsinfo.h"
#include "lsqcore.h"
#include "lstxtqry.h"
#include "lsqrycon.h"
#include "lsdnode.h"
#include "prepdisp.h"
#include "dispmisc.h"
#include "heights.h"
#include "lschp.h"
#include "dnutils.h"
#include "dninfo.h"
#include "iobj.h"
#include "zqfromza.h"
#include "lsdevice.h"

void AdjustForLeftIndent(PLSQSUBINFO, DWORD, PLSTEXTCELL, long);


#define FIsSplat(endr)	(endr == endrEndColumn 	|| 	\
						endr == endrEndSection 	|| 	\
						endr == endrEndPage)


//    %%Function:	LsQueryLineCpPpoint
//    %%Contact:	victork
//
/*
 *		Returns dim-info of the cp in the line.
 *
 *		If that cp isn't displayed in the line, take closest to the left that is displayed.
 *		If that's impossible, go to the right.
 */
LSERR WINAPI  LsQueryLineCpPpoint(
							PLSLINE 	plsline,
							LSCP		cpQuery,
							DWORD		cDepthQueryMax,			/* IN: allocated size of results array */
							PLSQSUBINFO	plsqsubinfoResults,		/* OUT: array[nDepthFormatMax] of query results */
							DWORD*		pcActualDepth,			/* OUT: size of results array (filled) */
							PLSTEXTCELL	plstextcell)			/* OUT: Text cell info */
{
	LSERR 	lserr;
	PLSSUBL	plssubl;
	PLSC	plsc;
	
	if (!FIsLSLINE(plsline)) return lserrInvalidLine;

	plssubl = &(plsline->lssubl);
	plsc = plssubl->plsc;
	Assert(FIsLSC(plsc));

	lserr = PrepareLineForDisplayProc(plsline);
	if (lserr != lserrNone)
		return lserr;

	/* cp of splat - we can return nothing sensible */
	
	if (cpQuery >= (plsline->lslinfo.cpLim)-1 && FIsSplat(plsline->lslinfo.endr))
		{
		*pcActualDepth = 0;
		return lserrNone;
		}
		
	if (plsc->lsstate == LsStateFree)
		{
		plsc->lsstate = LsStateQuerying;
		}
		
	lserr = QuerySublineCpPpointCore(plssubl, cpQuery, cDepthQueryMax, 
									plsqsubinfoResults, pcActualDepth, plstextcell);		
	
	if (lserr == lserrNone)
		{
		if (plsline->upStartAutonumberingText != 0)
			{
			AdjustForLeftIndent(plsqsubinfoResults, *pcActualDepth, plstextcell, plsline->upStartAutonumberingText);
			}

		if (plsqsubinfoResults->idobj == idObjNone)
			{												
			/* empty line - we can return nothing */
			*pcActualDepth = 0;
			}
		}
		
	if (plsc->lsstate == LsStateQuerying)
		{
		plsc->lsstate = LsStateFree;
		}

	return lserr;
}



//    %%Function:	LsQueryLinePointPcp
//    %%Contact:	victork
//
/*
 *		Returns dim-info of the cp in the line that contains given point.
 *
 *		If that dup isn't in the line, take closest that is instead.
 */
LSERR WINAPI  LsQueryLinePointPcp(
							PLSLINE 	plsline,
						 	PCPOINTUV 	ppointuvIn,				/* IN: query point */
							DWORD		cDepthQueryMax,
							PLSQSUBINFO	plsqsubinfoResults,		/* IN: pointer to array[nDepthQueryMax] */
							DWORD*		pcActualDepth,			/* OUT */
							PLSTEXTCELL	plstextcell)			/* OUT: Text cell info */
{
	LSERR 	lserr;
	PLSSUBL	plssubl;
	PLSC	plsc;
	POINTUV	pointuvStart;
	
	if (!FIsLSLINE(plsline)) return lserrInvalidLine;

	
	plssubl = &(plsline->lssubl);
	plsc = plssubl->plsc;
	Assert(FIsLSC(plsc));

	lserr = PrepareLineForDisplayProc(plsline);
	if (lserr != lserrNone)
		return lserr;
	
	/* splat - we can return nothing */
	if (ppointuvIn->u >= plsline->upLimLine && FIsSplat(plsline->lslinfo.endr))
		{
		*pcActualDepth = 0;
		return lserrNone;
		}
		
	pointuvStart = *ppointuvIn;
	
	// left indent isn't represented in the dnode list
	if (plsline->upStartAutonumberingText != 0)
		{
		pointuvStart.u -= plsline->upStartAutonumberingText;
		}
		
	lserr = QuerySublinePointPcpCore(plssubl, &pointuvStart, cDepthQueryMax, 
									plsqsubinfoResults, pcActualDepth, plstextcell);	
	
	if (lserr == lserrNone)
		{
		if (plsline->upStartAutonumberingText != 0)
			{
			AdjustForLeftIndent(plsqsubinfoResults, *pcActualDepth, plstextcell, plsline->upStartAutonumberingText);
			}

		if (plsqsubinfoResults->idobj == idObjNone)
			{												
			/* empty line - we can return nothing */
			*pcActualDepth = 0;
			}
		}

	return lserr;
}


//    %%Function:	LsQueryTextCellDetails
//    %%Contact:	victork
//
LSERR WINAPI LsQueryTextCellDetails(
							PLSLINE 		plsline,
						 	PCELLDETAILS	pcelldetails,
							LSCP			cpStartCell,		/* IN: cpStartCell	*/
							DWORD			cCharsInCell,		/* IN: nCharsInCell */
							DWORD			cGlyphsInCell,		/* IN: nGlyphsInCell */
							WCHAR*			pwch,				/* OUT: pointer array[nCharsInCell] of char codes */
							PGINDEX			pgindex,			/* OUT: pointer array[nGlyphsInCell] of glyph indices */
							long*			pdup,				/* OUT: pointer array[nGlyphsCell] of glyph widths */
							PGOFFSET 		pgoffset,			/* OUT: pointer array[nGlyphsInCell] of glyph offsets */
							PGPROP			pgprop)				/* OUT: pointer array[nGlyphsInCell] of glyph handles */
{

	PLSDNODE	pdnText;

	Unreferenced(plsline);					// is used in an assert only
	
	pdnText = (PLSDNODE)pcelldetails;		// I know it's really PLSDNODE

	Assert(FIsLSDNODE(pdnText));
	Assert(FIsDnodeReal(pdnText));
	Assert(IdObjFromDnode(pdnText) == IobjTextFromLsc(&(plsline->lssubl.plsc->lsiobjcontext)));

	// Try to defend again wrong input. Can't do a better job (use cCharsInCell) because of hyphenation.

	if (cpStartCell < pdnText->cpFirst || cpStartCell > pdnText->cpFirst + (long)pdnText->dcp)
		{
		NotReached();											// can only be client's mistake
		return lserrContradictoryQueryInput;					// in case it isn't noticed						
		}
	
	return QueryTextCellDetails(
						 	pdnText->u.real.pdobj,
							cpStartCell - pdnText->cpFirst,
							cCharsInCell,	
							cGlyphsInCell,	
							pwch,				
							pgindex,			
							pdup,				
							pgoffset,			
							pgprop);
}

//    %%Function:	LsQueryLineDup
//    %%Contact:	victork
//
LSERR WINAPI LsQueryLineDup(PLSLINE plsline,	/* IN: pointer to line -- opaque to client */
							long* pupStartAutonumberingText,
							long* pupLimAutonumberingText,
							long* pupStartMainText,
							long* pupStartTrailing,
							long* pupLimLine)

{
	LSERR lserr;

	if (!FIsLSLINE(plsline))
		return lserrInvalidLine;

	if (plsline->lssubl.plsc->lsstate != LsStateFree)
		return lserrContextInUse;

	lserr = PrepareLineForDisplayProc(plsline);
	if (lserr != lserrNone)
		return lserr;

	*pupStartAutonumberingText = plsline->upStartAutonumberingText; 
	*pupLimAutonumberingText = plsline->upLimAutonumberingText; 
	*pupStartMainText = plsline->upStartMainText; 
	*pupStartTrailing = plsline->upStartTrailing; 
	*pupLimLine = plsline->upLimLine; 
	
	return lserrNone;

}


//    %%Function:	LsQueryFLineEmpty
//    %%Contact:	victork
//
LSERR WINAPI LsQueryFLineEmpty(PLSLINE plsline,	/* IN: pointer to line -- opaque to client */
							   BOOL* pfEmpty)	/* OUT: Is line empty? */
{

	enum endres endr;
	PLSDNODE plsdnFirst;
	

	if (!FIsLSLINE(plsline))
		return lserrInvalidLine;

	if (plsline->lssubl.plsc->lsstate != LsStateFree)
		return lserrContextInUse;

	endr = plsline->lslinfo.endr;

	if (endr == endrNormal || endr == endrHyphenated)
		{
		// line that ends like that cannot be empty
		*pfEmpty = fFalse;
		return lserrNone;
		}

	// skip autonumbering - it cannot make line non-empty
	for(plsdnFirst = plsline->lssubl.plsdnFirst;
		plsdnFirst != NULL && FIsNotInContent(plsdnFirst);
		plsdnFirst = plsdnFirst->plsdnNext);

	// plsdnFirst points to the first dnode in content now or it is NULL

	switch (endr)
		{
	case endrEndPara:
	case endrAltEndPara:
	case endrSoftCR:
		// last dnode contains EOP and doesn't count as content
		Assert(plsdnFirst != NULL);
		Assert(plsdnFirst->plsdnNext == NULL || 
			   plsdnFirst->plsdnNext->cpFirst < plsline->lslinfo.cpLim);
		// EOP doesn't count as content - it cannot make line non-empty
		*pfEmpty = (plsdnFirst->plsdnNext == NULL);
		break;
		
	case endrEndColumn:
	case endrEndSection:
	case endrEndParaSection:
	case endrEndPage:
	case endrStopped:
		*pfEmpty = (plsdnFirst == NULL);
		break;
		
	default:
		NotReached();
		}

	return lserrNone;

}


//    %%Function:	AdjustForLeftIndent
//    %%Contact:	victork
//
void AdjustForLeftIndent(PLSQSUBINFO plsqsubinfoResults, DWORD cQueryLim, PLSTEXTCELL plstextcell, long upStartLine)

{
	plstextcell->pointUvStartCell.u += upStartLine;
	
	while (cQueryLim > 0)
		{
		plsqsubinfoResults->pointUvStartSubline.u += upStartLine;
		plsqsubinfoResults->pointUvStartRun.u += upStartLine;
		plsqsubinfoResults->pointUvStartObj.u += upStartLine;
		plsqsubinfoResults++;
		cQueryLim--;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lsqcore.c ===
#include "lsqcore.h"
#include "lsc.h"
#include "lsqsinfo.h"
#include "lsdnode.h"
#include "lssubl.h"
#include "heights.h"
#include "lschp.h"
#include "iobj.h"
#include "lsqin.h"
#include "lsqout.h"
#include "dninfo.h"
#include "lssubset.h"
#include "lstfset.h"
#include "dispmisc.h"


#define FIsInContent(pdn)			(!FIsNotInContent(pdn))
#define FIsZeroWidth(pdn)			(FIsDnodeReal(pdn) && (pdn)->u.real.dup == 0)
#define	FIsDnodeClosingBorder(pdn)  (FIsDnodeBorder(pdn) && (!(pdn)->fOpenBorder))


static void PrepareQueryCall(PLSSUBL, PLSDNODE, LSQIN*);
static LSERR FillInQueryResults(PLSC, PLSSUBL, PLSQSUBINFO, PLSDNODE, POINTUV*, LSQOUT*);
static void FillInTextCellInfo(PLSC, PLSDNODE, POINTUV*, LSQOUT*, PLSTEXTCELL);
static void TransformPointsOnLowerLevels(PLSQSUBINFO, DWORD, PLSTEXTCELL, PPOINTUV, LSTFLOW, LSTFLOW);
static void ApplyFormula(PPOINTUV, DWORD[], PPOINTUV);

static PLSDNODE BacktrackToPreviousDnode(PLSDNODE pdn, POINTUV* pt);
static PLSDNODE AdvanceToNextDnodeQuery(PLSDNODE, PPOINTUV);


//    %%Function:	QuerySublineCpPpointCore
//    %%Contact:	victork
//
/*
 *		Returns dim-info of the cp in the subline.
 *
 *		If that cp isn't displayed in the line, take closest to the left that is displayed.
 *		If that's impossible, go to the right.
 *
 *		Hidden text inside ligature makes it impossible to tell whether a particular cp is hidden or not
 */

LSERR QuerySublineCpPpointCore(
								PLSSUBL 	plssubl, 	
								LSCP 		cp,					/* IN: cpQuery */
								DWORD		cDepthQueryMax,		/* IN: allocated size of results array */
								PLSQSUBINFO	plsqsubinfoResults,	/* OUT: array[cDepthQueryMax] of results */
								DWORD*		pcActualDepth,		/* OUT: size of results array (filled) */
								PLSTEXTCELL	plstextcell)		/* OUT: Text cell info */


{
	PLSC		plsc;
	LSERR 		lserr = lserrNone;
	PLSDNODE 	pdn, pdnPrev = NULL;
	POINTUV		pt;
	LSCP 		cpLim;
	
	LSQIN		lsqin;
	LSQOUT		lsqout;

	PLSSUBL 	plssublLowerLevels; 	
	POINTUV		ptStartLowerLevels;
	PLSQSUBINFO	plsqsubinfoLowerLevels;
	DWORD		cDepthQueryMaxLowerLevels;
	DWORD		cActualDepthLowerLevels;

	Assert(FIsLSSUBL(plssubl));
	Assert(!plssubl->fDupInvalid);
	
	if (cDepthQueryMax == 0)
		{
		return lserrInsufficientQueryDepth;
		}

	plsc = plssubl->plsc;
	cpLim = plssubl->cpLimDisplay;

	pt.u = 0;
	pt.v = 0;
	pdn = plssubl->plsdnFirst;

	/* Skip over autonumbers & starting pens/borders */
	while (FDnodeBeforeCpLim(pdn, cpLim) && (FIsNotInContent(pdn) || !(FIsDnodeReal(pdn))))
		{
		pdn = AdvanceToNextDnodeQuery(pdn, &pt);
		}

	if (!FDnodeBeforeCpLim(pdn, cpLim))
		{												/* empty subline */
		*pcActualDepth = 0;
		return lserrNone;
		}

	// if cp <= pdn->cpFirst, pdn is the dnode to query, else...
	
	if (cp > pdn->cpFirst)
		{
		/* Skip dnodes before the cp */
		while (FDnodeBeforeCpLim(pdn, cpLim) && pdn->cpFirst + pdn->dcp <= (LSDCP)cp)
			{
			pdnPrev = pdn;
			pdn = AdvanceToNextDnodeQuery(pdn, &pt);
			}

		/* go back if our cp is in vanished text or pen or border */
	 	if (!FDnodeBeforeCpLim(pdn, cpLim) || 					// reached the end
	 				pdn->cpFirst > cp ||						// went too far because of hidden text
	 				!(FIsDnodeReal(pdn)))						// our cp points to a pen
			{	
			Assert(pdnPrev != NULL);							// we made at least one forward step
			pdn = pdnPrev;	
			pdnPrev = BacktrackToPreviousDnode(pdnPrev, &pt);

			// skip all pens/borders
			while (pdn != NULL && FIsInContent(pdn) && !(FIsDnodeReal(pdn)))
				{
				pdn = pdnPrev;	
				pdnPrev = BacktrackToPreviousDnode(pdnPrev, &pt);	
				}
				
			// nothing good to the left situation is impossible
			Assert(pdn != NULL && !FIsNotInContent(pdn));
			}		
		}
		
	/* we've found the dnode, have pt just before it, ask method for details */

	if (cp >= (LSCP) (pdn->cpFirst + pdn->dcp))				/* cp in next vanished piece */
		cp = pdn->cpFirst + pdn->dcp - 1;					/* query last cp */

	if (cp < (LSCP) pdn->cpFirst)							/* cp in a previous pen */
		cp = pdn->cpFirst;									/* query first  cp */

	pt.v += pdn->u.real.lschp.dvpPos;						// go to the local baseline
	
	PrepareQueryCall(plssubl, pdn, &lsqin);
	
	lserr = (*plsc->lsiobjcontext.rgobj[pdn->u.real.lschp.idObj].lsim.pfnQueryCpPpoint)
							(pdn->u.real.pdobj, cp - pdn->cpFirst, &lsqin, &lsqout);
	if (lserr != lserrNone)
			 return lserr;

	lserr = FillInQueryResults(plsc, plssubl, plsqsubinfoResults, pdn, &pt, &lsqout);
	
	if (lserr != lserrNone)
			 return lserr;

	if (lsqout.plssubl == NULL)						// terminal object
		{
		*pcActualDepth = 1;

		FillInTextCellInfo(plsc, pdn, &pt, &lsqout, plstextcell);
		}
	else											// there are more level(s)
		{
		// recursive call to fill lower levels
		plssublLowerLevels = lsqout.plssubl;
		plsqsubinfoLowerLevels = plsqsubinfoResults + 1;
		cDepthQueryMaxLowerLevels = cDepthQueryMax - 1;
		
		lserr = QuerySublineCpPpointCore(plssublLowerLevels, cp, cDepthQueryMaxLowerLevels, 
										plsqsubinfoLowerLevels, &cActualDepthLowerLevels, plstextcell);		
		if (lserr != lserrNone)
				 return lserr;
				 
		*pcActualDepth = cActualDepthLowerLevels + 1;

		ptStartLowerLevels.u = pt.u + lsqout.pointUvStartSubline.u;
		ptStartLowerLevels.v = pt.v + lsqout.pointUvStartSubline.v;

		TransformPointsOnLowerLevels(plsqsubinfoLowerLevels, cActualDepthLowerLevels, plstextcell, 
								 &ptStartLowerLevels, plssubl->lstflow, plssublLowerLevels->lstflow);
		}
		
	return lserrNone;
}


//    %%Function:	QuerySublinePointPcpCore
//    %%Contact:	victork
//
/*
 *		Returns dim-info of the cp in the line, that a) contains given point or
 *													 b) is closest to it from the left or
 *													 c) is just closest to it
 */
 
LSERR QuerySublinePointPcpCore(
								PLSSUBL 	plssubl, 
								PCPOINTUV 	pptIn,
								DWORD		cDepthQueryMax,		/* IN: allocated size of results array */
								PLSQSUBINFO	plsqsubinfoResults,	/* OUT: array[cDepthQueryMax] of results */
								DWORD*		pcActualDepth,		/* OUT: size of results array (filled) */
								PLSTEXTCELL	plstextcell)		/* OUT: Text cell info */
{
	PLSC		plsc;
	LSERR 		lserr = lserrNone;
	PLSDNODE 	pdn, pdnPrev = NULL;
	POINTUV		pt, ptInside, ptInsideLocal;
	LSCP 		cpLim;
	
	LSQIN		lsqin;
	LSQOUT		lsqout;

	PLSSUBL 	plssublLowerLevels; 	
	POINTUV		ptStartLowerLevels;
	PLSQSUBINFO	plsqsubinfoLowerLevels;
	DWORD		cDepthQueryMaxLowerLevels;
	DWORD		cActualDepthLowerLevels;
	long		upQuery;

	Assert(FIsLSSUBL(plssubl));
	Assert(!plssubl->fDupInvalid);
	
	if (cDepthQueryMax == 0)
		{
		return lserrInsufficientQueryDepth;
		}
	
	plsc = plssubl->plsc;
	cpLim = plssubl->cpLimDisplay;
	
	pt.u = 0;
	pt.v = 0;
	pdn = plssubl->plsdnFirst;

	/* Skip over autonumbers & starting pens & empty dnodes */
	while (FDnodeBeforeCpLim(pdn, cpLim) && (FIsNotInContent(pdn) || !(FIsDnodeReal(pdn)) || FIsZeroWidth(pdn)))
		{
		pdn = AdvanceToNextDnodeQuery(pdn, &pt);
		}

	if (!FDnodeBeforeCpLim(pdn, cpLim))
		{												/* empty subline */
		*pcActualDepth = 0;
		return lserrNone;
		}

	upQuery = pptIn->u;
	
	/* 
	 *	Find dnode with our point inside.
	 *
	 *	We look only at upQuery to do it.
	 */

	// if pt.u >= upQuery, pdn is the dnode to query, else...
	
 	if (pt.u <= upQuery)
 		{
		// skip until the end or dnode to the right of our point
		//	(That means extra work, but covers zero dup situation without additional if.)
			
		while (FDnodeBeforeCpLim(pdn, cpLim) && pt.u <= upQuery)
			{
			pdnPrev = pdn;
			pdn = AdvanceToNextDnodeQuery(pdn, &pt);
			}

		if (FIsDnodeBorder(pdnPrev))
			{
			if (pdnPrev->fOpenBorder)
				{
				// upQuery was in the previous opening border - pdn is the dnode we need
				
				Assert(FDnodeBeforeCpLim(pdn, cpLim));
				}
			else
				{
				// upQuery was in the previous closing border - dnode we need is before the border
				
				pdn = pdnPrev;	
				Assert(pdn != NULL && !FIsNotInContent(pdn));
				
				pdnPrev = BacktrackToPreviousDnode(pdnPrev, &pt);

				pdn = pdnPrev;	
				Assert(pdn != NULL && !FIsNotInContent(pdn));
				
				pdnPrev = BacktrackToPreviousDnode(pdnPrev, &pt);
				}
			}
		else
			{
			/* go back to the previous dnode */
			
			pdn = pdnPrev;	
			pdnPrev = BacktrackToPreviousDnode(pdnPrev, &pt);

			// if it is a pen/border or empty dnode (non-req hyphen), skip them all
			// (Border cannot be the previous dnode, but is possble later)
			
			while (pdn != NULL && (!(FIsDnodeReal(pdn)) || FIsZeroWidth(pdn)))
				{
				pdn = pdnPrev;	
				pdnPrev = BacktrackToPreviousDnode(pdnPrev, &pt);	
				}
				
			// "nothing good to the left" situation is impossible
			Assert(pdn != NULL && !FIsNotInContent(pdn));
			}
 		}
		
	// We have found the leftmost dnode with our dup to the right of it
	// pt is just before it, ask method for details
	
	pt.v += pdn->u.real.lschp.dvpPos;						// go to the local baseline

	PrepareQueryCall(plssubl, pdn, &lsqin);
	
	// get query point relative to the starting point of the dnode
	// we give no guarantee that it is really inside dnode box
	ptInside.u = pptIn->u - pt.u;
	ptInside.v = pptIn->v - pt.v;

	lserr = (*plsc->lsiobjcontext.rgobj[pdn->u.real.lschp.idObj].lsim.pfnQueryPointPcp)
							(pdn->u.real.pdobj, &ptInside, &lsqin, &lsqout);								 
	if (lserr != lserrNone)
			 return lserr;
			 
	lserr = FillInQueryResults(plsc, plssubl, plsqsubinfoResults, pdn, &pt, &lsqout);
	
	if (lserr != lserrNone)
			 return lserr;

	if (lsqout.plssubl == NULL)						// terminal object
		{
		*pcActualDepth = 1;

		FillInTextCellInfo(plsc, pdn, &pt, &lsqout, plstextcell);
		}
	else											// there are more level(s)
		{
		// recursive call to fill lower levels
		plssublLowerLevels = lsqout.plssubl;
		plsqsubinfoLowerLevels = plsqsubinfoResults + 1;
		cDepthQueryMaxLowerLevels = cDepthQueryMax - 1;
		
		// get query point in lower level subline coordinate system

		lserr = LsPointUV2FromPointUV1(plssubl->lstflow, &(lsqout.pointUvStartSubline), &ptInside,			/* IN: end input point (TF1) */
											plssublLowerLevels->lstflow, &ptInsideLocal);
		if (lserr != lserrNone)
				 return lserr;

		lserr = QuerySublinePointPcpCore(plssublLowerLevels, &ptInsideLocal, cDepthQueryMaxLowerLevels, 
										plsqsubinfoLowerLevels, &cActualDepthLowerLevels, plstextcell);		
		if (lserr != lserrNone)
				 return lserr;
				 
		*pcActualDepth = cActualDepthLowerLevels + 1;

		ptStartLowerLevels.u = pt.u + lsqout.pointUvStartSubline.u;
		ptStartLowerLevels.v = pt.v + lsqout.pointUvStartSubline.v;

		TransformPointsOnLowerLevels(plsqsubinfoLowerLevels, cActualDepthLowerLevels, plstextcell, 
								 &ptStartLowerLevels, plssubl->lstflow, plssublLowerLevels->lstflow);
		}

	return lserrNone;
}


//    %%Function:	PrepareQueryCall
//    %%Contact:	victork
//
static void PrepareQueryCall(PLSSUBL plssubl, PLSDNODE pdn, LSQIN*	plsqin)
{
	plsqin->lstflowSubline = plssubl->lstflow;
	plsqin->plsrun = pdn->u.real.plsrun;
	plsqin->cpFirstRun = pdn->cpFirst;
	plsqin->dcpRun = pdn->dcp;
	plsqin->heightsPresRun = pdn->u.real.objdim.heightsPres;
	plsqin->dupRun = pdn->u.real.dup;
	plsqin->dvpPosRun = pdn->u.real.lschp.dvpPos;
}


//    %%Function:	FillInQueryResults
//    %%Contact:	victork
//
static LSERR FillInQueryResults(
								PLSC		plsc,
								PLSSUBL 	plssubl, 
								PLSQSUBINFO	plsqsubinfoResults,
								PLSDNODE 	pdn,
								POINTUV* 	ppt,
								LSQOUT*		plsqout
								)
{							
	OBJDIM		objdimSubline;
	LSERR		lserr;
	PLSDNODE	pdnNext, pdnPrev;
	
	// fill in subline info
	
	lserr = LssbGetObjDimSubline(plssubl, &(plsqsubinfoResults->lstflowSubline), &objdimSubline);
	if (lserr != lserrNone)
			 return lserr;

	lserr = LssbGetDupSubline(plssubl, &(plsqsubinfoResults->lstflowSubline), &plsqsubinfoResults->dupSubline);
	if (lserr != lserrNone)
			 return lserr;

	plsqsubinfoResults->cpFirstSubline = plssubl->cpFirst;
	plsqsubinfoResults->dcpSubline = plssubl->cpLimDisplay - plssubl->cpFirst;
	plsqsubinfoResults->pointUvStartSubline.u = 0;
	plsqsubinfoResults->pointUvStartSubline.v = 0;

	plsqsubinfoResults->heightsPresSubline = objdimSubline.heightsPres;

	// fill in dnode info
	
	if (IdObjFromDnode(pdn) == IobjTextFromLsc(&(plsc->lsiobjcontext)))
		plsqsubinfoResults->idobj = idObjText;
	else
		plsqsubinfoResults->idobj = pdn->u.real.lschp.idObj;

	plsqsubinfoResults->plsrun = pdn->u.real.plsrun;
	plsqsubinfoResults->cpFirstRun = pdn->cpFirst;
	plsqsubinfoResults->dcpRun = pdn->dcp;
	plsqsubinfoResults->pointUvStartRun = *ppt;							// local baseline
	plsqsubinfoResults->heightsPresRun = pdn->u.real.objdim.heightsPres;
	plsqsubinfoResults->dupRun = pdn->u.real.dup;
	plsqsubinfoResults->dvpPosRun = pdn->u.real.lschp.dvpPos;
	
	// fill in object info
	
	plsqsubinfoResults->pointUvStartObj.u = ppt->u + plsqout->pointUvStartObj.u;
	plsqsubinfoResults->pointUvStartObj.v = ppt->v + plsqout->pointUvStartObj.v;
	plsqsubinfoResults->heightsPresObj = plsqout->heightsPresObj;
	plsqsubinfoResults->dupObj = plsqout->dupObj;

	// add borders info
	
	plsqsubinfoResults->dupBorderAfter = 0;
	plsqsubinfoResults->dupBorderBefore = 0;

	if (pdn->u.real.lschp.fBorder)
		{
		pdnNext = pdn->plsdnNext;
		
		if (pdnNext != NULL && FIsDnodeClosingBorder(pdnNext))
			{
			plsqsubinfoResults->dupBorderAfter = pdnNext->u.pen.dup;
			}

		pdnPrev = pdn->plsdnPrev;
		
		if (pdnPrev != NULL && FIsDnodeOpenBorder(pdnPrev))
			{
			Assert(FIsInContent(pdnPrev));
			
			plsqsubinfoResults->dupBorderBefore = pdnPrev->u.pen.dup;
			}
		}

	return lserrNone;
}


//    %%Function:	FillInTextCellInfo
//    %%Contact:	victork
//
static void FillInTextCellInfo(
								PLSC		plsc,
								PLSDNODE 	pdn,
								POINTUV* 	ppt,
								LSQOUT*		plsqout,
								PLSTEXTCELL	plstextcell		/* OUT: Text cell info */
								)
{		
	if (IdObjFromDnode(pdn) == IobjTextFromLsc(&(plsc->lsiobjcontext)))
		{
		// text has cell info filled - copy it
		
		*plstextcell = plsqout->lstextcell;

		// but starting point is relative to the begining of dnode - adjust to that of subline

		plstextcell->pointUvStartCell.u += ppt->u;
		plstextcell->pointUvStartCell.v += ppt->v;

		// adjust cpEndCell if some hidden text got into last ligature - text is unaware of the issue
		
		if (pdn->cpFirst + pdn->dcp < (LSDCP) pdn->cpLimOriginal &&
			(LSDCP) plstextcell->cpEndCell == pdn->cpFirst + pdn->dcp - 1)
			{
			plstextcell->cpEndCell = pdn->cpLimOriginal - 1;
			}

		// pointer to the dnode to get details quickly - only query manager knows what PCELLDETAILS is
		
		plstextcell->pCellDetails = (PCELLDETAILS)pdn;
		}
	else
		{
		// non-text object should not fill lstxtcell, client should not look into it
		// I fill it with object information for debug purposes
		// Consider zapping it in lsqline later (Rick's suggestion)
		
		plstextcell->cpStartCell = pdn->cpFirst;
		plstextcell->cpEndCell = pdn->cpFirst + pdn->dcp - 1;
	 	plstextcell->pointUvStartCell = *ppt;
		plstextcell->dupCell = pdn->u.real.dup;
		plstextcell->cCharsInCell = 0;
		plstextcell->cGlyphsInCell = 0;
		plstextcell->pCellDetails = NULL;
		}
}


//    %%Function:	TransformPointsOnLowerLevels
//    %%Contact:	victork
//
// transform all vectors in results array from lstflow2 to lstflow1, adding pointuvStart (lstflow1)

static void TransformPointsOnLowerLevels(
								PLSQSUBINFO	plsqsubinfo,		/* IN/OUT: results array */		
								DWORD		cDepth,				/* IN: size of results array */
								PLSTEXTCELL	plstextcell,		// IN/OUT: text cell
								PPOINTUV	ppointuvStart,		// IN: in lstflow1
								LSTFLOW		lstflow1,			// IN: lstflow1
								LSTFLOW		lstflow2)			// IN: lstflow2

{
	// Have to apply formulas
	//		VectorOut.u = k11 * VectorIn.u + k12 * VectorIn.v + pointuvStart.u 
	//		VectorOut.v = k21 * VectorIn.u + k22 * VectorIn.v + pointuvStart.u 
	// to several vectors in results array (all elements in k matrix are zero or +/- 1)
	// Algorithm: find the matrix first, then use it

	DWORD	k[4];
	POINTUV	pointuv0, pointuv1, pointuv2;

	pointuv0.u = 0;
	pointuv0.v = 0;
	
	pointuv1.u = 1;
	pointuv1.v = 0;
	
	LsPointUV2FromPointUV1(lstflow2, &pointuv0, &pointuv1, lstflow1, &pointuv2);
	
	k[0] = pointuv2.u;			// k11
	k[1] = pointuv2.v;			// k21

	pointuv1.u = 0;
	pointuv1.v = 1;
	
	LsPointUV2FromPointUV1(lstflow2, &pointuv0, &pointuv1, lstflow1, &pointuv2);
	
	k[2] = pointuv2.u;			// k12
	k[3] = pointuv2.v;			// k22


	// all points in lower levels are in lstflowLowerLevels (lstflow2) with starting point at the 
	// beginning of the top lower levels subline
	// Translate them to lstflowTop (lstflow1) and starting point of our subline.
	
	while (cDepth > 0)
		{
		ApplyFormula(&(plsqsubinfo->pointUvStartSubline), k, ppointuvStart);
		ApplyFormula(&(plsqsubinfo->pointUvStartRun), k, ppointuvStart);
		ApplyFormula(&(plsqsubinfo->pointUvStartObj), k, ppointuvStart);
		plsqsubinfo++;
		cDepth--;
		}

	// StartCell point should be adjusted too
	ApplyFormula(&(plstextcell->pointUvStartCell), k, ppointuvStart);
		
}

//    %%Function:	ApplyFormula
//    %%Contact:	victork
//
static void ApplyFormula(PPOINTUV ppointuv, DWORD* rgk, PPOINTUV ppointuvStart)
{
	POINTUV	pointuvTemp;

	pointuvTemp.u = ppointuvStart->u + rgk[0] * ppointuv->u + rgk[2] * ppointuv->v;
	pointuvTemp.v = ppointuvStart->v + rgk[1] * ppointuv->u + rgk[3] * ppointuv->v;
	*ppointuv = pointuvTemp;
}

//    %%Function:	AdvanceToNextDnodeQuery
//    %%Contact:	victork
//
/* 
 *	Advance to the next node and update pen position (never goes into sublines)
 */

static PLSDNODE AdvanceToNextDnodeQuery(PLSDNODE pdn, POINTUV* ppt)
{

	if (pdn->klsdn == klsdnReal)
		{
		ppt->u += pdn->u.real.dup;										
		}
	else												/* 	case klsdnPen */
		{
		ppt->u += pdn->u.pen.dup;
		ppt->v += pdn->u.pen.dvp;
		}

	return pdn->plsdnNext;
}

//    %%Function:	BacktrackToPreviousDnode
//    %%Contact:	victork
//
// 	Backtrack and downdate pen position.
//	Both parameters are input/output
//	Input: dnode number N-1 and point at the beginning of the dnode number N
//	Output: point at the beginning of the dnode number N-1
//	Return: dnode number N-2

static PLSDNODE BacktrackToPreviousDnode(PLSDNODE pdn, POINTUV* ppt)
{

	if (FIsDnodeReal(pdn))
		{
		ppt->u -= pdn->u.real.dup;										
		}
	else												/* 	it's Pen */
		{
		ppt->u -=	pdn->u.pen.dup;
		ppt->v -= pdn->u.pen.dvp;
		}
	
	return pdn->plsdnPrev;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lsfetch.c ===
#include "lsidefs.h"
#include "dninfo.h"
#include "dnutils.h"
#include "fmti.h"
#include "getfmtst.h"
#include "iobj.h"
#include "iobjln.h"
#include "lsc.h"
#include "lsdnode.h"
#include "lsfetch.h"
#include "lsfrun.h"
#include "lsline.h"
#include "lsesc.h"
#include "lstext.h"
#include "ntiman.h"
#include "qheap.h"
#include "setfmtst.h"
#include "tabutils.h"
#include "zqfromza.h"
#include "lssubl.h"
#include "autonum.h"
#include "lscfmtfl.h"

#include <limits.h>
#include "lsmem.h"						/* memset() */

/* L I M  R G */
/*----------------------------------------------------------------------------
    %%Function: LimRg
    %%Contact: igorzv

    Returns # of elements in an array.
----------------------------------------------------------------------------*/
#define LimRg(rg)	(sizeof(rg)/sizeof((rg)[0]))



/* A S S E R T  V A L I D  F M T R E S */
/*----------------------------------------------------------------------------
    %%Macro: AssertValidFmtres
    %%Contact: lenoxb

    Verifies that fmtrCk has a legal value.
----------------------------------------------------------------------------*/
#define AssertValidFmtres(fmtrCk) \
		Assert( \
				(fmtrCk) == fmtrCompletedRun || \
				(fmtrCk) == fmtrExceededMargin || \
				(fmtrCk) == fmtrTab  || \
				(fmtrCk) == fmtrStopped \
			  );




/* S E T  T O  M A X */
/*----------------------------------------------------------------------------
    %%Macro: SetToMax
    %%Contact: lenoxb

    Sets "a" to the maximum of "a" and "b".
----------------------------------------------------------------------------*/
#define SetToMax(a,b)		if ((a) < (b)) (a) = (b); else




/* S E T  H E I G H T  T O  M A X */
/*----------------------------------------------------------------------------
    %%Macro: SetHeightToMax
    %%Contact: igorzv

    Sets the line height elements of an LSLINFO structure to the maximum
	of their current value, and the height of an arbitrary object.
	(plslinfo)->dvrMultiLineHeight == dvHeightIgnore is sign not 
	to take into account this dnode 
----------------------------------------------------------------------------*/
#define SetHeightToMax(plslinfo,pobjdim) \
{\
	if ((pobjdim)->heightsRef.dvMultiLineHeight != dvHeightIgnore)\
		{\
		SetToMax((plslinfo)->dvrAscent, (pobjdim)->heightsRef.dvAscent);\
		SetToMax((plslinfo)->dvpAscent, (pobjdim)->heightsPres.dvAscent);\
		SetToMax((plslinfo)->dvrDescent, (pobjdim)->heightsRef.dvDescent);\
		SetToMax((plslinfo)->dvpDescent, (pobjdim)->heightsPres.dvDescent);\
		SetToMax((plslinfo)->dvpMultiLineHeight, (pobjdim)->heightsPres.dvMultiLineHeight);\
		SetToMax((plslinfo)->dvrMultiLineHeight, (pobjdim)->heightsRef.dvMultiLineHeight);\
		}\
}






#define PlnobjFromLsc(plsc,iobj)	((Assert(FIsLSC(plsc)), PlnobjFromLsline((plsc)->plslineCur,iobj)))

#define CreateLNObjInLsc(plsc, iobj) ((PLsimFromLsc(&((plsc)->lsiobjcontext),iobj))->pfnCreateLNObj\
									 (PilsobjFromLsc(&((plsc)->lsiobjcontext),iobj), \
														   &((plsc)->plslineCur->rgplnobj[iobj])))

/* This macros created to avoid code duplication  */

#define FRunIsNotSimple(plschp, fHidden)   \
									(((plschp)->idObj != idObjTextChp) ||  \
									 ((fHidden)) ||  \
									  ((plschp)->fBorder) || \
									  FApplyNominalToIdeal(plschp))

#define CreateDnode(plsc, plsdnNew) \
		(plsdnNew) = PvNewQuick(GetPqhAllDNodes(plsc), sizeof *(plsdnNew));\
		if ((plsdnNew) == NULL)\
			return lserrOutOfMemory;\
		(plsdnNew)->tag = tagLSDNODE;\
		(plsdnNew)->plsdnPrev = GetCurrentDnode(plsc);\
		(plsdnNew)->plsdnNext = NULL;\
		(plsdnNew)->plssubl = GetCurrentSubline(plsc);\
		/* we don't connect dnode list with this dnode untill handler calls*/ \
		/*Finish API, but we put correct pointer to previous in this dnode,*/ \
		/*so we can easily link list in Finish routines   */\
		(plsdnNew)->cpFirst = GetCurrentCpLim(plsc); \
		/* flush all flags, bellow check that result is what  we expect */ \
		*((DWORD *) ((&(plsdnNew)->dcp)+1)) = 0;\
		Assert((plsdnNew)->klsdn == klsdnReal);\
		Assert((plsdnNew)->fRigidDup == fFalse);\
		Assert((plsdnNew)->fAdvancedPen == fFalse);\
		Assert((plsdnNew)->fTab == fFalse);\
		Assert((plsdnNew)->icaltbd == 0);\
		Assert((plsdnNew)->fBorderNode == fFalse);\
		Assert((plsdnNew)->fOpenBorder == fFalse);\
		Assert((plsdnNew)->fEndOfSection == fFalse); \
		Assert((plsdnNew)->fEndOfColumn == fFalse); \
		Assert((plsdnNew)->fEndOfPage == fFalse); \
		Assert((plsdnNew)->fEndOfPara == fFalse); \
		Assert((plsdnNew)->fAltEndOfPara == fFalse); \
		Assert((plsdnNew)->fSoftCR == fFalse); \
		Assert((plsdnNew)->fInsideBorder == fFalse); \
		Assert((plsdnNew)->fAutoDecTab == fFalse); \
		Assert((plsdnNew)->fTabForAutonumber == fFalse);


#define FillRealPart(plsdnNew, plsfrunOfDnode)\
		/* we don't initialize  here variables that will be set in FiniSimpleRegular  */ \
		(plsdnNew)->u.real.pinfosubl = NULL;\
		/* next two assignement we do to use DestroyDnodeList in the case of error */ \
		(plsdnNew)->u.real.plsrun = (plsfrunOfDnode)->plsrun;\
		(plsdnNew)->u.real.pdobj = NULL;\
		/* we put amount of characters to dcp to check it in LsdnFinishSimpleByOneChar */ \
		(plsdnNew)->dcp = (plsfrunOfDnode)->cwchRun; \
		(plsdnNew)->cpLimOriginal = (plsdnNew)->cpFirst + (plsdnNew)->dcp;

#define CreateRealDnode(plsc,plsdnNew, plsrun)\
		CreateDnode((plsc), (plsdnNew));\
		FillRealPart((plsdnNew), (plsrun));

#define CreatePenDnode(plsc,plsdnNew)\
		CreateDnode((plsc), (plsdnNew));\
		(plsdnNew)->dcp = 0;\
		(plsdnNew)->cpLimOriginal = (plsdnNew)->cpFirst;\
		(plsdnNew)->u.pen.dur = 0;\
		(plsdnNew)->u.pen.dup = 0;\
		(plsdnNew)->u.pen.dvr = 0;\
		(plsdnNew)->u.pen.dvp = 0;\
		(plsdnNew)->klsdn = klsdnPenBorder;

#define CreateBorderDnode(plsc,plsdnNew, durBorder, dupBorder)\
		CreateDnode((plsc), (plsdnNew));\
		(plsdnNew)->dcp = 0;\
		(plsdnNew)->cpLimOriginal = (plsdnNew)->cpFirst;\
		(plsdnNew)->u.pen.dur = (durBorder);\
		(plsdnNew)->u.pen.dup = (dupBorder);\
		(plsdnNew)->u.pen.dvr = 0;\
		(plsdnNew)->u.pen.dvp = 0;\
		(plsdnNew)->klsdn = klsdnPenBorder; \
		(plsdnNew)->fBorderNode = fTrue; \
		TurnOnNonRealDnodeEncounted(plsc);

#define FNeedToCutPossibleContextViolation(plsc, plsdn) \
	(FIsDnodeReal(plsdn) && \
	 ((plsdn)->u.real.lschp.dcpMaxContext > 1) && \
	 (IdObjFromDnode(plsdn) == IobjTextFromLsc(&((plsc)->lsiobjcontext)))  \
    )

/* ------------------------------------------------------------------ */
static LSERR CheckNewPara(PLSC, LSCP, LSCP, BOOL*);
static BOOL FLimitRunEsc(LSFRUN*, const LSESC*, DWORD);
static LSERR CreateInitialPen(PLSC plsc, long dur);
static LSERR 	UndoLastDnode(PLSC);				/* IN: ls context */
static LSERR  OpenBorder(PLSC plsc, PLSRUN plsrun);
static LSERR HandleSplat(PLSC plsc, FMTRES* pfmtres);
static LSERR ErrReleaseRunToFormat	  (PLSC,	/* IN: ptr to line services context */	
									  PLSRUN,	/* IN: ponter to a run structure to be deleted */
									  LSERR);	/* IN: code of an error							*/


/* ---------------------------------------------------------------------- */

/* F E T C H  A P P E N D  E S C  R E S U M E  C O R E */
/*----------------------------------------------------------------------------
    %%Function: FetchAppendEscResumeCore
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	urColumnMax		-	(IN) right margin where to stop
	plsesc		-		(IN) escape characters
	clsesc	-			(IN) # of escape characters
	rgbreakrec	-		(IN) input array of break records 
	cbreakrec,			(IN) number of records in input array 
	pfmtres		-		(OUT) result of last formatter
	pcpLim	-			(OUT) where we stop fetching
	pplsdnFirst		-	(OUT) first dnode that was created
	pplsdnLast		-	(OUT) last dnode that was created
	pur			-		(OUT) pen position after procedure

	If cbreakrec > 0 fetches run with cpFirst from first break record.
	After that if rigth msrgin is not exceeded cals FetchAppendEscCore
----------------------------------------------------------------------------*/
LSERR 	FetchAppendEscResumeCore(PLSC plsc, long urColumnMax, const LSESC* plsesc,
						   DWORD clsesc, const BREAKREC* rgbreakrec,
						   DWORD cbreakrec, FMTRES* pfmtres, LSCP*	  pcpLim,
						   PLSDNODE* pplsdnFirst, PLSDNODE* pplsdnLast, 
						   long* pur)
						   
	{
	LSFRUN lsfrun;
	LSCHP lschp;  /* local memory to store lschp */
	BOOL fHidden;
	FMTRES fmtresResume;
	LSERR lserr;
	PLSDNODE* pplsdnFirstStore;   /* where to find plsdnFirst  */
	
	Assert(FIsLSC(plsc)); 
	Assert(FFormattingAllowed(plsc));
	Assert(!(rgbreakrec == NULL && cbreakrec != 0));
	Assert(GetCurrentDnode(plsc) == NULL); /* it should be begining of a subline */

	if (cbreakrec > 0)
		{
		/*Initialization;    */
		
		lsfrun.plschp = &lschp;
		pplsdnFirstStore = GetWhereToPutLink(plsc, GetCurrentDnode(plsc));

		/* fetch run that starts object to resume */
		lserr = plsc->lscbk.pfnFetchRun(plsc->pols, rgbreakrec[0].cpFirst,
			&lsfrun.lpwchRun, &lsfrun.cwchRun,
			&fHidden, &lschp, &lsfrun.plsrun);
		if (lserr != lserrNone)
			return lserr;
		
		if (lsfrun.cwchRun <= 0 || fHidden || lsfrun.plschp->idObj != rgbreakrec[0].idobj)
			{
			lserr = lserrInvalidBreakRecord;
			if (!plsc->fDontReleaseRuns)
				{
				plsc->lscbk.pfnReleaseRun(plsc->pols, lsfrun.plsrun);
				}
			return lserr;
			}

		/* zero amount of characters before dispatching to an object */
		lsfrun.cwchRun = 0;

		lserr = ProcessOneRun(plsc, urColumnMax, &lsfrun, rgbreakrec,
							  cbreakrec,&fmtresResume);
		if (lserr != lserrNone)
			return lserr;

		/* we know that resumed object is not text, so only two fmtres are possible
		   and we don't consider others */
		Assert(fmtresResume == fmtrCompletedRun || fmtresResume == fmtrExceededMargin);

		if (fmtresResume == fmtrCompletedRun)
			{

			lserr = FetchAppendEscCore(plsc, urColumnMax, plsesc, clsesc, pfmtres, pcpLim,
						   pplsdnFirst, pplsdnLast, pur);
			if (lserr != lserrNone)
				return lserr;

			/* special handling of empty dnode list as an result of FetchAppendEscCore */
			if (*pplsdnFirst == NULL)
				{
				*pplsdnLast = GetCurrentDnode(plsc); /* this assigning is correct even when 
													    resumed object produces empty list 
														of dnodes because it starts subline */

				*pfmtres = fmtresResume;
				}

			/* rewrite first dnode */
			*pplsdnFirst = *pplsdnFirstStore; 
			}
		else	/* stop fetching here */
			{
			/*  Prepare output   */
			*pfmtres = fmtresResume;
			*pcpLim = GetCurrentCpLim(plsc);
			*pplsdnFirst = *pplsdnFirstStore; 
			*pplsdnLast = GetCurrentDnode(plsc);
			*pur = GetCurrentUr(plsc);
			}
		
		Assert((*pplsdnFirst == NULL) == (*pplsdnLast == NULL));
		Assert((*pplsdnLast == NULL) || ((*pplsdnLast)->plsdnNext == NULL));

		return lserrNone;
		}
	else    /* no breakrecords */
		{
		return FetchAppendEscCore(plsc, urColumnMax, plsesc, clsesc, pfmtres, pcpLim,
						   pplsdnFirst, pplsdnLast, pur);
		}
	}

/* ---------------------------------------------------------------------- */

/* F E T C H  A P P E N D  E S C  C O R E */
/*----------------------------------------------------------------------------
    %%Function: FetchAppendEscCore
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	urColumnMax		-	(IN) right margin where to stop
	plsesc		-		(IN) escape characters
	clsesc	-			(IN) # of escape characters
	pfmtres		-		(OUT) result of last formatter
	pcpLim	-			(OUT) where we stop fetching
	pplsdnFirst		-	(OUT) first dnode that was created
	pplsdnLast		-	(OUT) last dnode that was created
	pur			-		(OUT) pen position after procedure

	Loop: fetch run, dispatch it to object handler until escape character
			or terminal fmtres.
----------------------------------------------------------------------------*/


LSERR 	FetchAppendEscCore(PLSC plsc, long urColumnMax, const LSESC* plsesc,
						   DWORD clsesc, FMTRES* pfmtres, LSCP*	  pcpLim,
						   PLSDNODE* pplsdnFirst, PLSDNODE* pplsdnLast, 
						   long* pur)
						   
	{
	
	BOOL fDone = fFalse;
	LSFRUN lsfrun;
	LSCHP lschp;  /* local memory to store lschp */
	FMTRES fmtres;
	BOOL fHidden;
	LSCP cpLimOfCutRun = (LSCP)(-1);   /* cpLim of run that was cuted according with Esc character
									   is not valid in other cases
	we use it to check that whole such run was handled by formater */
	LSCP cpPrev = (LSCP)(-1);	/* cp of previous run valid only after first iteration */
	LSERR lserr;
	PLSDNODE* pplsdnFirstStore;   /* where to find plsdnFirst  */
	
	
	Assert(FIsLSC(plsc)); 
	Assert(FFormattingAllowed(plsc)); 
	
	/*Initialization;    */
	lsfrun.plschp = &lschp;
	fmtres = fmtrCompletedRun;  /* it will be output if return right away with esc character */
	pplsdnFirstStore = GetWhereToPutLink(plsc, GetCurrentDnode(plsc));
	
	while (!fDone)
		{
		cpPrev = GetCurrentCpLim(plsc);
		/*     FetchRun        */
		lserr = plsc->lscbk.pfnFetchRun(plsc->pols, GetCurrentCpLim(plsc),
			&lsfrun.lpwchRun, &lsfrun.cwchRun,
			&fHidden, &lschp, &lsfrun.plsrun);
		if (lserr != lserrNone)
			return lserr;
		
		if (lsfrun.cwchRun <= 0)
			{
			lserr = lserrInvalidDcpFetched;
			if (!plsc->fDontReleaseRuns)
				{
				plsc->lscbk.pfnReleaseRun(plsc->pols, lsfrun.plsrun);
				}
			return lserr;
			}
		
		if (fHidden)
			{
			AdvanceCurrentCpLim(plsc, lsfrun.cwchRun);
			if (lsfrun.plsrun != NULL && !plsc->fDontReleaseRuns)  /* we have not used this plsrun */
				{
				lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, lsfrun.plsrun);
				if (lserr != lserrNone)
					return lserr;
				}
			/*  Handle vanish end of paragraph;  */
			/*  There is situation in Word (see bug 118) when after fetching hidden text
			paragraph boundaries can be changed. So we have to call CheckNewPara
			every time after hidden text  */
			
			lserr = CheckNewPara(plsc, cpPrev, GetCurrentCpLim(plsc), &fDone);
			if (lserr != lserrNone)
				return lserr;
			
			if (fDone) 
				{
				/* it will eventually force stop formatting so we should apply 
				nominal to ideal here */
				if (FNominalToIdealEncounted(plsc))
					{
					lserr = ApplyNominalToIdeal(PlschunkcontextFromSubline(GetCurrentSubline(plsc)),
						&plsc->lsiobjcontext,
						plsc->grpfManager, plsc->lsadjustcontext.lskj,
						FIsSubLineMain(GetCurrentSubline(plsc)),
						FLineContainsAutoNumber(plsc), 
						GetCurrentDnode(plsc));
					if (lserr != lserrNone)
						return lserr;  
					}
				fmtres = fmtrStopped;
				}
			}
		else
			{
			/*   Check Esc character;     */
			if (clsesc > 0 && FLimitRunEsc(&lsfrun, plsesc, clsesc))
				{
				cpLimOfCutRun = (LSCP) (GetCurrentCpLim(plsc) + lsfrun.cwchRun);
				fDone = (lsfrun.cwchRun == 0);
				}
			
			if (!fDone)
				{
				lserr = ProcessOneRun(plsc, urColumnMax, &lsfrun, NULL, 0, &fmtres);
				if (lserr != lserrNone)
					return lserr;
				
				/*Check fmtres: Are formating done?;   */
				switch (fmtres)
					{
					case fmtrCompletedRun:  
						fDone = (GetCurrentCpLim(plsc) == cpLimOfCutRun); /* is true only if we cuted because */
						Assert(!fDone || clsesc > 0);			 /* of esc character and formater handled such*/
						break;									 /* run completely  */
						
					case fmtrExceededMargin:
						fDone = fTrue;
						break;
						
					case fmtrTab:
						fDone = fTrue;
						break;

					case fmtrStopped:
						fDone = fTrue;
						break;
						
					default:
						NotReached();
						
					}
				
				}
			else   /* after limiting run by esc characters it was empty */
				{
				if (lsfrun.plsrun != NULL && !plsc->fDontReleaseRuns)  /* we have not used this plsrun */
					{
					lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, lsfrun.plsrun);
					if (lserr != lserrNone)
						return lserr;
					fmtres = fmtrCompletedRun;
					}
				}
			}  /* if/else hidden  */
		}
		
		
		/*  Prepare output   */
		*pfmtres = fmtres;
		*pcpLim = GetCurrentCpLim(plsc);
		*pplsdnFirst = *pplsdnFirstStore; 
		if (*pplsdnFirst != NULL)					
			*pplsdnLast = GetCurrentDnode(plsc);
		else
			*pplsdnLast = NULL;
		*pur = GetCurrentUr(plsc);
		
		Assert((*pplsdnFirst == NULL) == (*pplsdnLast == NULL));
		Assert((*pplsdnLast == NULL) || ((*pplsdnLast)->plsdnNext == NULL));
		
		return lserrNone;
	}		
	

/* ---------------------------------------------------------------------- */

/* P R O C E S S  O N E  R U N */
/*----------------------------------------------------------------------------
    %%Function: ProcessOneRun
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	urColumnMax		-	(IN) right margin where to stop
	plsfrun		-		(IN) given run
	rgbreakrec	-		(IN) input array of break records 
	cbreakrec,			(IN) number of records in input array 
	pfmtres		-		(OUT) result of formatting

1) If run it's not a text run applies nominal to ideal to previous text chunk.
	To have correct pen position before dispatching to an foreign object.
2) Get text metrics and dispatches run to an handler.
3) If fmtres is terminal applies nominal to ideal to the last chunk. 
----------------------------------------------------------------------------*/


LSERR ProcessOneRun	(PLSC plsc,	long urColumnMax, const LSFRUN* plsfrun, 
					 const BREAKREC* rgbreakrec,
					 DWORD cbreakrec, FMTRES* pfmtres)	


{
	DWORD iobj;
	LSIMETHODS* plsim;
	PLNOBJ plnobj;
	struct fmtin fmti;
	LSERR lserr;
	PLSDNODE plsdnNew;
	PLSDNODE  plsdnToFinishOld;   /* we should restore it after every formater */
	PLSSUBL  plssublOld;
	PLSDNODE plsdnNomimalToIdeal;
	PLSDNODE* pplsdnToStoreNext; 
	PLSDNODE plsdnNext;
	PLSDNODE plsdnCurrent;
	PLSDNODE plsdnLast;
	BOOL fInterruptBorder;
	BOOL fInsideBorderUp = fFalse;
	BOOL fBordered = fFalse;

	

	Assert(FIsLSC(plsc));
	Assert(!(rgbreakrec == NULL && cbreakrec != 0));


	plsdnToFinishOld = GetDnodeToFinish(plsc);
	plssublOld = GetCurrentSubline(plsc);
	plsdnCurrent = GetCurrentDnode(plsc);
	pplsdnToStoreNext = GetWhereToPutLink(plsc, plsdnCurrent);
	if (plsdnToFinishOld != NULL)
		fInsideBorderUp = plsdnToFinishOld->fInsideBorder;


	if (plsfrun->plschp->idObj == idObjTextChp)
		iobj = IobjTextFromLsc(&plsc->lsiobjcontext);
	else
		iobj = plsfrun->plschp->idObj;

	Assert (FIobjValid(&plsc->lsiobjcontext, iobj));		/* Reject other out of range ids */
	if (!FIobjValid(&plsc->lsiobjcontext, iobj))			/*  for both debug and ship builds. */
		return ErrReleaseRunToFormat(plsc, plsfrun->plsrun, lserrInvalidObjectIdFetched);

	/* here we are catching for situatuion when client adding text dnode to a chunk to 
	which nominal to ideal has been applied, such situation will lead later to applying nominal
	to ideal twice to the same dnode, and this text doesn't like */
	AssertImplies(iobj == IobjTextFromLsc(&plsc->lsiobjcontext),
				  !FNTIAppliedToLastChunk(PlschunkcontextFromSubline(plssublOld)));
	if (iobj == IobjTextFromLsc(&plsc->lsiobjcontext) &&
		FNTIAppliedToLastChunk(PlschunkcontextFromSubline(plssublOld)))
		return ErrReleaseRunToFormat(plsc, plsfrun->plsrun, lserrFormattingFunctionDisabled);


	plsim = PLsimFromLsc(&plsc->lsiobjcontext, iobj);

	if (iobj != IobjTextFromLsc(&plsc->lsiobjcontext))
		{
		TurnOffAllSimpleText(plsc);  /* not text */
		TurnOnForeignObjectEncounted(plsc);
		
		if (FNominalToIdealEncounted(plsc))
			{
			lserr = ApplyNominalToIdeal(PlschunkcontextFromSubline(plssublOld), &plsc->lsiobjcontext,
				plsc->grpfManager, plsc->lsadjustcontext.lskj,
				FIsSubLineMain(plssublOld),	FLineContainsAutoNumber(plsc),
				plsdnCurrent);
			if (lserr != lserrNone)
				return ErrReleaseRunToFormat(plsc, plsfrun->plsrun, lserr);
			
			/* we should recalculate plsdnCurrent because nominal to ideal can destroy last dnode */
			plsdnCurrent = GetCurrentDnode(plsc);
			pplsdnToStoreNext = GetWhereToPutLink(plsc, plsdnCurrent);
			}
		
		} 

	FlushNTIAppliedToLastChunk(PlschunkcontextFromSubline(plssublOld));

	/* creating border dnodes */
	/* skip back pen dnodes */
	while (plsdnCurrent != NULL && FIsDnodePen(plsdnCurrent)) 
		{
		plsdnCurrent = plsdnCurrent->plsdnPrev;
		}

	if (FDnodeHasBorder(plsdnCurrent) && 
		!(FIsDnodeBorder(plsdnCurrent) && !FIsDnodeOpenBorder(plsdnCurrent))) /* previous dnode has unclosed border */
		/* condition in if looks superfluous but it works correctly even if dnodes deleting
		happend during formatting */
		{
		if (plsfrun->plschp->fBorder)
			{
			/* check that client wants to border runs together */
			lserr = plsc->lscbk.pfnFInterruptBorder(plsc->pols, plsdnCurrent->u.real.plsrun,
				plsfrun->plsrun, &fInterruptBorder);
			if (lserr != lserrNone)
				return ErrReleaseRunToFormat(plsc, plsfrun->plsrun, lserr);

			if (fInterruptBorder)
				{
				/* close previous border and open new one */
				lserr = CloseCurrentBorder(plsc);
				if (lserr != lserrNone)
					return ErrReleaseRunToFormat(plsc, plsfrun->plsrun, lserr);
				lserr = OpenBorder(plsc, plsfrun->plsrun);
				if (lserr != lserrNone)
					return ErrReleaseRunToFormat(plsc, plsfrun->plsrun, lserr);
				}
			fBordered = fTrue;
			}
		else
			{
			lserr = CloseCurrentBorder(plsc);
			if (lserr != lserrNone)
				return ErrReleaseRunToFormat(plsc, plsfrun->plsrun, lserr);
			}
		}
	else
		{
		if (plsfrun->plschp->fBorder)
			{
			if 	(fInsideBorderUp)
				{
				/* border is open on upper level: turn off border flag */
				((PLSCHP) (plsfrun->plschp))->fBorder = fFalse;
				}
			else
				{
				lserr = OpenBorder(plsc, plsfrun->plsrun);
				if (lserr != lserrNone)
					return ErrReleaseRunToFormat(plsc, plsfrun->plsrun, lserr);
				fBordered = fTrue;
				}
			}
		}

	/* we always create real dnode and change it for pen if needed in Finish method */
	CreateRealDnode(plsc, plsdnNew, plsfrun);
	plsdnNew->fInsideBorder = fInsideBorderUp || fBordered;

	/* initialization of fmti    */


	fmti.lsfgi.fFirstOnLine = FIsFirstOnLine(plsdnNew) && FIsSubLineMain(plssublOld);
	fmti.lsfgi.cpFirst = GetCurrentCpLim(plsc);
	fmti.lsfgi.urPen = GetCurrentUr(plsc);
	fmti.lsfgi.vrPen = GetCurrentVr(plsc);

	fmti.lsfgi.urColumnMax = urColumnMax;
	
	fmti.lsfgi.lstflow = plssublOld->lstflow;
	fmti.lsfrun = *plsfrun;
	fmti.plsdnTop = plsdnNew;


	lserr = plsc->lscbk.pfnGetRunTextMetrics(plsc->pols, fmti.lsfrun.plsrun,
								   lsdevReference, fmti.lsfgi.lstflow, &fmti.lstxmRef);
	if (lserr != lserrNone)
		{
		DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
			plsdnNew, plsc->fDontReleaseRuns);
		return lserr;
		}

	if (plsc->lsdocinf.fPresEqualRef)
		fmti.lstxmPres = fmti.lstxmRef;
	else
		{
		lserr = plsc->lscbk.pfnGetRunTextMetrics(plsc->pols, fmti.lsfrun.plsrun,
									   lsdevPres, fmti.lsfgi.lstflow,
										   &fmti.lstxmPres);
		if (lserr != lserrNone)
			{
			DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
				plsdnNew, plsc->fDontReleaseRuns);
			return lserr;
			}
		}


	plnobj = PlnobjFromLsc(plsc, iobj);


	if (plnobj == NULL)
		{
		lserr = CreateLNObjInLsc(plsc, iobj);
		if (lserr != lserrNone) 
			{
			DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
				plsdnNew, plsc->fDontReleaseRuns);
			return lserr;
			}
		plnobj = PlnobjFromLsc(plsc, iobj);
		}

	/* set dnode to finish */
	SetDnodeToFinish(plsc, plsdnNew);
	/* set current subline to NULL */
	SetCurrentSubline(plsc, NULL);
	
	if (cbreakrec == 0)
		{
		lserr = plsim->pfnFmt(plnobj, &fmti, pfmtres);
		}
	else{
		if (plsim->pfnFmtResume == NULL)
			return lserrInvalidBreakRecord;
		lserr = plsim->pfnFmtResume(plnobj, rgbreakrec, cbreakrec, &fmti, pfmtres);
		}

	if (lserr != lserrNone) 
		{
		if (plsc->lslistcontext.plsdnToFinish != NULL) /* dnode hasn't added to list */
			DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
				plsdnNew, plsc->fDontReleaseRuns);
		/* we should restore dnode to finish  and current subline  to properly handle
		error on upper level */
		SetCurrentSubline(plsc, plssublOld);
		SetDnodeToFinish(plsc, plsdnToFinishOld);
		return lserr;
		}

	AssertValidFmtres(*pfmtres); 

	if (GetCurrentSubline(plsc) != NULL || GetDnodeToFinish(plsc) != NULL)
		{
		/* we should restore dnode to finish  and current subline  to properly handle
		error on upper level */
		SetCurrentSubline(plsc, plssublOld);
		SetDnodeToFinish(plsc, plsdnToFinishOld);
		return lserrUnfinishedDnode;
		}

	/* restore dnode to finish  and current subline */
	SetCurrentSubline(plsc, plssublOld);
	SetDnodeToFinish(plsc, plsdnToFinishOld);

	/* to avoid all problems with deleteing dnodes we don't use plsdnNew */
	plsdnLast = GetCurrentDnodeSubl(plssublOld);

	/* case of tab */
	if (*pfmtres == fmtrTab)
		{	
		plsdnLast->fTab = fTrue;
		/* caller later can skip this tab so we prepare zero values */
		Assert(FIsDnodeReal(plsdnLast));
		Assert(IdObjFromDnode(plsdnLast) == IobjTextFromLsc(&plsc->lsiobjcontext));

		TurnOffAllSimpleText(plsc);  /* not text */
		}

	/* case of splat */
	if (*pfmtres == fmtrStopped && plsdnLast != NULL && FIsDnodeSplat(plsdnLast))
		{
		lserr = HandleSplat(plsc, pfmtres);
		if (lserr != lserrNone)
			return lserr;  
		/* Handle splat can delete plsdnLast */
		plsdnLast = GetCurrentDnodeSubl(plssublOld);
		}

	/* in a case of exceeded margin or hard break or tab (so all values of fmtres but fmtrCompletedRun)  */
	/* we need apply nominal to ideal to have correct lenght */
	if (*pfmtres != fmtrCompletedRun && plsdnLast != NULL && FNominalToIdealEncounted(plsc))
		{	
		if (*pfmtres == fmtrTab || FIsDnodeSplat(plsdnLast)) 
			plsdnNomimalToIdeal = plsdnLast->plsdnPrev;
		else
			plsdnNomimalToIdeal = plsdnLast;

		lserr = ApplyNominalToIdeal(PlschunkcontextFromSubline(plssublOld), &plsc->lsiobjcontext,
									plsc->grpfManager, plsc->lsadjustcontext.lskj,
									FIsSubLineMain(plssublOld),	FLineContainsAutoNumber(plsc),
									plsdnNomimalToIdeal);
		if (lserr != lserrNone)
			return lserr;  

		/* ApplyNominalToIdeal can delete plsdnLast */
		plsdnLast = GetCurrentDnodeSubl(plssublOld);
		/* if we run nominal to ideal because of tab chunk of text to which
		nominal to ideal is applied is not last chunk */
		if (*pfmtres == fmtrTab || FIsDnodeSplat(plsdnLast)) 
			FlushNTIAppliedToLastChunk(PlschunkcontextFromSubline(plssublOld));

		/* in a case of exceeded right margin we should extract dcpMaxContext characters 
		   because after fetching further result of nominal to ideal can be different for these
		   characters: examples ligatures or kerning */
		if (*pfmtres == fmtrExceededMargin && 
			FNeedToCutPossibleContextViolation(plsc, plsdnLast))
			{
			lserr = CutPossibleContextViolation(PlschunkcontextFromSubline(plssublOld),
												plsdnLast);
			if (lserr != lserrNone)
				return lserr; 
			/* such procedure also can delete plsdnLast */
			plsdnLast = GetCurrentDnodeSubl(plssublOld);
			}

		} 

	if (iobj != IobjTextFromLsc(&plsc->lsiobjcontext))
	/* only in this case there is a possibility to apply width modification 
	to preceding character */
		{
		/* we are actually applying width modification to preceding character if first
		dnode produced by formating is non text */
	   /* we can't relly on plsdnLast here because of such Finish methods as 
	   FinishByOneCharacter and FinishBySubline */
		/* we still rely here on pplsdnToStoreNext in other words we assume that
		plsdnCurrent (the current dnode in the begining of our procedure ) has not been
		deleted during nominal to ideal. To prove this we use that nominal to ideal has been
		already applied to plsdnCurrent*/
		plsdnNext = *pplsdnToStoreNext;
		Assert(plsdnNext == NULL || FIsLSDNODE(plsdnNext));
		if (FNominalToIdealEncounted(plsc) && 
			plsdnNext != NULL && 
			FIsDnodeReal(plsdnNext) &&
			IdObjFromDnode(plsdnNext) != IobjTextFromLsc(&plsc->lsiobjcontext)
			)
			{
				lserr = ApplyModWidthToPrecedingChar(PlschunkcontextFromSubline(plssublOld),
										&plsc->lsiobjcontext, plsc->grpfManager, 
										plsc->lsadjustcontext.lskj, plsdnNext);
			if (lserr != lserrNone)
				return lserr; 
			} 
		}


	
	return lserrNone;
}


/* ---------------------------------------------------------------------- */

/* Q U I C K  F O R M A T T I N G */
/*----------------------------------------------------------------------------
    %%Function: QuickFormatting
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsfrun		-		(IN) given run
	urColumnMax		-	(IN) right margin where to stop
	pfGeneral		-	(OUT) quick formatting was stopped: we should use general formatting 
	pfHardStop		-	(OUT) formatting ended with hard break
	pcpLim		-		(OUT) cpLim after procedure
	pur			-		(OUT) pen position after procedure

Works only with text runs without nominal to ideal and without tabs.
Stops if condition below is broken. 
----------------------------------------------------------------------------*/


LSERR 	QuickFormatting(PLSC plsc, LSFRUN* plsfrun,	long urColumnMax,
					    BOOL* pfGeneral, BOOL* pfHardStop,	
					    LSCP* pcpLim, long* pur)	

	{
	
	struct fmtin fmti;
	LSLINFO* plslinfoText;
	DWORD iobjText;
	PLNOBJ plnobjText;
	PLSLINE plsline;
	BOOL fHidden;
	const POLS pols = plsc->pols;
	BOOL fGeneral;
	FMTRES fmtres = fmtrCompletedRun;
	LSERR lserr;
	PLSDNODE plsdnNew;
	PLSSUBL plssubl;
	
	iobjText = IobjTextFromLsc(&(plsc->lsiobjcontext));
	plnobjText = PlnobjFromLsc(plsc, iobjText);
	plssubl = GetCurrentSubline(plsc);
	
	fmti.lsfrun = *plsfrun;
	fmti.lsfgi.fFirstOnLine = TRUE;
	fmti.lsfgi.cpFirst = GetCurrentCpLim(plsc);
	fmti.lsfgi.vrPen = GetCurrentVr(plsc);
	fmti.lsfgi.urPen = GetCurrentUr(plsc);
	fmti.lsfgi.lstflow = plssubl->lstflow;
	fmti.lsfgi.urColumnMax = urColumnMax;
	
	
	plsline = plsc->plslineCur;
	plslinfoText = &(plsline->lslinfo);
	
	fGeneral = fFalse;
	fHidden = fFalse;  /* in InitTextParams we already skipped all vanished text  */
	
	
	
	for (;;)						/* "break" exits quick-format loop */
		{							
		/* Run has been alreary fetched */
		
		/*we don't want to handle here vanished text, foreign object, nominal to ideal */
		if ( FRunIsNotSimple(fmti.lsfrun.plschp, fHidden))
			{
			/* we should release run here, in general procedure we will fetch it again */
			if (!plsc->fDontReleaseRuns)
				{
				
				lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, fmti.lsfrun.plsrun);
				if (lserr != lserrNone)
					return lserr;
				}			
			fGeneral = fTrue;			
			break;						
			}
		
		/*Create dnode for text;     */
		CreateRealDnode(plsc, plsdnNew, &fmti.lsfrun);
		
		SetDnodeToFinish(plsc, plsdnNew);
		
		/*		prepare fmtin     */
		fmti.plsdnTop = plsdnNew;

		
		lserr = plsc->lscbk.pfnGetRunTextMetrics(pols, fmti.lsfrun.plsrun,
			lsdevReference, fmti.lsfgi.lstflow, &fmti.lstxmRef);
		if (lserr != lserrNone)
			{
			DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
				plsdnNew, plsc->fDontReleaseRuns);
			return lserr;
			}
		
		if (plsc->lsdocinf.fPresEqualRef)
			{
			fmti.lstxmPres = fmti.lstxmRef;
			}
		else
			{
			lserr = plsc->lscbk.pfnGetRunTextMetrics(pols, fmti.lsfrun.plsrun,
				lsdevPres, fmti.lsfgi.lstflow,
				&fmti.lstxmPres);
			if (lserr != lserrNone)
				{
				DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
					plsdnNew, plsc->fDontReleaseRuns);
				return lserr;
				}
			}
		
		SetCurrentSubline(plsc, NULL);
		lserr = FmtText(plnobjText, &fmti, &fmtres);
		if (lserr != lserrNone)
			{
			if (plsc->lslistcontext.plsdnToFinish != NULL) /* dnode hasn't added to list */
				DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
				plsdnNew, plsc->fDontReleaseRuns);
			return lserr;
			}
		/* restore current subline */
		SetCurrentSubline(plsc, plssubl);

		if (fmtres == fmtrTab )  /* tab: we quite from quick loop deleting this dnode
				because we will append it again in FormatGeneralCase  */
			{
			lserr = UndoLastDnode(plsc);  /* dnode is already in list  */
			if (lserr != lserrNone)
				return lserr;
			fGeneral = fTrue;
			break;
			}
			
			
		AssertValidFmtres(fmtres); 
			
		SetHeightToMax(plslinfoText, &(plsdnNew->u.real.objdim));
			
		if (FIsDnodeSplat(plsdnNew))
			{
			lserr = HandleSplat(plsc, &fmtres);
			if (lserr != lserrNone)
				return lserr;
			}

		if (fmtres != fmtrCompletedRun)
			{
			/*  after break we should check that final heights is not zero	*/
			/* otherwise  we take heights from last run */
			/* so we will have correct line height after quick break */
			if (plslinfoText->dvrAscent == 0 && plslinfoText->dvrDescent == 0)
				{
				plslinfoText->dvrAscent = fmti.lstxmRef.dvAscent;
				plslinfoText->dvpAscent = fmti.lstxmPres.dvAscent;
				plslinfoText->dvrDescent = fmti.lstxmRef.dvDescent;
				plslinfoText->dvpDescent = fmti.lstxmPres.dvDescent;
				plslinfoText->dvpMultiLineHeight = dvHeightIgnore;
				plslinfoText->dvrMultiLineHeight = dvHeightIgnore;		
				}	
			break;
			}
		
		/*	prepare next iteration;  */
			
		fmti.lsfgi.fFirstOnLine = fFalse;
		fmti.lsfgi.urPen = GetCurrentUr(plsc);
		fmti.lsfgi.cpFirst = GetCurrentCpLim(plsc);
			
		lserr = plsc->lscbk.pfnFetchRun(pols, fmti.lsfgi.cpFirst,
			&fmti.lsfrun.lpwchRun,
			&fmti.lsfrun.cwchRun,
			&fHidden, (LSCHP *)fmti.lsfrun.plschp,
			&fmti.lsfrun.plsrun);
		if (lserr != lserrNone)
			return lserr;

		Assert(fmti.lsfrun.cwchRun > 0);
			
		}		/* for (;;) */
	
	
	
	/* prepare output */
	*pfGeneral = fGeneral;
	*pfHardStop = (fmtres == fmtrStopped);
	*pcpLim = GetCurrentCpLim(plsc);
	*pur = GetCurrentUr(plsc);
	
	return lserrNone;
	
	}


/* C H E C K  N E W  P A R A */
/*----------------------------------------------------------------------------
    %%Function: CheckNewPara
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	cpPrev			-   (IN) cp in old paragraph
	cpThis			-	(IN) cp in new paragraph
	pfQuit			-	(OUT) stop formatting because new paragraph is not compatible with old

    Handles leaping from paragraph to paragraph (due to vanished text) on
	behalf of FetchAppendEscCore().  If the new paragraph is compatible
	with the old one, FetchPap is called and text is informed of the
	new para end parameters.
----------------------------------------------------------------------------*/
static LSERR CheckNewPara(PLSC plsc, LSCP cpPrev, LSCP cpThis, BOOL* pfQuit)
{
	LSERR lserr;
	BOOL  fHazard;
	LSPAP lspap;
	DWORD iobjText; 
	PLNOBJ plnobjText;  

	*pfQuit = fTrue;

	Assert(cpThis >= 0 && cpThis > cpPrev);


		

	lserr = plsc->lscbk.pfnCheckParaBoundaries(plsc->pols, cpPrev, cpThis, &fHazard);
	if (lserr != lserrNone)
		return lserr;

	if (!fHazard)
		{

		lserr = plsc->lscbk.pfnFetchPap(plsc->pols, cpThis, &lspap);
			if (lserr != lserrNone)
			return lserr;

		/* we don't know are we really in a new paragraph or not */
		/* so we have to modify information about end of paragraph */
		/* always as would we are in a new paragraph */
		iobjText = IobjTextFromLsc(&plsc->lsiobjcontext);
		plnobjText = PlnobjFromLsc(plsc, iobjText);

		lserr = ModifyTextLineEnding(plnobjText, lspap.lskeop);
		if (lserr != lserrNone)
			return lserr;    
		
		SetCpInPara(plsc->lstabscontext, cpThis);
		plsc->fLimSplat = lspap.grpf & fFmiLimSplat;
		plsc->fIgnoreSplatBreak = lspap.grpf & fFmiIgnoreSplatBreak;

		/* we don't invalidate tabs info and other paragraph properties 
		/* that we stored in context */

		*pfQuit = fFalse;
		}

	return lserr;
}


/* F L I M I T  R U N  E S C */
/*----------------------------------------------------------------------------
    %%Function: FLimitRunEsc
    %%Contact: igorzv
Parameters:
	plsfrun		-	(IN) run to cut
	plsesc		-	(IN) set of esc characters
	iescLim		-	(IN) number of esc characters 

    On behalf of LsFetchAppendEscCore(), this routine limits a run when
	an escape character is present.
----------------------------------------------------------------------------*/
static BOOL FLimitRunEsc(LSFRUN* plsfrun, const LSESC* plsesc, DWORD iescLim)
{
	DWORD iesc;
	DWORD ich;
	const LPCWSTR pwch = plsfrun->lpwchRun;
	const DWORD ichLim = plsfrun->cwchRun;

	Assert(iescLim > 0);	/* optimization -- test before calling */

	for (ich=0;  ich<ichLim;  ich++)
		{
		for (iesc=0;  iesc<iescLim;  iesc++)
			{

			if (FBetween(pwch[ich], plsesc[iesc].wchFirst, plsesc[iesc].wchLast))
				{
				plsfrun->cwchRun = ich;
				return fTrue;
				}
			}
		}
	return fFalse;
}



/* F O R M A T  A N M */
/*----------------------------------------------------------------------------
    %%Function: FormatAnm
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsfrunMainText	-	(IN) first run of the main text

    Formats and allignes bullets and numbering
----------------------------------------------------------------------------*/

LSERR FormatAnm(PLSC plsc, PLSFRUN plsfrunMainText)
{
	long duaSpaceAnm;
	long duaWidthAnm;
	LSKALIGN lskalignAnm;
	WCHAR wchAdd;
	BOOL fWord95Model;
	LSERR lserr;
	LSFRUN lsfrun;
	LSCHP lschp;  /* local memory to store lschp */
	FMTRES fmtres;
	long durUsed;
	long urOriginal;
	long durAfter = 0;
	long durBefore = 0;
	LSCP cpLimOriginal;
	OBJDIM* pobjdimAnm;
	PLSDNODE plsdnAllignmentTab;
	BOOL fInterruptBorder;
	LSCHP lschpAdd; /* lschp for character added after autonumber */
	PLSRUN plsrunAdd; /* plsrun for character added after autonumber */


	Assert(FIsLSC(plsc)); 
	Assert(FFormattingAllowed(plsc)); 


	/*Initialization;    */
	lsfrun.plschp = &lschp;
	cpLimOriginal = GetCurrentCpLim(plsc);
	urOriginal = GetCurrentUr(plsc);
	SetCurrentCpLim(plsc, cpFirstAnm); 

	/* get autonumbering information */
	lserr = plsc->lscbk.pfnGetAutoNumberInfo(plsc->pols, &lskalignAnm, &lschp, &lsfrun.plsrun,
							&wchAdd, &lschpAdd, &plsrunAdd, 
							&fWord95Model, &duaSpaceAnm, &duaWidthAnm);
	if (lserr != lserrNone)
			return lserr;

	Assert(!memcmp(&lschp, &lschpAdd, sizeof(lschpAdd)));

	lsfrun.cwchRun = 0 ; /* we dont use characters in formating autonumbering object */
	lsfrun.lpwchRun = NULL;

	/* put idobj of autonumber to lschp */
	lschp.idObj = (WORD) IobjAutonumFromLsc(&plsc->lsiobjcontext);

	/* remove underlining and some other bits from chp */
	/* we don't underline it as a whole */
	lschp.fUnderline = fFalse;
	lschp.fStrike = fFalse;
	lschp.fShade = fFalse;
	lschp.EffectsFlags = 0;

	lserr = ProcessOneRun(plsc, uLsInfiniteRM, &lsfrun, NULL,
						  0, &fmtres);
	if (lserr != lserrNone)
		return lserr;

	Assert(fmtres == fmtrCompletedRun);
	Assert(GetCurrentDnode(plsc) != NULL);


	/* store heights of autonumber */
	Assert(FIsDnodeReal(GetCurrentDnode(plsc)));
	pobjdimAnm = &(GetCurrentDnode(plsc)->u.real.objdim);
	plsc->plslineCur->lslinfo.dvpAscentAutoNumber = pobjdimAnm->heightsPres.dvAscent;
	plsc->plslineCur->lslinfo.dvrAscentAutoNumber = pobjdimAnm->heightsRef.dvAscent;
	plsc->plslineCur->lslinfo.dvpDescentAutoNumber = pobjdimAnm->heightsPres.dvDescent;
	plsc->plslineCur->lslinfo.dvrDescentAutoNumber = pobjdimAnm->heightsRef.dvDescent;


	if (wchAdd != 0)  /* fill in lsfrun with a run of one character */
		{
		lsfrun.plschp = &lschpAdd;
		lsfrun.plsrun = plsrunAdd;
		lsfrun.lpwchRun = &wchAdd;
		lsfrun.cwchRun = 1;
		
		lserr = ProcessOneRun(plsc, uLsInfiniteRM, &lsfrun, NULL,
			0, &fmtres);
		if (lserr != lserrNone)
			return lserr;
		
		Assert(fmtres == fmtrCompletedRun || fmtres == fmtrTab);
		}

	plsdnAllignmentTab = GetCurrentDnode(plsc); /* in the case when added character is not tab this
												   value will not be used */

	if (lsfrun.plschp->fBorder)
		{
		if (plsfrunMainText->plschp->fBorder)
			{
			/* check that client wants to border runs together */
			lserr = plsc->lscbk.pfnFInterruptBorder(plsc->pols, 
				lsfrun.plsrun, plsfrunMainText->plsrun, &fInterruptBorder);
			if (lserr != lserrNone)
				return lserr;
			
			if (fInterruptBorder)
				{
				/* we should close border before allignment */
				lserr = CloseCurrentBorder(plsc);
				if (lserr != lserrNone)
					return lserr;
				}
			}
		else
			{
			/* we should close border before allignment */
			lserr = CloseCurrentBorder(plsc);
			if (lserr != lserrNone)
				return lserr;
			}
		}

	durUsed = GetCurrentUr(plsc) - urOriginal; 

	if (fWord95Model)
		{
		Assert(wchAdd != 0);
		Assert(fmtres == fmtrTab);

		AllignAutonum95(UrFromUa(LstflowFromSubline(GetCurrentSubline(plsc)),
							&(plsc->lsdocinf.lsdevres), duaSpaceAnm),
						UrFromUa(LstflowFromSubline(GetCurrentSubline(plsc)),
							&(plsc->lsdocinf.lsdevres), duaWidthAnm),
						lskalignAnm, durUsed, plsdnAllignmentTab,
						&durBefore, &durAfter);
		}
	else
		{
		lserr = AllignAutonum(&(plsc->lstabscontext), lskalignAnm, 
							(wchAdd != 0 && fmtres == fmtrTab),
					        plsdnAllignmentTab, GetCurrentUr(plsc), 
					        durUsed, &durBefore, &durAfter);
		if (lserr != lserrNone)
			return lserr;
		/* if there is no allignment after then durAfter should be zero */
		Assert(!((durAfter != 0) && (!(wchAdd != 0 && fmtres == fmtrTab))));
		}

	/* change geometry because of durBefore  */
	plsc->lsadjustcontext.urStartAutonumberingText = 
		plsc->lsadjustcontext.urLeftIndent + durBefore;
	AdvanceCurrentUr(plsc, durBefore);
	
	/* change geometry because of durAfter */
	AdvanceCurrentUr(plsc, durAfter);

	plsc->lsadjustcontext.urStartMainText = GetCurrentUr(plsc);

	/* restore cpLim   */
	SetCurrentCpLim(plsc, cpLimOriginal);
	
	return lserrNone;
}

#define iobjAutoDecimalTab		(idObjTextChp-1)

/* I N I T I A L I Z E  A U T O  D E C  T A B	 */
/*----------------------------------------------------------------------------
    %%Function: InitializeAutoDecTab
    %%Contact: igorzv
Parameters:
	plsc				-	(IN) ptr to line services context
	durAutoDecimalTab	-	(IN) auto decimal tab offset 

    Creates tab stop record and dnode for "auto-decimal tab"
----------------------------------------------------------------------------*/


LSERR InitializeAutoDecTab(PLSC plsc, long durAutoDecimalTab) 

	{
	PLSDNODE plsdnTab;
	LSERR lserr;
	LSKTAB lsktab;
	BOOL fBreakThroughTab;
	LSCP cpLimOriginal;
	
	if (durAutoDecimalTab > GetCurrentUr(plsc))  
		{
		cpLimOriginal = GetCurrentCpLim(plsc);
		SetCurrentCpLim(plsc, LONG_MIN + 1); 

		lserr = InitTabsContextForAutoDecimalTab(&plsc->lstabscontext, durAutoDecimalTab);
		if (lserr != lserrNone)
			return lserrNone;

		CreateDnode(plsc, plsdnTab);  

		*(GetWhereToPutLink(plsc, plsdnTab->plsdnPrev)) = plsdnTab;
		SetCurrentDnode(plsc, plsdnTab); 

		/* fill in this dnode */
		memset(&plsdnTab->u.real.objdim, 0, sizeof(OBJDIM));
		memset(&plsdnTab->u.real.lschp, 0, sizeof(LSCHP));
		plsdnTab->u.real.lschp.idObj = (WORD) IobjTextFromLsc(&plsc->lsiobjcontext);
		plsdnTab->fTab = fTrue;
		plsdnTab->fAutoDecTab = fTrue;
		plsdnTab->cpLimOriginal = cpLimOriginal; /* it's important to display to put correct value here */
		plsdnTab->dcp = 0;

		/* If PrepareLineToDisplay is not called, this dnode will not convert to pen and will destroyed
		   as real dnode. So we need to put NULL to plsrun, pdobj, pinfosubl*/
		plsdnTab->u.real.plsrun = NULL;
		plsdnTab->u.real.pdobj = NULL;
		plsdnTab->u.real.pinfosubl = NULL;

		lserr = GetCurTabInfoCore(&plsc->lstabscontext, plsdnTab, GetCurrentUr(plsc),
								  fFalse, &lsktab, &fBreakThroughTab);			
		if (lserr != lserrNone)
			return lserr;

		TurnOnTabEncounted(plsc);
		if (lsktab != lsktLeft)
			TurnOnNonLeftTabEncounted(plsc);

		/* restore cpLim   */
		SetCurrentCpLim(plsc, cpLimOriginal);

		TurnOnAutodecimalTabPresent(plsc);	
		}
	return lserrNone;
	}

/* H A N D L E  T A B	 */
/*----------------------------------------------------------------------------
    %%Function: HandleTab
    %%Contact: igorzv
Parameters:
	plsc				-	(IN) ptr to line services context

    Wraper around calls to tabutils module.
----------------------------------------------------------------------------*/

LSERR HandleTab(PLSC plsc)	
{
	LSKTAB lsktab; 
	LSERR lserr;
	BOOL fBreakThroughTab;
	long durPendingTab;
	long urNewMargin;

	/* if we are not on a stage of a formatting this procedure resolve previous tab if any */

	/* before tab calculation we should resolve pending tab */
	lserr = ResolvePrevTabCore(&plsc->lstabscontext, GetCurrentDnode(plsc),
							  GetCurrentUr(plsc), &durPendingTab);
	if (lserr != lserrNone) 
		return lserr;
	/* move current pen position */
	Assert(durPendingTab >= 0);
	AdvanceCurrentUr(plsc, durPendingTab);

	if (FFormattingAllowed(plsc))
		{
		/* in this case we are called only after tab */
		Assert(GetCurrentDnode(plsc)->fTab);
		lserr = GetCurTabInfoCore(&plsc->lstabscontext, GetCurrentDnode(plsc), GetCurrentUr(plsc),
			fFalse, &lsktab, &fBreakThroughTab);			
		if (lserr != lserrNone)
			return lserr;

		TurnOnTabEncounted(plsc);
		if (lsktab != lsktLeft)
			TurnOnNonLeftTabEncounted(plsc);

		/* move current pen position */
		AdvanceCurrentUr(plsc, DurFromDnode(GetCurrentDnode(plsc)));

		if (fBreakThroughTab)
			{
			lserr = GetMarginAfterBreakThroughTab(&plsc->lstabscontext, GetCurrentDnode(plsc),
												  &urNewMargin);
			if (lserr != lserrNone)
				return lserr;
			
			SetBreakthroughLine(plsc, urNewMargin);
			}
		}
	return lserrNone;
}

#define idObjSplat		idObjTextChp - 2

/* H A N D L E  S P L A T */
/*----------------------------------------------------------------------------
    %%Function: HandleSplat
    %%Contact: igorzv
Parameters:
	plsc				-	(IN) ptr to line services context
	pfmtres				-	(OUT) fmtres of the splat dnode, procedure can change it
							in the case of fIgnoreSplatBreak to either fmtrCompletedRun 
							or fmtrStopped

    Markes dnode for splat, deletes it in a case of fIgnoreSplatBreak
----------------------------------------------------------------------------*/

LSERR HandleSplat(PLSC plsc, FMTRES* pfmtres)	
	{
	PLSDNODE plsdn;
	LSCP cpAfterSplat;
	BOOL fQuit;
	LSERR lserr;

	plsdn = GetCurrentDnode(plsc);
	cpAfterSplat = GetCurrentCpLim(plsc);

	if (plsc->fIgnoreSplatBreak)
		{
		lserr = CheckNewPara(plsc, cpAfterSplat - 1, cpAfterSplat, &fQuit);
		if (lserr != lserrNone)
			return lserr;
		
		if (fQuit)
			{
			/* despite plsc->fIgnoreSplatBreak we should stop formatting here */
			*pfmtres = fmtrStopped;
			}
		else
			{
			*pfmtres = fmtrCompletedRun;
			}
		
		/* delete splat dnode */
		/* break link   */
		*(GetWhereToPutLink(plsc, plsdn->plsdnPrev)) = NULL;
		
		/* restore current dnode, don't change cpLim and geometry */
		SetCurrentDnode(plsc, plsdn->plsdnPrev);
		
		Assert(plsdn->plsdnNext == NULL);
		lserr =	DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
			plsdn, plsc->fDontReleaseRuns);
		if (lserr != lserrNone)
			return lserr;
		
		
		}
	else
		{
		
		/* set special idobj that will solve all chunk group chunk problems */
		Assert(FIsDnodeReal(plsdn));
		plsdn->u.real.lschp.idObj = idObjSplat;
		TurnOffAllSimpleText(plsc);  /* not simple text */
		
		}

	return lserrNone;
	}

/* C R E A T E  S U B L I N E  C O R E	 */
/*----------------------------------------------------------------------------
    %%Function: CreateSublineCore
    %%Contact: igorzv
Parameters:
	plsc		-	(IN) ptr to line services context
	cpFirst		-	(IN) first cp of a subline
	urColumnMax	-	(IN) max possible width of a subline
	lstflow		-	(IN) text flow of a subline
	fContiguos	-	(IN) if TRUE such line has the same coordinate system as main line
						 and is allowed to have tabs

    Allocates, initializes subline structure. Sets subline as current.
----------------------------------------------------------------------------*/

LSERR 	CreateSublineCore(PLSC plsc, LSCP cpFirst, long urColumnMax,
						  LSTFLOW lstflow, BOOL fContiguous)
	{
	PLSSUBL plssubl;
	LSERR lserr;

	Assert(FIsLSC(plsc));
	Assert(FFormattingAllowed(plsc) || FBreakingAllowed(plsc));
	Assert(GetCurrentSubline(plsc) == NULL); 

	plssubl = plsc->lscbk.pfnNewPtr(plsc->pols,
											sizeof(LSSUBL));
	if (plssubl == NULL)
		return lserrOutOfMemory;

	/* fill in structure */
	plssubl->tag = tagLSSUBL;
	plssubl->plsc = plsc;
	plssubl->cpFirst = cpFirst;
	plssubl->lstflow = lstflow;
	plssubl->urColumnMax = urColumnMax;
	plssubl->cpLim = cpFirst;
	plssubl->plsdnFirst = NULL;
	plssubl->plsdnLast = NULL;
	plssubl->fMain = fFalse;
	plssubl->plsdnUpTemp = NULL;
	plssubl->fAcceptedForDisplay = fFalse;
	plssubl->fRightMarginExceeded = fFalse;

	if (fContiguous)
		{
		Assert(FFormattingAllowed(plsc));
		Assert(SublineFromDnode(GetDnodeToFinish(plsc))->fContiguous);
		plssubl->urCur = GetCurrentUrSubl(SublineFromDnode(GetDnodeToFinish(plsc)));
		plssubl->vrCur = GetCurrentVrSubl(SublineFromDnode(GetDnodeToFinish(plsc)));
		}
	else
		{
		plssubl->urCur = 0;
		plssubl->vrCur = 0;
		}
	plssubl->fContiguous = (BYTE) fContiguous;
	plssubl->fDupInvalid = fTrue;

	plssubl->plschunkcontext = plsc->lscbk.pfnNewPtr(plsc->pols,
											sizeof(LSCHUNKCONTEXT));
	if (plssubl->plschunkcontext == NULL)
		return lserrOutOfMemory;

	lserr = AllocChunkArrays(plssubl->plschunkcontext, &plsc->lscbk, plsc->pols,
							 &plsc->lsiobjcontext);
	if (lserr != lserrNone)
		return lserr;
	
	InitSublineChunkContext(plssubl->plschunkcontext, plssubl->urCur, plssubl->vrCur);

	/* allocate break context */
	plssubl->pbrkcontext = plsc->lscbk.pfnNewPtr(plsc->pols,
											sizeof(BRKCONTEXT));
	if (plssubl->pbrkcontext == NULL)
		return lserrOutOfMemory;
	/* set flags */
	plssubl->pbrkcontext->fBreakPrevValid = fFalse;
	plssubl->pbrkcontext->fBreakNextValid = fFalse;
	plssubl->pbrkcontext->fBreakForceValid = fFalse;


	/* set this subline as current */
	SetCurrentSubline(plsc, plssubl);

	IncreaseFormatDepth(plsc);

	return lserrNone;
	}


/* F I N I S H  S U B L I N E  C O R E	 */
/*----------------------------------------------------------------------------
    %%Function: FinishSublineCore
    %%Contact: igorzv
Parameters:
	plssubl		-	(IN) subline to finish

    Applies nominal to ideal to the last chunk of text, flushes current subline
----------------------------------------------------------------------------*/


LSERR   FinishSublineCore(
						 PLSSUBL plssubl)			/* IN: subline to finish	*/
	{
	PLSC plsc;
	LSERR lserr;
	PLSDNODE plsdn;

	Assert(FIsLSSUBL(plssubl));

	plsc = plssubl->plsc;
	Assert(plssubl == GetCurrentSubline(plsc));

	/* apply nominal to ideal to the last chunk of text */
	if (FNominalToIdealEncounted(plsc))
		{
		lserr = ApplyNominalToIdeal(PlschunkcontextFromSubline(plssubl), &plsc->lsiobjcontext,
								plsc->grpfManager, plsc->lsadjustcontext.lskj,
								FIsSubLineMain(plssubl), FLineContainsAutoNumber(plsc),
								GetCurrentDnodeSubl(plssubl));
		if (lserr != lserrNone)
			return lserr; 
		}

	/* skip back pen dnodes */
	plsdn = plssubl->plsdnLast;
	while (plsdn != NULL && FIsDnodePen(plsdn)) 
		{
		plsdn = plsdn->plsdnPrev;
		}

	/* close last border */
	if (FDnodeHasBorder(plsdn) && !FIsDnodeCloseBorder(plsdn))
		{
		lserr = CloseCurrentBorder(plsc);
		if (lserr != lserrNone)
			return lserr;
		}

	/* set boundaries for display */
	SetCpLimDisplaySubl(plssubl, GetCurrentCpLimSubl(plssubl));
	SetLastDnodeDisplaySubl(plssubl, GetCurrentDnodeSubl(plssubl));


	/* flush current subline */
	SetCurrentSubline(plsc, NULL);

	DecreaseFormatDepth(plsc); 

	lserr = LsSublineFinishedText(PlnobjFromLsc(plsc, IobjTextFromLsc(&((plsc)->lsiobjcontext))));
	if (lserr != lserrNone)
		return lserr;

	return lserrNone;
	}

/* U N D O  L A S T  D N O D E	 */
/*----------------------------------------------------------------------------
    %%Function: UndoLastDnode
    %%Contact: igorzv
Parameters:
	plsc		-	(IN) ptr to line services context

    Restores set before last dnode and deletes it.
----------------------------------------------------------------------------*/

static LSERR 	UndoLastDnode(PLSC plsc)
{
	PLSDNODE plsdn = GetCurrentDnode(plsc);
	long cpDecrease;
	
	Assert(FIsLSDNODE(plsdn));

	/* break link   */
	*(GetWhereToPutLink(plsc, plsdn->plsdnPrev)) = NULL;

	/* restore state */
	cpDecrease = plsdn->dcp;
	AdvanceCurrentCpLim(plsc, -cpDecrease);
	SetCurrentDnode(plsc, plsdn->plsdnPrev);
	AdvanceCurrentUr(plsc, -DurFromDnode(plsdn)); 
	AdvanceCurrentVr(plsc, -DvrFromDnode(plsdn)); 

	Assert(plsdn->plsdnNext == NULL);
	return 	DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
				plsdn, plsc->fDontReleaseRuns);


}

/* O P E N  B O R D E R	 */
/*----------------------------------------------------------------------------
    %%Function: OpenBorder
    %%Contact: igorzv
Parameters:
	plsc		-	(IN) ptr to line services context
	plsrun		-	(IN) run with border information

    Creates border dnode
----------------------------------------------------------------------------*/
static LSERR  OpenBorder(PLSC plsc, PLSRUN plsrun)
	{
	PLSDNODE plsdnCurrent;
	PLSDNODE* pplsdnToStoreNext;
	long durBorder, dupBorder;
	PLSDNODE plsdnBorder;
	LSERR lserr;

	plsdnCurrent = GetCurrentDnode(plsc);
	pplsdnToStoreNext = GetWhereToPutLink(plsc, plsdnCurrent);

	lserr = plsc->lscbk.pfnGetBorderInfo(plsc->pols, plsrun, GetCurrentLstflow(plsc),
		&durBorder, &dupBorder);
	if (lserr != lserrNone)
		return lserr;


	CreateBorderDnode(plsc, plsdnBorder, durBorder, dupBorder);
	plsdnBorder->fOpenBorder = fTrue;
	
	/* maintain list and state */
	*pplsdnToStoreNext = plsdnBorder;
	SetCurrentDnode(plsc, plsdnBorder);
	AdvanceCurrentUr(plsc, durBorder);
	TurnOffAllSimpleText(plsc);  /* not simple text */

	return lserrNone;
	}

/* C L O S E  C U R R E N T  B O R D E R	 */
/*----------------------------------------------------------------------------
    %%Function: CloseCurrentBorder
    %%Contact: igorzv
Parameters:
	plsc		-	(IN) ptr to line services context

    Creates border dnode
----------------------------------------------------------------------------*/
LSERR  CloseCurrentBorder(PLSC plsc)
	{
	PLSDNODE plsdnCurrent;
	PLSDNODE* pplsdnToStoreNext;
	long durBorder, dupBorder;
	PLSDNODE plsdnBorder;
	LSERR lserr;
	PLSDNODE plsdn;

	plsdnCurrent = GetCurrentDnode(plsc);
	pplsdnToStoreNext = GetWhereToPutLink(plsc, plsdnCurrent);

	/* find open border */
	plsdn = plsdnCurrent;
	Assert(FIsLSDNODE(plsdn));
	while (! FIsDnodeBorder(plsdn))
		{
		plsdn = plsdn->plsdnPrev;
		Assert(FIsLSDNODE(plsdn));
		}
	Assert(plsdn->fOpenBorder);

	if (plsdn != plsdnCurrent)
		{
		durBorder = plsdn->u.pen.dur;
		dupBorder = plsdn->u.pen.dup;

		CreateBorderDnode(plsc, plsdnBorder, durBorder, dupBorder);
	
		/* maintain list and state */
		*pplsdnToStoreNext = plsdnBorder;
		SetCurrentDnode(plsc, plsdnBorder);
		AdvanceCurrentUr(plsc, durBorder);
		}
	else
		{
		/* we have empty list between borders */
		lserr = UndoLastDnode(plsc);
		if (lserr != lserrNone)
			return lserrNone;
		}

	return lserrNone;
	}

long RightMarginIncreasing(PLSC plsc, long urColumnMax) 
	{
	long Coeff = plsc->lMarginIncreaseCoefficient;
	long urInch;
	long One32rd;
		if (urColumnMax <= 0) 
			{ 
			/* such strange formula for non positive margin is to have on 
			the first iteration 1 inch and 8 inches 	on the second*/
			urInch = UrFromUa(LstflowFromSubline(GetCurrentSubline(plsc)), 
								&(plsc)->lsdocinf.lsdevres,	1440);
			if (Coeff == uLsInfiniteRM || (Coeff >= uLsInfiniteRM / (7 * urInch)))
				return uLsInfiniteRM;
			else
				return (7*Coeff - 6)* urInch; 
			}
		else
			{
			if (urColumnMax <= 32)
				One32rd = 1;
			else
				One32rd = urColumnMax >> 5;
			
			if (Coeff == uLsInfiniteRM || (Coeff >= (uLsInfiniteRM - urColumnMax)/One32rd))
				return uLsInfiniteRM;
			else
				return urColumnMax + (Coeff * One32rd); 
			}
	}

/*----------------------------------------------------------------------------
/* E R R  R E L E A S E  R U N  T O  F O R M A T */
/*----------------------------------------------------------------------------
    %%Function: ErrReleaseRunToFormat
    %%Contact: igorzv
Parameters:
	plsc		-	(IN) ptr to line services context 
	plsrun		-	(IN) ponter to a run structure to be deleted	
	lserr		-	(IN) code of an error	

	Called in a error situation when run has not been formatted yet .
----------------------------------------------------------------------------*/
static LSERR ErrReleaseRunToFormat(PLSC plsc, PLSRUN plsrun, LSERR lserr) 
{
	LSERR lserrIgnore;

	if (!plsc->fDontReleaseRuns)
			lserrIgnore = plsc->lscbk.pfnReleaseRun(plsc->pols, plsrun);

	return lserr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lsenum.c ===
#include "lsenum.h"
#include "lsc.h"
#include "lsline.h"
#include "prepdisp.h"
#include "enumcore.h"


//    %%Function:	LsEnumLine
//    %%Contact:	victork
//
/*
 * Enumerates the formatted line (main subline) (from the given point is fGeometry needed).
 */
	
LSERR WINAPI LsEnumLine(PLSLINE plsline, BOOL fReverseOrder, BOOL fGeometryNeeded, const POINT* pptorg)
{

	PLSC 	plsc;
	LSERR 	lserr;

	if (!FIsLSLINE(plsline)) return lserrInvalidParameter;

	plsc = plsline->lssubl.plsc;
	Assert(FIsLSC(plsc));

	if (plsc->lsstate != LsStateFree) return lserrContextInUse;

	if (fGeometryNeeded)
		{
		lserr = PrepareLineForDisplayProc(plsline);

		plsc->lsstate = LsStateFree;
		
		if (lserr != lserrNone) return lserr;
		}

	plsc->lsstate = LsStateEnumerating;

	lserr = EnumSublineCore(&(plsline->lssubl), fReverseOrder, fGeometryNeeded, 
								pptorg, plsline->upStartAutonumberingText);

	plsc->lsstate = LsStateFree;
	
	return lserr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lsqsubl.c ===
#include "lsc.h"
#include "lsqsubl.h"
#include "lssubl.h"
#include "lsqcore.h"


//    %%Function:	LsQueryCpPpointSubline
//    %%Contact:	victork
//
LSERR WINAPI  LsQueryCpPpointSubline(
							PLSSUBL 	plssubl,			/* IN: pointer to subline info */
							LSCP 		cpQuery,			/* IN: cpQuery */
							DWORD		cDepthQueryMax,		/* IN: allocated size of results array */
							PLSQSUBINFO	plsqsubinfoResults,	/* OUT: array[cDepthFormatMax] of query results */
							DWORD*		pcActualDepth,		/* OUT: size of results array (filled) */
							PLSTEXTCELL	plstextcellInfo)	/* OUT: Text cell info */
{
	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	
	Assert(!plssubl->fDupInvalid);

	return	QuerySublineCpPpointCore(plssubl, cpQuery, cDepthQueryMax, 
									plsqsubinfoResults, pcActualDepth, plstextcellInfo);
}


//    %%Function:	LsQueryPointPcpSubline
//    %%Contact:	victork
//
LSERR WINAPI LsQueryPointPcpSubline(
							PLSSUBL 	plssubl,			/* IN: pointer to subline info */
						 	PCPOINTUV 	ppointuvIn,			/* IN: query point (uQuery,vQuery) (line text flow) */
							DWORD		cDepthQueryMax,		/* IN: allocated size of results array */
							PLSQSUBINFO	plsqsubinfoResults,	/* OUT: array[cDepthFormatMax] of query results */
							DWORD*		pcActualDepth,		/* OUT: size of results array (filled) */
							PLSTEXTCELL	plstextcellInfo)	/* OUT: Text cell info */
{
	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	
	Assert(!plssubl->fDupInvalid);

	return	QuerySublinePointPcpCore(plssubl, ppointuvIn, cDepthQueryMax, 
									plsqsubinfoResults, pcActualDepth, plstextcellInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lsstring.c ===
#include "lsmem.h"
#include <limits.h>

#include "lsstring.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"

/* Internal Functions prototypes */
static LSERR CheckReallocCharArrays(PLNOBJ plnobj, long cwch, long iwchLocalStart, long *cwchCorrect);
static LSERR CheckReallocSpacesArrays(PILSOBJ pobj, long cwSpaces);
static LSERR CopyCharsSpacesToDispList(PLNOBJ plnobj, WCHAR* rgwch, long cwch,
																	long* rgwSpaces, long cwSpaces);
static LSERR CopySpacesToDispList(PLNOBJ plnobj, long iNumOfSpaces, long durSpace);

/* Export Functions implementations */

/*----------------------------------------------------------------------------
    %%Function: GetWidth
    %%Contact: sergeyge
	
	Fetches widths until end of run or right margin

	Uses cache to improve performance
----------------------------------------------------------------------------*/
LSERR GetWidths(PLNOBJ plnobj, PLSRUN plsrun, long iwchStart, LPWSTR lpwch, LSCP cpFirst, long dcp, long durWidthExceed,
											LSTFLOW lstflow, long* pcwchFetched, long* pdurWidth)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long durWidth;
	long cwch;
	long iwchDur;
	long cwchCorrect;
	long cwchIter;
	long durWidthIter;
	BOOL fNothingReturned = fTrue;

	pilsobj = plnobj->pilsobj;

	durWidth = 0;
	cwch = 0;
	iwchDur = iwchStart;
	*pcwchFetched = 0;
	*pdurWidth = 0;

	if (pilsobj->dcpFetchedWidth != 0 && cpFirst == pilsobj->cpFirstFetchedWidth &&
		iwchStart == pilsobj->iwchFetchedWidth && lpwch[0] == pilsobj->wchFetchedWidthFirst)
		{
		Assert(dcp >= pilsobj->dcpFetchedWidth);
		cwch = pilsobj->dcpFetchedWidth;
		durWidth = pilsobj->durFetchedWidth;
/* FormatRegular assumes that First character exceeding right margin will stop GetCharWidth loop;
	Special character could change situation---fix it.
*/
		if (durWidth > durWidthExceed)
			{
			while(cwch > 1 && durWidth - durWidthExceed > pilsobj->pdur[iwchStart + cwch - 1])
				{
				cwch--;
				durWidth -= pilsobj->pdur[iwchStart + cwch];
				}
			}
		dcp -= cwch;
		durWidthExceed -= durWidth;
		iwchDur += cwch;
		fNothingReturned = fFalse;
		}
		
	while (fNothingReturned || dcp > 0 && durWidthExceed >= 0)
		{
		lserr = CheckReallocCharArrays(plnobj, dcp, iwchDur, &cwchCorrect);
		if (lserr != lserrNone) return lserr;

		lserr = (*pilsobj->plscbk->pfnGetRunCharWidths)(pilsobj->pols, plsrun, lsdevReference, 
						&lpwch[cwch], cwchCorrect, (int)durWidthExceed, 
						lstflow, (int*)&pilsobj->pdur[iwchDur], &durWidthIter, &cwchIter);
		if (lserr != lserrNone) return lserr;

		Assert(durWidthIter >= 0);
		Assert(durWidthIter <= uLsInfiniteRM);

		Assert (durWidthIter <= uLsInfiniteRM - durWidth);

		if (durWidthIter > uLsInfiniteRM - durWidth)
			return lserrTooLongParagraph;

		durWidth += durWidthIter;

		durWidthExceed -= durWidthIter;
		iwchDur += cwchIter;
		cwch += cwchIter;
		dcp -= cwchIter;
		fNothingReturned = fFalse;
		}
	

	*pcwchFetched = cwch;
	*pdurWidth = durWidth;

	pilsobj->iwchFetchedWidth = iwchStart;
	pilsobj->cpFirstFetchedWidth = cpFirst;
	pilsobj->dcpFetchedWidth = cwch;
	pilsobj->durFetchedWidth = durWidth;

	return lserrNone;
}


/* F O R M A T  S T R I N G */
/*----------------------------------------------------------------------------
    %%Function: FormatString
    %%Contact: sergeyge
	
	Formats the local run
----------------------------------------------------------------------------*/
LSERR FormatString(PLNOBJ plnobj, PTXTOBJ pdobjText, WCHAR* rgwch, long cwch, 
												long* rgwSpaces, long cwSpaces, long durWidth)
{
	LSERR lserr;
	PILSOBJ pilsobj;

	pilsobj = plnobj->pilsobj;

	lserr = CopyCharsSpacesToDispList(plnobj, rgwch, cwch, rgwSpaces, cwSpaces);
	if (lserr != lserrNone) return lserr;

	/* fill out all related members from strils and output parameters */
	pdobjText->iwchLim = pdobjText->iwchLim + cwch;
	pdobjText->u.reg.iwSpacesLim = pdobjText->u.reg.iwSpacesLim + cwSpaces;

	/* Fix Width Fetching state */
	Assert((long)pilsobj->dcpFetchedWidth >=  cwch);
	Assert(pilsobj->durFetchedWidth >= durWidth);

	pilsobj->iwchFetchedWidth = pilsobj->iwchFetchedWidth + cwch;
	pilsobj->cpFirstFetchedWidth += cwch;
	pilsobj->dcpFetchedWidth -= cwch;
	pilsobj->durFetchedWidth -= durWidth;

	return lserrNone;
}

/* F I L L  R E G U L A R  P R E S  W I D T H S */
/*----------------------------------------------------------------------------
    %%Function: MeasureStringFirst
    %%Contact: sergeyge

	Calculates dur of one character.
----------------------------------------------------------------------------*/
LSERR FillRegularPresWidths(PLNOBJ plnobj, PLSRUN plsrun, LSTFLOW lstflow, PTXTOBJ pdobjText)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	int* rgDup;
	long dupJunk;
	long limDupJunk;

	pilsobj = plnobj->pilsobj;

	if (pilsobj->fDisplay)
		{
		rgDup = (int *)&plnobj->pdup[pdobjText->iwchFirst];

		if (!pilsobj->fPresEqualRef)
			{		
			lserr = (*pilsobj->plscbk->pfnGetRunCharWidths)(pilsobj->pols, plsrun, lsdevPres,
				&pilsobj->pwchOrig[pdobjText->iwchFirst], pdobjText->iwchLim - pdobjText->iwchFirst,
				LONG_MAX, lstflow, rgDup, &dupJunk, &limDupJunk);
			if (lserr != lserrNone) return lserr;
			}
		else            /* fPresEqualRef        */
			{
			memcpy(rgDup, &pilsobj->pdur[pdobjText->iwchFirst], sizeof(long) * (pdobjText->iwchLim - pdobjText->iwchFirst));
			}
		}
	
	return lserrNone;

}


/* G E T  O N E  C H A R  D U P */
/*----------------------------------------------------------------------------
    %%Function: MeasureStringFirst
    %%Contact: sergeyge

	Calculates dur of one character.
----------------------------------------------------------------------------*/
LSERR GetOneCharDur(PILSOBJ pilsobj, PLSRUN plsrun, WCHAR wch, LSTFLOW lstflow, long* pdur)
{
	LSERR lserr;
	long durSumJunk;
	long limDurJunk;

	lserr = (*pilsobj->plscbk->pfnGetRunCharWidths)(pilsobj->pols, plsrun, lsdevReference, &wch, 1, LONG_MAX, lstflow,
													(int*)pdur, &durSumJunk, &limDurJunk);
	if (lserr != lserrNone) return lserr;

	return lserrNone;
}

/* G E T  O N E  C H A R  D U P */
/*----------------------------------------------------------------------------
    %%Function: GetOneCharDup
    %%Contact: sergeyge
	
	Calculates dup of one character
----------------------------------------------------------------------------*/
LSERR GetOneCharDup(PILSOBJ pilsobj, PLSRUN plsrun, WCHAR wch, LSTFLOW lstflow, long dur, long* pdup)
{
	LSERR lserr;
	long dupSumJunk;
	long limDupJunk;

	*pdup = 0;
	if (pilsobj->fDisplay)
		{
		if (!pilsobj->fPresEqualRef)
			{
			lserr = (*pilsobj->plscbk->pfnGetRunCharWidths)(pilsobj->pols, plsrun, lsdevPres, &wch, 1,
								 LONG_MAX, lstflow, (int*)pdup, &dupSumJunk, &limDupJunk);
			if (lserr != lserrNone) return lserr;
			}
		else
			{
			*pdup = dur;
			}
		}
		

	return lserrNone;
}

/* G E T  V I S I  D U P */
/*----------------------------------------------------------------------------
    %%Function: GetVisiDup
    %%Contact: sergeyge
	
	Calculates dup of visi character character
----------------------------------------------------------------------------*/
LSERR GetVisiCharDup(PILSOBJ pilsobj, PLSRUN plsrun, WCHAR wch, LSTFLOW lstflow, long* pdup)
{
	LSERR lserr;
	long dupSumJunk;
	long limDupJunk;

	*pdup = 0;
	if (pilsobj->fDisplay)
		{
		lserr = (*pilsobj->plscbk->pfnGetRunCharWidths)(pilsobj->pols, plsrun, lsdevPres, &wch, 1,
								 LONG_MAX, lstflow, (int*)pdup, &dupSumJunk, &limDupJunk);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;
}


/* A D D  C H A R A C T E R  W I T H  W I D T H */
/*----------------------------------------------------------------------------
    %%Function: AddCharacterWithWidth
    %%Contact: sergeyge
	
	Writes character code and its width in wchOrig, wch, dup, dur arrays.
	Stores character code (in the VISI situation it can be different from wch)
	in pilsobj->wchPrev.
----------------------------------------------------------------------------*/
LSERR AddCharacterWithWidth(PLNOBJ plnobj, PTXTOBJ pdobjText, WCHAR wchOrig, long durWidth, WCHAR wch, long dupWidth)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long iwchLocalStart;
	long cjunk;

	pilsobj = plnobj->pilsobj;

	iwchLocalStart = pilsobj->wchMac;

	lserr = CheckReallocCharArrays(plnobj, 1, iwchLocalStart, &cjunk);
	if (lserr != lserrNone) return lserr;


/* Fix cached width information before width in the pdur array is overwritten by durWidth.
	Theoretically durWidth can be different from the cached value */

	if (pilsobj->dcpFetchedWidth > 0)
		{
		pilsobj->iwchFetchedWidth ++;
		pilsobj->cpFirstFetchedWidth ++;
		pilsobj->dcpFetchedWidth --;
		pilsobj->durFetchedWidth -= pilsobj->pdur[iwchLocalStart];
		}


	pilsobj->pwchOrig[iwchLocalStart] = wchOrig;
	pilsobj->pdur[iwchLocalStart] = durWidth;

	if (pilsobj->fDisplay)
		{
		plnobj->pwch[iwchLocalStart] = wch;
		plnobj->pdup[iwchLocalStart] = dupWidth;
		}

	pilsobj->wchMac++;

	pdobjText->iwchLim++;

	Assert(pilsobj->wchMac == pdobjText->iwchLim);


	return lserrNone;
}

/* F I X  S P A C E S */
/*----------------------------------------------------------------------------
    %%Function: FixSpaces
    %%Contact: sergeyge
	
	Fixes space character code for the Visi Spaces situation
----------------------------------------------------------------------------*/
void FixSpaces(PLNOBJ plnobj, PTXTOBJ pdobjText, WCHAR wch)
{
	PILSOBJ pilsobj;
	long i;

	pilsobj = plnobj->pilsobj;

	if (pilsobj->fDisplay)
		{
		for (i = pdobjText->u.reg.iwSpacesFirst; i < pdobjText->u.reg.iwSpacesLim; i++)
			{
			plnobj->pwch[pilsobj->pwSpaces[i]] = wch;
			}
		}
}

/* A D D  S P A C E S */
/*----------------------------------------------------------------------------
    %%Function: AddTrailingSpaces
    %%Contact: sergeyge
	
	Adds trailing/bordered spaces to the disp list
----------------------------------------------------------------------------*/
LSERR AddSpaces(PLNOBJ plnobj, PTXTOBJ pdobjText, long durSpace, long iNumOfSpaces)
{
	LSERR lserr;

	lserr = CopySpacesToDispList(plnobj, iNumOfSpaces, durSpace);
	if (lserr != lserrNone) return lserr;

	pdobjText->iwchLim = pdobjText->iwchLim + iNumOfSpaces;
	pdobjText->u.reg.iwSpacesLim = pdobjText->u.reg.iwSpacesLim + iNumOfSpaces;

	/* Fix Fetched Widths part. For non-bordered case, this procedure is activated for
		trailing spaces only, so this state should also be filled with 0s, but
		for bordered case it must be flushed
	*/
	FlushStringState(plnobj->pilsobj);

	return lserrNone;
}

/* I N C R E A S E   W C H M A C  B Y  @ */
/*----------------------------------------------------------------------------
    %%Function: IncreaseWchMacBy2
    %%Contact: sergeyge
	
----------------------------------------------------------------------------*/
LSERR IncreaseWchMacBy2(PLNOBJ plnobj)
{
	LSERR lserr;
	long cwch;
	
	lserr = CheckReallocCharArrays(plnobj, 2, plnobj->pilsobj->wchMac, &cwch);
	if (lserr != lserrNone) return lserr;

	Assert(cwch <= 2 && cwch > 0);

	if (cwch == 1)
		{
		lserr = CheckReallocCharArrays(plnobj, 1, plnobj->pilsobj->wchMac + 1, &cwch);
		if (lserr != lserrNone) return lserr;
		Assert(cwch == 1);
		}

	plnobj->pilsobj->wchMac += 2;

	return lserrNone;	
}

/* Internal Functions Implementation */


/* C H E C K  R E A L L O C  C H A R  A R R A Y S */
/*----------------------------------------------------------------------------
    %%Function: ReallocCharArrays
    %%Contact: sergeyge
	
	Reallocates character based arrays, increasing them by delta
----------------------------------------------------------------------------*/
static LSERR CheckReallocCharArrays(PLNOBJ plnobj, long cwch, long iwchLocalStart, long *cwchCorrect)
{
	PILSOBJ pilsobj;
	WCHAR* pwch;
	long* pdup;
	long* pdur;
	GMAP* pgmap;
	TXTINF* ptxtinf;
	long delta;

	pilsobj = plnobj->pilsobj;

	/* pdupPen was made equal to pdup at the CreateLnObj time;
		it can be changed to pdupPenAlloc at Adjust time only */
	Assert(plnobj->pdup == plnobj->pdupPen);

	/* Constant 2 is not random. We need to have 2 extra places for characters
	   for breaking with AutoHyphen and YSR which adds one charcter and hyphen.
	*/
	if (iwchLocalStart + cwch <= (long)pilsobj->wchMax - 2)
		{
		*cwchCorrect = cwch;
		}
	else if (iwchLocalStart < (long)pilsobj->wchMax - 2)
		{
		*cwchCorrect = pilsobj->wchMax - 2 - iwchLocalStart;
		}
	else 
		{
		Assert (iwchLocalStart == (long)pilsobj->wchMax - 2);

		delta = wchAddM;

		pwch = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, pilsobj->pwchOrig, (pilsobj->wchMax + delta) * sizeof(WCHAR) );
		if (pwch == NULL)
			{
			return lserrOutOfMemory;
			}
		pilsobj->pwchOrig = pwch;

		pwch = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, plnobj->pwch, (pilsobj->wchMax + delta) * sizeof(WCHAR) );
		if (pwch == NULL)
			{
			return lserrOutOfMemory;
			}
		plnobj->pwch = pwch;

		pdur = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, pilsobj->pdur, (pilsobj->wchMax + delta) * sizeof(long) );
		if (pdur == NULL)
			{
			return lserrOutOfMemory;
			}
		pilsobj->pdur = pdur;

		pdup = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, plnobj->pdup, (pilsobj->wchMax + delta) * sizeof(long) );
		if (pdup == NULL)
			{
			return lserrOutOfMemory;
			}
		plnobj->pdup = pdup;

		if (plnobj->pdupPenAlloc != NULL)
			{
			pdup = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, plnobj->pdupPenAlloc, (pilsobj->wchMax + delta) * sizeof(long) );
			if (pdup == NULL)
				{
				return lserrOutOfMemory;
				}
			plnobj->pdupPenAlloc = pdup;
			}

		if (plnobj->pgmap != NULL)
			{
			pgmap = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, plnobj->pgmap, (pilsobj->wchMax + delta) * sizeof(GMAP) );
			if (pgmap == NULL)
				{
				return lserrOutOfMemory;
				}
			plnobj->pgmap = pgmap;
			}

		if (pilsobj->pdurLeft != NULL)
			{
			pdur = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, pilsobj->pdurLeft, (pilsobj->wchMax + delta) * sizeof(long) );
			if (pdur == NULL)
				{
				return lserrOutOfMemory;
				}
			pilsobj->pdurLeft = pdur;
			memset(&pilsobj->pdurLeft[pilsobj->wchMax], 0, sizeof(long) * delta );
			}

		if	(pilsobj->pdurRight != NULL)
			{
			pdur = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, pilsobj->pdurRight, (pilsobj->wchMax + delta) * sizeof(long) );
			if (pdur == NULL)
				{
				return lserrOutOfMemory;
				}
			pilsobj->pdurRight = pdur;
			memset(&pilsobj->pdurRight[pilsobj->wchMax], 0, sizeof(long) * delta);
			}

		if (pilsobj->pduAdjust != NULL)
			{
			pdur = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, pilsobj->pduAdjust, (pilsobj->wchMax + delta) * sizeof(long) );
			if (pdur == NULL)
				{
				return lserrOutOfMemory;
				}
			pilsobj->pduAdjust = pdur;
			}

		if (pilsobj->ptxtinf != NULL)
			{
			ptxtinf = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, pilsobj->ptxtinf, (pilsobj->wchMax + delta) * sizeof(TXTINF) );
			if (ptxtinf == NULL)
				{
				return lserrOutOfMemory;
				}
			pilsobj->ptxtinf = ptxtinf;
			memset(&pilsobj->ptxtinf[pilsobj->wchMax], 0, sizeof(TXTINF) * delta);
			}

		pilsobj->wchMax += delta;
		plnobj->wchMax = pilsobj->wchMax;

		*cwchCorrect = delta;
		if (cwch < delta)
			*cwchCorrect = cwch;
		}

	/* see comment and Assert at the beginning of the file */
	plnobj->pdupPen = plnobj->pdup;

	return lserrNone;

}


/* C H E C K  R E A L L O C  S P A C E S  A R R A Y S */
/*----------------------------------------------------------------------------
    %%Function: CheckReallocSpacesArrays
    %%Contact: sergeyge
	
	Checks that there is enough space wSpaces
	to accomodate characters & spaces from the current local run.
	Reallocates these arrays if it is needed.
----------------------------------------------------------------------------*/
static LSERR CheckReallocSpacesArrays(PILSOBJ pilsobj, long cwSpaces)
{
	long iwSpacesLocalStart;
	long delta;
	long* pwSpaces;

	iwSpacesLocalStart = pilsobj->wSpacesMac;

	/* check that there is enough space for spaces in pwSpaces           */
	if (iwSpacesLocalStart + cwSpaces > pilsobj->wSpacesMax)
		{
		delta = wchAddM;
		if (delta < iwSpacesLocalStart + cwSpaces - pilsobj->wSpacesMax)
			{
			delta = iwSpacesLocalStart + cwSpaces - pilsobj->wSpacesMax;
			}
		pwSpaces = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, pilsobj->pwSpaces, (pilsobj->wSpacesMax + delta) * sizeof(long) );
		if (pwSpaces == NULL)
			{
			return lserrOutOfMemory;
			}
		pilsobj->pwSpaces = pwSpaces;
		pilsobj->wSpacesMax += delta;
		}

	return lserrNone;
}

/* C O P Y  C H A R S  S P A C E S  T O  D I S P  L I S T */
/*----------------------------------------------------------------------------
    %%Function: CopyCharsSpacesToDispList
    %%Contact: sergeyge
	
	Fills wch, dur and wSpaces arrays
----------------------------------------------------------------------------*/
static LSERR CopyCharsSpacesToDispList(PLNOBJ plnobj, WCHAR* rgwch, long cwch,
																		long* rgwSpaces, long cwSpaces)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long iwchLocalStart;
	long iwSpacesLocalStart;
	long i;

	pilsobj = plnobj->pilsobj;
	iwchLocalStart = pilsobj->wchMac;
	iwSpacesLocalStart = pilsobj->wSpacesMac;

	/* check that there is enough space for characters and their widths in pwch and pdup arrays  */ 
	lserr = CheckReallocSpacesArrays(pilsobj, cwSpaces);
	if (lserr != lserrNone) return lserr;

	/* fill pwch array      */
	memcpy(&pilsobj->pwchOrig[iwchLocalStart], rgwch, sizeof(rgwch[0]) * cwch);
	memcpy(&plnobj->pwch[iwchLocalStart], rgwch, sizeof(rgwch[0]) * cwch);
	pilsobj->wchMac += cwch;

	/* fill pwSpaces array, note that spaces with idexes greater than cwch should not be copied */
	for (i=0; i < cwSpaces && rgwSpaces[i] < cwch; i++)
		{
		pilsobj->pwSpaces[iwSpacesLocalStart + i] = iwchLocalStart + rgwSpaces[i];
		}

	pilsobj->wSpacesMac += i;

	return lserrNone;
}


/* C O P Y  S P A C E S  T O  D I S P  L I S T */
/*----------------------------------------------------------------------------
    %%Function: CopyTrailingSpacesToDispList
    %%Contact: sergeyge
	
	Fills wch, dur, dup, wSpaces arrays with the trailing spaces info
----------------------------------------------------------------------------*/
static LSERR CopySpacesToDispList(PLNOBJ plnobj, long iNumOfSpaces, long durSpace)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long iwchLocalStart;
	long iwSpacesLocalStart;
	long i;
	long cwch;
	long iwchStartCheck;
	long cwchCorrect;

	pilsobj = plnobj->pilsobj;
	iwchLocalStart = pilsobj->wchMac;
	iwSpacesLocalStart = pilsobj->wSpacesMac;

	cwch = iNumOfSpaces;
	iwchStartCheck = iwchLocalStart;

	while (cwch > 0)
		{
		lserr = CheckReallocCharArrays(plnobj, cwch, iwchStartCheck, &cwchCorrect);
		if (lserr != lserrNone) return lserr;

		iwchStartCheck += cwchCorrect;
		cwch -= cwchCorrect;
		}
	
	lserr = CheckReallocSpacesArrays(pilsobj, iNumOfSpaces);
	if (lserr != lserrNone) return lserr;

	for (i=0; i < iNumOfSpaces; i++)
		{
		plnobj->pwch[iwchLocalStart + i] = pilsobj->wchSpace;
		pilsobj->pwchOrig[iwchLocalStart + i] = pilsobj->wchSpace;
		pilsobj->pdur[iwchLocalStart + i] = durSpace;
		pilsobj->pwSpaces[iwSpacesLocalStart + i] = iwchLocalStart + i;
		}

	pilsobj->wchMac += iNumOfSpaces;
	pilsobj->wSpacesMac += iNumOfSpaces;
	
	return lserrNone;
}

/* F L A S H  S T R I N G  S T A T E */
/*----------------------------------------------------------------------------
    %%Function: FlashStringState
    %%Contact: sergeyge
	
----------------------------------------------------------------------------*/
void FlushStringState(PILSOBJ pilsobj)
{
	pilsobj->iwchFetchedWidth = 0;
	pilsobj->cpFirstFetchedWidth = 0;
	pilsobj->dcpFetchedWidth = 0;
	pilsobj->durFetchedWidth = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lssubset.c ===
/* LSSUBSET.C                  */
#include "lssubset.h"
#include "lsidefs.h"
#include "lssubl.h"
#include "sublutil.h"

/* L S S B  G E T  O B J  D I M  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LssbGetObjDimSubline
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	plstflow			-	(OUT) subline's lstflow
	pobjdim				-	(OUT) dimensions of subline

----------------------------------------------------------------------------*/

LSERR WINAPI LssbGetObjDimSubline(PLSSUBL plssubl, LSTFLOW* plstflow, POBJDIM pobjdim)			
	{
	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (plstflow == NULL) return lserrInvalidParameter;
	if (pobjdim == NULL) return lserrInvalidParameter;

	*plstflow = plssubl->lstflow;

	return GetObjDimSublineCore(plssubl, pobjdim);
	}
							
/* L S S B  G E T  D U P  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LssbGetDupSubline
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	plstflow			-	(OUT) subline's lstflow
	pdup				-	(OUT) width of subline

----------------------------------------------------------------------------*/
LSERR WINAPI LssbGetDupSubline(PLSSUBL plssubl,	LSTFLOW* plstflow, long* pdup)	
	{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (plstflow == NULL) return lserrInvalidParameter;
	if (pdup == NULL) return lserrInvalidParameter;

	*plstflow = plssubl->lstflow;

	return GetDupSublineCore(plssubl, pdup);
	}

/* L S S B  F  D O N E  P R E S  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LssbFDonePresSubline
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	pfDonePresSubline	-	(OUT) is presentation coordinates are already calculated 

----------------------------------------------------------------------------*/
LSERR WINAPI LssbFDonePresSubline(PLSSUBL plssubl, BOOL* pfDonePresSubline)		
	{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (pfDonePresSubline == NULL) return lserrInvalidParameter;

	*pfDonePresSubline = !plssubl->fDupInvalid;

	return lserrNone;
	}

/* L S S B  F  D O N E  D I S P L A Y*/
/*----------------------------------------------------------------------------
    %%Function: LssbFDoneDisplay
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	pfDonePresSubline	-	(OUT) is subline has been accepted for display with 
								  upper subline

----------------------------------------------------------------------------*/

LSERR WINAPI LssbFDoneDisplay(PLSSUBL plssubl, BOOL* pfDoneDisplay)	
	{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (pfDoneDisplay == NULL) return lserrInvalidParameter;

	*pfDoneDisplay = plssubl->fAcceptedForDisplay;

	return lserrNone;
	}

/* L S S B  G E T  P L S R U N S  F R O M  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LssbGetPlsrunsFromSubline
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	cDnodes				-	(IN) number of dnodes in subline
	rgplsrun			-	(OUT) array of plsrun's

----------------------------------------------------------------------------*/

LSERR WINAPI LssbGetPlsrunsFromSubline(PLSSUBL plssubl,	DWORD cDnodes, PLSRUN* rgplsrun)	
	{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (rgplsrun == NULL) return lserrInvalidParameter;

	return GetPlsrunFromSublineCore(plssubl, cDnodes, rgplsrun);
	}

/* L S S B  G E T  N U M B E R  D N O D E S  I N  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LssbGetNumberDnodesInSubline
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	pcDnodes			-	(OUT) number of dnodes in subline

----------------------------------------------------------------------------*/
LSERR WINAPI LssbGetNumberDnodesInSubline(PLSSUBL plssubl, DWORD* pcDnodes)	
	{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (pcDnodes == NULL) return lserrInvalidParameter;

	return GetNumberDnodesCore(plssubl, pcDnodes);
	}

/* L S S B  G E T  V I S I B L E  D C P  I N  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LssbGetVisibleDcpInSubline
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	pdcp				-	(OUT) number of characters

----------------------------------------------------------------------------*/
LSERR WINAPI LssbGetVisibleDcpInSubline(PLSSUBL plssubl, LSDCP* pdcp)	
	{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (pdcp == NULL) return lserrInvalidParameter;

	return GetVisibleDcpInSublineCore(plssubl, pdcp);
	}

/* L S S B  G E T  G E T  D U R  T R A I L  I N  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LssbGetDurTrailInSubline
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	pdurTrail			-	(OUT) width of trailing area in subline

----------------------------------------------------------------------------*/
LSERR WINAPI LssbGetDurTrailInSubline(PLSSUBL plssubl, long* pdurTrail)
	{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (pdurTrail == NULL) return lserrInvalidParameter;

	return GetDurTrailInSubline(plssubl, pdurTrail);
	}

/* L S S B  G E T  G E T  D U R  T R A I L  W I T H  P E N S  I N  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LssbGetDurTrailWithPensInSubline
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	pdurTrail			-	(OUT) width of trailing area in subline

----------------------------------------------------------------------------*/
LSERR WINAPI LssbGetDurTrailWithPensInSubline(PLSSUBL plssubl, long* pdurTrail)
	{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (pdurTrail == NULL) return lserrInvalidParameter;

	return GetDurTrailWithPensInSubline(plssubl, pdurTrail);
	}


/* L S S B  F  I S  S U B L I N E  E M P T Y*/
/*----------------------------------------------------------------------------
    %%Function: LssbFIsSublineEmpty
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	pfEmpty				-	(OUT) is this subline empty

----------------------------------------------------------------------------*/
LSERR WINAPI LssbFIsSublineEmpty(PLSSUBL plssubl, BOOL*  pfEmpty)	
								
	{
	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (pfEmpty == NULL) return lserrInvalidParameter;

	return FIsSublineEmpty(plssubl, pfEmpty);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lssetdoc.c ===
#include "iobj.h"
#include "lsidefs.h"	
#include "lssetdoc.h" 
#include "lsc.h"
#include "lstext.h"
#include "prepdisp.h"
#include "zqfromza.h"

static LSERR SetDocForFormaters(PLSC plsc, LSDOCINF* plsdocinf);


/* L S  S E T  D O C */
/*----------------------------------------------------------------------------
    %%Function: LsSetDoc
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	fDisplay			-	(IN) Intend to display? 
	fPresEqualRef		-	(IN) Ref & Pres Devices are equal?
	pclsdevres			-	(IN) device resolutions 			


    Fill in a part of a Line Services context.
	Can be called more frequently then LsCreateContext.
----------------------------------------------------------------------------*/


LSERR WINAPI LsSetDoc(PLSC plsc,	
					  BOOL fDisplay,				
					  BOOL fPresEqualRef,				
					  const LSDEVRES* pclsdevres) 
{

	LSDOCINF* plsdocinf = &(plsc->lsdocinf);
	LSERR lserr;

	if (!FIsLSC(plsc))					/* check that context is valid and not busy (for example in formating) */
		return lserrInvalidContext;
	if (FIsLSCBusy(plsc))
		return lserrSetDocDisabled;


	if (!fDisplay && !fPresEqualRef) 
		{
		plsc->lsstate = LsStateNotReady;
		return lserrInvalidParameter;
		}

	/* if nothing is changed: return right away */
	if (((BYTE) fDisplay == plsdocinf->fDisplay) &&
		((BYTE) fPresEqualRef == plsdocinf->fPresEqualRef ) &&
		(pclsdevres->dxrInch == plsdocinf->lsdevres.dxrInch) &&
		(pclsdevres->dyrInch == plsdocinf->lsdevres.dyrInch) && 
		(fPresEqualRef ||
			((pclsdevres->dxpInch == plsdocinf->lsdevres.dxpInch) &&
			 (pclsdevres->dypInch == plsdocinf->lsdevres.dypInch))))
		return lserrNone;
		  

	/* if we have current line we  must prepare it for display before changing context  */
	if (plsc->plslineCur != NULL)
		{
		lserr = PrepareLineForDisplayProc(plsc->plslineCur);
		if (lserr != lserrNone)
			{
			plsc->lsstate = LsStateNotReady;
			return lserr;
			}
		plsc->plslineCur = NULL;
		}

	plsc->lsstate = LsStateSettingDoc;  /* this assignment should be after PrepareForDisplay */


	plsdocinf->fDisplay = (BYTE) fDisplay;
	plsdocinf->fPresEqualRef = (BYTE) fPresEqualRef;
	plsdocinf->lsdevres = *pclsdevres;

	if (fPresEqualRef) 
		{
		plsdocinf->lsdevres.dxpInch = plsdocinf->lsdevres.dxrInch;
		plsdocinf->lsdevres.dypInch = plsdocinf->lsdevres.dyrInch;
		}

	if (!FBetween(plsdocinf->lsdevres.dxpInch, 0, zqLim-1) ||
		!FBetween(plsdocinf->lsdevres.dypInch, 0, zqLim-1) ||
		!FBetween(plsdocinf->lsdevres.dxrInch, 0, zqLim-1) ||
		!FBetween(plsdocinf->lsdevres.dyrInch, 0, zqLim-1))
		{
		plsc->lsstate = LsStateNotReady;
		return lserrInvalidParameter;
		}
		
	lserr = SetDocForFormaters(plsc, plsdocinf);
	if (lserr != lserrNone)
		{
		plsc->lsstate = LsStateNotReady;
		return lserr;
		}

	plsc->lsstate = LsStateFree;
	return lserrNone;
}

LSERR WINAPI LsSetModWidthPairs(
					  PLSC  plsc,				/* IN: ptr to line services context */
					  DWORD clspairact,			/* IN: Number of mod pairs info units*/ 
					  const LSPAIRACT* rglspairact,	/* IN: Mod pairs info units array  */
					  DWORD cModWidthClasses,			/* IN: Number of Mod Width classes	*/
					  const BYTE* rgilspairact)	/* IN: Mod width information(square):
											  indexes in the LSPAIRACT array */
{
	LSERR lserr;
	DWORD iobjText;
	PILSOBJ pilsobjText;

	if (!FIsLSC(plsc))					/* check that context is valid and not busy (for example in formating) */
		return lserrInvalidContext;
	if (FIsLSCBusy(plsc))
		return lserrSetDocDisabled;



	/* if we have current line we  must prepare it for display before changing context  */
	if (plsc->plslineCur != NULL)
		{
		lserr = PrepareLineForDisplayProc(plsc->plslineCur);
		if (lserr != lserrNone)
			{
			plsc->lsstate = LsStateNotReady;
			return lserr;
			}
		plsc->plslineCur = NULL;
		}

	plsc->lsstate = LsStateSettingDoc;  /* this assignment should be after PrepareForDisplay */


	iobjText = IobjTextFromLsc(&plsc->lsiobjcontext);
	pilsobjText = PilsobjFromLsc(&plsc->lsiobjcontext, iobjText); 
	
	lserr = SetTextModWidthPairs(pilsobjText, clspairact,
				rglspairact, cModWidthClasses, rgilspairact);
	if (lserr != lserrNone)
		{
		plsc->lsstate = LsStateNotReady;
		return lserr;
		}

	plsc->lsstate = LsStateFree;
	return lserrNone;
}

LSERR WINAPI LsSetCompression(
					  PLSC plsc,				/* IN: ptr to line services context */
					  DWORD cPriorities,			/* IN: Number of compression priorities*/
					  DWORD clspract,			/* IN: Number of compression info units*/
					  const LSPRACT* rglspract,	/* IN: Compession info units array 	*/
					  DWORD cModWidthClasses,			/* IN: Number of Mod Width classes	*/
					  const BYTE* rgilspract)		/* IN: Compression information:
											  indexes in the LSPRACT array  */
{
	LSERR lserr;
	DWORD iobjText;
	PILSOBJ pilsobjText;

	if (!FIsLSC(plsc))					/* check that context is valid and not busy (for example in formating) */
		return lserrInvalidContext;
	if (FIsLSCBusy(plsc))
		return lserrSetDocDisabled;



	/* if we have current line we  must prepare it for display before changing context  */
	if (plsc->plslineCur != NULL)
		{
		lserr = PrepareLineForDisplayProc(plsc->plslineCur);
		if (lserr != lserrNone)
			{
			plsc->lsstate = LsStateNotReady;
			return lserr;
			}
		plsc->plslineCur = NULL;
		}

	plsc->lsstate = LsStateSettingDoc;  /* this assignment should be after PrepareForDisplay */


	iobjText = IobjTextFromLsc(&plsc->lsiobjcontext);
	pilsobjText = PilsobjFromLsc(&plsc->lsiobjcontext, iobjText); 
	
	lserr = SetTextCompression(pilsobjText, cPriorities, clspract,
				rglspract, cModWidthClasses, rgilspract);
	if (lserr != lserrNone)
		{
		plsc->lsstate = LsStateNotReady;
		return lserr;
		}

	plsc->lsstate = LsStateFree;
	return lserrNone;
}


LSERR WINAPI LsSetExpansion(
					  PLSC plsc,				/* IN: ptr to line services context */
					  DWORD cExpansionClasses,			/* IN: Number of expansion info units*/
					  const LSEXPAN* rglsexpan,	/* IN: Expansion info units array	*/
					  DWORD cModWidthClasses,			/* IN: Number of Mod Width classes	*/
					  const BYTE* rgilsexpan)		/* IN: Expansion information(square):
											  indexes in the LSEXPAN array  */

{
	LSERR lserr;
	DWORD iobjText;
	PILSOBJ pilsobjText;

	if (!FIsLSC(plsc))					/* check that context is valid and not busy (for example in formating) */
		return lserrInvalidContext;
	if (FIsLSCBusy(plsc))
		return lserrSetDocDisabled;



	/* if we have current line we  must prepare it for display before changing context  */
	if (plsc->plslineCur != NULL)
		{
		lserr = PrepareLineForDisplayProc(plsc->plslineCur);
		if (lserr != lserrNone)
			{
			plsc->lsstate = LsStateNotReady;
			return lserr;
			}
		plsc->plslineCur = NULL;
		}

	plsc->lsstate = LsStateSettingDoc;  /* this assignment should be after PrepareForDisplay */


	iobjText = IobjTextFromLsc(&plsc->lsiobjcontext);
	pilsobjText = PilsobjFromLsc(&plsc->lsiobjcontext, iobjText); 
	
	lserr = SetTextExpansion(pilsobjText, cExpansionClasses, 
				rglsexpan, cModWidthClasses, rgilsexpan);
	if (lserr != lserrNone)
		{
		plsc->lsstate = LsStateNotReady;
		return lserr;
		}

	plsc->lsstate = LsStateFree;
	return lserrNone;
}


LSERR WINAPI LsSetBreaking(
					  PLSC plsc,				/* IN: ptr to line services context */
					  DWORD clsbrk,			/* IN: Number of breaking info units*/
					  const LSBRK* rglsbrk,		/* IN: Breaking info units array	*/
					  DWORD cBreakingClasses,			/* IN: Number of breaking classes	*/
					  const BYTE* rgilsbrk)		/* IN: Breaking information(square):
											  indexes in the LSBRK array  */

{
	LSERR lserr;
	DWORD iobjText;
	PILSOBJ pilsobjText;

	if (!FIsLSC(plsc))					/* check that context is valid and not busy (for example in formating) */
		return lserrInvalidContext;
	if (FIsLSCBusy(plsc))
		return lserrSetDocDisabled;



	/* if we have current line we  must prepare it for display before changing context  */
	if (plsc->plslineCur != NULL)
		{
		lserr = PrepareLineForDisplayProc(plsc->plslineCur);
		if (lserr != lserrNone)
			{
			plsc->lsstate = LsStateNotReady;
			return lserr;
			}
		plsc->plslineCur = NULL;
		}

	plsc->lsstate = LsStateSettingDoc;  /* this assignment should be after PrepareForDisplay */


	iobjText = IobjTextFromLsc(&plsc->lsiobjcontext);
	pilsobjText = PilsobjFromLsc(&plsc->lsiobjcontext, iobjText); 
	
	lserr = SetTextBreaking(pilsobjText, clsbrk, 
				rglsbrk, cBreakingClasses, rgilsbrk);
	if (lserr != lserrNone)
		{
		plsc->lsstate = LsStateNotReady;
		return lserr;
		}

	plsc->lsstate = LsStateFree;
	return lserrNone;
}



/* S E T  D O C  F O R  F O R M A T E R S */
/*----------------------------------------------------------------------------
    %%Function: SetDocForFormaters
    %%Contact: igorzv
Parameter:
	plsc		-	(IN) ptr to line services context 
	plsdocinf	-	(IN) ptr to set doc input 

Invokes SetDoc methods for all formaters
----------------------------------------------------------------------------*/

LSERR SetDocForFormaters(PLSC plsc, LSDOCINF* plsdocinf)
{
	DWORD iobjMac;
	DWORD iobj;
	PILSOBJ pilsobj;
	LSERR lserr;


	Assert(FIsLSC(plsc));
	Assert(plsc->lsstate == LsStateSettingDoc);
	Assert(plsdocinf != NULL);

	iobjMac = plsc->lsiobjcontext.iobjMac;

	for (iobj = 0;  iobj < iobjMac;  iobj++)
		{
		pilsobj = plsc->lsiobjcontext.rgobj[iobj].pilsobj;
		lserr = plsc->lsiobjcontext.rgobj[iobj].lsim.pfnSetDoc(pilsobj,plsdocinf);
		if (lserr != lserrNone)
			return lserr;
		}
	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lstfset.c ===
#include "lsidefs.h"
#include "lstfset.h"

//    %%Function:	LsPointUV2FromPointUV1
//    %%Contact:	victork
//
LSERR WINAPI LsPointUV2FromPointUV1(LSTFLOW lstflow1,	 		/* IN: text flow 1 */
									PCPOINTUV pptStart,	 		/* IN: start input point (TF1) */
									PCPOINTUV pptEnd,			/* IN: end input point (TF1) */
									LSTFLOW lstflow2,	 		/* IN: text flow 2 */
									PPOINTUV pptOut)			/* OUT: vector in TF2 */


{

Assert(lstflowES == 0);
Assert(lstflowEN == 1);
Assert(lstflowSE == 2);
Assert(lstflowSW == 3);
Assert(lstflowWS == 4);
Assert(lstflowWN == 5);
Assert(lstflowNE == 6);
Assert(lstflowNW == 7);

// The three bits that constitute lstflow happens to have well defined meanings.
//
// Middle bit: on for vertical writing, off for horizontal.
// First (low value) bit: "on" means v-axis points right or down (positive).
// Third bit: "off" means u-axis points right or down (positive).
//
// So the algorithm of covertion (u1,v1) in lstflow1 to (u2,v2) in lstflow2 is:
// 
// fHorizontalOrVertical1 = lstflow1 & fUVertical;
// fUPositive1 = !(lstflow1 & fUDirection);
// fVPositive1 = lstflow1 & fVDirection;
// fHorizontalOrVertical2 = lstflow2 & fUVertical;
// fUPositive2 = !(lstflow2 & fUDirection);
// fVPositive2 = lstflow2 & fVDirection;
//
// 
// if (fHorizontalOrVertical1 == fHorizontalOrVertical2)
//  	{
//		if (fUPositive1 == fUPositive2)
//			{
//			u2 = u1;
//			}
//		else
//			{
//			u2 = -u1;
//			}
//		if (fVPositive1 == fVPositive2)
//			{
//			v2 = v1;
//			}
//		else
//			{
//			v2 = -v1;
//			}
//	 	}
// else
//		{
//		if (fUPositive1 == fVPositive2)
//			{
//			u2 = v1;
//			}
//		else
//			{
//			u2 = -v1;
//			}
//		if (fVPositive1 == fUPositive2)
//			{
//			v2 = u1;
//			}
//		else
//			{
//			v2 = -u1;
//			}
//		}
//
// Actual code is a little bit more compact.
// 
// A hack (?): (!a == !b) is used instead of (((a==0) && (b==0)) || ((a!=0) && (b!=0)))

if ((lstflow1 ^ lstflow2) & fUVertical)				// one is vertical, another is horizontal
	{
	pptOut->u = (pptEnd->v - pptStart->v) * 
							((!(lstflow2 & fUDirection) == !(lstflow1 & fVDirection)) ? -1 : 1);
	pptOut->v = (pptEnd->u - pptStart->u) * 
							((!(lstflow2 & fVDirection) == !(lstflow1 & fUDirection)) ? -1 : 1);
	}
else
	{
	pptOut->u = (pptEnd->u - pptStart->u) * 
							(((lstflow1 ^ lstflow2) & fUDirection) ? -1 : 1);
	pptOut->v = (pptEnd->v - pptStart->v) * 
							(((lstflow1 ^ lstflow2) & fVDirection) ? -1 : 1);
	}

	return lserrNone;
}


//    %%Function:	LsPointXYFromPointUV
//    %%Contact:	victork
//
/*  returns (x,y) point given (x,y) point and (u,v) vector */

LSERR WINAPI LsPointXYFromPointUV(const POINT* pptXY, 		/* IN: input point (x,y) */
							LSTFLOW lstflow,	 	/* IN: text flow for */
							PCPOINTUV pptUV,		/* IN: vector in (u,v) */
							POINT* pptXYOut) 		/* OUT: point (x,y) */

{
	switch (lstflow)
		{
		case lstflowES:									/* latin */
			pptXYOut->x = pptXY->x + pptUV->u;
			pptXYOut->y = pptXY->y - pptUV->v;
			return lserrNone;
		case lstflowSW:									/* vertical FE */
			pptXYOut->x = pptXY->x + pptUV->v;
			pptXYOut->y = pptXY->y + pptUV->u;
			return lserrNone;
		case lstflowWS:									/* BiDi */
			pptXYOut->x = pptXY->x - pptUV->u;
			pptXYOut->y = pptXY->y - pptUV->v;
			return lserrNone;
		case lstflowEN:
			pptXYOut->x = pptXY->x + pptUV->u;
			pptXYOut->y = pptXY->y + pptUV->v;
			return lserrNone;
		case lstflowSE:
			pptXYOut->x = pptXY->x - pptUV->v;
			pptXYOut->y = pptXY->y + pptUV->u;
			return lserrNone;
		case lstflowWN:
			pptXYOut->x = pptXY->x - pptUV->u;
			pptXYOut->y = pptXY->y + pptUV->v;
			return lserrNone;
		case lstflowNE:
			pptXYOut->x = pptXY->x - pptUV->v;
			pptXYOut->y = pptXY->y - pptUV->u;
			return lserrNone;
		case lstflowNW:
			pptXYOut->x = pptXY->x + pptUV->v;
			pptXYOut->y = pptXY->y - pptUV->u;
			return lserrNone;
		default:
			NotReached();
			return lserrInvalidParameter;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lstxtbrk.c ===
#include <limits.h>
#include "lsmem.h"
#include "lstxtbrk.h"
#include "lstxtbrs.h"
#include "lstxtmap.h"
#include "lsdntext.h"
#include "brko.h"
#include "locchnk.h"
#include "lschp.h"
#include "posichnk.h"
#include "objdim.h"
#include "lshyph.h"
#include "lskysr.h"
#include "lstxtffi.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"

#define FWrapTrailingSpaces(pilsobj, ptxtobj, fInChildList) \
		(lserr = LsdnFInChildList((pilsobj)->plsc, (ptxtobj)->plsdnUpNode, &(fInChildList)), \
		Assert(lserr == lserrNone), \
		(fInChildList) || ((pilsobj)->grpf & fTxtWrapTrailingSpaces))

#define FRegularBreakableBeforeDobj(ptxtobj) \
		((ptxtobj)->txtkind == txtkindRegular || (ptxtobj)->txtkind == txtkindYsrChar || \
		 (ptxtobj)->txtkind == txtkindSpecSpace || (ptxtobj)->txtkind == txtkindHardHyphen)
#define FRegularBreakableAfterDobj(ptxtobj) \
		((ptxtobj)->txtkind == txtkindRegular || (ptxtobj)->txtkind == txtkindYsrChar || \
		 (ptxtobj)->txtkind == txtkindSpecSpace)
/* Internal Functions prototypes */
static BOOL FindPrevSpace(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
										long* pitxtobjSpace, long* piwchSpace);
static BOOL FindNextSpace(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
										long* pitxtobjSpace, long* piwchSpace);
static LSERR TryPrevBreakFindYsr(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
								long itxtobjSpace, long iwchSpace,
								BOOL* pfBroken, BOOL* pfFoundYsr, long* pitxtobjYsr, PBRKOUT ptbo);
static LSERR TryNextBreakFindYsr(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
								long itxtobjSpace, long iwchSpace,
								BOOL* pfBroken, PBRKOUT ptbo);
static LSERR TryBreakWithHyphen(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
						BOOL fSpaceFound, long itxtobjSpace, long iwchSpace,
						BOOL fFoundYsr, long itxtobjYsr, BOOL* pfBroken, PBRKOUT ptbo);
static LSERR TryBreakAtSpace(PCLOCCHNK plocchnk, PCPOSICHNK pposichnk,long itxtobjSpace, long iwchSpace, 
					BRKKIND brkkind, BOOL* pfBroken, long* pitxtobjCurNew, long* piwchCurNew, PBRKOUT ptbo);
static LSERR TryBreakAtSpaceWrap(PCLOCCHNK plocchnk, PCPOSICHNK pposichnk,
								 long itxtobjSpace, long iwchSpace, BRKKIND brkkind,
								 BOOL* pfBroken, long* pitxtobjCurNew, long* piwchCurNew, PBRKOUT ptbo);
static LSERR TryBreakAtSpaceNormal(PCLOCCHNK plocchnk, long itxtobjSpace, long iwchSpace, BRKKIND brkkind,
								 BOOL* pfBroken, long* pitxtobjCurNew, long* piwchCurNew, PBRKOUT ptbo);
static LSERR TryBreakAcrossSpaces(PCLOCCHNK plocchnk,
						BOOL fBeforeFound, long itxtobjBefore, long iwchBefore,
						BOOL fAfterFound, long itxtobjAfter, long iwchAfter, BRKKIND brkkind,
						BOOL* pfBroken, PBRKOUT ptbo);
static LSERR TryPrevBreakRegular(PCLOCCHNK plocchnk, long itxtobj, long iwchSpace, long iwchCur,
																BOOL* pfBroken, PBRKOUT ptbo);
static LSERR TryNextBreakRegular(PCLOCCHNK plocchnk, long itxtobj, long iwchSpace, long iwchCur,
																BOOL* pfBroken, PBRKOUT ptbo);
static LSERR CheckBreakAtLastChar(PCLOCCHNK pclocchnk, BRKCLS brkclsLeading, long iwch, long itxtobj,
																BOOL* pfBroken);
static LSERR TryBreakAtHardHyphen(PCLOCCHNK plocchnk, long itxtobj, long iwch, BRKKIND brkkind,
																BOOL* pfBroken, PBRKOUT ptbo);
static LSERR TryBreakAtOptBreak(PCLOCCHNK plocchnk, long itxtobj, BRKKIND brkkind,
																BOOL* pfBroken, PBRKOUT ptbo);
static LSERR TryBreakAtEOL(PCLOCCHNK plocchnk, long itxtobj, BRKKIND brkkind, BOOL* pfBroken, PBRKOUT ptbo);
static LSERR TryBreakAtNonReqHyphen(PCLOCCHNK plocchnk, long itxtobj, BRKKIND brkkind, 
																BOOL* pfBroken, PBRKOUT ptbo);
static LSERR TryBreakAfterChunk(PCLOCCHNK plocchnk, BRKCOND brkcond, BOOL* pfBroken, PBRKOUT ptbo);
static LSERR TryBreakBeforeChunk(PCLOCCHNK plocchnk, BRKCOND brkcond, BOOL* pfBroken, PBRKOUT ptbo);
static LSERR CanBreakBeforeText(PCLOCCHNK plocchnk, BRKCOND* pbrktxt);
static LSERR CanBreakAfterText(PCLOCCHNK plocchnk, BOOL fNonSpaceFound, long itxtobjBefore,
																	long iwchBefore, BRKCOND* pbrktxt);
static LSERR FillPtboPbrkinf(PCLOCCHNK plocchnk, long itxtobj, long iwch, 
										/*long itxtobjBeforeTrail,*/ long iwchBeforeTrail, BRKKIND brkkind,
										BREAKINFO** ppbrkinf, PBRKOUT ptbo);

/* Export Functions Implementation */


/* F I N D  P R E V  B R E A K  T E X T */
/*----------------------------------------------------------------------------
    %%Function: FindPrevBreakTxt
    %%Contact: sergeyge

	Breaks the line in general case.

	Strategy:
	in loop while break was not found:
		--Finds the last space.
		--Checks for break opportunity behind last space. If it exists, performs break.
		--If there is no such an opportunity tries to hyphenate if needed.
		--Tries to breaks at space, if other possibilies did not work
----------------------------------------------------------------------------*/
LSERR WINAPI FindPrevBreakText(PCLOCCHNK plocchnk, PCPOSICHNK pposichnk, BRKCOND brkcondAfter, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long iwchFirst;
	long itxtobjCur = 0;				/* Initialization to keep compiler satisfied */
	PTXTOBJ ptxtobjCur;
	long iwchCur = 0;					/* Initialization to keep compiler satisfied */	/* Absolute index of current char in rgwch */
	long itxtobjSpace;
	long iwchSpace;						/* Absolute index of last space in rgwch */
	long itxtobjYsr;
	BOOL fSpaceFound;
	BOOL fBroken;
	BOOL fFoundYsr;
	long itxtobjCurNew;
	long iwchCurNew;
	BOOL fInChildList;

	Assert(plocchnk->clschnk > 0);
	pilsobj = ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->plnobj->pilsobj;
	iwchFirst = ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->iwchFirst;
	fBroken = fFalse;

	if (pposichnk->ichnk == ichnkOutside)
		{
/* Check break after chunk. If break is impossible, make sure that it is not considered any longer */
		lserr = TryBreakAfterChunk(plocchnk, brkcondAfter, &fBroken, ptbo);
		if (lserr != lserrNone) return lserr;

		if (!fBroken)
			{
			itxtobjCur = plocchnk->clschnk-1;
			ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
			iwchCur = ptxtobjCur->iwchFirst + plocchnk->plschnk[itxtobjCur].dcp  - 1;
			if (iwchCur < ptxtobjCur->iwchFirst)
				itxtobjCur--;

			Assert(itxtobjCur >= 0 || iwchCur < iwchFirst);

			if (itxtobjCur >= 0)
				FindNonSpaceBefore(plocchnk->plschnk, itxtobjCur, iwchCur, &itxtobjCur, &iwchCur);
			/* if not found, we are safe because iwchCur will be < iwchFirst in this case */

			}
		}
	else
		{
		itxtobjCur = pposichnk->ichnk;
		ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
		Assert(ptxtobjCur->iwchFirst + pposichnk->dcp > 0);
		iwchCur = ptxtobjCur->iwchFirst + pposichnk->dcp - 1;

		if (ptxtobjCur->txtkind == txtkindEOL)
			{
			lserr = TryBreakAtEOL(plocchnk, itxtobjCur, brkkindPrev, &fBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			}
		else if (!FRegularBreakableAfterDobj(ptxtobjCur))
			{
			/* It won't be done after FindPrevSpace for non-regular DOBJ's, because they might overwrite
				don't break before space logic
			*/
			iwchCur--;
			if (iwchCur < ptxtobjCur->iwchFirst)
				itxtobjCur--;
			}

		}

	while (!fBroken && iwchCur >= iwchFirst)
		{

		/* it is important to start search for space before subtructing 1,
			since space might have been a truncation point

			it is not very beautiful that iwchCur is wrong for ichnkOutside, but
			fortunately it still works correctly with FindPrevSpace.
		*/

		fSpaceFound = FindPrevSpace(plocchnk, itxtobjCur, iwchCur, &itxtobjSpace, &iwchSpace);

		/* now index of the current wchar should be decreased by 1 in both starting situation(obviously)
			and following iterations (because break cannot happen before space),
			but not for non-Regular DOBJ's.
			At starting situation it has already been done. In following iterations Hard/OptBreak's should
			produce hard-coded break opportunity
		 */
		Assert(itxtobjCur >= 0);
		ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
		if (FRegularBreakableAfterDobj(ptxtobjCur))
			{
			iwchCur--;
			if (iwchCur < ptxtobjCur->iwchFirst && itxtobjCur > 0)
				itxtobjCur--;
			}

	/* Check if there is break opportunity behind last space */
		lserr = TryPrevBreakFindYsr(plocchnk, itxtobjCur, iwchCur, itxtobjSpace, iwchSpace,
									 &fBroken, &fFoundYsr, &itxtobjYsr, ptbo);
		if (lserr != lserrNone) return lserr;

		if (!fBroken)
			{
			if ((pilsobj->grpf & fTxtDoHyphenation) && iwchCur > iwchSpace)
				{
				lserr = LsdnFInChildList(ptxtobjCur->plnobj->pilsobj->plsc, ptxtobjCur->plsdnUpNode, &fInChildList);
				if (lserr != lserrNone) return lserr;
				if (!fInChildList)
					{
					lserr = TryBreakWithHyphen(plocchnk, itxtobjCur, iwchCur, fSpaceFound, itxtobjSpace, iwchSpace,
												fFoundYsr, itxtobjYsr, &fBroken, ptbo);
					if (lserr != lserrNone) return lserr;
					}
				}
			if (!fBroken)
				{
				if (fSpaceFound)
					{
					lserr = TryBreakAtSpace(plocchnk, pposichnk, itxtobjSpace, iwchSpace, brkkindPrev,
								 &fBroken, &itxtobjCurNew, &iwchCurNew, ptbo);
					if (lserr != lserrNone) return lserr;
		
					iwchCur = iwchCurNew;
					itxtobjCur = itxtobjCurNew;
					}
				else
					{
					iwchCur = iwchFirst - 1;
					}
				}
			}
		}

	if (!fBroken)
		{
		memset(ptbo, 0, sizeof (*ptbo));
		Assert(ptbo->fSuccessful == fFalse);
	/* Addition for the new break logic---brkcond is added as input/output*/
		ptbo->brkcond = brkcondCan;
		if (pilsobj->grpf & fTxtApplyBreakingRules)
			{
			lserr = CanBreakBeforeText(plocchnk, &ptbo->brkcond);
			if (lserr != lserrNone) return lserr;
			}
	/* end of new breaking logic */
		}

	return lserrNone;
}

/* F I N D  N E X T  B R E A K  T E X T */
/*----------------------------------------------------------------------------
    %%Function: FindNextBreakTxt
    %%Contact: sergeyge

	Breaks the line in general case.

	Strategy:
	in loop while break was not found:
		--Finds the next space.
		--Checks for break opportunity before found space. If it exists, performs break.
		--Tries to breaks at space, if other possibilies did not work
----------------------------------------------------------------------------*/
LSERR WINAPI FindNextBreakText(PCLOCCHNK plocchnk, PCPOSICHNK pposichnk, BRKCOND brkcondBefore, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long iwchLast;
	long itxtobjCur = 0;				/* Initialization to keep compiler satisfied */
	PTXTOBJ ptxtobjCur;					/* Initialization to keep compiler satisfied */
	long iwchCur = 0;						/* Absolute index of current char in rgwch */
	long itxtobjSpace;
	long iwchSpace;						/* Absolute index of last space in rgwch */
	BOOL fSpaceFound;
	BOOL fBroken;
	long itxtobjCurNew;
	long iwchCurNew;
	BOOL fInChildList;

	BOOL fNonSpaceFound;
	long itxtobjBefore;
	long iwchBefore;
	BREAKINFO* pbrkinf;
	

	Assert(plocchnk->clschnk > 0);
	pilsobj = ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->plnobj->pilsobj;
	iwchLast = ((PTXTOBJ)plocchnk->plschnk[plocchnk->clschnk - 1].pdobj)->iwchLim - 1;
	fBroken = fFalse;

	if (pposichnk->ichnk == ichnkOutside)
		{
/* Check break after chunk. If break is impossible, make sure that it is not considered any longer */
		lserr = TryBreakBeforeChunk(plocchnk, brkcondBefore, &fBroken, ptbo);
		if (lserr != lserrNone) return lserr;
		if (!fBroken)
			{
			itxtobjCur = 0;
			ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[0].pdobj;
			iwchCur = ptxtobjCur->iwchFirst;
			/* Hack: In the case of NRH or alike satisfy condition of the while loop below */
			if (ptxtobjCur->iwchLim == ptxtobjCur->iwchFirst)
				iwchCur--;
			}
		}
	else
		{
		itxtobjCur = pposichnk->ichnk;
		ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
		Assert(ptxtobjCur->iwchFirst + pposichnk->dcp > 0);
		iwchCur = ptxtobjCur->iwchFirst + pposichnk->dcp - 1;

	/* 	if truncation point was space, find first next opportunity after spaces	*/
		if (!FWrapTrailingSpaces(pilsobj, ptxtobjCur, fInChildList))
			{
			FindNonSpaceAfter(plocchnk->plschnk, plocchnk->clschnk,
												 itxtobjCur, iwchCur, &itxtobjCur, &iwchCur);
			ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
			}

		/* Hack: In the case of NRH or alike satisfy condition of the while loop below */
		if (ptxtobjCur->iwchLim == ptxtobjCur->iwchFirst)
			iwchCur = ptxtobjCur->iwchFirst - 1;
		}

	while (!fBroken && iwchCur <= iwchLast)
		{

		fSpaceFound = FindNextSpace(plocchnk, itxtobjCur, iwchCur, &itxtobjSpace, &iwchSpace);

	/* Check if there is break opportunity before next space */
		lserr = TryNextBreakFindYsr(plocchnk, itxtobjCur, iwchCur, itxtobjSpace, iwchSpace,
								 &fBroken, ptbo);
		if (lserr != lserrNone) return lserr;

		if (!fBroken)
			{
			if (fSpaceFound)
				{
				lserr = TryBreakAtSpace(plocchnk, pposichnk, itxtobjSpace, iwchSpace, brkkindNext,
							 &fBroken, &itxtobjCurNew, &iwchCurNew, ptbo);
				if (lserr != lserrNone) return lserr;

				if (!fBroken)
					{
					iwchCur = iwchCurNew;
					itxtobjCur = itxtobjCurNew;
					Assert(itxtobjCur >= 0 && itxtobjCur < (long)plocchnk->clschnk);
					ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
					/* Hack: In the case of NRH or alike satisfy condition of the while loop */
					if (ptxtobjCur->iwchLim == ptxtobjCur->iwchFirst)
						iwchCur--;
					}
				}
			else
				{
				iwchCur = iwchLast + 1;
				}
			}
		}

	if (!fBroken)
		{
		memset(ptbo, 0, sizeof (*ptbo));
		Assert(ptbo->fSuccessful == fFalse);
		ptbo->brkcond = brkcondCan;

		Assert(plocchnk->clschnk > 0);
		itxtobjCur = plocchnk->clschnk - 1;
		ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
		iwchCur = ptxtobjCur->iwchLim - 1;
		fNonSpaceFound = FindNonSpaceBefore(plocchnk->plschnk, itxtobjCur, iwchCur,
																	&itxtobjBefore, &iwchBefore);
		if (pilsobj->grpf & fTxtApplyBreakingRules)
			{
			lserr = CanBreakAfterText(plocchnk, fNonSpaceFound, itxtobjBefore, iwchBefore, &ptbo->brkcond);
			if (lserr != lserrNone) return lserr;
			if (iwchBefore != iwchCur && ptbo->brkcond == brkcondCan)
				ptbo->brkcond = brkcondPlease;
			}
		if (ptbo->brkcond != brkcondNever)
			{

			/* if following Assert fails, iwchCur is calculated incorrectly a few lines above,
				but it must be correct, because NonRecHyphen/... would have already caused break
			*/
			Assert(ptxtobjCur->iwchLim > ptxtobjCur->iwchFirst);
														
			lserr = FillPtboPbrkinf(plocchnk, itxtobjCur, iwchCur, /*itxtobjBefore,*/ iwchBefore,
													brkkindNext, &pbrkinf, ptbo);
			if (lserr != lserrNone) return lserr;
			ptbo->fSuccessful = fFalse;
		
		/* next if statement with comment is copied from TryBreakNextNormal() with replacement of
			iwchCur - 1 by iwchCur */
		/* fModWidthSpace can be at the last char here only iff fWrapAllSpaces;
			if we touch balanced space here, the logic of GetMinCompressAmount should be rethinked!*/
			if (pilsobj->pdurRight != NULL && pilsobj->pdurRight[iwchCur] != 0 &&
														!pilsobj->ptxtinf[iwchCur].fModWidthSpace)
				{
				pbrkinf->u.normal.durFix = - pilsobj->pdurRight[iwchCur];
				ptbo->objdim.dur -= pilsobj->pdurRight[iwchCur];
				}

			}
		}

	return lserrNone;
}


/* Internal Functions Implementation */

/* F I N D  P R E V  S P A C E */
/*----------------------------------------------------------------------------
    %%Function: FindPrevSpace
    %%Contact: sergeyge

	Returns TRUE if there is a space and FALSE otherwise.
	Reports the index of the dobj containing last space
	and space's index in rgwchOrig array.
----------------------------------------------------------------------------*/
static BOOL FindPrevSpace(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
										long* pitxtobjSpace, long* piwchSpace)
{

	PILSOBJ pilsobj;
	BOOL fSpaceFound;
	PTXTOBJ ptxtobjCur;
	long* rgwSpaces;
	long iwSpacesCur;

	ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
	pilsobj = ptxtobjCur->plnobj->pilsobj;
	rgwSpaces = pilsobj->pwSpaces;

	fSpaceFound = fFalse;

/* In the case fWrapAllSpaces space is treated as a regular character */

	if (!(pilsobj->grpf & fTxtWrapAllSpaces))
		{

		if (ptxtobjCur->txtkind == txtkindRegular)
			{
			iwSpacesCur = ptxtobjCur->u.reg.iwSpacesLim - 1;
			while (iwSpacesCur >= ptxtobjCur->u.reg.iwSpacesFirst &&
	 /* current character might be space, if text chunk is not last on the line */
						 rgwSpaces[iwSpacesCur] > iwchCur)
				{
				iwSpacesCur--;
				}

			if (ptxtobjCur->txtf & txtfGlyphBased)
				{
				while (iwSpacesCur >= ptxtobjCur->u.reg.iwSpacesFirst && 
										!FIwchOneToOne(pilsobj, rgwSpaces[iwSpacesCur]))
				iwSpacesCur--;
				}

			if (iwSpacesCur >= ptxtobjCur->u.reg.iwSpacesFirst)
				{
				fSpaceFound = fTrue;
				*pitxtobjSpace = itxtobjCur;
				*piwchSpace = rgwSpaces[iwSpacesCur];
				}
			}
		else if (ptxtobjCur->txtkind == txtkindSpecSpace)
			{
			fSpaceFound = fTrue;
			*pitxtobjSpace = itxtobjCur;
			*piwchSpace = iwchCur;
			}

		itxtobjCur--;

		while (!fSpaceFound && itxtobjCur >= 0)
		 	{

			ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;

			if (ptxtobjCur->txtkind == txtkindRegular)
				{

				iwSpacesCur = ptxtobjCur->u.reg.iwSpacesLim - 1;

				if (ptxtobjCur->txtf & txtfGlyphBased)
					{
					while (iwSpacesCur >= ptxtobjCur->u.reg.iwSpacesFirst && 
										!FIwchOneToOne(pilsobj, rgwSpaces[iwSpacesCur]))
					iwSpacesCur--;
					}


				if (iwSpacesCur >= ptxtobjCur->u.reg.iwSpacesFirst)
					{
					fSpaceFound = fTrue;
					*pitxtobjSpace = itxtobjCur;
					*piwchSpace = rgwSpaces[iwSpacesCur];
					}
				}
			else if (ptxtobjCur->txtkind == txtkindSpecSpace)
				{
				fSpaceFound = fTrue;
				*pitxtobjSpace = itxtobjCur;
				*piwchSpace = ptxtobjCur->iwchLim - 1;
				}

			itxtobjCur--;		

			}
		}

	if (!fSpaceFound)
		{
		*pitxtobjSpace = -1;
		*piwchSpace = ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->iwchFirst - 1;
		}

	return fSpaceFound;
}

/* F I N D  N E X T  S P A C E */
/*----------------------------------------------------------------------------
    %%Function: FindNextSpace
    %%Contact: sergeyge

	Returns TRUE if there is a space and FALSE otherwise.
	Reports the index of the dobj containing last space
	and space's index in rgwchOrig array.
----------------------------------------------------------------------------*/
static BOOL FindNextSpace(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
										long* pitxtobjSpace, long* piwchSpace)
{

	PILSOBJ pilsobj;
	BOOL fSpaceFound;
	PTXTOBJ ptxtobjCur;
	long* rgwSpaces;
	long iwSpacesCur;

	ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
	pilsobj = ptxtobjCur->plnobj->pilsobj;
	rgwSpaces = pilsobj->pwSpaces;

	fSpaceFound = fFalse;

/* In the case fWrapAllSpaces space is treated as a regular character */

	if (!(pilsobj->grpf & fTxtWrapAllSpaces))
		{
		if (ptxtobjCur->txtkind == txtkindRegular)
			{
			iwSpacesCur = ptxtobjCur->u.reg.iwSpacesFirst;
			while (iwSpacesCur < ptxtobjCur->u.reg.iwSpacesLim &&
						 rgwSpaces[iwSpacesCur] < iwchCur)
				{
				iwSpacesCur++;
				}

			if (ptxtobjCur->txtf & txtfGlyphBased)
				{
				while (iwSpacesCur < ptxtobjCur->u.reg.iwSpacesLim && 
									!FIwchOneToOne(pilsobj, rgwSpaces[iwSpacesCur]))
				iwSpacesCur++;
				}


			if (iwSpacesCur < ptxtobjCur->u.reg.iwSpacesLim)
				{
				fSpaceFound = fTrue;
				*pitxtobjSpace = itxtobjCur;
				*piwchSpace = rgwSpaces[iwSpacesCur];
				}
			}
		else if (ptxtobjCur->txtkind == txtkindSpecSpace)
			{
			fSpaceFound = fTrue;
			*pitxtobjSpace = itxtobjCur;
			*piwchSpace = iwchCur;
			}

		itxtobjCur++;

		while (!fSpaceFound && itxtobjCur < (long)plocchnk->clschnk)
		 	{

			ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;

			if (ptxtobjCur->txtkind == txtkindRegular)
				{

				iwSpacesCur = ptxtobjCur->u.reg.iwSpacesFirst;

				if (ptxtobjCur->txtf & txtfGlyphBased)
					{
					while (iwSpacesCur < ptxtobjCur->u.reg.iwSpacesLim && 
									!FIwchOneToOne(pilsobj, rgwSpaces[iwSpacesCur]))
					iwSpacesCur++;
					}

				if (iwSpacesCur < ptxtobjCur->u.reg.iwSpacesLim)
					{
					fSpaceFound = fTrue;
					*pitxtobjSpace = itxtobjCur;
					*piwchSpace = rgwSpaces[iwSpacesCur];
					}
				}
			else if (ptxtobjCur->txtkind == txtkindSpecSpace)
				{
				fSpaceFound = fTrue;
				*pitxtobjSpace = itxtobjCur;
				*piwchSpace = ptxtobjCur->iwchFirst;
				}

			itxtobjCur++;		

			}
		}

	if (!fSpaceFound)
		{
		*pitxtobjSpace = plocchnk->clschnk;
		*piwchSpace = ((PTXTOBJ)plocchnk->plschnk[plocchnk->clschnk-1].pdobj)->iwchLim;
		}

	return fSpaceFound;
}

/* T R Y  P R E V  B R E A K  F I N D  Y S R */
/*----------------------------------------------------------------------------
    %%Function: TryPrevBreakFindYsr
    %%Contact: sergeyge

	Realizes break if there is one before next space.
	Since each special character has its own dobj we need to check only type of dobj
----------------------------------------------------------------------------*/
static LSERR TryPrevBreakFindYsr(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
								long itxtobjSpace, long iwchSpace,
								BOOL* pfBroken, BOOL* pfFoundYsr, long* pitxtobjYsr, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobjCur;

	ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
	pilsobj = ptxtobjCur->plnobj->pilsobj;

	*pfBroken = fFalse;
	*pfFoundYsr = fFalse;

	/* following condition is almost always TRUE,
	   so in bread-and-butter situation we do almost nothing */ 
	if ((long)itxtobjCur == itxtobjSpace && !(pilsobj->grpf & fTxtApplyBreakingRules))
		{
		return lserrNone;
		}

/* In loop condition check for itxtobjCur > itxtobjSpace is necessary for the case of empty
	DOBJ's: NonReqHyphen, OptBreak
*/
	while((itxtobjCur > itxtobjSpace || iwchCur > iwchSpace) && !*pfBroken)
		{
		ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;

		Assert(ptxtobjCur->txtkind != txtkindEOL && ptxtobjCur->txtkind != txtkindTab);
		Assert(ptxtobjCur->txtkind != txtkindSpecSpace || (pilsobj->grpf & fTxtWrapAllSpaces));

		switch (ptxtobjCur->txtkind)
			{
		case txtkindRegular:
			if (pilsobj->grpf & fTxtApplyBreakingRules)
				{
				lserr = TryPrevBreakRegular(plocchnk, itxtobjCur, iwchSpace, iwchCur, pfBroken, ptbo);
				if (lserr != lserrNone) return lserr;
				}
			break;
		case txtkindHardHyphen:
	        lserr = TryBreakAtHardHyphen(plocchnk, itxtobjCur, iwchCur, brkkindPrev, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			break;
		case txtkindOptBreak:
	        lserr = TryBreakAtOptBreak(plocchnk, itxtobjCur, brkkindPrev, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			break;
		case txtkindNonReqHyphen:
	        lserr = TryBreakAtNonReqHyphen(plocchnk, itxtobjCur, brkkindPrev, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			break;
		case txtkindYsrChar:
			if (!*pfFoundYsr)
				{
				*pfFoundYsr = fTrue;
				*pitxtobjYsr = itxtobjCur;
				}
			break;
		case txtkindSpecSpace:
/* It is possible for fTxtWrapAllSpaces case */
			Assert(pilsobj->grpf & fTxtApplyBreakingRules);
			Assert(pilsobj->grpf & fTxtWrapAllSpaces);

			lserr = TryPrevBreakRegular(plocchnk, itxtobjCur, iwchSpace, iwchCur, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			break;
			}

		iwchCur = ptxtobjCur->iwchFirst - 1;

		itxtobjCur--;

		}

	return lserrNone;
}

/* T R Y  N E X T  B R E A K  F I N D  Y S R */
/*----------------------------------------------------------------------------
    %%Function: TryPrevBreakFindYsr
    %%Contact: sergeyge

	Realizes break if there is one after last space.
	Also fills info about last YSR character after last space.
	Since each special character has its own dobj we need to check only type of dobj
----------------------------------------------------------------------------*/
static LSERR TryNextBreakFindYsr(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
								long itxtobjSpace, long iwchSpace,
								BOOL* pfBroken, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobjCur;

	ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
	pilsobj = ptxtobjCur->plnobj->pilsobj;

	*pfBroken = fFalse;

/* In loop condition check for itxtobjCur < itxtobjSpace is necessary for the case of empty
	DOBJ's: NonReqHyphen, OptBreak
*/
	while((itxtobjCur < itxtobjSpace || iwchCur < iwchSpace) && !*pfBroken)
		{
		ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;

		Assert(ptxtobjCur->txtkind != txtkindSpecSpace || (pilsobj->grpf & fTxtWrapAllSpaces));

		switch (ptxtobjCur->txtkind)
			{
		case txtkindRegular:
			if (pilsobj->grpf & fTxtApplyBreakingRules)
				{
				lserr = TryNextBreakRegular(plocchnk, itxtobjCur, iwchSpace, iwchCur, pfBroken, ptbo);
				if (lserr != lserrNone) return lserr;
				}
			break;
		case txtkindHardHyphen:
	        lserr = TryBreakAtHardHyphen(plocchnk, itxtobjCur, iwchCur, brkkindNext, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			break;
		case txtkindOptBreak:
	        lserr = TryBreakAtOptBreak(plocchnk, itxtobjCur, brkkindNext, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			break;
		case txtkindEOL:
	        lserr = TryBreakAtEOL(plocchnk, itxtobjCur, brkkindNext, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			break;
		case txtkindNonReqHyphen:
	        lserr = TryBreakAtNonReqHyphen(plocchnk, itxtobjCur, brkkindNext, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			break;
		case txtkindSpecSpace:
/* It is possible for fTxtWrapAllSpaces case */
			Assert(pilsobj->grpf & fTxtApplyBreakingRules);
			Assert(pilsobj->grpf & fTxtWrapAllSpaces);

			lserr = TryNextBreakRegular(plocchnk, itxtobjCur, iwchSpace, iwchCur, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			break;
			}

		iwchCur = ptxtobjCur->iwchLim;

		itxtobjCur++;

		}

	return lserrNone;
}


/* T R Y  B R E A K  W I T H  H Y P H E N */
/*----------------------------------------------------------------------------
    %%Function: TryBreakWithHyphen
    %%Contact: sergeyge

	Tries to realize break as hyphenation

	Strategy:

	--Checks if hyphenation should be performed (CheckHotZone)
	--If it should, calls hyphenator.
`	--If hyphenator is successful tryes to insert hyphen
	  else sets break opportunity at the last space
----------------------------------------------------------------------------*/
static LSERR TryBreakWithHyphen(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
						BOOL fSpaceFound, long itxtobjSpace, long iwchSpace,
						BOOL fFoundYsr, long itxtobjYsr, BOOL* pfBroken, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long itxtobjWordStart;
	long iwchWordStart;
	PTXTOBJ ptxtobjWordStart;
	PTXTOBJ ptxtobjYsr;
	long dwchYsr;
	LSCP cpMac;
	LSCP cpWordStart;
	PLSRUN plsrunYsr;
	YSRINF ysrinf;
	HYPHOUT hyphout;
	struct lshyph lshyphLast;
	struct lshyph lshyphNew;
	BOOL fHyphenInserted;
	BOOL fInHyphenZone = fTrue;
	DWORD kysr;
	WCHAR wchYsr;
	long urPenLast;
	OBJDIM objdim;
	BREAKINFO* pbrkinf;
	long itxtobjPrevPrev;
	long durBorder;
	BOOL fSuccessful;
	long i;
	
	if (!fSpaceFound)
		{
		itxtobjWordStart = 0;
		iwchWordStart = ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->iwchFirst;
		}
	else
		{
		itxtobjWordStart = itxtobjSpace;
		iwchWordStart = iwchSpace + 1;
		lserr = CheckHotZone(plocchnk, itxtobjSpace, iwchSpace, &fInHyphenZone);
		if (lserr != lserrNone) return lserr;
		}

	ptxtobjWordStart = (PTXTOBJ)plocchnk->plschnk[itxtobjWordStart].pdobj;
	pilsobj = ptxtobjWordStart->plnobj->pilsobj;

	fHyphenInserted = fFalse;


	if (fInHyphenZone)
		{

		/* Fill lshyphLast if there was YSR character */
		if (fFoundYsr)
			{
			plsrunYsr = plocchnk->plschnk[itxtobjYsr].plsrun;

			lserr = (*pilsobj->plscbk->pfnGetHyphenInfo)(pilsobj->pols, plsrunYsr, &kysr, &wchYsr);
		   	if (lserr != lserrNone) return lserr;
	
			lshyphLast.kysr = kysr;
			lshyphLast.wchYsr = wchYsr;

			lshyphLast.cpYsr = plocchnk->plschnk[itxtobjYsr].cpFirst;
			}
		else
			{
			lshyphLast.kysr = kysrNil;
			}

		Assert (iwchCur >= ((PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj)->iwchFirst ||
		((PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj)->iwchFirst == ((PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj)->iwchLim);

		cpMac = plocchnk->plschnk[itxtobjCur].cpFirst + 
						(iwchCur - ((PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj)->iwchFirst) + 1;

		cpWordStart = plocchnk->plschnk[itxtobjWordStart].cpFirst +
								 (iwchWordStart - ptxtobjWordStart->iwchFirst);

		lshyphNew.kysr = kysrNormal;

		while (!fHyphenInserted && lshyphNew.kysr != kysrNil)
			{
			lserr = (pilsobj->plscbk->pfnHyphenate)(pilsobj->pols, &lshyphLast,	cpWordStart, cpMac, &lshyphNew);

			if (lserr != lserrNone) return lserr;
		
			if (lshyphNew.kysr != kysrNil)
				{
				/* if TryBreak.. will be unsuccessful we will try hyphenation again with a new cpMac */
				Assert(lshyphNew.cpYsr >= cpWordStart && lshyphNew.cpYsr < cpMac);

				cpMac = lshyphNew.cpYsr;
				lshyphLast = lshyphNew;

				for (i=0; i <= itxtobjCur && plocchnk->plschnk[i].cpFirst <= cpMac; i++);

				itxtobjYsr = i - 1;

				Assert(lshyphNew.cpYsr < plocchnk->plschnk[itxtobjYsr].cpFirst + 
																(long)plocchnk->plschnk[itxtobjYsr].dcp);

				dwchYsr = cpMac - plocchnk->plschnk[itxtobjYsr].cpFirst;

				ysrinf.wchYsr = lshyphNew.wchYsr;
				ysrinf.kysr = (WORD)lshyphNew.kysr;

				itxtobjPrevPrev = ichnkOutside;
				for (i=itxtobjYsr; i >= 0 && plocchnk->plschnk[i].cpFirst > cpMac - 1; i--);
				if (i >= 0)
					itxtobjPrevPrev = i;
				
				lserr = ProcessYsr(plocchnk, itxtobjYsr, dwchYsr, itxtobjYsr, itxtobjPrevPrev, ysrinf,
																					&fSuccessful, &hyphout);
				if (lserr != lserrNone) return lserr;
				Assert(hyphout.ddurDnodePrevPrev == 0);

				if (fSuccessful)
					{
					/* try break may be unsuccessful because it won't fit in the column */
					ptxtobjYsr = (PTXTOBJ)plocchnk->plschnk[itxtobjYsr].pdobj;
					if (ptxtobjYsr->txtf & txtfGlyphBased)
						lserr = CalcPartWidthsGlyphs(ptxtobjYsr, dwchYsr + 1, &objdim, &urPenLast);
					else
						lserr = CalcPartWidths(ptxtobjYsr, dwchYsr + 1, &objdim, &urPenLast);
					if (lserr != lserrNone) return lserr;

					durBorder = 0;
					if (plocchnk->plschnk[itxtobjYsr].plschp->fBorder)
						{
						lserr = LsdnGetBorderAfter(pilsobj->plsc, ptxtobjYsr->plsdnUpNode, &durBorder);
						Assert(lserr == lserrNone);
						}

					if (plocchnk->ppointUvLoc[itxtobjYsr].u + urPenLast + hyphout.durChangeTotal + durBorder
																	<= plocchnk->lsfgi.urColumnMax)
						{

						fHyphenInserted = fTrue;

						ptbo->fSuccessful = fTrue;
						ptbo->posichnk.ichnk = itxtobjYsr;
						ptbo->posichnk.dcp = dwchYsr + 1;
						ptbo->objdim = objdim;
						ptbo->objdim.dur = urPenLast + hyphout.durChangeTotal;

						lserr = GetPbrkinf(pilsobj, plocchnk->plschnk[itxtobjYsr].pdobj, brkkindPrev, &pbrkinf);
						if (lserr != lserrNone) return lserr;

						pbrkinf->pdobj = plocchnk->plschnk[itxtobjYsr].pdobj;
						pbrkinf->brkkind = brkkindPrev;
						pbrkinf->dcp = dwchYsr + 1;
						pbrkinf->brkt = brktHyphen;

						pbrkinf->u.hyphen.iwchLim = hyphout.iwchLim;
						pbrkinf->u.hyphen.dwchYsr = hyphout.dwchYsr;
						pbrkinf->u.hyphen.durHyphen = hyphout.durHyphen;
						pbrkinf->u.hyphen.dupHyphen = hyphout.dupHyphen;
						pbrkinf->u.hyphen.durPrev = hyphout.durPrev;
						pbrkinf->u.hyphen.dupPrev = hyphout.dupPrev;
						pbrkinf->u.hyphen.durPrevPrev = hyphout.durPrevPrev;
						pbrkinf->u.hyphen.dupPrevPrev = hyphout.dupPrevPrev;
						pbrkinf->u.hyphen.ddurDnodePrev = hyphout.ddurDnodePrev;
						pbrkinf->u.hyphen.wchPrev = hyphout.wchPrev;
						pbrkinf->u.hyphen.wchPrevPrev = hyphout.wchPrevPrev;
						pbrkinf->u.hyphen.gindHyphen = hyphout.gindHyphen;
						pbrkinf->u.hyphen.gindPrev = hyphout.gindPrev;
						pbrkinf->u.hyphen.gindPrevPrev = hyphout.gindPrevPrev;
						pbrkinf->u.hyphen.igindHyphen = hyphout.igindHyphen;
						pbrkinf->u.hyphen.igindPrev = hyphout.igindPrev;
						pbrkinf->u.hyphen.igindPrevPrev = hyphout.igindPrevPrev;
						}
					}
				}
			}

		}
		
	*pfBroken = fHyphenInserted;

	return lserrNone;
}

/* T R Y  B R E A K  A T  S P A C E */
/*----------------------------------------------------------------------------
    %%Function: TryBreakAtSpace
    %%Contact: sergeyge
	
	Dispatchs desicion to either TryBreakAtSpaceNormal or
								 TryBreakAtSpaceWrap
----------------------------------------------------------------------------*/
static LSERR TryBreakAtSpace(PCLOCCHNK plocchnk, PCPOSICHNK pposichnk, long itxtobjSpace, long iwchSpace, 
							BRKKIND brkkind, BOOL* pfBroken, long* pitxtobjCurNew, long* piwchCurNew, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	BOOL fInChildList;

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobjSpace].pdobj;
	pilsobj = ptxtobj->plnobj->pilsobj;

	Assert(!(pilsobj->grpf & fTxtWrapAllSpaces));

	if (FWrapTrailingSpaces(pilsobj, ptxtobj, fInChildList))
		{
		lserr = TryBreakAtSpaceWrap(plocchnk, pposichnk, itxtobjSpace, iwchSpace, brkkind,
											pfBroken, pitxtobjCurNew, piwchCurNew, ptbo);
		}
	else
		{
		lserr = TryBreakAtSpaceNormal(plocchnk, itxtobjSpace, iwchSpace, brkkind, 
											pfBroken, pitxtobjCurNew, piwchCurNew, ptbo);
		}

	return lserr;
}


/* T R Y  B R E A K  A T  S P A C E  W R A P */
/*----------------------------------------------------------------------------
    %%Function: TryBreakAtSpaceWrap
    %%Contact: sergeyge
	
	Realizes break at space for the fWrapTrailingSpaces case.
----------------------------------------------------------------------------*/
static LSERR TryBreakAtSpaceWrap(PCLOCCHNK plocchnk, PCPOSICHNK pposichnk,
								 long itxtobjSpace, long iwchSpace, BRKKIND brkkind,
								 BOOL* pfBroken, long* pitxtobjCurNew, long* piwchCurNew, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobjSpace;
	long itxtobjBefore;
	long itxtobjAfter;
	long iwchBefore;
	long iwchAfter;
	BOOL fBeforeFound;
	BOOL fAfterFound = fTrue;
	
	*pfBroken = fFalse;
	*pitxtobjCurNew = -1;
	*piwchCurNew = -1;

	ptxtobjSpace = (PTXTOBJ)plocchnk->plschnk[itxtobjSpace].pdobj;
	pilsobj = ptxtobjSpace->plnobj->pilsobj;

	fBeforeFound = FindNonSpaceBefore(plocchnk->plschnk, itxtobjSpace, iwchSpace,
														&itxtobjBefore, &iwchBefore);
	Assert(fBeforeFound || iwchBefore == ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->iwchFirst - 1);
		 /* iwchBefore is needed for check that previous char is not space	*/

	if (brkkind == brkkindPrev &&						/* previous break only, next break must be after */
		iwchSpace - iwchBefore > 1 &&					/* previous character is space	*/
		pposichnk->ichnk != ichnkOutside &&				/* and space exceeds right margin */
		iwchSpace == (long)(((PTXTOBJ)plocchnk->plschnk[pposichnk->ichnk].pdobj)->iwchFirst +
						  						pposichnk->dcp - 1))
		{
		fAfterFound = fTrue;
		itxtobjAfter = itxtobjSpace;
		iwchAfter = iwchSpace;
		}
	else
		{
		fAfterFound = FindNextChar(plocchnk->plschnk, plocchnk->clschnk, itxtobjSpace, iwchSpace,
														 &itxtobjAfter, &iwchAfter);
		}

	lserr = TryBreakAcrossSpaces(plocchnk,
							fBeforeFound, itxtobjBefore, iwchBefore,
							fAfterFound, itxtobjAfter, iwchAfter, brkkind, pfBroken, ptbo);

	if (lserr != lserrNone) return lserr;

	if (!*pfBroken)
		{
		if (brkkind == brkkindPrev)
			{
			FindPrevChar(plocchnk->plschnk, itxtobjSpace, iwchSpace,
														 pitxtobjCurNew, piwchCurNew);
			}
		else
			{
			Assert(brkkind == brkkindNext);
			*pitxtobjCurNew = itxtobjAfter;
			*piwchCurNew = iwchAfter;
			}
		}

	return lserrNone;
}

/* T R Y  B R E A K  A T  S P A C E  N O R M A L */
/*----------------------------------------------------------------------------
    %%Function: TryBreakAtSpaceNormal
    %%Contact: sergeyge
	
	Realizes break at space for the normal (!fWrapTrailingSpaces) case.
----------------------------------------------------------------------------*/
static LSERR TryBreakAtSpaceNormal(PCLOCCHNK plocchnk, long itxtobjSpace, long iwchSpace, BRKKIND brkkind,
								 BOOL* pfBroken, long* pitxtobjCurNew, long* piwchCurNew, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobjSpace;
	long itxtobjBefore;
	long itxtobjAfter;
	long iwchBefore;
	long iwchAfter;
	BOOL fBeforeFound;
	BOOL fAfterFound;
	
	*pfBroken = fFalse;
	*pitxtobjCurNew = -1;
	*piwchCurNew = -1;

	ptxtobjSpace = (PTXTOBJ)plocchnk->plschnk[itxtobjSpace].pdobj;
	pilsobj = ptxtobjSpace->plnobj->pilsobj;

	fBeforeFound = FindNonSpaceBefore(plocchnk->plschnk, 
										itxtobjSpace, iwchSpace, &itxtobjBefore, &iwchBefore);
	Assert(fBeforeFound || iwchBefore == ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->iwchFirst - 1);

	fAfterFound = FindNonSpaceAfter(plocchnk->plschnk, plocchnk->clschnk,
												 itxtobjSpace, iwchSpace, &itxtobjAfter, &iwchAfter);

	lserr = TryBreakAcrossSpaces(plocchnk, fBeforeFound, itxtobjBefore, iwchBefore,
										fAfterFound, itxtobjAfter, iwchAfter, brkkind, pfBroken, ptbo);
	if (lserr != lserrNone) return lserr;

	if (!*pfBroken)
		{
		if (brkkind == brkkindPrev)
			{
			*pitxtobjCurNew = itxtobjBefore;
			*piwchCurNew = iwchBefore;
			}
		else
			{
			Assert(brkkind == brkkindNext);
			*pitxtobjCurNew = itxtobjAfter;
			*piwchCurNew = iwchAfter;
			}
		}

	return lserrNone;
}


/* T R Y  B R E A K  A C R O S S  S P A C E S */
/*----------------------------------------------------------------------------
    %%Function: TryBreakAcrossSpaces
    %%Contact: sergeyge
	
	Checks break across spaces, sets it if it is possible
----------------------------------------------------------------------------*/
static LSERR TryBreakAcrossSpaces(PCLOCCHNK plocchnk,
						BOOL fBeforeFound, long itxtobjBefore, long iwchBefore,
						BOOL fAfterFound, long itxtobjAfter, long iwchAfter, BRKKIND brkkind,
						BOOL* pfBroken, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobjBefore = NULL;
	PTXTOBJ ptxtobjAfter = NULL;
	BRKCLS brkclsLeading = 0;			/* Initialization to keep compiler satisfied */
	BRKCLS brkclsFollowing = 0;			/* Initialization to keep compiler satisfied */
	BRKCLS brkclsJunk;
	BRKCOND brktxt;
	BREAKINFO* pbrkinf;
	BOOL fCanBreak;

	pilsobj = ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	fCanBreak = fTrue;
	*pfBroken = fFalse;

	if (fAfterFound)
		{
		ptxtobjAfter = (PTXTOBJ)plocchnk->plschnk[itxtobjAfter].pdobj;

		if (ptxtobjAfter->txtkind == txtkindEOL)
			{
			lserr = TryBreakAtEOL(plocchnk, itxtobjAfter, brkkind, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			Assert (*pfBroken == fTrue);
			}

		}

	if (!*pfBroken && (pilsobj->grpf & fTxtApplyBreakingRules) )
		{

		if (fAfterFound)
			{
			Assert(ptxtobjAfter->txtkind != txtkindTab && ptxtobjAfter->txtkind != txtkindEOL);
			/* Space After is possible for fWarapTrailingSpaces case*/
			if (ptxtobjAfter->txtkind == txtkindOptBreak ||
				ptxtobjAfter->txtkind == txtkindNonReqHyphen)
				{
				fAfterFound = fFalse;		/* After char of no importance for making break decision */
				}
			else if (!FRegularBreakableBeforeDobj(ptxtobjAfter))
				{
				fCanBreak = fFalse;		/* Cannot break before non-standard dobj's,
										compare with CheckBreakAtLastChar			 */
				}
			else if ((ptxtobjAfter->txtf & txtfGlyphBased) && iwchAfter > ptxtobjAfter->iwchFirst)
				/* if iwchAfter is first character of Dnode, it is definitely not shaped together
					 with the previous char */
				{
				if (!FIwchLastInContext(pilsobj, iwchAfter - 1))
					{
					fCanBreak = fFalse;
				/* Additional hack to handle case when Accented spaces are separated by spaces */
					if (iwchAfter - 1 > iwchBefore + 1 && /* There are more spaces in between */
						FIwchFirstInContext(pilsobj, iwchAfter - 1) )
						{
						fCanBreak = fTrue;
						iwchAfter--;
						}
					}
				}
			}
		else
			{
			if (brkkind == brkkindPrev)
			/* patch for the cases when we break across spaces 
				at the end of text chunk during PrevBreak logic.
				Problems are possible because trailing spaces could exceed RM, 
				and no information about following chunk was passed in.
			*/
				{
				BOOL fStoppedAfter;
				
				Assert(fCanBreak);
				Assert(plocchnk->clschnk > 0);
				/* Check if there is Splat, or Hidden text producing fStopped after this chunk
					In this case we must break after
					(we will set fAfterFound and fBeforeFound to False to ensure it)
				*/
				lserr = LsdnFStoppedAfterChunk(pilsobj->plsc,
							((PTXTOBJ)plocchnk->plschnk[plocchnk->clschnk-1].pdobj)->plsdnUpNode,
							&fStoppedAfter);
				if (lserr != lserrNone) return lserr;

				if (fStoppedAfter)
					{
					Assert(fCanBreak);
					Assert(!fAfterFound);
					fBeforeFound = fFalse;
					}
				else
				/* If there is no Splat, or Hidden text producing fStopped after this chunk
					we should not break if next chunk returnd brkcondNever on the left side.
				*/
					{

					lserr = LsdnFCanBreakBeforeNextChunk(pilsobj->plsc,
							((PTXTOBJ)plocchnk->plschnk[plocchnk->clschnk-1].pdobj)->plsdnUpNode,
							&fCanBreak);
					if (lserr != lserrNone) return lserr;
					}
				}
			else
				{
				Assert (brkkind == brkkindNext);
				fCanBreak = fFalse;		/* Do not break; let code at the ens of FindNextBreak set correct brkcond */
				}
			}

		if (fBeforeFound)
			{
			ptxtobjBefore = (PTXTOBJ)plocchnk->plschnk[itxtobjBefore].pdobj;

			Assert(ptxtobjBefore->txtkind != txtkindTab &&
				   ptxtobjBefore->txtkind != txtkindSpecSpace &&
				   ptxtobjBefore->txtkind != txtkindEOL);

			if (ptxtobjBefore->txtkind == txtkindHardHyphen ||
				ptxtobjBefore->txtkind == txtkindOptBreak ||
				ptxtobjBefore->txtkind == txtkindNonReqHyphen)
				{
				fBeforeFound = fFalse;		/* Before char of no importance for making break decision */
				}
			else if (ptxtobjBefore->txtkind == txtkindNonBreakSpace ||
				ptxtobjBefore->txtkind == txtkindNonBreakHyphen ||
				ptxtobjBefore->txtkind == txtkindOptNonBreak)
				{
				fCanBreak = fFalse;		/* Cannot break after Non-Breaks */
				}
			}

		if (fCanBreak)
			{
			if (fBeforeFound)
				{
				lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plocchnk->plschnk[itxtobjBefore].plsrun,
					plocchnk->plschnk[itxtobjBefore].cpFirst + (iwchBefore - ptxtobjBefore->iwchFirst),
					pilsobj->pwchOrig[iwchBefore], &brkclsLeading, &brkclsJunk);
				if (lserr != lserrNone) return lserr;

				Assert(brkclsLeading < pilsobj->cBreakingClasses && brkclsJunk < pilsobj->cBreakingClasses);
				if (brkclsLeading >= pilsobj->cBreakingClasses || brkclsJunk >= pilsobj->cBreakingClasses)
						return lserrInvalidBreakingClass;
				}

			if (fAfterFound)
				{
				lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plocchnk->plschnk[itxtobjAfter].plsrun,
					plocchnk->plschnk[itxtobjAfter].cpFirst + (iwchAfter - ptxtobjAfter->iwchFirst),					
					pilsobj->pwchOrig[iwchAfter], &brkclsJunk, &brkclsFollowing);
				if (lserr != lserrNone) return lserr;

				Assert(brkclsJunk < pilsobj->cBreakingClasses && brkclsFollowing < pilsobj->cBreakingClasses);
				if (brkclsJunk >= pilsobj->cBreakingClasses || brkclsFollowing >= pilsobj->cBreakingClasses)
						return lserrInvalidBreakingClass;
				}

			if (fBeforeFound && fAfterFound)
				{
				fCanBreak = FCanBreakAcrossSpaces(pilsobj, brkclsLeading, brkclsFollowing);
				}
			else if (fBeforeFound && !fAfterFound)
				{
				lserr = (*pilsobj->plscbk->pfnCanBreakAfterChar)(pilsobj->pols, brkclsLeading, &brktxt);
				if (lserr != lserrNone) return lserr;
				fCanBreak = (brktxt != brkcondNever);
				}
			else if (!fBeforeFound && fAfterFound)
				{
				lserr = (*pilsobj->plscbk->pfnCanBreakBeforeChar)(pilsobj->pols, brkclsFollowing, &brktxt);
				if (lserr != lserrNone) return lserr;
				fCanBreak = (brktxt != brkcondNever);
				}
			}
		}

	if (!*pfBroken && fCanBreak)
		{
		FillPtboPbrkinf(plocchnk, itxtobjAfter, iwchAfter - 1, /*itxtobjBefore,*/ iwchBefore,
																	brkkind, &pbrkinf, ptbo);
		*pfBroken = fTrue;
		}

	return lserrNone;

}

/* T R Y  P R E V  B R E A K  R E G U L A R */
/*----------------------------------------------------------------------------
    %%Function: TryPrevBreakRegular
    %%Contact: sergeyge
	
	Checks (and sets) for prev break inside regular dobj
----------------------------------------------------------------------------*/
static LSERR TryPrevBreakRegular(PCLOCCHNK plocchnk, long itxtobj, long iwchSpace, long iwchCur,
																	BOOL* pfBroken, PBRKOUT ptbo)
{
	LSERR lserr;
	PTXTOBJ ptxtobj;
	PILSOBJ pilsobj;
	PLSRUN plsrun;
	long iwchFirst;
	BRKCLS brkclsFollowingCache;
	BRKCLS brkclsLeading;
	BRKCLS brkclsFollowing;
	BREAKINFO* pbrkinf;
	
	*pfBroken = fFalse;
	if (iwchCur <= iwchSpace) return lserrNone;

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj;
	pilsobj = ptxtobj->plnobj->pilsobj;

	Assert(ptxtobj->txtkind == txtkindRegular || 
		(ptxtobj->txtkind == txtkindSpecSpace && (pilsobj->grpf & fTxtWrapAllSpaces)));

	Assert( pilsobj->grpf & fTxtApplyBreakingRules );
	plsrun = plocchnk->plschnk[itxtobj].plsrun;

	iwchFirst = ptxtobj->iwchFirst;
	if (iwchSpace + 1 > iwchFirst)
		iwchFirst = iwchSpace + 1;

	lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plsrun,
				plocchnk->plschnk[itxtobj].cpFirst + (iwchCur - ptxtobj->iwchFirst),			
				pilsobj->pwchOrig[iwchCur], &brkclsLeading, &brkclsFollowingCache);
	if (lserr != lserrNone) return lserr;

	Assert(brkclsLeading < pilsobj->cBreakingClasses && brkclsFollowingCache < pilsobj->cBreakingClasses);
	if (brkclsLeading >= pilsobj->cBreakingClasses || brkclsFollowingCache >= pilsobj->cBreakingClasses)
					return lserrInvalidBreakingClass;


	lserr = CheckBreakAtLastChar(plocchnk, brkclsLeading, iwchCur, itxtobj, pfBroken);
	if (lserr != lserrNone) return lserr;

	iwchCur--;

	while (!*pfBroken && iwchCur >= iwchFirst)
		{
		brkclsFollowing = brkclsFollowingCache;
		lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plsrun,
			plocchnk->plschnk[itxtobj].cpFirst + (iwchCur - ptxtobj->iwchFirst),				
			pilsobj->pwchOrig[iwchCur], &brkclsLeading, &brkclsFollowingCache);
		if (lserr != lserrNone) return lserr;
	
		Assert(brkclsLeading < pilsobj->cBreakingClasses && brkclsFollowingCache < pilsobj->cBreakingClasses);
		if (brkclsLeading >= pilsobj->cBreakingClasses || brkclsFollowingCache >= pilsobj->cBreakingClasses)
					return lserrInvalidBreakingClass;

		*pfBroken = FCanBreak(pilsobj, brkclsLeading, brkclsFollowing) && 
					(!(ptxtobj->txtf & txtfGlyphBased) || FIwchLastInContext(pilsobj, iwchCur));
		iwchCur --;
		}

	if (*pfBroken)
		{
		lserr = FillPtboPbrkinf(plocchnk, itxtobj, iwchCur+1, /*itxtobj,*/ iwchCur+1, 
															brkkindPrev, &pbrkinf, ptbo);
		if (lserr != lserrNone) return lserr;
		/* fModWidthSpace can be at the last char here only iff fWrapAllSpaces;
			if we touch balanced space here, the logic of GetMinCompressAmount should be rethinked!*/
		if (pilsobj->pdurRight != NULL && pilsobj->pdurRight[iwchCur + 1] > 0 &&
													!pilsobj->ptxtinf[iwchCur - 1].fModWidthSpace)
			{
			pbrkinf->u.normal.durFix = - pilsobj->pdurRight[iwchCur + 1];
			ptbo->objdim.dur -= pilsobj->pdurRight[iwchCur + 1];
			}
		}

	return lserrNone;

}

/* T R Y  N E X T  B R E A K  R E G U L A R */
/*----------------------------------------------------------------------------
    %%Function: TryNextBreakRegular
    %%Contact: sergeyge
	
	Checks (and sets) for next break inside regular dobj
----------------------------------------------------------------------------*/
static LSERR TryNextBreakRegular(PCLOCCHNK plocchnk, long itxtobj, long iwchSpace, long iwchCur,
																		BOOL* pfBroken, PBRKOUT ptbo)
{
	LSERR lserr;
	PTXTOBJ ptxtobj;
	PILSOBJ pilsobj;
	PLSRUN plsrun;
	long iwchLast;
	BRKCLS brkclsLeadingCache;
	BRKCLS brkclsLeading;
	BRKCLS brkclsFollowing;
	BRKCLS brkclsJunk;
	BREAKINFO* pbrkinf;
	
	*pfBroken = fFalse;
	if (iwchCur >= iwchSpace) return lserrNone;

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj;
	pilsobj = ptxtobj->plnobj->pilsobj;

	Assert(ptxtobj->txtkind == txtkindRegular || 
		(ptxtobj->txtkind == txtkindSpecSpace && (pilsobj->grpf & fTxtWrapAllSpaces)));

	Assert(pilsobj->grpf & fTxtApplyBreakingRules);
	plsrun = plocchnk->plschnk[itxtobj].plsrun;

	iwchLast = ptxtobj->iwchLim - 1;
	/* The last possibility for break is BEFORE LAST CHAR before space */
	if (iwchSpace - 1 < iwchLast)
		iwchLast = iwchSpace - 1;

	lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plsrun,
		plocchnk->plschnk[itxtobj].cpFirst + (iwchCur - ptxtobj->iwchFirst),
		pilsobj->pwchOrig[iwchCur], &brkclsLeadingCache, &brkclsJunk);
	if (lserr != lserrNone) return lserr;

	Assert(brkclsLeadingCache < pilsobj->cBreakingClasses && brkclsJunk < pilsobj->cBreakingClasses);
	if (brkclsLeadingCache >= pilsobj->cBreakingClasses || brkclsJunk >= pilsobj->cBreakingClasses)
					return lserrInvalidBreakingClass;

	while (!*pfBroken && iwchCur < iwchLast)
		{
		brkclsLeading = brkclsLeadingCache;
		lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plsrun,
			plocchnk->plschnk[itxtobj].cpFirst + (iwchCur + 1 - ptxtobj->iwchFirst),
			pilsobj->pwchOrig[iwchCur + 1], &brkclsLeadingCache, &brkclsFollowing);
		if (lserr != lserrNone) return lserr;

		Assert(brkclsLeadingCache < pilsobj->cBreakingClasses && brkclsFollowing < pilsobj->cBreakingClasses);
		if (brkclsLeadingCache >= pilsobj->cBreakingClasses || brkclsFollowing >= pilsobj->cBreakingClasses)
					return lserrInvalidBreakingClass;

		*pfBroken = FCanBreak(pilsobj, brkclsLeading, brkclsFollowing) &&
					(!(ptxtobj->txtf & txtfGlyphBased) || FIwchLastInContext(pilsobj, iwchCur));

		iwchCur++;
		}

	if (!*pfBroken && iwchCur == iwchLast && iwchLast < iwchSpace - 1)
		{
		lserr = CheckBreakAtLastChar(plocchnk, brkclsLeadingCache, iwchLast, itxtobj, pfBroken);
		iwchCur++;
		if (lserr != lserrNone) return lserr;
		}

	if (*pfBroken)
		{
		Assert (iwchCur >= 1);

		FillPtboPbrkinf(plocchnk, itxtobj, iwchCur-1, /*itxtobj,*/ iwchCur-1, brkkindNext, &pbrkinf, ptbo);

		/* fModWidthSpace can be at the last char here only iff fWrapAllSpaces;
			if we touch balanced space here, the logic of GetMinCompressAmount should be rethinked!*/
		if (pilsobj->pdurRight != NULL && pilsobj->pdurRight[iwchCur - 1] != 0 &&
													!pilsobj->ptxtinf[iwchCur - 1].fModWidthSpace)
			{
			pbrkinf->u.normal.durFix = - pilsobj->pdurRight[iwchCur - 1];
			ptbo->objdim.dur -= pilsobj->pdurRight[iwchCur - 1];
			}

		}

	return lserrNone;

}

/* C H E C K  B R E A K  A T  L A S T  C H A R */
/*----------------------------------------------------------------------------
    %%Function: CheckBreakAtLastChar
    %%Contact: sergeyge
	
	Checks (and sets) for prev break inside regular dobj
----------------------------------------------------------------------------*/
static LSERR CheckBreakAtLastChar(PCLOCCHNK plocchnk, BRKCLS brkclsLeading, long iwch, long itxtobj, BOOL* pfBroken)
{
	LSERR lserr;
	PTXTOBJ ptxtobj;
	PILSOBJ pilsobj;
	long itxtobjAfter;
	long iwchAfter;
	BRKCLS brkclsFollowing;
	BRKCLS brkclsJunk;
/*	BRKTXTCOND brktxt;*/

	*pfBroken = fFalse;

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj;
	pilsobj = ptxtobj->plnobj->pilsobj;

	if ((ptxtobj->txtf & txtfGlyphBased) && !FIwchLastInContext(pilsobj, iwch))
		return lserrNone;

	pilsobj = ptxtobj->plnobj->pilsobj;

	if (iwch < ptxtobj->iwchLim - 1)
		{
		lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plocchnk->plschnk[itxtobj].plsrun,
			plocchnk->plschnk[itxtobj].cpFirst + (iwch + 1 - ptxtobj->iwchFirst),
			pilsobj->pwchOrig[iwch + 1], &brkclsJunk, &brkclsFollowing);
		if (lserr != lserrNone) return lserr;

		Assert(brkclsJunk < pilsobj->cBreakingClasses && brkclsFollowing < pilsobj->cBreakingClasses);
		if (brkclsJunk >= pilsobj->cBreakingClasses || brkclsFollowing >= pilsobj->cBreakingClasses)
					return lserrInvalidBreakingClass;

		*pfBroken = FCanBreak(pilsobj, brkclsLeading, brkclsFollowing);

		}
	else if (FindNextChar(plocchnk->plschnk, plocchnk->clschnk, itxtobj, iwch, 
															&itxtobjAfter, &iwchAfter))
		{

		ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobjAfter].pdobj;

		if (FRegularBreakableBeforeDobj(ptxtobj))
			{
			Assert(ptxtobj->txtkind != txtkindSpecSpace || (pilsobj->grpf & fTxtWrapAllSpaces) );
						
			lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plocchnk->plschnk[itxtobjAfter].plsrun,
				plocchnk->plschnk[itxtobjAfter].cpFirst + (iwchAfter - ptxtobj->iwchFirst),
				pilsobj->pwchOrig[iwchAfter], &brkclsJunk, &brkclsFollowing);
			if (lserr != lserrNone) return lserr;

			Assert(brkclsJunk < pilsobj->cBreakingClasses && brkclsFollowing < pilsobj->cBreakingClasses);
			if (brkclsJunk >= pilsobj->cBreakingClasses || brkclsFollowing >= pilsobj->cBreakingClasses)
					return lserrInvalidBreakingClass;


			*pfBroken = FCanBreak(pilsobj, brkclsLeading, brkclsFollowing);
			}

		}
/* Manager takes care of the ELSE situation; */

	return lserrNone;

}

/* T R Y  B R E A K  A T  H A R D  H Y P H E N */
/*----------------------------------------------------------------------------
    %%Function: TryBreakAtHardHyphen
    %%Contact: sergeyge
	
	Realizes break at hard hyphen
----------------------------------------------------------------------------*/
static LSERR TryBreakAtHardHyphen(PCLOCCHNK plocchnk, long itxtobj, long iwch, BRKKIND brkkind,
													BOOL* pfBroken, PBRKOUT ptbo)
{

	LSERR lserr;
	BREAKINFO* pbrkinf;

	Assert(((PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj)->txtkind == txtkindHardHyphen);
	Assert(!(((PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj)->txtf & txtfGlyphBased));

	lserr = FillPtboPbrkinf(plocchnk, itxtobj, iwch, /*itxtobj,*/ iwch, brkkind, &pbrkinf, ptbo);
	if (lserr != lserrNone) return lserr;

	*pfBroken = fTrue;

	return lserrNone;
}

/* T R Y  B R E A K  A T  O P T  B R E A K */
/*----------------------------------------------------------------------------
    %%Function: TryBreakAtOptBreak
    %%Contact: sergeyge
	
	Realizes break at OptBreak
----------------------------------------------------------------------------*/
static LSERR TryBreakAtOptBreak(PCLOCCHNK plocchnk, long itxtobj, BRKKIND brkkind,
																 BOOL* pfBroken, PBRKOUT ptbo)
{

	LSERR lserr;
	PTXTOBJ ptxtobj;
	BREAKINFO* pbrkinf;

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj;
	Assert(!(ptxtobj->txtf & txtfGlyphBased));

	Assert(ptxtobj->txtkind == txtkindOptBreak);
	Assert(ptxtobj->iwchLim == ptxtobj->iwchFirst + 1 && (ptxtobj->txtf & txtfVisi)||
			ptxtobj->iwchLim == ptxtobj->iwchFirst);

	lserr = FillPtboPbrkinf(plocchnk, itxtobj, ptxtobj->iwchLim-1, /*itxtobj,*/ ptxtobj->iwchLim-1,
											brkkind, &pbrkinf, ptbo);
	if (lserr != lserrNone) return lserr;
	
	ptbo->posichnk.dcp = 1;
	pbrkinf->dcp = 1;
	pbrkinf->brkt = brktOptBreak;

	*pfBroken = fTrue;

	return lserrNone;
}


/* T R Y  B R E A K  A T  E O L */
/*----------------------------------------------------------------------------
    %%Function: TryBreakAtEOL
    %%Contact: sergeyge
	
	Realizes break at EOP/EOL
----------------------------------------------------------------------------*/
static LSERR TryBreakAtEOL(PCLOCCHNK plocchnk, long itxtobj, BRKKIND brkkind, BOOL* pfBroken, PBRKOUT ptbo)
{

	LSERR lserr;
	PTXTOBJ ptxtobj;
	long itxtobjBefore;
	long iwchBefore;
	BREAKINFO* pbrkinf;

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj; 

	Assert(ptxtobj->txtkind == txtkindEOL);
	Assert(ptxtobj->iwchLim == ptxtobj->iwchFirst + 1);

	FindNonSpaceBefore(plocchnk->plschnk, itxtobj, ptxtobj->iwchFirst, &itxtobjBefore, &iwchBefore);

	lserr = FillPtboPbrkinf(plocchnk, itxtobj, ptxtobj->iwchFirst, /*itxtobjBefore,*/ iwchBefore, 
													brkkind, &pbrkinf, ptbo);
	if (lserr != lserrNone) return lserr;

	*pfBroken = fTrue;

	return lserrNone;
}


/* T R Y  B R E A K  A T  N O N  R E Q  H Y P H E N */
/*----------------------------------------------------------------------------
    %%Function: TryBreakAtNonReqHyphen
    %%Contact: sergeyge
	
	Realizes break at NonReqHyphen.
----------------------------------------------------------------------------*/
static LSERR TryBreakAtNonReqHyphen(PCLOCCHNK plocchnk, long itxtobj, BRKKIND brkkind,
																 BOOL* pfBroken, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	YSRINF ysrinf;
	HYPHOUT hyphout;
	BREAKINFO* pbrkinf;
	LSCP cpMac;
	DWORD kysr;
	WCHAR wchYsr;
	long itxtobjPrev;
	long itxtobjPrevPrev;
	BOOL fSuccessful;
	long durBorder;
	long i;

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;
	cpMac = plocchnk->plschnk[itxtobj].cpFirst;

	Assert( ptxtobj->txtkind == txtkindNonReqHyphen);
	Assert(!(ptxtobj->txtf & txtfGlyphBased));

	lserr = (*pilsobj->plscbk->pfnGetHyphenInfo)(pilsobj->pols, plocchnk->plschnk[itxtobj].plsrun, &kysr, &wchYsr);
   	if (lserr != lserrNone) return lserr;

	if (kysr == kysrNil)
		kysr = kysrNormal;

	ysrinf.wchYsr = wchYsr;
	ysrinf.kysr = (WORD)kysr;

	itxtobjPrev = ichnkOutside;
	for (i=itxtobj; i >= 0 && plocchnk->plschnk[i].cpFirst > cpMac - 1; i--);
	if (i >= 0)
		itxtobjPrev = i;

	itxtobjPrevPrev = ichnkOutside;
	for (i=itxtobj; i >= 0 && plocchnk->plschnk[i].cpFirst > cpMac - 2; i--);
	if (i >= 0)
		itxtobjPrevPrev = i;
	
	lserr = ProcessYsr(plocchnk, itxtobj, - 1, itxtobjPrev, itxtobjPrevPrev, ysrinf, &fSuccessful, &hyphout);
	if (lserr != lserrNone) return lserr;

	if (fSuccessful)
		{

		durBorder = 0;
		if (plocchnk->plschnk[itxtobj].plschp->fBorder)
			{
			lserr = LsdnGetBorderAfter(pilsobj->plsc, ptxtobj->plsdnUpNode, &durBorder);
			Assert(lserr == lserrNone);
			}

		if (plocchnk->ppointUvLoc[itxtobj].u + hyphout.durChangeTotal + durBorder <= 
									plocchnk->lsfgi.urColumnMax || brkkind == brkkindNext)
			{
			*pfBroken = fTrue;

			ptbo->fSuccessful = fTrue;
			ptbo->posichnk.ichnk = itxtobj;
			ptbo->posichnk.dcp = 1;

			lserr = LsdnGetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, &ptbo->objdim);
			if (lserr != lserrNone) return lserr;

			ptbo->objdim.dur += hyphout.durChangeTotal;

			lserr = GetPbrkinf(pilsobj, plocchnk->plschnk[itxtobj].pdobj, brkkind, &pbrkinf);
			if (lserr != lserrNone) return lserr;

			pbrkinf->pdobj = plocchnk->plschnk[itxtobj].pdobj;
			pbrkinf->brkkind = brkkind;
			pbrkinf->dcp = 1;

			pbrkinf->brkt = brktNonReq;

			pbrkinf->u.nonreq.durHyphen = hyphout.durHyphen;
			if (pilsobj->grpf & fTxtVisiCondHyphens)
				{
				pbrkinf->u.nonreq.wchHyphenPres = pilsobj->wchVisiNonReqHyphen;
				pbrkinf->u.nonreq.dupHyphen = plnobj->pdup[ptxtobj->iwchFirst];
				}
			else
				{	
				pbrkinf->u.nonreq.wchHyphenPres = pilsobj->wchHyphen;
				pbrkinf->u.nonreq.dupHyphen = hyphout.dupHyphen;
				}

			pbrkinf->u.nonreq.iwchLim = hyphout.iwchLim;
			pbrkinf->u.nonreq.dwchYsr = hyphout.dwchYsr - 1;
			pbrkinf->u.nonreq.durPrev = hyphout.durPrev;
			pbrkinf->u.nonreq.dupPrev = hyphout.dupPrev;
			pbrkinf->u.nonreq.durPrevPrev = hyphout.durPrevPrev;
			pbrkinf->u.nonreq.dupPrevPrev = hyphout.dupPrevPrev;
			pbrkinf->u.nonreq.ddurDnodePrev = hyphout.ddurDnodePrev;
			pbrkinf->u.nonreq.ddurDnodePrevPrev = hyphout.ddurDnodePrevPrev;
			pbrkinf->u.nonreq.ddurTotal = hyphout.durChangeTotal;
			pbrkinf->u.nonreq.wchPrev = hyphout.wchPrev;
			pbrkinf->u.nonreq.wchPrevPrev = hyphout.wchPrevPrev;
			pbrkinf->u.nonreq.gindPrev = hyphout.gindPrev;
			pbrkinf->u.nonreq.gindPrevPrev = hyphout.gindPrevPrev;
			pbrkinf->u.nonreq.igindPrev = hyphout.igindPrev;
			pbrkinf->u.nonreq.igindPrevPrev = hyphout.igindPrevPrev;
			}
		}
	return lserrNone;
}

/* T R Y  B R E A K  A F T E R  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: TryBreakAfterChunk
    %%Contact: sergeyge

----------------------------------------------------------------------------*/
static LSERR TryBreakAfterChunk(PCLOCCHNK plocchnk, BRKCOND brkcond, BOOL* pfBroken, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobjLast;
	long itxtobjLast;
	long iwchLast;
	long itxtobjBefore;
	long iwchBefore;
	BOOL fNonSpaceFound;
	BRKCOND brkcondTemp;
	BREAKINFO* pbrkinf;
	

	*pfBroken = fFalse;

	itxtobjLast = plocchnk->clschnk-1;
	ptxtobjLast = (PTXTOBJ)plocchnk->plschnk[itxtobjLast].pdobj;
	pilsobj = ptxtobjLast->plnobj->pilsobj;
	iwchLast = ptxtobjLast->iwchLim - 1;

	Assert(ptxtobjLast->txtkind != txtkindTab &&
			   ptxtobjLast->txtkind != txtkindEOL);

	switch (ptxtobjLast->txtkind)
		{
	case txtkindRegular:
	case txtkindSpecSpace:
	case txtkindYsrChar:

		fNonSpaceFound = FindNonSpaceBefore(plocchnk->plschnk, itxtobjLast, iwchLast,
																	&itxtobjBefore, &iwchBefore);

		if (pilsobj->grpf & fTxtApplyBreakingRules)

			{
			lserr = CanBreakAfterText(plocchnk, fNonSpaceFound, itxtobjBefore, iwchBefore, &brkcondTemp);
			if (lserr != lserrNone) return lserr;
			if (iwchBefore != iwchLast && brkcondTemp == brkcondCan)
				brkcondTemp = brkcondPlease;

			if (brkcond == brkcondPlease && brkcondTemp != brkcondNever ||
				brkcond == brkcondCan && brkcondTemp == brkcondPlease)
				{
				*pfBroken = fTrue;
				lserr = FillPtboPbrkinf(plocchnk, itxtobjLast, iwchLast, /*itxtobjBefore,*/ iwchBefore,
																		brkkindPrev, &pbrkinf, ptbo);
				if (lserr != lserrNone) return lserr;
				}
			}
		else
			{
			Assert(iwchLast >= ptxtobjLast->iwchFirst);
			if (brkcond == brkcondPlease || 
				brkcond == brkcondCan && iwchLast != iwchBefore)
				{
				*pfBroken = fTrue;
				lserr = FillPtboPbrkinf(plocchnk, itxtobjLast, iwchLast, /*itxtobjBefore,*/ iwchBefore,
																		brkkindPrev, &pbrkinf, ptbo);
				if (lserr != lserrNone) return lserr;
				}
			}
		break;
	case txtkindNonBreakSpace:
	case txtkindNonBreakHyphen:
	case txtkindOptNonBreak:
		break;
	case txtkindHardHyphen:
        lserr = TryBreakAtHardHyphen(plocchnk, itxtobjLast, iwchLast, brkkindPrev, pfBroken, ptbo);
		if (lserr != lserrNone) return lserr;
		break;
	case txtkindOptBreak:
        lserr = TryBreakAtOptBreak(plocchnk, itxtobjLast, brkkindPrev, pfBroken, ptbo);
		if (lserr != lserrNone) return lserr;
		break;
	case txtkindNonReqHyphen:
        lserr = TryBreakAtNonReqHyphen(plocchnk, itxtobjLast, brkkindPrev, pfBroken, ptbo);
		if (lserr != lserrNone) return lserr;
		break;
		}
	
	return lserrNone;
}

/* T R Y  B R E A K  B E F O R E  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: TryBreakBeforeChunk
    %%Contact: sergeyge

----------------------------------------------------------------------------*/
static LSERR TryBreakBeforeChunk(PCLOCCHNK plocchnk, BRKCOND brkcond, BOOL* pfBroken, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	BRKCOND brkcondTemp;

	pilsobj = ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	*pfBroken = fFalse;

	if (!(pilsobj->grpf & fTxtApplyBreakingRules))
		*pfBroken = (brkcond == brkcondPlease);
	else 
		{
		lserr = CanBreakBeforeText(plocchnk, &brkcondTemp);
		if (lserr != lserrNone) return lserr;
		*pfBroken = (brkcond == brkcondPlease && brkcondTemp != brkcondNever ||
						brkcond == brkcondCan && brkcondTemp == brkcondPlease);			
		}

	if (*pfBroken)
		{
		memset(ptbo, 0, sizeof (*ptbo));
		ptbo->fSuccessful = fTrue;
		return lserrNone;
		}

	return lserrNone;

}



/* C A N  B R E A K  B E F O R E  T E X T */
/*----------------------------------------------------------------------------
    %%Function: CanBreakBeforeText
    %%Contact: sergeyge

	Checks if break before text chunk is possible.
----------------------------------------------------------------------------*/
static LSERR CanBreakBeforeText(PCLOCCHNK plocchnk, BRKCOND* pbrktxt)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	WCHAR wch;
	BRKCLS brkclsBefore;
	BRKCLS brkclsJunk;

	Assert(plocchnk->clschnk > 0);
	ptxtobj = (PTXTOBJ)plocchnk->plschnk[0].pdobj;
	pilsobj = ptxtobj->plnobj->pilsobj;
	if (plocchnk->lsfgi.fFirstOnLine || !FRegularBreakableBeforeDobj(ptxtobj))
		{
		*pbrktxt = brkcondNever;
		}
	else
		{
		wch = pilsobj->pwchOrig[ptxtobj->iwchFirst];
		if ( (wch == pilsobj->wchSpace || ptxtobj->txtkind == txtkindSpecSpace) &&
					 !(pilsobj->grpf & fTxtWrapAllSpaces) )
			{
			*pbrktxt = brkcondNever;
			}
		else
			{
			lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plocchnk->plschnk[0].plsrun,
					plocchnk->plschnk[0].cpFirst, wch, &brkclsJunk, &brkclsBefore);
			if (lserr != lserrNone) return lserr;

			lserr = (*pilsobj->plscbk->pfnCanBreakBeforeChar)(pilsobj->pols, brkclsBefore, pbrktxt);
			if (lserr != lserrNone) return lserr;
			
			}
		}

	return lserrNone;

}				

/* C A N  B R E A K  A F T E R  T E X T */
/*----------------------------------------------------------------------------
    %%Function: CanBreakAfterText
    %%Contact: sergeyge

	Checks if break after text chunk is possible.
----------------------------------------------------------------------------*/
static LSERR CanBreakAfterText(PCLOCCHNK plocchnk, BOOL fNonSpaceFound, long itxtobjBefore,
																	long iwchBefore, BRKCOND* pbrktxt)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	BRKCLS brkclsAfter;
	BRKCLS brkclsJunk;

	if (fNonSpaceFound)
		{
		ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobjBefore].pdobj;
		
		pilsobj = ptxtobj->plnobj->pilsobj;

		Assert(ptxtobj->txtkind != txtkindTab &&
			   ptxtobj->txtkind != txtkindSpecSpace &&
			   ptxtobj->txtkind != txtkindEOL);

		if (ptxtobj->txtkind == txtkindHardHyphen ||
			ptxtobj->txtkind == txtkindOptBreak ||
			ptxtobj->txtkind == txtkindNonReqHyphen)
			{
			*pbrktxt = brkcondPlease;
			}
		else if (ptxtobj->txtkind == txtkindNonBreakSpace ||
			ptxtobj->txtkind == txtkindNonBreakHyphen ||
			ptxtobj->txtkind == txtkindOptNonBreak)
			{
			*pbrktxt = brkcondNever;
			}
		else
			{
			Assert(ptxtobj->txtkind == txtkindRegular ||
			   ptxtobj->txtkind == txtkindYsrChar);

			lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols,
				plocchnk->plschnk[itxtobjBefore].plsrun,
				plocchnk->plschnk[itxtobjBefore].cpFirst + (iwchBefore - ptxtobj->iwchFirst),
				pilsobj->pwchOrig[iwchBefore], &brkclsAfter, &brkclsJunk);
			if (lserr != lserrNone) return lserr;

			lserr = (*pilsobj->plscbk->pfnCanBreakAfterChar)(pilsobj->pols, brkclsAfter, pbrktxt);
			if (lserr != lserrNone) return lserr;
			}
		}
	else
		{
		/* REVIEW sergeyge: check if it is correct	*/
		*pbrktxt = brkcondPlease;
//		*pbrktxt = brkcondNever;
		}

	return lserrNone;

}				

/* F I L L  P T B O  P B R K I N F */
/*----------------------------------------------------------------------------
    %%Function: FillPtboPbrkinf
    %%Contact: sergeyge
	
	Prepares output of the breaking procedure
----------------------------------------------------------------------------*/
static LSERR FillPtboPbrkinf(PCLOCCHNK plocchnk, long itxtobj, long iwch, 
										/* long itxtobjBefore,*/ long iwchBefore, BRKKIND brkkind,
										BREAKINFO** ppbrkinf, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long dwchBreak;
	long igindLim;
	long dur;

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj;
	pilsobj = ptxtobj->plnobj->pilsobj;
	dwchBreak = iwch - ptxtobj->iwchFirst + 1;
	igindLim = 0;

	if (ptxtobj->txtf & txtfGlyphBased)
		{
		igindLim = IgindFirstFromIwch(ptxtobj, ptxtobj->iwchFirst + dwchBreak);
		lserr = CalcPartWidthsGlyphs(ptxtobj, dwchBreak, &ptbo->objdim, &dur);
		}
	else
		lserr = CalcPartWidths(ptxtobj, dwchBreak, &ptbo->objdim, &dur);
	if (lserr != lserrNone) return lserr;

	ptbo->fSuccessful = fTrue;
	ptbo->objdim.dur = dur;
	ptbo->posichnk.ichnk = itxtobj;
	ptbo->posichnk.dcp = dwchBreak;

	if (iwchBefore < ptxtobj->iwchFirst)
		{
		if (!(pilsobj->grpf & fTxtSpacesInfluenceHeight))
			{
			ptbo->objdim.heightsRef.dvMultiLineHeight = dvHeightIgnore;
			ptbo->objdim.heightsPres.dvMultiLineHeight = dvHeightIgnore;
			}
		}

	lserr = GetPbrkinf(pilsobj, (PDOBJ)ptxtobj, brkkind, ppbrkinf);
	if (lserr != lserrNone) return lserr;

	(*ppbrkinf)->pdobj = (PDOBJ)ptxtobj;
	(*ppbrkinf)->brkkind = brkkind;
	(*ppbrkinf)->dcp = (LSDCP)dwchBreak;
	(*ppbrkinf)->u.normal.igindLim = igindLim;
	Assert((*ppbrkinf)->brkt == brktNormal);
	Assert((*ppbrkinf)->u.normal.durFix == 0);

	return lserrNone;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lstxtbr1.c ===
#include <limits.h>
#include "lsmem.h"
#include "lstxtbr1.h"
#include "lstxtbrs.h"
#include "lstxtmap.h"
#include "lsdntext.h"
#include "brko.h"
#include "locchnk.h"
#include "locchnk.h"
#include "posichnk.h"
#include "objdim.h"
#include "lstxtffi.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"

static void TruncateGlyphBased(PTXTOBJ ptxtobj, long itxtobj, long urTotal, long urColumnMax,
													PPOSICHNK pposichnk);

/* Export Functions Implementation */


/* Q U I C K  B R E A K  T E X T */
/*----------------------------------------------------------------------------
    %%Function: QuickBreakText
    %%Contact: sergeyge

	Breaks the line if it is easy to do, namely:
		-- break-character is space
		-- previous character is not space
----------------------------------------------------------------------------*/
LSERR QuickBreakText(PDOBJ pdobj, BOOL* pfSuccessful, LSDCP* pdcpBreak, POBJDIM pobjdim)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long iwchSpace;
	long dur;

	*pfSuccessful = fFalse;

	ptxtobj = (PTXTOBJ)pdobj;

	pilsobj = ptxtobj->plnobj->pilsobj;

	Assert(!(pilsobj->grpf & fTxtDoHyphenation));
	Assert(!(pilsobj->grpf & fTxtWrapTrailingSpaces));
	Assert(!(pilsobj->grpf & fTxtWrapAllSpaces));
	Assert(!(ptxtobj->txtf & txtfGlyphBased));

	if (ptxtobj->txtkind == txtkindRegular)
		{
		if	(!(pilsobj->grpf & fTxtApplyBreakingRules))
			{
			if	(ptxtobj->u.reg.iwSpacesLim > ptxtobj->u.reg.iwSpacesFirst)
				{
				iwchSpace = pilsobj->pwSpaces[ptxtobj->u.reg.iwSpacesLim - 1];
				Assert(iwchSpace < ptxtobj->iwchLim - 1);		/* formatting never stops at space	*/
				if (iwchSpace + 1 - ptxtobj->iwchFirst > ptxtobj->u.reg.iwSpacesLim - ptxtobj->u.reg.iwSpacesFirst)
					{
					*pfSuccessful = fTrue;
					*pdcpBreak = iwchSpace - ptxtobj->iwchFirst + 1;
					lserr = CalcPartWidths(ptxtobj, *pdcpBreak, pobjdim, &dur);
					Assert(lserr == lserrNone);
					pobjdim->dur = dur;
					
					Assert(*pdcpBreak > 1);

					ptxtobj->iwchLim = iwchSpace + 1;
					}
				}
			}
	
		else
			{
			LSCP cpFirst;
			PLSRUN plsrun;
			long iwchFirst;
			long iwchCur;
			long iwchInSpace;
			BRKCLS brkclsFollowingCache;
			BRKCLS brkclsLeading;
			BRKCLS brkclsFollowing;

			Assert(pilsobj->pwchOrig[ptxtobj->iwchLim - 1] != pilsobj->wchSpace);
			lserr = LsdnGetCpFirst(pilsobj->plsc, ptxtobj->plsdnUpNode, &cpFirst);
			Assert(lserr == lserrNone);
			lserr = LsdnGetPlsrun(pilsobj->plsc, ptxtobj->plsdnUpNode, &plsrun);
			Assert(lserr == lserrNone);
			iwchFirst = ptxtobj->iwchFirst;
			if (ptxtobj->u.reg.iwSpacesLim > ptxtobj->u.reg.iwSpacesFirst)
				iwchFirst = pilsobj->pwSpaces[ptxtobj->u.reg.iwSpacesLim - 1] + 1;

			iwchCur = ptxtobj->iwchLim - 1;

			lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plsrun,
					cpFirst + (iwchCur - ptxtobj->iwchFirst),			
					pilsobj->pwchOrig[iwchCur], &brkclsLeading, &brkclsFollowingCache);
			if (lserr != lserrNone) return lserr;

			Assert(brkclsLeading < pilsobj->cBreakingClasses && brkclsFollowingCache < pilsobj->cBreakingClasses);

			iwchCur--;

			while (!*pfSuccessful && iwchCur >= iwchFirst)
				{
				brkclsFollowing = brkclsFollowingCache;
				lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plsrun,
					cpFirst + (iwchCur - ptxtobj->iwchFirst),				
					pilsobj->pwchOrig[iwchCur], &brkclsLeading, &brkclsFollowingCache);
				if (lserr != lserrNone) return lserr;
		
				Assert(brkclsLeading < pilsobj->cBreakingClasses && brkclsFollowingCache < pilsobj->cBreakingClasses);

				*pfSuccessful = FCanBreak(pilsobj, brkclsLeading, brkclsFollowing);
				iwchCur --;
				}
			
			if (!*pfSuccessful && iwchFirst > ptxtobj->iwchFirst)
				{
				Assert(pilsobj->pwchOrig[iwchCur] == pilsobj->wchSpace);
				iwchCur--;
				for (iwchInSpace = iwchCur; iwchInSpace >= ptxtobj->iwchFirst &&
						pilsobj->pwchOrig[iwchInSpace] == pilsobj->wchSpace; iwchInSpace--);

				if (iwchInSpace >= ptxtobj->iwchFirst)
					{
					brkclsFollowing = brkclsFollowingCache;
					lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plsrun,
							cpFirst + (iwchInSpace - ptxtobj->iwchFirst),			
							pilsobj->pwchOrig[iwchInSpace], &brkclsLeading, &brkclsFollowingCache);
					if (lserr != lserrNone) return lserr;

					Assert(brkclsLeading < pilsobj->cBreakingClasses && brkclsFollowingCache < pilsobj->cBreakingClasses);
				
					*pfSuccessful = FCanBreakAcrossSpaces(pilsobj, brkclsLeading, brkclsFollowing);

					}
				}

			if (*pfSuccessful)
				{
				*pdcpBreak = iwchCur + 1 - ptxtobj->iwchFirst + 1;
				lserr = CalcPartWidths(ptxtobj, *pdcpBreak, pobjdim, &dur);
				Assert(lserr == lserrNone);
				pobjdim->dur = dur;
				
				Assert(*pdcpBreak >= 1);

				ptxtobj->iwchLim = iwchCur + 2;
				}
			}
		}

   return lserrNone;			

}

/* S E T  B R E A K  T E X T */
/*----------------------------------------------------------------------------
    %%Function:SetBreakText
    %%Contact: sergeyge

----------------------------------------------------------------------------*/
LSERR WINAPI SetBreakText(PDOBJ pdobj, BRKKIND brkkind, DWORD nBreakRec, BREAKREC* rgBreakRec, DWORD* pnActual)
{
	LSERR lserr;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long iwchLim;
	long ibrkinf;
	BREAKINFO* pbrkinf;
	BOOL fInChildList;

	Unreferenced(nBreakRec);
	Unreferenced(rgBreakRec);

	*pnActual = 0;

	ptxtobj = (PTXTOBJ) pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	for (ibrkinf = 0; ibrkinf < (long)pilsobj->breakinfMac &&
		(pilsobj->pbreakinf[ibrkinf].pdobj != pdobj || pilsobj->pbreakinf[ibrkinf].brkkind != brkkind);
																						ibrkinf++ );
	if (ibrkinf < (long)pilsobj->breakinfMac)
		{
		pbrkinf = &pilsobj->pbreakinf[ibrkinf];
		switch (pbrkinf->brkt)
			{
		case brktNormal:
			iwchLim = ptxtobj->iwchFirst + pbrkinf->dcp;
			if (iwchLim < ptxtobj->iwchLim)
				ptxtobj->iwchLim = iwchLim;
			ptxtobj->igindLim = pbrkinf->u.normal.igindLim;
			if (pbrkinf->u.normal.durFix != 0)
				{
				Assert(!(ptxtobj->txtf & txtfGlyphBased));
				pilsobj->pdur[ptxtobj->iwchLim - 1] += pbrkinf->u.normal.durFix;
				Assert (pilsobj->pdurRight != NULL);
				pilsobj->pdurRight[ptxtobj->iwchLim - 1] = 0;
				}
			break;
		case brktHyphen:
			iwchLim = pbrkinf->u.hyphen.iwchLim;
			ptxtobj->iwchLim = iwchLim;
			plnobj->pdobjHyphen = ptxtobj;	
			plnobj->dwchYsr = pbrkinf->u.hyphen.dwchYsr;	

			pilsobj->pwchOrig[iwchLim - 1] = pilsobj->wchHyphen;
			plnobj->pwch[iwchLim - 1] = pilsobj->wchHyphen;

			if (pbrkinf->u.hyphen.gindHyphen != 0)
				{
				ptxtobj->igindLim = pbrkinf->u.hyphen.igindHyphen + 1;
				plnobj->pgind[pbrkinf->u.hyphen.igindHyphen] = pbrkinf->u.hyphen.gindHyphen;
				pilsobj->pdurGind[pbrkinf->u.hyphen.igindHyphen] = pbrkinf->u.hyphen.durHyphen;
				plnobj->pdupGind[pbrkinf->u.hyphen.igindHyphen] = pbrkinf->u.hyphen.dupHyphen;
				if (pilsobj->pduGright != NULL)
						pilsobj->pduGright[pbrkinf->u.hyphen.igindHyphen] = 0;
				/* REVIEW sergeyge: It would be nice to move this activity to lstxtmap module */
				plnobj->pgmap[iwchLim - 1] = (WORD)(pbrkinf->u.hyphen.igindHyphen -
												(ptxtobj->igindFirst - plnobj->pgmap[ptxtobj->iwchFirst]));
				pilsobj->ptxtinf[iwchLim - 1].fOneToOne = fTrue;
				pilsobj->ptxtinf[iwchLim - 1].fFirstInContext = fTrue;
				pilsobj->ptxtinf[iwchLim - 1].fLastInContext = fTrue;
				pilsobj->pginf[pbrkinf->u.hyphen.igindHyphen] = ginffOneToOne |
													 ginffFirstInContext | ginffLastInContext;
				}
			else
				{
				pilsobj->pdur[iwchLim - 1] = pbrkinf->u.hyphen.durHyphen;
				plnobj->pdup[iwchLim - 1] = pbrkinf->u.hyphen.dupHyphen;
				if (pilsobj->pdurRight != NULL)
					pilsobj->pdurRight[iwchLim - 1] = 0;
				if (pilsobj->pdurLeft != NULL)
					pilsobj->pdurLeft[iwchLim - 1] = 0;
				}

			if (pbrkinf->u.hyphen.wchPrev != 0)
				{
				pilsobj->pwchOrig[iwchLim - 2] = pbrkinf->u.hyphen.wchPrev;
				plnobj->pwch[iwchLim - 2] = pbrkinf->u.hyphen.wchPrev;
				if (pbrkinf->u.hyphen.gindPrev != 0)
					{
					plnobj->pgind[pbrkinf->u.hyphen.igindPrev] = pbrkinf->u.hyphen.gindPrev;
					pilsobj->pdurGind[pbrkinf->u.hyphen.igindPrev] = pbrkinf->u.hyphen.durPrev;
					plnobj->pdupGind[pbrkinf->u.hyphen.igindPrev] = pbrkinf->u.hyphen.dupPrev;
					if (pilsobj->pduGright != NULL)
						pilsobj->pduGright[pbrkinf->u.hyphen.igindPrev] = 0;
					/* REVIEW sergeyge: It would be nice to move this activity to lstxtmap module */
					/* If Prev glyph is added the following activity is required;
						If it is just replaced, we assign the same values,because ProcessYsr
						would not allow replace not OneToOne character
					*/
					plnobj->pgmap[iwchLim - 2] = (WORD)(pbrkinf->u.hyphen.igindPrev - 
											(ptxtobj->igindFirst - plnobj->pgmap[ptxtobj->iwchFirst]));
					pilsobj->ptxtinf[iwchLim - 2].fOneToOne = fTrue;
					pilsobj->ptxtinf[iwchLim - 2].fFirstInContext = fTrue;
					pilsobj->ptxtinf[iwchLim - 2].fLastInContext = fTrue;
					pilsobj->pginf[pbrkinf->u.hyphen.igindPrev] = ginffOneToOne |
													ginffFirstInContext | ginffLastInContext;
					}
				else
					{
					pilsobj->pdur[iwchLim - 2] = pbrkinf->u.hyphen.durPrev;
					plnobj->pdup[iwchLim - 2] = pbrkinf->u.hyphen.dupPrev;
					if (pilsobj->pdurRight != NULL)
						pilsobj->pdurRight[iwchLim - 2] = 0;
					if (pilsobj->pdurLeft != NULL)
						pilsobj->pdurLeft[iwchLim - 2] = 0;
						}
				}

			if (pbrkinf->u.hyphen.wchPrevPrev != 0)
				{
				pilsobj->pwchOrig[iwchLim - 3] = pbrkinf->u.hyphen.wchPrevPrev;
				plnobj->pwch[iwchLim - 3] = pbrkinf->u.hyphen.wchPrevPrev;
				if (pbrkinf->u.hyphen.gindPrevPrev != 0)
					{
					plnobj->pgind[pbrkinf->u.hyphen.igindPrevPrev] = pbrkinf->u.hyphen.gindPrevPrev;
					pilsobj->pdurGind[pbrkinf->u.hyphen.igindPrevPrev] = pbrkinf->u.hyphen.durPrevPrev;
					plnobj->pdupGind[pbrkinf->u.hyphen.igindPrevPrev] = pbrkinf->u.hyphen.dupPrevPrev;
					if (pilsobj->pduGright != NULL)
						pilsobj->pduGright[pbrkinf->u.hyphen.igindPrevPrev] = 0;
					}
				else
					{
					pilsobj->pdur[iwchLim - 3] = pbrkinf->u.hyphen.durPrevPrev;
					plnobj->pdup[iwchLim - 3] = pbrkinf->u.hyphen.dupPrevPrev;
					if (pilsobj->pdurRight != NULL)
						pilsobj->pdurRight[iwchLim - 3] = 0;
					if (pilsobj->pdurLeft != NULL)
						pilsobj->pdurLeft[iwchLim - 3] = 0;
					}

				}

			if (pbrkinf->u.hyphen.ddurDnodePrev != 0)
				{
				
				lserr = LsdnResetWidthInPreviousDnodes(pilsobj->plsc, ptxtobj->plsdnUpNode, 
					pbrkinf->u.hyphen.ddurDnodePrev, 0);

				if (lserr != lserrNone) return lserr;
				}

			lserr = LsdnSetHyphenated(pilsobj->plsc);
			if (lserr != lserrNone) return lserr;

			break;

		case brktNonReq:
			Assert(pbrkinf->dcp == 1);
			iwchLim = pbrkinf->u.nonreq.iwchLim;
			ptxtobj->iwchLim = iwchLim;
			Assert(iwchLim == ptxtobj->iwchFirst + pbrkinf->u.nonreq.dwchYsr);
			plnobj->pdobjHyphen = ptxtobj;	
			plnobj->dwchYsr = pbrkinf->u.nonreq.dwchYsr;	

			Assert(ptxtobj->iwchLim == iwchLim);
			pilsobj->pwchOrig[iwchLim - 1] = pilsobj->wchHyphen;
			plnobj->pwch[iwchLim - 1] = pbrkinf->u.nonreq.wchHyphenPres;
			pilsobj->pdur[iwchLim - 1] = pbrkinf->u.nonreq.durHyphen;
			plnobj->pdup[iwchLim - 1] = pbrkinf->u.nonreq.dupHyphen;
			if (pilsobj->pdurRight != NULL)
				pilsobj->pdurRight[iwchLim - 1] = 0;
			if (pilsobj->pdurLeft != NULL)
				pilsobj->pdurLeft[iwchLim - 1] = 0;

			if (pbrkinf->u.nonreq.wchPrev != 0)
				{
				pilsobj->pwchOrig[iwchLim - 2] = pbrkinf->u.nonreq.wchPrev;
				plnobj->pwch[iwchLim - 2] = pbrkinf->u.nonreq.wchPrev;

				if (pbrkinf->u.nonreq.gindPrev != 0)
					{
					plnobj->pgind[pbrkinf->u.nonreq.igindPrev] = pbrkinf->u.nonreq.gindPrev;
					pilsobj->pdurGind[pbrkinf->u.nonreq.igindPrev] = pbrkinf->u.nonreq.durPrev;
					plnobj->pdupGind[pbrkinf->u.nonreq.igindPrev] = pbrkinf->u.nonreq.dupPrev;
					if (pilsobj->pduGright != NULL)
						pilsobj->pduGright[pbrkinf->u.nonreq.igindPrev] = 0;
					}
				else
					{
					pilsobj->pdur[iwchLim - 2] = pbrkinf->u.nonreq.durPrev;
					plnobj->pdup[iwchLim - 2] = pbrkinf->u.nonreq.dupPrev;
					if (pilsobj->pdurRight != NULL)
						pilsobj->pdurRight[iwchLim - 2] = 0;
					if (pilsobj->pdurLeft != NULL)
						pilsobj->pdurLeft[iwchLim - 2] = 0;
					}
				}

			if (pbrkinf->u.nonreq.wchPrevPrev != 0)
				{
				pilsobj->pwchOrig[iwchLim - 3] = pbrkinf->u.nonreq.wchPrevPrev;
				plnobj->pwch[iwchLim - 3] = pbrkinf->u.nonreq.wchPrevPrev;
				if (pbrkinf->u.nonreq.gindPrevPrev != 0)
					{
					plnobj->pgind[pbrkinf->u.nonreq.igindPrevPrev] = pbrkinf->u.nonreq.gindPrevPrev;
					pilsobj->pdurGind[pbrkinf->u.nonreq.igindPrevPrev] = pbrkinf->u.nonreq.durPrevPrev;
					plnobj->pdupGind[pbrkinf->u.nonreq.igindPrevPrev] = pbrkinf->u.nonreq.dupPrevPrev;
					if (pilsobj->pduGright != NULL)
						pilsobj->pduGright[pbrkinf->u.nonreq.igindPrevPrev] = 0;
					}
				else
					{
					pilsobj->pdur[iwchLim - 3] = pbrkinf->u.nonreq.durPrevPrev;
					plnobj->pdup[iwchLim - 3] = pbrkinf->u.nonreq.dupPrevPrev;
					if (pilsobj->pdurRight != NULL)
						pilsobj->pdurRight[iwchLim - 3] = 0;
					if (pilsobj->pdurLeft != NULL)
						pilsobj->pdurLeft[iwchLim - 3] = 0;
					}
				}

			if (pbrkinf->u.nonreq.ddurDnodePrev != 0 || pbrkinf->u.nonreq.ddurDnodePrevPrev != 0)
				{
				lserr = LsdnResetWidthInPreviousDnodes(pilsobj->plsc, ptxtobj->plsdnUpNode, 
					pbrkinf->u.nonreq.ddurDnodePrev, pbrkinf->u.nonreq.ddurDnodePrevPrev);

				if (lserr != lserrNone) return lserr;
				}


			lserr = LsdnFInChildList(pilsobj->plsc, ptxtobj->plsdnUpNode, &fInChildList);
			Assert(lserr == lserrNone);
			
			if (!fInChildList)
				{
				lserr = LsdnSetHyphenated(pilsobj->plsc);
				Assert(lserr == lserrNone);
				}
			break;
		case brktOptBreak:
			break;
		default:
			NotReached();
			}
		}
	else
		{
		/* REVIEW sergeyge: we should return to the discussion of brkkind later.
			At the moment manager passes brkkindNext if during NextBreak object retrurned break 
			with dcp == 0 and break was snapped to the previous DNODE inside chunk
		*/
//		Assert(ptxtobj->iwchLim == ptxtobj->iwchFirst || ptxtobj->txtkind == txtkindEOL ||
//				brkkind == brkkindImposedAfter);
		}

	return lserrNone;			
}


/* F O R C E  B R E A K  T E X T */
/*----------------------------------------------------------------------------
    %%Function: ForceBreakText
    %%Contact: sergeyge

	Force break method.
	Breaks behind all characters in dobj, if they fit in line, or
		dobj consists of one character which is the first on the line,
	Breaks before the last character otherwise.
----------------------------------------------------------------------------*/
LSERR WINAPI ForceBreakText(PCLOCCHNK plocchnk, PCPOSICHNK pposichnk, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobjLast;
	long itxtobjLast;
	long dcpLast;
	OBJDIM objdim;
	BREAKINFO* pbrkinf;
	long igindLim;

	pilsobj = ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	memset(ptbo, 0, sizeof(*ptbo));

	ptbo->fSuccessful = fTrue;

	igindLim = 0;

	/* Outside means before for ForceBreak */
	if (pposichnk->ichnk == ichnkOutside)
		{
		itxtobjLast = 0;
		ptxtobjLast = (PTXTOBJ)plocchnk->plschnk[itxtobjLast].pdobj;
		dcpLast = 1;
		}
	else
		{
		itxtobjLast = pposichnk->ichnk;
		ptxtobjLast = (PTXTOBJ)plocchnk->plschnk[itxtobjLast].pdobj;
		Assert(ptxtobjLast->iwchFirst + pposichnk->dcp > 0);
		Assert(pposichnk->dcp > 0);
		dcpLast = pposichnk->dcp;

		if (pilsobj->fTruncatedBefore)
			{

			BOOL fInChildList;
	
			lserr = LsdnFInChildList(pilsobj->plsc, ptxtobjLast->plsdnUpNode, &fInChildList);
			Assert(lserr == lserrNone);
			
			if (!fInChildList)
				{
				dcpLast++;
				Assert(ptxtobjLast->iwchLim + 1 >= ptxtobjLast->iwchFirst + dcpLast);

				/* possible because if truncation returned dcp == 0, manager has reset it to previous dnode */
				if (ptxtobjLast->iwchLim + 1 == ptxtobjLast->iwchFirst + dcpLast)
					{
					itxtobjLast++;
					Assert(itxtobjLast < (long)plocchnk->clschnk);
					ptxtobjLast = (PTXTOBJ)plocchnk->plschnk[itxtobjLast].pdobj;
					dcpLast = 1;
					}
				}
			}
		}

	ptbo->posichnk.ichnk = itxtobjLast;

	lserr = LsdnGetObjDim(pilsobj->plsc, ptxtobjLast->plsdnUpNode, &ptbo->objdim);
	if (lserr != lserrNone) return lserr;

	if (plocchnk->lsfgi.fFirstOnLine && itxtobjLast == 0 && ptxtobjLast->iwchLim == ptxtobjLast->iwchFirst)
		{
		Assert(!(ptxtobjLast->txtf & txtfGlyphBased));
		ptbo->posichnk.dcp = 1;
		}
	else
		{
		if (ptxtobjLast->txtf & txtfGlyphBased)
			{
			Assert(ptxtobjLast->iwchLim > ptxtobjLast->iwchFirst);
			if (!plocchnk->lsfgi.fFirstOnLine || itxtobjLast > 0 || dcpLast > 1)
				{
				ptbo->posichnk.dcp = 0;
				if (dcpLast > 1)
					ptbo->posichnk.dcp = DcpAfterContextFromDcp(ptxtobjLast, dcpLast - 1);
				}
			else
				ptbo->posichnk.dcp =  DcpAfterContextFromDcp(ptxtobjLast, 1);

			igindLim = IgindFirstFromIwch(ptxtobjLast, ptxtobjLast->iwchFirst + ptbo->posichnk.dcp);

			lserr = CalcPartWidthsGlyphs(ptxtobjLast, ptbo->posichnk.dcp, &objdim, &ptbo->objdim.dur);
			if (lserr != lserrNone) return lserr;
			}
		else
			{
			if (!plocchnk->lsfgi.fFirstOnLine || itxtobjLast > 0 || dcpLast > 1)
				{
				ptbo->posichnk.dcp = dcpLast - 1;
				lserr = CalcPartWidths(ptxtobjLast, ptbo->posichnk.dcp, &objdim, &ptbo->objdim.dur);
				if (lserr != lserrNone) return lserr;
				}
			else
				{
				if (ptxtobjLast->iwchLim > ptxtobjLast->iwchFirst)
					{
					lserr = CalcPartWidths(ptxtobjLast, 1, &objdim, &ptbo->objdim.dur);
					}
				else
					{
					ptbo->objdim.dur = 0;
					}
				ptbo->posichnk.dcp =  1;
				}
			}
		}


/* Don't check that Heights of this dobj should be ignored, since in normal case, if there were spaces
	there was also break */

	lserr = GetPbrkinf(pilsobj, (PDOBJ)ptxtobjLast, brkkindForce, &pbrkinf);
	if (lserr != lserrNone) return lserr;

	pbrkinf->pdobj = (PDOBJ)ptxtobjLast;
	pbrkinf->brkkind = brkkindForce;
	pbrkinf->dcp = ptbo->posichnk.dcp;
	pbrkinf->u.normal.igindLim = igindLim;
	Assert(pbrkinf->brkt == brktNormal);
	Assert(pbrkinf->u.normal.durFix == 0);

	return lserrNone;
}


/* T R U N C A T E  T E X T */
/*----------------------------------------------------------------------------
    %%Function: TruncateText
    %%Contact: sergeyge

	Truncates text chunk
----------------------------------------------------------------------------*/
LSERR WINAPI TruncateText(PCLOCCHNK plocchnk, PPOSICHNK pposichnk)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj = NULL;
	long itxtobj;
	long iwchCur;
	long iwchFirst;
	long* pdur;
	long urColumnMax;
	long urTotal;
	OBJDIM objdim;
	BOOL fTruncateBefore;

	pilsobj = ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	urColumnMax = plocchnk->lsfgi.urColumnMax; 
	
	Assert(plocchnk->ppointUvLoc[0].u <= urColumnMax);

	for (itxtobj = plocchnk->clschnk - 1; plocchnk->ppointUvLoc[itxtobj].u > urColumnMax; itxtobj--);

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj;
	lserr = LsdnGetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, &objdim);
	if (lserr != lserrNone) return lserr;
	urTotal = plocchnk->ppointUvLoc[itxtobj].u + objdim.dur;

	Assert(urTotal > urColumnMax);

	if (ptxtobj->txtf & txtfGlyphBased)
		{
		TruncateGlyphBased(ptxtobj, itxtobj, urTotal, urColumnMax, pposichnk);
		return lserrNone;
		}

	iwchCur = ptxtobj->iwchLim;
	iwchFirst = ptxtobj->iwchFirst;

	pdur = pilsobj->pdur;
	while (urTotal > urColumnMax)
		{
		iwchCur--;
		urTotal -= pdur[iwchCur];
		}

	Assert(iwchCur >= iwchFirst);

/* REVIEW sergeyge--- extremely ugly condition, 
	and still slightly incompatible with Word.
	To make it more compatible txtkind should be checked against
	OptBreak, OptNonBreak, NonReqHyphen
	If we won't check it for OptBreak,..., we will have different break point for the Visi case

  Before fix for bug 227 we checked also that prev char is not space, but now it is not important.

*/
	if ((pilsobj->grpf & fTxtFCheckTruncateBefore) && iwchCur > 0 && 

		/* We enforce that there is no funny logic if EOL is truncation point */
		ptxtobj->txtkind != txtkindEOL &&
		
		 !(iwchCur == iwchFirst && itxtobj > 0 &&
		 ((PTXTOBJ)plocchnk->plschnk[itxtobj-1].pdobj)->txtkind != txtkindRegular &&
		 ((PTXTOBJ)plocchnk->plschnk[itxtobj-1].pdobj)->txtkind != txtkindHardHyphen &&
		 ((PTXTOBJ)plocchnk->plschnk[itxtobj-1].pdobj)->txtkind != txtkindYsrChar)
		
		)
		{
		BOOL fInChildList;

		lserr = LsdnFInChildList(pilsobj->plsc, ptxtobj->plsdnUpNode, &fInChildList);
		Assert(lserr == lserrNone);

		if (!fInChildList)
			{
			PLSRUN plsrunCur = plocchnk->plschnk[itxtobj].plsrun;
			LSCP cpCur = plocchnk->plschnk[itxtobj].cpFirst + (iwchCur - iwchFirst);
			long durCur = 0;
			PLSRUN plsrunPrev = NULL;
			WCHAR wchPrev = 0;
			LSCP cpPrev = -1;
			long durPrev = 0;

			if (iwchCur > iwchFirst)
				{
				plsrunPrev = plsrunCur;
				wchPrev = pilsobj->pwchOrig[iwchCur - 1];
				durPrev = pilsobj->pdur[iwchCur - 1];
				cpPrev = cpCur - 1;
				}
			else if (itxtobj > 0)
				{
				PTXTOBJ ptxtobjPrev = (PTXTOBJ)plocchnk->plschnk[itxtobj - 1].pdobj;
				long iwchPrev = ptxtobjPrev->iwchLim - 1;
				plsrunPrev= plocchnk->plschnk[itxtobj - 1].plsrun;
				wchPrev = pilsobj->pwchOrig[iwchPrev];
				durPrev = pilsobj->pdur[iwchPrev];
				cpPrev = plocchnk->plschnk[itxtobj-1].cpFirst + (iwchPrev - ptxtobjPrev->iwchFirst);
				}

	/* REVIEW sergeyge: dangerous change to fix bug 399. It looks correct, but might trigger some other
		incompatibility.
	*/
			durCur = pilsobj->pdur[iwchCur];
			if (pilsobj->pdurRight != NULL)
				durCur -= pilsobj->pdurRight[iwchCur];

			lserr = (*pilsobj->plscbk->pfnFTruncateBefore)(pilsobj->pols,
						plsrunCur, cpCur, pilsobj->pwchOrig[iwchCur], durCur,
						plsrunPrev, cpPrev, wchPrev, durPrev,
						urTotal + durCur - urColumnMax,	&fTruncateBefore);
			if (lserr != lserrNone) return lserr;

			if (fTruncateBefore && iwchCur > 0 && pdur[iwchCur-1] > 0)
				{
				iwchCur--;
				pilsobj->fTruncatedBefore = fTrue;
				}
			}
		}

	pposichnk->ichnk = itxtobj;
	pposichnk->dcp = iwchCur - iwchFirst + 1;

	return lserrNone;
}

/* internal functions implementation */

static void TruncateGlyphBased(PTXTOBJ ptxtobj, long itxtobj, long urTotal, long urColumnMax,
													PPOSICHNK pposichnk)
{
	PILSOBJ pilsobj;
	long iwchFirst;
	long iwchCur;
	long igindCur;
	long igindFirst;
	long* pdurGind;

	pilsobj= ptxtobj->plnobj->pilsobj;

	iwchFirst = ptxtobj->iwchFirst;
	
	igindCur = ptxtobj->igindLim;
	igindFirst = ptxtobj->igindFirst;

	pdurGind = pilsobj->pdurGind;
	while (urTotal > urColumnMax)
		{
		igindCur--;
		urTotal -= pdurGind[igindCur];
		}

	Assert(igindCur >= igindFirst);

	iwchCur = IwchFirstFromIgind(ptxtobj, igindCur);

	pposichnk->ichnk = itxtobj;
	pposichnk->dcp = iwchCur - iwchFirst + 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lstxtbrs.c ===
#include "lsmem.h"
#include <limits.h>
#include "lstxtbrs.h"
#include "lstxtmap.h"
#include "lsdntext.h"
#include "zqfromza.h"
#include "locchnk.h"
#include "posichnk.h"
#include "objdim.h"
#include "lskysr.h"
#include "lstxtffi.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"

static void GetOneCharWidth(PTXTOBJ ptxtobj, long dwch, long* pdurChar);
static LSERR GetWidthOfGlyph(PILSOBJ pilsobj, PLSRUN plsrun, LSTFLOW lstflow, WCHAR wch, BOOL* pfSuccessful, 
											GINDEX* pgind, long* pdurNew, long* pdupNew);
static LSERR GetWidthOfChar(PILSOBJ pilsobj, PLSRUN plsrun, LSTFLOW lstflow, WCHAR wch,
																			long* pdurNew, long* pdupNew);


/* F I N D  N O N  S P A C E  B E F O R E */
/*----------------------------------------------------------------------------
    %%Function: FindNonSpaceBefore
    %%Contact: sergeyge
	
----------------------------------------------------------------------------*/
BOOL FindNonSpaceBefore(PCLSCHNK rglschnk, long itxtobjCur, long iwchCur,
									long* pitxtobjBefore, long* piwchBefore)
{
	PILSOBJ pilsobj;
	long iwch;
	BOOL fInSpace;
	long itxtobj;
	PTXTOBJ ptxtobj;
	long iwchFirst;

	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;

	fInSpace = fTrue;
	itxtobj = itxtobjCur;

	iwch = iwchCur;

	while (fInSpace && itxtobj >= 0)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;

		if ((ptxtobj->txtkind != txtkindRegular && ptxtobj->txtkind != txtkindSpecSpace || 
			(pilsobj->grpf & fTxtWrapAllSpaces)) && ptxtobj->txtkind != txtkindEOL )
			{
			*pitxtobjBefore = itxtobj;
			*piwchBefore = ptxtobj->iwchLim - 1;
			if (iwchCur < *piwchBefore)
				*piwchBefore = iwchCur;
			fInSpace = fFalse;
			}
		else if (ptxtobj->txtkind == txtkindRegular)
			{
			iwchFirst = ptxtobj->iwchFirst;

			for (; iwch >= iwchFirst && pilsobj->pwchOrig[iwch] == pilsobj->wchSpace; iwch--);

			if (iwch >= iwchFirst)
				{
				*pitxtobjBefore = itxtobj;
				*piwchBefore = iwch;
				fInSpace = fFalse;
				}
			}

		iwch = ptxtobj->iwchFirst - 1;
		itxtobj--;

		}

	if (fInSpace)
		{
		*pitxtobjBefore = 0;
		*piwchBefore = iwch;
		}

	return !fInSpace;

}

/* F I N D  N O N  S P A C E  A F T E R */
/*----------------------------------------------------------------------------
    %%Function: FindNonSpaceAfter
    %%Contact: sergeyge
	
----------------------------------------------------------------------------*/
BOOL FindNonSpaceAfter(PCLSCHNK rglschnk, DWORD clschnk, long itxtobjCur, long iwchCur,
									long* pitxtobjAfter, long* piwchAfter)
{
	PILSOBJ pilsobj;
	long iwch;
	BOOL fInSpace;
	long itxtobj;
	PTXTOBJ ptxtobj;
	long iwchLim;

	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;

	fInSpace = fTrue;
	itxtobj = itxtobjCur;

	iwch = iwchCur;

	while (fInSpace && itxtobj < (long)clschnk)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;

		if (ptxtobj->txtkind != txtkindRegular && ptxtobj->txtkind != txtkindSpecSpace ||
				(pilsobj->grpf & fTxtWrapAllSpaces))
			{
			*pitxtobjAfter = itxtobj;
			*piwchAfter = ptxtobj->iwchFirst;
			if (iwchCur > *piwchAfter)
				*piwchAfter = iwchCur;
			fInSpace = fFalse;
			}
		else if (ptxtobj->txtkind == txtkindRegular)
			{
			iwchLim = ptxtobj->iwchLim;
			for (; iwch < iwchLim && pilsobj->pwchOrig[iwch] == pilsobj->wchSpace; iwch++);
			if (iwch < iwchLim)
				{
				*pitxtobjAfter = itxtobj;
				*piwchAfter = iwch;
				fInSpace = fFalse;
				}
			}

		iwch = ptxtobj->iwchLim;
		itxtobj++;
		}


	if (fInSpace)
		{
		*pitxtobjAfter = clschnk - 1;   /* Important for correct ptbo settting in TryBreakAcrossSpaces */
		*piwchAfter = iwch;
		}

	return !fInSpace;
	
}

/* F I N D  P R E V  C H A R */
/*----------------------------------------------------------------------------
    %%Function: FindPrevChar
    %%Contact: sergeyge
	
----------------------------------------------------------------------------*/
BOOL FindPrevChar(PCLSCHNK rglschnk, long itxtobjCur, long iwchCur,
																long* pitxtobjBefore, long* piwchBefore)
{
	PTXTOBJ ptxtobj;

	ptxtobj = (PTXTOBJ)rglschnk[itxtobjCur].pdobj;

	if (iwchCur > ptxtobj->iwchFirst)
		{
		*pitxtobjBefore = itxtobjCur;
		*piwchBefore = iwchCur - 1;
		return fTrue;
		}
	else if (itxtobjCur > 0)
		{
		*pitxtobjBefore = itxtobjCur - 1;
		*piwchBefore = ((PTXTOBJ)rglschnk[*pitxtobjBefore].pdobj)->iwchLim - 1;
		return fTrue;
		}
	else
		{
		*pitxtobjBefore = 0;
		*piwchBefore = ((PTXTOBJ)rglschnk[0].pdobj)->iwchFirst - 1;
		}

	return fFalse;
}



/* F I N D  N E X T  C H A R */
/*----------------------------------------------------------------------------
    %%Function: FindNextChar
    %%Contact: sergeyge
	
----------------------------------------------------------------------------*/
BOOL FindNextChar(PCLSCHNK rglschnk, DWORD clschnk, long itxtobjCur, long iwchCur,
																long* pitxtobjAfter, long* piwchAfter)
{
	PTXTOBJ ptxtobj;

	ptxtobj = (PTXTOBJ)rglschnk[itxtobjCur].pdobj;

	if (iwchCur < ptxtobj->iwchLim - 1)
		{
		*pitxtobjAfter = itxtobjCur;
		*piwchAfter = iwchCur + 1;
		return fTrue;
		}
	else if (itxtobjCur < (long)clschnk - 1)
		{
		*pitxtobjAfter = itxtobjCur + 1;
		*piwchAfter = ((PTXTOBJ)rglschnk[*pitxtobjAfter].pdobj)->iwchFirst;
		return fTrue;
		}
	else
		{
		/* not found but set correct values for ptbo in TryBreakAcrossSpaces */
		*pitxtobjAfter = clschnk - 1;
		*piwchAfter = ((PTXTOBJ)rglschnk[*pitxtobjAfter].pdobj)->iwchLim;
		}

	return fFalse;
}



/* C A L C  P A R T  W I D T H S */
/*----------------------------------------------------------------------------
    %%Function: CalcPartWidths
    %%Contact: sergeyge
	
	Calculates width from the beginning of the dobj until character iwchLim
----------------------------------------------------------------------------*/
LSERR CalcPartWidths(PTXTOBJ ptxtobj, long dwchLim, POBJDIM pobjdim, long* pdur)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long* rgdur;
	long durSum;
	long i;

	pilsobj = ptxtobj->plnobj->pilsobj;

	rgdur = pilsobj->pdur;

	Assert(dwchLim <= ptxtobj->iwchLim - ptxtobj->iwchFirst);

	lserr = LsdnGetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, pobjdim);
	if (lserr != lserrNone) return lserr;

	if (dwchLim == 0)
		{
		*pdur = 0;
		return lserrNone;
		}

	durSum = 0;
	/* Calculate the tail of the string, then subtract */ 
	for (i = ptxtobj->iwchFirst + dwchLim; i < ptxtobj->iwchLim; i++)
		{
		durSum += rgdur[i];
		}

	*pdur = pobjdim->dur - durSum;

	return lserrNone;	
}

/* C A L C  P A R T  W I D T H S  G L Y P H S */
/*----------------------------------------------------------------------------
    %%Function: CalcPartWidthsGlyphs
    %%Contact: sergeyge
	
	Calculates width from the beginning of the dobj until character iwchLim
----------------------------------------------------------------------------*/
LSERR CalcPartWidthsGlyphs(PTXTOBJ ptxtobj, long dwchLim, POBJDIM pobjdim, long* pdur)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long* rgdurGind;
	long durSum;
	long igindStart;
	long i;

	pilsobj = ptxtobj->plnobj->pilsobj;

	rgdurGind = pilsobj->pdurGind;

	Assert(dwchLim <= ptxtobj->iwchLim - ptxtobj->iwchFirst);

	
	Assert(ptxtobj->iwchFirst + dwchLim == ptxtobj->iwchLim ||
						pilsobj->ptxtinf[ptxtobj->iwchFirst + dwchLim].fFirstInContext);
	igindStart = IgindFirstFromIwch(ptxtobj, ptxtobj->iwchFirst + dwchLim);

	lserr = LsdnGetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, pobjdim);
	if (lserr != lserrNone) return lserr;

	durSum = 0;
	/* Calculate the tail of the string, then subtract */ 
	for (i = igindStart; i < ptxtobj->igindLim; i++)
		{
		durSum += rgdurGind[i];
		}

	*pdur = pobjdim->dur - durSum;

	return lserrNone;	
}


/* C H E C K  H O T  Z O N E */
/*----------------------------------------------------------------------------
    %%Function: CheckHotZone
    %%Contact: sergeyge
	
----------------------------------------------------------------------------*/
LSERR CheckHotZone(PCLOCCHNK plocchnk, long itxtobj, long iwch, BOOL* pfInHyphenZone)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long dur;
	long durLeftIndent;
	OBJDIM objdim;

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj;
	pilsobj = ptxtobj->plnobj->pilsobj;

	if (ptxtobj->txtf & txtfGlyphBased)
		lserr = CalcPartWidthsGlyphs(ptxtobj, iwch + 1 - ptxtobj->iwchFirst, &objdim, &dur);
	else
		lserr = CalcPartWidths(ptxtobj, iwch + 1 - ptxtobj->iwchFirst, &objdim, &dur);

	if (lserr != lserrNone) return lserr;

	durLeftIndent = 0;

	if (pilsobj->grpf & fTxtIndentChangesHyphenZone	)
		{
		lserr = LsdnGetLeftIndentDur(pilsobj->plsc, &durLeftIndent);
		Assert(lserr == lserrNone);
		}

	*pfInHyphenZone = 
			(plocchnk->lsfgi.urColumnMax - (plocchnk->ppointUvLoc[itxtobj].u + dur) + durLeftIndent >= 
			UrFromUa(plocchnk->lsfgi.lstflow, &pilsobj->lsdevres, pilsobj->duaHyphenationZone) );

	return lserrNone;
}

/* P R O C E S S  Y S R */
/*----------------------------------------------------------------------------
    %%Function: ProcessYsr
    %%Contact: sergeyge
	
----------------------------------------------------------------------------*/
LSERR ProcessYsr(PCLOCCHNK plocchnk, long itxtobjYsr, long dwchYsr, long itxtobjPrev, long itxtobjPrevPrev,
														YSRINF ysrinf, BOOL* pfSuccess, HYPHOUT* phyphout)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobjYsr;
	PTXTOBJ ptxtobjPrev;
	PTXTOBJ ptxtobjPrevPrev;
	const LSCHNKE* pchnkeYsr;
	const LSCHNKE* pchnkePrev;
	const LSCHNKE* pchnkePrevPrev;
	long iwchYsr;
	long durPrevOld = 0;
	long durPrevPrevOld = 0;
	long dupNew;
	long durNew;
	long dupHyphen;
	long durHyphen;
	BOOL fSuccessful;
	GINDEX gind;

	memset(phyphout, 0, sizeof(*phyphout));
	*pfSuccess = fTrue;

	pchnkeYsr = &plocchnk->plschnk[itxtobjYsr];
	ptxtobjYsr = (PTXTOBJ)pchnkeYsr->pdobj;
	plnobj = ptxtobjYsr->plnobj;
	pilsobj = plnobj->pilsobj;

	iwchYsr = ptxtobjYsr->iwchFirst + dwchYsr;

	if (ptxtobjYsr->txtf & txtfGlyphBased)
		{
		lserr = GetWidthOfGlyph(pilsobj, pchnkeYsr->plsrun, plocchnk->lsfgi.lstflow, pilsobj->wchHyphen,
									 &fSuccessful, &gind, &durHyphen, &dupHyphen);
		if (lserr != lserrNone) return lserr;

		if (!fSuccessful)
			{
			*pfSuccess = fFalse;
			return lserrNone;
			}

		phyphout->gindHyphen = gind;
		phyphout->igindHyphen = IgindFirstFromIwch(ptxtobjYsr, iwchYsr) + 1;
		}
	else
		{
		lserr = GetWidthOfChar(pilsobj, pchnkeYsr->plsrun, plocchnk->lsfgi.lstflow, pilsobj->wchHyphen, &durHyphen, &dupHyphen);
		if (lserr != lserrNone) return lserr;
		}
	
	phyphout->durHyphen = durHyphen;
	phyphout->dupHyphen = dupHyphen;
	Assert(phyphout->wchPrev == 0);
	Assert(phyphout->durPrev == 0);
	Assert(phyphout->dupPrev == 0);
	Assert(phyphout->wchPrevPrev == 0);
	Assert(phyphout->durPrevPrev == 0);
	Assert(phyphout->dupPrevPrev == 0);

	switch (ysrinf.kysr)
		{
	case kysrNormal:
	case kysrChangeAfter:
		if (itxtobjPrev == itxtobjYsr && (ptxtobjYsr->txtf & txtfGlyphBased) && !FIwchOneToOne(pilsobj, iwchYsr))
			{
			*pfSuccess = fFalse;
			return lserrNone;
			}

		phyphout->iwchLim = iwchYsr + 2;
		phyphout->dwchYsr = 2;

		phyphout->durChangeTotal = durHyphen;
		break;

	case kysrChangeBefore:
		if (itxtobjPrev == ichnkOutside)
			{
			*pfSuccess = fFalse;
			return lserrNone;
			}

		pchnkePrev = &plocchnk->plschnk[itxtobjPrev];
		ptxtobjPrev = (PTXTOBJ)pchnkePrev->pdobj;

		if (iwchYsr < ptxtobjPrev->iwchFirst || iwchYsr >= ptxtobjPrev->iwchLim)
			{
			*pfSuccess = fFalse;
			return lserrNone;
			}

		if (ptxtobjPrev->txtf & txtfGlyphBased)
			{
			lserr = GetWidthOfGlyph(pilsobj, pchnkePrev->plsrun, plocchnk->lsfgi.lstflow, ysrinf.wchYsr,
										 &fSuccessful, &gind, &durNew, &dupNew);
			if (lserr != lserrNone) return lserr;

			if (!fSuccessful || !FIwchOneToOne(pilsobj, iwchYsr))
				{
				*pfSuccess = fFalse;
				return lserrNone;
				}
			phyphout->gindPrev = gind;
			phyphout->igindPrev = IgindFirstFromIwch(ptxtobjPrev, iwchYsr);
			}
		else
			{
			lserr = GetWidthOfChar(pilsobj, pchnkePrev->plsrun, plocchnk->lsfgi.lstflow, ysrinf.wchYsr, &durNew, &dupNew);
			if (lserr != lserrNone) return lserr;
			}

		GetOneCharWidth(ptxtobjPrev, iwchYsr, &durPrevOld);

		phyphout->iwchLim = iwchYsr + 2;
		phyphout->dwchYsr = 2;

		phyphout->wchPrev = ysrinf.wchYsr;
		phyphout->durPrev = durNew;
		phyphout->dupPrev = dupNew;

		phyphout->durChangeTotal = durHyphen + durNew - durPrevOld;
		break;

	case kysrAddBefore:
		if (ptxtobjYsr->txtf & txtfGlyphBased)
			{
			lserr = GetWidthOfGlyph(pilsobj, pchnkeYsr->plsrun, plocchnk->lsfgi.lstflow, ysrinf.wchYsr,
										 &fSuccessful, &gind, &durNew, &dupNew);
			if (lserr != lserrNone) return lserr;

			if (!fSuccessful || !FIwchOneToOne(pilsobj, iwchYsr))
				{
				*pfSuccess = fFalse;
				return lserrNone;
				}
			phyphout->gindPrev = gind;
			phyphout->igindHyphen++;
			phyphout->igindPrev = phyphout->igindHyphen - 1;
			}
		else
			{
			lserr = GetWidthOfChar(pilsobj, pchnkeYsr->plsrun, plocchnk->lsfgi.lstflow, ysrinf.wchYsr, &durNew, &dupNew);
			if (lserr != lserrNone) return lserr;
			}

		/* procedure CheckReallocArrays made shure we have enough space in arrays */
		phyphout->iwchLim = iwchYsr + 3;
		phyphout->dwchYsr = 3;

		phyphout->wchPrev = ysrinf.wchYsr;
		phyphout->durPrev = durNew;
		phyphout->dupPrev = dupNew;

		phyphout->durChangeTotal = durHyphen + durNew;
		break;

	case kysrDelAndChange:
		if (itxtobjPrev == ichnkOutside || itxtobjPrevPrev == ichnkOutside)
			{
			*pfSuccess = fFalse;
			return lserrNone;
			}
		

		pchnkePrev = &plocchnk->plschnk[itxtobjPrev];
		ptxtobjPrev = (PTXTOBJ)pchnkePrev->pdobj;
		pchnkePrevPrev = &plocchnk->plschnk[itxtobjPrevPrev];
		ptxtobjPrevPrev = (PTXTOBJ)pchnkePrevPrev->pdobj;

		if (iwchYsr < ptxtobjPrev->iwchFirst || iwchYsr >= ptxtobjPrev->iwchLim ||
			iwchYsr - 1 < ptxtobjPrevPrev->iwchFirst || iwchYsr - 1>= ptxtobjPrevPrev->iwchLim)
			{
			*pfSuccess = fFalse;
			return lserrNone;
			}

		GetOneCharWidth(ptxtobjPrev, iwchYsr, &durPrevOld);
		GetOneCharWidth(ptxtobjPrevPrev, iwchYsr - 1, &durPrevPrevOld);

		if (ptxtobjPrev->txtf & txtfGlyphBased)
			{
			lserr = GetWidthOfGlyph(pilsobj, pchnkePrev->plsrun, plocchnk->lsfgi.lstflow, pilsobj->wchSpace,
										 &fSuccessful, &gind, &durNew, &dupNew);
			if (lserr != lserrNone) return lserr;

			if (!fSuccessful || !FIwchOneToOne(pilsobj, iwchYsr))
				{
				*pfSuccess = fFalse;
				return lserrNone;
				}
			phyphout->gindPrev = gind;
			phyphout->igindPrev = IgindFirstFromIwch(ptxtobjPrev, iwchYsr);
			}

		if (ptxtobjPrevPrev->txtf & txtfGlyphBased)
			{
			lserr = GetWidthOfGlyph(pilsobj, pchnkePrevPrev->plsrun, plocchnk->lsfgi.lstflow, ysrinf.wchYsr,
										 &fSuccessful, &gind, &durNew, &dupNew);
			if (lserr != lserrNone) return lserr;

			if (!fSuccessful || !FIwchOneToOne(pilsobj, iwchYsr - 1))
				{
				*pfSuccess = fFalse;
				return lserrNone;
				}
			phyphout->gindPrevPrev = gind;
			phyphout->igindPrevPrev = IgindFirstFromIwch(ptxtobjPrevPrev, iwchYsr - 1);
			}
		else
			{
			lserr = GetWidthOfChar(pilsobj, pchnkePrevPrev->plsrun, plocchnk->lsfgi.lstflow, ysrinf.wchYsr, &durNew, &dupNew);
			if (lserr != lserrNone) return lserr;
			}

		
		phyphout->iwchLim = iwchYsr + 2;
		phyphout->dwchYsr = 2;

		phyphout->wchPrev = pilsobj->wchSpace;
		phyphout->durPrev = 0;
		phyphout->dupPrev = 0;
		phyphout->wchPrevPrev = ysrinf.wchYsr;
		phyphout->durPrevPrev = durNew;
		phyphout->dupPrevPrev = dupNew;

		phyphout->durChangeTotal = durHyphen + durNew - durPrevOld - durPrevPrevOld;
		
		break;

	case kysrDeleteBefore:
		if (itxtobjPrev == ichnkOutside)
			{
			*pfSuccess = fFalse;
			return lserrNone;
			}

		pchnkePrev = &plocchnk->plschnk[itxtobjPrev];
		ptxtobjPrev = (PTXTOBJ)pchnkePrev->pdobj;

		if (iwchYsr < ptxtobjPrev->iwchFirst || iwchYsr >= ptxtobjPrev->iwchLim)
			{
			*pfSuccess = fFalse;
			return lserrNone;
			}

		GetOneCharWidth(ptxtobjPrev, iwchYsr, &durPrevOld);

		if (ptxtobjPrev->txtf & txtfGlyphBased)
			{
			lserr = GetWidthOfGlyph(pilsobj, pchnkePrev->plsrun, plocchnk->lsfgi.lstflow, pilsobj->wchSpace,
										 &fSuccessful, &gind, &durNew, &dupNew);
			if (lserr != lserrNone) return lserr;

			if (!fSuccessful || !FIwchOneToOne(pilsobj, iwchYsr))
				{
				*pfSuccess = fFalse;
				return lserrNone;
				}
			phyphout->gindPrev = gind;
			phyphout->igindPrev = IgindFirstFromIwch(ptxtobjPrev, iwchYsr);
			}


		phyphout->iwchLim = iwchYsr + 2;
		phyphout->dwchYsr = 2;

		phyphout->wchPrev = pilsobj->wchSpace;
		phyphout->durPrev = 0;
		phyphout->dupPrev = 0;

		phyphout->durChangeTotal = durHyphen - durPrevOld;
		break;
	default:
		NotReached();
		}

	if (itxtobjPrev != itxtobjYsr && durPrevOld != 0)
		{
		phyphout->ddurDnodePrev += (phyphout->durPrev - durPrevOld);
		}

	if (itxtobjPrevPrev != itxtobjYsr && durPrevPrevOld != 0)
		{
		if (itxtobjPrev == itxtobjPrevPrev || itxtobjPrev == itxtobjYsr)
			{
			phyphout->ddurDnodePrev += (phyphout->durPrevPrev - durPrevPrevOld);
			}
		else
			{
			phyphout->ddurDnodePrevPrev += (phyphout->durPrevPrev - durPrevPrevOld);
			}
		}

	return lserrNone;
}

#define cIncreaseBeakInfoMax	4

/* G E T  P B R K I N F */
/*----------------------------------------------------------------------------
    %%Function: GetPbrkinf
    %%Contact: sergeyge
	
	Gets the pointer to the available BREAKINFO staructure
----------------------------------------------------------------------------*/
LSERR GetPbrkinf(PILSOBJ pilsobj, PDOBJ pdobj, BRKKIND brkkind, BREAKINFO** ppbrkinf)
{
	LSERR lserr;
	BREAKINFO* pbreakinf;
	long ibrkinf = 0xFFFF;
	BOOL fInChildList;

	pbreakinf = pilsobj->pbreakinf;

	lserr = LsdnFInChildList(pilsobj->plsc, ((PTXTOBJ)pdobj)->plsdnUpNode, &fInChildList);
	Assert(lserr == lserrNone);

	if (!fInChildList)
		{
		switch(brkkind)
			{
		case brkkindPrev:
			ibrkinf = 0;
			break;
		case brkkindNext:
			ibrkinf = 1;
			break;
		case brkkindForce:
			ibrkinf = 2;
			break;
		default:
			NotReached();
			}
		}
	else
		{
		for (ibrkinf = 3; ibrkinf < (long)pilsobj->breakinfMac && 
					(pbreakinf[ibrkinf].pdobj != pdobj || pbreakinf[ibrkinf].brkkind != brkkind); ibrkinf++);
		}

	if (ibrkinf < (long)pilsobj->breakinfMac)
		{
		Assert(ibrkinf < 3 || pbreakinf[ibrkinf].pdobj == pdobj && pbreakinf[ibrkinf].brkkind == brkkind);
		*ppbrkinf = &pbreakinf[ibrkinf];
		}
	else if (pilsobj->breakinfMac < pilsobj->breakinfMax)
		{
		*ppbrkinf = &pilsobj->pbreakinf[pilsobj->breakinfMac];
		pilsobj->breakinfMac++;
		}
	else
		{
		Assert(pilsobj->breakinfMac == pilsobj->breakinfMax);
		pbreakinf = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, pilsobj->pbreakinf,
									 (pilsobj->breakinfMax + cIncreaseBeakInfoMax) * sizeof(BREAKINFO) );
		if (pbreakinf == NULL)
			{
			return lserrOutOfMemory;
			}
		pilsobj->pbreakinf = pbreakinf;
		pilsobj->breakinfMax += cIncreaseBeakInfoMax;

		*ppbrkinf = &pilsobj->pbreakinf[pilsobj->breakinfMac];
		pilsobj->breakinfMac++;
		}

	memset(*ppbrkinf, 0, sizeof(BREAKINFO));

	return lserrNone;
}

/* Internal functions implementation */

/* G E T  O N E  C H A R  W I D T H */
/*----------------------------------------------------------------------------
    %%Function: GetOneCharWidth
    %%Contact: sergeyge
	
	Reports width of the character iwch
----------------------------------------------------------------------------*/
static void GetOneCharWidth(PTXTOBJ ptxtobj, long iwch, long* pdurChar)
{
	if (ptxtobj->txtf & txtfGlyphBased)
		*pdurChar = ptxtobj->plnobj->pilsobj->pdurGind[IgindFirstFromIwch(ptxtobj, iwch)];
	else 
		*pdurChar = ptxtobj->plnobj->pilsobj->pdur[iwch];
}

/* G E T  W I D T H  O F  C H A R */
/*----------------------------------------------------------------------------
    %%Function: GetWidthOfChar
    %%Contact: sergeyge
	
	Reports width of the character wch with plsrun
----------------------------------------------------------------------------*/
static LSERR GetWidthOfChar(PILSOBJ pilsobj, PLSRUN plsrun, LSTFLOW lstflow, WCHAR wch, long* pdurNew, long* pdupNew)
{
	LSERR lserr;
	long durSumJunk;
	long limDurJunk;

	lserr = (*pilsobj->plscbk->pfnGetRunCharWidths)(pilsobj->pols, plsrun, lsdevReference, &wch, 1, LONG_MAX, lstflow,
																		(int*)pdurNew, &durSumJunk, &limDurJunk);
	if (lserr != lserrNone) return lserr;

	if (pilsobj->fDisplay)
		{
		if (!pilsobj->fPresEqualRef)
			{		
			lserr = (*pilsobj->plscbk->pfnGetRunCharWidths)(pilsobj->pols, plsrun, lsdevPres, &wch, 1, LONG_MAX, lstflow,
																		(int*)pdupNew, &durSumJunk, &limDurJunk);
			if (lserr != lserrNone) return lserr;
			}
		else            /* fPresEqualRef        */
			{
			*pdupNew = *pdurNew;
			}
		}

	return lserrNone;
	
}

/* G E T  W I D T H  O F  G L Y P H */
/*----------------------------------------------------------------------------
    %%Function: GetWidthOfGlyph
    %%Contact: sergeyge
	
	Reports width of the glyph corresponding to the character with plsrun
----------------------------------------------------------------------------*/
static LSERR GetWidthOfGlyph(PILSOBJ pilsobj, PLSRUN plsrun, LSTFLOW lstflow, WCHAR wch, BOOL* pfSuccessful, 
											GINDEX* pgind, long* pdurNew, long* pdupNew)
{
	LSERR lserr;
	GPROP* pgpropTemp;
	GPROP gprop;
	GMAP gmap;
	GINDEX* pgindTemp;
	DWORD cgind;
	GOFFSET goffs;

	*pfSuccessful = fTrue;

	lserr = (*pilsobj->plscbk->pfnGetGlyphs)(pilsobj->pols, plsrun, &wch, 1, lstflow, &gmap, &pgindTemp, &pgpropTemp, &cgind);
	if (lserr != lserrNone) return lserr;

	if (cgind != 1)
		{
		*pfSuccessful = fFalse;
		return lserrNone;
		}

	*pgind = *pgindTemp;
	gprop = *pgpropTemp;

	lserr = (*pilsobj->plscbk->pfnGetGlyphPositions)(pilsobj->pols, plsrun, lsdevReference, &wch, &gmap, 1, pgind,
				&gprop, cgind, lstflow,
				(int*)pdurNew, &goffs);
	if (lserr != lserrNone) return lserr;
	
	Assert(goffs.du == 0);
	Assert(goffs.dv == 0);

	if (pilsobj->fDisplay)
		{
		if (!pilsobj->fPresEqualRef)
			{
			lserr = (*pilsobj->plscbk->pfnGetGlyphPositions)(pilsobj->pols, plsrun, lsdevPres, &wch, &gmap, 1, pgind,
				&gprop, cgind, lstflow,
				(int*)pdupNew, &goffs);
			if (lserr != lserrNone) return lserr;
			}
		else
			*pdupNew = *pdurNew;
		}

	return lserrNone;
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lstxtmap.c ===
#include "lstxtmap.h"
#include "txtinf.h"
#include "txtginf.h"
#include "txtobj.h"
#include "txtils.h"


/* ==============================================================	*/
/* IgndFirstFromIwch	Find first GL index for a given IWCH		*/
/*																	*/
/* Contact: antons													*/
/* ==============================================================	*/

long IgindFirstFromIwch(PTXTOBJ ptxtobj, long iwch)
{
	PLNOBJ  plnobj  = ptxtobj->plnobj;

	Assert (FBetween (iwch, ptxtobj->iwchFirst, ptxtobj->iwchLim));

	/* Since "pilsobj->pgmap [iwch]" - */
	/* GL index is not absolute but RELATIVE to the first run shaped */
	/* with ptxtobj "together", we have to calculate required GL index */
	/* with the following folmula: */

	if (iwch == ptxtobj->iwchLim)
		return ptxtobj->igindLim;
	else
		return ptxtobj->igindFirst + plnobj->pgmap [iwch] - 
				plnobj->pgmap [ptxtobj->iwchFirst];
}

/* ==============================================================	*/
/* IgindFirstFromIwchVeryFirst 										*/
/*																	*/
/* Contact: antons													*/
/* ==============================================================	*/

long IgindFirstFromIwchVeryFirst (PTXTOBJ ptxtobj, long igindVeryFirst, long iwch)
{
	Assert (ptxtobj->iwchLim > ptxtobj->iwchFirst);

	return igindVeryFirst + ptxtobj->plnobj->pgmap [iwch];
}


/* ==============================================================	*/
/* IgindLastFromIwchVeryFirst										*/
/*																	*/
/* Contact: antons													*/
/* ==============================================================	*/

long IgindLastFromIwchVeryFirst (PTXTOBJ ptxtobj, long igindVeryFirst, long iwch)
{
	TXTGINF* pginf = ptxtobj->plnobj->pilsobj->pginf; 
	long igindLast;

	Assert (ptxtobj->iwchLim > ptxtobj->iwchFirst);

	igindLast = IgindFirstFromIwchVeryFirst (ptxtobj, igindVeryFirst, iwch);

	while (! (pginf [igindLast] & ginffLastInContext)) igindLast++;

	return igindLast;
}

void GetIgindsFromTxtobj ( PTXTOBJ	ptxtobj, 
						   long 	igindVeryFirst, 
						   long * 	pigindFirst, 
						   long * 	pigindLim )
{
	PLNOBJ  plnobj = ptxtobj->plnobj;
	PILSOBJ pilsobj = plnobj->pilsobj;
	TXTGINF* pginf = pilsobj->pginf; 
	long igindLast;

	Assert (ptxtobj->iwchLim > ptxtobj->iwchFirst);
	Assert (pilsobj->ptxtinf [ptxtobj->iwchFirst].fFirstInContext);
	Assert (pilsobj->ptxtinf [ptxtobj->iwchLim-1].fLastInContext);
	
	*pigindFirst = igindVeryFirst + plnobj->pgmap [ptxtobj->iwchFirst];

	igindLast = IgindFirstFromIwch (ptxtobj, ptxtobj->iwchLim-1);

	while (! (pginf [igindLast] & ginffLastInContext)) igindLast++;

	*pigindLim = igindLast + 1;
}





/* ==============================================================	*/
/* IgndLastFromIwch		Find last GL index for a given IWCH			*/
/*																	*/
/* Contact: antons													*/
/* ==============================================================	*/

long IgindLastFromIwch(PTXTOBJ ptxtobj, long iwch)
{
	PILSOBJ  pilsobj  = ptxtobj->plnobj->pilsobj;
	TXTGINF* pginf    = pilsobj->pginf; 
	long igindLast;

	if (iwch < ptxtobj->iwchFirst)
		return -1;

	igindLast = IgindFirstFromIwch (ptxtobj, iwch);

	Assert (FBetween (iwch, ptxtobj->iwchFirst, ptxtobj->iwchLim-1));

	while (! (pginf [igindLast] & ginffLastInContext)) igindLast++;

	Assert (ptxtobj->igindLim == 0 || FBetween (igindLast, ptxtobj->igindFirst, ptxtobj->igindLim-1));

	return igindLast;
}


/* ===================================================================	*/
/* IgindBaseFromIgind:													*/
/* Returns last glyph with non-zero width before IGIND in this context	*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

long IgindBaseFromIgind(PILSOBJ pilsobj, long igind)
{
	TXTGINF* pginf    = pilsobj->pginf; 

	/*  Very simple... just scan back until <> 0 */

	while (pilsobj->pdurGind [igind] == 0 && !(pginf [igind] & ginffFirstInContext)) 
		{

		Assert (igind > 0);

		igind --;
		}

	return igind;
}


/* ===================================================================	*/
/* IwchFirstFromIgind:													*/
/* Returns first IWCH in the context for a given IGIND					*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

long IwchFirstFromIgind(PTXTOBJ ptxtobj, long igind)
{
	PILSOBJ  pilsobj  = ptxtobj->plnobj->pilsobj;
	TXTINF*  ptxtinf  = pilsobj->ptxtinf;
	TXTGINF* pginf    = pilsobj->pginf; 

	long iwchFirst	= ptxtobj->iwchFirst;
	long igindLast	= ptxtobj->igindFirst;

	Assert (FBetween (igind, ptxtobj->igindFirst, ptxtobj->igindLim-1));

	/* Go ahead until we have found last GIND of the first conext in txtobj */
		
	while (! (pginf [igindLast] & ginffLastInContext)) igindLast++;

	/* The following LOOP goes ahead checking context after context 	/* beginning of txtobj

	   INVARIANT:

			iwchFirst -- First IWCH of the current context
			igindLast -- Last  GIND of the current context
			
	   The second condition is true because of the "while" above

	*/

	while (igindLast < igind)
	{

		/* Asserts to check that INVARIANT is true */
		
		Assert (ptxtinf  [iwchFirst].fFirstInContext);
		Assert (pginf [igindLast] & ginffLastInContext);

		/* Move ahead by 1 context... it is easy */

		igindLast++;
		while (! (pginf [igindLast] & ginffLastInContext)) igindLast++;
		while (! (ptxtinf [iwchFirst]. fLastInContext)) iwchFirst++;
		iwchFirst++;
	};

	/* Asserts to check that we have not gone out from txtobj boundaries before reaching igind */

	Assert (FBetween (iwchFirst, ptxtobj->iwchFirst, ptxtobj->iwchLim-1));
	Assert (FBetween (igindLast, ptxtobj->igindFirst, ptxtobj->igindLim-1));
	
	/* Well, since INVARIANT is true and "igindLast >= igind", 
	   igind should belong to the current context. What we have to return
	   is just iwchFirst 
	*/

	return iwchFirst;
}

/* ===================================================================	*/
/* IwchLastFromIwch:													*/
/* Returns last iwch of context from given iwch							*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

long IwchLastFromIwch(PTXTOBJ ptxtobj, long iwch)
{
	PILSOBJ  pilsobj  = ptxtobj->plnobj->pilsobj;
	TXTINF*  ptxtinf  = pilsobj->ptxtinf;

	Assert(iwch >= ptxtobj->iwchFirst && iwch < ptxtobj->iwchLim);

	while (! (ptxtinf [iwch]. fLastInContext))
		iwch++;

	Assert(iwch >= ptxtobj->iwchFirst && iwch < ptxtobj->iwchLim);

	return iwch;
}

/* ===================================================================	*/
/* IwchPrevLastFromIwch:												*/
/* Returns last iwch of previous context from given iwch				*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

long IwchPrevLastFromIwch(PTXTOBJ ptxtobj, long iwch)
{
	PILSOBJ  pilsobj  = ptxtobj->plnobj->pilsobj;
	TXTINF*  ptxtinf  = pilsobj->ptxtinf;

	long iwchFirst	= ptxtobj->iwchFirst;

	iwch--;

	Assert(iwch >= ptxtobj->iwchFirst && iwch < ptxtobj->iwchLim);

	while (iwch >= iwchFirst && ! (ptxtinf [iwch]. fLastInContext))
		iwch--;

	return iwch;
}


/* ===================================================================	*/
/* FIwchOneToOne:														*/
/* Checks that IWCH belongs to 1:1 context								*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

BOOL FIwchOneToOne(PILSOBJ pilsobj, long iwch)
{
	return pilsobj->ptxtinf [iwch].fOneToOne;
}


/* ===================================================================	*/
/* FIwchLastInContext:													*/
/* Checks that IWCH is last in the context								*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

BOOL FIwchLastInContext(PILSOBJ pilsobj, long iwch)
{
	return pilsobj->ptxtinf [iwch].fLastInContext;

}

/* ===================================================================	*/
/* FIwchFirstInContext:													*/
/* Checks that IWCH is first in the context								*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

BOOL FIwchFirstInContext(PILSOBJ pilsobj, long iwch)
{
	return pilsobj->ptxtinf [iwch].fFirstInContext;
}


/* ===================================================================	*/
/* FIgindLastInContext:													*/
/* Checks that a given GL index is last in the context					*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

BOOL FIgindLastInContext(PILSOBJ pilsobj, long igind)
{
	return pilsobj->pginf [igind] & ginffLastInContext;
}

/* ===================================================================	*/
/* FIgindFirstInContext:												*/
/* Checks that a given GL index is first in the context					*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

BOOL FIgindFirstInContext(PILSOBJ pilsobj, long igind)
{
	return pilsobj->pginf [igind] & ginffFirstInContext;
}


/* ===================================================================	*/
/* DcpAfterContextFromDcp:												*/
/* For a given DCP (from the beginning of txtobj) it returns DCP after	*/
/* context bondary														*/
/*																		*/	
/* Function assumes that DCP starts with 1 and means					*/
/* "number of characters" from the beginning of txtobj. The resulting	*/
/* DCP (number of characters) will contain the rest of last context in	*/
/* given DCP. If context was closed then it returns the same DCP		*/	
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

long DcpAfterContextFromDcp(PTXTOBJ ptxtobj, long dcp)
{
	PILSOBJ  pilsobj  = ptxtobj->plnobj->pilsobj;
	TXTINF*  ptxtinf  = pilsobj->ptxtinf;

	/* Translate dcp to iwchLast */

	long iwchLast = ptxtobj->iwchFirst + dcp - 1; 

	/* Here we check that iwchLast "= dcp-1" is correct for a given txtobj */

	Assert (FBetween (iwchLast, ptxtobj->iwchFirst, ptxtobj->iwchLim-1));

	/* Just scan ahead until context finishes */

	while (! ptxtinf [iwchLast].fLastInContext) iwchLast++;

	/* Again check that we are in txtobj boundaries */
	
	Assert (FBetween (iwchLast, ptxtobj->iwchFirst, ptxtobj->iwchLim-1));

	/* Translate iwchLast back to dcp */

	return iwchLast - ptxtobj->iwchFirst + 1;
}


/* ===================================================================	*/
/* InterpretMap															*/	
/*																		*/
/* Fills internal CH- and GL- based bits with context information		*/	
/* (the information is used by the rest functions in this file only)	*/
/*																		*/
/* IN:	pilsobj															*/
/*		iwchFirst	- The first iwch in "shaped together" chunk			*/
/*		dwch		- Number of characters in this chunk				*/
/*		igindFirst	- The first gind in "shaped together chunk			*/
/*		cgind		- Number of glyphs in this chunk					*/
/*																		*/
/* OUT:	(nothing)														*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

void InterpretMap(PLNOBJ plnobj, long iwchFirst, long dwch, long igindFirst, long cgind)
{

	TXTINF*  ptxtinf  = plnobj->pilsobj->ptxtinf;
	TXTGINF* pginf    = plnobj->pilsobj->pginf; 
	GMAP*	 pgmap	  = plnobj->pgmap;

	/* Last possible iwch and gind (remember, they are "last", not "lim" */

	long iwchLast  = iwchFirst + dwch - 1;
	long igindLast = igindFirst + cgind - 1;

	/* Two global variables for main loop */

	long iwchFirstInContext = iwchFirst;
	long igindFirstInContext = igindFirst;
	
	/* The following WHILE translates context after context

		INVARIANT:

			* iwchFirstInContext   -- The first iwch in current context
			* igindFirstInContext  -- The first gind in current context
			* All context to the left from current have been translated

		The loop translates current context and moves iwchFirstIn... &
		igindFirst... to the next context

	*/

	while (iwchFirstInContext <= iwchLast)
			
		/* According to D.Gris I should have checked "!= iwchLast+1" but I do not
		   like ship version to come to infinite loop even because of wrong data ;-)
		   For debug, I will have Assert right after loop terminates */	
	
		{

		/* Variables for last gind and iwch of the current context */

		long igindLastInContext;
		long iwchLastInContext = iwchFirstInContext;

		/* Just to make sure that igindFirst... corresponds to iwchFirst... */

		Assert ( pgmap [iwchFirstInContext] + igindFirst == igindFirstInContext );
		Assert (iwchLastInContext <= iwchLast);

		/* P.S. Since pgmap values are RELATIVE to the beginning of "shape together"
		   chunk, we shall ALWAYS add igindFirst to pgmap value in order to get
		   GL index in our meaning 
		*/
		
		/* Following simple loop with find correct iwchLastInContext */
		/* Note that we add igindFirst to pgmap value (see PS. above) */

		while ((iwchLastInContext <= iwchLast) && (pgmap [iwchLastInContext] + igindFirst == igindFirstInContext)) 
			iwchLastInContext++;

		iwchLastInContext--;

		/* Now we know iwchLastInContextare and we are ready to find igindLastInContext 

		   I will peep in pgmap value of the character following iwchLastInContext or take
		   last avaiable GL index (igindLast) if iwchLastInContext is really last available

		*/

		igindLastInContext = (iwchLastInContext < iwchLast ? 
			pgmap [iwchLastInContext+1] + igindFirst - 1 :
			igindLast
		);

		/* Check that there is at least one GL inside our context */
		/* Note: we do not need to check the same for characters */

		Assert (igindFirstInContext <= igindLastInContext);

		/* It is time to set flags in our GL and CH arrays */

		if ( ( iwchFirstInContext ==  iwchLastInContext) && 
			 (igindFirstInContext == igindLastInContext))
			{

			/* We have 1:1 mapping (I separate it for better perfomance) */
			
			ptxtinf [iwchFirstInContext].fOneToOne = fTrue;
			ptxtinf [iwchFirstInContext].fFirstInContext = fTrue;
			ptxtinf [iwchFirstInContext].fLastInContext = fTrue;

			/* See comments in "General case" */

			pginf [igindFirstInContext] |= ginffOneToOne | ginffFirstInContext | ginffLastInContext;
			}
		else 
			{
			
			/* General case when there is not 1:1 mapping */
			
			long i; /* Variable for two loops */

			/* Set up character-based bits */
			
			for (i=iwchFirstInContext; i<=iwchLastInContext; i++)
				{
				ptxtinf [i].fOneToOne = fFalse; /* Of course, it is not 1:1 */

				/* I was considering whether to place boundary cases (first/last character
				   in context) outside loop but finally came to the conclusion that it would
				   cheaper both for code and perfomance to check it for each character as
				   follows */

				ptxtinf [i].fFirstInContext = (i==iwchFirstInContext);
				ptxtinf [i].fLastInContext = (i==iwchLastInContext);
				};

			
			/* With glyph-based flags we can win some perfomance by setting all bits in
			   one operation (since they are really bits, not booleans. Again I do not like
			   to do separate job for context boundaries */			

			for (i=igindFirstInContext; i<=igindLastInContext; i++)
				pginf [i] &= ~ (ginffOneToOne | ginffFirstInContext |
									ginffLastInContext);

			/* And finally I set corresponding bits for the first & last GLs in the context */

			pginf [igindFirstInContext] |= ginffFirstInContext;
			pginf [igindLastInContext] |= ginffLastInContext;
			};


		/* To start loop again we have to move to the next context. Now it is easy... */

		iwchFirstInContext = iwchLastInContext+1;
		igindFirstInContext = igindLastInContext+1;
		};


	/* See comments in the beginning of the loop */

	Assert (iwchFirstInContext == iwchLast + 1);
	Assert (igindFirstInContext == igindLast + 1);

	/* And according to INVARIANT, we are done */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lstxtjst.c ===
#include "lsmem.h"
#include <limits.h>

#include "lstxtjst.h"

#include "lstxtwrd.h"
#include "lstxtcmp.h"
#include "lstxtglf.h"
#include "lstxtscl.h"
#include "lstxtmap.h"
#include "lsdnset.h"
#include "lsdntext.h"
#include "locchnk.h"
#include "posichnk.h"
#include "objdim.h"
#include "lstxtffi.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"

#define min(a,b)     ((a) > (b) ? (b) : (a))
#define max(a,b)     ((a) < (b) ? (b) : (a))

static void GetFirstPosAfterStartSpaces(const LSGRCHNK* plsgrchnk, long itxtobjLast, long iwchLim,
				long* pitxtobjAfterStartSpaces, long* piwchAfterStartSpaces, BOOL* pfFirstOnLineAfter);
static LSERR HandleSimpleTextWysi(LSKJUST lskjust, const LSGRCHNK* plsgrchnk, long durToDistribute,
			 long dupAvailable, LSTFLOW lstflow, long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
			 long itxtobjLast, long iwchLast, BOOL fExactSync,
			 BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail);
static LSERR HandleSimpleTextPres(LSKJUST lskjust, const LSGRCHNK* plsgrchnk,
					 long dupAvailable, long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
					 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
					 long* pdupText, long* pdupTail);
static LSERR HandleGeneralSpacesExactSync(LSKJUST lskjust, const LSGRCHNK* plsgrchnk, long durToDistribute,
			 long dupAvailable, LSTFLOW lstflow, long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
			 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail);
static LSERR HandleGeneralSpacesPres(LSKJUST lskjust, const LSGRCHNK* plsgrchnk, long dupAvailable,
					 LSTFLOW lstflow, long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
					 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
					 long* pdupText, long* pdupTail);
static LSERR HandleTablesBased(LSKJUST lskjust, const LSGRCHNK* plsgrchnk,
			 long durToDistribute, long dupAvailable, LSTFLOW lstflow,
			 long itxtobjAfterStartSpaces, long iwchAfterStartSpaces, BOOL fFirstOnLineAfter,
			 long itxtobjLast, long iwchLast, long cNonText, BOOL fLastObjectIsText,
			 BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail, long* pdupExtNonText);
static LSERR HandleFullGlyphsExactSync(const LSGRCHNK* plsgrchnk,
			 long durToDistribute, long dupAvailable, LSTFLOW lstflow,
			 long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
			 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail);
static LSERR HandleFullGlyphsPres(const LSGRCHNK* plsgrchnk, long dupAvailable,
			 LSTFLOW lstflow, long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
			 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail);

/* A D J U S T  T E X T */
/*----------------------------------------------------------------------------
    %%Function: AdjustText
    %%Contact: sergeyge

	The top-level text handler function of
	the PrepLineForDisplay time---calculation of the presentation widths

	It calculates justification area (from first non-space to last non-space),
	checks for the type of justification and WYSIWYG algorythm 
	and redirects the program flow accordingly.
----------------------------------------------------------------------------*/
LSERR AdjustText(LSKJUST lskjust, long durColumnMax, long durTotal, long dupAvailable,
		const LSGRCHNK* plsgrchnk, PCPOSICHNK pposichnkBeforeTrailing, LSTFLOW lstflow,
		BOOL fCompress, DWORD cNonText,	BOOL fSuppressWiggle, BOOL fExactSync,
		BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
		long* pdupText, long* pdupTail,long* pdupExtNonTextObjects,	DWORD* pcExtNonTextObjects)
{
	PILSOBJ pilsobj;
	long itxtobjAfterStartSpaces;
	long itxtobjLast;
	PTXTOBJ ptxtobjLast;
	long iwchAfterStartSpaces;
	long iwchLast;
	long clsgrchnk;
	long durToDistribute;
	BOOL fFirstOnLineAfter;
	BOOL fLastObjectIsText;
	LSDCP dcp;

	*pdupText = 0;
	*pdupTail = 0;
	*pdupExtNonTextObjects = 0;
	*pcExtNonTextObjects = 0;

	clsgrchnk = (long)plsgrchnk->clsgrchnk;

	if (clsgrchnk == 0)
		{
		Assert(cNonText > 0);
		if (lskjust == lskjFullScaled || lskjust == lskjFullInterLetterAligned)
			{
			*pcExtNonTextObjects = cNonText - 1;
			*pdupExtNonTextObjects = dupAvailable;
			}
		return lserrNone;
		}


	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;
	Assert (pilsobj->fDisplay);

	if (pilsobj->fPresEqualRef)
		{
		fExactSync = fFalse;
		fSuppressWiggle = fFalse;
		}


	itxtobjLast = pposichnkBeforeTrailing->ichnk;
	dcp = pposichnkBeforeTrailing->dcp;

	Assert(itxtobjLast >= 0);
	Assert(itxtobjLast < clsgrchnk || (itxtobjLast == clsgrchnk && dcp == 0));

	if (dcp == 0 && itxtobjLast > 0)
		{
		itxtobjLast--;
		dcp = plsgrchnk->plschnk[itxtobjLast].dcp;
		}

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[itxtobjLast].pdobj;

	if (ptxtobjLast->iwchLim > ptxtobjLast->iwchFirst)
		iwchLast = ptxtobjLast->iwchFirst + dcp - 1;
	else
		iwchLast = ptxtobjLast->iwchLim - 1;

	/* In the case of AutoHyphenation, dcp reported by manager is not equal to the real number of characters---
		it should be fixed.	Notice that in the case of "delete before" hyphenation type,
		situation is totally wrong because deleted character was replaced by space and collected by manager  as trailing space.
	*/
	if (ptxtobjLast == ptxtobjLast->plnobj->pdobjHyphen)
		{
		iwchLast = ptxtobjLast->iwchLim - 1;
		}


	Assert(iwchLast >= ptxtobjLast->iwchFirst - 1);
	Assert(iwchLast <= ptxtobjLast->iwchLim - 1);
	
	GetFirstPosAfterStartSpaces(plsgrchnk, itxtobjLast, iwchLast + 1,
								&itxtobjAfterStartSpaces, &iwchAfterStartSpaces, &fFirstOnLineAfter);

	durToDistribute = durColumnMax - durTotal;

	if (!pilsobj->fNotSimpleText)
		{
		if (durToDistribute < 0)
			fSuppressWiggle = fFalse;

		if (fExactSync || fSuppressWiggle)
			{
			return HandleSimpleTextWysi(lskjust, plsgrchnk, durToDistribute, dupAvailable, lstflow, 
				itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast, fExactSync,
				fForcedBreak, fSuppressTrailingSpaces,
				pdupText, pdupTail);
			}
//		else if (fSupressWiggle) /* add later */
		else
			{
			return HandleSimpleTextPres(lskjust, plsgrchnk, dupAvailable, 
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast,
							fForcedBreak, fSuppressTrailingSpaces,
							pdupText, pdupTail);
			}
		}
	else
		{
		long itxtobjFirstInLastTextChunk;
		for(itxtobjFirstInLastTextChunk = clsgrchnk; itxtobjFirstInLastTextChunk > 0 &&
			!(plsgrchnk->pcont[itxtobjFirstInLastTextChunk - 1] & fcontNonTextAfter); itxtobjFirstInLastTextChunk--);

		fLastObjectIsText = fTrue;
		if (itxtobjLast < itxtobjFirstInLastTextChunk || 
			itxtobjLast == itxtobjFirstInLastTextChunk && iwchLast < ((PTXTOBJ)plsgrchnk->plschnk[itxtobjFirstInLastTextChunk].pdobj)->iwchFirst )
			{
/* REVIEW sergeyge: check this logic */
			if (cNonText > 0)
				cNonText--;
			fLastObjectIsText = fFalse;
			}

		*pcExtNonTextObjects = cNonText;

		if (fCompress || lskjust == lskjFullInterLetterAligned || lskjust == lskjFullScaled || pilsobj->fSnapGrid)
			{
			return HandleTablesBased(lskjust, plsgrchnk, durToDistribute, dupAvailable, lstflow,
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, fFirstOnLineAfter, 
							itxtobjLast, iwchLast, cNonText, fLastObjectIsText,
							fForcedBreak, fSuppressTrailingSpaces,
							pdupText, pdupTail, pdupExtNonTextObjects);
			}
		else if (lskjust == lskjFullGlyphs)
			{
			if (fExactSync || fSuppressWiggle)
				{
				return HandleFullGlyphsExactSync(plsgrchnk, durToDistribute, dupAvailable, lstflow,
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast,
							fForcedBreak, fSuppressTrailingSpaces,
							pdupText, pdupTail);
				}
			else
				{
				return HandleFullGlyphsPres(plsgrchnk, dupAvailable, lstflow,
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast,
							fForcedBreak, fSuppressTrailingSpaces,
							pdupText, pdupTail);
				}
			}
		else 
			{
			if (plsgrchnk->clsgrchnk == 0)
				return lserrNone;

			Assert(fCompress == fFalse);
			Assert(lskjust == lskjNone || lskjust == lskjFullInterWord);
			if (fExactSync || fSuppressWiggle)
				{
				return HandleGeneralSpacesExactSync(lskjust, plsgrchnk, durToDistribute, dupAvailable, lstflow,
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast,
							fForcedBreak, fSuppressTrailingSpaces,
							pdupText, pdupTail);
				}
			else
				{
				return HandleGeneralSpacesPres(lskjust, plsgrchnk, dupAvailable, lstflow,
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast,
							fForcedBreak, fSuppressTrailingSpaces,
							pdupText, pdupTail);
				}
			}

		}

}


/* C A N  C O M P R E S S  T E X T */
/*----------------------------------------------------------------------------
    %%Function: CanCompressText
    %%Contact: sergeyge

	Procedure checks if there is enough compression opportunities on the line
	to squeeze in needed amount (durToCompress).
	Trailing spaces are already subtracted by the manager.
	This procedure takes care of the hanging punctuation
	and possible changes if this break opportunity will be realized

	At the end it helps Word to solve backward compatibility issues
----------------------------------------------------------------------------*/
LSERR CanCompressText(const LSGRCHNK* plsgrchnk, PCPOSICHNK pposichnkBeforeTrailing, LSTFLOW lstflow,
					long durToCompress,	BOOL* pfCanCompress, BOOL* pfActualCompress, long* pdurNonSufficient)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long clschnk;
	long itxtobjFirstInLastTextChunk; /* if GroupChunk ends with foreign object it is equal to cchnk */
	long itxtobjLast;
	PTXTOBJ ptxtobjLast;
	long iwchLast;
	long iwchLastTemp;
	long iwchAfterStartSpaces;
	long itxtobjAfterStartSpaces;
	long durCompressTotal;
	BOOL fHangingPunct;
	BOOL fChangeBackLastChar;
	long ibrkinf;
	BREAKINFO* pbrkinf = NULL;
	BOOL fFirstOnLineAfter;

	long durCompLastRight;
	long durCompLastLeft;
	long durChangeComp;
	BOOL fCancelHangingPunct;
	MWCLS mwclsLast;
	LSCP cpLim;
	LSCP cpLastAdjustable;
	LSDCP dcp;
	
	*pfCanCompress = fFalse;
	*pfActualCompress = fTrue;

	clschnk = (long)plsgrchnk->clsgrchnk;

	if (clschnk == 0)
		{
		*pfCanCompress = (durToCompress <=0 );
		*pfActualCompress = fFalse;
		return lserrNone;
		}

	Assert(clschnk > 0);

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[clschnk-1].pdobj)->plnobj->pilsobj;

	itxtobjLast = pposichnkBeforeTrailing->ichnk;
	dcp = pposichnkBeforeTrailing->dcp;

	Assert(itxtobjLast >= 0);
	Assert(itxtobjLast < clschnk || (itxtobjLast == clschnk && dcp == 0));

	if (dcp == 0 && itxtobjLast > 0)
		{
		itxtobjLast--;
		dcp = plsgrchnk->plschnk[itxtobjLast].dcp;
		}

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[itxtobjLast].pdobj;

	if (ptxtobjLast->iwchLim > ptxtobjLast->iwchFirst)
		iwchLast = ptxtobjLast->iwchFirst + dcp - 1;
	else
		iwchLast = ptxtobjLast->iwchLim - 1;

	Assert(iwchLast <= ptxtobjLast->iwchLim - 1);
	Assert(iwchLast >= ptxtobjLast->iwchFirst - 1);

	GetFirstPosAfterStartSpaces(plsgrchnk, itxtobjLast, iwchLast + 1,
								&itxtobjAfterStartSpaces, &iwchAfterStartSpaces, &fFirstOnLineAfter);

	if (iwchAfterStartSpaces > iwchLast)
		{
		*pfCanCompress = (durToCompress <=0 );
		*pfActualCompress = fFalse;
		return lserrNone;
		}

	for(itxtobjFirstInLastTextChunk = clschnk; itxtobjFirstInLastTextChunk > 0 && !(plsgrchnk->pcont[itxtobjFirstInLastTextChunk - 1] & fcontNonTextAfter); itxtobjFirstInLastTextChunk--);

	fHangingPunct = fFalse;
	if ((pilsobj->grpf & fTxtHangingPunct) &&
		(itxtobjLast > itxtobjFirstInLastTextChunk ||
		 itxtobjLast == itxtobjFirstInLastTextChunk && iwchLast >= ((PTXTOBJ)plsgrchnk->plschnk[itxtobjFirstInLastTextChunk].pdobj)->iwchFirst) &&
		!(ptxtobjLast->txtf & txtfGlyphBased))
		{
		lserr = (*pilsobj->plscbk->pfnFHangingPunct)(pilsobj->pols, plsgrchnk->plschnk[itxtobjLast].plsrun,
				(BYTE)pilsobj->ptxtinf[iwchLast].mwcls, pilsobj->pwchOrig[iwchLast], &fHangingPunct);
		if (lserr != lserrNone) return lserr;
		}
	
	/* Compression information should be collected under assumption that all chars have correct widths;
		Correct width of HangingPunct should be subtructed as well
	 */

	iwchLastTemp = iwchLast;
	
	fChangeBackLastChar = fFalse;

	for (ibrkinf = 0; ibrkinf < (long)pilsobj->breakinfMac &&
		(pilsobj->pbreakinf[ibrkinf].pdobj != (PDOBJ)ptxtobjLast ||
		((long)pilsobj->pbreakinf[ibrkinf].dcp != iwchLast + 1 - ptxtobjLast->iwchFirst &&
		 ptxtobjLast->txtkind != txtkindNonReqHyphen && ptxtobjLast->txtkind != txtkindOptBreak));
																						ibrkinf++);
	if (ibrkinf < (long)pilsobj->breakinfMac)
		{
		pbrkinf = &pilsobj->pbreakinf[ibrkinf];
		Assert(pbrkinf->brkt != brktHyphen);

		if (pbrkinf->brkt == brktNormal && pbrkinf->u.normal.durFix != 0)
			{
			/* Now manager makes correct calculation */
//			durToCompress += pbrkinf->u.normal.durFix;
			Assert(pilsobj->pdurRight[iwchLast] == - pbrkinf->u.normal.durFix);
			pilsobj->pdur[iwchLast] += pbrkinf->u.normal.durFix;
			pilsobj->pdurRight[iwchLast] = 0;
			fChangeBackLastChar = fTrue;
			}
		else if (pbrkinf->brkt == brktNonReq)
			{
			Assert(iwchLast + 1 == ptxtobjLast->iwchLim);
			/* Now manager makes correct calculation */
//			durToCompress += pbrkinf->u.nonreq.ddurTotal;
			fHangingPunct = fFalse;				/* hanging punct does not make sence in this case */
			if (pbrkinf->u.nonreq.dwchYsr >= 1)
				{
				if (pbrkinf->u.nonreq.wchPrev != 0)
					{
					iwchLastTemp--;
					if (pbrkinf->u.nonreq.wchPrevPrev != 0)
						{
						iwchLastTemp--;
						}
					}
				}
			}
		}


	*pfActualCompress = (durToCompress > 0);

	if (fHangingPunct)
		{
		pilsobj->ptxtinf[iwchLast].fHangingPunct = fTrue;

		durToCompress -= pilsobj->pdur[iwchLast];
		iwchLastTemp--;
		}

	durCompressTotal = 0;

	if (!pilsobj->fSnapGrid)
		{
		lserr = FetchCompressInfo(plsgrchnk, fFirstOnLineAfter, lstflow, 
			itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLastTemp + 1,
			durToCompress, &durCompressTotal);

		if (lserr != lserrNone) return lserr;
		}

	/* Next piece is added to provide mechanism for the backword compatibility with Word */
	durCompLastRight = 0; 
	durCompLastLeft = 0; 

	if	(!(((PTXTOBJ)(plsgrchnk->plschnk[itxtobjLast].pdobj))->txtf & txtfGlyphBased) &&
									!pilsobj->fSnapGrid)
		{
		GetCompLastCharInfo(pilsobj, iwchLast, &mwclsLast, &durCompLastRight, &durCompLastLeft);

		/* First 3 lines of the following condition mean:
			Is Last Significant Character On The Line Text?
		*/
		if (itxtobjFirstInLastTextChunk < (long)clschnk &&
			(itxtobjLast > itxtobjFirstInLastTextChunk ||
				 itxtobjLast == itxtobjFirstInLastTextChunk && iwchLast >= ((PTXTOBJ)plsgrchnk->plschnk[itxtobjFirstInLastTextChunk].pdobj)->iwchFirst) &&
			(durCompLastRight > 0 || durCompLastLeft > 0 || fHangingPunct))
			{
			cpLim = plsgrchnk->plschnk[clschnk-1].cpFirst + plsgrchnk->plschnk[clschnk-1].dcp;

			cpLastAdjustable = plsgrchnk->plschnk[itxtobjLast].cpFirst + 
					iwchLast - ((PTXTOBJ)plsgrchnk->plschnk[itxtobjLast].pdobj)->iwchFirst;

			durChangeComp = 0;

			if (fHangingPunct)
				{
				lserr = (*pilsobj->plscbk->pfnFCancelHangingPunct)(pilsobj->pols, cpLim, cpLastAdjustable,
												pilsobj->pwchOrig[iwchLast], mwclsLast, &fCancelHangingPunct);
				if (lserr != lserrNone) return lserr;

				if (fCancelHangingPunct)
					{
					lserr = FetchCompressInfo(plsgrchnk, fFirstOnLineAfter, lstflow, 
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast + 1,
							LONG_MAX, &durCompressTotal);
					if (lserr != lserrNone) return lserr;

					durToCompress += pilsobj->pdur[iwchLast];
		
					GetCompLastCharInfo(pilsobj, iwchLast, &mwclsLast, &durCompLastRight, &durCompLastLeft);
		
					if ((durCompLastRight + durCompLastLeft) > 0)
						{
						lserr = (*pilsobj->plscbk->pfnModifyCompAtLastChar)(pilsobj->pols, cpLim, cpLastAdjustable,
														pilsobj->pwchOrig[iwchLast], mwclsLast, 
														durCompLastRight, durCompLastLeft, &durChangeComp);
						if (lserr != lserrNone) return lserr;
						}

					Assert(durChangeComp >= 0);
					Assert(durChangeComp == 0 || (durCompLastRight + durCompLastLeft) > 0);
					}
				}
			else
				{
				lserr = (*pilsobj->plscbk->pfnModifyCompAtLastChar)(pilsobj->pols, cpLim, cpLastAdjustable,
					pilsobj->pwchOrig[iwchLast], mwclsLast, durCompLastRight, durCompLastLeft, &durChangeComp);
				if (lserr != lserrNone) return lserr;
		
				Assert(durChangeComp >= 0);
				Assert(durChangeComp == 0 || (durCompLastRight + durCompLastLeft) > 0);
				}

			durCompressTotal -= durChangeComp;
			}
		/* End of the piece is added to provide mechanizm for the backword compatibility with Word */
		}
	/* Restore width changed before the call to FetchCompressInfo */
	if (fChangeBackLastChar)
		{
		pilsobj->pdur[iwchLast] -= pbrkinf->u.normal.durFix;
		pilsobj->pdurRight[iwchLast] = - pbrkinf->u.normal.durFix;
		}

	if (!pilsobj->fSnapGrid)
		*pfCanCompress = (durToCompress <= durCompressTotal);
	else
		*pfCanCompress = (fHangingPunct && durToCompress <= 0);

	*pdurNonSufficient = durToCompress - durCompressTotal;

	return lserrNone;
}


/* D I S T R I B U T E  I N  T E X T */
/*----------------------------------------------------------------------------
    %%Function: DistributeInText
    %%Contact: sergeyge

	Distributes given amount in text chunk equally
	between all participating characters
----------------------------------------------------------------------------*/
LSERR DistributeInText(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, DWORD cNonText,
									   long durToDistribute, long* pdurNonTextObjects)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	DWORD clschnk;
	long* rgdur;
	long iFirst;
	long iLim;
	PTXTOBJ ptxtobj;
	long itxtobj;
	long i;
	long durTxtobj;
	OBJDIM objdim;

	Unreferenced(lstflow);
	clschnk = plsgrchnk->clsgrchnk;
	Assert(clschnk + cNonText > 0);
	
	if (clschnk == 0)
		{
		*pdurNonTextObjects = durToDistribute;
		return lserrNone;
		}

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;

/* REVIEW sergeyge:Very ugly but still better than anything else?
	Problem case is latin Rubi---NTI was not called and so additional arrays were not allocated

	Original solution---scaling everything down---is not an option becuse than we lose all
	left sided changes in the Rubi subline for Japanese case
*/
	pilsobj->fNotSimpleText = fTrue;

	if (pilsobj->pdurRight == NULL)
		{
		pilsobj->pdurRight = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->wchMax );
		Assert (pilsobj->pdurLeft == NULL);
		Assert (pilsobj->ptxtinf == NULL);
		pilsobj->pdurLeft = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->wchMax );
		pilsobj->ptxtinf = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(TXTINF) * pilsobj->wchMax );
		if (pilsobj->pdurRight == NULL || pilsobj->pdurLeft == NULL || pilsobj->ptxtinf == NULL)
			{
			return lserrOutOfMemory;
			}
		memset(pilsobj->pdurRight, 0, sizeof(long) * pilsobj->wchMax );
		memset(pilsobj->pdurLeft, 0, sizeof(long) * pilsobj->wchMax );
		memset(pilsobj->ptxtinf, 0, sizeof(TXTINF) * pilsobj->wchMax);
		}


	ApplyDistribution(plsgrchnk, cNonText, durToDistribute, pdurNonTextObjects);

	for (itxtobj = 0; itxtobj < (long)clschnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			iFirst = ptxtobj->igindFirst;
			iLim = ptxtobj->igindLim;
			rgdur = pilsobj->pdurGind;
			}
		else
			{
			iFirst = ptxtobj->iwchFirst;
			iLim = ptxtobj->iwchLim;
			rgdur = pilsobj->pdur;
			}
		durTxtobj = 0;
		for (i = iFirst; i < iLim; i++)
			{
			durTxtobj += rgdur[i];
			}

		lserr = LsdnGetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, &objdim);
		if (lserr != lserrNone) return lserr;

		objdim.dur = durTxtobj;

		lserr = LsdnResetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, &objdim);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;
}

/* G E T  T R A I L  I N F O  T E X T */
/*----------------------------------------------------------------------------
    %%Function: GetTrailInfoText
    %%Contact: sergeyge

	Calculates number of spaces at the end of dobj (assuming that it ends at dcp)
	and	the width of the trailing area
----------------------------------------------------------------------------*/
void GetTrailInfoText(PDOBJ pdobj, LSDCP dcp, DWORD* pcNumOfTrailSpaces, long* pdurTrailing)
{
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long iwch;
	
	Assert(dcp > 0);
	ptxtobj = (PTXTOBJ)pdobj;
	pilsobj = ptxtobj->plnobj->pilsobj;


	*pcNumOfTrailSpaces = 0;
	*pdurTrailing = 0;


	if (ptxtobj->txtkind == txtkindEOL)
		{
		Assert(dcp == 1);
		*pcNumOfTrailSpaces = 1;
		*pdurTrailing = ptxtobj->plnobj->pilsobj->pdur[ptxtobj->iwchFirst];
		}
	else if (!(pilsobj->grpf & fTxtWrapAllSpaces))
		{
		if (ptxtobj->txtkind == txtkindRegular)
			{

			Assert(ptxtobj->iwchLim >= ptxtobj->iwchFirst + (long)dcp);

			if (!(ptxtobj->txtf & txtfGlyphBased))
				{
				for (iwch = ptxtobj->iwchFirst + dcp - 1;
					iwch >= ptxtobj->iwchFirst && pilsobj->pwchOrig[iwch] == pilsobj->wchSpace; iwch--)
					{
					(*pcNumOfTrailSpaces)++;
					*pdurTrailing += pilsobj->pdur[iwch];
					}
				}
			else
				{
				long igindFirst = 0;
				long iwchFirst = 0;
				long igindLast;
				long igind;

				Assert(FIwchLastInContext(pilsobj, ptxtobj->iwchFirst + dcp - 1));

				igindLast = IgindLastFromIwch(ptxtobj, ptxtobj->iwchFirst + dcp - 1);

				for (iwch = ptxtobj->iwchFirst + dcp - 1;
					iwch >= ptxtobj->iwchFirst && pilsobj->pwchOrig[iwch] == pilsobj->wchSpace; iwch--);
				if (iwch < ptxtobj->iwchFirst)
					{
					iwchFirst = ptxtobj->iwchFirst;
					igindFirst = ptxtobj->igindFirst;
					}
				else
					{
					iwchFirst = IwchLastFromIwch(ptxtobj, iwch) + 1;
					igindFirst = IgindLastFromIwch(ptxtobj, iwch) + 1;
					}

				*pcNumOfTrailSpaces = ptxtobj->iwchFirst + dcp - iwchFirst;

				Assert(igindLast < ptxtobj->igindLim);
				for (igind = igindFirst; igind <= igindLast; igind++)
					*pdurTrailing += pilsobj->pdurGind[igind];
				}
			}
		else if (ptxtobj->txtkind == txtkindSpecSpace)
			{
			*pcNumOfTrailSpaces = dcp;
			*pdurTrailing = 0;
			for (iwch = ptxtobj->iwchFirst + dcp - 1; iwch >= ptxtobj->iwchFirst; iwch--)
					*pdurTrailing += pilsobj->pdur[iwch];
			}
		}
		
}


/* F  S U S P E C T  D E V I C E  D I F F E R E N T */
/*----------------------------------------------------------------------------
    %%Function: FSuspectDeviceDifferent
    %%Contact: sergeyge

	Returns TRUE if Visi character or NonReqHyphen-like character might be present
	on the line, and therefore fast prep-for-displaying is impossible in the case
	when fPresEqualRef is TRUE
----------------------------------------------------------------------------*/
BOOL FSuspectDeviceDifferent(PLNOBJ plnobj)
{
	return (plnobj->pilsobj->fDifficultForAdjust);
}


/* F  Q U I C K  S C A L I N G */
/*----------------------------------------------------------------------------
    %%Function: FQuickScaling
    %%Contact: sergeyge

	Checks if fast scaling is possible in the case when fPresEqualRef is FALSE
----------------------------------------------------------------------------*/
BOOL FQuickScaling(PLNOBJ plnobj, BOOL fVertical, long durTotal)
{
	PILSOBJ pilsobj;
	long durMax;

	pilsobj = plnobj->pilsobj;

	durMax = pilsobj->durRightMaxX;
	if (fVertical)
		durMax = pilsobj->durRightMaxY;

	return (durTotal < durMax && !pilsobj->fDifficultForAdjust && plnobj->ptxtobjFirst == plnobj->ptxtobj);
}


#define UpFromUrFast(ur)	( ((ur) * MagicConstant + (1 << 20)) >> 21)


/* Q U I C K  A D J U S T  E X A C T */
/*----------------------------------------------------------------------------
    %%Function: AdjustText
    %%Contact: sergeyge

	Fast scaling: does not check for width restrictions and for Visi situations,
	assumes that there is only text on the line.
----------------------------------------------------------------------------*/
void QuickAdjustExact(PDOBJ* rgpdobj, DWORD cdobj,	DWORD cNumOfTrailSpaces, BOOL fVertical,
																	long* pdupText, long* pdupTrail)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	long* rgdur;
	long* rgdup;
	long durSum;
	long dupSum;
	long dupErrLast;
	long dupPrevChar;
	long MagicConstant;
	long dupIdeal;
	long dupReal;
	long dupErrNew;
	long dupAdjust;
	long wCarry;
	long iwchPrev;
	long iwch;
	long itxtobj;
	long dupTotal;

	Assert(cdobj > 0);

	plnobj = ((PTXTOBJ)rgpdobj[0])->plnobj;
	pilsobj = plnobj->pilsobj;

	Assert(!pilsobj->fDifficultForAdjust);

	rgdur = pilsobj->pdur;
	rgdup = plnobj->pdup;

	if (fVertical)
		MagicConstant = pilsobj->MagicConstantY;
	else
		MagicConstant = pilsobj->MagicConstantX;

	itxtobj = 0;

	durSum = 0;
	dupPrevChar = 0;
	/* Pretty dirty; we make sure that for the first iteration dupAdjust will be 0 */
	iwchPrev = ((PTXTOBJ)rgpdobj[0])->iwchFirst;
	dupErrLast = rgdup[iwchPrev] - UpFromUrFast(rgdur[iwchPrev]);
	dupSum = 0;

	for(itxtobj = 0; itxtobj < (long)cdobj; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) rgpdobj[itxtobj];
		Assert(ptxtobj->txtkind != txtkindTab);
		Assert(!(ptxtobj->txtf & txtfGlyphBased));

		for(iwch = ptxtobj->iwchFirst; iwch < ptxtobj->iwchLim; iwch++)
			{
			durSum += rgdur[iwch];
			/* here David Bangs algorithm starts */
			dupIdeal = UpFromUrFast(durSum) - dupSum;
			Assert(dupIdeal >= 0);

			dupReal = rgdup[iwch];
			dupErrNew = dupReal - dupIdeal;
			dupAdjust = dupErrNew - dupErrLast;
			Assert(iwch > ((PTXTOBJ)rgpdobj[0])->iwchFirst || dupAdjust == 0);
			if (dupAdjust != 0)
				{
				wCarry = dupAdjust & 1;

			   	if (dupAdjust > 0)	
						{
			   		dupAdjust >>= 1;
					if (dupErrLast < -dupErrNew)
						dupAdjust += wCarry;
						dupAdjust = min(dupPrevChar /*-1*/, dupAdjust); 
					}
				else
					{
					dupAdjust >>= 1;
					if (dupErrNew < -dupErrLast)
						dupAdjust += wCarry;
					dupAdjust = max(/*1*/ - dupIdeal, dupAdjust); 
					}

				rgdup[iwchPrev] -= dupAdjust;
				dupIdeal += dupAdjust;
				}

			rgdup[iwch] = dupIdeal;
			dupSum += (dupIdeal - dupAdjust);
			dupErrLast = dupReal - dupIdeal;
			iwchPrev = iwch;
			dupPrevChar = dupIdeal;
			/* here David Bangs algorithm stops */
			}

		}


	*pdupText = 0;
	*pdupTrail = 0;
	for (itxtobj=0; itxtobj < (long)cdobj - 1; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) rgpdobj[itxtobj];
		dupTotal = 0;

		for(iwch = ptxtobj->iwchFirst; iwch < ptxtobj->iwchLim; iwch++)
			dupTotal += rgdup[iwch];

		*pdupText += dupTotal;
		lserr = LsdnSetTextDup(plnobj->pilsobj->plsc, ptxtobj->plsdnUpNode, dupTotal);
		Assert(lserr == lserrNone);
		}
	
	Assert(itxtobj == (long)cdobj - 1);
	ptxtobj = (PTXTOBJ) rgpdobj[itxtobj];

	Assert(ptxtobj->txtkind == txtkindEOL && cNumOfTrailSpaces == 1||
				 ptxtobj->iwchLim - ptxtobj->iwchFirst > (long)cNumOfTrailSpaces);
	dupTotal = 0;

	for (iwch = ptxtobj->iwchLim - 1; iwch > ptxtobj->iwchLim - (long)cNumOfTrailSpaces - 1; iwch--)
		{
		dupTotal += rgdup[iwch];
		*pdupTrail += rgdup[iwch];
		}

	Assert(iwch == ptxtobj->iwchLim - (long)cNumOfTrailSpaces - 1);

	for (; iwch >= ptxtobj->iwchFirst; iwch--)
		{
		dupTotal += rgdup[iwch];
		}

	*pdupText += dupTotal;
	lserr = LsdnSetTextDup(plnobj->pilsobj->plsc, ptxtobj->plsdnUpNode, dupTotal);
	Assert(lserr == lserrNone);

	return;
}

/* Internal functions implementation */


/* G E T  F I R S T  P O S  A F T E R  S T A R T  S P A C E S */
/*----------------------------------------------------------------------------
    %%Function: GetFirstPosAfterStartSpaces
    %%Contact: sergeyge

	Reports index of the first char after leading spaces
----------------------------------------------------------------------------*/
static void GetFirstPosAfterStartSpaces(const LSGRCHNK* plsgrchnk, long itxtobjLast, long iwchLim,
				long* pitxtobjAfterStartSpaces, long* piwchAfterStartSpaces, BOOL* pfFirstOnLineAfter)
{
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	long iwch;
	BOOL fInStartSpace;
	long itxtobj;
	PTXTOBJ ptxtobj;
	long iwchLimInDobj;
	PLSCHNK rglschnk;

	Assert(plsgrchnk->clsgrchnk > 0);

	rglschnk = plsgrchnk->plschnk;
	plnobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj;
	pilsobj = plnobj->pilsobj;
	itxtobj = 0;
	ptxtobj = (PTXTOBJ)rglschnk[0].pdobj;
	iwch =  0;

	*pitxtobjAfterStartSpaces = 0;
	*piwchAfterStartSpaces = ptxtobj->iwchFirst;
	*pfFirstOnLineAfter = !(plsgrchnk->pcont[0] & fcontNonTextBefore);

	fInStartSpace = *pfFirstOnLineAfter;

	while (fInStartSpace && itxtobj <= itxtobjLast)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;

		iwchLimInDobj = iwchLim;
		if (itxtobj < itxtobjLast)
			iwchLimInDobj = ptxtobj->iwchLim;

		if (plsgrchnk->pcont[itxtobj] & fcontNonTextBefore)
			{
			*pfFirstOnLineAfter = fFalse;
			*pitxtobjAfterStartSpaces = itxtobj;
			*piwchAfterStartSpaces = ptxtobj->iwchFirst;
			fInStartSpace = fFalse;
			}

		else if (ptxtobj->txtkind == txtkindRegular)
			{
			for (iwch = ptxtobj->iwchFirst; iwch < iwchLimInDobj && 
								pilsobj->pwchOrig[iwch] == pilsobj->wchSpace; iwch++);

			if ((ptxtobj->txtf & txtfGlyphBased) && iwch < iwchLimInDobj)
				{
				for(; !FIwchFirstInContext(pilsobj, iwch); iwch--);
				Assert(iwch >= ptxtobj->iwchFirst);
				}

			if (iwch < iwchLimInDobj)
				{
				*pitxtobjAfterStartSpaces = itxtobj;
				*piwchAfterStartSpaces = iwch;
				fInStartSpace = fFalse;
				}
			}
	/* REVIEW: sergeyge---should something be changed in the following check? */
		else if (ptxtobj->txtkind != txtkindEOL 
//				&&	 ptxtobj->txtkind != txtkindSpecSpace
				 )
			{
			*pitxtobjAfterStartSpaces = itxtobj;
			*piwchAfterStartSpaces = ptxtobj->iwchFirst;
			fInStartSpace = fFalse;
			}

		itxtobj++;
		iwch = iwchLimInDobj;
		}
		
	if (fInStartSpace)
		{
		*pitxtobjAfterStartSpaces = itxtobj;
		*piwchAfterStartSpaces = iwchLim;
		}

	return;

}


/* H A N D L E  S I M P L E  T E X T  W Y S I */
/*----------------------------------------------------------------------------
    %%Function: HandleSimpleTextWysi
    %%Contact: sergeyge

	Implements Latin-like justification in spaces (if needed)
	on the reference device	and WYSIWYG algorithm for the exact positioning
	under assumption that there were no NominalToIdeal modifications
	(except for Latin kerning) on the line.

	Startegy:
	 Distribute in spaces if needed
	 Scale down width of spaces from the reference device to the presentation one
	 Apply WYSIWYG algorithm
----------------------------------------------------------------------------*/
static LSERR HandleSimpleTextWysi(LSKJUST lskjust, const LSGRCHNK* plsgrchnk, long durToDistribute,
			 long dupAvailable, LSTFLOW lstflow, long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
			 long itxtobjLast, long iwchLast, BOOL fExactSync, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail)
{
	PTXTOBJ ptxtobj;
	BOOL fFullyJustified;

	fFullyJustified = fFalse;

	if (itxtobjLast > itxtobjAfterStartSpaces || (itxtobjLast == itxtobjAfterStartSpaces && iwchLast >= iwchAfterStartSpaces))
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;

		if (lskjust != lskjNone && durToDistribute > 0)
			{
			FullPositiveSpaceJustification(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces, 
							itxtobjLast, iwchLast,	ptxtobj->plnobj->pilsobj->pdur, NULL,
							durToDistribute, &fFullyJustified);
			ScaleSpaces(plsgrchnk, lstflow, itxtobjLast, iwchLast);
			}
		else if (!fForcedBreak && durToDistribute < 0)
			{
			fFullyJustified = fTrue;
			NegativeSpaceJustification(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces, 
							itxtobjLast, iwchLast, ptxtobj->plnobj->pilsobj->pdur, NULL,
							-durToDistribute);
			ScaleSpaces(plsgrchnk, lstflow, itxtobjLast, iwchLast);
			}
		}

	Unreferenced(fExactSync);
/*	if (fExactSync)*/
		ApplyWysi(plsgrchnk, lstflow);
/*	else
		ApplyNonExactWysi(plsgrchnk, lstflow);
*/

	return FinalAdjustmentOnPres(plsgrchnk, itxtobjLast, iwchLast, dupAvailable,
									 fFullyJustified, fForcedBreak, fSuppressTrailingSpaces,
									 pdupText, pdupTail);

}

/* H A N D L E  S I M P L E  T E X T  P R E S */
/*----------------------------------------------------------------------------
    %%Function: HandleSimpleTextPres
    %%Contact: sergeyge

	Implements Latin-like justification in spaces (if needed) 
	on the presentation device
	under assumption that there were no NominalToIdeal modifications
	(except for Latin kerning) on the line.

----------------------------------------------------------------------------*/
static LSERR HandleSimpleTextPres(LSKJUST lskjust, const LSGRCHNK* plsgrchnk,
					 long dupAvailable, long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
					 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
					 long* pdupText, long* pdupTail)
{
	PTXTOBJ ptxtobj;
	BOOL fFullyJustified;
	long* rgdup;
	long itxtobj;
	long iwchLim;
	long iwch;
	long dupTotal;
	long dupToDistribute;

	if (itxtobjLast > itxtobjAfterStartSpaces || (itxtobjLast == itxtobjAfterStartSpaces && iwchLast >= iwchAfterStartSpaces))
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;

		rgdup = ptxtobj->plnobj->pdup;

		dupTotal = 0;

		/* REVIEW sergeyge: should we think about eliminating this loop for online view? */
		for (itxtobj=0; itxtobj <= itxtobjLast; itxtobj++)
			{
			ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
	
			iwchLim = iwchLast + 1;
			if (itxtobj < itxtobjLast)
				iwchLim = ptxtobj->iwchLim;

			for (iwch = ptxtobj->iwchFirst; iwch < iwchLim; iwch++)
				{
				dupTotal += rgdup[iwch];
				}
			}

		dupToDistribute = dupAvailable - dupTotal;

		if (lskjust != lskjNone && dupToDistribute > 0)
			{
			FullPositiveSpaceJustification(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces, 
							itxtobjLast, iwchLast, rgdup, NULL,
							dupToDistribute, &fFullyJustified);
			}
		else if (!fForcedBreak && dupToDistribute < 0)
			{
			NegativeSpaceJustification(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces, 
							itxtobjLast, iwchLast, rgdup, NULL,
							-dupToDistribute);
			}

		}

	return FinalAdjustmentOnPres(plsgrchnk, itxtobjLast, iwchLast, dupAvailable,
									 fFalse, fForcedBreak, fSuppressTrailingSpaces,
									 pdupText, pdupTail);

}

/* H A N D L E  G E N E R A L  S P A C E S  E X A C T  S Y N C */
/*----------------------------------------------------------------------------
    %%Function: HandleGeneralSpacesExactSync
    %%Contact: sergeyge

	Implements Latin-like justification in spaces (if needed)
	on the reference device	and WYSIWYG algorithm for the exact positioning
	in the general case

	Startegy:
	 Distribute in spaces if needed
	 Scale down changes applied to characters during NTI and distribution
	 If glyphs were detected on the line,
      scale down changes apllied to glyphs during NTI
	  and adjust offsets
	 Apply WYSIWYG algorithm
	 If some characters were changed on the left side
	  prepare additional width array for the display time
----------------------------------------------------------------------------*/
static LSERR HandleGeneralSpacesExactSync(LSKJUST lskjust, const LSGRCHNK* plsgrchnk, long durToDistribute,
			 long dupAvailable, LSTFLOW lstflow, long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
			 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail)
{
	LSERR lserr;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	BOOL fFullyJustified = fFalse;
	BOOL fLeftSideAffected = fFalse;
	BOOL fGlyphDetected = fFalse;

	plnobj = ((PTXTOBJ) plsgrchnk->plschnk[0].pdobj)->plnobj;
	pilsobj = plnobj->pilsobj;

	if (itxtobjLast > itxtobjAfterStartSpaces || (itxtobjLast == itxtobjAfterStartSpaces && iwchLast >= iwchAfterStartSpaces))
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;

		if (lskjust != lskjNone && durToDistribute > 0)
			{
			FullPositiveSpaceJustification(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces, 
							itxtobjLast, iwchLast,	pilsobj->pdur, pilsobj->pdurGind,
							durToDistribute, &fFullyJustified);
			}
		else if (!fForcedBreak && durToDistribute < 0)
			{
			fFullyJustified = fTrue;
			NegativeSpaceJustification(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces, 
							itxtobjLast, iwchLast, pilsobj->pdur, pilsobj->pdurGind,
							-durToDistribute);
			}
		}

	ScaleCharSides(plsgrchnk, lstflow, &fLeftSideAffected, &fGlyphDetected);

	if (fGlyphDetected)
		{
		ScaleGlyphSides(plsgrchnk, lstflow);
		UpdateGlyphOffsets(plsgrchnk);
		SetBeforeJustCopy(plsgrchnk);
		}

	ApplyWysi(plsgrchnk, lstflow);

	lserr = FinalAdjustmentOnPres(plsgrchnk, itxtobjLast, iwchLast, dupAvailable,
									 fFullyJustified, fForcedBreak, fSuppressTrailingSpaces,
									 pdupText, pdupTail);
	if (lserr != lserrNone) return lserr;

	/* If pdupPen is already used, don't forget to copy pdup there---ScaleSides could change it */
	if (fLeftSideAffected || plnobj->pdup != plnobj->pdupPen)
		{
		lserr = FillDupPen(plsgrchnk, lstflow, itxtobjLast, iwchLast);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;

}

/* H A N D L E  G E N E R A L  S P A C E S  P R E S */
/*----------------------------------------------------------------------------
    %%Function: HandleGeneralSpacesPres
    %%Contact: sergeyge

	Implements Latin-like justification in spaces (if needed)
	directly on the presentation device in the general case

	Startegy:
	 Scale down changes applied to characters during NTI
	 If glyphs were detected on the line,
      scale down changes apllied to glyphs during NTI
	  and adjust glyph offsets
	 Distribute in spaces if needed
	 If glyphs were detected on the line,
	  adjust glyph offsets
	 If some characters were changed on the left side
	  prepare additional width array for the display time
----------------------------------------------------------------------------*/
static LSERR HandleGeneralSpacesPres(LSKJUST lskjust, const LSGRCHNK* plsgrchnk, long dupAvailable,
					 LSTFLOW lstflow, long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
					 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
					 long* pdupText, long* pdupTail)
{
	LSERR lserr;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	long* rgdup;
	BOOL fFullyJustified;
	long itxtobj;
	long iwchLastInDobj;
	long iFirst;
	long iLim;
	long i;
	long dupTotal;
	long dupToDistribute;
	BOOL fLeftSideAffected = fFalse;
	BOOL fGlyphDetected = fFalse;

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	plnobj = ptxtobjLast->plnobj;

	ScaleCharSides(plsgrchnk, lstflow, &fLeftSideAffected, &fGlyphDetected);

	if (fGlyphDetected)
		{
		ScaleGlyphSides(plsgrchnk, lstflow);
		UpdateGlyphOffsets(plsgrchnk);
		SetBeforeJustCopy(plsgrchnk);
		}

	if (itxtobjLast > itxtobjAfterStartSpaces || (itxtobjLast == itxtobjAfterStartSpaces && iwchLast >= iwchAfterStartSpaces))
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;

		dupTotal = 0;
		for (itxtobj=0; itxtobj <= itxtobjLast; itxtobj++)
			{
			ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;

			if (ptxtobj->txtf & txtfGlyphBased)
				{
				iFirst = ptxtobj->igindFirst;
				iwchLastInDobj = iwchLast;
				if (itxtobj < itxtobjLast)
					iwchLastInDobj = ptxtobj->iwchLim - 1;
				iLim = IgindLastFromIwch(ptxtobj, iwchLastInDobj) + 1;
				rgdup = plnobj->pdupGind;
				}
			else
				{
				iFirst = ptxtobj->iwchFirst;
				iLim = iwchLast + 1;
				if (itxtobj < itxtobjLast)
					iLim = ptxtobj->iwchLim;
				rgdup = plnobj->pdup;
				}
	
			for (i =iFirst; i < iLim; i++)
				{
				dupTotal += rgdup[i];
				}
			}

		dupToDistribute = dupAvailable - dupTotal;

		if (lskjust != lskjNone && dupToDistribute > 0)
			{
			FullPositiveSpaceJustification(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces, 
							itxtobjLast, iwchLast, plnobj->pdup, plnobj->pdupGind,
							dupToDistribute, &fFullyJustified);
			}
		else if (!fForcedBreak && dupToDistribute < 0)
			{
			NegativeSpaceJustification(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces, 
							itxtobjLast, iwchLast, plnobj->pdup, plnobj->pdupGind,
							-dupToDistribute);
			}

		if (fGlyphDetected)
			{
			UpdateGlyphOffsets(plsgrchnk);
			}
		}

	lserr = FinalAdjustmentOnPres(plsgrchnk, itxtobjLast, iwchLast, dupAvailable,
									 fFalse, fForcedBreak, fSuppressTrailingSpaces,
									 pdupText, pdupTail);

	if (lserr != lserrNone) return lserr;

	/* If pdupPen is already used, don't forget to copy pdup there---ScaleSides could change it */
	if (fLeftSideAffected || plnobj->pdup != plnobj->pdupPen)
		{
		lserr = FillDupPen(plsgrchnk, lstflow, itxtobjLast, iwchLast);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;
}

/* H A N D L E  T A B L E  B A S E D */
/*----------------------------------------------------------------------------
    %%Function: HandleTableBased
    %%Contact: sergeyge

	Implements FE-like justification or compression
	on the reference device	and WYSIWYG algorithm for the exact positioning

	Startegy:
	 Apply needed type of justification or compression
	 Scale down changes applied to characters during NTI and justification
	 If glyphs were detected on the line,
      scale down changes apllied to glyphs during NTI
	  and adjust offsets
	 Apply WYSIWYG algorithm
	 If some characters were changed on the left side
	  prepare additional width array for the display time
----------------------------------------------------------------------------*/
static LSERR HandleTablesBased(LSKJUST lskjust, const LSGRCHNK* plsgrchnk,
			 long durToDistribute, long dupAvailable, LSTFLOW lstflow,
			 long itxtobjAfterStartSpaces, long iwchAfterStartSpaces, BOOL fFirstOnLineAfter,
			 long itxtobjLast, long iwchLast, long cNonText, BOOL fLastObjectIsText,
			 BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail, long* pdupExtNonText)
{
	LSERR lserr;
	PILSOBJ pilsobj = NULL;
	PLNOBJ plnobj;
	long durExtNonText = 0;
	DWORD clschnk;
	MWCLS mwclsLast;
	long durCompLastLeft = 0;
	long durCompLastRight = 0;
	long durHangingChar;
	long dupHangingChar = 0;
	BOOL fHangingUsed = fFalse;
	long durCompressTotal;
	long iwchLastTemp;
	BOOL fScaledExp;
	BOOL fFullyJustified = fFalse;
	BOOL fLeftSideAffected = fFalse;
	BOOL fGlyphDetected = fFalse;

	Assert(lskjust == lskjFullInterLetterAligned ||
		   lskjust == lskjFullScaled ||
		   lskjust == lskjNone);

	*pdupExtNonText = 0;
	clschnk = plsgrchnk->clsgrchnk;
	Assert(clschnk > 0);

	plnobj = ((PTXTOBJ) plsgrchnk->plschnk[0].pdobj)->plnobj;
	pilsobj = plnobj->pilsobj;

	if (itxtobjLast > itxtobjAfterStartSpaces || (itxtobjLast == itxtobjAfterStartSpaces && iwchLast >= iwchAfterStartSpaces))
		{

		Assert(clschnk > 0);

		if (pilsobj->fSnapGrid)
			{
			if (durToDistribute < 0)
				{
				Assert(-durToDistribute <= pilsobj->pdur[iwchLast]);
				fHangingUsed = fTrue;
				}
			}
		else if (durToDistribute < 0)
			{
			fFullyJustified = fTrue;
			lserr = FetchCompressInfo(plsgrchnk, fFirstOnLineAfter, lstflow,
				itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast + 1,
				LONG_MAX, &durCompressTotal);
			if (lserr != lserrNone) return lserr;
			
			if (fLastObjectIsText && !(((PTXTOBJ) plsgrchnk->plschnk[0].pdobj)->txtf & txtfGlyphBased))
				GetCompLastCharInfo(pilsobj, iwchLast, &mwclsLast, &durCompLastRight, &durCompLastLeft);

			if (pilsobj->ptxtinf[iwchLast].fHangingPunct)
				{		
				Assert(lskjust == lskjNone || lskjust == lskjFullInterLetterAligned || lskjust == lskjFullScaled);
				Assert(fLastObjectIsText);
				if (durCompLastRight >= -durToDistribute)
					{

					Assert(durCompLastRight > 0);
					CompressLastCharRight(pilsobj, iwchLast, durCompLastRight);

					if (lskjust != lskjNone)
						{
						fScaledExp = (lskjust != lskjFullInterLetterAligned);
						lserr = ApplyExpand(plsgrchnk, lstflow, fScaledExp, 
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast, cNonText,
							durCompLastRight + durToDistribute, &durExtNonText, &fFullyJustified);
						if (lserr != lserrNone) return lserr;
						}
					}

				else if (durCompressTotal - durCompLastRight >= -durToDistribute)
					{
					lserr = ApplyCompress(plsgrchnk, lstflow, itxtobjAfterStartSpaces, iwchAfterStartSpaces,
						itxtobjLast, iwchLast, -durToDistribute);
					if (lserr != lserrNone) return lserr;
					}

				else if (durCompressTotal >= -durToDistribute)
					{
					if (durCompLastRight > 0)
						CompressLastCharRight(pilsobj, iwchLast, durCompLastRight);

					lserr = ApplyCompress(plsgrchnk, lstflow, itxtobjAfterStartSpaces, iwchAfterStartSpaces,
						itxtobjLast, iwchLast + 1, -durToDistribute - durCompLastRight);
					if (lserr != lserrNone) return lserr;
					}
				else
					{
					durHangingChar = pilsobj->pdur[iwchLast];
					/* Order of operations is important here because dur of the hanging
						punctuation gets chnaged in the next lines of code and
						durHangingChar is used in ApplyCompress/ApplyExpand calls below!!!
					*/
					if (durCompLastRight > 0)
						CompressLastCharRight(pilsobj, iwchLast, durCompLastRight);

					fHangingUsed = fTrue;

					if (durHangingChar + durToDistribute >= 0)
						{
						fScaledExp = (lskjust != lskjFullInterLetterAligned);
						lserr = ApplyExpand(plsgrchnk, lstflow, fScaledExp,
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast,	iwchLast,
							cNonText, durHangingChar + durToDistribute, &durExtNonText, &fFullyJustified);
						if (lserr != lserrNone) return lserr;
						}
					else
						{
						lserr = ApplyCompress(plsgrchnk, lstflow,
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast,
							 -durToDistribute - durHangingChar);
						if (lserr != lserrNone) return lserr;
						}
					}
				}
			else
				{
				if (durCompLastRight >= -durToDistribute)
					{
					Assert(!(((PTXTOBJ) plsgrchnk->plschnk[0].pdobj)->txtf & txtfGlyphBased));
					CompressLastCharRight(pilsobj, iwchLast, -durToDistribute);
					}
				else
					{
					if (durCompLastRight > 0)
						{
						Assert(!(((PTXTOBJ) plsgrchnk->plschnk[0].pdobj)->txtf & txtfGlyphBased));
						CompressLastCharRight(pilsobj, iwchLast, durCompLastRight);
						}
					lserr = ApplyCompress(plsgrchnk, lstflow, itxtobjAfterStartSpaces, iwchAfterStartSpaces,
						itxtobjLast, iwchLast + 1, -durToDistribute - durCompLastRight);
					if (lserr != lserrNone) return lserr;
					}
				}

			}
		else 
			{
/*			Assert (durToDistribute >= 0 || iwchLast == iwchAfterStartSpaces);---Unfortunately it might be not true
			for the second line of Warichu, because durTotal for it is scaled up value of dup of the first line
*/
			if (lskjust != lskjNone && durToDistribute > 0)
				{
				Assert(lskjust == lskjFullScaled || lskjust == lskjFullInterLetterAligned);
				iwchLastTemp = iwchLast;
				if (!fLastObjectIsText)
					iwchLastTemp++;
				lserr = ApplyExpand(plsgrchnk, lstflow, lskjust == lskjFullScaled,
						itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLastTemp,
						cNonText, durToDistribute, &durExtNonText, &fFullyJustified);
				if (lserr != lserrNone) return lserr;
				}
			}

		}
	else if (cNonText != 0 && lskjust != lskjNone && durToDistribute > 0)
		{
		durExtNonText = durToDistribute;
		}

	ScaleExtNonText(pilsobj, lstflow, durExtNonText, pdupExtNonText);
	
	ScaleCharSides(plsgrchnk, lstflow, &fLeftSideAffected, &fGlyphDetected);

	if (fGlyphDetected)
		{
		ScaleGlyphSides(plsgrchnk, lstflow);
		UpdateGlyphOffsets(plsgrchnk);
		SetBeforeJustCopy(plsgrchnk);
		}

	ApplyWysi(plsgrchnk, lstflow);

	if (fHangingUsed)
		GetDupLastChar(plsgrchnk, iwchLast, &dupHangingChar);
		

	lserr = FinalAdjustmentOnPres(plsgrchnk, itxtobjLast, iwchLast,
									 dupAvailable + dupHangingChar - *pdupExtNonText,
									 fFullyJustified, fForcedBreak, fSuppressTrailingSpaces,
									 pdupText, pdupTail);
	if (lserr != lserrNone) return lserr;

	/* If pdupPen is already used, don't forget to copy pdup there---ScaleSides could change it */
	if (fLeftSideAffected || plnobj->pdup != plnobj->pdupPen)
		{
		lserr = FillDupPen(plsgrchnk, lstflow, itxtobjLast, iwchLast);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;
}

/* H A N D L E  F U L L  G L Y P H S  E X A C T  S Y N C */
/*----------------------------------------------------------------------------
    %%Function: HandleFullGlyphsExactSync
    %%Contact: sergeyge

	Implements glyph-based justification
	on the reference device	and WYSIWYG algorithm
	for the exact positioning

	Startegy:
	 Apply glyph-based justification if needed
	 Scale down changes applied to characters during NTI and justification
	 If glyphs were detected on the line,
      scale down changes apllied to glyphs during NTI
	  and adjust offsets
	 Apply WYSIWYG algorithm
	 If some characters were changed on the left side
	  prepare additional width array for the display time
----------------------------------------------------------------------------*/
static LSERR HandleFullGlyphsExactSync(const LSGRCHNK* plsgrchnk,
			 long durToDistribute, long dupAvailable, LSTFLOW lstflow,
			 long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
			 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	BOOL fFullyJustified = fFalse;
	BOOL fLeftSideAffected = fFalse;
	BOOL fGlyphDetected = fFalse;

	plnobj = ((PTXTOBJ) plsgrchnk->plschnk[0].pdobj)->plnobj;
	pilsobj = plnobj->pilsobj;

	ScaleGlyphSides(plsgrchnk, lstflow);
	UpdateGlyphOffsets(plsgrchnk);
	SetBeforeJustCopy(plsgrchnk);

	if (itxtobjLast > itxtobjAfterStartSpaces || (itxtobjLast == itxtobjAfterStartSpaces && iwchLast >= iwchAfterStartSpaces))
		{
		lserr = ApplyGlyphExpand(plsgrchnk, lstflow, lsdevReference,
						itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast,
						durToDistribute, pilsobj->pdur, pilsobj->pdurGind, pilsobj->pdurRight, pilsobj->pduGright,
						&fFullyJustified);
		if (lserr != lserrNone) return lserr;
		}

	ScaleCharSides(plsgrchnk, lstflow, &fLeftSideAffected, &fGlyphDetected);

	if (fGlyphDetected)
		{
		ScaleGlyphSides(plsgrchnk, lstflow);
		UpdateGlyphOffsets(plsgrchnk);
		}

	ApplyWysi(plsgrchnk, lstflow);

	lserr = FinalAdjustmentOnPres(plsgrchnk, itxtobjLast, iwchLast, dupAvailable,
									 fFullyJustified, fForcedBreak, fSuppressTrailingSpaces,
									 pdupText, pdupTail);
	if (lserr != lserrNone) return lserr;

	/* If pdupPen is already used, don't forget to copy pdup there---ScaleSides could change it */
	if (fLeftSideAffected || plnobj->pdup != plnobj->pdupPen)
		{
		lserr = FillDupPen(plsgrchnk, lstflow, itxtobjLast, iwchLast);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;
}

/* H A N D L E  F U L L  G L Y P H S  P R E S */
/*----------------------------------------------------------------------------
    %%Function: HandleFullGlyphsPres
    %%Contact: sergeyge

	Implements glyph-based justification
	directly on the presentation device

	Startegy:
	 Scale down changes applied to characters during NTI
	 If glyphs were detected on the line,
      scale down changes apllied to glyphs during NTI
	  and adjust offsets
	 Apply glyph-based justification if needed
	 If glyphs were detected on the line,
	  adjust offsets
	 If some characters were changed on the left side
	  prepare additional width array for the display time
----------------------------------------------------------------------------*/
static LSERR HandleFullGlyphsPres(const LSGRCHNK* plsgrchnk,
			 long dupAvailable, LSTFLOW lstflow,
			 long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
			 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	long* rgdup;
	long itxtobj;
	long iwchLastInDobj;
	long iFirst;
	long iLim;
	long i;
	long dupTotal;
	long dupToDistribute;
	BOOL fFullyJustified = fFalse;
	BOOL fLeftSideAffected = fFalse;
	BOOL fGlyphDetected = fFalse;

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	plnobj = ptxtobjLast->plnobj;
	pilsobj = plnobj->pilsobj;

	ScaleCharSides(plsgrchnk, lstflow, &fLeftSideAffected, &fGlyphDetected);
	if (fGlyphDetected)
		{
		ScaleGlyphSides(plsgrchnk, lstflow);
		UpdateGlyphOffsets(plsgrchnk);
		SetBeforeJustCopy(plsgrchnk);
		}

	if (itxtobjLast > itxtobjAfterStartSpaces || (itxtobjLast == itxtobjAfterStartSpaces && iwchLast >= iwchAfterStartSpaces))
		{
		rgdup = plnobj->pdup;

		dupTotal = 0;
		for (itxtobj=0; itxtobj <= itxtobjLast; itxtobj++)
			{
			ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;

			if (ptxtobj->txtf & txtfGlyphBased)
				{
				iFirst = ptxtobj->igindFirst;
				iwchLastInDobj = iwchLast;
				if (itxtobj < itxtobjLast)
					iwchLastInDobj = ptxtobj->iwchLim - 1;
				iLim = IgindLastFromIwch(ptxtobj, iwchLastInDobj) + 1;
				rgdup = plnobj->pdupGind;
				}
			else
				{
				iFirst = ptxtobj->iwchFirst;
				iLim = iwchLast + 1;
				if (itxtobj < itxtobjLast)
					iLim = ptxtobj->iwchLim;
				rgdup = plnobj->pdup;
				}
			

			for (i =iFirst; i < iLim; i++)
				{
				dupTotal += rgdup[i];
				}
			}

		dupToDistribute = dupAvailable - dupTotal;

		lserr = ApplyGlyphExpand(plsgrchnk, lstflow, lsdevPres,
				itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast,
				dupToDistribute, plnobj->pdup, plnobj->pdupGind, pilsobj->pdurRight, pilsobj->pduGright,
				&fFullyJustified);
		if (lserr != lserrNone) return lserr;

		if (fGlyphDetected)
			{
			UpdateGlyphOffsets(plsgrchnk);
			}

		}

	lserr = FinalAdjustmentOnPres(plsgrchnk, itxtobjLast, iwchLast, dupAvailable,
									 fFalse, fForcedBreak, fSuppressTrailingSpaces,
									 pdupText, pdupTail);

	if (lserr != lserrNone) return lserr;

	/* If pdupPen is already used, don't forget to copy pdup there---ScaleSides could change it */
	if (fLeftSideAffected || plnobj->pdup != plnobj->pdupPen)
		{
		lserr = FillDupPen(plsgrchnk, lstflow, itxtobjLast, iwchLast);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lstxtini.c ===
#include "lsmem.h"
#include "lstxtini.h"
#include "zqfromza.h"
#include "lscbk.h"
#include "lsdocinf.h"
#include "tlpr.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"
#include "txtconst.h"

#define min(a,b)     ((a) > (b) ? (b) : (a))
#define TxtVisiMask  (fTxtVisiCondHyphens | fTxtVisiParaMarks | fTxtVisiSpaces | fTxtVisiTabs | fTxtVisiBreaks)

/* Internal Functions Prototypes */
static void DestroyLNObjTextCore(PLNOBJ plnobj);
static LSERR ErrorLNObjText(PLNOBJ* plnobj, LSERR lserr);
static LSERR TxtAddSpec(PILSOBJ pilsobj, WCHAR wchSymbol, CLABEL clab, WCHAR wchUndef);
static LSERR TxtSortSpec(WCHAR* rgwchSpec, CLABEL* rgbKind, DWORD cwchSpec);
static void CkeckModWidthClasses(PILSOBJ pilsobj, DWORD cModWidthClasses);

/* Export Functions Implementation*/

/*   D E S T R O Y  I L S O B J  T E X T   */
/*----------------------------------------------------------------------------
    %%Function: DestroyILSObjText
    %%Contact: sergeyge

	Deallocates list of arrays of txtobj's
	Deallocates arrays anchored to ILSOBJ

	Deallocates text ilsobj
----------------------------------------------------------------------------*/
LSERR WINAPI DestroyILSObjText(PILSOBJ pilsobj)
{
	if (pilsobj != NULL)
		{

		if ( pilsobj->pwchOrig != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pwchOrig);
			pilsobj->pwchOrig = NULL;
			}		
		if ( pilsobj->pdur != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pdur);
			pilsobj->pdur = NULL;
			}
		if ( pilsobj->pdurLeft != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pdurLeft);
			pilsobj->pdurLeft = NULL;
			}
		if ( pilsobj->pdurRight != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pdurRight);
			pilsobj->pdurRight = NULL;
			}
		if ( pilsobj->pduAdjust != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pduAdjust);
			pilsobj->pduAdjust = NULL;
			}
		if ( pilsobj->ptxtinf != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->ptxtinf);
			pilsobj->ptxtinf = NULL;
			}
		if ( pilsobj->pdurGind != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pdurGind);
			pilsobj->pdurGind = NULL;
			}
		if ( pilsobj->pginf != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pginf);
			pilsobj->pginf = NULL;
			}
		if ( pilsobj->pduGright != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pduGright);
			pilsobj->pduGright = NULL;
			}
		if ( pilsobj->plsexpinf != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plsexpinf);
			pilsobj->plsexpinf = NULL;
			}
		if ( pilsobj->pwSpaces != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pwSpaces);
			pilsobj->pwSpaces = NULL;
			}

		if ( pilsobj->plspairact != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plspairact);
			pilsobj->plspairact = NULL;
			}
		if ( pilsobj->pilspairact != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pilspairact);
			pilsobj->pilspairact = NULL;
			}

		if ( pilsobj->plspract != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plspract);
			pilsobj->plspract = NULL;
			}
		if ( pilsobj->pilspract != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pilspract);
			pilsobj->pilspract = NULL;
			}

		if ( pilsobj->plsexpan != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plsexpan);
			pilsobj->plsexpan = NULL;
			}
		if ( pilsobj->pilsexpan != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pilsexpan);
			pilsobj->pilsexpan = NULL;
			}

		if ( pilsobj->plsbrk != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plsbrk);
			pilsobj->plsbrk = NULL;
			}
		if ( pilsobj->pilsbrk != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pilsbrk);
			pilsobj->pilsbrk = NULL;
			}

		if ( pilsobj->plnobj != NULL )
			{
			DestroyLNObjTextCore(pilsobj->plnobj);
			pilsobj->plnobj = NULL;
			}

		if (pilsobj->pbreakinf != NULL);
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pbreakinf);
			pilsobj->pbreakinf = NULL;
			}

		(*pilsobj->plscbk->pfnDisposePtr) (pilsobj->pols, pilsobj);

		}

	return lserrNone;
}

/* C R E A T E  I L S O B J  T E X T */
/*----------------------------------------------------------------------------
    %%Function: CreateILSObjText
    %%Contact: sergeyge

	Allocates text ilsobj and sets pols, plsc and call-backs in it
	Allocates first array of the list of arrays of txtobj's
	Allocates wchOrig/dur arrays. Other arrays will be allocated when needed.
----------------------------------------------------------------------------*/
LSERR WINAPI CreateILSObjText(POLS pols, PCLSC plsc, PCLSCBK plscbk, DWORD idobj, PILSOBJ* ppilsobj)
{
	PILSOBJ ptxtils;

	Unreferenced(idobj);

	*ppilsobj = NULL;
	
	ptxtils = (*plscbk->pfnNewPtr)(pols, sizeof(struct ilsobj));

	if (ptxtils == NULL)
		return lserrOutOfMemory;

	*ppilsobj = ptxtils;

	memset(ptxtils, 0, sizeof(struct ilsobj) );

	ptxtils->pols = pols;
	ptxtils->plsc = (PLSC)plsc;

	ptxtils->plscbk = plscbk;

	return lserrNone;
		 
}

/*   D E S T R O Y  L N O B J  T E X T   */
/*----------------------------------------------------------------------------
    %%Function: DestroyLNObjText
    %%Contact: sergeyge

	Deallocates arrays anchored to LNOBJ

	Deallocates text lnobj
----------------------------------------------------------------------------*/
LSERR WINAPI DestroyLNObjText(PLNOBJ plnobj)
{
	if (plnobj->pilsobj->plnobj == NULL)
		{
		plnobj->pilsobj->plnobj = plnobj;
		}

	else if (plnobj != NULL)
		{
		DestroyLNObjTextCore(plnobj);
		}

	return lserrNone;
}

/* C R E A T E  L N O B J  T E X T */
/*----------------------------------------------------------------------------
    %%Function: CreateLNObjText
    %%Contact: sergeyge

	Allocates text lnobj
	Allocates wch/dup arrays. dupPenAllocArray will be allocated when needed.
----------------------------------------------------------------------------*/
LSERR WINAPI CreateLNObjText(PCILSOBJ pilsobj, PLNOBJ* pplnobj)
{
	PLNOBJ ptxtln;

	if (pilsobj->plnobj != NULL)
		{
		*pplnobj = pilsobj->plnobj;
		if (pilsobj->plnobj->wchMax != pilsobj->wchMax)
			{
			Assert(pilsobj->plnobj->pwch != NULL);
			Assert(pilsobj->plnobj->pdup != NULL);
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pwch);
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pdup);
			if (pilsobj->plnobj->pgmap != NULL)
				{
				/* it will be allocated in CheckReallocGlyphs in lstxtnti.c */
				(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pgmap);
				pilsobj->plnobj->pgmap = NULL;
				}

			if (pilsobj->plnobj->pdupPenAlloc != NULL)
				{
				(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pdupPenAlloc);
				}

			pilsobj->plnobj->pdupPenAlloc = NULL;

			pilsobj->plnobj->wchMax = pilsobj->wchMax;
			pilsobj->plnobj->pwch = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(WCHAR) * pilsobj->wchMax);
			pilsobj->plnobj->pdup = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->wchMax);
			if (pilsobj->plnobj->pwch == NULL || pilsobj->plnobj->pdup == NULL)
				{
				pilsobj->plnobj = NULL;
				return ErrorLNObjText(pplnobj, lserrOutOfMemory);
				}
			}

		if (pilsobj->plnobj->gindMax != pilsobj->gindMax)
			{
			if (pilsobj->plnobj->pgind != NULL )
				(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pgind);
			if (pilsobj->plnobj->pdupGind != NULL )
				(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pdupGind);
			if (pilsobj->plnobj->pgoffs != NULL )
				(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pgoffs);
			if (pilsobj->plnobj->pexpt != NULL )
				(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pexpt);
			if (pilsobj->plnobj->pdupBeforeJust != NULL )
				(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pdupBeforeJust);
			if (pilsobj->plnobj->pgprop != NULL )
				(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pgprop);

			pilsobj->plnobj->gindMax = pilsobj->gindMax;
			pilsobj->plnobj->pgind = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(GINDEX) * pilsobj->gindMax);
			pilsobj->plnobj->pdupGind = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->gindMax);
			pilsobj->plnobj->pgoffs = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(GOFFSET) * pilsobj->gindMax);
			pilsobj->plnobj->pexpt = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(EXPTYPE) * pilsobj->gindMax);
			pilsobj->plnobj->pdupBeforeJust = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->gindMax);
			pilsobj->plnobj->pgprop = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(GPROP) * pilsobj->gindMax);

			if (pilsobj->plnobj->pgind == NULL || pilsobj->plnobj->pdupGind == NULL || 
				pilsobj->plnobj->pgoffs == NULL || pilsobj->plnobj->pexpt == NULL ||
				pilsobj->plnobj->pdupBeforeJust == NULL ||
				pilsobj->plnobj->pgprop == NULL)
				{
				pilsobj->plnobj = NULL;
				return ErrorLNObjText(pplnobj, lserrOutOfMemory);
				}

			memset(pilsobj->plnobj->pexpt, 0, sizeof(EXPTYPE) * pilsobj->gindMax);

			}

		pilsobj->plnobj = NULL;

		}
	else
		{
		*pplnobj = NULL;
	
		ptxtln = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(struct lnobj));

		if (ptxtln == NULL)
			{
			return lserrOutOfMemory;
			}

		*pplnobj = ptxtln;

		memset(ptxtln, 0, sizeof(struct lnobj) );

		ptxtln->pilsobj = pilsobj;

		ptxtln->ptxtobj = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(TXTOBJ) * txtobjMaxM + sizeof(TXTOBJ**));
		if ( ptxtln->ptxtobj == NULL)
			{
			return ErrorLNObjText(pplnobj, lserrOutOfMemory);
			}

		ptxtln->ptxtobjFirst = ptxtln->ptxtobj;
		*(TXTOBJ**)( ptxtln->ptxtobj + txtobjMaxM) = NULL;

		ptxtln->wchMax = pilsobj->wchMax;
		ptxtln->pwch = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(WCHAR) * pilsobj->wchMax);
		ptxtln->pdup = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->wchMax);

		if (ptxtln->pwch == NULL || ptxtln->pdup == NULL)
			{
			return ErrorLNObjText(pplnobj, lserrOutOfMemory);
			}

		if (pilsobj->gindMax > 0)
			{
			ptxtln->pgind = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(GINDEX) * pilsobj->gindMax);
			ptxtln->pdupGind = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->gindMax);
			ptxtln->pgoffs = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(GOFFSET) * pilsobj->gindMax);
			ptxtln->pexpt = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(EXPTYPE) * pilsobj->gindMax);
			ptxtln->pdupBeforeJust = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->gindMax);
			ptxtln->pgprop = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(GPROP) * pilsobj->gindMax);

			if (ptxtln->pgind == NULL || ptxtln->pdupGind == NULL ||
				ptxtln->pgoffs == NULL || ptxtln->pexpt == NULL ||
				ptxtln->pdupBeforeJust == NULL || ptxtln->pgprop == NULL)
				{
				return ErrorLNObjText(pplnobj, lserrOutOfMemory);
				}

			ptxtln->gindMax = pilsobj->gindMax;
			}
		}

	if (pilsobj->fNotSimpleText)
		{
		if (pilsobj->pdurRight != NULL)
			{
			memset(pilsobj->pdurRight, 0, sizeof(long) * pilsobj->wchMac );
			Assert (pilsobj->pdurLeft != NULL);
			memset(pilsobj->pdurLeft, 0, sizeof(long) * pilsobj->wchMac );
			Assert (pilsobj->ptxtinf != NULL);
			memset(pilsobj->ptxtinf, 0, sizeof(TXTINF) * pilsobj->wchMac );
			}
		if ((*pplnobj)->pdupPen == (*pplnobj)->pdupPenAlloc && (*pplnobj)->pdupPen != NULL)
			memset((*pplnobj)->pdupPenAlloc, 0,  sizeof(long) * pilsobj->wchMax);

		if (pilsobj->gindMac != 0)
			{
			Assert (pilsobj->pduGright != NULL);
			memset(pilsobj->pduGright, 0, sizeof(long) * pilsobj->gindMac );
			Assert (pilsobj->plsexpinf != NULL);
			memset(pilsobj->plsexpinf, 0, sizeof(LSEXPINFO) * pilsobj->gindMac );
			Assert ((*pplnobj)->pexpt != NULL);
			memset((*pplnobj)->pexpt, 0, sizeof(EXPTYPE) * pilsobj->gindMac );
			}
		}

	pilsobj->txtobjMac = 0;
	pilsobj->wchMac = 0;
	pilsobj->gindMac = 0;
	pilsobj->wSpacesMac = 0;

	pilsobj->fNotSimpleText = fFalse;
	pilsobj->fDifficultForAdjust = fFalse;

	pilsobj->fTruncatedBefore = fFalse;

	pilsobj->iwchCompressFetchedFirst = 0;
	pilsobj->itxtobjCompressFetchedLim = 0;
	pilsobj->iwchCompressFetchedLim = 0;

	pilsobj->dcpFetchedWidth = 0;

	pilsobj->breakinfMac = 3;
	pilsobj->pbreakinf[0].pdobj = NULL;
	pilsobj->pbreakinf[1].pdobj = NULL;
	pilsobj->pbreakinf[2].pdobj = NULL;

	(*pplnobj)->ptxtobj = (*pplnobj)->ptxtobjFirst;

	(*pplnobj)->pdupPen = (*pplnobj)->pdup;

	(*pplnobj)->pdobjHyphen = NULL;
								
	(*pplnobj)->dwchYsr = 0;

	return lserrNone;

}

/* S E T  D O C  T E X T */
/*----------------------------------------------------------------------------
    %%Function: SetDocText
    %%Contact: sergeyge

	Initialization at the doc level
	Called when resolutions are changed
----------------------------------------------------------------------------*/
LSERR WINAPI SetDocText(PILSOBJ pilsobj, PCLSDOCINF plsdocinf)
{
	pilsobj->fDisplay = plsdocinf->fDisplay;
	pilsobj->fPresEqualRef = plsdocinf->fPresEqualRef;
	pilsobj->lsdevres = plsdocinf->lsdevres;

	/* Be careful---In Visi case fPresEqualRef can be True, but sizes of characters---different
	*/
	if (pilsobj->fDisplay && !pilsobj->fPresEqualRef)
		{
		pilsobj->MagicConstantX = LsLwMultDivR(pilsobj->lsdevres.dxpInch, 1 << 21, pilsobj->lsdevres.dxrInch);
		pilsobj->durRightMaxX = min(1 << 21, (0x7FFFFFFF - (1 << 20)) / pilsobj->MagicConstantX);

		pilsobj->MagicConstantY = pilsobj->MagicConstantX;
		pilsobj->durRightMaxY = pilsobj->durRightMaxY;

		if (pilsobj->lsdevres.dxrInch != pilsobj->lsdevres.dyrInch ||
							 pilsobj->lsdevres.dxpInch != pilsobj->lsdevres.dypInch)
			pilsobj->MagicConstantY = LsLwMultDivR(pilsobj->lsdevres.dypInch, 1 << 21, pilsobj->lsdevres.dyrInch);
			pilsobj->durRightMaxY = min(1 << 21, (0x7FFFFFFF - (1 << 20)) / pilsobj->MagicConstantY);
		}


	return lserrNone;
}

/* S E T  T E X T   B R E A K I N G */
/*----------------------------------------------------------------------------
    %%Function: SetTextBreaking
    %%Contact: sergeyge

	Initialization on the doc level
	Called when the breaking table should be installed or changed
----------------------------------------------------------------------------*/
LSERR SetTextBreaking(PILSOBJ pilsobj, DWORD clsbrk, const LSBRK* rglsbrk,
														 DWORD cBreakingClasses, const BYTE* rgibrk)
{
	DWORD i;

	if (pilsobj->cBreakingClasses < cBreakingClasses)
		{
		if (pilsobj->cBreakingClasses > 0)
			{
			Assert(pilsobj->pilsbrk != NULL);
			
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pilsbrk);
			pilsobj->pilsbrk = NULL;
			pilsobj->cBreakingClasses = 0;
			}

		pilsobj->pilsbrk = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols,
										sizeof(BYTE) * cBreakingClasses * cBreakingClasses);
		if ( pilsobj->pilsbrk == NULL)
			{
			return lserrOutOfMemory;
			}

		pilsobj->cBreakingClasses = cBreakingClasses;
			
		}

	if (pilsobj->clsbrk < clsbrk)
		{
		if (pilsobj->clsbrk > 0)
			{
			Assert(pilsobj->plsbrk != NULL);
			
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plsbrk);
			pilsobj->plsbrk = NULL;
			pilsobj->clsbrk = 0;
			}

		pilsobj->plsbrk = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(LSBRK) * clsbrk);
		if ( pilsobj->plsbrk == NULL)
			{
			return lserrOutOfMemory;
			}

		pilsobj->clsbrk = clsbrk;

		}

	memcpy(pilsobj->plsbrk, rglsbrk, sizeof(LSBRK) * clsbrk);
	memcpy(pilsobj->pilsbrk, rgibrk, sizeof(BYTE) * cBreakingClasses * cBreakingClasses);

	for (i = 0; i < cBreakingClasses * cBreakingClasses; i++)
		{
		if (rgibrk[i] >= clsbrk)
			{
			Assert(fFalse);
			return lserrInvalidParameter;  /* REVIEW sergeyge: another error code? */
			}
		}

	return lserrNone;
}

/* S E T  T E X T  M O D  W I D T H  P A I R S */
/*----------------------------------------------------------------------------
    %%Function: SetTextModWidthPairs
    %%Contact: sergeyge

	Initialization on the doc level
	Called when the ModWidthPairs table should be installed or changed
----------------------------------------------------------------------------*/
LSERR SetTextModWidthPairs(PILSOBJ pilsobj,	DWORD clspairact, const LSPAIRACT* rglspairact,
									DWORD cModWidthClasses, const BYTE* rgipairact)
{
	DWORD i;
	
	CkeckModWidthClasses(pilsobj, cModWidthClasses);

	if (pilsobj->pilspairact == NULL)
		{
		pilsobj->pilspairact = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols,
									sizeof(BYTE) * cModWidthClasses * cModWidthClasses);
		if ( pilsobj->pilspairact == NULL)
			{
			return lserrOutOfMemory;
			}
		}

	if (pilsobj->clspairact < clspairact)
		{
		if (pilsobj->clspairact > 0)
			{
			Assert(pilsobj->plspairact != NULL);
			
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plspairact);
			pilsobj->plspairact = NULL;
			pilsobj->clspairact = 0;
			}

		pilsobj->plspairact = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(LSPAIRACT) * clspairact);
		if ( pilsobj->plspairact == NULL)
			{
			return lserrOutOfMemory;
			}

		pilsobj->clspairact = clspairact;
		}

	memcpy(pilsobj->plspairact, rglspairact, sizeof(LSPAIRACT) * clspairact);
	memcpy(pilsobj->pilspairact, rgipairact, sizeof(BYTE) * cModWidthClasses * cModWidthClasses);

	for (i = 0; i < cModWidthClasses * cModWidthClasses; i++)
		{
		if (rgipairact[i] >= clspairact)
			{
			Assert(fFalse);
			return lserrInvalidParameter;  /* REVIEW sergeyge: another error code? */
			}
		}

	return lserrNone;

}

/* S E T  T E X T  C O M P R E S S I O N */
/*----------------------------------------------------------------------------
    %%Function: SetTextCompression
    %%Contact: sergeyge

	Initialization on the doc level
	Called when the Compression table should be installed or changed
----------------------------------------------------------------------------*/
LSERR SetTextCompression(PILSOBJ pilsobj, DWORD cCompPrior, DWORD clspract, const LSPRACT* rglspract,
									DWORD cModWidthClasses, const BYTE* rgipract)
{
	DWORD i;
	
	CkeckModWidthClasses(pilsobj, cModWidthClasses);

	if (pilsobj->pilspract == NULL)
		{
		pilsobj->pilspract = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols,
									sizeof(BYTE) * cModWidthClasses);
		if ( pilsobj->pilspract == NULL)
			{
			return lserrOutOfMemory;
			}
		}

	if (pilsobj->clspract < clspract)
		{
		if (pilsobj->clspract > 0)
			{
			Assert(pilsobj->plspract != NULL);
			
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plspract);
			pilsobj->plspract = NULL;
			pilsobj->clspract = 0;
			}

		pilsobj->plspract = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(LSPRACT) * clspract);
		if ( pilsobj->plspract == NULL)
			{
			return lserrOutOfMemory;
			}

		pilsobj->clspract = clspract;
		}

	pilsobj->cCompPrior = cCompPrior;

	memcpy(pilsobj->plspract, rglspract, sizeof(LSPRACT) * clspract);
	memcpy(pilsobj->pilspract, rgipract, sizeof(BYTE) * cModWidthClasses);

	for (i = 0; i < cModWidthClasses; i++)
		{
		if (rgipract[i] >= clspract)
			{
			Assert(fFalse);
			return lserrInvalidParameter;  /* REVIEW sergeyge: another error code? */
			}
		}

	return lserrNone;

}

/* S E T  T E X T  E X P A N S I O N */
/*----------------------------------------------------------------------------
    %%Function: SetTextExpansion
    %%Contact: sergeyge

	Initialization on the doc level
	Called when the Expansion table should be installed or changed
----------------------------------------------------------------------------*/
LSERR SetTextExpansion(PILSOBJ pilsobj,	DWORD clsexpan, const LSEXPAN* rglsexpan,
									DWORD cModWidthClasses, const BYTE* rgiexpan)
{
	DWORD i;
	
	CkeckModWidthClasses(pilsobj, cModWidthClasses);

	if (pilsobj->pilsexpan == NULL)
		{
		pilsobj->pilsexpan = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols,
									sizeof(BYTE) * cModWidthClasses * cModWidthClasses);
		if ( pilsobj->pilsexpan == NULL)
			{
			return lserrOutOfMemory;
			}
		}

	if (pilsobj->clsexpan < clsexpan)
		{
		if (pilsobj->clsexpan > 0)
			{
			Assert(pilsobj->plsexpan != NULL);
			
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plsexpan);
			pilsobj->plsexpan = NULL;
			pilsobj->clsexpan = 0;
			}

		pilsobj->plsexpan = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(LSEXPAN) * clsexpan);
		if ( pilsobj->plsexpan == NULL)
			{
			return lserrOutOfMemory;
			}

		pilsobj->clsexpan = clsexpan;
		}

	memcpy(pilsobj->plsexpan, rglsexpan, sizeof(LSEXPAN) * clsexpan);
	memcpy(pilsobj->pilsexpan, rgiexpan, sizeof(BYTE) * cModWidthClasses * cModWidthClasses);

	for (i = 0; i < cModWidthClasses * cModWidthClasses; i++)
		{
		if (rgiexpan[i] >= clsexpan)
			{
			Assert(fFalse);
			return lserrInvalidParameter;  /* REVIEW sergeyge: another error code? */
			}
		}

	return lserrNone;

}

/* S E T  T E X T  L I N E  P A R A M S */
/*----------------------------------------------------------------------------
    %%Function: SetTextLineParams
    %%Contact: sergeyge

	Initialization at the beginning of the line
	with the text specific parameters.
----------------------------------------------------------------------------*/
LSERR SetTextLineParams(PLNOBJ plnobj, const TLPR* ptlpr)
{
	PILSOBJ pilsobj;

	pilsobj = plnobj->pilsobj;

	pilsobj->grpf = ptlpr->grpfText;
	pilsobj->fSnapGrid = ptlpr->fSnapGrid;
	pilsobj->duaHyphenationZone = ptlpr->duaHyphenationZone;

	pilsobj->lskeop = ptlpr->lskeop;

	plnobj->fDrawInCharCodes = pilsobj->grpf & fTxtDrawInCharCodes;

	if ( (pilsobj->grpf & fTxtApplyBreakingRules) && pilsobj->pilsbrk == NULL)
		return lserrBreakingTableNotSet;


	return lserrNone;
}

/* M O D I F Y  T E X T  L I N E  E N D I N G */
/*----------------------------------------------------------------------------
    %%Function: ModifyTextLineEnding
    %%Contact: sergeyge

	Modifies line ending information when text vanishes across paragraph boundary
----------------------------------------------------------------------------*/
LSERR ModifyTextLineEnding(PLNOBJ plnobj, LSKEOP lskeop)
{

	plnobj->pilsobj->lskeop = lskeop;

	return lserrNone;
}



/*  S E T  T E X T  C O N F I G */
/*----------------------------------------------------------------------------
    %%Function: SetTextConfig
    %%Contact: sergeyge

	Sets special characters in the ilsobj
----------------------------------------------------------------------------*/
LSERR SetTextConfig(PILSOBJ pilsobj, const LSTXTCFG* plstxtcfg)
{
	LSERR lserr;
	WCHAR wchUndef;

	wchUndef = plstxtcfg->wchUndef; 

	pilsobj->wchVisiNull = plstxtcfg->wchVisiNull;
	pilsobj->wchVisiEndPara = plstxtcfg->wchVisiEndPara;
	pilsobj->wchVisiAltEndPara = plstxtcfg->wchVisiAltEndPara;
	pilsobj->wchVisiEndLineInPara = plstxtcfg->wchVisiEndLineInPara;
	pilsobj->wchVisiSpace = plstxtcfg->wchVisiSpace;
	pilsobj->wchVisiNonBreakSpace = plstxtcfg->wchVisiNonBreakSpace;
	pilsobj->wchVisiNonBreakHyphen = plstxtcfg->wchVisiNonBreakHyphen;
	pilsobj->wchVisiNonReqHyphen = plstxtcfg->wchVisiNonReqHyphen;
	pilsobj->wchVisiTab = plstxtcfg->wchVisiTab;
	pilsobj->wchVisiEmSpace = plstxtcfg->wchVisiEmSpace;
	pilsobj->wchVisiEnSpace = plstxtcfg->wchVisiEnSpace;
	pilsobj->wchVisiNarrowSpace = plstxtcfg->wchVisiNarrowSpace;
	pilsobj->wchVisiOptBreak = plstxtcfg->wchVisiOptBreak;
	pilsobj->wchVisiNoBreak = plstxtcfg->wchVisiNoBreak;
	pilsobj->wchVisiFESpace = plstxtcfg->wchVisiFESpace;

	Assert(0 == clabRegular);
	Assert(pilsobj->wchVisiEndPara != wchUndef);
	Assert(pilsobj->wchVisiAltEndPara != wchUndef);
	Assert(pilsobj->wchVisiEndLineInPara != wchUndef);

	pilsobj->wchSpace = plstxtcfg->wchSpace;
	pilsobj->wchHyphen = plstxtcfg->wchHyphen;
	pilsobj->wchReplace = plstxtcfg->wchReplace;
	pilsobj->wchNonBreakSpace = plstxtcfg->wchNonBreakSpace;

	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchNull, clabNull, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchSpace, clabSpace, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchHyphen, clabHardHyphen, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchTab, clabTab, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchEndPara1, clabEOP1, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchEndPara2, clabEOP2, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchAltEndPara, clabAltEOP, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchEndLineInPara, clabEndLineInPara, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchColumnBreak, clabColumnBreak, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchSectionBreak, clabSectionBreak, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchPageBreak, clabPageBreak, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchNonBreakSpace, clabNonBreakSpace, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchNonBreakHyphen, clabNonBreakHyphen, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchNonReqHyphen, clabNonReqHyphen, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchEmDash, clabHardHyphen, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchEnDash, clabHardHyphen, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchEnSpace, clabEnSpace, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchEmSpace, clabEmSpace, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchNarrowSpace, clabNarrowSpace, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchOptBreak, clabOptBreak, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchNoBreak, clabNonBreak, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchFESpace, clabFESpace, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchJoiner, clabJoiner, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchNonJoiner, clabNonJoiner, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchToReplace, clabToReplace, wchUndef);
	if (lserr != lserrNone) return lserr;

	lserr = TxtSortSpec( pilsobj->rgwchSpec, pilsobj->rgbKind, pilsobj->cwchSpec);
	if (lserr != lserrNone) return lserr;

	Assert(pilsobj->pwchOrig == NULL && pilsobj->pdur == NULL && pilsobj->pwSpaces == NULL);

	pilsobj->wchMax = plstxtcfg->cEstimatedCharsPerLine;
	pilsobj->pwchOrig = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(WCHAR) * pilsobj->wchMax );
	pilsobj->pdur = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->wchMax );
	pilsobj->pwSpaces = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * wSpacesMaxM);
	pilsobj->pbreakinf = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(BREAKINFO) * 3);
			/* One for Prev/Next/Force Break for main subline */

	if (pilsobj->pwchOrig == NULL || pilsobj->pdur == NULL || pilsobj->pwSpaces == NULL ||
																	pilsobj->pbreakinf == NULL)
		{
		return lserrOutOfMemory;
		}

	pilsobj->wSpacesMax = wSpacesMaxM;
	pilsobj->breakinfMax = 3;
	pilsobj->breakinfMac = 3;

	/* be careful---CreateLNObjText makes pilsobj->plnobj = NULL,
		if pilsobj->plnobj is not NULL
	 */
	Assert(pilsobj->plnobj == NULL);

	lserr = CreateLNObjText(pilsobj, &pilsobj->plnobj);

	return lserr;
}

/* Internal Functions Implementation */


/*----------------------------------------------------------------------------
    %%Function: ErrorLNObjText
    %%Contact: sergeyge

----------------------------------------------------------------------------*/
static LSERR ErrorLNObjText(PLNOBJ* pplnobj, LSERR lserr)
{
	DestroyLNObjTextCore(*pplnobj);
	*pplnobj = NULL;
	
	return lserr;
}

/*----------------------------------------------------------------------------
    %%Function: DestroyLNObjTextCore
    %%Contact: sergeyge

----------------------------------------------------------------------------*/
static void DestroyLNObjTextCore(PLNOBJ plnobj)
{
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjNext;

	pilsobj = plnobj->pilsobj;

	ptxtobj = plnobj->ptxtobjFirst;
	while ( ptxtobj != NULL )
		{
		ptxtobjNext = *(TXTOBJ**)(ptxtobj + txtobjMaxM);
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, ptxtobj);
		ptxtobj = ptxtobjNext;
		}		

	plnobj->ptxtobjFirst = NULL;

	if ( plnobj->pwch != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pwch);
		plnobj->pwch = NULL;
		}		
	if ( plnobj->pdup != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pdup);
		plnobj->pdup = NULL;
		}
	if ( plnobj->pdupPenAlloc != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pdupPenAlloc);
		plnobj->pdupPenAlloc = NULL;
		}

	if ( plnobj->pgind != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pgind);
		plnobj->pgind = NULL;
		}
	if ( plnobj->pdupGind != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pdupGind);
		plnobj->pdupGind = NULL;
		}
	if ( plnobj->pgoffs != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pgoffs);
		plnobj->pgoffs = NULL;
		}
	if ( plnobj->pexpt != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pexpt);
		plnobj->pexpt = NULL;
		}
	if ( plnobj->pdupBeforeJust != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pdupBeforeJust);
		plnobj->pdupBeforeJust = NULL;
		}
	if ( plnobj->pgprop != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pgprop);
		plnobj->pgprop = NULL;
		}
	if ( plnobj->pgmap != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pgmap);
		plnobj->pgmap = NULL;
		}

	(*pilsobj->plscbk->pfnDisposePtr) (pilsobj->pols, plnobj);

	return;
}

/* C H E C K  C  M O D  W I D T H  C L A S S E S */
/*----------------------------------------------------------------------------
    %%Function: CheckCModWidthClasses
    %%Contact: sergeyge

	Checks that new cModWidthClasses does not contradict old one.
	If it does, disposes all relevant arrays
----------------------------------------------------------------------------*/
static void CkeckModWidthClasses(PILSOBJ pilsobj, DWORD cModWidthClasses)
{
	if (pilsobj->cModWidthClasses != cModWidthClasses)
		{
		if (pilsobj->pilspairact != NULL)
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pilspairact);
			pilsobj->pilspairact = NULL;
			}

		if (pilsobj->pilspract != NULL)
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pilspract);
			pilsobj->pilspract = NULL;
			}

		if (pilsobj->pilsexpan != NULL)
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pilsexpan);
			pilsobj->pilsexpan = NULL;
			}

		pilsobj->cModWidthClasses = cModWidthClasses;
			
		}

}


/* T X T  A D D  S P E C */
/*----------------------------------------------------------------------------
    %%Function: TxtAddSpec
    %%Contact: sergeyge

	Sets special character in the ilsobj structure

	Strategy:

	if special character (wchSymbol) less than 256,
	set its type in the rgbSwitch[wchSymbol] (there cannot be more then 15 different types)

	if special character is greater than 256,
	set first bit of rgbSwitch[wchSymbol & 0x00FF]
	(it is independent of types of characters < 256 , since these types <= 15);
	also remember character and it's type in 
	rgwchSpec, rgbKind respectively.
----------------------------------------------------------------------------*/
static LSERR TxtAddSpec(PILSOBJ pilsobj, WCHAR wchSymbol, CLABEL clab, WCHAR wchUndef)
{
	CLABEL* rgbSwitch;

	rgbSwitch = pilsobj->rgbSwitch;

	if (wchSymbol == wchUndef)
		{
		return lserrNone;
		}
	if (wchSymbol < 256)
		{
		if ( (rgbSwitch[wchSymbol] & fSpecMask) == 0)
			{
			rgbSwitch[wchSymbol] |= clab;
			}
		else
			{
			Assert(fFalse);
			return lserrDuplicateSpecialCharacter;
			}
		}
	else
		{		
			rgbSwitch[wchSymbol & 0x00FF] |= clabSuspicious;
			pilsobj->rgwchSpec[pilsobj->cwchSpec] = wchSymbol;
			pilsobj->rgbKind[pilsobj->cwchSpec] = clab;
			pilsobj->cwchSpec++;
		}

	return lserrNone;
}

/* T X T  S O R T  S P E C */
/*----------------------------------------------------------------------------
    %%Function: TxtSortSpec
    %%Contact: sergeyge

	Sorts rgwchSpec array (and moves elements of rgbKind appropriately)
	to make search for special chars >= 256 faster.
----------------------------------------------------------------------------*/
static LSERR TxtSortSpec(WCHAR* rgwchSpec, CLABEL* rgbKind, DWORD cwchSpec)
{
	int i, j, iMin;
	WCHAR wchChange;
	CLABEL clabChange;
	BOOL fChanged;

	for (i=0; i < (int)cwchSpec-1; i++)
		{
		iMin = i;
		fChanged = fFalse;
		for (j = i+1; j < (int)cwchSpec; j++)
			{
			if (rgwchSpec[j] < rgwchSpec[iMin])
				{
				fChanged = fTrue;
				iMin = j;
				}
			}
		if (fChanged)
			{
			clabChange = rgbKind[i];
			wchChange = rgwchSpec[i];
			rgbKind[i] = rgbKind[iMin];
			rgwchSpec[i] = rgwchSpec[iMin];
			rgbKind[iMin] = clabChange;
			rgwchSpec[iMin] = wchChange;

			}
		}

	for (i=0; i < (int)cwchSpec-1; i++)
		{
		if (rgwchSpec[i] == rgwchSpec[i+1])
			{
			Assert(fFalse);
			return lserrDuplicateSpecialCharacter;
			}
		}

	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lstxtnti.c ===
#include "lsmem.h"

#include "lstxtnti.h"
#include "lstxtmod.h"
#include "lstxtmap.h"
#include "lstxtbrs.h"
#include "lsdnset.h"
#include "lsdntext.h"
#include "lschp.h"
#include "lstxtffi.h"
#include "tnti.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"
#include "lschnke.h"
#include "lsems.h"
#include "objdim.h"

#define max(a,b)     ((a) < (b) ? (b) : (a))


#define maskAllCharBasedArrays  (fTntiModWidthOnRun | fTntiModWidthSpace | fTntiModWidthPairs | \
			fTntiCompressOnRun | fTntiCompressSpace | fTntiCompressTable | \
			fTntiExpandOnRun | fTntiExpandSpace | fTntiExpandTable)

#define maskModWidth  (fTntiModWidthOnRun | fTntiModWidthSpace | fTntiModWidthPairs)

#define FModWidthSomeDobj(n)	(rglschnk[(n)].plschp->fModWidthOnRun || \
								rglschnk[(n)].plschp->fModWidthSpace || \
								rglschnk[(n)].plschp->fModWidthPairs)

static LSERR PrepareAllArraysGetModWidth(DWORD grpfTnti, DWORD cchnk, const LSCHNKE* rglschnk);
static LSERR ApplyKern(LSTFLOW lstflow, DWORD cchnk, const LSCHNKE* rglschnk);
static LSERR CheckApplyKernBetweenRuns(LSTFLOW lstflow, const LSCHNKE* rglschnk, long itxtobjPrev, long itxtobjCur);
static LSERR ApplyKernToRun(LSTFLOW lstflow, const LSCHNKE* rglschnk, long itxtobjCur);
static BOOL GetPrevImportantRun(const LSCHNKE* rglschnk, long itxtobj, long* pitxtobjPrev);
static BOOL GetNextImportantRun(DWORD cchnk, const LSCHNKE* rglschnk, long itxtobj, long* pitxtobjNext);
static LSERR GetModWidthClasses(DWORD cchnk, const LSCHNKE* rglschnk);
static LSERR ApplyModWidth(LSTFLOW lstflow, BOOL fFirstOnLine, BOOL fAutoNumberPresent, DWORD cchnk, const LSCHNKE* rglschnk);
static LSERR ApplySnapGrid(DWORD cchnk, const LSCHNKE* rglschnk);
static LSERR ApplyModWidthToRun(LSTFLOW lstflow, BOOL fFirstOnLine, BOOL fAutoNumberPresent, DWORD cchnk, const LSCHNKE* rglschnk, long itxtobjCur);
static LSERR CheckApplyModWidthBetweenRuns(LSTFLOW lstflow, const LSCHNKE* rglschnk, long itxtobjPrev, long itxtobjCur);
static LSERR CheckApplyPunctStartLine(PILSOBJ pilsobj, PLSRUN plsrun, LSEMS* plsems, long iwch,
																				long* pddurChange);
static LSERR CheckApplyModWidthSpace(PILSOBJ pilsobj, PLSRUN plsrunPrev, PLSRUN plsrunCur, PLSRUN plsrunNext,
						LSEMS* plsems, long iwchPrev, long iwchCur, long iwchNext, long* pddurChange);
static LSERR CheckApplyModWidthOnRun(PILSOBJ pilsobj, PTXTOBJ ptxtobjPrev, PLSRUN plsrunPrev, PLSRUN plsrunCur,
						LSEMS* plsems, long iwchFirst, long iwchSecond, long* pddurChange);
static LSERR ApplySnapChanges(PILSOBJ pilsobj, const LSCHNKE* rglschnk, long iwchFirstSnapped,
							 long itxtobjFirstSnapped, long iwchPrev, long itxtobjPrev, long durTotal);
static LSERR UndoAppliedModWidth(PILSOBJ pilsobj, const LSCHNKE* rglschnk,
										long itxtobj, long iwch, BYTE side, long* pdurUndo);
static LSERR CleanUpGrid(PILSOBJ pilsobj, PLSRUN* rgplsrun, LSCP* rgcp, BOOL* rgfSnapped, 
																				LSERR lserr);
static long CalcSnapped(long urPen, long urColumnMax, long cGrid, long durGridWhole, long durGridRem);

static LSERR ApplyGlyphs(LSTFLOW lstflow, DWORD cchnk, const LSCHNKE* rglschnk);
static LSERR ApplyGlyphsToRange(LSTFLOW lstflow, const LSCHNKE* rglschnk, long itxtobjFirst, long itxtobjLast);
static LSERR CheckReallocGlyphs(PLNOBJ plnobj, long cglyphs);
static LSERR FixGlyphSpaces(LSTFLOW lstflow, const LSCHNKE* rglschnk,
									long itxtobjFirst, long igindVeryFirst, long itxtobjLast);
static LSERR FixTxtobjs(const LSCHNKE* rglschnk, long itxtobjFirst, long igindFirst, long itxtobjLast);
static LSERR Realloc(PILSOBJ pols, void** pInOut, long cbytes);
static void	CopyGindices(PLNOBJ plnobj, GINDEX* pgindex, PGPROP pgprop, long cgind, long* pigindFirst);

#define CheckApplyModWidthTwoChars(pilsobj, plsemsFirst, plsemsSecond,\
						 iwchFirst, iwchSecond, pddurChangeFirst, pddurChangeSecond) \
{\
	LSPAIRACT lspairact;\
	MWCLS mwclsCur;\
	MWCLS mwclsNext;\
	BYTE side;\
\
	*(pddurChangeFirst) = 0;\
	*(pddurChangeSecond) = 0;\
	mwclsCur = (BYTE)(pilsobj)->ptxtinf[((iwchFirst))].mwcls;\
	mwclsNext = (BYTE)(pilsobj)->ptxtinf[(iwchSecond)].mwcls;\
	Assert(mwclsCur < (pilsobj)->cModWidthClasses);\
	Assert(mwclsNext < (pilsobj)->cModWidthClasses);\
	lspairact = \
		(pilsobj)->plspairact[(pilsobj)->pilspairact[(pilsobj)->cModWidthClasses * mwclsCur + mwclsNext]];\
\
	if (lspairact.lsactFirst.side != sideNone)\
		{\
		GetChanges(lspairact.lsactFirst, (plsemsFirst), (pilsobj)->pdur[((iwchFirst))], fFalse, &side, (pddurChangeFirst));\
		ApplyChanges((pilsobj), ((iwchFirst)), side, *(pddurChangeFirst));\
/*		(pilsobj)->ptxtinf[((iwchFirst))].fModWidthPair = fTrue;*/\
		}\
\
	if (lspairact.lsactSecond.side != sideNone)\
		{\
		GetChanges(lspairact.lsactSecond, (plsemsSecond), (pilsobj)->pdur[(iwchSecond)], fFalse, &side, (pddurChangeSecond));\
		ApplyChanges((pilsobj), (iwchSecond), side, *(pddurChangeSecond));\
/*		(pilsobj)->ptxtinf[(iwchSecond)].fModWidthPair = fTrue;*/\
		}\
\
}


LSERR NominalToIdealText(DWORD grpfTnti, LSTFLOW lstflow, BOOL fFirstOnLine, BOOL fAutoNumberPresent, DWORD cchnk, const LSCHNKE* rglschnk)
{
	LSERR lserr;
	PILSOBJ pilsobj;

	Assert(cchnk > 0);

	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;

	lserr = PrepareAllArraysGetModWidth(grpfTnti, cchnk, rglschnk);
	if (lserr != lserrNone) return lserr;

	if (grpfTnti & fTntiGlyphBased)
		{
		lserr = ApplyGlyphs(lstflow, cchnk, rglschnk);
		if (lserr != lserrNone) return lserr;
		}

	if (grpfTnti & fTntiKern)
		{
		lserr = ApplyKern(lstflow, cchnk, rglschnk);
		if (lserr != lserrNone) return lserr;
		}

	if ((grpfTnti & maskModWidth) || (pilsobj->grpf & fTxtPunctStartLine))
		{
		lserr = ApplyModWidth(lstflow, fFirstOnLine, fAutoNumberPresent, cchnk, rglschnk);
		if (lserr != lserrNone) return lserr;
		}

	if (pilsobj->fSnapGrid)
		{
#ifdef DEBUG
		{
		BOOL fInChildList;
		lserr = LsdnFInChildList(pilsobj->plsc, ((PTXTOBJ)rglschnk[0].pdobj)->plsdnUpNode, &fInChildList);
		Assert(lserr == lserrNone);
		Assert(!(grpfTnti & fTntiGlyphBased) || fInChildList);
		}
#endif
		lserr = ApplySnapGrid(cchnk, rglschnk);
		if (lserr != lserrNone) return lserr;
		}

	return lserr;
}

/* G E T  F I R S T  C H A R  I N  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: GetFirstCharInChunk
    %%Contact: sergeyge

	Prepares information about first visible char in chunk
----------------------------------------------------------------------------*/
LSERR GetFirstCharInChunk(DWORD cchnk, const LSCHNKE* rglschnk, BOOL* pfSuccessful,
					 WCHAR* pwch, PLSRUN* pplsrun, PHEIGHTS pheights, MWCLS* pmwcls)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long itxtobj;
	long iwch;
	PTXTOBJ ptxtobj;
	OBJDIM objdim;

	Assert(cchnk > 0);
	
	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;
	*pfSuccessful = fFalse;
	if (GetNextImportantRun(cchnk, rglschnk, 0, &itxtobj))
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfModWidthClassed)
			{
			Assert(!(ptxtobj->txtf & txtfGlyphBased));
			*pfSuccessful = fTrue;
			iwch = ptxtobj->iwchFirst;
			*pwch = pilsobj->pwchOrig[iwch];
			*pplsrun = rglschnk[itxtobj].plsrun;
			*pmwcls = (MWCLS)pilsobj->ptxtinf[iwch].mwcls;
			lserr = LsdnGetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, &objdim);
			if (lserr != lserrNone) return lserr;
			*pheights = objdim.heightsRef;
			}
		}

	return lserrNone;

}

/* G E T  L A S T  C H A R  I N  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: GetLastCharInChunk
    %%Contact: sergeyge

	Prepares information about first visible char in chunk
----------------------------------------------------------------------------*/
LSERR GetLastCharInChunk(DWORD cchnk, const LSCHNKE* rglschnk, BOOL* pfSuccessful,
					 WCHAR* pwch, PLSRUN* pplsrun, PHEIGHTS pheights, MWCLS* pmwcls)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long itxtobj;
	long iwch;
	PTXTOBJ ptxtobj;
	OBJDIM objdim;

	Assert(cchnk > 0);
	
	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;
	*pfSuccessful = fFalse;
	if ( GetPrevImportantRun(rglschnk, cchnk - 1, &itxtobj))
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfModWidthClassed)
			{
			Assert(!(ptxtobj->txtf & txtfGlyphBased));
			*pfSuccessful = fTrue;
			iwch = ptxtobj->iwchLim - 1;
			*pwch = pilsobj->pwchOrig[iwch];
			*pplsrun = rglschnk[itxtobj].plsrun;
			*pmwcls = (MWCLS)pilsobj->ptxtinf[iwch].mwcls;
			lserr = LsdnGetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, &objdim);
			if (lserr != lserrNone) return lserr;
			*pheights = objdim.heightsRef;
			}
		}

	return lserrNone;

}

/* M O D I F Y  F I R S T  C H A R  I N  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: ModifyFirstCharInChunk
    %%Contact: sergeyge

	Prepares information about first visible char in chunk
----------------------------------------------------------------------------*/
LSERR ModifyFirstCharInChunk(DWORD cchnk, const LSCHNKE* rglschnk, long durChange)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long itxtobj;
	long iwch;
	PTXTOBJ ptxtobj;
	BOOL fFound;

	Assert(cchnk > 0);
	
	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;

	fFound = GetNextImportantRun(cchnk, rglschnk, 0, &itxtobj);

	Assert(fFound);
	Assert(pilsobj->pdurLeft != NULL);

	ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;

	Assert(!(ptxtobj->txtf & txtfGlyphBased));
	Assert(ptxtobj->txtf & txtfModWidthClassed);

	iwch = ptxtobj->iwchFirst;
	ApplyChanges(pilsobj, iwch, sideLeft, durChange);
	lserr = LsdnModifySimpleWidth(pilsobj->plsc, ptxtobj->plsdnUpNode, durChange);
	
	return lserrNone;
}

/* M O D I F Y  L A S T  C H A R  I N  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: ModifyLastCharInChunk
    %%Contact: sergeyge

	Prepares information about first visible char in chunk
----------------------------------------------------------------------------*/
LSERR ModifyLastCharInChunk(DWORD cchnk, const LSCHNKE* rglschnk, long durChange)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long itxtobj;
	long iwch;
	PTXTOBJ ptxtobj;
	BOOL fFound;

	Assert(cchnk > 0);
	
	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;

	fFound = GetPrevImportantRun(rglschnk, cchnk-1, &itxtobj);

	Assert(fFound);
	Assert(pilsobj->pdurRight != NULL);

	ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;

	Assert(!(ptxtobj->txtf & txtfGlyphBased));
	Assert(ptxtobj->txtf & txtfModWidthClassed);

	iwch = ptxtobj->iwchLim - 1;
	ApplyChanges(pilsobj, iwch, sideRight, durChange);
	lserr = LsdnModifySimpleWidth(pilsobj->plsc, ptxtobj->plsdnUpNode, durChange);
	
	return lserrNone;
}

/* C U T  T E X T  D O B J */
/*----------------------------------------------------------------------------
    %%Function: CutTextDobj
    %%Contact: sergeyge

	Cuts characters according to dcpMaxContext
----------------------------------------------------------------------------*/

LSERR CutTextDobj(DWORD cchnk, const LSCHNKE* rglschnk)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long itxtobjLast;
	long dcp;
	long dur;
	long iwchLim;
	long igindLim;
	long iwSpacesFirst;
	long iwSpacesLim;
	BOOL fNonSpaceBeforeFound;
	long itxtobjBefore;
	long iwchBefore;
	OBJDIM objdim;
	long itxtobj;
	BOOL fFixSpaces = fTrue;

	Assert(cchnk > 0);

	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;

	iwchLim = ((PTXTOBJ)rglschnk[cchnk - 1].pdobj)->iwchLim - rglschnk[cchnk-1].plschp->dcpMaxContext + 1;

	itxtobjLast = cchnk - 1;
	while (itxtobjLast >= 0 && iwchLim <= ((PTXTOBJ)rglschnk[itxtobjLast].pdobj)->iwchFirst)
		itxtobjLast--;

	if (itxtobjLast >= 0)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobjLast].pdobj;

		fNonSpaceBeforeFound = FindNonSpaceBefore(rglschnk, itxtobjLast, iwchLim - 1, &itxtobjBefore, &iwchBefore);

		if (fNonSpaceBeforeFound)
			{
			if (iwchBefore != iwchLim - 1)
				{
				Assert(itxtobjBefore >= 0);
				itxtobjLast = itxtobjBefore;
				iwchLim = iwchBefore + 1;
				ptxtobj = (PTXTOBJ)rglschnk[itxtobjLast].pdobj;
				}

			dcp = iwchLim - ptxtobj->iwchFirst;

			lserr = LsdnGetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, &objdim);
			Assert(lserr == lserrNone);

			dur = objdim.dur;

			Assert(ptxtobj->iwchFirst + (long)dcp <= ptxtobj->iwchLim);
		
			if (ptxtobj->txtf & txtfGlyphBased)
				{
				long igind;

				Assert(iwchLim >= ptxtobj->iwchFirst);

/* REVIEW sergeyge: We should take IwchLastFromIwch instead and get rid of fFixSpaces---
		right?
*/
				if (iwchLim > ptxtobj->iwchFirst)
					iwchLim = IwchPrevLastFromIwch(ptxtobj, iwchLim) + 1;

				/* if part of Dnode is to be left, calculate this part
					else delete the whole Dnode
				*/
				if (iwchLim > ptxtobj->iwchFirst)
					{
					igindLim = IgindLastFromIwch(ptxtobj, iwchLim - 1) + 1;
					for (igind = igindLim; igind < ptxtobj->igindLim; igind++)
						dur -= pilsobj->pdurGind[igind];
					ptxtobj->iwchLim = iwchLim;
					ptxtobj->igindLim = igindLim;
					lserr = LsdnSetSimpleWidth(pilsobj->plsc, ptxtobj->plsdnUpNode, dur);
					Assert (lserr == lserrNone);
					lserr = LsdnResetDcp(pilsobj->plsc, 
											ptxtobj->plsdnUpNode, iwchLim - ptxtobj->iwchFirst);
					Assert (lserr == lserrNone);
					}
				else
					{
					itxtobjLast--;
					fFixSpaces = fFalse;
					}
			
				}
			else
				{
				long iwch;

				for (iwch = iwchLim; iwch < ptxtobj->iwchLim; iwch++)
					dur -= pilsobj->pdur[iwch];
				ptxtobj->iwchLim = iwchLim;
				lserr = LsdnSetSimpleWidth(pilsobj->plsc, ptxtobj->plsdnUpNode, dur);
				Assert (lserr == lserrNone);
				lserr = LsdnResetDcp(pilsobj->plsc, ptxtobj->plsdnUpNode, dcp);
				Assert (lserr == lserrNone);
			
				}

			if (fFixSpaces)
				{
				Assert(ptxtobj == (PTXTOBJ)rglschnk[itxtobjLast].pdobj);
				iwSpacesFirst = ptxtobj->u.reg.iwSpacesFirst;
				iwSpacesLim = ptxtobj->u.reg.iwSpacesLim;

				while (iwSpacesLim > iwSpacesFirst && pilsobj->pwSpaces[iwSpacesLim - 1] > iwchLim - 1)
					{
					iwSpacesLim--;
					}

				ptxtobj->u.reg.iwSpacesLim = iwSpacesLim;

				Assert(iwchLim == ptxtobj->iwchLim);

				if (iwSpacesLim - iwSpacesFirst == iwchLim - ptxtobj->iwchFirst && 
					!(pilsobj->grpf & fTxtSpacesInfluenceHeight) &&
					objdim.heightsRef.dvMultiLineHeight != dvHeightIgnore)
					{
					objdim.dur = dur;
					objdim.heightsRef.dvMultiLineHeight = dvHeightIgnore;
					objdim.heightsPres.dvMultiLineHeight = dvHeightIgnore;
					lserr = LsdnResetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, &objdim);
					Assert (lserr == lserrNone);
					}
				}
			}
		else
			{
	/* dirty triangle: in the case of fNonSpaceFound==fFalse, correct itxtobjLast */ 
			itxtobjLast = -1;
			}
		}


	for (itxtobj = itxtobjLast + 1; itxtobj < (long)cchnk; itxtobj++)
		{
		lserr = LsdnSetSimpleWidth(pilsobj->plsc, ((PTXTOBJ)rglschnk[itxtobj].pdobj)->plsdnUpNode, 0);
		Assert (lserr == lserrNone);
		lserr = LsdnResetDcp(pilsobj->plsc, ((PTXTOBJ)rglschnk[itxtobj].pdobj)->plsdnUpNode, 0);
		Assert (lserr == lserrNone);
		}


	return lserrNone;
}


/* Internal functions implementation */

static LSERR PrepareAllArraysGetModWidth(DWORD grpfTnti, DWORD cchnk, const LSCHNKE* rglschnk)
{
	LSERR lserr;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;

	plnobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj;
	pilsobj = plnobj->pilsobj;

	Assert ((grpfTnti & maskAllCharBasedArrays) || (pilsobj->grpf & fTxtPunctStartLine) || 
			(pilsobj->grpf & fTxtHangingPunct) || (grpfTnti & fTntiGlyphBased) ||
			(grpfTnti & fTntiKern) || pilsobj->fSnapGrid);
/* if we got to nti some adjustment is needed and we must allocate pdurAdjust */

	if (pilsobj->pduAdjust == NULL)
		{
		pilsobj->pduAdjust = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->wchMax );
		if (pilsobj->pduAdjust == NULL)
			{
			return lserrOutOfMemory;
			}
		}

	if ( (grpfTnti & maskAllCharBasedArrays) || (pilsobj->grpf & fTxtPunctStartLine) || 
					(pilsobj->grpf & fTxtHangingPunct) || pilsobj->fSnapGrid || (grpfTnti & fTntiGlyphBased))
		{
		Assert(pilsobj->pduAdjust != NULL);

		if (pilsobj->pdurRight == NULL)
			{

			Assert (pilsobj->pdurLeft == NULL);
			Assert(pilsobj->ptxtinf == NULL);

			pilsobj->pdurRight = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->wchMax );
			pilsobj->pdurLeft = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->wchMax );
			pilsobj->ptxtinf = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(TXTINF) * pilsobj->wchMax );
			if (pilsobj->pdurRight == NULL || pilsobj->pdurLeft == NULL || pilsobj->ptxtinf == NULL)
				{
				return lserrOutOfMemory;
				}
			memset(pilsobj->pdurRight, 0, sizeof(long) * pilsobj->wchMax );
			memset(pilsobj->pdurLeft, 0, sizeof(long) * pilsobj->wchMax );
			memset(pilsobj->ptxtinf, 0, sizeof(TXTINF) * pilsobj->wchMax);
			}


		pilsobj->fNotSimpleText = fTrue;
		}

	if (grpfTnti & fTntiGlyphBased)
		{
		lserr = CheckReallocGlyphs(plnobj, pilsobj->wchMax - 2);
		if (lserr != lserrNone) return lserr;
		}

	if ( (grpfTnti & maskAllCharBasedArrays) || (pilsobj->grpf & fTxtPunctStartLine) || 
					(pilsobj->grpf & fTxtHangingPunct) || pilsobj->fSnapGrid)
		{
		lserr = GetModWidthClasses(cchnk, rglschnk);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;

}

static LSERR ApplyKern(LSTFLOW lstflow, DWORD cchnk, const LSCHNKE* rglschnk)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	long itxtobjPrev = 0;
	long itxtobjCur;
	BOOL fFoundNextRun;
	BOOL fFoundKernedPrevRun;

	plnobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj;
	pilsobj = plnobj->pilsobj;

	fFoundNextRun = GetNextImportantRun(cchnk, rglschnk, 0, &itxtobjCur);

	fFoundKernedPrevRun = fFalse;

	while (fFoundNextRun)
		{
		if (fFoundKernedPrevRun && rglschnk[itxtobjCur].plschp->fApplyKern)
			{
			lserr = CheckApplyKernBetweenRuns(lstflow, rglschnk, itxtobjPrev, itxtobjCur);
			if (lserr != lserrNone) return lserr;
			}

		if (rglschnk[itxtobjCur].plschp->fApplyKern)
			{
			lserr = ApplyKernToRun(lstflow, rglschnk, itxtobjCur);
			if (lserr != lserrNone) return lserr;

			fFoundKernedPrevRun = fTrue;
			itxtobjPrev = itxtobjCur;
			}
		else
			{
			fFoundKernedPrevRun = fFalse;
			}

		fFoundNextRun = GetNextImportantRun(cchnk, rglschnk, itxtobjCur + 1, &itxtobjCur);
		}
	
	return lserrNone;
}

static LSERR CheckApplyKernBetweenRuns(LSTFLOW lstflow, const LSCHNKE* rglschnk,
															long itxtobjPrev, long itxtobjCur)
{
	LSERR lserr;
	PTXTOBJ ptxtobj;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	long iwchLim;
	BOOL fKernPrevRun;
	long dduKern;
	WCHAR* pwch = NULL;
	WCHAR rgwchTwo[2];
	long dduAdjust;

	ptxtobj = (PTXTOBJ)rglschnk[itxtobjPrev].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj; 

	Assert(!(ptxtobj->txtf & txtfGlyphBased));

	lserr = (*pilsobj->plscbk->pfnCheckRunKernability)(pilsobj->pols, rglschnk[itxtobjPrev].plsrun,
									 rglschnk[itxtobjCur].plsrun, &fKernPrevRun);
	if (lserr != lserrNone) return lserr;

	if (fKernPrevRun)
		{
		iwchLim = ptxtobj->iwchLim;
		if (iwchLim == ((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->iwchFirst)
			{
			pwch = &pilsobj->pwchOrig[iwchLim - 1];
			}
		else
			{
			rgwchTwo[0] = pilsobj->pwchOrig[iwchLim - 1];
			rgwchTwo[1] = pilsobj->pwchOrig[((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->iwchFirst];
			pwch = rgwchTwo;
			}

		lserr = (*pilsobj->plscbk->pfnGetRunCharKerning)(pilsobj->pols, rglschnk[itxtobjPrev].plsrun,
						lsdevReference,	pwch, 2, lstflow, (int*)&dduKern);
		if (lserr != lserrNone) return lserr;
		
		dduAdjust = max(-pilsobj->pdur[iwchLim - 1], dduKern);
		pilsobj->pdur[iwchLim - 1] += dduAdjust;

		lserr = LsdnModifySimpleWidth(pilsobj->plsc, ptxtobj->plsdnUpNode, dduAdjust);
		if (lserr != lserrNone) return lserr;

		if (pilsobj->fDisplay)
			{
			if (!pilsobj->fPresEqualRef)
				{
				lserr = (*pilsobj->plscbk->pfnGetRunCharKerning)(pilsobj->pols, rglschnk[itxtobjPrev].plsrun,
								lsdevPres, pwch, 2, lstflow, (int*)&dduKern);
				if (lserr != lserrNone) return lserr;
				
				dduAdjust = max(-plnobj->pdup[iwchLim - 1], dduKern);
				plnobj->pdup[iwchLim - 1] += dduAdjust;

				}
			else
				{
				plnobj->pdup[iwchLim - 1] = pilsobj->pdur[iwchLim-1];
				}
			}
		}

	return lserrNone;

}

static LSERR ApplyKernToRun(LSTFLOW lstflow, const LSCHNKE* rglschnk, long itxtobjCur)
{
	LSERR lserr;
	PTXTOBJ ptxtobj;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	long iwchFirst;
	long iwchLim;
	long iwch;
	long dduAdjust;
	long ddurChange;

	ptxtobj = (PTXTOBJ)rglschnk[itxtobjCur].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	Assert(!(ptxtobj->txtf & txtfGlyphBased));
	Assert(pilsobj->pduAdjust != NULL);

	iwchFirst = ptxtobj->iwchFirst;
	iwchLim = ptxtobj->iwchLim;

	Assert (iwchLim > iwchFirst);

	if (iwchLim == iwchFirst + 1)
		return lserrNone;

	lserr = (*pilsobj->plscbk->pfnGetRunCharKerning)(pilsobj->pols, rglschnk[itxtobjCur].plsrun, lsdevReference,
				&pilsobj->pwchOrig[iwchFirst], iwchLim - iwchFirst, lstflow, (int*)&pilsobj->pduAdjust[iwchFirst]);
	if (lserr != lserrNone) return lserr;

	ddurChange = 0;

	for (iwch = iwchFirst; iwch < iwchLim - 1; iwch++)
		{
		dduAdjust = max(-pilsobj->pdur[iwch], pilsobj->pduAdjust[iwch]);
		pilsobj->pdur[iwch] += dduAdjust;
		ddurChange += dduAdjust;
		}

	if (ddurChange != 0)
		{
		lserr = LsdnModifySimpleWidth(pilsobj->plsc, ptxtobj->plsdnUpNode, ddurChange);
		if (lserr != lserrNone) return lserr;
		}

	if (pilsobj->fDisplay)
		{
		if (!pilsobj->fPresEqualRef)
			{
			lserr = (*pilsobj->plscbk->pfnGetRunCharKerning)(pilsobj->pols, rglschnk[itxtobjCur].plsrun, lsdevPres,
					&plnobj->pwch[iwchFirst], iwchLim - iwchFirst, lstflow, (int*)&pilsobj->pduAdjust[iwchFirst]);
			if (lserr != lserrNone) return lserr;
	
			for (iwch = iwchFirst; iwch < iwchLim - 1; iwch++)
				{
				dduAdjust = max(-plnobj->pdup[iwch], pilsobj->pduAdjust[iwch]);
				plnobj->pdup[iwch] += dduAdjust;
				}
			}
		else
			{
			memcpy(&plnobj->pdup[iwchFirst], &pilsobj->pdur[iwchFirst], sizeof(long) * (iwchLim - iwchFirst) );
			}
		}

	return lserrNone;
}

static BOOL GetPrevImportantRun(const LSCHNKE* rglschnk, long itxtobj, long* pitxtobjPrev)
{
	PTXTOBJ ptxtobj;

	while (itxtobj >= 0 /*&& !fFound  (fFound logic changed to break)*/)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
		if (!(ptxtobj->txtf & txtfSkipAtNti))
			{
			/*fFound = fTrue;*/
			break;
			}
		else
			{
			itxtobj--;
			}
		}

	*pitxtobjPrev = itxtobj;

	return (itxtobj >= 0);
}

static BOOL GetNextImportantRun(DWORD cchnk, const LSCHNKE* rglschnk, long itxtobj, long* pitxtobjNext)
{
	PTXTOBJ ptxtobj;

	while (itxtobj < (long)cchnk /*&& !fFound  (fFound logic changed to break)*/)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
		if (!(ptxtobj->txtf & txtfSkipAtNti))
			{
			/*fFound = fTrue;*/
			break;
			}
		else
			{
			itxtobj++;
			}
		}

	*pitxtobjNext = itxtobj;

	return (itxtobj < (long)cchnk);
}

static LSERR ApplyModWidth(LSTFLOW lstflow, BOOL fFirstOnLine, BOOL fAutoNumberPresent, DWORD cchnk, const LSCHNKE* rglschnk)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	long itxtobjPrev=0;
	long itxtobjCur;
	BOOL fFoundNextRun;
	BOOL fFoundModWidthPrevRun;

	plnobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj;
	pilsobj = plnobj->pilsobj;

	fFoundNextRun = GetNextImportantRun(cchnk, rglschnk, 0, &itxtobjCur);

	fFoundModWidthPrevRun = fFalse;

	while (fFoundNextRun)
		{
		if (fFoundModWidthPrevRun && FModWidthSomeDobj(itxtobjCur))
			{
			lserr = CheckApplyModWidthBetweenRuns(lstflow, rglschnk, itxtobjPrev, itxtobjCur);
			if (lserr != lserrNone) return lserr;
			}

		lserr = ApplyModWidthToRun(lstflow, fFirstOnLine, fAutoNumberPresent,cchnk, rglschnk, itxtobjCur);
		if (lserr != lserrNone) return lserr;

		fFoundModWidthPrevRun = FModWidthSomeDobj(itxtobjCur);
		itxtobjPrev = itxtobjCur;

		fFoundNextRun = GetNextImportantRun(cchnk, rglschnk, itxtobjCur + 1, &itxtobjCur);
		}
	
	return lserrNone;
}

static LSERR ApplyModWidthToRun(LSTFLOW lstflow, BOOL fFirstOnLine, BOOL fAutoNumberPresent, DWORD cchnk, const LSCHNKE* rglschnk, long itxtobjCur)
{
	LSERR lserr;
	PTXTOBJ ptxtobj;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	long iwchVeryFirst;
	long iwchVeryLim;
	long iwchFirst;
	long iwchLim;
	long iwch;
	long iwchPrev;
	long iwchNext;
	LSEMS lsems;
	PLSRUN plsrun;
	PLSRUN plsrunPrev;
	PLSRUN plsrunNext;
	long itxtobjPrev;
	long itxtobjNext;
	BOOL fFoundPrevRun;
	BOOL fFoundNextRun;
	long ddurChangeFirst;
	long ddurChangeSecond;
	long ddurChange;
	WCHAR* pwchOrig;

	ptxtobj = (PTXTOBJ)rglschnk[itxtobjCur].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;
	plsrun = rglschnk[itxtobjCur].plsrun;

	lserr = (*pilsobj->plscbk->pfnGetEms)(pilsobj->pols, plsrun, lstflow, &lsems);
	if (lserr != lserrNone) return lserr;

	Assert(ptxtobj->iwchLim > ptxtobj->iwchFirst);

	ddurChange = 0;
	/* all changes to the last char which depend on the next run will be applied in the next
		call to ApplyModWidthBetween runs
	*/ 
	iwchLim = ptxtobj->iwchLim;
	iwchFirst = ptxtobj->iwchFirst;

	if ( (pilsobj->grpf & fTxtPunctStartLine) && fFirstOnLine && itxtobjCur == 0 &&
					!(fAutoNumberPresent && (pilsobj->grpf & fTxtNoPunctAfterAutoNumber	)) &&
					!(ptxtobj->txtf & txtfGlyphBased)
		)
		{
		CheckApplyPunctStartLine(pilsobj, plsrun, &lsems, iwchFirst, &ddurChangeFirst);
		ddurChange += ddurChangeFirst;
		}

	if (rglschnk[itxtobjCur].plschp->fModWidthPairs)
		{
		Assert(pilsobj->ptxtinf != NULL);
		Assert(pilsobj->plspairact != NULL);
		Assert(pilsobj->pilspairact != NULL);
		Assert(!(ptxtobj->txtf & txtfGlyphBased));

		Assert(pilsobj->pilspairact != NULL);
		if(pilsobj->pilspairact == NULL)
			return lserrModWidthPairsNotSet;			

		for (iwch = iwchFirst; iwch < iwchLim - 1; iwch++)
			{
			CheckApplyModWidthTwoChars(pilsobj, &lsems, &lsems, iwch, iwch+1, &ddurChangeFirst, &ddurChangeSecond);
			ddurChange += (ddurChangeFirst + ddurChangeSecond);
			}

		}

	/* REVIEW sergeyge(elik): should we try to avoid second loop through characters? */
	if (rglschnk[itxtobjCur].plschp->fModWidthSpace)
		{
		Assert(!(ptxtobj->txtf & txtfGlyphBased));

		iwchVeryFirst = ((PTXTOBJ)rglschnk[0].pdobj)->iwchFirst;
		iwchVeryLim = ((PTXTOBJ)rglschnk[cchnk-1].pdobj)->iwchLim;
		pwchOrig = pilsobj->pwchOrig;

		for (iwch = iwchFirst; iwch < iwchLim; iwch++)
			{
			if (pwchOrig[iwch] == pilsobj->wchSpace)
				{
				plsrunPrev = NULL;
				iwchPrev = 0;
				if (iwch > iwchFirst)
					{
					plsrunPrev = plsrun;
					iwchPrev = iwch - 1;
					}
				else if (iwch > iwchVeryFirst)
					{
					Assert(itxtobjCur > 0);
					fFoundPrevRun = GetPrevImportantRun(rglschnk, itxtobjCur-1, &itxtobjPrev);
					if (fFoundPrevRun)
						{
						Assert(itxtobjPrev >= 0);
						plsrunPrev = rglschnk[itxtobjPrev].plsrun;
						iwchPrev = ((PTXTOBJ)rglschnk[itxtobjPrev].pdobj)->iwchLim - 1;
						}
					}

				plsrunNext = NULL;
				iwchNext = 0;
				if (iwch < iwchLim - 1)
					{
					plsrunNext = plsrun;
					iwchNext = iwch + 1;
					}
				else if (iwch < iwchVeryLim - 1)
					{
					Assert(itxtobjCur < (long)cchnk - 1);
					fFoundNextRun = GetNextImportantRun(cchnk, rglschnk, itxtobjCur+1, &itxtobjNext);
					if (fFoundNextRun)
						{
						Assert(itxtobjNext < (long)cchnk);
						plsrunNext = rglschnk[itxtobjNext].plsrun;
						iwchNext = ((PTXTOBJ)rglschnk[itxtobjNext].pdobj)->iwchFirst;
						}
					}

				lserr = CheckApplyModWidthSpace(pilsobj, plsrunPrev, plsrun, plsrunNext, &lsems,
													iwchPrev, iwch, iwchNext, &ddurChangeFirst);
				if (lserr != lserrNone) return lserr;

				ddurChange += ddurChangeFirst;

				}
			}
		}

	if (ddurChange != 0)
		{
		lserr = LsdnModifySimpleWidth(pilsobj->plsc, ptxtobj->plsdnUpNode, ddurChange);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;
}

static LSERR CheckApplyModWidthBetweenRuns(LSTFLOW lstflow, const LSCHNKE* rglschnk, long itxtobjPrev, long itxtobjCur)
{
	LSERR lserr;
	PTXTOBJ ptxtobjPrev;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	long iwchNext;
	long iwch;
	LSEMS lsemsPrev;
	LSEMS lsemsCur;
	PLSRUN plsrunPrev;
	PLSRUN plsrunCur;
	long ddurChangeFirst;
	long ddurChangeSecond;
	long ddurChangePrev;
	long ddurChangeCur;

	ddurChangePrev = 0;
	ddurChangeCur = 0;

	ptxtobjPrev = (PTXTOBJ)rglschnk[itxtobjPrev].pdobj;
	plnobj = ptxtobjPrev->plnobj;
	pilsobj = plnobj->pilsobj;
	plsrunPrev = rglschnk[itxtobjPrev].plsrun;
	plsrunCur = rglschnk[itxtobjCur].plsrun;

	iwchNext = ((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->iwchFirst;

	lserr = (*pilsobj->plscbk->pfnGetEms)(pilsobj->pols, plsrunPrev, lstflow, &lsemsPrev);
	if (lserr != lserrNone) return lserr;
	lserr = (*pilsobj->plscbk->pfnGetEms)(pilsobj->pols, plsrunCur, lstflow, &lsemsCur);
	if (lserr != lserrNone) return lserr;

	iwch = ptxtobjPrev->iwchLim - 1;

	if (rglschnk[itxtobjPrev].plschp->fModWidthOnRun && rglschnk[itxtobjCur].plschp->fModWidthOnRun)
		{
		lserr = CheckApplyModWidthOnRun(pilsobj, ptxtobjPrev, 
									plsrunPrev, plsrunCur, &lsemsPrev, iwch, iwchNext, &ddurChangeFirst);
		if (lserr != lserrNone) return lserr;
		ddurChangePrev += ddurChangeFirst;
		}

	if (rglschnk[itxtobjPrev].plschp->fModWidthPairs && rglschnk[itxtobjCur].plschp->fModWidthPairs)
		{
		Assert ((!(ptxtobjPrev->txtf & txtfGlyphBased)) &&
								!(((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->txtf & txtfGlyphBased));
		CheckApplyModWidthTwoChars(pilsobj, &lsemsPrev, &lsemsCur, iwch, iwchNext, &ddurChangeFirst, &ddurChangeSecond);
		ddurChangePrev += ddurChangeFirst;
		ddurChangeCur += ddurChangeSecond;
		}

	if (ddurChangePrev != 0)
		{
		lserr = LsdnModifySimpleWidth(pilsobj->plsc, ptxtobjPrev->plsdnUpNode, ddurChangePrev);
		if (lserr != lserrNone) return lserr;
		}

	if (ddurChangeCur != 0)
		{
		lserr = LsdnModifySimpleWidth(pilsobj->plsc, ((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->plsdnUpNode,
																						ddurChangeCur);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;
}

static LSERR GetModWidthClasses(DWORD cchnk, const LSCHNKE* rglschnk)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long itxtobj;
	long iwchFirst;
	long iwchLim;
	long iwch;
	long i;
	MWCLS* pmwcls;
	WCHAR* pwchOrig;
	TXTINF* ptxtinf;

	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;
	pwchOrig = pilsobj->pwchOrig;
	ptxtinf = pilsobj->ptxtinf;
	
	for (itxtobj = 0; itxtobj < (long)cchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
		if (!(ptxtobj->txtf & txtfGlyphBased))
			{
			iwchFirst = ptxtobj->iwchFirst;
			iwchLim = ptxtobj->iwchLim;

			if (iwchLim > iwchFirst)
				{
				Assert(pilsobj->pduAdjust != NULL);
				/* I use pdurAdjust as temporary buffer to read MWCLS info */
				pmwcls = (MWCLS*)(&pilsobj->pduAdjust[iwchFirst]);
				lserr =(*pilsobj->plscbk->pfnGetModWidthClasses)(pilsobj->pols, rglschnk[itxtobj].plsrun,
									&pwchOrig[iwchFirst], (DWORD)(iwchLim - iwchFirst), pmwcls);
				if (lserr != lserrNone) return lserr;
				for (i=0, iwch = iwchFirst; iwch < iwchLim; i++, iwch++)
					{
					Assert(pmwcls[i] < pilsobj->cModWidthClasses);
					if (pmwcls[i] >= pilsobj->cModWidthClasses)
						return lserrInvalidModWidthClass;
					ptxtinf[iwch].mwcls = pmwcls[i];
					}
				
				}

			ptxtobj->txtf |= txtfModWidthClassed;

			}


		}

	return lserrNone;
}

static LSERR CheckApplyPunctStartLine(PILSOBJ pilsobj, PLSRUN plsrun, LSEMS* plsems, long iwch,
																				long* pddurChange)
{
	LSERR lserr;
	LSACT lsact;
	MWCLS mwcls;
	BYTE side;

	*pddurChange = 0;

	mwcls = (BYTE)pilsobj->ptxtinf[iwch].mwcls;
	Assert(mwcls < pilsobj->cModWidthClasses);

	lserr = (*pilsobj->plscbk->pfnPunctStartLine)(pilsobj->pols, plsrun, mwcls, pilsobj->pwchOrig[iwch], &lsact);
	if (lserr != lserrNone) return lserr;

	if (lsact.side != sideNone)
		{
		GetChanges(lsact, plsems, pilsobj->pdur[iwch], fFalse, &side, pddurChange);
		ApplyChanges(pilsobj, iwch, side, *pddurChange);
/*		pilsobj->ptxtinf[iwch].fStartLinePunct = fTrue;*/
		}

	return lserrNone;
}

static LSERR CheckApplyModWidthSpace(PILSOBJ pilsobj, PLSRUN plsrunPrev, PLSRUN plsrunCur, PLSRUN plsrunNext,
						LSEMS* plsems, long iwchPrev, long iwchCur, long iwchNext, long* pddurChange)
{
	LSERR lserr;
	WCHAR wchPrev;
	WCHAR wchNext;
	LSACT lsact;
	BYTE side;

	*pddurChange = 0;

	wchPrev = 0;
	if (plsrunPrev != NULL)
		wchPrev = pilsobj->pwchOrig[iwchPrev];

	wchNext = 0;
	if (plsrunNext != NULL)
		wchNext = pilsobj->pwchOrig[iwchNext];

	lserr = (*pilsobj->plscbk->pfnModWidthSpace)(pilsobj->pols, plsrunCur, plsrunPrev, wchPrev, plsrunNext, wchNext,
																				 &lsact);
	if (lserr != lserrNone) return lserr;

	if (lsact.side != sideNone)
		{
		GetChanges(lsact, plsems, pilsobj->pdur[iwchCur], fTrue, &side, pddurChange);
		Assert(side == sideRight);
		ApplyChanges(pilsobj, iwchCur, side, *pddurChange);
		pilsobj->ptxtinf[iwchCur].fModWidthSpace = fTrue;
		}

	return lserrNone;
}

static LSERR CheckApplyModWidthOnRun(PILSOBJ pilsobj, PTXTOBJ ptxtobjPrev, PLSRUN plsrunPrev, PLSRUN plsrunCur,
						LSEMS* plsems, long iwchFirst, long iwchSecond, long* pddurChange)
{
	LSERR lserr;
	LSACT lsact;
	BYTE side;
	long igindLast;
	long igind;

	*pddurChange = 0;
	lserr = (*pilsobj->plscbk->pfnModWidthOnRun)(pilsobj->pols, plsrunPrev, pilsobj->pwchOrig[iwchFirst],
					plsrunCur, pilsobj->pwchOrig[iwchSecond], &lsact);
	if (lserr != lserrNone) return lserr;

	if (lsact.side != sideNone)
		{
		if (ptxtobjPrev->txtf & txtfGlyphBased)
			{
			igindLast = IgindLastFromIwch(ptxtobjPrev, iwchFirst);
			igind = IgindBaseFromIgind(pilsobj, igindLast);
			GetChanges(lsact, plsems, pilsobj->pdurGind[igind], fTrue, &side, pddurChange);
			Assert(side == sideRight);
			ApplyGlyphChanges(pilsobj, igind, *pddurChange);
			}
		else
			{
			GetChanges(lsact, plsems, pilsobj->pdur[iwchFirst], fTrue, &side, pddurChange);
			Assert(side == sideRight);
			ApplyChanges(pilsobj, iwchFirst, side, *pddurChange);
			}
		pilsobj->ptxtinf[iwchFirst].fModWidthOnRun = fTrue;
		}

	return lserrNone;
}

static LSERR ApplySnapGrid(DWORD cchnk, const LSCHNKE* rglschnk)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long iwchVeryFirst;
	long iwchVeryLim;
	long iwchFirstInDobj;
	long iwchLimInDobj;
	long iwch;
	long iwchFirstSnapped;
	long iwchPrev;
	long itxtobj;
	long itxtobjCur;
	long itxtobjFirstSnapped;
	long itxtobjPrev;
	PLSRUN* rgplsrun = NULL;
	LSCP* rgcp = NULL;
	BOOL* rgfSnapped = NULL;
	long irg;
	PLSRUN plsrunCur;
	LSCP cpCur;
	long cGrid;
	BOOL fFoundNextRun;
	long urColumnMax;
	long urPen;
	long durPen;
	long urPenSnapped;
	long urPenFirstSnapped;
	long durUndo;
	long durGridWhole;
	long durGridRem;
	BOOL fInChildList;

	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;

	lserr = LsdnFInChildList(pilsobj->plsc, ((PTXTOBJ)rglschnk[0].pdobj)->plsdnUpNode, &fInChildList);
	Assert(lserr == lserrNone);

	if (fInChildList)
		return lserrNone;

	iwchVeryFirst = ((PTXTOBJ)rglschnk[0].pdobj)->iwchFirst;
	iwchVeryLim = ((PTXTOBJ)rglschnk[cchnk - 1].pdobj)->iwchLim;

	if (iwchVeryLim <= iwchVeryFirst)
		return lserrNone;

	rgcp = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, (iwchVeryLim - iwchVeryFirst) * sizeof (LSCP));
	if (rgcp == NULL)
		return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserrOutOfMemory);
	
	rgplsrun = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, (iwchVeryLim - iwchVeryFirst) * sizeof (PLSRUN));
	if (rgplsrun == NULL)
		return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserrOutOfMemory);
		
	rgfSnapped = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, (iwchVeryLim - iwchVeryFirst) * sizeof (BOOL));
	if (rgfSnapped == NULL)
		return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserrOutOfMemory);

	irg = 0;

	for (itxtobj = 0; itxtobj < (long)cchnk; itxtobj++)
		{
		iwchFirstInDobj = ((PTXTOBJ)rglschnk[itxtobj].pdobj)->iwchFirst;
		iwchLimInDobj = ((PTXTOBJ)rglschnk[itxtobj].pdobj)->iwchLim;
		plsrunCur = rglschnk[itxtobj].plsrun;
		cpCur = rglschnk[itxtobj].cpFirst;

		for (iwch = iwchFirstInDobj; iwch < iwchLimInDobj; iwch++)
			{
			rgcp[irg] = cpCur;
			rgplsrun[irg] = plsrunCur;
			irg++;
			cpCur++;
			}
		}

	lserr = (*pilsobj->plscbk->pfnGetSnapGrid)(pilsobj->pols, &pilsobj->pwchOrig[iwchVeryFirst], rgplsrun, rgcp, irg, rgfSnapped, (DWORD*)&cGrid);
	if (lserr != lserrNone) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserr);

	Assert(cGrid > 0);

	if (cGrid <= 0) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserrNone);

	rgfSnapped[0] = fTrue;	/* First character of each lock chunk must be snapped */

	fFoundNextRun = GetNextImportantRun(cchnk, rglschnk, 0, &itxtobjCur);

	if (fFoundNextRun && rgfSnapped[((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->iwchFirst - iwchVeryFirst])
		{
		iwchFirstInDobj = ((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->iwchFirst;

	/* fix for the case when ModWidth was applied before snapping to grid.
		Changes to the left of the first character should be undone.
	*/
		lserr = UndoAppliedModWidth(pilsobj, rglschnk, itxtobjCur, iwchFirstInDobj, sideLeft, &durUndo);
		if (lserr != lserrNone) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserr);

		lserr = LsdnGetUrPenAtBeginningOfChunk(pilsobj->plsc, ((PTXTOBJ)rglschnk[0].pdobj)->plsdnUpNode,
																					 &urPen, &urColumnMax);
		if (lserr != lserrNone) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserr);

		if (urColumnMax <= 0) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserrNone);

		durGridWhole = urColumnMax / cGrid;
		durGridRem = urColumnMax - durGridWhole * cGrid;

		urPenSnapped = CalcSnapped(urPen, urColumnMax, cGrid, durGridWhole, durGridRem);

		Assert(urPenSnapped >= urPen);

		if (urPenSnapped > urPen)
			{
			ApplyChanges(pilsobj, iwchFirstInDobj, sideLeft, urPenSnapped - urPen);
			lserr = LsdnModifySimpleWidth(pilsobj->plsc, ((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->plsdnUpNode, 
																						urPenSnapped - urPen);
			if (lserr != lserrNone) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserr);
			}

/* Dangerous fix to the bug 594. Width of first character was just changed. First iteration of the 
	following for loop assumes that it was not. So I initialize variables in such way that 
	first iteration will work correctly---2 errors compensate each other

	before fix initialization was:
		durPen = 0;
		urPen = urPenSnapped
*/
		durPen = urPen - urPenSnapped;
/*		urPen = urPenSnapped;*/


		urPenFirstSnapped = urPenSnapped;
		iwchFirstSnapped = iwchFirstInDobj;
		itxtobjFirstSnapped = itxtobjCur;
		iwchPrev = iwchFirstInDobj;
		itxtobjPrev = itxtobjCur;

		while (fFoundNextRun)
			{
			iwchFirstInDobj = ((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->iwchFirst;
			iwchLimInDobj = ((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->iwchLim;
			for (iwch = iwchFirstInDobj; iwch < iwchLimInDobj; iwch++)
				{
				if (rgfSnapped[iwch - iwchVeryFirst] && iwch > iwchFirstSnapped)
					{

	/* fix for the case when ModWidth was applied before snapping to grid.
		Changes to the right of the last character should be undone.
	*/
					lserr = UndoAppliedModWidth(pilsobj, rglschnk, itxtobjPrev, iwchPrev, sideRight, &durUndo);
					if (lserr != lserrNone) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserr);
					if (durUndo != 0)
						{
						urPen += durUndo;
						durPen += durUndo;
						}
	/* end of the fix due to ModWidth */

					urPenSnapped = CalcSnapped(urPen, urColumnMax, cGrid, durGridWhole, durGridRem);
					Assert(urPenSnapped - urPenFirstSnapped - durPen >= 0);

					lserr = ApplySnapChanges(pilsobj, rglschnk, iwchFirstSnapped, itxtobjFirstSnapped,
										iwchPrev, itxtobjPrev, urPenSnapped - urPenFirstSnapped - durPen);
					if (lserr != lserrNone) return CleanUpGrid(pilsobj,  rgplsrun, rgcp, rgfSnapped, lserr);

					durPen = 0;
					urPen = urPenSnapped;
					urPenFirstSnapped = urPenSnapped;
					iwchFirstSnapped = iwch;
					itxtobjFirstSnapped = itxtobjCur;

	/* fix for the case when ModWidth was applied before snapping to grid.
		Changes to the left of the first character should be undone.
	*/
					lserr = UndoAppliedModWidth(pilsobj, rglschnk, itxtobjCur, iwch, sideLeft, &durUndo);
					if (lserr != lserrNone) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserr);
					}

				urPen += pilsobj->pdur[iwch];
				durPen += pilsobj->pdur[iwch];
				iwchPrev = iwch;
				itxtobjPrev = itxtobjCur;
				}

			fFoundNextRun = GetNextImportantRun(cchnk, rglschnk, itxtobjCur + 1, &itxtobjCur);
			}

	/* fix for the case when ModWidth was applied before snapping to grid.
		Changes to the right of the last character should be undone.
	*/
		UndoAppliedModWidth(pilsobj, rglschnk, itxtobjPrev, iwchPrev, sideRight, &durUndo);
		if (lserr != lserrNone) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserr);
		if (durUndo != 0)
			{
			urPen += durUndo;
			durPen += durUndo;
			}
	/* end of the fix due to ModWidth */

		urPenSnapped = CalcSnapped(urPen, urColumnMax, cGrid, durGridWhole, durGridRem);
		Assert(urPenSnapped - urPenFirstSnapped - durPen >= 0);
		lserr = ApplySnapChanges(pilsobj, rglschnk, iwchFirstSnapped, itxtobjFirstSnapped,
								iwchPrev, itxtobjPrev, urPenSnapped - urPenFirstSnapped - durPen);
		if (lserr != lserrNone) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserr);
		}


	return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserrNone);
}

static LSERR UndoAppliedModWidth(PILSOBJ pilsobj, const LSCHNKE* rglschnk,
										long itxtobj, long iwch, BYTE side, long* pdurUndo)
{
	LSERR lserr;

	UndoAppliedChanges(pilsobj, iwch, side, pdurUndo);
	if (*pdurUndo != 0)
		{
		lserr = LsdnModifySimpleWidth(pilsobj->plsc, ((PTXTOBJ)rglschnk[itxtobj].pdobj)->plsdnUpNode, 
																					*pdurUndo);
		if (lserr != lserrNone) return lserr;

		pilsobj->ptxtinf[iwch].fModWidthOnRun = fFalse;
		pilsobj->ptxtinf[iwch].fModWidthSpace = fTrue;
		}

	return lserrNone;

}

static LSERR ApplySnapChanges(PILSOBJ pilsobj, const LSCHNKE* rglschnk, long iwchFirstSnapped,
					 long itxtobjFirstSnapped, long iwchLastSnapped, long itxtobjLastSnapped, long durTotal)
{
	LSERR lserr;
	long durSnapRight;
	long durSnapLeft;

	durSnapRight = durTotal >> 1;
	durSnapLeft = durTotal - durSnapRight;
	ApplyChanges(pilsobj, iwchFirstSnapped, sideLeft, durSnapLeft);
	lserr = LsdnModifySimpleWidth(pilsobj->plsc, ((PTXTOBJ)rglschnk[itxtobjFirstSnapped].pdobj)->plsdnUpNode, 
																				durSnapLeft);
	if (lserr != lserrNone) return lserr;

	ApplyChanges(pilsobj, iwchLastSnapped, sideRight, durSnapRight);
	lserr = LsdnModifySimpleWidth(pilsobj->plsc, ((PTXTOBJ)rglschnk[itxtobjLastSnapped].pdobj)->plsdnUpNode, 
																					durSnapRight);
	if (lserr != lserrNone) return lserr;

	return lserrNone;
}

static LSERR CleanUpGrid(PILSOBJ pilsobj, PLSRUN* rgplsrun, LSCP* rgcp, BOOL* rgfSnapped, 
																				LSERR lserr)
{
	if (rgplsrun != NULL)
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, rgplsrun);
	if (rgcp != NULL)
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, rgcp);
	if (rgfSnapped != NULL)
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, rgfSnapped);

	return lserr;

}

static long CalcSnapped(long urPen, long urColumnMax, long cGrid, long durGridWhole, long durGridRem)
{
	long idGrid;

	/* It is important to prove that idGrid-->urPenSnapped-->idGrid produces the same idGrid we started with.
	Here is the proof:
	idGrid-->urPenSnapped:	(idGrid * durGridWhole + durGridRem*idGrid/cGrid)---it is urPenSnapped

	urPenSnapped-->idGrid:

	(urPenSnapped * cGrid + urColumnMax - 1 ) / urColumnMax =
	((idGrid * durGridWhole + durGridRem*idGrid/cGrid) * cGrid + urColumnMax - 1) / urColumnMax =
	(idGrid * (urColumnMax - durGridRem) + durGridRem * idGrid + urColumnMax - 1) / urColumnMax =
	(idGrid * urColumnMax + urColumnMax - 1) / urColumnMax = idGrid

	It shows also that if one takes urPenSnapped + 1, result will be idGrid + 1 which is exactly correct
	*/

	if (urPen >= 0)
		idGrid = (urPen * cGrid + urColumnMax - 1 ) / urColumnMax;
	else
		idGrid = - ((-urPen * cGrid) / urColumnMax);

	return idGrid * durGridWhole + durGridRem * idGrid / cGrid;

}


#define cwchShapedTogetherMax	0x7FFF

/* Glyph-related activities */

static LSERR ApplyGlyphs(LSTFLOW lstflow, DWORD cchnk, const LSCHNKE* rglschnk)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long itxtobj;
	long itxtobjFirst;
	long itxtobjLast;
	BOOL fInterruptShaping;
	long iwchFirstGlobal;
	long iwchLimGlobal;

	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;

	itxtobj = 0;
	while (itxtobj < (long)cchnk && !(((PTXTOBJ)rglschnk[itxtobj].pdobj)->txtf & txtfGlyphBased))
		itxtobj++;

/* Following Assert is surprisingly wrong, counterexample: glyph-based EOP and nothing else on the line */
/*	Assert(itxtobj < (long)cchnk); */

	while (itxtobj < (long)cchnk)
		{
		itxtobjFirst = itxtobj;
		iwchFirstGlobal = ((PTXTOBJ)rglschnk[itxtobjFirst].pdobj)->iwchFirst;

		iwchLimGlobal = ((PTXTOBJ)rglschnk[itxtobj].pdobj)->iwchLim;
		Assert(iwchLimGlobal - iwchFirstGlobal < cwchShapedTogetherMax);

		itxtobj++;
		fInterruptShaping = fFalse;

		if (itxtobj < (long)cchnk)
			iwchLimGlobal = ((PTXTOBJ)rglschnk[itxtobj].pdobj)->iwchLim;


		while (iwchLimGlobal - iwchFirstGlobal < cwchShapedTogetherMax && 
						!fInterruptShaping && itxtobj < (long)cchnk && 
						(((PTXTOBJ)rglschnk[itxtobj].pdobj)->txtf & txtfGlyphBased))
			{
			lserr = (*pilsobj->plscbk->pfnFInterruptShaping)(pilsobj->pols, lstflow,
					 rglschnk[itxtobj-1].plsrun, rglschnk[itxtobj].plsrun, &fInterruptShaping);
			if (lserr != lserrNone) return lserr;
	
			if (!fInterruptShaping)
				itxtobj++;

			if (itxtobj < (long)cchnk)
				iwchLimGlobal = ((PTXTOBJ)rglschnk[itxtobj].pdobj)->iwchLim;
			}
	
		itxtobjLast = itxtobj - 1;

		lserr = ApplyGlyphsToRange(lstflow, rglschnk, itxtobjFirst, itxtobjLast);
		if (lserr != lserrNone) return lserr;

		while (itxtobj < (long)cchnk && !(((PTXTOBJ)rglschnk[itxtobj].pdobj)->txtf & txtfGlyphBased))
			itxtobj++;

		}

	return lserrNone;
}

static LSERR ApplyGlyphsToRange(LSTFLOW lstflow, const LSCHNKE* rglschnk, long itxtobjFirst, long itxtobjLast)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobjFirst;
	PTXTOBJ ptxtobjLast;
	PLSRUN plsrun;
	long iwchFirstGlobal;
	long iwchLimGlobal;
	GINDEX* pgindex;
	PGPROP pgprop;
	DWORD cgind;
	long igindFirst;

	ptxtobjFirst = (PTXTOBJ)rglschnk[itxtobjFirst].pdobj;
	ptxtobjLast = (PTXTOBJ)rglschnk[itxtobjLast].pdobj;

	plnobj = ptxtobjFirst->plnobj;
	pilsobj = plnobj->pilsobj;

	iwchFirstGlobal = ptxtobjFirst->iwchFirst;
	iwchLimGlobal = ptxtobjLast->iwchLim;

	plsrun = rglschnk[itxtobjFirst].plsrun;
	
	lserr = (*pilsobj->plscbk->pfnGetGlyphs)(pilsobj->pols, plsrun, &pilsobj->pwchOrig[iwchFirstGlobal],
								iwchLimGlobal - iwchFirstGlobal, lstflow,
								&plnobj->pgmap[iwchFirstGlobal], &pgindex, &pgprop, &cgind);
	if (lserr != lserrNone) return lserr;

	lserr = CheckReallocGlyphs(plnobj, cgind);
	if (lserr != lserrNone) return lserr;

	CopyGindices(plnobj, pgindex, pgprop, cgind, &igindFirst);

	lserr = (*pilsobj->plscbk->pfnGetGlyphPositions)(pilsobj->pols, plsrun, lsdevReference, &pilsobj->pwchOrig[iwchFirstGlobal],
				&plnobj->pgmap[iwchFirstGlobal], iwchLimGlobal - iwchFirstGlobal,
				&plnobj->pgind[igindFirst], &plnobj->pgprop[igindFirst], cgind, lstflow,
				(int*)&pilsobj->pdurGind[igindFirst], &plnobj->pgoffs[igindFirst]);
	if (lserr != lserrNone) return lserr;


	if (pilsobj->fDisplay)
		{
		if (!pilsobj->fPresEqualRef)
			{
			lserr = (*pilsobj->plscbk->pfnGetGlyphPositions)(pilsobj->pols, plsrun, lsdevPres, &pilsobj->pwchOrig[iwchFirstGlobal],
				&plnobj->pgmap[iwchFirstGlobal], iwchLimGlobal - iwchFirstGlobal,
				&plnobj->pgind[igindFirst], &plnobj->pgprop[igindFirst], cgind, lstflow,
				(int*)&plnobj->pdupGind[igindFirst], &plnobj->pgoffs[igindFirst]);
			if (lserr != lserrNone) return lserr;
			}
/* ScaleSides will take care of the following memcpy */
//		else
//			memcpy (&plnobj->pdupGind[igindFirst], &pilsobj->pdurGind[igindFirst], sizeof(long)*cgind);
		}

	InterpretMap(plnobj, iwchFirstGlobal, iwchLimGlobal - iwchFirstGlobal, igindFirst, cgind);

	Assert(plnobj->pgmap[iwchFirstGlobal] == 0);

	if (pilsobj->fDisplay && (pilsobj->grpf & fTxtVisiSpaces) && rglschnk[itxtobjFirst].cpFirst >= 0)
		{
		FixGlyphSpaces(lstflow, rglschnk, itxtobjFirst, igindFirst, itxtobjLast);
		}

	lserr = FixTxtobjs(rglschnk, itxtobjFirst, igindFirst, itxtobjLast);
	if (lserr != lserrNone) return lserr;

	ptxtobjFirst->txtf |= txtfFirstShaping;

	while (ptxtobjLast->iwchLim == ptxtobjLast->iwchFirst)
		{
		itxtobjLast--;
		Assert (itxtobjLast >= itxtobjFirst);
		ptxtobjLast = (PTXTOBJ)rglschnk[itxtobjLast].pdobj;
		}

	ptxtobjLast->txtf |= txtfLastShaping;

	return lserrNone;
}

static LSERR FixTxtobjs(const LSCHNKE* rglschnk, long itxtobjFirst, long igindVeryFirst, long itxtobjLast)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long itxtobj;
	long iwchFirst;
	long iwchLast;
	long dcpFirst;
	long durTotal;
	long iwSpacesVeryLim;
	long iwSpacesFirst;
	long iwSpacesLim;
	int igind;

	pilsobj = ((PTXTOBJ)rglschnk[itxtobjFirst].pdobj)->plnobj->pilsobj;
	iwchFirst = ((PTXTOBJ)rglschnk[itxtobjFirst].pdobj)->iwchFirst;

	iwSpacesVeryLim = ((PTXTOBJ)rglschnk[itxtobjLast].pdobj)->u.reg.iwSpacesLim;

	for (itxtobj = itxtobjFirst; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
		Assert(ptxtobj->txtkind == txtkindRegular);
		Assert((long)rglschnk[itxtobj].dcp == ptxtobj->iwchLim - ptxtobj->iwchFirst);
		dcpFirst = iwchFirst - ptxtobj->iwchFirst;
		Assert(dcpFirst >= 0);
		ptxtobj->iwchFirst = iwchFirst;
		iwchLast = ptxtobj->iwchLim - 1;
		if (iwchLast < iwchFirst)
			{
			ptxtobj->iwchLim = iwchFirst;
			ptxtobj->u.reg.iwSpacesLim = ptxtobj->u.reg.iwSpacesFirst;

			Assert(itxtobj > itxtobjFirst);
			ptxtobj->igindFirst = ((PTXTOBJ)rglschnk[itxtobj-1].pdobj)->iwchLim;
			ptxtobj->igindLim = ptxtobj->igindFirst;

			lserr = LsdnSetSimpleWidth(pilsobj->plsc, ptxtobj->plsdnUpNode, 0);
			if (lserr != lserrNone) return lserr;

			lserr = LsdnResetDcpMerge(pilsobj->plsc, 
										ptxtobj->plsdnUpNode, rglschnk[itxtobj].cpFirst + dcpFirst, 0);
			if (lserr != lserrNone) return lserr;

			/* It would be cleaner to mark these dobj's by another flag, but is it 
			worth to introduce one?
			*/
			ptxtobj->txtf |= txtfSkipAtNti;

			}
		else
			{
			while (!pilsobj->ptxtinf[iwchLast].fLastInContext)
				iwchLast++;
			Assert(iwchLast < (long)pilsobj->wchMac);

			ptxtobj->iwchLim = iwchLast + 1;

			lserr = LsdnResetDcpMerge(pilsobj->plsc, ptxtobj->plsdnUpNode, rglschnk[itxtobj].cpFirst + dcpFirst, iwchLast + 1 - iwchFirst);
			if (lserr != lserrNone) return lserr;

			Assert (iwchFirst == ptxtobj->iwchFirst);
			Assert (FIwchFirstInContext (pilsobj, iwchFirst));
			Assert (FIwchLastInContext (pilsobj, iwchLast));

			ptxtobj->igindFirst = IgindFirstFromIwchVeryFirst (ptxtobj, igindVeryFirst, iwchFirst);
			ptxtobj->igindLim = IgindLastFromIwchVeryFirst (ptxtobj, igindVeryFirst, iwchLast) + 1;

			durTotal = 0;
			for (igind = ptxtobj->igindFirst; igind < ptxtobj->igindLim; igind++)
				durTotal += pilsobj->pdurGind[igind];

			lserr = LsdnSetSimpleWidth(pilsobj->plsc, ptxtobj->plsdnUpNode, durTotal);
			if (lserr != lserrNone) return lserr;

			iwSpacesFirst = ptxtobj->u.reg.iwSpacesFirst;
			iwSpacesLim = ptxtobj->u.reg.iwSpacesLim;

			while (iwSpacesLim < iwSpacesVeryLim && pilsobj->pwSpaces[iwSpacesLim] < ptxtobj->iwchLim)
				{
				iwSpacesLim++;
				}

			while (iwSpacesFirst < iwSpacesLim && pilsobj->pwSpaces[iwSpacesFirst] < ptxtobj->iwchFirst)
				{
				iwSpacesFirst++;
				}

			ptxtobj->u.reg.iwSpacesFirst = iwSpacesFirst;
			ptxtobj->u.reg.iwSpacesLim = iwSpacesLim;

			iwchFirst = ptxtobj->iwchLim;
			}
		}

	return lserrNone;
}

static LSERR CheckReallocGlyphs(PLNOBJ plnobj, long cglyphs)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long igindLocalStart;
	long cNew;
	void* pTemp;

	pilsobj = plnobj->pilsobj;

	igindLocalStart = pilsobj->gindMac;


	if (plnobj->pgmap == NULL)
		{
		pTemp = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(GMAP) * pilsobj->wchMax );
		if (pTemp == NULL) return lserrOutOfMemory;

		plnobj->pgmap = pTemp;
		}

	if ( igindLocalStart + cglyphs <= (long)pilsobj->gindMax - 2)
		{
		return lserrNone;
		}
	else
		{
		cNew = gindAddM + pilsobj->gindMax;
		if (cNew - 2 < igindLocalStart + cglyphs)
			{
			cNew = igindLocalStart + cglyphs + 2;
			}
		lserr = Realloc(pilsobj, &pilsobj->pdurGind, sizeof(long) * cNew);
		if (lserr != lserrNone) return lserr;
		lserr = Realloc(pilsobj, &pilsobj->pginf, sizeof(TXTGINF) * cNew);
		if (lserr != lserrNone) return lserr;
		lserr = Realloc(pilsobj, &pilsobj->pduGright, sizeof(long) * cNew);
		if (lserr != lserrNone) return lserr;
		lserr = Realloc(pilsobj, &pilsobj->plsexpinf, sizeof(LSEXPINFO) * cNew);
		if (lserr != lserrNone) return lserr;

		lserr = Realloc(pilsobj, &plnobj->pgind, sizeof(GINDEX) * cNew);
		if (lserr != lserrNone) return lserr;
		lserr = Realloc(pilsobj, &plnobj->pdupGind, sizeof(long) * cNew);
		if (lserr != lserrNone) return lserr;
		lserr = Realloc(pilsobj, &plnobj->pgoffs, sizeof(GOFFSET) * cNew);
		if (lserr != lserrNone) return lserr;
		lserr = Realloc(pilsobj, &plnobj->pexpt, sizeof(EXPTYPE) * cNew);
		if (lserr != lserrNone) return lserr;
		lserr = Realloc(pilsobj, &plnobj->pdupBeforeJust, sizeof(long) * cNew);
		if (lserr != lserrNone) return lserr;
		lserr = Realloc(pilsobj, &plnobj->pgprop, sizeof(GPROP) * cNew);
		if (lserr != lserrNone) return lserr;
	
		memset(&pilsobj->plsexpinf[pilsobj->gindMax], 0, sizeof(LSEXPINFO) * (cNew - pilsobj->gindMax) );
		memset(&pilsobj->pduGright[pilsobj->gindMax], 0, sizeof(long) * (cNew - pilsobj->gindMax) );
		memset(&plnobj->pexpt[pilsobj->gindMax], 0, sizeof(EXPTYPE) * (cNew - pilsobj->gindMax) );
		pilsobj->gindMax = cNew;
		plnobj->gindMax = cNew;
		}

	return lserrNone;
}

static LSERR Realloc(PILSOBJ pilsobj, void** pInOut, long cbytes)
{
	void* pTemp;

	if (*pInOut == NULL)
		pTemp = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, cbytes );
	else
		pTemp = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, *pInOut, cbytes );

	if (pTemp == NULL)
		{
		return lserrOutOfMemory;
		}
	
	*pInOut = pTemp;

	return lserrNone;
	
}

static void	CopyGindices(PLNOBJ plnobj, GINDEX* pgindex, PGPROP pgprop, long cgind, long* pigindFirst)
{
	*pigindFirst = plnobj->pilsobj->gindMac;
	memcpy(&plnobj->pgind[*pigindFirst], pgindex, sizeof(GINDEX) * cgind);
	memcpy(&plnobj->pgprop[*pigindFirst], pgprop, sizeof(GPROP) * cgind);

	plnobj->pilsobj->gindMac += cgind;
}

/* F I X  G L Y P H  S P A C E S */
/*----------------------------------------------------------------------------
    %%Function: FixGlyphSpaces
    %%Contact: sergeyge
	
	Fixes space glyph index for the Visi Spaces situation
----------------------------------------------------------------------------*/
static LSERR FixGlyphSpaces(LSTFLOW lstflow, const LSCHNKE* rglschnk,
									long itxtobjFirst, long igindVeryFirst, long itxtobjLast)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	long itxtobj;
	long iwSpace;
	long iwch;

	GMAP gmapTemp;
	GINDEX* pgindTemp;
	GPROP* pgpropTemp;
	DWORD cgind;

	plnobj = ((PTXTOBJ)rglschnk[itxtobjFirst].pdobj)->plnobj;
	pilsobj = plnobj->pilsobj;

	lserr = (*pilsobj->plscbk->pfnGetGlyphs)(pilsobj->pols, rglschnk[itxtobjFirst].plsrun, 
							&pilsobj->wchVisiSpace, 1, lstflow, &gmapTemp, &pgindTemp, &pgpropTemp, &cgind);
	if (lserr != lserrNone) return lserr;

	if (cgind != 1)
		{
		return lserrNone;
		}

	for (itxtobj=itxtobjFirst; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
		Assert(ptxtobj->txtkind == txtkindRegular);
		for (iwSpace = ptxtobj->u.reg.iwSpacesFirst; iwSpace < ptxtobj->u.reg.iwSpacesLim; iwSpace++)
			{
			iwch = pilsobj->pwSpaces[iwSpace];
			if ( FIwchOneToOne(pilsobj, iwch) )
				plnobj->pgind[IgindFirstFromIwchVeryFirst (ptxtobj, igindVeryFirst, iwch)] = *pgindTemp;
			}
		}

	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lstxtcmp.c ===
#include "lsmem.h"

#include "lstxtcmp.h"
#include "lstxtmod.h"
#include "lstxtmap.h"

#include "lschp.h"
#include "lspract.h"
#include "lsems.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"

#define min(a,b)     ((a) > (b) ? (b) : (a))
#define max(a,b)     ((a) < (b) ? (b) : (a))

typedef struct
{
	long rgdurPrior[2];
	long rgcExpPrior[2];
	long cExpOppr;
} EXPINFO;

typedef struct
{
	long durComp;
	long cCompOppr;
} COMPINFO;


static LSERR GetExpandInfo(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, BOOL fScaled,
					 long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLim,	EXPINFO* pexpinfo);
static void GetCompressInfo(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchFirst, 
											long itxtobjLast, long iwchLim, COMPINFO* pcompinfo);
static LSERR CheckExpandSpace(PILSOBJ pilsobj, LSEMS* plsems, long iwchPrev, long iwch, long iwchNext,
							PTXTOBJ ptxtobjCur, PLSRUN plsrunPrev, PLSRUN plsrunCur, PLSRUN plsrunNext,
							BOOL* pfExpandOpp, long* pdurChange);
static LSERR CheckExpandOnRun(PILSOBJ pilsobj, LSEMS* plsems, long iwch, long iwchNext, PTXTOBJ ptxtobjCur,
							PLSRUN plsrunCur, PLSRUN plsrunNext, BOOL* pfExpandOpp, long* pdurChange);
static void ApplyPriorCompression(const LSGRCHNK* plsgrchnk,  long itxtobjFirst, long iwchFirst,
									long itxtobjLast, long iwchLim, BYTE prior,
									long durToCompress, long durAvailable, long cExpOppr);
static void ApplyPriorExpansion(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchFirst,
			 long txtobjLast, long iwchLim, BYTE prior, long durToExpand, long durAvailable, long cExpOppr);
static void ApplyFullExpansion(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchFirst,
		long itxtobjLast, long iwchLim, long durToExpand, long cExpOppr, long cNonText, long* pdurNonText);
static LSERR CheckCompSpace(PILSOBJ pilsobj, LSEMS* plsems, long iwchPrev, long iwch, long iwchNext,
			PTXTOBJ ptxtobjCur, PLSRUN plsrunPrev, PLSRUN plsrunCur, PLSRUN plsrunNext, long* pdurChange);
static LSERR CheckCompOnRun(PILSOBJ pilsobj, LSEMS* plsems, long iwch, long iwchNext, PTXTOBJ ptxtobjCur,
							PLSRUN plsrunCur, PLSRUN plsrunNext, long* pdurChange);
static void SetComp(PILSOBJ pilsobj, long iwch, BYTE prior, BYTE side, long durChange);
static BOOL GetNextRun(const LSGRCHNK* plsgrchnk, long itxtobj, long* pitxtobjNext);
static void GetPrevCharRun(const LSGRCHNK* plsgrchnk, long itxtobj, long iwch, long* piwchPrev, PLSRUN* pplsrunPrev);

/* F E T C H  C O M P R E S S  I N F O */
/*----------------------------------------------------------------------------
    %%Function: FetchCompressInfo
    %%Contact: sergeyge

	Fetches compression information until durCompressMaxStop exceeded
---------------------------------------------------------------------------*/
LSERR FetchCompressInfo(const LSGRCHNK* plsgrchnk, BOOL fFirstOnLine, LSTFLOW lstflow, 
						long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLim,
						long durCompressMaxStop, long* pdurCompressTotal)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	TXTINF* rgtxtinf;
	WCHAR* rgwchOrig;
	PTXTOBJ ptxtobj;
	PLSRUN plsrunCur;
	PLSRUN plsrunPrev;
	PLSRUN plsrunNext = NULL;
	PCLSCHP plschp;
	LSPRACT lspract;
	BYTE side;
	BYTE sideFinal;
	long durChange;
	long durTemp;
	LSEMS lsems;
	BOOL fNextAdjacentFound;
	long itxtobj;
	long itxtobjNext;
	long itxtobjLastProcessed;
	long itxtobjCompressFetchedLim;
	long iwchCompressFetchedLim;
	long iwchLimDobj;
	long iwch;
	long iwchPrev;
	long iwchNext;
	BOOL fGlyphBased;

	*pdurCompressTotal = 0;

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	rgtxtinf = pilsobj->ptxtinf;
	/* rgtxtinf == NULL means that there were no runs which possibly could introduce compress opportunity */
	if (rgtxtinf == NULL)
		return lserrNone;

	iwch = iwchFirst;

	rgwchOrig = pilsobj->pwchOrig;

	itxtobjCompressFetchedLim = 0;
	iwchCompressFetchedLim = 0;
	
	if (pilsobj->iwchCompressFetchedFirst == iwchFirst)
		{
		itxtobjCompressFetchedLim = pilsobj->itxtobjCompressFetchedLim;
		iwchCompressFetchedLim = pilsobj->iwchCompressFetchedLim;
		}

	itxtobj = itxtobjFirst;
	itxtobjLastProcessed = itxtobj-1;

	if (itxtobj < (long)plsgrchnk->clsgrchnk)
		GetNextRun(plsgrchnk, itxtobj, &itxtobj);

	Assert( itxtobj == (long)plsgrchnk->clsgrchnk || 
			((PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj)->iwchLim >
			((PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj)->iwchFirst);

	while(itxtobj <= itxtobjLast && *pdurCompressTotal < durCompressMaxStop)
		{
		itxtobjLastProcessed = itxtobj;

		fNextAdjacentFound = GetNextRun(plsgrchnk, itxtobj + 1, &itxtobjNext);

		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		plsrunCur = plsgrchnk->plschnk[itxtobj].plsrun;
		plschp = plsgrchnk->plschnk[itxtobj].plschp;

		iwchLimDobj = iwchLim;
		if (itxtobj < itxtobjLast)
			iwchLimDobj = ptxtobj->iwchLim;

		if (itxtobj > itxtobjCompressFetchedLim - 1 ||
			itxtobj == itxtobjCompressFetchedLim - 1 && iwchLimDobj > iwchCompressFetchedLim)
			{
			lserr = (*pilsobj->plscbk->pfnGetEms)(pilsobj->pols, plsrunCur, lstflow, &lsems);
			if (lserr != lserrNone) return lserr;
			}

		iwch = iwchFirst;
		if (itxtobj > itxtobjFirst)
			iwch = ptxtobj->iwchFirst;

		for (; iwch < iwchLimDobj && *pdurCompressTotal < durCompressMaxStop; iwch++)
			{
			if (itxtobj < itxtobjCompressFetchedLim - 1 || 
					itxtobj == itxtobjCompressFetchedLim - 1 && iwch < iwchCompressFetchedLim)
				{
				if (rgtxtinf[iwch].prior != prior0)
					*pdurCompressTotal -= pilsobj->pduAdjust[iwch];
				}
			else
				{

				fGlyphBased = (ptxtobj->txtf & txtfGlyphBased);
				rgtxtinf[iwch].prior = prior0;
	
				if (!fGlyphBased && plschp->fCompressTable && !rgtxtinf[iwch].fModWidthOnRun && 
																		!rgtxtinf[iwch].fModWidthSpace)
					{
					lspract = pilsobj->plspract[pilsobj->pilspract[rgtxtinf[iwch].mwcls]];
					Assert(lspract.prior <= pilsobj->cCompPrior);
					if (lspract.prior != prior0)
						{
						GetChanges(lspract.lsact, &lsems, pilsobj->pdur[iwch] - pilsobj->pdurRight[iwch] - pilsobj->pdurLeft[iwch],
																			fFalse, &side, &durTemp);
						TranslateChanges(side, durTemp, pilsobj->pdur[iwch], pilsobj->pdurRight[iwch], pilsobj->pdurLeft[iwch],
															 &sideFinal, &durChange);
						if (sideFinal != sideNone && durChange < 0)
							{
							if (itxtobj > itxtobjFirst || itxtobj == itxtobjFirst && iwch > iwchFirst ||
									 !fFirstOnLine || sideFinal != sideLeft)
								{
								SetComp(pilsobj, iwch, lspract.prior, sideFinal, durChange);
								*pdurCompressTotal -= durChange;
								}
							}
						}
					}

				if (rgwchOrig[iwch] == pilsobj->wchSpace && plschp->fCompressSpace &&
					rgtxtinf[iwch].prior == prior0 && (!fGlyphBased || FIwchOneToOne(pilsobj, iwch)))
					{
					plsrunNext = NULL;
					iwchNext = 0;
					/* we take ptxtobj->iwchLim instead of iwchLimDobj because iwchLimDobj char(last char
						before spaces on the line must be used for context considerations
					*/ 
					if (iwch < ptxtobj->iwchLim - 1)
						{
						plsrunNext = plsrunCur;
						iwchNext = iwch + 1;
						}
					else if (fNextAdjacentFound)
						{
						plsrunNext = plsgrchnk->plschnk[itxtobjNext].plsrun;
						iwchNext = ((PTXTOBJ)plsgrchnk->plschnk[itxtobjNext].pdobj)->iwchFirst;
						}
			
					GetPrevCharRun(plsgrchnk, itxtobj, iwch, &iwchPrev, &plsrunPrev);

					lserr = CheckCompSpace(pilsobj, &lsems, iwchPrev, iwch, iwchNext, ptxtobj,
													plsrunPrev, plsrunCur, plsrunNext, &durChange);
					if (lserr != lserrNone) return lserr;
	
					*pdurCompressTotal -= durChange;

					}

				if (iwch == ptxtobj->iwchLim - 1 && plschp->fCompressOnRun && fNextAdjacentFound && 
									rgtxtinf[iwch].prior == prior0)
					{
					plsrunNext = plsgrchnk->plschnk[itxtobjNext].plsrun;
					iwchNext = ((PTXTOBJ)plsgrchnk->plschnk[itxtobjNext].pdobj)->iwchFirst;
					lserr = CheckCompOnRun(pilsobj, &lsems, iwch, iwchNext, ptxtobj, plsrunCur, plsrunNext, &durChange);
					if (lserr != lserrNone) return lserr;
					*pdurCompressTotal -= durChange;
					}
				}

			}

		itxtobj = itxtobjNext;

		}

	pilsobj->iwchCompressFetchedFirst = iwchFirst;
	pilsobj->itxtobjCompressFetchedLim = itxtobjLastProcessed + 1;
	pilsobj->iwchCompressFetchedLim = min(iwch, iwchLim);

	return lserrNone;
}

/* G E T  C O M P  L A S T  C H A R  I N F O */
/*----------------------------------------------------------------------------
    %%Function: GetCompLastCharInfo
    %%Contact: sergeyge

---------------------------------------------------------------------------*/
void GetCompLastCharInfo(PILSOBJ pilsobj, long iwchLast, MWCLS* pmwcls,
														long* pdurCompRight, long* pdurCompLeft)
{
	/* Strong assumption for this function is that it is not called on GlyphBased run */
	TXTINF txtinf;
	
	*pdurCompRight = 0;
	*pdurCompLeft = 0;

	/* ptxtinf == NULL means that there were no runs which possibly can introduce compress opportunity */
	if (pilsobj->ptxtinf == NULL)
		return;

	txtinf = pilsobj->ptxtinf[iwchLast];

	*pmwcls = (MWCLS)txtinf.mwcls;

	if (txtinf.prior != prior0)
		{
		InterpretChanges(pilsobj, iwchLast, (BYTE)txtinf.side, pilsobj->pduAdjust[iwchLast], pdurCompLeft, pdurCompRight);
		Assert(pilsobj->pduAdjust[iwchLast] == *pdurCompLeft + *pdurCompRight);
		}

	*pdurCompLeft = - *pdurCompLeft;
	*pdurCompRight = - *pdurCompRight;
}

/* C O M P R E S S  L A S T  C H A R  R I G H T */
/*----------------------------------------------------------------------------
    %%Function: CompressLastCharRight
    %%Contact: sergeyge

---------------------------------------------------------------------------*/
void CompressLastCharRight(PILSOBJ pilsobj, long iwchLast, long durToAdjustRight)
{
	/* Strong assumption for this function is that it is not called on GlyphBased run */
	pilsobj->pdur[iwchLast] -= durToAdjustRight;

	Assert(pilsobj->pdurRight != NULL);
	Assert(pilsobj->pdurLeft != NULL);
	Assert(pilsobj->ptxtinf != NULL);

	pilsobj->pdurRight[iwchLast] -= durToAdjustRight;

	if (durToAdjustRight > 0 && pilsobj->ptxtinf[iwchLast].prior != prior0)
		{
		if (pilsobj->ptxtinf[iwchLast].side == sideRight)
			{
			pilsobj->ptxtinf[iwchLast].prior = prior0;
			pilsobj->pduAdjust[iwchLast] = 0;
			}
		else if (pilsobj->ptxtinf[iwchLast].side == sideLeftRight)
			{
			pilsobj->ptxtinf[iwchLast].side = sideLeft;
			pilsobj->pduAdjust[iwchLast] += durToAdjustRight;
			}
		else
			{
			Assert(fFalse);
			}
		}
}


/* A P P L Y  C O M P R E S S */
/*----------------------------------------------------------------------------
    %%Function: ApplyCompress
    %%Contact: sergeyge

	Applies prioratized compression
---------------------------------------------------------------------------*/
LSERR ApplyCompress(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, 
				long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLim, long durToCompress)
{
	PILSOBJ pilsobj;
	COMPINFO rgcompinfo[5];
	COMPINFO* pcompinfo;
	BOOL fReleasePcompinfo;
	long i;
	
	Unreferenced(lstflow);	
	
	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	fReleasePcompinfo = fFalse;
	pcompinfo = rgcompinfo;
	if (pilsobj->cCompPrior > 5)
		{
		pcompinfo = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(COMPINFO) * pilsobj->cCompPrior);
		if (pcompinfo == NULL)
			 return lserrOutOfMemory;
		else
			fReleasePcompinfo = fTrue;
		}

	GetCompressInfo(plsgrchnk, itxtobjFirst, iwchFirst, itxtobjLast, iwchLim, pcompinfo);

	for (i = 0; i < (long)pilsobj->cCompPrior && durToCompress > 0; i++)
		{
		if (pcompinfo[i].cCompOppr > 0)
			{
			ApplyPriorCompression(plsgrchnk, itxtobjFirst, iwchFirst, itxtobjLast, iwchLim, (BYTE)(i+1), durToCompress,
											pcompinfo[i].durComp, pcompinfo[i].cCompOppr);
			durToCompress -= pcompinfo[i].durComp;
			}
		}

	/* Following Assert is not compatible with the squeezing mode */
	/*Assert(durToCompress <= 0);*/

	if (fReleasePcompinfo)
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pcompinfo);

	return lserrNone;
}

/* A P P L Y  E X P A N D */
/*----------------------------------------------------------------------------
    %%Function: ApplyExpand
    %%Contact: sergeyge

	Applies prioratized expansion
---------------------------------------------------------------------------*/

LSERR ApplyExpand(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, BOOL fScaled,	long itxtobjFirst, long iwchFirst,
					 long itxtobjLast, long iwchLim, DWORD cNonTextObjects, long durToExpand,
					 long* pdurExtNonText, BOOL* pfFinalAdjustNeeded)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	EXPINFO expinfo;
	long i;

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	*pdurExtNonText = 0;

	lserr = GetExpandInfo(plsgrchnk, lstflow, fScaled, itxtobjFirst, iwchFirst, itxtobjLast, iwchLim, &expinfo);
	if (lserr != lserrNone) return lserr;

	for (i = 0; i < 2 && durToExpand > 0; i++)
		{
		if (expinfo.rgcExpPrior[i])
			{
			ApplyPriorExpansion(plsgrchnk, itxtobjFirst, iwchFirst, itxtobjLast, iwchLim, (BYTE)(i+1), durToExpand,
											expinfo.rgdurPrior[i], expinfo.rgcExpPrior[i]);
			durToExpand -= expinfo.rgdurPrior[i];
			}
		}

	if (durToExpand > 0)
		{
		ApplyFullExpansion(plsgrchnk, itxtobjFirst, iwchFirst, itxtobjLast, iwchLim, durToExpand,
									expinfo.cExpOppr, cNonTextObjects, pdurExtNonText);

		}

	*pfFinalAdjustNeeded = (expinfo.cExpOppr + cNonTextObjects > 0);

	return lserrNone;
}

/* A P P L Y  D I S T R I B U T I O N */
/*----------------------------------------------------------------------------
    %%Function: ApplyDistribution
    %%Contact: sergeyge

	Applies equal distribution to text chunk
---------------------------------------------------------------------------*/
void ApplyDistribution(const LSGRCHNK* plsgrchnk, DWORD cNonText,
									   long durToDistribute, long* pdurNonTextObjects)
{
	PILSOBJ pilsobj;
	long clschnk;
	PTXTOBJ ptxtobj;
	long itxtobj;
	long iwchFirst;
	long iwchLim;
	long iwch;
	long igind;
	long durToAdd;
	long cwchToDistribute;
	long cwchToDistributeAll;
	long wdurBound;
	long iwchUsed;

	clschnk = (long)plsgrchnk->clsgrchnk;
	Assert(clschnk > 0);

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	cwchToDistribute = 0;


	for (itxtobj = 0; itxtobj < clschnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		iwchFirst = ptxtobj->iwchFirst;
		iwchLim = iwchFirst + plsgrchnk->plschnk[itxtobj].dcp;
		if (itxtobj == clschnk - 1)
			iwchLim--;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			for (iwch = iwchFirst; iwch < iwchLim; iwch++)
				{
				if (FIwchLastInContext(pilsobj, iwch))
					cwchToDistribute++;
				}
			}
		else
			cwchToDistribute += (iwchLim - iwchFirst);
		}		

	cwchToDistributeAll = cwchToDistribute + cNonText;

	*pdurNonTextObjects = 0;
	
	if (cwchToDistributeAll == 0)
		return;

	*pdurNonTextObjects = durToDistribute * cNonText / cwchToDistributeAll;

	durToDistribute -= *pdurNonTextObjects;

	if (cwchToDistribute == 0)
		return;

	durToAdd = durToDistribute / cwchToDistribute;
	wdurBound = durToDistribute - durToAdd * cwchToDistribute;

	iwchUsed = 0;

	for (itxtobj = 0; itxtobj < clschnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		iwchFirst = ptxtobj->iwchFirst;
		iwchLim = iwchFirst + plsgrchnk->plschnk[itxtobj].dcp;
		if (itxtobj == clschnk - 1)
			iwchLim--;

		if (ptxtobj->txtf & txtfGlyphBased)
			{
			for (iwch = iwchFirst; iwch < iwchLim; iwch++)
				{
				if (FIwchLastInContext(pilsobj, iwch))
					{
					igind = IgindLastFromIwch(ptxtobj, iwch);
					igind = IgindBaseFromIgind(pilsobj, igind);
					if (iwchUsed < wdurBound)
						{
						ApplyGlyphChanges(pilsobj, igind, durToAdd + 1);
						}
					else
						{
						ApplyGlyphChanges(pilsobj, igind, durToAdd);
						}
					iwchUsed++;
					}
				}
			}
		else
			{
			for (iwch = iwchFirst; iwch < iwchLim; iwch++)
				{
				if (iwchUsed < wdurBound)
					{
					ApplyChanges(pilsobj, iwch, sideRight, durToAdd + 1);
					}
				else
					{
					ApplyChanges(pilsobj, iwch, sideRight, durToAdd);
					}
				iwchUsed++;
				}
			}
		}
}

/* Internal functions implementation */

/* G E T  E X P A N D  I N F O */
/*----------------------------------------------------------------------------
    %%Function: GetExpandInfo
    %%Contact: sergeyge

	Collects expansion information
---------------------------------------------------------------------------*/
static LSERR GetExpandInfo(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, BOOL fScaled,
					 long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLim,	EXPINFO* pexpinfo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	TXTINF* rgtxtinf;
	WCHAR* rgwchOrig;
	PTXTOBJ ptxtobj;
	PLSRUN plsrunCur;
	PLSRUN plsrunPrev;
	PLSRUN plsrunNext;
	PCLSCHP plschp;
	long durChange;
	LSEMS lsems;
	BOOL fNextAdjacentFound;
	long itxtobj;
	long itxtobjNext;
	long iwchLimDobj;
	LSEXPAN lsexpan;
	long iwch;
	long iwchPrev;
	long iwchNext;
	BOOL fExpandOpp;
	BOOL fGlyphBased;

	memset(pexpinfo, 0, sizeof(EXPINFO));

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	rgtxtinf = pilsobj->ptxtinf;
	/* rgtxtinf == NULL means that there were no runs which possibly can introduce expansion opportunity */
	if (rgtxtinf == NULL)
		return lserrNone;

	rgwchOrig = pilsobj->pwchOrig;

	itxtobj = itxtobjFirst;

	if (itxtobj < (long)plsgrchnk->clsgrchnk)
		GetNextRun(plsgrchnk, itxtobj, &itxtobj);

	Assert(itxtobj == (long)plsgrchnk->clsgrchnk ||
			((PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj)->iwchLim >
			((PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj)->iwchFirst);

	while(itxtobj <= itxtobjLast)
		{
		fNextAdjacentFound = GetNextRun(plsgrchnk, itxtobj + 1, &itxtobjNext);

		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		fGlyphBased = (ptxtobj->txtf & txtfGlyphBased);
		plsrunCur = plsgrchnk->plschnk[itxtobj].plsrun;
		plschp = plsgrchnk->plschnk[itxtobj].plschp;

		lserr = (*pilsobj->plscbk->pfnGetEms)(pilsobj->pols, plsrunCur, lstflow, &lsems);
		if (lserr != lserrNone) return lserr;


		iwchLimDobj = iwchLim;
		if (itxtobj < itxtobjLast)
			iwchLimDobj = ptxtobj->iwchLim;

		iwch = iwchFirst;
		if (itxtobj > itxtobjFirst)
			iwch = ptxtobj->iwchFirst;

		for (; iwch < iwchLimDobj; iwch++)
			{

			rgtxtinf[iwch].prior = prior0;

			if (rgwchOrig[iwch] == pilsobj->wchSpace && plschp->fExpandSpace && 
												(!fGlyphBased || FIwchOneToOne(pilsobj, iwch)))
				{
				plsrunNext = NULL;
				iwchNext = 0;
				/* we take ptxtobj->iwchLim instead of iwchLimDobj because iwchLimInDobj char(last char
					before spaces on the line must be used for context considerations
				*/ 
				if (iwch < ptxtobj->iwchLim - 1)
					{
					plsrunNext = plsrunCur;
					iwchNext = iwch + 1;
					}
				else if (fNextAdjacentFound)
					{
					plsrunNext = plsgrchnk->plschnk[itxtobjNext].plsrun;
					iwchNext = ((PTXTOBJ)plsgrchnk->plschnk[itxtobjNext].pdobj)->iwchFirst;
					}
			
				GetPrevCharRun(plsgrchnk, itxtobj, iwch, &iwchPrev, &plsrunPrev);

				lserr = CheckExpandSpace(pilsobj, &lsems, iwchPrev, iwch, iwchNext, ptxtobj,
												plsrunPrev, plsrunCur, plsrunNext, &fExpandOpp, &durChange);
				if (lserr != lserrNone) return lserr;

				if (fExpandOpp)
					{
					pexpinfo->cExpOppr++;
					rgtxtinf[iwch].fExpand = fTrue;
					if (durChange > 0)
						{
						pexpinfo->rgdurPrior[0] += durChange;
						pexpinfo->rgcExpPrior[0]++;
						rgtxtinf[iwch].prior = 1;
						pilsobj->pduAdjust[iwch] = durChange;
						}
					}
	

				}

			if (!rgtxtinf[iwch].fExpand && iwch == ptxtobj->iwchLim - 1 && plschp->fExpandOnRun && 
							fNextAdjacentFound)
				{
				plsrunNext = plsgrchnk->plschnk[itxtobjNext].plsrun;
				iwchNext = ((PTXTOBJ)plsgrchnk->plschnk[itxtobjNext].pdobj)->iwchFirst;
				lserr = CheckExpandOnRun(pilsobj, &lsems, iwch, iwchNext, ptxtobj, plsrunCur, plsrunNext,
														&fExpandOpp, &durChange);
				if (lserr != lserrNone) return lserr;

				if (fExpandOpp)
					{
					pexpinfo->cExpOppr++;
					rgtxtinf[iwch].fExpand = fTrue;
					if (durChange > 0)
						{
						pexpinfo->rgdurPrior[1] += durChange;
						pexpinfo->rgcExpPrior[1]++;
						rgtxtinf[iwch].prior = 2;
						pilsobj->pduAdjust[iwch] = durChange;
						}
					}
				}
			else if (!rgtxtinf[iwch].fExpand && iwch == ptxtobj->iwchLim - 1 && !fNextAdjacentFound &&
							(plsgrchnk->pcont[itxtobj] & fcontExpandAfter))
				{
				/* Character before foreign object */
				pexpinfo->cExpOppr++;
				rgtxtinf[iwch].fExpand = fTrue;
				}

			if (!rgtxtinf[iwch].fExpand && plschp->fExpandTable)
				{
				Assert(!fGlyphBased);
				if (iwch < ptxtobj->iwchLim - 1)
					{
					lsexpan = pilsobj->plsexpan[pilsobj->pilsexpan[
							pilsobj->cModWidthClasses * rgtxtinf[iwch].mwcls + rgtxtinf[iwch+1].mwcls
																  ]
												];
					if (fScaled && lsexpan.fFullScaled || !fScaled && lsexpan.fFullInterletter)
						{
						pexpinfo->cExpOppr++;
						rgtxtinf[iwch].fExpand = fTrue;
						}
					}

				else if (fNextAdjacentFound && plsgrchnk->plschnk[itxtobjNext].plschp->fExpandTable)
					{
					Assert(!(((PTXTOBJ)plsgrchnk->plschnk[itxtobjNext].pdobj)->txtf & txtfGlyphBased));
					iwchNext = ((PTXTOBJ)plsgrchnk->plschnk[itxtobjNext].pdobj)->iwchFirst;

					lsexpan = pilsobj->plsexpan[pilsobj->pilsexpan[
							pilsobj->cModWidthClasses * rgtxtinf[iwch].mwcls + rgtxtinf[iwchNext].mwcls
																  ]
												];
					if (fScaled && lsexpan.fFullScaled || !fScaled && lsexpan.fFullInterletter)
						{
						pexpinfo->cExpOppr++;
						rgtxtinf[iwch].fExpand = fTrue;
						}
					}
				}



			}

		itxtobj = itxtobjNext;

		}

	return lserrNone;
}

/* C H E C K  E X P A N D  S P A C E */
/*----------------------------------------------------------------------------
    %%Function: CheckExpandSpace
    %%Contact: sergeyge

	Reports if there is expansion opportunity on space and amount of expansion
---------------------------------------------------------------------------*/
static LSERR CheckExpandSpace(PILSOBJ pilsobj, LSEMS* plsems, long iwchPrev, long iwch, long iwchNext,
	PTXTOBJ ptxtobjCur, PLSRUN plsrunPrev, PLSRUN plsrunCur, PLSRUN plsrunNext,
	BOOL* pfExpandOpp, long* pdurChange)
{
	LSERR lserr;
	BYTE side;
	LSACT lsact;
	long igind;
	
	*pfExpandOpp = fFalse;
	*pdurChange = 0;

	lserr = (*pilsobj->plscbk->pfnExpWidthSpace)(pilsobj->pols, plsrunCur,
			 plsrunPrev, pilsobj->pwchOrig[iwchPrev], plsrunNext, pilsobj->pwchOrig[iwchNext], &lsact);
	if (lserr != lserrNone) return lserr;

	if (lsact.side != sideNone)
		{
		*pfExpandOpp = fTrue;
		if (ptxtobjCur->txtf & txtfGlyphBased)
			{
			igind = IgindLastFromIwch(ptxtobjCur, iwch);
			GetChanges(lsact, plsems, pilsobj->pdurGind[igind], fTrue, &side, pdurChange);
			}
		else
			{
			GetChanges(lsact, plsems, pilsobj->pdur[iwch], fTrue, &side, pdurChange);
			}

		Assert(side == sideRight);

		if (*pdurChange < 0)
			*pdurChange = 0;
		}

	return lserrNone;
}

/* C H E C K  E X P A N D  O N  R U N */
/*----------------------------------------------------------------------------
    %%Function: CheckExpandOnRun
    %%Contact: sergeyge

	Reports if there is expansion opportunity between runs and amount of expansion
---------------------------------------------------------------------------*/
static LSERR CheckExpandOnRun(PILSOBJ pilsobj, LSEMS* plsems, long iwch, long iwchNext, PTXTOBJ ptxtobjCur,
							PLSRUN plsrunCur, PLSRUN plsrunNext, BOOL* pfExpandOpp, long* pdurChange)
{
	LSERR lserr;
	BYTE side;
	LSACT lsact;
	long igind;

	*pfExpandOpp = fFalse;
	*pdurChange = 0;

	lserr = (*pilsobj->plscbk->pfnExpOnRun)(pilsobj->pols, plsrunCur, pilsobj->pwchOrig[iwch], 
						plsrunNext, pilsobj->pwchOrig[iwchNext], &lsact);
	if (lserr != lserrNone) return lserr;

	if (lsact.side != sideNone)
		{
		*pfExpandOpp = fTrue;
		if (ptxtobjCur->txtf & txtfGlyphBased)
			{
			igind = IgindLastFromIwch(ptxtobjCur, iwch);
			igind = IgindBaseFromIgind(pilsobj, igind);
			GetChanges(lsact, plsems, pilsobj->pdurGind[igind], fTrue, &side, pdurChange);
			}
		else
			{
			GetChanges(lsact, plsems, pilsobj->pdur[iwch], fTrue, &side, pdurChange);
			}
		Assert(side == sideRight);
		if (*pdurChange < 0)
			*pdurChange = 0;
		}


	return lserrNone;
}

/* C H E C K  C O M P  S P A C E */
/*----------------------------------------------------------------------------
    %%Function: CheckCompSpace
    %%Contact: sergeyge

	Reports if there is compression opportunity on space and amount of compression
---------------------------------------------------------------------------*/
static LSERR CheckCompSpace(PILSOBJ pilsobj, LSEMS* plsems, long iwchPrev, long iwch, long iwchNext,
			PTXTOBJ ptxtobjCur, PLSRUN plsrunPrev, PLSRUN plsrunCur, PLSRUN plsrunNext, long* pdurChange)
{
	LSERR lserr;
	BYTE side;
	LSPRACT lspract;
	long igind;
	
	*pdurChange = 0;

	lserr = (*pilsobj->plscbk->pfnCompWidthSpace)(pilsobj->pols, plsrunCur,
			 plsrunPrev, pilsobj->pwchOrig[iwchPrev], plsrunNext, pilsobj->pwchOrig[iwchNext], &lspract);
	if (lserr != lserrNone) return lserr;

	if (lspract.prior != prior0)
		{
		if (ptxtobjCur->txtf & txtfGlyphBased)
			{
			igind = IgindLastFromIwch(ptxtobjCur, iwch);
			GetChanges(lspract.lsact, plsems, pilsobj->pdurGind[igind], fFalse, &side, pdurChange);
			}
		else
			{
			GetChanges(lspract.lsact, plsems, pilsobj->pdur[iwch], fFalse, &side, pdurChange);
			}

		Assert(side == sideRight);
		if (*pdurChange < 0)
			SetComp(pilsobj, iwch, lspract.prior, side, *pdurChange);
		else
			*pdurChange = 0;
		}

	return lserrNone;
}

/* C H E C K  C O M P  O N  R U N */
/*----------------------------------------------------------------------------
    %%Function: CheckCompOnRun
    %%Contact: sergeyge

	Reports if there is compression opportunity between runs and amount of compression
---------------------------------------------------------------------------*/
static LSERR CheckCompOnRun(PILSOBJ pilsobj, LSEMS* plsems, long iwch, long iwchNext,
							PTXTOBJ ptxtobjCur, PLSRUN plsrunCur, PLSRUN plsrunNext, long* pdurChange)
{
	LSERR lserr;
	BYTE side;
	LSPRACT lspract;
	long igind;

	*pdurChange = 0;

	lserr = (*pilsobj->plscbk->pfnCompOnRun)(pilsobj->pols, plsrunCur, pilsobj->pwchOrig[iwch], 
						plsrunNext, pilsobj->pwchOrig[iwchNext], &lspract);
	if (lserr != lserrNone) return lserr;

	if (lspract.prior != prior0)

		{
		if (ptxtobjCur->txtf & txtfGlyphBased)
			{
			igind = IgindLastFromIwch(ptxtobjCur, iwch);
			igind = IgindBaseFromIgind(pilsobj, igind);
			GetChanges(lspract.lsact, plsems, pilsobj->pdurGind[igind], fFalse, &side, pdurChange);
			}
		else
			{
			GetChanges(lspract.lsact, plsems, pilsobj->pdur[iwch], fFalse, &side, pdurChange);
			}
		Assert(side == sideRight);
		if (*pdurChange < 0)
			SetComp(pilsobj, iwch, lspract.prior, side, *pdurChange);
		else
			*pdurChange = 0;	
		}

	return lserrNone;
}

/* S E T  C O M P */
/*----------------------------------------------------------------------------
    %%Function: SetComp
    %%Contact: sergeyge

---------------------------------------------------------------------------*/
static void SetComp(PILSOBJ pilsobj, long iwch, BYTE prior, BYTE side, long durChange)
{
	pilsobj->ptxtinf[iwch].prior = prior;
	pilsobj->ptxtinf[iwch].side = side;
	pilsobj->pduAdjust[iwch] = durChange;
}

/* G E T  N E X T  R U N */
/*----------------------------------------------------------------------------
    %%Function: GetNextRun
    %%Contact: sergeyge

---------------------------------------------------------------------------*/
static BOOL GetNextRun(const LSGRCHNK* plsgrchnk, long itxtobj, long* pitxtobjNext)
{
	long clschnk;
	PTXTOBJ ptxtobj;
	BOOL fFound;
	BOOL fContiguous;

	clschnk = (long)plsgrchnk->clsgrchnk;

	*pitxtobjNext = clschnk;

	fFound = fFalse;
	fContiguous = fTrue;

	while (!fFound && itxtobj < clschnk)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		fFound = !(ptxtobj->txtf & txtfSkipAtNti);
		fContiguous = fContiguous && !(plsgrchnk->pcont[itxtobj] & fcontNonTextBefore);
		itxtobj++;
		}

	if (fFound)
		*pitxtobjNext = itxtobj - 1;

	return fFound && fContiguous;
}

/* G E T  P R E V  C H A R  R U N */
/*----------------------------------------------------------------------------
    %%Function: GetPrevCharRun
    %%Contact: sergeyge

---------------------------------------------------------------------------*/
static void GetPrevCharRun(const LSGRCHNK* plsgrchnk, long itxtobj, long iwch, long* piwchPrev, 
																					PLSRUN* pplsrunPrev)
{
	BOOL fFound;
	PTXTOBJ ptxtobj;

	fFound = fFalse;

	Assert(itxtobj < (long)plsgrchnk->clsgrchnk);

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;

	Assert(iwch >= ptxtobj->iwchFirst && iwch < ptxtobj->iwchLim);

	*piwchPrev = 0;
	*pplsrunPrev = NULL;
	if (iwch > ptxtobj->iwchFirst)
		{
		fFound = fTrue;
		*piwchPrev = iwch - 1;
		*pplsrunPrev = plsgrchnk->plschnk[itxtobj].plsrun;
		}
	else
		{
		while (!fFound && itxtobj > 0 && !(plsgrchnk->pcont[itxtobj] & fcontNonTextBefore))
			{
			itxtobj--;
			Assert(itxtobj >= 0);
			ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
			fFound = !(ptxtobj->txtf & txtfSkipAtNti);
			if (fFound)
				{
				*piwchPrev = ((PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj)->iwchLim - 1;
				*pplsrunPrev = plsgrchnk->plschnk[itxtobj].plsrun;
				}

			}		
		}
}

/* A P P L Y  P R I O R  E X P A N S I O N */
/*----------------------------------------------------------------------------
    %%Function: ApplyPriorExpansion
    %%Contact: sergeyge

	Applies expansion on one priority level
---------------------------------------------------------------------------*/
static void ApplyPriorExpansion(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchFirst,
			 long itxtobjLast, long iwchLim, BYTE prior, long durToExpand, long durAvailable, long cExpOppr)
{
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	TXTINF* rgtxtinf;
	long* rgdurAdjust;
	long durSubstr;
	long durChange;
	long cBound;
	long cOpprCur;
	long itxtobj;
	long iwch;
	long iwchFirstInDobj;
	long iwchLimInDobj;
	long igind;
	BOOL fGlyphBased;

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;
	rgtxtinf = pilsobj->ptxtinf;
	rgdurAdjust = pilsobj->pduAdjust;

	Assert(durToExpand > 0);
	if (durAvailable == 0)
		return;

	if (durAvailable < durToExpand)
		durToExpand = durAvailable;

	Assert(cExpOppr > 0);

	durSubstr = (durAvailable - durToExpand) / cExpOppr;
	cBound = (durAvailable - durToExpand) - durSubstr * cExpOppr;

	cOpprCur = 0;

	for (itxtobj = itxtobjFirst; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;

		fGlyphBased = (ptxtobj->txtf & txtfGlyphBased);


		iwchFirstInDobj = iwchFirst;
		if (itxtobj > itxtobjFirst)
			iwchFirstInDobj = ptxtobj->iwchFirst;

		iwchLimInDobj = iwchLim;
		if (itxtobj < itxtobjLast)
			iwchLimInDobj = ptxtobj->iwchLim;

		for (iwch = iwchFirstInDobj; iwch < iwchLimInDobj; iwch++)
			{
			if (rgtxtinf[iwch].prior == prior)
				{
				cOpprCur++;
				durChange = rgdurAdjust[iwch] - durSubstr;
				if (cOpprCur <= cBound)
					durChange--;
				if (durChange >= 0)
					{
					if (fGlyphBased)
						{
						igind = IgindLastFromIwch(ptxtobj, iwch);
						igind = IgindBaseFromIgind(pilsobj, igind);
						ApplyGlyphChanges(pilsobj, igind, durChange);
						}
					else
						ApplyChanges(pilsobj, iwch, sideRight, durChange);
					}

				}
			}
		}

}

/* A P P L Y  F U L L  E X P A N S I O N */
/*----------------------------------------------------------------------------
    %%Function: ApplyFullExpansion
    %%Contact: sergeyge

	Applies risidual unlimited expansion
---------------------------------------------------------------------------*/
static void ApplyFullExpansion(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchFirst,
		long itxtobjLast, long iwchLim, long durToExpand, long cExpOppr, long cNonText, long* pdurNonText)
{
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	TXTINF* rgtxtinf;
	long* rgdurAdjust;
	long cBound;
	long cOpprCur;
	long cExpOpprTotal;
	long durChange;
	long durAdd;
	long itxtobj;
	long iwch;
	long iwchFirstInDobj;
	long iwchLimInDobj;
	long igind;
	BOOL fGlyphBased;

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;
	rgtxtinf = pilsobj->ptxtinf;
	rgdurAdjust = pilsobj->pduAdjust;

	*pdurNonText = 0;

	cExpOpprTotal = cExpOppr + cNonText;

	if (cExpOpprTotal > 0)
		{

		*pdurNonText = durToExpand * cNonText / cExpOpprTotal;

		durToExpand -= *pdurNonText;

		if (cExpOppr > 0)
			{

			durAdd = durToExpand / cExpOppr;

			cBound = durToExpand - durAdd * cExpOppr;

			cOpprCur = 0;

			for (itxtobj = itxtobjFirst; itxtobj <= itxtobjLast; itxtobj++)
				{
				ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;

				fGlyphBased = (ptxtobj->txtf & txtfGlyphBased);

				iwchFirstInDobj = iwchFirst;
				if (itxtobj > itxtobjFirst)
					iwchFirstInDobj = ptxtobj->iwchFirst;

				iwchLimInDobj = iwchLim;
				if (itxtobj < itxtobjLast)
					iwchLimInDobj = ptxtobj->iwchLim;

				for (iwch = iwchFirstInDobj; iwch < iwchLimInDobj; iwch++)
					{
					if (rgtxtinf[iwch].fExpand)
						{
						cOpprCur++;
						durChange = durAdd;
						if (cOpprCur <= cBound)
							durChange++;

						if (fGlyphBased)
							{
							igind = IgindLastFromIwch(ptxtobj, iwch);
							igind = IgindBaseFromIgind(pilsobj, igind);
							ApplyGlyphChanges(pilsobj, igind, durChange);
							}
						else
							ApplyChanges(pilsobj, iwch, sideRight, durChange);
						}
					}
				}
			}
		}
}

/* G E T  C O M P R E S S  I N F O */
/*----------------------------------------------------------------------------
    %%Function: GetCompressInfo
    %%Contact: sergeyge

	Agregates compression information accross for priorities
---------------------------------------------------------------------------*/
static void GetCompressInfo(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchFirst, 
											long itxtobjLast, long iwchLim, COMPINFO* pcompinfo)
{
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	TXTINF* rgtxtinf;
	long* rgdurAdjust;
	UINT prior;
	long cCompPrior;
	long itxtobj;
	long iwch;
	long iwchFirstInDobj;
	long iwchLimInDobj;

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;
	cCompPrior = pilsobj->cCompPrior;
	memset(pcompinfo, 0, sizeof(COMPINFO) * cCompPrior);

	rgtxtinf = pilsobj->ptxtinf;
	rgdurAdjust = pilsobj->pduAdjust;
	/* rgtxtinf == NULL means that there were no runs which possibly can introduce compress opportunity */
	if (rgtxtinf == NULL)
		return;

	for (itxtobj = itxtobjFirst; itxtobj <= itxtobjLast ; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;

		iwchFirstInDobj = iwchFirst;
		if (itxtobj > itxtobjFirst)
			iwchFirstInDobj = ptxtobj->iwchFirst;

		iwchLimInDobj = iwchLim;
		if (itxtobj < itxtobjLast)
			iwchLimInDobj = ptxtobj->iwchLim;

		for (iwch = iwchFirstInDobj; iwch < iwchLimInDobj; iwch++)
			{
			prior =	rgtxtinf[iwch].prior;
			Assert(prior <= (BYTE)cCompPrior);
			if (prior > 0)
				{
				pcompinfo[prior - 1].cCompOppr++;
				pcompinfo[prior - 1].durComp -= rgdurAdjust[iwch];
				}
			}
		}
}

/* A P P L Y  P R I O R  C O M P R E S S I O N */
/*----------------------------------------------------------------------------
    %%Function: ApplyPriorCompression
    %%Contact: sergeyge

	Applies compression for one priority level
---------------------------------------------------------------------------*/
static void ApplyPriorCompression(const LSGRCHNK* plsgrchnk,  long itxtobjFirst, long iwchFirst,
									long itxtobjLast, long iwchLim, BYTE prior,
									long durToCompress, long durAvailable, long cExpOppr)
{
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	TXTINF* rgtxtinf;
	long* rgdurAdjust;
	long durSubstr;
	long cBound;
	long cOpprCur;
	long durChange;
	long iwch;
	long itxtobj;
	long igind;
	BOOL fGlyphBased;
	long iwchFirstInDobj;
	long iwchLimInDobj;

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;
	rgtxtinf = pilsobj->ptxtinf;
	rgdurAdjust = pilsobj->pduAdjust;

	Assert(durToCompress > 0);
	if (durAvailable == 0)
		return;

	if (durAvailable < durToCompress)
		durToCompress = durAvailable;

	Assert(cExpOppr > 0);

	durSubstr = (durAvailable - durToCompress) / cExpOppr;
	cBound = (durAvailable - durToCompress) - durSubstr * cExpOppr;

	cOpprCur = 0;
	for (itxtobj = itxtobjFirst; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;

		fGlyphBased = (ptxtobj->txtf & txtfGlyphBased);

		iwchFirstInDobj = iwchFirst;
		if (itxtobj > itxtobjFirst)
			iwchFirstInDobj = ptxtobj->iwchFirst;

		iwchLimInDobj = iwchLim;
		if (itxtobj < itxtobjLast)
			iwchLimInDobj = ptxtobj->iwchLim;

		for (iwch = iwchFirstInDobj; iwch < iwchLimInDobj; iwch++)
			{
			if (rgtxtinf[iwch].prior == prior)
				{
				cOpprCur++;
				durChange = rgdurAdjust[iwch] + durSubstr;
				if (cExpOppr - cBound < cOpprCur)
					durChange++;
				if (durChange < 0)
					{
					if (fGlyphBased)
						{
						igind = IgindLastFromIwch(ptxtobj, iwch);
						igind = IgindBaseFromIgind(pilsobj, igind);
						ApplyGlyphChanges(pilsobj, igind,  durChange);
						}
					else
						ApplyChanges(pilsobj, iwch, (BYTE)rgtxtinf[iwch].side, durChange);
					}
				}
			}
		}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lstxtglf.c ===
#include "lsmem.h"

#include "lstxtglf.h"

#include "lstxtmap.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"

#include "zqfromza.h"

typedef struct
{
	long cWhite;
	long duMaxWhite;
	long duTotalWhite;
	long cContinuous;
	long duMaxContinuous;
	long duMinContinuous;
	long cDiscrete;
	long duMaxDiscrete;
} EXPG;

typedef struct
{
	long cExpginfo;
	EXPG* pexpg;
	long cResidual;
} EXPGINFO;

#define priorSpace 1
#define priorMax 8
#define cDiscreteMax 25

#define min(a,b)     ((a) > (b) ? (b) : (a))
#define max(a,b)     ((a) < (b) ? (b) : (a))

static LSERR CollectGlyphExpInfo(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, LSDEVICE lsdev,
								long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLast,
								long* rgdu, long* rgduGind, EXPGINFO* pexpginfo);
static LSERR ApplyPriorGlyphExp(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, LSDEVICE lsdev, 
						long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLast,
						long prior, long duToDistribute, EXPG* pexpg, long* rgdu, long* rgduGind,
						long* rgduRight, long* rgduGright, long* pduDistributed);
LSERR static ApplyDiscrete(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, LSDEVICE lsdev,
						long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLast,
						long prior,	long duToDistribute, long cDiscrete, 
						long* rgduGind, long* rgduGright, long* pduDistributed);
static void ApplyOneEachContinuous(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchFirst,
						long itxtobjLast, long iwchLast, long prior, long duToDistribute, long cContinuous,
						long* rgduGind, long* rgduGright, long* pduDistributed);
static void ApplyFullWhiteContinuous(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLast,
						long prior,
						long* rgdu, long* rgduGind,	long* rgduRight, long* rgduGright, long* pduDistributed);
static void ApplyPropWhiteContinuous(const LSGRCHNK* plsgrchnk, BOOL fWhiteOnly,
						long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLast, long prior,
					 	long duToDistribute, long duTotalMin,
						long* rgdu, long* rgduGind, long* rgduRight, long* rgduGright, long* pduDistributed);
static void	ApplyResidualGlyphExp(const LSGRCHNK* plsgrchnk, long itxtobjFirst,
						long iwchFirst, long itxtobjLast, long iwchLim, long duToDistribute,
						long cResidual, long* rgduGind, long* rgduGright, long* pduDistributed);
static void	FixExpt(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchVeryFirst,
					 long itxtobjLast, long iwchLast, long* rgduGright);
static void CalcExpandChanges(long cWhole, long duDenom, long duRest, long duLocal, long duMax,
												long* pduChange, long* pduAddCurrent);
static void ApplyGlyphExpandChanges(long ind, long* rgduGind, long* rgduGright, long* pduDistributed, long duChange);


/* A P P L Y  G L Y P H  E X P A N D */
/*----------------------------------------------------------------------------
    %%Function: ApplyGlyphExpand
    %%Contact: sergeyge

	Applies glyph expansion
	First collects information about expansion opportunities
	Then applies expansion according to priorities
	If it is not sufficient, applies risidual expansion
----------------------------------------------------------------------------*/
LSERR ApplyGlyphExpand(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, LSDEVICE lsdev,
						long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLast,
						long duToDistribute, long* rgdu, long* rgduGind, long* rgduRight, long* rgduGright,
						BOOL* pfFullyJustified)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	EXPGINFO expginfo;
	EXPG rgexpg[priorMax];
	long duDistributed;
	long i;
	
	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	expginfo.pexpg = rgexpg;
	expginfo.cExpginfo = priorMax;

	lserr = CollectGlyphExpInfo(plsgrchnk, lstflow, lsdev,
								itxtobjFirst, iwchFirst, itxtobjLast, iwchLast,  rgdu, rgduGind, &expginfo);
	if (lserr != lserrNone) return lserr;

	for (i = 0; i < priorMax && duToDistribute > 0; i++)
		{
		lserr = ApplyPriorGlyphExp(plsgrchnk, lstflow, lsdev, itxtobjFirst, iwchFirst, itxtobjLast, iwchLast,
							 i + 1, duToDistribute,	&expginfo.pexpg[i], rgdu, rgduGind, rgduRight, rgduGright,
							 &duDistributed);
		if (lserr != lserrNone) return lserr;

		Assert(duDistributed <= duToDistribute);
		duToDistribute -= duDistributed;		
		}

	FixExpt(plsgrchnk, itxtobjFirst, iwchFirst, itxtobjLast, iwchLast, rgduGright);

	if (duToDistribute > 0 && expginfo.cResidual > 0)
		{
		ApplyResidualGlyphExp(plsgrchnk, itxtobjFirst, iwchFirst, itxtobjLast, iwchLast, duToDistribute,
										expginfo.cResidual, rgduGind, rgduGright, &duDistributed);
		Assert(duDistributed == duToDistribute);
		duToDistribute = 0;		
		}

	*pfFullyJustified = (duToDistribute == 0);

	return lserrNone;
}

/* C O L L E C T  G L Y P H  E X P  I N F O */
/*----------------------------------------------------------------------------
    %%Function: CollectGlyphExpInfo
    %%Contact: sergeyge

	Collects expansion information and agreagated values for
	the expansion algorithm.
	Spaces from character-based runs contribute as expansion opportunities
	of exptAddWhiteSpace type with prior==priorSpace and duMax==lsexpinfInfinity
----------------------------------------------------------------------------*/
static LSERR CollectGlyphExpInfo(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, LSDEVICE lsdev,
								long itxtobjFirst, long iwchVeryFirst, long itxtobjLast, long iwchLast,
								long* rgdu, long* rgduGind, EXPGINFO* pexpginfo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	PLSRUN plsrun;
	LSEXPINFO* plsexpinf;
	EXPTYPE* pexpt;
	long itxtobj;
	long iwchFirst;
	long iwchLim;
	long igindFirst;
	long igindLim;
	long igind;
	long iwSpace;

	memset(pexpginfo->pexpg, 0, sizeof(EXPG) * pexpginfo->cExpginfo);
	pexpginfo->cResidual = 0;

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	plnobj = ptxtobjLast->plnobj;
	pilsobj = plnobj->pilsobj;

	itxtobj = itxtobjFirst;

	plsexpinf = pilsobj->plsexpinf;
	pexpt = plnobj->pexpt;

	while (itxtobj <= itxtobjLast)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			iwchFirst = iwchVeryFirst;
			if (itxtobj > itxtobjFirst)
				iwchFirst = ptxtobj->iwchFirst;

			Assert(iwchFirst < ptxtobj->iwchLim);

			igindFirst = IgindFirstFromIwch(ptxtobj, iwchFirst);
			plsrun = plsgrchnk->plschnk[itxtobj].plsrun;
			while ((!(ptxtobj->txtf & txtfLastShaping)) && itxtobj < itxtobjLast )
				{
				itxtobj++;
				ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
				Assert (ptxtobj->txtf & txtfGlyphBased);
				Assert(ptxtobj->igindFirst == ((PTXTOBJ)plsgrchnk->plschnk[itxtobj-1].pdobj)->igindLim);
				Assert(ptxtobj->iwchFirst == ((PTXTOBJ)plsgrchnk->plschnk[itxtobj-1].pdobj)->iwchLim);
				}

			iwchLim = ptxtobj->iwchLim;
			igindLim = ptxtobj->igindLim;
			Assert(itxtobj <= itxtobjLast);
			if (itxtobj == itxtobjLast)
				{
				iwchLim = iwchLast + 1;
				Assert(IgindLastFromIwch(ptxtobjLast, iwchLast) + 1 <= igindLim);
				igindLim = IgindLastFromIwch(ptxtobjLast, iwchLast);

				while (!FIgindFirstInContext(pilsobj, igindLim) && rgduGind[igindLim] == 0)
					igindLim--;

				Assert(igindLim >= ptxtobj->igindFirst);

				igindLim++;
				}

			lserr = (*pilsobj->plscbk->pfnGetGlyphExpansionInfo)(pilsobj->pols, plsrun, lsdev,
					&pilsobj->pwchOrig[iwchFirst], &plnobj->pgmap[iwchFirst], iwchLim - iwchFirst, 
					&plnobj->pgind[igindFirst], &plnobj->pgprop[igindFirst], igindLim - igindFirst, 
					lstflow, itxtobj == itxtobjLast, &pexpt[igindFirst], &plsexpinf[igindFirst]);

			if (lserr != lserrNone) return lserr;
		
			for (igind = igindFirst; igind < igindLim; igind++)
				{
				Assert(plsexpinf[igind].prior < priorMax);
				if (plsexpinf[igind].prior > 0)
					{
					switch (pexpt[igind])
						{
					case exptAddWhiteSpace:
						Assert(plsexpinf[igind].duMax > 0);
						if (rgduGind[igind] > 0)
							{
							pexpginfo->pexpg[plsexpinf[igind].prior - 1].duMaxWhite += plsexpinf[igind].duMax;
							pexpginfo->pexpg[plsexpinf[igind].prior - 1].duTotalWhite += rgduGind[igind];
							pexpginfo->pexpg[plsexpinf[igind].prior - 1].cWhite++;
							}
						break;
					case exptAddInkContinuous:
						Assert(plsexpinf[igind].duMax > 0);
						Assert(plsexpinf[igind].u.AddInkContinuous.duMin > 0);
						pexpginfo->pexpg[plsexpinf[igind].prior - 1].duMaxContinuous += plsexpinf[igind].duMax;
						pexpginfo->pexpg[plsexpinf[igind].prior - 1].duMinContinuous +=
															plsexpinf[igind].u.AddInkContinuous.duMin;
						pexpginfo->pexpg[plsexpinf[igind].prior - 1].cContinuous++;
						break;
					case exptAddInkDiscrete:
						Assert(plsexpinf[igind].duMax > 0);
						pexpginfo->pexpg[plsexpinf[igind].prior - 1].duMaxDiscrete += plsexpinf[igind].duMax;
						pexpginfo->pexpg[plsexpinf[igind].prior - 1].cDiscrete++;
						break;
						}
					}
				if (plsexpinf[igind].fCanBeUsedForResidual)
					pexpginfo->cResidual++;
				}
	
			}
		else
			{
			if (ptxtobj->txtkind == txtkindRegular)
				{
				iwchFirst = iwchVeryFirst;
				if (itxtobj > itxtobjFirst)
					iwchFirst = ptxtobj->iwchFirst;

				iwchLim = iwchLast + 1;
				if (itxtobj < itxtobjLast)
					iwchLim = ptxtobj->iwchLim;
				
				for (iwSpace = ptxtobj->u.reg.iwSpacesFirst; iwSpace < ptxtobj->u.reg.iwSpacesLim &&
														pilsobj->pwSpaces[iwSpace] < iwchFirst; iwSpace++);
				for (; iwSpace < ptxtobj->u.reg.iwSpacesLim &&
															pilsobj->pwSpaces[iwSpace] < iwchLim; iwSpace++)
					{
					pexpginfo->pexpg[priorSpace - 1].duMaxWhite += lsexpinfInfinity;
					pexpginfo->pexpg[priorSpace - 1].duTotalWhite += rgdu[pilsobj->pwSpaces[iwSpace]];
					pexpginfo->pexpg[priorSpace - 1].cWhite++;
					}
				}
			}

		itxtobj++;

		}

	return lserrNone;
}


/* A P P L Y  P R I O R  G L Y P H  E X P A N D */
/*----------------------------------------------------------------------------
    %%Function: ApplyPriorGlyphExpand
    %%Contact: sergeyge

	Applies glyph expansion for particular priority

	Startegy:
	1. Apply Discrete expansion
	2. If the rest to distribute is bigger than the sum of maximus for other distribution types
				 use these maximums for distribution
	   else if sum of mimimums is less than the rest to distribute
				 distribute proportionally to this minimums (width of character for AddWhiteSpace type)
	   else
				increase AddContinuous opportrunities by minimum one by one while possible,
				distribute the rest in White opportunities proportionally
---------------------------------------------------------------------------*/
static LSERR ApplyPriorGlyphExp(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, LSDEVICE lsdev, 
						long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLast,
						long prior, long duToDistribute, EXPG* pexpg, long* rgdu, long* rgduGind,
						long* rgduRight, long* rgduGright, long* pduDistributed)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long duCovered;
	const BOOL fWhiteOnly = fTrue;
	
	*pduDistributed = 0;

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	Assert(duToDistribute > 0);

	if (pexpg->cDiscrete > 0)
		{
		lserr = ApplyDiscrete(plsgrchnk, lstflow, lsdev, itxtobjFirst, iwchFirst, itxtobjLast, iwchLast,
						prior, duToDistribute, pexpg->cDiscrete, 
						rgduGind, rgduGright, &duCovered);
		if (lserr != lserrNone) return lserr;

		Assert(duCovered <= duToDistribute);

		duToDistribute -= duCovered;
		*pduDistributed += duCovered;
		}

	if (duToDistribute > 0 && pexpg->cWhite + pexpg->cContinuous > 0 )
		{
		if (pexpg->duMaxWhite + pexpg->duMaxContinuous <= duToDistribute)
			{
			ApplyFullWhiteContinuous(plsgrchnk, itxtobjFirst, iwchFirst, itxtobjLast, iwchLast,
						prior, rgdu, rgduGind, rgduRight, rgduGright, &duCovered);

			Assert(duCovered == pexpg->duMaxWhite + pexpg->duMaxContinuous);

			duToDistribute -= duCovered;
			*pduDistributed += duCovered;
			}
		else if (pexpg->duTotalWhite + pexpg->duMinContinuous <= duToDistribute)
			{
			Assert(pexpg->duMaxWhite + pexpg->duMaxContinuous > duToDistribute);
			ApplyPropWhiteContinuous(plsgrchnk, !fWhiteOnly,
						itxtobjFirst, iwchFirst, itxtobjLast, iwchLast,
						prior,	duToDistribute,	pexpg->duTotalWhite + pexpg->duMinContinuous,
						rgdu, rgduGind, rgduRight, rgduGright, &duCovered);

			duToDistribute -= duCovered;
			*pduDistributed += duCovered;
			}
		else
			{
			Assert(pexpg->duTotalWhite + pexpg->duMinContinuous > duToDistribute);
			if (pexpg->cContinuous > 0)
				{
				ApplyOneEachContinuous(plsgrchnk, itxtobjFirst, iwchFirst, itxtobjLast, iwchLast,
						prior, duToDistribute, pexpg->cContinuous,
						rgduGind, rgduGright, &duCovered);
				duToDistribute -= duCovered;
				*pduDistributed += duCovered;
				}
			if (pexpg->cWhite > 0 && duToDistribute > 0)
				{
				ApplyPropWhiteContinuous(plsgrchnk, fWhiteOnly,
						itxtobjFirst, iwchFirst, itxtobjLast, iwchLast,
						prior, duToDistribute, pexpg->duTotalWhite,
						rgdu, rgduGind, rgduRight, rgduGright, &duCovered);
				duToDistribute -= duCovered;
				*pduDistributed += duCovered;
				}

			}
		}

	return lserrNone;
}

/* A P P L Y  D I S C R E T E */
/*----------------------------------------------------------------------------
    %%Function: ApplyDiscrete
    %%Contact: sergeyge

	Applies disctrete glyph expansion for particular priority

	Goes ones from first to last glyph on this priority level, and chooses maximum
	discrete opportunity which still fits.
---------------------------------------------------------------------------*/
LSERR static ApplyDiscrete(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, LSDEVICE lsdev,
						long itxtobjFirst, long iwchVeryFirst, long itxtobjLast, long iwchLast,
						long prior,	long duToDistribute, long cDiscrete, 
						long* rgduGind, long* rgduGright, long* pduDistributed)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	PLSRUN plsrun;
	LSEXPINFO* plsexpinf;
	EXPTYPE* pexpt;
	long itxtobj;
	long iwchFirst;
	long iwchLim;
	long igindFirst;
	long igindLim;
	long igind;
	long rgduDiscrete[cDiscreteMax];
	long* pduDiscrete;
	long cwidths;
	int i;

	*pduDistributed = 0;

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	plnobj = ptxtobjLast->plnobj;
	pilsobj = plnobj->pilsobj;

	itxtobj = itxtobjFirst;

	plsexpinf = pilsobj->plsexpinf;
	pexpt = plnobj->pexpt;

	for (itxtobj = itxtobjLast; itxtobj >= itxtobjFirst && cDiscrete > 0 && duToDistribute > 0; itxtobj--)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			iwchFirst = iwchVeryFirst;
			if (itxtobj > itxtobjFirst)
				iwchFirst = ptxtobj->iwchFirst;

			Assert(iwchFirst < ptxtobj->iwchLim);

			igindFirst = IgindFirstFromIwch(ptxtobj, iwchFirst);

			iwchLim = ptxtobj->iwchLim;
			igindLim = ptxtobj->igindLim;
			Assert(itxtobj <= itxtobjLast);
			if (itxtobj == itxtobjLast)
				{
				iwchLim = iwchLast + 1;
				Assert(IgindLastFromIwch(ptxtobjLast, iwchLast) + 1 <= igindLim);
				igindLim = IgindLastFromIwch(ptxtobjLast, iwchLast) + 1;
				}

			plsrun = plsgrchnk->plschnk[itxtobj].plsrun;

			for (igind = igindLim - 1; igind >= igindFirst && cDiscrete > 0 && duToDistribute > 0; igind--)
				{
				if (pexpt[igind] == exptAddInkDiscrete && plsexpinf[igind].prior == prior)
					{
					cDiscrete--;
					if (duToDistribute > plsexpinf[igind].duMax)
						{
						ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, plsexpinf[igind].duMax);
						duToDistribute -= plsexpinf[igind].duMax;
						}
					else
						{
						pduDiscrete = rgduDiscrete;
						cwidths = plsexpinf[igind].u.AddInkDiscrete.cwidths - 1;
						if (cwidths > cDiscreteMax)
							{
							pduDiscrete = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * cwidths);
							if (pduDiscrete == NULL) return lserrOutOfMemory;
							}
						lserr = (pilsobj->plscbk->pfnGetGlyphExpansionInkInfo)(pilsobj->pols, plsrun, lsdev,
								plnobj->pgind[igind], plnobj->pgprop[igind], lstflow, cwidths, pduDiscrete);
						if (lserr != lserrNone)
							{
							if (pduDiscrete != rgduDiscrete)
								(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pduDiscrete);
							return lserr;
							}
						#ifdef DEBUG
						for (i = 0; i < cwidths - 1; i++)
							Assert(pduDiscrete[i] <= pduDiscrete[i+1]);
						#endif
						for (i = cwidths - 1; i >= 0 && pduDiscrete[i] > duToDistribute; i--);
						if (i >= 0)
							{
							Assert(pduDiscrete[i] <= duToDistribute);
							ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, pduDiscrete[i]);
							duToDistribute -= pduDiscrete[i];
							}
						if (pduDiscrete != rgduDiscrete)
							(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pduDiscrete);
						}
					}
				}
			}
		}

	return lserrNone;
}

/* A P P L Y  O N E  E A C H  C O N T I N U O U S */
/*----------------------------------------------------------------------------
    %%Function: ApplyOneEachContinuous
    %%Contact: sergeyge

	Applies glyph expansion for particular priority

	Goes ones from first to last glyph on this priority level, and adds minimum
	to each glyph with AddIncContinuous exapnsion type, if this minimum still fits
---------------------------------------------------------------------------*/
static void ApplyOneEachContinuous(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchVeryFirst,
						long itxtobjLast, long iwchLast, long prior, long duToDistribute, long cContinuous,
						long* rgduGind, long* rgduGright, long* pduDistributed)
{
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	LSEXPINFO* plsexpinf;
	EXPTYPE* pexpt;
	long itxtobj;
	long iwchFirst;
	long iwchLim;
	long igindFirst;
	long igindLim;
	long igind;

	*pduDistributed = 0;

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	plnobj = ptxtobjLast->plnobj;
	pilsobj = plnobj->pilsobj;

	itxtobj = itxtobjFirst;

	plsexpinf = pilsobj->plsexpinf;
	pexpt = plnobj->pexpt;

	for (itxtobj = itxtobjLast; itxtobj >= itxtobjFirst && cContinuous > 0 && duToDistribute > 0; itxtobj--)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			iwchFirst = iwchVeryFirst;
			if (itxtobj > itxtobjFirst)
				iwchFirst = ptxtobj->iwchFirst;

			Assert(iwchFirst < ptxtobj->iwchLim);
			igindFirst = IgindFirstFromIwch(ptxtobj, iwchFirst);

			iwchLim = ptxtobj->iwchLim;
			igindLim = ptxtobj->igindLim;
			Assert(itxtobj <= itxtobjLast);
			if (itxtobj == itxtobjLast)
				{
				iwchLim = iwchLast + 1;
				Assert(IgindLastFromIwch(ptxtobjLast, iwchLast) + 1 <= igindLim);
				igindLim = IgindLastFromIwch(ptxtobjLast, iwchLast) + 1;
				}

			for (igind = igindLim - 1; igind >= igindFirst && cContinuous> 0 && duToDistribute > 0; igind--)
				{
				if (pexpt[igind] == exptAddInkContinuous && plsexpinf[igind].prior == prior)
					{
					cContinuous--;
					if (duToDistribute > plsexpinf[igind].u.AddInkContinuous.duMin)
						{
						ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, plsexpinf[igind].u.AddInkContinuous.duMin);
						duToDistribute -= plsexpinf[igind].u.AddInkContinuous.duMin;
						}
					}
				}
			}
		}

}

/* A P P L Y  F U L L  W H I T E  C O N T I N U O U S */
/*----------------------------------------------------------------------------
    %%Function: ApplyFullWhiteContinuous
    %%Contact: sergeyge

	Applies glyph expansion for particular priority

	Goes ones from first to last glyph on this priority level, and adds maximum
	to each glyph with AddIncContinuous or AddWhiteSpace exapnsion type
---------------------------------------------------------------------------*/
static void ApplyFullWhiteContinuous(const LSGRCHNK* plsgrchnk,
						long itxtobjFirst, long iwchVeryFirst, long itxtobjLast, long iwchLast,
						long prior,
						long* rgdu, long* rgduGind,	long* rgduRight, long* rgduGright, long* pduDistributed)
{
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	LSEXPINFO* plsexpinf;
	EXPTYPE* pexpt;
	long itxtobj;
	long iwchFirst;
	long iwchLim;
	long igindFirst;
	long igindLim;
	long igind;
	long iwSpace;

	*pduDistributed = 0;

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	plnobj = ptxtobjLast->plnobj;
	pilsobj = plnobj->pilsobj;

	itxtobj = itxtobjFirst;

	plsexpinf = pilsobj->plsexpinf;
	pexpt = plnobj->pexpt;

	for (itxtobj = itxtobjFirst; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			iwchFirst = iwchVeryFirst;
			if (itxtobj > itxtobjFirst)
				iwchFirst = ptxtobj->iwchFirst;

			Assert(iwchFirst < ptxtobj->iwchLim);

			igindFirst = IgindFirstFromIwch(ptxtobj, iwchFirst);

			iwchLim = ptxtobj->iwchLim;
			igindLim = ptxtobj->igindLim;
			Assert(itxtobj <= itxtobjLast);
			if (itxtobj == itxtobjLast)
				{
				iwchLim = iwchLast + 1;
				Assert(IgindLastFromIwch(ptxtobjLast, iwchLast) + 1 <= igindLim);
				igindLim = IgindLastFromIwch(ptxtobjLast, iwchLast) + 1;
				}

			for (igind = igindFirst; igind < igindLim; igind++)
				{
				if (plsexpinf[igind].prior == prior &&
						(pexpt[igind] == exptAddWhiteSpace || pexpt[igind] == exptAddInkContinuous))
					{
					ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, plsexpinf[igind].duMax);
					}
				}
	
			}
		else
			{
			if (ptxtobj->txtkind == txtkindRegular && prior == priorSpace)
				{
				iwchFirst = iwchVeryFirst;
				if (itxtobj > itxtobjFirst)
					iwchFirst = ptxtobj->iwchFirst;
			
				iwchLim = iwchLast + 1;
				if (itxtobj < itxtobjLast)
					iwchLim = ptxtobj->iwchLim;

				for (iwSpace = ptxtobj->u.reg.iwSpacesFirst; iwSpace < ptxtobj->u.reg.iwSpacesLim &&
														pilsobj->pwSpaces[iwSpace] < iwchFirst; iwSpace++);
				for (; iwSpace < ptxtobj->u.reg.iwSpacesLim &&
													 pilsobj->pwSpaces[iwSpace] < iwchLim; iwSpace++)
					{
					Assert(fFalse);
					ApplyGlyphExpandChanges(pilsobj->pwSpaces[iwSpace], rgdu, rgduRight, pduDistributed, lsexpinfInfinity);
					}
				}
			}
		}
}

/* A P P L Y  P R O P  W H I T E  C O N T I N U O U S */
/*----------------------------------------------------------------------------
    %%Function: ApplyPropWhiteContinuous
    %%Contact: sergeyge

	Applies glyph expansion for particular priority

	Goes ones from first to last glyph on this priority level, and increases width
	for each glyph with AddIncContinuous or AddWhiteSpace exapnsion type
	proportionally to its minimum (for InkCont) or width of character (for WhiteSpace).
---------------------------------------------------------------------------*/
static void ApplyPropWhiteContinuous(const LSGRCHNK* plsgrchnk, BOOL fWhiteOnly,
						long itxtobjFirst, long iwchVeryFirst, long itxtobjLast, long iwchLast, long prior,
					 	long duToDistribute, long duDenom,
						long* rgdu, long* rgduGind, long* rgduRight, long* rgduGright, long* pduDistributed)
{
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	LSEXPINFO* plsexpinf;
	EXPTYPE* pexpt;
	long itxtobj;
	long iwchFirst;
	long iwchLim;
	long igindFirst;
	long igindLim;
	long igind;
	long cWhole;
	long duAddCurrent;
	long duDebt;
	long duRest;
	long duChange;
	long iwch;
	long iwSpace;
	long duDebtSaved;

	*pduDistributed = 0;

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	plnobj = ptxtobjLast->plnobj;
	pilsobj = plnobj->pilsobj;

	plsexpinf = pilsobj->plsexpinf;
	pexpt = plnobj->pexpt;

	cWhole = duToDistribute / duDenom;

	duRest = duToDistribute - cWhole * duDenom;

	duAddCurrent = 0;

	duDebt = 0;

	for (itxtobj = itxtobjFirst; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			iwchFirst = iwchVeryFirst;
			if (itxtobj > itxtobjFirst)
				iwchFirst = ptxtobj->iwchFirst;

			Assert(iwchFirst < ptxtobj->iwchLim);

			igindFirst = IgindFirstFromIwch(ptxtobj, iwchFirst);

			iwchLim = ptxtobj->iwchLim;
			igindLim = ptxtobj->igindLim;
			Assert(itxtobj <= itxtobjLast);
			if (itxtobj == itxtobjLast)
				{
				iwchLim = iwchLast + 1;
				Assert(IgindLastFromIwch(ptxtobjLast, iwchLast) + 1 <= igindLim);
				igindLim = IgindLastFromIwch(ptxtobjLast, iwchLast) + 1;
				}

			for (igind = igindFirst; igind < igindLim; igind++)
				{
				if (plsexpinf[igind].prior == prior)
					{
					if (pexpt[igind] == exptAddWhiteSpace)
						{
						Assert(rgduGright[igind] == 0 || pexpt[igind] == exptAddInkDiscrete);
						CalcExpandChanges(cWhole, duDenom, duRest,
								 rgduGind[igind], plsexpinf[igind].duMax, &duChange, &duAddCurrent);
						if (duChange > 0)
							ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, duChange);
						}

					else if (pexpt[igind] == exptAddInkContinuous && !fWhiteOnly)
						{
						Assert(rgduGright[igind] == 0 || pexpt[igind] == exptAddInkDiscrete);
						CalcExpandChanges(cWhole, duDenom, duRest, plsexpinf[igind].u.AddInkContinuous.duMin,
													 plsexpinf[igind].duMax, &duChange, &duAddCurrent);
						if (duChange > 0)
							ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, duChange);
						}
					}
				}
	
			}
		else
			{
			if (ptxtobj->txtkind == txtkindRegular && prior == priorSpace)
				{
				iwchFirst = iwchVeryFirst;
				if (itxtobj > itxtobjFirst)
					iwchFirst = ptxtobj->iwchFirst;

				iwchLim = iwchLast + 1;
				if (itxtobj < itxtobjLast)
					iwchLim = ptxtobj->iwchLim;

				for (iwSpace = ptxtobj->u.reg.iwSpacesFirst; iwSpace < ptxtobj->u.reg.iwSpacesLim &&
														pilsobj->pwSpaces[iwSpace] < iwchFirst; iwSpace++);
				for (; iwSpace < ptxtobj->u.reg.iwSpacesLim &&
													 pilsobj->pwSpaces[iwSpace] < iwchLim; iwSpace++)
					{
					iwch = pilsobj->pwSpaces[iwSpace];
					CalcExpandChanges(cWhole, duDenom, duRest, rgdu[iwch], lsexpinfInfinity,
												&duChange, &duAddCurrent);
					if (duChange > 0)
						ApplyGlyphExpandChanges(iwch, rgdu, rgduRight, pduDistributed, duChange);
					}
				}
			}

		}

	duDebt = duToDistribute - *pduDistributed;
	Assert(duDebt >= 0);
/* If not everything distributed, distribute it somehow not violating Min/Max boundaries */
	duDebtSaved = 0;
	while (duDebt > 0 && duDebt != duDebtSaved)
		{
		duDebtSaved = duDebt;
		for (itxtobj = itxtobjLast; itxtobj >= itxtobjFirst && duDebt > 0; itxtobj--)
			{
			ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
			if (ptxtobj->txtf & txtfGlyphBased)
				{
				iwchFirst = iwchVeryFirst;
				if (itxtobj > itxtobjFirst)
					iwchFirst = ptxtobj->iwchFirst;

				Assert(iwchFirst < ptxtobj->iwchLim);

				igindFirst = IgindFirstFromIwch(ptxtobj, iwchFirst);

				iwchLim = ptxtobj->iwchLim;
				igindLim = ptxtobj->igindLim;
				Assert(itxtobj <= itxtobjLast);
				if (itxtobj == itxtobjLast)
					{
					iwchLim = iwchLast + 1;
					Assert(IgindLastFromIwch(ptxtobjLast, iwchLast) + 1 <= igindLim);
					igindLim = IgindLastFromIwch(ptxtobjLast, iwchLast) + 1;
					}

				for (igind = igindLim - 1; igind >= igindFirst && duDebt > 0; igind--)
					{
					if (plsexpinf[igind].prior == prior && rgduGright[igind] < plsexpinf[igind].duMax)
						{
						if (pexpt[igind] == exptAddWhiteSpace)
							{
							duChange = min(rgduGind[igind] - rgduGright[igind], min(duDebt, plsexpinf[igind].duMax - rgduGright[igind]));
							ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, duChange);
							duDebt -= duChange;
							}
						else if (pexpt[igind] == exptAddInkContinuous && !fWhiteOnly)
							{
							Assert(rgduGright[igind] > 0);
							duChange = min(plsexpinf[igind].u.AddInkContinuous.duMin, min(duDebt, plsexpinf[igind].duMax - rgduGright[igind]));
							ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, duChange);
							duDebt -= duChange;
							}
						}
					}
		
				}
			else
				{
				if (ptxtobj->txtkind == txtkindRegular && prior == priorSpace)
					{
					iwchFirst = iwchVeryFirst;
					if (itxtobj > itxtobjFirst)
						iwchFirst = ptxtobj->iwchFirst;

					iwchLim = iwchLast + 1;
					if (itxtobj < itxtobjLast)
						iwchLim = ptxtobj->iwchLim;

					for (iwSpace = ptxtobj->u.reg.iwSpacesLim - 1; iwSpace >= ptxtobj->u.reg.iwSpacesFirst &&
												pilsobj->pwSpaces[iwSpace] >= iwchLim; iwSpace--);
					for (; iwSpace >= ptxtobj->u.reg.iwSpacesFirst &&
								 pilsobj->pwSpaces[iwSpace] >= iwchFirst && duDebt > 0; iwSpace--)
						{
						iwch = pilsobj->pwSpaces[iwSpace];
						duChange = min(rgdu[iwch] - rgduRight[iwch], duDebt);
						ApplyGlyphExpandChanges(iwch, rgdu, rgduRight, pduDistributed, duChange);
						duDebt -= duChange;
						}
					}
				}

			}
		Assert(duDebt == duToDistribute - *pduDistributed);
		}

}

/* A P P L Y  R E S I D U A L  G L Y P H  E X P */
/*----------------------------------------------------------------------------
    %%Function: ApplyResidualGlyphExp
    %%Contact: sergeyge


	Distributes equally between all risidual opportunities
---------------------------------------------------------------------------*/
static void	ApplyResidualGlyphExp(const LSGRCHNK* plsgrchnk, long itxtobjFirst,
						long iwchVeryFirst, long itxtobjLast, long iwchLast, long duToDistribute,
						long cResidual, long* rgduGind, long* rgduGright, long* pduDistributed)
{
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	LSEXPINFO* plsexpinf;
	long itxtobj;
	long iwchFirst;
	long iwchLim;
	long igindFirst;
	long igindLim;
	long igind;
	long cUsed;
	long duAdd;
	long cBound;

	*pduDistributed = 0;

	if (cResidual == 0)
		return;

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	pilsobj = ptxtobjLast->plnobj->pilsobj;

	itxtobj = itxtobjFirst;

	plsexpinf = pilsobj->plsexpinf;

	duAdd = duToDistribute / cResidual;

	cBound = duToDistribute - duAdd * cResidual;

	cUsed = 0;

	for (itxtobj = itxtobjFirst; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			iwchFirst = iwchVeryFirst;
			if (itxtobj > itxtobjFirst)
				iwchFirst = ptxtobj->iwchFirst;

			Assert(iwchFirst < ptxtobj->iwchLim);
			igindFirst = IgindFirstFromIwch(ptxtobj, iwchFirst);

			iwchLim = ptxtobj->iwchLim;
			igindLim = ptxtobj->igindLim;
			Assert(itxtobj <= itxtobjLast);
			if (itxtobj == itxtobjLast)
				{
				iwchLim = iwchLast + 1;
				Assert(IgindLastFromIwch(ptxtobjLast, iwchLast) + 1 <= igindLim);
				igindLim = IgindLastFromIwch(ptxtobjLast, iwchLast) + 1;
				}

			for (igind = igindFirst; igind < igindLim; igind++)
				{
				if (plsexpinf[igind].fCanBeUsedForResidual)
					{
					if (cUsed < cBound)
						ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, duAdd + 1);
					else
						ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, duAdd);
					cUsed++;
					}
				}
			}
		}

	Assert(duToDistribute == *pduDistributed);

}

/* F I X  E X P T */
/*----------------------------------------------------------------------------
    %%Function: FixExpt
    %%Contact: sergeyge

	Zeroes expt for the glyphs which were not changed,
	so correct distribution type is passed to client at display time
---------------------------------------------------------------------------*/
static void	FixExpt(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchVeryFirst,
					 long itxtobjLast, long iwchLast, long* rgduGright)
{
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	EXPTYPE* pexpt;
	long itxtobj;
	long iwchFirst;
	long iwchLim;
	long igindFirst;
	long igindLim;
	long igind;

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	pexpt = ptxtobjLast->plnobj->pexpt;

	itxtobj = itxtobjFirst;

	for (itxtobj = itxtobjFirst; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			iwchFirst = iwchVeryFirst;
			if (itxtobj > itxtobjFirst)
				iwchFirst = ptxtobj->iwchFirst;

			Assert(iwchFirst < ptxtobj->iwchLim);
			igindFirst = IgindFirstFromIwch(ptxtobj, iwchFirst);

			iwchLim = ptxtobj->iwchLim;
			igindLim = ptxtobj->igindLim;
			Assert(itxtobj <= itxtobjLast);
			if (itxtobj == itxtobjLast)
				{
				iwchLim = iwchLast + 1;
				Assert(IgindLastFromIwch(ptxtobjLast, iwchLast) + 1 <= igindLim);
				igindLim = IgindLastFromIwch(ptxtobjLast, iwchLast) + 1;
				}

			for (igind = igindFirst; igind < igindLim; igind++)
				{
				if (rgduGright[igind] == 0)
					{
					pexpt[igind] = 0;
					}
				}
			}
		}

}

/* C A L C  E X P A N D  C H A N G E S */
/*----------------------------------------------------------------------------
    %%Function: CalcExpandChanges
    %%Contact: sergeyge

	Arithmetics for proportional distribution
---------------------------------------------------------------------------*/
static void CalcExpandChanges(long cWhole, long duDenom, long duRest, long duLocal, long duMax,
												long* pduChange, long* pduAddCurrent)
{
/* REVIEW sergeyge: is __int64 necessary to avoid overflow??? */
	__int64 temp;

	temp = Mul64 (duRest, duLocal) + *pduAddCurrent;
	
	Assert(duDenom > 0);
	Assert(Div64 (temp, duDenom) < 0x7FFFFFFF);
	
	*pduChange = (long) Div64 (temp, duDenom);
	
	Assert( temp - Mul64(*pduChange, duDenom) < 0x7FFFFFFF);
	*pduAddCurrent = (long)(temp - Mul64(*pduChange, duDenom));
	
	*pduChange += (cWhole * duLocal);
	if (*pduChange > duMax)
		{
		*pduChange = duMax;
		}

}

/* A P P L Y  G L Y P H  E X P A N D  C H A N G E S */
/*----------------------------------------------------------------------------
    %%Function: ApplyGlyphExpandChanges
    %%Contact: sergeyge

---------------------------------------------------------------------------*/
static void ApplyGlyphExpandChanges(long ind, long* rgduGind, long* rgduGright, long* pduDistributed, long duChange)
{
	rgduGind[ind] += duChange;
	rgduGright[ind] += duChange;
	*pduDistributed += duChange;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lstxtfmt.c ===
#include "lsmem.h"
#include <limits.h>

#include "lstxtfmt.h"
#include "lsstring.h"
#include "lstxtffi.h"
#include "lsdnfin.h"
#include "lsdnfinp.h"
#include "lsdntext.h"
#include "zqfromza.h"
#include "txtobj.h"
#include "lskysr.h"
#include "lschp.h"
#include "fmti.h"
#include "objdim.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"
#include "txtconst.h"

#define cwchLocalMax 120

/* Internal Functions Prototypes */
static LSERR FormatRegularCharacters(PLNOBJ plnobj, PCFMTIN pfmtin,	FMTRES* pfmtr);
static LSERR CreateFillTextDobj(PLNOBJ plnobj, long txtkind, PCFMTIN pfmtin, BOOL fIgnoreGlyphs, 
																					TXTOBJ** ppdobjText);
static LSERR GetTextDobj(PLNOBJ plnobj, TXTOBJ** ppdobjText);
static LSERR FillRealFmtOut(PILSOBJ pilsobj, LSDCP dcp, long dur, TXTOBJ* pdobjText, PCFMTIN pfmtin,
																				 BOOL fIgnoreHeights);
static LSERR AppendTrailingSpaces(PLNOBJ plnobj, TXTOBJ* pdobjText, WCHAR* rgwchGlobal,
									 long iwchGlobal, long cwchGlobal,
									 long* iwchGlobalNew, long* pddur);
static LSERR FormatStartEmptyDobj(PLNOBJ plnobj, PCFMTIN pfmtin, long txtkind, DWORD fTxtVisi, 
																		WCHAR wchVisi, FMTRES* pfmtr);
static LSERR FormatStartTab(PLNOBJ plnobj, PCFMTIN pfmtin, FMTRES* pfmtr);
static LSERR FormatStartOneRegularChar(PLNOBJ plnobj, PCFMTIN pfmtin, long txtkind, FMTRES* pfmtr);
static LSERR FormatStartToReplace(PLNOBJ plnobj, PCFMTIN pfmtin, FMTRES* pfmtr);
static LSERR FormatStartEol(PLNOBJ plnobj, PCFMTIN pfmtin, WCHAR wch, STOPRES stopr, FMTRES* pfmtr);
static LSERR FormatStartDelete(PLNOBJ plnobj, LSDCP dcp, FMTRES* pfmtr);
static LSERR FormatStartSplat(PLNOBJ plnobj, PCFMTIN pfmtin, STOPRES stopr, FMTRES* pfmtr);
static LSERR FormatStartBorderedSpaces(PLNOBJ plnobj, PCFMTIN pfmtin, FMTRES* pfmtr);
static LSERR FormatSpecial(PLNOBJ plnobj, WCHAR wchRef, WCHAR wchPres, BOOL fVisible,
															long txtkind, PCFMTIN pfmtin, FMTRES* pfmtr);
static STOPRES StoprHardBreak(CLABEL clab);
static CLABEL ClabFromChar(PILSOBJ pilsobj, WCHAR wch);

/* Export Functions Implementation  */

/* L S  T X T  F M T */
/*----------------------------------------------------------------------------
    %%Function: LsTxtFmt
    %%Contact: sergeyge

    The top-level function of the text formatter.
	It checks for the first character and state
	and redirects the program flow accordingly.
----------------------------------------------------------------------------*/

LSERR WINAPI FmtText(PLNOBJ plnobj, PCFMTIN pfmtin, FMTRES* pfmtr)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	WCHAR wchFirst;
	CLABEL clab;
	BOOL fInChildList;

	pilsobj = plnobj->pilsobj;

	wchFirst = pfmtin->lsfrun.lpwchRun[0];

	clab = pilsobj->rgbSwitch[wchFirst & 0x00FF]; /* REVIEW sergeyge       */
	if (clab != clabRegular)
		{
		clab = ClabFromChar(pilsobj, wchFirst);
		}

	/* check for the YSR-character                                           */
	if (pfmtin->lsfrun.plschp->fHyphen && clab == clabRegular)
		{
		return FormatStartOneRegularChar(plnobj, pfmtin, txtkindYsrChar, pfmtr);
		} 
	else
		{
		switch (clab)
			{
		case clabRegular:
			return FormatRegularCharacters(plnobj, pfmtin, pfmtr);
		case clabSpace:
			if (pfmtin->lsfrun.plschp->fBorder)
				return FormatStartBorderedSpaces(plnobj, pfmtin, pfmtr);
			else
				return FormatRegularCharacters(plnobj, pfmtin, pfmtr);
		case clabEOP1:
			switch (pilsobj->lskeop)
				{
			case lskeopEndPara1:
				return FormatStartEol(plnobj, pfmtin, pilsobj->wchVisiEndPara, stoprEndPara, pfmtr);
			case lskeopEndPara12:
				return FormatStartDelete(plnobj, 1, pfmtr);
			default:
				return FormatStartOneRegularChar(plnobj, pfmtin, txtkindRegular, pfmtr);
				}
		case clabEOP2:
			switch (pilsobj->lskeop)
				{
			case lskeopEndPara2:
			case lskeopEndPara12:
				return FormatStartEol(plnobj, pfmtin, pilsobj->wchVisiEndPara, stoprEndPara, pfmtr);
			default:
				return FormatStartOneRegularChar(plnobj, pfmtin, txtkindRegular, pfmtr);
				}
			break;
		case clabAltEOP:
			switch (pilsobj->lskeop)
				{
			case lskeopEndParaAlt:
				return FormatStartEol(plnobj, pfmtin, pilsobj->wchVisiAltEndPara, stoprAltEndPara, pfmtr);
			default:
				return FormatStartOneRegularChar(plnobj, pfmtin, txtkindRegular, pfmtr);
				}
		case clabEndLineInPara:
			return FormatStartEol(plnobj, pfmtin, pilsobj->wchVisiEndLineInPara, stoprSoftCR, pfmtr);
		case clabTab:
			return FormatStartTab(plnobj, pfmtin, pfmtr);
		case clabNull:
			if (pilsobj->grpf & fTxtVisiSpaces)
				return FormatSpecial(plnobj, wchFirst, pilsobj->wchVisiNull, fTrue, txtkindRegular, pfmtin, pfmtr);		
			else
				return FormatSpecial(plnobj, wchFirst, wchFirst, fFalse, txtkindRegular, pfmtin, pfmtr);		
		case clabNonReqHyphen:
			return FormatStartEmptyDobj(plnobj, pfmtin, txtkindNonReqHyphen, fTxtVisiCondHyphens, 
																	pilsobj->wchVisiNonReqHyphen, pfmtr);
		case clabNonBreakHyphen:
			if (pilsobj->grpf & fTxtVisiCondHyphens)
				return FormatSpecial(plnobj, pilsobj->wchHyphen, pilsobj->wchVisiNonBreakHyphen, fTrue, txtkindNonBreakHyphen, pfmtin, pfmtr);		
			else
				return FormatSpecial(plnobj, pilsobj->wchHyphen, pilsobj->wchHyphen, fFalse, txtkindNonBreakHyphen, pfmtin, pfmtr);		
		case clabNonBreakSpace:
			if (pilsobj->grpf & fTxtVisiSpaces)
				return FormatSpecial(plnobj, pilsobj->wchSpace, pilsobj->wchVisiNonBreakSpace, fTrue, txtkindNonBreakSpace, pfmtin, pfmtr);		
			else
				return FormatSpecial(plnobj, pilsobj->wchSpace, pilsobj->wchSpace, fFalse, txtkindNonBreakSpace, pfmtin, pfmtr);		
		case clabHardHyphen:
			if (pilsobj->grpf & fTxtTreatHyphenAsRegular)
				return FormatSpecial(plnobj, wchFirst, wchFirst, fFalse, txtkindRegular, pfmtin, pfmtr);
			else
				return FormatSpecial(plnobj, wchFirst, wchFirst, fFalse, txtkindHardHyphen, pfmtin, pfmtr);
		case clabSectionBreak:
		case clabColumnBreak:
		case clabPageBreak:
			lserr = LsdnFInChildList(pilsobj->plsc, pfmtin->plsdnTop, &fInChildList);
			if (lserr != lserrNone) return lserr;
			if (fInChildList)
				return FormatStartDelete(plnobj, 1, pfmtr);
			else
				return FormatStartSplat(plnobj, pfmtin, StoprHardBreak(clab), pfmtr);
		case clabEmSpace:
			if (pilsobj->grpf & fTxtVisiSpaces)
				return FormatSpecial(plnobj, wchFirst, pilsobj->wchVisiEmSpace, fTrue, txtkindSpecSpace, pfmtin, pfmtr);		
			else
				return FormatSpecial(plnobj, wchFirst, wchFirst, fFalse, txtkindSpecSpace, pfmtin, pfmtr);		
		case clabEnSpace:
			if (pilsobj->grpf & fTxtVisiSpaces)
				return FormatSpecial(plnobj, wchFirst, pilsobj->wchVisiEnSpace, fTrue, txtkindSpecSpace, pfmtin, pfmtr);		
			else
				return FormatSpecial(plnobj, wchFirst, wchFirst, fFalse, txtkindSpecSpace, pfmtin, pfmtr);		
		case clabNarrowSpace:
			if (pilsobj->grpf & fTxtVisiSpaces)
				return FormatSpecial(plnobj, wchFirst, pilsobj->wchVisiNarrowSpace, fTrue, txtkindSpecSpace, pfmtin, pfmtr);		
			else
				return FormatSpecial(plnobj, wchFirst, wchFirst, fFalse, txtkindSpecSpace, pfmtin, pfmtr);		
		case clabOptBreak:
			return FormatStartEmptyDobj(plnobj, pfmtin, txtkindOptBreak, fTxtVisiBreaks, 
																	pilsobj->wchVisiOptBreak, pfmtr);
		case clabNonBreak:
			return FormatStartEmptyDobj(plnobj, pfmtin, txtkindOptNonBreak, fTxtVisiBreaks, 
																	pilsobj->wchVisiNoBreak, pfmtr);
		case clabFESpace:
			if (pilsobj->grpf & fTxtVisiSpaces)
				return FormatSpecial(plnobj, wchFirst, pilsobj->wchVisiFESpace, fTrue, txtkindSpecSpace, pfmtin, pfmtr);		
			else
				return FormatSpecial(plnobj, wchFirst, wchFirst, fFalse, txtkindSpecSpace, pfmtin, pfmtr);
		case clabJoiner:
		case clabNonJoiner:
			return FormatStartOneRegularChar(plnobj, pfmtin, txtkindRegular, pfmtr);
		case clabToReplace:					/* backslash in FE Word				*/
			return FormatStartToReplace(plnobj, pfmtin, pfmtr);
			}
		}

	return lserrNone;
}

/* L S  D E S T R O Y  T X T  D O B J*/
/*----------------------------------------------------------------------------
    %%Function: LsDestroyTxtDObj
    %%Contact: sergeyge

    DestroyDObj method of the text handler.
----------------------------------------------------------------------------*/
LSERR WINAPI DestroyDObjText(PDOBJ pdobj)
{
	Unreferenced(pdobj);
	return lserrNone;
}

/* L S  S U B L I N E  F I N I S H E D  T E X T */
/*----------------------------------------------------------------------------
    %%Function: LsSublineFinishedText
    %%Contact: sergeyge

    Notification from Manager about finishing the subline
----------------------------------------------------------------------------*/
LSERR LsSublineFinishedText(PLNOBJ plnobj)
{
	Assert(plnobj->pilsobj->wchMac + 2 <= plnobj->pilsobj->wchMax);

	return IncreaseWchMacBy2(plnobj);

}

/* Internal Functions Implementation */

/* F O R M A T  R E G U L A R  C H A R A C T E R S */
/*----------------------------------------------------------------------------
    %%Function: FormatRegularCharacters
    %%Contact: sergeyge

    Formats run starting with the regular character.
	Ends as soon as any special character is encountered or
    right margin is achieved or
	all characters are processed.
----------------------------------------------------------------------------*/
static LSERR FormatRegularCharacters(PLNOBJ plnobj, PCFMTIN pfmtin, FMTRES* pfmtr)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long cwchGlobal;
	long iwchGlobal;
	long iwchLocal;
	long cwchLocal;
	long iwSpaces;

	long cwchMax;
	LSCP cpFirst;
	long durWidthExceed;
	WCHAR* rgwchGlobal;
	WCHAR* rgwchLocal;
	long rgwSpaces[cwchLocalMax];

	TXTOBJ* pdobjText;
	long durWidth;
	long ddur;
	BOOL fTerminateLoops;
	long dur;
	CLABEL clab;
	CLABEL* rgbSwitch;
	WCHAR wchSpace;
	long iwchGlobalNew;
	BOOL fInSpaces = fFalse;
	int i;
	int idur;

	pilsobj = plnobj->pilsobj;

	lserr = CreateFillTextDobj(plnobj, txtkindRegular, pfmtin, fFalse, &pdobjText);
	if (lserr != lserrNone) return lserr;

	rgbSwitch = pilsobj->rgbSwitch;
	wchSpace = pilsobj->wchSpace;
	rgwchGlobal = (WCHAR*)pfmtin->lsfrun.lpwchRun;
	cwchGlobal = (long)pfmtin->lsfrun.cwchRun;
	iwchGlobal = 0;
	fTerminateLoops = fFalse;
	durWidthExceed = pfmtin->lsfgi.urColumnMax - pfmtin->lsfgi.urPen;

	cpFirst = pfmtin->lsfgi.cpFirst;
	dur = 0;

	while (iwchGlobal < cwchGlobal && !fTerminateLoops)
		{
		rgwchLocal = &rgwchGlobal[iwchGlobal];

		cwchMax = cwchGlobal - iwchGlobal;
		if (cwchMax > cwchLocalMax)
			cwchMax = cwchLocalMax;

		lserr = GetWidths(plnobj, pfmtin->lsfrun.plsrun, pdobjText->iwchLim, rgwchLocal, 
					cpFirst, cwchMax, durWidthExceed, pfmtin->lsfgi.lstflow, &cwchLocal, &durWidth);
		if (lserr != lserrNone) return lserr;

		iwchLocal = 0;
		iwSpaces = 0;		

		while (iwchLocal < cwchLocal /*&& !fTerminateLoops*/)
			{
			if (rgbSwitch[rgwchLocal[iwchLocal] & 0x00FF] == clabRegular)
				iwchLocal++;
			else if (rgwchLocal[iwchLocal] == wchSpace)
				{
				if (!pfmtin->lsfrun.plschp->fBorder)
					{
					rgwSpaces[iwSpaces] = iwchLocal;
					iwchLocal++;
					iwSpaces++;
					}
				else
					{
					fTerminateLoops = fTrue;

					durWidth = 0;
					for (i = 0, idur = pdobjText->iwchLim; i < iwchLocal; i++, idur++)
						durWidth += pilsobj->pdur[idur];
					break; /* This break is equivalent to the check commented out in the loop condition */
					}
				}
			else
				{
				clab = ClabFromChar(pilsobj, rgwchLocal[iwchLocal]);
				
				if (clab == clabRegular)
					{
					iwchLocal++;
					}
				else
					{
					/* Terminate loops (and processing of run) for any special character */
					fTerminateLoops = fTrue;

					durWidth = 0;
					for (i = 0, idur = pdobjText->iwchLim; i < iwchLocal; i++, idur++)
						durWidth += pilsobj->pdur[idur];

					break; /* This break is equivalent to the check commented out in the loop condition */
					}
				}
			}

		if (iwchLocal != 0)
			{

			fInSpaces = fFalse;
	
			lserr = FormatString(plnobj, pdobjText, rgwchLocal, iwchLocal, rgwSpaces, iwSpaces, durWidth);
			if (lserr != lserrNone) return lserr;

			iwchGlobal += iwchLocal;
			durWidthExceed -= durWidth;

			Assert(dur < uLsInfiniteRM); /* We can be sure of it because dur is 0 during first iteration,
											and we check for uLsInfiniteRM in the TrailingSpaces logic */
			Assert(durWidth < uLsInfiniteRM);

			dur += durWidth;

			cpFirst += iwchLocal;
			
			if (cwchLocal == iwchLocal && durWidthExceed < 0)
				{
				if (rgwchLocal[cwchLocal-1] == wchSpace)
					{
					fInSpaces = fTrue;
					if (iwchGlobal < cwchGlobal && pilsobj->wchSpace == rgwchGlobal[iwchGlobal])
						{
						lserr = AppendTrailingSpaces(plnobj, pdobjText, rgwchGlobal,
													(DWORD)iwchGlobal, cwchGlobal, &iwchGlobalNew, &ddur);
						if (lserr != lserrNone) return lserr;

						if (iwchGlobalNew != iwchGlobal)
							{
							cpFirst += (iwchGlobalNew - iwchGlobal);
							iwchGlobal = iwchGlobalNew;

							Assert (ddur <= uLsInfiniteRM - dur);

							if (ddur > uLsInfiniteRM - dur)
								return lserrTooLongParagraph;

							dur += ddur;
							}
						}
					}
				else
					fTerminateLoops = fTrue;
				}

			}  /* if iwchLocal != 0                                      */ 					
	
		}      /* while iwchGlobal < cwchGlobal && !fTerminateLoops       */


	Assert(iwchGlobal == pdobjText->iwchLim - pdobjText->iwchFirst);
	Assert(iwchGlobal > 0);

	lserr = FillRegularPresWidths(plnobj, pfmtin->lsfrun.plsrun, pfmtin->lsfgi.lstflow, pdobjText);
	if (lserr != lserrNone) return lserr;

	if ((pilsobj->grpf & fTxtVisiSpaces) && pfmtin->lsfgi.cpFirst >= 0)
		{
		FixSpaces(plnobj, pdobjText, pilsobj->wchVisiSpace);
		}

	*pfmtr = fmtrCompletedRun;	

	if (durWidthExceed < 0 && !fInSpaces)
		{
	   	*pfmtr = fmtrExceededMargin;
		}

	lserr = FillRealFmtOut(pilsobj, iwchGlobal, dur, pdobjText, pfmtin,
		iwchGlobal == pdobjText->u.reg.iwSpacesLim - pdobjText->u.reg.iwSpacesFirst);

	return lserr;
	
}



/* C R E A T E  F I L L  T E X T  D O B J */
/*----------------------------------------------------------------------------
    %%Function: CreateFillTextDobj
    %%Contact: sergeyge

	Requests pointer to the new text DObj and then fills common memebers
----------------------------------------------------------------------------*/
static LSERR CreateFillTextDobj(PLNOBJ plnobj, long txtkind, PCFMTIN pfmtin, BOOL fIgnoreGlyphs,
																				TXTOBJ** ppdobjText)
{
	LSERR lserr;
	PILSOBJ pilsobj;

	pilsobj = plnobj->pilsobj;

	lserr = GetTextDobj(plnobj, ppdobjText);
	if (lserr != lserrNone) return lserr;

	(*ppdobjText)->txtkind = (BYTE)txtkind;
	(*ppdobjText)->plnobj = plnobj;
	(*ppdobjText)->plsdnUpNode = pfmtin->plsdnTop;

	if (pfmtin->lstxmPres.fMonospaced)
		(*ppdobjText)->txtf |= txtfMonospaced;

	(*ppdobjText)->iwchFirst = pilsobj->wchMac;
	(*ppdobjText)->iwchLim = pilsobj->wchMac;
	

	if (txtkind == txtkindRegular)
		{
		(*ppdobjText)->u.reg.iwSpacesFirst = pilsobj->wSpacesMac;
		(*ppdobjText)->u.reg.iwSpacesLim = pilsobj->wSpacesMac;
		}
	
	if (!fIgnoreGlyphs && pfmtin->lsfrun.plschp->fGlyphBased)
		(*ppdobjText)->txtf |= txtfGlyphBased;
	

	return lserrNone;
}

/* G E T  T E X T  D O B J */
/*----------------------------------------------------------------------------
    %%Function: GetTextDobj
    %%Contact: sergeyge

	Produces pointer of the first unoccupied DObj from the preallocated chunk.
	If nothing is left, allocates next piece and includes it in the linked list.
----------------------------------------------------------------------------*/
static LSERR GetTextDobj(PLNOBJ plnobj, TXTOBJ** ppdobjText)
{
	PILSOBJ pilsobj;
	TXTOBJ* ptxtobj;

	pilsobj = plnobj->pilsobj;

	if (pilsobj->txtobjMac < txtobjMaxM)
		{
		*ppdobjText = &plnobj->ptxtobj[pilsobj->txtobjMac];
		pilsobj->txtobjMac++;
		}
	else
		{
		/* if nothing is left in the active piece, there are still two possibilities:
			either there is next preallocated (during the formatting of the previous lines piece
			or next piece should be allocated
		*/
		if ( *(TXTOBJ**)(plnobj->ptxtobj + txtobjMaxM) == NULL)
			{
			ptxtobj = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(TXTOBJ) * txtobjMaxM + sizeof(TXTOBJ**));
			if (ptxtobj == NULL)
				{
				return lserrOutOfMemory;
				}
			*(TXTOBJ**)(ptxtobj + txtobjMaxM) = NULL;
			*(TXTOBJ**)(plnobj->ptxtobj + txtobjMaxM) = ptxtobj;
			plnobj->ptxtobj = ptxtobj;
			}
		else
			{
			plnobj->ptxtobj = *(TXTOBJ**)(plnobj->ptxtobj + txtobjMaxM);
			}
  		*ppdobjText = plnobj->ptxtobj;
  		pilsobj->txtobjMac = 1;
		}

	memset(*ppdobjText, 0, sizeof(**ppdobjText));

	return lserrNone;
}


/* F I L L  R E A L  F M T  O U T */
/*----------------------------------------------------------------------------
    %%Function: FillRealFmtOut
    %%Contact: sergeyge

	Sets dup in dobj and
	calls to LsdnFinishSimpleRegular for the regular case (real upper node)
----------------------------------------------------------------------------*/

static LSERR FillRealFmtOut(PILSOBJ pilsobj, LSDCP lsdcp, long dur, TXTOBJ* pdobjText, PCFMTIN pfmtin,
																						 BOOL fSpacesOnly)
{
	LSERR lserr;
	OBJDIM objdim;

	objdim.dur = dur;

	objdim.heightsPres.dvAscent = pfmtin->lstxmPres.dvAscent;
	objdim.heightsRef.dvAscent = pfmtin->lstxmRef.dvAscent;
	objdim.heightsPres.dvDescent = pfmtin->lstxmPres.dvDescent;
	objdim.heightsRef.dvDescent = pfmtin->lstxmRef.dvDescent;
	objdim.heightsPres.dvMultiLineHeight = pfmtin->lstxmPres.dvMultiLineHeight;
	objdim.heightsRef.dvMultiLineHeight = pfmtin->lstxmRef.dvMultiLineHeight;

	if (fSpacesOnly)
		{
		if (!(pilsobj->grpf & fTxtSpacesInfluenceHeight))
			{
			objdim.heightsRef.dvMultiLineHeight = dvHeightIgnore;
			objdim.heightsPres.dvMultiLineHeight = dvHeightIgnore;
			}
		}


	/* It is ugly to set part of FetchedWidth state here, but it is absolutely needed
		to fix bug 546. iwchFetchedWidthFirst was introduced to fix this bug
	*/
	if (lsdcp < pfmtin->lsfrun.cwchRun)
		pilsobj->wchFetchedWidthFirst = pfmtin->lsfrun.lpwchRun[lsdcp];
	else
		FlushStringState(pilsobj);  /* Next char is not available---it is risky to use optimization */

	lserr = LsdnFinishRegular(pilsobj->plsc, lsdcp,
							pfmtin->lsfrun.plsrun, pfmtin->lsfrun.plschp, (PDOBJ)pdobjText, &objdim);
	return lserr;	
}


/* A P P E N D  T R A I L I N G  S P A C E S */
/*----------------------------------------------------------------------------
    %%Function: AppendTrailingSpaces
    %%Contact: sergeyge

	Trailing spaces logic.
----------------------------------------------------------------------------*/
static LSERR AppendTrailingSpaces(PLNOBJ plnobj, TXTOBJ* pdobjText, WCHAR* rgwchGlobal,
									 long iwchGlobal, long cwchGlobal,
									 long* iwchGlobalNew, long* pddur)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long iNumOfSpaces;
	long durSpace;

	pilsobj = plnobj->pilsobj;

	Assert(iwchGlobal < cwchGlobal && pilsobj->wchSpace == rgwchGlobal[iwchGlobal]);

	iNumOfSpaces = 1;
	iwchGlobal++;

	while (iwchGlobal < cwchGlobal && pilsobj->wchSpace == rgwchGlobal[iwchGlobal])
		{
		iNumOfSpaces++;
		iwchGlobal++;
		}

	*iwchGlobalNew = iwchGlobal;

	Assert(pilsobj->pwchOrig[pdobjText->iwchLim - 1] == pilsobj->wchSpace);

	durSpace = pilsobj->pdur[pdobjText->iwchLim - 1];

	Assert (iNumOfSpaces > 0);
	Assert(durSpace <= uLsInfiniteRM / iNumOfSpaces);

	if (durSpace > uLsInfiniteRM / iNumOfSpaces)
		return lserrTooLongParagraph;

	*pddur = durSpace * iNumOfSpaces;

	/* Calls function of the string module level */
	lserr = AddSpaces(plnobj, pdobjText, durSpace, iNumOfSpaces);

	return lserr;
}

/* F O R M A T  S T A R T  E M P T Y  D O B J */
/*----------------------------------------------------------------------------
    %%Function: FormatStartEmptyDobj
    %%Contact: sergeyge

	NonReqHyphen/OptionalBreak/OptionalNonBreak logic
----------------------------------------------------------------------------*/
static LSERR FormatStartEmptyDobj(PLNOBJ plnobj, PCFMTIN pfmtin, long txtkind, DWORD fTxtVisi,
																		WCHAR wchVisi, FMTRES* pfmtr)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	TXTOBJ* pdobjText;
	PLSRUN plsrun;
	long dup;
/*	long durOut = 0; */

	pilsobj = plnobj->pilsobj;
	plsrun = pfmtin->lsfrun.plsrun;

	lserr = CreateFillTextDobj(plnobj, txtkind, pfmtin, fTrue, &pdobjText);
	if (lserr != lserrNone) return lserr;

	pdobjText->txtf |= txtfSkipAtNti;
	pilsobj->fDifficultForAdjust = fTrue;

	if (pilsobj->grpf & fTxtVisi)
		{
		Assert(pilsobj->fDisplay);

		/* Imitate formatting for 1-char string without writing in the string level structures */	
/*		lserr = GetOneCharDur(pilsobj, plsrun, pilsobj->wchHyphen, pfmtin->lsfgi.lstflow, &durOut);
		if (lserr != lserrNone) return lserr;
*/
		pdobjText->txtf |= txtfSkipAtWysi;
		pdobjText->txtf |= txtfVisi;

		lserr = GetVisiCharDup(pilsobj, plsrun, wchVisi, pfmtin->lsfgi.lstflow, &dup);
		if (lserr != lserrNone) return lserr;

/*	Restore this code instead of current one if Word wants to keep differences in breaking

		lserr = AddCharacterWithWidth(plnobj, pdobjText, pilsobj->wchHyphen, durOut, wchVisi, dup);
	   	if (lserr != lserrNone) return lserr;

		lserr = FillRealFmtOut(pilsobj, 1, durOut, pdobjText, pfmtin, fFalse);
	   	if (lserr != lserrNone) return lserr;
*/
		lserr = AddCharacterWithWidth(plnobj, pdobjText, pilsobj->wchHyphen, 0, wchVisi, dup);
	   	if (lserr != lserrNone) return lserr;

		lserr = FillRealFmtOut(pilsobj, 1, 0, pdobjText, pfmtin, fTrue);
	   	if (lserr != lserrNone) return lserr;
		}
	else
		{
		lserr = FillRealFmtOut(pilsobj, 1, 0, pdobjText, pfmtin, fTrue);
	   	if (lserr != lserrNone) return lserr;
		FlushStringState(pilsobj);  /* Position of fetched widths is not correct any longer */
		}

	*pfmtr = fmtrCompletedRun;	

	return lserrNone;
}

/* F O R M A T  S T A R T  T A B  */
/*----------------------------------------------------------------------------
    %%Function: FormatStartTab
    %%Contact: sergeyge

	Tab logic
----------------------------------------------------------------------------*/
static LSERR FormatStartTab(PLNOBJ plnobj, PCFMTIN pfmtin, FMTRES* pfmtr)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ pdobjText;
	int durJunk;
	long cJunk;

	pilsobj = plnobj->pilsobj;

	lserr = CreateFillTextDobj(plnobj, txtkindTab, pfmtin, fTrue, &pdobjText);
	if (lserr != lserrNone) return lserr;

	pdobjText->u.tab.wchTabLeader = pilsobj->wchSpace;

	if (pilsobj->grpf & fTxtVisiTabs)
		{
		Assert(pilsobj->fDisplay);
		pdobjText->txtf |= txtfVisi;
		/* REVIEW sergeyge: Next call is made to show Visi Tab correctly in WORD
			it should be moved to the WAL */
		(*pilsobj->plscbk->pfnGetRunCharWidths)(pilsobj->pols, pfmtin->lsfrun.plsrun,
					lsdevPres, &pilsobj->wchVisiTab, 1, LONG_MAX, pfmtin->lsfgi.lstflow,
					&durJunk, (long*)&durJunk, &cJunk);
		pdobjText->u.tab.wch = 	pilsobj->wchVisiTab;
		}
	else
		{
		pdobjText->u.tab.wch = 	pfmtin->lsfrun.lpwchRun[0];
		}

	lserr = AddCharacterWithWidth(plnobj, pdobjText, pfmtin->lsfrun.lpwchRun[0], 0, 
															pfmtin->lsfrun.lpwchRun[0], 0);
   	if (lserr != lserrNone) return lserr;

	lserr = FillRealFmtOut(pilsobj, 1, 0, pdobjText, pfmtin, fTrue);
   	if (lserr != lserrNone) return lserr;

	*pfmtr = fmtrTab;

	return lserrNone;
}

/* F O R M A T  S T A R T  B O R D E R E D  S P A C E S */
/*----------------------------------------------------------------------------
    %%Function: FormatStartBorderedSpaces
    %%Contact: sergeyge

	Formatting od the spaces within bordered run
----------------------------------------------------------------------------*/
static LSERR FormatStartBorderedSpaces(PLNOBJ plnobj, PCFMTIN pfmtin, FMTRES* pfmtr)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	TXTOBJ* pdobjText;
	long durSpace;
	DWORD iNumOfSpaces;

	pilsobj = plnobj->pilsobj;

	lserr = CreateFillTextDobj(plnobj, txtkindRegular, pfmtin, fFalse, &pdobjText);
	if (lserr != lserrNone) return lserr;

	Assert(pfmtin->lsfrun.lpwchRun[0] == pilsobj->wchSpace);

	/* fill additional information for txtkindYsrChar text DObj */
	lserr = GetOneCharDur(pilsobj, pfmtin->lsfrun.plsrun, pilsobj->wchSpace, pfmtin->lsfgi.lstflow, &durSpace);
	if (lserr != lserrNone) return lserr;

	iNumOfSpaces = 0;

	while (pilsobj->wchSpace == pfmtin->lsfrun.lpwchRun[iNumOfSpaces] && iNumOfSpaces < pfmtin->lsfrun.cwchRun)
		{
		iNumOfSpaces++;
		}

	/* Calls functions of the string module level */
	lserr = AddSpaces(plnobj, pdobjText, durSpace, iNumOfSpaces);
	if (lserr != lserrNone) return lserr;

	lserr = FillRegularPresWidths(plnobj, pfmtin->lsfrun.plsrun, pfmtin->lsfgi.lstflow, pdobjText);
	if (lserr != lserrNone) return lserr;

	if ((pilsobj->grpf & fTxtVisiSpaces) && pfmtin->lsfgi.cpFirst >= 0)
		{
		FixSpaces(plnobj, pdobjText, pilsobj->wchVisiSpace);
		}


	*pfmtr = fmtrCompletedRun;	

	lserr = FillRealFmtOut(pilsobj, iNumOfSpaces, durSpace * iNumOfSpaces, pdobjText,  pfmtin, fTrue);
	if (lserr != lserrNone) return lserr;

	return lserrNone;
}


/* F O R M A T  S T A R T  O N E  R E G U L A R  C H A R  */
/*----------------------------------------------------------------------------
    %%Function: FormatStartOneRegularChar
    %%Contact: sergeyge

	YSR/(NonSignificant for this paragraph EOP) character logic.
----------------------------------------------------------------------------*/
static LSERR FormatStartOneRegularChar(PLNOBJ plnobj, PCFMTIN pfmtin, long txtkind, FMTRES* pfmtr)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	TXTOBJ* pdobjText;
	long durOut;
	long dupOut;
	WCHAR wch;

	pilsobj = plnobj->pilsobj;

	lserr = CreateFillTextDobj(plnobj, txtkind, pfmtin, fFalse, &pdobjText);
	if (lserr != lserrNone) return lserr;

	wch = pfmtin->lsfrun.lpwchRun[0];

	/* fill additional information for txtkindYsrChar text DObj */
	lserr = GetOneCharDur(pilsobj, pfmtin->lsfrun.plsrun, wch, pfmtin->lsfgi.lstflow, &durOut);
	if (lserr != lserrNone) return lserr;

	lserr = GetOneCharDup(pilsobj, pfmtin->lsfrun.plsrun, wch, pfmtin->lsfgi.lstflow, durOut, &dupOut);
	if (lserr != lserrNone) return lserr;

	Assert(durOut < uLsInfiniteRM);

	lserr = AddCharacterWithWidth(plnobj, pdobjText, wch, durOut, wch, dupOut);

	*pfmtr = fmtrCompletedRun;	

	if (durOut > pfmtin->lsfgi.urColumnMax - pfmtin->lsfgi.urPen)
		{
	   	*pfmtr = fmtrExceededMargin;
		}

	lserr = FillRealFmtOut(pilsobj, 1, durOut, pdobjText,  pfmtin, fFalse);
	if (lserr != lserrNone) return lserr;

	return lserrNone;
}

/* F O R M A T  S T A R T  T O  R E P L A C E  */
/*----------------------------------------------------------------------------
    %%Function: FormatStartToReplace
    %%Contact: sergeyge

	Implements replacement of one char code ("\") by another (Yen)
----------------------------------------------------------------------------*/
static LSERR FormatStartToReplace(PLNOBJ plnobj, PCFMTIN pfmtin, FMTRES* pfmtr)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	TXTOBJ* pdobjText;
	WCHAR wch;
	long durOut;
	long dupOut;

	pilsobj = plnobj->pilsobj;

	lserr = CreateFillTextDobj(plnobj, txtkindRegular, pfmtin, fFalse, &pdobjText);
	if (lserr != lserrNone) return lserr;

	/* fill additional information for txtkindYsrChar text DObj */

	if (pfmtin->lsfrun.plschp->fCheckForReplaceChar)
		wch = pilsobj->wchReplace;
	else
		wch = pfmtin->lsfrun.lpwchRun[0];

	lserr = GetOneCharDur(pilsobj, pfmtin->lsfrun.plsrun, wch, pfmtin->lsfgi.lstflow, &durOut);
	if (lserr != lserrNone) return lserr;

	lserr = GetOneCharDup(pilsobj, pfmtin->lsfrun.plsrun, wch, pfmtin->lsfgi.lstflow, durOut, &dupOut);
	if (lserr != lserrNone) return lserr;

	Assert(durOut < uLsInfiniteRM);

	lserr = AddCharacterWithWidth(plnobj, pdobjText, wch, durOut, wch, dupOut);

	*pfmtr = fmtrCompletedRun;	

	if (durOut > pfmtin->lsfgi.urColumnMax - pfmtin->lsfgi.urPen)
		{
	   	*pfmtr = fmtrExceededMargin;
		}

	lserr = FillRealFmtOut(pilsobj, 1, durOut, pdobjText,  pfmtin, fFalse);
	if (lserr != lserrNone) return lserr;

	return lserrNone;
}


/* F O R M A T  S T A R T  E O L  */
/*----------------------------------------------------------------------------
    %%Function: FormatStartEop
    %%Contact: sergeyge

	EOP/SoftCR logic.
----------------------------------------------------------------------------*/
static LSERR FormatStartEol(PLNOBJ plnobj, PCFMTIN pfmtin, WCHAR wchVisiEnd, STOPRES stopr, FMTRES* pfmtr)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLSRUN plsrun;
	TXTOBJ* pdobjText;
	WCHAR wchAdd;
	long dupWch;
	long durWch;
	BOOL fInChildList;
	OBJDIM objdim;

	pilsobj = plnobj->pilsobj;
	plsrun = pfmtin->lsfrun.plsrun;

	lserr = LsdnFInChildList(pilsobj->plsc, pfmtin->plsdnTop, &fInChildList);
   	Assert(lserr == lserrNone);

	if (fInChildList)
		return FormatStartOneRegularChar(plnobj, pfmtin, txtkindRegular, pfmtr);

	*pfmtr = fmtrStopped;

	/* CreateFillTextDobj section starts */

	lserr = GetTextDobj(plnobj, &pdobjText);
	if (lserr != lserrNone) return lserr;

	pdobjText->txtkind = txtkindEOL;
	pdobjText->plnobj = plnobj;
	pdobjText->plsdnUpNode = pfmtin->plsdnTop;

	pdobjText->iwchFirst = pilsobj->wchMac;
	
	/* CreateFillTextDobj section ends */

	pdobjText->txtf |= txtfSkipAtNti;


	if (pilsobj->grpf & fTxtVisiParaMarks) 
		wchAdd = wchVisiEnd;
	else
		wchAdd = pilsobj->wchSpace;

	
	if (pilsobj->fDisplay)
		{
		lserr = GetVisiCharDup(pilsobj, plsrun, wchVisiEnd, pfmtin->lsfgi.lstflow, &dupWch);
		if (lserr != lserrNone) return lserr;
		durWch = UrFromUp(pfmtin->lsfgi.lstflow, &pilsobj->lsdevres, dupWch);
		plnobj->pwch[pilsobj->wchMac] = wchAdd;
		plnobj->pdup[pilsobj->wchMac] = dupWch;
		}
	else
		{
		durWch = 1;
		}


	Assert(durWch < uLsInfiniteRM);

	pilsobj->pwchOrig[pilsobj->wchMac] = wchAdd;
	pilsobj->pdur[pilsobj->wchMac] = durWch;

	/* AddCharacterWithWidth section starts---parts of it were moved up	*/
	/* We do not check for sufficient space in allocated arrays becayse anyway we allocate for 2 additional
			characters due to possible changes at hyphenation time
	*/
	pilsobj->dcpFetchedWidth = 0;

	pilsobj->wchMac++;

	pdobjText->iwchLim = pilsobj->wchMac;

	Assert(pdobjText->iwchLim == pdobjText->iwchFirst + 1);

	/* AddCharacterWithWidth section ends	*/

	/* FillRealFmtOut section starts	*/

	objdim.dur = durWch;

	objdim.heightsPres.dvAscent = pfmtin->lstxmPres.dvAscent;
	objdim.heightsRef.dvAscent = pfmtin->lstxmRef.dvAscent;
	objdim.heightsPres.dvDescent = pfmtin->lstxmPres.dvDescent;
	objdim.heightsRef.dvDescent = pfmtin->lstxmRef.dvDescent;
	objdim.heightsPres.dvMultiLineHeight = pfmtin->lstxmPres.dvMultiLineHeight;
	objdim.heightsRef.dvMultiLineHeight = pfmtin->lstxmRef.dvMultiLineHeight;

	if (!(pilsobj->grpf & fTxtSpacesInfluenceHeight))
		{
		objdim.heightsRef.dvMultiLineHeight = dvHeightIgnore;
		objdim.heightsPres.dvMultiLineHeight = dvHeightIgnore;
		}

	lserr = LsdnSetStopr(pilsobj->plsc, pfmtin->plsdnTop, stopr);
	Assert(lserr == lserrNone);
	lserr = LsdnFinishRegular(pilsobj->plsc, 1,
							pfmtin->lsfrun.plsrun, pfmtin->lsfrun.plschp, (PDOBJ)pdobjText, &objdim);
	return lserr;	
}

/* F O R M A T  S T A R T  D E L E T E  */
/*----------------------------------------------------------------------------
    %%Function: FormatStartDelete
    %%Contact: sergeyge

	Formatting by Delete upper dnode
----------------------------------------------------------------------------*/
static LSERR FormatStartDelete(PLNOBJ plnobj, LSDCP dcp, FMTRES* pfmtr)
{
	PILSOBJ pilsobj;

	pilsobj = plnobj->pilsobj;

	FlushStringState(pilsobj);  /* Position of fetched widths is not correct any longer */

	*pfmtr = fmtrCompletedRun;

	return LsdnFinishDelete(pilsobj->plsc, dcp);
}	

/* F O R M A T  S T A R T  S P L A T  */
/*----------------------------------------------------------------------------
    %%Function: FormatStartSplat
    %%Contact: sergeyge

	Splat formatting logic
----------------------------------------------------------------------------*/
static LSERR FormatStartSplat(PLNOBJ plnobj, PCFMTIN pfmtin, STOPRES stopr, FMTRES* pfmtr)
{
	*pfmtr = fmtrStopped;
	LsdnSetStopr(plnobj->pilsobj->plsc, pfmtin->plsdnTop, stopr);
	return FillRealFmtOut(plnobj->pilsobj, 1, 0, NULL,  pfmtin, fTrue);
}

/* F O R M A T  S P E C I A L  */
/*----------------------------------------------------------------------------
    %%Function: FormatSpecial
    %%Contact: sergeyge

	Formatting of the special characters (not NonReqHyphen, not Tab)
	Uses wchRef for formatting on reference device, wchPres--on preview device
----------------------------------------------------------------------------*/
static LSERR FormatSpecial(PLNOBJ plnobj, WCHAR wchRef, WCHAR wchPres, BOOL fVisible, long txtkind, 
											PCFMTIN pfmtin, FMTRES* pfmtr)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ pdobjText;
	PLSRUN plsrun;
	long dur;
	long dup;
	long durGlobal;
	long cwchRun;
	const WCHAR* pwchRun;
	long iNumOfChars;
	long durWidth;
	long i;

	pilsobj = plnobj->pilsobj;
	plsrun = pfmtin->lsfrun.plsrun;

	lserr = CreateFillTextDobj(plnobj, txtkind, pfmtin, fTrue, &pdobjText);
	if (lserr != lserrNone) return lserr;

	durWidth = pfmtin->lsfgi.urColumnMax - pfmtin->lsfgi.urPen;

	/* Imitate formatting for 1-char string without writing in the string level structures */	
	lserr = GetOneCharDur(pilsobj, plsrun, wchRef, pfmtin->lsfgi.lstflow, &dur);
	if (lserr != lserrNone) return lserr;

	/* Calculate presentation width */
	Assert(wchPres == wchRef || fVisible);
	if (fVisible)
		{
		long dupOrig;

		pilsobj->fDifficultForAdjust = fTrue;
		lserr = GetVisiCharDup(pilsobj, plsrun, wchPres, pfmtin->lsfgi.lstflow, &dup);
		if (lserr != lserrNone) return lserr;
		lserr = GetOneCharDup(pilsobj, plsrun, wchPres, pfmtin->lsfgi.lstflow, dur, &dupOrig);
		if (lserr != lserrNone) return lserr;
		if (dup != dupOrig)
			pdobjText->txtf |= txtfSkipAtWysi;
		}
	else
		{
		lserr = GetOneCharDup(pilsobj, plsrun, wchPres, pfmtin->lsfgi.lstflow, dur, &dup);
		if (lserr != lserrNone) return lserr;
		}

	cwchRun = (long)pfmtin->lsfrun.cwchRun;

	pwchRun = pfmtin->lsfrun.lpwchRun;

	/* check if there are a few identical characters and calculate their number -- we can format them all at once */
	for (iNumOfChars = 1; iNumOfChars < cwchRun && pwchRun[0] == pwchRun[iNumOfChars]; iNumOfChars++);

	durGlobal = 0;

	Assert(iNumOfChars > 0);
	Assert (dur <= uLsInfiniteRM / iNumOfChars);

	if (dur > uLsInfiniteRM / iNumOfChars)
		return lserrTooLongParagraph;

	/*  Don't forget to write at least one char even if pen was positioned behind right margin	*/

	lserr = AddCharacterWithWidth(plnobj, pdobjText, wchRef, dur, wchPres, dup);
	if (lserr != lserrNone) return lserr;
	durWidth -= dur;
	durGlobal += dur;
	
	for (i = 1; i < iNumOfChars && (durWidth >= 0 || txtkind == txtkindSpecSpace); i++)
		{
		lserr = AddCharacterWithWidth(plnobj, pdobjText, wchRef, dur, wchPres, dup);
   		if (lserr != lserrNone) return lserr;
		durWidth -= dur;
		durGlobal += dur;
		}

	iNumOfChars = i;

	*pfmtr = fmtrCompletedRun;

	if (durWidth < 0 && txtkind != txtkindSpecSpace)   /* Don't stop formatting while in spaces	*/
   		*pfmtr = fmtrExceededMargin;

	if (fVisible)
		pdobjText->txtf |= txtfVisi;

	lserr = FillRealFmtOut(pilsobj, iNumOfChars, durGlobal, pdobjText, pfmtin,
																txtkind == txtkindSpecSpace);
	if (lserr != lserrNone) return lserr;


	return lserrNone;
}

/* F M T R  H A R D  B R E A K */
/*----------------------------------------------------------------------------
    %%Function: FmtrHardBreak
    %%Contact: sergeyge

	Calculates fmtr based on clab for the hard breaks.
----------------------------------------------------------------------------*/
static STOPRES StoprHardBreak(CLABEL clab)
{
	switch (clab)
		{
	case clabSectionBreak:
		return stoprEndSection;
	case clabPageBreak:
		return stoprEndPage;
	case clabColumnBreak:
		return stoprEndColumn;
	default:
		NotReached();
		return 0;
		}
}

/* C L A B  F R O M  C H A R */
/*----------------------------------------------------------------------------
    %%Function: ClabFromChar
    %%Contact: sergeyge

	Calculates clab for wch
----------------------------------------------------------------------------*/
static CLABEL ClabFromChar(PILSOBJ pilsobj, WCHAR wch)            /* REVIEW sergeyge   - the whole procedure can be fixed */
{
	DWORD i;

	if (wch < 0x00FF)
		{
		return (CLABEL)(pilsobj->rgbSwitch[wch] & fSpecMask);
		}
	else
		{
		if (pilsobj->rgbSwitch[wch & 0x00FF] & clabSuspicious)
			{
/*
REVIEW sergeyge (elik) It does not make sense to make bin search while
there are two wide special characters only. It would make sense to switch
to binary search as soon as this number is more than 4.
*/
			for (i=0; i < pilsobj->cwchSpec && wch != pilsobj->rgwchSpec[i]; i++);
			if (i == pilsobj->cwchSpec)
				{
				return clabRegular;
				}
			else
				{
				return pilsobj->rgbKind[i];
				}
			}
		else
			{
			return clabRegular;
			}
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lstxtmod.c ===
#include "lstxtmod.h"

#include "lsems.h"
#include "txtils.h"

void GetChanges(LSACT lsact, LSEMS* plsems, long durCur, BOOL fByIsPlus, BYTE* pside, long* pddurChange)
{
	*pside = lsact.side;
	switch (lsact.kamnt)
		{
	case kamntNone:
		*pddurChange = 0;
		break;
	case kamntToHalfEm:
		*pddurChange = plsems->em2 - durCur;
		break;
	case kamntToQuarterEm:
		*pddurChange = plsems->em4 - durCur;
		break;
	case kamntToThirdEm:
		*pddurChange = plsems->em3 - durCur;
		break;
	case kamntTo15Sixteenth:
		*pddurChange = plsems->em16 - durCur;
		break;
	case kamntToUserDefinedExpan:
		*pddurChange = plsems->udExp - durCur;
		break;
	case kamntToUserDefinedComp:
		*pddurChange = plsems->udComp - durCur;
		break;
	case kamntByHalfEm:
		if (fByIsPlus)
			*pddurChange = plsems->em2;
		else
			*pddurChange = -plsems->em2;
		break;
	case kamntByQuarterEm:
		if (fByIsPlus)
			*pddurChange = plsems->em4;
		else
			*pddurChange = -plsems->em4;
		break;
	case kamntByEighthEm:
		if (fByIsPlus)
			*pddurChange = plsems->em8;
		else
			*pddurChange = -plsems->em8;
		break;
	case kamntByUserDefinedExpan:
		if (fByIsPlus)
			*pddurChange = plsems->udExp;
		else
			*pddurChange = -plsems->udExp;
		break;
	case kamntByUserDefinedComp:
		if (fByIsPlus)
			*pddurChange = plsems->udComp;
		else
			*pddurChange = -plsems->udComp;
		break;
	default:
		Assert(fFalse);
		}

	if (*pddurChange < -durCur)
		*pddurChange = -durCur;

}

void TranslateChanges(BYTE sideRecom, long durAdjustRecom, long durCur, long durRight, long durLeft,
														 BYTE* psideFinal, long* pdurChange)
{
	long durLeftRecom = 0;
	long durRightRecom = 0;

	Assert(sideRecom != sideNone);

	switch (sideRecom)
		{
	case sideRight:
		durLeftRecom = 0;
		durRightRecom = durAdjustRecom - durRight;
		break;
	case sideLeft:
		durRightRecom = 0;
		durLeftRecom = durAdjustRecom - durLeft;
		break;
	case sideLeftRight:
		durRightRecom = durAdjustRecom >> 1;
		durLeftRecom = durAdjustRecom - durRightRecom;
		durRightRecom -= durRight;
		durLeftRecom -= durLeft;
		break;
		}

	*psideFinal = sideNone;
	if (durRightRecom != 0 && durLeftRecom != 0)
		*psideFinal = sideLeftRight;
	else if (durRightRecom != 0)
		*psideFinal = sideRight;
	else if (durLeftRecom != 0)
		*psideFinal = sideLeft;

	*pdurChange = durLeftRecom + durRightRecom;

	if (*pdurChange < -durCur)
		*pdurChange = -durCur;
}

void ApplyChanges(PILSOBJ pilsobj, long iwch, BYTE side, long ddurChange)
{
	long ddurChangeLeft;
	long ddurChangeRight;

	pilsobj->pdur[iwch] += ddurChange;

	InterpretChanges(pilsobj, iwch, side, ddurChange, &ddurChangeLeft, &ddurChangeRight);
	Assert(ddurChange == ddurChangeLeft + ddurChangeRight);

	pilsobj->pdurLeft[iwch] += ddurChangeLeft;
	pilsobj->pdurRight[iwch] += ddurChangeRight;
}

void InterpretChanges(PILSOBJ pilsobj, long iwch, BYTE side, long ddurChange, long* pddurChangeLeft, long* pddurChangeRight)
{
	long ddurChangeLeftRight;

	switch (side)
		{
	case sideNone:
		Assert(ddurChange == 0);
		*pddurChangeLeft = 0;
		*pddurChangeRight = 0;
		break;
	case sideRight:
		Assert(pilsobj->pdurRight != NULL);
		*pddurChangeLeft = 0;
		*pddurChangeRight = ddurChange;
		break;
	case sideLeft:
		Assert(pilsobj->pdurLeft != NULL);
		*pddurChangeLeft = ddurChange;
		*pddurChangeRight = 0;
		break;
	case sideLeftRight:
		Assert(pilsobj->pdurRight != NULL);
		Assert(pilsobj->pdurLeft != NULL);
		ddurChangeLeftRight = ddurChange + pilsobj->pdurRight[iwch] + pilsobj->pdurLeft[iwch];
		*pddurChangeRight = (ddurChangeLeftRight >> 1) - pilsobj->pdurRight[iwch];
		*pddurChangeLeft = (ddurChange - *pddurChangeRight);
		break;
		}
}

void UndoAppliedChanges(PILSOBJ pilsobj, long iwch, BYTE side, long* pddurChange)
{
	Assert(side == sideRight || side == sideLeft);

	switch (side)
		{
	case sideRight:
		Assert(pilsobj->pdurRight != NULL);
		*pddurChange = -pilsobj->pdurRight[iwch];
		pilsobj->pdurRight[iwch] = 0;
		break;
	case sideLeft:
		Assert(pilsobj->pdurLeft != NULL);
		*pddurChange = -pilsobj->pdurLeft[iwch];
		pilsobj->pdurLeft[iwch] = 0;
		break;
		}

	pilsobj->pdur[iwch] += *pddurChange;
	
}

void ApplyGlyphChanges(PILSOBJ pilsobj, long igind, long ddurChange)
{
/*	while (pilsobj->pdurGind[igind] == 0 && !pislobj->ptxtginf[igind].fFirstInContext)
		igind--;
*/
	pilsobj->pdurGind[igind] += ddurChange;

	Assert(pilsobj->pduGright != NULL);
	pilsobj->pduGright[igind] += ddurChange;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lstxttab.c ===
#include "lstxttab.h"

#include "lstxtmap.h"
#include "lsdnset.h"
#include "objdim.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"


LSERR SetTabLeader(PDOBJ pdobj, WCHAR wch)
{
	Assert(((PTXTOBJ)pdobj)->txtkind == txtkindTab);
	
	((PTXTOBJ)pdobj)->u.tab.wchTabLeader = wch;

	return lserrNone;
}

/*  L S  G E T  D E C I M A L  P O I N T */
/*----------------------------------------------------------------------------
    %%Function: LsGetDecimalPoint
    %%Contact: sergeyge

	Finds dobj, containing decimal point and reports its index as well as
	relative and dur from the beginning of dobj until decimal point.
----------------------------------------------------------------------------*/
LSERR LsGetDecimalPoint(const LSGRCHNK* plsgrchnk, enum lsdevice lsdev, DWORD* pigrchnk, long* pduToDecimal)
{
	LSERR lserr;
	DWORD clsgrchnk;
	PLSCHNK rglschnk;
	POLS pols;
	PLSRUN plsrun;
	PLNOBJ ptxtln;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	WCHAR* rgwch;
	long* rgdu;
	long* rgwSpaces;
	long itxtobj;
	long iwch;
	long iwchSpace;
	long iwSpace;
	BOOL fInDigits;
	BOOL fDigit;
	WCHAR wchDec;
	WCHAR wchThou;
	BOOL fThouIsSpace;
	BOOL fFound;
	BOOL fRealPointFound;
	long iwchDecimal = 0;
	long du;
	BOOL fGlyphBased;
	long iFirst;
	long iLim;
	long iDecimal;
	long i;

	clsgrchnk = plsgrchnk->clsgrchnk;

	if (clsgrchnk == 0)
		{
		*pigrchnk = idobjOutside;
		*pduToDecimal = 0;
		return lserrNone;
		}

	rglschnk = plsgrchnk->plschnk;
	ptxtln = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj;
	pilsobj = ptxtln->pilsobj;
	pols = pilsobj->pols;
	rgwch = pilsobj->pwchOrig;
	rgwSpaces = pilsobj->pwSpaces;

	fInDigits = fFalse;
	fFound = fFalse;
	fRealPointFound = fFalse;
	
	for (itxtobj = 0; !fFound && itxtobj < (long)clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
		fGlyphBased = ptxtobj->txtf & txtfGlyphBased;
		plsrun = rglschnk[itxtobj].plsrun;
		lserr = (*pilsobj->plscbk->pfnGetNumericSeparators)(pols, plsrun, &wchDec, &wchThou);
		if (lserr != lserrNone) return lserr;
		fThouIsSpace = (wchThou == pilsobj->wchSpace || wchThou == pilsobj->wchNonBreakSpace);
		if (ptxtobj->txtkind == txtkindRegular)
			{
			iwSpace = ptxtobj->u.reg.iwSpacesFirst;
			if (iwSpace == ptxtobj->u.reg.iwSpacesLim)
				{
				iwchSpace = ptxtobj->iwchLim;
				}
			else
				{
				iwchSpace = rgwSpaces[iwSpace];
				}
			for (iwch = ptxtobj->iwchFirst; !fFound && iwch < ptxtobj->iwchLim; iwch++)
				{
				if (!fGlyphBased || FIwchOneToOne(pilsobj, iwch))
					{
					if (iwch == iwchSpace)
						{
						if (fInDigits && !fThouIsSpace)
							{
							iwchDecimal = iwch;
							fFound = fTrue;
							}
						else
							{
							iwSpace++;
							if (iwSpace == ptxtobj->u.reg.iwSpacesLim)
								{
								iwchSpace = ptxtobj->iwchLim;
								}
							else
								{
								iwchSpace = rgwSpaces[iwSpace];
								}
							}
						}
					else if (rgwch[iwch] == wchDec)
						{
						iwchDecimal = iwch;
						fFound = fTrue;
						fRealPointFound = fTrue;
						}
					else
						{
						lserr = (*pilsobj->plscbk->pfnCheckForDigit)(pols, plsrun, rgwch[iwch], &fDigit);
						if (lserr != lserrNone) return lserr;
						if (fDigit)
							{
							fInDigits = fTrue;
							}
						else
							{
							iwchDecimal = iwch;
							fFound = (fInDigits && rgwch[iwch] != wchThou);
							}
						}
					}
				} /* for (iwch= ... */
			}     /* if (txtkind == txtkindRegular */
		else if (ptxtobj->txtkind == txtkindNonBreakSpace)
			{
			if (fInDigits && !fThouIsSpace)
				{
				iwchDecimal = ptxtobj->iwchFirst;
				fFound = fTrue;
				}
			}
		else if (ptxtobj->txtkind == txtkindEOL)
			{
			iwchDecimal = ptxtobj->iwchFirst;
			fFound = fTrue;
			}
		else 	/* All other dobj's interrupt digits */
			{
			if (fInDigits && ptxtobj->iwchLim > ptxtobj->iwchFirst)
				{
				iwchDecimal = ptxtobj->iwchFirst;
				fFound = fTrue;
				}
			}

		if (!fFound && (plsgrchnk->pcont[itxtobj] & fcontNonTextAfter))
			{
			iwchDecimal = ptxtobj->iwchLim;
			fFound = fInDigits;
			}
		}		  /* for (itxtobj= ... */

	itxtobj--;

	Assert(itxtobj >= 0);
	ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;


	if (fFound)
		{

		/* If we stopped because of digit followed by non-digit
		 (real decimal point was not found) break after digit rather than before following character

		 If we stopped because of EOP after non-digit, IF statement will work correctly as well
		*/
		if (itxtobj > 0 && !fRealPointFound && iwchDecimal == ptxtobj->iwchFirst && !(plsgrchnk->pcont[itxtobj] & fcontNonTextBefore))
			{
			itxtobj--;
			ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
			iwchDecimal = ptxtobj->iwchLim;
			}

		if (ptxtobj->txtf & txtfGlyphBased)
			{
			if (lsdev == lsdevReference)
				rgdu = pilsobj->pdurGind;
			else
				rgdu = ptxtln->pdupGind;
			iFirst = ptxtobj->igindFirst;
			iLim = ptxtobj->igindLim;
			iDecimal = IgindFirstFromIwch(ptxtobj, iwchDecimal);
			Assert (iDecimal >= ptxtobj->igindFirst);
			}
		else
			{
			if (lsdev == lsdevReference)
				rgdu = pilsobj->pdur;
			else
				rgdu = ptxtln->pdup;
			iFirst = ptxtobj->iwchFirst;
			iLim = ptxtobj->iwchLim;
			iDecimal = iwchDecimal;
			Assert (iDecimal >= ptxtobj->iwchFirst);
			}


		du = 0;
		for (i = iFirst; i < iDecimal; i++)
			{
			du += rgdu[i];
			}

		*pigrchnk = itxtobj;
		*pduToDecimal = du;
		}
	else
		{
		*pigrchnk = idobjOutside;
		*pduToDecimal = 0;
		}

	return lserrNone;
}

/*  L S  G E T  C H A R  T A B */
/*----------------------------------------------------------------------------
    %%Function: LsGetCharTab
    %%Contact: sergeyge

	Finds dobj, containing char for char tab point and reports its index as well as
	relative and dur from the beginning of dobj until decimal point.
----------------------------------------------------------------------------*/
LSERR LsGetCharTab(const LSGRCHNK* plsgrchnk, WCHAR wchCharTab, enum lsdevice lsdev,
							DWORD* pigrchnk, long* pduToCharacter)
{
	DWORD clsgrchnk;
	PLSCHNK rglschnk;
	POLS pols;
	PLSRUN plsrun;
	PLNOBJ ptxtln;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	WCHAR* rgwch;
	long* rgdu;
	long itxtobj;
	long iwch;
	BOOL fFound;
	long itxtobjCharTab = 0;
	long iwchCharTab = 0;
	long du;
	BOOL fGlyphBased;
	long iFirst;
	long iLim;
	long iCharTab;
	long i;

	clsgrchnk = plsgrchnk->clsgrchnk;

	if (clsgrchnk == 0)
		{
		*pigrchnk = idobjOutside;
		*pduToCharacter = 0;
		return lserrNone;
		}

	rglschnk = plsgrchnk->plschnk;
	ptxtln = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj;
	pilsobj = ptxtln->pilsobj;
	pols = pilsobj->pols;
	rgwch = pilsobj->pwchOrig;

	fFound = fFalse;

	for (itxtobj = 0; !fFound && itxtobj < (long)clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
		fGlyphBased = ptxtobj->txtf & txtfGlyphBased;
		plsrun = rglschnk[itxtobj].plsrun;
		if (ptxtobj->txtkind == txtkindRegular)
			{
			for (iwch = ptxtobj->iwchFirst; !fFound && iwch < ptxtobj->iwchLim; iwch++)
				{
				if (!fGlyphBased || FIwchOneToOne(pilsobj, iwch))
					{
					if (rgwch[iwch] == wchCharTab)
						{
						itxtobjCharTab = itxtobj;
						iwchCharTab = iwch;
						fFound = fTrue;
						}
					}
				} /* for (iwch= ... */
			}     /* if (txtkind == txtkindRegular */
		else if (ptxtobj->txtkind == txtkindEOL)
			{
			/* If we stopped because of EOP
			 (real character is not found) break after previous character rather than before EOP.
			 It is important for BiDi.
			*/
			if (itxtobj > 0 && !(plsgrchnk->pcont[itxtobj] & fcontNonTextBefore))
				{
				itxtobjCharTab = itxtobj - 1;
				iwchCharTab = ((PTXTOBJ)rglschnk[itxtobjCharTab].pdobj)->iwchLim;
				}
			else
				{
				itxtobjCharTab = itxtobj;
				iwchCharTab = ptxtobj->iwchFirst;
				}

			fFound = fTrue;
			}

		}		  /* for (itxtobj= ... */



	if (fFound)
		{

		ptxtobj = (PTXTOBJ)rglschnk[itxtobjCharTab].pdobj;

		if (ptxtobj->txtf & txtfGlyphBased)
			{
			if (lsdev == lsdevReference)
				rgdu = pilsobj->pdurGind;
			else
				rgdu = ptxtln->pdupGind;
			iFirst = ptxtobj->igindFirst;
			iLim = ptxtobj->igindLim;
			iCharTab = IgindFirstFromIwch(ptxtobj, iwchCharTab);
			Assert (iCharTab >= ptxtobj->igindFirst);
			}
		else
			{
			if (lsdev == lsdevReference)
				rgdu = pilsobj->pdur;
			else
				rgdu = ptxtln->pdup;
			iFirst = ptxtobj->iwchFirst;
			iLim = ptxtobj->iwchLim;
			iCharTab = iwchCharTab;
			Assert (iCharTab >= ptxtobj->iwchFirst);
			}


		du = 0;
		for (i = iFirst; i < iCharTab; i++)
			{
			du += rgdu[i];
			}

		*pigrchnk = itxtobjCharTab;
		*pduToCharacter = du;
		}
	else
		{
		*pigrchnk = idobjOutside;
		*pduToCharacter = 0;
		}

	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\ntiman.c ===
#include "ntiman.h"
#include "plschcon.h"
#include "lschcon.h"
#include "dninfo.h"
#include "iobj.h"
#include "chnutils.h"
#include "lstext.h"
#include "lscfmtfl.h"

#define     	FNominalToIdealNeeded(plschnkcontext, grpf, lskjust)    \
				((plschnkcontext)->grpfTnti != 0) || \
				 FNominalToIdealBecauseOfParagraphProperties(grpf, lskjust)  
				

LSERR ApplyNominalToIdeal(
						  PLSCHUNKCONTEXT plschunkcontext, /* LS chunk context */
						  PLSIOBJCONTEXT plsiobjcontext, /* installed objects */
						  DWORD grpf,		/* grpf */
  						  LSKJUST lskjust,		/* kind of justification */
						  BOOL fIsSublineMain,			/* fIsSubLineMain */
						  BOOL fLineContainsAutoNumber,  
						  PLSDNODE plsdnLast)	/* dnode until which we should do nominal to ideal */
{
	LSERR lserr;
	PLSDNODE plsdnPrev;
	BOOL fSuccessful;
	WCHAR wchar;
	PLSRUN plsrunText;
	HEIGHTS heightsText;
	MWCLS mwcls;
	DWORD iobj;
	LSIMETHODS* plsim;
	long durChange;
	PLSDNODE plsdnLastContent;



	plsdnLastContent = plsdnLast;
	// skip borders
	while(plsdnLastContent != NULL && FIsDnodeBorder(plsdnLastContent))
		{
		plsdnLastContent = plsdnLastContent->plsdnPrev;
		}


	/* if there are now dnodes in line or nominal to ideal has been already applied 
	return right away */
	if (plsdnLastContent == NULL || plschunkcontext->fNTIAppliedToLastChunk) 
		return lserrNone;

	Assert(FIsLSDNODE(plsdnLastContent));


	/*if last dnode text */
	if (FIsDnodeReal(plsdnLastContent) && !(plsdnLastContent->fTab) && 
		(IdObjFromDnode(plsdnLastContent) == IobjTextFromLsc(plsiobjcontext)))
		{

		lserr = FillChunkArray(plschunkcontext, plsdnLastContent);
		if (lserr != lserrNone)
			return lserr; 

		if (FNominalToIdealNeeded(plschunkcontext, grpf, lskjust))
			{
			lserr = NominalToIdealText(
					plschunkcontext->grpfTnti,	
					LstflowFromDnode(plsdnLastContent),
					(FIsFirstOnLine(plschunkcontext->pplsdnChunk[0]) && fIsSublineMain),
					fLineContainsAutoNumber ,
					plschunkcontext->locchnkCurrent.clschnk,	
					plschunkcontext->locchnkCurrent.plschnk);
			if (lserr != lserrNone)
				return lserr; 
			SetNTIAppliedToLastChunk(plschunkcontext);

			/* apply width modification between preceding object and first text */
			plsdnPrev = plschunkcontext->pplsdnChunk[0]->plsdnPrev;
			if (plsdnPrev != NULL && FIsDnodeReal(plsdnPrev) && !plsdnPrev->fTab)
				{
				lserr = GetFirstCharInChunk(plschunkcontext->locchnkCurrent.clschnk,
					plschunkcontext->locchnkCurrent.plschnk, &fSuccessful,
					&wchar, &plsrunText, &heightsText, &mwcls);
				if (lserr != lserrNone)
					return lserr; 

				if (fSuccessful)
					{
					iobj = IdObjFromDnode(plsdnPrev);
					plsim = PLsimFromLsc(plsiobjcontext, iobj);
					if (plsim->pfnGetModWidthFollowingChar != NULL)
						{
						lserr = plsim->pfnGetModWidthFollowingChar(plsdnPrev->u.real.pdobj,
							plsdnPrev->u.real.plsrun, plsrunText, &heightsText, wchar,
							mwcls, &durChange);
						if (lserr != lserrNone)
							return lserr;
						
						if (durChange != 0)
							{
							lserr = ModifyFirstCharInChunk(
												plschunkcontext->locchnkCurrent.clschnk,
												plschunkcontext->locchnkCurrent.plschnk,
												durChange);				
							if (lserr != lserrNone)
								return lserr;
							} 
						}  /* object has this method */
					}	/* call back from text was successful  */
				}	/*	there is non-text object before chunk of text */
			}	/* nominal to ideal is needed */
		} /* last dnode text after autonumbering */		

	return lserrNone;
}

LSERR ApplyModWidthToPrecedingChar(
						  PLSCHUNKCONTEXT plschunkcontext, /* LS chunk context */
						  PLSIOBJCONTEXT plsiobjcontext, /* installed objects */
						  DWORD grpf,		/* grpf */
  						  LSKJUST lskjust,		/* kind of justification */
    					  PLSDNODE plsdnNonText) /* non-text dnode after text */
	{
	LSERR lserr;
	BOOL fSuccessful;
	WCHAR wchar;
	PLSRUN plsrunText;
	HEIGHTS heightsText;
	MWCLS mwcls;
	DWORD iobj;
	LSIMETHODS* plsim;
	long durChange;
	PLSDNODE plsdnPrev;
	
	Assert(FIsLSDNODE(plsdnNonText));

	plsdnPrev = plsdnNonText->plsdnPrev; 

	/*if Prev dnode text */
	if (plsdnPrev != NULL && FIsDnodeReal(plsdnPrev) && !(plsdnPrev->fTab)  &&
		(IdObjFromDnode(plsdnPrev) == IobjTextFromLsc(plsiobjcontext)))
		{
	
		if (plschunkcontext->FChunkValid)
			{
			/* chunk we have is exactly what we need */
			Assert(plschunkcontext->locchnkCurrent.clschnk != 0);
			Assert(!plschunkcontext->FGroupChunk);
			Assert((plschunkcontext->pplsdnChunk[plschunkcontext->locchnkCurrent.clschnk - 1])
			->plsdnNext == plsdnNonText);
			}
		else
			{
			lserr = FillChunkArray(plschunkcontext, plsdnPrev);
			if (lserr != lserrNone)
				return lserr; 
			}
		
		if (FNominalToIdealNeeded(plschunkcontext, grpf, lskjust))
			{
			/* apply width modification between text and following object */
			lserr = GetLastCharInChunk(plschunkcontext->locchnkCurrent.clschnk,
				plschunkcontext->locchnkCurrent.plschnk, &fSuccessful,
				&wchar, &plsrunText, &heightsText, &mwcls);
			if (lserr != lserrNone)
				return lserr; 
			
			if (fSuccessful)
				{
				iobj = IdObjFromDnode(plsdnNonText);
				plsim = PLsimFromLsc(plsiobjcontext, iobj);
				if (plsim->pfnGetModWidthPrecedingChar != NULL)
					{
					lserr = plsim->pfnGetModWidthPrecedingChar(plsdnNonText->u.real.pdobj,
						plsdnNonText->u.real.plsrun, plsrunText, &heightsText, wchar,
						mwcls, &durChange);
					if (lserr != lserrNone)
						return lserr;
					
					if (durChange != 0)
						{
						lserr = ModifyLastCharInChunk(
							plschunkcontext->locchnkCurrent.clschnk,
							plschunkcontext->locchnkCurrent.plschnk,
							durChange);				
						if (lserr != lserrNone)
							return lserr;
						} 
					}  /* object has this method */
				}	/* call back from text was successful  */
			}	/* nominal to ideal is needed */
		}  /* there is text before */
	return lserrNone;
	
	}

LSERR CutPossibleContextViolation(
						  PLSCHUNKCONTEXT plschunkcontext, /* LS chunk context */
    					  PLSDNODE plsdnLast) /* last text dnode */
	{
	LSERR lserr;
	
	Assert(FIsLSDNODE(plsdnLast));
	
	
	if (plschunkcontext->FChunkValid)
		{
		/* chunk we have is exactly what we need */
		Assert(plschunkcontext->locchnkCurrent.clschnk != 0);
		Assert(!plschunkcontext->FGroupChunk);
		Assert((plschunkcontext->pplsdnChunk[plschunkcontext->locchnkCurrent.clschnk - 1])
			== plsdnLast);
		}
	else
		{
		lserr = FillChunkArray(plschunkcontext, plsdnLast);
		if (lserr != lserrNone)
			return lserr; 
		}

	lserr = CutTextDobj(plschunkcontext->locchnkCurrent.clschnk,
					plschunkcontext->locchnkCurrent.plschnk);	
	if (lserr != lserrNone)
		return lserr; 

	
	return lserrNone;
	
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lstxtwrd.c ===
#include "lstxtwrd.h"

#include "lstxtmap.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"

#define min(a,b)     ((a) > (b) ? (b) : (a))
#define max(a,b)     ((a) < (b) ? (b) : (a))

#define SqueezingFactorShift 2

static long GetNumberOfSpaces(const LSGRCHNK* plsgrchnk, 
						long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
						long itxtobjLast, long iwchLast);

static void DistributeInDobjsSpaces(const LSGRCHNK* plsgrchnk,
						long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
						long itxtobjLast, long iwchLast, long* rgdu, long* rgduGind, long duAdd, long wDuBound);

static void GetSqueezingInfo(const LSGRCHNK* plsgrchnk,
						long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
						long itxtobjLast, long iwchLast, long* rgdu, long* rgduGind,
						long* pNumOfSpaces, long* pduForSqueezing);

static void	SqueezeInDobjs(const LSGRCHNK* plsgrchnk, 
						long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
						long itxtobjLast, long iwchLast, long* rgdu, long* rgduGind,
						long duSubstr, long wDuBound);

/* F U L L  P O S I T I V E  J U S T I F I C A T I O N */
/*----------------------------------------------------------------------------
    %%Function: FullPositiveJustification
    %%Contact: sergeyge

	Performs positive distribution in spaces.

	Since amount to distribute is not nesessary divisible by number of spaces,
	additional pixels (wDupBound, wDurBound) are distributed among first
	wDupBound/wDurBound spaces.

	Leading spaces do not participate.
----------------------------------------------------------------------------*/
void FullPositiveSpaceJustification(const LSGRCHNK* plsgrchnk,
					long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
					long itxtobjLast, long iwchLast,
					long* rgdu, long* rgduGind, long duToDistribute, BOOL* pfSpacesFound)
{
    long NumOfSpaces;
    long duAdd;
    long wDuBound;

	Assert(duToDistribute > 0);
	
	NumOfSpaces = GetNumberOfSpaces(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces,
																			itxtobjLast, iwchLast);
	if (NumOfSpaces > 0)
		{

		duAdd = duToDistribute / NumOfSpaces;

		wDuBound = duToDistribute - (duAdd * NumOfSpaces);

		DistributeInDobjsSpaces(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces,
											itxtobjLast, iwchLast, rgdu, rgduGind, duAdd, wDuBound);
		}

	*pfSpacesFound = (NumOfSpaces > 0);
}

/* N E G A T I V E  S P A C E  J U S T I F I C A T I O N */
/*----------------------------------------------------------------------------
    %%Function: NegativeSpaceJustification
    %%Contact: sergeyge

	Performs squeezing into spaces if it is possible.
	If it is impossible squeezes in as much as it can
----------------------------------------------------------------------------*/
void NegativeSpaceJustification(const LSGRCHNK* plsgrchnk,
						long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
						long itxtobjLast, long iwchLast, long* rgdu, long* rgduGind, long duToSqueeze)
{
    long NumOfSpaces;
	long duForSqueezing;
    long duSubstr;
    long wDuBound;

	Assert(duToSqueeze > 0);

	GetSqueezingInfo(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces,
									itxtobjLast, iwchLast, rgdu, rgduGind, &NumOfSpaces, &duForSqueezing);

	/* We cannot squeeze more tha we can */
	if (duForSqueezing < duToSqueeze)
		duToSqueeze = duForSqueezing;

	/* dupSubstr shows how much should be subtracted from maximum squeezing
			each space provides.
	   wDupBound--from how many spaces additional pixel should be subtracted */
	if (NumOfSpaces > 0)
		{
		duSubstr = (duForSqueezing - duToSqueeze) / NumOfSpaces;
		wDuBound = (duForSqueezing - duToSqueeze) - duSubstr * NumOfSpaces;
		

		Assert(duSubstr >= 0);
		Assert(wDuBound >= 0);
		SqueezeInDobjs(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces,
								itxtobjLast, iwchLast, rgdu, rgduGind, duSubstr, wDuBound);
		}

	return;
}


/* Internal Functions Implementation */

/* G E T  N U M B E R  O F  S P A C E S */
/*----------------------------------------------------------------------------
    %%Function: GetNumberOfSpaces
    %%Contact: sergeyge

	Reports amount of spaces for distribution.
----------------------------------------------------------------------------*/
static long GetNumberOfSpaces(const LSGRCHNK* plsgrchnk, 
						long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
						long itxtobjLast, long iwchLast)
{
	long NumOfSpaces;
	PTXTOBJ ptxtobj;
	PILSOBJ pilsobj;
	long* rgwSpaces;
	long iwSpacesFirst;
	long iwSpacesLim;
	long iwSpaces;
	long iwchFirst;
	long iwchLim;
	long itxtobj;

	ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[0].pdobj;
	pilsobj = ptxtobj->plnobj->pilsobj;
	rgwSpaces = pilsobj->pwSpaces;

	NumOfSpaces = 0;

	for (itxtobj = itxtobjAfterStartSpaces; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		if (ptxtobj->txtkind == txtkindRegular)
			{
			iwSpacesFirst = ptxtobj->u.reg.iwSpacesFirst;
			iwSpacesLim = ptxtobj->u.reg.iwSpacesLim;


			iwchFirst = iwchAfterStartSpaces;
			if (itxtobj > itxtobjAfterStartSpaces)
				iwchFirst = ptxtobj->iwchFirst;

			iwchLim = iwchLast + 1;
			if (itxtobj < itxtobjLast)
				iwchLim = ptxtobj->iwchLim;

			while (iwSpacesFirst < iwSpacesLim && rgwSpaces[iwSpacesFirst] < iwchFirst)
				{
				iwSpacesFirst++;
				}

			while (iwSpacesLim > iwSpacesFirst && rgwSpaces[iwSpacesLim-1] >= iwchLim)
				{
				iwSpacesLim--;
				}
	
			if (ptxtobj->txtf & txtfGlyphBased)
				{
				for (iwSpaces = iwSpacesFirst; iwSpaces < iwSpacesLim; iwSpaces++)
					if (FIwchOneToOne(pilsobj, rgwSpaces[iwSpaces]))
						NumOfSpaces++;
				}
			else
				NumOfSpaces += (iwSpacesLim - iwSpacesFirst);
	
			}
		}

	return NumOfSpaces;
}

/* D I S T R I B U T E  I N  D O B J S */
/*----------------------------------------------------------------------------
    %%Function: DistributeInDobjs
    %%Contact: sergeyge

	Performs distribution in dobjs, based on precalculated information.
----------------------------------------------------------------------------*/
static void DistributeInDobjsSpaces(const LSGRCHNK* plsgrchnk,
						long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
						long itxtobjLast, long iwchLast, long* rgdu, long* rgduGind, long duAdd, long wDuBound)
{
	PTXTOBJ ptxtobj;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	long* rgwSpaces;
	long iwSpacesFirst;
	long iwSpacesLim;
	long iwchFirst;
	long iwchLim;
	long CurSpace;
	long itxtobj;
	long iwSpaces;
	long igind;
	long CurSpaceForSecondLoop;

	plnobj = ((PTXTOBJ)(plsgrchnk->plschnk[0].pdobj))->plnobj;
	pilsobj = plnobj->pilsobj;
	rgwSpaces = pilsobj->pwSpaces;
	
	CurSpace = 0;
	for (itxtobj = itxtobjAfterStartSpaces; itxtobj <= itxtobjLast ; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		if (ptxtobj->txtkind == txtkindRegular)
			{
			iwSpacesFirst = ptxtobj->u.reg.iwSpacesFirst;
			iwSpacesLim = ptxtobj->u.reg.iwSpacesLim;

			iwchFirst = iwchAfterStartSpaces;
			if (itxtobj > itxtobjAfterStartSpaces)
				iwchFirst = ptxtobj->iwchFirst;

			iwchLim = iwchLast + 1;
			if (itxtobj < itxtobjLast)
				iwchLim = ptxtobj->iwchLim;

			while (iwSpacesFirst < iwSpacesLim && rgwSpaces[iwSpacesFirst] < iwchFirst)
				{
				iwSpacesFirst++;
				}

			while (iwSpacesLim > iwSpacesFirst && rgwSpaces[iwSpacesLim-1] >= iwchLim)
				{
				iwSpacesLim--;
				}

			if (ptxtobj->txtf & txtfGlyphBased)
				{
				Assert(rgduGind != NULL);
				for(iwSpaces = iwSpacesFirst; iwSpaces < iwSpacesLim; iwSpaces++)
					{
					if (FIwchOneToOne(pilsobj, rgwSpaces[iwSpaces]))
						{
						igind = IgindFirstFromIwch(ptxtobj, rgwSpaces[iwSpaces]);
						if (CurSpace < wDuBound)
							{
							rgduGind[igind] += (duAdd + 1);
							pilsobj->pduGright[igind] += (duAdd + 1);
							}
						else
							{			
							rgduGind[igind] += duAdd;
							pilsobj->pduGright[igind] += duAdd;
							}

						CurSpace++;
						}

					}
				}
			else
				{
	
				CurSpaceForSecondLoop = CurSpace;

				for(iwSpaces = iwSpacesFirst; iwSpaces < iwSpacesLim; iwSpaces++)
					{
					if (CurSpace < wDuBound)
						{
						rgdu[rgwSpaces[iwSpaces]] += (duAdd + 1);
						}
					else
						{			
						rgdu[rgwSpaces[iwSpaces]] += duAdd;
						}

					CurSpace++;
					}
				if (pilsobj->fNotSimpleText)
					{
					for(iwSpaces = iwSpacesFirst; iwSpaces < iwSpacesLim; iwSpaces++)
						{
						if (CurSpaceForSecondLoop < wDuBound)
							{
							pilsobj->pdurRight[rgwSpaces[iwSpaces]] += (duAdd + 1);
							}
						else
							{			
							pilsobj->pdurRight[rgwSpaces[iwSpaces]] += duAdd;
							}

						CurSpaceForSecondLoop++;
						}
					}
				}
			}
		}

}

/* G E T  S Q U E E Z I N G  I N F O */
/*----------------------------------------------------------------------------
    %%Function: GetSqueezingInfo
    %%Contact: sergeyge

	Calculates maximum amount of pixels to squeeze into spaces.
	Leading spaces are used for squeezing.
----------------------------------------------------------------------------*/
static void GetSqueezingInfo(const LSGRCHNK* plsgrchnk,
						long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
						long itxtobjLast, long iwchLast, long* rgdu, long* rgduGind,
						long* pNumOfSpaces, long* pduForSqueezing)
{
	PTXTOBJ ptxtobj;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	long* rgwSpaces;
	long iwSpacesFirst;
	long iwSpacesLim;
	long iwchFirst;
	long iwchLim;
	long itxtobj;
	long iwSpaces;

	ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;
	rgwSpaces = pilsobj->pwSpaces;

	*pNumOfSpaces = 0;
	*pduForSqueezing = 0;

	for (itxtobj = itxtobjAfterStartSpaces; itxtobj <= itxtobjLast ; itxtobj++)
		{

		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		if (! (ptxtobj->txtf & txtfMonospaced) )
			{

			if (ptxtobj->txtkind == txtkindRegular)
				{
				iwSpacesFirst = ptxtobj->u.reg.iwSpacesFirst;
				iwSpacesLim = ptxtobj->u.reg.iwSpacesLim;

				iwchFirst = iwchAfterStartSpaces;
				if (itxtobj > itxtobjAfterStartSpaces)
					iwchFirst = ptxtobj->iwchFirst;

				iwchLim = iwchLast + 1;
				if (itxtobj < itxtobjLast)
					iwchLim = ptxtobj->iwchLim;

				while (iwSpacesFirst < iwSpacesLim && rgwSpaces[iwSpacesFirst] < iwchFirst)
					{
					iwSpacesFirst++;
					}

				while (iwSpacesLim > iwSpacesFirst && rgwSpaces[iwSpacesLim-1] >= iwchLim)
					{
					iwSpacesLim--;
					}

				if (ptxtobj->txtf & txtfGlyphBased)
					{
					for (iwSpaces = iwSpacesFirst; iwSpaces < iwSpacesLim; iwSpaces++)
						{
						if (FIwchOneToOne(pilsobj, rgwSpaces[iwSpaces]))
							{
							(*pduForSqueezing) += rgduGind[IgindFirstFromIwch(ptxtobj,rgwSpaces[iwSpaces])] >>
																					 SqueezingFactorShift;
							(*pNumOfSpaces)++;
							}
						}
					}
				else
					{
					for (iwSpaces = iwSpacesFirst; iwSpaces < iwSpacesLim; iwSpaces++)
						{
						(*pduForSqueezing) += rgdu[rgwSpaces[iwSpaces]] >> SqueezingFactorShift;
						}
	
					(*pNumOfSpaces) += (iwSpacesLim - iwSpacesFirst);
					}
				}
			}		

		}
}

/* S Q U E E Z E  I N  D O B J S  */
/*----------------------------------------------------------------------------
    %%Function: SqueezeInDobjs
    %%Contact: sergeyge

	Performs squeezing in dobjs, based on precalculated information
----------------------------------------------------------------------------*/
static void	SqueezeInDobjs(const LSGRCHNK* plsgrchnk, 
						long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
						long itxtobjLast, long iwchLast, long* rgdu, long* rgduGind,
						long duSubstr, long wDuBound)
{
	PTXTOBJ ptxtobj;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	long* rgwSpaces;
	long iwSpacesFirst;
	long iwSpacesLim;
	long iwchFirst;
	long iwchLim;
	long duChange;
	long CurSpace;
	long itxtobj;
	long iwSpaces;
	long igind;
	long CurSpaceForSecondLoop;

	ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;
	rgwSpaces = pilsobj->pwSpaces;
	
	CurSpace = 0;

	for (itxtobj = itxtobjAfterStartSpaces; itxtobj <= itxtobjLast; itxtobj++)
		{

		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		if (! (ptxtobj->txtf & txtfMonospaced) )
			{

			if (ptxtobj->txtkind == txtkindRegular)
				{
				iwSpacesFirst = ptxtobj->u.reg.iwSpacesFirst;
				iwSpacesLim = ptxtobj->u.reg.iwSpacesLim;

				iwchFirst = iwchAfterStartSpaces;
				if (itxtobj > itxtobjAfterStartSpaces)
					iwchFirst = ptxtobj->iwchFirst;

				iwchLim = iwchLast + 1;
				if (itxtobj < itxtobjLast)
					iwchLim = ptxtobj->iwchLim;

				while (iwSpacesFirst < iwSpacesLim && rgwSpaces[iwSpacesFirst] < iwchFirst)
					{
					iwSpacesFirst++;
					}

				while (iwSpacesLim > iwSpacesFirst && rgwSpaces[iwSpacesLim-1] >= iwchLim)
					{
					iwSpacesLim--;
					}

				if (ptxtobj->txtf & txtfGlyphBased)
					{
					for(iwSpaces = iwSpacesFirst; iwSpaces < iwSpacesLim; iwSpaces++)
						{
						if (FIwchOneToOne(pilsobj, rgwSpaces[iwSpaces]))
							{
							igind = IgindFirstFromIwch(ptxtobj, rgwSpaces[iwSpaces]);
							duChange =  -(rgduGind[igind] >> SqueezingFactorShift) + duSubstr;
							if (CurSpace < wDuBound)
								{
								duChange += 1;
								}

							rgduGind[igind] += duChange;
							pilsobj->pduGright[igind] += duChange;

							CurSpace++;

							}
						}
					}
				else
					{
					CurSpaceForSecondLoop = CurSpace;
					for(iwSpaces = iwSpacesFirst; iwSpaces < iwSpacesLim; iwSpaces++)
						{
						duChange =  -(rgdu[rgwSpaces[iwSpaces]] >> SqueezingFactorShift) + duSubstr;
						if (CurSpace < wDuBound)
							{
							duChange += 1;
							}

						rgdu[rgwSpaces[iwSpaces]] += duChange;

						CurSpace++;

						}
					if (pilsobj->fNotSimpleText)
						{

						for(iwSpaces = iwSpacesFirst; iwSpaces < iwSpacesLim; iwSpaces++)
							{
							duChange =  -(rgdu[rgwSpaces[iwSpaces]] >> SqueezingFactorShift) + duSubstr;
							if (CurSpaceForSecondLoop < wDuBound)
								{
								duChange += 1;
								}

							pilsobj->pdurRight[rgwSpaces[iwSpaces]] += duChange;

							CurSpaceForSecondLoop++;

							}
						}
					}
				}
			}

		}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\prepdisp.c ===
#include <limits.h>
#include "prepdisp.h"
#include "lsc.h"
#include "lsline.h"
#include "lssubl.h"
#include "iobj.h"
#include "lstxtjst.h"
#include "lstxttab.h"
#include "lsgrchnk.h"
#include "posichnk.h"
#include "chnutils.h"
#include "tabutils.h"
#include "lsdnode.h"
#include "zqfromza.h"
#include "lsdevice.h"
#include "lssubset.h"
#include "lsffi.h"
#include "iobjln.h"
#include "txtconst.h"
#include "lskalign.h"
#include "dninfo.h"

typedef enum 				/* types of TextGroupChunk walls */
{
	LineBegin,				
	LineEnd,
	Tab,
	Pen,
} KWALL;

typedef struct
{
	KWALL 		kwall;		/* wall type */
	PLSDNODE 	pdn;		/* tab or pen dnode, PLINEBEGIN for LineBegin */
	LSKTAB		lsktab;		/* if type is Tab - kind of tab */
	WCHAR 		wchCharTab;	/* point character if lsktab == lsktChar */
	long		upTab;		/* scaled tab position */
} GrpChnkWall;

static BOOL DnodeHasSublineForMe(PLSDNODE pdn, BOOL fLineCompressed);
static void ScaleDownLevel(PLSSUBL plssubl, BOOL* pfAnySublines, BOOL* pfCollectVisual);
static LSERR SetJustificationForLastGroupChunk(PLSLINE plsline, GrpChnkWall LastWall, 
					LSKJUST* plskj, LSKALIGN* plskalign);
static LSERR CalcPresAutonumbers(PLSLINE plsline, PLSDNODE* pdnStartMainText);
static void FindWallToCollectSublinesAfter(PLSDNODE pdnFirst, LSCP cpLim, BOOL fLineCompressed, PLSDNODE* ppdnLastWall);
static LSERR GetDistanceToTabPoint(GRCHUNKEXT* pgrchunkext, LSCP cpLim, LSKTAB lsktab, WCHAR wchCharTab,
										PLSDNODE pdnFirst, long* pdupToDecimal);
static void WidenNonTextObjects(GRCHUNKEXT* pgrchunkext, long dupToAdd, DWORD cObjects);
static void ConvertAutoTabToPen(PLSLINE plsline, PLSDNODE pdnAutoDecimalTab);
static LSERR CalcPresForDnodeWithSublines(PLSC plsc, PLSDNODE pdn, BOOL fLineCompressed, 
											LSKJUST lskj, BOOL fLastOnLine);
static LSERR CalcPresChunk(PLSC plsc, PLSDNODE pdnFirst, PLSDNODE pdnLim, 
				COLLECTSUBLINES CollectGroupChunkPurpose, BOOL fLineCompressed, 
				LSKJUST lskj, BOOL fLastOnLine);
static void UpdateUpLimUnderline(PLSLINE plsline, long dupTail);
static LSERR PrepareLineForDisplay(PLSLINE plsline);


#define PLINEBEGIN    ((void *)(-1))

#define FIsWall(p, cpLim)	 (!FDnodeBeforeCpLim(p, cpLim) || p->fTab || FIsDnodePen(p))

#define FIsDnodeNormalPen(plsdn) 		(FIsDnodePen(plsdn) && (!(plsdn)->fAdvancedPen))

#define FCollinearTflows(t1, t2)  		(((t1) & fUVertical) == ((t2) & fUVertical))


//    %%Function:	DnodeHasSublineForMe
//    %%Contact:	victork
//
// Is there relevant subline in this dnode?

static BOOL DnodeHasSublineForMe(PLSDNODE pdn, BOOL fLineCompressed)
{
	BOOL	fSublineFound = fFalse;
	
	if (FIsDnodeReal(pdn) && pdn->u.real.pinfosubl != NULL)
		{
		
		if (pdn->u.real.pinfosubl->fUseForCompression && fLineCompressed)
			{
			fSublineFound = fTrue;
			}
		
		if (pdn->u.real.pinfosubl->fUseForJustification && !fLineCompressed)
			{
			fSublineFound = fTrue;
			}
		}
	return fSublineFound;
}


//    %%Function:	ScaleDownLevel
//    %%Contact:	victork
//
/*
 *	Scales all non-text objects on the level(s).
 *	
 *	If the level (meaning subline) contains dnode(s) which submitted sublines for compression
 *	or expansion, ScaleDownLevel reports the fact and calls itself for submitted sublines.
 *	This strategy relyes on the fact that ScaleDownLevel is idempotent procedure. Some sublines
 *	will be scaled down twice - let that be.
 *
 *	Two additional questions are answered - whether there are some submitted sublines and
 *		whether there is a reason go VisualLine (underlining, shading, borders on lower levels).
 */

static void ScaleDownLevel(PLSSUBL plssubl, BOOL* pfAnySublines, BOOL* pfCollectVisual)
{
	const PLSC 	plsc = plssubl->plsc;
	LSTFLOW 	lstflow = plssubl->lstflow;	
	const DWORD iobjText = IobjTextFromLsc(&(plsc->lsiobjcontext));
	LSDEVRES* 	pdevres = &(plsc->lsdocinf.lsdevres);
	PLSDNODE 	pdn = plssubl->plsdnFirst;
	DWORD		i;
	BOOL 		fDummy;
	
	BOOL 		fSeeReasonForVisualLine = fFalse;
	
	while (pdn != NULL)							/* don't care about break */
		{
		if (FIsDnodeReal(pdn))
			{
			if (pdn->u.real.lschp.fUnderline || pdn->u.real.lschp.fShade || pdn->u.real.lschp.fBorder)
				{
				fSeeReasonForVisualLine = fTrue;
				}
				
			if (IdObjFromDnode(pdn) == iobjText)
				{
				if (pdn->fTab)
					pdn->u.real.dup = UpFromUr(lstflow, pdevres, pdn->u.real.objdim.dur);
				}
			else
				{							
				if (!pdn->fRigidDup)
					{
					pdn->u.real.dup = UpFromUr(lstflow, pdevres, pdn->u.real.objdim.dur);
					}
					
				if (pdn->u.real.pinfosubl != NULL)
					{
					*pfAnySublines = fTrue;

					for (i = 0; i < pdn->u.real.pinfosubl->cSubline; i++)
						{
						ScaleDownLevel((pdn->u.real.pinfosubl->rgpsubl)[i], &fDummy, pfCollectVisual);
						}
					}
				}
			}
		else if (FIsDnodePen(pdn))
			{
			pdn->u.pen.dup = UpFromUr(lstflow, pdevres, pdn->u.pen.dur);
			}
		else
			{
			// Borders are rigidDup always - no scaling down
			
			// we'll try to "undo" the moving at display time at the main level if
			// fUnderlineTrailSpacesRM is on. So, after prepdisp we want none or only one 
			// fBorderMovedFromTrailingArea flag remain and the meaning of the flag is:
			// I am the border that should be moved back into trailing spaces.
			
			if (pdn->fBorderMovedFromTrailingArea)
				{
				if (!FIsSubLineMain(pdn->plssubl) || 
					!plsc->lsadjustcontext.fUnderlineTrailSpacesRM)
					{
					pdn->fBorderMovedFromTrailingArea = fFalse;
					}
				}
			}

		pdn = pdn->plsdnNext;
		}
		
	if (fSeeReasonForVisualLine && !plssubl->fMain)
		{
		*pfCollectVisual = fTrue;
		}
		
}


//    %%Function:	FindWallToCollectSublinesAfter
//    %%Contact:	victork
//
// Finds the last wall - wall after which we will start to use submitted subllines.
// If there are no sublines to participate in justification, pdnLastWall is set to null,
// else it points to the last wall (tab, pen or PLINEBEGIN).

static void FindWallToCollectSublinesAfter(PLSDNODE pdnFirst, LSCP cpLim, BOOL fLineCompressed, 
										PLSDNODE* ppdnLastWall)
{
	PLSDNODE pdn;
	BOOL	 fSublineFound;

	// Find last tab.

	*ppdnLastWall = PLINEBEGIN;
	
	pdn = pdnFirst;

	while (FDnodeBeforeCpLim(pdn, cpLim))
		{
		if (FIsDnodeReal(pdn))
			{
			if (pdn->fTab)
				{
				*ppdnLastWall = pdn;
				}
			}
		else													/* pen */
			if (!FIsDnodeBorder(pdn) && !pdn->fAdvancedPen)		// and not advance pen or border
				{
				*ppdnLastWall = pdn;
				}
				
		pdn = pdn->plsdnNext;
		}

	// OK, last groupchunk starts with a tab or there is only one groupchunk on the line.
	// Are there submitted sublines of our compression/expansion type after it?

	fSublineFound = fFalse;
	
	if (*ppdnLastWall == PLINEBEGIN)
		{
		pdn = pdnFirst;
		}
	else
		{
		pdn = (*ppdnLastWall)->plsdnNext;
		}

	while (FDnodeBeforeCpLim(pdn, cpLim))
		{
		fSublineFound |= DnodeHasSublineForMe(pdn, fLineCompressed);
		pdn = pdn->plsdnNext;
		}

	if (!fSublineFound)
		{
		*ppdnLastWall = NULL;									// don't need last tab
		}
	return;
}


//    %%Function:	CalcPresAutonumbers
//    %%Contact:	victork
//
/*
 *	Scales dup for autonumbering dnodes, calls CalcPres for autonumbering object.
 *
 *	We want to have main line start exactly on upStartMainText. To achive that we play with
 *	the width of "white space" dnode, which	today contains a tab (usually) or a space. 
 *	(This dnode is pdnWhiteSpace in the code.) If it is not present, we change width of autonumbering
 *	object itself. We don't want one of them go negative,so sometimes rounding errors force us
 *	to move start of the main text to the right.
 */


static LSERR CalcPresAutonumbers(PLSLINE plsline, PLSDNODE* pdnStartMainText)
{
	LSERR 	lserr;
	const PLSC 	plsc = plsline->lssubl.plsc;
	LSTFLOW 	lstflow = plsline->lssubl.lstflow;	
	LSDEVRES* 	pdevres = &(plsc->lsdocinf.lsdevres);
		
	PLSDNODE 	pdn, pdnObject, pdnWhiteSpace, pdnToAdjust, pdnAfterAutonumbers;

	long 		dupAdjust, dupClosingBorder = 0;
	long 		dupAutonumbering = 0;

	plsline->upStartAutonumberingText = UpFromUr(lstflow, pdevres, plsc->lsadjustcontext.urStartAutonumberingText);


	// Find the first dnode after autonumbering sequence
	
	// First find the first dnode with positive cpFirst
	
	pdn = plsline->lssubl.plsdnFirst;

	Assert(pdn != NULL && FIsNotInContent(pdn));
	
	pdnAfterAutonumbers = pdn->plsdnNext;

	while (pdnAfterAutonumbers != NULL && FIsNotInContent(pdnAfterAutonumbers))
		{
		pdn = pdnAfterAutonumbers;
		pdnAfterAutonumbers = pdn->plsdnNext;
		}
		
	// pdnAfterAutonumbers is first dnode in content (with positive cpFirst). It can be NULL.
	// But it is not the first dnode after autonumbering sequence if autodecimal tab is present

	if (plsc->lsadjustcontext.fAutodecimalTabPresent)
		{
		Assert(FIsDnodeReal(pdn) && pdn->fTab);
		
		pdnAfterAutonumbers = pdn;
		}

	// Now go againg through autonumbering sequence
	
	// process opening border
	
	pdn = plsline->lssubl.plsdnFirst;
	
	if (FIsDnodeBorder(pdn))
		{
		Assert(pdn->cpFirst < 0);
		Assert(pdn->fOpenBorder);
		
		pdnObject = pdn->plsdnNext;
		dupAutonumbering += pdn->u.pen.dup;
		}
	else
		{
		pdnObject = pdn;
		}
		
	// process B&N object
	
	Assert(pdnObject != NULL && pdnObject->cpFirst < 0);				// B&N object should be there
	Assert(FIsDnodeReal(pdnObject));
	
	// scale down dup from dur for the first dnode
	
	pdnObject->u.real.dup = UpFromUr(lstflow, pdevres, pdnObject->u.real.objdim.dur);
	
	dupAutonumbering += pdnObject->u.real.dup;

	pdn = pdnObject->plsdnNext;
	Assert(pdn != NULL);								// line must contain something after B&N dnodes
	
	// process "white space" dnode
	
	if (pdn != pdnAfterAutonumbers && FIsDnodeReal(pdn))
		{
		pdnWhiteSpace = pdn;
		dupAutonumbering += pdnWhiteSpace->u.real.dup;
		pdnToAdjust = pdnWhiteSpace;
		pdn = pdnWhiteSpace->plsdnNext;
		}
	else
		{
		pdnWhiteSpace = NULL;
		pdnToAdjust = pdnObject;
		}

	Assert(pdn != NULL);								// line must contain something after B&N dnodes
	
	// process closing border
	
	if (pdn != pdnAfterAutonumbers)
		{
		Assert(FIsDnodeBorder(pdn));
		Assert(!pdn->fOpenBorder);

		dupClosingBorder = pdn->u.pen.dup;
		dupAutonumbering += dupClosingBorder;
		
		pdn = pdn->plsdnNext;
		}

	Assert(pdn == pdnAfterAutonumbers);	

	*pdnStartMainText = pdn;
														
	// change dup of the tab or object dnode to ensure exact main text alignment

	dupAdjust =  plsline->upStartMainText - plsline->upStartAutonumberingText - dupAutonumbering;
	
	pdnToAdjust->u.real.dup += dupAdjust;
	
	if (pdnToAdjust->u.real.dup < 0)
		{
		// Rounding errors result in negative dup - better to move starting point of the main line.
		// It can lead to the nasty situation of right margin to the left of the line beginning in
		// theory, but not in practice. This problem is ignored then.
		
		plsline->upStartMainText -= pdnToAdjust->u.real.dup;
		pdnToAdjust->u.real.dup = 0;
		}

	// do CalcPres for the autonumbering object - it's always lskjNone and not last object on the line
	
	lserr = (*plsc->lsiobjcontext.rgobj[pdnObject->u.real.lschp.idObj].lsim.pfnCalcPresentation)
						(pdnObject->u.real.pdobj, pdnObject->u.real.dup, lskjNone, fFalse);
	if (lserr != lserrNone)
		return lserr;

	if (pdnWhiteSpace != NULL)
		{
		plsline->upLimAutonumberingText = plsline->upStartMainText - 
														pdnWhiteSpace->u.real.dup - dupClosingBorder;

		// If "white space" dnode is not a tab, dup should be set in it.
		
		if (!pdnWhiteSpace->fTab)
			{
			// It's always lskjNone and not last object on the line for white space dnode

			lserr = (*plsc->lsiobjcontext.rgobj[pdnWhiteSpace->u.real.lschp.idObj].lsim.pfnCalcPresentation)
								(pdnWhiteSpace->u.real.pdobj, pdnWhiteSpace->u.real.dup, lskjNone, fFalse);
			if (lserr != lserrNone)
				return lserr;
			}
		}
	else
		{
		plsline->upLimAutonumberingText = plsline->upStartMainText - dupClosingBorder;
		}
		
	return lserrNone;		
}

//    %%Function:	SetJustificationForLastGroupChunk
//    %%Contact:	victork
//
//	Changes lskj and lskalign for the last GC if it should be done
// 	If not, it's OK to leave these parameters unchanged - so they are kind of I/O
//
//	We adjust all group chunks except maybe the last one with lskjNone, so guestion is about
//	last GroupChunk only.
//
//	We do some tricks with justification mode at the end of line, and the answer depends on 
//	kind of last tab, end of paragraph, etc.
//
static LSERR SetJustificationForLastGroupChunk(PLSLINE plsline, GrpChnkWall LastWall, 
												LSKJUST* plskj, LSKALIGN* plskalign)

{
	LSERR 		lserr;
	const PLSC 	plsc = plsline->lssubl.plsc;
	LSKJUST 	lskjPara = plsc->lsadjustcontext.lskj;
	LSKALIGN 	lskalignPara = plsc->lsadjustcontext.lskalign;
	ENDRES		endr = plsline->lslinfo.endr;
	BOOL 		fJustify;

	//	no justification intended - lskj remains None, lskalign unchanged
	
	if ((lskjPara == lskjNone || lskjPara == lskjSnapGrid) && lskalignPara == lskalLeft)
		{
		return lserrNone;
		}
	
	//	Line ends in a normal way - we apply justification, lskalign unchanged
	
	if (endr == endrNormal || endr == endrHyphenated)
		{
		*plskj = lskjPara;
		return lserrNone;
		}
	
	// break-through tab kills justification, alignment games
	
	if (FBreakthroughLine(plsc))
		{
		return lserrNone;
		}

	// if last Left Wall is non-left tab, justification is off too
	
	if (LastWall.kwall == Tab && LastWall.lsktab != lsktLeft)
		{
		// we used to return here
		// Now we want to give Word a chance to change lskalign from Right to Left for
		// the last line in paragraph after text box.
		// REVIEW (Victork) Should we call pfnFGetLastLineJustification always?
		lskjPara = lskjNone;
		}

	// What's the matter behind the callback.
	//
	// They say: no full justification for the last line in paragraph. What does this exactly mean?
	// For example, Latin and FE word make different decisions for endrEndSection line.
	// Let's ask. 
	//
	// Additional parameter is added to cover the behavior full-justified text wrapping a textbox (bug 682)
	// A lone word should be aligned to the right to create a full-justified page, but not at the end of
	// the paragraph.
	
	lserr = (*plsc->lscbk.pfnFGetLastLineJustification)(plsc->pols, lskjPara, lskalignPara, endr, 
						&fJustify, plskalign);
	
	if (lserr != lserrNone) return lserr;

	if (fJustify)
		{
		*plskj = lskjPara;
		}
	
	return lserrNone;
}


//    %%Function:	GetDistanceToTabPoint
//    %%Contact:	victork
//
/*
 *		Calculate DistanceToTabPoint given GrpChnk and first Dnode
 *
 *		TabPoint is decimal point for the decimal tab, wchCharTab for character tab
 */
static LSERR GetDistanceToTabPoint(GRCHUNKEXT* pgrchunkext, LSCP cpLim, LSKTAB lsktab, WCHAR wchCharTab,
										PLSDNODE pdnFirst, long* pdupToTabPoint)
{
	LSERR 		lserr;
	DWORD		igrchnk;					/* # of dnodes before dnode with the point */
	long 		dupToPointInsideDnode;
	PLSDNODE	pdnTabPoint;

	if (pgrchunkext->durTotal == 0)
		{
		*pdupToTabPoint = 0;
		return lserrNone;
		}

	lserr = CollectTextGroupChunk(pdnFirst, cpLim, CollectSublinesForDecimalTab, pgrchunkext); 
	if (lserr != lserrNone) 
		return lserr;

	if (lsktab == lsktDecimal)
		{
		lserr = LsGetDecimalPoint(&(pgrchunkext->lsgrchnk), lsdevPres, &igrchnk, &dupToPointInsideDnode);
		}
	else
		{
		Assert(lsktab == lsktChar);
		lserr = LsGetCharTab(&(pgrchunkext->lsgrchnk), wchCharTab, lsdevPres, &igrchnk, &dupToPointInsideDnode);
		}
	
	if (lserr != lserrNone) 
		return lserr;
		
	if (igrchnk == ichnkOutside)						// no TabPoint in the whole grpchnk
		{
		// we say: pretend it is right after last dnode (in logical sequence)
		
		pdnTabPoint = pgrchunkext->plsdnLastUsed;
		dupToPointInsideDnode = DupFromDnode(pdnTabPoint);
		}
	else
		{
		pdnTabPoint = pgrchunkext->plschunkcontext->pplsdnChunk[igrchnk];
		}
		
	// We now have the distance between TabPoint and the beginning of the dnode containing it.
	// FindPointOffset will add the dup's of all dnodes before that dnode.

	FindPointOffset(pdnFirst, lsdevPres, LstflowFromDnode(pdnFirst), CollectSublinesForDecimalTab, 
						pdnTabPoint, dupToPointInsideDnode, pdupToTabPoint);	
						
	return lserrNone;
}

//    %%Function:	WidenNonTextObjects
//    %%Contact:	victork
//
/*
 *		Add dupToAddToNonTextObjects to the width of first cNonTextObjectsToExtend in the GroupChunk
 */
static void WidenNonTextObjects(GRCHUNKEXT* pgrchunkext, long dupToAdd, DWORD cObjects)
{
	PLSDNODE pdn;

	long	dupAddToEveryone;
	long	dupDistributeToFew;
	long	dupAddToThis;
	long	dupCurrentSum;

	DWORD 	cObjectsLeft, i;

	Assert(cObjects != 0);
	Assert(dupToAdd > 0);

	dupAddToEveryone = dupToAdd / cObjects;
	dupDistributeToFew = dupToAdd - (dupAddToEveryone * cObjects);

	cObjectsLeft = cObjects;
	dupCurrentSum = 0;

	/* 
     *		Following loop tries to distribute remaining dupDistributeToFew pixels evenly.
	 *
     *		Algorithm would be easy if fractions are allowed and you can see it in comments;
     *		The actual algorithm avoids fractions by multiplying everything by cObjects
     */

	i = 0;
	
	while (cObjectsLeft > 0)
		{
		Assert(i < pgrchunkext->cNonTextObjects);
		
		pdn = (pgrchunkext->pplsdnNonText)[i];
		Assert(pdn != NULL && FIsDnodeReal(pdn) /* && IdObjFromDnode(pdn) != iobjText */ );

		if ((pgrchunkext->pfNonTextExpandAfter)[i])
			{
			dupAddToThis = dupAddToEveryone;

			dupCurrentSum += dupDistributeToFew;			/* currentSum += Distribute / cObjects; */
			
			if (dupCurrentSum >= (long)cObjects)			/* if (currentSum >= 1) */
				{
				dupAddToThis ++;
				dupCurrentSum -= (long)cObjects;			/* currentSum--; */
				}
				
			pdn->u.real.dup += dupAddToThis;		

			cObjectsLeft --;
			}
		i++;
		}

	return;
}


//    %%Function:	ConvertAutoTabToPen
//    %%Contact:	victork
//
static void ConvertAutoTabToPen(PLSLINE plsline, PLSDNODE pdnAutoDecimalTab)
{
	long dup, dur;

	Assert(pdnAutoDecimalTab->fTab);			/* it's still a tab */

	dup = pdnAutoDecimalTab->u.real.dup;
	dur = pdnAutoDecimalTab->u.real.objdim.dur;

	pdnAutoDecimalTab->klsdn = klsdnPenBorder;
	pdnAutoDecimalTab->fAdvancedPen = fFalse;
	pdnAutoDecimalTab->fTab = fFalse;
	pdnAutoDecimalTab->icaltbd = 0;
	pdnAutoDecimalTab->u.pen.dup = dup;
	pdnAutoDecimalTab->u.pen.dur = dur;
	pdnAutoDecimalTab->u.pen.dvp = 0;
	pdnAutoDecimalTab->u.pen.dvr = 0;
	plsline->fNonRealDnodeEncounted = fTrue;
}

//    %%Function:	CalcPresForDnodeWithSublines
//    %%Contact:	victork
//
static LSERR CalcPresForDnodeWithSublines(PLSC plsc, PLSDNODE pdn, BOOL fLineCompressed, 
											LSKJUST lskj, BOOL fLastOnLine)
{
	
	PLSSUBL* rgpsubl;
	DWORD	 i;
	
	LSTFLOW lstflow;					// dummy parameter
	LSERR	lserr;
	long	dupSubline;
	long	dupDnode = 0;
	COLLECTSUBLINES CollectGroupChunkPurpose; 


	Assert(DnodeHasSublineForMe(pdn, fLineCompressed));
	
	// calculate dup for dnode with sublines that took part in justification

	if (fLineCompressed)
		{
		CollectGroupChunkPurpose = CollectSublinesForCompression;
		}
	else
		{
		CollectGroupChunkPurpose = CollectSublinesForJustification;
		}

	rgpsubl = pdn->u.real.pinfosubl->rgpsubl;
	
	for (i = 0; i < pdn->u.real.pinfosubl->cSubline; i++)
		{
		// fLastOnLine is always false on lower levels
		
		lserr = CalcPresChunk(plsc, rgpsubl[i]->plsdnFirst, rgpsubl[i]->plsdnLastDisplay,
									CollectGroupChunkPurpose, fLineCompressed, lskj, fFalse);
		if (lserr != lserrNone)
			return lserr;
		LssbGetDupSubline(rgpsubl[i], &lstflow, &dupSubline);
		dupDnode += dupSubline;
		(rgpsubl[i])->fDupInvalid = fFalse;
		}

	// fill dup and call CalcPresentation

	pdn->u.real.dup = dupDnode;

	lserr = (*plsc->lsiobjcontext.rgobj[pdn->u.real.lschp.idObj].lsim.pfnCalcPresentation)
									(pdn->u.real.pdobj, dupDnode, lskj, fLastOnLine);
	if (lserr != lserrNone)
		return lserr;
		
	return lserrNone;
}

//    %%Function:	CalcPresChunk
//    %%Contact:	victork
//
/*
 *	Calls CalcPresentation for all non-text objects on the chunk.
 *	That means 	1) all dnodes in all GroupChunks (including dnodes in submitted sublines) 
 *				2) all dnodes that have submitted sublines
 *
 *	Foreign object on the upper level, which is followed only by trailing spaces, 
 *	should be called with fLastOnLine == fTrue.
 *  Input boolean says whether the input groupchunk is the last on line.
 *
 *	Sets dup for justified sublines
 */
static LSERR CalcPresChunk(PLSC plsc, PLSDNODE pdnFirst, PLSDNODE pdnLast, 
					COLLECTSUBLINES CollectGroupChunkPurpose, BOOL fLineCompressed, 
					LSKJUST lskj, BOOL fLastOnLine)
{
	LSERR		lserr;
	const DWORD iobjText = IobjTextFromLsc(&(plsc->lsiobjcontext));
	BOOL 		fCollecting;
	
	PLSDNODE	pdn;
	
	long		dupTailDnode;				// dummy parameter - will not use
	DWORD		cNumOfTrailers;

	fCollecting = (CollectGroupChunkPurpose != CollectSublinesNone);


	Assert(pdnFirst != NULL);
	Assert(pdnLast != NULL);
	
	pdn = pdnLast;

	// go backwards to switch fLastOnLine off once we are not in trailing spaces

	for (;;)
		{
		if (FIsDnodeReal(pdn))
			if (IdObjFromDnode(pdn) == iobjText)
				{
				if (fLastOnLine == fTrue)
					{
					GetTrailInfoText(pdn->u.real.pdobj, pdn->dcp, &cNumOfTrailers, &dupTailDnode);

					if (cNumOfTrailers < pdn->dcp)
						{
						fLastOnLine = fFalse;							// trailing spaces stop here
						}
					}
				}
			else
				{
				if (fCollecting && DnodeHasSublineForMe(pdn, fLineCompressed))
					{
					lserr = CalcPresForDnodeWithSublines(plsc, pdn, fLineCompressed, lskj, fLastOnLine); 
					if (lserr != lserrNone)
						return lserr;
					}
				else
					{
					lserr = (*plsc->lsiobjcontext.rgobj[pdn->u.real.lschp.idObj].lsim.pfnCalcPresentation)
										(pdn->u.real.pdobj, pdn->u.real.dup, lskj, fLastOnLine);
					if (lserr != lserrNone)
						return lserr;
					}
					
				fLastOnLine = fFalse;
				}

		if (pdn == pdnFirst)
			{
			break;
			}
			
		pdn = pdn->plsdnPrev;

		Assert(pdn != NULL);	// we'll encounter pdnFirst first
		}
		
	return lserrNone;
}

//    %%Function:	UpdateUpLimUnderline
//    %%Contact:	victork
//
/*
 *	Change upLimUnderline to underline trailing spaces, but not EOP.
 *	Notice that from now on upLimUnderline doesn't equals upStartTrailing anymore
 */
 
static void UpdateUpLimUnderline(PLSLINE plsline, long dupTail)
{
	PLSDNODE 	pdnLast;
	
	plsline->upLimUnderline += dupTail;

	// Now EOPs - they are alone in the last dnode or have some borders around them
	
	if (plsline->lslinfo.endr == endrEndPara 		||
		plsline->lslinfo.endr == endrAltEndPara 	||
		plsline->lslinfo.endr == endrEndParaSection ||
		plsline->lslinfo.endr == endrSoftCR)
		{
			
		pdnLast = plsline->lssubl.plsdnLastDisplay;

		Assert(FIsDnodeReal(pdnLast));					// no borders in trailing spaces area
		Assert(pdnLast->dcp == 1);
		Assert(pdnLast->u.real.dup <= dupTail);
		
		plsline->upLimUnderline -= pdnLast->u.real.dup;

		pdnLast = pdnLast->plsdnPrev;
		}

	// This option extends underlining only up to the right margin
	
	if (plsline->upLimUnderline > plsline->upRightMarginJustify)
		{
		plsline->upLimUnderline = plsline->upRightMarginJustify;
		}
}


//    %%Function:	PrepareLineForDisplayProc
//    %%Contact:	victork
//
/*
 *		PrepareLineForDisplayProc fills in the dup's in dnode list and lsline
 * 			
 *	Input dnode list consists of "normal dnode list" of dnodes with positive non-negative cp,
 *	which can be preceded (in this order) by B&N sequence either and/or one Autotab dnode.
 *
 *	B&N sequence is OpeningBorder+AutonumberingObject+TabOrSpace+ClosingBorder. 
 *	ClosingBorder or both OpeningBorder and ClosingBorder can be missing. TabOrSpace can be 
 *	missing too. B&N sequence starts at urStartAutonumberingText and ends at urStartMainText.
 *	Tab in B&N sequence should not be resolved in a usual way.
 *	
 *	Autotab dnode has negative cpFirst, but starts at urStartMainText. It is to be resolved in
 *	a usual way and then be replaced by a pen dnode.
 */

LSERR PrepareLineForDisplayProc(PLSLINE plsline)
{

	LSERR 		lserr;
	const PLSC 	plsc = plsline->lssubl.plsc;
	const DWORD iobjText = IobjTextFromLsc(&(plsc->lsiobjcontext));
	LSDEVRES* 	pdevres = &(plsc->lsdocinf.lsdevres);
	LSTFLOW 	lstflow = plsline->lssubl.lstflow;					/* text flow of the line */
	BOOL 		fVertical = lstflow & fUVertical;

	long		dupText, dupTail, dupTailDnode;
	DWORD		cNumOfTrailers;
	PLSDNODE 	pdn;
	BOOL 		fLastOnLine;

	DWORD		i;
	PDOBJ		pdobj[txtobjMaxM];				// quick group chunk

	Assert(FIsLSLINE(plsline));

	// Next assert means that client should destroy line immediately after creating it 
	//	if fDisplay is set to fFalse in LsSetDoc.
	
	Assert(FDisplay(plsc));

	if (!plsline->lssubl.fDupInvalid)					/* line has been prepared earlier  */
		return lserrNone;  

	Assert(plsc->lsstate == LsStateFree);
	Assert(plsc->plslineCur == plsline);

	plsc->lsstate = LsStatePreparingForDisplay;

	// first try to recognize quick cases, call slow PredDisp otherwise
	
	if (plsc->lsadjustcontext.lskj != lskjNone						|| 
				plsc->lsadjustcontext.lskalign != lskalLeft			|| 
				plsc->lsadjustcontext.lsbrj != lsbrjBreakJustify	||
				plsc->lsadjustcontext.fNominalToIdealEncounted		|| 
				plsc->lsadjustcontext.fSubmittedSublineEncounted	||
				plsline->fNonRealDnodeEncounted						||
				plsline->lssubl.plsdnFirst == NULL					|| 
				FIsNotInContent(plsline->lssubl.plsdnFirst))
		{
		return PrepareLineForDisplay(plsline);
		}

	if (plsc->lsdocinf.fPresEqualRef && !FSuspectDeviceDifferent(PlnobjFromLsline(plsline, iobjText)))
		{
		// Trident quick case - no need to scale down. Dups are already set in text dnodes.

		// go through dnode list to calculate dupTrail and CalcPres foreign objects

		pdn = plsline->lssubl.plsdnLastDisplay;
		dupTail = 0;
		
		fLastOnLine = fTrue;
		
		while (pdn != NULL && IdObjFromDnode(pdn) == iobjText)
			{
			Assert(pdn->u.real.dup == pdn->u.real.objdim.dur);

			GetTrailInfoText(pdn->u.real.pdobj, pdn->dcp, &cNumOfTrailers, &dupTailDnode);

			dupTail += dupTailDnode;

			if (cNumOfTrailers < pdn->dcp)
				{
				fLastOnLine = fFalse;				// trailing spaces stop here
				break;								// text is the last on the line
				}

			pdn = pdn->plsdnPrev;
			}

		// dupTail is calculated, we still should call pfnCalcPresentation for foreing objects

		if (plsc->lsadjustcontext.fForeignObjectEncounted)
			{

			while (pdn != NULL)
				{
				Assert(pdn->u.real.dup == pdn->u.real.objdim.dur);
				
				if (IdObjFromDnode(pdn) != iobjText)
					{
					lserr = (*plsc->lsiobjcontext.rgobj[pdn->u.real.lschp.idObj].lsim.pfnCalcPresentation)
												(pdn->u.real.pdobj, pdn->u.real.dup, lskjNone, fLastOnLine);
					if (lserr != lserrNone)
						{
						plsc->lsstate = LsStateFree;
						return lserr;
						}

					fLastOnLine = fFalse;				// only the first coulsd be the last on the line
					}
				
				pdn = pdn->plsdnPrev;
				}
			}
			
		plsline->lssubl.fDupInvalid = fFalse;
		
		plsline->upRightMarginJustify = plsc->lsadjustcontext.urRightMarginJustify;
		plsline->upStartMainText = plsc->lsadjustcontext.urStartMainText;
		plsline->upStartAutonumberingText = plsline->upStartMainText;
		plsline->upLimAutonumberingText = plsline->upStartMainText;
		plsline->upLimLine = plsline->lssubl.urCur;
		plsline->upStartTrailing = plsline->upLimLine - dupTail;
		plsline->upLimUnderline = plsline->upStartTrailing;

		plsline->fCollectVisual = fFalse;

		if (plsc->lsadjustcontext.fUnderlineTrailSpacesRM && 
					plsline->upLimUnderline < plsline->upRightMarginJustify)
			{
			UpdateUpLimUnderline(plsline, dupTail);
			}
			
		plsc->lsstate = LsStateFree;
		return lserrNone;
	}

	if ((plsc->grpfManager & fFmiPresExactSync) != 0 &&	
			!plsc->lsadjustcontext.fForeignObjectEncounted &&
			!plsc->lsadjustcontext.fNonLeftTabEncounted &&
			plsline->lssubl.plsdnLastDisplay != NULL &&			// empty line is not a quick case ;(
			FQuickScaling(PlnobjFromLsline(plsline, iobjText), fVertical, 
										plsline->lssubl.urCur - plsc->lsadjustcontext.urStartMainText))
		{
		// Looks like Word quick case 
		// We can still go slow way if all trailing spaces are not in one dnode
		
		if (plsline->lslinfo.endr == endrEndPara)
			{
			
			Assert(FIsDnodeReal(plsline->lssubl.plsdnLastDisplay));
			Assert(plsline->lssubl.plsdnLastDisplay->dcp == 1);
			
			pdn = plsline->lssubl.plsdnLastDisplay->plsdnPrev;

			if (pdn != NULL)
				{
				GetTrailInfoText(pdn->u.real.pdobj, pdn->dcp, &cNumOfTrailers, &dupTailDnode);
				
				if (cNumOfTrailers > 0)
					{
					// There are spaces before EOP - go slow way
					return PrepareLineForDisplay(plsline);
					}
				}

			cNumOfTrailers = 1;
			}
		else
			{
			pdn = plsline->lssubl.plsdnLastDisplay;
			
			GetTrailInfoText(pdn->u.real.pdobj, pdn->dcp, &cNumOfTrailers, &dupTailDnode);
			
			if (cNumOfTrailers == pdn->dcp)
				{
				// We can't be sure all spaces are in this dnode - forget it then
				return PrepareLineForDisplay(plsline);
				}
			
			}

		// we are sure now that all cNumOfTrailers trailing spaces are in the last dnode

		// fill standard output part, upStartMainText will be used below

		plsline->lssubl.fDupInvalid = fFalse;
		plsline->fCollectVisual = fFalse;

		plsline->upRightMarginJustify = UpFromUr(lstflow, pdevres, plsc->lsadjustcontext.urRightMarginJustify);
		plsline->upStartMainText = UpFromUr(lstflow, pdevres, plsc->lsadjustcontext.urStartMainText);
		plsline->upStartAutonumberingText = plsline->upStartMainText;
		plsline->upLimAutonumberingText = plsline->upStartMainText;
		
		if (!plsc->lsadjustcontext.fTabEncounted)
			{
			// Very nice, we have only one groupchunk to collect
			
			for (pdn = plsline->lssubl.plsdnFirst, i = 0;;)
				{
				Assert(FIsDnodeReal(pdn));
				Assert(IdObjFromDnode(pdn) == iobjText);

				// i never gets outside of pdobj array.
				// Text makes sure in FQuickscaling

				Assert(i < txtobjMaxM);
				
				pdobj[i] = pdn->u.real.pdobj;

				i++;

				if (pdn == plsline->lssubl.plsdnLastDisplay)
					{
					break;
					}

				pdn = pdn->plsdnNext;
				}

			QuickAdjustExact(&(pdobj[0]), i, cNumOfTrailers, fVertical, &dupText, &dupTail);

			plsline->upRightMarginJustify = UpFromUr(lstflow, pdevres, plsc->lsadjustcontext.urRightMarginJustify);
			plsline->upStartMainText = UpFromUr(lstflow, pdevres, plsc->lsadjustcontext.urStartMainText);
			plsline->upStartAutonumberingText = plsline->upStartMainText;
			plsline->upLimAutonumberingText = plsline->upStartMainText;
			plsline->upLimLine = plsline->upStartMainText + dupText;
			plsline->upStartTrailing = plsline->upLimLine - dupTail;
			plsline->upLimUnderline = plsline->upStartTrailing;

			plsline->fCollectVisual = fFalse;

			if (plsc->lsadjustcontext.fUnderlineTrailSpacesRM && 
						plsline->upLimUnderline < plsline->upRightMarginJustify)
				{
				UpdateUpLimUnderline(plsline, dupTail);
				}
				
			plsc->lsstate = LsStateFree;
			return lserrNone;
			}
		else
			{
			// Tabs are present, but they all are left tabs

			pdn = plsline->lssubl.plsdnFirst;
			plsline->upLimLine = plsline->upStartMainText;

			// Do one QuickGroupChunk after another, moving plsline->upLimLine

			for (;;)
				{
				// loop body: Collect next QuickGroupChunk, deal with it, exit after last one

				for (i = 0;;)
					{
					Assert(FIsDnodeReal(pdn));
					Assert(IdObjFromDnode(pdn) == iobjText);

					if (pdn->fTab)
						{
						break;
						}

					Assert(i < txtobjMaxM);
					
					pdobj[i] = pdn->u.real.pdobj;

					i++;

					if (pdn == plsline->lssubl.plsdnLastDisplay)
						{
						break;
						}

					pdn = pdn->plsdnNext;
					}

				Assert(pdn == plsline->lssubl.plsdnLastDisplay || pdn->fTab);

				if (pdn->fTab)
					{
					long upTabStop;
					
					if (i == 0)
						{
						dupText = 0;
						dupTail = 0;
						}
					else
						{
						QuickAdjustExact(pdobj, i, 0, fVertical, &dupText, &dupTail);
						}

					Assert(plsc->lstabscontext.pcaltbd[pdn->icaltbd].lskt == lsktLeft);

					upTabStop = UpFromUr(lstflow, pdevres, plsc->lstabscontext.pcaltbd[pdn->icaltbd].ur);
					pdn->u.real.dup = upTabStop - plsline->upLimLine - dupText;
					plsline->upLimLine = upTabStop;

					if (pdn == plsline->lssubl.plsdnLastDisplay)
						{
						break;
						}
					
					pdn = pdn->plsdnNext;
					}
				else
					{

					Assert(i != 0);
					
					QuickAdjustExact(pdobj, i, cNumOfTrailers, fVertical, &dupText, &dupTail);
						
					plsline->upLimLine += dupText;

					break;
					}
				}
			
			plsline->upStartTrailing = plsline->upLimLine - dupTail;
			plsline->upLimUnderline = plsline->upStartTrailing;

			if (plsc->lsadjustcontext.fUnderlineTrailSpacesRM && 
						plsline->upLimUnderline < plsline->upRightMarginJustify)
				{
				UpdateUpLimUnderline(plsline, dupTail);
				}
				
			plsc->lsstate = LsStateFree;
			return lserrNone;
			}
		}

	// Getting here means quick prepdisp haven't happen
	
	return PrepareLineForDisplay(plsline);

}


/*
 *	This is slow and painstaking procedure that does everyting.
 *	Called when QuickPrep above cannot cope.
 */

static LSERR PrepareLineForDisplay(PLSLINE plsline)
{
	LSERR 		lserr = lserrNone;
	const PLSC 	plsc = plsline->lssubl.plsc;
	LSTFLOW 	lstflow = plsline->lssubl.lstflow;		/* text flow of the subline */
	const DWORD iobjText = IobjTextFromLsc(&(plsc->lsiobjcontext));
	LSDEVRES* 	pdevres = &(plsc->lsdocinf.lsdevres);
	long 		urColumnMax = plsc->lsadjustcontext.urRightMarginJustify;
	long 		upColumnMax = UpFromUr(lstflow, pdevres, urColumnMax);
	LSCP		cpLim = plsline->lssubl.cpLimDisplay;
	PLSDNODE 	pdnFirst = plsline->lssubl.plsdnFirst;	/* the first dnode of the line */

	PLSDNODE 	pdnAutoDecimalTab = NULL;		/* NULL means - no such a thing on the line */

	GRCHUNKEXT 	grchunkext;
	BOOL		fEmptyGroupChunk;
	
	PLSDNODE 	pdnLastWall = NULL;				/* last wall with submitted sublines after it */
	BOOL		fAnySublines = fFalse;
	
	COLLECTSUBLINES CollectGroupChunkPurpose =  (plsc->lsadjustcontext.fLineCompressed) ?
								CollectSublinesForCompression : CollectSublinesForJustification;

	// parameters to call AdjustText
	
	LSKJUST 	lskj = lskjNone;					/* These four will be changed only when calling	*/
	BOOL		fForcedBreak = fFalse;				/*  AdjustText last time on the line 			*/
	BOOL		fSuppressTrailingSpaces = fFalse;	/* if ever */
	LSKALIGN	lskalign = plsc->lsadjustcontext.lskalign;		// Alignment can be changed too
	
	long		dupAvailable;
	BOOL		fExact;
	BOOL		fSuppressWiggle;	
	
	long 		dupText, dupTail = 0, dupToAddToNonTextObjects;
	long 		durColumnMax;
	DWORD 		cNonTextObjectsToExtend;

	PLSDNODE 	pdnNextFirst;					/* first Dnode of the next GrpChnk */
	GrpChnkWall	LeftWall, RightWall;			/* current TextGroupChunk walls */
	long		upLeftWall,urLeftWall;			/* Left wall position */

	long		dupWall, durWall;
	long		dupGrpChnk;
	long	 	dupToTabPoint;
	long 		dupJustifyLine;

	LSKTAB		lsktabLast = lsktLeft;
	long		dupLastTab = 0;
	long		upLeftWallForCentering;
	
	PLSDNODE 	pdnLast;


	InitGroupChunkExt(plsline->lssubl.plschunkcontext, iobjText, &grchunkext);		/* prepare one GRCHUNKEXT for all */

	plsline->upStartMainText = UpFromUr(lstflow, pdevres, plsc->lsadjustcontext.urStartMainText);

	// set defaults incase there are no autonumbering
	
	plsline->upStartAutonumberingText = plsline->upStartMainText;
	plsline->upLimAutonumberingText = plsline->upStartMainText;

	// fCollectVisual can be reset to fTrue by ScaleDownLevel called here or in AdjustSubline
	
	plsline->fCollectVisual = fFalse;
	
 	if (!plsline->fAllSimpleText)
		{
		/* straighforward scaling down of non-text objects */
		
		ScaleDownLevel(&(plsline->lssubl), &fAnySublines, &(plsline->fCollectVisual));

		if (plsc->lsadjustcontext.fLineContainsAutoNumber)
			{

			// do dup setting for autonumbers, update pdnFirst to point after it
			
			lserr = CalcPresAutonumbers(plsline, &pdnFirst);		
			if (lserr != lserrNone)
				{
				plsc->lsstate = LsStateFree;
				return lserr;
				}
			}

		// If autodecimal tab is there, pdnFirst points at it - make a note.
		// This tab can only be just before main text and it has negative cpFirst
		// Check for NULL is needed because empty dnode list is possible in LS. 
		// We don't have a dnode for splat, so we'll get here with pdnFirst == NULL
		// when line is (object that said delete me) + splat
		
		if (plsc->lsadjustcontext.fAutodecimalTabPresent)
			{
			Assert(pdnFirst != NULL && FIsNotInContent(pdnFirst) && pdnFirst->fTab);
			// It doesn't need any special handling even having negative cpFirst
			// We note it to convert to pen later
			pdnAutoDecimalTab = pdnFirst;
			}
			
		if (fAnySublines)
			{
			// Find last tab and prepare sublines after it.
			
			FindWallToCollectSublinesAfter(pdnFirst,  cpLim, plsc->lsadjustcontext.fLineCompressed, 
										&pdnLastWall);
			}
	}

	/*
	 *	Loop structure : While !end_of_line do
	 *						{
	 *						get next Wall (collect GrpChnk);
	 *						adjust 	GrpChnk;
	 *						set dup of the tab to the left of the GrpChnk;
	 *						move one Wall to the right
	 *						}
	 *
	 *	Invariance: all dup before LeftWall are done.
	 *				upLeftWall is at the beginning of the left wall
	 *				pdnNextFirst is the dnode to start collecting next GrpChnk with
	 */

	pdnNextFirst = pdnFirst; 
	LeftWall.kwall = LineBegin;
	LeftWall.pdn = PLINEBEGIN;
	LeftWall.lsktab = lsktLeft;							// 4 lines just against asserts
	LeftWall.wchCharTab = 0;						
	LeftWall.upTab = 0;
	RightWall = LeftWall;
	upLeftWall = 0;
	urLeftWall = 0;

	while (LeftWall.kwall != LineEnd)
		{
		/* 	1. Find next wall (collect GrpChnk or skip collecting if two walls in a row)
		 * 	
		 * 	Input:  pdnNextFirst - first dnode after Left wall
		 *
		 * 	Output: RightWall.pdn & grchunkext. 
		 * 	   if there is no GrpChnk some zeros in grchunkext is enough
         */
		if (FIsWall(pdnNextFirst, cpLim))
			{
			fEmptyGroupChunk = fTrue;
			RightWall.pdn = pdnNextFirst;
			grchunkext.durTotal = 0;
			grchunkext.durTextTotal = 0;
			grchunkext.dupNonTextTotal = 0;
			}
		else
			{
			lserr = CollectTextGroupChunk(pdnNextFirst, cpLim, CollectGroupChunkPurpose, &grchunkext);
			if (lserr != lserrNone)
				{
				plsc->lsstate = LsStateFree;
				return lserr;
				}
				
			if (grchunkext.lsgrchnk.clsgrchnk == 0 && grchunkext.cNonTextObjects == 0)
				{
				// only borders in this groupchunk - no need to call AdjustText
				
				fEmptyGroupChunk = fTrue;
				grchunkext.durTextTotal = 0;
				}
			else
				{
				fEmptyGroupChunk = fFalse;
				}
				
			RightWall.pdn = grchunkext.plsdnNext;
			}

		/* 
		 * 	2. fill in Right Wall information
		 *
		 * 	Input: RightWall.pdn
		 *
		 * 	Output: pdnNextFirst, RightWall information. 
	 	 */
		if (!FDnodeBeforeCpLim(RightWall.pdn, cpLim))
			{
			RightWall.kwall = LineEnd;
			}
		else
			{
			Assert(FIsWall(RightWall.pdn, cpLim));
			pdnNextFirst = RightWall.pdn->plsdnNext;

			if (FIsDnodePen(RightWall.pdn))
				{
				RightWall.kwall = Pen;
				}
			else
				{
				Assert(RightWall.pdn->fTab);			/* it must be a tab */

				RightWall.kwall = Tab;
				RightWall.lsktab = plsc->lstabscontext.pcaltbd[RightWall.pdn->icaltbd].lskt;
				RightWall.wchCharTab = plsc->lstabscontext.pcaltbd[RightWall.pdn->icaltbd].wchCharTab;
				RightWall.upTab = UpFromUr(lstflow, pdevres, plsc->lstabscontext.pcaltbd[RightWall.pdn->icaltbd].ur);
				}
			}

		/* 
		 *	prepare parameters for AdjustText
		 *
		 * 	Input: LeftWall, urLeftWall, upLeftWall, is_it_the_last_one
		 *
		 * 	Output: durColumnMax; lskj, dupAvailable and other input parameters for AdjustText
		 * 	        
		 */

		if (RightWall.kwall != LineEnd)
			{
			if (RightWall.kwall == Tab && RightWall.lsktab == lsktLeft)
				{
				
				// Now we know for sure what space we have for text in this groupchunk
				// and can do decent job if client doesn't care about fExact
				
				long upLeft, urLeft, upRight, urRight;

				urRight = plsc->lstabscontext.pcaltbd[RightWall.pdn->icaltbd].ur;
				upRight = UpFromUr(lstflow, pdevres, urRight);

				if (LeftWall.kwall == Tab && LeftWall.lsktab == lsktLeft)
					{			
					urLeft = plsc->lstabscontext.pcaltbd[LeftWall.pdn->icaltbd].ur;
					upLeft = UpFromUr(lstflow, pdevres, urLeft);
					}
				else if (LeftWall.kwall == LineBegin)
					{
					urLeft = plsc->lsadjustcontext.urStartMainText;
					upLeft = plsline->upStartMainText;
					}
				else if (LeftWall.kwall == Pen)
					{
					/* pen - it've been scaled already, we know left wall dimensions in advance */
					urLeft = urLeftWall + LeftWall.pdn->u.pen.dur;
					upLeft = upLeftWall + LeftWall.pdn->u.pen.dup;
					}
				else 						/* now non-left tabs */
					{
					urLeft = urLeftWall;
					upLeft = upLeftWall;
					}

				durColumnMax = urRight - urLeft;
				dupAvailable = upRight - upLeft;

				Assert(durColumnMax >= 0);
				
				// dupAvailable can be < 0 here - visi optional hyphens in previous GC, for example.
				// AdjustText doesn't mind, meaning it won't crush.
				
				fSuppressWiggle = ((plsc->grpfManager & fFmiPresSuppressWiggle) != 0);
				fExact = ((plsc->grpfManager & fFmiPresExactSync) != 0);
				}
			else
				{
				// situation is complicated - we go the safest way.
				
				durColumnMax = grchunkext.durTotal;
				dupAvailable = LONG_MAX;
				fExact = fTrue;
				fSuppressWiggle = fTrue;
				}
			}
		else		
			{
			/* for the last GrpChnk we must to calculate durColumnMax and dupAvailable */

			if (LeftWall.kwall == Tab && LeftWall.lsktab == lsktLeft)
				{			
				durColumnMax = urColumnMax - plsc->lstabscontext.pcaltbd[LeftWall.pdn->icaltbd].ur;
				dupAvailable = UpFromUr(lstflow, pdevres, urColumnMax) - grchunkext.dupNonTextTotal - 
					UpFromUr(lstflow, pdevres, plsc->lstabscontext.pcaltbd[LeftWall.pdn->icaltbd].ur);
				}
			else if (LeftWall.kwall == LineBegin)
				{
				durColumnMax = urColumnMax - plsc->lsadjustcontext.urStartMainText;
				dupAvailable = upColumnMax - plsline->upStartMainText - grchunkext.dupNonTextTotal;

				// Ask AdjustText to set widths of trailing spaces to 0 only if
				// It is the last groupchunk, (we actually only care for "the only one" situation)
				// and its first dnode (again, we actually only care for "the only one" situation)
				// submits subline for both justification and trailing spaces
				// and this subline runs in the direction opposite to the line direction.
				
				if (!fEmptyGroupChunk &&
						FIsDnodeReal(grchunkext.plsdnFirst) && grchunkext.plsdnFirst->u.real.pinfosubl != NULL &&
						grchunkext.plsdnFirst->u.real.pinfosubl->fUseForJustification &&
						grchunkext.plsdnFirst->u.real.pinfosubl->fUseForTrailingArea &&
						FCollinearTflows(((grchunkext.plsdnFirst->u.real.pinfosubl->rgpsubl)[0])->lstflow, lstflow) &&
						((grchunkext.plsdnFirst->u.real.pinfosubl->rgpsubl)[0])->lstflow != lstflow)				
					{
					fSuppressTrailingSpaces = fTrue;
					}
				}
			else if (LeftWall.kwall == Pen)
				{
				/* pen - it've been scaled already, we know wall dimensions in advance */
				durColumnMax = urColumnMax - urLeftWall - LeftWall.pdn->u.pen.dur;
				dupAvailable = UpFromUr(lstflow, pdevres, urColumnMax) - upLeftWall - 
									LeftWall.pdn->u.pen.dup - grchunkext.dupNonTextTotal;
				}
			else 						/* now non-left tabs */
				{
				durColumnMax = urColumnMax - urLeftWall;
				dupAvailable = UpFromUr(lstflow, pdevres, urColumnMax) - upLeftWall - grchunkext.dupNonTextTotal;
				}
			
			// we do some tricks with justification mode at the end of line
			// alignment can change too.

			lserr = SetJustificationForLastGroupChunk(plsline, LeftWall, &lskj, &lskalign);   
			if (lserr != lserrNone)
				{
				plsc->lsstate = LsStateFree;
				return lserr;
				}

			// Don't try to squeeze into RMJustify is RMBreak is infinite.
			
			if (plsc->urRightMarginBreak >= uLsInfiniteRM)
				{
				dupAvailable = LONG_MAX;
				}
				
			fSuppressWiggle = ((plsc->grpfManager & fFmiPresSuppressWiggle) != 0);
			fExact = ((plsc->grpfManager & fFmiPresExactSync) != 0);
			fForcedBreak = plsline->lslinfo.fForcedBreak;
			}

		/* 
		 * Adjust text (if any) 
		 *
		 * 	Input: durColumnMax, dupAvailable, lskj and other input parameters
		 *
		 * 	Output:  dupText and dupTail 
		 */
		if (fEmptyGroupChunk)
			{
			dupText = 0;
			dupTail = 0;
			dupToAddToNonTextObjects = 0;
			}
		else
			{
			lserr = AdjustText(lskj, durColumnMax, grchunkext.durTotal - grchunkext.durTrailing,
								dupAvailable, &(grchunkext.lsgrchnk), 
								&(grchunkext.posichnkBeforeTrailing), lstflow,
								plsc->lsadjustcontext.fLineCompressed && RightWall.kwall == LineEnd,
								grchunkext.cNonTextObjectsExpand,   
								fSuppressWiggle, fExact, fForcedBreak, fSuppressTrailingSpaces, 
								&dupText, &dupTail, &dupToAddToNonTextObjects, &cNonTextObjectsToExtend);   
			if (lserr != lserrNone)
				{
				plsc->lsstate = LsStateFree;
				return lserr;
				}

			//	Finish justification by expanding non-text object.
			
			if (cNonTextObjectsToExtend != 0 && dupToAddToNonTextObjects > 0)
				{
				WidenNonTextObjects(&grchunkext, dupToAddToNonTextObjects, cNonTextObjectsToExtend);
				}
			else
				//	We don't compressi and we don't expand the last non-text object on the line
				{
				dupToAddToNonTextObjects = 0;				// don't say we did it
				}
				
			/*
			 *	Set dup in non-text objects (do CalcPres) in the current GroupChunk
			 *
			 *	The job cannot be postponed until after the end of the main loop and done for the whole line
			 *		because GetDistanceToDecimalPoint relies on dups in upper level dnodes
			 */
			 
			if (!plsline->fAllSimpleText)
				{
				// find the last upper level dnode of the groupchunk
				
				if (grchunkext.plsdnNext != NULL)
					{
					pdnLast = (grchunkext.plsdnNext)->plsdnPrev;
					}
				else
					{
					Assert(RightWall.kwall == LineEnd);
					pdnLast = plsline->lssubl.plsdnLastDisplay;
					}
					
				lserr = CalcPresChunk(plsc, grchunkext.plsdnFirst, pdnLast, CollectGroupChunkPurpose, 
							plsc->lsadjustcontext.fLineCompressed, lskj, (RightWall.kwall == LineEnd));
							
				if (lserr != lserrNone)
					{
					plsc->lsstate = LsStateFree;
					return lserr;
					}
				}
		}

		/* 
		 *	Set the left wall (if it's a tab - resolve it)
		 *
		 * 	Input: LeftWall, dupText, dupTail, grchunkext.dupNonTextTotal, grchunkext.durTotal, 
		 *			dupToAddToNonTextObjects (grchunkext for decimal tab)
		 *
		 * 	Output:  dupWall, durWall 
		 */
		dupGrpChnk = dupText + grchunkext.dupNonTextTotal + dupToAddToNonTextObjects;

		lsktabLast = lsktLeft;							// no tab equal left tab for my purpose
		
		if (LeftWall.kwall == Tab)
			{
			/* calculate dup of the Left wall now */

			if (dupGrpChnk == 0)					/* consecutive tabs */

				dupWall = LeftWall.upTab - upLeftWall;

			else 	
				if (LeftWall.lsktab == lsktLeft)
					dupWall = LeftWall.upTab - upLeftWall;
				else if (LeftWall.lsktab == lsktRight)
					dupWall = LeftWall.upTab - upLeftWall - (dupGrpChnk - dupTail);
				else if (LeftWall.lsktab == lsktCenter)
					dupWall = LeftWall.upTab - upLeftWall - ((dupGrpChnk - dupTail) / 2);
				else 	/* LeftWall.lsktab == lsktDecimal or lsktChar */
					{
					lserr = GetDistanceToTabPoint(&grchunkext, cpLim, LeftWall.lsktab, LeftWall.wchCharTab,  
													LeftWall.pdn->plsdnNext, &dupToTabPoint);
					if (lserr != lserrNone)
						{
						plsc->lsstate = LsStateFree;
						return lserr;
						}

					dupWall = LeftWall.upTab - upLeftWall - dupToTabPoint;
					}

			// take care of previous text and right margin
					
			if (RightWall.kwall == LineEnd && 
					(upLeftWall + dupWall + dupGrpChnk - dupTail) > upColumnMax)
				{
				// We don't want to cross RM because of last center tab
				
				dupWall = upColumnMax - upLeftWall - dupGrpChnk + dupTail;
				}

			if (dupWall < 0)
				dupWall = 0;

			/* LeftWall tab resolving */
			LeftWall.pdn->u.real.dup = dupWall;
			durWall = LeftWall.pdn->u.real.objdim.dur;

			// for reproducing Word's bug of forgetting last not-left tab for centering.
			
			lsktabLast = LeftWall.lsktab;
			dupLastTab = dupWall;
			}
		else if (LeftWall.kwall == Pen)
			{
			dupWall = LeftWall.pdn->u.pen.dup;		/* it've been scaled already */
			durWall = LeftWall.pdn->u.pen.dur;
			}
		else 										/* LeftWall.kwall == LineBegin */
			{
			dupWall = plsline->upStartMainText;
			durWall = plsc->lsadjustcontext.urStartMainText;
			}

		/* update loop variables, move one wall to the right */

		upLeftWall += dupWall + dupGrpChnk;
		urLeftWall += durWall + grchunkext.durTotal;
		LeftWall = RightWall;
	}												/* end of the main loop */

	/* 
	 *	prepare output parameters
	 */

	plsline->upRightMarginJustify = upColumnMax;
	plsline->upLimLine = upLeftWall;
	plsline->upStartTrailing = upLeftWall - dupTail;
	plsline->upLimUnderline = plsline->upStartTrailing;
	plsline->lssubl.fDupInvalid = fFalse;

	/* 	
     *				Do left margin adjustment (not for breakthrough tab)
     *				 We're interested in lskalRight and Centered now
	 */
	
	if (lskalign != lskalLeft && !FBreakthroughLine(plsc))
		{
		if (plsc->lsadjustcontext.fForgetLastTabAlignment && lsktabLast != lsktLeft)
			{
			// reproduction of an old Word bug: when last tab was not left and was resolved at line end
			// they forgot to update their counterpart of upLeftWallForCentering. Word still have to be
			// able to show old documents formatted in this crazy way as they were.
			
			upLeftWallForCentering = upLeftWall - dupLastTab - dupTail;
			}
		else
			{
			upLeftWallForCentering = upLeftWall - dupTail;
			}
			
		if (lskalign == lskalRight)
			{
			dupJustifyLine = upColumnMax - upLeftWallForCentering;
			}
		else	
			{
			/* These logic of centering is too simple to be valid, but Word uses it */
			
			dupJustifyLine = (upColumnMax - upLeftWallForCentering) / 2;
			}
			
		// Apply adjustment if hanging punctuation haven't make it negative
		
		if (dupJustifyLine > 0)	
			{
			plsline->upStartAutonumberingText += dupJustifyLine;
			plsline->upLimAutonumberingText += dupJustifyLine;
			plsline->upStartMainText += dupJustifyLine;
			plsline->upLimLine += dupJustifyLine;
			plsline->upStartTrailing += dupJustifyLine;
			plsline->upLimUnderline += dupJustifyLine;
			}
		}

	if (plsc->lsadjustcontext.fUnderlineTrailSpacesRM && 
				plsline->upLimUnderline < plsline->upRightMarginJustify)
		{
		UpdateUpLimUnderline(plsline, dupTail);
		}
		
	if (pdnAutoDecimalTab != NULL)
		ConvertAutoTabToPen(plsline, pdnAutoDecimalTab);

	plsc->lsstate = LsStateFree;

	return lserr;
}

//    %%Function:	MatchPresSubline
//    %%Contact:	victork
//
/*
 *			Order of operations
 *
 *		1. Straighforward scaling down of non-text objects
 *		2. Adjusting of text by LeftExact
 *		3. Intelligent rescaling of pens to counteract rounding errors and text non-expansion.
 *		4. Calling CalcPresentation for all non-text objects
 */
LSERR MatchPresSubline(PLSSUBL plssubl)
{
	LSERR 		lserr;
	const PLSC 	plsc = plssubl->plsc;
	LSTFLOW 	lstflow = plssubl->lstflow;					/* text flow of the subline */
	const DWORD iobjText = IobjTextFromLsc(&(plsc->lsiobjcontext));
	LSDEVRES* 	pdevres = &(plsc->lsdocinf.lsdevres);
	LSCP		cpLim = plssubl->cpLimDisplay;
	PLSDNODE 	pdnFirst = plssubl->plsdnFirst;
	GRCHUNKEXT 	grchunkext;

	long 		dupAvailable;							/* input for AdjustText */
	
	long 		dupText, dupTail, dupToAddToNonTextObjects;		/* dummy output for AdjustText */
	DWORD 		cNonTextObjectsToExtend;
	
	BOOL 	 	fDummy1, fDummy2;									// dummy parameters
	
	long 		urAlreadyScaled, upAlreadyScaled, upAlreadyScaledNew;

	PLSDNODE pdn;
	
	Assert(plssubl->fDupInvalid == fTrue);
	
	/*	1. Straighforward scaling down of non-text objects */
	
	ScaleDownLevel(plssubl, &fDummy1, &fDummy2);

	/* 	2. Adjusting of text on the level by LeftExact */
	
	InitGroupChunkExt(plssubl->plschunkcontext, iobjText, &grchunkext);	/* prepare GRCHUNKEXT */

	pdn = pdnFirst;

	while (pdn != NULL && (pdn->fTab || FIsDnodeNormalPen(pdn)))		/* skip GrpChnk Wall(s) */
		pdn = pdn->plsdnNext;

	while (FDnodeBeforeCpLim(pdn, cpLim))
		{
		lserr = CollectTextGroupChunk(pdn, cpLim, CollectSublinesNone, &grchunkext);
		if (lserr != lserrNone)
			return lserr;

		/* Adjust text by Left, Exact, no durFreeSpace, ignore any shortcomings */

		dupAvailable = UpFromUr(lstflow, pdevres, grchunkext.durTotal) - grchunkext.dupNonTextTotal;

		// posichnkBeforeTrailing is undefined when CollectSublinesNone, tell AdjustText about it

		grchunkext.posichnkBeforeTrailing.ichnk = grchunkext.lsgrchnk.clsgrchnk;
		grchunkext.posichnkBeforeTrailing.dcp = 0;
		
		lserr = AdjustText(lskjNone, grchunkext.durTotal, grchunkext.durTotal, 
							dupAvailable, 
							&(grchunkext.lsgrchnk),
							&(grchunkext.posichnkBeforeTrailing), 
							lstflow, 
							fFalse, 						// compress?
							grchunkext.cNonTextObjects,   
							fTrue, 							// fSuppressWiggle
							fTrue,							// fExact
							fFalse,							// fForcedBreak
							fFalse,							// fSuppressTrailingSpaces
							&dupText, &dupTail, &dupToAddToNonTextObjects, &cNonTextObjectsToExtend);   
		if (lserr != lserrNone)
			return lserr;

		pdn = grchunkext.plsdnNext;
		while (pdn != NULL && (pdn->fTab || FIsDnodeNormalPen(pdn)))		/* skip GrpChnk Wall(s) */
			pdn = pdn->plsdnNext;
		}

	/*	3-4. Intelligent rescaling of pens to counteract rounding errors and text non-expansion. 
	 *    	 and adjusting of lower levels. Calling CalcPresentation for non-text objects.
	 */

	pdn = pdnFirst;
	urAlreadyScaled = 0;
	upAlreadyScaled = 0;

	while (FDnodeBeforeCpLim(pdn, cpLim))
		{
		if (FIsDnodeReal(pdn))
			{
			urAlreadyScaled += pdn->u.real.objdim.dur;
			upAlreadyScaled += pdn->u.real.dup;
			if (IdObjFromDnode(pdn) != iobjText)
				{
				// It's always lskjNone and not last object on the line for MatchPresSubline
				lserr = (*plsc->lsiobjcontext.rgobj[pdn->u.real.lschp.idObj].lsim.pfnCalcPresentation)
									(pdn->u.real.pdobj, pdn->u.real.dup, lskjNone, fFalse);
				if (lserr != lserrNone)
					return lserr;
				}
			}
		else if (FIsDnodeBorder(pdn))
			{
			// we don't rescale borders to preserve (dupOpeningBorder == dupClosingBorder)
			upAlreadyScaled += pdn->u.real.dup;
			urAlreadyScaled += pdn->u.pen.dur;
			}
		else		/* pen */
			{							
			urAlreadyScaled += pdn->u.pen.dur;
			upAlreadyScaledNew = UpFromUr(lstflow, pdevres, urAlreadyScaled);
			pdn->u.pen.dup = upAlreadyScaledNew - upAlreadyScaled;
			upAlreadyScaled = upAlreadyScaledNew;
			}

		pdn = pdn->plsdnNext;
		}
		
	plssubl->fDupInvalid = fFalse;

	return lserrNone;
}

//    %%Function:	AdjustSubline
//    %%Contact:	victork
//
/*
 *
 *		Scale down non-text objects.
 *		Collect GroupChunk
 *		It should cover the whole subline or else do MatchPresSubline instead.
 *		Adjust text by expanding or compressing to given dup.
 *		Call CalcPresentation for all non-text objects.
 */
 
LSERR AdjustSubline(PLSSUBL plssubl, LSKJUST lskjust, long dup, BOOL fCompress)
{
	LSERR 		lserr;
	const PLSC 	plsc = plssubl->plsc;
	LSTFLOW 	lstflow = plssubl->lstflow;					/* text flow of the subline */
	const DWORD iobjText = IobjTextFromLsc(&(plsc->lsiobjcontext));
	LSDEVRES* 	pdevres = &(plsc->lsdocinf.lsdevres);
	LSCP		cpLim = plssubl->cpLimDisplay;
	PLSDNODE 	pdnFirst = plssubl->plsdnFirst;
	GRCHUNKEXT 	grchunkext;
	COLLECTSUBLINES CollectGroupChunkPurpose; 

	long 		dupAvailable, durColumnMax;			/* input for AdjustText */
	
	long 		dupText, dupTail, dupToAddToNonTextObjects;		/* dummy output for AdjustText */
	DWORD 		cNonTextObjectsToExtend;
	BOOL 	 	fDummy;

	if (plssubl->plsdnFirst == NULL)
		{
		return lserrNone;
		}

	Assert(plssubl->fDupInvalid == fTrue);
		
 	ScaleDownLevel(plssubl, &fDummy, &(plsc->plslineCur->fCollectVisual));

	CollectGroupChunkPurpose = (fCompress) ? CollectSublinesForCompression : CollectSublinesForJustification;

	InitGroupChunkExt(plssubl->plschunkcontext, iobjText, &grchunkext);	/* prepare GRCHUNKEXT */

	lserr = CollectTextGroupChunk(pdnFirst, cpLim, CollectGroupChunkPurpose, &grchunkext);
	if (lserr != lserrNone)
		return lserr;

	if (FDnodeBeforeCpLim(grchunkext.plsdnNext, cpLim))			// more than one GroupChunk -
		{
		return MatchPresSubline(plssubl);						// cancel Expansion
		}

	dupAvailable = dup - grchunkext.dupNonTextTotal;

	if (dupAvailable < 0)										// input dup is wrong -
		{
		return MatchPresSubline(plssubl);						// cancel Expansion
		}

	durColumnMax = UrFromUp(lstflow, pdevres, dup);				// get dur by scaling back

	lserr = AdjustText(lskjust, durColumnMax, grchunkext.durTotal - grchunkext.durTrailing, 
						dupAvailable, 
						&(grchunkext.lsgrchnk),
						&(grchunkext.posichnkBeforeTrailing), lstflow, 
						fCompress, 						// compress?
						grchunkext.cNonTextObjects,   
						fTrue, 							// fSuppressWiggle
						fTrue,							// fExact
						fFalse,							// fForcedBreak
						fFalse,							// fSuppressTrailingSpaces
						&dupText, &dupTail, &dupToAddToNonTextObjects, &cNonTextObjectsToExtend);   
	if (lserr != lserrNone)
		return lserr;
		
	if (cNonTextObjectsToExtend != 0 && dupToAddToNonTextObjects > 0)
		{
		WidenNonTextObjects(&grchunkext, dupToAddToNonTextObjects, cNonTextObjectsToExtend);
		}

	// fLastOnLine is always false on lower levels

	lserr = CalcPresChunk(plsc, plssubl->plsdnFirst, plssubl->plsdnLastDisplay,
									CollectGroupChunkPurpose, fCompress, lskjust, fFalse);

	plssubl->fDupInvalid = fFalse;
						
	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\qheap.c ===
#include "lsmem.h"
#include "lsidefs.h"
#include "lsc.h"
#include "qheap.h"

/* ---------------------------------------------------------------------- */

struct qheap
{
#ifdef DEBUG
    DWORD tag;
#endif

	BYTE* pbFreeObj;					/* List of free objects in storage */
	BYTE** ppbAdditionalStorageList;		/* List of additional storage (chunk)*/

	POLS pols;
	void* (WINAPI* pfnNewPtr)(POLS, DWORD);
	void  (WINAPI* pfnDisposePtr)(POLS, void*);

    DWORD cbObj;
	DWORD cbObjNoLink;
	DWORD iobjChunk; /* number of elements in chunk */

	BOOL fFlush; /* use flush and don't use destroy */
};

#define tagQHEAP		Tag('Q','H','E','A')
#define FIsQHEAP(p)		FHasTag(p,tagQHEAP)


#define SetNextPb(pb,pbNext)	( (*(BYTE**)(pb)) = (pbNext) )
#define PbGetNext(pbObj)		( *(BYTE**)(pbObj) )

#define PLinkFromClientMemory(pClient)   (BYTE *)	((BYTE**)pClient - 1)
#define ClientMemoryFromPLink(pLink)     (void *)	((BYTE**)pLink   + 1)


#ifdef DEBUG
#define DebugMemset(a,b,c)		if ((a) != NULL) memset(a,b,c); else
#else
#define DebugMemset(a,b,c)		(void)(0)
#endif

/* ---------------------------------------------------------------------- */



/* C R E A T E  Q U I C K  H E A P */
/*----------------------------------------------------------------------------
    %%Function: CreateQuickHeap
    %%Contact: igorzv

    Creates a block of fixed-size objects which can be allocated and
	deallocated with very little overhead.  Once the heap is created,
	allocation of up to the	specified number of objects will not require
	using the application's	callback function.
----------------------------------------------------------------------------*/
PQHEAP CreateQuickHeap(PLSC plsc, DWORD iobjChunk, DWORD cbObj, BOOL fFlush)
{
	DWORD cbStorage;
	PQHEAP pqh;
	BYTE* pbObj;
	BYTE* pbNextObj;
	DWORD iobj;
	DWORD cbObjNoLink = cbObj;
	BYTE** ppbChunk;

	Assert(iobjChunk != 0 && cbObj != 0);

	cbObj += sizeof(BYTE*);
	cbStorage = cbObj * iobjChunk;
	pqh = plsc->lscbk.pfnNewPtr(plsc->pols, sizeof(*pqh));
	if (pqh == NULL)
		return NULL;

	ppbChunk = plsc->lscbk.pfnNewPtr(plsc->pols, sizeof(BYTE*) + cbStorage);
	if (ppbChunk == NULL)
		{
		plsc->lscbk.pfnDisposePtr(plsc->pols, pqh);
		return NULL;
		}
	pbObj = (BYTE*) (ppbChunk + 1);

#ifdef DEBUG
	pqh->tag = tagQHEAP;
#endif

	pqh->pbFreeObj = pbObj;
	pqh->ppbAdditionalStorageList = ppbChunk;
	pqh->pols = plsc->pols;
	pqh->pfnNewPtr = plsc->lscbk.pfnNewPtr;
	pqh->pfnDisposePtr = plsc->lscbk.pfnDisposePtr;
	pqh->cbObj = cbObj;
	pqh->cbObjNoLink = cbObjNoLink;
	pqh->iobjChunk = iobjChunk;
	pqh->fFlush = fFlush;

	/* Loop iobjChunk-1 times to chain the nodes together, then terminate
	 * the chain outside the loop.
	 */
	for (iobj = 1;  iobj < iobjChunk;  iobj++)
		{
		pbNextObj = pbObj + cbObj;
		SetNextPb(pbObj,pbNextObj);
		pbObj = pbNextObj;
		}
	SetNextPb(pbObj,NULL);

	/* terminate chain of chunks */
	*ppbChunk = NULL;
	return pqh;
}


/* D E S T R O Y  Q U I C K  H E A P */
/*----------------------------------------------------------------------------
    %%Function: DestroyQuickHeap
    %%Contact: igorzv

    Destroys one of the blocks of fixed-size objects which was created by
	CreateQuickHeap().
----------------------------------------------------------------------------*/
void DestroyQuickHeap(PQHEAP pqh)
{
	BYTE** ppbChunk;
	BYTE** ppbChunkPrev = NULL;

	if (pqh)
		{

#ifdef DEBUG
		BYTE* pbObj;
		BYTE* pbNext;
		DWORD cbStorage;
		DWORD i;


		Assert(FIsQHEAP(pqh));

		/* check that everything is free */
		/* mark free objects*/
		for (pbObj = pqh->pbFreeObj;  pbObj != NULL;  pbObj = pbNext)
			{
			pbNext = PbGetNext(pbObj);

			DebugMemset(pbObj, 0xe4, pqh->cbObj);
			}

		/* check that all objects are marked */
		ppbChunk = pqh->ppbAdditionalStorageList;
		Assert(ppbChunk != NULL);
		cbStorage = pqh->cbObj * pqh->iobjChunk;
		while (ppbChunk != NULL)
			{
			for (pbObj = (BYTE *)(ppbChunk + 1), i=0; i < cbStorage;  pbObj++, i++)
				{
				AssertSz(*pbObj == 0xe4, "Heap object not freed");
				}
			ppbChunk = (BYTE**) *ppbChunk;
			}
#endif
	   /* free all chunks */
		ppbChunk = pqh->ppbAdditionalStorageList;
		Assert(ppbChunk != NULL);
		while (ppbChunk != NULL)
			{
			ppbChunkPrev = ppbChunk;
			ppbChunk = (BYTE**) *ppbChunk;
			pqh->pfnDisposePtr(pqh->pols, ppbChunkPrev);
			}
		/* free header */
		pqh->pfnDisposePtr(pqh->pols, pqh);
		}
}


/* P V  N E W  Q U I C K  P R O C */
/*----------------------------------------------------------------------------
    %%Function: PvNewQuickProc
    %%Contact: igorzv

    Allocates an object from one of the blocks of fixed-size objects which
	was created by CreateQuickHeap().  If no preallocated objects are
	available, the callback function memory management function will be
	used to attempt to allocate additional memory.

	This function should not be called directly.  Instead, the PvNewQuick()
	macro should be used in order to allow debug code to validate that the
	heap contains objects of the expected size.
----------------------------------------------------------------------------*/
void* PvNewQuickProc(PQHEAP pqh)
{
	BYTE* pbObj;
	BYTE* pbNextObj;
	BYTE** ppbChunk;
	BYTE** ppbChunkPrev = NULL;
	DWORD cbStorage;
	DWORD iobj;
	BYTE* pbObjLast = NULL;


	Assert(FIsQHEAP(pqh));

	if (pqh->pbFreeObj == NULL)
		{
		cbStorage = pqh->cbObj * pqh->iobjChunk;
		ppbChunk = pqh->ppbAdditionalStorageList;
		Assert(ppbChunk != NULL);
		/* find last chunk in the list */
		while (ppbChunk != NULL)
			{
			ppbChunkPrev = ppbChunk;
			ppbChunk = (BYTE**) *ppbChunk;
			}

		/* allocate memory */
		ppbChunk = pqh->pfnNewPtr(pqh->pols, sizeof(BYTE*) + cbStorage);
		if (ppbChunk == NULL)
			return NULL;
		pbObj = (BYTE*) (ppbChunk + 1);
		/* add chunk to the list */
		*ppbChunkPrev = (BYTE *) ppbChunk;

		/* terminate chain of chunks */
		*ppbChunk = NULL;

		/* add new objects to free list */
		pqh->pbFreeObj = pbObj;

		if (pqh->fFlush)  /* to link all objects into  a chain */
			{
			/* find last object in chain */
			pbObjLast = (BYTE*) (ppbChunkPrev + 1);
			pbObjLast += (pqh->iobjChunk - 1) * pqh->cbObj;
			SetNextPb(pbObjLast,pbObj);
			}

		/* Loop iobjChunk-1 times to chain the nodes together, then terminate
		 * the chain outside the loop.
		 */
		for (iobj = 1;  iobj < pqh->iobjChunk;  iobj++)
			{
			pbNextObj = pbObj + pqh->cbObj;
			SetNextPb(pbObj,pbNextObj);
			pbObj = pbNextObj;
			}
		SetNextPb(pbObj,NULL);
		}

	pbObj = pqh->pbFreeObj;
	Assert(pbObj != NULL);
	pqh->pbFreeObj = PbGetNext(pbObj);
	DebugMemset(ClientMemoryFromPLink(pbObj), 0xE8, pqh->cbObjNoLink);

	return ClientMemoryFromPLink(pbObj);		
}


/* D I S P O S E  Q U I C K  P V  P R O C */
/*----------------------------------------------------------------------------
    %%Function: DisposeQuickPvProc
    %%Contact: igorzv

    De-allocates an object which was allocated by PvNewQuickProc().

	This function should not be called directly.  Instead, the PvDisposeQuick
	macro should be used in order to allow debug code to validate that the
	heap contains objects of the expected size.
----------------------------------------------------------------------------*/
void DisposeQuickPvProc(PQHEAP pqh, void* pv)
{
	BYTE* pbObj = PLinkFromClientMemory(pv);

	Assert(FIsQHEAP(pqh));
	Assert(!pqh->fFlush);

	if (pbObj != NULL)
		{
		DebugMemset(pbObj, 0xE9, pqh->cbObjNoLink);

		SetNextPb(pbObj, pqh->pbFreeObj);
		pqh->pbFreeObj = pbObj;
		}
}

/* F L U S H  Q U I C K  H E A P */
/*----------------------------------------------------------------------------
    %%Function: FlushQuickHeap
    %%Contact: igorzv

  For a quck heap with a flush flag, returns all objects to the list of
  free objects.
----------------------------------------------------------------------------*/
void FlushQuickHeap(PQHEAP pqh)
{

	Assert(FIsQHEAP(pqh));
	Assert(pqh->fFlush);

	pqh->pbFreeObj = (BYTE*) (pqh->ppbAdditionalStorageList + 1);


}


#ifdef DEBUG
/* C B  O B J  Q U I C K */
/*----------------------------------------------------------------------------
    %%Function: CbObjQuick
    %%Contact: igorzv

    Returns the size of the objects in this quick heap.  Used by the
	PvNewQuick() and PvDisposeQuick() macros to validate that the
	heap contains objects of the expected size.
----------------------------------------------------------------------------*/
DWORD CbObjQuick(PQHEAP pqh)
{
	Assert(FIsQHEAP(pqh));
	return pqh->cbObjNoLink;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lstxtqry.c ===
#include "lsmem.h"

#include "lstxtqry.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"
#include "lsqin.h"
#include "lsqout.h"

typedef struct celldimensions
{
	long	iwchFirst, iwchLim;
	long	igindFirst, igindLim;
	long	dup;
	long 	dcp;					// number of cps in cell - different from iwchLim - iwchFirst
									// if hyphenation added a character
									// filled just before calling AddHyphenationToCell
} CELL;

typedef CELL* PCELL;


static const POINTUV ptZero = {0,0};


//    %%Function:	GetCellDimensions
//    %%Contact:	victork
//
// Input: 	iwchFirst and igindFirst in CELL structure
// Output:	the rest of the structure

static void GetCellDimensions(PTXTOBJ ptxtobj, PCELL pcell)

{
	PLNOBJ	plnobj = ptxtobj->plnobj;
	long* 	rgdup = plnobj->pdupGind;			// widths of glyphs
	GMAP*	pgmap = plnobj->pgmap;				// first glyph in a cell with given character
												// 0 <= i <= wchMax (wchMax in lnobj)
												// 0 <= pgmap[i] <= "glyphs in a shape" (not igindMax)
	long	i, dupCell;
	GMAP	iShapeGindFirstInCell;				// iShape means index from gmap, not index to rgdup

	// Assert that pcell->iwchFirst is really the cell boundary
	// Notice that ptxtinf (and everything in ilsobj) is not valid in query time)
	
	Assert(pcell->iwchFirst == ptxtobj->iwchFirst || pgmap[pcell->iwchFirst] != pgmap[pcell->iwchFirst-1]);
	
	// Assert that pcell->igindFirst corresponds to pcell->iwchFirst
	
	Assert(ptxtobj->igindFirst + pgmap[pcell->iwchFirst] - pgmap [ptxtobj->iwchFirst] == pcell->igindFirst);

	// find out dimentions of the cell - all characters have the same gmap value
	
	iShapeGindFirstInCell = pgmap[pcell->iwchFirst];

	// "infinite" loop will stop when pcell->iwchLim is found

	Assert(pcell->iwchFirst < ptxtobj->iwchLim);				// ensure loop ends
	
	for (i = pcell->iwchFirst + 1; ; i++)
		{
		if (i == ptxtobj->iwchLim)
			{
			pcell->iwchLim = ptxtobj->iwchLim;
			pcell->igindLim = ptxtobj->igindLim;
			break;
			}
		else if (pgmap[i] != iShapeGindFirstInCell)
			{
			pcell->iwchLim = i;
			pcell->igindLim = pcell->igindFirst + pgmap[i] - iShapeGindFirstInCell;
			break;
			}
		}
	
	for (i = pcell->igindFirst, dupCell = 0; i < pcell->igindLim; i++)
		{
		dupCell += rgdup[i];
		}

	pcell->dup	= dupCell;
	
}

//    %%Function:	AddHyphenationToCell
//    %%Contact:	victork
//
static void	AddHyphenationToCell(PTXTOBJ ptxtobj, PCELL pcell)
{	
	long* 	rgdup;
	long	i;
	long	dwch = ptxtobj->plnobj->dwchYsr - 1;			/* number of chars to add */ 

	if (ptxtobj->txtf&txtfGlyphBased)
		{
		rgdup = ptxtobj->plnobj->pdupGind;
		i = pcell->igindLim;

		while (dwch > 0)
			{
			pcell->dup += rgdup[i];
			pcell->iwchLim ++;
			pcell->igindLim ++;					// there are no ligatures amongst added characters
			dwch--;
			i++;
			}
		}
	else
		{
		rgdup = ptxtobj->plnobj->pdup;
		i = pcell->iwchLim;
		
		while (dwch > 0)
			{
			pcell->dup += rgdup[i];
			pcell->iwchLim ++;
			dwch--;
			i++;
			}
		}

	Assert(pcell->iwchLim == (long) ptxtobj->iwchLim);
}

//    %%Function:	QueryDcpPcell
//    %%Contact:	victork
//
static void QueryDcpPcell(PTXTOBJ ptxtobj, LSDCP dcp, PCELL pcell, long* pupStartCell)
{
	PLNOBJ	plnobj = ptxtobj->plnobj;
	long 	iwchLim = (long) ptxtobj->iwchLim;
	
	long* 	rgdup;
	long 	i;

	CELL	cell = {0,0,0,0,0,0};
	
	long	iwchQuery;
	long	upStartCell;

	BOOL 	fHyphenationPresent = fFalse;

	if (ptxtobj == plnobj->pdobjHyphen)
		{
		fHyphenationPresent = fTrue;
		iwchLim -= (plnobj->dwchYsr - 1);		/* exclude additional Ysr characters */
		}
		
	iwchQuery = ptxtobj->iwchFirst + dcp;

	Assert(iwchQuery < iwchLim);

	if (ptxtobj->txtf&txtfGlyphBased)
		{
		// initialize loop variables to describe non-existent previous cell
		
		upStartCell = 0;
		cell.iwchLim = ptxtobj->iwchFirst;
		cell.igindLim = ptxtobj->igindFirst;
		cell.dup = 0;
		
		// loop does cell after cell until the cell containing iwchQuery is found
		
		while (cell.iwchLim <= iwchQuery)
			{
			// start filling info about current cell
			
			upStartCell += cell.dup;
			cell.iwchFirst = cell.iwchLim;
			cell.igindFirst = cell.igindLim;

			// get the rest
			
			GetCellDimensions(ptxtobj, &cell);
			}
		}
	else
		{
		rgdup = plnobj->pdup;

		i = ptxtobj->iwchFirst;
		upStartCell = 0;

		while (dcp > 0)
			{
			upStartCell += rgdup[i];
			dcp--;
			i++;
			}
			
		Assert(i < iwchLim);								/* I'm given dcp inside */
		
		// put the info into cell structure
		cell.dup = rgdup[i];
		cell.iwchFirst = i;
		cell.iwchLim = i+1;
		
		// these two are irrelevant, but for the sake of convenience...
		cell.igindFirst = i;
		cell.igindLim = i;
		}

	cell.dcp = cell.iwchLim - cell.iwchFirst; 			// hyphenation can change that
	
	// YSR can extend the last cell

	if (fHyphenationPresent && cell.iwchLim == iwchLim)
		{
		// the cell is up to the YSR sequence - let's include it 

		AddHyphenationToCell(ptxtobj, &cell);
		}
			
	*pcell = cell;
	*pupStartCell = upStartCell;
}


//    %%Function:	QueryCpPpointText
//    %%Contact:	victork
//
/*	Input is dcp and dnode dimensions
 *	Output is point where character begins (on baseline of dnode, so v is always zero),
 *	dimensions of the character - only width is calculated 
 */

LSERR WINAPI QueryCpPpointText(PDOBJ pdobj, LSDCP dcp, PCLSQIN plsqin, PLSQOUT plsqout)
{

	PTXTOBJ ptxtobj = (PTXTOBJ)pdobj;
	
	CELL	cell;
	long	upStartCell;

	plsqout->pointUvStartObj = ptZero;
	plsqout->heightsPresObj = plsqin->heightsPresRun;
	plsqout->dupObj = plsqin->dupRun;
	
	plsqout->plssubl = NULL;
	plsqout->pointUvStartSubline = ptZero;
	
	plsqout->lstextcell.pointUvStartCell = ptZero;					// u can be changed later

	if (ptxtobj->txtkind == txtkindTab)
		{
		// A tab is always in a separate dnode and is treated differently
		
		Assert(dcp == 0);
		
		plsqout->lstextcell.cpStartCell = plsqin->cpFirstRun;
		plsqout->lstextcell.cpEndCell = plsqin->cpFirstRun;
		plsqout->lstextcell.dupCell = plsqin->dupRun;
		plsqout->lstextcell.cCharsInCell = 1;
		plsqout->lstextcell.cGlyphsInCell = 0;
		return lserrNone;
		}
		
	if (ptxtobj->iwchFirst == ptxtobj->iwchLim)
		{
		// empty dobj (for NonReqHyphen, OptBreak, or NonBreak characters)
		
		Assert(dcp == 0);
		Assert(plsqin->dupRun == 0);
		
		Assert(ptxtobj->txtkind ==  txtkindNonReqHyphen || ptxtobj->txtkind == txtkindOptBreak || 
				ptxtobj->txtkind == txtkindOptNonBreak);

		plsqout->lstextcell.cpStartCell = plsqin->cpFirstRun;
		plsqout->lstextcell.cpEndCell = plsqin->cpFirstRun;
		plsqout->lstextcell.dupCell = 0;
		plsqout->lstextcell.cCharsInCell = 0;
		plsqout->lstextcell.cGlyphsInCell = 0;
		
		return lserrNone;
		}
		

	// Find the cell - common with QueryTextCellDetails
	
	QueryDcpPcell(ptxtobj, dcp, &cell, &upStartCell);
	
	plsqout->lstextcell.cpStartCell = plsqin->cpFirstRun + cell.iwchFirst - ptxtobj->iwchFirst;
	plsqout->lstextcell.cpEndCell = plsqout->lstextcell.cpStartCell + cell.dcp - 1;
	plsqout->lstextcell.pointUvStartCell.u = upStartCell;
	plsqout->lstextcell.dupCell = cell.dup;
	plsqout->lstextcell.cCharsInCell = cell.iwchLim - cell.iwchFirst;
	plsqout->lstextcell.cGlyphsInCell = cell.igindLim - cell.igindFirst;

	return lserrNone;
}

//    %%Function:	QueryPointPcpText
//    %%Contact:	victork
//
LSERR WINAPI QueryPointPcpText(PDOBJ pdobj, PCPOINTUV pptIn, PCLSQIN plsqin, PLSQOUT plsqout)

{
	PTXTOBJ ptxtobj = (PTXTOBJ)pdobj;
	PLNOBJ	plnobj = ptxtobj->plnobj;
	long 	iwchLim = (long) ptxtobj->iwchLim;
	BOOL 	fHyphenationPresent = fFalse;
	
	long* 	rgdup;
	long 	i;
	long	upQuery, upStartCell, upLimCell;
	
	CELL	cell = {0,0,0,0,0,0};									// init'ed to get rid of assert
	
	plsqout->pointUvStartObj = ptZero;
	plsqout->heightsPresObj = plsqin->heightsPresRun;
	plsqout->dupObj = plsqin->dupRun;
	
	plsqout->plssubl = NULL;
	plsqout->pointUvStartSubline = ptZero;
	
	plsqout->lstextcell.pointUvStartCell = ptZero;					// u can change later
	
	if (ptxtobj->txtkind == txtkindTab)
		{
		// A tab is always in a separate dnode and is treated differently
				
		plsqout->lstextcell.cpStartCell = plsqin->cpFirstRun;
		plsqout->lstextcell.cpEndCell = plsqin->cpFirstRun;
		plsqout->lstextcell.dupCell = plsqin->dupRun;
		plsqout->lstextcell.cCharsInCell = 1;
		plsqout->lstextcell.cGlyphsInCell = 0;
		return lserrNone;
		}

	if (ptxtobj == plnobj->pdobjHyphen)
		{
		fHyphenationPresent = fTrue;
		iwchLim -= (plnobj->dwchYsr - 1);		/* exclude additional Ysr characters */
		}
		
	upQuery = pptIn->u;
	if (upQuery < 0)
		{
		upQuery = 0;									// return leftmost when clicked outside left
		}
		
	upStartCell = 0;

	if (ptxtobj->txtf&txtfGlyphBased)
		{
		// initialize loop variables to describe non-existent previous cell
		
		upLimCell = 0;
		cell.iwchLim = ptxtobj->iwchFirst;
		cell.igindLim = ptxtobj->igindFirst;
		cell.dup = 0;
		
		// loop does cell after cell until the last cell or the cell containing upQuery
		
		while (cell.iwchLim < iwchLim && upLimCell <= upQuery)
			{
			// start filling info about current cell
			
			upStartCell = upLimCell;
			cell.iwchFirst = cell.iwchLim;
			cell.igindFirst = cell.igindLim;

			// get the rest
			
			GetCellDimensions(ptxtobj, &cell);
			
			upLimCell = upStartCell + cell.dup;
			}
		}
	else
		{
		rgdup = plnobj->pdup;

		i = ptxtobj->iwchFirst;
		upLimCell = 0;
		
		while (upLimCell <= upQuery && i < iwchLim)
			{
			upStartCell = upLimCell;
			upLimCell += rgdup[i];
			i++;
			}
			
		// put the info into cell structure
		cell.dup = rgdup[i - 1];
		cell.iwchFirst = i - 1;
		cell.iwchLim = i;
		
		// these two are irrelevant, but for the sake of convenience...
		cell.igindFirst = i - 1;
		cell.igindLim = i - 1;
		}

	cell.dcp = cell.iwchLim - cell.iwchFirst; 			// hyphenation can change that

	// YSR can extend the last cell

	if (fHyphenationPresent && cell.iwchLim == iwchLim)
		{
		// the cell is up to the YSR sequence - let's include it 

		AddHyphenationToCell(ptxtobj, &cell);
		}
			
	plsqout->lstextcell.cpStartCell = plsqin->cpFirstRun + cell.iwchFirst - ptxtobj->iwchFirst;
	plsqout->lstextcell.cpEndCell = plsqout->lstextcell.cpStartCell + cell.dcp - 1;
	plsqout->lstextcell.pointUvStartCell.u = upStartCell;
	plsqout->lstextcell.dupCell = cell.dup;
	plsqout->lstextcell.cCharsInCell = cell.iwchLim - cell.iwchFirst;
	plsqout->lstextcell.cGlyphsInCell = cell.igindLim - cell.igindFirst;

	return lserrNone;
}


//    %%Function:	QueryTextCellDetails
//    %%Contact:	victork
//
LSERR WINAPI QueryTextCellDetails(
						 	PDOBJ 	pdobj,
							LSDCP	dcp,				/* IN: dcpStartCell	*/
							DWORD	cChars,				/* IN: cCharsInCell */
							DWORD	cGlyphs,			/* IN: cGlyphsInCell */
							LPWSTR	pwchOut,			/* OUT: pointer array[cChars] of char codes */
							PGINDEX	pgindex,			/* OUT: pointer array[cGlyphs] of glyph indices */
							long*	pdup,				/* OUT: pointer array[cGlyphs] of glyph widths */
							PGOFFSET pgoffset,			/* OUT: pointer array[cGlyphs] of glyph offsets */
							PGPROP	pgprop)				/* OUT: pointer array[cGlyphs] of glyph handles */
{
	PTXTOBJ ptxtobj = (PTXTOBJ)pdobj;
	PLNOBJ	plnobj = ptxtobj->plnobj;

	CELL	cell;
	long	upDummy;
	
	Unreferenced(cGlyphs);
	Unreferenced(cChars);							// used only in an assert

	if (ptxtobj->txtkind == txtkindTab)
		{
		// Tab is in a separate dnode always and is treated differently
		Assert(dcp == 0);
		Assert(cChars == 1);
		*pwchOut = ptxtobj->u.tab.wch;
		*pdup = (ptxtobj->plnobj->pdup)[ptxtobj->iwchFirst];
		return lserrNone;
		}
		
	if (ptxtobj->iwchFirst == ptxtobj->iwchLim)
		{
		// empty dobj (for NonReqHyphen, OptBreak, or NonBreak characters)
		
		Assert(dcp == 0);
		Assert(cChars == 0);
		Assert(cGlyphs == 0);
		
		return lserrNone;
		}

	// Find the cell - common with QueryCpPpointText
	
	QueryDcpPcell(ptxtobj, dcp, &cell, &upDummy);
	
	Assert(cell.iwchLim - cell.iwchFirst == (long) cChars);

	memcpy(pwchOut, &plnobj->pwch[cell.iwchFirst], sizeof(long) * cChars);

	if (ptxtobj->txtf&txtfGlyphBased)
		{
		Assert(cell.igindLim - cell.igindFirst == (long) cGlyphs);
		
		memcpy(pdup, &plnobj->pdupGind[cell.igindFirst], sizeof(long) * cGlyphs);
		memcpy(pgindex, &plnobj->pgind[cell.igindFirst], sizeof(long) * cGlyphs);
		memcpy(pgoffset, &plnobj->pgoffs[cell.igindFirst], sizeof(long) * cGlyphs);
		memcpy(pgprop, &plnobj->pgprop[cell.igindFirst], sizeof(long) * cGlyphs);
		}
	else
		{
		memcpy(pdup, &plnobj->pdup[cell.iwchFirst], sizeof(long) * cChars);
		}
	
	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\lstxtscl.c ===
#include "lsmem.h"
#include <limits.h>

#include "lstxtscl.h"

#include "lstxtmap.h"
#include "lsdntext.h"
#include "zqfromza.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"

static void ApplyWysiGlyphs(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, long itxtobjStart,
							long durSumStart, long dupSumStart, BOOL fContinueWysiStart,
							long* pitxtobjLim, long* pdurSum, long* pdupSum);
static void CopyRefToPresForScaleCharSides(const LSGRCHNK* plsgrchnk, BOOL* pfLeftSideAffected, BOOL* pfGlyphDetected);
static void CopyRefToPresForScaleGlyphSides(const LSGRCHNK* plsgrchnk);

#define min(a,b)     ((a) > (b) ? (b) : (a))
#define max(a,b)     ((a) < (b) ? (b) : (a))
#define abs(a)     	((a) < 0 ? (-a) : (a))

#define SetMagicConstant() (lstflow & fUVertical) ? \
	(MagicConstant = pilsobj->MagicConstantY, durRightMax = pilsobj->durRightMaxY) : \
	(MagicConstant = pilsobj->MagicConstantX, durRightMax = pilsobj->durRightMaxX)

#define UpFromUrFast(ur)	( ((ur) * MagicConstant + (1 << 20)) >> 21)

#define FAdjustable(ptxtobj) (!((ptxtobj)->txtf & txtfSkipAtWysi)  && \
						((ptxtobj)->iwchLim - (ptxtobj)->iwchFirst > 0))

/* A P P L Y  W Y S I */
/*----------------------------------------------------------------------------
    %%Function: ApplyWysi
    %%Contact: sergeyge

	WYSIWYG algorithm for exact positioning of characters without wiggling
----------------------------------------------------------------------------*/
void ApplyWysi(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow) 
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long* rgdur;
	long* rgdup;
	long iwch;
	long itxtobj;
	long iwchPrev = 0;
	long iwchLim;
	BOOL fContinueWysi;
	BOOL fContinueAveraging;
	long durSum = 0;
	long dupSum = 0;
	long dupErrLast = 0;
	long dupPrevChar = 0;
	long MagicConstant;
	long durRightMax;
	long dupIdeal;
	long dupReal;
	long dupErrNew;
	long dupAdjust;
	long wCarry;

	long itxtobjNew;
	long durSumNew;
	long dupSumNew;

	Assert (plsgrchnk->clsgrchnk > 0);

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	if (pilsobj->fPresEqualRef)
		return;

	SetMagicConstant();

	rgdur = pilsobj->pdur;
	rgdup = plnobj->pdup;

	fContinueWysi = fFalse;
	fContinueAveraging = fFalse;

	itxtobj = 0;

	while(itxtobj < (long)plsgrchnk->clsgrchnk)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;
		Assert(ptxtobj->txtkind != txtkindTab);
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			ApplyWysiGlyphs(plsgrchnk, lstflow, itxtobj, durSum, dupSum, fContinueWysi, 
															&itxtobjNew, &durSumNew, &dupSumNew);
			itxtobj = itxtobjNew;
			durSum = durSumNew;
			dupSum = dupSumNew;
			fContinueAveraging = fFalse;
			fContinueWysi = fTrue;
			}
		else
			{
			if (FAdjustable(ptxtobj))
				{

				fContinueAveraging = fContinueAveraging && !(plsgrchnk->pcont[itxtobj] & fcontNonTextBefore);

				iwch = ptxtobj->iwchFirst;
				iwchLim = ptxtobj->iwchLim;

				while (iwch < iwchLim)
					{
					if (!fContinueAveraging)
						{
						fContinueAveraging = fTrue;
						if (!fContinueWysi)
							{
							fContinueWysi = fTrue;
							durSum = rgdur[iwch];
							if (durSum <= durRightMax)
								{
								dupIdeal = UpFromUrFast(durSum);
								dupErrLast = rgdup[iwch] - dupIdeal;
								rgdup[iwch] = dupIdeal;
								dupPrevChar = dupIdeal;
								iwchPrev = iwch;
								dupSum = dupIdeal;
								Assert(dupSum >= 0);
								}
							else
								{
								rgdup[iwch] = UpFromUr(lstflow, &pilsobj->lsdevres, durSum);
								dupSum = rgdup[iwch];
		/* Nothing else is set here because inside following while loop, first IF 
			will be FALSE and loop will be terminated
		*/
								}
							iwch++;
							}
						else
							{
							durSum += rgdur[iwch];
							if (durSum <= durRightMax)
								{
								dupIdeal = UpFromUrFast(durSum) - dupSum;
								dupErrLast = rgdup[iwch] - dupIdeal;
								rgdup[iwch] = dupIdeal;
								dupPrevChar = dupIdeal;
								iwchPrev = iwch;
								dupSum += dupIdeal;
								Assert(dupSum >= 0);
								iwch++;
								}
							else
								{
								durSum -= rgdur[iwch];
		/* Small triangle. Strictly speaking we could change nothing here
			but it is cleaner to keep invariants in order.
			Nothing else is set here because inside following while loop, first IF will 
			be FALSE and loop will be terminated.
		*/
								}
							}

						}

					while(iwch < iwchLim /* && fContinueWysi --replaced by break*/)
						{
						durSum += rgdur[iwch];
						if (durSum <= durRightMax)
							{
						/* here David Bangs algorithm starts */
							dupIdeal = UpFromUrFast(durSum) - dupSum;
							Assert(dupIdeal >= 0);

							dupReal = rgdup[iwch];
							dupErrNew = dupReal - dupIdeal;
							dupAdjust = dupErrNew - dupErrLast;
							if (dupAdjust != 0)
								{
								wCarry = dupAdjust & 1;

							   	if (dupAdjust > 0)	
			   						{
							   		dupAdjust >>= 1;
	   								if (dupErrLast < -dupErrNew)
										dupAdjust += wCarry;
									dupAdjust = min(dupPrevChar /*-1*/, dupAdjust); 
									}
								else
									{
									dupAdjust >>= 1;
									if (dupErrNew < -dupErrLast)
										dupAdjust += wCarry;
									dupAdjust = max(/*1*/ - dupIdeal, dupAdjust); 
									}
								}
				
							rgdup[iwchPrev] -= dupAdjust;
							dupIdeal += dupAdjust;
							rgdup[iwch] = dupIdeal;
							dupSum += (dupIdeal - dupAdjust);
							dupErrLast = dupReal - dupIdeal;
							iwchPrev = iwch;
							dupPrevChar = dupIdeal;
						/* here David Bangs algorithm stops */
							iwch++;
							}
						else
							{
							fContinueWysi = fFalse;
							fContinueAveraging = fFalse;
							break;
							}
						}


					}

				}

			else
				{
				fContinueAveraging = fFalse;
				}
			itxtobj++;
			}

		}

	return;

}


/* S C A L E  S P A C E S */
/*----------------------------------------------------------------------------
    %%Function: ScaleSpaces
    %%Contact: sergeyge

	Scales down widths of spaces 
----------------------------------------------------------------------------*/
void ScaleSpaces(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, long itxtobjLast, long iwchLast)
{
	PTXTOBJ ptxtobj;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	long* rgdur;
	long* rgdup;
	long* rgwSpaces;
	long iwSpacesLim;
	long iwchLim;
	long itxtobj;
	long MagicConstant;
	long durRightMax;
	long dupSpace;
	long i;

	Assert (plsgrchnk->clsgrchnk > 0);

	plnobj = ((PTXTOBJ)(plsgrchnk->plschnk[0].pdobj))->plnobj;
	pilsobj = plnobj->pilsobj;
	rgdur = pilsobj->pdur;
	rgdup = plnobj->pdup;
	rgwSpaces = pilsobj->pwSpaces;

	Assert(!pilsobj->fPresEqualRef);
	Assert(!pilsobj->fNotSimpleText);

	SetMagicConstant();

	for (itxtobj = 0; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		Assert(!(ptxtobj->txtf & txtfGlyphBased));

		if (ptxtobj->txtkind == txtkindRegular)
			{
			iwSpacesLim = ptxtobj->u.reg.iwSpacesLim;

			iwchLim = iwchLast + 1;
			if (itxtobj < itxtobjLast)
				iwchLim = ptxtobj->iwchLim;

			while (iwSpacesLim > ptxtobj->u.reg.iwSpacesFirst && rgwSpaces[iwSpacesLim-1] >= iwchLim)
				{
				iwSpacesLim--;
				}

			for(i = ptxtobj->u.reg.iwSpacesFirst; i < iwSpacesLim; i++)
				{
				if (rgdur[rgwSpaces[i]] < durRightMax)
					{
					dupSpace = UpFromUrFast(rgdur[rgwSpaces[i]]);
					}
				else
					{
					dupSpace = UpFromUr(lstflow, &pilsobj->lsdevres, rgdur[rgwSpaces[i]]);
					}
				Assert(dupSpace >= 0);
				rgdup[rgwSpaces[i]] = dupSpace;
				}
			}
		}

	return;

}

/* S C A L E  C H A R  S I D E S */
/*----------------------------------------------------------------------------
    %%Function: ScaleCharSides
    %%Contact: sergeyge

	Scales down changes applied to characters
----------------------------------------------------------------------------*/
void ScaleCharSides(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, BOOL* pfLeftSideAffected, BOOL* pfGlyphDetected)
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long* rgdur;
	long* rgdup;
	long* rgdurRight;
	long* rgdurLeft;
	long i;
	long itxtobj;
	long iLim;
	long durTemp = 0;
	long dupTemp = 0;
	long MagicConstant;
	long durRightMax;

	Assert (plsgrchnk->clsgrchnk > 0);

	*pfLeftSideAffected = fFalse;
	*pfGlyphDetected = fFalse;
	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	if (pilsobj->fPresEqualRef)
		{
		CopyRefToPresForScaleCharSides(plsgrchnk, pfLeftSideAffected, pfGlyphDetected);
		return;
		}

	SetMagicConstant();

	for (itxtobj = 0; itxtobj < (long)plsgrchnk->clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		Assert(ptxtobj->txtkind != txtkindTab);
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			*pfGlyphDetected = fTrue;
			}
		else
			{
			if (FAdjustable(ptxtobj))
				{
				rgdur = pilsobj->pdur;
				rgdup = plnobj->pdup;
				rgdurRight = pilsobj->pdurRight;
				rgdurLeft = pilsobj->pdurLeft;

				i = ptxtobj->iwchFirst;
				iLim = ptxtobj->iwchLim;

				while(i < iLim)
					{
					durTemp = rgdurRight[i] + rgdurLeft[i];
					*pfLeftSideAffected = *pfLeftSideAffected || (rgdurLeft[i] != 0);
					if (durTemp != 0)
						{
						if (abs(durTemp) <= durRightMax)
							{
							dupTemp = UpFromUrFast(durTemp);
							}
						else
							{
							dupTemp = UpFromUr(lstflow, &pilsobj->lsdevres, durTemp);
							}
						rgdup[i] += dupTemp;
						}
					i++;
					}

				}
			}
		}

	return;
}

/* S C A L E  G L Y P H  S I D E S */
/*----------------------------------------------------------------------------
    %%Function: ScaleGlyphSides
    %%Contact: sergeyge

	Scales down changes applied to glyphs
----------------------------------------------------------------------------*/
void ScaleGlyphSides(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow)
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long* rgdur;
	long* rgdup;
	long* rgdurRight;
	long i;
	long itxtobj;
	long iLim;
	long durTemp = 0;
	long dupTemp = 0;
	long MagicConstant;
	long durRightMax;

	Assert (plsgrchnk->clsgrchnk > 0);

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	if (pilsobj->fPresEqualRef)
		{
		CopyRefToPresForScaleGlyphSides(plsgrchnk);
		return;
		}

	SetMagicConstant();

	for (itxtobj = 0; itxtobj < (long)plsgrchnk->clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		Assert(ptxtobj->txtkind != txtkindTab);
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			Assert (FAdjustable(ptxtobj));
			rgdur = pilsobj->pdurGind;
			rgdup = plnobj->pdupGind;
			rgdurRight = pilsobj->pduGright;

			i = ptxtobj->igindFirst;
			iLim = ptxtobj->igindLim;

			while(i < iLim)
				{
				durTemp = rgdurRight[i];
				if (durTemp != 0)
					{
					if (abs(durTemp) <= durRightMax)
						{
						dupTemp = UpFromUrFast(durTemp);
						}
					else
						{
						dupTemp = UpFromUr(lstflow, &pilsobj->lsdevres, durTemp);
						}
					rgdup[i] += dupTemp;
					rgdurRight[i] = dupTemp;

					}
				i++;
				}
			}
		}

	return;
}

/* U P D A T E  G L Y P H  O F F S E T S */
/*----------------------------------------------------------------------------
    %%Function: UpdateGlyphOffsets
    %%Contact: sergeyge

	Adjusts offsets of glyphs which are attached to the glyph with changed width
----------------------------------------------------------------------------*/
void UpdateGlyphOffsets(const LSGRCHNK* plsgrchnk)
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long* rgduRight;
	long* rgdup;
	long igind;
	long itxtobj;
	long dupTemp = 0;

	Assert (plsgrchnk->clsgrchnk > 0);

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;


	rgduRight = pilsobj->pduGright;
	rgdup = plnobj->pdupGind;

	for (itxtobj = 0; itxtobj < (long)plsgrchnk->clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		Assert(ptxtobj->txtkind != txtkindTab);
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			igind = ptxtobj->igindFirst;
			while(igind < ptxtobj->igindLim)
				{
				dupTemp = rgduRight[igind];
				if (dupTemp != 0)
					{
					while(!FIgindLastInContext(pilsobj, igind) && rgdup[igind + 1] == 0)
						{
						igind++;
						plnobj->pgoffs[igind].du -= dupTemp;
						}
					}
				
				igind++;
				}
			memset(&rgduRight[ptxtobj->igindFirst], 0, sizeof(long)*(ptxtobj->igindLim - ptxtobj->igindFirst));
			}
		}

}

/* S E T  B E F O R E  J U S T  C O P Y */
/*----------------------------------------------------------------------------
    %%Function: SetBeforeJustCopy
    %%Contact: sergeyge

	Fills pdupBeforeJust output array
----------------------------------------------------------------------------*/
void SetBeforeJustCopy(const LSGRCHNK* plsgrchnk)
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long itxtobj;
	long igindFirst;
	long igindLim;

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	for (itxtobj = 0; itxtobj < (long)plsgrchnk->clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		Assert(ptxtobj->txtkind != txtkindTab);
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			igindFirst = ptxtobj->igindFirst;
			igindLim = ptxtobj->igindLim;
			memcpy(&plnobj->pdupBeforeJust[igindFirst], &plnobj->pdupGind[igindFirst], sizeof(long)*(igindLim - igindFirst));
			}
		}
}


/* S C A L E  E X T  N O N  T E X T */
/*----------------------------------------------------------------------------
    %%Function: ScaleExtNonText
    %%Contact: sergeyge

	Scales down change which is 
	to be applyed by manager to non-text objects
----------------------------------------------------------------------------*/
void ScaleExtNonText(PILSOBJ pilsobj, LSTFLOW lstflow, long durExtNonText, long* pdupExtNonText)
{
	long MagicConstant;
	long durRightMax;

	if (pilsobj->fPresEqualRef)
		*pdupExtNonText = durExtNonText;
	else
		{

		SetMagicConstant();

		*pdupExtNonText = 0;
		Assert(durExtNonText >= 0);
		if (durExtNonText > 0)
			{
			if (durExtNonText <= durRightMax)
				{
				*pdupExtNonText = UpFromUrFast(durExtNonText);
				}
			else
				{
				*pdupExtNonText = UpFromUr(lstflow, &pilsobj->lsdevres, durExtNonText);
				}
			}
		}

	return;
}

/* G E T  D U P  L A S T  C H A R */
/*----------------------------------------------------------------------------
    %%Function: GetDupLastChar
    %%Contact: sergeyge

----------------------------------------------------------------------------*/
void GetDupLastChar(const LSGRCHNK* plsgrchnk, long iwchLast, long* pdupHangingChar)
{
	*pdupHangingChar = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pdup[iwchLast];
}


/* F I L L  D U P  P E N */
/*----------------------------------------------------------------------------
    %%Function: FillDupPen
    %%Contact: sergeyge


	In the case when some characters were changed on the left side,
	prepares array of widths which is used at display time 
----------------------------------------------------------------------------*/
LSERR FillDupPen(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, long itxtobjLast, long iwchLast)
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long* rgdup;
	long* rgdupPen;
	long* rgdurLeft;
	long iwch;
	long iwchLocLim;
	long iwchLim;
	long itxtobj;
	long MagicConstant;
	long durRightMax;
	long durLeft;
	long dupLeft;

	Assert (plsgrchnk->clsgrchnk > 0);

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	if (plnobj->pdupPenAlloc == NULL)
		{
		plnobj->pdupPenAlloc = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->wchMax);
		if (plnobj->pdupPenAlloc == NULL)
			return lserrOutOfMemory;

		memset(plnobj->pdupPenAlloc, 0,  sizeof(long) * pilsobj->wchMax);
		}

	if (plnobj->pdupPen == plnobj->pdup)
		{
		plnobj->pdupPen = plnobj->pdupPenAlloc;
		memcpy(plnobj->pdupPen, plnobj->pdup, sizeof(long) * pilsobj->wchMac);
		}

	rgdurLeft = pilsobj->pdurLeft;
	rgdup = plnobj->pdup;
	rgdupPen = plnobj->pdupPen;

	SetMagicConstant();

	for (itxtobj = 0; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;
		/* Left chopping is impossible for glyph-based runs;
			no additional data structures are introduced for glyphs for
			this case.
		 */
		if (!(ptxtobj->txtf & txtfGlyphBased) )
			{

			Assert(ptxtobj->txtkind != txtkindTab);

			iwch = ptxtobj->iwchFirst;
			iwchLocLim = iwchLast + 1;
			if (itxtobj < itxtobjLast)
				iwchLocLim = ptxtobj->iwchLim;

			Assert(iwchLocLim <= ptxtobj->iwchLim);

			if (iwch < iwchLocLim)
				{
				rgdupPen[iwch] = rgdup[iwch];
				durLeft = rgdurLeft[iwch];
				if (durLeft != 0)
					{
					if (pilsobj->fPresEqualRef)
						dupLeft = durLeft;
					else
						{
						if (abs(durLeft) <= durRightMax)
							{
							dupLeft = UpFromUrFast(durLeft);
							}
						else
							{
							dupLeft = UpFromUr(lstflow, &pilsobj->lsdevres, durLeft);
							}
						}

					ptxtobj->dupBefore = -dupLeft;
					rgdupPen[iwch] -= dupLeft;
					}

				iwch++;
				}


			while (iwch < iwchLocLim)
				{
				rgdupPen[iwch] = rgdup[iwch];
				durLeft = rgdurLeft[iwch];
				if (durLeft != 0)
					{
					if (pilsobj->fPresEqualRef)
						dupLeft = durLeft;
					else
						{
						if (abs(durLeft) <= durRightMax)
							{
							dupLeft = UpFromUrFast(durLeft);
							}
						else
							{
							dupLeft = UpFromUr(lstflow, &pilsobj->lsdevres, durLeft);
							}
						}

					rgdupPen[iwch-1] += dupLeft;
					rgdupPen[iwch] -= dupLeft;
					}

				iwch++;
				}

			iwchLim = ptxtobj->iwchLim;

			Assert(iwch == iwchLocLim);


			for (; iwch < iwchLim; iwch++)
				{
				rgdupPen[iwch] = rgdup[iwch];
				}
			}
		}

	Assert(itxtobj == itxtobjLast + 1);

	for (; itxtobj < (long)plsgrchnk->clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;
		if (!(ptxtobj->txtf & txtfGlyphBased))
			{

			for (iwch = ptxtobj->iwchFirst; iwch < ptxtobj->iwchLim; iwch++)
				{
				rgdupPen[iwch] = rgdup[iwch];
				}
			}
		}

	return lserrNone;
}

/* F I N A L  A D J U S T M E N T  O N  P R E S */
/*----------------------------------------------------------------------------
    %%Function: FinalAdjustmentOnPres
    %%Contact: sergeyge

	Sets dup's to DNODE's
	Implements emergency procedures to fit on presentation device
----------------------------------------------------------------------------*/
LSERR FinalAdjustmentOnPres(const LSGRCHNK* plsgrchnk, long itxtobjLast, long iwchLast,
					long dupAvailable, BOOL fFullyScaled, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
					long* pdupText, long* pdupTail)
{
	LSERR lserr;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	long* rgdup;
	long iFirst;
	long iLim;
	long iMinLim;
	long dupTotal;
	long dupToDistribute;
	long dupAdd;
	long dupChange;
	long itxtobj;
	long i;
	long iTemp;
	long dupToDistributePrev;

	Assert (plsgrchnk->clsgrchnk > 0);
	Assert (itxtobjLast < (long)plsgrchnk->clsgrchnk);
	
	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	plnobj = ptxtobjLast->plnobj;
	pilsobj = plnobj->pilsobj;

	*pdupText = 0;
	*pdupTail = 0;

	for (itxtobj=0; itxtobj < (long)plsgrchnk->clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		dupTotal = 0;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			iFirst = ptxtobj->igindFirst;
			iLim = ptxtobj->igindLim;
			iMinLim = iLim;
			if (itxtobj == itxtobjLast)
				iMinLim = IgindLastFromIwch(ptxtobjLast, iwchLast) + 1;
			else if (itxtobj > itxtobjLast)
				iMinLim = iFirst;
			rgdup = plnobj->pdupGind;
			}
		else
			{
			iFirst = ptxtobj->iwchFirst;
			iLim = ptxtobj->iwchLim;
			iMinLim = iLim;
			if (itxtobj == itxtobjLast)
				iMinLim = iwchLast + 1;
			else if (itxtobj > itxtobjLast)
				iMinLim = iFirst;

			rgdup = plnobj->pdup;
			}

		for (i = iFirst; i < iMinLim; i++)
			{
			dupTotal += rgdup[i];
			}

		Assert(i >= iMinLim);

/* Take care of trailing area, taking into account fSuppressTrailingSpaces bit */
		if (fSuppressTrailingSpaces)
			{
			for (; i < iLim; i++)
				{
				rgdup[i] = 0;
				}
			}
		else
			{
			for (; i < iLim; i++)
				{
				dupTotal += rgdup[i];
				*pdupTail += rgdup[i];
				}
			}

		*pdupText += dupTotal;
		lserr = LsdnSetTextDup(plnobj->pilsobj->plsc, ptxtobj->plsdnUpNode, dupTotal);
		if (lserr != lserrNone) return lserr;
		}

	if (itxtobjLast < 0)
		return lserrNone;

	dupToDistribute = dupAvailable - (*pdupText - *pdupTail);

/* fFinalAdjustNeeded==fTrue, if there were spaces on the line. If there were no spaces,
		justification is not needed
*/
	if ( (!fForcedBreak && dupToDistribute < 0 && -dupToDistribute < *pdupText) ||
		 	(dupToDistribute > 0 && fFullyScaled))
		{

		dupAdd = 0;
		if (dupToDistribute > 0)
			{
			dupAdd  = 1;
			}
		else if (dupToDistribute < 0)
			{
			dupAdd = -1;
			}

		dupToDistributePrev = 0;
		while (dupToDistribute != 0 && dupToDistributePrev != dupToDistribute)
			{

			dupToDistributePrev = dupToDistribute;

			for (itxtobj = itxtobjLast; itxtobj >= 0 && dupToDistribute != 0; itxtobj--)
				{
				ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
				dupChange = 0;
				/* REVIEW sergeyge: iwchLast-1 is used because we want correct alignment for the
							last character. Is it correct?
				*/
				if (ptxtobj->txtf & txtfGlyphBased)
					{
					rgdup = plnobj->pdupGind;

					if (itxtobj == itxtobjLast)
						i = IgindLastFromIwch(ptxtobjLast, iwchLast);
					else
						{ 
						Assert(itxtobj < itxtobjLast);
						i = ptxtobj->igindLim - 1;
						}

					for (; i >= ptxtobj->igindFirst && dupToDistribute != 0; i--)
						{
						if (rgdup[i] > 1)
							{
							rgdup[i] += dupAdd;
							iTemp = i;
							while(!FIgindLastInContext(pilsobj, iTemp) && rgdup[iTemp + 1] == 0)
								{
								iTemp++;
								plnobj->pgoffs[iTemp].du -= dupAdd;
								}

							dupToDistribute -= dupAdd;
							dupChange += dupAdd;
							}
						}
					}
				else
					{
					rgdup = plnobj->pdup;
					i = iwchLast;
					if (itxtobj < itxtobjLast)
						i = ptxtobj->iwchLim - 1;
					for (; i >= ptxtobj->iwchFirst && dupToDistribute != 0; i--)
						{
						if (rgdup[i] > 1)
							{
							rgdup[i] += dupAdd;
							dupToDistribute -= dupAdd;
							dupChange += dupAdd;
							}
						}
					}
			
				lserr = LsdnModifyTextDup(ptxtobj->plnobj->pilsobj->plsc, ptxtobj->plsdnUpNode, dupChange);
				if (lserr != lserrNone) return lserr;

				*pdupText += dupChange;
			
				}
			}


		}

	return lserrNone;
}

/* Internal Procedures Implementation */

/* A P P L Y  W Y S I  G L Y P H S */
/*----------------------------------------------------------------------------
    %%Function: ApplyWysiGlyphs
    %%Contact: sergeyge

	WYSIWYG algorithm for exact positioning of glyphs without wiggling
----------------------------------------------------------------------------*/
static void ApplyWysiGlyphs(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, long itxtobjStart,
							long durSumStart, long dupSumStart, BOOL fContinueWysiStart,
							long* pitxtobjLim, long* pdurSum, long* pdupSum)
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long* rgdur;
	long* rgdup;
	long igind;
	long itxtobj;
	long igindPrev = 0;
	long igindLim;
	BOOL fContinueWysi;
	BOOL fContinueAveraging;
	long durSum;
	long dupSum;
	long dupErrLast = 0;
	long dupPrevChar = 0;
	long MagicConstant;
	long durRightMax;
	long dupIdeal;
	long dupReal;
	long dupErrNew;
	long dupAdjust;
	long wCarry;

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	SetMagicConstant();

	rgdur = pilsobj->pdurGind;
	rgdup = plnobj->pdupGind;

	fContinueAveraging = fFalse;

	durSum = durSumStart;
	dupSum = dupSumStart;
	fContinueWysi = fContinueWysiStart;

	itxtobj = itxtobjStart;

	while(itxtobj < (long)plsgrchnk->clsgrchnk)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;
		Assert(ptxtobj->txtkind != txtkindTab);
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			Assert(FAdjustable(ptxtobj));

			fContinueAveraging = fContinueAveraging && !(plsgrchnk->pcont[itxtobj] & fcontNonTextBefore);

			igind = ptxtobj->igindFirst;
			igindLim = ptxtobj->igindLim;

			while (igind < igindLim)
				{
				if (!fContinueAveraging)
					{
					fContinueAveraging = fTrue;
					if (!fContinueWysi)
						{
						fContinueWysi = fTrue;
						durSum = rgdur[igind];
						if (durSum <= durRightMax)
							{
							dupIdeal = UpFromUrFast(durSum);
							dupErrLast = rgdup[igind] - dupIdeal;
							rgdup[igind] = dupIdeal;
							dupPrevChar = dupIdeal;
							igindPrev = igind;
							dupSum = dupIdeal;
							Assert(dupSum >= 0);
							while(!FIgindLastInContext(pilsobj, igind) && rgdup[igind + 1] == 0)
								{
								igind++;
								plnobj->pgoffs[igind].du += dupErrLast;
								}
							}
						else
							{
							dupIdeal = UpFromUr(lstflow, &pilsobj->lsdevres, durSum);
							dupErrLast = rgdup[igind] - dupIdeal;
							rgdup[igind] = dupIdeal;
							dupSum = dupIdeal;
		/* Nothing else is set here because inside following while loop, first IF 
			will be FALSE and loop will be terminated
		*/
							while(!FIgindLastInContext(pilsobj, igind) && rgdup[igind + 1] == 0)
								{
								igind++;
								plnobj->pgoffs[igind].du += dupErrLast;
								}
							}
						igind++;
						}
					else
						{
						durSum += rgdur[igind];
						if (durSum <= durRightMax)
							{
							dupIdeal = UpFromUrFast(durSum) - dupSum;
							dupErrLast = rgdup[igind] - dupIdeal;
							rgdup[igind] = dupIdeal;
							dupPrevChar = dupIdeal;
							igindPrev = igind;
							dupSum += dupIdeal;
							Assert(dupSum >= 0);
							while(!FIgindLastInContext(pilsobj, igind) && rgdup[igind + 1] == 0)
								{
								igind++;
								plnobj->pgoffs[igind].du += dupErrLast;
								}
							igind++;
							}
						else
							{
							durSum -= rgdur[igind];
		/* Small triangle. Strictly speaking we could change nothing here
			but it is cleaner to keep invariants in order.
			Nothing else is set here because inside following while loop, first IF will 
			be FALSE and loop will be terminated.
		*/
							}
						}
					}

				while(igind < igindLim /* && fContinueWysi --replaced by break*/)
					{
					durSum += rgdur[igind];
					if (durSum <= durRightMax)
						{
					/* here David Bangs algorithm starts */
						dupIdeal = UpFromUrFast(durSum) - dupSum;
						Assert(dupIdeal >= 0);

						dupReal = rgdup[igind];
						dupErrNew = dupReal - dupIdeal;
						dupAdjust = dupErrNew - dupErrLast;
						if (dupAdjust != 0)
							{
							wCarry = dupAdjust & 1;

						   	if (dupAdjust > 0)	
		   						{
						   		dupAdjust >>= 1;
   								if (dupErrLast < -dupErrNew)
									dupAdjust += wCarry;
								dupAdjust = min(dupPrevChar /*-1*/, dupAdjust); 
								}
							else
								{
								dupAdjust >>= 1;
								if (dupErrNew < -dupErrLast)
									dupAdjust += wCarry;
								dupAdjust = max(/*1*/ - dupIdeal, dupAdjust); 
								}
							}
			
						rgdup[igindPrev] -= dupAdjust;
						while(!FIgindLastInContext(pilsobj, igindPrev) && rgdup[igindPrev + 1] == 0)
							{
							igindPrev++;
							plnobj->pgoffs[igindPrev].du += dupAdjust;
							}
						dupIdeal += dupAdjust;
						rgdup[igind] = dupIdeal;
						dupSum += (dupIdeal - dupAdjust);
						dupErrLast = dupReal - dupIdeal;
						igindPrev = igind;
						while(!FIgindLastInContext(pilsobj, igind) && rgdup[igind + 1] == 0)
							{
							igind++;
							plnobj->pgoffs[igind].du += dupErrLast;
							}
						dupPrevChar = dupIdeal;
						/* here David Bangs algorithm stops */
						igind++;
						}
					else
						{
						fContinueWysi = fFalse;
						fContinueAveraging = fFalse;
						break;
						}
					}

				}

			itxtobj++;

			}
		else
			{
			break;
			}
		}

	*pitxtobjLim = itxtobj;
	*pdurSum = durSum;
	*pdupSum = dupSum;	

	return;

}

/* C O P Y  R E F  T O  P R E S  F O R  S C A L E  C H A R  S I D E S */
/*----------------------------------------------------------------------------
    %%Function: CopyRefToPresForScaleCharSides
    %%Contact: sergeyge

----------------------------------------------------------------------------*/
static void CopyRefToPresForScaleCharSides(const LSGRCHNK* plsgrchnk, BOOL* pfLeftSideAffected, BOOL* pfGlyphDetected)
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long itxtobj;
	long iFirst;
	long iLim;
	long i;

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	*pfLeftSideAffected = fFalse;
	*pfGlyphDetected = fFalse;

	for (itxtobj = 0; itxtobj < (long)plsgrchnk->clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		Assert(ptxtobj->txtkind != txtkindTab);
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			Assert (FAdjustable(ptxtobj));
			*pfGlyphDetected = fTrue;
			}
		else
			{
			if(FAdjustable(ptxtobj))
				{
				iFirst = ptxtobj->iwchFirst;
				iLim = ptxtobj->iwchLim;
				memcpy(&plnobj->pdup[iFirst], &pilsobj->pdur[iFirst], sizeof(long)*(iLim - iFirst));
				for (i = iFirst; i < iLim && !*pfLeftSideAffected; i++)
					{
					*pfLeftSideAffected = (pilsobj->pdurLeft[i] != 0);
					}
				}
			}
		}
}

/* C O P Y  R E F  T O  P R E S  F O R  S C A L E  G L Y P H  S I D E S */
/*----------------------------------------------------------------------------
    %%Function: CopyRefToPresForScaleGlyphSides
    %%Contact: sergeyge

----------------------------------------------------------------------------*/
static void CopyRefToPresForScaleGlyphSides(const LSGRCHNK* plsgrchnk)
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long itxtobj;
	long iFirst;
	long iLim;

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;


	for (itxtobj = 0; itxtobj < (long)plsgrchnk->clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		Assert(ptxtobj->txtkind != txtkindTab);
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			Assert (FAdjustable(ptxtobj));
			iFirst = ptxtobj->igindFirst;
			iLim = ptxtobj->igindLim;
			memcpy(&plnobj->pdupGind[iFirst], &pilsobj->pdurGind[iFirst], sizeof(long)*(iLim - iFirst));
			}
		}
}


#ifdef FUTURE

/* NOT USED IN LS 3.0 */

/* A P P L Y  N O N  E X A C T  W Y S I */
/*----------------------------------------------------------------------------
    %%Function: ApplyNonExactWysi
    %%Contact: sergeyge

	Alternative WYSIWYG algorithm of characters without wiggling
	sacrifices exact positioning somewhat in attempt to improve
	character spacing
----------------------------------------------------------------------------*/

#define dupBigError 2

void ApplyNonExactWysi(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow) 
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long* rgdur;
	long* rgdup;
	WCHAR* rgwch;
	long iwch;
	long itxtobj;
	long iwchPrev = 0;
	long iwchLim;
	BOOL fContinueWysi;
	BOOL fContinueAveraging;
	long durSum = 0;
	long dupSum = 0;
	long dupErrLast = 0;
	long MagicConstant;
	long durRightMax;
	long dupIdeal;
	long dupAdjust;
	BOOL fInSpaces;

	Assert (plsgrchnk->clsgrchnk > 0);

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	if (pilsobj->fPresEqualRef)
		return;

	SetMagicConstant();

	rgdur = pilsobj->pdur;
	rgdup = plnobj->pdup;
	rgwch = pilsobj->pwchOrig;

	fContinueWysi = fFalse;
	fContinueAveraging = fFalse;

	itxtobj = 0;

	while(itxtobj < (long)plsgrchnk->clsgrchnk)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;
		Assert(ptxtobj->txtkind != txtkindTab);
		Assert(!(ptxtobj->txtf & txtfGlyphBased));
		if (FAdjustable(ptxtobj))
			{
			fInSpaces = ptxtobj->txtkind == txtkindSpecSpace || ptxtobj->txtkind == txtkindNonBreakSpace;

			fContinueAveraging = fContinueAveraging && !(plsgrchnk->pcont[itxtobj] & fcontNonTextBefore);

			iwch = ptxtobj->iwchFirst;
			iwchLim = ptxtobj->iwchLim;

			while (iwch < iwchLim)
				{
				if (!fContinueAveraging)
					{
					fContinueAveraging = fTrue;
					if (!fContinueWysi)
						{
						fContinueWysi = fTrue;
						durSum = rgdur[iwch];
						if (durSum <= durRightMax)
							{
							dupIdeal = UpFromUrFast(durSum);
							if (dupIdeal < 0)
								dupIdeal = 0;							

							dupErrLast = rgdup[iwch] - dupIdeal;
	
							iwchPrev = iwch;
							if (dupErrLast > dupBigError && rgdup[iwch] > 0)
								{
								rgdup[iwch]--;
								}
							else if (dupErrLast < -dupBigError)
								{
								rgdup[iwch]++;
								}

							dupSum = rgdup[iwch];
							Assert(dupSum >= 0);
							}
						else
							{
							rgdup[iwch] = UpFromUr(lstflow, &pilsobj->lsdevres, durSum);
							dupSum = rgdup[iwch];
	/* Nothing else is set here because inside following while loop, first IF 
		will be FALSE and loop will be terminated
	*/
							}
						iwch++;
						}
					else
						{
						durSum += rgdur[iwch];
						if (durSum <= durRightMax)
							{
							dupIdeal = UpFromUrFast(durSum) - dupSum;
							dupErrLast = rgdup[iwch] - dupIdeal;

							iwchPrev = iwch;

							if (dupErrLast > dupBigError && rgdup[iwch] > 0)
								{
								rgdup[iwch]--;
								}
							else if (dupErrLast < -dupBigError)
								{
								rgdup[iwch]++;
								}

							dupSum += rgdup[iwch];

							iwch++;
							}
						else
							{
							durSum -= rgdur[iwch];
	/* Small triangle. Strictly speaking we could change nothing here
		but it is cleaner to keep invariants in order.
		Nothing else is set here because inside following while loop, first IF will 
		be FALSE and loop will be terminated.
	*/
							}
						}

					}

				while(iwch < iwchLim /* && fContinueWysi --replaced by break*/)
					{
					durSum += rgdur[iwch];
					if (durSum <= durRightMax)
						{
					/* here modified David Bangs algorithm starts */
						dupIdeal = UpFromUrFast(durSum) - dupSum;
						Assert(dupIdeal >= 0);

						dupErrLast = rgdup[iwch] - dupIdeal;

						if (dupErrLast != 0  &&  (rgwch[iwch] == pilsobj->wchSpace || fInSpaces))
							{
							if (dupErrLast > 0)
								{
								dupAdjust = min(rgdup[iwch] >> 1, dupErrLast);
								rgdup[iwch] -= dupAdjust;
								}
							else
								{
								Assert(dupErrLast < 0);
								rgdup[iwch] -= dupErrLast;
								}
							}
						else if (dupErrLast > dupBigError)
							{
							dupAdjust = (dupErrLast - 1) >> 1;

							rgdup[iwchPrev] -= dupAdjust;
							dupSum -= dupAdjust;
							rgdup[iwch] -= dupAdjust;
							}
						else if (dupErrLast < -dupBigError)
							{
							dupAdjust = -((-dupErrLast - 1) >> 1);

							rgdup[iwchPrev] -= dupAdjust;
							dupSum -= dupAdjust;
							rgdup[iwch] -= dupAdjust;
							}

						dupSum += rgdup[iwch];
						iwchPrev = iwch;
					/* here modified David Bangs algorithm stops */
						iwch++;
						}
					else
						{
						fContinueWysi = fFalse;
						fContinueAveraging = fFalse;
						break;
						}
					}


				}

			}

		else
			{
			fContinueAveraging = fFalse;
			}
		itxtobj++;

		}

	return;
}

#endif   /* FUTURE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\objhelp.c ===
#include	"lsidefs.h"
#include	"lsmem.h"
#include	"limits.h"
#include	"objhelp.h"
#include	"lscrsubl.h"
#include	"lssubset.h"
#include	"lsdnset.h"
#include	"lstfset.h"
#include	"lsdocinf.h"
#include	"fmti.h"
#include	"lsqout.h"
#include	"lsqin.h"
#include	"mwcls.h"
#include	"brkkind.h"
#include	"brko.h"


/* G E T  B R E A K  R E C O R D  I N D E X */
/*----------------------------------------------------------------------------
	%%Function: GetBreakRecordIndex
	%%Contact: antons

		Index of the break record from brkkind. Assert if 
		brrkkind = brkkindImposedAfter.
	
----------------------------------------------------------------------------*/

DWORD GetBreakRecordIndex (BRKKIND brkkind)
{
	DWORD result = 0;
	
	Assert (brkkind != brkkindImposedAfter);
	Assert (NBreaksToSave == 3);

	switch (brkkind)
		{
		case brkkindPrev:  result = 0; break;
		case brkkindNext:  result = 1; break;
		case brkkindForce: result = 2; break;

		case brkkindImposedAfter: break;

		default: AssertSz (FALSE, "Unknown brkkind");
		};

	Assert (result < NBreaksToSave);
	
	return result;		
}

/* F O R M A T L I N E */
/*----------------------------------------------------------------------------
	%%Function: FormatLine
	%%Contact: antons

		Formats a line of text with the given escape characters ignoring
		all tabs, eops, etc.
	
----------------------------------------------------------------------------*/
LSERR FormatLine(
	PLSC plsc,
	LSCP cpStart,
	long durColMax,
	LSTFLOW lstflow,
	PLSSUBL *pplssubl,
	DWORD cdwlsesc,
	const LSESC *plsesc,
	OBJDIM *pobjdim,
	LSCP *pcpOut,
	PLSDNODE *pplsdnStart,
	PLSDNODE *pplsdnEnd,
	FMTRES *pfmtres)
{
	return FormatResumedLine ( plsc,					
							   cpStart,
							   durColMax,
							   lstflow,
							   pplssubl,
							   cdwlsesc,
							   plsesc,
							   pobjdim,
							   pcpOut,
							   pplsdnStart,
							   pplsdnEnd,
							   pfmtres,
							   NULL,		/* Array of break records */
							   0 );			/* Number of break record */



}

/* F O R M A T R E S U M E D L I N E */
/*----------------------------------------------------------------------------
	%%Function: FormatResumedLine
	%%Contact: ricksa

		Formats a line that contains broken objects at its beginning.
	
----------------------------------------------------------------------------*/
LSERR FormatResumedLine(
	PLSC plsc,					
	LSCP cpStart,
	long durColMax,
	LSTFLOW lstflow,
	PLSSUBL *pplssubl,
	DWORD cdwlsesc,
	const LSESC *plsesc,
	POBJDIM pobjdim,
	LSCP *pcpOut,
	PLSDNODE *pplsdnStart,
	PLSDNODE *pplsdnEnd,
	FMTRES *pfmtres,
	const BREAKREC *pbreakrec,
	DWORD cbreakrec)
{
	LSERR lserr;
	PLSDNODE plsdnStart;
	PLSDNODE plsdnEnd;
	LSCP cpOut;
	FMTRES fmtres;
	PLSSUBL plssubl = NULL;
	BOOL fSuccessful = FALSE;
	LSTFLOW lstflowUnused;

	*pplssubl = NULL; /* In case of lserr */

	while (! fSuccessful)
		{
		lserr = LsCreateSubline(plsc, cpStart, durColMax, lstflow, FALSE);

		if (lserr != lserrNone) return lserr;

		lserr = LsFetchAppendToCurrentSublineResume(plsc, pbreakrec, cbreakrec, 
					0, plsesc, cdwlsesc, &fSuccessful, &fmtres, &cpOut, &plsdnStart, &plsdnEnd);

		if (lserr != lserrNone) return lserr;

		/* REVIEW (antons): fmtrStopped is not handled */
		Assert (fmtres == fmtrCompletedRun || fmtres == fmtrExceededMargin || fmtres == fmtrTab);

		if (pplsdnStart != NULL) *pplsdnStart = plsdnStart;

		while (fSuccessful && (fmtres == fmtrTab))
			{
			/* Format as much as we can - note we move max to maximum postive value. */
			lserr = LsFetchAppendToCurrentSubline(plsc, 0,  plsesc, cdwlsesc, 
							&fSuccessful, &fmtres, &cpOut, &plsdnStart, &plsdnEnd);

			if (lserr != lserrNone) return lserr;

			/* REVIEW (antons): fmtrStopped is not handled */
			Assert (fmtres == fmtrCompletedRun || fmtres == fmtrExceededMargin || fmtres == fmtrTab);
			}

		if (! fSuccessful)
			{
			/* FetchAppend UnSuccessful => Finish and Destroy subline, then repeat */

			lserr = LsFinishCurrentSubline(plsc, &plssubl);
			if (lserr != lserrNone) return lserr;

			lserr = LsDestroySubline(plssubl);
			if (lserr != lserrNone) return lserr;
			}
		else
			{
			if (pplsdnEnd != NULL) *pplsdnEnd = plsdnEnd;

			*pcpOut = cpOut;
			*pfmtres = fmtres;
			};

		}; /* while (! fSuccessful) */


	lserr = LsFinishCurrentSubline(plsc, &plssubl);

	if (lserrNone != lserr) return lserr;

	lserr = LssbGetObjDimSubline(plssubl, &lstflowUnused, pobjdim);

	if (lserr != lserrNone) 
		{
		LsDestroySubline(plssubl);
		return lserr;
		}

	*pplssubl = plssubl;

	return lserrNone;
}

/* C R E A T E Q U E R Y R E S U L T */
/*----------------------------------------------------------------------------
	%%Function: CreateQueryResult
	%%Contact: ricksa

		Common routine to fill in query output record for Query methods.

		.
----------------------------------------------------------------------------*/
LSERR CreateQueryResult(
	PLSSUBL plssubl,			/*(IN): subline of ruby */
	long dupAdj,				/*(IN): u offset of start of subline */
	long dvpAdj,				/*(IN): v offset of start of subline */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	ZeroMemory(plsqout, sizeof(LSQOUT));
	plsqout->heightsPresObj = plsqin->heightsPresRun;
	plsqout->dupObj = plsqin->dupRun;
	ZeroMemory(&plsqout->lstextcell, sizeof(plsqout->lstextcell));
	plsqout->plssubl = plssubl;
	plsqout->pointUvStartSubline.u += dupAdj;
	plsqout->pointUvStartSubline.v += dvpAdj;
	return lserrNone;
}

/* O B J H E L P F M T R E S U M E */
/*----------------------------------------------------------------------------
	%%Function: ObjHelpFmtResume
	%%Contact: ricksa

		This is a helper that is used by objects that don't support
		the resuming of formatting.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ObjHelpFmtResume(
	PLNOBJ plnobj,				/* (IN): object lnobj */
	const BREAKREC *rgBreakRecord,	/* (IN): array of break records */
	DWORD nBreakRecord,			/* (IN): size of the break records array */
	PCFMTIN pcfmtin,			/* (IN): formatting input */
	FMTRES *pfmtres)			/* (OUT): formatting result */
{
	Unreferenced(plnobj);
	Unreferenced(rgBreakRecord);
	Unreferenced(nBreakRecord);
	Unreferenced(pcfmtin);
	Unreferenced(pfmtres);

	return lserrInvalidBreakRecord;
}

/* O B J H E L P G E T M O D W I D T H C H A R */
/*----------------------------------------------------------------------------
	%%Function: ObjHelpGetModWidthChar
	%%Contact: ricksa

		Implementation of LSIMETHOD for objects that do nothing for mod width.
		Tatenakayoko and Hih are examples of this kind of object.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ObjHelpGetModWidthChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the preceding char */
	PCHEIGHTS pcheightsRef,		/* (IN): height info about character */
	WCHAR wchar,				/* (IN): preceding character */
	MWCLS mwcls,				/* (IN): ModWidth class of preceding character */
	long *pdurChange)			/* (OUT): amount by which width of the preceding char is to be changed */
{
	Unreferenced(pdobj);
	Unreferenced(plsrun);
	Unreferenced(plsrunText);
	Unreferenced(pcheightsRef);
	Unreferenced(wchar);
	Unreferenced(mwcls);
	*pdurChange = 0;
	return lserrNone;
}


/* O B J H E L P S E T B R E A K */
/*----------------------------------------------------------------------------
	%%Function: ObjHelpSetBreak
	%%Contact: ricksa

		SetBreak

		Implementation of LSIMETHOD for objects that do nothing for SetBreak.
		Tatenakayoko and Hih are examples of this kind of object.

----------------------------------------------------------------------------*/
LSERR WINAPI ObjHelpSetBreak(
	PDOBJ pdobj,				/* (IN): dobj which is broken */
	BRKKIND brkkind,			/* (IN): Previous / Next / Force / Imposed was chosen */
	DWORD cBreakRecord,			/* (IN): size of array */
	BREAKREC *rgBreakRecord,	/* (IN): array of break records */
	DWORD *pcActualBreakRecord)	/* (IN): actual number of used elements in array */
{
	Unreferenced(pdobj);
	Unreferenced(brkkind);
	Unreferenced(rgBreakRecord);
	Unreferenced(cBreakRecord);

	*pcActualBreakRecord = 0;

	return lserrNone;
}

/* ObjHelpFExpandWithPrecedingChar */
/*----------------------------------------------------------------------------
	%%Function: ObjHelpFExpandWithPrecedingChar
	%%Contact: ricksa

		Default implementation of LSIMETHOD for objects that do not
		allow expanding the previous character.

----------------------------------------------------------------------------*/
LSERR WINAPI ObjHelpFExpandWithPrecedingChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the preceding char */
	WCHAR wchar,				/* (IN): preceding character */
	MWCLS mwcls,				/* (IN): ModWidth class of preceding character*/ 
	BOOL *pfExpand)				/* (OUT): (OUT): expand preceding character? */
{
	Unreferenced(pdobj);
	Unreferenced(plsrun);
	Unreferenced(plsrunText);
	Unreferenced(wchar);
	Unreferenced(mwcls);

	*pfExpand = fTrue;
	return lserrNone;
}

/* ObjHelpFExpandWithFollowingChar */
/*----------------------------------------------------------------------------
	%%Function: ObjHelpFExpandWithFollowingChar
	%%Contact: ricksa

		Default implementation of LSIMETHOD for objects that do not
		allow expanding themselves.

----------------------------------------------------------------------------*/
LSERR WINAPI ObjHelpFExpandWithFollowingChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the following char */
	WCHAR wchar,				/* (IN): following character */
	MWCLS mwcls,				/* (IN): ModWidth class of following character*/ 
	BOOL *pfExpand)				/* (OUT): expand object? */
{
	Unreferenced(pdobj);
	Unreferenced(plsrun);
	Unreferenced(plsrunText);
	Unreferenced(wchar);
	Unreferenced(mwcls);

	*pfExpand = fTrue;
	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\sublutil.c ===
#include "lsidefs.h"
#include "sublutil.h"
#include "dnutils.h"
#include "lssubl.h"
#include "lsdnode.h"
#include "dninfo.h"
#include "lsimeth.h"
#include "iobj.h"
#include "lsmem.h"
#include "chnutils.h"
#include "posichnk.h"
#include "getfmtst.h"
#include "lstext.h"

#ifdef DEBUG
#define DebugMemset(a,b,c)		if ((a) != NULL) memset(a,b,c); else
#else
#define DebugMemset(a,b,c)		(void)(0)
#endif



LSERR GetSpecialEffectsSublineCore(PLSSUBL plssubl,PLSIOBJCONTEXT plsiobjcontext,
								   UINT* pfEffectsFlags)
{
	PLSDNODE plsdn;
	PLSDNODE plsdnPrev;
	UINT fEffectsFlagsObject;
	DWORD iobj;
	LSERR lserr;
	LSIMETHODS* plsim;


	Assert(FIsLSSUBL(plssubl));


	*pfEffectsFlags = 0;

	plsdn = plssubl->plsdnFirst;
	plsdnPrev = NULL;

	while(plsdnPrev != plssubl->plsdnLast)
		{
		if (FIsDnodeReal(plsdn))
			{
			*pfEffectsFlags |= plsdn->u.real.lschp.EffectsFlags;
			iobj = IdObjFromDnode(plsdn);
			if (iobj != IobjTextFromLsc(plsiobjcontext) && !FIsDnodeSplat(plsdn))
				{
				plsim = PLsimFromLsc(plsiobjcontext, iobj);
				if (plsim->pfnGetSpecialEffectsInside != NULL)
					{
					lserr = plsim->pfnGetSpecialEffectsInside(plsdn->u.real.pdobj,
						&fEffectsFlagsObject);
					
					if (lserr != lserrNone)
						return lserr;
					*pfEffectsFlags |= fEffectsFlagsObject;
					}
				}
			}
		plsdnPrev = plsdn;
		plsdn = plsdn->plsdnNext;
		}
	
	return lserrNone;
}


LSERR	GetObjDimSublineCore(
							 PLSSUBL plssubl,			/* IN: subline			*/
							 POBJDIM pobjdim)			/* OUT: dimension of subline */
	{
		PLSDNODE plsdnFirst = plssubl->plsdnFirst;
		PLSDNODE plsdnLast = plssubl->plsdnLast;
		
		/* skip autonumber for the main subline  */
		if (FIsSubLineMain(plssubl))
			{
			while (plsdnFirst != NULL && plsdnFirst->cpFirst < 0)
				{
				plsdnFirst = plsdnFirst->plsdnNext;
				}
			/* because of splat right after autonumber plsdnFirst can be NULL */
			if (plsdnFirst == NULL) 
				plsdnLast = NULL;
			}

		return FindListDims(plsdnFirst, plsdnLast, pobjdim);
	}

LSERR  GetDupSublineCore(
							PLSSUBL plssubl,			/* IN: Subline Context			*/
					 	    long* pdup)					/* OUT: dup of subline			*/
	{
	   FindListDup(plssubl->plsdnFirst, plssubl->cpLim, pdup);
	   return lserrNone;
	}



LSERR 	FIsSublineEmpty(
						PLSSUBL plssubl,		/* IN: subline						*/
						 BOOL*  pfEmpty)		/* OUT:is this subline empty */
	{
	PLSDNODE plsdnLast;
	Assert(FIsLSSUBL(plssubl));
	Assert((plssubl->plsdnFirst == NULL) == (plssubl->plsdnLast == NULL));

	plsdnLast = plssubl->plsdnLast;

	if (FIsSubLineMain(plssubl))
		{
		if (plsdnLast != NULL && FIsDnodeSplat(plsdnLast))
			{
			plsdnLast = plsdnLast->plsdnPrev;
			}
		*pfEmpty = (plsdnLast == NULL || FIsNotInContent(plsdnLast));
		}
	else
		{
		*pfEmpty = (plsdnLast == NULL );
		}

	return lserrNone;
	}


LSERR	DestroySublineCore(PLSSUBL plssubl,LSCBK* plscbk, POLS pols,
						   PLSIOBJCONTEXT plsiobjcontext, BOOL fDontReleaseRuns)/* IN: subline to destroy   */
	{
	LSERR lserr;
	
	Assert(FIsLSSUBL(plssubl));

	lserr = DestroyDnodeList(plscbk, pols, plsiobjcontext,
					   plssubl->plsdnFirst, fDontReleaseRuns);
	if (lserr != lserrNone)
		return lserr;

	/* destroy chunk context */	
	DestroyChunkContext(plssubl->plschunkcontext);

	/* destroy break context */
	Assert(plssubl->pbrkcontext != NULL);  /* we don't expect main subline to be called */
	DebugMemset(plssubl->pbrkcontext, 0xE9, sizeof(BRKCONTEXT));
	plscbk->pfnDisposePtr(pols, plssubl->pbrkcontext);

	plssubl->tag = tagInvalid;
	DebugMemset(plssubl, 0xE9, sizeof(LSSUBL));
	plscbk->pfnDisposePtr(pols, plssubl);

	return lserrNone;

	}

BOOL   FAreTabsPensInSubline(
						   PLSSUBL plssubl)				/* IN: subline */
	{
	PLSDNODE plsdn;
	PLSDNODE plsdnPrev;
	BOOL fAreTabsPensInSubline;

	Assert(FIsLSSUBL(plssubl));

	fAreTabsPensInSubline = fFalse;

	plsdn = plssubl->plsdnFirst;
	plsdnPrev = NULL;

	while(plsdnPrev != plssubl->plsdnLast)
		{
		if (FIsDnodePen(plsdn) || plsdn->fTab)
			{
			fAreTabsPensInSubline = fTrue;
			break;
			}
		plsdnPrev = plsdn;
		plsdn = plsdn->plsdnNext;
		}
	
	return fAreTabsPensInSubline;
}



LSERR	GetPlsrunFromSublineCore(
							    PLSSUBL	plssubl,		/* IN: subline */
								DWORD   crgPlsrun,		/* IN: size of array */
								PLSRUN* rgPlsrun)		/* OUT: array of plsruns */
	{
	DWORD i = 0;
	PLSDNODE plsdn;
	PLSDNODE plsdnPrev;

	Assert(FIsLSSUBL(plssubl));


	plsdn = plssubl->plsdnFirst;
	plsdnPrev = NULL;

	while(plsdnPrev != plssubl->plsdnLast && i < crgPlsrun)
		{
		if (FIsDnodeReal(plsdn))
			{
			rgPlsrun[i] = plsdn->u.real.plsrun;
			}
		else  /* pen */
			{
			rgPlsrun[i] = NULL;
			}
		plsdnPrev = plsdn;
		plsdn = plsdn->plsdnNext;
		i++;
		}

	return lserrNone;

	}

LSERR	GetNumberDnodesCore(
							PLSSUBL	plssubl,	/* IN: subline */
							DWORD* cDnodes)	/* OUT: numberof dnodes in subline */
	{
	PLSDNODE plsdn;
	PLSDNODE plsdnPrev;

	Assert(FIsLSSUBL(plssubl));

	*cDnodes = 0;
	plsdn = plssubl->plsdnFirst;
	plsdnPrev = NULL;

	while(plsdnPrev != plssubl->plsdnLast)
		{
		(*cDnodes)++;
		plsdnPrev = plsdn;
		plsdn = plsdn->plsdnNext;
		}

	return lserrNone;

	}

LSERR 	GetVisibleDcpInSublineCore(
								   PLSSUBL plssubl,	 /* IN: subline						*/
								   LSDCP*  pndcp)	 /* OUT:amount of visible characters in subline */
	{
	PLSDNODE plsdn;
	PLSDNODE plsdnPrev;

	Assert(FIsLSSUBL(plssubl));

	*pndcp = 0;
	plsdn = plssubl->plsdnFirst;
	plsdnPrev = NULL;

	while(plsdnPrev != plssubl->plsdnLast)
		{
		if (FIsDnodeReal(plsdn))
			{
			*pndcp += plsdn->dcp;
			}

		plsdnPrev = plsdn;
		plsdn = plsdn->plsdnNext;
		}

	return lserrNone;

	}

LSERR GetDurTrailInSubline(
						   PLSSUBL plssubl,			/* IN: Subline Context			*/
													long* pdurTrail)				/* OUT: width of trailing area
													in subline		*/
	{
	LSERR lserr;
	PLSCHUNKCONTEXT plschunkcontext;
	PLSDNODE plsdn;
	LSDCP dcpTrail;
	PLSDNODE plsdnStartTrail;
	LSDCP dcpStartTrailingText;
	int cDnodesTrailing;
	PLSDNODE plsdnTrailingObject;
	LSDCP dcpTrailingObject;
	BOOL fClosingBorderStartsTrailing;

	*pdurTrail = 0;
	
	plsdn = GetCurrentDnodeSubl(plssubl);
	plschunkcontext = PlschunkcontextFromSubline(plssubl);
	
	
	if (plsdn != NULL)
		{
		lserr = GetTrailingInfoForTextGroupChunk(plsdn, 
				plsdn->dcp, IobjTextFromLsc(plschunkcontext->plsiobjcontext),
				pdurTrail, &dcpTrail, &plsdnStartTrail,
				&dcpStartTrailingText, &cDnodesTrailing, 
				&plsdnTrailingObject, &dcpTrailingObject, &fClosingBorderStartsTrailing);
	
		if (lserr != lserrNone) 
			return lserr;
		}
	
	return lserrNone;
	}

LSERR GetDurTrailWithPensInSubline(
						   PLSSUBL plssubl,			/* IN: Subline Context			*/
													long* pdurTrail)				/* OUT: width of trailing area
													in subline		*/
	{
	LSERR lserr;
	PLSCHUNKCONTEXT plschunkcontext;
	PLSDNODE plsdn;
	LSDCP dcpTrail;
	PLSDNODE plsdnStartTrail;
	LSDCP dcpStartTrailingText;
	int cDnodesTrailing;
	PLSDNODE plsdnTrailingObject;
	LSDCP dcpTrailingObject;
	BOOL fClosingBorderStartsTrailing;
	long durTrailLoc;
	BOOL fContinue = fTrue;

	*pdurTrail = 0;
	
	plsdn = GetCurrentDnodeSubl(plssubl);
	plschunkcontext = PlschunkcontextFromSubline(plssubl);
	
	
	while(fContinue)
		{
		
		if (plsdn != NULL)
			{
			lserr = GetTrailingInfoForTextGroupChunk(plsdn, 
				plsdn->dcp, IobjTextFromLsc(plschunkcontext->plsiobjcontext),
				&durTrailLoc, &dcpTrail, &plsdnStartTrail,
				&dcpStartTrailingText, &cDnodesTrailing, 
				&plsdnTrailingObject, &dcpTrailingObject, &fClosingBorderStartsTrailing);
			
			if (lserr != lserrNone) 
				return lserr;
			
			*pdurTrail += durTrailLoc;
			if (dcpTrailingObject == 0)
				{
				/* we stopped just before group chunk, may be because of pen */
				Assert(FIsLSDNODE(plsdnTrailingObject));
				plsdn = plsdnTrailingObject->plsdnPrev;
				while(plsdn != NULL && FIsDnodePen(plsdn))
					{
					*pdurTrail += DurFromDnode(plsdn);
					plsdn = plsdn->plsdnPrev;
					}
				}
			else
				{
				fContinue = fFalse;
				}
			}
		else
			{
			fContinue = fFalse;
			}
		
		}
	
	return lserrNone;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\tabutils.c ===
#include "lsidefs.h"
#include "dninfo.h"
#include "tabutils.h"
#include "lstbcon.h"
#include "plstbcon.h"
#include "lstabs.h"
#include "lsktab.h"
#include "lscaltbd.h"
#include "lstext.h"
#include "zqfromza.h"
#include "iobj.h"
#include "chnutils.h"
#include "lscbk.h"
#include "limqmem.h"
#include "posichnk.h"


#include <limits.h>


static LSERR FillTabsContext(PLSTABSCONTEXT, LSTFLOW);
static LSERR ItbdMergeTabs(PLSTABSCONTEXT plstabscontext, LSTFLOW lstflow, const LSTABS* plstabs,
						   BOOL fHangingTab,
						   long duaHangingTab,
						   WCHAR wchHangingTabLeader, DWORD* picaltbdMac);
static LSERR FindTab (PLSTABSCONTEXT plstabscontext, long urPen, BOOL fUseHangingTabAsDefault,
					  BOOL fZeroWidthUserTab,
					  DWORD* picaltbd, BOOL* pfBreakThroughTab);
static LSERR IncreaseTabsArray(PLSTABSCONTEXT plstabscontext, DWORD ccaltbdMaxNew);



/* G E T  C U R  T A B  I N F O  C O R E*/
/*----------------------------------------------------------------------------
    %%Function: GetCurTabInfoCore
    %%Contact: igorzv
	Parameters:
	plstabscontext	-	(IN) pointer to tabs context 
	plsdnTab		-	(IN) dnode with tab 
	urTab			-	(IN) position before this tab 
	fResolveAllTabsAsLeft(IN) switch all other tab to left
	plsktab			-	(OUT) type of current tab  
	pfBreakThroughTab-	(OUT)is break through tab occurs 

	Provides information about nearest tab stop
----------------------------------------------------------------------------*/

LSERR GetCurTabInfoCore(PLSTABSCONTEXT plstabscontext, PLSDNODE plsdnTab,	
					long urTab,	BOOL fResolveAllTabsAsLeft,
					LSKTAB* plsktab, BOOL* pfBreakThroughTab)
{
	LSERR lserr;
	LSCALTBD* plscaltbd;  
	DWORD icaltbd;
	long durTab;
	BOOL fUseHangingTabAsDefault = fFalse;
	BOOL fZeroWidthUserTab = fFalse;
	long urToFindTabStop;
	
	

	Assert(plsktab != NULL); 

	Assert(FIsLSDNODE(plsdnTab));
	Assert(plsdnTab->fTab);
	Assert(FIsDnodeReal(plsdnTab));

//	Assert(plstabscontext->plsdnPendingTab == NULL);
	

	/* first tab on line   */
	if (!plstabscontext->fTabsInitialized)
		{
		lserr = FillTabsContext(plstabscontext, LstflowFromDnode(plsdnTab));
		if (lserr != lserrNone) 
			return lserr;
		}

	urToFindTabStop = urTab;
	if (plstabscontext->fResolveTabsAsWord97	) /* such strange behaviour was in Word97 */
		{
		if (plsdnTab->fTabForAutonumber)
			{
			fZeroWidthUserTab = fTrue;
			fUseHangingTabAsDefault = fTrue;
			}
		else
			{
			urToFindTabStop++;
			}
		}

	/* find tab in tabs table */
	lserr = FindTab(plstabscontext, urToFindTabStop, fUseHangingTabAsDefault, 
		fZeroWidthUserTab, &icaltbd, pfBreakThroughTab);
	if (lserr != lserrNone) 
		return lserr;

	plsdnTab->icaltbd = icaltbd;
	plscaltbd = &(plstabscontext->pcaltbd[icaltbd]);
	
	/* ask text to set tab leader in his structures */
	if (plscaltbd->wchTabLeader != 0)
		{
		lserr = SetTabLeader(plsdnTab->u.real.pdobj, plscaltbd->wchTabLeader);
		if (lserr != lserrNone) 
			return lserr;   
		}

	*plsktab = plscaltbd->lskt;
	if (fResolveAllTabsAsLeft)
		*plsktab = lsktLeft;

	/* offset calculation for left tab , register pending tab for all others */
	switch (*plsktab)
		{
	default:
		NotReached();
		break;

	case lsktLeft:
		durTab = plscaltbd->ur - urTab;
		Assert(durTab >= 0);

		SetDnodeDurFmt(plsdnTab, durTab);
		break;

	case lsktRight:
	case lsktCenter:
	case lsktDecimal:
	case lsktChar:
		plstabscontext->plsdnPendingTab = plsdnTab;
		plstabscontext->urBeforePendingTab = urTab;
		break;
		}
	
 
	return lserrNone;
}

/* R E S O L V E  P R E V  T A B  C O R E*/
/*----------------------------------------------------------------------------
    %%Function: ResolvePrevTabCore
    %%Contact: igorzv
	Parameters:
	plstabscontext	-	(IN) pointer to tabs context 
	plsdnCurrent	-	(IN) current dnode 
	urCurrentPen	-	(IN) current pen position 
	pdurPendingTab	-	(OUT)offset because of pending tab

	Resolves if exists previous pending tab (right, decimal or center)
----------------------------------------------------------------------------*/

LSERR ResolvePrevTabCore(PLSTABSCONTEXT plstabscontext,	PLSDNODE plsdnCurrent,	
						long urCurrentPen, long* pdurPendingTab)
					
{

	PLSDNODE plsdnPendingTab;
	LSCALTBD* plscaltbd; 
	long urTabStop, durTab, durSeg; 
	PLSDNODE plsdn;
	long durTrail;
	GRCHUNKEXT grchnkext;
	DWORD index;
	long durToDecimalPoint;
	LSERR lserr;
	PLSCHUNKCONTEXT plschunkcontext;
	DWORD cchTrail;
	PLSDNODE plsdnStartTrail;
	LSDCP dcpStartTrailingText;
	PLSDNODE plsdnTrailingObject;
	LSDCP dcpTrailingObject;
	int cDnodesTrailing;
	BOOL fClosingBorderStartsTrailing;
	PLSDNODE plsdnDecimalPoint;

	
	*pdurPendingTab = 0;
	
	plsdnPendingTab = plstabscontext->plsdnPendingTab;
	
	if (plsdnPendingTab == NULL || 
		plsdnPendingTab->cpFirst >= plsdnCurrent->cpFirst)
		/* this second condition can happen after break when because of increased margin
		we fetch pending tab but later break was found before */
		{
		/* no business for us */ 
		return lserrNone;
		}
	
	/* pending in an other subline */
	if (SublineFromDnode(plsdnCurrent) != SublineFromDnode(plsdnPendingTab))
		{
		/* cancell pending tab */
		CancelPendingTab(plstabscontext);
		return lserrNone;
		}
	
	Assert(FIsLSDNODE(plsdnCurrent));
	plschunkcontext = PlschunkcontextFromSubline(SublineFromDnode(plsdnCurrent));
	Assert(plstabscontext->fTabsInitialized);
	
	
	Assert(FIsLSDNODE(plsdnPendingTab));
	Assert(plsdnPendingTab->fTab);
	Assert(FIsDnodeReal(plsdnPendingTab));
	
	plscaltbd = &(plstabscontext->pcaltbd[plsdnPendingTab->icaltbd]);
	urTabStop = plscaltbd->ur;
	durSeg = urCurrentPen - plstabscontext->urBeforePendingTab; 
	
	/* find durTrail */
	/* collect last chunk */
	plsdn = plsdnCurrent;
	/* If we resolve pending tab because of other tab we should 
	use previous dnode to calculate correct group chunk . We also must 
	be careful keeping in mind that line can be stopped right after pending tab */
	if ((plsdn->fTab && plsdn != plsdnPendingTab)) 
		plsdn = plsdn->plsdnPrev;
	
	Assert(FIsLSDNODE(plsdn));
	Assert(!FIsNotInContent(plsdn));
	
	lserr = GetTrailingInfoForTextGroupChunk(plsdn, 
		plsdn->dcp, IdObjFromDnode(plsdnPendingTab),
		&durTrail, &cchTrail, &plsdnStartTrail,
		&dcpStartTrailingText, &cDnodesTrailing, 
		&plsdnTrailingObject, &dcpTrailingObject, &fClosingBorderStartsTrailing);
	if (lserr != lserrNone) 
		return lserr;
	
	
	switch (plscaltbd->lskt)
		{
		default:
		case lsktLeft:
			NotReached();
			break;
			
		case lsktRight:
		case lsktCenter:
			durSeg -= durTrail;
			
			
			if (plscaltbd->lskt == lsktCenter)
				durSeg /= 2;
			break;
			
			
		case lsktDecimal:
		case lsktChar:
			InitGroupChunkExt(plschunkcontext, IdObjFromDnode(plsdnPendingTab), &grchnkext);
			
			plsdn = plsdnPendingTab->plsdnNext;
			Assert(FIsLSDNODE(plsdn));
			
			lserr = CollectTextGroupChunk(plsdn, plsdnCurrent->cpLimOriginal,
				CollectSublinesForDecimalTab, &grchnkext); 
			if (lserr != lserrNone) 
				return lserr;
			
			if (grchnkext.plsdnLastUsed == NULL)
				{
				/* there are now dnodes between tabs */
				durSeg = 0;
				}
			else
				{
				if (grchnkext.lsgrchnk.clsgrchnk > 0)
					{
					if (plscaltbd->lskt == lsktDecimal)
						{
						lserr = LsGetDecimalPoint(&(grchnkext.lsgrchnk), lsdevReference,
							&index, &durToDecimalPoint);
						if (lserr != lserrNone) 
							return lserr;
						}
					else
						{
						Assert(plscaltbd->lskt == lsktChar);
						lserr = LsGetCharTab(&(grchnkext.lsgrchnk), plscaltbd->wchCharTab, lsdevReference,
							&index, &durToDecimalPoint);
						if (lserr != lserrNone) 
							return lserr;
						}
					}
				else
					{
					index = idobjOutside;
					durToDecimalPoint = 0;
					}
				
				if (index != idobjOutside) /* decimal point has been found */
					{
					plsdnDecimalPoint = grchnkext.plschunkcontext->pplsdnChunk[index];
					}
				else
					{
					/* we allign end of the last logical cp to the tab stop */
					plsdnDecimalPoint = grchnkext.plsdnLastUsed;
					durToDecimalPoint = DurFromDnode(plsdnDecimalPoint);
					}
				
				FindPointOffset(plsdn, lsdevReference, LstflowFromDnode(plsdn),	
					CollectSublinesForDecimalTab, 
					plsdnDecimalPoint,	
					durToDecimalPoint, &durSeg);
				}
			
			break;   
		}
	
	durTab = urTabStop - plstabscontext->urBeforePendingTab - durSeg;
	if (urTabStop < plstabscontext->urColumnMax && 
		(durTab + urCurrentPen - durTrail > plstabscontext->urColumnMax))
		{
		/* this code is for compatibility with Word: when we are not in a situation
		of break through tab we dont allow line to leap right margin after we resolve
		pending tab */
		durTab = plstabscontext->urColumnMax - urCurrentPen + durTrail;
		}
	
	if (durTab > 0)
		{
		SetDnodeDurFmt(plsdnPendingTab, durTab);
		*pdurPendingTab = durTab;
		}
	
	
	plstabscontext->plsdnPendingTab = NULL;
	return lserrNone;
}


/* F I L L  T A B S  C O N T E X T*/
/*----------------------------------------------------------------------------
    %%Function: FillTabsContext
    %%Contact: igorzv
	Parameters:
	plstabscontext	-	(IN) pointer to tabs context 
	lstflow			-	(IN) text flow of the line

	Initializes tabs context using clients callback FetchTabs
----------------------------------------------------------------------------*/

LSERR FillTabsContext(PLSTABSCONTEXT plstabscontext, LSTFLOW lstflow)
{

	LSTABS lstabs;
	BOOL fHangingTab;
	long uaHangingTab;
	WCHAR wchHangingTabLeader;
	LSERR lserr;

	lserr = plstabscontext->plscbk->pfnFetchTabs(plstabscontext->pols, plstabscontext->cpInPara,
									&lstabs, &fHangingTab, &uaHangingTab, &wchHangingTabLeader);
	if (lserr != lserrNone) 
		return lserr;

	plstabscontext->durIncrementalTab = UrFromUa(lstflow, &(plstabscontext->plsdocinf->lsdevres), lstabs.duaIncrementalTab);
	/* Copy tabs from LSTABS to rgcaltbd[], inserting a hanging tab if
	 * required.
	 */
	if (fHangingTab || lstabs.iTabUserDefMac > 0)
		{
		lserr = ItbdMergeTabs(plstabscontext, lstflow, 
							  &lstabs, fHangingTab,
							  uaHangingTab, wchHangingTabLeader, &plstabscontext->icaltbdMac);
		if (lserr != lserrNone) 
			return lserr;
		}
	else
		{
		plstabscontext->icaltbdMac = 0;
		}


	
	plstabscontext->fTabsInitialized = fTrue;
	return lserrNone;
}


/* I N I T  T A B S  C O N T E X T  F O R  A U T O  D E C I M A L  T A B*/
/*----------------------------------------------------------------------------
    %%Function: InitTabsContextForAutoDecimalTab
    %%Contact: igorzv
	Parameters:
	plstabscontext	-	(IN) pointer to tabs context 
	durAutoDecimalTab-	(IN) tab stop for autodecimal tab

	Creates tabs context that consists of one tab stop - auto decimal
----------------------------------------------------------------------------*/

LSERR InitTabsContextForAutoDecimalTab(PLSTABSCONTEXT plstabscontext, long durAutoDecimalTab)
	{
	
	LSCALTBD* pcaltbd;
	
	
	pcaltbd = plstabscontext->pcaltbd;
	
	Assert(plstabscontext->ccaltbdMax >= 1);
	
	if (!plstabscontext->fTabsInitialized)
		{
		plstabscontext->icaltbdMac = 1;
		
		pcaltbd->lskt = lsktDecimal;
		pcaltbd->ur = durAutoDecimalTab;
		pcaltbd->wchTabLeader = 0;
		
		plstabscontext->fTabsInitialized = fTrue;
		}
	else
		{
		/* tab is already there because of autonumber */
		Assert(plstabscontext->icaltbdMac == 1);
		Assert(pcaltbd->lskt == lsktDecimal);
		Assert(pcaltbd->ur == durAutoDecimalTab);
		}

	return lserrNone;
	}



/* I T B D  M E R G E  T A B S */
/*----------------------------------------------------------------------------
    %%Function: ItbdMergeTabs
    %%Contact: igorzv
	Parameters:
	plstabscontext	-	(IN) pointer to tabs context 
	lstflow			-	(IN) text flow of the line
	plstabs			-	(IN) tabs array provided by client
	fHangingTab		-	(IN) does paragraph have hanging tab
	uaHangingTab	-	(IN) position of hanging tab
	wchHangingTabLeader-(IN) leader for hanging tab
	picaltbdMac			(OUT) amount of tabs in array



    Copies tabs from LSPAP into ptbd[], inserting a hanging tab where
    required.
----------------------------------------------------------------------------*/
static LSERR ItbdMergeTabs(PLSTABSCONTEXT plstabscontext, LSTFLOW lstflow, 
						   const LSTABS* plstabs, BOOL fHangingTab,
						   long uaHangingTab, WCHAR wchHangingTabLeader, DWORD* picaltbdMac)
{
	long uaPrevTab, uaCurrentTab;
	DWORD itbdOut, itbdIn, itbdLimIn;
	LSCALTBD* plscaltbd;
	DWORD ccaltbdMax;
	LSERR lserr;

	/* check that have enough room*/
	ccaltbdMax = plstabs->iTabUserDefMac;
	if (fHangingTab)
		ccaltbdMax++;
	if (ccaltbdMax >= plstabscontext->ccaltbdMax)
		{
		lserr = IncreaseTabsArray(plstabscontext, ccaltbdMax + limCaltbd);
		if (lserr != lserrNone)
			return lserr;
		}

	plscaltbd = plstabscontext->pcaltbd;

	itbdLimIn = plstabs->iTabUserDefMac;

	uaPrevTab = LONG_MAX;
	itbdOut = 0;

	if (fHangingTab)
		{

		/* If no user tabs, or hanging tab is before 0th user tab,
		 * make hanging tab the 0th member of ptbd[].
		 */
		if (itbdLimIn == 0 || uaHangingTab < plstabs->pTab[0].ua)
			{
			plscaltbd[0].lskt = lsktLeft;
			plscaltbd[0].ur = UrFromUa(lstflow,
						&(plstabscontext->plsdocinf->lsdevres), uaHangingTab);
			plscaltbd[0].wchTabLeader = wchHangingTabLeader;
			plscaltbd[0].fDefault = fFalse;
			plscaltbd[0].fHangingTab = fTrue;
			uaPrevTab = uaHangingTab;
			itbdOut = 1;
			}
		}
	else
		{
		uaHangingTab = LONG_MAX;
		}

	/* Copy user defined tabs, checking each time for hanging tab.
	 */
	for (itbdIn = 0;  itbdIn < itbdLimIn;  itbdOut++, itbdIn++)
		{
		uaCurrentTab = plstabs->pTab[itbdIn].ua; 

		/* If hanging tab is between previous tab and this tab,
		 * insert hanging tab into ptbd[] here and revisit "this" 
		 * tab again during next loop iteration.
		 */
		if (uaPrevTab < uaHangingTab && uaHangingTab < uaCurrentTab)
			{
			plscaltbd[itbdOut].lskt = lsktLeft;
			plscaltbd[itbdOut].ur = UrFromUa(lstflow, &(plstabscontext->plsdocinf->lsdevres),
											uaHangingTab);
			plscaltbd[itbdOut].wchTabLeader = wchHangingTabLeader;
			plscaltbd[itbdOut].fDefault = fFalse;
			plscaltbd[itbdOut].fHangingTab = fTrue;
			itbdIn -= 1;
			uaPrevTab = uaHangingTab;
			}
		else
			{
			plscaltbd[itbdOut].lskt =  plstabs->pTab[itbdIn].lskt;
			plscaltbd[itbdOut].ur = UrFromUa(lstflow, &(plstabscontext->plsdocinf->lsdevres),
												plstabs->pTab[itbdIn].ua);
			plscaltbd[itbdOut].wchTabLeader =  plstabs->pTab[itbdIn].wchTabLeader;
			plscaltbd[itbdOut].wchCharTab =  plstabs->pTab[itbdIn].wchCharTab;
			plscaltbd[itbdOut].fDefault = fFalse;
			plscaltbd[itbdOut].fHangingTab = fFalse;
			uaPrevTab = uaCurrentTab;
			}
		}

	/* If hanging tab is after final user tab, make hanging tab the
	 * final member of ptbd[]
	 */
	if (uaPrevTab < uaHangingTab && uaHangingTab < LONG_MAX)
		{
		plscaltbd[itbdOut].lskt = lsktLeft;
		plscaltbd[itbdOut].ur = UrFromUa(lstflow,
							&(plstabscontext->plsdocinf->lsdevres), uaHangingTab);
		plscaltbd[itbdOut].wchTabLeader = wchHangingTabLeader;
		plscaltbd[itbdOut].fDefault = fFalse;
		plscaltbd[itbdOut].fHangingTab = fTrue;
		itbdOut += 1;
		}

	*picaltbdMac = itbdOut;
	return lserrNone;
}

/* F I N D  T A B*/
/*----------------------------------------------------------------------------
    %%Function: FindTab
    %%Contact: igorzv
	Parameters:
	plstabscontext	-	(IN) pointer to tabs context 
	urPen			-	(IN) position before this tab 
	fUseHangingTabAsDefault - (IN) usually hanging tab is used as user defined tab,
							but in one case for compstibility with Word97 it's treated as
							user default tab 
	fZeroWidthUserTab-	(IN) for compatibility with Word97
	picaltbd		-	(OUT)pointer to a record describing tab stop 
	pfBreakThroughTab-	(OUT)is break through tab occurs 

	Procedure findes fist tab stop after current pen position. In the case when
	it is a default tab stop program adds record to an array of tab stops.
	This procedure also resolves breakthrouhtab logic.
----------------------------------------------------------------------------*/

static LSERR FindTab (PLSTABSCONTEXT plstabscontext, long urPen, BOOL fUseHangingTabAsDefault,
					  BOOL fZeroWidthUserTab,
					  DWORD* picaltbd, BOOL* pfBreakThroughTab)
{

	DWORD icaltbdMac = plstabscontext->icaltbdMac;
	LSCALTBD* pcaltbd = plstabscontext->pcaltbd;
	long durIncTab, durDelta;
	DWORD i;
	LSERR lserr;
	int iHangingTab = -1;
	long urDefaultTab;
	long urPenForUserTab = urPen;

	*pfBreakThroughTab = fFalse;
	
	if (fZeroWidthUserTab)
		urPenForUserTab--;

	for (i = 0; i < icaltbdMac &&
					(urPenForUserTab >= (pcaltbd[i].ur)		/* if fUseHangingTabAsDefault we skip it */
						|| (fUseHangingTabAsDefault && pcaltbd[i].fHangingTab));
	     i++)
			 {
			 if (fUseHangingTabAsDefault && pcaltbd[i].fHangingTab)
				iHangingTab = i;
			 }

	if (i == icaltbdMac)
		{

		/* We deleted strange calculation of tab stop which was there due to compatibility with
		Word97. Compatibility we are solving when calling this procedure */
		durIncTab = plstabscontext->durIncrementalTab;
		if (durIncTab == 0)
			durIncTab = 1;
		durDelta = durIncTab;
		if (urPen < 0)
			durDelta = 0;
		urDefaultTab = ((urPen + durDelta) / durIncTab) * durIncTab;  

		if (fUseHangingTabAsDefault && iHangingTab != -1 &&
			pcaltbd[iHangingTab].ur > urPen &&
			pcaltbd[iHangingTab].ur <= urDefaultTab)
			{
			/* in this case hanging tab is the nearesr default tab */
			i = iHangingTab;
			}
		else
			{
			
			icaltbdMac++;
			if (icaltbdMac >= plstabscontext->ccaltbdMax)
				{
				lserr = IncreaseTabsArray(plstabscontext, 0);
				if (lserr != lserrNone)
					return lserr;
				pcaltbd = plstabscontext->pcaltbd;
				}
			
			plstabscontext->icaltbdMac = icaltbdMac; 
			pcaltbd[i].lskt = lsktLeft;
			pcaltbd[i].wchTabLeader = 0;  /* REVIEW (igorzv) do we need wchSpace as tab leader in this case */
			pcaltbd[i].fDefault = fTrue;
			pcaltbd[i].fHangingTab = fFalse;
			
			pcaltbd[i].ur = urDefaultTab;  
			}
		}
	else
		{
		if (urPen < plstabscontext->urColumnMax && 
			pcaltbd[i].ur >= plstabscontext->urColumnMax)
		/* tab we found is user defined behind right margin */
		/* it is important to check also that we are not already behind right margin,
		   opposite can happens because of exceeded right margin */
			{
			*pfBreakThroughTab = fTrue;
			}
		}

	*picaltbd = i;
	return lserrNone;

}

/* I N C R E A S E  T A B S  A R R A Y*/
/*----------------------------------------------------------------------------
    %%Function: IncreaseTabsArray
    %%Contact: igorzv

Parameters:
	plsc			-		(IN) ptr to line services context 
	ccaltbdMaxNew	-		(IN) new value for array size if 0 then add limCaltbd

Relocate tabs array and set new values in context
----------------------------------------------------------------------------*/
static LSERR IncreaseTabsArray(PLSTABSCONTEXT plstabscontext, DWORD ccaltbdMaxNew)
{

	DWORD ccaltbdMax;

	if (ccaltbdMaxNew > 0)
		ccaltbdMax = ccaltbdMaxNew;
	else
		ccaltbdMax = plstabscontext->ccaltbdMax + limCaltbd;


	/* create new array for tabs  */
	plstabscontext->pcaltbd = plstabscontext->plscbk->pfnReallocPtr(plstabscontext->pols, 
											plstabscontext->pcaltbd,
											sizeof(LSCALTBD)*ccaltbdMax);


	if (plstabscontext->pcaltbd == NULL )
		return lserrOutOfMemory;

	plstabscontext->ccaltbdMax = ccaltbdMax;

	return lserrNone;

}

/* G E T  M A R G I N  A F T E R  B R E A K  T H R O U G H  T A B*/
/*----------------------------------------------------------------------------
    %%Function: GetMarginAfterBreakThroughTab
    %%Contact: igorzv

Parameters:
	plsc			-		(IN) ptr to line services context 
	plsdnTab		-		(IN) tab which triggered breakthrough tab
	purNewMargin	-		(OUT) new margin because of breakthrough tab
----------------------------------------------------------------------------*/

LSERR GetMarginAfterBreakThroughTab(PLSTABSCONTEXT plstabscontext,
								  PLSDNODE plsdnTab, long* purNewMargin)			

	{
	LSERR lserr;
	long uaNewMargin;

	lserr = plstabscontext->plscbk->pfnGetBreakThroughTab(plstabscontext->pols,
					UaFromUr(LstflowFromDnode(plsdnTab), &(plstabscontext->plsdocinf->lsdevres),
							 plstabscontext->urColumnMax),
					UaFromUr(LstflowFromDnode(plsdnTab), &(plstabscontext->plsdocinf->lsdevres),
							 plstabscontext->pcaltbd[plsdnTab->icaltbd].ur),

					&uaNewMargin);

	if (lserr != lserrNone)
		return lserr;

	*purNewMargin = UrFromUa(LstflowFromDnode(plsdnTab), &(plstabscontext->plsdocinf->lsdevres),
							 uaNewMargin);
	return lserrNone;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\robj.c ===
#include	"lsmem.h"
#include	"limits.h"
#include	"lscbk.h"
#include	"lsdevres.h"
#include	"pdobj.h"
#include	"objdim.h"
#include	"plssubl.h"
#include	"plsdnode.h"
#include	"pilsobj.h"
#include	"lscrsubl.h"
#include	"lssubset.h"
#include	"lsdnset.h"
#include	"lsdocinf.h"
#include	"lsidefs.h"
#include	"fmti.h"
#include	"posichnk.h"
#include	"locchnk.h"
#include	"lsdnfin.h"
#include	"brko.h"
#include	"lspap.h"
#include	"plspap.h"
#include	"lsqsubl.h"
#include	"dispi.h"
#include	"lsdssubl.h"
#include	"lsems.h"
#include	"lstfset.h"
#include	"plnobj.h"
#include	"plocchnk.h"
#include	"lsimeth.h"
#include	"robj.h"
#include	"lsidefs.h"
#include	"brkpos.h"
#include	"objhelp.h"

#include	"lssubset.h"

typedef enum breaksublinetype
{
	breakSublineAfter,
	breakSublineInside

} BREAKSUBLINETYPE;

struct ilsobj
{
    POLS				pols;
	LSCBK				lscbk;
	PLSC				plsc;
	DWORD				idobj;
	LSESC				lsesc;
	PFNREVERSEGETINFO	pfnReverseGetInfo;
	PFNREVERSEENUM		pfnReverseEnum;
};


typedef struct rbreakrec
{
	BOOL				fValid;					/* Is this break record contains valid info? */
	BREAKSUBLINETYPE	breakSublineType;		/* After / Inside */
	LSCP				cpBreak;				/* CpLim of the break */

} RBREAKREC;


struct dobj
{
	PILSOBJ				pilsobj;			/* ILS object */
	LSTFLOW				lstflowL;			/* flow of line input */
	LSTFLOW				lstflowO;			/* flow of this object */
	BOOL				fDoNotBreakAround;	/* Break around robj as "can"  */
	BOOL				fSuppressTrailingSpaces;
											/* Kill trailing space when robj is
											   alone on the line & broken */ 
	BOOL				fFirstOnLine;		/* If first on line -- required for
											   fSuppressTrailingSpaces */
	PLSDNODE			plsdnTop;			/* Parent dnode */
	LSCP				cpStart;			/* Starting LS cp for object */
	LSCP				cpStartObj;			/* cp for start of object can be different
											   than cpStart if object is broken. */
	LSCP				cpFirstSubline;		/* cpFirst of the subline; will be
											   equal to cpStart when object is broken and
											   equal to cpStart+1 when it isnot broken */
	LSDCP				dcpSubline;			/* Number of characters in the subline */
											   
	LSDCP				dcp;				/* Number of characters in object */
	PLSSUBL				plssubl;			/* Subline formatted RTL */
	OBJDIM				objdimAll;			/* Objdim for entire object */
	long				dup;				/* dup of object */

	RBREAKREC			breakRecord [NBreaksToSave];
	
											/* Last 3 break records for each break */
};

static LSTFLOW rlstflowReverse[8] =
{
	lstflowWS,	/* Reverse lstflowES */
	lstflowWN,	/* Reverse lstflowEN */
	lstflowNE,	/* Reverse lstflowSE */
	lstflowNW,	/* Reverse lstflowSW */
	lstflowES,	/* Reverse lstflowWS */
	lstflowEN,	/* Reverse lstflowWN */
	lstflowSE,	/* Reverse lstflowNE */
	lstflowSW	/* Reverse lstflowNW */
};


/* R E V E R S E  S A V E  B R E A K  R E C O R D  */
/*----------------------------------------------------------------------------
	%%Function: RobjSaveBreakRecord
	%%Contact: antons

		Save break record in DOBJ.
	
----------------------------------------------------------------------------*/

static void ReverseSaveBreakRecord (
	PDOBJ pdobj, 
	BRKKIND brkkindWhatBreak,
	BREAKSUBLINETYPE breakSublineType,
	LSCP cpBreak)
{
	DWORD ind = GetBreakRecordIndex (brkkindWhatBreak);

	pdobj->breakRecord [ind].fValid = TRUE;
	pdobj->breakRecord [ind].breakSublineType = breakSublineType;
	pdobj->breakRecord [ind].cpBreak = cpBreak; 
}

/* R E V E R S E  G E T  B R E A K  R E C O R D  */
/*----------------------------------------------------------------------------
	%%Function: ReverseGetBreakRecord
	%%Contact: antons

		Read break record from DOBJ.
	
----------------------------------------------------------------------------*/

static void ReverseGetBreakRecord (
	PDOBJ pdobj, 
	BRKKIND brkkindWhatBreak, 
	BREAKSUBLINETYPE *breakSublineType,
	LSCP * pcpBreak )
{
	DWORD ind = GetBreakRecordIndex (brkkindWhatBreak);

	Assert (pdobj->breakRecord [ind].fValid);

	*breakSublineType = pdobj->breakRecord [ind].breakSublineType;
	*pcpBreak = pdobj->breakRecord [ind].cpBreak;
}


/* F R E E D O B J */
/*----------------------------------------------------------------------------
	%%Function: ReverseFreeDobj
	%%Contact: antons

		Free all resources associated with this Reverse dobj.
	
----------------------------------------------------------------------------*/
static LSERR ReverseFreeDobj(PDOBJ pdobj)
{
	LSERR lserr = lserrNone;

	PILSOBJ pilsobj = pdobj->pilsobj;

	if (pdobj->plssubl != NULL)
		{
		lserr = LsDestroySubline(pdobj->plssubl);
		}

    pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pdobj);

	return lserr;
}

/* R E V E R S E  F M T  F A I L E D */
/*----------------------------------------------------------------------------
	%%Function: ReverseFmtFailed
	%%Contact: antons

		Could not create Reverse DOBJ due to error. 
		
----------------------------------------------------------------------------*/
static LSERR ReverseFmtFailed (PDOBJ pdobj, LSERR lserr)
{
	if (pdobj != NULL) ReverseFreeDobj (pdobj); /* Works with parially-filled DOBJ */

	return lserr;
}

/* T R A N S L A T E  C P  L I M  S U B L I N E  T O  D C P  E X T E R N A L
/*----------------------------------------------------------------------------
	%%Function: TranslateCpLimSublineToDcpExternal
	%%Contact: antons

		Translates position (CpLim) in the subline to dcp of
		the reverse object.

----------------------------------------------------------------------------*/

/* REVIEW (antons): Is old name OK for new behavior? */

LSDCP TranslateCpLimSublineToDcpExternal (PDOBJ pdobj, LSCP cpLim)
{
	Unreferenced (pdobj);

	Assert (cpLim <= pdobj->cpStart + (long) pdobj->dcp);
	Assert (cpLim >= pdobj->cpStart);

	Assert (pdobj->cpStart <= pdobj->cpFirstSubline);
	Assert (pdobj->cpStart + pdobj->dcp >= pdobj->cpFirstSubline + pdobj->dcpSubline);

	return cpLim - pdobj->cpStart;
}

/* T R A N S L A T E  D C P  E X T E R N A L  T O  C P  L I M  S U B L I N E
/*----------------------------------------------------------------------------
	%%Function: TranslateCpLimInternalToExternal
	%%Contact: antons

		Translates position (dcp) in reverse object to cpLim of
		the subline. 

----------------------------------------------------------------------------*/

LSCP TranslateDcpExternalToCpLimSubline (PDOBJ pdobj, LSDCP dcp)
{
	Unreferenced (pdobj);

	Assert (dcp <= pdobj->dcp);

	Assert (pdobj->cpStart <= pdobj->cpFirstSubline);
	Assert (pdobj->cpStart + pdobj->dcp >= pdobj->cpFirstSubline + pdobj->dcpSubline);

	return pdobj->cpStart + dcp;
}


/* F I N I S H   B R E A K   R E G U L A R  */
/*----------------------------------------------------------------------------
	%%Function: FinishBreakRegular
	%%Contact: antons

		Set up breaking information for proposed break point. 

		Caller must save break record by hiself!
	
----------------------------------------------------------------------------*/
static LSERR FinishBreakRegular (

	DWORD ichnk,				/* (IN): chunk id */
	PDOBJ pdobj,				/* (IN): object for break */
	LSCP cpBreak,				/* (IN): cp - break to report outside */
	POBJDIM pobjdimSubline,		/* (IN): objdim for subline at proposed break */
	PBRKOUT pbrkout)			/* (OUT): break info for Line Services */
{
	Assert (ichnk != ichnkOutside);

	pbrkout->fSuccessful = fTrue;
	pbrkout->posichnk.dcp = TranslateCpLimSublineToDcpExternal (pdobj, cpBreak);
	pbrkout->posichnk.ichnk = ichnk;

	pbrkout->objdim = *pobjdimSubline;

	return lserrNone;
}

/* P U T B R E A K A T E N D O F O B J E C T */
/*----------------------------------------------------------------------------
	%%Function: PutBreakAtEndOfObject
	%%Contact: antons

		Fill in break output record for the end of the object.
	
----------------------------------------------------------------------------*/
static void PutBreakAtEndOfObject (

	DWORD ichnk,				/* (IN): index in chunk */
	PCLOCCHNK pclocchnk,		/* (IN): locchnk to find break */
	PBRKOUT pbrkout)			/* (OUT): results of breaking */
{	
	PDOBJ pdobj = pclocchnk->plschnk[ichnk].pdobj;

	Assert (ichnk != ichnkOutside);

	pbrkout->fSuccessful = fTrue;
	pbrkout->posichnk.dcp = pdobj->dcp;
	pbrkout->posichnk.ichnk = ichnk;
	pbrkout->objdim = pdobj->objdimAll;
}


/* P U T B R E A K B E F O R E O B J E C T */
/*----------------------------------------------------------------------------
	%%Function: PutBreakBeforeObject
	%%Contact: antons

		Fill in break output record for break before object.
	
----------------------------------------------------------------------------*/

static void PutBreakBeforeObject (

	DWORD ichnk,				/* (IN): index in chunk */
	PCLOCCHNK pclocchnk,		/* (IN): locchnk to find break */
	PBRKOUT pbrkout)			/* (OUT): results of breaking */
{
	Unreferenced (pclocchnk);
	
	Assert (ichnk != ichnkOutside);

	pbrkout->fSuccessful = fTrue;
	pbrkout->posichnk.dcp = 0;
	pbrkout->posichnk.ichnk = ichnk;

	ZeroMemory (&pbrkout->objdim, sizeof(pbrkout->objdim));
}


/* P U T B R E A K U N S U C C E S S F U L */
/*----------------------------------------------------------------------------
	%%Function: PutBreakUnsuccessful
	%%Contact: antons

		Fill in break output record for unsuccessful break of ROBJ
	
----------------------------------------------------------------------------*/

static void PutBreakUnsuccessful (PDOBJ pdobj, PBRKOUT pbrkout)
{
	pbrkout->fSuccessful = FALSE;

	if (pdobj->fDoNotBreakAround) pbrkout->brkcond = brkcondCan;
	else
		pbrkout->brkcond = brkcondPlease;

}


/* I N I T D O B J */
/*----------------------------------------------------------------------------
	%%Function: InitDobj
	%%Contact: ricksa

		Allocate and initialize DOBJ with basic information.
	
----------------------------------------------------------------------------*/
static LSERR InitDobj(
	PILSOBJ pilsobj,			/* (IN): ilsobj */
    PCFMTIN pcfmtin,			/* (IN): formatting input */
	PDOBJ *ppdobj)				/* (OUT): initialized dobj */	
{
	/* Assume failure */
	LSERR lserr;

    PDOBJ pdobj = (PDOBJ) 
		pilsobj->lscbk.pfnNewPtr(pilsobj->pols, sizeof(*pdobj));

    if (pdobj != NULL)
		{
		int iBreakRec;
		
		ZeroMemory(pdobj, sizeof(*pdobj));

		pdobj->pilsobj = pilsobj;
		pdobj->cpStart = pcfmtin->lsfgi.cpFirst;
		pdobj->lstflowL = pcfmtin->lsfgi.lstflow;
		pdobj->lstflowO = rlstflowReverse[(int) pcfmtin->lsfgi.lstflow];
		pdobj->cpStartObj = pcfmtin->lsfgi.cpFirst;

		for (iBreakRec = 0; iBreakRec < NBreaksToSave; iBreakRec++)
			{
			pdobj->breakRecord [iBreakRec].fValid = FALSE;
			};
		
		*ppdobj = pdobj;

		lserr = lserrNone;
		}
	else
		{
		lserr = lserrOutOfMemory;
		}

	return lserr;
}

/* F I N I S H F M T */
/*----------------------------------------------------------------------------
	%%Function: FinishFmt
	%%Contact: ricksa

		Helper for ReverseFmt & ReverseFmtResume that completes work
		for formatting.
	
----------------------------------------------------------------------------*/
static LSERR FinishFmt(
	PDOBJ pdobj,				/* (IN): dobj for reverse */
	PILSOBJ pilsobj,			/* (IN): ILS object for Reverse */
    PCFMTIN pcfmtin,			/* (IN): formatting input */
	LSCP cpFirstMain,			/* (IN): cp first of reverse subline */
	LSCP cpLast,				/* (IN): cp output from formatting subline */
	FMTRES fmtres)				/* (IN): final format state */
{
	LSERR lserr;

	/* Set cpFirst and cpLim for reverse subline */

	pdobj->cpFirstSubline = cpFirstMain;
	pdobj->dcpSubline = cpLast - pdobj->cpFirstSubline;

	/* Set dcp for whole object */

	pdobj->dcp = cpLast - pdobj->cpStart;

	if (fmtres != fmtrExceededMargin)
		{
		/* Note: +1 for the escape character at the end of the object. */
		pdobj->dcp++;
		}

	lserr = LsdnSubmitSublines(pilsobj->plsc, pcfmtin->plsdnTop, 1, 
				&pdobj->plssubl, TRUE, FALSE, TRUE, TRUE, FALSE);

	if (lserr != lserrNone) return ReverseFmtFailed (pdobj, lserr);

	return LsdnFinishRegular(pilsobj->plsc, pdobj->dcp, 
		pcfmtin->lsfrun.plsrun, pcfmtin->lsfrun.plschp, pdobj, 
			&pdobj->objdimAll);
}

/* R E V E R S E C R E A T E I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: ReverseCreateILSObj
	%%Contact: ricksa

		CreateILSObj

		Create the ILS object for all Reverse objects.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseCreateILSObj(
	POLS pols,				/* (IN): client application context */
	PLSC plsc,				/* (IN): LS context */
	PCLSCBK pclscbk,		/* (IN): callbacks to client application */
	DWORD idObj,			/* (IN): id of the object */
	PILSOBJ *ppilsobj)		/* (OUT): object ilsobj */
{
    PILSOBJ pilsobj;
	REVERSEINIT reverseinit;
	LSERR lserr;

	*ppilsobj = NULL; /* in case of error */

	/* Get initialization data */
	reverseinit.dwVersion = REVERSE_VERSION;
	lserr = pclscbk->pfnGetObjectHandlerInfo(pols, idObj, &reverseinit);

	if (lserr != lserrNone)	return lserr;

    pilsobj = (PILSOBJ) pclscbk->pfnNewPtr(pols, sizeof(*pilsobj));

	if (NULL == pilsobj) return lserrOutOfMemory;

    pilsobj->pols = pols;
    pilsobj->lscbk = *pclscbk;
	pilsobj->plsc = plsc;
	pilsobj->idobj = idObj;
	pilsobj->lsesc.wchFirst = reverseinit.wchEndReverse;
	pilsobj->lsesc.wchLast = reverseinit.wchEndReverse;
	pilsobj->pfnReverseEnum = reverseinit.pfnEnum;
	pilsobj->pfnReverseGetInfo = reverseinit.pfnGetRobjInfo;

	*ppilsobj = pilsobj;

	return lserrNone;
}

/* R E V E R S E D E S T R O Y I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: ReverseDestroyILSObj
	%%Contact: ricksa

		DestroyILSObj

		Free all resources assocaiated with Reverse ILS object.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseDestroyILSObj(
	PILSOBJ pilsobj)			/* (IN): object ilsobj */
{
	pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pilsobj);
	return lserrNone;
}

/* R E V E R S E S E T D O C */
/*----------------------------------------------------------------------------
	%%Function: ReverseSetDoc
	%%Contact: ricksa

		SetDoc

		Keep track of device information for scaling purposes.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseSetDoc(
	PILSOBJ pilsobj,			/* (IN): object ilsobj */
	PCLSDOCINF pclsdocinf)		/* (IN): initialization data of the document level */
{
	Unreferenced(pilsobj);
	Unreferenced(pclsdocinf);

	return lserrNone;
}


/* R E V E R S E C R E A T E L N O B J */
/*----------------------------------------------------------------------------
	%%Function: ReverseCreateLNObj
	%%Contact: ricksa

		CreateLNObj

		Create the Line Object for the Reverse. No real need for a line
		object so don't allocated it.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseCreateLNObj(
	PCILSOBJ pcilsobj,			/* (IN): object ilsobj */
	PLNOBJ *pplnobj)			/* (OUT): object lnobj */
{
	*pplnobj = (PLNOBJ) pcilsobj;

	return lserrNone;
}

/* R E V E R S E D E S T R O Y L N O B J */
/*----------------------------------------------------------------------------
	%%Function: ReverseDestroyLNObj
	%%Contact: ricksa

		DestroyLNObj

		Frees resources associated with the Reverse line object. Since
		there isn't any this is a no-op.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseDestroyLNObj(
	PLNOBJ plnobj)				/* (OUT): object lnobj */

{
	Unreferenced(plnobj);

	return lserrNone;
}

/* R E V E R S E F M T */
/*----------------------------------------------------------------------------
	%%Function: ReverseFmt
	%%Contact: ricksa

		Fmt

		Format the Reverse object. 
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseFmt(
    PLNOBJ plnobj,				/* (IN): object lnobj */
    PCFMTIN pcfmtin,			/* (IN): formatting input */
    FMTRES *pfmtres)			/* (OUT): formatting result */
{
	PDOBJ pdobj;
	LSERR lserr;
	PILSOBJ pilsobj = (PILSOBJ) plnobj;
	LSCP cpStartMain = pcfmtin->lsfgi.cpFirst + 1;
	LSCP cpOut;

	lserr = InitDobj(pilsobj, pcfmtin, &pdobj);

//	Assert (pilsobj->pfnReverseGetInfo != NULL);

	if (pilsobj->pfnReverseGetInfo != NULL)
		{
		lserr = pilsobj->pfnReverseGetInfo (pilsobj->pols, 
											pcfmtin->lsfgi.cpFirst,
											pcfmtin->lsfrun.plsrun, 
											&pdobj->fDoNotBreakAround,
											&pdobj->fSuppressTrailingSpaces);

		if (lserr != lserrNone) return ReverseFmtFailed (pdobj, lserr);

	};

	if (lserr != lserrNone)	return lserrNone;

	pdobj->fFirstOnLine = pcfmtin->lsfgi.fFirstOnLine;
	pdobj->plsdnTop = pcfmtin->plsdnTop;

	// Format the text to the maximum remaining in the column
	lserr = FormatLine(pilsobj->plsc, cpStartMain, 
		pcfmtin->lsfgi.urColumnMax - pcfmtin->lsfgi.urPen, 
			pdobj->lstflowO, &pdobj->plssubl, 1, &pilsobj->lsesc,  
				&pdobj->objdimAll, &cpOut, NULL, NULL, pfmtres);

	if (lserr != lserrNone) return ReverseFmtFailed (pdobj, lserr);

	return FinishFmt(pdobj, pilsobj, pcfmtin, cpStartMain, cpOut, *pfmtres);
}

/* R E V E R S E F M T R E S U M E */
/*----------------------------------------------------------------------------
	%%Function: ReverseFmtResume
	%%Contact: ricksa

		Fmt

		Format a broken Reverse object. 

----------------------------------------------------------------------------*/

LSERR WINAPI ReverseFmtResume(
	PLNOBJ plnobj,				/* (IN): object lnobj */
	const BREAKREC *rgBreakRecord,	/* (IN): array of break records */
	DWORD nBreakRecord,			/* (IN): size of the break records array */
	PCFMTIN pcfmtin,			/* (IN): formatting input */
	FMTRES *pfmtres)			/* (OUT): formatting result */
{
	PDOBJ pdobj;
	LSERR lserr;
	PILSOBJ pilsobj = (PILSOBJ) plnobj;
	LSCP cpStartMain = pcfmtin->lsfgi.cpFirst;
	LSCP cpOut;

	lserr = InitDobj(pilsobj, pcfmtin, &pdobj);

	if (lserr != lserrNone)	return lserr;

	/* InitDobj sets cpStartObj to start of text. Because we are resuming,
	   we need to set this to the real start of the object. */

	pdobj->cpStartObj = rgBreakRecord->cpFirst;

//	Assert (pilsobj->pfnReverseGetInfo != NULL);

	if (pilsobj->pfnReverseGetInfo != NULL)
		{
		lserr = pilsobj->pfnReverseGetInfo (pilsobj->pols, pcfmtin->lsfgi.cpFirst,
											pcfmtin->lsfrun.plsrun, 
											&pdobj->fDoNotBreakAround,
											&pdobj->fSuppressTrailingSpaces);

		if (lserr != lserrNone) return ReverseFmtFailed (pdobj, lserr);
		};

	pdobj->fFirstOnLine = pcfmtin->lsfgi.fFirstOnLine;
	pdobj->plsdnTop = pcfmtin->plsdnTop;

	/* Format the text to the maximum remaining in the column */

	lserr = FormatResumedLine(pilsobj->plsc, cpStartMain, 
		pcfmtin->lsfgi.urColumnMax - pcfmtin->lsfgi.urPen, 
			pdobj->lstflowO, &pdobj->plssubl, 1, &pilsobj->lsesc,  
				&pdobj->objdimAll, &cpOut, NULL, NULL, pfmtres,
					&rgBreakRecord[1], nBreakRecord - 1);

	if (lserr != lserrNone) return ReverseFmtFailed (pdobj, lserr);

	return FinishFmt(pdobj, pilsobj, pcfmtin, cpStartMain, cpOut, *pfmtres);
}



/* R E V E R S E T R U N C A T E C H U N K */
/*----------------------------------------------------------------------------
	%%Function: ReverseTruncateChunk
	%%Contact: ricksa

	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseTruncateChunk(
	PCLOCCHNK plocchnk,			/* (IN): locchnk to truncate */
	PPOSICHNK posichnk)			/* (OUT): truncation point */
{
	long urColumnMax = plocchnk->lsfgi.urColumnMax;
	long ur = plocchnk->ppointUvLoc[0].u;
	PDOBJ pdobj = NULL;
	DWORD i;
	LSCP cp;
	LSERR lserr;

	AssertSz(plocchnk->ppointUvLoc[0].u <= urColumnMax, 
		"ReverseTruncateChunk - pen greater than column max");

	/* Look for chunk to truncate */
	for (i = 0; ur <= urColumnMax; i++)
	{
		AssertSz((i < plocchnk->clschnk), "ReverseTruncateChunk exceeded group of chunks");
	
		ur = plocchnk->ppointUvLoc[i].u;

		AssertSz(ur <= urColumnMax, 
			"ReverseTruncateChunk - pen pos past column max");

		pdobj = plocchnk->plschnk[i].pdobj;

		ur += pdobj->objdimAll.dur;
	}

	/* Found the object where truncation is to occur */
	AssertSz(pdobj != NULL, "ReverseTruncateChunk - pdobj is NULL");

	/* Get the truncation point from the subline */
	lserr = LsTruncateSubline(pdobj->plssubl, 
		urColumnMax - (ur - pdobj->objdimAll.dur), &cp);

	if (lserr != lserrNone)	return lserr;

	/* Format return result */

	posichnk->ichnk = i - 1;

	posichnk->dcp = TranslateCpLimSublineToDcpExternal (pdobj, cp + 1);

	return lserrNone;
}


/* R E V E R S E F I N D P R E V B R E A K C O R E*/
/*----------------------------------------------------------------------------
	%%Function: ReverseFindPrevBreakCore
	%%Contact: antons


----------------------------------------------------------------------------*/

LSERR ReverseFindPrevBreakCore (
									 
	PCLOCCHNK	pclocchnk,		/* (IN): locchnk to break */
	DWORD		ichnk,			/* (IN): object to start looking for break */
	BOOL		fDcpOutside,	/* (IN): when true, start looking from outside */
	LSDCP		dcp,			/* (IN): starting dcp; valid only when fDcpOutside=False */
	BRKCOND		brkcond,		/* (IN): recommmendation about the break before ichnk */
	PBRKOUT		pbrkout)		/* (OUT): result of breaking */
{
	LSERR lserr;
	PDOBJ pdobj = pclocchnk->plschnk[ichnk].pdobj;

	if (fDcpOutside)
		{
		if ( brkcond != brkcondNever &&  
			! (pdobj->fDoNotBreakAround && brkcond == brkcondCan) )
			{
			/* Can break after ichnk */

			PutBreakAtEndOfObject(ichnk, pclocchnk, pbrkout);
			ReverseSaveBreakRecord (pdobj, brkkindPrev, breakSublineAfter, pdobj->cpStart + pdobj->dcp);
			return lserrNone;
			}
		else
			{
			/* Try to break ichnk */

			return ReverseFindPrevBreakCore ( pclocchnk, 
											  ichnk, 
											  fFalse, 
											  pclocchnk->plschnk[ichnk].dcp - 1,
											  brkcond,
											  pbrkout );
			}
		}
	else
		{

		LSCP cpTruncateSubline = TranslateDcpExternalToCpLimSubline (pdobj, dcp - 1);
		BOOL fSuccessful;
		LSCP cpBreak;
		OBJDIM objdimSubline;
		BRKPOS brkpos;

		Assert (dcp >= 1 && dcp <= pdobj->dcp);

		/* REVIEW (antons): I do not think that passing pclocchnk->lsfgi.urColumnMax is correct... */
		/*					need to be confirmed with IgorZv */

		lserr = LsFindPrevBreakSubline (
						pdobj->plssubl, 
						pclocchnk->lsfgi.fFirstOnLine,
						cpTruncateSubline, 
						pclocchnk->lsfgi.urColumnMax,
						&fSuccessful, 
						&cpBreak, 
						&objdimSubline, 
						&brkpos);

		if (lserr != lserrNone)	return lserr;

		/* 1. Unsuccessful or break before first DNode */

		if (!fSuccessful || (fSuccessful && brkpos == brkposBeforeFirstDnode))
			{
			if (ichnk == 0) 
				{
				/* First in the chunk => return UnSuccessful */

				PutBreakUnsuccessful (pdobj, pbrkout);
				return lserrNone;
				}

			else
				{
				/* Break between objects */
		
				if (pdobj->fDoNotBreakAround)
					{
					return ReverseFindPrevBreakCore ( pclocchnk,
													  ichnk - 1,
													  fTrue,
													  0,
													  brkcondCan,
													  pbrkout );
					}
				else
					{
					pdobj = pclocchnk->plschnk[ichnk-1].pdobj;

					PutBreakAtEndOfObject(ichnk - 1, pclocchnk, pbrkout);
					ReverseSaveBreakRecord (
											pclocchnk->plschnk[ichnk-1].pdobj, 
											brkkindPrev, 
											breakSublineAfter, pdobj->cpStart + pdobj->dcp);
					return lserrNone;
					};
		
				};
			}

		/* 2. Successful break after last DNode */

		else if (brkpos == brkposAfterLastDnode)
			{
			if (brkcond == brkcondNever) /* Can not reset dcp */
				{

				/* We are not allowed to break "after", */
				/* so we are trying another previous break if possible */

				return ReverseFindPrevBreakCore ( pclocchnk,
												  ichnk,
												  fFalse,
												  dcp-1,
												  brkcondCan,
												  pbrkout );
				}
	
			else /* Can reset dcp */
				{
				
				/*	We reset dcp of the break so it happends after object but in break
				record we remember that we should call SetBreakSubline with brkkindPrev */

				ReverseSaveBreakRecord ( pdobj, brkkindPrev, breakSublineInside,
										 pdobj->cpStart + pdobj->dcp );

				return FinishBreakRegular ( ichnk,
											pdobj,
											pdobj->cpStart + pdobj->dcp,
											& objdimSubline,
											pbrkout );
				}	;
			}
		else
			{
			/* 3. Successful break inside subline */

			ReverseSaveBreakRecord (pdobj, brkkindPrev, breakSublineInside,
									cpBreak );

			return FinishBreakRegular (	ichnk, 
										pdobj, 
										cpBreak,
										&objdimSubline, 
										pbrkout );
			};
		};

}


/* R E V E R S E F I N D P R E V B R E A K C H U N K */
/*----------------------------------------------------------------------------
	%%Function: ReverseFindPrevBreakChunk
	%%Contact: antons

  
----------------------------------------------------------------------------*/

LSERR WINAPI ReverseFindPrevBreakChunk (

	PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
	PCPOSICHNK pcpoischnk,		/* (IN): place to start looking for break */
	BRKCOND brkcond,			/* (IN): recommmendation about the break after chunk */
	PBRKOUT pbrkout)			/* (OUT): results of breaking */
{

	if (pcpoischnk->ichnk == ichnkOutside)
		{
		return ReverseFindPrevBreakCore ( pclocchnk, 
										  pclocchnk->clschnk - 1, 
										  fTrue, 
										  0,
										  brkcond, 
										  pbrkout );
		}
	else
		{
		return ReverseFindPrevBreakCore ( pclocchnk, 
										  pcpoischnk->ichnk, 
										  fFalse, 
										  pcpoischnk->dcp,
										  brkcondPlease,
										  pbrkout );
		};
}


/* R E V E R S E F I N D N E X T B R E A K C O R E*/
/*----------------------------------------------------------------------------
	%%Function: ReverseFindNextBreakCore
	%%Contact: antons

  
----------------------------------------------------------------------------*/

LSERR ReverseFindNextBreakCore (
									 
	PCLOCCHNK	pclocchnk,		/* (IN): locchnk to break */
	DWORD		ichnk,			/* (IN): object to start looking for break */
	BOOL		fDcpOutside,	/* (IN): when true, start looking from outside */
	LSDCP		dcp,			/* (IN): starting dcp; valid only when fDcpOutside=False */
	BRKCOND		brkcond,		/* (IN): recommmendation about the break before ichnk */
	PBRKOUT		pbrkout )		/* (OUT): result of breaking */
{
	LSERR lserr;
	PDOBJ pdobj = pclocchnk->plschnk[ichnk].pdobj;

	if (fDcpOutside)
		{
		if ( brkcond != brkcondNever &&  
			! (pdobj->fDoNotBreakAround && brkcond == brkcondCan) )
			{
			/* Can break before ichnk */

			PutBreakBeforeObject (ichnk, pclocchnk, pbrkout);
			return lserrNone;
			}
		else
			{
			/* Try to break ichnk */

			return ReverseFindNextBreakCore (pclocchnk, ichnk, fFalse, 1, brkcond, pbrkout );
			}
		}
	else
		{
		/* Dcp is inside ichnk */

		LSCP cpTruncateSubline = TranslateDcpExternalToCpLimSubline (pdobj, dcp - 1);
		BOOL fSuccessful;
		LSCP cpBreak;
		OBJDIM objdimSubline;
		BRKPOS brkpos;

		Assert (dcp >= 1 && dcp <= pdobj->dcp);


		/* REVIEW (antons): I do not think that passing pclocchnk->lsfgi.urColumnMax is correct... */
		/*					need to be confirmed with IgorZv */

		lserr = LsFindNextBreakSubline (
						pdobj->plssubl, 
						pclocchnk->lsfgi.fFirstOnLine,
						cpTruncateSubline, 
						pclocchnk->lsfgi.urColumnMax,
						&fSuccessful, 
						&cpBreak, 
						&objdimSubline, 
						&brkpos);

		if (lserr != lserrNone)	return lserr;

		if (!fSuccessful)
			{
			/* Unsuccessful break */

			if (ichnk == pclocchnk->clschnk-1) /* Last object in chunk */
				{
				/* Review (AntonS): Better would be take objdimSubline */

				pbrkout->objdim = pclocchnk->plschnk[ichnk].pdobj->objdimAll;

				PutBreakUnsuccessful (pdobj, pbrkout);
	
				/* Break condition is not next => have to store break record */
				ReverseSaveBreakRecord ( pdobj, 
										brkkindNext,
										breakSublineAfter, pdobj->cpStart + pdobj->dcp );
				return lserrNone;
				}
			else if (pdobj->fDoNotBreakAround)
				{
				/* Try to break next object */

				return ReverseFindNextBreakCore (
												pclocchnk,
												ichnk+1,
												fTrue,
												0,
												brkcondCan,
												pbrkout );
				}
			else
				{
				/* Break after ichnk */

				PutBreakAtEndOfObject(ichnk, pclocchnk, pbrkout);

				ReverseSaveBreakRecord ( pclocchnk->plschnk[ichnk].pdobj, 
										 brkkindNext, 
										 breakSublineAfter,
										 pclocchnk->plschnk[ichnk].pdobj->cpStart +
										 pclocchnk->plschnk[ichnk].pdobj->dcp );
				return lserrNone;
				};
			}

		else if (brkpos == brkposAfterLastDnode)
			{
			/* Break after last dnode => reset dcp and break afetr ichnk */

			ReverseSaveBreakRecord (pdobj, brkkindNext, breakSublineInside, pdobj->cpStart + pdobj->dcp);

			return FinishBreakRegular ( ichnk, 
										pdobj, 
										pdobj->cpStart + pdobj->dcp, 
										& objdimSubline, 
										pbrkout );
			}

		else 
			{
			/* 3. Successful break inside subline */

			ReverseSaveBreakRecord (pdobj, brkkindNext, breakSublineInside, cpBreak);

			return FinishBreakRegular ( ichnk, 
										pdobj, 
										cpBreak, 
										& objdimSubline, 
										pbrkout);
			};
		}

} /* End of ReverseFindNextBreakCore */


/* R E V E R S E F I N D N E X T B R E A K C H U N K */
/*----------------------------------------------------------------------------
	%%Function: ReverseFindNextBreakChunk
	%%Contact: antons

  
----------------------------------------------------------------------------*/

LSERR WINAPI ReverseFindNextBreakChunk (

	PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
	PCPOSICHNK pcpoischnk,		/* (IN): place to start looking for break */
	BRKCOND brkcond,			/* (IN): recommmendation about the break after chunk */
	PBRKOUT pbrkout)			/* (OUT): results of breaking */
{
	LSERR lserr;

	if (pcpoischnk->ichnk == ichnkOutside)
		{
		lserr = ReverseFindNextBreakCore ( pclocchnk, 
										  0, 
										  fTrue, 
										  0,
										  brkcond,
										  pbrkout );

		}
	else
		{
		lserr = ReverseFindNextBreakCore ( pclocchnk, 
										  pcpoischnk->ichnk,
										  fFalse,
										  pcpoischnk->dcp,
										  brkcondPlease,
										  pbrkout );
		};

	return lserr;
}

			
/* R E V E R S E F O R C E B R E A K C H U N K */
/*----------------------------------------------------------------------------
	%%Function: ReverseForceBreak
	%%Contact: antons


----------------------------------------------------------------------------*/

LSERR WINAPI ReverseForceBreakChunk (

	PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
	PCPOSICHNK pcposichnkIn,	/* (IN): place to start looking for break */
	PBRKOUT pbrkout)			/* (OUT): results of breaking */
{

	POSICHNK posichnk = * pcposichnkIn;
	
	LSERR lserr;
	LSCP cpTruncateSubline;
	LSCP cpBreak;
	OBJDIM objdimSubline;
	PDOBJ pdobj;

	BRKPOS brkpos;

	if (posichnk.ichnk == ichnkOutside)
		{
		/* When left indent is bigger then Right Margin */
		posichnk.ichnk = 0;
		posichnk.dcp = 1;
		};
	
	Assert (posichnk.ichnk != ichnkOutside);

	pdobj = pclocchnk->plschnk[posichnk.ichnk].pdobj;

	if (pclocchnk->lsfgi.fFirstOnLine && (posichnk.ichnk == 0))
		{

		/* Object is the first on line (can not break before) */

		LSDCP dcp = posichnk.dcp;
		BOOL fEmpty;

		Assert (dcp >= 1 && dcp <= pdobj->dcp);

		lserr = LssbFIsSublineEmpty (pdobj->plssubl, &fEmpty);

		if (lserr != lserrNone) return lserr;
		
		if (fEmpty)
			{
			/* Can not ForceBreak empty subline */

			Assert (posichnk.ichnk == 0);
	
			PutBreakAtEndOfObject(0, pclocchnk, pbrkout);

			ReverseSaveBreakRecord ( pclocchnk->plschnk[0].pdobj, 
									 brkkindForce, 
									 breakSublineAfter,  
									 pclocchnk->plschnk[0].pdobj->cpStart +
									 pclocchnk->plschnk[0].pdobj->dcp );

			return lserrNone;
			};
			
		/* Subline is not empty => do force break */
		
		/* REVIEW (antons): The same as in Prev & Next Break */
		cpTruncateSubline = TranslateDcpExternalToCpLimSubline (pdobj, dcp - 1);
		
		lserr = LsForceBreakSubline ( 
						pdobj->plssubl, 
						pclocchnk->lsfgi.fFirstOnLine, 
						cpTruncateSubline, 
						pclocchnk->lsfgi.urColumnMax, 
						&cpBreak, 
						&objdimSubline,
						&brkpos );

		if (lserr != lserrNone) return lserr;

		/* REVIEW (antons): Check with IgorZv that Assert is correct ;-) */

		Assert (brkpos != brkposBeforeFirstDnode);

		if (brkpos == brkposAfterLastDnode)
			{
			/* We reset dcp so that closing brace stays on the same line */
			
			ReverseSaveBreakRecord (pdobj, brkkindForce, breakSublineInside, pdobj->cpStart + pdobj->dcp);

			return FinishBreakRegular ( posichnk.ichnk, 
										pdobj, 
										pdobj->cpStart + pdobj->dcp,  
										&objdimSubline, 
										pbrkout );
			}
		else
			{
			/* "Regular" ;-) ForceBreak inside subline */
			
			ReverseSaveBreakRecord (pdobj, brkkindForce, breakSublineInside, cpBreak);

			return FinishBreakRegular (  posichnk.ichnk, 
										 pdobj, 
										 cpBreak, 
										 &objdimSubline, 
										 pbrkout );
			}
		}

	else 
		{

		/* Can break before ichnk */

		PutBreakBeforeObject (posichnk.ichnk, pclocchnk, pbrkout);

		/*	Do not need to save break record when break "before", because it will be
			translated by manager to SetBreak (previous_dnode, ImposeAfter)	*/

		/* REVIEW (antons): It is strange that I have difference between break "before"
							not-first ichnk element and break "after" not-last. And only 
							in the second case I remember break record */

		return lserrNone;

		};

} /* ReverseForceBreakChunk */


/* R E V E R S E S E T B R E A K */
/*----------------------------------------------------------------------------
	%%Function: ReverseSetBreak
	%%Contact: antons


----------------------------------------------------------------------------*/

LSERR WINAPI ReverseSetBreak(
	PDOBJ pdobj,				/* (IN): dobj which is broken */
	BRKKIND brkkind,			/* (IN): Prev / Next / Force / Impose After */
	DWORD cBreakRecord,			/* (IN): size of array */
	BREAKREC *rgBreakRecord,	/* (IN): array of break records */
	DWORD *pcActualBreakRecord)	/* (IN): actual number of used elements in array */
{
	LSERR lserr = lserrNone;

	if (cBreakRecord < 1) return lserrInsufficientBreakRecBuffer;

	if (pdobj->fSuppressTrailingSpaces && pdobj->fFirstOnLine)
		{
		/* Robj is alone on the line => submit for trailing spaces */

		if (brkkind != brkkindImposedAfter)
			{
			BREAKSUBLINETYPE breakSublineType;
			LSCP cpBreak;
			ReverseGetBreakRecord (pdobj, brkkind, &breakSublineType, &cpBreak);

			if (cpBreak < (LSCP) (pdobj->cpStart + pdobj->dcp))
				{
				lserr = LsdnSubmitSublines(pdobj->pilsobj->plsc, pdobj->plsdnTop, 1, 
								&pdobj->plssubl, TRUE, TRUE, TRUE, TRUE, TRUE);

				if (lserr != lserrNone) return lserr;
				};
			};
		};

	if (brkkind == brkkindImposedAfter)
		{
		/* Break is imposed ater DNODE */

		lserr = LsSetBreakSubline ( pdobj->plssubl, 
									brkkindImposedAfter, 
									cBreakRecord-1, 
								    & rgBreakRecord [1], 
									pcActualBreakRecord );
		if (lserr != lserrNone) return lserr;

		Assert (*pcActualBreakRecord == 0);
		return lserrNone;
		}

	else
		{
		BREAKSUBLINETYPE breakSublineType;
		LSCP cpBreak;

		/* Result of previous Prev / Next or Force - used stored break record */

		ReverseGetBreakRecord (pdobj, brkkind, &breakSublineType, &cpBreak);

		Assert (breakSublineType == breakSublineAfter || breakSublineType == breakSublineInside);

		if (breakSublineType == breakSublineAfter)
			{
			/* type = breakSublineAfter */

			lserr = LsSetBreakSubline ( pdobj->plssubl, 
										brkkindImposedAfter, 
										cBreakRecord-1, 
					  				    & rgBreakRecord [1], 
										pcActualBreakRecord );
			if (lserr != lserrNone) return lserr;
										
			Assert (*pcActualBreakRecord == 0);
			return lserrNone;
			}

		else 
			{ 
			/* type = breakSublineInside */

			lserr = LsSetBreakSubline ( pdobj->plssubl, 
										brkkind, 
										cBreakRecord-1,
									    & rgBreakRecord [1], 
										pcActualBreakRecord );
			if (lserr != lserrNone) return lserr;

			/* Still possible to have break after object */

				
			if (cpBreak == (LSCP) (pdobj->cpStart + pdobj->dcp))
				{
				Assert (*pcActualBreakRecord == 0);
				return lserrNone;
				}
			else
				{
				(*pcActualBreakRecord) += 1;
	
				rgBreakRecord[0].idobj = pdobj->pilsobj->idobj;
				rgBreakRecord[0].cpFirst = pdobj->cpStartObj;

				return lserrNone;
				}
			};	

		}; 
}

/* R E V E R S E G E T S P E C I A L E F F E C T S I N S I D E */
/*----------------------------------------------------------------------------
	%%Function: ReverseGetSpecialEffectsInside
	%%Contact: ricksa

		GetSpecialEffectsInside

		.

----------------------------------------------------------------------------*/
LSERR WINAPI ReverseGetSpecialEffectsInside(
	PDOBJ pdobj,				/* (IN): dobj */
	UINT *pEffectsFlags)		/* (OUT): Special effects for this object */
{
	return LsGetSpecialEffectsSubline(pdobj->plssubl, pEffectsFlags);
}

/* R E V E R S E C A L C P R E S E N T A T I O N */
/*----------------------------------------------------------------------------
	%%Function: ReverseCalcPresentation
	%%Contact: ricksa

		CalcPresentation
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseCalcPresentation(
	PDOBJ pdobj,				/* (IN): dobj */
	long dup,					/* (IN): dup of dobj */
	LSKJUST lskjust,			/* (IN): Justification type */
	BOOL fLastVisibleOnLine )	/* (IN): Is this object last visible on line? */
{
	LSERR lserr;
	BOOL fDone;

	Unreferenced (lskjust);
	Unreferenced (fLastVisibleOnLine);	

	pdobj->dup = dup;

	/* Make sure that justification line has been made ready for presentation */
	lserr = LssbFDonePresSubline(pdobj->plssubl, &fDone);

	if ((lserrNone == lserr) && !fDone)
		{
		lserr = LsMatchPresSubline(pdobj->plssubl);
		}

	return lserr;
}

/* R E V E R S E Q U E R Y P O I N T P C P */
/*----------------------------------------------------------------------------
	%%Function: ReverseQueryPointPcp
	%%Contact: ricksa

		Map dup to dcp

----------------------------------------------------------------------------*/
LSERR WINAPI ReverseQueryPointPcp(
	PDOBJ pdobj,				/*(IN): dobj to query */
	PCPOINTUV ppointuvQuery,	/*(IN): query point (uQuery,vQuery) */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	Unreferenced(ppointuvQuery);

	return CreateQueryResult(pdobj->plssubl, pdobj->dup - 1, 0, plsqin, plsqout);
}

/* R E V E R S E Q U E R Y C P P P O I N T */
/*----------------------------------------------------------------------------
	%%Function: ReverseQueryCpPpoint
	%%Contact: ricksa

		Map dcp to dup

----------------------------------------------------------------------------*/
LSERR WINAPI ReverseQueryCpPpoint(
	PDOBJ pdobj,				/*(IN): dobj to query, */
	LSDCP dcp,					/*(IN): dcp for the query */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	Unreferenced(dcp);

	return CreateQueryResult(pdobj->plssubl, pdobj->dup - 1, 0, plsqin, plsqout);
}

	
/* R E V E R S E D I S P L A Y */
/*----------------------------------------------------------------------------
	%%Function: ReverseDisplay
	%%Contact: ricksa

		Display

		This calculates the positions of the various lines for the
		display and then displays them.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseDisplay(
	PDOBJ pdobj,
	PCDISPIN pcdispin)
{
	POINTUV pointuv;
	POINT pt;
	BOOL fDisplayed;
	LSERR lserr = LssbFDoneDisplay(pdobj->plssubl, &fDisplayed);

	if (lserr != lserrNone)
		{
		return lserr;
		}

	if (fDisplayed)
		{
		return lserrNone;
		}

	/* Calculate point to start displaying the subline. */
	pointuv.u = pdobj->dup - 1;
	pointuv.v = 0;

	LsPointXYFromPointUV(&pcdispin->ptPen, pdobj->lstflowL, &pointuv, &pt);

	/* display the Reverse line */

	return LsDisplaySubline(pdobj->plssubl, &pt, pcdispin->kDispMode, pcdispin->prcClip);

}

/* R E V E R S E D E S T R O Y D O B J */
/*----------------------------------------------------------------------------
	%%Function: ReverseDestroyDobj
	%%Contact: ricksa

		DestroyDobj

		Free all resources connected with the input dobj.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseDestroyDobj(
	PDOBJ pdobj)
{
	return ReverseFreeDobj(pdobj);
}

/* R E V E R S E E N U M */
/*----------------------------------------------------------------------------
	%%Function: ReverseEnum
	%%Contact: ricksa

		Enum

		Enumeration callback - passed to client.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseEnum(
	PDOBJ pdobj,				/*(IN): dobj to enumerate */
	PLSRUN plsrun,				/*(IN): from DNODE */
	PCLSCHP plschp,				/*(IN): from DNODE */
	LSCP cp,					/*(IN): from DNODE */
	LSDCP dcp,					/*(IN): from DNODE */
	LSTFLOW lstflow,			/*(IN): text flow*/
	BOOL fReverse,				/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,		/*(IN): */
	const POINT *pt,			/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,		/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun)				/*(IN): from DNODE, relevant iff fGeometryNeeded */
{
	return pdobj->pilsobj->pfnReverseEnum(pdobj->pilsobj->pols, plsrun, plschp, 
		cp, dcp, lstflow, fReverse, fGeometryNeeded, pt, pcheights, dupRun, 
			pdobj->lstflowO, pdobj->plssubl);
}
	
/* L S G E T R E V E R S E L S I M E T H O D S */
/*----------------------------------------------------------------------------
	%%Function: LsGetReverseLsimethods
	%%Contact: ricksa

		Initialize object handler for client.
	
----------------------------------------------------------------------------*/
LSERR WINAPI LsGetReverseLsimethods(
        LSIMETHODS *plsim)
{
	plsim->pfnCreateILSObj = ReverseCreateILSObj;
	plsim->pfnDestroyILSObj = ReverseDestroyILSObj;
	plsim->pfnSetDoc = ReverseSetDoc;
	plsim->pfnCreateLNObj = ReverseCreateLNObj;
	plsim->pfnDestroyLNObj = ReverseDestroyLNObj;
	plsim->pfnFmt = ReverseFmt;
	plsim->pfnFmtResume = ReverseFmtResume;
	plsim->pfnGetModWidthPrecedingChar = ObjHelpGetModWidthChar;
	plsim->pfnGetModWidthFollowingChar = ObjHelpGetModWidthChar;
	plsim->pfnTruncateChunk = ReverseTruncateChunk;
	plsim->pfnFindPrevBreakChunk = ReverseFindPrevBreakChunk;
	plsim->pfnFindNextBreakChunk = ReverseFindNextBreakChunk;
	plsim->pfnForceBreakChunk = ReverseForceBreakChunk;
	plsim->pfnSetBreak = ReverseSetBreak;
	plsim->pfnGetSpecialEffectsInside = ReverseGetSpecialEffectsInside;
	plsim->pfnFExpandWithPrecedingChar = ObjHelpFExpandWithPrecedingChar;
	plsim->pfnFExpandWithFollowingChar = ObjHelpFExpandWithFollowingChar;
	plsim->pfnCalcPresentation = ReverseCalcPresentation;
	plsim->pfnQueryPointPcp = ReverseQueryPointPcp;
	plsim->pfnQueryCpPpoint = ReverseQueryCpPpoint;
	plsim->pfnDisplay = ReverseDisplay;
	plsim->pfnDestroyDObj = ReverseDestroyDobj;
	plsim->pfnEnum = ReverseEnum;
	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\unixfunctions.c ===
#ifdef UNIX
void msls3_DllMain(void* handle, unsigned int reason, void* reserved)
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\textenum.c ===
#include "lsidefs.h"
#include "plsrun.h"
#include "pilsobj.h"
#include "txtils.h"
#include "txtobj.h"
#include "txtln.h"

//    %%Function:	EnumObjText
//    %%Contact:	victork
//
LSERR WINAPI EnumObjText(PDOBJ pdobj, PLSRUN plsrun, PCLSCHP plschp, LSCP cpFirst, LSDCP dcp, 
					LSTFLOW lstflow, BOOL fReverseOrder, BOOL fGeometryProvided, 
					const POINT* pptStart, PCHEIGHTS pheightsPres, long dupRun)
				  
{
	TXTOBJ* ptxtobj;
	PLNOBJ 	plnobj;
	PILSOBJ pilsobj;
	long* 	pdup;
	BOOL 	fCharWidthsProvided;

  	ptxtobj = (TXTOBJ*)pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	Unreferenced(plschp);

	if (ptxtobj->txtkind == txtkindTab)
		{
		return (*pilsobj->plscbk->pfnEnumTab)(pilsobj->pols, plsrun, cpFirst,
									&plnobj->pwch[ptxtobj->iwchFirst],
									ptxtobj->u.tab.wchTabLeader, lstflow, 
									fReverseOrder, fGeometryProvided,
									pptStart, pheightsPres, dupRun);
		}

	if (ptxtobj->txtf & txtfGlyphBased)
		{
		fCharWidthsProvided = fFalse;
		pdup = NULL;
		}
	else
		{
		fCharWidthsProvided = fTrue;
		pdup = &plnobj->pdup[ptxtobj->iwchFirst];
		}
		
	return (*pilsobj->plscbk->pfnEnumText)(pilsobj->pols, plsrun, cpFirst, dcp, 
									&plnobj->pwch[ptxtobj->iwchFirst],
									ptxtobj->iwchLim - ptxtobj->iwchFirst, lstflow, 
									fReverseOrder, fGeometryProvided,
									pptStart, pheightsPres, dupRun,
									fCharWidthsProvided, pdup);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\sobjhelp.c ===
/*
 *	sobjhelp.c 
 *
 *	This file contains implementations of methods that help
 *	common simple objects handle breaking and queries. All objects
 *	that use these routines must as the first entry in their dobj
 *	structure define an SObjCommon entry which these routines 
 *	will cast dobj's to.
 *
 */

#include "lsdefs.h"
#include "lsidefs.h"
#include "plocchnk.h"
#include "pposichn.h"
#include "posichnk.h"
#include "locchnk.h"
#include "brkcond.h"
#include "pbrko.h"
#include "brko.h"
#include "lsqout.h"
#include "lsqin.h"
#include "objhelp.h"
#include "sobjhelp.h"
#include "memory.h"
#include "lsmem.h"
#include "brkkind.h"

#define GET_DUR(pdobj) (((PSOBJHELP)pdobj)->objdimAll.dur)
#define GET_OBJDIM(pdobj) (((PSOBJHELP)pdobj)->objdimAll)
#define GET_DCP(pdobj) (((PSOBJHELP)pdobj)->dcp)
#define GET_MODAFTER(pdobj) (((PSOBJHELP)pdobj)->durModAfter)


/* F I L L B R E A K O U T */
/*----------------------------------------------------------------------------
	%%Function: FillBreakOut
	%%Contact: ricksa

		Fill break output record.
	
----------------------------------------------------------------------------*/
static void FillBreakOut(
	PDOBJ pdobj,				/* (IN): DOBJ for object */
	DWORD ichnk,				/* (IN): index in chunk */
	PBRKOUT pbrkout)			/* (OUT): break output record */
{
	pbrkout->posichnk.ichnk = ichnk;
	pbrkout->fSuccessful = fTrue;
	pbrkout->posichnk.dcp = GET_DCP(pdobj);
	pbrkout->objdim = GET_OBJDIM(pdobj);
	pbrkout->objdim.dur -= GET_MODAFTER(pdobj);
}

/* S O B J T R U N C A T E C H U N K */
/*----------------------------------------------------------------------------
	%%Function: SobjTruncateChunk
	%%Contact: ricksa

		.
	
----------------------------------------------------------------------------*/
LSERR WINAPI SobjTruncateChunk(
	PCLOCCHNK plocchnk,			/* (IN): locchnk to truncate */
	PPOSICHNK posichnk)			/* (OUT): truncation point */
{
	long urColumnMax = plocchnk->lsfgi.urColumnMax;
	long ur = plocchnk->ppointUvLoc[0].u;
	PDOBJ pdobj = NULL;
	DWORD i = 0;

	AssertSz(plocchnk->ppointUvLoc[0].u <= urColumnMax, 
		"SobjTruncateChunk - pen greater than column max");

	while (ur <= urColumnMax)
	{
		AssertSz((i < plocchnk->clschnk), "SobjTruncateChunk exceeded group of chunks");

		AssertSz(plocchnk->ppointUvLoc[i].u <= urColumnMax,
			"SobjTruncateChunk starting pen exceeds col max");

		pdobj = plocchnk->plschnk[i].pdobj;
		ur = plocchnk->ppointUvLoc[i].u + GET_DUR(pdobj);
		i++;
	}

	/* LS does not allow the truncation point to be at the beginning of the object */
	AssertSz(pdobj != NULL, "SobjTruncateChunk - pdobj NULL!");
	posichnk->ichnk = i - 1;
	posichnk->dcp = GET_DCP(pdobj);

	return lserrNone;
}

/* S O B J F I N D P R E V B R E A K C H U N K */
/*----------------------------------------------------------------------------
	%%Function: SobjFindPrevBreakChunk
	%%Contact: ricksa

		.
	
----------------------------------------------------------------------------*/
LSERR WINAPI SobjFindPrevBreakChunk(
	PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
	PCPOSICHNK pcpoischnk,		/* (IN): place to start looking for break */
	BRKCOND brkcond,			/* (IN): recommmendation about the break after chunk */
	PBRKOUT pbrkout)			/* (OUT): results of breaking */
{
	PDOBJ pdobj;
	DWORD ichnk = pcpoischnk->ichnk;

	AssertSz((int) brkcondPlease == 0, 
		"SobjFindPrevBreakChunk - brcondPlease != 0");

	ZeroMemory(pbrkout, sizeof(*pbrkout));

	if (ichnk == ichnkOutside)
	{
		ichnk = pclocchnk->clschnk - 1;
		pbrkout->posichnk.ichnk = ichnk;
		pdobj = pclocchnk->plschnk[ichnk].pdobj;

		if (GET_DUR(pdobj) - GET_MODAFTER(pdobj) 
				+ pclocchnk->ppointUvLoc[ichnk].u
					> pclocchnk->lsfgi.urColumnMax)
			{
			/* Are we at beginning of chunk? */
			if (ichnk > 0)
				{
				/* No - use the prior object in chunk */
				ichnk--;
				pdobj = pclocchnk->plschnk[ichnk].pdobj;
				}
			else
				{
				/* Yes. We need the break to happen before us. */
				pbrkout->posichnk.ichnk = ichnk;
				
				return lserrNone;
				}
			}

		if (brkcond != brkcondNever)
			{
			/* Break at end of chunk. */

			FillBreakOut(pdobj, ichnk, pbrkout);
			
			return lserrNone;
			}
			/* Else break at the beginning of last part of chunk */
	}

	if (ichnk >= 1)
	{
		/* Break before the current object */
		FillBreakOut(pclocchnk->plschnk[ichnk - 1].pdobj, ichnk - 1, pbrkout);
	}

	return lserrNone;
}

/* S O B J F I N D N E X T B R E A K C H U N K */
/*----------------------------------------------------------------------------
	%%Function: SobjFindNextBreakChunk
	%%Contact: ricksa

		.
	
----------------------------------------------------------------------------*/
LSERR WINAPI SobjFindNextBreakChunk(
	PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
	PCPOSICHNK pcpoischnk,		/* (IN): place to start looking for break */
	BRKCOND brkcond,			/* (IN): recommmendation about the break before chunk */
	PBRKOUT pbrkout)			/* (OUT): results of breaking */
{
	DWORD ichnk = pcpoischnk->ichnk;

	AssertSz((int) brkcondPlease == 0, 
		"SobjFindNextBreakChunk - brcondPlease != 0");

	ZeroMemory(pbrkout, sizeof(*pbrkout));

	if (ichnkOutside == ichnk)
		{
		if (brkcondNever != brkcond)	
			{
			pbrkout->fSuccessful = fTrue;

			return lserrNone;
			}

		/* can't break before so break after first item in chunk */
		ichnk = 0;
		}

	/* If not outside, we break at end of current dobj */
	FillBreakOut(pclocchnk->plschnk[ichnk].pdobj, ichnk, pbrkout);

	if (pclocchnk->clschnk - 1 == ichnk)
		{
		/* At the end of chunk. We can't say success for sure */
		pbrkout->fSuccessful = fFalse;
		}

	return lserrNone;
}

/* S O B J F O R C E B R E A K C H U N K */
/*----------------------------------------------------------------------------
	%%Function: SobjForceBreak
	%%Contact: ricksa

		Force Break

		.
----------------------------------------------------------------------------*/
LSERR WINAPI SobjForceBreakChunk(
	PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
	PCPOSICHNK pcposichnk,		/* (IN): place to start looking for break */
	PBRKOUT pbrkout)			/* (OUT): results of breaking */
{
	DWORD ichnk = pcposichnk->ichnk;

	ZeroMemory(pbrkout, sizeof(*pbrkout));
	pbrkout->posichnk.ichnk = ichnk;

	if (pclocchnk->lsfgi.fFirstOnLine && (0 == ichnk))
		{
		FillBreakOut(pclocchnk->plschnk[ichnk].pdobj, ichnk, pbrkout);
		}

	else if (ichnk == ichnkOutside)
		{
		/* Breaking after first object */
		FillBreakOut(pclocchnk->plschnk[0].pdobj, 0, pbrkout);
		}
	else if (ichnk != 0)
		{
		FillBreakOut(pclocchnk->plschnk[ichnk-1].pdobj, ichnk-1, pbrkout);
		}

	else /* Nothing, breaking before object */;		

	pbrkout->fSuccessful = fTrue; /* Force break is always successful! */

	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\tatenak.c ===
#include	"lsmem.h"
#include	"limits.h"
#include	"tatenak.h"
#include	"objhelp.h"
#include	"lscbk.h"
#include	"lsdevres.h"
#include	"pdobj.h"
#include	"objdim.h"
#include	"plssubl.h"
#include	"plsdnode.h"
#include	"pilsobj.h"
#include	"lscrsubl.h"
#include	"lssubset.h"
#include	"lsdnset.h"
#include	"zqfromza.h"
#include	"sobjhelp.h"
#include	"lsdocinf.h"
#include	"fmti.h"
#include	"posichnk.h"
#include	"locchnk.h"
#include	"lsdnfin.h"
#include	"brko.h"
#include	"lspap.h"
#include	"plspap.h"
#include	"lsqsubl.h"
#include	"dispi.h"
#include	"lsdssubl.h"
#include	"lsems.h"
#include	"dispmisc.h"
#include	"lstfset.h"
#include	"sobjhelp.h"

#define TATENAKAYOKO_ESC_CNT	1


struct ilsobj
{
    POLS				pols;
	LSCBK				lscbk;
	PLSC				plsc;
	LSDEVRES			lsdevres;
	LSESC				lsescTatenakayoko;
	TATENAKAYOKOCBK		tcbk;			/* Callbacks  to client application */
};


typedef struct SUBLINEDNODES
{
	PLSDNODE			plsdnStart;
	PLSDNODE			plsdnEnd;

} SUBLINEDNODES, *PSUBLINEDNODES;

struct dobj
{
	SOBJHELP			sobjhelp;			/* common simple object area */
	PILSOBJ				pilsobj;			/* ILS object */
	LSCP				cpStart;			/* Starting LS cp for object */
	LSTFLOW				lstflowParent;		/* text flow of the parent subline */
	LSTFLOW				lstflowSubline;		/* text flow in Tatenakayoko Subline 
												(must be Rotate90 [lstflowParent] */
	PLSSUBL				plssubl;			/* Handle to subline for Tatenakayoko */
	long				dvpDescentReserved;	/* Part of descent reserved for client */
	OBJDIM				objdimT;			/* Objdim of the Tatenakayoko */

	/* (dupSubline, duvSubline) is vector from starting point of Tatenakayoko to */
	/* the starting point of its subline in coordinate system of parent subline */

	long				dupSubline;			
	long				dvpSubline;

};

static const POINTUV pointuvOrigin00 = { 0, 0 };
static const POINT   pointOrigin00 = { 0, 0 };

/* F R E E D O B J */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoFreeDobj
	%%Contact: antons

		Free all resources associated with this Tatenakayoko dobj.
	
----------------------------------------------------------------------------*/
static LSERR TatenakayokoFreeDobj(PDOBJ pdobj)
{
	LSERR lserr = lserrNone;

	PILSOBJ pilsobj = pdobj->pilsobj;

	if (pdobj->plssubl != NULL)
		{
		lserr = LsDestroySubline(pdobj->plssubl);
		}

    pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pdobj);
	return lserr;
}


/* T A T E N A K A Y O K O C R E A T E I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoCreateILSObj
	%%Contact: ricksa

		CreateILSObj

		Create the ILS object for all Tatenakayoko objects.
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoCreateILSObj(
	POLS pols,				/* (IN): client application context */
	PLSC plsc,				/* (IN): LS context */
	PCLSCBK pclscbk,		/* (IN): callbacks to client application */
	DWORD idObj,			/* (IN): id of the object */
	PILSOBJ *ppilsobj)		/* (OUT): object ilsobj */
{
    PILSOBJ pilsobj;
	LSERR lserr;
	TATENAKAYOKOINIT tatenakayokoinit;
	tatenakayokoinit.dwVersion = TATENAKAYOKO_VERSION;

	/* Get initialization data */
	lserr = pclscbk->pfnGetObjectHandlerInfo(pols, idObj, &tatenakayokoinit);

	if (lserr != lserrNone)
		{
		*ppilsobj = NULL;
		return lserr;
		}

    pilsobj = pclscbk->pfnNewPtr(pols, sizeof(*pilsobj));

	if (pilsobj == NULL)
	{
		*ppilsobj = NULL;
		return lserrOutOfMemory;
	}

    pilsobj->pols = pols;
    pilsobj->lscbk = *pclscbk;
	pilsobj->plsc = plsc;
	pilsobj->lsescTatenakayoko.wchFirst = tatenakayokoinit.wchEndTatenakayoko;
	pilsobj->lsescTatenakayoko.wchLast = tatenakayokoinit.wchEndTatenakayoko;
	pilsobj->tcbk = tatenakayokoinit.tatenakayokocbk;

	*ppilsobj = pilsobj;
	return lserrNone;
}

/* T A T E N A K A Y O K O D E S T R O Y I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoDestroyILSObj
	%%Contact: ricksa

		DestroyILSObj

		Free all resources assocaiated with Tatenakayoko ILS object.
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoDestroyILSObj(
	PILSOBJ pilsobj)			/* (IN): object ilsobj */
{
	pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pilsobj);
	return lserrNone;
}

/* T A T E N A K A Y O K O S E T D O C */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoSetDoc
	%%Contact: ricksa

		SetDoc

		Keep track of device information for scaling purposes.
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoSetDoc(
	PILSOBJ pilsobj,			/* (IN): object ilsobj */
	PCLSDOCINF pclsdocinf)		/* (IN): initialization data of the document level */
{
	pilsobj->lsdevres = pclsdocinf->lsdevres;
	return lserrNone;
}


/* T A T E N A K A Y O K O C R E A T E L N O B J */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoCreateLNObj
	%%Contact: ricksa

		CreateLNObj

		Create the Line Object for the Tatenakayoko. No real need for a line
		object so don't allocated it.
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoCreateLNObj(
	PCILSOBJ pcilsobj,			/* (IN): object ilsobj */
	PLNOBJ *pplnobj)			/* (OUT): object lnobj */
{
	*pplnobj = (PLNOBJ) pcilsobj;
	return lserrNone;
}

/* T A T E N A K A Y O K O D E S T R O Y L N O B J */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoDestroyLNObj
	%%Contact: ricksa

		DestroyLNObj

		Frees resources associated with the Tatenakayoko line object. Since
		there isn't any this is a no-op.
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoDestroyLNObj(
	PLNOBJ plnobj)				/* (OUT): object lnobj */

{
	Unreferenced(plnobj);
	return lserrNone;
}



/* T A T E N A K A Y O K O F M T */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoFmt
	%%Contact: ricksa

		Fmt

		Format the Tatenakayoko object. 
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoFmt(
    PLNOBJ plnobj,				/* (IN): object lnobj */
    PCFMTIN pcfmtin,			/* (IN): formatting input */
    FMTRES *pfmtres)			/* (OUT): formatting result */
{
	static LSTFLOW lstflowRotate90[] = 	
		{
		lstflowNE, /* [ lstflowES ] */
		lstflowNW, /* [ lstflowEN ] */
		lstflowEN, /* [ lstflowSE ] */
		lstflowES, /* [ lstflowSW ] */
		lstflowSE, /* [ lstflowWS ] */
		lstflowSW, /* [ lstflowWN ] */
		lstflowWN, /* [ lstflowNE ] */
		lstflowWS  /* [ lstflowNW ] */
		};

	PDOBJ pdobj;
	LSERR lserr;
	PILSOBJ pilsobj = (PILSOBJ) plnobj;
	POLS pols = pilsobj->pols;
	LSCP cpStartMain = pcfmtin->lsfgi.cpFirst + 1;
	LSCP cpOut;
	LSTFLOW lstflow = pcfmtin->lsfgi.lstflow;
	FMTRES fmtres;
	FMTRES fmtr = fmtrCompletedRun;

    /*
     * Allocate the DOBJ
     */

    pdobj = pilsobj->lscbk.pfnNewPtr(pols, sizeof(*pdobj));

    if (NULL == pdobj)
		{
		return lserrOutOfMemory;
		}

	ZeroMemory(pdobj, sizeof(*pdobj));
	pdobj->pilsobj = pilsobj;
	pdobj->cpStart = pcfmtin->lsfgi.cpFirst;
	pdobj->lstflowParent = lstflow;
	pdobj->lstflowSubline = lstflowRotate90 [lstflow];

	/*
	 * Build main line of text
	 */
	lserr = FormatLine(pilsobj->plsc, cpStartMain, LONG_MAX, pdobj->lstflowSubline,
		&pdobj->plssubl, TATENAKAYOKO_ESC_CNT, &pilsobj->lsescTatenakayoko,  
			&pdobj->objdimT, &cpOut, NULL, NULL, &fmtres);

	if (lserr != lserrNone)
		{
		TatenakayokoFreeDobj (pdobj);
		return lserr;
		}

	Assert (fmtres != fmtrExceededMargin);

	/* 
	 *	Calculate the object dimensions.
	 */
	lserr = pilsobj->tcbk.pfnGetTatenakayokoLinePosition(pols, pdobj->cpStart, pdobj->lstflowParent,
		pcfmtin->lsfrun.plsrun, pdobj->objdimT.dur, 
			&pdobj->sobjhelp.objdimAll.heightsRef, 
				&pdobj->sobjhelp.objdimAll.heightsPres, 
					&pdobj->dvpDescentReserved);

	if (lserr != lserrNone)
		{
		TatenakayokoFreeDobj (pdobj);
		return lserr;
		}

	/* set width of Tatenakayoko relative to text flow of line that contains it. */
	pdobj->sobjhelp.objdimAll.dur = pdobj->objdimT.heightsRef.dvAscent 
		+ pdobj->objdimT.heightsRef.dvDescent;

	/*
	 * Note: the + 2 in the following is because cpStartMain is + 1 from the
	 * actual start of the object (it is the cpStartMain of the Tatenakayoko
	 * data) and additional + 1 for the escape character at the end of the
	 * tatenakayoko.
	 */
	pdobj->sobjhelp.dcp = cpOut - cpStartMain + 2;
	
	lserr = LsdnFinishRegular(pilsobj->plsc, pdobj->sobjhelp.dcp, 
		pcfmtin->lsfrun.plsrun, pcfmtin->lsfrun.plschp, pdobj, 
			&pdobj->sobjhelp.objdimAll);
		
	if (lserr != lserrNone)
		{
		TatenakayokoFreeDobj (pdobj);
		return lserr;
		}

	lserr = LsdnSetRigidDup ( pilsobj->plsc, pcfmtin->plsdnTop,
							  pdobj->objdimT.heightsPres.dvAscent + 
							  pdobj->objdimT.heightsPres.dvDescent );

	if (lserr != lserrNone)
		{
		TatenakayokoFreeDobj (pdobj);
		return lserr;
		}
	
	if (pcfmtin->lsfgi.urPen + pdobj->sobjhelp.objdimAll.dur > pcfmtin->lsfgi.urColumnMax)
		{
		fmtr = fmtrExceededMargin;
		}

	*pfmtres = fmtr;

	return lserrNone;
}



/* T A T E N A K A Y O K O G E T S P E C I A L E F F E C T S I N S I D E */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoGetSpecialEffectsInside
	%%Contact: ricksa

		GetSpecialEffectsInside

		.

----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoGetSpecialEffectsInside(
	PDOBJ pdobj,				/* (IN): dobj */
	UINT *pEffectsFlags)		/* (OUT): Special effects for this object */
{
	return LsGetSpecialEffectsSubline(pdobj->plssubl, pEffectsFlags);
}


/* G E T U F R O M L S T F L O W */
/*----------------------------------------------------------------------------
	%%Function: GetUFromLstflow
	%%Contact: antons

		GetUFromLstflow

	Gets XY vector corresponding to U-direction of lstflow.

----------------------------------------------------------------------------*/

void GetUFromLstflow (LSTFLOW lstflow, POINT * ppoint)
{
	POINTUV ptOneU = {1, 0};

	LsPointXYFromPointUV (& pointOrigin00, lstflow, &ptOneU, ppoint);
}


/* G E T V F R O M L S T F L O W */
/*----------------------------------------------------------------------------
	%%Function: GetVFromLstflow
	%%Contact: antons

		GetVFromLstflow

	Gets XY vector corresponding to V-direction of lstflow.

----------------------------------------------------------------------------*/

void GetVFromLstflow (LSTFLOW lstflow, POINT * ppoint)
{
	POINTUV ptOneV = {0, 1};

	LsPointXYFromPointUV (& pointOrigin00, lstflow, &ptOneV, ppoint);
}


/* T A T E N A K A Y O K O C A L C P R E S E N T A T I O N */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoCalcPresentation
	%%Contact: antons

		CalcPresentation
	
		This just makes the line match the calculated presentation of the line.
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoCalcPresentation(
	PDOBJ pdobj,				/* (IN): dobj */
	long dup,					/* (IN): dup of dobj */
	LSKJUST lskjust, 			/* (IN): Justification type */
	BOOL fLastVisibleOnLine )	/* (IN): Is this object last visible on line? */
{
	
	POINTUV ptTemp;
	POINTUV pointuv;

	POINT ptSublineV;
	POINT ptParentU;

	Unreferenced (fLastVisibleOnLine);
	Unreferenced (lskjust);

	pdobj->dupSubline = 0;
	pdobj->dvpSubline = 0;

	GetUFromLstflow (pdobj->lstflowParent, &ptParentU);
	GetVFromLstflow (pdobj->lstflowSubline, &ptSublineV);

	/* Assert that Main U is parallel to Subline V */

	Assert (ptParentU.x * ptSublineV.y - ptParentU.y * ptSublineV.x == 0);

	pointuv.u = - (pdobj->sobjhelp.objdimAll.heightsPres.dvDescent 
		- pdobj->dvpDescentReserved);

	pointuv.v = 0;

	LsPointUV2FromPointUV1 (pdobj->lstflowSubline, & pointuvOrigin00, & pointuv, 
							pdobj->lstflowParent, & ptTemp);

	pdobj->dupSubline += ptTemp.u;
	pdobj->dvpSubline += ptTemp.v;

	if ((ptParentU.x == ptSublineV.x) && (ptParentU.y == ptSublineV.y))
		{
		pdobj->dupSubline += pdobj->objdimT.heightsPres.dvDescent;
		}
	else
		{
		pdobj->dupSubline += pdobj->objdimT.heightsPres.dvAscent;
		}


	Unreferenced(dup);

	return LsMatchPresSubline(pdobj->plssubl);

}

/* T A T E N A K A Y O K O Q U E R Y P O I N T P C P */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoQueryPointPcp
	%%Contact: ricksa

		Map dup to dcp

		This just passes the offset of the subline to the helper function
		which will format the output.

----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoQueryPointPcp(
	PDOBJ pdobj,				/*(IN): dobj to query */
	PCPOINTUV ppointuvQuery,	/*(IN): query point (uQuery,vQuery) */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	Unreferenced(ppointuvQuery);

	return CreateQueryResult
		(pdobj->plssubl, pdobj->dupSubline, pdobj->dvpSubline, plsqin, plsqout);
}
	
/* T A T E N A K A Y O K O Q U E R Y C P P P O I N T */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoQueryCpPpoint
	%%Contact: ricksa

		Map dcp to dup

		This just passes the offset of the subline to the helper function
		which will format the output.

----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoQueryCpPpoint(
	PDOBJ pdobj,				/*(IN): dobj to query */
	LSDCP dcp,					/*(IN): dcp for the query */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	Unreferenced(dcp);

	return CreateQueryResult(pdobj->plssubl, 
		pdobj->dupSubline, pdobj->dvpSubline, plsqin, plsqout);

}


/* T A T E N A K A Y O K O D I S P L A Y */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoDisplay
	%%Contact: ricksa

		Display

		This calculates the position of the subline for the
		display and then displays it.
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoDisplay(
	PDOBJ pdobj,				/*(IN): dobj to display */
	PCDISPIN pcdispin)			/*(IN): info for display */
{
	POINT ptLine;
	POINTUV ptAdd;

	ptAdd.u = pdobj->dupSubline;
	ptAdd.v = pdobj->dvpSubline;

	LsPointXYFromPointUV(&pcdispin->ptPen, pdobj->lstflowParent, &ptAdd, &ptLine);

	/* display the Tatenakayoko line */

	return LsDisplaySubline(pdobj->plssubl, &ptLine, pcdispin->kDispMode, 
		pcdispin->prcClip);

}

/* T A T E N A K A Y O K O D E S T R O Y D O B J */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoDestroyDobj
	%%Contact: ricksa

		DestroyDobj

		Free all resources connected with the input dobj.
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoDestroyDobj(
	PDOBJ pdobj)				/*(IN): dobj to destroy */
{
	return TatenakayokoFreeDobj(pdobj);
}

/* T A T E N A K A Y O K O E N U M */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoEnum
	%%Contact: ricksa

		Enum

		Enumeration callback - passed to client.
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoEnum(
	PDOBJ pdobj,				/*(IN): dobj to enumerate */
	PLSRUN plsrun,				/*(IN): from DNODE */
	PCLSCHP plschp,				/*(IN): from DNODE */
	LSCP cp,					/*(IN): from DNODE */
	LSDCP dcp,					/*(IN): from DNODE */
	LSTFLOW lstflow,			/*(IN): text flow*/
	BOOL fReverse,				/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,		/*(IN): */
	const POINT *pt,			/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,		/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun)				/*(IN): from DNODE, relevant iff fGeometryNeeded */
{
	return pdobj->pilsobj->tcbk.pfnTatenakayokoEnum(pdobj->pilsobj->pols, plsrun,
		plschp, cp, dcp, lstflow, fReverse, fGeometryNeeded, pt, pcheights, 
			dupRun, pdobj->lstflowParent, pdobj->plssubl);
}

/* T A T E N A K A Y O K O H A N D L E R I N I T */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoHandlerInit
	%%Contact: ricksa

		Initialize global Tatenakayoko data and return LSIMETHODS.
	
----------------------------------------------------------------------------*/
LSERR WINAPI LsGetTatenakayokoLsimethods(
	LSIMETHODS *plsim)
{
	plsim->pfnCreateILSObj = TatenakayokoCreateILSObj;
	plsim->pfnDestroyILSObj = TatenakayokoDestroyILSObj;
	plsim->pfnSetDoc = TatenakayokoSetDoc;
	plsim->pfnCreateLNObj = TatenakayokoCreateLNObj;
	plsim->pfnDestroyLNObj = TatenakayokoDestroyLNObj;
	plsim->pfnFmt = TatenakayokoFmt;
	plsim->pfnFmtResume = ObjHelpFmtResume;
	plsim->pfnGetModWidthPrecedingChar = ObjHelpGetModWidthChar;
	plsim->pfnGetModWidthFollowingChar = ObjHelpGetModWidthChar;
	plsim->pfnTruncateChunk = SobjTruncateChunk;
	plsim->pfnFindPrevBreakChunk = SobjFindPrevBreakChunk;
	plsim->pfnFindNextBreakChunk = SobjFindNextBreakChunk;
	plsim->pfnForceBreakChunk = SobjForceBreakChunk;
	plsim->pfnSetBreak = ObjHelpSetBreak;
	plsim->pfnGetSpecialEffectsInside = TatenakayokoGetSpecialEffectsInside;
	plsim->pfnFExpandWithPrecedingChar = ObjHelpFExpandWithPrecedingChar;
	plsim->pfnFExpandWithFollowingChar = ObjHelpFExpandWithFollowingChar;
	plsim->pfnCalcPresentation = TatenakayokoCalcPresentation;
	plsim->pfnQueryPointPcp = TatenakayokoQueryPointPcp;
	plsim->pfnQueryCpPpoint = TatenakayokoQueryCpPpoint;
	plsim->pfnDisplay = TatenakayokoDisplay;
	plsim->pfnDestroyDObj = TatenakayokoDestroyDobj;
	plsim->pfnEnum = TatenakayokoEnum;
	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\ruby.c ===
#include	"lsmem.h"
#include	"limits.h"
#include	"ruby.h"
#include	"objhelp.h"
#include	"lscbk.h"
#include	"lsdevres.h"
#include	"pdobj.h"
#include	"objdim.h"
#include	"plssubl.h"
#include	"plsdnode.h"
#include	"pilsobj.h"
#include	"lscrsubl.h"
#include	"lssubset.h"
#include	"lsdnset.h"
#include	"zqfromza.h"
#include	"lsdocinf.h"
#include	"fmti.h"
#include	"posichnk.h"
#include	"locchnk.h"
#include	"lsdnfin.h"
#include	"brko.h"
#include	"lspap.h"
#include	"plspap.h"
#include	"lsqsubl.h"
#include	"dispi.h"
#include	"lsdssubl.h"
#include	"lsems.h"
#include	"dispmisc.h"
#include	"lstfset.h"
#include	"lsqout.h"
#include	"lsqin.h"
#include	"sobjhelp.h"
#include	"brkkind.h"


#define RUBY_MAIN_ESC_CNT	1
#define RUBY_RUBY_ESC_CNT	1


struct ilsobj
{
    POLS				pols;
	LSCBK				lscbk;
	PLSC				plsc;
	LSDEVRES			lsdevres;
	RUBYSYNTAX			rubysyntax;
	LSESC				lsescMain;
	LSESC				lsescRuby;
	RUBYCBK				rcbk;			/* Callbacks  to client application */

};

typedef struct SUBLINEDNODES
{
	PLSDNODE			plsdnStart;
	PLSDNODE			plsdnEnd;

} SUBLINEDNODES, *PSUBLINEDNODES;

struct dobj
{	
	SOBJHELP			sobjhelp;			/* common area for simple objects */	
	PILSOBJ				pilsobj;			/* ILS object */
	PLSDNODE			plsdn;				/* DNODE for this object */
	LSCP				cpStart;			/* Starting LS cp for object */
	LSTFLOW				lstflow;			/* text flow for the Ruby object */
	PLSRUN				plsrunFirstRubyChar;/* plsrun for first Ruby line char */
	PLSRUN				plsrunLastRubyChar;	/* plsrun for last Ruby line char */
	LSCP				cpStartRuby;		/* first cp of the ruby line */
	LSCP				cpStartMain;		/* first cp of the main line */
	PLSSUBL				plssublMain;		/* Handle to first subline */
	OBJDIM				objdimMain;			/* Objdim of first subline */
	PLSSUBL				plssublRuby;		/* Handle to second line */
	OBJDIM				objdimRuby;			/* Objdim of second line */
	long				dvpMainOffset;		/* Offset of main line's baseline */
											/* from baseline ofRuby object. */
	long				dvpRubyOffset;		/* Offset of Ruby line's baseline */
											/* from baseline of Ruby object. */
	long				dvrRubyOffset;		/* Offset of Ruby line's baseline */
											/* from baseline of Ruby object in reference units. */
	enum rubycharjust	rubycharjust;		/* Type of centering */
	long				durSplWidthMod;		/* special Ruby width mod if special behavior
											 * when Ruby is on the end of the line */
	BOOL				fFirstOnLine:1;		/* TRUE = object is first on line */
	BOOL				fSpecialLineStartEnd:1;/* Special Begin of Line or End of */
											/* Line behavior. */
	BOOL				fModAfterCalled:1;	/* Whether mod width after has been called */
	long				durDiff;			/* Amount of overhang of ruby line if */
											/* ruby line is longer, otherwise amount */
											/* of underhang if main text is longer. */
	long				durModBefore;		/* Mod width distance before */
	long				dupOffsetMain;		/* Offset from start of object of main line. */
	long				dupOffsetRuby;		/* Offset from start of object of ruby line. */
	SUBLINEDNODES		sublnlsdnMain;		/* Start end dnodes of main line */
	SUBLINEDNODES		sublnlsdnRuby;		/* Start end dnodes of ruby line */
};



/* F R E E D O B J */
/*----------------------------------------------------------------------------
	%%Function: RubyFreeDobj
	%%Contact: antons

		Free all resources associated with this Ruby dobj.
	
----------------------------------------------------------------------------*/
static LSERR RubyFreeDobj (PDOBJ pdobj)
{
	LSERR lserr1 = lserrNone;
	LSERR lserr2 = lserrNone;

	PILSOBJ pilsobj = pdobj->pilsobj;

	if (pdobj->plssublMain != NULL)
		{
		lserr1 = LsDestroySubline(pdobj->plssublMain);
		}

	if (pdobj->plssublRuby != NULL)
		{
		lserr2 = LsDestroySubline(pdobj->plssublRuby);
		}

    pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pdobj);

	if (lserr1 != lserrNone) 
		{
		return lserr1;
		}
	else
		{
		return lserr2;
		}

}


/* R U B Y  F M T  F A I L E D */
/*----------------------------------------------------------------------------
	%%Function: RubyFmtFailed
	%%Contact: antons

		Could not create Ruby DOBJ due to error. 
		IN:	pdobj of partially created Ruby; NULL if pdobj was not yet allocated;
		IN:	lserr from the last error
		
----------------------------------------------------------------------------*/
static LSERR RubyFmtFailed (PDOBJ pdobj, LSERR lserr)
{
	if (pdobj != NULL) RubyFreeDobj (pdobj); /* Works with parially-filled DOBJ */

	return lserr;
}


/* G E T R U N S F O R S U B L I N E */
/*----------------------------------------------------------------------------
	%%Function: GetRunsForSubline
	%%Contact: ricksa

		This gets all the runs for a particular subline.
----------------------------------------------------------------------------*/
static LSERR GetRunsForSubline(
	PILSOBJ pilsobj,			/* (IN): object ILS */
	PLSSUBL plssubl,			/* (IN): subline to get the runs from */
	DWORD *pcdwRuns,			/* (OUT): count of runs for subline */
	PLSRUN **ppplsrun)			/* (OUT): array of plsruns for subline */
{
	DWORD cdwRuns;

	LSERR lserr = LssbGetNumberDnodesInSubline(plssubl, &cdwRuns);

	*ppplsrun = NULL; /* No runs or in case of error */

	if (lserr != lserrNone) return lserr;

	if (cdwRuns != 0)
		{
		
	    *ppplsrun = (PLSRUN *) pilsobj->lscbk.pfnNewPtr(pilsobj->pols,
			sizeof(PLSRUN) * cdwRuns);

		if (*ppplsrun == NULL) return lserrOutOfMemory;

		lserr = LssbGetPlsrunsFromSubline(plssubl, cdwRuns, *ppplsrun);

		if (lserr != lserrNone)
			{
			pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, *ppplsrun);
			
			*ppplsrun = NULL;
			return lserr;
			}
		}

	*pcdwRuns = cdwRuns;

	return lserrNone;
}

/* D I S T R I B U T E T O L I N E */
/*----------------------------------------------------------------------------
	%%Function: DistributeToLine
	%%Contact: ricksa

		Distribute space to line & get new size of line.
----------------------------------------------------------------------------*/
static LSERR DistributeToLine(
	PLSC plsc,					/* (IN): LS context */
	SUBLINEDNODES *psublnlsdn,	/* (IN): start/end dnode for subline */
	long durToDistribute,		/* (IN): amount to distribute*/
	PLSSUBL plssubl,			/* (IN): subline for distribution */
	POBJDIM pobjdim)			/* (OUT): new size of line dimesions */
{
	LSERR lserr = LsdnDistribute(plsc, psublnlsdn->plsdnStart, 
		psublnlsdn->plsdnEnd, durToDistribute);
	LSTFLOW lstflowUnused;

	if (lserrNone == lserr)
		{
		/* recalculate objdim for line */
		lserr = LssbGetObjDimSubline(plssubl, &lstflowUnused, pobjdim);
		}

	return lserr;
}


/* D O R U B Y S P A C E D I S T R I B U T I O N */
/*----------------------------------------------------------------------------
	%%Function: DoRubySpaceDistribution
	%%Contact: ricksa

		Do the ruby space distribution to handle overhangs.
----------------------------------------------------------------------------*/
static LSERR DoRubySpaceDistribution(
	PDOBJ pdobj)
{
	long durDiff = 0; 
	long dur = pdobj->objdimMain.dur - pdobj->objdimRuby.dur;
	long durAbs = dur;
	PLSSUBL plssubl;
	LSDCP dcp;
	PILSOBJ pilsobj = pdobj->pilsobj;
	LSERR lserr = lserrNone;
	SUBLINEDNODES *psublnlsdn;
	POBJDIM pobjdim;
	BOOL fSpecialJust;
	long durToDistribute;

	if ((0 == pdobj->objdimMain.dur)
		|| (0 == pdobj->objdimRuby.dur)
		|| (0 == dur))
		{
		/* Can't distribute space on a shorter line so we are done. */
		return lserrNone;
		}

	if (dur > 0)
		{
		/* Main line is longer - distibute in Ruby pronunciation line */

		/*
		 *	According to the JIS spec, special alignment only occurs when the 
		 *	Ruby text is longer than the main text. Therefore, if the main
		 *	line is longer we turn of the special aligment flag here.
		 */
		pdobj->fSpecialLineStartEnd = FALSE;
		plssubl = pdobj->plssublRuby;
		psublnlsdn = &pdobj->sublnlsdnRuby;
		pobjdim = &pdobj->objdimRuby;
		}
	else
		{
		/* Ruby pronunciation line is longer - distibute in main line */
		plssubl = pdobj->plssublMain;
		psublnlsdn = &pdobj->sublnlsdnMain;
		pobjdim = &pdobj->objdimMain;
		durAbs = -dur;
		}

	fSpecialJust = FALSE;
//	fSpecialJust = 
//		pdobj->fSpecialLineStartEnd && pdobj->fFirstOnLine;

	if (!fSpecialJust)
		{
		switch (pdobj->rubycharjust)
			{
			case rcj121:
				lserr = LssbGetVisibleDcpInSubline(plssubl, &dcp);

				Assert (dcp > 0);

				if (lserr != lserrNone)
					{
					break;
					}

				dcp *= 2;

				if (durAbs >= (long) dcp)
					{
					durDiff = durAbs / dcp;

					/* Note: distribution amount is amount excluding 
					 * beginning and end.
					 */
					lserr = DistributeToLine(pilsobj->plsc, psublnlsdn,
						durAbs - 2 * durDiff, plssubl, pobjdim);

					if (dur < 0)
						{
						durDiff = - durDiff;
						}

					break;
					}

				/*
				 * Intention fall through in the case where the overhang will
				 * be less than one pixel.
				 */

			case rcj010:
				AssertSz(0 == durDiff, 
					"DoRubySpaceDistribution rcj010 unexpected value for durDiff");

				lserr = LssbGetVisibleDcpInSubline(plssubl, &dcp);

				Assert (dcp > 0);

				if (lserr != lserrNone)
					{
					break;
					}
				
				if (dcp != 1)
					{
					lserr = DistributeToLine(pilsobj->plsc, psublnlsdn,
						durAbs, plssubl, pobjdim);
					break;
					}

				/*
				 * Intentional fall through to center case.
				 * Only one character in line so we just center it.
				 */
	
			case rcjCenter:
				durDiff = dur / 2;
				break;

			case rcjLeft:
				durDiff = 0;
				break;

			case rcjRight:
				durDiff = dur;
				break;

			default:
				AssertSz(FALSE, 
					"DoRubySpaceDistribution - invalid adjustment value");
			}
		}
	else
		{
		/* First on line & special justification used. */
		LSERR lserr = LssbGetVisibleDcpInSubline(plssubl, &dcp);

		Assert (dcp > 0);

		if (lserrNone == lserr)
		{
			if (durAbs >= (long) dcp)
				{
				durDiff = durAbs / dcp;
				}

				durToDistribute = durAbs - durDiff;

				if (dur < 0)
					{
					durDiff = -durDiff;
					}

			lserr = DistributeToLine(pilsobj->plsc, psublnlsdn, 
				durToDistribute, plssubl, pobjdim);
			}
		}

	pdobj->durDiff = durDiff;
	return lserr;
}

/* G E T M A I N P O I N T */
/*----------------------------------------------------------------------------
	%%Function: GetMainPoint
	%%Contact: ricksa

		This gets the point for the baseline of the main line of text in
		the Ruby object.
		
----------------------------------------------------------------------------*/
static LSERR GetMainPoint(
	PDOBJ pdobj,				/*(IN): dobj for Ruby */
	const POINT *pptBase,		/*(IN): point for baseline. */
	LSTFLOW lstflow,			/*(IN): lstflow at baseline of object */
	POINT *pptLine)				/*(OUT): point for baseline of main text */
{	
	POINTUV pointuv;
	pointuv.u = pdobj->dupOffsetMain;
	pointuv.v = pdobj->dvpMainOffset;
	return LsPointXYFromPointUV(pptBase, lstflow, &pointuv, pptLine);
}

/* G E T M A I N P O I N T */
/*----------------------------------------------------------------------------
	%%Function: GetMainPoint
	%%Contact: ricksa

		This gets the point for the baseline of the main line of text in
		the Ruby object.
		
----------------------------------------------------------------------------*/
static LSERR GetRubyPoint(
	PDOBJ pdobj,				/*(IN): dobj for Ruby */
	const POINT *pptBase,		/*(IN): point for baseline. */
	LSTFLOW lstflow,			/*(IN): lstflow at baseline of object */
	POINT *pptLine)				/*(OUT): point for baseline of ruby text */
{	
	POINTUV pointuv;
	pointuv.u = pdobj->dupOffsetRuby;
	pointuv.v = pdobj->dvpRubyOffset;
	return LsPointXYFromPointUV(pptBase, lstflow, &pointuv, pptLine);
}

/* M O D W I D T H H A N D L E R */
/*----------------------------------------------------------------------------
	%%Function: ModWidthHandler
	%%Contact: ricksa

		This gets the adjustment for the Ruby object and the text character
		and then adjusts the Ruby object's size based on the response from
		the client.
----------------------------------------------------------------------------*/
static LSERR ModWidthHandler(
	PDOBJ pdobj,				/* (IN): dobj for Ruby */
	enum rubycharloc rubyloc,	/* (IN): whether char is before or after */
	PLSRUN plsrun,				/* (IN): run for character */
	WCHAR wch,					/* (IN): character before or after Ruby object */
	MWCLS mwcls,				/* (IN): mod width class for for character */
	PCHEIGHTS pcheightsRef,		/* (IN): height of character */
	PLSRUN plsrunRubyObject,	/* (IN): plsrun for the ruby object */
	PLSRUN plsrunRubyText,		/* (IN): plsrun for ruby text */
	long durOverhang,			/* (IN): maximum amount of overhang */
	long *pdurAdjText,			/* (OUT): amount to change text object size */
	long *pdurRubyMod)			/* (OUT): amount to change ruby object */
{
	LSERR lserr;
	PILSOBJ pilsobj = pdobj->pilsobj;
	LSEMS lsems;
	long durModRuby = 0;
	long durMaxOverhang = 0;

	/*
	 * Ruby can overhang only if it is longer and if preceeding/succeeding
	 * character is of lesser or equal height than the bottom of the Ruby
	 * pronunciation line.
	 */
	if ((durOverhang < 0) 
		&& (pcheightsRef->dvAscent <= 
			(pdobj->dvrRubyOffset - pdobj->objdimRuby.heightsRef.dvDescent)))
		{
		/* Ruby line overhangs - get max to overhang */
		lserr = pilsobj->lscbk.pfnGetEms(pilsobj->pols, plsrunRubyText, 
			pdobj->lstflow, &lsems);

		if (lserr != lserrNone)
			{
			return lserr;
			}

		durMaxOverhang = lsems.em;
		durOverhang = -durOverhang;

		if (durMaxOverhang > durOverhang)
			{
			/* limit maximum overhang to max overhang for ruby line */
			durMaxOverhang = durOverhang;
			}
		}

	lserr = pilsobj->rcbk.pfnFetchRubyWidthAdjust(pilsobj->pols, 
		pdobj->cpStart, plsrun, wch, mwcls, plsrunRubyObject, 
			rubyloc, durMaxOverhang, pdurAdjText, &durModRuby);

	if (lserrNone == lserr)
		{
		if (durModRuby != 0)
			{
			/* size of ruby object needs to change */
			pdobj->sobjhelp.objdimAll.dur += durModRuby;
			lserr = LsdnResetObjDim(pilsobj->plsc, pdobj->plsdn, 
				&pdobj->sobjhelp.objdimAll);
			}

		*pdurRubyMod = durModRuby;
		}

	return lserr;
}

/* M A S S A G E F O R R I G H T A D J U S T */
/*----------------------------------------------------------------------------
	%%Function: MassageForRightAdjust
	%%Contact: ricksa


		Massage object so that right aligned lines will end on exactly
		the same pixel.
	
----------------------------------------------------------------------------*/
static LSERR MassageForRightAdjust(
	PDOBJ pdobj)				/* dobj for Ruby */
{
	LSERR lserr;
	long dupRuby;
	long dupMain;
	long dupDiff;
	LSTFLOW lstflowIgnored;

	/* Get the length of the two lines */
	lserr = LssbGetDupSubline(pdobj->plssublMain, &lstflowIgnored, &dupMain);
	if (lserr != lserrNone) return lserr;

	lserr = LssbGetDupSubline(pdobj->plssublRuby, &lstflowIgnored, &dupRuby);
	if (lserr != lserrNone)	return lserr;

	/* Get difference between two lines */
	dupDiff = dupMain - dupRuby;

	if (dupDiff >= 0)
		{
		/* Main line longest */
		pdobj->dupOffsetRuby = pdobj->dupOffsetMain + dupDiff;
		}
	else
		{
		/* Ruby line longest - reverse sign of dupDiff to add */
		pdobj->dupOffsetMain = pdobj->dupOffsetRuby - dupDiff;
		}

	return lserrNone;
}

/* R U B I C R E A T E I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: RubyCreateILSObj
	%%Contact: ricksa

		CreateILSObj

		Create the ILS object for all Ruby objects.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyCreateILSObj(
	POLS pols,				/* (IN): client application context */
	PLSC plsc,				/* (IN): LS context */
	PCLSCBK pclscbk,		/* (IN): callbacks to client application */
	DWORD idObj,			/* (IN): id of the object */
	PILSOBJ *ppilsobj)		/* (OUT): object ilsobj */
{
    PILSOBJ pilsobj;
	LSERR lserr;
	RUBYINIT rubyinit;
	rubyinit.dwVersion = RUBY_VERSION;

	/* Get initialization data */
	lserr = pclscbk->pfnGetObjectHandlerInfo(pols, idObj, &rubyinit);

	if (lserr != lserrNone)
		{
		return lserr;
		}

    pilsobj = pclscbk->pfnNewPtr(pols, sizeof(*pilsobj));

	if (NULL == pilsobj)
	{
		return lserrOutOfMemory;
	}

    pilsobj->pols = pols;
    pilsobj->lscbk = *pclscbk;
	pilsobj->plsc = plsc;
	pilsobj->lsescMain.wchFirst = rubyinit.wchEscMain;
	pilsobj->lsescMain.wchLast = rubyinit.wchEscMain;
	pilsobj->lsescRuby.wchFirst = rubyinit.wchEscRuby;
	pilsobj->lsescRuby.wchLast = rubyinit.wchEscRuby;
	pilsobj->rcbk = rubyinit.rcbk;
	pilsobj->rubysyntax = rubyinit.rubysyntax;

	*ppilsobj = pilsobj;
	return lserrNone;
}

/* R U B I D E S T R O Y I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: RubyDestroyILSObj
	%%Contact: ricksa

		DestroyILSObj

		Free all resources assocaiated with Ruby ILS object.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyDestroyILSObj(
	PILSOBJ pilsobj)			/* (IN): object ilsobj */
{
	pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pilsobj);
	return lserrNone;
}

/* R U B I S E T D O C */
/*----------------------------------------------------------------------------
	%%Function: RubySetDoc
	%%Contact: ricksa

		SetDoc

		Keep track of device resolution.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubySetDoc(
	PILSOBJ pilsobj,			/* (IN): object ilsobj */
	PCLSDOCINF pclsdocinf)		/* (IN): initialization data of the document level */
{
	pilsobj->lsdevres = pclsdocinf->lsdevres;
	return lserrNone;
}


/* R U B I C R E A T E L N O B J */
/*----------------------------------------------------------------------------
	%%Function: RubyCreateLNObj
	%%Contact: ricksa

		CreateLNObj

		Create the Line Object for the Ruby. Since we only really need
		the global ILS object, just pass that object back as the line object.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyCreateLNObj(
	PCILSOBJ pcilsobj,			/* (IN): object ilsobj */
	PLNOBJ *pplnobj)			/* (OUT): object lnobj */
{
	*pplnobj = (PLNOBJ) pcilsobj;
	return lserrNone;
}

/* R U B I D E S T R O Y L N O B J */
/*----------------------------------------------------------------------------
	%%Function: RubyDestroyLNObj
	%%Contact: ricksa

		DestroyLNObj

		Frees resources associated with the Ruby line object. No-op because
		we don't really allocate one.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyDestroyLNObj(
	PLNOBJ plnobj)				/* (OUT): object lnobj */

{
	Unreferenced(plnobj);
	return lserrNone;
}

/* R U B I F M T */
/*----------------------------------------------------------------------------
	%%Function: RubyFmt
	%%Contact: ricksa

		Fmt

		Format the Ruby object. This formats the main line and the 
		pronunciation line. It then queries the client for spacing
		information and then completes the formatting.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyFmt(
    PLNOBJ plnobj,				/* (IN): object lnobj */
    PCFMTIN pcfmtin,			/* (IN): formatting input */
    FMTRES *pfmtres)			/* (OUT): formatting result */
{
	PDOBJ pdobj;
	LSERR lserr;
	PILSOBJ pilsobj = (PILSOBJ) plnobj;
	POLS pols = pilsobj->pols;
	LSCP cpStartMain;
	LSCP cpStartRuby = pcfmtin->lsfgi.cpFirst + 1;
	LSCP cpOut;
	LSTFLOW lstflow = pcfmtin->lsfgi.lstflow;
	DWORD cdwRunsMain;
	DWORD cdwRunsRuby;
	PLSRUN *pplsrunMain = NULL;
	PLSRUN *pplsrunRuby = NULL;
	FMTRES fmtres;
	OBJDIM objdimAll;
	FMTRES fmtr = fmtrCompletedRun;
	BOOL fSpecialLineStartEnd;

    /*
     * Allocate the DOBJ
     */
    pdobj = pilsobj->lscbk.pfnNewPtr(pols, sizeof(*pdobj));

    if (pdobj == NULL) return RubyFmtFailed (NULL, lserrOutOfMemory);

	ZeroMemory(pdobj, sizeof(*pdobj));
	pdobj->pilsobj = pilsobj;
	pdobj->plsdn = pcfmtin->plsdnTop;
	pdobj->cpStart = pcfmtin->lsfgi.cpFirst;
	pdobj->fFirstOnLine = pcfmtin->lsfgi.fFirstOnLine;
	pdobj->lstflow = lstflow;

	if (RubyPronunciationLineFirst == pilsobj->rubysyntax)
		{
		/*
		 * Build pronunciation line of text
		 */
		 
		lserr = FormatLine(pilsobj->plsc, cpStartRuby, LONG_MAX, lstflow,
			&pdobj->plssublRuby, RUBY_RUBY_ESC_CNT, &pilsobj->lsescRuby,  
				&pdobj->objdimRuby, &cpOut, &pdobj->sublnlsdnRuby.plsdnStart,
					&pdobj->sublnlsdnRuby.plsdnEnd, &fmtres);

		/* +1 moves passed the ruby line escape character */
		cpStartMain = cpOut + 1;

		pdobj->cpStartRuby = cpStartRuby;
		pdobj->cpStartMain = cpStartMain;

		/*
		 * Build main line of text
 		 */
		if (lserrNone == lserr)
			{
			lserr = FormatLine(pilsobj->plsc, cpStartMain, LONG_MAX, lstflow,
				&pdobj->plssublMain, RUBY_MAIN_ESC_CNT, &pilsobj->lsescMain,  
					&pdobj->objdimMain, &cpOut, &pdobj->sublnlsdnMain.plsdnStart, 
						&pdobj->sublnlsdnMain.plsdnEnd, &fmtres);
			}
		}
	else
		{
		/*
		 * Build main line of text
 		 */

		cpStartMain = cpStartRuby;

		lserr = FormatLine(pilsobj->plsc, cpStartMain, LONG_MAX, lstflow,
			&pdobj->plssublMain, RUBY_MAIN_ESC_CNT, &pilsobj->lsescMain,  
				&pdobj->objdimMain, &cpOut, &pdobj->sublnlsdnMain.plsdnStart, 
					&pdobj->sublnlsdnMain.plsdnEnd, &fmtres);

		/* +1 moves passed the main line escape character */
		cpStartRuby = cpOut + 1;

		pdobj->cpStartRuby = cpStartRuby;
		pdobj->cpStartMain = cpStartMain;

		/*
		 * Build pronunciation line of text
		 */
		if (lserrNone == lserr)
			{
			lserr = FormatLine(pilsobj->plsc, cpStartRuby, LONG_MAX, lstflow,
				&pdobj->plssublRuby, RUBY_RUBY_ESC_CNT, &pilsobj->lsescRuby,  
					&pdobj->objdimRuby, &cpOut, &pdobj->sublnlsdnRuby.plsdnStart, 
						&pdobj->sublnlsdnRuby.plsdnEnd, &fmtres);

			}
		}

	if (lserr != lserrNone)	return RubyFmtFailed (pdobj, lserr);

	lserr = GetRunsForSubline(pilsobj, pdobj->plssublMain, &cdwRunsMain, &pplsrunMain);

	if (lserr != lserrNone) return RubyFmtFailed (pdobj, lserr);

	lserr = GetRunsForSubline(pilsobj, pdobj->plssublRuby, &cdwRunsRuby, &pplsrunRuby);

	if (lserr != lserrNone) return RubyFmtFailed (pdobj, lserr);

	/* Save the first and last plsrun for use in GetModWidth */
	if (cdwRunsRuby != 0)
		{
		pdobj->plsrunFirstRubyChar = pplsrunRuby[0];
		pdobj->plsrunLastRubyChar = pplsrunRuby[cdwRunsRuby - 1];
		}

	/* 
	 *	Calculate the object dimensions.
	 */
	lserr = pilsobj->rcbk.pfnFetchRubyPosition(pols, pdobj->cpStart, pdobj->lstflow,
		cdwRunsMain, pplsrunMain, &pdobj->objdimMain.heightsRef, 
			&pdobj->objdimMain.heightsPres, cdwRunsRuby, pplsrunRuby, 
				&pdobj->objdimRuby.heightsRef, &pdobj->objdimRuby.heightsPres,
					&objdimAll.heightsRef, &objdimAll.heightsPres, 
						&pdobj->dvpMainOffset, &pdobj->dvrRubyOffset, 
							&pdobj->dvpRubyOffset, &pdobj->rubycharjust, 
								&fSpecialLineStartEnd);

	/* Free buffers allocated for plsruns for this call */
	
	if (pplsrunMain != NULL) pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pplsrunMain);

	if (pplsrunRuby != NULL) pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pplsrunRuby);

	if (lserr != lserrNone) return RubyFmtFailed (pdobj, lserr);

	/*
	 * Special line start/end adjustment matters only when a justification of
	 * centered, 0:1:0 or 1:2:1 is selected.
	 */

	if (fSpecialLineStartEnd 
		&& (pdobj->rubycharjust != rcjLeft)
		&& (pdobj->rubycharjust != rcjRight))
		{
		pdobj->fSpecialLineStartEnd = TRUE;
		}

	/* Distribute space for Ruby */
	lserr = DoRubySpaceDistribution(pdobj);

	if (lserr != lserrNone) return RubyFmtFailed (pdobj, lserr);

	/* ur is ur of longest subline. */

	objdimAll.dur = pdobj->objdimMain.dur;

	if (pdobj->objdimMain.dur < pdobj->objdimRuby.dur)
		{
		objdimAll.dur = pdobj->objdimRuby.dur;
		}

	pdobj->sobjhelp.objdimAll = objdimAll;

	/* Need to add 1 to take into account escape character at end. */

	pdobj->sobjhelp.dcp = cpOut - pdobj->cpStart + 1;

	lserr = LsdnFinishRegular(pilsobj->plsc, pdobj->sobjhelp.dcp, 
		pcfmtin->lsfrun.plsrun, pcfmtin->lsfrun.plschp, pdobj, 
			&pdobj->sobjhelp.objdimAll);
		
	if (lserr != lserrNone) return RubyFmtFailed (pdobj, lserr);

	if (pcfmtin->lsfgi.urPen + objdimAll.dur > pcfmtin->lsfgi.urColumnMax)
		{
		fmtr = fmtrExceededMargin;
		}

	*pfmtres = fmtr;

	AssertSz(((pdobj->fFirstOnLine && pcfmtin->lsfgi.fFirstOnLine) 
		|| (!pdobj->fFirstOnLine && !pcfmtin->lsfgi.fFirstOnLine)), 
		"RubyFmt - bad first on line flag");

	return lserrNone;
}

/* R U B Y G E T M O D W I D T H P R E C E D I N G C H A R */
/*----------------------------------------------------------------------------
	%%Function: RubyGetModWidthPrecedingChar
	%%Contact: ricksa

		.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyGetModWidthPrecedingChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the preceding char */
	PCHEIGHTS pcheightsRef,		/* (IN): height info about character */
	WCHAR wchar,				/* (IN): preceding character */
	MWCLS mwcls,				/* (IN): ModWidth class of preceding character */
	long *pdurChange)			/* (OUT): amount by which width of the preceding char is to be changed */
{
	AssertSz(!pdobj->fFirstOnLine, "RubyGetModWidthPrecedingChar got called for first char");

	return ModWidthHandler(pdobj, rubyBefore, plsrunText, wchar, mwcls, 
		pcheightsRef, plsrun, pdobj->plsrunFirstRubyChar, pdobj->durDiff, 
			pdurChange, &pdobj->durModBefore);
}

/* R U B Y G E T M O D W I D T H F O L L O W I N G C H A R */
/*----------------------------------------------------------------------------
	%%Function: RubyGetModWidthFollowingChar
	%%Contact: ricksa

		.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyGetModWidthFollowingChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the following char */
	PCHEIGHTS pcheightsRef,		/* (IN): height info about character */
	WCHAR wchar,				/* (IN): following character */
	MWCLS mwcls,				/* (IN): ModWidth class of the following character */
	long *pdurChange)			/* (OUT): amount by which width of the following char is to be changed */
{
	long durDiff = pdobj->durDiff;
	pdobj->fModAfterCalled = TRUE;

	switch (pdobj->rubycharjust)
		{
		case rcjRight:
			/* Right justified so no overhang on right */
			durDiff = 0;
			break;

		case rcjLeft:
			/* For left, max overhang is difference between widths of lines */
			durDiff = pdobj->objdimMain.dur - pdobj->objdimRuby.dur;
			break;

		default:
			break;				
		}

	return ModWidthHandler(pdobj, rubyAfter, plsrunText, wchar, mwcls, 
		pcheightsRef, plsrun, pdobj->plsrunLastRubyChar, durDiff, pdurChange,
			&pdobj->sobjhelp.durModAfter);
}


/* R U B Y S E T B R E A K */
/*----------------------------------------------------------------------------
	%%Function: RubySetBreak
	%%Contact: ricksa

		SetBreak

		.
----------------------------------------------------------------------------*/
LSERR WINAPI RubySetBreak(
	PDOBJ pdobj,				/* (IN): dobj which is broken */
	BRKKIND brkkind,			/* (IN): prev | next | force | after */
	DWORD cBreakRecord,			/* (IN): size of array */
	BREAKREC *rgBreakRecord,	/* (IN): array of break records */
	DWORD *pcActualBreakRecord)	/* (IN): actual number of used elements in array */
{
	LSERR lserr = lserrNone;
	LSCP cpOut;

	LSDCP dcpVisible;

	/* REVIEW (antons): Check this strange logic after new breaking will work */

	Unreferenced (rgBreakRecord);
	Unreferenced (cBreakRecord);
	Unreferenced (brkkind);
	Unreferenced (pdobj);

	Unreferenced (cpOut);
	Unreferenced (dcpVisible);


	*pcActualBreakRecord = 0;

#ifdef UNDEFINED

	if (pdobj->fSpecialLineStartEnd && !pdobj->fFirstOnLine && 
		brkkind != brkkindImposedAfter)
	{

		/*
		 * Because object is last on line and Ruby overhangs, we need to adjust 
		 * its width for the new overhang.
		 */

		PILSOBJ pilsobj = pdobj->pilsobj;
		FMTRES fmtres;
		long dur;
		long dcpOffset = pdobj->dcpRuby;

		if (RubyMainLineFirst == pdobj->pilsobj->rubysyntax)
			{
			dcpOffset = 0;
			}

		/* clear out original subline */
		LsDestroySubline(pdobj->plssublMain);

		/* Format the main line over again */
		lserr = FormatLine(pilsobj->plsc, pdobj->cpStart + dcpOffset + 1, 
			LONG_MAX, pdobj->lstflow, &pdobj->plssublMain, RUBY_MAIN_ESC_CNT,
				&pilsobj->lsescMain, &pdobj->objdimMain, &cpOut, 
					&pdobj->sublnlsdnMain.plsdnStart, 
						&pdobj->sublnlsdnMain.plsdnEnd, &fmtres);

		if (lserr != lserrNone) return lserr;

		dur = pdobj->objdimRuby.dur - pdobj->objdimMain.dur;

		AssertSz(dur > 0, "RubySetBreak - no overhang width");

		lserr = LssbGetVisibleDcpInSubline(pdobj->plssublMain, &dcpVisible);

		if (lserrNone == lserr)
			{
			pdobj->durDiff = 0;

			if (dur > (long) dcpVisible)
				{
				pdobj->durDiff = -(dur / (long) dcpVisible);
				dur += pdobj->durDiff;
				}

			/* Force to right just so we can guranatee end on same pixel */
			pdobj->rubycharjust = rcjRight;	

			lserr = LsdnDistribute(pilsobj->plsc, 
				pdobj->sublnlsdnMain.plsdnStart,
					pdobj->sublnlsdnMain.plsdnEnd, dur);
			}
		}

#endif

	return lserr;	
}

/* R U B Y G E T S P E C I A L E F F E C T S I N S I D E */
/*----------------------------------------------------------------------------
	%%Function: RubyGetSpecialEffectsInside
	%%Contact: ricksa

		GetSpecialEffectsInside

		.

----------------------------------------------------------------------------*/
LSERR WINAPI RubyGetSpecialEffectsInside(
	PDOBJ pdobj,				/* (IN): dobj */
	UINT *pEffectsFlags)		/* (OUT): Special effects for this object */
{
	LSERR lserr = LsGetSpecialEffectsSubline(pdobj->plssublMain, pEffectsFlags);

	if (lserrNone == lserr)
		{
		UINT uiSpecialEffectsRuby;
	
		lserr = LsGetSpecialEffectsSubline(pdobj->plssublRuby, &uiSpecialEffectsRuby);

		*pEffectsFlags |= uiSpecialEffectsRuby;
		}

	return lserr;
}

/* R U B Y C A L C P R E S E N T A T I O N */
/*----------------------------------------------------------------------------
	%%Function: RubyCalcPresentation
	%%Contact: ricksa

		CalcPresentation
	
		This has two jobs. First, it prepares each line for presentation. Then,
		it calculates the positions of the lines in output device coordinates.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyCalcPresentation(
	PDOBJ pdobj,				/* (IN): dobj */
	long dup,					/* (IN): dup of dobj */
	LSKJUST lskjust,			/* (IN): Justification type */
	BOOL fLastVisibleOnLine )	/* (IN): Is this object last visible on line? */
{
	PILSOBJ pilsobj = pdobj->pilsobj;
	LSERR lserr = lserrNone;
	long durOffsetMain;
	long durOffsetRuby;
	long durDiff = pdobj->durDiff;

	Unreferenced (lskjust);
	Unreferenced(dup);
		
	/*
	 *	Prepare lines for presentation
	 */

	if (pdobj->fSpecialLineStartEnd && !pdobj->fFirstOnLine && fLastVisibleOnLine)
		{
		pdobj->rubycharjust = rcjRight;	
		};

	lserr = LsMatchPresSubline(pdobj->plssublMain);

	if (lserr != lserrNone)
		{
		return lserr;
		}

	lserr = LsMatchPresSubline(pdobj->plssublRuby);

	if (lserr != lserrNone)
		{
		return lserr;
		}

	/*
	 *	Calculate positions of lines
	 */

	if (pdobj->fFirstOnLine && pdobj->fSpecialLineStartEnd)
		{
		durDiff = 0;
		}

	durOffsetMain = pdobj->durModBefore;

	/* Calculate amount to adjust in reference */
	if ((durDiff < 0) && (pdobj->rubycharjust != rcjLeft))
		{
		/* Ruby line overhangs main line */
		durOffsetMain -= durDiff;
		}

	pdobj->dupOffsetMain = UpFromUr(pdobj->lstflow, (&pilsobj->lsdevres), 
		durOffsetMain);

	durOffsetRuby = pdobj->durModBefore;

	if (durDiff > 0)
		{
		/* Main line underhangs ruby line */
		durOffsetRuby += durDiff;
		}

	pdobj->dupOffsetRuby = UpFromUr(pdobj->lstflow, (&pilsobj->lsdevres), 
		durOffsetRuby);

	if (rcjRight == pdobj->rubycharjust)
		{
		/*
		 * There can be a pixel rounding error in the above calculations
		 * so that we massage the above calculations so that when the
		 * adjustment is right, both lines are guaranteed to end of the
		 * same pixel.
		 */
		MassageForRightAdjust(pdobj);
		}

	return lserr;
}

/* R U B Y Q U E R Y P O I N T P C P */
/*----------------------------------------------------------------------------
	%%Function: RubyQueryPointPcp
	%%Contact: ricksa

		Map dup to dcp

		There is a certain trickiness about how we determine which subline
		to query. Because the client specifies the offsets, the sublines
		can actually wind up anywhere. We use the simple algorithm that
		if the query does not fall into the Ruby pronunciation line, they
		actually mean the main line of text.
----------------------------------------------------------------------------*/
LSERR WINAPI RubyQueryPointPcp(
	PDOBJ pdobj,				/*(IN): dobj to query */
	PCPOINTUV ppointuvQuery,	/*(IN): query point (uQuery,vQuery) */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	PLSSUBL plssubl;
 	long dupAdj;
	long dvpAdj;
	long dvpRubyOffset = pdobj->dvpRubyOffset;

	/*
	 * Decide which line to to return based on the height of the point input
	 */

	/* Assume main line */
	plssubl = pdobj->plssublMain;
	dupAdj = pdobj->dupOffsetMain;
	dvpAdj = 0;

	if ((ppointuvQuery->v > (dvpRubyOffset - pdobj->objdimRuby.heightsPres.dvDescent))
		&& (ppointuvQuery->v <= (dvpRubyOffset + pdobj->objdimRuby.heightsPres.dvAscent)))
		{
		/* hit second line */
		plssubl = pdobj->plssublRuby;
		dupAdj = pdobj->dupOffsetRuby;
		dvpAdj = pdobj->dvpRubyOffset;
		}

	return CreateQueryResult(plssubl, dupAdj, dvpAdj, plsqin, plsqout);
}
	
/* R U B Y Q U E R Y C P P P O I N T */
/*----------------------------------------------------------------------------
	%%Function: RubyQueryCpPpoint
	%%Contact: ricksa

		Map dcp to dup

		If client wants all text treated as a single object, then the handler
		just returns the object dimensions. Otherwise, we calculate the line to
		query and ask that line for the dimensions of the dcp.
----------------------------------------------------------------------------*/
LSERR WINAPI RubyQueryCpPpoint(
	PDOBJ pdobj,				/*(IN): dobj to query, */
	LSDCP dcp,					/*(IN): dcp for the query */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	PLSSUBL plssubl;
 	long dupAdj;
	long dvpAdj;
	BOOL fMain = fFalse;

	LSCP cpQuery = pdobj->cpStart + dcp;

	/*
	 *	Calculate subline to query
	 */

	/* Assume ruby line */
	plssubl = pdobj->plssublRuby;
	dupAdj = pdobj->dupOffsetRuby;
	dvpAdj = pdobj->dvpRubyOffset;

	/* + 1 means we include the cp of the object in the Ruby pronunciation line. */
	if (RubyPronunciationLineFirst == pdobj->pilsobj->rubysyntax)
		{
		/* Ruby pronunciation line is first */
		if (cpQuery >= pdobj->cpStartMain)
			{
			fMain = fTrue;
			}
		}
	else
		{
		/* Main text line is first */
		if (cpQuery < pdobj->cpStartRuby)
			{
			fMain = fTrue;
			}
		}

	if (fMain)
		{
		plssubl = pdobj->plssublMain;
		dupAdj = pdobj->dupOffsetMain;
		dvpAdj = pdobj->dvpMainOffset;
		}

	return CreateQueryResult(plssubl, dupAdj, dvpAdj, plsqin, plsqout);
}

	
/* R U B I D I S P L A Y */
/*----------------------------------------------------------------------------
	%%Function: RubyDisplay
	%%Contact: ricksa

		Display

		This calculates the positions of the various lines for the
		display and then displays them.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyDisplay(
	PDOBJ pdobj,				/*(IN): dobj to display */
	PCDISPIN pcdispin)			/*(IN): display info */
{
	LSERR lserr;
	LSTFLOW lstflow = pcdispin->lstflow;
	UINT kDispMode = pcdispin->kDispMode;
	POINT ptLine;

	/* Calculate point to start displaying main line. */
	GetMainPoint(pdobj, &pcdispin->ptPen, lstflow, &ptLine);

	/* display first line */
	lserr = LsDisplaySubline(pdobj->plssublMain, &ptLine, kDispMode,
		pcdispin->prcClip);

	if (lserr != lserrNone)
		{
		return lserr;
		}

	/* Calculate point to start displaying ruby line. */
	GetRubyPoint(pdobj, &pcdispin->ptPen, lstflow, &ptLine);

	/* display ruby line */
	return LsDisplaySubline(pdobj->plssublRuby, &ptLine, kDispMode, 
		pcdispin->prcClip);
}

/* R U B I D E S T R O Y D O B J */
/*----------------------------------------------------------------------------
	%%Function: RubyDestroyDobj
	%%Contact: ricksa

		DestroyDobj

		Free all resources connected with the input dobj.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyDestroyDobj(
	PDOBJ pdobj)				/*(IN): dobj to destroy */
{
	return RubyFreeDobj (pdobj);
}

/* R U B Y E N U M */
/*----------------------------------------------------------------------------
	%%Function: RubyEnum
	%%Contact: ricksa

		Enum

		Enumeration callback - passed to client.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyEnum(
	PDOBJ pdobj,				/*(IN): dobj to enumerate */
	PLSRUN plsrun,				/*(IN): from DNODE */
	PCLSCHP plschp,				/*(IN): from DNODE */
	LSCP cp,					/*(IN): from DNODE */
	LSDCP dcp,					/*(IN): from DNODE */
	LSTFLOW lstflow,			/*(IN): text flow*/
	BOOL fReverse,				/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,		/*(IN): */
	const POINT *pt,			/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,		/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun)				/*(IN): from DNODE, relevant iff fGeometryNeeded */
{
	POINT ptMain;
	POINT ptRuby;
	long dupMain = 0;
	long dupRuby = 0;
	LSERR lserr;
	LSTFLOW lstflowIgnored;

	if (fGeometryNeeded)
		{
		GetMainPoint(pdobj, pt, lstflow, &ptMain);
		GetRubyPoint(pdobj, pt, lstflow, &ptMain);
		lserr = LssbGetDupSubline(pdobj->plssublMain, &lstflowIgnored, &dupMain);
		AssertSz(lserrNone == lserr, "RubyEnum - can't get dup for main");
		lserr = LssbGetDupSubline(pdobj->plssublRuby, &lstflowIgnored, &dupRuby);
		AssertSz(lserrNone == lserr, "RubyEnum - can't get dup for ruby");
		}

	return pdobj->pilsobj->rcbk.pfnRubyEnum(pdobj->pilsobj->pols, plsrun, 
		plschp, cp, dcp, lstflow, fReverse, fGeometryNeeded, pt, pcheights, 
			dupRun, &ptMain, &pdobj->objdimMain.heightsPres, dupMain, &ptRuby, 
				&pdobj->objdimRuby.heightsPres, dupRuby, pdobj->plssublMain,
					pdobj->plssublRuby);
}
	
	

/* R U B I H A N D L E R I N I T */
/*----------------------------------------------------------------------------
	%%Function: RubyHandlerInit
	%%Contact: ricksa

		Initialize global Ruby data and return LSIMETHODS.
	
----------------------------------------------------------------------------*/
LSERR WINAPI LsGetRubyLsimethods(
	LSIMETHODS *plsim)
{
	plsim->pfnCreateILSObj = RubyCreateILSObj;
	plsim->pfnDestroyILSObj = RubyDestroyILSObj;
	plsim->pfnSetDoc = RubySetDoc;
	plsim->pfnCreateLNObj = RubyCreateLNObj;
	plsim->pfnDestroyLNObj = RubyDestroyLNObj;
	plsim->pfnFmt = RubyFmt;
	plsim->pfnFmtResume = ObjHelpFmtResume;
	plsim->pfnGetModWidthPrecedingChar = RubyGetModWidthPrecedingChar;
	plsim->pfnGetModWidthFollowingChar = RubyGetModWidthFollowingChar;
	plsim->pfnTruncateChunk = SobjTruncateChunk;
	plsim->pfnFindPrevBreakChunk = SobjFindPrevBreakChunk;
	plsim->pfnFindNextBreakChunk = SobjFindNextBreakChunk;
	plsim->pfnForceBreakChunk = SobjForceBreakChunk;
	plsim->pfnSetBreak = RubySetBreak;
	plsim->pfnGetSpecialEffectsInside = RubyGetSpecialEffectsInside;
	plsim->pfnFExpandWithPrecedingChar = ObjHelpFExpandWithPrecedingChar;
	plsim->pfnFExpandWithFollowingChar = ObjHelpFExpandWithFollowingChar;
	plsim->pfnCalcPresentation = RubyCalcPresentation;
	plsim->pfnQueryPointPcp = RubyQueryPointPcp;
	plsim->pfnQueryCpPpoint = RubyQueryCpPpoint;
	plsim->pfnDisplay = RubyDisplay;
	plsim->pfnDestroyDObj = RubyDestroyDobj;
	plsim->pfnEnum = RubyEnum;
	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\afxres.h ===
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\zqfromza.c ===
#include <limits.h>

#include "lsidefs.h"
#include "zqfromza.h"


#ifdef _X86_

/* ===========================================================  */
/*																*/
/* Functions implemented on Intel X86 Assember					*/
/*																*/
/* ===========================================================  */

#define HIWORD(x) DWORD PTR [x+4]
#define LOWORD(x) DWORD PTR [x]


long ZqFromZa_Asm (long dzqInch, long za)
{
	long result;
	__asm
	{
		mov eax, za;
		cmp eax, 0
		jge POSITIVE

			neg eax
			mul dzqInch;
			add eax, czaUnitInch / 2
			mov ecx, czaUnitInch
			adc	edx, 0		
			div	ecx;
			neg eax
			jmp RETURN

		POSITIVE:

			mul dzqInch;
			add eax, czaUnitInch / 2
			mov ecx, czaUnitInch
			adc	edx, 0		
			div	ecx;
		
		RETURN:

			mov result, eax
		
	};

	/*
	Assert (result == ZqFromZa_C (dzqInch, za));
	*/

	return result;
}

/* D I V 6 4 _ A S M */
/*----------------------------------------------------------------------------
	%%Function: Div64_Asm
	%%Contact: antons

		Intel assembler implementation of 64-bit division. The 
		orignal code was taken from lldiv.asm (VC++ 6.0).
		
----------------------------------------------------------------------------*/

__int64 Div64_Asm (__int64 DVND, __int64 DVSR)
{
	__int64 result;

	__asm {

		xor     edi,edi				// result sign assumed positive

        mov     eax,HIWORD(DVND)	// hi word of a
        or      eax,eax				// test to see if signed
        jge     L1					// skip rest if a is already positive
        inc     edi					// complement result sign flag
        mov     edx,LOWORD(DVND)	// lo word of a
        neg     eax					// make a positive
        neg     edx
        sbb     eax,0
        mov     HIWORD(DVND),eax	// save positive value
        mov     LOWORD(DVND),edx
L1:
        mov     eax,HIWORD(DVSR)	// hi word of b
        or      eax,eax				// test to see if signed
        jge     L2					// skip rest if b is already positive
        inc     edi					// complement the result sign flag
        mov     edx,LOWORD(DVSR)	// lo word of a
        neg     eax					// make b positive
        neg     edx
        sbb     eax,0
        mov     HIWORD(DVSR),eax	// save positive value
        mov     LOWORD(DVSR),edx
L2:

// Now do the divide.  First look to see if the divisor is less than 4194304K.
// If so, then we can use a simple algorithm with word divides, otherwise
// things get a little more complex.
//
// NOTE - eax currently contains the high order word of DVSR

        or      eax,eax         // check to see if divisor < 4194304K
        jnz     L3				// nope, gotta do this the hard way
        mov     ecx,LOWORD(DVSR) // load divisor
        mov     eax,HIWORD(DVND) // load high word of dividend
        xor     edx,edx
        div     ecx             // eax <- high order bits of quotient
        mov     ebx,eax         // save high bits of quotient
        mov     eax,LOWORD(DVND) // edx:eax <- remainder:lo word of dividend
        div     ecx             // eax <- low order bits of quotient
        mov     edx,ebx         // edx:eax <- quotient
        jmp     L4				// set sign, restore stack and return

//
// Here we do it the hard way.  Remember, eax contains the high word of DVSR
//

L3:
        mov     ebx,eax         // ebx:ecx <- divisor
        mov     ecx,LOWORD(DVSR)
        mov     edx,HIWORD(DVND) // edx:eax <- dividend
        mov     eax,LOWORD(DVND)
L5:
        shr     ebx,1           // shift divisor right one bit
        rcr     ecx,1
        shr     edx,1           // shift dividend right one bit
        rcr     eax,1
        or      ebx,ebx
        jnz     L5				// loop until divisor < 4194304K
        div     ecx             // now divide, ignore remainder
        mov     esi,eax         // save quotient

/*
// We may be off by one, so to check, we will multiply the quotient
// by the divisor and check the result against the orignal dividend
// Note that we must also check for overflow, which can occur if the
// dividend is close to 2**64 and the quotient is off by 1.

*/

        mul     HIWORD(DVSR) // QUOT * HIWORD(DVSR)
        mov     ecx,eax
        mov     eax,LOWORD(DVSR)
        mul     esi             // QUOT * LOWORD(DVSR)
        add     edx,ecx         // EDX:EAX = QUOT * DVSR
        jc      L6				// carry means Quotient is off by 1

//
// do long compare here between original dividend and the result of the
// multiply in edx:eax.  If original is larger or equal, we are ok, otherwise
// subtract one (1) from the quotient.
//

        cmp     edx,HIWORD(DVND) // compare hi words of result and original
        ja      L6				// if result > original, do subtract
        jb      L7				// if result < original, we are ok
        cmp     eax,LOWORD(DVND) // hi words are equal, compare lo words
        jbe     L7				// if less or equal we are ok, else subtract
L6:
        dec     esi             // subtract 1 from quotient
L7:
        xor     edx,edx         // edx:eax <- quotient
        mov     eax,esi

//
// Just the cleanup left to do.  edx:eax contains the quotient.  Set the sign
// according to the save value, cleanup the stack, and return.
//

L4:
        dec     edi             // check to see if result is negative
        jnz     L8				// if EDI == 0, result should be negative
        neg     edx             // otherwise, negate the result
        neg     eax
        sbb     edx,0

//
// Restore the saved registers and return.
//

L8:
		mov		HIWORD(result),edx
		mov		LOWORD(result),eax

	}; /* ASM */

	return result;
}


/* M U L 6 4 _ A S M */
/*----------------------------------------------------------------------------
	%%Function: Mul64_Asm
	%%Contact: antons

		Intel assembler implementation of 64-bit multiplication. The 
		orignal code was taken from llmul.asm (VC++ 6.0).
		
----------------------------------------------------------------------------*/

__int64 Mul64_Asm (__int64 A, __int64 B)
{
	__int64 result;
	
	__asm {

        mov     eax,HIWORD(A)
        mov     ecx,LOWORD(B)

        mul     ecx					// eax has AHI, ecx has BLO, so AHI * BLO
        mov     esi,eax				// save result

        mov     eax,LOWORD(A)
        mul     HIWORD(B)			// ALO * BHI
        add     esi,eax				// ebx = ((ALO * BHI) + (AHI * BLO))

        mov     eax,LOWORD(A)		// ecx = BLO
        mul     ecx					// so edx:eax = ALO*BLO
        add     edx,esi				// now edx has all the LO*HI stuff

		mov		HIWORD(result),edx
		mov		LOWORD(result),eax

	}; /* ASM */

	return result;
}

/* ===========================================================  */
/*																*/
/* End of Assembler functions									*/
/*																*/
/* ===========================================================  */

#endif /* _X86_ */


long ZqFromZa_C (long dzqInch, long za)
{
	long cInches;
	long zaExtra;

	if (za < 0)
		{
		Assert (((long) -za) > 0); /* Check for overflow */
		return -ZqFromZa_C (dzqInch, -za);
		};

	Assert(0 <= za);
	Assert(0 < dzqInch && dzqInch < zqLim);
	Assert(0 < czaUnitInch);

	cInches = za / czaUnitInch;
	zaExtra = za % czaUnitInch;

	return (cInches * dzqInch) +
			((zaExtra * dzqInch) + (czaUnitInch/2)) / czaUnitInch;
}

long ZaFromZq(long dzqInch, long zq)
{
	long cInches;
	long zqExtra;

	if (zq < 0)
		return -ZaFromZq(dzqInch, -zq);

	Assert(0 <= zq);
	Assert(0 < dzqInch && dzqInch < zqLim);
	Assert(0 < czaUnitInch);

	cInches = zq / dzqInch;
	zqExtra = zq % dzqInch;

	return (cInches * czaUnitInch) + 
			((zqExtra * czaUnitInch) + ((unsigned long) dzqInch/2)) / dzqInch;
}


long LsLwMultDivR(long l, long lNumer, long lDenom)
{
	__int64 llT;

	Assert(lDenom != 0);
	if (lDenom == 0)	/* this is really sloppy! Don't depend on this! */
		return LONG_MAX;

    if (l == 0)
        return 0;

    if (lNumer == lDenom)
        return l;

    llT = Mul64 (l, lNumer);

	if ( (l ^ lNumer ^ lDenom) < 0)		/* xor sign bits to give result sign */
		llT -= lDenom / 2;
	else
		llT += lDenom / 2;
		
	if ((__int64)(long)llT == llT)		/* Did the multiply fit in 32-bits */
		return ( ((long)llT) / lDenom);	/* If so, do a 32-bit divide. */

	llT = Div64 (llT, lDenom);

	if (llT > LONG_MAX)
		return LONG_MAX;
	else if (llT < LONG_MIN)
		return LONG_MIN;
	else
		return (long) llT;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\vruby.c ===
/* ---------------------------- */
/*								*/
/* Vertical Ruby object handler */
/*								*/
/* Contact: antons				*/
/*								*/
/* ---------------------------- */


#include	"lsmem.h"
#include	"limits.h"
#include	"vruby.h"
#include	"objhelp.h"
#include	"lscbk.h"
#include	"lsdevres.h"
#include	"pdobj.h"
#include	"objdim.h"
#include	"plssubl.h"
#include	"plsdnode.h"
#include	"pilsobj.h"
#include	"lscrsubl.h"
#include	"lssubset.h"
#include	"lsdnset.h"
#include	"zqfromza.h"
#include	"lsdocinf.h"
#include	"fmti.h"
#include	"posichnk.h"
#include	"locchnk.h"
#include	"lsdnfin.h"
#include	"brko.h"
#include	"lspap.h"
#include	"plspap.h"
#include	"lsqsubl.h"
#include	"dispi.h"
#include	"lsdssubl.h"
#include	"lsems.h"
#include	"dispmisc.h"
#include	"lstfset.h"
#include	"lsqout.h"
#include	"lsqin.h"
#include	"sobjhelp.h"
#include	"brkkind.h"


#define VRUBY_MAIN_ESC_CNT	1
#define VRUBY_RUBY_ESC_CNT	1


#define max(a,b) ((a)>(b) ? (a) : (b))

struct ilsobj
{
    POLS				pols;
	LSCBK				lscbk;
	PLSC				plsc;
	LSDEVRES			lsdevres;
	VRUBYSYNTAX			vrubysyntax;
	LSESC				lsescMain;
	LSESC				lsescRuby;
	VRUBYCBK			vrcbk;		/* Callbacks  to client application */

};

struct dobj
{	
	SOBJHELP			sobjhelp;			/* common area for simple objects */	
	PILSOBJ				pilsobj;			/* ILS object */
	PLSDNODE			plsdn;				/* DNODE for this object */
	PLSRUN				plsrun;				/* PLSRUN of the object */
	LSCP				cpStart;			/* Starting LS cp for object */
	LSTFLOW				lstflowParent;		/* text flow of the parent subline */
	LSTFLOW				lstflowRuby;		/* text flow of the ruby subline (must be Rotate90CloclWise [lstflowParent]) */

	LSCP				cpStartRuby;		/* first cp of the ruby line */
	LSCP				cpStartMain;		/* first cp of the main line */

	PLSSUBL				plssublMain;		/* Handle to first subline */
	PLSSUBL				plssublRuby;		/* Handle to second line */

	HEIGHTS				heightsRefRubyT;	/* Ref and pres height of rotated Ruby line as given by client */
	HEIGHTS				heightsPresRubyT;

	OBJDIM				objdimMain;			/* Dimensions of the main subline */
	OBJDIM				objdimRuby;			/* Dimensions of the ruby subline */

	/* Display information */

	long				dupMain;
	long				dupOffsetRuby;		/* Offset of Ruby line's baseline from start of object */
	long				dvpOffsetRuby;		/* Offset of Ruby line's baseline from start of object */

};


/* V R U B Y  F R E E  D O B J */
/*----------------------------------------------------------------------------
	%%Function: VRubyFreeDobj
	%%Contact: antons

		Free all resources associated with this VRuby dobj.
	
----------------------------------------------------------------------------*/
static LSERR VRubyFreeDobj (PDOBJ pdobj)
{
	LSERR lserr1 = lserrNone;
	LSERR lserr2 = lserrNone;

	PILSOBJ pilsobj = pdobj->pilsobj;

	if (pdobj->plssublMain != NULL)
		{
		lserr1 = LsDestroySubline(pdobj->plssublMain);
		}

	if (pdobj->plssublRuby != NULL)
		{
		lserr2 = LsDestroySubline(pdobj->plssublRuby);
		}

    pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pdobj);

	if (lserr1 != lserrNone) return lserr1;
	else return lserr2;

}


/* V R U B Y  F M T  F A I L E D */
/*----------------------------------------------------------------------------
	%%Function: RubyFmtFailed
	%%Contact: antons

		Could not create VRuby DOBJ due to error. 

----------------------------------------------------------------------------*/
static LSERR VRubyFmtFailed (PDOBJ pdobj, LSERR lserr)
{
	if (pdobj != NULL) VRubyFreeDobj (pdobj); /* Works with parially-filled DOBJ */

	return lserr;
}



/* V R U B I C R E A T E I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: VRubyCreateILSObj
	%%Contact: antons

		Create the ILS object for all VRuby objects.
	
----------------------------------------------------------------------------*/
LSERR WINAPI VRubyCreateILSObj (
	POLS pols,				/* (IN): client application context */
	PLSC plsc,				/* (IN): LS context */
	PCLSCBK pclscbk,		/* (IN): callbacks to client application */
	DWORD idObj,			/* (IN): id of the object */
	PILSOBJ *ppilsobj)		/* (OUT): object ilsobj */
{
    PILSOBJ pilsobj;
	LSERR lserr;
	VRUBYINIT vrubyinit;
	vrubyinit.dwVersion = VRUBY_VERSION;

	/* Get initialization data */
	lserr = pclscbk->pfnGetObjectHandlerInfo(pols, idObj, &vrubyinit);

	if (lserr != lserrNone)	return lserr;

    pilsobj = pclscbk->pfnNewPtr(pols, sizeof(*pilsobj));

	if (NULL == pilsobj) return lserrOutOfMemory;

    pilsobj->pols = pols;
    pilsobj->lscbk = *pclscbk;
	pilsobj->plsc = plsc;
	pilsobj->lsescMain.wchFirst = vrubyinit.wchEscMain;
	pilsobj->lsescMain.wchLast = vrubyinit.wchEscMain;
	pilsobj->lsescRuby.wchFirst = vrubyinit.wchEscRuby;
	pilsobj->lsescRuby.wchLast = vrubyinit.wchEscRuby;
	pilsobj->vrcbk = vrubyinit.vrcbk;
	pilsobj->vrubysyntax = vrubyinit.vrubysyntax;

	*ppilsobj = pilsobj;
	return lserrNone;
}

/* V R U B I D E S T R O Y I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: RubyDestroyILSObj
	%%Contact: antons

		Free all resources assocaiated with VRuby ILS object.
	
----------------------------------------------------------------------------*/
LSERR WINAPI VRubyDestroyILSObj(
	PILSOBJ pilsobj)			/* (IN): object ilsobj */
{
	pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pilsobj);
	return lserrNone;
}

/* V R U B I S E T D O C */
/*----------------------------------------------------------------------------
	%%Function: VRubySetDoc
	%%Contact: antons

		Keep track of device resolution.
	
----------------------------------------------------------------------------*/

LSERR WINAPI VRubySetDoc(
	PILSOBJ pilsobj,			/* (IN): object ilsobj */
	PCLSDOCINF pclsdocinf)		/* (IN): initialization data of the document level */
{
	pilsobj->lsdevres = pclsdocinf->lsdevres;
	return lserrNone;
}


/* V R U B I C R E A T E L N O B J */
/*----------------------------------------------------------------------------
	%%Function: RubyCreateLNObj
	%%Contact: antons

		Create the Line Object for the Ruby. Since we only really need
		the global ILS object, just pass that object back as the line object.
	
----------------------------------------------------------------------------*/

LSERR WINAPI VRubyCreateLNObj (PCILSOBJ pcilsobj, PLNOBJ *pplnobj)
{
	*pplnobj = (PLNOBJ) pcilsobj;
	return lserrNone;
}

/* V R U B I D E S T R O Y L N O B J */
/*----------------------------------------------------------------------------
	%%Function: RubyDestroyLNObj
	%%Contact: antons

		Frees resources associated with the Ruby line object. No-op because
		we don't really allocate one.
	
----------------------------------------------------------------------------*/

LSERR WINAPI VRubyDestroyLNObj (PLNOBJ plnobj)
{
	Unreferenced(plnobj);
	return lserrNone;
}


/* L S F T L O W   V R U B Y   F R O M   L S T F L O W   M A I N */
/* ----------------------------------------------------------------------------
	%%Function: LstflowVRubyFromLstflowMain
	%%Contact: antons

	
----------------------------------------------------------------------------*/

LSTFLOW LstflowVRubyFromLstflowMain (LSTFLOW lstflow)
{
	static LSTFLOW lstflowRotateForRuby [] =
		{
		lstflowSW, /* [ lstflowES ] - english */
		lstflowNW, /* [ lstflowEN ] */ 
		lstflowEN, /* [ lstflowSE ] */
		lstflowWN, /* [ lstflowSW ] */

		lstflowSE, /* [ lstflowWS ] - bidi */

		lstflowNE, /* [ lstflowWN ] */
		lstflowES, /* [ lstflowNE ] */
		lstflowWS  /* [ lstflowNW ] */
		};

	return lstflowRotateForRuby [lstflow];
}

/* C A L C  A G R E G A T E D   H E I G H T */
/*----------------------------------------------------------------------------
	%%Function: CalcAgregatedHeight
	%%Contact: antons


----------------------------------------------------------------------------*/


void CalcAgregatedHeights (PCHEIGHTS pcHeights1, PCHEIGHTS pcHeights2, PHEIGHTS pHeightOut)
{
	pHeightOut->dvAscent = max (pcHeights1->dvAscent, pcHeights2->dvAscent);
	pHeightOut->dvDescent = max (pcHeights1->dvDescent, pcHeights2->dvDescent);
	pHeightOut->dvMultiLineHeight = max (pcHeights1->dvMultiLineHeight, pcHeights2->dvMultiLineHeight);
}


/* V R U B I F M T */
/*----------------------------------------------------------------------------
	%%Function: VRubyFmt
	%%Contact: antons

		Format Vertical Ruby object
	
----------------------------------------------------------------------------*/

LSERR WINAPI VRubyFmt(
    PLNOBJ plnobj,				/* (IN): object lnobj */
    PCFMTIN pcfmtin,			/* (IN): formatting input */
    FMTRES *pfmtres)			/* (OUT): formatting result */
{
	PDOBJ pdobj;
	LSERR lserr;
	PILSOBJ pilsobj = (PILSOBJ) plnobj;
	POLS pols = pilsobj->pols;
	LSCP cpStartMain;
	LSCP cpStartRuby = pcfmtin->lsfgi.cpFirst + 1;
	LSCP cpOut;
	LSTFLOW lstflow = pcfmtin->lsfgi.lstflow;
	FMTRES fmtres;
	FMTRES fmtr = fmtrCompletedRun;
	LONG durAdjust;

    /* Allocate the DOBJ */

    pdobj = pilsobj->lscbk.pfnNewPtr(pols, sizeof(*pdobj));

    if (pdobj == NULL) return VRubyFmtFailed (NULL, lserrOutOfMemory);

	ZeroMemory(pdobj, sizeof(*pdobj));
	pdobj->pilsobj = pilsobj;
	pdobj->plsrun = pcfmtin->lsfrun.plsrun;
	pdobj->plsdn = pcfmtin->plsdnTop;
	pdobj->cpStart = pcfmtin->lsfgi.cpFirst;
	pdobj->lstflowParent = lstflow;
	pdobj->lstflowRuby = LstflowVRubyFromLstflowMain (lstflow);

	if (VRubyPronunciationLineFirst == pilsobj->vrubysyntax)
		{
		/* Build pronunciation line of text */
		
		lserr = FormatLine ( pilsobj->plsc, cpStartRuby, LONG_MAX, pdobj->lstflowRuby,
							 & pdobj->plssublRuby, 1, &pilsobj->lsescRuby,
							 & pdobj->objdimRuby, &cpOut, NULL, NULL, &fmtres );

		/* +1 moves passed the ruby line escape character */
		cpStartMain = cpOut + 1;

		pdobj->cpStartRuby = cpStartRuby;
		pdobj->cpStartMain = cpStartMain;

		/* Build main line of text */

		if (lserrNone == lserr)
			{
			lserr = FormatLine ( pilsobj->plsc, cpStartMain, LONG_MAX, lstflow,
								 & pdobj->plssublMain, 1, &pilsobj->lsescMain,
								 & pdobj->objdimMain, &cpOut, NULL, NULL, &fmtres );
			}
		}
	else
		{
		/* Build main line of text */

		cpStartMain = cpStartRuby;

		lserr = FormatLine ( pilsobj->plsc, cpStartMain, LONG_MAX, lstflow,
							 & pdobj->plssublMain, 1, &pilsobj->lsescMain,  
							 & pdobj->objdimMain, &cpOut, NULL, NULL, &fmtres );

		/* +1 moves passed the main line escape character */
		cpStartRuby = cpOut + 1;

		pdobj->cpStartRuby = cpStartRuby;
		pdobj->cpStartMain = cpStartMain;

		/* Build pronunciation line of text */

		if (lserrNone == lserr)
			{
			lserr = FormatLine ( pilsobj->plsc, cpStartRuby, LONG_MAX, pdobj->lstflowRuby,
								 & pdobj->plssublRuby, 1, &pilsobj->lsescRuby,  
								 & pdobj->objdimRuby, &cpOut, NULL, NULL, &fmtres);

			}
		}

	if (lserr != lserrNone)	return VRubyFmtFailed (pdobj, lserr);

	/* Calculate the object dimensions */

	lserr = pilsobj->vrcbk.pfnFetchVRubyPosition
				( pols, pdobj->cpStart, pdobj->lstflowParent,
				  pdobj->plsrun,
				  &pdobj->objdimMain.heightsRef, &pdobj->objdimMain.heightsPres,
				  pdobj->objdimRuby.dur,
				  &pdobj->heightsPresRubyT,
				  &pdobj->heightsRefRubyT,
				  &durAdjust );

	if (lserr != lserrNone) return VRubyFmtFailed (pdobj, lserr);

	pdobj->sobjhelp.objdimAll.dur = pdobj->objdimMain.dur + pdobj->objdimRuby.heightsRef.dvDescent + 
															pdobj->objdimRuby.heightsRef.dvAscent +
															durAdjust ;

	CalcAgregatedHeights (&pdobj->objdimMain.heightsPres, &pdobj->heightsPresRubyT, &pdobj->sobjhelp.objdimAll.heightsPres );
	CalcAgregatedHeights (&pdobj->objdimMain.heightsRef, &pdobj->heightsRefRubyT, &pdobj->sobjhelp.objdimAll.heightsRef );

	/* Need to add 1 to take into account escape character at end. */

	pdobj->sobjhelp.dcp = cpOut - pdobj->cpStart + 1;

	lserr = LsdnFinishRegular(pilsobj->plsc, pdobj->sobjhelp.dcp, 
		pcfmtin->lsfrun.plsrun, pcfmtin->lsfrun.plschp, pdobj, 
			&pdobj->sobjhelp.objdimAll);
		
	if (lserr != lserrNone) return VRubyFmtFailed (pdobj, lserr);

	if (pcfmtin->lsfgi.urPen + pdobj->sobjhelp.objdimAll.dur > pcfmtin->lsfgi.urColumnMax)
		{
		fmtr = fmtrExceededMargin;
		}

	*pfmtres = fmtr;

	return lserrNone;
}


/* V R U B Y S E T B R E A K */
/*----------------------------------------------------------------------------
	%%Function: VRubySetBreak
	%%Contact: antons

		SetBreak

----------------------------------------------------------------------------*/

LSERR WINAPI VRubySetBreak (
	PDOBJ pdobj,				/* (IN): dobj which is broken */
	BRKKIND brkkind,			/* (IN): prev | next | force | after */
	DWORD cBreakRecord,			/* (IN): size of array */
	BREAKREC *rgBreakRecord,	/* (IN): array of break records */
	DWORD *pcActualBreakRecord)	/* (IN): actual number of used elements in array */
{
	Unreferenced (rgBreakRecord);
	Unreferenced (cBreakRecord);
	Unreferenced (brkkind);
	Unreferenced (pdobj);

	*pcActualBreakRecord = 0;

	return lserrNone;	
}

/* V R U B Y G E T S P E C I A L E F F E C T S I N S I D E */
/*----------------------------------------------------------------------------
	%%Function: VRubyGetSpecialEffectsInside
	%%Contact: antons

		VRubyGetSpecialEffectsInside


----------------------------------------------------------------------------*/
LSERR WINAPI VRubyGetSpecialEffectsInside(
	PDOBJ pdobj,				/* (IN): dobj */
	UINT *pEffectsFlags)		/* (OUT): Special effects for this object */
{
	LSERR lserr = LsGetSpecialEffectsSubline(pdobj->plssublMain, pEffectsFlags);

	if (lserrNone == lserr)
		{
		UINT uiSpecialEffectsRuby;
	
		lserr = LsGetSpecialEffectsSubline(pdobj->plssublRuby, &uiSpecialEffectsRuby);

		*pEffectsFlags |= uiSpecialEffectsRuby;
		}

	return lserr;
}

/* V R U B Y C A L C P R E S E N T A T I O N */
/*----------------------------------------------------------------------------
	%%Function: VRubyCalcPresentation
	%%Contact: antons

		CalcPresentation
	
----------------------------------------------------------------------------*/
LSERR WINAPI VRubyCalcPresentation (
	PDOBJ pdobj,				/* (IN): dobj */
	long dup,					/* (IN): dup of dobj */
	LSKJUST lskjust,			/* (IN): Justification type */
	BOOL fLastVisibleOnLine )	/* (IN): Is this object last visible on line? */
{
	LSERR lserr = lserrNone;
	LSTFLOW lstflowUnused;

	Unreferenced (lskjust);
	Unreferenced(dup);
	Unreferenced (fLastVisibleOnLine);
		
	lserr = LsMatchPresSubline(pdobj->plssublMain);
	if (lserr != lserrNone) return lserr;

	lserr = LsMatchPresSubline(pdobj->plssublRuby);
	if (lserr != lserrNone)	return lserr;

	LssbGetDupSubline (pdobj->plssublMain, &lstflowUnused, &pdobj->dupMain);

	pdobj->dupOffsetRuby = pdobj->dupMain + pdobj->objdimRuby.heightsPres.dvDescent;

	/* Review (antons): This will not work if horizintal res != vertical */

	pdobj->dvpOffsetRuby = pdobj->heightsPresRubyT.dvAscent;

	return lserr;
}

/* V R U B Y Q U E R Y P O I N T P C P */
/*----------------------------------------------------------------------------
	%%Function: RubyQueryPointPcp
	%%Contact: antons

----------------------------------------------------------------------------*/
LSERR WINAPI VRubyQueryPointPcp(
	PDOBJ pdobj,				/*(IN): dobj to query */
	PCPOINTUV ppointuvQuery,	/*(IN): query point (uQuery,vQuery) */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	PLSSUBL plssubl;
 	long dupAdj;
	long dvpAdj;

	/*
	 * Decide which line to to return based on the height of the point input
	 */

	/* Assume main line */
	plssubl = pdobj->plssublMain;
	dupAdj = 0;
	dvpAdj = 0;

	if (ppointuvQuery->u > pdobj->dupMain)
		{
		/* hit second line */

		plssubl = pdobj->plssublRuby;
		dupAdj = pdobj->dupOffsetRuby;
		dvpAdj = pdobj->dvpOffsetRuby;
		}

	return CreateQueryResult(plssubl, dupAdj, dvpAdj, plsqin, plsqout);
}
	
/* V R U B Y Q U E R Y C P P P O I N T */
/*----------------------------------------------------------------------------
	%%Function: RubyQueryCpPpoint
	%%Contact: antons

----------------------------------------------------------------------------*/
LSERR WINAPI VRubyQueryCpPpoint(
	PDOBJ pdobj,				/*(IN): dobj to query, */
	LSDCP dcp,					/*(IN): dcp for the query */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	PLSSUBL plssubl;
 	long dupAdj;
	long dvpAdj;
	BOOL fMain = fFalse;

	LSCP cpQuery = pdobj->cpStart + dcp;

	/* Assume ruby line */
	plssubl = pdobj->plssublRuby;
	dupAdj = pdobj->dupOffsetRuby;
	dvpAdj = pdobj->dvpOffsetRuby;

	/* + 1 means we include the cp of the object in the Ruby pronunciation line. */
	if (VRubyPronunciationLineFirst == pdobj->pilsobj->vrubysyntax)
		{
		/* Ruby pronunciation line is first */
		if (cpQuery >= pdobj->cpStartMain)
			{
			fMain = fTrue;
			}
		}
	else
		{
		/* Main text line is first */
		if (cpQuery < pdobj->cpStartRuby)
			{
			fMain = fTrue;
			}
		}

	if (fMain)
		{
		plssubl = pdobj->plssublMain;
		dupAdj = 0;
		dvpAdj = 0;
		}

	return CreateQueryResult(plssubl, dupAdj, dvpAdj, plsqin, plsqout);
}

	
/* V R U B I D I S P L A Y */
/*----------------------------------------------------------------------------
	%%Function: VRubyDisplay
	%%Contact: antons

	
----------------------------------------------------------------------------*/
LSERR WINAPI VRubyDisplay(
	PDOBJ pdobj,				/*(IN): dobj to display */
	PCDISPIN pcdispin)			/*(IN): display info */
{
	LSERR lserr;
	UINT kDispMode = pcdispin->kDispMode;
	POINTUV ptAdd;
	POINT ptLine;

	/* display first line */
	lserr = LsDisplaySubline(pdobj->plssublMain, &pcdispin->ptPen, kDispMode,
		pcdispin->prcClip);

	if (lserr != lserrNone)	return lserr;

	ptAdd.u = pdobj->dupOffsetRuby;
	ptAdd.v = pdobj->dvpOffsetRuby;

	LsPointXYFromPointUV(&pcdispin->ptPen, pdobj->lstflowParent, &ptAdd, &ptLine);

	return LsDisplaySubline(pdobj->plssublRuby, &ptLine, kDispMode, pcdispin->prcClip);
}

/* V R U B I D E S T R O Y D O B J */
/*----------------------------------------------------------------------------
	%%Function: VRubyDestroyDobj
	%%Contact: antons


----------------------------------------------------------------------------*/
LSERR WINAPI VRubyDestroyDobj(
	PDOBJ pdobj)				/*(IN): dobj to destroy */
{
	return VRubyFreeDobj (pdobj);
}

/* V R U B Y E N U M */
/*----------------------------------------------------------------------------
	%%Function: VRubyEnum
	%%Contact: antons

	
----------------------------------------------------------------------------*/
LSERR WINAPI VRubyEnum (
	PDOBJ pdobj,				/*(IN): dobj to enumerate */
	PLSRUN plsrun,				/*(IN): from DNODE */
	PCLSCHP plschp,				/*(IN): from DNODE */
	LSCP cp,					/*(IN): from DNODE */
	LSDCP dcp,					/*(IN): from DNODE */
	LSTFLOW lstflow,			/*(IN): text flow*/
	BOOL fReverse,				/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,		/*(IN): */
	const POINT *ppt,			/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,		/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun )				/*(IN): from DNODE, relevant iff fGeometryNeeded */
{
	POINT ptMain;
	POINT ptRuby;
	POINTUV ptAdd;
	long dupMain = 0;
	long dupRuby = 0;
	LSERR lserr;
	LSTFLOW lstflowIgnored;

	if (fGeometryNeeded)
		{
		ptMain = *ppt; 
		ptAdd.u = pdobj->dupOffsetRuby;
		ptAdd.v = pdobj->dvpOffsetRuby;

		LsPointXYFromPointUV(ppt, pdobj->lstflowParent, &ptAdd, &ptRuby);

		lserr = LssbGetDupSubline(pdobj->plssublMain, &lstflowIgnored, &dupMain);
		if (lserr != lserrNone) return lserr;

		lserr = LssbGetDupSubline(pdobj->plssublRuby, &lstflowIgnored, &dupRuby);
		if (lserr != lserrNone) return lserr;
		}

	return pdobj->pilsobj->vrcbk.pfnVRubyEnum (pdobj->pilsobj->pols, plsrun, 
		plschp, cp, dcp, lstflow, fReverse, fGeometryNeeded, ppt, pcheights, 
			dupRun, &ptMain, &pdobj->objdimMain.heightsPres, dupMain, &ptRuby, 
				&pdobj->objdimRuby.heightsPres, dupRuby, pdobj->plssublMain,
					pdobj->plssublRuby);

}
	

/* V R U B I H A N D L E R I N I T */
/*----------------------------------------------------------------------------
	%%Function: VRubyHandlerInit
	%%Contact: antons

	
----------------------------------------------------------------------------*/
LSERR WINAPI LsGetVRubyLsimethods ( LSIMETHODS *plsim )
{
	plsim->pfnCreateILSObj = VRubyCreateILSObj;
	plsim->pfnDestroyILSObj = VRubyDestroyILSObj;
	plsim->pfnSetDoc = VRubySetDoc;
	plsim->pfnCreateLNObj = VRubyCreateLNObj;
	plsim->pfnDestroyLNObj = VRubyDestroyLNObj;
	plsim->pfnFmt = VRubyFmt;
	plsim->pfnFmtResume = ObjHelpFmtResume;
	plsim->pfnGetModWidthPrecedingChar = ObjHelpGetModWidthChar;
	plsim->pfnGetModWidthFollowingChar = ObjHelpGetModWidthChar;
	plsim->pfnTruncateChunk = SobjTruncateChunk;
	plsim->pfnFindPrevBreakChunk = SobjFindPrevBreakChunk;
	plsim->pfnFindNextBreakChunk = SobjFindNextBreakChunk;
	plsim->pfnForceBreakChunk = SobjForceBreakChunk;
	plsim->pfnSetBreak = VRubySetBreak;
	plsim->pfnGetSpecialEffectsInside = VRubyGetSpecialEffectsInside;
	plsim->pfnFExpandWithPrecedingChar = ObjHelpFExpandWithPrecedingChar;
	plsim->pfnFExpandWithFollowingChar = ObjHelpFExpandWithFollowingChar;
	plsim->pfnCalcPresentation = VRubyCalcPresentation;
	plsim->pfnQueryPointPcp = VRubyQueryPointPcp;
	plsim->pfnQueryCpPpoint = VRubyQueryCpPpoint;
	plsim->pfnDisplay = VRubyDisplay;
	plsim->pfnDestroyDObj = VRubyDestroyDobj;
	plsim->pfnEnum = VRubyEnum;

	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\aimm.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Tue Jan 13 08:56:29 1998
 */
/* Compiler settings for aimm.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __aimm_h__
#define __aimm_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEnumRegisterWordA_FWD_DEFINED__
#define __IEnumRegisterWordA_FWD_DEFINED__
typedef interface IEnumRegisterWordA IEnumRegisterWordA;
#endif 	/* __IEnumRegisterWordA_FWD_DEFINED__ */


#ifndef __IEnumRegisterWordW_FWD_DEFINED__
#define __IEnumRegisterWordW_FWD_DEFINED__
typedef interface IEnumRegisterWordW IEnumRegisterWordW;
#endif 	/* __IEnumRegisterWordW_FWD_DEFINED__ */


#ifndef __IAIMMRegistrar_FWD_DEFINED__
#define __IAIMMRegistrar_FWD_DEFINED__
typedef interface IAIMMRegistrar IAIMMRegistrar;
#endif 	/* __IAIMMRegistrar_FWD_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_FWD_DEFINED__
#define __IActiveIMMMessagePumpOwner_FWD_DEFINED__
typedef interface IActiveIMMMessagePumpOwner IActiveIMMMessagePumpOwner;
#endif 	/* __IActiveIMMMessagePumpOwner_FWD_DEFINED__ */


#ifndef __IActiveIMMApp_FWD_DEFINED__
#define __IActiveIMMApp_FWD_DEFINED__
typedef interface IActiveIMMApp IActiveIMMApp;
#endif 	/* __IActiveIMMApp_FWD_DEFINED__ */


#ifndef __IActiveIMMIME_FWD_DEFINED__
#define __IActiveIMMIME_FWD_DEFINED__
typedef interface IActiveIMMIME IActiveIMMIME;
#endif 	/* __IActiveIMMIME_FWD_DEFINED__ */


#ifndef __IActiveIME_FWD_DEFINED__
#define __IActiveIME_FWD_DEFINED__
typedef interface IActiveIME IActiveIME;
#endif 	/* __IActiveIME_FWD_DEFINED__ */


#ifndef __CActiveIMM_FWD_DEFINED__
#define __CActiveIMM_FWD_DEFINED__

#ifdef __cplusplus
typedef class CActiveIMM CActiveIMM;
#else
typedef struct CActiveIMM CActiveIMM;
#endif /* __cplusplus */

#endif 	/* __CActiveIMM_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_aimm_0000
 * at Tue Jan 13 08:56:29 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


//=--------------------------------------------------------------------------=
// aimm.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// IActiveIMM Interfaces.



extern RPC_IF_HANDLE __MIDL_itf_aimm_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_aimm_0000_v0_0_s_ifspec;


#ifndef __ActiveIMM_LIBRARY_DEFINED__
#define __ActiveIMM_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ActiveIMM
 * at Tue Jan 13 08:56:29 1998
 * using MIDL 3.01.75
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 


#ifndef _IMM_
#error Must include imm.h!
#endif
#if 0
typedef WORD LANGID;

typedef /* [public][public][public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0001
    {
    LPSTR lpReading;
    LPSTR lpWord;
    }	REGISTERWORDA;

typedef /* [public][public][public][public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0002
    {
    LPWSTR lpReading;
    LPWSTR lpWord;
    }	REGISTERWORDW;

typedef /* [public][public][public][public][public][public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0003
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    }	LOGFONTA;

typedef /* [public][public][public][public][public][public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0004
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    }	LOGFONTW;

typedef DWORD HIMC;

typedef DWORD HIMCC;

typedef /* [public][public][public][public][public][public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0005
    {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    }	CANDIDATEFORM;

typedef /* [public][public][public][public][public][public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0006
    {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    }	COMPOSITIONFORM;

typedef /* [public][public][public][public][public][public][public][public][public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0007
    {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[ 1 ];
    }	CANDIDATELIST;

typedef /* [public][public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0008
    {
    DWORD dwStyle;
    CHAR szDescription[ 32 ];
    }	STYLEBUFA;

typedef /* [public][public][public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0009
    {
    DWORD dwStyle;
    WCHAR szDescription[ 32 ];
    }	STYLEBUFW;

typedef WORD ATOM;

#endif
#ifndef _DDKIMM_H_
typedef /* [public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0010
    {
    HWND hWnd;
    BOOL fOpen;
    POINT ptStatusWndPos;
    POINT ptSoftKbdPos;
    DWORD fdwConversion;
    DWORD fdwSentence;
    union 
        {
        LOGFONTA A;
        LOGFONTW W;
        }	lfFont;
    COMPOSITIONFORM cfCompForm;
    CANDIDATEFORM cfCandForm[ 4 ];
    HIMCC hCompStr;
    HIMCC hCandInfo;
    HIMCC hGuideLine;
    HIMCC hPrivate;
    DWORD dwNumMsgBuf;
    HIMCC hMsgBuf;
    DWORD fdwInit;
    DWORD dwReserve[ 3 ];
    }	INPUTCONTEXT;

typedef /* [public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0012
    {
    DWORD dwPrivateDataSize;
    DWORD fdwProperty;
    DWORD fdwConversionCaps;
    DWORD fdwSentenceCaps;
    DWORD fdwUICaps;
    DWORD fdwSCSCaps;
    DWORD fdwSelectCaps;
    }	IMEINFO;

#endif

EXTERN_C const IID LIBID_ActiveIMM;

#ifndef __IEnumRegisterWordA_INTERFACE_DEFINED__
#define __IEnumRegisterWordA_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRegisterWordA
 * at Tue Jan 13 08:56:29 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IEnumRegisterWordA;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("08C03412-F96B-11d0-A475-00AA006BCC59")
    IEnumRegisterWordA : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDA __RPC_FAR *rgRegisterWord,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordAVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRegisterWordA __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRegisterWordA __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRegisterWordA __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRegisterWordA __RPC_FAR * This,
            /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRegisterWordA __RPC_FAR * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDA __RPC_FAR *rgRegisterWord,
            /* [out] */ ULONG __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRegisterWordA __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRegisterWordA __RPC_FAR * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordAVtbl;

    interface IEnumRegisterWordA
    {
        CONST_VTBL struct IEnumRegisterWordAVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordA_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRegisterWordA_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRegisterWordA_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRegisterWordA_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRegisterWordA_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched)

#define IEnumRegisterWordA_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRegisterWordA_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Clone_Proxy( 
    IEnumRegisterWordA __RPC_FAR * This,
    /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRegisterWordA_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Next_Proxy( 
    IEnumRegisterWordA __RPC_FAR * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ REGISTERWORDA __RPC_FAR *rgRegisterWord,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IEnumRegisterWordA_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Reset_Proxy( 
    IEnumRegisterWordA __RPC_FAR * This);


void __RPC_STUB IEnumRegisterWordA_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Skip_Proxy( 
    IEnumRegisterWordA __RPC_FAR * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumRegisterWordA_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRegisterWordA_INTERFACE_DEFINED__ */


#ifndef __IEnumRegisterWordW_INTERFACE_DEFINED__
#define __IEnumRegisterWordW_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRegisterWordW
 * at Tue Jan 13 08:56:29 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IEnumRegisterWordW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("4955DD31-B159-11d0-8FCF-00AA006BCC59")
    IEnumRegisterWordW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDW __RPC_FAR *rgRegisterWord,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRegisterWordW __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRegisterWordW __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRegisterWordW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRegisterWordW __RPC_FAR * This,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRegisterWordW __RPC_FAR * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDW __RPC_FAR *rgRegisterWord,
            /* [out] */ ULONG __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRegisterWordW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRegisterWordW __RPC_FAR * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordWVtbl;

    interface IEnumRegisterWordW
    {
        CONST_VTBL struct IEnumRegisterWordWVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRegisterWordW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRegisterWordW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRegisterWordW_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRegisterWordW_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched)

#define IEnumRegisterWordW_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRegisterWordW_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Clone_Proxy( 
    IEnumRegisterWordW __RPC_FAR * This,
    /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRegisterWordW_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Next_Proxy( 
    IEnumRegisterWordW __RPC_FAR * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ REGISTERWORDW __RPC_FAR *rgRegisterWord,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IEnumRegisterWordW_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Reset_Proxy( 
    IEnumRegisterWordW __RPC_FAR * This);


void __RPC_STUB IEnumRegisterWordW_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Skip_Proxy( 
    IEnumRegisterWordW __RPC_FAR * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumRegisterWordW_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRegisterWordW_INTERFACE_DEFINED__ */


#ifndef __IAIMMRegistrar_INTERFACE_DEFINED__
#define __IAIMMRegistrar_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAIMMRegistrar
 * at Tue Jan 13 08:56:29 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IAIMMRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("c7afa428-5007-11d1-aa94-0060b067b86e")
    IAIMMRegistrar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterIME( 
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterIME( 
            /* [in] */ REFCLSID rclsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAIMMRegistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAIMMRegistrar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAIMMRegistrar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAIMMRegistrar __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterIME )( 
            IAIMMRegistrar __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterIME )( 
            IAIMMRegistrar __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid);
        
        END_INTERFACE
    } IAIMMRegistrarVtbl;

    interface IAIMMRegistrar
    {
        CONST_VTBL struct IAIMMRegistrarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAIMMRegistrar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAIMMRegistrar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAIMMRegistrar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAIMMRegistrar_RegisterIME(This,rclsid)	\
    (This)->lpVtbl -> RegisterIME(This,rclsid)

#define IAIMMRegistrar_UnregisterIME(This,rclsid)	\
    (This)->lpVtbl -> UnregisterIME(This,rclsid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAIMMRegistrar_RegisterIME_Proxy( 
    IAIMMRegistrar __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB IAIMMRegistrar_RegisterIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAIMMRegistrar_UnregisterIME_Proxy( 
    IAIMMRegistrar __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB IAIMMRegistrar_UnregisterIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAIMMRegistrar_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__
#define __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IActiveIMMMessagePumpOwner
 * at Tue Jan 13 08:56:29 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IActiveIMMMessagePumpOwner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("b5cf2cfa-8aeb-11d1-9364-0060b067b86e")
    IActiveIMMMessagePumpOwner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTranslateMessage( 
            /* [in] */ MSG __RPC_FAR *pMsg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMMessagePumpOwnerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnTranslateMessage )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This,
            /* [in] */ MSG __RPC_FAR *pMsg);
        
        END_INTERFACE
    } IActiveIMMMessagePumpOwnerVtbl;

    interface IActiveIMMMessagePumpOwner
    {
        CONST_VTBL struct IActiveIMMMessagePumpOwnerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMMessagePumpOwner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMMessagePumpOwner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMMessagePumpOwner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMMessagePumpOwner_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IActiveIMMMessagePumpOwner_End(This)	\
    (This)->lpVtbl -> End(This)

#define IActiveIMMMessagePumpOwner_OnTranslateMessage(This,pMsg)	\
    (This)->lpVtbl -> OnTranslateMessage(This,pMsg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Start_Proxy( 
    IActiveIMMMessagePumpOwner __RPC_FAR * This);


void __RPC_STUB IActiveIMMMessagePumpOwner_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_End_Proxy( 
    IActiveIMMMessagePumpOwner __RPC_FAR * This);


void __RPC_STUB IActiveIMMMessagePumpOwner_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_OnTranslateMessage_Proxy( 
    IActiveIMMMessagePumpOwner __RPC_FAR * This,
    /* [in] */ MSG __RPC_FAR *pMsg);


void __RPC_STUB IActiveIMMMessagePumpOwner_OnTranslateMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMApp_INTERFACE_DEFINED__
#define __IActiveIMMApp_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IActiveIMMApp
 * at Tue Jan 13 08:56:29 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IActiveIMMApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("08c0e040-62d1-11d1-9326-0060b067b86e")
    IActiveIMMApp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AssociateContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC __RPC_FAR *phPrev) = 0;
        
        virtual HRESULT STDM